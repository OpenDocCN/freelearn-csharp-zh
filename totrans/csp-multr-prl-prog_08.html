<html><head></head><body><div class="chapter" title="Chapter&#xA0;8.&#xA0;Debugging Multithreaded Applications with Visual Studio"><div class="titlepage"><div><div><h1 class="title"><a id="ch08"/>Chapter 8. Debugging Multithreaded Applications with Visual Studio</h1></div></div></div><p>Multithreaded applications<a id="id423" class="indexterm"/> present their own set of challenges to develop as we have seen so far in this book, but they also have a unique set of challenges to debug. Visual Studio, starting with Visual Studio 2010, has developed additions to the debugger to assist with debugging tasks and the <code class="literal">Parallel</code> library.</p><p>Visual Studio has had the <span class="strong"><strong>Threads</strong></span> window<a id="id424" class="indexterm"/> in their debugger since 2003 to assist with debugging threads. However, starting with Visual Studio 2010, they have added the <a id="id425" class="indexterm"/>
<span class="strong"><strong>Parallel Stacks</strong></span> <a id="id426" class="indexterm"/>window, <span class="strong"><strong>Parallel Watch</strong></span> window, and the <span class="strong"><strong>Tasks</strong></span> window<a id="id427" class="indexterm"/> to aid in debugging applications<a id="id428" class="indexterm"/> using the<span class="strong"><strong> Task Parallel Library</strong></span> (<span class="strong"><strong>TPL</strong></span>). In this chapter, we will examine all of these windows and demonstrate how to step through a multithreaded and multitask application to find program flow issues and race/lock conditions.</p><p>A <span class="strong"><strong>race condition</strong></span><a id="id429" class="indexterm"/> is a type of error that occurs when multiple threads interfere with each other and is based on the timing and execution of the different threads. Because of this, the condition does not happen every time the application executes. It takes a certain timing of the execution of the different threads.</p><p>A race condition happens when two or more threads access a data variable and try to modify it at approximately the same time. Since the OS scheduler can switch between threads at any time, you cannot predict the order in which the threads will access the data. The result of the change in data is dependent on the OS scheduling algorithm. Both the threads are "racing" to access the data.</p><p>Problems can happen when one thread examines the contents of a variable and performs an action but another thread changes the contents of the same variable during the time the first thread examines it and then acts on it.</p><p>A <span class="strong"><strong>lock condition</strong></span><a id="id430" class="indexterm"/> occurs when two or more threads are waiting on a resource that is locked by another thread. So, if thread 1 is waiting on a resource locked by thread 2 and thread 2 is waiting on a resource locked by thread 1, then both threads will remain "hung" forever waiting on each other to free up a resource. This is a type of a lock condition called a <a id="id431" class="indexterm"/>
<span class="strong"><strong>deadlock</strong></span>.</p><p>In this chapter, you will learn the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Using the <span class="strong"><strong>Threads</strong></span> window in the debugger</li><li class="listitem" style="list-style-type: disc">Using the <span class="strong"><strong>Tasks</strong></span> window in the debugger</li><li class="listitem" style="list-style-type: disc">Accessing the <span class="strong"><strong>Parallel Stacks</strong></span> and <span class="strong"><strong>Parallel Watch</strong></span> windows</li><li class="listitem" style="list-style-type: disc">Stepping through an application with more than one thread and more than one task</li><li class="listitem" style="list-style-type: disc">Detecting a deadlock condition</li></ul></div><div class="section" title="Considerations for debugging multithreaded applications"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec59"/>Considerations for debugging multithreaded applications</h1></div></div></div><p>There are several things to <a id="id432" class="indexterm"/>consider when debugging a parallel application. The first thing is probably the most obvious—there are multiple things happening at once. If you have an application with five threads, then all five threads can be executing at the same time depending on how many cores your machine has. If you step through a particular thread, the other threads are not just waiting on you unless there are breakpoints or they are waiting on a resource locked by the thread you are stepping through. You need to understand how your parallel application is designed and how it executes so you know what is happening in parallel—especially what is happening in threads other than the one you may by stepping through.</p><p>Secondly, debugging a concurrent application takes a lot of information. When using the debugger on a TPL application, you can have the <span class="strong"><strong>Local</strong></span>, <span class="strong"><strong>Immediate</strong></span>, <span class="strong"><strong>Threads</strong></span>, <span class="strong"><strong>Task</strong></span>, <span class="strong"><strong>Parallel Stack</strong></span>, <span class="strong"><strong>Parallel Task</strong></span>, <span class="strong"><strong>Process Explorer</strong></span>, <span class="strong"><strong>Source Code</strong></span>, and <span class="strong"><strong>Object Explorer</strong></span> windows all open at the same time. This either takes a lot of screen real estate or requires constantly moving windows around to see the information that you need. I highly recommend doing this on a dual monitor setup. You can never have too much screen room when debugging a parallel application. There are few things more frustrating than not being able to easily see all the information you need as you step through an application.</p></div></div>
<div class="section" title="Using the Threads window"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec60"/>Using the Threads window</h1></div></div></div><p>The <span class="strong"><strong>Threads</strong></span> window in the <a id="id433" class="indexterm"/>Visual Studio debugger allows you to view details of all of the threads in an application and work with them. You can view the stack of each thread. You can freeze or thaw a thread, and view all of the details concerning a thread.</p><p>If you start the debugger in an application and then go to <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Windows</strong></span>, you can select the <span class="strong"><strong>Threads</strong></span> window. If you do this, you should see something like the following; this is the <span class="strong"><strong>Threads</strong></span> window for the thread's version of the <code class="literal">OldStarFinder</code> program we did in <a class="link" href="ch07.html" title="Chapter 7. Data Parallelism">Chapter 7</a>, <span class="emphasis"><em>Data Parallelism</em></span>:</p><div class="mediaobject"><img src="graphics/8321EN_08_01.jpg" alt="Using the Threads window"/></div><p>Let's take a look at this<a id="id434" class="indexterm"/> window and examine it in detail. It contains the following columns:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Flag</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Active</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ID</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Managed ID</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Category</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Name</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Location</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Priority</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Affinity Mask</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Suspended Count</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Process Name</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Process ID</strong></span></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Transport Qualifier</strong></span></li></ul></div><p>The <span class="strong"><strong>Flag</strong></span> column<a id="id435" class="indexterm"/> allows <a id="id436" class="indexterm"/>you to designate a thread as one that you want to watch. If you right-click on a thread in this window, you can mark or unmark it as a flagged thread.</p><p>The <span class="strong"><strong>Active</strong></span> column<a id="id437" class="indexterm"/> indicates which thread is the currently active thread. A <a id="id438" class="indexterm"/>yellow arrow designates the active thread in the debugger. It is also important to note that when stepping through a thread, other threads continue their operation unless a breakpoint is set. All of the threads do not block while you are stepping through a particular thread.</p><p>The <span class="strong"><strong>ID</strong></span> column<a id="id439" class="indexterm"/> shows a thread's ID number in Windows, which is different<a id="id440" class="indexterm"/> from the .NET Managed ID.</p><p>The <span class="strong"><strong>Managed ID</strong></span> column<a id="id441" class="indexterm"/> shows the managed ID number of a <a id="id442" class="indexterm"/>thread. A <span class="strong"><strong>managed thread</strong></span><a id="id443" class="indexterm"/> is different from a Windows thread. A managed thread, in this context, is a thread managed in .NET by the CLR and the threadpool. A managed thread can execute in one or more Windows threads. A .NET managed thread is created using the .NET <code class="literal">Threads</code> class. Also, remember when using <code class="literal">Tasks</code> that a task is not a thread.</p><p>The <span class="strong"><strong>Category</strong></span> column<a id="id444" class="indexterm"/> displays the thread's classification as either the <a id="id445" class="indexterm"/>main thread, a user interface thread, a remote procedure handler thread, or a worker thread.</p><p>The <span class="strong"><strong>Name</strong></span> column<a id="id446" class="indexterm"/> displays the thread's <span class="strong"><strong>Name</strong></span> property if it is set, or<a id="id447" class="indexterm"/> otherwise displays <span class="strong"><strong>&lt;No Name&gt;</strong></span>.</p><p>The <span class="strong"><strong>Location</strong></span> column<a id="id448" class="indexterm"/> shows what method the thread is currently executing. By <a id="id449" class="indexterm"/>double-clicking on a row in this column, you can see the thread's full stack.</p><p>The <span class="strong"><strong>Priority</strong></span> column<a id="id450" class="indexterm"/> shows the Windows priority for the<a id="id451" class="indexterm"/> thread.</p><p>The <span class="strong"><strong>Affinity Mask</strong></span> column<a id="id452" class="indexterm"/> shows this mask for each thread. The affinity <a id="id453" class="indexterm"/>is a bitwise mask indicating which processors a thread is eligible to execute on. In our example, we have a four-processor system and all but one of the threads has a mask that ends with <code class="literal">1111</code>. These are the four bits representing our four processors. This indicates that these threads can execute on any of the processors. There are methods in the <code class="literal">Threads</code> class that allow you to programmatically set which processors a thread can run on if you wish.</p><p>The <span class="strong"><strong>Suspended Count</strong></span> column<a id="id454" class="indexterm"/> is a count manipulated by freezing and<a id="id455" class="indexterm"/> thawing threads. If you freeze a thread in managed code, then the thread will not run even if it is able to, and the suspended count will be <code class="literal">1</code>.</p><p>The <span class="strong"><strong>Process Name</strong></span> column<a id="id456" class="indexterm"/> displays the Windows process that the thread is <a id="id457" class="indexterm"/>associated with. Since we are running our application through the Visual Studio debugger, you will see that our threads have <span class="strong"><strong>OldStarsFinder.vshost.exe</strong></span> as the process. You can also run the Task Manager in Windows and see this process.</p><p>Now that we have gone through all of the information the <span class="strong"><strong>Threads</strong></span> window supplies, what are some of the functions you can do with it? You can show or hide columns in the display by clicking on the <span class="strong"><strong>Columns</strong></span> dropdown in the header of this window; you can also do a Group By operation of the threads to group them for better management. We already saw how you can double-click on a row in the <span class="strong"><strong>Location</strong></span> column and see a thread's call stack. You can also make any thread the <span class="strong"><strong>Active</strong></span> thread by right-clicking on it and selecting <span class="strong"><strong>Switch To Thread</strong></span>.</p><p>Next, let's examine the <span class="strong"><strong>Tasks</strong></span> window.</p></div>
<div class="section" title="Using the Tasks window"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec61"/>Using the Tasks window</h1></div></div></div><p>The <span class="strong"><strong>Tasks</strong></span> window <a id="id458" class="indexterm"/>was added to the Visual Studio debugger in the 2010 version when the TPL was added to .NET in Version 4.0. It is similar to the <span class="strong"><strong>Threads</strong></span> window and shows information about each task in your application. Tasks are created using the <code class="literal">System.Threading.Tasks.Task</code> class or by using the <code class="literal">async</code> and <code class="literal">await</code> keywords. The <code class="literal">async</code> and <code class="literal">await</code> keywords were introduced in Version 4.5 of .NET and will be covered in <a class="link" href="ch11.html" title="Chapter 11. The Asynchronous Programming Model">Chapter 11</a>, <span class="emphasis"><em>The Asynchronous Programming Model</em></span>. Like the <span class="strong"><strong>Threads</strong></span> window, it can be accessed from the debugger in Visual Studio by navigating to <span class="strong"><strong>Debug</strong></span> | <span class="strong"><strong>Windows</strong></span>:</p><div class="mediaobject"><img src="graphics/8321EN_08_02.jpg" alt="Using the Tasks window"/></div><p>Let's examine the information and functions you can use the <span class="strong"><strong>Tasks</strong></span> window for:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Flags</strong></span>: This<a id="id459" class="indexterm"/> column shows the tasks that you have flagged or unflagged. By clicking on this column for a task, you can flag the threads in this <a id="id460" class="indexterm"/>task. You can flag several tasks and then sort or use the Group By function to show the flagged tasks at the top. You can also filter the <span class="strong"><strong>Parallel Stacks</strong></span> window by flagged tasks so you only see the parallel stacks of the tasks you are interested in.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Icons</strong></span>: This <a id="id461" class="indexterm"/>column shows which is the current task present on the<a id="id462" class="indexterm"/> current thread. This is shown by a yellow arrow. A white arrow indicates that the current task is at a breakpoint in the debugger. A pause symbol indicates that a task has been frozen.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>ID</strong></span>: This <a id="id463" class="indexterm"/>column is a Windows-generated identification number for a <a id="id464" class="indexterm"/>task. In our example, I have entered <code class="literal">8</code> into the <span class="strong"><strong>Number of bitmaps to divide into for processing</strong></span> textbox and then set a breakpoint after the <code class="literal">Parallel.ForEach</code> loop. You can see that we have created eight tasks that are all running an anonymous method, and that it is initiated from the <span class="strong"><strong>Find Old Stars</strong></span> button's click event handler. Their IDs are numbers 1 through 8.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Status</strong></span>: This column shows <a id="id465" class="indexterm"/>the task's state, which can be any of the following:<div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Active</strong></span>: The task is <a id="id466" class="indexterm"/>currently active on the stack</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Deadlocked</strong></span>: The <a id="id467" class="indexterm"/>task is currently deadlocked waiting on a resource</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Waiting</strong></span>: The <a id="id468" class="indexterm"/>task is currently waiting on CPU allocation</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Scheduled</strong></span>: The <a id="id469" class="indexterm"/>task is scheduled to start executing when a thread in the threadpool is available</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Completed</strong></span>: The task <a id="id470" class="indexterm"/>has completed its execution</li></ul></div><p>A task is considered in a deadlock state if its thread is in a lock condition with another thread in the application. A task is considered waiting if it is waiting on a lock to be freed or another task to complete.</p></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Location</strong></span>: This<a id="id471" class="indexterm"/> column displays the call stack for that particular<a id="id472" class="indexterm"/> task. Unlike the <span class="strong"><strong>Threads</strong></span> window, to see the whole call stack, you need to hover over this column instead of double-clicking on it. Also, if a task has not started but is scheduled, then this column will not be populated yet.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Parent</strong></span>: This column <a id="id473" class="indexterm"/>displays the ID of the task that<a id="id474" class="indexterm"/> created it.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>Thread Assignment</strong></span>: This column <a id="id475" class="indexterm"/>displays the thread<a id="id476" class="indexterm"/> ID and thread name of the thread the task is executing on. In our example, you can see we used a number to name the thread of our tasks in this line of code:<div class="informalexample"><pre class="programlisting">Parallel.ForEach(BitmapList, item =&gt; ThreadOldStarsFinder(item,ran.Next(1000).ToString()));</pre></div><p>We pass in a random number between 1 and 1,000 as the second parameter of the <code class="literal">ThreadOldStarsFinder</code> method and then use the following line to set the thread name for the corresponding task:</p><div class="informalexample"><pre class="programlisting">Thread.CurrentThread.Name = ThreadName;</pre></div></li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>APPDomain</strong></span>: This <a id="id477" class="indexterm"/>column shows the application domain the<a id="id478" class="indexterm"/> task is running inside. The <span class="strong"><strong>Process</strong></span> column displays the Windows ID of the Windows process the task is executing inside.</li><li class="listitem" style="list-style-type: disc"><span class="strong"><strong>AsyncState</strong></span>: This column, if <a id="id479" class="indexterm"/>using the <code class="literal">async</code> or <code class="literal">await</code> keywords to <a id="id480" class="indexterm"/>run a task from a method call, shows the async state of the task.</li></ul></div><p>When debugging TPL applications, this window is very helpful in getting an overview of all of the tasks your code has generated, which are active, and the call stack and thread information of each of them. Combining this with the <span class="strong"><strong>Threads</strong></span> window will give you a good look at all of the entities running in your application and where they are in their execution.</p><p>The <span class="strong"><strong>Tasks</strong></span> window is really only useful in debugging multithreaded applications if you are using the TPL. If you are using threads or the <code class="literal">BackgroundWorker</code> component, this window will not be helpful.</p></div>
<div class="section" title="Using the Parallel Stacks window"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec62"/>Using the Parallel Stacks window</h1></div></div></div><p>The <span class="strong"><strong>Parallel Stacks</strong></span> window is<a id="id481" class="indexterm"/> very helpful in debugging parallel applications because it shows you task and thread information in a graphical view almost like a flowchart. It shows a lot of the same information as the <span class="strong"><strong>Threads</strong></span> and <span class="strong"><strong>Tasks</strong></span> windows but in a different format and it shows relationships between the threads and tasks, which is very helpful.</p><p>The <span class="strong"><strong>Threads</strong></span> and <span class="strong"><strong>Tasks</strong></span> windows are a good tabular way to view all of the entities of your multithreaded application but they do not do a real good job of showing relationship and program flow information.</p><p>The <span class="strong"><strong>Parallel Stacks</strong></span> information has a <span class="strong"><strong>Threads</strong></span> view and a <span class="strong"><strong>Tasks</strong></span> view. Each of these views can also be toggled to a <span class="strong"><strong>Method</strong></span> view.</p><p>The following is the <span class="strong"><strong>Threads</strong></span> view of our <code class="literal">OldStarsFinder</code> application after the <code class="literal">Parallel.ForEach</code> command executes and the bitmap is divided into eight sections:</p><div class="mediaobject"><img src="graphics/8321EN_08_03.jpg" alt="Using the Parallel Stacks window"/></div><p>The following is the <span class="strong"><strong>Tasks</strong></span> <a id="id482" class="indexterm"/>view of our <code class="literal">OldStarsFinder</code> application after the <code class="literal">Parallel.ForEach</code> command executes and the bitmap is divided into eight sections:</p><div class="mediaobject"><img src="graphics/8321EN_08_04.jpg" alt="Using the Parallel Stacks window"/></div><p>The following is the <span class="strong"><strong>Threads</strong></span> view <a id="id483" class="indexterm"/>toggled to the <span class="strong"><strong>Method</strong></span> view of our <code class="literal">OldStarsFinder</code> application after the <code class="literal">Parallel.ForEach</code> command executes and the bitmap is divided into eight sections:</p><div class="mediaobject"><img src="graphics/8321EN_08_05.jpg" alt="Using the Parallel Stacks window"/></div><p>The following screenshot <a id="id484" class="indexterm"/>shows the <span class="strong"><strong>Tasks</strong></span> view toggled to <span class="strong"><strong>Method</strong></span> view of our <code class="literal">OldStarsFinder</code> application after the <code class="literal">Parallel.ForEach</code> command executes and the bitmap is divided into eight sections:</p><div class="mediaobject"><img src="graphics/8321EN_08_06.jpg" alt="Using the Parallel Stacks window"/></div><p>There are several items to<a id="id485" class="indexterm"/> note about this window. First is the toolbar. It allows you to select either <span class="strong"><strong>Threads</strong></span> or <span class="strong"><strong>Tasks</strong></span> from the drop-down menu. It also allows you to show only flagged threads in the window. Next, it allows you to toggle to the <span class="strong"><strong>Method</strong></span> view, and also to zoom in on an area.</p><p>In the <span class="strong"><strong>Threads</strong></span> and <span class="strong"><strong>Tasks</strong></span> views, the call path of the current thread is highlighted in blue. That is why you can see more than one box highlighted. The arrows connected to the boxes show the call path of the task or thread, and each box in the diagram represents a call stack. Also, if you hover over a box's (also known as a node) header or a row in a node, you get a tooltip. The tooltip of the node header shows the thread ID and name of all the threads in the call path leading to this node. In the row or method tooltip, you'll see the stack of the method.</p><p>The yellow arrow in a node indicates the active frame of the currently active thread. Also, the method name in all the nodes of the active thread's current stack frame are styled in bold. If you right-click on a method row in a stack frame, you will get a menu that allows you to go to that task or thread, or to the source code.</p><p>The <span class="strong"><strong>Method</strong></span> view we showed earlier shows all methods that either call or are called by the current method. The current method is shown in the middle with the methods that call it below and the methods it calls above. This is a nice way to get a current runtime view of the Visual Studio<a id="id486" class="indexterm"/> function, <span class="strong"><strong>Find All References</strong></span>. It is not exactly the same but is similar.</p><p>The <span class="strong"><strong>Parallel Stacks</strong></span> <a id="id487" class="indexterm"/>window is probably where you will spend most of your time in the debug mode except for actually stepping through the code. Typically, you will have the <span class="strong"><strong>Threads</strong></span> and <span class="strong"><strong>Tasks</strong></span> windows up for a tabular reference, the code up to set breakpoints and step through lines, and the <span class="strong"><strong>Parallel Stacks</strong></span> window to follow all of the threads, tasks, and their relations.</p></div>
<div class="section" title="Using the Parallel Watch window"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec63"/>Using the Parallel Watch window</h1></div></div></div><p>The <span class="strong"><strong>Parallel Watch</strong></span> window <a id="id488" class="indexterm"/>allows you to display the values of an expression that is held on multiple threads. You can see it running a parallel application and select <span class="strong"><strong>Parallel Watch</strong></span> by navigating to <span class="strong"><strong>Window</strong></span> | <span class="strong"><strong>Debug</strong></span>. As you see in the following screenshot, the <span class="strong"><strong>Parallel Watch</strong></span> window is empty until you add a watch statement. Each row shows a thread that has a method call that matches the method on the current stack frame.</p><p>If you click on the <span class="strong"><strong>&lt;Add Watch&gt;</strong></span> bar, you can type in an expression to watch. This allows you to see the value of the same expression in multiple threads. You can show up to four <span class="strong"><strong>Parallel Watch</strong></span> windows just like the regular <span class="strong"><strong>Watch</strong></span> window if you would like to watch more than one expression. You can also filter the watch list by using the <span class="strong"><strong>Filter by Boolean Expression</strong></span> box in the top-right corner of the window. If you type in an expression there, it will only show the threads in which that expression is true:</p><div class="mediaobject"><img src="graphics/8321EN_08_07.jpg" alt="Using the Parallel Watch window"/></div><p>The <span class="strong"><strong>Parallel Watch</strong></span> window is really just the <span class="strong"><strong>Watch</strong></span> window but it allows you to watch the same expression on all the threads in your application. Any C# expression is valid in this window.</p><p>In the following <a id="id489" class="indexterm"/>example, we took the previously used example and added a watch on a variable. We are watching the <code class="literal">Thread.Name</code> value of the thread each task is assigned. Here is the same window after we have completed the <code class="literal">Parallel.ForEach</code> command. You can see only one of the tasks has executed but the others are scheduled. The one that has started has executed the first line of its delegate, which is to set the thread name:</p><div class="mediaobject"><img src="graphics/8321EN_08_08.jpg" alt="Using the Parallel Watch window"/></div><p>This window is a very good way in a <code class="literal">Parallel.For</code> or <code class="literal">Parallel.ForEach</code> loop that is executing the same delegate multiple times in multiple tasks to view the value of an expression in the delegate. It allows you to see the current value each task has at that moment of execution.</p></div>
<div class="section" title="Debugging an entire application"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec64"/>Debugging an entire application</h1></div></div></div><p>Now that we have examined all of<a id="id490" class="indexterm"/> the windows that the Visual Studio debugger provides for debugging multithreaded applications let's go through a real example. We will use the <code class="literal">OldStarsFinder</code> application that uses tasks and the TPL that we finished in <a class="link" href="ch07.html" title="Chapter 7. Data Parallelism">Chapter 7</a>, <span class="emphasis"><em>Data Parallelism</em></span>. Remember that this application takes a user-entered number and then divides a large bitmap file by that number into an equal number of smaller bitmap files. Then, using a parallel <code class="literal">ForEach</code> loop, it processes each bitmap to try and find old stars in the image. It keeps a track of how many old stars are found. When it finishes, it reassembles the pieces and displays the large bitmap with each old star colored blue. It also displays the final number of old stars it found. Let's get started.</p><div class="section" title="How to do it"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec79"/>How to do it</h2></div></div></div><p>First, let's open our <code class="literal">OldStarsFinder</code> application in Visual Studio and set some breakpoints to help us get started. Then perform the following steps:</p><div class="orderedlist"><ol class="orderedlist arabic"><li class="listitem">Put a breakpoint on the line of code that contains the <code class="literal">Parallel.ForEach</code> command as shown here:<div class="mediaobject"><img src="graphics/8321EN_08_09.jpg" alt="How to do it"/></div></li><li class="listitem">Now let's place a second<a id="id491" class="indexterm"/> break in the <code class="literal">ThreadOldStarsFinder</code> method that each of the parallel tasks are executing. We will place it early in the method where we set the thread name using the random number that we pass in from the <code class="literal">Parallel.ForEach</code> command:<div class="mediaobject"><img src="graphics/8321EN_08_10.jpg" alt="How to do it"/></div></li><li class="listitem">Now, let's start the <a id="id492" class="indexterm"/>application in the debugger and enter <code class="literal">6</code> in the textbox for how many bitmaps to divide the large image into:<div class="mediaobject"><img src="graphics/8321EN_08_11.jpg" alt="How to do it"/></div></li><li class="listitem">Next, let's click on the <a id="id493" class="indexterm"/><span class="strong"><strong>Old Star Finder</strong></span> button. We will see that the code enters the button's click event handler and comes to the first breakpoint that we set at the <code class="literal">Parallel.ForEach</code> command. The following screenshot shows how the debugger looks along with the <span class="strong"><strong>Thread</strong></span>, <span class="strong"><strong>Tasks</strong></span>, <span class="strong"><strong>Parallel Stacks</strong></span>, and <span class="strong"><strong>Parallel Watch</strong></span> windows:<div class="mediaobject"><img src="graphics/8321EN_08_12.jpg" alt="How to do it"/></div><p>Right before we <a id="id494" class="indexterm"/>step over the <code class="literal">Parallel.ForEach</code> command, you can see that there are no tasks yet:</p><div class="mediaobject"><img src="graphics/8321EN_08_13.jpg" alt="How to do it"/></div><p>You will also see that<a id="id495" class="indexterm"/> there are no extra threads for these tasks because we have not executed the parallel data loop yet:</p><div class="mediaobject"><img src="graphics/8321EN_08_14.jpg" alt="How to do it"/></div><div class="mediaobject"><img src="graphics/8321EN_08_15.jpg" alt="How to do it"/></div><p>And looking at the <a id="id496" class="indexterm"/>
<span class="strong"><strong>Parallel Stacks</strong></span> window you only see the main thread of the application:</p><div class="mediaobject"><img src="graphics/8321EN_08_16.jpg" alt="How to do it"/></div></li><li class="listitem">Now, let's step <a id="id497" class="indexterm"/>over the <code class="literal">Parallel.ForEach</code> command and look at these same windows while we are at a breakpoint in the delegate:<div class="mediaobject"><img src="graphics/8321EN_08_17.jpg" alt="How to do it"/></div></li><li class="listitem">Now, if you hover over the<a id="id498" class="indexterm"/> line in the <span class="strong"><strong>Parallel Stacks</strong></span> window with the yellow arrow, you will see the line of code each thread is executing. This is using the <span class="strong"><strong>Threads</strong></span> view of the <span class="strong"><strong>Parallel Stacks</strong></span> window:<div class="mediaobject"><img src="graphics/8321EN_08_18.jpg" alt="How to do it"/></div></li><li class="listitem">Now, let's examine the <a id="id499" class="indexterm"/>same thing using the <span class="strong"><strong>Tasks</strong></span> view of the <span class="strong"><strong>Parallel Stacks</strong></span> window:<div class="mediaobject"><img src="graphics/8321EN_08_19.jpg" alt="How to do it"/></div></li><li class="listitem">Also, at the same time, let's <a id="id500" class="indexterm"/>examine our <span class="strong"><strong>Parallel Watch</strong></span> window:<div class="mediaobject"><img src="graphics/8321EN_08_20.jpg" alt="How to do it"/></div></li><li class="listitem">Next, let's step over the <a id="id501" class="indexterm"/>current line in the <code class="literal">ThreadOldStarsFinder</code> delegate method and take another look at our windows:<div class="mediaobject"><img src="graphics/8321EN_08_21.jpg" alt="How to do it"/></div></li><li class="listitem">Then start stepping through the<a id="id502" class="indexterm"/> delegate and notice what happens. Here is a view from our example:<div class="mediaobject"><img src="graphics/8321EN_08_22.jpg" alt="How to do it"/></div></li><li class="listitem">Notice how the<a id="id503" class="indexterm"/> information changes in the windows as you start to step through the delegate of one task on one thread. You will notice all of the tasks are, or can be, on different lines after you step over one line in this one thread. Also, the <span class="strong"><strong>Parallel Watch</strong></span> window will show different values of the expression as you step through.</li><li class="listitem">Now, let the program run until it has completed the parallel loop and it is ready to reassemble the pieces.<div class="mediaobject"><img src="graphics/8321EN_08_23.jpg" alt="How to do it"/></div></li><li class="listitem">As you can see, we still<a id="id504" class="indexterm"/> have multiple threads running in our application but no tasks. This indicates that all of the tasks we created in the <code class="literal">Parallel.ForEach</code> loop have completed their delegate functions and the tasks are no longer on the threadpool. But the application still has threads it is using and some it needs to clean up.</li></ol></div><p>Now we have seen how to open all of the various windows in the debugger for parallel debugging and stepped through our multithreaded TPL-based application. Let's talk about what just happened and what we saw.</p></div><div class="section" title="How it works"><div class="titlepage"><div><div><h2 class="title"><a id="ch08lvl2sec80"/>How it works</h2></div></div></div><p>You can see from our previous example that before we enter the <code class="literal">Parallel.ForEach</code> command, there are no tasks shown in our <span class="strong"><strong>Tasks</strong></span> window or <span class="strong"><strong>Parallel Stacks</strong></span> window in the <span class="strong"><strong>Tasks</strong></span> view; this is shown in the following screenshot:</p><div class="mediaobject"><img src="graphics/8321EN_08_24.jpg" alt="How it works"/></div><p>There are no tasks yet <a id="id505" class="indexterm"/>because we have not created any. But the application has several threads already. There is one for the main thread and it is the one we have a breakpoint on, one to handle .NET system events, and one for the visual studio debugger our application is running inside.</p><p>Let's switch our <span class="strong"><strong>Parallel Stacks</strong></span> window to <span class="strong"><strong>Threads</strong></span> view:</p><div class="mediaobject"><img src="graphics/8321EN_08_25.jpg" alt="How it works"/></div><p>Now, you can see that the <a id="id506" class="indexterm"/>yellow arrow is in the <span class="strong"><strong>Old Stars Finder</strong></span> button's click event handler on line <span class="strong"><strong>139</strong></span> right where our breakpoint is. The <code class="literal">prsOldStarsCount</code> variable is set to <code class="literal">0</code> because that is how we initialized it, and none of the versions of the delegate have run yet to update it.</p><p>Now, I have stepped through the delegate line twice to let two of the parallel tasks get started. Let's look at the results so far:</p><div class="mediaobject"><img src="graphics/8321EN_08_26.jpg" alt="How it works"/></div><p>Remember that when we <a id="id507" class="indexterm"/>step over a line in one thread, the other threads continue to operate until the thread we step over completes and the control is returned back to the debugger. So, a lot of other things can happen while we execute one line in one thread. As we see here, we are currently in a task numbered <span class="strong"><strong>3</strong></span> at line <span class="strong"><strong>49</strong></span>. We can also see that task <span class="strong"><strong>1</strong></span> is currently waiting on line <span class="strong"><strong>57</strong></span>. We also notice in the <span class="strong"><strong>Parallel Watch</strong></span> window that both tasks show the value of <span class="strong"><strong>369</strong></span> in the variable, <code class="literal">prsOldStarsCount</code>. What does this tell us?</p><p>This tells us that while we are still on one of the first lines in the delegate method in task <span class="strong"><strong>3</strong></span> and it has not begun any real processing yet, other tasks have already found <span class="strong"><strong>369</strong></span> old stars. You'll also notice that both tasks in the <span class="strong"><strong>Parallel Watch</strong></span> window show the same value for <code class="literal">prsOldStarsCount</code>. This is because this is a global variable and all tasks are looking at and updating the same copy. Now, let's step over one line of code in the task <span class="strong"><strong>3</strong></span> delegate and see what happens:</p><div class="mediaobject"><img src="graphics/8321EN_08_27.jpg" alt="How it works"/></div><p>Now, we are on line <span class="strong"><strong>49</strong></span> in the task numbered <span class="strong"><strong>4</strong></span> and the value of <code class="literal">prsOldStarsCount</code> is <span class="strong"><strong>605</strong></span>. What just happened? We stepped over one line in task <span class="strong"><strong>3</strong></span> and ended up in task <span class="strong"><strong>4</strong></span> on the same line.</p><p>Remember we have a <a id="id508" class="indexterm"/>breakpoint set in the delegate method of each of the six tasks that our <code class="literal">Parallel.ForEach</code> loop created. When you step over a line or continue in the debugger, it stops at the next break point that is encountered. Also, remember that when we step over a line, all of our threads and tasks can run during that time. So, when we stepped over the line in task <span class="strong"><strong>3</strong></span>, the next breakpoint the debugger came to was that same line in task <span class="strong"><strong>4</strong></span>. You can see several things from our window. Tasks <span class="strong"><strong>2</strong></span>, <span class="strong"><strong>3</strong></span>, and <span class="strong"><strong>4</strong></span> are all on line <span class="strong"><strong>49</strong></span> and haven't gotten to line <span class="strong"><strong>51</strong></span> (the next executable line). This tells us that when we stepped over line <span class="strong"><strong>49</strong></span> in task <span class="strong"><strong>3</strong></span> the debugger encountered a break at line <span class="strong"><strong>49</strong></span> in task <span class="strong"><strong>4</strong></span> before the execution of line <span class="strong"><strong>49</strong></span> in task <span class="strong"><strong>3</strong></span> got completed. We also see that in the time it took to reach this next break point, our tasks have now counted <span class="strong"><strong>605</strong></span> old stars, up from <span class="strong"><strong>369</strong></span>. Since task <span class="strong"><strong>1</strong></span> is the only task we see past line <span class="strong"><strong>49</strong></span>, we can surmise that it is the one that has counted all of these stars.</p><p>Now, let's step over this line and see what happens next:</p><div class="mediaobject"><img src="graphics/8321EN_08_28.jpg" alt="How it works"/></div><p>This time we moved to <a id="id509" class="indexterm"/>line <span class="strong"><strong>49</strong></span> of task <span class="strong"><strong>2</strong></span> and no more old stars have been counted. Let's step over one more line and examine:</p><div class="mediaobject"><img src="graphics/8321EN_08_29.jpg" alt="How it works"/></div><p>Now we have stopped on<a id="id510" class="indexterm"/> line <span class="strong"><strong>49</strong></span> of task <span class="strong"><strong>5</strong></span>. You can also see that both tasks <span class="strong"><strong>1</strong></span> and <span class="strong"><strong>3</strong></span> are now past line <span class="strong"><strong>49</strong></span> and we have now counted <span class="strong"><strong>869</strong></span> old stars. Let's step over one more line:</p><div class="mediaobject"><img src="graphics/8321EN_08_30.jpg" alt="How it works"/></div><p>Now you can see we have <a id="id511" class="indexterm"/>started all six tasks that we asked for in our <code class="literal">Parallel.ForEach</code> loop and are already up to <span class="strong"><strong>1331</strong></span> old stars. But even with <span class="strong"><strong>1331</strong></span> old stars already found, we have not moved past line <span class="strong"><strong>49</strong></span> in three of our six tasks. Let's step over one more line. Since we have reached this breakpoint line in all six tasks, we should now step through the current task we are on, which is task <span class="strong"><strong>6</strong></span>. </p><p>But as we do so, the other tasks can all run. That being said, the machine we are running on has four processing cores, so not all of them can get CPU time at once, as shown:</p><div class="mediaobject"><img src="graphics/8321EN_08_31.jpg" alt="How it works"/></div><p>As you can see, we now<a id="id512" class="indexterm"/> can start to step through the current task without stopping because the delegate that all of the tasks are running has no more breakpoints that can interfere. You can also see that in the time it took to execute this one line in task <span class="strong"><strong>6</strong></span>, we have now counted <span class="strong"><strong>1686</strong></span> old stars and moved a couple of lines in a few other tasks.</p><div class="note" title="Note" style=""><div class="inner"><h3 class="title"><a id="note28"/>Note</h3><p>Also note that when you see <span class="strong"><strong>[External code]</strong></span> in the stack frame, this is referring to .NET code and not your own source code. You can set your debugger to show the stack of external code, but usually this provides you with too much information when you are mostly concerned with the flow and debugging of your own source code.</p></div></div><p>At this point, keep stepping through and see what happens; then stop your application and redo the exercise. Each time you run the application in the debugger, you should see slightly different results because we have multiple threads running and competing for processing time. Each time you step through the code, different threads will get different amounts of CPU time depending on availability and other competing processes running on your machine. Remember your application and debugging is not the only thing running in your Windows machine.</p></div></div>
<div class="section" title="Summary"><div class="titlepage"><div><div><h1 class="title"><a id="ch08lvl1sec65"/>Summary</h1></div></div></div><p>In this chapter, we have examined all of the functionality that Visual Studio provides multithreaded and parallel application developers to help them troubleshoot and debug their source code. We have examined the <span class="strong"><strong>Threads</strong></span> window, <span class="strong"><strong>Tasks</strong></span> window, <span class="strong"><strong>Parallel Tasks</strong></span> window in <span class="strong"><strong>Threads</strong></span> mode, the <span class="strong"><strong>Parallel Stacks</strong></span> window in <span class="strong"><strong>Tasks</strong></span> mode, and the <span class="strong"><strong>Parallel Stacks</strong></span> window. We have also examined our <code class="literal">OldStarsFinder</code> application using these windows and then stepped through its execution.</p><p>You have learned how to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Examine all threads of your application as it runs</li><li class="listitem" style="list-style-type: disc">Examine all tasks your application creates using the TPL</li><li class="listitem" style="list-style-type: disc">Step through an application with multiple tasks and threads running</li><li class="listitem" style="list-style-type: disc">View the stack of any thread or task in your application</li><li class="listitem" style="list-style-type: disc">Set watch expressions and view them across all the threads</li></ul></div><p>In the next chapter, we will discuss some popular design patterns for parallel applications.</p></div></body></html>