<html><head></head><body>
		<div><h1 id="_idParaDest-47" class="chapter-number"><a id="_idTextAnchor048"/>4</h1>
			<h1 id="_idParaDest-48"><a id="_idTextAnchor049"/>Command-Line Parsing</h1>
			<p>In the previous chapter, we created a console application and learned how to pass parameters to it, converting these parameters to their expected data type when needed (remember that parameters passed to a console application are of the <code>String</code> type).</p>
			<p>However, even though a console application is at the heart of a CLI application, a CLI application is more than just a console application. A CLI application contains named parameters, switches, and subcommands to achieve the intended goal.</p>
			<p>Armed with our knowledge of creating console applications, we’ll build on top of that to learn how to create a CLI application.</p>
			<p>To do so, in this chapter, we’ll cover the following topics:</p>
			<ul>
				<li>Creating the console application</li>
				<li>Parsing the arguments of a console application</li>
				<li>From console to CLI: parsing the arguments using an existing library</li>
			</ul>
			<p>By the end of the chapter, you will learn how to start with a simple console application and convert it to a powerful CLI application that handles commands, subcommands, and options.</p>
			<p class="callout-heading">Introducing Bookmarkr</p>
			<p class="callout"><strong class="bold">Bookmarkr</strong> is the<a id="_idIndexMarker097"/> name of the CLI application we will be building throughout this book.</p>
			<p class="callout">It is a command-line application for managing bookmarks.</p>
			<p class="callout">Throughout the pages of this book, we will bring <em class="italic">Bookmarkr</em> to life and add more and more features to it.</p>
			<p class="callout"><em class="italic">Why a </em><em class="italic">bookmark manager?</em></p>
			<p class="callout">Because everyone has used<a id="_idIndexMarker098"/> one, so they are familiar with how such a tool works and what functionalities it provides.</p>
			<p class="callout">By removing the burden of understanding the business context of <em class="italic">what</em> we are building, we can then focus all of our attention on <em class="italic">how</em> we are building it. And that is precisely why I chose this application. Plus, it could still be super useful 😉.</p>
			<h1 id="_idParaDest-49"><a id="_idTextAnchor050"/>Technical requirements</h1>
			<p>The code for this chapter can be found in the GitHub repository accompanying this book, <a href="https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter04">https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter04</a>.</p>
			<h1 id="_idParaDest-50"><a id="_idTextAnchor051"/>Creating the console application</h1>
			<p>Let’s<a id="_idIndexMarker099"/> start by creating the console application. For this, in Visual Studio Code, display the <strong class="bold">Terminal</strong> window by going to <strong class="bold">View</strong>|<strong class="bold">Terminal</strong>.</p>
			<p>Then, position yourself where you want the code folder to be created (I mentioned in the previous chapter that I always create a <code>C:\Code</code> folder that will contain all of my code projects).</p>
			<p>From there, type the following command to create the console application<a id="_idTextAnchor052"/>:</p>
			<pre class="console">
$ dotnet new console -n bookmarkr -o bookmarkr --use-program-main</pre>			<p>The .NET project currently looks like this when loaded in Visual Studio Code:</p>
			<div><div><img src="img/B22400_04_01.jpg" alt="Figure 4.1 – The bookmarkr project opened in Visual Studio Code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The bookmarkr project opened in Visual Studio Code</p>
			<p>Let’s add<a id="_idIndexMarker100"/> some code to the <code>Program.cs</code> file.</p>
			<p>The first feature we will implement is the ability to add a new bookmark to the list of bookmarks.</p>
			<p>To do so, we need to create a <code>BookmarkService</code> class that will contain all the logic for the bookmarking operations. By following the best practices of development, we will create that class in its own code file, named <code>BookmarkService.cs</code>:</p>
			<pre class="source-code">
namespace bookmarkr;
public class BookmarkService
{
}</pre>			<p>Next, we will need to add a list of <code>Bookmark</code> objects to that <code>BookmarkService</code> class:</p>
			<pre class="source-code">
namespace bookmarkr;
public class BookmarkService
{
    private readonly List&lt;Bookmark&gt; _bookmarks = new();
}</pre>			<p>We <a id="_idIndexMarker101"/>will also need to define the <code>Bookmark</code> class. Here, again, we will follow the best practices of development, and we will create that class in its own code file, smartly named <code>Bookmark.cs</code> 😊. This class looks like this:</p>
			<pre class="source-code">
namespace bookmarkr;
public class Bookmark
{
    public required string Name { get; set; }
    public required string Url { get; set; }
}</pre>			<p>Since the two properties of the <code>Bookmark</code> object cannot be <code>null</code>, we declare them with the <code>required</code> modifier.</p>
			<p>The updated .NET project now looks like this:</p>
			<div><div><img src="img/B22400_04_02.jpg" alt="Figure 4.2 – The updated bookmarkr project opened in Visual Studio Code"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – The updated bookmarkr project opened in Visual Studio Code</p>
			<p>Now that we have all the pieces in place, let’s see how we can process user requests.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor053"/>Parsing the arguments of a console application</h1>
			<p>A <a id="_idIndexMarker102"/>request to a CLI application usually contains the name of the command (and an optional subcommand) along with arguments that provide values to the parameters needed by the command.</p>
			<p>The first command we will be adding is the ability to add a new bookmark to the list of bookmarks.</p>
			<p>The syntax of the expected command is the following:</p>
			<pre class="console">
$ bookmarkr link add &lt;name&gt; &lt;url&gt;</pre>			<p>So, let’s modify the code to handle such a command!</p>
			<p>We will start with the <code>Main</code> method of the <code>Program</code> class (located in the <code>Program.cs</code> file). Why? Because this is the method that receives the input parameters from the user.</p>
			<p>Since we may have multiple commands in the future, we will add a <code>switch</code> statement to handle each one of these. Hence, the code will look like this:</p>
			<pre class="source-code">
namespace bookmarkr;
class Program
{
    static void Main(string[] args)
    {
        if(args == null || args.Length == 0)
        {
            Helper.ShowErrorMessage(["You haven't passed any argument. 
            The expected syntax is:", "bookmarkr &lt;command-name&gt; 
            &lt;parameters&gt;"]);
            return;
        }
        var service = new BookmarkService();
        switch(args[0].ToLower())
        {
            case "link":
                ManageLinks(args, service);
                break;
            // we may add more commands here...
            default:
                Helper.ShowErrorMessage(["Unknown Command"]);
                break;
        }
    }
    static void ManageLinks(string[] args, BookmarkService svc)
    {
        if(args.Length &lt; 2)
        {
            Helper.ShowErrorMessage(["Unsufficient number  of 
            parameters. The expected syntax is:", "bookmarkr link 
            &lt;subcommand&gt; &lt;parameters&gt;"]);
        }
        switch(args[1].ToLower())
        {
            case "add":
                svc.AddLink(args[2], args[3]);
                break;
            // we may add more subcommands here...
            default:
                Helper.ShowErrorMessage(["Unsufficient number of 
                parameters. The expected syntax is:", "bookmarkr link 
                &lt;subcommand&gt; &lt;parameters&gt;"]);
                break;
        }
    }
}</pre>			<p>Let’s<a id="_idIndexMarker103"/> explain this code:</p>
			<ul>
				<li>The <code>Main</code> method<a id="_idIndexMarker104"/> dispatches the processing of each command to a specific method within the <code>Program</code> class. Since, for now, we only have one command (<code>link</code>), we have only one processing method (<code>ManageLinks</code>).</li>
				<li>The <code>ManageLinks</code> method handles the subcommands related to links. For now, we only have one subcommand (<code>add</code>) but we can easily imagine having more subcommands, such as <code>update</code> (to update the URL of an existing link), <code>remove</code> (to remove an existing link), and <code>list</code> (to list all existing links).</li>
				<li>Finally, the <code>ShowErrorMessage</code> method is a utility method used to display error messages in red-colored text. Its code can be found in the <code>Helper</code> class and is omitted here because it does not provide value to the topic we are discussing.</li>
			</ul>
			<p>If you write (or copy) this code, you’ll notice that it does not compile. This is due to the <code>AddLink</code> method not yet being available in the <code>BookmarkService</code> class. Let’s add it!</p>
			<p>The code of the <code>AddLink</code> method is the following:</p>
			<pre class="source-code">
public void AddLink(string name, string url)
{
        if(string.IsNullOrWhiteSpace(name))
        {
            Helper.ShowErrorMessage(["the 'name' for the link is 
            not provided. The expected syntax is:", "bookmarkr link 
            add &lt;name&gt; &lt;url&gt;"]);
            return;
        }
        if(string.IsNullOrWhiteSpace(url))
        {
            Helper.ShowErrorMessage(["the 'url' for the link is 
            not provided. The expected syntax is:", "bookmarkr link 
            add &lt;name&gt; &lt;url&gt;"]);
            return;
        }
        if(_bookmarks.Any(b =&gt; b.Name.Equals(name, StringComparison.
        OrdinalIgnoreCase)))
        {
            Helper.ShowWarningMessage([$"A link with the name '{name}' 
            already exists. It will thus not be added",
            $"To update the existing link, use the command: bookmarkr 
            link update '{name}' '{url}'"]);
            return;
        }
        _bookmarks.Add(new Bookmark { Name = name, Url = url});
        Helper.ShowSuccessMessage(["Bookmark successfully added!"]);
}</pre>			<p>This code is pretty <a id="_idIndexMarker105"/>simple and straightforward, but let’s explain it briefly:</p>
			<ul>
				<li>We first ensure that both the <code>name</code> and <code>url</code> parameters are provided. If not, we return an error message to the user with the expected syntax for the command.</li>
				<li>We ensure that the link to be added is not already present in the list of bookmarks. If it is present, we inform the user with a warning message and invite them to use the <code>update</code> subcommand if they intend to update an existing link.</li>
				<li>If the link does not already exist, we add it to the list of bookmarks and inform the user with a success message.</li>
			</ul>
			<p>Pretty easy, isn’t it? 😊</p>
			<p>However, there is a problem with this approach to building CLI applications. Can you guess what it is?</p>
			<p>It is based on positional parameters. In other words, we expect the first parameter to be the name of the command, the second parameter to be the name of the subcommand, the third parameter to be the value of the <code>name</code> parameter, and the fourth parameter to be the value of the <code>url</code> parameter.</p>
			<p>But there are a couple of issues:</p>
			<ul>
				<li>How could the user be aware of that order?</li>
				<li>What if the user provided the <code>url</code> value as the third parameter and the <code>name</code> value as the fourth parameter?</li>
			</ul>
			<p>If you’re familiar with using CLI applications, you will know that the usual syntax for a CLI command looks like this:</p>
			<pre class="console">
$ bookmarkr link add --name &lt;name&gt; --url &lt;url&gt;</pre>			<p>It can also look like this:</p>
			<pre class="console">
$ bookmarkr link add -n &lt;name&gt; -u &lt;url&gt;</pre>			<p>This helps the <a id="_idIndexMarker106"/>user to know what is expected as parameters and to provide the parameters in the appropriate manner.</p>
			<p>We can, of course, rely on the <code>args</code> list of parameters and compare each one to what is expected (for example, checking whether the third parameter’s value is <code>--name</code> or <code>-n</code> so we know that the fourth parameter represents the value of the name of the link, and so on), but this will complexify our code too much.</p>
			<p>I know what you’re thinking. You’re smart and you’ve already figured out that the best approach to solve this problem is to develop a library to parse these parameters and figure out what they represent.</p>
			<p>But, because I know you’re smart, I know that you’ve already searched for an existing library that does just that. After all, you do not want to reinvent the wheel, do you?</p>
			<h1 id="_idParaDest-52"><a id="_idTextAnchor054"/>From console to CLI – parsing the arguments using an existing library</h1>
			<p>Although many libraries exist for the different programming languages, including .NET, we will focus on <code>System.CommandLine</code> throughout<a id="_idIndexMarker107"/> this book.</p>
			<p>You may be wondering why we chose this library, especially if you are familiar with (or have heard about) <code>CommandLineParser</code>, which<a id="_idIndexMarker108"/> is another common library for that matter.</p>
			<p>There are multiple reasons for that. In essence, <code>System.CommandLine</code> is a more modern, feature-rich, and performant library, whereas <code>CommandLineParser</code> is a simpler and more lightweight alternative.</p>
			<p>Additionally, there are a few other reasons why I prefer <code>System.CommandLine</code>:</p>
			<ul>
				<li><code>System.CommandLine</code> is a .NET Foundation project developed by Microsoft and the community, while <code>CommandLineParser</code> is a third-party library</li>
				<li><code>System.CommandLine</code> uses a builder pattern and a more declarative approach to define commands and options, while <code>CommandLineParser</code> uses attributes and a more imperative approach</li>
				<li><code>System.CommandLine</code> provides more advanced features out of the box, such as command hierarchies, response files, auto-completion, and parsing directives, whereas <code>CommandLineParser</code> is more lightweight and focused on basic command-line parsing</li>
				<li><code>System.CommandLine</code> is known to be faster and more efficient, especially for large command-line structures</li>
				<li>Even though both libraries are cross-platform, <code>System.CommandLine</code> has better support for platform-specific conventions, such as case-insensitivity on Windows</li>
			</ul>
			<p>Now, let’s rewrite our application to benefit from <a id="_idIndexMarker109"/>the <code>System.CommandLine</code> library!</p>
			<p class="callout-heading">Important note #1</p>
			<p class="callout">The previous code of the <code>Program.cs</code> file has been moved into a <code>Program.Console.txt</code> file for further reference.</p>
			<p class="callout-heading">Important note #2</p>
			<p class="callout">While you can execute the application by its executable name (located in <code>bin\Debug\net8.0\bookmarkr.exe</code>), it’s more convenient, during the development phase, to use the <code>dotnet </code><code>run</code> command.</p>
			<p class="callout">I prefer to rely on the executable name because it matches how we will use the application in production. If you prefer to use the <code>dotnet run</code> command, simply replace <code>bookmarkr</code> with <code>dotnet run</code> in the following execution syntaxes.</p>
			<p>The first thing we need to do is to add the <code>System.CommandLine</code> NuGet package library to our project. To do this, open the Visual Studio Code terminal and type the following command:</p>
			<pre class="console">
$ dotnet add package System.CommandLine --prerelease</pre>			<p>At the time of the writing of this chapter, this library is still in Beta. When it makes it to <code>--prerelease</code> switch anymore.</p>
			<p>The way <code>System.CommandLine</code> works is to have a <code>RootCommand</code> object that will act as the root command for all other commands of the CLI application. This means that every command in the application has, as a parent, either the <code>root</code> command or another command whose parent is ultimately the root command.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor055"/>Adding the root command</h2>
			<p>The root command is the one that <a id="_idIndexMarker111"/>gets called when the user invokes the CLI application with no parameters.</p>
			<p>The root command is an instance of the <code>RootCommand</code> class:</p>
			<pre class="source-code">
var rootCommand = new RootCommand("Bookmarkr is a bookmark manager provided as a CLI application.")
{
};</pre>			<p>A command has a handler, which is a method that is called as the result of the user invoking that command:</p>
			<pre class="source-code">
rootCommand.SetHandler(OnHandleRootCommand);</pre>			<p>The <code>SetHandler</code> method takes a delegate to the actual method that does the job:</p>
			<pre class="source-code">
static void OnHandleRootCommand()
{
    Console.WriteLine("Hello from the root command!");
}</pre>			<p>Finally, and since the <code>System.CommandLine</code> library follows the <code>Builder</code> pattern, we need to build and invoke a parser to kick things in:</p>
			<pre class="source-code">
var parser = new CommandLineBuilder(rootCommand)
    .UseDefaults()
    .Build();
return await parser.InvokeAsync(args);</pre>			<p>Last but not least, let’s add the required <code>using</code> statements at the top of the file:</p>
			<pre class="source-code">
using System.CommandLine;
using System.CommandLine.Builder;
using System.CommandLine.Parsing;</pre>			<p>We are now ready to execute our application! Type the following:</p>
			<pre class="console">
$ bookmarkr</pre>			<p>When executed, the<a id="_idIndexMarker112"/> application will invoke the appropriate command (here, the root command since no argument was passed to the executing application), which, in turn, will invoke its handler method (<code>OnHandleRootCommand</code>), and the result of its execution will be returned to the user. In this example, the command will display the message <code>"Hello from the </code><code>root command!"</code>.</p>
			<div><div><img src="img/B22400_04_03.jpg" alt="Figure 4.3 – Invoking the root command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – Invoking the root command</p>
			<p>Isn’t that exciting? No? You’re right… This is not (yet) looking like a CLI application. Let’s add another command!</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor056"/>Adding the link command</h2>
			<p>The syntax for adding bookmarks<a id="_idIndexMarker113"/> using our CLI application is supposed to be like this:</p>
			<pre class="console">
$ bookmarkr link add &lt;name&gt; &lt;url&gt;</pre>			<p>So, we need to create a <code>link</code> command. This command will have the root command as a parent:</p>
			<pre class="source-code">
var linkCommand = new Command("link", "Manage bookmarks links")
{
};
rootCommand.AddCommand(linkCommand);</pre>			<p>Next, we need an <code>add</code> command, whose parent will be the <code>link</code> command:</p>
			<pre class="source-code">
var addLinkCommand = new Command("add", "Add a new bookmark link")
{
};
linkCommand.AddCommand(addLinkCommand);
addLinkCommand.SetHandler(OnHandleAddLinkCommand);</pre>			<p>Now, let’s execute this application:</p>
			<pre class="console">
$ bookmarkr link add</pre>			<p>Pretty close, huh?</p>
			<p>The only elements that are missing are the <code>&lt;name&gt;</code> and <code>&lt;url&gt;</code> parts. These are called <strong class="bold">options</strong>, and we will look into them in a moment. But first, let’s focus on commands.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor057"/>About commands</h2>
			<p>Commands are like a tree <a id="_idIndexMarker114"/>where the root command is… well, the root of that tree.</p>
			<p>Each command has a parent, which is either another command (for example, <code>add</code> has <code>link</code> as a parent), or the root command itself (as for the <code>link</code> command).</p>
			<p>The command tree dictates the syntax of the CLI application. For example, we cannot perform the following call:</p>
			<pre class="console">
$ bookmarkr add</pre>			<p>This is because no <code>add</code> command has the root command as a parent.</p>
			<h2 id="_idParaDest-56"><a id="_idTextAnchor058"/>Do all commands need to have a handler method?</h2>
			<p>The answer is, no, they don’t. Only commands that actually do some processing need to have a handler method. In our case, neither the root command nor the <code>link</code> command require a handler.</p>
			<h2 id="_idParaDest-57"><a id="_idTextAnchor059"/>Adding options to the link command</h2>
			<p>Since the <code>add</code> command<a id="_idIndexMarker115"/> requires two parameters (<code>name</code> and <code>url</code>), we will add two options to it:</p>
			<pre class="source-code">
var nameOption = new Option&lt;string&gt;(
    ["--name", "-n"],
    "The name of the bookmark"
);
var urlOption = new Option&lt;string&gt;(
    ["--url", "-u"],
    "The URL of the bookmark"
);</pre>			<p>As you can see, an <code>Option</code> is defined by the following:</p>
			<ul>
				<li>The data type of its value (here, a string)</li>
				<li>Its aliases (for <code>urlOption</code>, these are <code>--url</code> and <code>-u</code>)</li>
				<li>Its description, which will be useful when requesting the help menu for that command (for <code>urlOption</code>, it is <code>"The URL of </code><code>the bookmark"</code>)</li>
			</ul>
			<p>Next, we need to<a id="_idIndexMarker116"/> assign these options to the command, as follows:</p>
			<pre class="source-code">
var addLinkCommand = new Command("add", "Add a new bookmark link")
{
    nameOption,
    urlOption
};</pre>			<p>We then need to pass these options to the <code>Handler </code>method:</p>
			<pre class="source-code">
addLinkCommand.SetHandler(OnHandleAddLinkCommand, nameOption, urlOption);</pre>			<p>And, finally, we use the values of these options in the <code>Handler</code> method:</p>
			<pre class="source-code">
static void OnHandleAddLinkCommand(string name, string url)
{
    // 'service' is an instance of 'BookmarkService'.
    service.AddLink(name, url);
}</pre>			<p>Now, if we execute the application, we get the expected result. This time, we saved about half of the code by not having to parse the arguments of the console application and delegating this to the <code>System.CommandLine</code> library:</p>
			<div><div><img src="img/B22400_04_04.jpg" alt="Figure 4.4 – We successfully added a bookmark"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – We successfully added a bookmark</p>
			<p>Note that, using<a id="_idIndexMarker117"/> the aliases, we can execute the CLI application using this syntax:</p>
			<pre class="console">
$ bookmarkr --name 'Packt Publishing' --url 'https://www.packtpub.com'</pre>			<p> We can also use this syntax:</p>
			<pre class="console">
$ bookmarkr -n 'Packt Publishing' -u 'https://www.packtpub.com'</pre>			<p>The result will be the same as the one shown in <em class="italic">Figure 4</em><em class="italic">.4</em>.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor060"/>What other types of options can we use?</h2>
			<p><code>System.CommandLine</code> doesn’t only support <code>string</code> options. <code>Option&lt;T&gt;</code> is a generic type, so you can create an <code>Option&lt;T&gt;</code> for any data type. This, for example, could be the following:</p>
			<ul>
				<li><code>int</code></li>
				<li><code>double</code></li>
				<li><code>bool</code></li>
				<li><code>DateTime</code></li>
				<li><code>Uri</code></li>
				<li><code>TimeSpan</code></li>
				<li><code>Regex</code></li>
				<li><code>Enum</code></li>
				<li><code>IPAddress</code></li>
				<li><code>FileInfo</code></li>
			</ul>
			<p>It could even be your own custom class if you prefer.</p>
			<p>Depending on the data type we use, the provided value for the option will be parsed into that data type. If parsing fails, an exception will be raised, and an error message will be displayed to the console.</p>
			<p>Here is an illustrative example. The root command has been updated to accept an integer option. When the program is executed and a value that cannot be parsed into an integer is provided for that option, we get the following error message:</p>
			<pre class="console">
$ bookmarkr --number toto
Cannot parse argument 'toto' for option '--number' as expected type 'System.Int32'.</pre>			<p>Hmm… Although the name of the option indicates that it is expecting a number, it is not clear what that number is all about. What is its purpose? Is there a range of valid values for that number? A little help would be… well, helpful here 😊.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor061"/>Getting help</h2>
			<p>The good news is that when <a id="_idIndexMarker118"/>using <code>System.CommandLine</code>, we get the help menu automatically built for us. All we need to do is to provide meaningful names and descriptions to our commands and options and the library will do the rest.</p>
			<p>We can get help by using either one of these options:</p>
			<ul>
				<li><code>--</code><code>help</code></li>
				<li><code>-h</code></li>
				<li><code>-?</code></li>
			</ul>
			<p>The result will look like this:</p>
			<div><div><img src="img/B22400_04_05.jpg" alt="Figure 4.5 – Help!"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Help!</p>
			<p>This also works for<a id="_idIndexMarker119"/> subcommands. For example, if we want to get help regarding the <code>link</code> command, we can type the following:</p>
			<div><div><img src="img/B22400_04_06.jpg" alt="Figure 4.6 – Getting help for the link command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Getting help for the link command</p>
			<p>We can do this<a id="_idIndexMarker120"/> for one subcommand at a time, such as the <code>link add</code> command, for example:</p>
			<div><div><img src="img/B22400_04_07.jpg" alt="Figure 4.7 – Getting help for the link add command"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Getting help for the link add command</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">You have probably noticed <a id="_idIndexMarker121"/>that the <code>dotnet run</code> syntax for getting help requires an extra <code>--</code>. This is not a typo. It is required because, otherwise, the .NET CLI tool will <em class="italic">think</em> that you are requesting help with the <code>dotnet</code> tool.</p>
			<p class="callout">The extra <code>--</code> is used to separate the arguments that are passed to <code>dotnet run</code> from the arguments that are passed to the application being run. Everything after <code>--</code> is considered an argument to the application, not to <code>dotnet run</code>.</p>
			<p>However, one thing we should keep in mind is that the usage of a CLI application (and hence, its help) depends on the current version of the application. But how do we get that information?</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/>Getting the application’s version number</h2>
			<p>There is a built-in<a id="_idIndexMarker122"/> option (<code>--version</code>) that displays the version number of the CLI application.</p>
			<p>To display it, execute the command as follows:</p>
			<pre class="console">
$ bookmarkr --version</pre>			<p>But where does this value come from?</p>
			<p>Well, it can be found in the <code>.csproj</code> file, within the <code>&lt;PropertyGroup&gt;</code> element at the beginning of the file:</p>
			<pre class="source-code">
&lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;net8.0&lt;/TargetFramework&gt;
    &lt;ImplicitUsings&gt;enable&lt;/ImplicitUsings&gt;
    &lt;Nullable&gt;enable&lt;/Nullable&gt;
    &lt;Version&gt;2.0.0&lt;/Version&gt;
&lt;/PropertyGroup&gt;</pre>			<p>Note that if no <code>&lt;version&gt;</code> element is provided, the default value to be returned will be <code>1.0.0</code>.</p>
			<p class="callout-heading">Important note</p>
			<p class="callout">Here, too, if you want to use the <code>dotnet run</code> syntax to query the version number of the application, you’ll need to use the extra <code>--</code>, as follows: <code>dotnet run -- --</code><code>version</code>.</p>
			<p>And that’s it! You’re now all set and ready to create your first CLI application!</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor063"/>Summary</h1>
			<p>In this chapter, we started to build our very own CLI application, <em class="italic">Bookmarkr</em>, which is a bookmark manager provided as a CLI application, so it can be used within a Terminal window.</p>
			<p>We started with a console application (because remember, “At the core of every CLI application is a console application”), and then we introduced a library for parsing its command-line arguments including commands, subcommands, and options so we don’t need to reinvent the wheel.</p>
			<p>In the upcoming chapter, we will see how to control inputs and outputs and how to read data from and write data to a file so we can perform backup and restore operations for our bookmarks. This will prove especially useful to import and export bookmarks into and out of our bookmark manager application</p>
			<h1 id="_idParaDest-62"><a id="_idTextAnchor064"/>Your turn!</h1>
			<p>Following along with the provided code is a great way to learn through practice.</p>
			<p>A better way is by challenging yourself to achieve tasks. Hence, I challenge you to improve the <em class="italic">Bookmarkr</em> application by adding the following features.</p>
			<h2 id="_idParaDest-63"><a id="_idTextAnchor065"/>Task #1 – Delete an existing bookmark</h2>
			<p>The syntax is as follows:</p>
			<pre class="console">
$ bookmarkr link remove --name &lt;name&gt;</pre>			<p>It can also be as follows:</p>
			<pre class="console">
$ bookmarkr link remove -n &lt;name&gt;</pre>			<p>If the requested link name does not exist, the application should display a warning message to the user. Otherwise, the application should delete that bookmark and display a success message to the user.</p>
			<h2 id="_idParaDest-64"><a id="_idTextAnchor066"/>Task #2 – Update an existing bookmark</h2>
			<p>The syntax is as follows:</p>
			<pre class="console">
$ bookmarkr link update --name &lt;name&gt; --url &lt;url&gt;</pre>			<p>It can also be as follows:</p>
			<pre class="console">
$ bookmarkr link update -n &lt;name&gt; -u &lt;url&gt;</pre>			<p>If the requested link name does not exist, the application should display an error message to the user and invite them to use the <code>add</code> command to add a new bookmark. Otherwise, the application should update the existing bookmark with the newly provided URL and display a success message to the user.</p>
			<h2 id="_idParaDest-65"><a id="_idTextAnchor067"/>Task #3 – List all existing bookmarks</h2>
			<p>The syntax is as follows:</p>
			<pre class="console">
$ bookmarkr link --list</pre>			<p>It can also be as follows:</p>
			<pre class="console">
$ bookmarkr link -l</pre>			<p>If the list of bookmarks contains no items, the application should display a warning message saying that the list of bookmarks is empty and, therefore, there is nothing to display. Otherwise, the application should present the list of bookmarks as follows:</p>
			<pre class="console">
# &lt;name 1&gt;
&lt;url 1&gt;
# &lt;name 2&gt;
&lt;url 2&gt;
...</pre>		</div>
	</body></html>