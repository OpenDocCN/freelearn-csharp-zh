<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-180"><a id="_idTextAnchor189"/>8</h1>
<h1 id="_idParaDest-181"><a id="_idTextAnchor190"/>Catching Exceptions with Exception Handling</h1>
<p>We always try to make our code as stable as possible when building web applications, but there are times when we can’t catch everything. This is why exceptions are considered a foundational part of development. Exception handling is essential for preventing web applications from crashing and displaying an ugly error message on a page. It’s tempting to wrap everything with <code>try</code>/<code>catch</code> or <code>try</code>/<code>finally</code> statements and move on. This should be avoided. Coding with <code>try</code>/<code>catch</code>/<code>finally</code> statements in an application should be the exception to the rule.</p>
<p>The common coding standards in this chapter are meant to remove those types of scenarios and provide a better developer experience.</p>
<p>In this chapter, we’ll examine what exception handling means to developers and when to use it, along with where to handle global exceptions and examine performance considerations. Once we understand the basics of exception handling, the last section will cover some common practices of exception handling, such as applying the “prevention before exception” principle to code, using logging, learning how exception handling is similar to unit tests, and why empty catch blocks should be avoided.</p>
<p>Finally, we’ll learn how to use .NET’s new exception filter, along with pattern matching, when to use <code>finally</code> blocks, and why it’s a good idea to rethrow exceptions.</p>
<p>In this chapter, we’ll cover the following main topics:</p>
<ul>
<li>Using exception handling</li>
<li>Handling global exceptions</li>
<li>Performance considerations</li>
<li>Common exception handling techniques</li>
</ul>
<p>After completing this chapter, you’ll understand exception handling better, when and how to use it, how to implement global exception handling, and how to know if performance is a problem when using exception handling.</p>
<h1 id="_idParaDest-182"><a id="_idTextAnchor191"/>Technical requirements</h1>
<p>We recommend using a favorite editor to add the exception handling code snippets throughout this chapter. Our recommendations are as follows:</p>
<ul>
<li>Visual Studio (preferably the latest version)</li>
<li>Visual Studio Code</li>
<li>JetBrains Rider</li>
</ul>
<p>The editor we’ll be using is Visual Studio 2022 Enterprise, but any version (Community or Professional) will work with the code.</p>
<h1 id="_idParaDest-183"><a id="_idTextAnchor192"/>Using exception handling</h1>
<p>In this section, we’ll discuss what exception handling is, the two types of error handling, when to use error handling in an application, and how exceptions affect performance.</p>
<h2 id="_idParaDest-184"><a id="_idTextAnchor193"/>What is exception handling?</h2>
<p>Exception handling is the ability to recover gracefully from unexpected situations in the code during runtime; <a id="_idIndexMarker449"/>how do we handle errors or problems we experience in applications? It also involves cleaning up allocated resources when issues occur to avoid memory leaks.</p>
<p>There are two types of errors:</p>
<ul>
<li><strong class="bold">Runtime errors</strong>: These are <a id="_idIndexMarker450"/>unexpected errors we experience when running the application.</li>
<li><code>ArgumentNullException.ThrowIfNull()</code> at the beginning of a method to confirm whether a parameter is null or not).</li>
</ul>
<p>Since this book focuses on intermediate to advanced developers, we’re assuming debugging an ASP.NET application is a common process; we all know debugging and exception handling go hand-in-hand. Developers should have a general understanding of what the code in question does when they wrap it with a <code>try</code>/<code>catch</code> block. The ability to create useful exceptions is extremely important. Exceptions should be clear and simple.</p>
<p>For example, early in my career, a developer was experiencing an error message telling them they were running out of disk space. Other developers were experiencing the same error in the application as well and were frantically trying to figure out the problem. The issue turned out to be a bad error message created by a developer along with a <em class="italic">server</em> running out of disk space, not individual developer machines. This could’ve been avoided by <a id="_idIndexMarker452"/>creating better log messages or detecting whether there was disk space available. While we can write better error messages in the exception handlers, we can only protect the code from so much.</p>
<p>Seriously, though – the ability to create a simple and clear error message can be a challenge while coding, but it does make a difference in the long run. We’ll cover some of the common exception handling techniques in the next section.</p>
<h2 id="_idParaDest-185"><a id="_idTextAnchor194"/>When to use exception handling</h2>
<p>The ability to identify whether or not code requires an exception handler can be tricky. In addition to <a id="_idIndexMarker453"/>whether a <code>try</code>/<code>catch</code>/<code>finally</code> block is required, are there resources involved that we need to clean up?</p>
<p>Context is important when it comes to exception handling. In my experience, I always ask three questions before adding exception handling:</p>
<ol>
<li><code>TryParse</code> instead of a full <code>try</code>/<code>catch</code>/<code>finally</code> block or having to manually throw an error because of an invalid parameter.</li>
<li><strong class="bold">Will an external resource throw exceptions?</strong> Examples include web APIs, storage issues, file missing, and so on.</li>
<li><strong class="bold">Do I have to clean up after myself if an error occurs?</strong> Examples include losing a file connection, loading a bitmap, or a database connection.</li>
</ol>
<p>Developers should only use exception handling when they encounter a line of code that they cannot handle <a id="_idIndexMarker454"/>and is considered outside of their control, similar to the possibility of not enough disk drive space.</p>
<p>In this section, we reviewed what exception handling was and when to use it properly.</p>
<h1 id="_idParaDest-186"><a id="_idTextAnchor195"/>Handling global exceptions</h1>
<p>As mentioned earlier in <a id="_idIndexMarker455"/>this chapter, we can only handle so many errors when it comes to web applications. But what if we want to provide a catch-all for all unhandled exceptions?</p>
<p>For global exceptions, we need to revisit the middleware. There is a method called <code>UseExceptionHandler()</code> in the <code>Startup.cs</code> file that points to a <code>/Error</code> page (either Razor or MVC), as shown in the following code snippet:</p>
<pre class="source-code">
if (env.IsDevelopment())
{
    app.UseDeveloperExceptionPage();
}
else
{
    app.UseExceptionHandler("/Error");
    app.UseHsts();
}</pre> <p>Pay particular attention to the <code>env.IsDevelopment()</code> condition. <em class="italic">The </em><code>/Error</code><em class="italic"> page is meant for non-development viewing only</em>. As we mentioned back in <a href="B19493_04.xhtml#_idTextAnchor086"><em class="italic">Chapter 4</em></a> regarding security, always be careful what to show on this page. It may expose system data such as a database connection string that contains credentials or other sensitive data.</p>
<p>To access the exception through the error page, we require the <code>IExceptionHandlerPathFeature</code> instance through <code>HttpContext.Features</code>. This can <a id="_idIndexMarker456"/>be seen in the following <code>OnGet()</code> method on the <code>/</code><code>Error</code> page:</p>
<pre class="source-code">
public void OnGet()
{
    RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier;
    var exceptionFeature =
        HttpContext.Features.Get&lt;IExceptionHandlerPathFeature&gt;();
    // Access the Exception through exceptionFeature?.Error
    // Access the Path through exceptionFeature?.Path
    if (exceptionFeature?.Path == "/")
    {
        ErrorMessage ??= string.Empty;
        ErrorMessage += " We have bigger problems if the main page is             bombing.";
        _logger.Log(LogLevel.Error, exceptionFeature?.Error,             ErrorMessage);
    }
}</pre> <p><code>HttpContext.Features</code> gives us access to the error. From there, we need to determine what to display on the page. In this case, we can see that the main page contains the error. Once we have identified the issue, we can create a public message, and log the error, and store it in <code>ErrorMessage</code> so that the main page can display it.</p>
<p>While this is a simplistic example, alternatively, we can use our middleware to catch global errors as well. Instead of <a id="_idIndexMarker457"/>passing in a page location, we can use a Lambda for our exception handling in the middleware, as shown in the following code snippet:</p>
<pre class="source-code">
app.UseExceptionHandler(handler =&gt;
{
    var logger = loggerFactory.CreateLogger("Middleware");
    handler.Run(async context =&gt;
    {
        context.Response.StatusCode = StatusCodes.            Status501NotImplemented;
        context.Response.ContentType = MediaTypeNames.Text.Plain;
        await context.Response.WriteAsync("Uh-oh...an exception was             thrown.");
        var exceptionFeature =
            context.Features.Get&lt;IExceptionHandlerPathFeature&gt;();
        if (exceptionFeature?.Path == "/")
        {
            var message = " Yep, the home page isn't implemented                 yet.";
            await context.Response.WriteAsync(message);
            logger.Log(LogLevel.Error, exceptionFeature.Error,                 $@"Error:{message}");
        }
    });
});</pre> <p>We retrieve the <code>ExceptionHandlerPathFeature</code> instance the same way as we did on the <code>/Error</code> page. Of <a id="_idIndexMarker458"/>course, we always want to log the error, so we know what to fix (“It’s that darn home page again”).</p>
<p>In this section, we learned how to use middleware to create a global exception handler. This allows us to centralize the error handling and avoid too many exception handlers throughout our application. Next, we’ll focus on performance considerations when writing exception handlers.</p>
<h1 id="_idParaDest-187"><a id="_idTextAnchor196"/>Performance considerations</h1>
<p>One common myth about exception handling is that it doesn’t affect performance. If exceptions are <a id="_idIndexMarker459"/>significantly harming the application’s performance, that’s a sign that exceptions are being used too much. Exceptions should not control the flow of the application whatsoever.</p>
<p>Ideally, the code should flow with no interruptions. In small web applications with a few users, this type of approach may be adequate, but for high-performing, high-traffic websites, placing a <code>try</code>/<code>catch</code> block in frequently-called code may cause the site to suffer a performance hit.</p>
<p>In this section, we covered what exception handling was, reviewed the two types of errors in applications, identified where exception handling is ideal, and covered some of the performance myths regarding exceptions. Next, we’ll look at some common exception handling techniques.</p>
<h1 id="_idParaDest-188"><a id="_idTextAnchor197"/>Common exception handling techniques</h1>
<p>Exceptions are <a id="_idIndexMarker460"/>expensive in .NET. When an exception occurs in the application, there are resources in place to begin the error handling process when an exception occurs, such as the stack trace process. Even when we are catching and handling the errors, ASP.NET is still creating the <code>Exception</code> object and everything associated with it along with walking up the call stack to locate the handler.</p>
<p>In this section, we’ll look at common approaches in the industry to minimize the exceptions through “prevention before exception,” why to use logging, why unit testing is similar to exception <a id="_idIndexMarker461"/>handling, why empty catch blocks should be avoided, how to simplify exceptions using exception filtering and pattern matching, why blocks are important when releasing resources, and how to rethrow exceptions properly.</p>
<h2 id="_idParaDest-189"><a id="_idTextAnchor198"/>Prevention before exception</h2>
<p>As we said in the previous section, exceptions interrupt the flow of an application when encountered and can cause more problems than intended, such as releasing resources that were previously allocated and triggering multiple exceptions up the call stack. If we’re writing <code>try</code>/<code>catch</code> blocks of code to control the flow of the program, we’re doing it wrong. It’s best to perform checks before wrapping code with <code>try</code>/<code>catch</code> blocks.</p>
<p>If there’s one thing to take <a id="_idIndexMarker462"/>away from this chapter, let it be this principle: prevention before exception.</p>
<p>The concept of prevention before exception refers to the idea of trying to prevent the error from happening using less destructive methods, such as stopping the execution of the website completely.</p>
<p>For example, examine the following code:</p>
<pre class="source-code">
var number = "2";
int result;
try
{
    result = int.Parse(number);
}
catch
{
    result = 0;
}
// use result</pre> <p>In a happy path, the number will be parsed and the result will be <code>2</code>. However, if the string contained a value of “hi”, the result will become a zero.</p>
<p>A better approach would be using the newest <code>TryParse</code> with <code>var</code>, a<a id="_idTextAnchor199"/>s shown here:</p>
<pre class="source-code">
var number = "2";
if (!int.TryParse(number, out var result))
{
    result = 0;
}
// use result</pre> <p>With this approach, we are attempting to convert the number and store the converted value into a new <a id="_idIndexMarker463"/>variable called <code>result</code>. <code>TryParse</code> returns true if the conversion was successful and false if not. If the conversion fails, we set <code>result</code> to <code>0</code>.</p>
<p>We prevented an exception by handling the conversion through easier means. There are a large number of conversion methods in .NET and we can accomplish the same thing without <code>try</code>/<code>catch</code>/<code>finally</code> blocks.</p>
<p>For simpler exceptions, look at the <code>try</code>/<code>catch</code> block and ask if we can apply some sort of prevention before creating exceptions.</p>
<h2 id="_idParaDest-190"><a id="_idTextAnchor200"/>Use logging</h2>
<p>When creating a <code>try</code>/<code>catch</code> block, it’s <a id="_idIndexMarker464"/>best to show the intent of what we want to get out of the code. Is the error something we can recover from or is it something that requires investigation when it occurs?</p>
<p>If it’s the latter, it’s best to send a well-constructed error message to the logger before throwing the error. As mentioned in various chapters, it’s best to use a logging strategy to identify issues throughout the code base.</p>
<p>If we use the previous example to determine the value that caused the error, we can create a log entry, as shown here:</p>
<pre class="source-code">
var number = "hi";
int result;
try
{
    result = int.Parse(number);
}
catch
{
    // gives us "OnGetAsync:invalid number - hi"
    _logger.LogInformation($"{MethodBase.GetCurrentMethod()}:invalid number - {number}");
    result = 0;
}
// use result</pre> <p>While this gives us a <a id="_idIndexMarker465"/>clear log entry for our <code>try</code>/<code>catch</code> block, we can copy this one-liner to our <code>TryParse</code> example as well.</p>
<p>The idea is to provide enough information to developers without jarring the user’s experience with errors.</p>
<h2 id="_idParaDest-191"><a id="_idTextAnchor201"/>Apply a unit testing methodology</h2>
<p>If we have to <a id="_idIndexMarker466"/>use a <code>try</code>/<code>catch</code> block, look at it like a unit test. We mentioned that unit tests have the triple-A approach (Arrange, Act, and Assert). We want to create a minimal amount of code to get the job done and move on.</p>
<p>Initialize the objects at the beginning (Arrange) and wrap a <code>try</code>/<code>catch</code> block around the suspecting line causing the error (Act). Minimize the amount of code inside the <code>try</code>/<code>catch</code> block.</p>
<p>Once again, we can apply this <a id="_idIndexMarker467"/>approach to the previous code example, which has been modified as follows:</p>
<pre class="source-code">
// Arrange
var number = "2";
int result;
try
{
    // Act
    result = int.Parse(number);
}
// Assert
catch
{
    // gives us "OnGetAsync:invalid number - hi"
    _logger.LogInformation($"{MethodBase.GetCurrentMethod()}:invalid number - {number}");
    result = 0;
}
// use result</pre> <p>Anything above the <code>try</code> statement would be considered part of <code>Arrange</code>; the one-liner inside the try’s brackets is considered <code>Act</code>. The <code>Assert</code> piece would be part of the <code>catch</code> statement. This statement would be the equivalent of a failed <code>Assert</code>.</p>
<h2 id="_idParaDest-192"><a id="_idTextAnchor202"/>Avoid empty catch statements</h2>
<p>While preventing <a id="_idIndexMarker468"/>errors is critical to our applications, consider an empty catch statement, as shown here:</p>
<pre class="source-code">
private void Deposit(Account myAccount, decimal amount)
{
    try
    {
        myAccount.Deposit(amount);
    }
    catch { }
}</pre> <p>What happens when the <code>Deposit()</code> method doesn’t work? If we do have an error in the code, the <code>catch</code> statement should contain something to let the developer know an error occurred. At the very least, a <code>Log</code> statement should exist to notify the team about the issue.</p>
<p>While an empty <code>try</code>/<code>catch</code> block keeps the program from crashing, it causes a bigger problem. Once someone discovers there’s an error with depositing funds, it may be hard to find the issue since it doesn’t log the problem because it’s not logging or throwing an error.</p>
<h2 id="_idParaDest-193"><a id="_idTextAnchor203"/>Use exception filtering and pattern matching</h2>
<p>If we are dealing with multiple exceptions for a section of code, a new feature in .NET called <a id="_idIndexMarker469"/>exception filtering can make <a id="_idIndexMarker470"/>the exception handling terser. If we have compact code, exception filtering can provide a more efficient and modern code base.</p>
<p>For instance, file handling can often result in a wide variety of exceptions. Consider the following code snippet:</p>
<pre class="source-code">
FileStream fileStream = null;
try
{
    fileStream = new FileStream(@"C:\temp\myfile.txt", FileMode.Append);
}
catch (DirectoryNotFoundException e)
{
    _logger.Log(LogLevel.Information, MethodBase.GetCurrentMethod()+":Directory not found - " + e.Message);
}
catch (FileNotFoundException e)
{
    _logger.Log(LogLevel.Information, MethodBase.GetCurrentMethod()+":File Not Found - " + e.Message);
}
catch (IOException e)
{
    _logger.Log(LogLevel.Information, MethodBase.GetCurrentMethod()+":I/O Error - " + e.Message);
}
catch (NotSupportedException e)
{
    _logger.Log(LogLevel.Information, MethodBase.GetCurrentMethod()+":Not Supported - " + e.Message);
}
catch (Exception e)
{
    _logger.Log(LogLevel.Information, MethodBase.GetCurrentMethod()+":General Exception - " + e.Message);
}
// Use filestream</pre> <p>In the preceding code, we log each exception and provide a message based on the specific <a id="_idIndexMarker471"/>exception. With exception filtering, we <a id="_idIndexMarker472"/>can shorten the lines to something a little easier to read:</p>
<pre class="source-code">
FileStream fileStream = null;
try
{
    fileStream = new FileStream(@"C:\temp\myfile.txt", FileMode.Append);
}
catch (Exception e) when
    (  e is DirectoryNotFoundException
    || e is FileNotFoundException)
{
    _logger.Log(LogLevel.Warning, $"{MethodBase.GetCurrentMethod()}:{nameof(e)} - {e.Message}");
}
catch (Exception e) when
    (e is NotSupportedException
    || e is IOException)
{
    _logger.Log(LogLevel.Error, $"{MethodBase.GetCurrentMethod()}:{nameof(e)} - {e.Message}");
}
catch (Exception e)
{
    _logger.Log(LogLevel.Error, $"{MethodBase.GetCurrentMethod()}:{nameof(e)} - {e.Message}");
}
// Use filestream</pre> <p>In the preceding code, we are grouping <code>DirectoryNotFoundException</code> and <code>FileNotFoundException</code> and logging them as warnings. When we encounter a <code>NotSupportedException</code> or <code>IOException</code> error, we consider that a little more of a problem <a id="_idIndexMarker473"/>and log those as errors. Anything<a id="_idIndexMarker474"/> else coming through will be caught as a general exception and logged as an error with the message.</p>
<p>Along with exception filtering, .NET introduced another new feature called pattern matching. With pattern matching, we can shorten the code even further:</p>
<pre class="source-code">
FileStream fileStream = null;
try
{
    fileStream = new FileStream(@"C:\temp\myfile.txt", FileMode.Append);
}
catch (Exception e)
{
    var logLevel = e switch
    {
        DirectoryNotFoundException =&gt; LogLevel.Warning,
        FileNotFoundException =&gt; LogLevel.Warning,
        _ =&gt; LogLevel.Error
    };
    _logger.Log(logLevel, $"{MethodBase.GetCurrentMethod()}:{nameof(e)} - {e.Message}");
}
// Use filestream</pre> <p>The preceding code uses a <code>switch</code> statement inside the <code>catch</code> brackets to identify what type of exception we’re experiencing. Think of switch pattern matching as an inline <code>if</code> statement. The preceding line returns the value of <code>logLevel</code> based on the exception type.</p>
<p>The underscore (<code>_</code>) is called a discard variable (it’s like a default in a switch statement). If everything else falls <a id="_idIndexMarker475"/>through the switch, then <a id="_idIndexMarker476"/>we’ll just default the log level to <code>LogLevel.Error</code> and log the message with the current method, the name of the exception type, and the exception message.</p>
<p>Exception handling can be wordy with, for instance, I/O-based methods and connections. Exception filtering and pattern matching can help ease the wordiness of catching various exceptions.</p>
<h2 id="_idParaDest-194"><a id="_idTextAnchor204"/>Use finally blocks for cleanup</h2>
<p>When working with <a id="_idIndexMarker477"/>database connections, file-based operations, or resources, it’s best to use <code>finally</code> for cleanup.</p>
<p>For example, if we’re connecting to a database and want to close the connection afterward, we’d have to create a piece of code similar to the following:</p>
<pre class="source-code">
using System.Data.SqlClient;
var connectionString = @"Data Source=localhost;Initial Catalog=myDatabase;Integrated Security=true;";
using SqlConnection connection = new SqlConnection(connectionString);
var command = new SqlCommand("UPDATE Users SET Name='Jonathan' WHERE ID=1 ", connection);
try
{
    command.Connection.Open();
    command.ExecuteNonQuery();
}
catch (SqlException ex)
{
    Console.WriteLine(ex.ToString());
    throw;
}
finally
{
    connection.Close();
}</pre> <p>In the <a id="_idIndexMarker478"/>preceding code, the connection object is passed into the <code>SqlCommand</code> constructor. When we execute the SQL query, the command is passed into the connection and executed. Once our code is executed, we close the connection in the <code>finally</code> statement. Since we have a <code>using</code> statement and the <code>SqlConnection</code> class implements <code>IDisposable</code>, it will automatically be disposed of.</p>
<p>There are times when we need <code>finally</code> statements to clean up, but there are exceptions when they aren’t necessary.</p>
<h2 id="_idParaDest-195"><a id="_idTextAnchor205"/>Knowing when to throw</h2>
<p>In the previous <a id="_idIndexMarker479"/>code example, we issued <code>throw;</code> as opposed to <code>throw ex;</code>.</p>
<p>If we run the code example in the previous section with <code>throw;</code>, we see that the stack trace in Visual Studio is seen through the <strong class="bold">Call </strong><strong class="bold">Stack</strong> pane:</p>
<div><div><img alt="Figure 8.1 – Snapshot of a call stack with a simple throw;" src="img/B19493_08_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.1 – Snapshot of a call stack with a simple throw;</p>
<p>What happens if we change the line to <code>throw ex;</code>?</p>
<div><div><img alt="Figure 8.2 – Snapshot of a call stack with throw ex;" src="img/B19493_08_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 8.2 – Snapshot of a call stack with throw ex;</p>
<p>The stack trace completely disappears. The error will become harder to track if we don’t have a stack trace. There are times when we want to simply throw the exception. It’s always better to rethrow the exception so that the stack trace is left intact for locating errors.</p>
<p>In this section, we covered many standards of what is considered practical when applying exception handling in the code. We learned how to minimize exceptions with “prevention <a id="_idIndexMarker480"/>before exception,” why logging is important, and why exception handling is like unit testing.</p>
<p>We also learned to avoid empty catch blocks, simplify exceptions using exception filtering and pattern matching, when to use finally blocks, and how to rethrow exceptions properly.</p>
<h1 id="_idParaDest-196"><a id="_idTextAnchor206"/>Summary</h1>
<p>Exception handling is important but requires a level of experience when writing truly robust applications. Applications need to recover so that the user doesn’t have a jarring experience.</p>
<p>In this chapter, we learned about exception handling, when to use it, and where it makes sense, as well as performance considerations.</p>
<p>We ended this chapter by learning about the common techniques of exception handling by understanding the “prevention before exception” principle, why logging is important, and why exception handling is like unit testing.</p>
<p>We also learned that empty catch blocks are wasteful, how to simplify exceptions using exception filtering and pattern matching, when to use finally blocks, and how to rethrow exceptions properly.</p>
<p>In the next chapter, we’ll look at web API standards and how they are extremely important to the ASP.NET Core ecosystem.</p>
</div>
</body></html>