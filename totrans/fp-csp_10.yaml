- en: '10'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pipelines and Composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will combine all knowledge from previous chapters and first
    discuss function composition, which allows us to combine simple functions to create
    more complex operations. Then, we will see how to construct pipelines using the
    `Pipe` method. We will also recall how to create monadic pipelines that gracefully
    handle errors. Furthermore, the fluent interface technique, which helps to write
    code that can be read almost like regular text, will be presented.
  prefs: []
  type: TYPE_NORMAL
- en: 'To sum it up, this chapter walks us through these topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building pipelines
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The fluent interface
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Advanced composition with monads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: I could not betray our tradition and, for the last time, prepared three self-check
    tasks for you.
  prefs: []
  type: TYPE_NORMAL
- en: Task 1 – Enemy wave processing pipeline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Compose a series of functions into a pipeline that processes a list of enemy
    waves, applying increased difficulty (hard mode), validating the result, and transforming
    it into a formatted string using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Task 2 – Game data file processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using the following code, compose a series of monadic functions into a pipeline
    that processes a game data file, reads its content, processes it, and writes the
    result to another file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Task 3 – Dynamic SQL query generation using currying and partial application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Use currying to build a function for dynamic query generation for tower defense
    game data and partially applied functions for querying enemy types and levels.
    Use the following function to generate query scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: These tasks should be already familiar to you since they were discussed in previous
    chapters. However, you still might feel that there is room for improvement in
    your mastery of composition, currying, or partial application. If so, you are
    more than welcome to proceed with reading this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Function composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steve looked at Julia with a mix of excitement and nervousness.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *So, we’re finally putting all the pieces together? I’m excited but
    a* *little overwhelmed.*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Don’t worry, Steve. We’ll take it step by step. Remember, these concepts
    build on each other. You’ve already learned* *a lot!*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *You’re right. I’m ready to dive in. Where do* *we start?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Let’s begin with function composition. It’s a great way to combine
    everything we’ve learned* *so far...*'
  prefs: []
  type: TYPE_NORMAL
- en: Function composition is the process of combining two or more functions to produce
    a new function. Let’s spice things up a notch and add higher-order functions to
    our composition example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider a scenario where we need to transform a list of user data. We have
    the following higher-order functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '**map**: Applies a function to each element in a list'
  prefs: []
  type: TYPE_NORMAL
- en: '**filter**: Filters elements in a list based on a predicate'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define these functions in the following way:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, let’s define our transformation and filtering functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now compose `map` and `filter` to create a function that will do all
    these actions at once:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: As a result, we have the `processUsers` function filter the list first to only
    include strings that start with “a” and then capitalize each remaining string.
    Of course, we could write all code using just one `processUsers` method, but the
    current solution allows us to reuse small functions in different places. The idea
    here is to start replacing big methods with compositions of smaller ones. Additional
    benefits are that small methods have much lower cognitive load and cyclomatic
    complexity, making them much easier to read and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: As Julia finished explaining function composition, Steve nodded thoughtfully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: I think I’m starting to see how this all fits together. But how do we
    use this in larger applications?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: Great question! That’s where pipelines come in. They allow us to chain
    these composed functions in a more structured way. Let me show you...'
  prefs: []
  type: TYPE_NORMAL
- en: Building pipelines
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Before constructing pipelines, let’s briefly recap two key concepts from the
    previous chapter: currying and partial application. These techniques are fundamental
    to creating flexible, reusable function components that serve as excellent pipeline
    building blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Currying, as we learned, transforms a function that takes multiple arguments
    into a sequence of functions, each accepting a single argument. Here’s an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Partial application, on the other hand, involves fixing a number of arguments
    to a function, producing another function with fewer parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'These concepts naturally lead on to pipeline construction. By currying functions
    or partially applying them, we create specialized, single-purpose functions that
    can be easily composed into pipelines. This approach allows us to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Break down complex operations into simpler, more manageable pieces
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Reuse these pieces across different pipelines or contexts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create more expressive and readable code by chaining these specialized functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For instance, consider a pipeline for processing game data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Each step in this pipeline could be a curried or partially applied function,
    allowing for easy customization and reuse. As we explore pipeline construction
    further, remember how currying and partial application can be leveraged to create
    more flexible and powerful pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to building pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: Pipelines process data through a sequence of processing steps, each represented
    by a function. This approach is particularly useful for tasks that require multiple
    transformations, validations, or computations. You most probably have already
    encountered pipelines while using LINQ to manipulate collections.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s consider a real-world scenario: an **Extract, Transform, Load** (**ETL**)
    process for publishing manuscripts. This process involves several steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Extracting (querying) the manuscript from a database
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Validating its content
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transforming it into the required format
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Loading (submitting) it for publication
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Each step can be represented as a function, and we can use a pipeline to streamline
    this process. To do this, let’s create a method that applies a sequence of functions
    to an initial value, passing the result of each function to the next, and name
    it `Pipe`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s consider book manuscript processing: querying the manuscript from a database,
    validating its content, transforming it into the required format, and finally
    submitting it for publication:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s how we might execute this flow without using the `Pipe` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, using the `Pipe` method, our code becomes 10 times better:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Of course, it adds a bit of overhead, and the program might work noticeably
    more slowly, but it’s so much easier and faster to read!
  prefs: []
  type: TYPE_NORMAL
- en: Performance considerations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Talking about the overhead, while functional programming techniques such as
    composition and pipelines offer improved readability and maintainability, it’s
    important to understand their performance implications. When we compose functions,
    the compiler generates a series of nested method calls. This can lead to multiple
    stack frame allocations, impacting performance for deeply nested compositions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To better understand the difference, let’s benchmark different approaches:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Running these benchmarks might yield results similar to the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B21069_10_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, the imperative approach is almost twice as fast as the functional
    approach. However, the performance of a usual LINQ pipeline and our own is almost
    identical! While the imperative approach shows better performance, it’s important
    to note that functional approaches often provide benefits in code readability,
    maintainability, and composability.
  prefs: []
  type: TYPE_NORMAL
- en: The fluent interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The fluent interface is the API pattern that allows us to chain method calls
    in a readable and intuitive manner. This term became widely known in 2005, but
    some people still think of it as just method chaining. However, the main idea
    is to make the code look like a **domain-specific language** (**DSL**). Let’s
    rework our previous example by introducing a fluent interface technique.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s define a class to encapsulate the pipeline steps for processing
    a manuscript:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Using the fluent interface, we can rewrite the pipeline more expressively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, it looks almost identical to the example with the `Pipe` method,
    but the `Query` and `Submit` methods differ. It is because they do not depend
    on external validation or transformation rules that might change the logic but
    are rather straightforward. It’s a good idea to use a fluent interface when there
    is enough logic that will probably not change in the future. But if there isn’t
    any, we can use the `Pipe` method.
  prefs: []
  type: TYPE_NORMAL
- en: Advanced composition with monads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Steve scratched his head, looking a bit confused.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Julia, I thought we were done with monads. Why are we* *revisiting
    them?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *Good observation, Steve. We’re circling back to monads because they’re
    incredibly powerful for composing complex operations, especially when dealing
    with error handling and asynchronous processes. Let me show you how they fit into*
    *our pipelines...*'
  prefs: []
  type: TYPE_NORMAL
- en: Monads provide a mechanism for chaining operations as well. In previous chapters,
    you learned about the basic concept of monads and the `Bind` method. We will use
    the `Bind` method to chain operations in more complex contexts, such as error
    handling and asynchronous processing.
  prefs: []
  type: TYPE_NORMAL
- en: In our first scenario, we need to fetch and process user data from an external
    API. Each step in the process might fail, and we need to handle these errors gracefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s recall our `Result` monad definition:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, rewrite our previous example to use the `Result` type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now compose these functions using `Bind` to create a monadic pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s use the pipeline to process user data:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The expected console output is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Again, the `processManuscript` method looks quite similar to the previous ones;
    however, this time, it includes graceful error handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s now see how we can combine currying, partial application, and monadic
    operations to create a robust error-handling pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This example demonstrates the power of combining currying, partial application,
    and monadic composition. We’ve created a pipeline that parses input, validates
    it, and performs a transformation, all while handling potential errors in each
    step. The use of curried and partially applied functions makes our pipeline both
    flexible and easy to extend.
  prefs: []
  type: TYPE_NORMAL
- en: As they wrapped up their discussion, Steve looked both tired and accomplished.
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Wow, Julia. This has been quite a journey. I never thought I’d understand
    these concepts when* *we started*.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *You’ve come a long way, Steve. How do you feel about functional* *programming
    now*?'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *I’m excited to start applying these concepts in our projects. It’s
    amazing how much clearer and more structured our code* *can be*.'
  prefs: []
  type: TYPE_NORMAL
- en: Julia smiled, proud of Steve’s progress.
  prefs: []
  type: TYPE_NORMAL
- en: 'Julia: *That’s great to hear, Steve. Remember, practice makes perfect. Keep
    experimenting and don’t be afraid to ask questions. Ready for some exercises to
    cement what* *we’ve learned?*'
  prefs: []
  type: TYPE_NORMAL
- en: 'Steve: *Absolutely! Bring* *them on!*'
  prefs: []
  type: TYPE_NORMAL
- en: Exercises
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exercise 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Compose a series of functions into a pipeline that processes a list of enemy
    waves, applying increased difficulty (hard mode), validating the result, and transforming
    it into a formatted string using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Using the following code, compose a series of monadic functions into a pipeline
    that processes a game data file, reads its content, processes it, and writes the
    result to another file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: Exercise 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Use currying to build a function for dynamic query generation for tower defense
    game data and partially applied functions for querying enemy types and levels.
    Use the following function to generate query scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Solutions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Here are the solutions to the exercises provided in the previous section. Use
    them to ensure your understanding and to correct any mistakes you might have made.
  prefs: []
  type: TYPE_NORMAL
- en: Solution 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, we compose these functions to create a transaction processing pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we test it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Solution 2
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We start by creating the monadic pipeline using the given functions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s test the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Solution 3
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this solution, we create a curried version of the function first:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we use it to generate queries:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'We write the code to use them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Here’s the expected result:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: After finishing these exercises, you should have a better understanding of how
    to use pipelines, currying, and partial applications in your code.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we integrated knowledge from previous chapters to revisit pipelines
    and composition. We started with function composition, showing how to combine
    simple functions into complex operations using higher-order functions for mapping
    and filtering collections.
  prefs: []
  type: TYPE_NORMAL
- en: We then introduced the `Pipe` method, which simplifies a pipeline’s function
    chaining. When applied to our book publishing system example, it enabled clear
    processing steps for querying, validating, transforming, and submitting a manuscript.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we examined the fluent interface pattern, which allows quite intuitive
    method chaining. The `ManuscriptProcessor` class demonstrated how a fluent interface
    can make our code more expressive and user-friendly. We also covered advanced
    composition with monads using the `Result` type for graceful error handling in
    monadic pipelines.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will be the last of our journey, and I truly hope you enjoy
    the process. So, finish the exercises if you haven’t yet done so, and see you
    in the next chapter!
  prefs: []
  type: TYPE_NORMAL
- en: Part 4:Conclusion and Future Directions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the final part, we reflect on the journey we’ve taken through functional
    programming in C#. We’ll summarize the key concepts learned, reinforcing your
    understanding of how these techniques can be applied to write cleaner, more maintainable
    code. We’ll also look ahead to what’s next in your functional programming journey,
    providing guidance on how to further advance your skills and stay up-to-date with
    evolving best practices in the field.
  prefs: []
  type: TYPE_NORMAL
- en: 'This part has the following chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 11*](B21069_11.xhtml#_idTextAnchor446)*, Reflecting and Looking Ahead*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
