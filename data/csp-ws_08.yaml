- en: 8\. Creating and Using Web API Clients
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 8. 创建和使用 Web API 客户端
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will step into the world of HTTP practice by making calls
    to Web APIs. You will interact with Web APIs in a variety of ways using a web
    browser, your own HTTP client, and NuGet packages. You will learn the basics of
    security involved in Web APIs, use PayPal to make sandbox payments, and explore
    cloud services such as Azure Text Analytics and Azure Blob storage.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将通过调用 Web API 来步入 HTTP 实践的世界。你将使用网络浏览器、你自己的 HTTP 客户端和 NuGet 包以各种方式与 Web
    API 交互。你将学习 Web API 中涉及的安全基础，使用 PayPal 进行沙盒支付，并探索 Azure 文本分析服务和 Azure Blob 存储等云服务。
- en: By the end of this chapter, you will be able to read HTTP requests and response
    messages, make calls to any Web API, and create your own HTTP client to simplify
    your work with complex APIs. You will also be able to dissect and learn both incoming
    HTTP requests and outgoing HTTP responses in any form and use development tools
    in the Chrome browser to inspect traffic moving back and forth when browsing your
    favorite websites.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将能够阅读 HTTP 请求和响应消息，调用任何 Web API，并创建自己的 HTTP 客户端以简化与复杂 API 的工作。你还将能够分析并学习任何形式的传入
    HTTP 请求和传出 HTTP 响应，并使用 Chrome 浏览器中的开发工具检查浏览你喜欢的网站时来回移动的流量。
- en: Introduction
  id: totrans-4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The World Wide Web (WWW) (or just the web) is a big store of all sorts of documents
    (XML, JSON, HTML, MP3, JPG, etc.) accessible through Uniform Resource Locators
    (URLs). A document in the context of the web is often called a resource. Some
    resources do not change. They are stored somewhere, and with every request, the
    same resource will be returned. Such resources are called static. Other resources
    are dynamic, which means they will be generated on demand.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 万维网（WWW）（或简称网络）是一个包含各种文档（XML、JSON、HTML、MP3、JPG 等）的大仓库，这些文档可以通过统一资源定位符（URL）访问。在网络的上下文中，一个文档通常被称为资源。有些资源不会改变。它们存储在某处，并且每次请求时，都会返回相同的资源。这类资源被称为静态资源。其他资源是动态的，这意味着它们将在需要时生成。
- en: 'Communication on the web happens through protocols. In the context of retrieving
    documents, you use Hypertext Transfer Protocol (HTTP). Hypertext is a special
    text that holds a link to a resource on the web. Clicking on it opens the resource
    it points to. HTTP is based on a client-server architecture. In simple terms,
    a client sends requests, and the server responds. An example of this in practice
    is the communication between a browser (client) and a website (hosted on a server).
    Usually, a single server serves many clients:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 网络上的通信通过协议进行。在检索文档的上下文中，你使用超文本传输协议（HTTP）。超文本是一种特殊的文本，它包含指向网络中资源的链接。点击它将打开它指向的资源。HTTP
    基于客户端-服务器架构。简单来说，客户端发送请求，服务器响应。实践中一个例子是浏览器（客户端）和网站（托管在服务器上）之间的通信。通常，单个服务器为许多客户端提供服务：
- en: '![Figure 8.1: Client-server architecture ](img/B16835_08_01.jpg)'
  id: totrans-7
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.1：客户端-服务器架构](img/B16835_08_01.jpg)'
- en: 'Figure 8.1: Client-server architecture'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：客户端-服务器架构
- en: 'When you navigate to a website, you send an `HTTP GET` request, and the server
    responds by displaying the relevant site content in the browser. `GET` is an HTTP
    verb—a method identifying how a request should be treated. Common HTTP verbs are
    the following:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 当你导航到网站时，你发送一个 `HTTP GET` 请求，服务器通过在浏览器中显示相关网站内容来响应。`GET` 是一个 HTTP 动词——一个标识请求应该如何被处理的方法。常见的
    HTTP 动词如下：
- en: '`GET`: Get a resource.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GET`：获取一个资源。'
- en: '`POST`: Create a resource or send a complex query.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST`：创建一个资源或发送一个复杂的查询。'
- en: '`PUT`: Update all resource fields.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT`：更新所有资源字段。'
- en: '`PATCH`: Update a single field.'
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH`：更新单个字段。'
- en: '`DELETE`: Remove a resource.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DELETE`：删除一个资源。'
- en: Browser
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 浏览器
- en: 'A modern browser is more than just a tool to access content on the internet.
    It includes tools to dissect elements of a website, inspect traffic, and even
    execute code. This side of a browser is called developer tools. The exact key
    binds may vary but pressing `F12` or `Control + Shift + I` should call up the
    Developer Tools tab. Perform the following steps to get to know it better:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 现代浏览器不仅仅是一个访问互联网内容的工具。它包括分解网站元素、检查流量甚至执行代码的工具。浏览器的这一部分被称为开发者工具。确切的快捷键可能有所不同，但按
    `F12` 或 `Control + Shift + I` 应该会调出开发者工具标签。执行以下步骤以更好地了解它：
- en: Open Google Chrome or any other browser.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Google Chrome 或任何其他浏览器。
- en: Navigate to [google.com](http://google.com). Press the keys `Control + Shift
    + I`.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 [google.com](http://google.com)。按 `Control + Shift + I` 键。
- en: 'Go to `Network` (`1`). The following window should be displayed:'
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 `网络` (`1`)。以下窗口应该会显示：
- en: '![Figure 8.2: Chrome with developer tools open with google.com loaded ](img/B16835_08_02.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![图8.2：Chrome浏览器中已打开开发者工具并加载了google.com](img/B16835_08_02.jpg)'
- en: 'Figure 8.2: Chrome with developer tools open with google.com loaded'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2：Chrome浏览器中已打开开发者工具并加载了google.com
- en: Select the first entry, [www.google.com](http://www.google.com) (`2`).
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择第一个条目，[www.google.com](http://www.google.com) (`2`)。
- en: Click `Headers` (`3`).
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`头部`(`3`)。
- en: In the `General` (`4`) section, you can observe the effects when you navigated
    to [google.com](http://google.com). The first thing that happened was `HTTP GET`
    request was sent to [https://www.google.com/](https://www.google.com/).
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`通用`(`4`)部分，你可以观察到导航到[google.com](http://google.com)时的效果。首先发生的事情是发送了`HTTP GET`请求到[https://www.google.com/](https://www.google.com/)。
- en: In the `Request Headers` section (`5`), you can see the metadata sent with the request.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`请求头部`部分(`5`)，你可以看到随请求发送的元数据。
- en: To see how Google responded, click the `Response` section (`6`).
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查看Google的响应，请点击`响应`部分(`6`)。
- en: 'This flow is called the client-server architecture, and the following applies:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这种流程被称为客户端-服务器架构，以下适用：
- en: The client is the Chrome browser that sends a request to [google.com](http://google.com).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端是发送请求到[google.com](http://google.com)的Chrome浏览器。
- en: The server is a machine(s) hosting [google.com](http://google.com) that responds
    with [google.com](http://google.com) website contents.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 服务器是一台（或多台）托管[google.com](http://google.com)的机器，它以[google.com](http://google.com)网站内容作为响应。
- en: Web API
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Web API
- en: An Application Programming Interface (API) is an interface through which you
    can call some functionality using code. It could be a class or an interface in
    C#, or a browser (you can interact with it through code provided by its own interface),
    but in the context of HTTP, it is a web service. A web service is an API hosted
    on a remote machine that is accessible through HTTP. An access point used to invoke
    a single piece of functionality on a Web API is called an endpoint. The most commonly
    used Web API type is RESTful.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序编程接口（API）是通过代码调用某些功能的一个接口。它可以是C#中的类或接口，或者是一个浏览器（你可以通过其提供的接口与之交互），但在HTTP的上下文中，它是一个网络服务。网络服务是托管在远程机器上的API，可以通过HTTP访问。用于在Web
    API上调用单个功能点的访问点称为端点。最常用的Web API类型是RESTful。
- en: RESTful API
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RESTful API
- en: 'A Representational State Transfer (REST) API is an API built on the following
    six principles. Four principles are a given whatever framework you use implementing
    a RESTful API, and, as a client, they should be expected:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 表示性状态转移（REST）API是基于以下六个原则构建的API。其中四个原则是无论你使用什么框架实现RESTful API，作为客户端都应该预期的：
- en: 'Client-server: A connection is made between a client and server. The client
    sends a request in order to get a response from a server.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 客户端-服务器：在客户端和服务器之间建立连接。客户端发送请求以从服务器获取响应。
- en: 'Stateless: The server will be able to process requests regardless of prior
    requests. This means that each request should contain all the information, rather
    than relying on a server to remember what happened before.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无状态：服务器将能够处理请求，而不管之前的请求。这意味着每个请求都应该包含所有信息，而不是依赖于服务器记住之前发生的事情。
- en: 'Cacheable: The ability to specify which requests can be cached using HTTP methods
    or headers.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可缓存：使用HTTP方法或头部指定哪些请求可以被缓存的特性。
- en: 'Code on demand (optional): REST allows scripts to be downloaded and executed
    on the client side. Back when the internet was made mostly of static pages, this
    was useful, but nowadays it is either not needed or is seen as a security risk.'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按需代码（可选）：REST允许脚本在客户端下载并执行。在互联网主要由静态页面组成的时候，这很有用，但现在要么不再需要，要么被视为安全风险。
- en: However, the other two principles (Client-server and Stateless) depend on you,
    and thus you will want to pay more attention to them. A layered system is a system
    made of layers, and each layer communicates only with the layer directly below
    it. A typical example of this is a three-tier architecture, where you separate
    presentation, business logic, and the data store. From a practical point of view,
    this means that a RESTful API (business logic layer) should not send HTML as a
    response because the responsibility for rendering output lies with the client
    (the presentation layer).
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，其他两个原则（客户端-服务器和无状态）取决于你，因此你将需要更加关注它们。分层系统是由层组成的系统，每一层只与直接下方的层进行通信。一个典型的例子是三层架构，其中你将表示层、业务逻辑和数据存储分开。从实际的角度来看，这意味着RESTful
    API（业务逻辑层）不应发送HTML作为响应，因为渲染输出的责任在于客户端（表示层）。
- en: 'The last principle is called a uniform interface. It defines a set of rules
    for an API:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个原则被称为统一接口。它定义了 API 的一组规则：
- en: 'Identification of resources:'
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 资源识别：
- en: Some examples of these are get all instances of a resource (`/resource`), create
    a resource (`/resource`), get a single resource (`/resource/id`), and get all
    instances of a subresource in a resource (`/resource/subresource/`).
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例包括获取资源的所有实例 (`/resource`)、创建资源 (`/resource`)、获取单个资源 (`/resource/id`) 以及获取资源中所有子资源的实例
    (`/resource/subresource/`)。
- en: 'Manipulation of resources through these representations:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过这些表示来操作资源：
- en: Resources are manipulated using HTTP verbs representing Create, Read, Update,
    and Delete (CRUD)—`GET`, `UPDATE`, `PUT`, `PATCH`, `DELETE`.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 使用表示创建、读取、更新和删除（CRUD）的 HTTP 动词来操作资源——`GET`、`UPDATE`、`PUT`、`PATCH`、`DELETE`。
- en: 'Self-descriptive messages:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 自描述消息：
- en: A response that includes all the required information, without any extra documentation,
    and indicates how the message should be processed (headers, mime type, etc.).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 包含所有必要信息且没有额外文档的响应，并指示如何处理消息（头、MIME 类型等）。
- en: 'Hypermedia as the engine of application state (HATEOAS):'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 超媒体作为应用程序状态引擎（HATEOAS）：
- en: Hyperlinks are included in response to all the related resources so that you
    can navigate to them. This guideline is usually ignored.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应中包含超链接，以便您可以导航到相关资源。此指南通常被忽略。
- en: REST is not the same as HTTP. REST is a set of guidelines, while HTTP is a protocol.
    The two might be confused because HTTP constraints heavily overlap with REST constraints
    (methods, headers, etc.). However, a RESTful API does not have to use HTTP to
    be RESTful, and at the same time HTTP can violate REST constraints by using a
    session or query parameters to provide actions to perform. A RESTful API can work
    with both XML and JSON data formats. However, almost all scenarios involve JSON.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: REST 与 HTTP 不同。REST 是一组指南，而 HTTP 是一种协议。两者可能会混淆，因为 HTTP 约束与 REST 约束（方法、头等）高度重叠。然而，RESTful
    API 不必使用 HTTP 才是 RESTful，同时 HTTP 可以通过使用会话或查询参数来执行操作而违反 REST 约束。RESTful API 可以与
    XML 和 JSON 数据格式一起工作。然而，几乎所有场景都涉及 JSON。
- en: Postman
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Postman
- en: 'Postman is one of the most popular tools used for testing different kinds of
    Web APIs. It is easy to set up and use. Postman, just like a browser, acts as
    an HTTP client. In order to download Postman, go to [https://www.postman.com/](https://www.postman.com/).
    You will need to sign up and then download the installer. Once you have installed
    Postman, perform the following steps:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 是用于测试不同类型 Web API 的最受欢迎的工具之一。它易于设置和使用。Postman 就像浏览器一样，充当 HTTP 客户端。为了下载
    Postman，请访问 [https://www.postman.com/](https://www.postman.com/)。你需要注册并下载安装程序。安装
    Postman 后，执行以下步骤：
- en: Open Postman.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Postman。
- en: Create your workspace by clicking `Workspaces` and then click on `Create Workspace`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 `Workspaces` 创建你的工作空间，然后点击 `Create Workspace`。
- en: In the new window, go to the `Collections` tab (`2`) and click the `Create new
    Collection` (`+`) button (`3`).
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，转到 `Collections` 选项卡 (`2`)，然后点击 `Create new Collection` (`+`) 按钮 (`3`)。
- en: Create a `New Collection` (`4`).
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `New Collection` (`4`)。
- en: 'Click on `Add a request` (`5`):'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Add a request` (`5`)：
- en: '![Figure 8.3: New Postman collection without requests ](img/B16835_08_03.jpg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.3：没有请求的新 Postman 收藏夹](img/B16835_08_03.jpg)'
- en: 'Figure 8.3: New Postman collection without requests'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3：没有请求的新 Postman 收藏夹
- en: A new request window will open.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 将会打开一个新的请求窗口。
- en: Click the edit symbol beside `New Request` and name the new request `Users` (`6`).
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `New Request` 旁边的编辑符号，并将新请求命名为 `Users` (`6`)。
- en: Select the `GET` HTTP verb and copy-paste the URL [https://api.github.com/users/github-user](https://api.github.com/users/github-user)
    (`7`).
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `GET` HTTP 动词，并将 URL [https://api.github.com/users/github-user](https://api.github.com/users/github-user)
    (`7`) 复制粘贴。
- en: Note
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Here, and in all places that follow, replace `github-user` with your own GitHub
    username.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此处以及随后的所有地方，将 `github-user` 替换为您的 GitHub 用户名。
- en: Click the `Send` button (`8`).
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Send` 按钮 (`8`)。
- en: 'Now scroll down to see the response result returned (`9`):'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在向下滚动查看返回的响应结果 (`9`)：
- en: '![Figure 8.4: GET GitHub user request in Postman ](img/B16835_08_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.4：Postman 中的 GET GitHub 用户请求](img/B16835_08_04.jpg)'
- en: 'Figure 8.4: GET GitHub user request in Postman'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4：Postman 中的 GET GitHub 用户请求
- en: Postman is superior to a browser when it comes to acting as an HTTP client.
    It is focused on forming HTTP requests and displays response information compactly,
    offering multiple output formats. In Postman, you can use multiple environments,
    set up pre-and post-conditions for requests, automated calls, and a lot more,
    but going through those advanced features is beyond the scope of this chapter.
    For now, it is enough to learn that Postman is a go-to tool for testing Web APIs
    by hand.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: Postman 在充当 HTTP 客户端方面优于浏览器。它专注于构建 HTTP 请求，并以紧凑的方式显示响应信息，提供多种输出格式。在 Postman
    中，您可以使用多个环境，为请求设置预条件和后条件，自动调用等，但这些高级功能超出了本章的范围。目前，只需知道 Postman 是手动测试 Web API 的首选工具即可。
- en: Client
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端
- en: REST requires communication between a client and a server. In the previous examples,
    the client role was taken by either a browser or Postman. However, neither a browser
    nor Postman can replace a client in your code. Instead, you'll need to create
    an HTTP request using C#.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: REST 需要在客户端和服务器之间进行通信。在先前的示例中，客户端角色由浏览器或 Postman 扮演。然而，浏览器或 Postman 都不能替代您代码中的客户端。相反，您需要使用
    C# 创建 HTTP 请求。
- en: Popular Web APIs often have a client created for you (in most common languages
    as well). The purpose of a Web API client is to simplify interactions with the
    underlying API. For example, instead of sending a `DELETE` request on an endpoint
    that does not support it and getting the response `Method Not Allowed`, you won't
    even have such an option on a custom client.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 流行的 Web API 通常为您创建了客户端（在大多数常用语言中也是如此）。Web API 客户端的目的在于简化与底层 API 的交互。例如，您不需要在不支持
    `DELETE` 请求的端点上发送请求并得到 `Method Not Allowed` 的响应，在自定义客户端上甚至不会有这样的选项。
- en: Octokit
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Octokit
- en: Octokit is a GitHub API client. It exposes a C# class through which you can
    pass objects to make calls to GitHub. The benefit of such a client is that you
    don't need to worry about which headers to pass or how to name things so that
    they are properly serialized. An API client handles all that for you.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: Octokit 是一个 GitHub API 客户端。它通过一个 C# 类暴露接口，您可以通过它传递对象来调用 GitHub。此类客户端的好处是您无需担心传递哪些头信息或如何命名以便它们被正确序列化。API
    客户端为您处理所有这些。
- en: 'You can install the Octokit client in your project by running the following
    command in the VS Code terminal or command prompt:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在 VS Code 终端或命令提示符中运行以下命令来在项目中安装 Octokit 客户端：
- en: '[PRE0]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Once you have the Octokit client installed, you can use it to create a GitHub
    client, as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦安装了 Octokit 客户端，您就可以使用它来创建 GitHub 客户端，如下所示：
- en: '[PRE1]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the preceding snippet, you needed a new `ProductHeaderValue` because GitHub
    expects a `UserAgent` header. As mentioned earlier, custom HTTP clients prevent
    a mistake from happening before you can even make a request. In this case, not
    providing a `UserAgent` header (through `ProductHeaderValue`) is not an option.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您需要一个新的 `ProductHeaderValue`，因为 GitHub 期望一个 `UserAgent` 头信息。如前所述，自定义
    HTTP 客户端可以防止在您甚至可以发出请求之前发生错误。在这种情况下，不提供 `UserAgent` 头信息（通过 `ProductHeaderValue`）不是一个选项。
- en: 'To see whether the client works, try to get information on the username `github-user`:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要检查客户端是否工作，尝试获取用户名 `github-user` 的信息：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In GitHub, `github-user` is displayed as `Almantask`. It is better to change
    it to your individual GitHub username for the code to work.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 上，`github-user` 显示为 `Almantask`。最好将其更改为您的个人 GitHub 用户名，以便代码能够正常工作。
- en: 'To print the date when the user was created, type the following code:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 要打印用户创建的日期，请输入以下代码：
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'You will see the following output:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 您将看到以下输出：
- en: '[PRE4]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Every method available on the GitHub API is also available on **GitHub client
    Octokit**. You don't need to worry about the endpoint, mandatory headers, a response,
    or the request format; it is all defined by the strongly typed client.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub API 上可用的每种方法在 **GitHub 客户端 Octokit** 上也同样可用。您无需担心端点、必填头信息、响应或请求格式；这一切都由强类型客户端定义。
- en: Note
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/DK2n2](https://packt.link/DK2n2).
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/DK2n2](https://packt.link/DK2n2) 找到此示例使用的代码。
- en: API Key
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: API 密钥
- en: 'With many public free APIs, you may be faced with concerns such as the following:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在许多公共免费 API 中，您可能会遇到以下担忧：
- en: How can you control an overwhelming number of requests?
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何控制大量的请求？
- en: At what point should which client be charged?
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应在何时对哪个客户端收费？
- en: If all these public APIs offered only anonymous access, you would not be able
    to identify the clients or determine how many calls each of them has made. An
    API key serves as the most basic means of authentication (identifying the client)
    and authorization (granting them access to do something with an API). Simply put,
    an API key allows you to call an API. Without it, you would have little to no
    access to an API.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果所有这些公共API只提供匿名访问，您将无法识别客户端或确定每个客户端各自调用了多少次。API密钥是基本认证（识别客户端）和授权（授予他们使用API进行某些操作的权限）的最基本手段。简单来说，API密钥允许您调用API。没有它，您将几乎没有访问API的权限。
- en: To help you grasp the use of API keys better, the next section will look at
    a Web API that requires one, that is, Azure Text Analytics.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 为了帮助您更好地掌握API密钥的使用，下一节将探讨需要API密钥的Web API，即Azure文本分析。
- en: Azure Text Analytics
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Azure文本分析
- en: 'Azure Text Analytics is an Azure API used to analyze text in the following
    ways:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: Azure文本分析是Azure API，用于以下方式分析文本：
- en: Identify named entities (people, events, organizations)
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别命名实体（人物、事件、组织）
- en: Interpret the mood of the text (positive, negative, neutral)
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释文本的情绪（积极、消极、中性）
- en: Produce a summary of a document or highlight key phrases
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 撰写文档的摘要或突出显示关键短语
- en: Process unstructured medical data, such as recognizing people, classifying diagnoses,
    and so on
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理非结构化医疗数据，例如识别人员、分类诊断等
- en: 'In order to demonstrate the Azure Text Analytics API, you will focus on sentimental
    analysis. This is the process of evaluating text according to a positive, negative,
    or neutral confidence score:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示Azure文本分析API，您将专注于情感分析。这是根据积极、消极或中立的置信度分数评估文本的过程：
- en: The score of 1, which means 100%, is the probability that the prediction (negative,
    positive, neutral) is correct.
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分为1，即100%，表示预测（消极、积极、中性）的正确概率。
- en: The score of 0, which means 0%, is an impossible prediction.
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分为0，即0%，表示不可能的预测。
- en: Note
  id: totrans-104
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Using Azure Text Analytics is free until you analyze more than 5,000 words per
    30 days.
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用Azure文本分析免费，直到您在30天内分析超过5,000个单词。
- en: Before you begin coding, you'll need to set up Azure Text Analytics on the Azure
    cloud. After all, you need both an endpoint and an API key to make a call to this
    API.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在开始编码之前，您需要在Azure云上设置Azure文本分析。毕竟，您需要一个端点和API密钥来调用此API。
- en: Note
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure you have set up an Azure subscription. If you don't have one, go to
    [https://azure.microsoft.com/en-gb/free/search](https://azure.microsoft.com/en-gb/free/search)
    and follow the instructions there to create a **free** subscription. An Azure
    free trial offers many services for free. Some of those services will remain free
    even after a year. A student subscription is an option for getting Azure credits
    and free services for a longer period. A credit or debit card is required to create
    an Azure subscription; however, you won't be charged unless you exceed the given
    Azure credits of the free service limitations.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已设置Azure订阅。如果您没有，请访问[https://azure.microsoft.com/en-gb/free/search](https://azure.microsoft.com/en-gb/free/search)，并按照那里的说明创建一个**免费**订阅。Azure免费试用提供许多免费服务。其中一些服务在一年后仍将免费。学生订阅是获取Azure信用额和更长时间免费服务的选项。创建Azure订阅需要信用卡或借记卡；然而，除非您超出免费服务的限制，否则您不会收费。
- en: 'One way in which Azure Text Analytics could be used to sort positive and negative
    feedback is by determining whether what you wrote sounds passive-aggressive or
    friendly. To see this in action, follow the steps to create a small application
    that analyzes any text you input into a console:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: Azure文本分析可以用来对积极和消极反馈进行排序的一种方式是确定您所写的内容听起来是被动攻击性的还是友好的。要查看此功能如何运作，请按照以下步骤创建一个小型应用程序，该应用程序可以分析您输入控制台中的任何文本：
- en: First, go to [https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics](https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics).
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，访问[https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics](https://portal.azure.com/#create/Microsoft.CognitiveServicesTextAnalytics)。
- en: 'Click `Continue to create your resource` without using any additional features:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击“继续创建资源”而不使用任何附加功能：
- en: '![Figure 8.5: Azure Text Analytics resource creation ](img/B16835_08_05.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图8.5：Azure文本分析资源创建](img/B16835_08_05.jpg)'
- en: 'Figure 8.5: Azure Text Analytics resource creation'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：Azure文本分析资源创建
- en: In the Create text analytics window, click the `Basics` tab. This is the first
    tab opened at the start of the creation of a new resource.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建文本分析窗口中，点击“基础”选项卡。这是创建新资源时首次打开的第一个选项卡。
- en: 'Select an option in the `Subscription` and `Resource group` fields:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`订阅`和`资源组`字段中选择一个选项：
- en: '![Figure 8.6: Entering the project details for new resource creation ](img/B16835_08_06.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图8.6：输入新资源创建的项目详情](img/B16835_08_06.jpg)'
- en: 'Figure 8.6: Entering the project details for new resource creation'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6：输入新资源创建的项目详情
- en: Then, select the region, for example, `North Europe`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择区域，例如，`北欧`。
- en: Enter the name, for example, `Packt-Test`.
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入名称，例如，`Packt-Test`。
- en: 'After that, select the `Free F0` pricing tier and click the `Review + create` button:'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 之后，选择`免费F0`定价层并点击`审查 + 创建`按钮：
- en: '![Figure 8.7: Azure Text Analytics pricing tier ](img/B16835_08_07.jpg)'
  id: totrans-121
  prefs: []
  type: TYPE_IMG
  zh: '![图8.7：Azure文本分析定价层](img/B16835_08_07.jpg)'
- en: 'Figure 8.7: Azure Text Analytics pricing tier'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：Azure文本分析定价层
- en: A new window gets displayed confirming your input.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 新窗口将显示以确认您的输入。
- en: Click the `Create` option. The Text Analytics API will start deploying. After
    the deployment of the service is done, a new window will open saying `Your deployment
    is complete`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`创建`选项。文本分析API将开始部署。服务部署完成后，将打开一个新窗口，显示`您的部署已完成`。
- en: 'Click on the `Go to resource` button:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`转到资源`按钮：
- en: '![Figure 8.8: The Text Analytics API showing the deployment as complete ](img/B16835_08_08.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图8.8：显示部署完成的文本分析API](img/B16835_08_08.jpg)'
- en: 'Figure 8.8: The Text Analytics API showing the deployment as complete'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：显示部署完成的文本分析API
- en: The Text Analytics resource window gets displayed.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 显示文本分析资源窗口。
- en: 'Click the `Keys and Endpoint` option. You will see the `Endpoint` option along
    with `KEY 1` and `KEY 2` to make calls to this API. You can choose from either
    of the keys:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`密钥和端点`选项。您将看到`端点`选项以及`KEY 1`和`KEY 2`以调用此API。您可以从任一密钥中选择：
- en: '![Figure 8.9: Azure Text Analytics quick start window with API key hyperlink
    ](img/B16835_08_09.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图8.9：带有API密钥超链接的Azure文本分析快速入门窗口](img/B16835_08_09.jpg)'
- en: 'Figure 8.9: Azure Text Analytics quick start window with API key hyperlink'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：带有API密钥超链接的Azure文本分析快速入门窗口
- en: Keep track of `KEY 1` (an API key). An API key is a secret and should not be
    exposed in plain text. You will once again be using the environment variables
    to store it.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪`KEY 1`（一个API密钥）。API密钥是秘密的，不应以纯文本形式公开。您将再次使用环境变量来存储它。
- en: 'Create an environment variable with key and value pair. The value will be the
    endpoint API key required to connect to Azure Text Analytics. To help identify
    the missing environment variable, use a helper class. The `GetOrThrow` method
    will get a user environment variable, and if it doesn''t exist, will throw an
    exception:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个键值对环境变量。值将是连接到Azure文本分析所需的端点API密钥。为了帮助识别缺失的环境变量，请使用辅助类。`GetOrThrow`方法将获取用户环境变量，如果不存在，将抛出异常：
- en: '[PRE5]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Keep track of the `Endpoint` option. You will use it in the upcoming exercise
    to call the API you have just deployed.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 跟踪`端点`选项。您将在接下来的练习中使用它来调用您刚刚部署的API。
- en: This section helped you to set up Azure Text Analytics on the Azure cloud, in
    addition to setting both an endpoint and an API key to make a call to the API.
    In the following exercise, you will be using the Azure Text Analytics client to
    make calls to the API.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 本节帮助您在Azure云上设置Azure文本分析，同时设置端点和API密钥以调用API。在接下来的练习中，您将使用Azure文本分析客户端调用API。
- en: 'Exercise 8.01: Performing Sentimental Text Analysis on Any Text'
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习8.01：对任何文本执行情感分析
- en: Azure Text Analytics is just another REST API. Once again, you make HTTP calls
    to it and get a response. This time, you will send over a text to get its sentimental
    analysis. Do another practice run of using a strongly typed client and make calls
    to a RESTful API from C#.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: Azure文本分析只是另一个REST API。再次，您向它发送HTTP请求并获取响应。这次，您将发送一段文本以获取其情感分析。再次练习使用强类型客户端从C#调用RESTful
    API。
- en: 'Using a recently deployed Azure Text Analytics service (`Pack-Test`, in this
    case), perform sentimental analysis on any text you want. Perform the following
    steps to complete this exercise:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 使用最近部署的Azure文本分析服务（在本例中为`Pack-Test`），对任何您想要的文本执行情感分析。按照以下步骤完成此练习：
- en: 'Install the `Azure.AI.TextAnalytics` NuGet package to get an Azure Text Analytics
    API client as follows:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下步骤安装`Azure.AI.TextAnalytics` NuGet包以获取Azure文本分析API客户端：
- en: '[PRE6]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Add the `TextAnalysisApiKey` environmental variable.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加`TextAnalysisApiKey`环境变量。
- en: Then add the `TextAnalysisEndpoint` environmental variable.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后添加`TextAnalysisEndpoint`环境变量。
- en: 'Create a `Demo` class and add references to the two environmental variables
    that you have recently added:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Demo` 类，并添加对最近添加的两个环境变量的引用：
- en: '[PRE7]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: These properties are used to hide sensitive values of the API key and endpoint.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 这些属性用于隐藏 API 密钥和端点的敏感值。
- en: 'Create a new `BuildClient` method to build an API client:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 `BuildClient` 方法来构建 API 客户端：
- en: '[PRE8]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The API client requires both a base URL—a kind of Unified Resource Identifier
    (URI)—and an API key to operate, both of which are passed to it during initialization.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: API 客户端需要两个操作参数：一个基础 URL——一种统一资源标识符 (URI)——和一个 API 密钥，这两个参数在初始化时传递给它。
- en: 'Using the client, create the `PerformSentimentalAnalysis` method to analyze
    the text:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用客户端，创建 `PerformSentimentalAnalysis` 方法来分析文本：
- en: '[PRE9]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Here, you are using the configuration object `AnalyzeSentimentOptions` to extract
    targets and opinions on them. The client has both the `AnalyzeSentimentAsync`
    and `AnalyzeSentiment` methods. For public client libraries, exposing both async
    and non-async versions of the same method is a very common scenario. After all,
    not everyone will be comfortable with an async API. However, when making calls
    to another machine (DB, API, and similar) it's best to use an async API. This
    is because an async call will not block the thread on which the call is made while
    it is waiting for a response from an API.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在使用配置对象 `AnalyzeSentimentOptions` 提取目标和对其的意见。客户端既有 `AnalyzeSentimentAsync`
    方法，也有 `AnalyzeSentiment` 方法。对于公共客户端库，公开相同方法的异步和非异步版本是一个非常常见的场景。毕竟，并不是每个人都会对异步
    API 感到舒适。然而，当调用另一台机器（数据库、API 等）时，最好使用异步 API。这是因为异步调用在等待 API 响应时不会阻塞调用线程。
- en: 'Now create a `DisplaySentenceSymmary` function to display the sentence''s overall
    evaluation:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个 `DisplaySentenceSymmary` 函数来显示句子的整体评估：
- en: '[PRE10]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Create a `DisplaySentenceOpinions` function to display the message `Opinions`
    for every target in a sentence:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `DisplaySentenceOpinions` 函数，用于在句子中的每个目标上显示消息 `Opinions`：
- en: '[PRE11]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The target of a sentence is a subject that has an opinion (grammatical modifier)
    applied to it. For example, with the sentence, **a beautiful day**, **day** would
    be a target and **beautiful** an opinion.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 句子的目标是应用了意见（语法修饰符）的主题。例如，在句子 **a beautiful day** 中，**day** 是目标，**beautiful**
    是意见。
- en: 'To perform a sentimental analysis on text typed in a console, create a `SentimentAnalysisExample`
    method:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在控制台中输入的文本上执行情感分析，创建 `SentimentAnalysisExample` 方法：
- en: '[PRE12]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The analysis text, in the preceding code snippet, evaluates the overall text's
    sentiment and then breaks it down into sentences, evaluating each.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，分析文本评估整体文本的情感，然后将其分解成句子，并对每个句子进行评估。
- en: 'To demonstrate how your code works, create a static `Demo.Run` method:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示你的代码如何工作，创建一个静态的 `Demo.Run` 方法：
- en: '[PRE13]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'With the environment variable set correctly, the following output should be displayed:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置正确的环境变量后，以下输出应该被显示：
- en: '[PRE14]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: You did not hardcode the value of an API key here because an API key, exposed
    publicly, poses a risk of being used not the way it was intended to. If stolen,
    it could have disastrous consequences (for example, being overused, creating a
    false resource, leaking data, deleting data, etc.). That is why when dealing with
    secrets, use the minimal possible countermeasures, that is, environmental variables.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里没有硬编码 API 密钥的值，因为公开的 API 密钥可能会被不当使用，如果被盗用，可能会产生灾难性的后果（例如，过度使用、创建虚假资源、数据泄露、删除数据等）。这就是为什么在处理机密信息时，应使用尽可能少的防护措施，即环境变量。
- en: Another benefit of environment variables is the ability to have a different
    value in different environments (local, integration, system test, production,
    etc.). Different environments often use different resources. So, pointing to those
    resources through environment variables will not require any changes to the code.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 环境变量的另一个好处是能够在不同的环境中具有不同的值（本地、集成、系统测试、生产等）。不同的环境通常使用不同的资源。因此，通过环境变量指向这些资源不需要对代码进行任何更改。
- en: In order to run this exercise, go to [https://packt.link/GR27A](https://packt.link/GR27A)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `await Exercises.Exercise01.Demo.Run();`. Similarly, uncomment the respective
    exercises'/examples'/activities' code lines in `Program.cs` before executing each
    of them.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行这个练习，请访问 [https://packt.link/GR27A](https://packt.link/GR27A) 并注释掉 `static
    void Main(string[] args)` 方法体内的所有行，除了 `await Exercises.Exercise01.Demo.Run();`。同样，在执行每个练习/示例/活动之前，取消注释
    `Program.cs` 中的相应练习/示例/活动代码行。
- en: Note
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/y1Bqy](https://packt.link/y1Bqy).
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/y1Bqy](https://packt.link/y1Bqy)找到用于此练习的代码。
- en: This exercise is just one of the many in which you consumed a public Web API.
    Azure is full of services like this. Calling an API using a strongly typed client
    is simple; however, not all APIs have one. In the next section, you will learn
    how to create your own Web API client.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 这项练习只是您消费公共Web API的许多练习之一。Azure充满了这样的服务。使用强类型客户端调用API很简单；然而，并非所有API都有。在下一节中，您将学习如何创建自己的Web
    API客户端。
- en: Your Own Client
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 您自己的客户端
- en: So far, you've only used a premade client to consume a Web API. However, for
    less popular APIs, there will not be any client for you to use. In those cases,
    you will have to make HTTP calls yourself. In .NET, the way of making calls has
    evolved quite a lot. If you don't want any third-party libraries, you can use
    the `HttpClient` class.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您只使用预制的客户端来消费Web API。然而，对于不太受欢迎的API，可能没有可用的客户端。在这种情况下，您将不得不自己进行HTTP调用。在.NET中，进行调用的方式已经发生了很大的变化。如果您不想使用任何第三方库，您可以使用`HttpClient`类。
- en: HttpClient
  id: totrans-173
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HttpClient
- en: 'In this section, you''ll repeat the GitHub `Users` example (from the *Postman*
    section), but this time using `HttpClient`. The flow for this is quite simple
    and is described for you in detail in the following example:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将重复GitHub `Users`示例（来自*Postman*部分），但这次使用`HttpClient`。这个流程相当简单，以下示例将为您详细描述：
- en: 'Within the `GitHttp` static class, create the `GetUser` method:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GitHttp`静态类中，创建`GetUser`方法：
- en: '[PRE15]'
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Within the `GitExamples` method, first, create a client:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GitExamples`方法中，首先创建一个客户端：
- en: '[PRE16]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Creating a client almost always involves specifying a specific base URL. Often,
    Web APIs require mandatory headers to be passed, or else they will invalidate
    the request (`400 Bad Request`). For GitHub, you need to send the `User-Agent`
    header identifying the client that calls the API. Adding the `Packt` user agent
    header to default headers will send that header with every request to the client.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 创建客户端几乎总是涉及指定特定的基本URL。通常，Web API需要传递强制性的头信息，否则它们将使请求无效（`400 Bad Request`）。对于GitHub，您需要发送标识调用API的客户端的`User-Agent`头信息。将`Packt`用户代理头信息添加到默认头信息中，将使该头信息随每个请求发送到客户端。
- en: 'You then create a request as follows:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后按照以下方式创建一个请求：
- en: '[PRE17]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Remember to replace `github-user` with your own GitHub username. Here, you've
    specified that you want to create a `GET` request. You did not specify a full
    path, but rather only the endpoint you want to hit; therefore, you had to flag
    `UriKind` as `Relative`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 记得将`github-user`替换为您自己的GitHub用户名。在这里，您指定了您想要创建一个`GET`请求。您没有指定完整的路径，而是只指定了您想要触发的端点；因此，您必须将`UriKind`标记为`Relative`。
- en: 'Next, send a request using the client:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，使用客户端发送请求：
- en: '[PRE18]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: There is only an async version of sending an HTTP request message, so you need
    to wait for it. The result of sending `HttpRequestMessage` is `HttpResponseMessage`.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 发送HTTP请求消息只有一个异步版本，因此您需要等待它。发送`HttpRequestMessage`的结果是`HttpResponseMessage`。
- en: 'Then, deserialize the content to a usable object as follows:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，按照以下方式将内容反序列化为可用的对象：
- en: '[PRE19]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Deserializing is the act of converting a structured text such as JSON into
    in-memory objects. For this, you need to convert the content to a string and then
    deserialize it. You could use a user model from Octokit NuGet. Since you are already
    making custom calls, you might as well use a custom model. For the bare minimum
    (only the fields you use), your model could look like this:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 反序列化是将结构化文本（如JSON）转换为内存中对象的过程。为此，您需要将内容转换为字符串，然后进行反序列化。您可以使用来自Octokit NuGet的用户模型。由于您已经在进行自定义调用，您也可以使用自定义模型。对于最基本的情况（仅使用到的字段），您的模型可能看起来像这样：
- en: '[PRE20]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: The line `[JsonProperty("created_at")]`, above `public DateTime CreatedAt {
    get; set; }`, binds the JSON field to the C# property. This binding is needed
    because the names don't match.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在`public DateTime CreatedAt { get; set; }`之上，行`[JsonProperty("created_at")]`将JSON字段绑定到C#属性。这种绑定是必要的，因为名称不匹配。
- en: If you want to create your own client (for making GitHub calls), it's your responsibility
    to expose all data that the API returns and not just the data you may need for
    a particular scenario by letting the consumer choose.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想创建自己的客户端（用于进行GitHub调用），您有责任公开API返回的所有数据，而不仅仅是特定场景下可能需要的数据，让消费者进行选择。
- en: 'Use the message from a previous call from Postman to get the GitHub user response
    body to generate models to deserialize to. In this case, the response message
    is as follows (message truncated for clarity):'
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用Postman之前的调用消息来获取GitHub用户响应体以生成要反序列化的模型。在这种情况下，响应消息如下（消息为了清晰而截断）：
- en: '[PRE21]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: There are many tools available that can convert JSON to the C# model.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 有许多工具可以将JSON转换为C#模型。
- en: In this case, use [https://json2csharp.com/](https://json2csharp.com/) to convert
    JSON to the C# model code.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这种情况下，使用[https://json2csharp.com/](https://json2csharp.com/)将JSON转换为C#模型代码。
- en: Copy the response (`GET github/user`) and go to [https://json2csharp.com/](https://json2csharp.com/).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制响应（`GET github/user`）并转到[https://json2csharp.com/](https://json2csharp.com/)。
- en: 'Paste the response into the textbox on the left and click the `Convert` button:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将响应粘贴到左侧的文本框中，然后点击`Convert`按钮：
- en: '![Figure 8.10: Converting JSON to the C# model code ](img/B16835_08_10.jpg)'
  id: totrans-198
  prefs: []
  type: TYPE_IMG
  zh: '![图8.10：将JSON转换为C#模型代码](img/B16835_08_10.jpg)'
- en: 'Figure 8.10: Converting JSON to the C# model code'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：将JSON转换为C#模型代码
- en: The left side displays a model for the JSON, while the right side displays the
    code (C# class) that is generated from JSON.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧显示JSON的模型，而右侧显示从JSON生成的代码（C#类）。
- en: 'Copy the content on the right and paste it into your code:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将右侧的内容复制并粘贴到你的代码中：
- en: '[PRE22]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is your model. Observe in the preceding code that `Root` is an unreadable
    class name. This is because the converter didn't have a way to know what class
    JSON represents. The `Root` class represents a user; therefore, rename it `User`.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是你的模型。在前面的代码中观察，`Root`是一个不可读的类名。这是因为转换器没有方法知道JSON代表什么类。`Root`类代表一个用户；因此，将其重命名为`User`。
- en: 'Lastly, the converter was probably created prior to .NET 5, which is why it
    didn''t have a feature for records. A record is a great class for serialization
    purposes and a great candidate for a data transfer object (DTO). A DTO is a class
    that has no logic but simply data, and sometimes attributes for binding serialization.
    The benefits you get are the following:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，转换器可能是在.NET 5之前创建的，这就是为什么它没有记录功能。记录是一个用于序列化的优秀类，也是数据传输对象（DTO）的优秀候选者。DTO是一个没有逻辑但仅包含数据，有时还包含用于绑定序列化的属性的类。你获得的好处如下：
- en: Value equality
  id: totrans-205
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 值相等
- en: '`ToString` will return properties and their values'
  id: totrans-206
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ToString`将返回属性及其值'
- en: The ability to define them with a less verbose syntax
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 能够用更简洁的语法定义它们
- en: So, use a record for defining DTOs in your applications whenever possible.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽可能在你的应用程序中使用记录来定义DTO。
- en: 'Rename the (`Root` to `User`) and change the type from `class` to `record`.
    The code line looks like this with no changes needed to the properties:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将（`Root`重命名为`User`）并将类型从`class`更改为`record`。代码行看起来如下，不需要对属性进行任何更改：
- en: '[PRE23]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Finally, run the following line of code:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行以下代码行：
- en: '[PRE24]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The output gets displayed as follows:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 输出显示如下：
- en: '[PRE25]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: In order to run this exercise, go to [https://packt.link/GR27A](https://packt.link/GR27A)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `await Examples.GitHttp.Demo.Run();`. Similarly, uncomment the respective exercises'/examples'/activities'
    code lines in `Program.cs` before execution.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此练习，请访问[https://packt.link/GR27A](https://packt.link/GR27A)并注释掉`static void
    Main(string[] args)`体内的所有行，除了`await Examples.GitHttp.Demo.Run();`。同样，在执行之前，取消注释`Program.cs`中的相应练习/示例/活动的代码行。
- en: Note
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/UPxmW](https://packt.link/UPxmW).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/UPxmW](https://packt.link/UPxmW)找到用于此示例的代码。
- en: Now that you have seen the benefits of using the `HttpClient` class in lieu
    of third-party libraries, you can now explore the `IDisposable` pattern in the
    following section.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了使用`HttpClient`类代替第三方库的好处，你可以在下一节探索`IDisposable`模式。
- en: HttpClient and IDisposable
  id: totrans-219
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: HttpClient和IDisposable
- en: '`HttpClient` implements the `IDisposable` pattern. In general, right after
    you are done using an object that implements `IDisposable`, you should clean up
    and call the `Dispose` method or wrap the calls within a `using` block. However,
    `HttpClient` is special in that you should not frequently create and dispose of
    it all over again. The problem with disposing and re-initializing `HttpClient`
    is that `HttpClient` manages connections it makes to other APIs and disposing
    of `HttpClient` does not properly close those connections (or sockets).'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient` 实现了 `IDisposable` 模式。一般来说，在你完成使用实现 `IDisposable` 的对象后，你应该清理并调用
    `Dispose` 方法，或者将调用封装在一个 `using` 块中。然而，`HttpClient` 是特殊的，你不应该频繁地创建和销毁它。销毁和重新初始化
    `HttpClient` 的问题在于 `HttpClient` 管理它与其他 API 建立的连接，销毁 `HttpClient` 并没有正确关闭这些连接（或套接字）。'
- en: The most dangerous part about that is that you will not notice any difference
    in developing your application locally, due to the massive number of connections
    available. However, when deploying an application to a live environment, you risk
    running out of free socket connections. Once again, avoid calling a `Dispose`
    method and reinitializing `HttpClient`. If you must, use `HttpClientFactory`.
    Not only does `HttpClientFactory` manage the lifetime of socket connections by
    managing `HttpClientMessageHandler` (the component responsible for sending the
    HTTP request and receiving the response) but it also provides logging capability,
    allows centralized management of clients' configuration, supports injecting middleware
    to clients, etc. The mentioned benefits are important if you use `HttpClient`
    in an enterprise setting. You can learn more about `HttpClientFactory` in *Chapter
    9*, *Creating API Services*.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 最危险的部分是，由于可用的连接数量巨大，你在本地开发应用程序时不会注意到任何差异。然而，当将应用程序部署到生产环境时，你可能会耗尽免费的套接字连接。再一次，避免调用
    `Dispose` 方法并重新初始化 `HttpClient`。如果你必须这样做，请使用 `HttpClientFactory`。不仅 `HttpClientFactory`
    通过管理 `HttpClientMessageHandler`（负责发送 HTTP 请求和接收响应的组件）来管理套接字连接的生存期，它还提供了日志记录功能，允许集中管理客户端的配置，支持向客户端注入中间件等。如果你在企业环境中使用
    `HttpClient`，这些提到的优势很重要。你可以在 *第 9 章*，*创建 API 服务* 中了解更多关于 `HttpClientFactory` 的信息。
- en: Ideally, you should have one static `HttpClient`, which you can reuse for calls
    to Web APIs throughout your application. However, you should not have a single
    `HttpClient` for everything. The point about not disposing of `HttpClient` and
    having a static one is not a hard rule. If you call many different APIs, they
    will have their own base addresses, mandatory headers, and so on. Having a single
    object for all is not a viable scenario.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，你应该有一个静态的 `HttpClient`，你可以在整个应用程序中重复使用它来调用 Web API。然而，你不应该为所有事情使用单个 `HttpClient`。关于不销毁
    `HttpClient` 并拥有一个静态的并不是一个硬性规则。如果你调用许多不同的 API，它们将有自己的基本地址、强制头等信息。为所有这些拥有一个单一的对象不是一个可行的场景。
- en: The requests you've handled so far were publicly accessible and did not have
    security. However, expensive or private operations in Web APIs are usually protected.
    Typically, protection is set up using an Authorization header. In many cases,
    an Authorization header involves some sort of an ID and secret. In the case of
    the GitHub API, it involves a client ID and client secret. But to get them, you
    will need to create an OAuth app.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你迄今为止处理过的请求是公开可访问的，并且没有安全性。然而，Web API 中的昂贵或私有操作通常受到保护。通常，保护是通过设置一个授权头来实现的。在许多情况下，授权头涉及某种形式的
    ID 和密钥。在 GitHub API 的情况下，它涉及客户端 ID 和客户端密钥。但是，要获取它们，你需要创建一个 OAuth 应用。
- en: Before you can do this though, you need to get familiar with OAuth.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够这样做之前，你需要熟悉 OAuth。
- en: OAuth
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: OAuth
- en: 'OAuth is an open-standard authorization protocol that allows delegating access
    on behalf of a user. This section will explore two examples:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth 是一种开放标准的授权协议，允许代表用户委托访问。本节将探讨两个示例：
- en: Real-life analogy
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 生活中的类比
- en: API analogy
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: API 类比
- en: Real-life Analogy
  id: totrans-229
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 生活中的类比
- en: 'Imagine a child at school. The teacher of that child is organizing a trip to
    another city. A permission slip from the parents is needed. The parents give a
    note: *It''s okay for my child to go to place X.* The child gives the note to
    the teacher and gets permission to travel to a field trip to destination X.'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一个在学校的孩子。那位孩子的老师正在组织去另一个城市的旅行。需要家长提供一份同意书。家长写了一张便条：*我的孩子可以去地方X，没有问题。* 孩子把便条交给老师，并获得前往目的地X的郊游许可。
- en: API Analogy
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API 类比
- en: Many applications are interconnected, with integrations to each other. For example,
    the famous social platform Discord allows you to display whatever accounts you
    have on other social media. But to do that, you need to connect to the platform
    of social media you want to display. For example, when you are on Discord and
    try to link a Twitter account, you will be required to log in on Twitter. A login
    will require a certain scope of access (your profile name, in this case). A successful
    login is proof that access is given, and Discord will be able to display your
    profile information on Twitter on your behalf.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 许多应用程序相互连接，彼此之间有集成。例如，著名的社交平台Discord允许您显示您在其他社交媒体上的任何账户。但要做到这一点，您需要连接到您想要显示的社交媒体平台。例如，当您在Discord上并尝试链接一个Twitter账户时，您将需要在Twitter上登录。登录需要一定的访问范围（在这种情况下是您的个人资料名称）。成功的登录是授予访问权限的证明，Discord将能够代表您在Twitter上显示您的个人资料信息。
- en: OAuth App for GitHub
  id: totrans-233
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GitHub OAuth应用程序
- en: Returning to the subject of GitHub, what is an OAuth app? It is a registration
    for a single point of security. It acts as your application identity. A GitHub
    user might have zero or more applications. As mentioned before, an OAuth app includes
    a client ID and secret. Through them, you can use the GitHub API. In other words,
    you can set it up to request access to secure features of GitHub, such as changing
    your personal data on GitHub.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到GitHub的主题，OAuth应用程序是什么？它是一个单一安全点的注册。它充当您的应用程序身份。GitHub用户可能有零个或多个应用程序。如前所述，OAuth应用程序包括客户端ID和密钥。通过它们，您可以使用GitHub
    API。换句话说，您可以设置它来请求访问GitHub的安全功能，例如更改您在GitHub上的个人数据。
- en: GitHub has an interesting API limitation. If more than 60 unauthenticated requests
    come from the same IP, it will block subsequent requests for up to an hour. However,
    the rate limitation can be removed by authorizing requests. That is the prime
    reason why you will be using authorization for an otherwise public endpoint.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub有一个有趣的API限制。如果来自同一IP的未认证请求超过60个，它将阻止长达一小时的后续请求。然而，通过授权请求可以移除速率限制。这就是您将使用授权来访问其他情况下公开端点的主要原因。
- en: 'OAuth usually involves two client applications:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: OAuth通常涉及两个客户端应用程序：
- en: One that requests permission on behalf of someone
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代表某人请求权限的应用
- en: Another that grants that permission
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一个授予该权限的应用
- en: 'Therefore, when setting up OAuth, you will most likely be required to create
    a URL to return to after the permission is granted from the client that can grant
    access. Setting up an OAuth app on GitHub involves these steps:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在设置OAuth时，您很可能会被要求创建一个URL，在客户端授予访问权限后返回。在GitHub上设置OAuth应用程序涉及以下步骤：
- en: 'In the top-right corner, click on your profile picture and click `Settings`:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在右上角，点击您的个人资料图片并点击`设置`：
- en: '![Figure 8.11: Account settings in GitHub ](img/B16835_08_11.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_IMG
  zh: '![图8.11：GitHub中的账户设置](img/B16835_08_11.jpg)'
- en: 'Figure 8.11: Account settings in GitHub'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：GitHub中的账户设置
- en: 'On the left side, scroll down almost to the bottom of the menu and click the
    `Developer settings` option:'
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧，向下滚动菜单直到接近底部，然后点击`开发者设置`选项：
- en: '![Figure 8.12: Developer settings in GitHub ](img/B16835_08_12.jpg)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图8.12：GitHub中的开发者设置](img/B16835_08_12.jpg)'
- en: 'Figure 8.12: Developer settings in GitHub'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12：GitHub中的开发者设置
- en: 'Now select the `Oauth Apps` option:'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在选择`OAuth应用程序`选项：
- en: '![Figure 8.13: Selecting OAuth apps in Developer settings in GitHub ](img/B16835_08_13.jpg)'
  id: totrans-247
  prefs: []
  type: TYPE_IMG
  zh: '![图8.13：在GitHub开发者设置中选择OAuth应用程序](img/B16835_08_13.jpg)'
- en: 'Figure 8.13: Selecting OAuth apps in Developer settings in GitHub'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.13：在GitHub开发者设置中选择OAuth应用程序
- en: 'Then click the `Register a new application` button:'
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后点击`注册新应用程序`按钮：
- en: '![Figure 8.14: Creating a new OAuth app in GitHub ](img/B16835_08_14.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![图8.14：在GitHub中创建新的OAuth应用程序](img/B16835_08_14.jpg)'
- en: 'Figure 8.14: Creating a new OAuth app in GitHub'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14：在GitHub中创建新的OAuth应用程序
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you have previously created an OAuth app, then this window will display all
    those listed. In order to create a new one, you will have to click `New OAuth
    App`.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您之前已创建OAuth应用程序，则此窗口将显示所有列出的应用程序。为了创建一个新的，您将必须点击`新建OAuth应用程序`。
- en: In the next window, you will complete the form. Start by filling in `Application
    name` (`5`). Avoid using special characters.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一个窗口中，您将完成表格。首先填写`应用程序名称`（`5`）。避免使用特殊字符。
- en: Next, fill in `Homepage URL` (`6`).
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，填写`主页URL`（`6`）。
- en: This URL usually points to a website that describes the use of OAuth for a particular
    case and why it is required. Even if you don't have a website that describes such
    a case, you can type a placeholder URL (in this case, `myapp.com`). The field
    accepts anything as long as it is a valid URL.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这个URL通常指向一个网站，该网站描述了特定情况下OAuth的使用以及为什么需要它。即使你没有描述此类情况的网站，你也可以输入一个占位符URL（在这个例子中，是`myapp.com`）。只要是一个有效的URL，这个字段就接受任何内容。
- en: Fill in the `Authorization callback URL` (`7`) field. This can be whatever you
    want. Here, `myapp.com/home` is used. Use a valid callback URL.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 填写`授权回调URL`（`7`）字段。这可以是任何你想要的内容。这里使用的是`myapp.com/home`。使用一个有效的回调URL。
- en: 'Click `Register application` (`8`):![Figure 8.15: New OAuth app window in GitHub
    ](img/B16835_08_15.jpg)'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`注册应用`（`8`）![图8.15：GitHub中的新OAuth应用窗口](img/B16835_08_15.jpg)
- en: 'Figure 8.15: New OAuth app window in GitHub'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15：GitHub中的新OAuth应用窗口
- en: 'In the new window, you will see `Client ID` and `Client secrets`:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，你会看到`Client ID`和`Client secrets`：
- en: '![Figure 8.16: Details of a new OAuth app on GitHub with app  credentials—Client
    ID and Client secrets ](img/B16835_08_16.jpg)'
  id: totrans-261
  prefs: []
  type: TYPE_IMG
  zh: '![图8.16：GitHub上新的OAuth应用详情，包括应用凭据—Client ID和Client secrets](img/B16835_08_16.jpg)'
- en: 'Figure 8.16: Details of a new OAuth app on GitHub with app credentials—Client
    ID and Client secrets'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16：GitHub上新的OAuth应用详情，包括应用凭据—Client ID和Client secrets
- en: It is best to store a client secret in a safe place for future reference because
    you will see it only once on GitHub. If you forget it, you will have to create
    a new secret and delete the old one.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 最好将客户端密钥存储在一个安全的地方以供将来参考，因为你只会在GitHub上看到它一次。如果你忘记了它，你将不得不创建一个新的密钥并删除旧的密钥。
- en: Now you have successfully created an OAuth app on GitHub. The client secret
    is partly hidden in this screenshot for a reason. You should never expose it publicly.
    In order to use it in a demo, you will use environmental variables first to hide
    them.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经在GitHub上成功创建了一个OAuth应用。客户端密钥在这张截图中被部分隐藏，这是出于一个原因。你永远不应该公开它。为了在演示中使用它，你将首先使用环境变量来隐藏它们。
- en: So, store the values in environmental variables `GithubClientId` and `GithubSecret`.
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 因此，将这些值存储在环境变量`GithubClientId`和`GithubSecret`中。
- en: 'Then expose the two through static properties in `Demo.cs` (explained earlier)
    as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后在`Demo.cs`中的静态属性中公开这两个属性（前面已解释）如下：
- en: '[PRE26]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This section covered the steps to set up an OAuth app in GitHub that can be
    used to request access to secure features of GitHub, such as changing your personal
    data. With this knowledge, you can now use a client ID and client secret to create
    authorized calls on the GitHub API, as demonstrated in the following section.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了在GitHub上设置OAuth应用的步骤，该应用可以用来请求访问GitHub的安全功能，例如更改你的个人数据。有了这些知识，你现在可以使用客户端ID和客户端密钥在GitHub
    API上创建授权调用，如下节所示。
- en: Authorization Header
  id: totrans-269
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 授权头
- en: Authorization headers come in three forms—basic, API key (or personal access
    token), and third-party authentication. The GitHub API does not allow an unlimited
    number of calls from the same source. Like the Azure Text Analytics client, it
    uses an API key as well. However, in this case, the API key is used for rate limiting
    (how many calls you can make in an hour). For anonymous calls, it only allows
    60 calls an hour. However, by using a valid Authorization header, the amount is
    increased to 5,000.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 授权头有三种形式——基本、API密钥（或个人访问令牌）和第三方身份验证。GitHub API不允许来自同一来源的无限制调用。就像Azure Text Analytics客户端一样，它也使用API密钥。然而，在这种情况下，API密钥用于速率限制（你每小时可以调用多少次）。对于匿名调用，它每小时只允许60次调用。但是，通过使用有效的授权头，这个数量可以增加到5,000。
- en: 'In the following example, you''ll make one more call than the rate limit allows
    (60 + 1 = 61). That way, you will get user information 61 times. For that to happen,
    you will also make sure that the `CacheControl` header is set to `NoCache` because
    you don''t want a request to be ignored after 60 consecutive calls:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的示例中，你将比速率限制允许的次数多调用一次（60 + 1 = 61）。这样，你将获取61次用户信息。为了实现这一点，你还需要确保将`CacheControl`头设置为`NoCache`，因为你不希望在60次连续调用后忽略请求：
- en: '[PRE27]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'This block of code is an adaptation of the `GetUser` method from the *HttpClient*
    section. There are three main adjustments here:'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码是对*HttpClient*部分中的`GetUser`方法的改编。这里主要有三个调整：
- en: The first is that everything in a loop runs 61 times.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一个调整是循环中的所有内容都运行61次。
- en: You have also added an error handler, which means if a response is not a success,
    you will print an error message returned by the API.
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你还添加了一个错误处理器，这意味着如果响应不是成功的，你将打印出API返回的错误信息。
- en: Lastly, you add a `CacheControl` header to ignore caching (because you do want
    61 calls to the server).
  id: totrans-276
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，你添加一个 `CacheControl` 头来忽略缓存（因为你确实希望有 61 次调用服务器）。
- en: 'Running this code results in an error message on the sixty-first call, which
    proves the API rate limitation (the error message has been truncated for clarity):'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码在第 61 次调用时会产生错误信息，这证明了 API 速率限制（错误信息已被截断以清晰显示）：
- en: '[PRE28]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'To fix this, you will need to add an `Authorization` header (you will add it
    just under the `CacheControl` header):'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 为了修复这个问题，你需要添加一个 `Authorization` 头（你将在 `CacheControl` 头下面添加它）：
- en: '[PRE29]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Due to GitHub's limitations on anonymous calls (for example, the fact that you
    can make only 60 requests per hour to get user profile information), you will
    find it more efficient to provide an Authorization header so that you are identified
    and therefore released from such strict constraints. In the examples that follow,
    you will get an authorization token that you will feed to this method, thus showing
    how authorization will help you overcome the rate limit.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 GitHub 对匿名调用有限制（例如，每小时只能进行 60 次请求以获取用户配置文件信息），你会发现提供授权头以识别自己并因此摆脱这种严格限制会更有效率。在接下来的示例中，你将获取一个授权令牌，并将其提供给此方法，从而展示授权如何帮助你克服速率限制。
- en: When running the demo code placed at [https://packt.link/Uz2BL](https://packt.link/Uz2BL),
    it is recommended that you run one example at a time (i.e., uncomment one line
    and comment the rest within the `Run` method). This is because the `Demo.cs` file
    is a mix of authorized and anonymous calls, and you might get unexpected results.
    However, keep the line where you get a token as it may be required by individual
    examples.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 当运行放置在 [https://packt.link/Uz2BL](https://packt.link/Uz2BL) 的演示代码时，建议你一次运行一个示例（即，取消注释一行，并在
    `Run` 方法中注释掉其余行）。这是因为 `Demo.cs` 文件是授权和匿名调用的混合，你可能会得到意外的结果。但是，保留获取令牌的行，因为它可能被个别示例所需要。
- en: At the end of this section, you should have grasped the logic behind the Authorization
    header and its three forms—basic, API key (or personal access token), and third-party
    authentication—and learned that, like the Azure Text Analytics client, the GitHub
    API uses an API key. Now you can move on to basic authentication.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节结束时，你应该已经掌握了授权头背后的逻辑及其三种形式——基本认证、API 密钥（或个人访问令牌）和第三方认证——并且了解到，与 Azure 文本分析客户端一样，GitHub
    API 使用 API 密钥。现在你可以继续学习基本认证。
- en: Basic Authentication
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本认证
- en: 'Basic authentication involves a username and password. The two are usually
    combined in a single string and encoded using the following format:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 基本认证涉及用户名和密码。这两个通常组合成一个字符串，并使用以下格式进行编码：
- en: '[PRE30]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Here is the code used to generate an authorization taken for basic authentication:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是用于生成基本认证授权令牌的代码：
- en: '[PRE31]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Use a username and password to get a basic token. Then pass it to the `GetUser61Times`
    method:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 使用用户名和密码获取基本令牌。然后将它传递给 `GetUser61Times` 方法：
- en: '[PRE32]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Calling `GetUser61Times` no longer displays an error because the rate limitation
    is avoided by supplying an Authorization header.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 调用 `GetUser61Times` 时不再显示错误，因为通过提供授权头避免了速率限制。
- en: Note
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/Uz2BL](https://packt.link/Uz2BL)
    and [https://packt.link/UPxmW](https://packt.link/UPxmW).
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/Uz2BL](https://packt.link/Uz2BL) 和 [https://packt.link/UPxmW](https://packt.link/UPxmW)
    找到用于此示例的代码。
- en: The next section will cover the more specialized API key and personal access
    token, which are similar as they both grant access to otherwise protected data.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将介绍更专业的 API 密钥和个人访问令牌，它们很相似，因为它们都提供了访问受保护数据的权限。
- en: API Key and Personal Access Token
  id: totrans-295
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: API 密钥和个人访问令牌
- en: A personal access token is limited to personal data. However, an API key can
    be used for the whole API. Other than the scope of what can be accessed, the two
    have no difference in how they are used. You can add an API key or a personal
    access token to an Authorization header as is.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 个人访问令牌仅限于个人数据。然而，API 密钥可以用于整个 API。除了可以访问的范围外，两者在使用方式上没有区别。你可以像这样将 API 密钥或个人访问令牌添加到授权头中。
- en: 'But, of course, to use an access token of a certain API, you first need to
    create it. You can do this through the following steps:'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 但是，当然，要使用某个 API 的访问令牌，你首先需要创建它。你可以通过以下步骤完成：
- en: Go to GitHub's `Developer settings` option under `Settings` window.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“设置”窗口下，前往 GitHub 的“开发者设置”选项。
- en: Navigate to `Personal access tokens` (`1`).
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到“个人访问令牌”（`1`）。
- en: 'Select `Generate new token` button (`2`):'
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择“生成新令牌”按钮（`2`）：
- en: '![Figure 8.17: Creating a new personal access token ](img/B16835_08_17.jpg)'
  id: totrans-301
  prefs: []
  type: TYPE_IMG
  zh: '![图8.17：创建新的个人访问令牌](img/B16835_08_17.jpg)'
- en: 'Figure 8.17: Creating a new personal access token'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17：创建新的个人访问令牌
- en: Next, enter your GitHub password.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，输入您的GitHub密码。
- en: Add a note (this can be anything) and scroll down. This screen will help you
    to modify user data, so check the `user` checkbox (`4`) to get access to it.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个备注（这可以是任何内容）并向下滚动。此屏幕将帮助您修改用户数据，因此请勾选`user`复选框（`4`）以获取访问权限。
- en: 'Click the `Generate token` button (`5`):'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击`Generate token`按钮（`5`）：
- en: '![Figure 8.18: Scope of access configured for a personal access token ](img/B16835_08_18.jpg)'
  id: totrans-306
  prefs: []
  type: TYPE_IMG
  zh: '![图8.18：为个人访问令牌配置的访问范围](img/B16835_08_18.jpg)'
- en: 'Figure 8.18: Scope of access configured for a personal access token'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.18：为个人访问令牌配置的访问范围
- en: 'In the new window, you will see all the personal access tokens, along with
    the newly added ones:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在新窗口中，您将看到所有个人访问令牌，包括新添加的：
- en: '![Figure 8.19: A new personal access token created on GitHub ](img/B16835_08_19.jpg)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图8.19：在GitHub上创建的新个人访问令牌](img/B16835_08_19.jpg)'
- en: 'Figure 8.19: A new personal access token created on GitHub'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19：在GitHub上创建的新个人访问令牌
- en: Note
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Remember that you will see the value of a token only once. So, make sure you
    copy and store it securely. Also, be aware that the personal access token expires
    after a month, at which point you need to regenerate it.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，您只能看到令牌值一次。因此，请确保您将其安全地复制并存储。此外，请注意，个人访问令牌在一个月后过期，此时您需要重新生成它。
- en: Create an environmental variable called `GitHubPersonalAccess`.
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`GitHubPersonalAccess`的环境变量。
- en: 'Add the personal access token to `Demo.cs`:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将个人访问令牌添加到`Demo.cs`中：
- en: '[PRE33]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Run the following code:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行以下代码：
- en: '[PRE34]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: You will observe that calling the `GetUser61Times` method does not fail.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 您将观察到调用`GetUser61Times`方法不会失败。
- en: Access tokens, authorization tokens, API keys, and JWTs (which will be further
    covered in the following sections) are different means to prove to an API that
    you have been granted access to it and have rights to a resource you want. But
    regardless of which specific kind of authorization you use, they will usually
    all go to the same place—that is, the Authorization header.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 访问令牌、授权令牌、API密钥和JWT（将在以下章节中进一步介绍）是向API证明您已被授予访问权限并有权访问您想要资源的不同方式。但无论您使用哪种具体的授权方式，它们通常都会指向同一个地方——即授权头。
- en: The next section will detail an authorization protocol called OAuth2.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将详细介绍一个名为OAuth2的授权协议。
- en: Third-Party Authentication—OAuth2
  id: totrans-321
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 第三方身份验证——OAuth2
- en: GitHub is an example of an authorization server. It allows access to a resource
    or functionality in the name of the owner. For example, updating the user's employment
    status is only available to a logged-in user. However, this can be done directly
    given the user has been granted the access to do so. A program getting access
    on behalf of someone is what OAuth2 is all about.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: GitHub是一个授权服务器的示例。它允许以所有者的名义访问资源或功能。例如，更新用户的就业状态仅对已登录用户可用。但是，如果用户已被授予执行此操作的访问权限，则可以直接这样做。OAuth2就是关于代表某人获取访问权限的程序。
- en: 'Perform the following steps to modify the user''s employment status:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以修改用户的就业状态：
- en: 'Navigate to this URL or send an HTTP `GET` request:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到此URL或发送一个HTTP `GET`请求：
- en: '[PRE35]'
  id: totrans-325
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Here, `{{ClientId}}` and `{{RedirectUrl}}` are the values that you have set
    in the OAuth2 GitHub app.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`{{ClientId}}`和`{{RedirectUrl}}`是您在OAuth2 GitHub应用中设置的值。
- en: Note
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Replace the placeholders `{{ClientId}}` and `{{RedirectUrl}}` with the ones
    from your GitHub OAuth app.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 将占位符`{{ClientId}}`和`{{RedirectUrl}}`替换为您GitHub OAuth应用中的相应值。
- en: 'The following screen prompts you to log in to your GitHub app:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕提示您登录到您的GitHub应用：
- en: '![Figure 8.20: Signing in to OAuth2 GitHub app ](img/B16835_08_20.jpg)'
  id: totrans-330
  prefs: []
  type: TYPE_IMG
  zh: '![图8.20：登录OAuth2 GitHub应用](img/B16835_08_20.jpg)'
- en: 'Figure 8.20: Signing in to OAuth2 GitHub app'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20：登录OAuth2 GitHub应用
- en: Complete `Username` and `Password`.
  id: totrans-332
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 完成用户名和密码。
- en: Next, click the `Sign in` button to log in.
  id: totrans-333
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，点击`Sign in`按钮进行登录。
- en: After a successful login, you will be redirected to a URL specified in your
    OAuth2 app.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 登录成功后，您将被重定向到OAuth2应用中指定的URL。
- en: 'Create a request for the token by sending an HTTP `POST` request to a URI in
    the following format:'
  id: totrans-335
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过向以下格式的URI发送HTTP `POST`请求来创建令牌请求：
- en: '[PRE36]'
  id: totrans-336
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'The code for it is as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 其代码如下：
- en: '[PRE37]'
  id: totrans-338
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In this case, the redirect URL was [https://www.google.com](https://www.google.com).
    The URI you ended up with was [https://www.google.com/?code=a681b5126b4d0ba160ba](https://www.google.com/?code=a681b5126b4d0ba160ba).
    The `code=` part is the code needed to get the `OAuth` access token. The token
    is returned in the following format:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，重定向URL是[https://www.google.com](https://www.google.com)。你最终得到的URI是[https://www.google.com/?code=a681b5126b4d0ba160ba](https://www.google.com/?code=a681b5126b4d0ba160ba)。`code=`部分是获取`OAuth`访问令牌所需的代码。令牌以以下格式返回：
- en: '[PRE38]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Before this token can be used, you need to parse it from the response. So,
    create a function to parse the token response:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此令牌可以使用之前，你需要从响应中解析它。因此，创建一个解析令牌响应的函数：
- en: '[PRE39]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This takes every `=` property and puts it into a dictionary. The string before
    `=` is a key and the string after `=` is a value.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 这会将每个`=`属性放入一个字典中。`=`之前的是键，`=`之后的是值。
- en: 'Use the `GetToken` function to create and send a request and parse a response,
    then format the token and return it:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`GetToken`函数创建并发送请求，然后解析响应，然后格式化令牌并返回它：
- en: '[PRE40]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Here, you created a request, sent it to a client, parsed the response as a
    token, and then returned it. `ValidateNoError` is commented out for now. You will
    come back to it later. The returned token should look something like this:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你创建了一个请求，将其发送到客户端，将响应解析为令牌，然后返回。`ValidateNoError`目前被注释掉了。你稍后会回到它。返回的令牌应该看起来像这样：
- en: '[PRE41]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This token is a bearer token, which is a token generated by an authorization
    server (in this case, GitHub) that grants access to GitHub on behalf of you (or
    any other username used for logging in to GitHub). You can use it to send requests
    that require special access. For example, update the employment status of a user.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这个令牌是一个持票令牌，它是由授权服务器（在这种情况下，是GitHub）生成的，代表你（或任何用于登录GitHub的其它用户名）访问GitHub。你可以用它来发送需要特殊访问权限的请求。例如，更新用户的就业状态。
- en: 'To update the employment status of a user, use the `UpdateEmploymentStatus`
    function:'
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要更新用户的就业状态，请使用`UpdateEmploymentStatus`函数：
- en: '[PRE42]'
  id: totrans-350
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: This block of code sets the user's property `isHireable` to `true` and prints
    the updated user information. The important part here is content; when sending
    `PUT`, `PATCH`, or a `POST` request, you often need a body with a request (or
    content in other words).
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将用户的属性`isHireable`设置为`true`并打印更新后的用户信息。这里重要的是内容；在发送`PUT`、`PATCH`或`POST`请求时，你通常需要一个带有请求（或换句话说，内容）的主体。
- en: The act of converting an in-memory object into structured text (for example,
    JSON) is called serialization. In this case, a body is a user update. You send
    a `PATCH` request because you only want to change the updated values. If a value
    is not provided in the content, it should not change. That's the key difference
    between a `PATCH` and `POST` request—a successful request overrides all values
    (even if you don't provide them).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 将内存中的对象转换为结构化文本（例如，JSON）的行为称为序列化。在这种情况下，主体是一个用户更新。你发送一个`PATCH`请求，因为你只想更改更新的值。如果内容中没有提供值，则不应更改。这是`PATCH`请求与`POST`请求之间的关键区别——成功的请求会覆盖所有值（即使你没有提供它们）。
- en: You used `new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore
    }` in order to avoid providing `null` values. This is because you do not want
    to update all the fields; just the ones you have supplied.
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 你使用了`new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore
    }`来避免提供`null`值。这是因为你不想更新所有字段，只更新你提供的那些字段。
- en: 'When creating HTTP content, you also need to supply a MIME type (a type of
    media sent over with the request). It is needed so that the server has a hint
    for how it is expected to process the request. A MIME type follows this format:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建HTTP内容时，你还需要提供一个MIME类型（请求中发送的一种媒体类型）。这是必要的，以便服务器可以了解它应该如何处理请求。MIME类型遵循以下格式：
- en: '[PRE43]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: In this case, `application/json` means that the client should expect JSON from
    a server. `application` is the most common MIME type, which means binary data.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`application/json`意味着客户端应该期望从服务器接收JSON。`application`是最常见的MIME类型，意味着二进制数据。
- en: There is also `StringContent`, which is a type of serialized content, usually
    as JSON or XML. Alternatively, you could use `StreamContent` or `ByteContent`,
    but those are slightly rarer and are used when performance or the volume of data
    is of concern.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有`StringContent`，它是一种序列化内容，通常是JSON或XML。或者，你也可以使用`StreamContent`或`ByteContent`，但它们稍微少用一些，并且在使用性能或数据量是关注点时使用。
- en: 'The following code shows the full demo:'
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码展示了完整的演示：
- en: '[PRE44]'
  id: totrans-359
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the `GetToken` method (used in *Step 6* of the *Third-Party Authentication
    (OAuth2)* section), there was one commented line of code, `ValidateNoError`. Uncomment
    it and implement the `GetToken` method, because you won''t always get a successful
    response, and parsing a token in that case will fail (i.e., it won''t exist).
    Therefore, it is always a good idea to validate the server response and throw
    an exception when the unexpected happens. Look at the following GitHub error format:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `GetToken` 方法（用于 *第三部分认证（OAuth2）* 部分的 *步骤 6*）中，有一行被注释掉的代码，`ValidateNoError`。取消注释它并实现
    `GetToken` 方法，因为你不总是能得到成功的响应，在这种情况下解析令牌将失败（即它不存在）。因此，始终验证服务器响应并在意外发生时抛出异常是一个好主意。查看以下
    GitHub 错误格式：
- en: '[PRE45]'
  id: totrans-361
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It is not very readable. `ValidateNoError` will format the response and throw
    that as an exception, instead of letting it fail silently:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是很易读。`ValidateNoError` 将格式化响应并将其作为异常抛出，而不是让它静默失败：
- en: '[PRE46]'
  id: totrans-363
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'If you run the code again and it fails for the same reasons, the error message
    will now read as follows:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行代码并且因为相同的原因失败，错误信息现在将如下所示：
- en: '[PRE47]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: This section covered the basics of how to send HTTP requests with some sort
    of security in place. In the sections that follow (*Restsharp* and *Refit*), you
    will create clients using third-party libraries to remove some of the boilerplate
    code required by `HttpClient`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 本节介绍了如何在有安全措施的情况下发送 HTTP 请求的基础知识。在接下来的部分（*Restsharp* 和 *Refit*）中，你将使用第三方库创建客户端，以减少
    `HttpClient` 所需的样板代码。
- en: Note
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/UPxmW](https://packt.link/UPxmW).
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/UPxmW](https://packt.link/UPxmW) 找到用于此示例的代码。
- en: Request Idempotency
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 请求幂等性
- en: An idempotent HTTP request is a request that always results in the same outcome.
    Only `GET`, `PUT`, and `PATCH` requests are idempotent because they either make
    no change or make the same change all over again, but that change does not ever
    cause an error and results in the same data. `DELETE` is not idempotent because
    deleting an already deleted item will produce an error. `POST` may or may not
    be idempotent, but that solely depends on the implementation.
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 幂等 HTTP 请求是指总是产生相同结果的请求。只有 `GET`、`PUT` 和 `PATCH` 请求是幂等的，因为它们要么不改变任何内容，要么重复相同的改变，但这种改变永远不会导致错误并产生相同的数据。`DELETE`
    不是幂等的，因为删除已删除的项目将产生错误。`POST` 可能是或不是幂等的，这完全取决于实现。
- en: PUT, PATCH, or POST
  id: totrans-371
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: PUT、PATCH 或 POST
- en: 'The difference between `PUT`, `PATCH`, and `POST` can be summed up as follows:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: '`PUT`、`PATCH` 和 `POST` 之间的区别可以总结如下：'
- en: '`PUT` is used for overriding fields in a model. Even if a single value is explicitly
    provided, the whole model will have the unprovided values (or at least that''s
    the expectation). For example, if you wanted to update user details by first getting
    the old details and then sending a modified version, you would use `PUT`.'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PUT` 用于覆盖模型中的字段。即使明确提供了单个值，整个模型也将包含未提供的值（或者至少这是预期）。例如，如果你想通过首先获取旧详情然后发送修改后的版本来更新用户详情，你会使用
    `PUT`。'
- en: '`PATCH` is used for updating only a single value that was provided explicitly.
    For example, if you wanted to update a username, it would make sense to send `PATCH`
    over a `PUT` request.'
  id: totrans-374
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PATCH` 用于更新明确提供的单个值。例如，如果你想更新用户名，使用 `PATCH` 而不是 `PUT` 请求会更合理。'
- en: '`POST` is used for creating items or sending a complex query. Either way, the
    default expectation of this verb is to have side effects. For example, if you
    wanted to create a user, you would use a `POST` request.'
  id: totrans-375
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`POST` 用于创建项目或发送复杂查询。无论哪种方式，此动词的默认预期都有副作用。例如，如果你想创建用户，你会使用 `POST` 请求。'
- en: 'Exercise 8.02: HttpClient Calling a Star Wars Web API'
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.02：HttpClient 调用星球大战 Web API
- en: You might be familiar with Star Wars. There are movies, games, and TV series.
    However, did you know that it also has multiple APIs to retrieve data? The upcoming
    exercise will introduce you to a different format of an API and will make you
    familiar with deserializing slightly more complex responses.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能熟悉星球大战。有电影、游戏和电视剧。然而，你知道它还有多个 API 来检索数据吗？即将到来的练习将介绍 API 的不同格式，并使你熟悉更复杂的响应的反序列化。
- en: 'In this exercise, you will create a strongly typed API client that will, under
    the hood, use `HttpClient`. The client will be used to return Star Wars movies.
    You will be using Star Wars API (SWAPI) ([https://swapi.dev/](https://swapi.dev/)).
    The required endpoint is [https://swapi.dev/api/films/](https://swapi.dev/api/films/).
    Perform the following steps to complete this exercise:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个强类型API客户端，它将底层使用`HttpClient`。该客户端将用于返回星球大战电影。你将使用星球大战API（SWAPI）([https://swapi.dev/](https://swapi.dev/))。所需的端点是[https://swapi.dev/api/films/](https://swapi.dev/api/films/)。执行以下步骤以完成此练习：
- en: 'Create a new class to hold `HttpClient` with a base URL:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的类来持有`HttpClient`和基本URL：
- en: '[PRE48]'
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This will act as a strongly typed API client.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这将作为一个强类型API客户端。
- en: Note
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The `/` at the end of the URI indicates that more text will be appended to the
    URI (after `api` rather than after `dev`).
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: URI末尾的`/`表示将在URI（在`api`之后而不是在`dev`之后）之后附加更多文本。
- en: 'Create a type for representing a movie:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个表示电影的类型：
- en: '[PRE49]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: This is a class you will use for deserializing movies within a response. The
    `ReleaseDate` property has `[JsonProperty("release_date")]` above it to specify
    that the `"release_date"` JSON field will map to the `ReleaseDate` C# property.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个你将用于在响应中反序列化电影的类。`ReleaseDate`属性上方有`[JsonProperty("release_date")]`来指定`"release_date"`
    JSON字段将映射到`ReleaseDate` C#属性。
- en: 'Create a type for storing results:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个用于存储结果的类型：
- en: '[PRE51]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: This is also a type for deserializing a movie response; however, the Star Wars
    API returns results in paginated format. It contains `Previous` and `Next` properties
    pointing to previous and next pages. For example, if you don't provide the page
    you want, it will return a value of `null`. However, the next property will point
    to the next page only if there are any elements left (otherwise it will also be
    `null`). Querying the API using next or previous as a URI will return the resources
    of that page. You used the `JsonProperty` attribute above `T Data` to provide
    JSON-to-property mapping because the property and JSON names do not match (the
    JSON field name is `results` while `Data` is the property name).
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个用于反序列化电影响应的类型；然而，星球大战API以分页格式返回结果。它包含`Previous`和`Next`属性，分别指向上一页和下一页。例如，如果你不提供想要的页码，它将返回`null`的值。然而，如果还有剩余元素，下一个属性将指向下一页（否则它也将是`null`）。使用下一个或上一个作为URI查询API将返回该页的资源。你使用`JsonProperty`属性在`T
    Data`上方提供JSON到属性的映射，因为属性和JSON名称不匹配（JSON字段名是`results`，而`Data`是属性名）。
- en: Note
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You could have changed `ApiResult` to have the `Results` property instead of
    `Data`. However, `ApiResult.Results` is a bit confusing. When writing code, instead
    of ease of automation (in this case, serialization), choose ease of maintainability
    and readability. For this reason, the name chosen in *Step 3* is different but
    clearer.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将`ApiResult`更改为具有`Results`属性而不是`Data`。然而，`ApiResult.Results`有点令人困惑。在编写代码时，与其选择自动化（在这种情况下，序列化）的便利性，不如选择可维护性和可读性。因此，*步骤3*中选择的名称不同但更清晰。
- en: 'Now, create a method to get multiple films:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个获取多个电影的方法：
- en: '[PRE52]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: You've returned a task so that others can await this method. Almost all HTTP
    calls will be `async Task`.
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 你返回了一个任务，以便其他人可以等待此方法。几乎所有HTTP调用都将使用`async Task`。
- en: 'Create an HTTP request to get all movies:'
  id: totrans-396
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个HTTP请求以获取所有电影：
- en: '[PRE53]'
  id: totrans-397
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: The URI is relative because you're calling it from `HttpClient` that already
    has a base URI set.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: URI是相对的，因为你是从已经设置了基本URI的`HttpClient`中调用的。
- en: 'To query the Star Wars API for movies, send this request:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要查询星球大战API中的电影，发送此请求：
- en: '[PRE54]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'It returns `HttpResponseMessage`. There are two important parts to this: status
    code and response body. C# has a method to determine whether there were any errors
    based on the status code. To handle errors, use the following code:'
  id: totrans-401
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它返回`HttpResponseMessage`。这个有两个重要部分：状态码和响应体。C#有一个方法可以根据状态码确定是否有错误。要处理错误，请使用以下代码：
- en: '[PRE55]'
  id: totrans-402
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Error handling is important because a failed HTTP request will often result
    in an error status code rather than an exception. It's recommended you do something
    similar before trying to deserialize the response body as, if it fails, you might
    get an unexpected body.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 错误处理很重要，因为失败的HTTP请求通常会返回错误状态码而不是异常。在尝试反序列化响应体之前，建议你做类似的事情，因为如果失败，你可能会得到意外的体。
- en: 'Now, call the `ReadAsStringAsync` method:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，调用`ReadAsStringAsync`方法：
- en: '[PRE56]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: The response has content that is more likely to be a kind of stream. To convert
    `HttpContent` to a string, call the `ReadAsStringAsync` method. This returns a
    string (JSON), which allows you to convert JSON to a C# object and deserialize
    the results. Lastly, you get the results by deserializing the response content
    body and converting it all to `ApiResult<Film>`.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 响应的内容更有可能是某种流。要将 `HttpContent` 转换为字符串，调用 `ReadAsStringAsync` 方法。这返回一个字符串（JSON），允许你将
    JSON 转换为 C# 对象并反序列化结果。最后，通过反序列化响应内容体并将所有内容转换为 `ApiResult<Film>` 来获取结果。
- en: 'For a demo, create the client and use it to get all the Star Wars films, then
    print them:'
  id: totrans-407
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了演示，创建客户端并使用它获取所有星球大战电影，然后打印它们：
- en: '[PRE57]'
  id: totrans-408
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'If everything is fine, you should see the following result:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切正常，你应该看到以下结果：
- en: '[PRE58]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: This exercise illustrates how to create strongly typed HTTP clients for simplicity.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习说明了如何创建强类型 HTTP 客户端以简化操作。
- en: Note
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 备注
- en: You can find the code used for this exercise at [https://packt.link/2CHpb](https://packt.link/2CHpb).
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/2CHpb](https://packt.link/2CHpb) 找到这个练习使用的代码。
- en: You might have noticed that sending an HTTP request and using an HTTP client
    is very similar to the way a simple text file is sent to the GitHub API. Even
    if it was different, endpoints throughout the same API usually share the same
    requirements. However, if you manually craft an HTTP request every time you need
    to call an API, you are not being very efficient. A better way is to create something
    reusable. A common approach is to create `BaseHttpClient`. You will put this into
    practice in the following activity.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，发送 HTTP 请求和使用 HTTP 客户端的方式非常类似于将简单的文本文件发送到 GitHub API 的方式。即使它们不同，同一个
    API 中的端点通常具有相同的要求。然而，如果你每次需要调用 API 时都手动构建 HTTP 请求，你并不高效。更好的方法是创建可重用的东西。一个常见的方法是创建
    `BaseHttpClient`。你将在以下活动中将其付诸实践。
- en: 'Activity 8.01: Reusing HttpClient for the Rapid Creation of API Clients'
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.01：通过重用 HttpClient 快速创建 API 客户端
- en: 'The problem with `HttpClient` is that you still have to manage many things
    by yourself:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient` 的问题是你仍然需要自己管理很多事情：'
- en: Error handling
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 错误处理
- en: Serializing and deserializing
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 序列化和反序列化
- en: Mandatory headers
  id: totrans-419
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 必须的头部信息
- en: Authorization
  id: totrans-420
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 授权
- en: When working in a team or on a bigger project, you are likely to be making more
    than just one HTTP call. The consistency and same requirements between different
    calls need to be managed.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在团队中工作或在更大的项目中工作时，你很可能会进行不止一次的 HTTP 调用。不同调用之间的一致性和相同要求需要被管理。
- en: The aim of this activity is to show one of many ways you can simplify working
    with repetitive HTTP calls. You will be using the `BaseHttpClient` class, which
    you will create first. The class will generalize error handling and deserializing
    responses and requests, which will significantly simplify different HTTP calls
    that you make. Here, you will learn how to implement a base client by rewriting
    `StarWarsClient` using `BaseHttpClient`.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是展示你可以简化重复 HTTP 调用的多种方法之一。你将使用 `BaseHttpClient` 类，你首先需要创建这个类。这个类将通用错误处理和反序列化响应和请求，这将显著简化你做出的不同
    HTTP 调用。在这里，你将学习如何通过重写 `StarWarsClient` 使用 `BaseHttpClient` 来实现基础客户端。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Create a base `HttpClient` class. A base client wraps `HttpClient`. Therefore,
    you will hold a private reference to it and allow it to be created from a URL.
    The inner `HttpClient` often also includes base headers, but they are not required
    in this case.
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个基础的 `HttpClient` 类。基础客户端封装 `HttpClient`。因此，你将保留对其的私有引用，并允许它从一个 URL 创建。内部的
    `HttpClient` 通常也包含基础头部，但在这个例子中不是必需的。
- en: Define a way to create requests for every method. For brevity, stick to a `GET`
    request. Within a `GET` request, it is a common practice to define the default
    headers, but once again, it is not mandatory in this example.
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一种为每个方法创建请求的方式。为了简洁，我们坚持使用 `GET` 请求。在 `GET` 请求中，定义默认头部是一个常见的做法，但在这个例子中，它不是强制的。
- en: Create a method to send requests and include error handling and deserialization.
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个发送请求的方法，并包括错误处理和反序列化。
- en: In SWAPI, if you are querying multiple results, you get back `ApiResult<IEnumerable<T>>`
    for pagination. Create a `SendGetManyRequest` method.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 SWAPI 中，如果你正在查询多个结果，你会得到 `ApiResult<IEnumerable<T>>` 用于分页。创建一个 `SendGetManyRequest`
    方法。
- en: Use the base client you have created and simplify the client from *Exercise
    8.02*.
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你创建的基础客户端，简化 *练习 8.02* 中的客户端。
- en: Run the code through the same demo code but using the new version of `StarWarsClient`.
  id: totrans-429
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用新的 `StarWarsClient` 版本通过相同的演示代码运行代码。
- en: 'If you run the demo once again with the new `StarWarsClient`, you should see
    the same films returned:'
  id: totrans-430
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果您再次使用新的 `StarWarsClient` 运行演示，您应该看到相同的电影返回：
- en: '[PRE59]'
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: In order to run this activity, go to [https://packt.link/GR27A](https://packt.link/GR27A)
    and comment all lines within the `static void` `Main(string[] args)` body, except
    `await Activities.Activity01.Demo.Run();`.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行此活动，请转到 [https://packt.link/GR27A](https://packt.link/GR27A) 并在 `static
    void Main(string[] args)` 体中注释掉所有行，除了 `await Activities.Activity01.Demo.Run();`。
- en: Note
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 此活动的解决方案可以在 [https://packt.link/qclbF](https://packt.link/qclbF) 找到。
- en: 'Reusing `HttpClient` like that is very useful because it removes code duplication.
    However, calling a Web API and removing duplicate code is a common problem and
    is likely to be solved in some way by some libraries. The following section will
    explore how to simplify calls to a Web API using two popular NuGet packages:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式重用 `HttpClient` 非常有用，因为它消除了代码重复。然而，调用 Web API 并消除重复代码是一个常见问题，并且可能通过某些库以某种方式解决。下一节将探讨如何使用两个流行的
    NuGet 包简化对 Web API 的调用：
- en: RestSharp
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RestSharp
- en: Refit
  id: totrans-437
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Refit
- en: RestSharp
  id: totrans-438
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: RestSharp
- en: 'The idea behind RestSharp is very similar to the base `HttpClient`—reducing
    code duplicity. It simplifies the creation of a request and provides a lot of
    the utility for making HTTP calls. Redo `StarWarsClient` using `RestSharp`, but
    first, you''ll install the `RestSharp` NuGet:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: RestSharp 的理念与基 `HttpClient` 非常相似——减少代码重复。它简化了请求的创建，并为进行 HTTP 调用提供了很多实用工具。使用
    `RestSharp` 重新做 `StarWarsClient`，但首先，您需要安装 `RestSharp` NuGet：
- en: '[PRE60]'
  id: totrans-440
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: 'Now create a client that is very similar to the one you created in *Activity
    8.01*:'
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个与您在 *活动 8.01* 中创建的非常相似的客户端：
- en: '[PRE61]'
  id: totrans-442
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Having `RestSharp` created gives you a response serialization out of the box.
    It is also able to guess which HTTP method you will use:'
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `RestSharp` 后，您将获得一个内置的响应序列化。它还能够猜测您将使用哪个 HTTP 方法：
- en: '[PRE62]'
  id: totrans-444
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: You passed the minimum required information to make an HTTP request (calling
    films, returning `ApiResult<IEnumerable<Film>>`) and the rest is done. This is
    very much like the base client you wrote previously.
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经通过了制作 HTTP 请求所需的最小信息（调用电影，返回 `ApiResult<IEnumerable<Film>>`），其余的工作已经完成。这非常类似于您之前编写的基客户端。
- en: Note
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`ApiResult` is the same type used in *Exercise 8.02*.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`ApiResult` 是与 *练习 8.02* 中相同的类型。'
- en: 'However, if you run this code against your demo, you will notice that the `Data`
    property (on JSON) comes back as `null`. This is because you had a `JsonProperty`
    attribute on the `response` and `film` classes. RestSharp uses a different serializer,
    which does not know about those attributes. To make it work, you could either
    change all the attributes to what RestSharp comprehends or use the same serializer
    as before. You are using `Newtonsoft.Json` and, in order to use that in RestSharp,
    you need to call the `UseSerializer` method, selecting `JsonNetSerializer`:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果您在您的演示中运行此代码，您会注意到 JSON 的 `Data` 属性返回为 `null`。这是因为您在 `response` 和 `film`
    类上有一个 `JsonProperty` 属性。RestSharp 使用不同的序列化器，它不知道这些属性。为了使其工作，您可以将所有属性更改为 RestSharp
    可以理解的形式，或者使用之前的相同序列化器。您正在使用 `Newtonsoft.Json`，为了在 RestSharp 中使用它，您需要调用 `UseSerializer`
    方法，选择 `JsonNetSerializer`：
- en: '[PRE63]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'On running the demo, the following output gets displayed:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行演示时，以下输出会显示：
- en: '[PRE64]'
  id: totrans-451
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The results are the same as those in *Exercise 8.02*; however, the difference
    is using the `Newtonsoft` serializer in the preceding example. `RestSharp` is
    probably the best abstraction for `HttpClient` as it minimizes the amount of code
    you need to write to make HTTP calls even while keeping its similarities with
    `HttpClient`.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与 *练习 8.02* 中的结果相同；然而，区别在于前一个示例中使用了 `Newtonsoft` 序列化器。`RestSharp` 可能是 `HttpClient`
    的最佳抽象，因为它最小化了您需要编写的代码量来执行 HTTP 调用，同时保持了与 `HttpClient` 的相似性。
- en: Note
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/f5vVG](https://packt.link/f5vVG).
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/f5vVG](https://packt.link/f5vVG) 找到用于此示例的代码。
- en: The example aims to communicate with Web APIs using HTTP requests. Even though
    the demo files look the same, they are using either a different library or design
    pattern. In the following activity, you will practice consuming more APIs using RestSharp.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 此示例旨在通过 HTTP 请求与 Web API 进行通信。尽管演示文件看起来相同，但它们使用的是不同的库或设计模式。在接下来的活动中，您将练习使用 RestSharp
    消费更多 API。
- en: 'Activity 8.02: The Countries API Using RestSharp to List all Countries'
  id: totrans-456
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动八.02：使用RestSharp列出所有国家的国家API
- en: The address [https://restcountries.com/v3/](https://restcountries.com/v3/) is
    a public web API that provides a list of all existing countries. Suppose that
    using that API, you need to get a list of all countries, find a country by its
    capital city (for example, Vilnius), and find all the countries that speak in
    a given language (for example, Lithuanian). You need to print only the first two
    country names, their regions, and their capitals, and implement a strongly typed
    client to access this API using `RestSharp`.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 地址[https://restcountries.com/v3/](https://restcountries.com/v3/)是一个公开的Web API，它提供了所有现有国家的列表。假设您需要使用该API获取所有国家的列表，通过首都（例如，维尔纽斯）查找国家，以及查找说给定语言（例如，立陶宛语）的所有国家。您需要只打印前两个国家的名称、它们所在的地区和首都，并实现一个强类型客户端来使用`RestSharp`访问此API。
- en: The aim of this activity is to make you feel more comfortable using third-party
    libraries (`RestSharp`) when making HTTP calls. Using third-party libraries often
    saves a lot of time. It allows you to reuse something that is already available.
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目的是让您在使用第三方库（`RestSharp`）进行HTTP调用时感到更加舒适。使用第三方库通常可以节省大量时间。它允许您重用已经存在的东西。
- en: 'Perform the following steps to complete this activity:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此活动：
- en: Create a base client class using the URL [https://restcountries.com/v3/](https://restcountries.com/v3/).
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[https://restcountries.com/v3/](https://restcountries.com/v3/)的URL创建一个基本客户端类。
- en: Note
  id: totrans-461
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Navigating to [https://restcountries.com/v3/](https://restcountries.com/v3/)
    will return the HTTP status code `404` with a `Page Not Found` message. This is
    because the base API URI doesn't contain any information on a resource; it is
    yet to be completed and is just the beginning of a full URI for a resource.
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 导航到[https://restcountries.com/v3/](https://restcountries.com/v3/)将返回HTTP状态码`404`，并显示“页面未找到”消息。这是因为基本API
    URI不包含任何关于资源的信息；它尚未完成，只是资源完整URI的开始。
- en: Create models for serialization.
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于序列化的模型。
- en: Use the example [https://restcountries.com/v3/name/peru](https://restcountries.com/v3/name/peru)
    to get a response.
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用示例[https://restcountries.com/v3/name/peru](https://restcountries.com/v3/name/peru)来获取响应。
- en: Copy the response and then use a class generator, such as [https://json2csharp.com/](https://json2csharp.com/),
    to make models out of JSON (response).
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制响应，然后使用类生成器，例如[https://json2csharp.com/](https://json2csharp.com/)，将JSON（响应）转换为模型。
- en: 'Within the client, create the following methods: `Get`, `GetByCapital`, and
    `GetByLanguage`.'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在客户端中创建以下方法：`Get`、`GetByCapital`和`GetByLanguage`。
- en: Create a demo calling all three methods.
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个调用所有三个方法的演示。
- en: Print the countries within each response.
  id: totrans-468
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印每个响应中的国家。
- en: 'The result should be as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 结果应该是这样的：
- en: '[PRE65]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Note
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: You now know that RestSharp simplifies the creation of a request and provides
    a lot of the utilities for making HTTP calls. The next section will help you practice
    using Refit, which is another way to consume an API.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在知道RestSharp简化了请求的创建，并为进行HTTP调用提供了许多实用工具。下一节将帮助您练习使用Refit，这是另一种消费API的方式。
- en: Refit
  id: totrans-474
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Refit
- en: 'Refit is the smartest client abstraction because it generates a client from
    an interface. All you have to do is provide an abstraction:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: Refit是最智能的客户端抽象，因为它从一个接口生成客户端。您需要做的只是提供一个抽象：
- en: 'To use the `Refit` library, first install the `Refit` NuGet:'
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使用`Refit`库，首先安装`Refit` NuGet：
- en: '[PRE66]'
  id: totrans-477
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'To create a client in Refit, first create an interface with HTTP methods:'
  id: totrans-478
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要在Refit中创建客户端，首先创建一个具有HTTP方法的接口：
- en: '[PRE67]'
  id: totrans-479
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Please note that the endpoint here is `/films` rather than `films`. If you run
    the code with `films`, you will get an exception suggesting that you change the
    endpoint with a preceding `/`.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，这里的端点是`/films`而不是`films`。如果您用`films`运行代码，您将得到一个异常，建议您使用前面的`/`更改端点。
- en: 'To resolve the client, simply run the following code:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要解析客户端，只需运行以下代码：
- en: '[PRE68]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'On running the demo, the following output gets displayed:'
  id: totrans-483
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行演示时，以下输出将显示：
- en: '[PRE69]'
  id: totrans-484
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: The results are the same as the ones you saw in *Exercise 8.02*; however, the difference
    is in the implementation.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 结果与您在*练习8.02*中看到的结果相同；然而，区别在于实现方式。
- en: Note
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/cqkH5](https://packt.link/cqkH5).
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/cqkH5](https://packt.link/cqkH5)找到用于此示例的代码。
- en: Use Refit only when your scenarios are trivial. Though Refit might seem like
    the easiest solution, it comes with its own complications when you need custom
    authorization for more complex scenarios. You will simplify the solution further
    in the following activity.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 仅当你的场景非常简单时才使用 Refit。尽管 Refit 可能看起来是最简单的解决方案，但在需要为更复杂的场景进行自定义授权时，它也会带来自己的复杂性。你将在接下来的活动中进一步简化解决方案。
- en: 'Activity 8.03: The Countries API Using Refit to List all Countries'
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.03：使用 Refit 列出所有国家的国家 API
- en: The more different ways you know of doing the same thing, the easier you can
    make a choice and pick the best tool for the job. Different teams may use different
    tools and Refit is quite a unique, minimalistic approach that you may encounter.
    Others may say it complicates work because there is too much hidden in the client
    interface (less code often does not mean that you can grasp the code easily).
    It doesn't matter whether you are for Refit or against it; it's good to have practiced
    things first-hand and formed your own opinion. This activity will help you do
    exactly that. Here, you will access the Countries API to display all countries,
    countries by their language, and by their capital city.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 你知道执行同一任务的不同方法越多，你做出选择并挑选最适合的工具就越容易。不同的团队可能会使用不同的工具，Refit 是一种相当独特、简约的方法，你可能会遇到。其他人可能会说它使工作复杂化，因为客户端界面中隐藏了太多东西（代码越少并不意味着你可以轻松掌握代码）。无论你是否支持
    Refit 或反对它，亲自实践并形成自己的观点都是好的。这个活动将帮助你做到这一点。在这里，你将访问国家 API 来显示所有国家、按语言划分的国家以及按首都划分的国家。
- en: 'The aim of this activity is to show how practical Refit can be for rapid prototyping
    when it comes to consuming simple APIs. The steps for this are as follows:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的目的是展示 Refit 在消费简单 API 时如何适用于快速原型设计。以下是这些步骤：
- en: Create models for serialization. For that, use the example [https://restcountries.com/v3/name/peru](https://restcountries.com/v3/name/peru)
    to get a response.
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建用于序列化的模型。为此，使用示例 [https://restcountries.com/v3/name/peru](https://restcountries.com/v3/name/peru)
    获取响应。
- en: Now copy the response.
  id: totrans-493
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在复制响应。
- en: Then use a class generator, such as [https://json2csharp.com/](https://json2csharp.com/),
    to make models out of JSON (response).
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后使用一个类生成器，例如 [https://json2csharp.com/](https://json2csharp.com/)，从 JSON（响应）中创建模型。
- en: 'Define an interface with methods: `Get`, `GetByCapital`, and `GetByLanguage`.'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定义一个具有以下方法的接口：`Get`、`GetByCapital` 和 `GetByLanguage`。
- en: Create a demo printing a country name, region, and country status.
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个打印国家名称、地区和国家状态的演示。
- en: 'The result will be displayed as follows:'
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 结果将如下显示：
- en: '[PRE70]'
  id: totrans-498
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Note
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动的解决方案可以在 [https://packt.link/qclbF](https://packt.link/qclbF) 找到。
- en: .NET has a few other native ways of creating HTTP requests, and for that, you
    can use `HttpWebRequest` or `WebClient`. The two are not deprecated and it is
    fine to use them, but they are older alternatives compared to the newer `HttpClient`.
    The next section covers all these.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 有几种创建 HTTP 请求的本地方法，为此，你可以使用 `HttpWebRequest` 或 `WebClient`。这两个方法尚未被弃用，使用它们是可以的，但与较新的
    `HttpClient` 相比，它们是较旧的替代方案。下一节将涵盖所有这些内容。
- en: In the following section, you'll find out about other libraries that solve the
    problem of code duplication when using `HttpClient`.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下部分，你将了解到其他一些库，它们可以解决在使用 `HttpClient` 时代码重复的问题。
- en: Other Ways of Making HTTP Requests
  id: totrans-503
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他创建 HTTP 请求的方法
- en: Refit and RestSharp are just two of many libraries solving the problem of code
    duplication when using `HttpClient`. Flurl and TinyRest are another two popular
    alternatives. New libraries are created every year and they are ever evolving.
    There is no one best way that suits all scenarios. To be sure you make the right
    choice, you'll want to do a little research first as there are some pitfalls to
    these alternatives to consider.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: Refit 和 RestSharp 只是众多解决在使用 `HttpClient` 时代码重复问题的库中的两个。Flurl 和 TinyRest 是另外两个流行的替代方案。每年都会创建新的库，并且它们在不断发展。没有一种适合所有场景的最佳方法。为了确保你做出正确的选择，你首先需要进行一些研究，因为对这些替代方案有一些潜在的问题需要考虑。
- en: '`HttpClient` was designed for the lowest-level HTTP calls in .NET. It is the
    safest option because it is well-documented, tested, and allows the most freedom.
    Though there are many libraries that are much simpler to use than `HttpClient`,
    they often target basic scenarios (no authorization, no dynamically set headers).
    When it comes to creating advanced HTTP calls, they often turn out to be quite
    complicated.'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: '`HttpClient` 是为 .NET 中的最低级 HTTP 调用而设计的。它是最安全的选项，因为它有良好的文档记录，经过测试，并允许最大的自由度。尽管有许多库比
    `HttpClient` 更容易使用，但它们通常针对基本场景（无授权，无动态设置的头）。当涉及到创建高级 HTTP 调用时，它们往往变得相当复杂。'
- en: When it comes to choosing which client to use, first go for the one provided
    natively by the API. If there is no client for the API, think about the complexity
    and scope of your project. For simple, small-scope projects, use whatever NuGet
    `HttpClient` alternative you find the most convenient. But if the scope of a project
    is big and the calls are complex, use the native `HttpClient` offered by the framework.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到选择使用哪个客户端时，首先选择 API 本地提供的客户端。如果没有为 API 提供客户端，考虑你项目的复杂性和范围。对于简单、范围较小的项目，使用你找到的最方便的
    NuGet `HttpClient` 替代方案。但如果项目的范围很大且调用复杂，请使用框架提供的本地 `HttpClient`。
- en: In the next exercise, you will implement an example where using Refit will turn
    it into a complication. To fix that complication, you will use both `HttpClient`
    and RestSharp.
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将实现一个示例，使用 Refit 将其转变为一个复杂问题。为了解决这个问题，你将同时使用 `HttpClient` 和 RestSharp。
- en: 'Exercise 8.03: A Strongly Typed HTTP Client for Testing Payments in a PayPal
    Sandbox'
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 8.03：用于在 PayPal 沙盒中测试支付的强类型 HTTP 客户端
- en: A common scenario in programming is making payments. However, during the development
    stage, you don't want to use a real bank account and thus look for ways to process
    payments in a test environment—that is, a sandbox. In this exercise, you will
    learn how to call a payments sandbox API. You will use PayPal's sandbox API ([https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/))
    to create an order and get the order that you have created.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 编程中常见的场景是进行支付。然而，在开发阶段，你不想使用真实的银行账户，因此寻找在测试环境中处理支付的方法——即沙盒。在这个练习中，你将学习如何调用支付沙盒
    API。你将使用 PayPal 的沙盒 API ([https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/))
    创建订单并获取你创建的订单。
- en: 'This exercise will use `Refit` for the client interface and the implementation
    resolution. It will also use `HttpClient` to provide a way of getting `auth` headers
    for Refit. Lastly, you will use RestSharp to get an access token from within `HttpClient`.
    Perform the following steps to complete this exercise:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习将使用 `Refit` 作为客户端接口和实现解析。它还将使用 `HttpClient` 为 Refit 提供获取 `auth` 标头的途径。最后，你将使用
    RestSharp 从 `HttpClient` 内部获取访问令牌。按照以下步骤完成此练习：
- en: Go to [https://www.paypal.com/tt/webapps/mpp/account-selection](https://www.paypal.com/tt/webapps/mpp/account-selection).
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 [https://www.paypal.com/tt/webapps/mpp/account-selection](https://www.paypal.com/tt/webapps/mpp/account-selection)。
- en: Create a PayPal account (either personal or business).
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 PayPal 账户（个人或商业）。
- en: Choose your location and click the `Get Started` button.
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的位置并点击 `Get Started` 按钮。
- en: Provide your mobile number.
  id: totrans-514
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供你的手机号码。
- en: Click the `Next` button and enter the code.
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Next` 按钮，并输入代码。
- en: Set up your profile by entering an email address and password.
  id: totrans-516
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过输入电子邮件地址和密码设置你的个人资料。
- en: Provide your address details.
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供你的地址详情。
- en: Now link your credit or debit card. You can also do this for free by following
    the instructions given at [https://www.paypal.com/tt/webapps/mpp/account-selection](https://www.paypal.com/tt/webapps/mpp/account-selection).
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在链接你的信用卡或借记卡。你也可以通过遵循 [https://www.paypal.com/tt/webapps/mpp/account-selection](https://www.paypal.com/tt/webapps/mpp/account-selection)
    提供的说明免费完成此操作。
- en: Note
  id: totrans-519
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: Creating an account on PayPal is free. The linking of credit (or debit) card
    requirement is just a part of account creation, and it doesn't charge you. The
    payment gets refunded as soon as the authentication is confirmed.
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 PayPal 上创建账户是免费的。链接信用卡（或借记卡）的要求只是账户创建的一部分，并且不会收取费用。一旦身份验证确认，支付就会退款。
- en: Now log out of the account and go to [https://developer.paypal.com/developer/accounts/](https://developer.paypal.com/developer/accounts/).
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在退出账户并前往 [https://developer.paypal.com/developer/accounts/](https://developer.paypal.com/developer/accounts/)。
- en: 'Click the `Log in to Dashboard` button and proceed ahead:'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 `Log in to Dashboard` 按钮，继续操作：
- en: '![Figure 8.21: Log in to the PayPal dashboard to manage both sandbox and live
    environments ](img/B16835_08_21.jpg)'
  id: totrans-523
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.21：登录 PayPal 控制面板以管理沙盒和实时环境](img/B16835_08_21.jpg)'
- en: 'Figure 8.21: Log in to the PayPal dashboard to manage both sandbox and live
    environments'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.21：登录 PayPal 控制面板以管理沙盒和实时环境
- en: Then enter the requested credentials and proceed to the next screen.
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后输入所需的凭据，并转到下一屏幕。
- en: 'Click the `Accounts` option under the `Sandbox` option. You will see two test
    accounts created for you:'
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Sandbox`选项下点击`Accounts`选项。您将看到为您创建的两个测试账户：
- en: '![Figure 8.22: Sandbox PayPal accounts for testing ](img/B16835_08_22.jpg)'
  id: totrans-527
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.22：用于测试的沙盒 PayPal 账户](img/B16835_08_22.jpg)'
- en: 'Figure 8.22: Sandbox PayPal accounts for testing'
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.22：用于测试的沙盒 PayPal 账户
- en: You will use these accounts to do testing in the next steps.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 您将使用这些账户在下一步中进行测试。
- en: Note
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The PayPal sandbox is free.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: PayPal 沙盒是免费的。
- en: Go to [https://developer.paypal.com/developer/applications](https://developer.paypal.com/developer/applications)
    to get your client ID and secret. Just like the GitHub example, PayPal uses an
    OAuth app to provide you with a client ID and a secret.
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://developer.paypal.com/developer/applications](https://developer.paypal.com/developer/applications)获取您的客户端
    ID 和密钥。就像 GitHub 示例一样，PayPal 使用 OAuth 应用为您提供客户端 ID 和密钥。
- en: 'For one of the default accounts, PayPal also generates a default OAuth app.
    So, click the `Sandbox` tab and select `Default Application`:'
  id: totrans-533
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于默认账户之一，PayPal 还会生成一个默认的 OAuth 应用。因此，点击`Sandbox`选项卡并选择`Default Application`：
- en: '![Figure 8.23: OAuth app creation for PayPal ](img/B16835_08_23.jpg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.23：为 PayPal 创建 OAuth 应用](img/B16835_08_23.jpg)'
- en: 'Figure 8.23: OAuth app creation for PayPal'
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.23：为 PayPal 创建 OAuth 应用
- en: In the new window, inspect both `Client ID` and `Secret`.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新窗口中，检查`Client ID`和`Secret`。
- en: 'Take note of both and store them in environmental variables:'
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意这两者并将它们存储在环境变量中：
- en: '![Figure 8.24: Default application details displaying Client ID and Secret
    ](img/B16835_08_24.jpg)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.24：显示 Client ID 和 Secret 的默认应用程序详情](img/B16835_08_24.jpg)'
- en: 'Figure 8.24: Default application details displaying Client ID and Secret'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.24：显示 Client ID 和 Secret 的默认应用程序详情
- en: 'Create properties for accessing the PayPal client ID and secret in a new empty
    class, `Exercise03.AuthHeaderHandler.cs`:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在一个新空类`Exercise03.AuthHeaderHandler.cs`中创建用于访问 PayPal 客户端 ID 和密钥的属性：
- en: '[PRE71]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: Here, the `EnvironmentVariable.GetOrThrow` helper methods are used to get the
    user's environment variable or throw it if it doesn't exist. You will use these
    properties to make a connection to the sandbox PayPal API.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 这里使用了`EnvironmentVariable.GetOrThrow`辅助方法来获取用户的环镜变量，如果不存在则抛出异常。您将使用这些属性来连接到沙盒
    PayPal API。
- en: Note
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for environment variables at [https://packt.link/y2MCy](https://packt.link/y2MCy).
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/y2MCy](https://packt.link/y2MCy)找到用于环境变量的代码。
- en: 'In the `Demo.cs` class, add a `const` variable for the `BaseAddress` of a PayPal sandbox:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Demo.cs`类中，添加一个`const`变量用于 PayPal 沙盒的`BaseAddress`：
- en: '[PRE72]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '`BaseAddress` will be used for initializing different clients (RestSharp and
    Refit) with the PayPal URL.'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: '`BaseAddress`将用于初始化具有 PayPal URL 的不同客户端（RestSharp 和 Refit）。'
- en: 'Use `Refit` to create a client with `CreateOrder` and `GetOrder` methods:'
  id: totrans-548
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`Refit`创建一个具有`CreateOrder`和`GetOrder`方法的客户端：
- en: '[PRE73]'
  id: totrans-549
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'To get a sample request, refer to the documentation of the API that you want
    to call. Usually, they have an example request. In this case, the PayPal `CreateOrder`
    request can be found at [https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/):'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取示例请求，请参考您想要调用的 API 的文档。通常，它们都有一个示例请求。在这种情况下，PayPal 的 `CreateOrder` 请求可以在[https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/)找到：
- en: '[PRE74]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '![Figure 8.25: PayPal CreateOrder example request with highlighted body ](img/B16835_08_25.jpg)'
  id: totrans-552
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.25：带有突出显示的 PayPal CreateOrder 请求体的示例请求](img/B16835_08_25.jpg)'
- en: 'Figure 8.25: PayPal CreateOrder example request with highlighted body'
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.25：带有突出显示的 PayPal CreateOrder 请求体的示例请求
- en: In *Figure 8.25*, `-d` is an argument and does not belong to the request body.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图 8.25*中，`-d`是一个参数，不属于请求体。
- en: Use [https://json2csharp.com/](https://json2csharp.com/) and generate C# classes
    out of the JSON. The corresponding C# classes will be generated for you.
  id: totrans-555
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[https://json2csharp.com/](https://json2csharp.com/)生成 C# 类，从 JSON 中生成相应的
    C# 类。
- en: 'Rename `RootObject` to `Order` and change all classes to the `record` type
    because it''s a more suitable type for DTO:'
  id: totrans-556
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RootObject`重命名为`Order`，并将所有类更改为`record`类型，因为这对于 DTO 是一个更合适的类型：
- en: '[PRE75]'
  id: totrans-557
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-558
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Using the same PayPal docs ([https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/)),
    copy the example response:'
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用相同的PayPal文档([https://developer.paypal.com/docs/api/orders/v2/](https://developer.paypal.com/docs/api/orders/v2/))，复制示例响应：
- en: '[PRE77]'
  id: totrans-560
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Use [https://json2csharp.com/](https://json2csharp.com/) and generate C# classes
    out of the JSON. Here, you will get classes very similar to the ones from request
    JSON. The only difference is the response (simplified for brevity):'
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用[https://json2csharp.com/](https://json2csharp.com/)从JSON生成C#类。在这里，你会得到与请求JSON非常相似的类。唯一的区别是响应（为了简洁而简化）：
- en: '[PRE78]'
  id: totrans-562
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Use `AuthHeaderHandler` to fetch an access token when you make a request and
    make sure it inherits `DelegatingHandler`:'
  id: totrans-563
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AuthHeaderHandler`在请求时获取访问令牌，并确保它继承自`DelegatingHandler`：
- en: '[PRE79]'
  id: totrans-564
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: To make calls to PayPal, you will need an `auth` header with every request.
    The `auth` header value is retrieved from yet another endpoint. Refit cannot just
    add a header on a whim. You can, however, set up Refit using a custom `HttpClient`
    with a custom `HttpMessageHandler` that fetches an access token whenever you make
    a request. The `AuthHeaderHandler` is used for that reason.
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 要调用PayPal，你需要在每个请求中包含`auth`头。`auth`头的值是从另一个端点检索的。Refit不能随意添加头。然而，你可以使用自定义`HttpClient`和自定义`HttpMessageHandler`设置Refit，该处理器在每次请求时都会获取访问令牌。`AuthHeaderHandler`就是为此而使用的。
- en: '`DelegatingHandler` is a class that allows intercepting `HttpRequest` when
    it''s being sent and doing something before or after it. In this case, before
    you send an HTTP request, you will fetch an `auth` header and add it to the request sent.'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: '`DelegatingHandler`是一个允许在发送`HttpRequest`时拦截它，并在发送前后执行某些操作的类。在这种情况下，在发送HTTP请求之前，你将获取`auth`头并将其添加到发送的请求中。'
- en: 'Now, override `SendRequest` by adding a bearer token to `AuthenticationHeader`:'
  id: totrans-567
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，通过向`AuthenticationHeader`添加bearer令牌来覆盖`SendRequest`：
- en: '[PRE80]'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'To get an access token, you first need to get an OAuth token using basic `auth`
    (the client ID and secret):'
  id: totrans-569
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要获取访问令牌，你首先需要使用基本的`auth`（客户端ID和密钥）获取OAuth令牌：
- en: '[PRE81]'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Getting an access token will require an `auth` token. Use the `RestSharp` client
    and add an `Authorization` header to the request.
  id: totrans-571
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取访问令牌需要`auth`令牌。使用`RestSharp`客户端并在请求中添加`Authorization`头。
- en: Next, set `content-type` to `application/x-www-form-urlencoded` as per the PayPal
    API spec.
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，根据PayPal API规范将`content-type`设置为`application/x-www-form-urlencoded`。
- en: 'Add the body content `grant_type=client_credentials` as follows:'
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按如下方式添加正文内容`grant_type=client_credentials`：
- en: '[PRE82]'
  id: totrans-574
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Execute the preceding request and return the response using the private nested
    class `Response` to simplify your work:'
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用私有嵌套类`Response`执行前面的请求并返回响应，以简化你的工作：
- en: '[PRE83]'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Why is the nested class needed? Here, the access token is nested within the
    response. It's not just a string that it returns, but rather an object. To parse
    it yourself from JSON would be a little complicated. However, you already know
    how to deserialize objects. So, even if it's just one property, deserializing
    still helps.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么需要嵌套类？在这里，访问令牌嵌套在响应中。它返回的不仅仅是一个字符串，而是一个对象。自己从JSON解析它可能会稍微复杂一些。然而，你已经知道如何反序列化对象。所以，即使只有一个属性，反序列化仍然有帮助。
- en: 'Now, create `RestClient` for the `GetAccessToken` method. Do so in the `AuthHandler`
    class:'
  id: totrans-578
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，为`GetAccessToken`方法创建`RestClient`。在`AuthHandler`类中这样做：
- en: '[PRE84]'
  id: totrans-579
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'In the `Demo` class, create the method `Run`:'
  id: totrans-580
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Demo`类中创建`Run`方法：
- en: '[PRE85]'
  id: totrans-581
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Resolve a `Refit` client with a custom `AuthHeaderHandler` provider:'
  id: totrans-582
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用自定义`AuthHeaderHandler`提供程序解析`Refit`客户端：
- en: '[PRE86]'
  id: totrans-583
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'Assuming that a payment was made by creating an `Order` object, run the following
    code:'
  id: totrans-584
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 假设通过创建`Order`对象进行了支付，运行以下代码：
- en: '[PRE87]'
  id: totrans-585
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Now, call PayPal API and create an order endpoint with the order you've just created.
  id: totrans-586
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，调用PayPal API并创建一个带有你刚刚创建的订单的订单端点。
- en: 'Get the created order to see if it works and print the retrieved order payment information:'
  id: totrans-587
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 获取创建的订单以查看它是否工作，并打印检索到的订单支付信息：
- en: '[PRE88]'
  id: totrans-588
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'With the environment variables set correctly, you should see the following output:'
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 在设置正确的环境变量后，你应该看到以下输出：
- en: '[PRE89]'
  id: totrans-590
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'As mentioned earlier, this is a sandbox API. However, a switch to a live environment
    with real money would just be a matter of setting up new PayPal accounts in that
    environment and calling a different endpoint: [https://api-m.paypal.com](https://api-m.paypal.com).'
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这是一个沙盒API。然而，切换到使用真实货币的实时环境只需在该环境中设置新的PayPal账户并调用不同的端点：[https://api-m.paypal.com](https://api-m.paypal.com)。
- en: Note
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You won't be able to access [https://api-m.paypal.com](https://api-m.paypal.com)
    because it is for production PayPal use and is paid. However, that should be the
    only change in code (a different base URI) when you are ready to move on to real
    integration with PayPal.
  id: totrans-593
  prefs: []
  type: TYPE_NORMAL
  zh: 您将无法访问 [https://api-m.paypal.com](https://api-m.paypal.com)，因为它用于生产 PayPal，并且是付费的。然而，当您准备好进行与
    PayPal 的实际集成时，代码中应该只有一处变化（不同的基本 URI）。
- en: Please make sure you have the environment variables set and are using your own
    client and secret. Otherwise, some unhandled exception errors may be displayed.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 请确保您已设置环境变量，并使用您自己的客户端和密钥。否则，可能会显示一些未处理的异常错误。
- en: Note
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/cFRq6](https://packt.link/cFRq6).
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/cFRq6](https://packt.link/cFRq6) 找到用于此练习的代码。
- en: You now know how to do simple CRUD operations with Web APIs. However, you have
    only worked with text so far. So, will calling an API with an image be any different?
    Find that out in the next activity.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在已经知道如何使用 Web API 进行简单的 CRUD 操作。然而，到目前为止你只处理过文本。那么，调用带有图像的 API 会有所不同吗？在下一个活动中找出答案。
- en: 'Activity 8.04: Using an Azure Blob Storage Client to Upload and Download Files'
  id: totrans-598
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 8.04：使用 Azure Blob 存储客户端上传和下载文件
- en: Azure Blob Storage is a cloud service on Azure for storing different files (logs,
    images, music, and whole drives). Before you can use any Azure Storage services,
    you will need a storage account. Blobs are just files, but they cannot be directly
    stored within an account; instead, they need a container.
  id: totrans-599
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Blob Storage 是 Azure 上的一个云服务，用于存储不同的文件（日志、图像、音乐和整个驱动器）。在您可以使用任何 Azure
    存储服务之前，您将需要一个存储帐户。Blob 只是文件，但它们不能直接存储在帐户中；相反，它们需要一个容器。
- en: An Azure Storage Container is like a directory where other files are stored.
    However, unlike a directory, a container cannot contain other containers. Use
    an Azure Storage Account to create two containers, upload an image and a text
    file, and then download the uploaded files locally. All this will be done in your
    own client, which wraps around the Azure Blob storage client.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 存储容器就像一个目录，其中存储着其他文件。然而，与目录不同的是，容器不能包含其他容器。使用 Azure 存储帐户创建两个容器，上传一个图像和一个文本文件，然后在本地上传的文件。所有这些都将在你自己的客户端中完成，该客户端围绕
    Azure Blob 存储客户端。
- en: 'The aim of this activity is to familiarize yourself with working on files through
    cloud storage while putting all that you have learned so far to the test. Perform
    the following steps to complete this activity:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 本活动的目的是熟悉通过云存储处理文件，同时将您迄今为止所学的一切应用到实践中。执行以下步骤以完成此活动：
- en: Navigate to `Azure Storage Accounts`.
  id: totrans-602
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到 `Azure 存储帐户`。
- en: Create a new Azure Storage Account.
  id: totrans-603
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Azure 存储帐户。
- en: Store a blob storage access key in environmental variables with the name `BlobStorageKey`.
  id: totrans-604
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 blob 存储访问密钥存储在名为 `BlobStorageKey` 的环境变量中。
- en: Install the `Azure Blob Storage` client.
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `Azure Blob Storage` 客户端。
- en: Create the `FilesClient` class for storing fields for blobs client and default
    container client (where blobs will be stored by default).
  id: totrans-606
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `FilesClient` 类以存储 blob 客户端和默认容器客户端的字段（blob 将默认存储在此容器中）。
- en: Create a constructor to initialize the two clients (to support access to different containers).
  id: totrans-607
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个构造函数来初始化两个客户端（以支持访问不同的容器）。
- en: Add a method to create a container or get an existing one if it already exists.
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个方法来创建容器或获取已存在的容器。
- en: Create a method to upload a file to a specific container.
  id: totrans-609
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法来将文件上传到特定的容器。
- en: Create a method to download a file from a specific container.
  id: totrans-610
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个方法来从特定的容器中下载文件。
- en: Create a `Demo` class with paths to download and upload directories.
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Demo` 类，包含下载和上传目录的路径。
- en: 'Add test data, namely the two files—that is, an image and a text file (*Figure
    8.26*, *Figure 8.27*, and *Figure 8.28*):'
  id: totrans-612
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加测试数据，即两个文件——即一个图像和一个文本文件（*图 8.26*、*图 8.27* 和 *图 8.28*）：
- en: '![Figure 8.26: Two Azure Storage containers, exercise04 and exercise04b,  in
    your storage account ](img/B16835_08_26.jpg)'
  id: totrans-613
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.26：您的存储帐户中的两个 Azure 存储容器，exercise04 和 exercise04b](img/B16835_08_26.jpg)'
- en: 'Figure 8.26: Two Azure Storage containers, exercise04 and exercise04b, in your
    storage account'
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.26：您的存储帐户中的两个 Azure 存储容器，exercise04 和 exercise04b
- en: 'Text file:'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 文本文件：
- en: '![Figure 8.27: Test1.txt file uploaded in exercise04 container ](img/B16835_08_27.jpg)'
  id: totrans-616
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.27：练习04容器中上传的 Test1.txt 文件](img/B16835_08_27.jpg)'
- en: 'Figure 8.27: Test1.txt file uploaded in exercise04 container'
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.27：练习04容器中上传的 Test1.txt 文件
- en: 'Image file:'
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
  zh: 图像文件：
- en: '![Figure 8.28: Morning.jpg file uploaded in exercise04b container ](img/B16835_08_28.jpg)'
  id: totrans-619
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.28：exercise04b 容器中上传的 Morning.jpg 文件](img/B16835_08_28.jpg)'
- en: 'Figure 8.28: Morning.jpg file uploaded in exercise04b container'
  id: totrans-620
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.28：exercise04b 容器中上传的 Morning.jpg 文件
- en: Create the method `Run` to upload a text file and then download it locally.
  id: totrans-621
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建名为 `Run` 的方法以上传文本文件，然后将其本地下载。
- en: 'Run the code. If you did everything correctly, you should see the following
    output with both files downloaded locally:'
  id: totrans-622
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。如果你一切都做对了，你应该会看到以下输出，两个文件都已本地下载：
- en: '![Figure 8.29: Morning.jpg and Test1.txt files downloaded from the two containers  after
    the demo code execution ](img/B16835_08_29.jpg)'
  id: totrans-623
  prefs: []
  type: TYPE_IMG
  zh: '![图 8.29：演示代码执行后从两个容器中下载的 Morning.jpg 和 Test1.txt 文件](img/B16835_08_29.jpg)'
- en: 'Figure 8.29: Morning.jpg and Test1.txt files downloaded from the two containers
    after the demo code execution'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.29：演示代码执行后从两个容器中下载的 Morning.jpg 和 Test1.txt 文件
- en: Note
  id: totrans-625
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可在 [https://packt.link/qclbF](https://packt.link/qclbF) 找到。
- en: It is near impossible to create a perfect client that is suitable for everyone.
    Therefore, even when there is a solution for some problem given to you, you will
    often still need to further abstract it away, adapting it to solve exactly the
    problem you have. The problem you had was in uploading and downloading a file
    from and to a specific folder. To solve the problem, you abstracted away layers
    of clients exposing just two functions—one for uploading a file and another for
    downloading a file.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎不可能创建一个适合所有人的完美客户端。因此，即使有人给你提供了一个问题的解决方案，你通常仍然需要进一步抽象它，以适应解决你确切的问题。你遇到的问题是上传和下载特定文件夹中的文件。为了解决这个问题，你抽象出多层客户端，只暴露两个函数——一个用于上传文件，另一个用于下载文件。
- en: Summary
  id: totrans-628
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: No matter the kind of programmer you are, there will be many scenarios in which
    you will have to consume a web service. There are different kinds of services
    online, but the most common type is RESTful. REST is just a set of guidelines
    and should therefore not be mixed up with HTTP. REST APIs are simple, self-documented,
    well-structured, and are currently a golden standard of Web APIs. However, in
    most cases in the context of RESTful APIs, a request is sent over HTTP and your
    message contains JSON.
  id: totrans-629
  prefs: []
  type: TYPE_NORMAL
  zh: 无论你是什么类型的程序员，都会有许多你必须消费网络服务的场景。在线上有不同种类的服务，但最常见的一种是 RESTful。REST 只是一组指南，因此不应与
    HTTP 混淆。REST API 简单、自文档化、结构良好，目前是 Web API 的黄金标准。然而，在大多数情况下，在 RESTful API 的上下文中，请求是通过
    HTTP 发送的，你的消息包含 JSON。
- en: The main tool for making HTTP calls using C# is `HttpClient`, however, before
    you try to implement HTTP calls yourself, you should look for a NuGet package
    of the Web API you're trying to consume. Azure Blob storage, Azure Text Analytics,
    PayPal, and GitHub are just a few examples of Web APIs.
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 C# 进行 HTTP 调用的主要工具是 `HttpClient`，然而，在你尝试自己实现 HTTP 调用之前，你应该寻找你试图消费的 Web API
    的 NuGet 包。Azure Blob 存储空间、Azure 文本分析、PayPal 和 GitHub 只是 Web API 的几个例子。
- en: In this chapter, you learned about a lot of functionality on the web that is
    done for you. It's not hard to consume; all you need to know now is how to communicate
    with the third-party RESTful Web APIs. In the next chapter, you will learn how
    to create your own RESTful web services using the ASP.NET Core Web API template
    as well as being introduced to Azure Functions and the special tools Swagger and
    NuGet.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你了解了许多为你完成的网络功能。消费起来并不困难；你现在需要知道的是如何与第三方 RESTful 网络API进行通信。在下一章中，你将学习如何使用
    ASP.NET Core Web API 模板创建自己的 RESTful 网络服务，同时还将介绍 Azure Functions 和特殊的工具 Swagger
    以及 NuGet。
