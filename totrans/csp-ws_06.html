<html><head></head><body>
<div><div><div></div>
</div>
<div><h1 id="_idParaDest-212"><a id="_idTextAnchor239"/>6. Entity Framework with SQL Server</h1>
</div>
<div><p class="callout-heading">Overview</p>
<p class="callout">This chapter introduces you to the basics of database design, storage, and processing using SQL and C#. You will learn about the Entity Framework (EF), and Object-Relational Mapper (ORM) and use them to convert database results into C# objects. You will then learn about the main performance pitfalls of SQL and EF and how to find and fix them. </p>
<p class="callout">Finally, you will delve into enterprise practices of working with databases by looking at Repository and Command Query Responsibility Segregation (CQRS) patterns and also by setting up a local database for development and testing. By the end of this chapter, you will be able to create and design your own database using PostgreSQL Server and use EF to hook a C# backend to it.</p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor240"/>Introduction</h1>
<p>There are multiple types of databases, but the most common one is relational, and the language for managing relational databases is SQL. SQL is optimized for data persistence. However, executing business rules in it is inefficient. Therefore, before consumption, data is often fetched in application memory and transformed into objects. This transformation is called object-relational mapping. </p>
<p>There is a lot of complexity in mapping database records to objects. However, this complexity is mitigated by Object-Relational Mapper (ORM). Some ORMs only do mapping (called micro-ORMs), but many popular ORMs also abstract away database language and allow you to use the same language to execute business rules and process data:</p>
<div><div><img alt="Figure 6.1: How an ORM works in translating C# to SQL and back " height="855" src="img/B16835_06_01.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 6.1: How an ORM works in translating C# to SQL and back</p>
<p>The focus of this chapter will be on Entity Framework (EF)—the most popular ORM in .NET. In the practical sections of this chapter, you will use it to rapidly prototype relational databases, and then make queries against them. It's worth mentioning that internally, whenever databases are involved, you are interacting with the ADO.NET part of .NET.</p>
<p>Before proceeding, however, it's recommended that you install the latest version of PostgreSQL with PostgreSQL Server found here: <a href="https://www.enterprisedb.com/downloads/postgres-postgresql-downloads">https://www.enterprisedb.com/downloads/postgres-postgresql-downloads</a>. You can find the installation instructions for this in the <em class="italic">Preface</em>. </p>
<p>This chapter will use the <code>AdventureWorks</code> database, which is an adaptation of a popular example database that Microsoft often uses; it will be defined in detail in the following section.</p>
<p class="callout-heading">Note</p>
<p class="callout">For those who are interested in learning the basics of databases and how to work with PostgreSQL, a reference chapter has been included in the GitHub repository of this book. You can access it at <a href="https://packt.link/sezEm">https://packt.link/sezEm</a>.</p>
<h1 id="_idParaDest-214"><a id="_idTextAnchor241"/>Creating a Demo Database Before You Start</h1>
<p>You will use <code>Adventureworks</code> as an example because it is a common database used by Microsoft and has just enough complexity to learn about databases topic.</p>
<p>Perform the following steps to do so:</p>
<ol>
<li>Open the command line and make a directory where you will call <code>AdventureWorks</code> database and move to that directory:<pre>C:\&lt;change-with-your-download-path-to-The-C-Sharp-Workshop&gt;\Chapter06\AdventureWorks\&gt;</pre><p class="callout-heading">Note</p><p class="callout">Replace <code>&lt;change-with-your-download-path-to-The-C-Sharp-Workshop&gt;</code> with a directory where you downloaded the The-C-Sharp-Workshop repository.</p></li>
<li>Create an empty <code>Adventureworks</code> database by running the following command in the console:<pre>psql -U postgres -c "CREATE DATABASE \"Adventureworks\";"</pre></li>
<li>Create tables and populate them with data using the installation script.<p class="callout-heading">Note</p><p class="callout">The installation script is found at <a href="https://packt.link/0SHd5">https://packt.link/0SHd5</a>.</p></li>
<li>Run the following command pointing to the installation script:<pre>psql -d Adventureworks -f install.sql -U postgres</pre></li>
</ol>
<h2 id="_idParaDest-215"><a id="_idTextAnchor242"/>Modeling Databases Using EF</h2>
<p>Working with a database from any other language comes with an interesting problem and that is, how do you convert table rows into C# objects? In C#, communicating with a database requires a database connection and SQL statements. Executing the statements will bring up a results reader, which is very similar to a table. Using the results reader dictionary, you can go through the results and map them into a new object.</p>
<p>The code for this would look like the following:</p>
<pre>using var connection = new NpgsqlConnection(Program.GlobalFactoryConnectionString);
connection.Open(); 
NpgsqlCommand command = new NpgsqlCommand("SELECT * FROM factory.product", connection);
var reader = command.ExecuteReader();
var products = new List&lt;Product&gt;();
while (reader.Read())
{
    products.Add(new Product
    {
        Id = (int)reader["id"],
        //ManufacturerId = (int)reader["ManufacturerId"],
        Name = (string)reader["name"],
        Price = (decimal)reader["price"]
    });
}
return products;</pre>
<p>Don't worry about the details of this code yet; it will be broken down soon. For now, it is enough to know that the preceding snippet returns all rows from the <code>factory.product</code> table and maps the results to a list named <code>products</code>. Using this approach may be okay when working with a single table, but when joins are involved, it becomes tricky. Mapping from one type to another, as has been done here, is very granular and can become tedious. In order to run this example, go to <a href="https://packt.link/2oxXn">https://packt.link/2oxXn</a> and comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.TalkingWithDb.Raw.Demo.Run();</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/7uIJq">https://packt.link/7uIJq</a>.</p>
<p>Another factor to consider is that when you deal with SQL from the client side, you should be careful. You should not assume that a user will use your program as intended. So, you should therefore add validation on both the client and server sides. For example, if a textbox requires a user ID to be entered, the client could enter <code>105</code> and get the details of the user of that ID. The query for this would be as follows:</p>
<pre>SELECT * FROM Users WHERE UserId = 105</pre>
<p>A user could also enter <code>105 or 1 = 1</code>, which is always true and thus this query returns all users:</p>
<pre>SELECT * FROM Users WHERE UserId = 105 or 1 = 1</pre>
<p>At best, this breaks your application. At worst, it leaks all the data. This kind of exploit is called SQL injection.</p>
<p>A simple yet effective way to solve the problem of accepting any kind of user input is to use an ORM as it allows you to convert database tables into C# objects and vice versa. In the .NET ecosystem, the three ORMs most commonly used are EF, Dapper, and NHibernate. Dapper is effective when top performance is needed because working with it involves executing raw SQL statements. Such ORMs are called micro-ORMs because they just do the mapping and nothing else.</p>
<p>NHibernate originated with the Java ecosystem and was one of the first ORMs in .NET. NHibernate, just like EF, solves a bigger problem than micro-ORMs by trying to abstract away SQL and database-related low-level details. Using a full-fledged ORM, such as EF or Nhibernate, often means that you don't need to write SQL to communicate with a database. In fact, the two ORMs allow you to generate complex databases out of the objects you have. The opposite is also possible (that is, you can generate objects out of databases you already have).</p>
<p>In the next sections, the focus will be on EF. Why not Dapper? Because Dapper requires knowledge of SQL and you want to make use of a simplified syntax. Why not NHibernate? Because NHibernate is old, it has too many configuration options, none of which are useful for getting started with ORMs.</p>
<p>Before delving into EF, you first need to connect to a database. So, proceed to learn about connection string and security.</p>
<h3 id="_idParaDest-216"><a id="_idTextAnchor243"/>Connection String and Security</h3>
<p>No matter what language you use, connecting to a database will always involve using a connection string. It contains three important parts:</p>
<ul>
<li>IP or a server name.</li>
<li>The name of the database you would like to connect to.</li>
<li>Some sort of security credentials (or none, if using a trusted connection only used for databases on the same network).</li>
</ul>
<p>To connect to the local database you were previously working on in the <em class="italic">Modeling Databases Using EF</em> section (<code>new NpgsqlConnection(ConnectionString))</code>, you could use the following connection string (the password has been obfuscated for security reasons):</p>
<pre>"Host=localhost;Username=postgres;Password=*****;Database=globalfactory2021"</pre>
<p>The connection string will be used when you will add the environment variables in your OS. This is detailed ahead. Different databases use different connections. For example, the following databases use these connections:</p>
<ul>
<li>SQL Server: <code>SqlConnection</code></li>
<li>PostgreSQL: <code>NpgsqlConnection</code></li>
<li>MySql: <code>MySqlConnection</code></li>
<li>SQLite: <code>SqliteConnection</code></li>
</ul>
<p>The connection object is the touching point between .NET and SQL database because it is only through it that you can communicate with a database.</p>
<p>Hardcoding a <strong class="bold">connection string</strong> comes with a few problems:</p>
<ul>
<li>To change a connection string, the program must be recompiled.</li>
<li>It's not secure. The connection string can be viewed by everyone who knows how to decompile code (or worse, is publicly visible if it's an open-source project).</li>
</ul>
<p>Therefore, a connection string is usually stored in a configuration file. This does not solve the problem of sensitive parts of a connection string being stored. To fix that, often, either the whole string or a part of it is replaced during the application's deployment. There are three main ways to securely store and retrieve application secrets:</p>
<ul>
<li>Environment variables: These are variables unique to a system and can be accessed by any application on the same machine. This is the simplest secure approach and might not be safe in a production environment.</li>
<li>Secret Manager tool (available in both .NET and .NET Core applications): Similar to environment variables but more .NET specific, it will store all secrets on the local machine as well but in a file called <code>secrets.json</code>. This option, too, might not be safe in a production environment.</li>
<li>Key vault: This is the most secure approach because, unlike the other two, it is not coupled with a specific environment. Key vaults store secrets in one centralized place; usually remotely. This approach is most commonly used for enterprise applications. In the context of Azure, Azure Key Vault is the best choice and is perfect for a production environment.</li>
</ul>
<p>In the following example, you'll try to securely store the connection string you made previously. You will use the simplest secure approach that is suitable for a development environment—that is, environment variables. This approach fits local development the best because the other two require third-party tools to set up and take much longer.</p>
<p class="callout-heading">Note</p>
<p class="callout">Before you continue, make sure to go through <em class="italic">Exercise 1</em> of the <em class="italic">Reference Chapter</em>, <em class="italic">A Primer for Simple Databases and SQL</em>. It has the steps needed to create a new database with the needed tables.</p>
<p>Adding an environment variable in your OS is just a matter of performing some simple steps. Perform the following steps in Windows to set the environment variables:</p>
<ol>
<li value="1">Go to <code>Control Panel</code>.</li>
<li>Click <code>System &amp; Security</code> and choose <code>System</code>.</li>
<li>Type <code>Environmental Variables</code> in the search box.</li>
<li>Then choose <code>Edit Environment Variables for your account</code> from the list displayed.</li>
<li>Inside the <code>Environment Variables</code> window, click <code>New</code> under the <code>System Variables</code> window.</li>
<li>Inside the New System variable window, type <code>GlobalFactory</code> beside the <code>Variable name</code>.</li>
<li>Beside <code>Variable value</code>, paste the following:<pre>Host=localhost;Username=postgres;Password=*****;Database=globalfactory2021</pre></li>
<li>Next click <code>OK</code> on all windows to set your environment variables.<p class="callout-heading">Note</p><p class="callout">Here the password would carry your database superuser password which you entered while creating the <code>globalfactory2021</code> database in PostgreSQL.</p><ul><li>Mac: From the command line, find <code>bash-profile: ~/.bash-profile f</code>. Open it using any text editor, then at the end of the file, add <code>export GlobalFactory='Host=localhost;Username=postgres;Password=*****;Database=globalfactory2021'</code>. Lastly, run <code>source ~/.bash-profile</code>, which will update the environment variables.</li>
<li>Linux: From the command line, run this: <code>export GlobalFactory='Host=localhost;Username=postgres;Password=*****;Database=globalfactory2021'</code>.</li>
</ul></li>
</ol>
<p>Getting the environment variable instead of an in-memory one can now be done by placing a property in <code>Program.cs</code>, at the top of the class, as follows:</p>
<pre>public static string ConnectionString { get; } = Environment.GetEnvironmentVariable("GlobalFactory", EnvironmentVariableTarget.User);</pre>
<p>This line returns the value of the <code>GlobalFactory</code> environment variable, configured for the local user. In the preceding snippet, you have added this line to <code>Program.cs</code> and made it static because that makes it easily accessible throughout the application. While in big applications, it is not a practice you would want to go for; however, for your purposes here, this is fine.</p>
<p>Before you grasp models—the centerpiece of a program—you need to know about the major versions of EF.</p>
<h3 id="_idParaDest-217"><a id="_idTextAnchor244"/>Which One to Choose—EF or EF Core?</h3>
<p>There are two major versions of EF—EF and EF Core. Both are widely used, but you should be aware of some factors before making the choice that fits your project's requirements the best. EF was first released in 2008. At that time, there was no .NET Core and C# was for <strong class="bold">Windows only</strong> and strictly required .NET Framework. Currently, the latest major version of EF is 6 and it's likely that there won't be any other major version, because in 2016, along with .NET Core 1.0 came EF Core 1 (a rework of EF 6).</p>
<p>EF Core was initially named EF 7. However, it was a complete rewrite of EF 6 and therefore was soon renamed EF Core 1.0. EF works only on .NET and is for Windows only, whereas .NET Core works only on .NET Core and is multi-platform.</p>
<p>Feature-wise, both frameworks are similar and are still being developed. However, the focus these days is on EF Core because the future of C# is associated with .NET 6, which is a multi-platform framework. At the time of writing this book, EF 6 has a richer set of features. However, EF Core is quickly catching up and is likely to soon be ahead. If your project's specifications do not require working with .NET Framework, it is preferable to stick with EF Core.</p>
<p class="callout-heading">Note</p>
<p class="callout">For the latest list of differences between the two, please refer to a comparison by Microsoft here: <a href="https://docs.microsoft.com/en-us/ef/efcore-and-ef6/">https://docs.microsoft.com/en-us/ef/efcore-and-ef6/</a>.</p>
<p>Before you proceed, install the EF Core NuGet package so that you get access to the EF Core API. With the project open in Visual Studio Code (VS Code), run the following line in the terminal:</p>
<pre>dotnet add package Microsoft.EntityFrameworkCore</pre>
<p>By itself, <code>EntityFrameworkCore</code> is just a tool to abstract away database structures. To connect it with a specific database provider, you will need another package. Here you are using PostgreSQL. Therefore, the package you will install is <code>Npgsql.EntityFrameworkCore.PostgreSQL</code>. In order to install it, from the VS Code console, run the following:</p>
<pre>dotnet add package Npgsql.EntityFrameworkCore.PostgreSQL</pre>
<p>You are now aware of the two versions of EF and how they work with .NET Framework and .NET. The next section will delve into the models which are the heart of a program.</p>
<h3 id="_idParaDest-218"><a id="_idTextAnchor245"/>Model</h3>
<p>A class designed to represent a business object is called a model. It always has data managed by properties or methods. Models are the centerpiece of a program. They don't depend on anything; other parts of a program point to them.</p>
<p>An object to which an ORM maps data tables is called an entity. In simple applications, an entity and a model are the same class. In complex applications, a change to a database is a common thing. That means that entities change often, and if you do not have a separate class for a model, your model would be impacted as well. Business logic should be isolated from database changes, and it is therefore recommended to have two classes—one for an entity and one for a model.</p>
<p>Before you continue with the next section, have a quick look at the <code>factory.product</code> and <code>factory.manufacturer</code> tables. One manufacturer makes many products. The following Entity Relationship (ER) diagram illustrates this relationship in <em class="italic">Figure 6.2</em>.</p>
<div><div><img alt="Figure 6.2: ER diagram of products and manufacturers " height="727" src="img/B16835_06_02.jpg" width="1133"/>
</div>
</div>
<p> </p>
<p class="figure-caption">Figure 6.2: ER diagram of products and manufacturers</p>
<p>An entity, ideally, should mirror table columns. You can mirror columns through properties. For example, a <code>factory.product</code> table has <code>id</code>, <code>name</code>, <code>price</code>, and <code>manufacturerId</code>. An object that maps to that would look like this:</p>
<pre>public class Product
{
    public int id { get; set; }
    public string name { get; set; }
    public decimal price { get; set; }
    public int manufacturerId { get; set; }
}</pre>
<p>You know that only the price of a product can change; the rest of the properties would not. However, in the preceding snippet, a setter has still been written for every property. This is because entities created through an ORM always need to have all properties with setters, or else it might not set the value.</p>
<p>An entity should be designed to match a table structure, but it does not always have to be that way. For example, if the <code>Id</code> property were renamed to <code>PrimaryKey</code>, you could still use EF the same way by using a special data annotation <code>[Key]</code>:</p>
<pre>public class Product
{
    [Key]
    public int PrimaryKey { get; set; }
    public string name { get; set; }
    public decimal price { get; set; }
    public int manufacturerId { get; set; }
}</pre>
<p>Data Annotation is an attribute that adds metadata to a property. You can use it to provide a different name, have a constraint column as a key, add the minimum and maximum lengths for fields, add precision, declare a field as mandatory, and more. On their own, data annotations don't do anything. They don't add logic to a model. Some other components will consume annotated objects, which will involve reading their attributes and performing actions based on that.</p>
<p>Your model (illustrating the ER diagram from <em class="italic">Figure 6.2</em>) is almost complete, but there are a few problems to be addressed:</p>
<ul>
<li>First, the table-model mapping is missing a schema (<code>factory</code>, in this case), and so you need to specify it explicitly using a <code>Table</code> attribute.</li>
<li>Second, by default if you wanted to also retrieve a <code>manufacturer</code>, you would need another query. You can fix this by adding a navigational property that refers to the manufacturer. But why should you use a navigational property? If there were only an ID, you would need a separate query to get the related entity. However, using navigational properties, you can use eager loading and get two or more entities at once.</li>
</ul>
<p>The following code snippet will show you how to create a <code>Manufacturer</code> class and fix these issues for both models:</p>
<pre>[Table("manufacturer", Schema = "factory")]
public class Manufacturer
{
    public int id { get; set; }
    public string name { get; set; }
    public string country { get; set; }
    public virtual ICollection&lt;Product&gt; Products { get; set; } = new List&lt;Product&gt;();
}</pre>
<p>Note the new <code>List&lt;Product&gt;();</code> part. It is needed so that if a table does not yet have products, the code would still function when you try to add a new product without throwing <code>NullReferenceException</code>.</p>
<p>In the following snippet of code, a model is created for a product table:</p>
<pre>[Table("product", Schema = "factory")]
public class Product
{
    public int id { get; set; }
    public string name { get; set; }
    public decimal price { get; set; }
    public int manufacturerId { get; set; }
    public virtual Manufacturer Manufacturer { get; set; }
}</pre>
<p>The two models are complete for mapping to tables from your database. You did not replace an ID property with a navigational property; both are present. If you did not do this, it would require the parent entity (<code>Manufacturer</code>) to be fetched before you could do anything with a product. With this approach, you can work with a product in isolation from the manufacturer. All you need is an ID link.</p>
<p>On top of the mentioned fixes, you made your navigational properties (<code>Manufacturer</code> and <code>Products</code>) virtual. This is needed to enable lazy loading for EF. Lazy loading means that there is no data loaded in a property until that property is referenced.</p>
<p>Finally, it is worth mentioning that for manufacturer products, you used <code>ICollection</code> and not <code>IEnumerable </code>or other collections. This makes sense because EF will need to populate the collection when it retrieves and map the items. <code>List</code> or even <code>Set</code> could work, but when designing object-oriented code, you should focus on the highest abstraction you can depend on, in this case it is <code>ICollection</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/gfgB1">https://packt.link/gfgB1</a>.</p>
<p>In order to run this example, go to <a href="https://packt.link/2oxXn">https://packt.link/2oxXn</a> and comment all lines within the <code>static void</code> <code>Main(string[] args)</code> body, except <code>Examples.TalkingWithDb.Orm.Demo.Run();</code>.</p>
<p>You are now clear about the entity, models, entity relationship, data annotation, eager loading, and lazy loading. The next section will show you how to combine everything and communicate with a database through EF Core.</p>
<h2 id="_idParaDest-219"><a id="_idTextAnchor246"/>DbContext and DbSet</h2>
<p><code>DbContext</code> is what EF uses as an abstraction to a database. A new database abstraction must be derived from the <code>DbContext</code> class and provide a way of connecting to a database. Just like a database contains one or more tables, <code>DbContext</code> contains one or more <code>DbSet</code> entities. For example, consider the following code:</p>
<pre>public class FactoryDbContext : DbContext
{
    public DbSet&lt;Product&gt; Products { get; set; }
    public DbSet&lt;Manufacturer&gt; Manufacturers { get; set; }
    
    protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
    {
        if (!optionsBuilder.IsConfigured)
        {
            optionsBuilder.UseNpgsql(Program.GlobalFactoryConnectionString);
        }
    }
}</pre>
<p>Here, <code>FactoryDbContext</code> is an abstraction of the database that you created before, with two tables: <code>Products</code> and <code>Manufacturers</code>. The <code>OnConfiguring</code> method takes <code>DbContextOptionsBuilder</code>, which allows you to specify what database you want to connect to and how that connection is made. In this case, you are using PostgreSQL Server and specifying a database to connect to. Please note that in case there is an already configured database provider then you will not use <code>Npgsql</code> in the <code>if</code> statement i.e., the <code>if (!optionsBuilder.IsConfigured)</code> statement.</p>
<p>It is important to note that you should not completely depend on a specific database provider for two reasons:</p>
<ul>
<li>Firstly, changing a database provider is easy; it is just a matter of using a different extension method on a builder.</li>
<li>Secondly, EF has an in-memory database provider, which is effective for testing. Alternatively, you could use SQLite as well as a lightweight database meant just for testing.</li>
</ul>
<p>Currently, your database abstraction needs improvement because it only lets you communicate with the SQL Server database. Instead of hardcoding the options, you will inject them. Injecting allows you to configure an existing class differently, without modifying it. You do not need to change the models to be able to choose the database you want to connect to. You can specify which database you want to connect to by passing an <code>options</code> object through the <code>FactoryDbContext</code> constructor:</p>
<pre> public FactoryDbContext(DbContextOptions&lt;FactoryDbContext&gt; options)
    : base(options)
{
}</pre>
<p>The default constructor is for the default provider, which will be used when no options are supplied. In this case, the context was designed to use PostgreSQL; therefore, you would add the following code:</p>
<pre>public FactoryDbContext()
    : base(UsePostgreSqlServerOptions())
{
}</pre>
<p><code>DbContext</code> can be configured using <code>DbContextOptions</code>. In this example, you need to configure a database provider (PostgreSQL) and a connection string. Choose the provider using <code>DbContextOptionsBuilder</code>. The <code>UseNpgsql</code> is how you hook the PostgreSQL provider with your database context, as shown here:</p>
<pre>protected static DbContextOptions UsePostgreSqlServerOptions()
{
    return new DbContextOptionsBuilder()
        .UseNpgsql(Program.ConnectionString)
        .Options;
}</pre>
<p>The full <code>DbContext</code> now looks like this:</p>
<pre>FactoryDbContext.cs
public class FactoryDbContext : DbContext
{
    public DbSet&lt;Product&gt; Products { get; set; }
    public DbSet&lt;Manufacturer&gt; Manufacturers { get; set; }
 
 
    public FactoryDbContext(DbContextOptions&lt;FactoryDbContext&gt; options)
        : base(options)
    {
    }
 
    public FactoryDbContext()
        : base(UsePostgreSqlServerOptions())
    {
    }
The complete code can be found here: <a href="https://packt.link/0uVPP">https://packt.link/0uVPP</a>.</pre>
<p>In order to run this example, go to <a href="https://packt.link/2oxXn">https://packt.link/2oxXn</a> and comment all lines within the <code>static void</code> <code>Main(string[] args)</code> body, except <code>Examples.TalkingWithDb.Orm.Demo.Run();</code>.</p>
<p>To get the products from the database you have made, you first connect to a database by initializing an instance of your <code>DbContext</code>. You then call a wanted <code>DbSet</code> from that context and send a call to a database by calling <code>ToList()</code>:</p>
<pre>using var context = new FactoryDbContext();
var products = context.Products.ToList();</pre>
<p>In this case, you create a <code>FactoryDbContext</code> (which creates a connection to the <code>GlobalFactory</code> database) and the <code>context.Products.ToList()</code> equates to a <code>SELECT * FROM Products</code> SQL statement.</p>
<p class="callout-heading">Note</p>
<p class="callout">The two lines mentioned are not included within GitHub. They are trivial and are here only for illustrative purposes.</p>
<p>When you initialize a <code>DbContext</code>, you almost always create a connection to a database, and if not managed, you might eventually run out of connections inside a connection pool (a collection of available connections). <code>DbContext</code> is an unmanaged resource; it implements the <code>IDisposable</code> interface, and so it needs explicit cleanup. Here, you applied a C# feature—inline using—which disposes of the object after it leaves the scope it is at:</p>
<pre>using var context = new FactoryDbContext()</pre>
<p>When you have a <code>DbContext</code>, getting data from it is trivial:</p>
<ul>
<li>Access a <code>DbSet</code>.</li>
<li>Convert it into a list.</li>
</ul>
<p>Why do you need to make any conversions, though? That is because <code>DbSet</code>, much like <code>IEnumerable</code>, is lazy-loaded. It encapsulates the SQL needed to execute. So, unless you explicitly demand it (for example, by calling <code>ToList</code>), there won't be any data queried. Calling <code>ToList</code> does the actual call to a database and retrieves all the products.</p>
<p>You now know all about databases. The next section will touch on the <code>AdventureWorks</code> database which is a common database for teaching SQL to beginners.</p>
<h3 id="_idParaDest-220"><a id="_idTextAnchor247"/>AdventureWorks Database</h3>
<p><code>AdventureWorks</code> is a database used for learning purposes. It contains dozens of tables and has hundreds of records in each table. The tables are focused on wholesale, which is a common scenario in enterprise applications. In other words, the <code>AdventureWorks</code> database provides examples for learning with closeness to real-world problems.</p>
<p class="callout-heading">Note</p>
<p class="callout">You must first create the <code>AdventureWorks</code> database in PostgreSQL. You can find the steps to create this database in the reference chapter placed on GitHub.</p>
<p>The previous sections covered entity, models, and how to combine everything and communicate with a database. You also learned about <code>DbContext</code> and <code>DbSet</code>. This concludes the theoretical portion of this section. In the following section, you will put this into practice with an exercise.</p>
<h2 id="_idParaDest-221"><a id="_idTextAnchor248"/>Exercise 6.01: Reading Stock Locations from AdventureWorks Database</h2>
<p>The simplest use case of EF is to read data tables into C# objects. This exercise will teach you how to create a data entity class and add correct attributes to it. For this, you will create an inventory <code>location</code> table within the example <code>AdventureWorks</code> database. Perform the following steps to do so:</p>
<ol>
<li value="1">Create a <code>Location</code> entity. It should have <code>LocationId</code>, <code>Name</code>, <code>Costrate</code>, <code>Availability</code>, and <code>ModifiedDate</code> properties, as follows:<pre>[Table("location", Schema = "production")]
public class Location
{
    [Column("locationid")]
    public int LocationId { get; set; }
    [Column("name")]
    public string Name { get; set; }
    [Column("costrate")]
    public double Costrate { get; set; }
    [Column("availability")]
    public double Availability { get; set; }
    [Column("modifieddate")]
    public DateTime ModifiedDate { get; set; }
}</pre></li>
</ol>
<p>A <code>[Table]</code> attribute has been applied because you need to specify a schema as well as a properly capitalized table name. On top of that, every column name needs to be explicitly specified using the <code>[Column]</code> attribute since the capitalization does not match.</p>
<ol>
<li value="2">Create a class named <code>AdventureWorksContext</code>, which inherits the <code>DbContext</code>, as follows:<pre>public class AdventureWorksContext : DbContext
{
    public DbSet&lt;Location&gt; Locations { get; set; }
 
    public AdventureWorksContext()
        : base(UsePostgreSqlServerOptions())
    {
    }
 
    protected static DbContextOptions UsePostgreSqlServerOptions()
    {
        return new DbContextOptionsBuilder()
            .UseNpgsql(Program.AdventureWorksConnectionString)
            .Options;
    }</pre></li>
</ol>
<p>Inheriting <code>DbContext</code> is necessary if you want to reuse the base functionality of database abstraction such as connecting to a database. The use of base functionality is visible in the two base constructors. In the parameterized constructor, you use PostgreSQL; in non-parameterized you can supply whatever database provider you choose.</p>
<ol>
<li value="3">Now use the <code>Program.AdventureWorksConnectionString</code> connection string as follows:<pre>Host=localhost;Username=postgres;Password=****;Database=Adventureworks. DbSet&lt;Location&gt;Locations</pre></li>
</ol>
<p>This represents the needed <code>location</code> table.</p>
<p class="callout-heading">Note</p>
<p class="callout">Please keep your PostgreSQL passwords safe. Don't write them in code in plaintext, instead use environment variables or secrets.</p>
<ol>
<li value="4">Connect to a database:<pre>var db = new AdventureWorksContext();</pre></li>
</ol>
<p>This is as simple as creating a new <code>DbContext</code>.</p>
<ol>
<li value="5">Get all products by adding the following code:<pre>var locations = db.Locations.ToList();</pre></li>
<li>Now that you have queried the locations and no longer need to keep the connection open, it is better to disconnect from the database. In order to disconnect from the database, call the <code>Dispose</code> method as follows:<pre>db.Dispose();</pre></li>
<li>Print the results by adding the following code:<pre>foreach (var location in locations)
{
    Console.WriteLine($"{location.LocationId} {location.Name} {location.Costrate} {location.Availability} {location.ModifiedDate}");
}</pre></li>
</ol>
<p>The code itself is run from <a href="https://packt.link/2oxXn">https://packt.link/2oxXn</a>. Make sure to comment all lines within <code>static void</code> <code>Main(string[] args)</code> body, except <code>Exercises.Exercise03.Demo.Run()</code>. When you run the code, the following output gets displayed:</p>
<pre>1 Tool Crib 0 0 2008-04-30 00:00:00
2 Sheet Metal Racks 0 0 2008-04-30 00:00:00
3 Paint Shop 0 0 2008-04-30 00:00:00
4 Paint Storage 0 0 2008-04-30 00:00:00
5 Metal Storage 0 0 2008-04-30 00:00:00
6 Miscellaneous Storage 0 0 2008-04-30 00:00:00
7 Finished Goods Storage 0 0 2008-04-30 00:00:00
10 Frame Forming 22,5 96 2008-04-30 00:00:00
20 Frame Welding 25 108 2008-04-30 00:00:00
30 Debur and Polish 14,5 120 2008-04-30 00:00:00
40 Paint 15,75 120 2008-04-30 00:00:00
45 Specialized Paint 18 80 2008-04-30 00:00:00
50 Subassembly 12,25 120 2008-04-30 00:00:00
60 Final Assembly 12,25 120 2008-04-30 00:00:00</pre>
<p>Working with EF is simple. As you can see from this exercise, it is intuitive and feels like a natural extension to C#.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/9Weup">https://packt.link/9Weup</a>.</p>
<h1 id="_idParaDest-222"><a id="_idTextAnchor249"/>Querying a Database—LINQ to SQL</h1>
<p>One of the more interesting features of EF is that running SQL statements is very much like working with a collection. For example, say you want to retrieve a product by its name. You can get a product by name the same way you would be using LINQ:</p>
<pre>public Product GetByName(string name)
{
    var product = db.Products.FirstOrDefault(p =&gt; p.Name == name);
    return product;
}</pre>
<p>Here, <code>FirstOrDefault</code> returns the first matching product by its name. If no product by that name exists, then it returns a <code>null</code>.</p>
<p>What about finding a unique element by its ID? In that case, you would use a special method (<code>Find</code>), which either gets an entity from a database or, if one with the same ID has been retrieved recently, returns it from memory:</p>
<pre>public Product GetById(int id)
{
    var product = db.Products.Find(id);
    return product;
}</pre>
<p>When using a primary key, it is better to use <code>Find</code> instead of <code>Where</code> because it has a slightly different meaning in the context of EF. Instead of trying to create a SQL query and execute it, <code>Find</code> will check whether this item has already been accessed and will retrieve it from a cache, rather than going through a database. This makes for more efficient operations.</p>
<p>What about finding all products by the related manufacturer ID? You can create a method that returns an <code>IEnumerable&lt;Product&gt;</code> for this purpose, named <code>GetByManufacturer</code>, as follows:</p>
<pre>public IEnumerable&lt;Product&gt; GetByManufacturer(int manufacturerId)
{    var products = db
        .Products
        .Where(p =&gt; p.Manufacturer.Id == manufacturerId)
        .ToList();
 
    return products;
}</pre>
<p>You might be wondering why you should choose to use <code>Where</code> instead of <code>Find</code> here. That is because you are getting many products by their foreign key <code>manufacturerId</code>. Be careful not to mix foreign and primary keys; <code>Find</code> is used only for primary keys.</p>
<p>In order to run this example, go to <a href="https://packt.link/2oxXn">https://packt.link/2oxXn</a> and comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.Crud.Demo.Run();</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/pwcwx">https://packt.link/pwcwx</a>.</p>
<p>Now, how about retrieving related entities? If you simply call <code>db.Manufacturers.ToList()</code>, you will have null products. This is because the products will not be retrieved automatically unless explicitly specified. If you didn't call <code>ToList()</code>, you could make use of lazy-loading (that is, loading the required entities on demand), but that would result in a very suboptimal solution as you would always be querying child entities for every parent.</p>
<p>A proper solution is to call <code>Include(parent =&gt; parent.ChildToInclude)</code>:</p>
<pre>db.Manufacturers
.Include(m =&gt; m.Products)
.ToList();</pre>
<p>This approach is called eager loading. With this approach, you specify which child entities should be retrieved immediately. There will be scenarios where child entities will have their child entities; there, you could call <code>ThenInclude</code>. In order to run this example, comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.Crud.Demo.Run();</code> in <code>Program.cs</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/c82nA">https://packt.link/c82nA</a>.</p>
<p>Remember when it was established that trying to get everything from a table is not the right thing to do in most cases? Eager loading has the same problem. So, what should you do if you only want some properties? It's time to learn about the other side of LINQ.</p>
<h2 id="_idParaDest-223"><a id="_idTextAnchor250"/>Query Syntax</h2>
<p>Query syntax is an alternative syntax to LINQ lambdas. It is very similar to SQL. The main advantage of query syntax over lambdas is that it feels more natural to write queries when you have complex joins and want only some of the data back. Imagine you wanted to get all product-manufacturer name pairs. You cannot simply get manufacturers and include products; you only want two products. If you tried using LINQ, the code would like the following:</p>
<pre>db.Products
.Join(db.Manufacturers,
    p =&gt; p.ManufacturerId, m =&gt; m.Id,
    (p, m) =&gt; new {Product = p.Name, Manufacturer = m.Name})
.ToList();</pre>
<p>The same operation using query syntax looks like this:</p>
<pre>(from p in db.Products
join m in db.Manufacturers
    on p.ManufacturerId equals m.Id
select new {Product = p.Name, Manufacturer = m.Name}
).ToList();</pre>
<p>Break the code down:</p>
<pre>from p in db.Products</pre>
<p>Now select all products and their columns:</p>
<pre>join m in db.Manufacturers</pre>
<p>For every product, add manufacturer columns like this:</p>
<pre>on p.ManufacturerId equals m.Id</pre>
<p>Manufacturer columns are added only for products which have <code>ManufacturerId</code> equal to the <code>Id</code> of the manufacturer (<code>INNER JOIN</code>).</p>
<p class="callout-heading">Note</p>
<p class="callout">Why can't you write <code>==</code> instead of <code>equals</code>? That is because, in LINQ query syntax, <code>equals</code> completes a join; it is not just a comparison of two values.</p>
<p>The <code>select</code> part is the same in both lambda and query syntax; however, it's worth mentioning what you selected. The <code>select new {...}</code> means that you create a new anonymous object to have all the things you want to select. The idea is to later use this to return a strongly typed object that you need. Therefore, after a <code>ToList</code> method, you are likely to perform another <code>select</code> operation to map the results for the final return. You cannot do the mapping right away because before you do <code>ToList</code>, you are still working with an expression that is yet to be converted into SQL. Only after <code>ToList</code> is called can you be sure that you are working with C# objects.</p>
<p>Finally, you may be wondering why the join is surrounded by brackets before calling <code>ToList</code>. That's because you were still in query syntax mode and the only way to escape it and go back to normal LINQ is by surrounding it with brackets.</p>
<p>If you struggle to remember LINQ query syntax, remember a <code>foreach</code> loop:</p>
<pre><strong class="bold">foreach(var</strong> product in db.Products<strong class="bold">)</strong></pre>
<p>The query syntax of <code>from</code> is as follows:</p>
<pre>from <strong class="bold">product in db.Products</strong></pre>
<p>The highlighted part in the preceding code snippet is the syntax parts that overlap on both. This also applies to join. The two make the most of query syntax.</p>
<p>Both lambda and query syntax has the same performance metrics because, in the end, the query syntax will be compiled into the lambda equivalent. When making complex joins, it might make more sense to use a query syntax because it will look closer to SQL and therefore might be easier to grasp.</p>
<p>Now run the code. In order to run this example, comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.Crud.Demo.Run();</code> in <code>Program.cs</code>:</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/c82nA">https://packt.link/c82nA</a>.</p>
<p>You now know that query syntax is an alternative syntax to LINQ lambdas. But how you can perform the remaining operations with rows that are, create, update, and delete, using query syntax? The next section details how that can be done.</p>
<h2 id="_idParaDest-224"><a id="_idTextAnchor251"/>The Rest of CRUD</h2>
<p>Adding, updating, and removing data using query syntax is also similar to basic LINQ. However, similar to executing the queries by calling <code>ToList</code>, it involves one extra step that is, committing the changes. Consider the following code where you are creating a new product:</p>
<pre>var product = new Product
{
    Name = "Teddy Bear",
    Price = 10,
    ManufacturerId = 1
};
db.Products.Add(product);
db.SaveChanges();</pre>
<p>This code should look almost completely familiar, except for the last line. The <code>SaveChanges</code> method is used to run the actual SQL. If you don't call it, nothing will happen, and the changes will be gone after disconnecting from the database. Also, when adding a child entity (<code>product</code>), you don't have to get a parent entity (<code>manufacturer</code>). All you have to do is to provide a link between the two via the foreign key (<code>ManufacturerId</code>).</p>
<p>Why do you need an extra method to apply your changes? Wouldn't it be simpler to call <code>Add</code> and immediately have a new product row created? In practice, it is not that simple. What happens if multiple <code>Add</code> methods of different entities need to be performed, and what if one of them fails? Should you allow some of them to succeed, while others fail? The worst thing you can do is to put your database in an invalid state, or, in other words, break data integrity. You need a mechanism to either complete fully or fail without affecting anything. </p>
<p>In the SQL context, such commands that are run together are called a transaction. You can do two things with transactions—either commit or roll them back. In EF, every action, other than a query, results in a transaction. The <code>SaveChanges</code> completes the transaction, whereas a command failing rolls the transaction back.</p>
<p>If you were to call plain SQL commands in C#, you would need to create a parameterized SQL command, provide each argument separately, and concatenate SQL for multi-query updates. For a small entity it may be easy; however, as the size grows the complexity increases as well. Using EF, you don't need to care about low-level details, such as passing arguments to a command. For example, with EF, adding a <code>manufacturer</code> with a few products is as simple as adding a <code>manufacturer</code> to a <code>Manufacturers</code> list:</p>
<pre>var manufacturer = new Manufacturer
{
    Country = "Lithuania",
    Name = "Toy Lasers",
    Products = new List&lt;Product&gt;
    {
        new()
        {
            Name = "Laser S",
            Price = 4.01m
        },
        new()
        {
            Name = "Laser M",
            Price = 7.99m
        }
    }
};
db.Manufacturers.Add(manufacturer);
db.SaveChanges();</pre>
<p>As you can see, creating manufacturers is nearly the same as adding an element to a list. The major difference is the need to complete the changes using <code>db.SaveChanges()</code> method.</p>
<p>What about updating an existing product? Set the price of a product to <code>45.99</code>:</p>
<pre>var productUpdate = new Product
{
    Id = existingProduct.Id,
    Price = 45.99m,
    ManufacturerId = existingProduct.ManufacturerId,
    Name = existingProduct.Name
};
db.Products.Update(productUpdate);
 db.SaveChanges();</pre>
<p>If you look carefully at this code, you are provided with not only the updated <code>Price</code> and an existing item <code>Id</code> but also all other fields. This is because there is no way for EF to know whether you want to set existing values to null or only set the new values. But don't worry; logically, there is rarely a case when you update something out of nowhere. You should have a set of items loaded somewhere. Therefore, updating an existing object would simply be a matter of setting a new value of a property of that object.</p>
<p>Of course, there are exceptions when you want to update just one thing. In that case, you can have a dedicated method and be completely in control. In the following snippet, you will update product values, but only when they are not null:</p>
<pre>var productToUpdate = db.Products.Find(productUpdate.Id);
var anyProductToUpdate = productToUpdate != null;
if (anyProductToUpdate)
{
    productToUpdate.Name = productUpdate.Name ?? productToUpdate.Name;
 
    productToUpdate.ManufacturerId = (productUpdate.ManufacturerId != default)
        ? productUpdate.ManufacturerId
        : productToUpdate.ManufacturerId;
 
    productToUpdate.Price = (productUpdate.Price != default)
        ? productUpdate.Price
        : productToUpdate.Price;
 
    db.SaveChanges();
}</pre>
<p>Here, you would only update the values if they were not the default ones. Ideally, when working in situations like this (in which you only want to update some of the fields), you should have a dedicated model for the updated fields, send those fields, and map them using libraries such as AutoMapper.</p>
<p class="callout-heading">Note</p>
<p class="callout">To learn more about AutoMapper, refer to their official documentation at <a href="https://docs.automapper.org/en/stable/Getting-started.xhtml">https://docs.automapper.org/en/stable/Getting-started.xhtml</a>.</p>
<p>What about deleting existing rows from a database? This involves first getting the object you want to remove and only then remove it. For example, say you want to remove a product with a particular ID:</p>
<pre>var productToDelete = db.Products.Find(productId);
if (productToDelete != null)
{
    db.Products.Remove(productToDelete);
    db.SaveChanges();
} </pre>
<p>Once again, removing something from a database is nearly the same as removing an element from a list with a small difference that <code>db.SaveChanges()</code> is used to confirm the changes. In order to run this example, comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.Crud.Demo.Run();</code> in <code>Program.cs</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/bH5c4">https://packt.link/bH5c4</a>.</p>
<p>You have grasped that the basic concept of CRUD is a combination of four functions—create, read, update, and delete. Now it is time to put this into practice in the following exercise.</p>
<h2 id="_idParaDest-225"><a id="_idTextAnchor252"/>Exercise 6.02: Updating Products and Manufacturers Table</h2>
<p>You have already created a <code>GlobalFactory</code> database with <code>Products</code> and <code>Manufacturers</code> tables, and you now have enough components to perform full Create, Read, Update and Delete (CRUD) on the database. In this exercise, you will use <code>FactoryDbContext</code> to create methods inside a new class called <code>GlobalFactoryService</code>, which can accomplish the following tasks:</p>
<ul>
<li>Add a list of manufacturers in the US.</li>
<li>Add a list of products to all manufacturers in the US.</li>
<li>Update any one product in the US with a given discount price.</li>
<li>Remove any one product from the US region.</li>
<li>Get all manufacturers from the US and their products.</li>
</ul>
<p>Perform the following steps to complete this exercise:</p>
<ol>
<li value="1">First, create a <code>GlobalFactoryService</code> class.</li>
<li>Create <code>FactoryDbContext</code> inside a constructor and inject the context. Injecting the context means that you have a choice of setting it up in any way you want (for example, using different providers).</li>
<li>Create a constructor that accepts <code>FactoryDbContext</code> as an argument, as follows:<pre>public class GlobalFactoryService : IDisposable
{
    private readonly FactoryDbContext _context;
 
    public GlobalFactoryService(FactoryDbContext context)
    {
        _context = context;
    }</pre></li>
<li>Create a <code>public void CreateManufacturersInUsa(IEnumerable&lt;string&gt; names)</code> method, as follows:<pre>public void CreateManufacturersInUsa(IEnumerable&lt;string&gt; names)
{
    var manufacturers = names
        .Select(name =&gt; new Manufacturer()
        {
            Name = name,
            Country = "USA"
        });
 
    _context.Manufacturers.AddRange(manufacturers);
    _context.SaveChanges();
}</pre></li>
</ol>
<p>A manufacturer has only two custom fields—<code>Name</code> and <code>Country</code>. In this case, the value of the <code>Country</code> is known to be <code>"USA"</code>. All you have to do is to pass a list of manufacturer <code>names</code> and build <code>Manufacturers</code> by combining the value of the <code>Country</code> with their name.</p>
<ol>
<li value="5">To create the products, create a <code>public void CreateUsaProducts(IEnumerable&lt;Product&gt; products)</code> method.</li>
<li>Then get all the manufacturers in the US.</li>
<li>Finally, iterate each manufacturer and add all the products to each of them:<pre>public void CreateUsaProducts(IEnumerable&lt;Product&gt; products)
{
    var manufacturersInUsa = _context
        .Manufacturers
        .Where(m =&gt; m.Country == "USA")
        .ToList();
 
    foreach (var product in products)
    {
        manufacturersInUsa.ForEach(m =&gt; m.Products.Add(
            new Product {Name = product.Name, Price = product.Price}
            ));
    }
 
    _context.SaveChanges();
}</pre></li>
</ol>
<p>Note that in this example, you have recreated a new product every time that you add the same product to a manufacturer. This is done because even though the product has the same properties, it belongs to a different manufacturer. In order for that distinction to be set, you need to pass different objects. If you do not do that, the products will be assigned to the same (last referenced) manufacturer.</p>
<ol>
<li value="8">Create a <code>public void SetAnyUsaProductOnDiscount(decimal discountedPrice)</code> method.</li>
<li>To set any USA product on discount, first get all the products from the US region and then select the first of them (order doesn't matter).</li>
<li>Next set a new <code>Price</code> for that product, and call <code>SaveChanges()</code> to confirm it:<pre>public void SetAnyUsaProductOnDiscount(decimal discountedPrice)
{
    var anyProductInUsa = _context
        .Products
        .FirstOrDefault(p =&gt; p.Manufacturer.Country == "USA");
 
    anyProductInUsa.Price = discountedPrice;
 
    _context.SaveChanges();
}</pre></li>
<li>Create a <code>public void RemoveAnyProductInUsa()</code> method.</li>
<li>To delete an item, simply select the first product in the <code>"USA"</code> group and remove it:<pre>public void RemoveAnyProductInUsa()
{
    var anyProductInUsa = _context
        .Products
        .FirstOrDefault(p =&gt; p.Manufacturer.Country == "USA");
 
    _context.Remove(anyProductInUsa);
    _context.SaveChanges();
}</pre><p class="callout-heading">Note</p><p class="callout">Observe that the <code>SaveChanges</code> has been called after every step.</p></li>
<li>In order to get a manufacturers from USA, create a <code>public IEnumerable&lt;Manufacturer&gt; GetManufacturersInUsa()</code> method.</li>
<li>Call the <code>ToList()</code> at the end of a query so that the SQL gets executed:<pre>  public IEnumerable&lt;Manufacturer&gt; GetManufacturersInUsa()
  {
      var manufacturersFromUsa = _context
          .Manufacturers
          .Include(m =&gt; m.Products)
          .Where(m =&gt; m.Country == "USA")
          .ToList();
 
      return manufacturersFromUsa;
  }
}</pre></li>
<li>Create a <code>Demo</code> class where you call all functions:<pre>Demo.cs
public static class Demo
{
    public static void Run()
    {
        var service = new GlobalFactoryService(new FactoryDbContext());
        service.CreateManufacturersInUsa(new []{"Best Buy", "Iron Retail"});
        service.CreateUsaProducts(new []
        {
            new Product
            {
                Name = "Toy computer",
                Price = 20.99m
            },
            new Product
            {</pre></li>
</ol>
<pre>The complete code can be found here: <a href="https://packt.link/qMYbi">https://packt.link/qMYbi</a>.</pre>
<p>In order to run this exercise, comment all lines within <code>static void Main(string[] args)</code> body except <code>Exercises.Exercise02.Demo.Run();</code> in <code>Program.cs</code>. The output of the preceding code will be as follows:</p>
<pre>Best Buy:
Loli microphone 5
Iron Retail:
Toy computer 20,99
Loli microphone 7,51</pre>
<p>This output shows exactly what you wanted to achieve. You created two manufacturers: <code>Best Buy</code> and <code>Iron Retail</code>. Each of them had two products, but from the first manufacturer, <code>Best Buy</code>, you removed one. Therefore, only a single product appears under it, as opposed to two products under <code>Iron Retail</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/uq97N">https://packt.link/uq97N</a>.</p>
<p>At this point, you know how to interact with an existing database. However, what you have done so far is manually written models to fit the <code>GlobalFactory</code> database you have created. Using EF, you only need one side—either a database or a <code>DbContext</code> schema. In the next sections, you will learn how to work with either approach.</p>
<h2 id="_idParaDest-226"><a id="_idTextAnchor253"/>Database First</h2>
<p>In some cases, you won't have to design a database yourself. Often, an architect will do that for you and then a database administrator will handle further changes. In other cases, you may get to work with some really old projects and a legacy database. Both scenarios are perfect for a database first approach because you can generate a <code>DbContext</code> schema with all the needed models using an existing database.</p>
<p>The project selected must be an executable project. For example, <code>WebApi</code> and <code>ConsoleApp</code> are okay; however, a class library is not (you cannot run a class library; you can only reference it from other applications). So, install EF tools by running this in the console:</p>
<pre>dotnet add package Microsoft.EntityFrameworkCore.tools</pre>
<p>Finally, run the following:</p>
<pre>dotnet ef dbcontext scaffold "Host=localhost;Username=postgres;Password=****;Database=Adventureworks" Npgsql.EntityFrameworkCore.PostgreSQL -o your/models/path --schema "production"</pre>
<p>This command reads the database schema (you specified to generate the database from all the schemas rather than just one production schema) and generates models out of it. You used the <code>AdventureWorks</code> database. Using the <code>-o</code> flag, you select the output directory, and using the <code>–schema</code> flag, you specify the schemas you would like to generate the database from.</p>
<p class="callout-heading">Note</p>
<p class="callout">The generated models from an existing database can be found at <a href="https://packt.link/8KIOK">https://packt.link/8KIOK</a>.</p>
<p>The models generated are quite interesting. They reveal two things that have not yet been talked about. When you created a <code>Manufacturer</code> class (read the <em class="italic">Modeling Databases Using EF</em> section), you did not initialize a collection of products from a constructor. This is not a big issue, but instead of not returning data, you get a null reference exception, which might not be what you want. None of the models, no matter how simple or complex they are, have attributes.</p>
<p>You are almost done with the db-first approach. The next section will revisit <code>DbContext</code> and inspect how EF does it so you can then apply what you learned in a code-first approach.</p>
<h3 id="_idParaDest-227"><a id="_idTextAnchor254"/>Revisiting DbContext</h3>
<p>By logically grasping the following snippet, <code>AdventureWorksContext</code>, you will notice that the default configuration is passed slightly differently from the one created in the <em class="italic">DbContext and DbSet</em> section. Instead of directly using a connection string for SQL Server, the generated context uses the <code>OnConfiguring</code> method to double-check the given context options and if they are unconfigured, set one. This is a cleaner approach because you don't have to manually initialize the builder yourself and prevent unconfigured options:</p>
<pre>public globalfactory2021Context()
        {
        }
        public globalfactory2021Context(DbContextOptions&lt;globalfactory2021Context&gt; options)
            : base(options)
        {
        } 
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            if (!optionsBuilder.IsConfigured)
            {
                optionsBuilder.UseNpgsql(Program.GlobalFactoryConnectionString);
            }
        }</pre>
<p>Next, there is a method named <code>OnModelCreating</code>. It is a method that takes <code>ModelBuilder</code> that is used to dynamically build models for your database. <code>ModelBuilder</code> directly replaces the attribute-based approach because it allows you to keep the models attribute-free and add whatever constraints or mappings are needed when the context is initialized. It includes column names, constraints, keys, and indexes.</p>
<p><code>ModelBuilder</code> allows you to use Fluent API (that is, method chaining), which in turn allows you to add extra configurations to models. Consider the following single, fully configured model:</p>
<pre>globalfactory2021Context.cs
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
modelBuilder.Entity&lt;Manufacturer&gt;(entity =&gt;
{
              entity.ToTable("manufacturer", "factory");
 
              entity.Property(e =&gt; e.Id)
                      .HasColumnName("id")
                      .UseIdentityAlwaysColumn();
 
              entity.Property(e =&gt; e.Country)
                      .IsRequired()
                      .HasMaxLength(50)
                      .HasColumnName("country");
The complete code can be found here: <a href="https://packt.link/S5s6d">https://packt.link/S5s6d</a>.</pre>
<p>Looking at this part of <code>ModelBuilder</code> will give you a full picture of how the model maps to a table and its columns, keys, indexes, and relations. The generated code is broken down for you. To begin configuring an entity, you need to call the following:</p>
<pre>modelBuilder.Entity&lt; Manufacturer &gt;(entity =&gt;</pre>
<p>Mapping to the table and schema looks like this:</p>
<pre>entity.ToTable("manufacturer", "factory");</pre>
<p>You can also add constraints (for example, to make sure that a field is not null) and set the character limit and name of a column the property maps to. In the following code, you're doing so for <code>Name</code>:</p>
<pre>entity.Property(e =&gt; e.Name)
        .IsRequired()
        .HasMaxLength(50)
   .HasColumnName("name");</pre>
<p>Lastly, some entities have multiple navigational properties associated with them. When multiple navigational properties are involved, EF may not be able to clearly interpret what the relationship should be. In those cases, you will need to configure it manually, as shown in the following code:</p>
<pre>                entity.HasOne(d =&gt; d.Manufacturer)
                    .WithMany(p =&gt; p.Products)
                    .HasForeignKey(d =&gt; d.Manufacturerid)
                    .HasConstraintName("product_manufacturerid_id");</pre>
<p>The preceding code maps the <code>Manufacturer</code> entity to <code>Product</code> with a 1:n relationship and sets the foreign key column to <code>product_manufacturerid_id</code>. Spotting those cases might be tricky; therefore, you should only add manual configurations when an error informs you about such an ambiguity:</p>
<pre>Unable to determine the relationship represented by navigation property Entity.NavProperty' of type 'AnotherEntity'. Either manually configure the relationship, or ignore this property from the model.</pre>
<p class="callout-heading">Note</p>
<p class="callout">There is no runnable code here; this is just a scaffold of a database.</p>
<p>Now you know what a generated <code>DbContext</code> looks like and how to customize models yourself. Without touching model classes, and instead using <code>ModelBuidler</code>, it is time to get familiar with doing the opposite, which is generating a database out of the context.</p>
<h3 id="_idParaDest-228"><a id="_idTextAnchor255"/>Generating DbContext from an Existing Database</h3>
<p>For subsequent examples, you will be using the <code>GlobalFactory2021</code> database. Just to be sure that what you have made is the same as what the database contains, you'll perform database scaffolding one more time. Scaffolding is an operation that takes a database schema (or <code>DbContext</code>, in this case) and generates a physical database out of it.</p>
<p>Open the console and run the following:</p>
<pre>dotnet ef dbcontext scaffold "Host=localhost;Username=postgres;Password=****;Database=globalfactory2021" Npgsql.EntityFrameworkCore.PostgreSQL -o Examples/GlobalFactory2021.</pre>
<p>For security, do not forget to replace the hardcoded connection string in <code>DbContext</code> with the one from the environment variable. The resulting <code>DbContext</code> should look like this:</p>
<div><div><img alt="Figure 6.3: DbContext generated after applying the scaffold command " height="141" src="img/B16835_06_03.jpg" width="898"/>
</div>
</div>
<p class="figure-caption">Figure 6.3: DbContext generated after applying the scaffold command</p>
<p>One of the main advantages of EF is that you can quickly define entities and then create a database out of them. But first, you'll need to learn the code first approach.</p>
<h3 id="_idParaDest-229"><a id="_idTextAnchor256"/>Code First and Migrations</h3>
<p>Usually, when you need to create a proof of concept, you will create a <code>DbContext</code> schema with the models and then generate a database out of that. Such an approach is called code first.</p>
<p>In this example, you will use the context you have generated from the <code>GlobalFactory2021</code> database and then generate a new database out of it. This approach requires an extra package named <code>Design</code>, so make sure it is installed by running the following command:</p>
<pre>dotnet add package Microsoft.EntityFrameworkCore.Design</pre>
<p>EF is able to generate a database and have different versioning for it. In fact, it can move from one database version to another. A single database version at any given time is called migration. Migrations are needed to ensure that you do not just always recreate databases (after all, you don't want to lose the existing data), but instead, apply them neatly in a secure and trusted way. To add the first migration, from the VS Code terminal, run the following:</p>
<pre>dotnet ef migrations add MyFirstMigration -c globalfactory2021Context</pre>
<p>This will generate a migration file:</p>
<div><div><img alt="Figure 6.4: New migration with defaults placed under the project Migrations folder  in the project root " height="328" src="img/B16835_06_04.jpg" width="965"/>
</div>
</div>
<p class="figure-caption">Figure 6.4: New migration with defaults placed under the project Migrations folder in the project root</p>
<p>The migration provides EF with information about the next database schema version and can therefore be used to generate a database from (or apply new changes to an existing database). Note that since you have multiple <code>DbContext</code> schemas and EF cannot tell you which context to use, you have to provide one explicitly. It is also worth mentioning that running this command requires selecting a default project, which includes the required context. and placing the migrations in that project's directory.</p>
<p>Why can't you just generate a database right away? When working with data, capturing a change at any given time and being able to go back to a previous version is very important. Even though directly generating a database might sound easy, it is not a viable approach because changes happen all the time. You want to be in control and have a choice to switch between versions at will. The migrations approach also works with code versioning systems, such as Git, because you can see the changes made to your database through a migration file. You will learn more about version control in <em class="italic">Chapter 11</em>, <em class="italic">Production-Ready C#: from Development to Deployment</em>.</p>
<p>Before creating a database, make sure you change the database name inside the connection string so that a new database can be created and not overwritten. Creating a new database from a migration you have can be done by running this command:</p>
<pre>dotnet ef database update -c globalfactory2021context</pre>
<p>If you open <code>pgAdmin</code>, you will see a very familiar view with the <code>manufacturer</code> and <code>product</code>. However, there is one new table for the migration history:</p>
<div><div><img alt="Figure 6.5: Generated database inside pgAdmin browser (simplified view for brevity) " height="504" src="img/B16835_06_05.jpg" width="1044"/>
</div>
</div>
<p class="figure-caption">Figure 6.5: Generated database inside pgAdmin browser (simplified view for brevity)</p>
<p>The <code>__EFMigrationsHistory</code> table lays out all the migrations performed, when they were performed, and the EF version with which they were executed. In the following screenshot, you can see the first migration created as <code>MyfirstMigration</code>:</p>
<div><div><img alt="Figure 6.6: EFMigrationsHistory table rows " height="396" src="img/B16835_06_06.jpg" width="1000"/>
</div>
</div>
<p class="figure-caption">Figure 6.6: EFMigrationsHistory table rows</p>
<p>You might find it strange that a migrations table has only two columns. However, those two columns have all the needed information, such as when, what, and how. Under <code>MigrationId</code>, the digits before <code>_</code> refer to the date and time the migration was run. This is followed by the migration name. The <code>ProductVersion</code> refers to the EF Core version with which the command was executed.</p>
<p>What if you wanted to make changes in your data models? What if you would like the <code>manufacturer</code> table to also have a date for the foundation? You would need to go through the same flow—add a migration and update the database.</p>
<p>So first, you would add a new property inside a <code>Manufacturer</code> class:</p>
<pre>public<a id="_idTextAnchor257"/> DateTime FoundedAt { get; set; }</pre>
<p>Here <code>FoundedAt</code> is a date. It does not need time associated with it, so you should specify an appropriate SQL Server type that maps to it. You would do this in <code>GlobalFactory2021Context</code> inside the <code>OnModelCreating</code> method:</p>
<pre>entity<a id="_idTextAnchor258"/>.Property(e =&gt; e.FoundedAt)
    .HasColumnType("date")</pre>
<p>Now you can add that to a new migration:</p>
<pre>dotnet ef migrations add AddManufacturerFoundedDate -c globalfactory2021Context</pre>
<p>Apply the new migration to the database:</p>
<pre>dotnet ef database update -c globalfactory2021context</pre>
<p>This will add a new entry to the migration history:</p>
<div><div><img alt="Figure 6.7: Migration 2 as the new migration created in the migrations table " height="203" src="img/B16835_06_07.jpg" width="835"/>
</div>
</div>
<p class="figure-caption">Figure 6.7: Migration 2 as the new migration created in the migrations table</p>
<p>You should see the new column in the <code>manufacturer</code> table as follows:</p>
<div><div><img alt="Figure 6.8: The manufacturer table with the new column named as foundedat " height="267" src="img/B16835_06_08.jpg" width="888"/>
</div>
</div>
<p> </p>
<p class="figure-caption">Figure 6.8: The manufacturer table with the new column named as foundedat</p>
<p>Now you know how to apply your models, change them, and generate a database out of the models. So far, you have made the following changes:</p>
<ul>
<li>Added the <code>FoundedAt</code> property and model builder changes.</li>
<li>Created a migration file.</li>
<li>Updated a database with that migration file.</li>
</ul>
<p>Undoing those changes will involve doing the opposite, in this sequence:</p>
<ul>
<li>Rolling back database changes (updating the database to the last successful migration).</li>
<li>Removing the migration file.</li>
<li>Removing model builder changes.</li>
</ul>
<p>EF migrations allow you to selectively apply any migration you want. Here, you will be applying the previous migration:</p>
<pre>dotnet ef database update MyFirstMigration -c globalfactory2021context</pre>
<p>You will delete the migration file using the following command:</p>
<pre>dotnet ef migrations remove -c globalfactory2021Context</pre>
<p>When working with big and complex databases, especially when they are already in production, performing migration using EF tools may become too complex. After all, you do not have full control of the exact script EF will generate for a migration. If you ever need a custom migration script, EF will no longer fit your bill. However, you can always convert whatever EF would do into SQL. You can do this by running the following command:</p>
<pre>dotnet ef migrations script -c globalfactory2021context</pre>
<p>This command produces, instead of a C# migration class, a SQL script. Executing a SQL script (often modified) is the preferred way of performing migrations in a production environment.</p>
<p>Those are just some basic yet common scenarios that you will be dealing with when working with databases. Change almost always happens; therefore, you should expect it and be prepared, as you will see in the following exercise.</p>
<h2 id="_idParaDest-230"><a id="_idTextAnchor259"/>Exercise 6.03: Managing Product Price Changes</h2>
<p>Once again, your manager is impressed with your results. This time, they have asked you to keep track of product price changes. They would like a new table, <code>ProductPriceHistory</code>, that holds a record of the changes in the price of a product.</p>
<p>The following steps will help you complete this exercise:</p>
<ol>
<li value="1">To track price changes, add a new model, <code>ProductPriceHistory</code> with the following fields:<ul><li><code>Id</code></li>
<li><code>Price</code></li>
<li><code>DateOfPrrice</code></li>
<li><code>ProductId</code></li>
<li><code>Product</code></li>
</ul></li>
</ol>
<p>The code for the new model will be as follows:</p>
<pre>public class ProductPriceHistory
{
    public int Id { get; set; }
    public decimal Price { get; set; }
    public DateTime DateOfPrice { get; set; }
    public int ProductId { get; set; }
 
    public Product Product { get; set; }
}</pre>
<ol>
<li value="2">Next, update the <code>Product</code> model so that it includes the historical price changes. So, add a new collection property, <code>ProductPriceHistory</code>:<pre>public ICollection&lt;ProductPriceHistory&gt; PriceHistory { get; set; }</pre></li>
<li>Change the <code>Price</code> column. <code>Price</code> should now be a method that gets the latest price of a product and the full model now looks like this:<pre>public partial class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public int ManufacturerId { get; set; }
 
    public decimal GetPrice() =&gt; PriceHistory
        .Where(p =&gt; p.ProductId == Id)
        .OrderByDescending(p =&gt; p.DateOfPrice)
        .First().Price;
 
    public Manufacturer Manufacturer { get; set; }
    public ICollection&lt;ProductPriceHistory&gt; PriceHistory { get; set; }
}</pre></li>
<li>Update <code>DbContext</code> to include a new <code>DbSet</code> and add the <code>ProductPriceHistory</code> configuration to the <code>OnModelCreating</code> method, as follows:<pre>modelBuilder.Entity&lt;ProductPriceHistory&gt;(entity =&gt;
{
    entity.ToTable("ProductPriceHistory", "Factory");
 
    entity.Property(e =&gt; e.Price)
        .HasColumnType("money");
 
    entity.Property(e =&gt; e.DateOfPrice)
        .HasColumnType("date");</pre></li>
</ol>
<p>The preceding code provides mappings to a table and column property types. A <code>Product</code> has many historical price changes, therefore it forms a 1:n relation with a <code>PriceHistory</code>.</p>
<ol>
<li value="5">Just after the preceding code, create a 1:n relation between <code>Product</code> and <code>PriceHistory</code>:<pre> RelationalForeignKeyBuilderExtensions.HasConstraintName((ReferenceCollectionBuilder)
        entity.HasOne(d =&gt; d.Product)
            .WithMany(p =&gt; p.PriceHistory)
            .HasForeignKey(d =&gt; d.ProductId), "FK_ProductPriceHistory_Product");
});</pre></li>
<li>For the database change to be captured (so that you can apply the change from code to database or roll back), add the <code>migration</code> as follows:<pre>dotnet ef migrations add AddProductPriceHistory -c globalfactory2021Contextv3 -o Exercises/Exercise03/Migrations</pre></li>
</ol>
<p>The following will be generated:</p>
<div><div><img alt="Figure 6.9: The generated database migrations and extra files " height="282" src="img/B16835_06_09.jpg" width="1120"/>
</div>
</div>
<p class="figure-caption">Figure 6.9: The generated database migrations and extra files</p>
<ol>
<li value="7">In order to apply the migration, run the following command:<pre>dotnet ef database update -c globalfactory2021contextv3</pre></li>
<li>Create a <code>Demo</code> by adding some dummy data:<pre>Demo.cs
public static class Demo
{
    public static void Run()
    {
        var db = new globalfactory2021Contextv3();
        var manufacturer = new Manufacturer
        {
            Country = "Canada",
            FoundedAt = DateTime.UtcNow,
            Name = "Fake Toys"
        };
 
        var product = new Product
        {
            Name = "Rubber Sweater",</pre></li>
</ol>
<pre>The complete code can be found here: <a href="https://packt.link/4FMz4">https://packt.link/4FMz4</a>.</pre>
<p>Here, you first created a <code>manufacturer</code> and its <code>product</code> and then added a few price changes. Once the changes were saved, you disconnected from the database (so that you don't work with cached entities). In order to test whether it works, you queried all <code>"Fake Toys"</code> manufacturer with their products and their price history.</p>
<p class="callout-heading">Note</p>
<p class="callout">When working with dates, especially in the context of databases or environments that may be shared beyond your local, prefer to use dates without your locale by calling <code>DateTime.UtcNow</code>.</p>
<ol>
<li value="9">In order to run this exercise, comment all lines within <code>static void Main(string[] args)</code> body except <code>Exercises.Exercise03.Demo.Run();</code> in <code>Program.cs</code>. You will see the following output:<pre>Fake Toys Rubber Sweater 15.5000</pre></li>
</ol>
<p>In the <code>Demo</code>, you created a <code>manufacturer</code> with one product which is a toy (<code>Rubber Sweater</code>). The toy has two prices: <code>15.11</code> and <code>15.50</code> (the latest). You then saved that toy in the database, disconnected, and reconnected from that database (making sure that the toy is not cached, but rather fetched), and executed an eager loading-based join.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for his exercise at <a href="https://packt.link/viVZW">https://packt.link/viVZW</a>.</p>
<p>EF is effective for rapid database development, but for that same reason, it is also very dangerous. Inexperienced developers often rely on the magic that happens behind the scenes and therefore forget that EF cannot magically optimize data models to fit your specific scenario or guess that the intended query should perform better. The following sections will review the main mistakes that people make while working with EF.</p>
<h1 id="_idParaDest-231"><a id="_idTextAnchor260"/>Pitfalls of EF</h1>
<p>EF abstracts a lot of details from you, significantly simplifying your work. However, it also introduces the risk of not being aware of what is actually happening. Sometimes, you might achieve what you want, but there may be a chance that you are not optimally achieving your goal. The following are some of the most common mistakes made in EF.</p>
<h2 id="_idParaDest-232"><a id="_idTextAnchor261"/>Examples Setup</h2>
<p>For all the following examples, assume that you will have this line initialized at the start:</p>
<pre>var db = new GlobalFactory2021Context();</pre>
<p>Assume, too, that every example will finish with this:</p>
<pre>db.Dispose();</pre>
<p>Also, the data itself will be seeded (pre-generated) using the following code:</p>
<pre>DataSeeding.cs
public static class DataSeeding
{
    public const string ManufacturerName = "Test Factory";
    public const string TestProduct1Name = "Product1     ";
    /// &lt;summary&gt;
    /// Padding s<a id="_idTextAnchor262"/>hould be 13 spaces to the right as per our test data, db and filtering requirements
    /// &lt;/summary&gt;
    public const string TestProduct2NameNotPadded = "Product2";
    public const decimal MaxPrice = 1000;
 
    public static void SeedDataNotSeededBefore()
    {
        var db = new globalfactory2021Context();
        var isDataAlreadySeeded = db.Manufacturers.Any(m =&gt; m.Name == ManufacturerName);
        if (isDataAlreadySeeded) return;
The complete code can be found here: <a href="https://packt.link/58JTd">https://packt.link/58JTd</a>.</pre>
<p>The preceding code creates a <code>manufacturer</code> with <code>10,000</code> products, but only if that <code>manufacturer</code> does not already exist. The <code>ManufacturerName</code> will be exactly 13 characters long, and their prices will be random, but no bigger than the maximum price. All of this information is saved to a database before you disconnect from it.</p>
<p class="callout-heading">Note</p>
<p class="callout">This is no runnable code and will be used in all the performance comparison examples.</p>
<p>All the examples will compare two functions achieving the same output. A summary of all the comparisons is done by executing this demo code:</p>
<pre>Demo.cs
public static class Demo
{
    public static void Run()
    {
        // For benchmarks to be more accurate, make sure you run the seeding before anything
        // And then restart the application
        // Lazy loading is a prime example of being impacted by this inverting the intended results.
        DataSeeding.SeedDataNotSeededBefore();
        // Slow-Faster example pairs
        // The title does not illustrate which you should pick
        // It rather illustrates when it becomes a problem.
 
    CompareExecTimes(EnumerableVsQueryable.Slow, EnumerableVsQueryable.Fast, "IEnumerable over IQueryable");
    CompareExecTimes(MethodChoice.Slow, MethodChoice.Fast, "equals over ==");
    CompareExecTimes(Loading.Lazy, Loading.Eager, "Lazy over Eager loading");
The complete code can be found here: <a href="https://packt.link/xE0Df">https://packt.link/xE0Df</a>.</pre>
<p>Here, you compare in-memory and SQL filtering, lazy and eager loading, tracked and untracked entities, and adding entities one by one as opposed to adding them in bulk. In the paragraphs that follow, you will find the functions being compared, but every comparison will show the following:</p>
<ul>
<li>Names of a scenario</li>
<li>Slow and fast versions for doing the same thing</li>
</ul>
<p>You will be using a stopwatch to measure execution time and print a formatted comparison after each run. In order to run this example, comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.PerformanceTraps.Demo.Run();</code> in <code>Program.cs</code>. You can refer to the <em class="italic">Summary of Results</em> section for the output.</p>
<p>The idea behind these examples is to compare an efficient way of working with EF with a direct equivalent inefficient way. The slow scenario is the inefficient way and the fast (which is the efficient one) is the way it should be done. The next section will detail the efficient way of using EF.</p>
<h2 id="_idParaDest-233"><a id="_idTextAnchor263"/>Multiple Adds</h2>
<p>Sometimes, without realizing it at the time, you'll find that you tend to use the most straightforward route while writing programs. For example, to add 100 items, you may use 100 individual addition operations. However, this isn't always the optimal approach and is especially inefficient when you're using EF. Instead of one query for a bulk of 100, you might run a single insert 100 times. As an example, see the following code:</p>
<pre>for (int i = 0; i &lt; 1000; i++)
{
    var product = new Product
    {
        Name = productName,
        Price = 11,
        ManufacturerId = 2
    };
    db.Products.Add(product);
}</pre>
<p>This code creates <code>1,000</code> products and attaches them to <code>DbContext</code>. What happens is that those <code>1,000</code> entities inside a <code>DbContext</code> schema are tracked. Instead of tracking them all as a single batch, you track each individually.</p>
<p>What you want to do, though, is to work with range operations:</p>
<ul>
<li><code>AddRange</code> or</li>
<li><code>UpdateRange</code>, or</li>
<li><code>RemoveRange</code></li>
</ul>
<p>A better version of the preceding code, designed to work in an optimal way with batches, looks like this:</p>
<pre>var toAdd = new List&lt;Product&gt;();
for (int i = 0; i &lt; 1000; i++)
{
    var product = new Product
    {
        Name = productName,
        Price = 11,
        Manufacturerid = 2
    };
    toAdd.Add(product);
}
db.Products.AddRange(toAdd);</pre>
<p>When creating multiple items with the intention to add them to the database, you should first add them to a list. After your list is complete, you can add the items as a batch to <code>DbSet&lt;Product&gt;</code>. You still have the problem of multiple adds, but the benefit of it over directly calling a <code>DbSet&lt;Product&gt;</code> add is that you no longer hit the change tracker with every add. In order to run this example, comment all lines within <code>static void</code> <code>Main(string[] args)</code> body except <code>Examples.PerformanceTraps.Demo.Run();</code> in <code>Program.cs</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/wPLyB">https://packt.link/wPLyB</a>.</p>
<p>The next section will take a look at another pitfall—how to query properly based on equality of properties.</p>
<h2 id="_idParaDest-234"><a id="_idTextAnchor264"/>Equals over ==</h2>
<p>The devil lies in the details. C# developers usually do not make this mistake, but if you are moving between languages (especially from Java), you might be doing this when filtering:</p>
<pre>var filtered = db.Products
    .Where(p =&gt; p.Name.Equals(DataSeeding.TestProduct1Name))
    .ToList();</pre>
<p>For LINQ, it is harmless. However, while using EF, this approach is not recommended. The problem is that EF can convert only some expressions to SQL. Usually, a complex method, such as equals, cannot be converted because it comes from a base object class, which can have multiple implementations. Instead, use a simple equality operator:</p>
<pre>var filtered = db.Products
    .Where(p =&gt; p.Name == DataSeeding.TestProduct1Name)
    .ToList();</pre>
<p>The problem with the first attempt was that it would first get all products (that is, execute a <code>get</code> statement in SQL) and only then the filter would be applied (in memory, in C#). Once again, this is problematic because getting with a filter applied in a database-native language is optimal but getting products in SQL and then filtering in C# is suboptimal. The problem is solved in the second attempt by replacing <code>Equals</code> with the equality operator, <code>==</code>. In order to run this example, comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.PerformanceTraps.Demo.Run();</code> in <code>Program.cs</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/js2es">https://packt.link/js2es</a>.</p>
<h2 id="_idParaDest-235"><a id="_idTextAnchor265"/>Using IEnumerable over IQueryable</h2>
<p>Another example involves misunderstanding the concept of <code>IEnumerable&lt;Product&gt;</code>:</p>
<pre>IEnumerable&lt;Product&gt; products = db.Products;
var filtered = products
    .Where(p =&gt; p.Name == DataSeeding.TestProduct1Name)
    .ToList();</pre>
<p>Here, you are getting products by a specific product name. But what happens when you assign a <code>DbSet&lt;Product&gt;</code> object to <code>Ienumerable&lt;Product&gt;</code> is that the <code>SELECT *</code> statement is executed. Therefore, instead of getting only the filtered products that you need, you will first get everything and then manually filter it.</p>
<p>You might wonder why you couldn't filter right away. In some cases, it makes sense to build queries and pass them across methods. But when doing so, you should not execute them until they are completely built. Therefore, instead of <code>Ienumerable&lt;Product&gt;</code>, you should use <code>Iqueryable&lt;Product&gt;</code>, which is an abstraction of queried entities—an expression that will be converted to SQL after calling <code>ToList&lt;Product&gt;</code> or similar. An efficient version of the preceding code would look like this:</p>
<pre>IQueryable&lt;Product&gt; products = db.Products;
var filtered = products
    .Where(p =&gt; p.Name == DataSeeding.TestProduct1Name)
    .ToList();</pre>
<p>The latter works faster because you apply a filter in SQL and not in memory. In order to run this example, comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.PerformanceTraps.Demo.Run();</code> in <code>Program.cs</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/ehq6C">https://packt.link/ehq6C</a>.</p>
<p>Eager and lazy loading has already been mentioned, but there is still another complexity that is significant enough and should be covered. The next section details them.</p>
<h2 id="_idParaDest-236"><a id="_idTextAnchor266"/>Lazy over Eager Loading</h2>
<p>In EF, you have an interesting n+1 queries problem. For example, if you get a list of items, then getting the list of their respective manufacturers afterward would result in a SQL query being executed; this would be lazy-loaded. Fortunately, from EF 2.1, this no longer happens by default, and it needs to be enabled explicitly. Assume that in the following examples, you have already enabled it.</p>
<p>Here is a query to get any first item and its manufacturer:</p>
<pre>var product = db.Products.First();
// Lazy loaded
var manufacturer = product.Manufacturer;</pre>
<p>Initially, upon looking at this code, you might think that there is no issue, but this small chunk of code executes two SQL queries:</p>
<ul>
<li>First, it selects the top product.</li>
<li>Then it selects the associated manufacturer, along with the manufacturer ID.</li>
</ul>
<p>To make the code more efficient, you need to explicitly specify that you do want the <code>Manufacturer</code> to be included with a product. A better, more efficient version of the code is as follows:</p>
<pre>var manufacturer = db.Products
    // Eager loaded
    .Include(p =&gt; p.Manufacturer)
    .First()
    .Manufacturer;</pre>
<p>The latter translates to a single query where a join between two tables is made and the first item from one of them is returned. In order to run this example, comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.PerformanceTraps.Demo.Run();</code> in <code>Program.cs</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/osrEM">https://packt.link/osrEM</a>.</p>
<h3 id="_idParaDest-237"><a id="_idTextAnchor267"/>Read-Only Queries</h3>
<p>EF assumes many things when running your queries. In most cases, it gets it right, but there are many cases when you should be explicit and order it not to assume. For example, you could get all the products like this:</p>
<pre>var products = db.Products
    .ToList();</pre>
<p>By default, EF will track all retrieved and changed entities. This is useful in some cases, but not always. When you have read-only queries, to just get and not modify entities, you would explicitly tell EF to not track any of them. An optimal way of getting products is as follows:</p>
<pre>var products = db.Products
    .AsNoTracking()
    .ToList();</pre>
<p>All this code does is run a query against the database and map the results. EF keeps the context clean. In order to run this example, comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.PerformanceTraps.Demo.Run();</code> in <code>Program.cs</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/rSW1k">https://packt.link/rSW1k</a>.</p>
<h2 id="_idParaDest-238"><a id="_idTextAnchor268"/>Summary of Results</h2>
<p>The following snippet shows all results from the previous sections, in a tabulated form:</p>
<pre>IENUMERABLE OVER IQUERYABLE          Scenario1: 75ms,   Scenario2: 31ms
EQUALS OVER ==                       Scenario1: 33ms,   Scenario2: 24ms
LAZY OVER EAGER LOADING              Scenario1: 3ms,    Scenario2: 29ms
READ-ONLY QUERIES                    Scenario1: 40ms,   Scenario2: 10ms
MULTIPLE ADDS                        Scenario1: 8ms,    Scenario2: 8ms</pre>
<p>Note that the output depends on the machine you are running the database, the data, and more. The point of this comparison is not to give you hard rules of what should be chosen, but rather to show how different approaches might save a lot of computing time.</p>
<p>EF is a powerful tool that allows rapid work with databases; however, you should be careful with how you use it. Do not worry, even if you think you are not sure how the queries work internally, there is still a way to see what happens underneath.</p>
<h2 id="_idParaDest-239"><a id="_idTextAnchor269"/>Tools to Help You Spot Problems Early On</h2>
<p>EF is a toolbox in itself; it allows you to easily hook into it and track what is happening without any external tools. You can enable logging all the EF actions by adding this to the <code>OnConfiguring</code> method:</p>
<pre>optionsBuilder.LogTo((s) =&gt; D<a id="_idTextAnchor270"/>ebug.WriteLine(s));</pre>
<p>If you run any of the example's code, this will log the trace inside an <code>output</code> window, as follows:</p>
<div><div><img alt="Figure 6.10: Debugging output after running the performance pitfalls demo " height="599" src="img/B16835_06_10.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 6.10: Debugging output after running the performance pitfalls demo</p>
<p>The image shows what SQL is generated when EF executes the code—specifically selecting all products.</p>
<p>This approach is useful when you want to both fully debug your application and know every step EF makes. It is efficient for spotting queries that you expect to execute as SQL but execute in memory.</p>
<p>In the next section, you will learn about patterns that will help you organize database communication code.</p>
<h1 id="_idParaDest-240"><a id="_idTextAnchor271"/>Working with a Database in Enterprise</h1>
<p>When talking about databases, you usually imagine SQL or another language to talk with them. On top of that, another language (C#, in this case) is most often used to connect to a database to execute SQL queries. If not controlled, C# gets mixed with SQL, and it causes a mess of your code. Over the years, there have been a few patterns refined to implement the communication with a database in a clean way. Two such patterns, namely, Repository and CQRS, are commonly used to this day.</p>
<h2 id="_idParaDest-241"><a id="_idTextAnchor272"/>Repository Pattern</h2>
<p>The Repository is a pattern that targets a model and defines all (if needed) possible CRUD operations. For example, if you take a <code>Product</code> model, you could have a repository with this interface:</p>
<pre>public interface IProductRepository
{
    int Create(Product product);
    void Delete(int id);
    void Update(Product product);
    Product Get(int id);
    IEnumerable&lt;Product&gt; Get();
}</pre>
<p>This is a classical repository pattern where every database operation is abstracted away. This allows you to do pretty much anything you want in a database without worrying about the underlying database or even the technology you use to communicate with the database.</p>
<p>Note that a <code>Create</code> method in this case returns an integer. Usually, when writing code, you would segregate methods that change a state from those that query something. In other words, do not try to both get something and change something. However, in this case, it is difficult to achieve because the ID of an entity will be generated by the database. Therefore, if you want to do something with the entity, you will need to get that ID. You could instead return the whole entity, but that is like getting a house when all you need is an address.</p>
<p>Given you want to do the same four operations (create, delete, update, and get), the pattern would look like this:</p>
<pre>public interface I<strong class="bold">Manufacturer</strong>Repository
{
    int Create(<strong class="bold">Manufacturer </strong>product);
    void Delete(int id);
    void Update(<strong class="bold">Manufacturer </strong>product);
    Manufacturer Get(int id);
    IEnumerable&lt;<strong class="bold">Manufacturer</strong>&gt; Get();
}</pre>
<p>It looks almost the same; the only difference is the targeted entity. Given that you had a very simple application that just does data processing in a very simple way, it would make sense to make these repositories generic:</p>
<pre>public interface IRepository&lt;<strong class="bold">TEntity</strong>&gt;: IDisposable where <strong class="bold">TEntity </strong>: class
{
    int Create(<strong class="bold">TEntity </strong>productentity);
    void Delete(long id)(int id);
    void Update(<strong class="bold">TEntity </strong>entityproduct);
    TEntity Get(long id)(int id);
    IEnumerable&lt;<strong class="bold">TEntity</strong>&gt; Get();
    void Dispose();
}</pre>
<p>Here, instead of <code>Product</code> or <code>Manufacturer</code>, the interface takes a generic <code>TEntity</code> that must be a class. You have also inherited an <code>IDisposable</code> interface to clean up all the resources that a repository used. This repository is still flawed. So, should you be able to persist any class? In that case, it would be nice to mark the classes that you could persist in.</p>
<p>Yes, you can do that. When talking about a repository, you should realize that even if something is supposed to be saved in a database, that does not mean that it will be saved separately. For example, contact information will always be saved with a person. A person can exist without contact information but contact information cannot exist without a person. Both person and contact information are entities. However, a person is also an aggregate (that is the entity that you will be targeting when adding data to a database), and it can exist by itself. This means that it makes no sense to have a repository for contact information if storing it would violate data integrity. Therefore, you should create a repository not per entity, but per aggregate.</p>
<p>What should every row in a database have? It should have an ID. An entity is a model that you can persist (that is, have an ID); therefore, you can define an interface for it:</p>
<pre>public interface IEntity
{
    int Id { get; }
}</pre>
<p>Please note that here you are using a <code>get</code>-only property because it does not make sense to set an ID in all cases. However, being able to identify an object (by getting the ID) is critical. Also note that the ID, in this case, is an integer because it is just a simple example and there will not be much data; but in real applications, it is usually either an integer or a GUID. Sometimes, an ID could even be both. In those cases, a consideration to make an entity interface generic (that is, taking generic <code>TId</code>) could be made.</p>
<p>What about an aggregate? An aggregate is an entity; you would therefore write the following:</p>
<pre>public interface IAggregate : IEntity
{
}</pre>
<p>In this scenario, you would then just write <code>Person: IAggregate, ContactInfo: IEntity</code>. If you apply the same principles to the two tables you had, you will get <code>Product: IAggregate, Manufacturer: IAggregate</code> because the two can be saved separately.</p>
<p class="callout-heading">Note</p>
<p class="callout">There is no runnable code here; however, you will be using it in the upcoming exercise. You can find the code used for this example at <a href="https://packt.link/JDLAo">https://packt.link/JDLAo</a>.</p>
<p>Writing a repository for every aggregate might become a tedious job, especially if there is no special logic to the way persistence is done. In the upcoming exercise, you will learn how to generalize and reuse repositories.</p>
<h2 id="_idParaDest-242"><a id="_idTextAnchor273"/>Exercise 6.04: Creating a Generic Repository</h2>
<p>Being coupled to an ORM may make your business logic harder to test. Also, due to persistence being so rooted at the core of most applications, it might be a hassle to change an ORM. For those reasons, you may want to put an abstraction layer in between business logic and a database. If you use <code>DbContext</code> as is, you couple yourself to <code>EntityFramework</code>.</p>
<p>In this exercise, you will learn how to create a database operations abstraction—a generic repository—that will work on any entity and support create, delete, update, and get operations. Implement those methods one by one:</p>
<ol>
<li value="1">First, create a generic repository class that takes <code>DbContext</code> in the constructor:<pre>public class Repository&lt;TAggregate&gt;: IRepository&lt;TAggregate&gt; where TAggregate: class
{
    private readonly DbSet&lt;TAggregate&gt; _dbSet;
    private readonly DbContext _context;
 
    public Repository(DbContext context)
    {
        _dbSet = context.Set&lt;TAggregate&gt;();
        _context = context;
    }</pre></li>
</ol>
<p>The <code>context.Set&lt;TEntity&gt;()</code> allows getting a table-model binding and then using it throughout the repository. Another interesting point is that you didn't have to supply a concrete <code>DbContext</code> as it uses generic entities, and a generic repository is applicable to every kind of context.</p>
<ol>
<li value="2">To implement a <code>Create</code> operation, add a method to insert a single aggregate:<pre>public int Create(TAggregate aggregate)
{
    var added = _dbSet.Add(aggregate);
    _context.SaveChanges();
 
    return added.Entity.Id;
}</pre></li>
<li>To implement a <code>Delete</code> operation, add a method to delete an aggregate by ID:<pre>    public void Delete(int id)
    {
        var toRemove = _dbSet.Find(id);
        if (toRemove != null)
        {
            _dbSet.Remove(toRemove);
        }
 
        _context.SaveChanges();
    }</pre></li>
<li>To implement an <code>Update</code> operation, add a method to update an entity by overriding the old values with the values of a new entity:<pre>    public void Update(TAggregate aggregate)
    {
        _dbSet.Update(aggregate);
        _context.SaveChanges();
    }</pre></li>
<li>To implement a <code>Read</code> operation, add a method to get a single entity by ID:<pre>    public TAggregate Get(int id)
    {
        return _dbSet.Find(id);
    }</pre></li>
<li>A <code>Read</code> operation should also support getting all the entities. So, add a method to get all entities:<pre>    public IEnumerable&lt;TAggregate&gt; Get()
    {
        return _dbSet.ToList();
    }</pre></li>
<li>Passing a <code>DbContext</code> to a constructor will open a database connection. As soon as you are done using a database, you should disconnect. In order to support a conventional disconnect, implement an <code>IDisposable</code> pattern:<pre>    public void Dispose()
    {
        _context?.Dispose();
    }
}</pre></li>
<li>To test whether the generic repository works, create a new <code>Run()</code> method:<pre>public static void Run()
{</pre></li>
<li>Inside the <code>Run()</code> method, initialize a new repository for the <code>Manufacturer</code> entity:<pre>     var db = new FactoryDbContext();
     var manufacturersRepository = new Repository&lt;Manufacturer&gt;(db);</pre></li>
<li>Test whether the <code>Create</code> operation works, by inserting a new <code>manufacturer</code> as shown in the following code:<pre>    var manufacturer = new Manufacturer { Country = "Lithuania", Name = "Tomo Baldai" };
     var id = manufacturersRepository.Create(manufacturer);</pre></li>
<li>Test whether the <code>Update</code> operation works, by updating the manufacturer's name as follows:<pre>     manufacturer.Name = "New Name";
     manufacturersRepository.Update(manufacturer);</pre></li>
<li>Test whether the <code>Read</code> operation works on a single entity, by retrieving the new manufacturer from a database and print it:<pre>     var manufacturerAfterChanges = manufacturersRepository.Get(id);
     Console.WriteLine($"Id: {manufacturerAfterChanges.Id}, " +
                  $"Name: {manufacturerAfterChanges.Name}");</pre></li>
</ol>
<p>You should see the following output:</p>
<pre>Id: 25, Name: New Name</pre>
<ol>
<li value="13">Test whether the <code>Read</code> operation works on all entities by getting the count of all manufacturers with the following code:<pre>    var countBeforeDelete = manufacturersRepository.Get().Count();</pre></li>
<li>You can test whether the <code>Delete</code> operation works by deleting the new manufacturer as follows:<pre>    manufacturersRepository.Delete(id);</pre></li>
<li>In order to see the impact of delete (one less manufacturer is expected), compare the counts as follows:<pre>    var countAfter = manufacturersRepository.Get().Count();
    Console.WriteLine($"Before: {countBeforeDelete}, after: {countAfter}");
}</pre></li>
<li>In order to run this exercise, comment all lines within <code>static void Main(string[] args)</code> body except <code>Exercises.Exercise04.Demo.Run();</code> in <code>Program.cs</code>. You should see the following output upon running the <code>dotnet run</code> command:<pre>Before: 3, after: 2</pre></li>
</ol>
<p>Repositories used to be the way to go (maybe 10-20 years ago) for implementing interactions with a database because these were a well-abstracted way to make calls against a database. An abstraction from a database would enable people to change the underlying database provider if needed. If a database changes, only the class that implements the interface will change but whatever consumes the interface will remain unaffected.</p>
<p>Looking back at <code>DbContext</code> and <code>DbSet</code>, you might ask why those can't be used directly. The answer is that you can, and it serves a similar purpose as repositories do. That is why the repository pattern should only be used if your queries are sufficiently complex (meaning it's several lines long).</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this exercise at <a href="https://packt.link/jDR0C">https://packt.link/jDR0C</a>.</p>
<p>The next section will explore another benefit of EF that is, local database testing.</p>
<h2 id="_idParaDest-243"><a id="_idTextAnchor274"/>Testing Data Persistence Logic Locally</h2>
<p>When developing software, you should always have quality and testability in mind. The problem with database testability is that it often requires a physical machine to host a database somewhere. However, you do not always have access to such a setup, especially at the start of a project.</p>
<p>Thankfully, EF is very flexible and offers a few packages to help out here. There are three main ways of testing with EF—<code>InMemory</code>, using SQLite, and calling an actual database. You have already seen plenty of demos calling a physical database. Next, you'll explore the other two: In-Memory and SQLite.</p>
<h3 id="_idParaDest-244"><a id="_idTextAnchor275"/>In-Memory Database Provider</h3>
<p>An in-memory database provider is just a bunch of in-memory lists available internally that make no queries whatsoever to a database. Usually, even garbage collection eliminates its state. Before you can continue, just like all other database providers, you will need to add one to your project.</p>
<p>Run the following command:</p>
<pre>dotnet add package Microsoft.EntityFrameworkCore.InMemory</pre>
<p>This command enables you to use an in-memory database when supplying <code>DbContextOptionsBuilder</code> with the <code>UseInMemoryDatabase</code> option, as done in the following snippet:</p>
<pre>var builder = new DbContextOptionsBuilder&lt;FactoryDbContext&gt;();
builder.UseInMemoryDatabase(Guid.NewGuid().ToString());
var options = builder.Options;
_db = new FactoryDbContext(options);</pre>
<p>In this snippet, you've used an options builder and created a new, isolated, in-memory database. The most important part here is the <code>builder.UseInMemoryDatabase();</code> method, which specifies that an in-memory database should be created. Also, note the <code>Guid.NewGuid().ToString()</code> argument. This argument is for a database name. In this case, it means that every time you call that line you will generate a unique database name, thus ensuring isolation between the new test databases. If you don't use this argument, you risk affecting a context under the test state. You want to avoid that for testing scenarios. When it comes to testing, starting with a fresh state is the right way to go. </p>
<p>In order to run this example, comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.TestingDb.Demo.Run();</code> in <code>Program.cs</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/mOodJ">https://packt.link/mOodJ</a>.</p>
<p>To test whether a generic repository for manufacturers works (assume that the preceding code will be reused), first create a new repository:</p>
<pre>var productsRepository = new Repository&lt;Product&gt;(db);</pre>
<p>The power of this pattern is that a new entity repository is simply specified as a different generic argument. If you wanted to test a manufacturer, you would not need to design a repository class for it. All you would have to do is to initialize a repository with <code>Manufacturer</code> passed as a generic argument, for example <code>new Repository&lt;Manfacturer&gt;(db)</code>.</p>
<p>Now, create a test <code>product</code> and save it:</p>
<pre>var product = new Product {Name = "Test PP", ManufacturerId = 1, Price = 9.99m};
var id = productsRepository.Create(product);</pre>
<p>To test the price update method, update <code>product.Price</code> and call the <code>Update</code> method:</p>
<pre>product.Price = 19m;
productsRepository.Update(product);</pre>
<p>In order to check whether a product was created successfully, call a <code>Get</code> method and pass the new product <code>id</code>:</p>
<pre>var productAfterChanges = productsRepository.Get(id);</pre>
<p>Type the following to print the product to the console:</p>
<pre>Console.WriteLine($"Id: {productAfterChanges.Id}, " +
                  $"Name: {productAfterChanges.Name}, " +
                  $"Price: {productAfterChanges.Price}");</pre>
<p>The output will get displayed as follows:</p>
<pre>Id: 1, Name: Test PP, Price: 19</pre>
<p>Now you need to check whether delete works. So, create a new product:</p>
<pre>var productToDelete = new Product { Name = "Test PP 2", ManufacturerId = 1, Price = 9.99m };
var idToDelete = productsRepository.Create(productToDelete);</pre>
<p>Check the current count of products in a repository:</p>
<pre>var countBeforeDelete = productsRepository.Get().Count();</pre>
<p>Now delete the product:</p>
<pre>productsRepository.Delete(idToDelete);</pre>
<p>Check the count once again, comparing it with the previous one:</p>
<pre>var countAfter = productsRepository.Get().Count();
Console.WriteLine($"Before: {countBeforeDelete}, after: {countAfter}");</pre>
<p>In order to run this example, comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.TestingDb.Demo.Run();</code> in <code>Program.cs</code>. The following output will get displayed:</p>
<pre>Before: 2, after: 1</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/DGjf2">https://packt.link/DGjf2</a>.</p>
<p>Using an In-Memory provider has its limitations. Up next, you will learn another alternative to testing code depending on the <code>DbContext</code> with fewer limitations.</p>
<h3 id="_idParaDest-245"><a id="_idTextAnchor276"/>SQLite Database Provider</h3>
<p>The problem with in-memory providers is that you cannot run any SQL statements on them. If you do, the code fails. Also, an in-memory provider is all about in-memory data structures and has nothing to do with SQL. SQLite database provider is free from those problems. The only issue it has is that SQLite is a dialect of SQL, so some raw SQL queries of other providers might not work.</p>
<p>To try out SQLite, run the following command in the VS Code terminal:</p>
<pre>dotnet add package Microsoft.EntityFrameworkCore.Sqlite</pre>
<p>The installed NuGet allows you to use SQLite provider when creating a <code>DbContext</code> schema, like this:</p>
<pre>var connection = new SqliteConnection("Filename=:memory:");
connection.Open();
var builder = new DbContextOptionsBuilder&lt;FactoryDbContext&gt;();
builder.UseSqlite(connection);
var options = builder.Options;
var db = new FactoryDbContext(options);
db.Database.EnsureCreated();</pre>
<p>In the preceding snippet, you have created a SQL connection, specifying that an in-memory SQLite database will be used. The <code>Db.Database.EnsureCreated()</code> was needed because the database would not always be created using that connection string. In order to run this example, comment all lines within <code>static void</code> <code>Main(string[] args)</code> body except <code>Examples.TestingDb.Demo.Run();</code> in <code>Program.cs</code>.</p>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/rW3JS">https://packt.link/rW3JS</a>.</p>
<p>If you were to create <code>ProductsRepository</code> and run the same code from the <code>InMemory</code> database example, you would get an error: <code>SQLite Error 19: 'FOREIGN KEY constraint failed'</code>. This is due to a missing manufacturer with an ID of 1 to which you are trying to link the new test products. This is a prime example of why the EF in-memory provider is not that reliable.</p>
<p>In order to fix this, add the following just before creating a test product:</p>
<pre>var manufacturer = new Manufacturer() { Id = 1 };
db.Manufacturers.Add(manufacturer);
db.SaveChanges();</pre>
<p>The only thing to remember is to clean up. After you are done using a database context that was created using a SQL connection, do not forget to dispose of that connection this way:</p>
<pre>connection.Dispose();</pre>
<p>At this point, you already know how to use <code>DbContext</code> in many different ways in order to communicate with a database. However, a dependency on a third-party library (EF Core) and unit testing maybe be tricky if all depends on a specific ORM. In the next paragraph, you will learn how to escape such a dependency.</p>
<h2 id="_idParaDest-246"><a id="_idTextAnchor277"/>A Few Words on Repository</h2>
<p>The Repository pattern works for simple CRUD applications because it can further simplify database interactions. However, given you are using EF, it is already simple enough to interact with a database and another layer of abstraction is not always justified. After all, one of the key reasons why the Repository pattern caught so much attention is that it allows you to escape database interactions. However, the EF in-memory provider allows that too, so there is even less of a reason to use a repository.</p>
<p>The generic repository pattern is a useful abstraction. It abstracts away database interaction under a simple interface. However, for non-trivial scenarios, you are likely to need your custom CRUD operations and then you would create a non-generic repository. In fact, non-generic repositories are the recommended approach (given you want to implement the pattern) because you rarely want all the CRUD methods for all the entities. It is not rare to end up with as little as a single method on a repository. If you use a generic repository, you could still make all methods virtual and override them, but then you will end up overriding all the time or having methods that you don't use. It is less than ideal.</p>
<p>The following section will explore a different pattern that strives to make simple, optimal interactions per database operation—CQRS.</p>
<h3 id="_idParaDest-247"><a id="_idTextAnchor278"/>Query and Command Handlers Patterns</h3>
<p>Command Query Responsibility Segregation (CQRS) is a pattern that aims to separate reads from writes. Instead of one class for all CRUD operations, you will have one class per CRUD method. On top of that, instead of one entity that fits all, you will have request and query object models dedicated to those specific scenarios. In CQRS, all database operations can be classified into two:</p>
<ul>
<li>Command: An operation that changes state (create, update, delete).</li>
<li>Query: An operation that gets something, without affecting the state.</li>
</ul>
<div><div><img alt="Figure 6.11: CQRS pattern as used by Martin Fowler " height="1189" src="img/B16835_06_11.jpg" width="1665"/>
</div>
</div>
<p class="figure-caption">Figure 6.11: CQRS pattern as used by Martin Fowler</p>
<p class="callout-heading">Note</p>
<p class="callout">The original source for this diagram can be found at <a href="https://www.martinfowler.com/bliki/CQRS.xhtml">https://www.martinfowler.com/bliki/CQRS.xhtml</a>.</p>
<p>In order to implement a command handler for creating a product, you would start by defining the command. What does the product need? It needs a name and a price, as well as a manufacturer. The ID for the create command is not needed (because the database generates it) and the manufacturer property can be removed as well because you will not make use of navigational properties. The name of a CQRS operation is made up of three parts—operation name, entity name, and <code>command</code> or <code>query</code> suffix. You are creating a product; therefore, the model will be called <code>CreateProductCommand</code>:</p>
<pre>public class CreateProductCommand
{
    public string Name { get; set; }
    public decimal Price { get; set; }
    public int ManufacturerId { get; set; }
}</pre>
<p>Next, you will create a handler of this command. In the constructor, pass the database context. In the <code>Handle</code> method, pass <code>CreateProductCommand</code>:</p>
<pre>CreateProductQueryHandler.cs
public class CreateProductCommandHandler
{
    private readonly FactoryDbContext _context;
 
    public CreateProductCommandHandler(FactoryDbContext context)
    {
        _context = context;
    }
 
    public int Handle(CreateProductCommand command)
    {
        var product = new Product
        {
            ManufacturerId = command.ManufacturerId,
            Name = command.Name,
The complete code can be found here: <a href="https://packt.link/xhAVS">https://packt.link/xhAVS</a>.</pre>
<p>Handlers are simple, single-method objects that implement all that is needed to process a command or a query. In order to test things, you'll also create a <code>GetProductQueryHandler</code> class:</p>
<pre>public class GetProductQueryHandler
{
    private readonly FactoryDbContext _context;
 
    public GetProductQueryHandler(FactoryDbContext context)
    {
        _context = context;
    }
 
    public Product Handle(int id)
    {
        return _context.Products.Find(id);
    }
}</pre>
<p>The idea is almost the same, except that, in this case, querying is so simple that the optimal model for it is a simple integer. In some scenarios, if you can predict the complexity growing and the query becoming more complex, then even such an integer could go to a model (in order to avoid a breaking change of query format changing completely—from a primitive integer to an object).</p>
<p>In order to see whether the command and query work, you will be using an in-memory database context once again. So, create a command to create a new product, a handler to handle it, execute it, and print the results as follows:</p>
<pre>var command = new CreateProductCommand { Name = "Test PP", Manufacturerid = 1, Price = 9.99m };
var commandHandler = new CreateProductCommandHandler(db);
var newProductId = commandHandler.Handle(command);</pre>
<p>Create a query to get the created product and a handler to execute the query:</p>
<pre>var query = newProductId;
var queryHandler = new GetProductQueryHandler(db);
var product = queryHandler.Handle(query);
Console.WriteLine($"Id: {product.Id}, " +
                  $"Name: {product.Name}, " +
                  $"Price: {product.Price}");</pre>
<p>In order to run this example, comment all lines within <code>static void Main(string[] args)</code> body except <code>Examples.Cqrs.Demo.Test();</code> in <code>Program.cs</code>. The output will be displayed as follows:</p>
<pre>Id: 1, Name: Test PP, Price: 9,99</pre>
<p class="callout-heading">Note</p>
<p class="callout">You can find the code used for this example at <a href="https://packt.link/Ij6J8">https://packt.link/Ij6J8</a>.</p>
<p>You might have wondered why, after so many demos, the <code>ProductId</code> is still <code>1</code>. That's because it is an in-memory database—one that you create fresh for a new test every time. Since you are starting with an empty database every time, the first addition of a new entity to a database results in a new item with an ID of 1.</p>
<p>You might wonder if you made some changes to a database or added a column to it, and how it would impact the rest of the codebase and the business logic. The next section will detail these scenarios.</p>
<h3 id="_idParaDest-248"><a id="_idTextAnchor279"/>Separating the Database Model from the Business Logic (Domain) Model</h3>
<p>Databases often change. However, should that impact the rest of the codebase? Should the fact that a column type changed, or another column was added affect the business logic? There is no straight answer to that. It all depends on the project scope, the resources, and the team's maturity. However, if you are working on a medium or a big project, you should consider segregating the database and domain completely. This does not only mean that different logic should be placed in different projects, but it also means that those projects should be decoupled from one another.</p>
<p>It is okay for a database layer to consume a domain layer, but it is not okay for the domain layer to do the same. If you want a complete separation between the two, you will have to introduce an anti-corruption layer. It is a concept that says not to consume foreign models and instead map them as soon as they hit the public component of that layer. The idea is that all interfaces should be domain-specific (that is, work with domain models). However, for a database communication implementation, internally, you will be working with database entities instead of domain models. This requires mapping one to another (when taking input or returning output).</p>
<p>In cases where database entities change completely, the domain-specific interface will remain the same. Only the mapping will change, which will prevent the database from impacting anything else. It is not an easy thing to grasp and implement for a beginner. It is recommended that you ignore that for now; your personal project scope is not worth the effort and you might not see any benefit.</p>
<p>This concludes the theoretical portion of this section. In the following section, you will put this into practice with an activity.</p>
<h2 id="_idParaDest-249"><a id="_idTextAnchor280"/>Activity 6.01: Tracking System for Trucks Dispatched</h2>
<p>A logistics company has hired you to keep track of dispatched trucks. A single dispatch includes the current location of a truck, the truck's ID, and the driver's ID. In this activity, you will create a database for dispatched trucks, seed it with a few dispatches, and prove it works by getting all possible data from it.</p>
<p>You will create two classes (<code>Truck</code> and <code>Person</code>), which consist of the following objects:</p>
<ul>
<li><code>Truck</code>: <code>Id</code>, <code>Brand</code>, <code>Model</code>, <code>YearOfMaking</code></li>
<li><code>Person</code>: <code>Id</code>, <code>Name</code>, <code>DoB</code></li>
</ul>
<p>All tables are stored in the <code>TruckLogistics</code> database, in the <code>TruckLogistics</code> schema.</p>
<p>Perform the following steps to complete this activity:</p>
<ol>
<li value="1">Create a <code>Person</code> class.</li>
<li>Create a <code>Truck</code> class.</li>
<li>Create a <code>TruckDispatch</code> class.</li>
<li>Create a <code>TruckDispatchDbContext</code> schema with three tables.</li>
<li>Create a connection string (ideally from environment variables).</li>
<li>Add a database migration.</li>
<li>Generate a database from the migration.</li>
<li>Connect to a database.</li>
<li>Seed the database with the initial data.</li>
<li>Get all data from the database.</li>
<li>Print the results.</li>
<li>Dispose of the <code>TruckDispatchesDbContext</code> schema (that is, disconnect).</li>
</ol>
<p>After completing these steps correctly, you should see the following output:</p>
<pre>Dispatch: 1 1,1,1 2021-11-02 21:45:42
Driver: Stephen King 2021-07-25 21:45:42
Truck: Scania R 500 LA6x2HHA 2009</pre>
<p class="callout-heading">Note</p>
<p class="callout">In order to run this activity, comment all lines within <code>static void Main(string[] args)</code> body except <code>Activities.Activity01.Demo.Run()</code>; in <code>Program.cs</code>.</p>
<p>The database should look like this:</p>
<div><div><img alt="Figure 6.12: Generated TruckLogistics database (simplified for brevity) " height="918" src="img/B16835_06_12.jpg" width="918"/>
</div>
</div>
<p class="figure-caption">Figure 6.12: Generated TruckLogistics database (simplified for brevity)</p>
<p>And the following migration files (similar, not exact) will be created:</p>
<div><div><img alt="Figure 6.13: Migration files created for the solution " height="182" src="img/B16835_06_13.jpg" width="1105"/>
</div>
</div>
<p class="figure-caption">Figure 6.13: Migration files created for the solution</p>
<p class="callout-heading">Note</p>
<p class="callout">The solution to this activity can be found at <a href="https://packt.link/qclbF">https://packt.link/qclbF</a>.</p>
<p>With the successful execution of this activity, you should now have solid know-how of how EF is used for rapidly developing solutions integrated with a database.</p>
<h1 id="_idParaDest-250"><a id="_idTextAnchor281"/>Summary</h1>
<p>In this chapter, you covered the benefits of an ORM and how to talk with a database from C# using the EF Core 6. EF allowed you to abstract a database using <code>DbContext</code> and include abstractions to tables, <code>DbSet</code>.</p>
<p>You experienced the simplicity of consuming a database using EF, which felt almost the same as writing LINQ queries. The only difference was the initial setup of a connection using a database context. You learned the client input should not be trusted, but ORMs allow you to consume queries with confidence because they take security into consideration and protect you from SQL injection. However, the way you connect to a database (that is, the connection string) has to be secured, and for that reason, you must store it just like any other secret and not hardcode it. You also studied the most common pitfalls when working with EF and tools that could help avoid those pitfalls. This chapter has given you enough skills to create and consume databases using EF.</p>
<p>In the next chapter, you will be focusing more on web applications—what they are, and how to build them.</p>
</div>
<div><div></div>
</div>
</div>
</body></html>