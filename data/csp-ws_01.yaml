- en: 1\. Hello C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1. 欢迎来到 C#
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: This chapter introduces you to the basics of C#. You will start by learning
    about the basics of the .NET Command-Line Interface (CLI) and how to use Visual
    Studio Code (VS Code) as a basic Integrated Development Environment (IDE). You
    will then learn about the various C# data types and how to declare variables for
    these types, before moving on to a section about arithmetic and logical operators.
    By the end of the chapter, you will know how to handle exceptions and errors and
    be able to write simple programs in C#.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍 C# 的基础知识。您将从学习 .NET 命令行界面 (CLI) 的基础知识以及如何使用 Visual Studio Code (VS Code)
    作为基本集成开发环境 (IDE) 开始。然后，您将了解各种 C# 数据类型以及如何为这些类型声明变量，之后将进入关于算术和逻辑运算符的部分。到本章结束时，您将了解如何处理异常和错误，并能够用
    C# 编写简单的程序。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: C# is a programming language created in the early 2000s by a team at Microsoft
    led by Anders Hejlsberg, who is also among the creators of some other popular
    languages, such as Delphi and Turbo Pascal, both widely used in the 1990s. Over
    the last 20 years, C# has grown and evolved, and today it is one of the most widely
    used programming languages globally, according to Stack Overflow's 2020 insights.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: C# 是一种在 2000 年代初期由微软团队创建的编程语言，该团队由安德斯·海尔斯伯格领导，他也是一些其他流行语言的创造者之一，例如 Delphi 和
    Turbo Pascal，这两种语言在 1990 年代被广泛使用。在过去 20 年中，C# 不断发展和演变，根据 Stack Overflow 的 2020
    年洞察，如今它已成为全球最广泛使用的编程语言之一。
- en: It has its reasons for holding such an honorable place in the tech community.
    C# allows you to write applications for a wide segment of markets and devices.
    From the banking industry, with its high-security standards, to e-commerce companies,
    which hold enormous volumes of transactions, it is a language trusted by companies
    that need both performance and reliability. Besides that, C# also makes it possible
    to write web, desktop, mobile, and even IoT applications, allowing you to develop
    for almost every kind of device.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 它在技术社区中占据如此崇高的地位有其原因。C# 允许你为广泛的市场和设备编写应用程序。从具有高安全标准的银行业务，到拥有巨大交易量的电子商务公司，它是一种被需要性能和可靠性的公司所信赖的语言。除此之外，C#
    还使得编写 Web、桌面、移动甚至物联网应用程序成为可能，让你可以为几乎任何类型的设备进行开发。
- en: 'C# was initially limited to work only on Windows; however, there have been
    concerted efforts by the C# team over the past few years to make it cross-platform
    compatible. Today, it can be used with all major OS distributions, namely, Windows,
    Linux, and macOS. The goal is simple: to develop, build, and run C# anywhere,
    letting each developer and team choose their most productive or favorite environment.'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: C# 最初仅限于在 Windows 上运行；然而，在过去几年中，C# 团队已经做出了共同努力，使其实现跨平台兼容。如今，它可以与所有主要操作系统发行版一起使用，即
    Windows、Linux 和 macOS。目标很简单：在任何地方开发、构建和运行 C#，让每个开发者和团队选择他们最 productive 或最喜欢的环境。
- en: Another remarkable characteristic of C# is that it is a strongly typed programming
    language. You will dive into this more deeply in the upcoming sections, and you
    will see that strong typing enables better data security while programming.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: C# 的另一个显著特点是它是一种强类型编程语言。您将在接下来的部分中深入了解这一点，并看到强类型在编程时能够提供更好的数据安全性。
- en: Besides that, C# has become open source over the last few years, with Microsoft
    as its principal maintainer. This is highly advantageous, as it allows the language
    to receive continuous improvements from around the globe, with a solid backing
    company that both promotes and invests in it. C# is also a multi-paradigm language,
    meaning that you can use it to write software in many programming styles, in a
    beautiful, concise, and proper manner.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，C# 在过去几年中已成为开源语言，微软是其主要维护者。这非常有优势，因为它允许语言从全球范围内持续改进，并得到一个既推广又投资的稳固公司的支持。C#
    也是一种多范式语言，这意味着你可以用它以多种编程风格编写软件，以美观、简洁和正确的方式。
- en: Running and Developing C# with the .NET CLI
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 .NET CLI 运行和开发 C#
- en: One term you'll hear a lot in the C# world is .NET. It is the foundation of
    C#, a framework that the language is built on top of. It has both a Software Development
    Kit (SDK) that allows the language to be developed and a runtime that allows the
    language to run.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 世界中，你将经常听到一个术语 .NET。它是 C# 的基础，是一个语言构建在其之上的框架。它既有一个软件开发工具包 (SDK)，允许开发语言，也有一个运行时，允许语言运行。
- en: That said, to start developing with C#, you only need to install the .NET SDK.
    This installation will provide both a compiler and the runtime on the development
    environment. In this section, you will cover the basic steps of preparing your
    environment for developing and running C# locally.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，要开始使用 C# 进行开发，你只需要安装 .NET SDK。此安装将在开发环境中提供编译器和运行时。在本节中，你将了解为在本地开发和运行 C#
    准备环境的基本步骤。
- en: Note
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to the *Preface* of this book for step-by-step instructions on
    how to download the .NET 6.0 SDK and install it on your machine.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本书的*前言*部分，了解如何逐步下载 .NET 6.0 SDK 并将其安装到你的机器上的详细说明。
- en: Once the installation of the .NET 6.0 SDK is completed, you will have something
    called the .NET CLI. This Command-Line Interface (CLI) allows you to create new
    projects, compile them, and run them with very simple commands that you can run
    directly from your terminal.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦完成 .NET 6.0 SDK 的安装，你将拥有一个称为 .NET CLI 的东西。这个命令行界面（CLI）允许你使用非常简单的命令直接从你的终端创建新项目、编译它们并运行它们。
- en: 'After the installation, run the following command on your favorite terminal:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 安装后，在你的首选终端中运行以下命令：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'You should see an output like this:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该看到如下输出：
- en: '[PRE1]'
  id: totrans-18
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This output shows that you have the 6.0.100 version of the SDK installed on
    your computer. That means you are ready to start developing your applications.
    If you type `dotnet -–help`, you will notice that several commands will appear
    for you as options to run within the CLI. In this section, you will cover the
    most basic ones that you need to create and run applications: `new`, `build`,
    and `run`.'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 此输出显示你在计算机上安装了 6.0.100 版本的 SDK。这意味着你已准备好开始开发你的应用程序。如果你输入 `dotnet -–help`，你会注意到
    CLI 中将出现几个命令供你选择运行。在本节中，你将了解你需要创建和运行应用程序的最基本命令：`new`、`build` 和 `run`。
- en: 'The `dotnet new` command allows you to create a bootstrap project to start
    developing. The CLI has several built-in templates, which are nothing more than
    basic bootstraps for various types of applications: web apps, desktop apps, and
    so on. You must specify two things in the `dotnet new` command:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`dotnet new` 命令允许你创建一个引导项目以开始开发。CLI 有几个内置模板，它们只是为各种类型的应用程序（如 Web 应用程序、桌面应用程序等）提供的基本引导。在
    `dotnet new` 命令中，你必须指定两件事：'
- en: The template name
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 模板名称
- en: The project name
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 项目名称
- en: 'The name is passed as an argument, which means you should specify it with a
    `-n` or `–name` flag. The command is as follows:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 名称作为参数传递，这意味着你应该使用 `-n` 或 `–name` 标志来指定它。命令如下：
- en: '[PRE2]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'For instance, to create a new console application named `MyConsoleApp` you
    can simply type:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，要创建一个名为 `MyConsoleApp` 的新控制台应用程序，你可以简单地输入：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This will generate a new folder with a file named `MyConsoleApp.csproj`, which
    is the C# project file that contains all the metadata needed by the compiler to
    build your project, and some files needed for the application to be built and
    run.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这将生成一个新文件夹，其中包含一个名为 `MyConsoleApp.csproj` 的文件，这是编译器构建你的项目所需的全部元数据文件，以及构建和运行应用程序所需的某些文件。
- en: 'Next, the `dotnet build` command allows you to build an application and make
    it ready to run. This command should be placed only in two locations:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，`dotnet build` 命令允许你构建一个应用程序并使其准备好运行。此命令应仅放置在两个位置：
- en: A project folder, containing a `.csproj` file.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个包含 `.csproj` 文件的项目文件夹。
- en: A folder containing a `.sln` file.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 包含 `.sln` 文件的文件夹。
- en: Solution (`.sln`) files are files that contain the metadata of one or more project
    files. They are used to organize multiple project files into single builds.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 解决方案（`.sln`）文件是包含一个或多个项目文件元数据的文件。它们用于将多个项目文件组织成单个构建。
- en: Finally, the third important command is dotnet `run`. This command allows you
    to properly run an application. It can be called without any arguments from the
    folder that contains the `.csproj` file of your .NET app, or without passing the
    project folder with the `-–project` flag on the CLI. The `run` command also automatically
    builds the application prior to the run.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，第三个重要的命令是 dotnet `run`。此命令允许你正确地运行应用程序。你可以在包含你的 .NET 应用 `.csproj` 文件的文件夹中不带任何参数调用此命令，或者不带
    `-–project` 标志通过 CLI 传递项目文件夹。`run` 命令还会在运行之前自动构建应用程序。
- en: Creating Programs with the CLI and VS Code
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 CLI 和 VS Code 创建程序
- en: While working through this book, you will use Visual Studio Code (VS Code) as
    your code editor. It works on all platforms, and you can download the version
    for your OS at https://code.visualstudio.com/. Although VS Code is not a complete
    Integrated Development Environment (IDE), it has a lot of extensions that make
    it a powerful tool to develop and do proper C# coding, regardless of the OS being
    used.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在阅读本书的过程中，您将使用 Visual Studio Code (VS Code) 作为您的代码编辑器。它适用于所有平台，您可以在 https://code.visualstudio.com/
    下载适用于您操作系统的版本。尽管 VS Code 不是一个完整的集成开发环境 (IDE)，但它拥有许多扩展，使其成为开发 C# 的强大工具，无论使用的是哪种操作系统。
- en: To properly develop C# code, you will primarily need to install the Microsoft
    C# extension. It equips VS Code with the ability to do code completion and identify
    errors and is available at [https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp).
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了正确开发 C# 代码，你主要需要安装 Microsoft C# 扩展。它为 VS Code 提供了代码补全和识别错误的能力，可在 [https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp](https://marketplace.visualstudio.com/items?itemName=ms-dotnettools.csharp)
    获取。
- en: Note
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Before proceeding, it is recommended that you install VS Code and the Microsoft
    C# extension. You can find a step-by-step breakdown of the installation process
    in the *Preface* of this book.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，建议您安装 VS Code 和 Microsoft C# 扩展。您可以在本书的 *前言* 中找到安装过程的逐步说明。
- en: Basic Anatomy of a C# Program
  id: totrans-38
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: C# 程序的基本结构
- en: In order to run, every C# program needs something called an entry point. In
    C#, the standard entry point for a program is the `Main` method. Regardless of
    your program type, whether it is a web application, desktop application, or even
    a simple console one, the `Main` method will be the **entry point** for your C#
    program. This means that each time an application runs, the runtime searches for
    this method within your code and executes the code blocks inside it.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了运行，每个 C# 程序都需要一个称为入口点的东西。在 C# 中，程序的默认入口点是 `Main` 方法。无论您的程序类型如何，是 Web 应用程序、桌面应用程序，甚至是简单的控制台应用程序，`Main`
    方法都将作为您的 C# 程序的 **入口点**。这意味着每次应用程序运行时，运行时都会在您的代码中搜索此方法并执行其中的代码块。
- en: This structure is created for you by the CLI, with the `new` command. A `Program.cs`
    file contains a class named `Program`, with a method named `Main`, which, in turn,
    contains a single instruction that will be executed after the program is built
    and running. You will learn more about methods and classes later, but for now,
    just know that a class is something that usually contains a set of data and that
    can perform actions on this data through these **methods**.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 此结构由 CLI 的 `new` 命令为您创建。一个 `Program.cs` 文件包含一个名为 `Program` 的类，其中有一个名为 `Main`
    的方法，该方法包含一个在程序构建并运行后将被执行的单一指令。您将在以后学习更多关于方法和类的内容，但就现在而言，只需知道类通常是包含一组数据的东西，并且可以通过这些
    **方法** 对这些数据进行操作。
- en: Another important thing to note regarding basic C# concepts is `//`.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于基本 C# 概念的另一个重要注意事项是 `//`。
- en: 'Exercise 1.01: Creating a Console App that Says "Hello World"'
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.01：创建一个输出 "Hello World" 的控制台应用程序
- en: In this exercise, you will see the CLI commands you learned about in the previous
    section, as you build your first ever C# program. It will be a simple console
    app that will print `Hello World` to the console.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将看到上一节中学习的 CLI 命令，在构建您的第一个 C# 程序时。它将是一个简单的控制台应用程序，将在控制台上打印 `Hello World`。
- en: 'Perform the following steps to do so:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此操作：
- en: 'Open the VS Code integrated terminal and type the following:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 VS Code 集成终端并输入以下内容：
- en: '[PRE4]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: This command will create a new console application in the `Exercise1_01` folder.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令将在 `Exercise1_01` 文件夹中创建一个新的控制台应用程序。
- en: 'On the command line, type the following:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令行中，输入以下内容：
- en: '[PRE5]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'You should see the following output:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '![Figure 1.1: "Hello World" output on the console ](img/B16835_01_01.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1: "Hello World" 在控制台上的输出](img/B16835_01_01.jpg)'
- en: 'Figure 1.1: "Hello World" output on the console'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '图 1.1: "Hello World" 在控制台上的输出'
- en: Note
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/HErU6](https://packt.link/HErU6).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/HErU6](https://packt.link/HErU6) 找到此练习使用的代码。
- en: In this exercise, you created the most basic program possible with C#, a console
    application that prints some text to the prompt. You also learned how to use .NET
    CLI, which is the mechanism built within the .NET SDK to create and manage .NET projects.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你使用 C# 创建了可能的最基本程序，这是一个将一些文本打印到提示符的控制台应用程序。你还学习了如何使用 .NET CLI，这是 .NET
    SDK 内部构建的机制，用于创建和管理 .NET 项目。
- en: Now proceed to the next section to grasp how top-level statements are written.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续下一节，了解如何编写顶层语句。
- en: Top-Level Statements
  id: totrans-57
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 顶层语句
- en: 'You must have noticed in *Exercise 1.01* that, by default, when you create
    a console application, you have a `Program.cs` file that contains the following:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 你一定注意到了在*练习1.01*中，默认情况下，当你创建一个控制台应用程序时，你会有一个`Program.cs`文件，其中包含以下内容：
- en: A class named `Program`.
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个名为`Program`的类。
- en: The static void `Main` keywords.
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态void `Main`关键字。
- en: 'You will learn about classes and methods in detail later, but for now, for
    the sake of simplicity, you do not need these resources to create and execute
    programs with C#. The latest version (.NET 6) introduced a feature that makes
    writing simple programs much easier and less verbose. For instance, consider the
    following:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 你将在后面详细学习类和方法，但就目前而言，为了简单起见，你不需要这些资源来使用C#创建和执行程序。最新版本(.NET 6)引入了一个功能，使得编写简单的程序更加容易和简洁。例如，考虑以下：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'You can simply replace this snippet with two lines of code, as follows:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简单地用以下两行代码替换这个片段，如下所示：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: By using such top-level statements, you can write concise programs. You can
    simply put the statements to be executed at the top of the program. This is also
    useful for speeding up the learning curve with C#, as you need not worry about
    advanced concepts upfront. The only thing to look out for here is that the project
    can have only one file with top-level statements.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这样的顶层语句，你可以编写简洁的程序。你只需将需要执行的语句放在程序顶部即可。这也有助于加快学习C#的曲线，因为你不需要一开始就担心高级概念。这里唯一需要注意的是，项目只能有一个包含顶层语句的文件。
- en: That is why in this chapter, you will find that all exercises will use this
    format, to make things as clear as possible.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，在本章中，你会发现所有练习都将使用这种格式，以便尽可能清晰地说明。
- en: Declaring Variables
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 声明变量
- en: You will now take your first steps in creating your own programs. This section
    will delve into the concept of variables—what they are and how to use them.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将迈出创建自己程序的第一步。本节将深入探讨变量的概念——它们是什么以及如何使用它们。
- en: A variable is a name given to a computer memory location that holds some data
    that may vary. For a variable to exist, it first must be **declared** with a type
    and a name. It can also have a value assigned to it. The declaration of a variable
    can be achieved in a few different ways.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 变量是给计算机内存位置起的名字，该位置存储了一些可能变化的数据。为了使变量存在，它首先必须用类型和名字**声明**。它也可以给它赋值。变量的声明可以通过几种不同的方式实现。
- en: 'There are some basic considerations regarding naming conventions for variables
    in C#:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 关于C#中变量命名约定的基本考虑如下：
- en: The names must be unique, starting with a letter, and should contain only letters,
    digits, and the underscore character (`_`). The names can also begin with an underscore
    character.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称必须是唯一的，以字母开头，并且只能包含字母、数字和下划线字符（`_`）。名称也可以以下划线字符开头。
- en: The names are case-sensitive; thus, `myVariable` and `MyVariable` are different
    names.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 名称是区分大小写的；因此，`myVariable`和`MyVariable`是不同的名称。
- en: Reserved keywords, such as `int` or `string`, cannot be used as names (this
    is a compiler restriction) unless you put an `@` symbol in front of the name,
    such as `@int` or `@string`.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保留关键字，如`int`或`string`，不能用作名称（这是一个编译器限制），除非你在名称前加上`@`符号，例如`@int`或`@string`。
- en: 'Variables can be declared in two ways: explicitly and implicitly. Both styles
    of the declaration have their pros and cons, which you will explore in the next
    section.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 变量可以通过两种方式声明：显式和隐式。这两种声明方式都有其优缺点，你将在下一节中探讨。
- en: Declaring Variables Explicitly
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式声明变量
- en: 'A variable can be declared explicitly by writing both its type and value. Suppose
    you want to create two variables, `a` and `b`, both containing integers. Doing
    so explicitly would look like this:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过写出其类型和值来**显式声明**一个变量。假设你想要创建两个变量，`a`和`b`，它们都包含整数。这样做显式地看起来像这样：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Before a variable is used, it must have a value assigned. Otherwise, the C#
    compiler will give an error while building your program. The following example
    illustrates that:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用变量之前，必须给它赋值。否则，C#编译器在构建你的程序时会报错。以下示例说明了这一点：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is also possible to declare multiple variables in the same line, like in
    the following snippet, where you are declaring three variables; two hold the value
    `100` and one holds the value `10`:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以在同一行声明多个变量，如下面的代码片段所示，其中你声明了三个变量；两个变量持有值`100`，一个变量持有值`10`：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Declaring Variables Implicitly
  id: totrans-82
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 隐式声明变量
- en: Remember that C# is a strongly typed programming language; this means that a
    variable will always have a type associated with it. It does not matter whether
    the type is declared implicitly or explicitly. With the `var` keyword, the C#
    compiler will infer the variable type based on the value that has been assigned
    to it.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，C# 是一种强类型编程语言；这意味着变量将始终与一个类型相关联。无论类型是隐式声明还是显式声明，使用 `var` 关键字，C# 编译器都会根据已分配给它的值推断变量类型。
- en: 'Consider that you want to create a variable that holds some text using this
    method. This can be done with the following statement:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想使用这种方法创建一个包含一些文本的变量。这可以通过以下语句完成：
- en: '[PRE11]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: For storing text in a variable, you should start and end the text with double
    quotes (`"`). In the preceding example, by looking at the value that was assigned
    to `name`, C# knows that the type this variable holds is a string, even though
    the type is not mentioned in the statement.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 要在变量中存储文本，你应该使用双引号（`"`）开始和结束文本。在上面的例子中，通过查看分配给 `name` 的值，C# 知道这个变量持有的类型是字符串，即使声明中没有提到类型。
- en: Explicit versus Implicit Declaration
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 显式声明与隐式声明
- en: Explicit declarations enhance readability with the type declared, and this is
    one of the main advantages of this technique. On the other hand, they tend to
    let the code become more verbose, especially when working with some data types
    (that you will see further ahead), such as `Collections`.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 显式声明通过声明类型提高了可读性，这是这种技术的主要优点之一。另一方面，它们往往会使得代码变得更加冗长，尤其是在处理一些数据类型（你将在后面看到）时，例如
    `Collections`。
- en: Essentially, deciding on the style of declaration depends on the personal preferences
    of the programmer, and may be influenced by the company's guidelines in some cases.
    In this journey of learning, it is recommended that you pick one that makes your
    learning path smoother, as there are few substantial differences from a purely
    technical standpoint.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，选择声明风格取决于程序员的个人喜好，在某些情况下可能还会受到公司指南的影响。在学习之旅中，建议你选择一种可以使你的学习路径更加顺畅的风格，因为从纯粹的技术角度来看，它们之间几乎没有实质性的区别。
- en: 'In the next exercise, you will do this yourself by assigning variables to inputs
    that come from a user''s interaction with a console application, where the user
    will be asked to input their name. To complete this exercise, you will make use
    of the following built-in methods that C# provides, which you will be using frequently
    in your C# journey:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将亲自通过将变量分配给来自用户与控制台应用程序交互的输入来完成这个任务，用户将被要求输入他们的名字。为了完成这个练习，你将使用 C#
    提供的以下内置方法，你将在你的 C# 之旅中经常使用这些方法：
- en: '`Console.ReadLine()`: This allows you to retrieve a value that the user prompted
    on the console.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Console.ReadLine()`: 这允许你检索用户在控制台上提示的值。'
- en: '`Console.WriteLine()`: This writes the value passed as an argument as an output
    to the console.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Console.WriteLine()`: 这会将作为参数传递的值作为输出写入控制台。'
- en: 'Exercise 1.02: Assigning Variables to User Inputs'
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.02：将变量分配给用户输入
- en: In this exercise, you will create an interactive console application. The app
    should ask you for your name, and once provided, it should display a greeting
    with your name in it.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个交互式控制台应用程序。该应用程序应该要求你输入你的名字，一旦提供，它应该显示包含你的名字的问候语。
- en: 'To complete this exercise, perform the following steps:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个练习，请执行以下步骤：
- en: 'Open Command Prompt and type the following:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并输入以下内容：
- en: '[PRE12]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This command creates a new console application in the `Exercise1_02` folder.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此命令在 `Exercise1_02` 文件夹中创建一个新的控制台应用程序。
- en: 'Open the `Program.cs` file. Paste the following inside the `Main` method:'
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 文件。在 `Main` 方法中粘贴以下内容：
- en: '[PRE13]'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Save the file. On the command line, type the following:'
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。在命令行中，输入以下内容：
- en: '[PRE14]'
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This outputs the following:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这将输出以下内容：
- en: '[PRE15]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now, type your name into the console and hit `Enter` on your keyboard. For
    example, if you type in `Mateus`, the following will be the output:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请在控制台中输入你的名字，然后按键盘上的 `Enter` 键。例如，如果你输入 `Mateus`，以下将是输出结果：
- en: '[PRE16]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/1fbVH](https://packt.link/1fbVH).
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/1fbVH](https://packt.link/1fbVH) 找到用于此练习的代码。
- en: You are more familiar with what variables are, how to declare them, and how
    to assign values to them. Now it is time to start talking about what data these
    variables can store and, more specifically, what types of data there are.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 你对变量是什么、如何声明它们以及如何给它们赋值已经很熟悉了。现在，是时候开始讨论这些变量可以存储什么数据了，更具体地说，是讨论有哪些数据类型。
- en: Data Types
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据类型
- en: In this section, you will talk about the main data types within C# and their functionalities.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，你将讨论C#中的主要数据类型及其功能。
- en: Strings
  id: totrans-112
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串
- en: 'C# uses the `string` keyword to identify data that stores text as a sequence
    of characters. You can declare a string in several ways, as shown in the following
    snippet. However, when assigning some value to a string variable, you must place
    the content between a pair of double quotes, as you can see in the last two examples:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: C#使用`string`关键字来标识存储文本作为字符序列的数据。你可以以多种方式声明字符串，如下面的代码片段所示。然而，当将某个值赋给字符串变量时，你必须将内容放在一对双引号之间，如最后两个示例所示：
- en: '[PRE17]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'One simple but effective technique (that you used in the preceding *Exercise
    1.02*) is one called string interpolation. With this technique, it is very simple
    to mix plain text values with variable values, so that the text is combined among
    these two. You can combine two or more strings by following these steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一种简单但有效的技术（你在前面的*练习1.02*中使用过）称为字符串插值。使用这种技术，将普通文本值与变量值混合变得非常简单，这样文本就可以在这两者之间结合。你可以通过以下步骤组合两个或多个字符串：
- en: Before the initial quotes, insert a `$` symbol.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在初始引号之前插入一个`$`符号。
- en: 'Now, inside the strings, place curly brackets and the name of the variable
    that you want to put into the string. In this case, this is done by putting `{name}`
    inside the initial string:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在字符串中放置大括号和你要放入字符串中的变量的名称。在这种情况下，这是通过在初始字符串中放置`{name}`来完成的：
- en: '[PRE18]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Another important fact to remember about strings is that they are immutable.
    This means that a string object cannot be changed after its creation. This happens
    because strings in C# are an array of characters. Arrays are data structures that
    gather objects of the same type and have a fixed length. You will cover arrays
    in detail in an upcoming section.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 关于字符串，需要记住的另一个重要事实是它们是不可变的。这意味着字符串对象在创建后不能被更改。这是因为C#中的字符串是一个字符数组。数组是收集相同类型对象并具有固定长度的数据结构。你将在接下来的章节中详细学习数组。
- en: In the next exercise, you will explore string immutability.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个练习中，你将探索字符串不可变性。
- en: 'Exercise 1.03: Checking String Immutability'
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.03：检查字符串不可变性
- en: 'In this exercise, you will use two strings to demonstrate that string references
    are always immutable. Perform the following steps to do so:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用两个字符串来演示字符串引用始终是不可变的。执行以下步骤来完成此操作：
- en: 'Open the VS Code integrated terminal and type the following:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VS Code集成终端并输入以下内容：
- en: '[PRE19]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Open the `Program.cs` file and create a method with the `void` return type,
    which replaces part of a string like so:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Program.cs`文件，创建一个具有`void`返回类型的方法，该方法替换字符串的一部分，如下所示：
- en: '[PRE20]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: In the preceding snippet, the `Replace` function is used to replace the first
    string (`World`, in this case) with the second one (`Mars`).
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，使用了`Replace`函数将第一个字符串（在这个例子中是`World`）替换为第二个字符串（`Mars`）。
- en: 'Now, create a method that does the same thing but returns the result instead:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个执行相同操作但返回结果的方法：
- en: '[PRE21]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Now insert the following after the previous methods. Here, you create two string
    variables and observe their behavior after trying to modify them with the methods
    created previously:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在在前面方法之后插入以下内容。在这里，你创建了两个字符串变量，并在尝试使用前面创建的方法修改它们后观察它们的行为：
- en: '[PRE22]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Finally, call `dotnet run --project Exercise1_03` from the command line. You
    should see the following output on the console:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从命令行调用`dotnet run --project Exercise1_03`。你应该在控制台上看到以下输出：
- en: '[PRE23]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Note
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/ZoNiw](https://packt.link/ZoNiw).
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/ZoNiw](https://packt.link/ZoNiw)找到用于此练习的代码。
- en: With this exercise, you saw the concept of string immutability in action. When
    you passed a string that was a reference type (`Hello World!`) as a method argument,
    it was not modified. That is what happens when you use the `FormatString` method,
    which returns `void`. Due to string immutability, a new string is created but
    not allocated to any variable, and the original string stays the same. With the
    second method, it returns a new string, and this string is then printed to the
    console.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，你看到了字符串不可变性的实际应用。当你传递一个作为引用类型的字符串（`Hello World!`）作为方法参数时，它没有被修改。这就是当你使用返回`void`的`FormatString`方法时发生的情况。由于字符串不可变性，会创建一个新的字符串，但不会分配给任何变量，原始字符串保持不变。第二个方法返回一个新的字符串，然后这个字符串被打印到控制台。
- en: Comparing Strings
  id: totrans-137
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字符串比较
- en: 'Even though strings are reference values, when you use the `.Equals()` method,
    the equality operator (`==`), and other operators (such as `!=`), you are actually
    comparing the values of the strings, as can be seen in the following example:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 即使字符串是引用类型，当你使用 `.Equals()` 方法、等号运算符 (`==`) 和其他运算符（例如 `!=`）时，你实际上是在比较字符串的值，如下例所示：
- en: '[PRE24]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Now you can compare these values and call `Console.WriteLine()` to output the
    result, like so:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以比较这些值并调用 `Console.WriteLine()` 来输出结果，如下所示：
- en: '[PRE25]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Running the preceding code results in the following output:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 运行前面的代码会产生以下输出：
- en: '[PRE26]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: You get this output because, even though strings are reference types, both the
    `==` and `.Equals` comparisons run against string values. Also, remember that
    strings are immutable. This means that when you assign `second` to `first` and
    set `first` as `null`, a new value is created for `first` and, therefore, the
    reference for `second` does not change.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你得到这个输出是因为，尽管字符串是引用类型，但 `==` 和 `.Equals` 比较都是针对字符串值进行的。还要记住，字符串是不可变的。这意味着当你将
    `second` 赋值给 `first` 并将 `first` 设置为 `null` 时，会为 `first` 创建一个新的值，因此 `second` 的引用不会改变。
- en: Numeric Types
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数值类型
- en: 'C# has its numeric types subdivided into two main categories—integral and floating-point
    type numbers. The integral number types are as follows:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: C# 将其数值类型分为两大类——整型数和浮点型数。整型数类型如下：
- en: '`sbyte`: Holds values from -128 to 127'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`sbyte`: 存储从 -128 到 127 的值'
- en: '`short`: Holds values from -32,768 to 32,767'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`short`: 存储从 -32,768 到 32,767 的值'
- en: '`int`: Holds values from -2,147,483,648 to 2,147,483,647'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`int`: 存储从 -2,147,483,648 到 2,147,483,647 的值'
- en: '`long`: Holds values from -9,223,372,036,854,775,808 to 9,223,372,036,854,775,807'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`long`: 存储从 -9,223,372,036,854,775,808 到 9,223,372,036,854,775,807 的值'
- en: Deciding which type of integral type to use depends on the size of the values
    you want to store.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 选择使用哪种整型取决于你想要存储的值的范围。
- en: All these types are called signed values. This means that they can store both
    negative and positive numbers. There is also another range of types called unsigned
    types. Unsigned types are `byte`, `ushort`, `uint`, and `ulong`. The main difference
    between them is that signed types can store negative numbers and unsigned types
    can store only numbers greater than or equal to zero. You will use signed types
    most of the time, so do not worry about remembering this all at once.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些类型都称为有符号值。这意味着它们可以存储负数和正数。还有另一系列类型称为无符号类型。无符号类型是 `byte`、`ushort`、`uint`
    和 `ulong`。它们之间的主要区别是有符号类型可以存储负数，而无符号类型只能存储大于或等于零的数字。你将大多数时间使用有符号类型，所以不必担心一次性记住所有这些。
- en: 'The other category, namely, floating-point types, refers to the types used
    to store numbers with one or more decimal points. There are three floating-point
    types in C#:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 另一类，即浮点类型，指的是用于存储带有一个或多个小数点的数字的类型。在 C# 中有三种浮点类型：
- en: '`float`: This occupies four bytes and can store numbers from ± 1.5 x 10−45
    to ± 3.4 x 1038 with a precision range of six to nine digits. To declare a float
    number using `var`, you can simply append `f` to the end of the number, like so:'
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`float`: 占用四个字节，可以存储从 ± 1.5 x 10−45 到 ± 3.4 x 1038 的数字，精度范围为六到九位数字。要使用 `var`
    声明一个浮点数，你只需在数字末尾附加 `f`，如下所示：'
- en: '[PRE27]'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`double`: This occupies eight bytes and can store numbers from ± 5.0 × 10−324
    to ± 1.7 × 1030 with a precision range of 15 to 17 digits. To declare a double
    number using var, you can append d to the end of the number, like so:'
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`double`: 占用八个字节，可以存储从 ± 5.0 × 10−324 到 ± 1.7 × 1030 的数字，精度范围为 15 到 17 位数字。要使用
    `var` 声明一个双精度数，你可以在数字末尾附加 `d`，如下所示：'
- en: '[PRE28]'
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '`decimal`: This occupies 16 bytes and can store numbers from ± 1.0 x 10-28
    to ± 7.9228 x 1028 with a precision range from 28 to 29 digits. To declare a decimal
    number using var, you must simply append m to the end of the number, like so:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`decimal`: 占用 16 字节，可以存储从 ± 1.0 x 10-28 到 ± 7.9228 x 1028 的数字，精度范围为 28 到 29
    位数字。要使用 `var` 声明一个十进制数，你只需在数字末尾附加 `m`，如下所示：'
- en: '[PRE29]'
  id: totrans-159
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Choosing the floating-point type depends mainly on the degree of precision required.
    For instance, `decimal` is mostly used for financial applications that need a
    very high degree of precision and cannot rely on rounding for accurate calculations.
    With GPS coordinates, `double` variables might be appropriate if you want to deal
    with sub-meter precisions that usually have 10 digits.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 选择浮点数类型主要取决于所需的精度程度。例如，`decimal` 主要用于需要非常高的精度且不能依赖四舍五入进行准确计算的金融应用程序。对于 GPS 坐标，如果你想要处理通常有
    10 位数字的亚米精度，`double` 变量可能很合适。
- en: Another relevant point to consider when choosing numeric types is performance.
    The larger the memory space allocated to a variable, the less performant the operations
    with these variables are. Therefore, if high precision is not a requirement, `float`
    variables will be better performers than `doubles`, which, in turn, will be better
    performers than decimals.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在选择数值类型时，还需要考虑的一个相关点是性能。分配给变量的内存空间越大，使用这些变量的操作性能就越低。因此，如果不需要高精度，`float`类型的变量将比`double`类型的变量性能更好，而`double`类型的变量又将比`decimal`类型的变量性能更好。
- en: Here you grasped what variables are and their main types. Now you will perform
    some basic calculations with them, such as addition, subtraction, and multiplication.
    This can be done using the arithmetic operators available in C#, such as `+`,
    `-`, `/`, and `*`. So, move on to the next exercise where you will create a basic
    calculator using these operators.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经掌握了变量及其主要类型的概念。接下来，你将使用它们进行一些基本的计算，例如加法、减法和乘法。这可以通过C#中可用的算术运算符来完成，如`+`、`-`、`/`和`*`。因此，继续进行下一个练习，你将使用这些运算符创建一个基本的计算器。
- en: 'Exercise 1.04: Using the Basic Arithmetic Operators'
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.04：使用基本算术运算符
- en: In this exercise, you will create a simple calculator that receives two inputs
    and shows the results between them, based on which arithmetic operation is selected.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个简单的计算器，它接收两个输入并显示它们之间的结果，这取决于选定的算术运算。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: 'Open the VS Code integrated terminal and type the following:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开VS Code集成终端，并输入以下命令：
- en: '[PRE30]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Navigate to the project folder, open the `Program.cs` file, and inside the
    `Main` method, declare two variables that read the user input, like so:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 导航到项目文件夹，打开`Program.cs`文件，然后在`Main`方法中声明两个变量来读取用户输入，如下所示：
- en: '[PRE31]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The preceding snippet uses the `.ReadLine` method to read the input. This method,
    however, gives a `string`, and you need to evaluate a number. Therefore, the `Parse`
    method has been used here. All the numeric types have a method called Parse, which
    receives a string and converts it into a number.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段使用了`.ReadLine`方法来读取输入。然而，这个方法返回的是一个`string`类型，而你需要评估一个数字。因此，这里使用了`Parse`方法。所有数值类型都有一个名为`Parse`的方法，它接收一个字符串并将其转换为数字。
- en: 'Next, you need to write the output of these basic operators to the console.
    Add the following code to the `Main` method:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，你需要将这些基本运算符的输出写入控制台。将以下代码添加到`Main`方法中：
- en: '[PRE32]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Run the program using the `dotnet run` command, and you should see the following
    output, if you input `10` and `20`, for instance:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dotnet run`命令运行程序，如果你输入`10`和`20`，你应该会看到以下输出：
- en: '[PRE33]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Note
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/ldWVv](https://packt.link/ldWVv).
  id: totrans-176
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/ldWVv](https://packt.link/ldWVv)找到这个练习使用的代码。
- en: Thus, you have built a simple calculator app in C# using the arithmetic operators.
    You also learned about the concept of parsing, which is used to convert strings
    to numbers. In the next section, you will briefly cover the topic of classes,
    one of the core concepts of programming in C#.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你已经使用算术运算符在C#中构建了一个简单的计算器应用程序。你还学习了解析的概念，它用于将字符串转换为数字。在下一节中，将简要介绍类，这是C#编程的核心概念之一。
- en: Classes
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类
- en: Classes are an integral part of coding in C# and will be covered comprehensively
    in *Chapter 2*, *Building Quality Object-Oriented Code*. This section touches
    upon the basics of classes so that you can begin using them in your programs.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 类是C#编程的一个基本组成部分，将在*第2章*，*构建高质量面向对象代码*中全面介绍。本节将介绍类的基础知识，以便你可以在程序中使用它们。
- en: The reserved `class` keyword within C# is used when you want to define the type
    of an object. An object, which can also be called an instance, is nothing more
    than a block of memory that has been allocated to store information. Given this
    definition, what a class does is act as a blueprint for an object by having some
    properties to describe this object and specifying the actions that this object
    can perform through methods.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，当你想要定义一个对象类型时，会使用保留的`class`关键字。一个对象，也可以称为实例，不过是一个分配了内存块来存储信息的实体。根据这个定义，类的作用就是通过一些属性来描述这个对象，并指定这个对象可以通过方法执行的操作，从而作为对象的蓝图。
- en: 'For example, consider that you have a class named `Person`, with two properties,
    `Name` and `Age`, and a method that checks whether `Person` is a child. Methods
    are where logic can be placed to perform some action. They can return a value
    of a certain type or have the special `void` keyword, which indicates that they
    do not return anything but just execute some action. You can also have methods
    calling other methods:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个名为`Person`的类，具有两个属性`Name`和`Age`，以及一个检查`Person`是否为孩子的方法。方法是可以放置逻辑以执行某些操作的地方。它们可以返回特定类型的数据，或者有特殊的`void`关键字，表示它们不返回任何内容，只是执行一些操作。你还可以有调用其他方法的方法：
- en: '[PRE34]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'One question remains, though. Since classes act as blueprints (or definitions
    if you prefer), how do you actually allocate memory to store the information defined
    by a class? This is done through a process called instantiation. When you instantiate
    an object, you allocate some space in memory for it in a reserved area called
    the heap. When you assign a variable to an object, you are setting the variable
    to have the address of this memory space, so that each time you manipulate this
    variable, it points to and manipulates the data allocated at this memory space.
    The following is a simple example of instantiation:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，还有一个问题。由于类充当蓝图（或者如果你更喜欢，定义），你实际上是如何为类定义的信息分配内存的？这是通过一个称为实例化的过程来完成的。当你实例化一个对象时，你会在一个称为堆的预留区域为其分配一些内存空间。当你将一个变量分配给一个对象时，你是在设置这个变量，使其拥有这个内存空间的地址，因此每次你操作这个变量时，它都会指向并操作在这个内存空间分配的数据。以下是一个简单的实例化示例：
- en: '[PRE35]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Note that `Person` has properties that have two magic keywords—`get` and `set`.
    Getters define that a property value can be retrieved, and setters define that
    a property value can be set.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Person`具有具有两个魔法关键字的属性——`get`和`set`。获取器定义了可以检索属性值，而设置器定义了可以设置属性值。
- en: Another important concept here is the concept of a constructor. A constructor
    is a method with no return type, usually present at the top level of the class
    for better readability. It specifies what is needed for an object to be created.
    By default, a class will always have a parameter-less constructor. If another
    constructor with parameters is defined, the class will be constrained to only
    this one. In that case, if you still want to have a parameter-less constructor,
    you must specify one. This is quite useful, as classes can have multiple constructors.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的概念是构造函数的概念。构造函数是一个没有返回类型的方法，通常位于类的顶层，以提高可读性。它指定了创建对象所需的内容。默认情况下，类将始终有一个无参数的构造函数。如果定义了具有参数的另一个构造函数，则类将仅限于这个一个。在这种情况下，如果你仍然想要一个无参数的构造函数，你必须指定一个。这非常有用，因为类可以有多个构造函数。
- en: 'That said, you can assign values to an object property that has a setter in
    the following ways:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，你可以以下方式为具有设置器的对象属性赋值：
- en: 'At the time of creation, via its constructor:'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建时，通过其构造函数：
- en: '[PRE36]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'At the time of creation, with direct variable assignment:'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在创建时，通过直接变量赋值：
- en: '[PRE37]'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'After the object is created, as follows:'
  id: totrans-192
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在对象创建后，如下所示：
- en: '[PRE38]'
  id: totrans-193
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There is a lot more to classes that you will see further on. For now, the main
    ideas are as follows:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在你接下来会看到的类中，还有很多内容。目前，主要思想如下：
- en: Classes are blueprints of objects and can have both properties and methods that
    describe these objects.
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类是对象的蓝图，可以具有描述这些对象的属性和方法。
- en: Objects need to be instantiated so that you can perform operations with them.
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象需要被实例化，这样你才能对它们执行操作。
- en: Classes have one parameter-less constructor by default, but can have many customized
    ones as required.
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类默认有一个无参数的构造函数，但可以根据需要有许多自定义的构造函数。
- en: Object variables are references that contain the memory address of a special
    memory space allocated to the object inside a dedicated memory section named the
    heap.
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对象变量是引用，包含分配给对象在名为堆的专用内存区域内的特殊内存地址。
- en: Dates
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 日期
- en: A date can be represented in C# using the `DateTime` value type. It is a struct
    with two static properties called `MinValue`, which is January 1, 0001 00:00:00,
    and `MaxValue`, which is December 31, 9999 11:59:59 P.M. As the names suggest,
    both these values represent the minimum and maximum dates according to the Gregorian
    calendar date format. The default value for `DateTime` objects is `MinValue`.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，可以使用`DateTime`值类型来表示日期。它是一个具有两个静态属性的结构体，分别称为`MinValue`和`MaxValue`，其中`MinValue`是公元0001年1月1日00:00:00，而`MaxValue`是公元9999年12月31日23:59:59。正如其名称所暗示的，这两个值都代表了根据格里高利日历日期格式的最小和最大日期。`DateTime`对象的默认值是`MinValue`。
- en: 'It is possible to construct a `DateTime` variable in various ways. Some of
    the most common ways are as follows:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以多种方式构造 `DateTime` 变量。以下是一些最常见的方法：
- en: 'Assigning the current time as follows:'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 按如下方式分配当前时间：
- en: '[PRE39]'
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: This sets the variable to the current date and time on the calling computer,
    expressed as the local time.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变量设置为调用计算机上的当前日期和时间，以本地时间表示。
- en: '[PRE40]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This sets the variable to the current date and time on this computer, expressed
    as the Coordinated Universal Time (UTC).
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 这将变量设置为这台计算机上的当前日期和时间，以协调世界时（UTC）表示。
- en: You can also use constructors for passing days, months, years, hours, minutes,
    and even seconds and milliseconds.
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以使用构造函数传递天数、月份、年份、小时、分钟，甚至秒和毫秒。
- en: There is also a special property available for `DateTime` objects called `Ticks`.
    It is a measure of the number of 100 nanoseconds elapsed since `DateTime.MinValue`.
    Every time you have an object of this type, you can call the `Ticks` property
    to get such a value.
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于 `DateTime` 对象，还有一个特殊属性称为 `Ticks`。它是自 `DateTime.MinValue` 以来经过的 100 纳秒数的度量。每次您有这种类型的对象时，都可以调用
    `Ticks` 属性来获取这样的值。
- en: Another special type for dates is the `TimeSpan` struct. A `TimeSpan` object
    represents a time interval as days, hours, minutes, and seconds. It is useful
    when fetching intervals between dates. You will now see what this looks like in practice.
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 另一种特殊类型用于日期的是 `TimeSpan` 结构。一个 `TimeSpan` 对象表示一个时间间隔，以天、小时、分钟和秒为单位。当需要获取日期之间的间隔时，它非常有用。现在您将看到它在实际中的应用。
- en: 'Exercise 1.05: Using Date Arithmetic'
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.05：使用日期算术
- en: 'In this exercise, you will use the `TimeSpan` method/struct to calculate the
    difference between your local time and the UTC time. To complete this exercise,
    perform the following steps:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用 `TimeSpan` 方法/结构来计算您的本地时间和 UTC 时间之间的差异。为了完成这个练习，请执行以下步骤：
- en: 'Open the VS Code integrated terminal and type the following:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 VS Code 集成终端并输入以下内容：
- en: '[PRE41]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Open the `Program.cs` file.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 文件。
- en: 'Paste the following inside the `Main` method and save the file:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码粘贴到 `Main` 方法中并保存文件：
- en: '[PRE42]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: In the preceding snippet, you first checked whether the current local date and
    UTC dates were equal. Then you checked for the interval between them, if any,
    using the `TimeSpan` method. Next, it printed the difference between the local
    and UTC time and printed the date two days ahead of the current one (`31/12/ 2020`,
    in this case).
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，您首先检查当前本地日期和 UTC 日期是否相等。然后，使用 `TimeSpan` 方法检查它们之间的间隔（如果有的话）。接下来，打印本地时间和
    UTC 时间之间的差异，并打印当前日期两天后的日期（在这种情况下为 `31/12/ 2020`）。
- en: 'Save the file. On the command line, type the following:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存文件。在命令行中，输入以下内容：
- en: '[PRE43]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'You should see an output like the following:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该看到以下输出：
- en: '[PRE44]'
  id: totrans-221
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Note
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/WIScZ](https://packt.link/WIScZ).
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/WIScZ](https://packt.link/WIScZ) 找到用于此练习的代码。
- en: Note that depending on your time zone, you will likely see different output.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，根据您的时区，您可能会看到不同的输出。
- en: Formatting Dates
  id: totrans-225
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 日期格式化
- en: 'It is also possible to format `DateTime` values to localized strings. That
    means formatting a `DateTime` instance according to a special concept within the
    C# language called a culture, which is a representation of your local time. For
    instance, dates are represented differently in different countries. Now take a
    look at the following examples, where dates are outputted in both the format used
    in France and the format used in the United States:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以将 `DateTime` 值格式化为本地化字符串。这意味着根据 C# 语言中称为“文化”的特殊概念来格式化 `DateTime` 实例，它是您本地时间的表示。例如，不同国家的日期表示方式不同。现在请看以下示例，其中日期以法国和美国使用的格式输出：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'It is also possible to explicitly define the format you want the date to be
    output in, as in the following example, where you pass the `yyyyMMddTHH:mm:ss`
    value to say that you want the date to be output as year, then month, then day,
    then hour, then minutes preceded by a colon, and finally, seconds, also preceded
    by a colon:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以显式定义您希望日期输出的格式，如下例所示，其中传递了 `yyyyMMddTHH:mm:ss` 值，表示您希望日期以年、月、日、时、分（带冒号）和秒（也带冒号）的顺序输出：
- en: '[PRE46]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'The following output gets displayed:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 将显示以下输出：
- en: '[PRE47]'
  id: totrans-231
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Logical Operators and Boolean Expressions
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 逻辑运算符和布尔表达式
- en: 'You are already familiar with these. Recall that in the preceding exercise,
    you did the following comparison:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经熟悉这些了。回想一下，在前面的练习中，您做了以下比较：
- en: '[PRE48]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This output assigns the value `true` to `now` if the dates are equal. But as
    you know, they might not necessarily be the same. Therefore, if the dates are
    different, a `false` value will be assigned. These two values are the result of
    such Boolean expressions and are called Boolean values. That is why the `now`
    variable has the type of `bool`.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 这个输出将 `true` 值赋给 `now` 如果日期相等。但正如你所知，它们可能并不一定相同。因此，如果日期不同，将分配一个 `false` 值。这两个值是这种布尔表达式的结果，被称为布尔值。这就是为什么
    `now` 变量的类型是 `bool`。
- en: 'Boolean expressions are the base for every logical comparison in every program.
    Based on these comparisons, a computer can execute a certain behavior in a program.
    Here are some other examples of Boolean expressions and variable assignments:'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 布尔表达式是每个程序中每个逻辑比较的基础。基于这些比较，计算机可以在程序中执行特定的行为。以下是一些其他布尔表达式和变量赋值的示例：
- en: 'Assigning the result of a comparison that checks whether `a` is greater than
    `b`:'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将检查 `a` 是否大于 `b` 的比较结果赋值：
- en: '[PRE49]'
  id: totrans-238
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Assigning the result of a comparison that checks whether `b` is greater than
    or equal to `a`:'
  id: totrans-239
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将检查 `b` 是否大于或等于 `a` 的比较结果赋值：
- en: '[PRE50]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Checking whether two strings are equal and assigning the result of this comparison
    to a variable:'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检查两个字符串是否相等，并将此比较的结果赋值给变量：
- en: '[PRE51]'
  id: totrans-242
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Clearly, the result of the previous comparison would be `false` and this value
    will be assigned to the `areTheseAnimalsSame` variable.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，前一个比较的结果将是 `false`，并将这个值赋给 `areTheseAnimalsSame` 变量。
- en: 'Now that you have learned what Booleans are and how they work, it is time to
    look at some logical operators you can use to compare Boolean variables and expressions:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经学习了什么是布尔值以及它们是如何工作的，现在是时候看看你可以用来比较布尔变量和表达式的逻辑运算符了：
- en: 'The `&&` (AND) operator: This operator will perform an equality comparison.
    It will return `true` if both are equal and `false` if they are not. Consider
    the following example, where you check whether two strings have the length `0`:'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`&&`（与）运算符：这个运算符将执行相等比较。如果两者相等则返回 `true`，如果不相等则返回 `false`。考虑以下示例，其中你检查两个字符串的长度是否为
    `0`：'
- en: '[PRE52]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `||` (OR) operator: This operator will check whether either of the values
    being compared is `true`. For example, here you are checking whether at least
    one of the strings has zero length:'
  id: totrans-247
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`||`（或）运算符：这个运算符将检查被比较的值中是否至少有一个是 `true`。例如，在这里你检查至少有一个字符串的长度为零：'
- en: '[PRE53]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'The `!` (NOT) operator: This operator takes a Boolean expression or value and
    negates it; that is, it returns the opposite value. For example, consider the
    following example, where you negate the result of a comparison that checks whether
    one of the strings has zero length:'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`!`（非）运算符：这个运算符取一个布尔表达式或值并取反；也就是说，它返回相反的值。例如，考虑以下示例，其中你取反了一个检查字符串长度是否为零的比较结果：'
- en: '[PRE54]'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Using if-else Statements
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 if-else 语句
- en: Up till now, you have learned about types, variables, and operators. Now it
    is time to go into the mechanisms that help you to use these concepts in real-world
    problems—that is, decision-making statements.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你已经学习了关于类型、变量和运算符的内容。现在，是时候深入了解帮助你将这些概念应用于现实世界问题的机制了——即决策语句。
- en: In C#, `if-else` statements are some of the most popular choices for implementing
    branching in code, which means telling the code to follow one path if a condition
    is satisfied, else follow another path. They are logical statements that evaluate
    a Boolean expression and continue the program's execution based on this evaluation result.
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，`if-else` 语句是实现代码分支的最受欢迎的选择之一，这意味着如果条件满足，则告诉代码遵循一条路径，否则遵循另一条路径。它们是评估布尔表达式并基于此评估结果继续程序执行的逻辑语句。
- en: For example, you can use `if-else` statements to check whether the password
    entered satisfies certain criteria (such as having at least six characters and
    one digit). In the next exercise, you will do exactly that, in a simple console
    application.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，你可以使用 `if-else` 语句来检查输入的密码是否满足某些标准（例如至少有六个字符和一个数字）。在下一个练习中，你将做 exactly that，在一个简单的控制台应用程序中。
- en: 'Exercise 1.06: Branching with if-else'
  id: totrans-255
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.06：使用 if-else 进行分支
- en: In this exercise, you will use `if-else` statements to write a simple credentials
    check program. The application should ask the user to enter their username; unless
    this value is at least six characters in length, the user cannot proceed. Once
    this condition is met, the user should be asked for a password. The password should
    also have a minimum of six characters containing at least one digit. Only after
    both these criteria are met should the program display a success message, such
    as `User successfully registered`.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用`if-else`语句编写一个简单的凭证检查程序。应用程序应该要求用户输入他们的用户名；除非这个值至少有六个字符长，否则用户不能继续。一旦这个条件得到满足，用户应该被要求输入密码。密码也应该至少有六个字符，并且至少包含一个数字。只有当这两个标准都满足后，程序才应显示成功信息，例如`User
    successfully registered`。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: 'Inside the VS Code integrated terminal, create a new console project called
    `Exercise1_06`:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code集成终端中，创建一个名为`Exercise1_06`的新控制台项目：
- en: '[PRE55]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Inside the `Main` method, add the following code to ask the user for a username,
    and assign the value to a variable:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法中，添加以下代码以请求用户输入用户名，并将值分配给一个变量：
- en: '[PRE56]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'Next, the program needs to check whether the username has more than six characters
    and if not, write an error message to the console:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，程序需要检查用户名是否超过六个字符，如果不是，则将错误信息写入控制台：
- en: '[PRE57]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'Now, within an `else` clause, you will continue the verification and ask the
    user to type a password. Once the user has entered a password, three points need
    to be checked. The first condition to check is whether the password has at least
    six characters and then whether there is at least one number. Then, if either
    of these conditions fails, the console should display an error message; else,
    it should display a success message. Add the following code for this:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`else`子句中，你将继续验证并要求用户输入密码。一旦用户输入了密码，需要检查三个点。第一个条件是检查密码是否至少有六个字符，然后是否有至少一个数字。然后，如果这些条件中的任何一个失败，控制台应该显示错误信息；否则，应该显示成功信息。为此，添加以下代码：
- en: '[PRE58]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: From the preceding snippet, you can see that if the user enters fewer than six
    characters, an error message is displayed as `The password must have at least
    6 characters.`. If the password doesn't contain a single digit but satisfies the
    preceding condition, another error message is displayed as `The password must
    contain at least one number.`.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码片段中，你可以看到如果用户输入的字符少于六个，会显示错误信息`The password must have at least 6 characters.`。如果密码不包含任何数字但满足前面的条件，则会显示另一个错误信息`The
    password must contain at least one number.`。
- en: Notice the logical condition used for this, which is `!password.Any(c => char.IsDi©(c))`.
    You will learn more about the `=>` notation in *Chapter 2*, *Building Quality
    Object-Oriented Code*, but for now, you just need to know that this line checks
    every character in the password and uses the `IsDigit` function to check whether
    the character is a digit. This is done for every character, and if no digit is
    found, the error message is displayed. If all the conditions are met, a success
    message is displayed as `User successfully registered.`.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 注意这里使用的逻辑条件是`!password.Any(c => char.IsDigit(c))`。你将在*第二章*，*构建高质量面向对象代码*中了解更多关于`=>`符号的内容，但就目前而言，你只需要知道这一行会检查密码中的每个字符，并使用`IsDigit`函数来检查该字符是否为数字。这是对每个字符进行的，如果没有找到数字，则会显示错误信息。如果所有条件都满足，则会显示成功信息`User
    successfully registered.`。
- en: 'Run the program using `dotnet run`. You should see an output like the following:'
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`dotnet run`运行程序。你应该会看到以下输出：
- en: '[PRE59]'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-270
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/3Q7oK](https://packt.link/3Q7oK).
  id: totrans-271
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/3Q7oK](https://packt.link/3Q7oK)找到这个练习所使用的代码。
- en: In this exercise, you worked with if-else branching statements to implement
    a simple user registration program.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你使用了if-else分支语句来实现一个简单的用户注册程序。
- en: The Ternary Operator
  id: totrans-273
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元操作符
- en: 'Another simple-to-use, yet effective, decision-making operator is the ternary
    operator. It allows you to set the value of a variable based on a Boolean comparison.
    For example, consider the following example:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个简单易用且有效的决策操作符是三元操作符。它允许你根据布尔比较设置变量的值。例如，考虑以下示例：
- en: '[PRE60]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Here, you are using the `?` symbol to check whether the Boolean condition placed
    before it is valid. The compiler runs the `IsChild` function for the `person`
    object. If the method returns `true`, the first value (before the `:` symbol)
    will be assigned to the `gift` variable. If the method returns `false`, the second
    value (after the `:` symbol) will be assigned to the `gift` variable.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用 `?` 符号来检查它之前放置的布尔条件是否有效。编译器为 `person` 对象运行 `IsChild` 函数。如果该方法返回 `true`，则第一个值（在
    `:` 符号之前）将被分配给 `gift` 变量。如果该方法返回 `false`，则第二个值（在 `:` 符号之后）将被分配给 `gift` 变量。
- en: The ternary operator is simple and makes assignments based on simple Boolean
    verifications even more concise. You will be using this quite often in your C#
    journey.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 三元运算符简单且使基于简单布尔验证的赋值更加简洁。你将在你的 C# 之旅中经常使用它。
- en: Reference and Value Types
  id: totrans-278
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 引用类型和值类型
- en: 'There are two types of variables in C#, namely, reference types and value types.
    Variables of value types, such as structs, contain the values themselves, as the
    name suggests. These values are stored in a memory space called the stack. When
    a variable of such a type is declared, specific memory space is allocated to store
    this value, as illustrated in the following figure:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中有两种类型的变量，即引用类型和值类型。值类型变量，如结构体，包含自身值，正如其名称所示。这些值存储在称为堆栈的内存空间中。当声明此类类型的变量时，将分配特定的内存空间来存储此值，如下图所示：
- en: '![Figure 1.2: Memory allocation for a value type variable ](img/B16835_01_02.jpg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2：值类型变量的内存分配](img/B16835_01_02.jpg)'
- en: 'Figure 1.2: Memory allocation for a value type variable'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.2：值类型变量的内存分配
- en: Here, the value of the variable, which is `5`, is stored in memory at the location
    `0x100` in the RAM. The built-in value types for C# are `bool`, `byte`, `char`,
    `decimal`, `double`, `enum`, `float`, `int`, `long`, `sbyte`, `short`, `struct`,
    `uint`, `ulong`, and `ushort`.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，变量的值，即 `5`，存储在 RAM 中的 `0x100` 位置。C# 的内置值类型包括 `bool`、`byte`、`char`、`decimal`、`double`、`enum`、`float`、`int`、`long`、`sbyte`、`short`、`struct`、`uint`、`ulong`
    和 `ushort`。
- en: 'The scenario for reference type variables is different, though. The three main
    reference types you need to know about in this chapter are `string`, array, and
    `class`. When a new reference type variable is assigned, what is stored in memory
    is not the value itself, but instead a memory address where the value gets allocated.
    For example, consider the following diagram:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 引用类型变量的场景不同。在本章中，你需要了解的三个主要引用类型是 `string`、数组和 `class`。当分配新的引用类型变量时，存储在内存中的不是值本身，而是一个值分配的内存地址。例如，考虑以下图示：
- en: '![Figure 1.3: Memory allocation for a reference type variable ](img/B16835_01_03.jpg)'
  id: totrans-284
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3：引用类型变量的内存分配](img/B16835_01_03.jpg)'
- en: 'Figure 1.3: Memory allocation for a reference type variable'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3：引用类型变量的内存分配
- en: 'Here, instead of the value of the string variable (`Hello`), the address where
    it is allocated (`0x100`) is stored in memory. For brevity, you will not dive
    deep into this topic, but it is important to know the following points:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，存储在内存中的不是字符串变量（`Hello`）的值，而是它分配的地址（`0x100`）。为了简洁起见，你不会深入探讨这个主题，但了解以下要点很重要：
- en: When value type variables are passed as parameters or assigned as the value
    of another variable, the .NET runtime copies the value of the variable to the
    other object. This means that the original variable is not affected by any changes
    made in the newer and subsequent variables, as the values were literally copied
    from one place to another.
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当值类型变量作为参数传递或作为另一个变量的值分配时，.NET 运行时会将变量的值复制到另一个对象。这意味着原始变量不会受到在较新和后续变量中做出的任何更改的影响，因为值是从一个地方直接复制到另一个地方的。
- en: When reference type variables are passed as parameters or assigned as the value
    of another variable, .NET passes the heap memory address instead of the value.
    This means that every subsequent change made in this variable inside a method
    will be reflected outside.
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当引用类型变量作为参数传递或作为另一个变量的值分配时，.NET 会传递堆内存地址而不是值。这意味着在方法内部对此变量所做的任何后续更改都将反映在外部。
- en: 'For instance, consider the following code, which deals with integers. Here,
    you declare an `int` variable named `a` and assign the value `100` to it. Later,
    you create another `int` variable named `b` and assign the value of `a` to it.
    Finally, you modify `b`, to be incremented by `100`:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，考虑以下处理整数的代码。这里，你声明一个名为 `a` 的 `int` 变量并将其值设置为 `100`。稍后，你创建另一个名为 `b` 的 `int`
    变量并将 `a` 的值赋给它。最后，你修改 `b`，将其增加 `100`：
- en: '[PRE61]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The values of `a` and `b` will be displayed in the following output:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`a` 和 `b` 的值将在以下输出中显示：'
- en: '[PRE62]'
  id: totrans-292
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: In this example, the value from `a` was copied into `b`. From this point, any
    other modification you do on `b` will reflect changes only in `b` and `a` will
    continue to have its original value.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`a` 的值被复制到 `b` 中。从这一点开始，你对 `b` 所做的任何其他修改都只会反映在 `b` 上，而 `a` 将继续保持其原始值。
- en: 'Now, what if you pass reference types as method arguments? Consider the following
    program. Here, you have a class named `Car` with two properties—`Name` and `GearType`.
    Inside the program is a method called `UpgradeGearType` that receives an object
    of the `Car` type and changes its `GearType` to `Automatic`:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你将引用类型作为方法参数传递，会发生什么？考虑以下程序。这里，你有一个名为 `Car` 的类，具有两个属性——`Name` 和 `GearType`。在程序中有一个名为
    `UpgradeGearType` 的方法，它接收 `Car` 类型的对象并将其 `GearType` 更改为 `Automatic`：
- en: '[PRE63]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'After you create a `Car` `UpgradeGearType()` method, the output will be as
    the follows:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建 `Car` 的 `UpgradeGearType()` 方法后，输出将如下所示：
- en: '[PRE64]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: Thus, you see that if you pass an `car` in this case) as an argument to a method
    (`UpgradeGearType` in this example), every change made inside this **object**
    is reflected after and outside the method call. This is because reference types
    refer to a specific location in memory.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以看到，如果你将一个 `car`（在这种情况下）作为参数传递给一个方法（例如示例中的 `UpgradeGearType`），在这个 **对象**
    内部所做的任何更改都会在方法调用之后和外部反映出来。这是因为引用类型引用内存中的特定位置。
- en: 'Exercise 1.07: Grasping Value and Reference Equality'
  id: totrans-299
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.07：掌握值和引用相等
- en: 'In this exercise, you will see how equality comparison is different for value
    types and reference types. Perform the following steps to do so:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将看到值类型和引用类型的相等比较有何不同。执行以下步骤来完成此操作：
- en: 'In VS Code, open the integrated terminal and type the following:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 中，打开集成终端并输入以下内容：
- en: '[PRE65]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Open the `Program.cs` file. In the same file, create a struct named `GoldenRetriever`
    with a `Name` property, as follows:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 文件。在同一文件中，创建一个名为 `GoldenRetriever` 的结构体，具有 `Name` 属性，如下所示：
- en: '[PRE66]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Still in the same file, create one more class named `BorderCollie` with a similar
    `Name` property:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 仍然在同一文件中，创建一个名为 `BorderCollie` 的另一个类，具有类似的 `Name` 属性：
- en: '[PRE67]'
  id: totrans-306
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'One final class must be created, a class named `Bernese`, also having the `Name`
    property, but with an extra override of the native `Equals` method:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还必须创建一个最终的类，一个名为 `Bernese` 的类，也具有 `Name` 属性，但额外重写了原生的 `Equals` 方法：
- en: '[PRE68]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Here, the `this` keyword is used to refer to the current `borderCollie` class.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`this` 关键字用于引用当前的 `borderCollie` 类。
- en: 'Finally, in the `Program.cs` file, you will create some objects for these types.
    Note that since you are using **top-level statements**, these declarations should
    be above the class and the struct declarations:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `Program.cs` 文件中，你将为这些类型创建一些对象。请注意，由于你正在使用 **顶层语句**，这些声明应该在类和结构体声明之上：
- en: '[PRE69]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Now, right after the previous declarations, compare these values using the
    `Equals` method and assign the result to some variables:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在之前的声明之后，使用 `Equals` 方法比较这些值并将结果赋给一些变量：
- en: '[PRE70]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Finally, print the comparison results to the console with the following:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用以下代码将比较结果打印到控制台：
- en: '[PRE71]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'Run the program from the command line using `dotnet run` and you will see the
    following output:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet run` 从命令行运行程序，你将看到以下输出：
- en: '[PRE72]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE72]'
- en: Note
  id: totrans-318
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/xcWN9](https://packt.link/xcWN9).
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/xcWN9](https://packt.link/xcWN9) 找到用于此练习的代码。
- en: As mentioned earlier, structs are value types. Therefore, when two objects of
    the same struct are compared with `Equals`, .NET internally checks all the struct
    properties. If those properties have equal values, then `true` is returned. With
    `Golden Retrievers`, for instance, if you had a `FamilyName` property and this
    property was different between the two objects, the result of the equality comparison
    would be `false`.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，结构体是值类型。因此，当两个相同结构体的对象使用 `Equals` 进行比较时，.NET 内部会检查所有结构体属性。如果这些属性的值相等，则返回
    `true`。以 `Golden Retrievers` 为例，如果你有一个 `FamilyName` 属性，并且这个属性在两个对象之间不同，则相等比较的结果将是
    `false`。
- en: For classes and all other reference types, the equality comparison is quite
    different. By default, object reference is checked on equality comparison. If
    the references are different (and they will be, unless the two variables are assigned
    to the same object), the equality comparison will return `false`. This explains
    the result you see for `Border Collies` in the example that the references were
    different for the two instances.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类和所有其他引用类型，相等比较相当不同。默认情况下，在相等比较时检查对象引用。如果引用不同（除非两个变量被分配到同一个对象），相等比较将返回`false`。这解释了示例中`Border
    Collies`的结果，即两个实例的引用是不同的。
- en: However, there is a method that can be implemented in reference types called
    Equals. Given two objects, the `Equals` method can be used for comparison following
    the logic placed inside the method. That is exactly what happened with the Bernese
    dogs example.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可以在引用类型中实现一个名为`Equals`的方法。给定两个对象，`Equals`方法可以用于在方法内部放置的逻辑之后的比较。这正是Bernese
    dogs示例中发生的情况。
- en: Default Value Types
  id: totrans-323
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认值类型
- en: 'Now that you have dealt with value and reference types, you will briefly explore
    the default value types. In C#, every type has a default value, as specified in
    the following table:'
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经处理了值和引用类型，你将简要探索默认值类型。在C#中，每个类型都有一个默认值，如下表所示：
- en: '![Figure 1.4: Default value types table ](img/B16835_01_04.jpg)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
  zh: '![图1.4：默认值类型表](img/B16835_01_04.jpg)'
- en: 'Figure 1.4: Default value types table'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.4：默认值类型表
- en: 'These default values can be assigned to a variable using the `default` keyword.
    To use this word in a variable declaration, you must explicitly declare the variable
    type before its name. For example, consider the following snippet, where you are
    assigning the `default` value to two `int` variables:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 这些默认值可以使用`default`关键字分配给变量。要在变量声明中使用此词，必须在变量名称之前显式声明变量类型。例如，考虑以下代码片段，其中你将`default`值分配给两个`int`变量：
- en: '[PRE73]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'Both `a` and `b` will be assigned the value `0` in this case. Note that it
    is not possible to use `var` in this case. This is because, for implicitly declared
    variables, the compiler needs a value assigned to the variable in order to infer
    its type. So, the following snippet will lead to an error because no type was
    set, either through an explicit declaration or by variable assignment:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`a`和`b`都将被分配值为`0`。请注意，在这种情况下不能使用`var`。这是因为，对于隐式声明的变量，编译器需要将值分配给变量以推断其类型。因此，以下代码片段将导致错误，因为没有设置类型，无论是通过显式声明还是通过变量赋值：
- en: '[PRE74]'
  id: totrans-330
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: Enhancing Decision Making with the switch Statement
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`switch`语句增强决策
- en: 'The `switch` statement is often used as an alternative to the if-else construct
    if a single expression is to be tested against three or more conditions, that
    is, when you want to select one of many code sections to be executed, such as
    the following:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要测试单个表达式与三个或更多条件时，`switch`语句通常用作if-else结构的替代方案，即当你想要执行多个代码部分中的一个时，如下所示：
- en: '[PRE75]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'The matching expression should return a value that is of one of the following
    types: `char`, `string`, `bool`, `numbers`, `enum`, and `object`. This value will
    then be evaluated within one of the matching case clauses or within the default
    clause if it does not match any prior clause.'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 匹配表达式应该返回以下类型之一：`char`、`string`、`bool`、`numbers`、`enum`和`object`。然后，这个值将在匹配的某个case子句或默认子句中进行评估，如果它不匹配任何先前的子句。
- en: It is important to say that only one `switch` section in a `switch` statement
    will be executed. C# doesn't allow execution to continue from one `switch` section
    to the next. However, a `switch` statement does not know how to stop by itself.
    You can either use the `break` keyword if you only wish to execute something without
    returning or return something if that is the case.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要说明，在`switch`语句中，只有一个`switch`部分会被执行。C#不允许从一个`switch`部分继续执行到下一个。然而，`switch`语句本身并不知道如何停止。你可以使用`break`关键字，如果你只想执行某些操作而不返回，或者如果需要返回某些值。
- en: Also, the `default` keyword on a `switch` statement is where the execution goes
    if none of the other options are matched. In the next exercise, you will use a
    `switch` statement to create a restaurant menu app.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，`switch`语句上的`default`关键字是如果没有匹配其他选项，执行将去的地方。在下一个练习中，你将使用`switch`语句创建一个餐厅菜单应用程序。
- en: 'Exercise 1.08: Using switch to Order Food'
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.08：使用`switch`来点餐
- en: In this exercise, you will create a console app that lets the user select from
    a menu of food items available at a restaurant. The app should display an acknowledgment
    receipt for the order. You will use the `switch` statement to implement the logic.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将创建一个控制台应用程序，允许用户从餐厅提供的菜单中选择食物项目。应用程序应显示订单的确认收据。您将使用`switch`语句来实现逻辑。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: Create a new console project called `Exercise1_08`.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Exercise1_08`的新控制台项目。
- en: 'Now, create an `System.Text.StringBuilder`. This is a class that helps build
    strings in many ways. Here, you are building strings line by line so that they
    can be properly displayed on the console:'
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个`System.Text.StringBuilder`。这是一个帮助以多种方式构建字符串的类。在这里，您是逐行构建字符串，以便它们可以在控制台上正确显示：
- en: '[PRE76]'
  id: totrans-342
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Display the menu on the console and ask the user to choose one of the options:'
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台上显示菜单，并要求用户选择一个选项：
- en: '[PRE77]'
  id: totrans-344
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Read the key that the user presses and assign it to a variable with the `Console.ReadKey()`
    method. This method works similarly to `ReadLine()`, which you have used before,
    with the difference that it reads the key that is immediately pressed after calling
    the method. Add the following code for this:'
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 读取用户按下的键并将其分配给一个变量，使用`Console.ReadKey()`方法。此方法与您之前使用的`ReadLine()`方法类似，区别在于它读取方法调用后立即按下的键。为此添加以下代码：
- en: '[PRE78]'
  id: totrans-346
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: 'Now it is time to use the `switch` statement. Use `option.KeyChar.ToString()`
    as the matching expression of the `switch` clause here. Keys `1`, `2`, `3`, and
    `4` should result in orders accepted for `burgers`, `cheeseburgers`, `double cheeseburgers`,
    and `Coke`, respectively:'
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在是时候使用`switch`语句了。在此处将`option.KeyChar.ToString()`用作`switch`子句的匹配表达式。键`1`、`2`、`3`和`4`应分别导致接受`汉堡`、`芝士汉堡`、`双层芝士汉堡`和`可乐`的订单：
- en: '[PRE79]'
  id: totrans-348
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Any other input, however, should be considered invalid and a message gets displayed,
    letting you know you have selected an invalid option:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，任何其他输入都应被视为无效，并显示一条消息，告知您已选择无效选项：
- en: '[PRE80]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'Finally, run the program with `dotnet run --project Exercise1_08` and interact
    with the console to see the possible outputs. For example, if you type `1`, you
    should see an output like the following:'
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`dotnet run --project Exercise1_08`运行程序，并与控制台交互以查看可能的输出。例如，如果您输入`1`，您应该看到以下输出：
- en: '[PRE81]'
  id: totrans-352
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: Note
  id: totrans-353
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/x1Mvn](https://packt.link/x1Mvn).
  id: totrans-354
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/x1Mvn](https://packt.link/x1Mvn)找到用于此练习的代码。
- en: Similarly, you should get the output for the other options as well. You have
    learned about branching statements in C#. There is another type of statement that
    you will use often while programming using C#, called iteration statements. The
    next section covers this topic in detail.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，您还应该获取其他选项的输出。您已经学习了C#中的分支语句。在用C#编程时，您还会经常使用另一种类型的语句，称为迭代语句。下一节将详细介绍这一主题。
- en: Iteration Statements
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 迭代语句
- en: Iteration statements, also called loops, are types of statements that are useful
    in the real world, as you often need to continuously repeat some logical execution
    in your applications `while` or `until` some condition is met, such as operating
    with a number that must be incremented until a certain value. C# offers numerous
    ways of implementing such iterations, and in this section, you will examine each
    of these in detail.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 迭代语句，也称为循环，是实际应用中有用的语句类型，因为您经常需要在满足某些条件（例如，操作必须递增到某个值的数字）之前，在您的应用程序中连续重复某些逻辑执行。C#提供了多种实现此类迭代的方法，在本节中，您将详细检查这些方法。
- en: while
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: while
- en: 'The first iteration statement you will consider is the `while` statement. This
    statement allows a C# program to execute a set of instructions while a certain
    Boolean expression is evaluated to be `true`. It has one of the most basic structures.
    Consider the following snippet:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 您将考虑的第一个迭代语句是`while`语句。此语句允许C#程序在某个布尔表达式评估为`true`时执行一系列指令。它具有最基本的结构之一。考虑以下代码片段：
- en: '[PRE82]'
  id: totrans-360
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: The preceding snippet shows how you can use the `while` statement. Note that
    the `while` keyword is followed by a pair of brackets enclosing a logical condition;
    in this case, the condition is that the value of `i` must be less than `10`. The
    code written inside the curly braces will be executed until this condition is
    `true`.
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段展示了如何使用`while`语句。请注意，`while`关键字后面跟着一对括号，括号内包含一个逻辑条件；在这种情况下，条件是`i`的值必须小于`10`。大括号内编写的代码将在该条件为`true`时执行。
- en: Thus, the preceding code will print the value of `i`, starting with `0`, up
    to `10`. This is fairly simplistic code; in the next exercise, you will use the
    `while` statement for something a little more complex, such as checking whether
    a number entered by you is a prime number.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，前面的代码将打印从`0`开始的`i`的值，直到`10`。这是一段相当简单的代码；在下一个练习中，您将使用`while`语句进行一些更复杂的操作，例如检查您输入的数字是否为质数。
- en: 'Exercise 1.09: Checking Whether a Number is Prime with a while Loop'
  id: totrans-363
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.09：使用`while`循环检查数字是否为质数
- en: In this exercise, you will use a `while` loop to check whether a number you
    enter is prime. To do so, the `while` loop will check whether the counter is less
    than or equal to the integer result of the division of the number by `2`. When
    this condition is satisfied, you check whether the remainder of the division of
    the number by the counter is `0`. If not, you increment the counter and continue
    until the loop condition is not met. If it is met, it means the number is not
    `false` and the loop can stop.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，您将使用`while`循环来检查您输入的数字是否为质数。为此，`while`循环将检查计数器是否小于或等于数字除以`2`的整数结果。当这个条件满足时，您检查数字除以计数器的余数是否为`0`。如果不是，您增加计数器并继续，直到循环条件不满足。如果满足，这意味着数字不是`false`，循环可以停止。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: Inside the VS Code integrated terminal, create a new console project called
    `Exercise1_09`.
  id: totrans-366
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code集成终端中，创建一个名为`Exercise1_09`的新控制台项目。
- en: 'Inside the `Program.cs` file, create the following method, which will perform
    the logic you introduced at the beginning of the exercise:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，创建以下方法，该方法将执行您在练习开始时引入的逻辑：
- en: '[PRE83]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: 'Now, input a number, so you can check whether it is prime:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，输入一个数字，这样您就可以检查它是否为质数：
- en: '[PRE84]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'Now, check whether the number is prime and print the result:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，检查数字是否为质数并打印结果：
- en: '[PRE85]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Finally, on the VS Code integrated terminal, call `dotnet run --project Exercise1_09`
    and interact with the program. For example, try entering `29` as an input:'
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在VS Code集成终端中，调用`dotnet run --project Exercise1_09`并与程序交互。例如，尝试输入`29`作为输入：
- en: '[PRE86]'
  id: totrans-374
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE86]'
- en: As expected, the result for `29` is `true` since it is a prime number.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期，`29`的结果为`true`，因为它是一个质数。
- en: Note
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/5oNg5](https://packt.link/5oNg5).
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/5oNg5](https://packt.link/5oNg5)找到用于此练习的代码。
- en: The preceding exercise aimed to show you the simple structure of a `while` loop
    with some more complex logic. It checks a number (named `input`) and prints whether
    it is a prime number. Here, you have seen the `break` keyword used again to stop
    program execution. Now proceed to learn about jump statements.
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的练习旨在向您展示一个带有一些更复杂逻辑的`while`循环的简单结构。它检查一个数字（命名为`input`）并打印它是否为质数。在这里，您再次看到了`break`关键字被用来停止程序执行。现在继续学习跳转语句。
- en: Jump Statements
  id: totrans-379
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳转语句
- en: 'There are some other important keywords used within loops that are worth mentioning
    as well. These keywords are called jump statements and are used to transfer program
    executions to another part. For instance, you could rewrite the `IsPrime` method
    as follows:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环中还有一些其他重要的关键字也值得提及。这些关键字被称为跳转语句，用于将程序执行转移到另一个部分。例如，您可以按如下方式重写`IsPrime`方法：
- en: '[PRE87]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: Here, you have inverted the logical check. Instead of checking whether the remainder
    is zero and then breaking the program execution, you have checked that the remainder
    is not zero and, if so, have used the `continue` statement to pass the execution
    to the next iteration.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您反转了逻辑检查。您不是检查余数是否为零然后中断程序执行，而是检查余数是否不为零，如果是这样，就使用`continue`语句将执行传递到下一个迭代。
- en: 'Now look at how you can rewrite this using another special keyword, `goto`:'
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，看看您如何使用另一个特殊关键字`goto`来重写它：
- en: '[PRE88]'
  id: totrans-384
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'The `goto` keyword can be used to jump from one part of the code to another
    one defined by what is called a label. In this case, the label was named `isNotAPrime`.
    Finally, take a look at one last way of writing this logic:'
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`goto`关键字从一个代码部分跳转到另一个由所谓的标签定义的部分。在这种情况下，标签被命名为`isNotAPrime`。最后，看看另一种编写这种逻辑的方法：
- en: '[PRE89]'
  id: totrans-386
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: Now, instead of using `break` or `continue` to stop the program execution, you
    simply use `return` to break the loop execution since the result that you were
    looking for was already found.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，您不是使用`break`或`continue`来停止程序执行，而是简单地使用`return`来中断循环执行，因为您已经找到了您要找的结果。
- en: do-while
  id: totrans-388
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: do-while
- en: 'The `do-while` loop is like the previous one, but with one subtle difference:
    it executes the logic at least once, while a simple `while` statement may never
    be executed if the condition is not met at the first execution. It has the following structure:'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`do-while` 循环与之前类似，但有一个细微的区别：它至少执行一次逻辑，而简单的 `while` 语句如果首次执行时条件不满足，可能永远不会执行。它具有以下结构：'
- en: '[PRE90]'
  id: totrans-390
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: In this example, you write the value of `t`, starting from `0`, and keep incrementing
    it while it is smaller than `5`. Before jumping into the next type of loop, learn
    about a new concept called arrays.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你从 `0` 开始写入 `t` 的值，并在它小于 `5` 时持续递增。在深入研究下一类循环之前，了解一个新概念，即数组。
- en: Arrays
  id: totrans-392
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 数组
- en: 'An array is a data structure used to store many objects of the same type. For
    instance, the following example is a variable declared as an array of integer
    numbers:'
  id: totrans-393
  prefs: []
  type: TYPE_NORMAL
  zh: 数组是一种用于存储许多相同类型对象的数据结构。例如，以下示例是一个声明为整数数组变量的变量：
- en: '[PRE91]'
  id: totrans-394
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: 'The first important thing to note about arrays is that they have a fixed capacity.
    This means that an array will have the length defined at the time of its creation
    and this length cannot change. The length can be determined in various ways. In
    the preceding example, the length is inferred by counting the number of objects
    in the array. However, another way of creating an array is like this:'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 关于数组的一个重要注意事项是它们具有固定容量。这意味着数组在其创建时将定义长度，并且这个长度不能改变。长度可以通过各种方式确定。在前面的例子中，长度是通过计算数组中的对象数量来推断的。然而，创建数组的另一种方式如下：
- en: '[PRE92]'
  id: totrans-396
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Here, you are creating an array that has the capacity of `5` integers, but
    you do not specify any value for the array elements. When an array of any data
    type is created without adding elements to it, the default values for that value
    type are set for each position of the array. For example, consider the following
    figure:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你正在创建一个容量为 `5` 个整数的数组，但你没有为数组元素指定任何值。当创建任何数据类型的数组而不向其中添加元素时，该值类型的默认值将设置为数组的每个位置。例如，考虑以下图示：
- en: '![Figure 1.5: Value type array with no index assigned ](img/B16835_01_05.jpg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.5：未分配索引的值类型数组](img/B16835_01_05.jpg)'
- en: 'Figure 1.5: Value type array with no index assigned'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5：未分配索引的值类型数组
- en: 'The preceding figure shows that when you create an integer array of five elements,
    without assigning a value to any element, the array is automatically filled with
    the default value at every position. In this case, the default value is `0`. Now
    consider the following figure:'
  id: totrans-400
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图示显示，当你创建一个包含五个元素的整数数组时，如果不为任何元素分配值，数组将自动在每个位置填充默认值。在这种情况下，默认值是 `0`。现在考虑以下图示：
- en: '![Figure 1.6: Reference type array with fixed size and only one index assigned
    ](img/B16835_01_06.jpg)'
  id: totrans-401
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.6：具有固定大小和单个索引的引用类型数组](img/B16835_01_06.jpg)'
- en: 'Figure 1.6: Reference type array with fixed size and only one index assigned'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.6：具有固定大小和单个索引的引用类型数组
- en: In the preceding example, you have created an array of five objects and assigned
    the `"Hello"` string value to the element at index `1`. The other positions of
    the array are automatically assigned the default value for objects, which is `null`.
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的例子中，你创建了一个包含五个对象的数组，并将 `"Hello"` 字符串值分配给索引 `1` 的元素。数组的其他位置自动分配对象的默认值，该默认值为
    `null`。
- en: Finally, it is worth noting that all arrays have indexes, which refers to the
    positions of the individual array elements. The first position will always have
    an index `0`. Thus, the positions in an array of size `n` can be specified from
    index `0` to `n-1`. Therefore, if you call `numbers[2]`, this means that you are
    trying to access the element in position `2` inside the numbers array.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，值得注意的是，所有数组都有索引，这指的是单个数组元素的位置。第一个位置始终具有索引 `0`。因此，大小为 `n` 的数组中的位置可以从索引 `0`
    到 `n-1` 指定。因此，如果你调用 `numbers[2]`，这意味着你正在尝试访问 `numbers` 数组中的位置 `2` 的元素。
- en: for Loops
  id: totrans-405
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: for 循环
- en: 'A `for` loop executes a set of instructions while a Boolean expression matches
    a specified condition. Just like `while` loops, jump statements can be used to
    stop a loop execution. It has the following structure:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`for` 循环在布尔表达式匹配指定条件时执行一系列指令。就像 `while` 循环一样，可以使用跳转语句来停止循环执行。它具有以下结构：'
- en: '[PRE93]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE93]'
- en: The initializer statement is executed before the loop starts. It is used to
    declare and assign a local variable that will be used only inside the scope of
    the loop.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 初始化语句在循环开始之前执行。它用于声明并分配一个仅用于循环作用域内的局部变量。
- en: 'But in more complex scenarios, it can be used to combine other statement expressions
    as well. The condition specifies a Boolean condition that indicates when the loop
    should either continue or exit. The iterator is usually used to increment or decrement
    the variable created in the initializer section. Take the following example, where
    a `for` loop is used to print the elements of an integer array:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 但在更复杂的场景中，它也可以用来组合其他语句表达式。条件指定了一个布尔条件，指示循环何时继续或退出。迭代器通常用于在初始化部分创建的变量中增加或减少。以下是一个例子，其中使用`for`循环打印整数数组的元素：
- en: '[PRE94]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE94]'
- en: In this example, an initializer variable, `j`, has been created that is assigned
    `0` initially. The `for` loop will keep executing while `j` is smaller than the
    array length minus `1` (remember that indexes always start at `0`). After each
    iteration, the value of `j` is incremented by `1`. In this way, the `for` loop
    goes through the entire array and performs the given action, that is, printing
    the value of the current array element.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，已经创建了一个初始化变量`j`，其初始值为`0`。`for`循环将在`j`小于数组长度减`1`时持续执行（记住索引总是从`0`开始）。在每次迭代后，`j`的值增加`1`。这样，`for`循环就会遍历整个数组并执行给定的操作，即打印当前数组元素的值。
- en: C# also allows the usage of **nested loops**, that is, a **loop within a loop**,
    as you will see in the next exercise.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: C#还允许使用**嵌套循环**，即**循环中的循环**，你将在下一个练习中看到。
- en: 'Exercise 1.10: Ordering an Array Using Bubble Sort'
  id: totrans-413
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.10：使用冒泡排序对数组进行排序
- en: In this exercise, you will execute one of the simplest sorting algorithms. Bubble
    sort consists of going through every pair of elements inside an array and swapping
    them if they are unordered. In the end, the expectation is to have an array ordered
    in ascending order. You will use nested `for` loops to implement this algorithm.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将执行一种最简单的排序算法。冒泡排序包括遍历数组中的每一对元素，并在它们未排序时交换它们。最终，期望得到一个按升序排列的数组。你将使用嵌套的`for`循环来实现这个算法。
- en: To begin with, the array to be sorted should be passed as a parameter to this
    method. For each element of this array, if the current element is greater than
    the next, their positions should be swapped. This swap occurs by storing the value
    of the next element in a temporary variable, assigning the value of the current
    element to the next element, and finally, setting the value of the current element
    with the temporary value stored. Once the first element is compared to all others,
    a comparison starts for the second element and so on, till finally, the array
    is sorted.
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，应该将待排序的数组作为参数传递给此方法。对于数组的每个元素，如果当前元素大于下一个元素，则应交换它们的位置。这种交换通过将下一个元素的值存储在一个临时变量中，将当前元素的值赋给下一个元素，最后使用存储的临时值设置当前元素的值来实现。一旦第一个元素与其他所有元素进行比较，就会开始对第二个元素进行比较，依此类推，直到最终数组被排序。
- en: 'The following steps will help you complete this exercise:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个练习：
- en: 'Create a new console project using the following command:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下命令创建一个新的控制台项目：
- en: '[PRE95]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'Inside the `Program.cs` file, create the method to implement the sorting algorithm.
    Add the following code:'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中，创建一个方法来实现排序算法。添加以下代码：
- en: '[PRE96]'
  id: totrans-420
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Now create an **array** with some numbers, as follows:'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个包含一些数字的**数组**，如下所示：
- en: '[PRE97]'
  id: totrans-422
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Call the `BubbleSort` method, passing the array as an argument, and assign
    the result to a variable, as follows:'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`BubbleSort`方法，将数组作为参数传递，并将结果赋给一个变量，如下所示：
- en: '[PRE98]'
  id: totrans-424
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Finally, you need to print the message that the array was sorted. To do so,
    iterate over it, printing the array elements:'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，你需要打印出数组已排序的消息。为此，遍历数组，打印数组元素：
- en: '[PRE99]'
  id: totrans-426
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Run the program with the `dotnet run --project Exercise1_10` command. You should
    see the following output on your screen:'
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `dotnet run --project Exercise1_10` 命令运行程序。你应该会在屏幕上看到以下输出：
- en: '[PRE100]'
  id: totrans-428
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Note
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/cJs8y](https://packt.link/cJs8y).
  id: totrans-430
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/cJs8y](https://packt.link/cJs8y)找到这个练习使用的代码。
- en: 'In this exercise, you used the two concepts learned in the last two sections:
    arrays and for loops. You manipulated arrays, accessing their values through indexes,
    and used for loops to move through these indexes.'
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你使用了在上一节学到的两个概念：数组和for循环。你操作数组，通过索引访问它们的值，并使用for循环遍历这些索引。
- en: There is another way to go through every element of an array or `foreach` statements.
    You will explore this in the following section.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 有另一种方法可以遍历数组或`foreach`语句的每个元素。你将在下一节中探索这一点。
- en: foreach Statements
  id: totrans-433
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: foreach语句
- en: 'A `foreach` statement executes a set of instructions for each element of a
    collection. Just like a `for` loop, the `break`, `continue`, `goto`, and `return`
    keywords can also be used with `foreach` statements. Consider the following example,
    in which you iterate over every element of an array and write it to the console
    as the output:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: '`foreach`语句为集合中的每个元素执行一组指令。就像`for`循环一样，`break`、`continue`、`goto`和`return`关键字也可以与`foreach`语句一起使用。考虑以下示例，其中你遍历数组的每个元素并将其写入控制台作为输出：'
- en: '[PRE101]'
  id: totrans-435
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: The preceding snippet prints the numbers from `1` to `5` to the console. You
    can use `foreach` statements with much more than arrays; they can also be used
    with lists, collections, and spans, which are other data structures that will
    be covered in later chapters.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段将数字从`1`到`5`打印到控制台。你可以使用`foreach`语句与比数组更多的东西一起使用；它们还可以与列表、集合和span一起使用，这些是将在后续章节中介绍的其他数据结构。
- en: File Handling
  id: totrans-437
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 文件处理
- en: So far, you have been creating programs that interact mostly with CPU and memory.
    This section will focus on I/O operations, that is, input and output operations,
    on the physical disk. A great example of this type of operation is file handling.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你一直在创建主要与CPU和内存交互的程序。本节将重点介绍I/O操作，即物理磁盘上的输入和输出操作。文件处理是这类操作的一个很好的例子。
- en: 'C# has several classes that help you perform I/O operations. Some of these
    are as follows:'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: C#有几个类可以帮助你执行I/O操作。其中一些如下：
- en: '`File`: This class provides methods for the manipulation of files, that is,
    reading, writing, creating, deleting, copying, and moving files on the disk.'
  id: totrans-440
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`File`：这个类提供了对文件进行操作的方法，即读取、写入、创建、删除、复制和移动磁盘上的文件。'
- en: '`Directory`: Like the `File` class, this class includes methods to create,
    move, and enumerate directories and subdirectories on the disk.'
  id: totrans-441
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Directory`：与`File`类类似，这个类包括创建、移动和枚举磁盘上的目录和子目录的方法。'
- en: '`Path`: This provides utilities to deal with absolute and relative paths of
    files and directories on the disk. A relative path is always related to some path
    inside the current directory where the application is being executed, and an absolute
    path refers to an absolute location inside the hard drive.'
  id: totrans-442
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Path`：提供处理磁盘上文件和目录的绝对路径和相对路径的实用工具。相对路径始终与当前应用程序执行的当前目录内的某个路径相关联，而绝对路径则指向硬盘内的一个绝对位置。'
- en: '`DriveInfo`: This provides information about a disk drive, such as `Name`,
    `DriveType`, `VolumeLabel`, and `DriveFormat`.'
  id: totrans-443
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DriveInfo`：提供有关磁盘驱动器的信息，例如`Name`、`DriveType`、`VolumeLabel`和`DriveFormat`。'
- en: 'You already know that files are mostly some sets of data located somewhere
    in a hard drive that can be opened for reading or writing by some program. When
    you open a file in a C# application, your program reads the file as a sequence
    of bytes through a communication channel. This communication channel is called
    a stream. Streams can be of two types:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道文件主要是一些数据集合，它们位于硬盘的某个位置，可以通过某些程序打开进行读取或写入。当你在一个C#应用程序中打开一个文件时，你的程序通过一个通信通道将文件作为一系列字节读取。这个通信通道被称为流。流有两种类型：
- en: The input streams are used for reading operations.
  id: totrans-445
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输入流用于读取操作。
- en: The output streams are used for writing operations.
  id: totrans-446
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 输出流用于写入操作。
- en: 'The `Stream` class is an abstract class in C# that enables common operations
    regarding this byte flow. For file handling on a hard disk, you will use the `FileStream`
    class, designed specifically for this purpose. The following are two important
    properties of this class: `FileAccess` and `FileMode`.'
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`Stream`类是C#中的一个抽象类，它使你可以执行与这种字节流相关的常见操作。对于硬盘上的文件处理，你将使用专门为此目的设计的`FileStream`类。以下是这个类两个重要的属性：`FileAccess`和`FileMode`。'
- en: FileAccess
  id: totrans-448
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FileAccess
- en: 'This is an `enum` that provides you with options to choose a level of access
    when opening a specified file:'
  id: totrans-449
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个`enum`，它为你提供了在打开指定文件时选择访问级别选项：
- en: '`Read`: This opens a file in read-only mode.'
  id: totrans-450
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Read`：以只读模式打开文件。'
- en: '`ReadWrite`: This opens a file in read and write mode.'
  id: totrans-451
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ReadWrite`：以读写模式打开文件。'
- en: '`Write`: This opens a file in write-only mode. This is rarely used, as you
    usually do some reading along with the writing.'
  id: totrans-452
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Write`：以只写模式打开文件。这很少使用，因为你通常会在写入的同时进行一些读取。'
- en: FileMode
  id: totrans-453
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: FileMode
- en: 'This is an `enum` that specifies the operations that can be performed on a
    file. It should be used along with the access mode as some modes only work with
    some levels of access. Take a look at the options, as follows:'
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个 `enum`，指定可以在文件上执行的操作。它应与访问模式一起使用，因为某些模式仅与某些访问级别一起工作。查看以下选项：
- en: '`Append`: Use this when you want to add content at the end of the file. If
    the file does not exist, a new one will be created. For this operation, the file
    must have write permission; otherwise, any attempt to read fails and throws a
    `NotSupportedException` exception. Exceptions are an important concept that will
    be covered later in this chapter.'
  id: totrans-455
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`追加`：当你想在文件末尾添加内容时使用此选项。如果文件不存在，则会创建一个新文件。对于此操作，文件必须具有写入权限；否则，任何尝试读取都会失败并抛出
    `NotSupportedException` 异常。异常是一个重要的概念，将在本章后面进行介绍。'
- en: '`Create`: Use this to create a new file or overwrite an existing one. For this
    option, too, write permission is required. In Windows, if the file exists but
    is hidden, an `UnauthorizedAccessException` exception is thrown.'
  id: totrans-456
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`创建`：使用此选项来创建新文件或覆盖现有文件。对于此选项，也需要写入权限。在 Windows 中，如果文件存在但被隐藏，则会抛出 `UnauthorizedAccessException`
    异常。'
- en: '`CreateNew`: This is like `Create` but is used to create new files and also
    requires write permission. However, if the file already exists, an `IOException`
    exception is thrown.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CreateNew`：这与 `Create` 类似，但用于创建新文件，并且也需要写入权限。然而，如果文件已存在，则会抛出 `IOException`
    异常。'
- en: '`Open`: As the name suggests, this mode is used to open a file. The file must
    have read or read and write permissions. If the file does not exist, a `FileNotFoundException`
    exception is thrown.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`打开`：正如其名所示，此模式用于打开文件。文件必须具有读取或读取和写入权限。如果文件不存在，则会抛出 `FileNotFoundException`
    异常。'
- en: '`OpenOrCreate`: This is like `Open`, except it creates a new file if it does
    not already exist.'
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OpenOrCreate`：这与 `Open` 类似，但如果文件不存在，则会创建一个新文件。'
- en: 'Exercise 1.11: Reading Content from Text Files'
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.11：从文本文件中读取内容
- en: In this exercise, you will read text from a Comma-Separated Values (CSV) file.
    CSV files simply contain data represented by strings and separated either by colons
    or semicolons.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 在此练习中，你将从一个逗号分隔值 (CSV) 文件中读取文本。CSV 文件仅包含由字符串表示的数据，并且由冒号或分号分隔。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: 'Open Command Prompt and type the following:'
  id: totrans-463
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开命令提示符并输入以下内容：
- en: '[PRE102]'
  id: totrans-464
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'At the `Exercise1_11` project folder location in your computer, create a file
    named `products.csv` and paste the following content inside it:'
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的计算机中 `Exercise1_11` 项目文件夹位置，创建一个名为 `products.csv` 的文件，并将以下内容粘贴到其中：
- en: '[PRE103]'
  id: totrans-466
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Open the `Program.cs` file and replace its contents with the following:'
  id: totrans-467
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Program.cs` 文件，并用以下内容替换其内容：
- en: '[PRE104]'
  id: totrans-468
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: Call `dotnet run` in Command Prompt and you will get an output that is the same
    as the contents of the CSV file you have created.
  id: totrans-469
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在命令提示符中调用 `dotnet run`，你将得到一个输出，其内容与您创建的 CSV 文件内容相同。
- en: Note
  id: totrans-470
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/5flid](https://packt.link/5flid).
  id: totrans-471
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/5flid](https://packt.link/5flid) 找到用于此练习的代码。
- en: This exercise has some pretty interesting outcomes, which you are going to learn
    step by step. First, you opened a file using the `FileStream` class. This allows
    you to start streaming bytes from a file with two special properties, namely,
    `FileMode` and `FileAccess`. It will return a `StreamReader` class. This class
    enables you to read these bytes as text characters.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 此练习有一些相当有趣的结果，你将逐步了解。首先，你使用 `FileStream` 类打开了一个文件。这允许你从文件开始流式传输字节，具有两个特殊属性，即
    `FileMode` 和 `FileAccess`。它将返回一个 `StreamReader` 类。此类使你能够将这些字节作为文本字符读取。
- en: Notice also that your `Main` method changed from `void` to `async` Task. Additionally,
    the `await` keyword has been used, which is used for asynchronous operations.
    You will learn more about these topics in upcoming chapters. For now, you only
    need to know that an async operation is something that does not block the program
    execution. This means that you can output lines as they are being read; that is,
    you do not have to wait for all of them to be read.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你的 `Main` 方法已从 `void` 更改为 `async` Task。此外，已使用 `await` 关键字，该关键字用于异步操作。你将在接下来的章节中了解更多关于这些主题的内容。现在，你只需要知道异步操作是那些不会阻塞程序执行的操作。这意味着你可以在读取时输出行；也就是说，你不需要等待它们全部被读取。
- en: In the next section, learn about the special keyword that handles files, databases,
    and network connections.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，你将了解处理文件、数据库和网络连接的特殊关键字。
- en: Disposable Objects
  id: totrans-475
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可丢弃对象
- en: Another special thing about the preceding exercise was the `using` keyword.
    It is a keyword used to clean up unmanaged resources from memory. These resources
    are special objects that handle some operational system resources, such as files,
    databases, and network connections. They are called **special** because they do
    what is called I/O operations; that is, they interact with the real resources
    of the machine, such as network and hard drives, not just with memory spaces.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 前一个练习中还有一个特殊之处，那就是 `using` 关键字。这是一个用于从内存中清理未管理资源的关键字。这些资源是特殊对象，它们处理一些操作系统资源，例如文件、数据库和网络连接。它们被称为
    **特殊**，因为它们执行所谓的 I/O 操作；也就是说，它们与机器的真实资源（如网络和硬盘）交互，而不仅仅是与内存空间。
- en: The memory used by objects in C# is handled by something called the garbage
    collector. By default, C# handles the memory space in the stack and the heap. The
    only types of objects that do not perform this cleanup are called unmanaged objects.
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: C# 中对象使用的内存由称为垃圾回收器的东西来处理。默认情况下，C# 处理堆栈和堆内存空间。唯一不执行此清理的对象类型称为未管理对象。
- en: Cleaning these objects from memory means that the resources will be free to
    be used by another process in the computer. That means a file can be handled by
    another one, a database connection is free to be used again by a connection pool,
    and so on. Those types of resources are called disposable resources. Every time
    you deal with a disposable resource, you can use the `using` keyword when creating
    an object. Then, the compiler knows that when the `using` statement closes, it
    can automatically free these resources.
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 从内存中清理这些对象意味着资源将可供计算机中的另一个进程使用。这意味着文件可以被另一个进程处理，数据库连接可以再次由连接池使用，等等。这些类型的资源被称为可处置资源。每次你处理可处置资源时，在创建对象时都可以使用
    `using` 关键字。然后，编译器知道当 `using` 语句关闭时，它可以自动释放这些资源。
- en: 'Exercise 1.12: Writing to a Text File'
  id: totrans-479
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 1.12：向文本文件写入
- en: In this exercise, you will write some text into a CSV file, again using the
    `FileStream` class.
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用 `FileStream` 类将一些文本写入 CSV 文件。
- en: 'Follow these steps to complete this exercise:'
  id: totrans-481
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤完成此练习：
- en: 'Open the VS Code integrated terminal and type the following:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 VS Code 集成终端并输入以下内容：
- en: '[PRE105]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: At a preferred location on your computer, copy the `products.csv` file from
    the previous exercise and paste it into this exercise's folder.
  id: totrans-484
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的计算机上的一个合适位置，将上一个练习中的 `products.csv` 文件复制并粘贴到这个练习的文件夹中。
- en: 'In `Program.cs`, create a method named `ReadFile` that will receive a `FileStream`
    file and iterate over the file lines to output the result to the console:'
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中创建一个名为 `ReadFile` 的方法，该方法将接收一个 `FileStream` 文件并遍历文件行，将结果输出到控制台：
- en: '[PRE106]'
  id: totrans-486
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Now, in your program, open the `products.csv` file with `StreamWriter` and
    add some more information to it, as follows:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在你的程序中，使用 `StreamWriter` 打开 `products.csv` 文件，并向其中添加更多信息，如下所示：
- en: '[PRE107]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Finally, read the contents of the file after modification:'
  id: totrans-489
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，修改文件后读取文件内容：
- en: '[PRE108]'
  id: totrans-490
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: 'Call `dotnet run --project Exercise1_12` in the VS Code integrated terminal
    and you will be able to see the contents of the CSV file you just created, in
    addition to the line you just appended:'
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 VS Code 集成终端中调用 `dotnet run --project Exercise1_12`，你将能够看到你刚刚创建的 CSV 文件的内容，以及你刚刚追加的行：
- en: '[PRE109]'
  id: totrans-492
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: Note that for each run, the program will append a new line, so you will see
    more lines being added.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，对于每次运行，程序将追加一行，所以你会看到更多行被添加。
- en: Note
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/dUk2z](https://packt.link/dUk2z).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/dUk2z](https://packt.link/dUk2z) 找到用于此练习的代码。
- en: Sometimes your program will fail to execute at some point and may not provide
    an output. Such an instance is called an exception error. The next section details
    all about such an error.
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 有时你的程序可能在某个点失败并无法提供输出。这种情况被称为异常错误。下一节将详细介绍此类错误。
- en: Exceptions
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 异常
- en: 'Exceptions indicate that a program has failed to execute at some point for
    some reason and can be raised by either the code itself or the .NET runtime. Usually,
    an exception is a severe failure and can even terminate your program''s execution.
    Fortunately, C# provides a special way of handling exceptions, which is `try/catch` blocks:'
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 异常表示程序在某些原因下未能执行，可能由代码本身或.NET运行时引发。通常，异常是一个严重的失败，甚至可能终止程序的执行。幸运的是，C# 提供了一种特殊的方式来处理异常，即
    `try/catch` 块：
- en: '[PRE110]'
  id: totrans-499
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Inside the `try` clause, you call the code that might throw an exception, and
    inside the `catch` clause, you can treat the exception that was raised. For instance,
    consider the following example:'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try`块中，你调用可能会抛出异常的代码，而在`catch`块中，你可以处理所抛出的异常。例如，考虑以下示例：
- en: '[PRE111]'
  id: totrans-501
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: This method takes two integers and returns the result of a division between
    them. However, what will happen if `b` is `0`? In such a case, the runtime will
    throw `System.DivideByZeroException`, indicating that it is not possible to execute
    the division. How could you handle this exception in a real-world program? You
    will explore this in the next exercise.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法接受两个整数并返回它们之间的除法结果。然而，如果`b`是`0`会发生什么？在这种情况下，运行时会抛出`System.DivideByZeroException`，表示无法执行除法。你如何在现实世界的程序中处理这个异常？你将在下一个练习中探索这个问题。
- en: 'Exercise 1.13: Handling Invalid User Inputs with try/catch'
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习1.13：使用try/catch处理无效用户输入
- en: In this exercise, you will create a console app that takes two inputs from you,
    divides the first number by the second one, and outputs the result. If you enter
    an invalid character, the app should throw an exception, and all of this should
    be handled inside the program logic.
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将创建一个控制台应用程序，该程序从你那里接收两个输入，将第一个数字除以第二个数字，并输出结果。如果你输入了无效字符，应用程序应该抛出异常，并且所有这些都应该在程序逻辑中处理。
- en: 'Perform the following steps to complete this exercise:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以完成此练习：
- en: Inside the VS Code integrated terminal, create a new console app called `Exercise1_13`.
  id: totrans-506
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在VS Code集成终端中，创建一个名为`Exercise1_13`的新控制台应用程序。
- en: 'Create the following method inside the `Program.cs` file:'
  id: totrans-507
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`文件中创建以下方法：
- en: '[PRE112]'
  id: totrans-508
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Now, create a Boolean variable to indicate whether the division was properly
    executed. Assign `false` to it as its initial value:'
  id: totrans-509
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个布尔变量来指示除法是否正确执行。将其初始值设置为`false`：
- en: '[PRE113]'
  id: totrans-510
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: 'Write a `while` loop that will check whether the division happened successfully.
    If it did, the program should terminate. If not, the program should prompt you
    to input valid data and perform the division again. Add the following code to
    do this:'
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编写一个`while`循环，检查除法是否成功执行。如果成功了，程序应该终止。如果没有，程序应该提示你输入有效数据并再次执行除法。添加以下代码来完成此操作：
- en: '[PRE114]'
  id: totrans-512
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Finally, execute the program using the `dotnet run` command and interact with
    the console. Try to insert strings instead of numbers and see what output you
    get. Look at the following output as an example:'
  id: totrans-513
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用`dotnet run`命令执行程序并与控制台交互。尝试插入字符串而不是数字，看看你会得到什么输出。以下是一个示例输出：
- en: '[PRE115]'
  id: totrans-514
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Note
  id: totrans-515
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/EVsrJ](https://packt.link/EVsrJ).
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/EVsrJ](https://packt.link/EVsrJ)找到用于此练习的代码。
- en: 'In this exercise, you handled two types of exceptions that are as follows:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你处理了两种类型的异常，如下所示：
- en: The `int.Parse(string str)` method throws `System.FormatException` if it is
    not possible to convert the `string` variable into an integer.
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当无法将`string`变量转换为整数时，`int.Parse(string str)`方法会抛出`System.FormatException`异常。
- en: The `double Divide(int a, int b)` method throws `System.DivideByZeroException`
    if b is 0.
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当`double Divide(int a, int b)`方法中的`b`为0时，会抛出`System.DivideByZeroException`异常。
- en: 'Now that you have seen how exceptions are handled, it is important to note
    a rule of thumb that will help you in your C# journey, which is that *you should
    only catch what you can or what you need to handle*. There are only a few situations
    where exception handling is really needed, as follows:'
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经看到了如何处理异常，重要的是要注意一个经验法则，这将有助于你在C#的学习之旅中，那就是*你应该只捕获你可以处理或需要处理的异常*。只有在少数情况下，异常处理才是真正必要的，如下所示：
- en: When you want to **mask** an exception, that is, catch it and pretend that nothing
    happened. This is known as exception suppression. That should take place when
    the exception that is thrown does not impact the flow of your program.
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想**抑制**异常，即捕获它并假装什么都没发生时。这被称为异常抑制。这应该在抛出的异常不会影响程序流程时发生。
- en: When you want to control your program's execution flow to perform some alternate
    actions, as you did in the preceding exercise
  id: totrans-522
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想控制程序的执行流程以执行一些替代操作时，就像在前面的练习中所做的那样
- en: When you want to catch a type of exception to throw it as another type. For
    instance, when communicating with your web API, you might see an exception of
    type `HttpException` that indicates that the destination is unreachable. You could
    make use of a custom exception here, such as `IntegrationException`, to indicate
    more clearly that it happened in a part of your application that performs some
    integrations with external APIs.
  id: totrans-523
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当你想捕获一种异常并将其抛出为另一种类型时。例如，在与你的 Web API 通信时，你可能会看到类型为 `HttpException` 的异常，这表明目标不可达。你可以在这种情况下使用自定义异常，例如
    `IntegrationException`，以更清楚地表明它发生在你的应用程序的某个部分，该部分执行了一些与外部 API 的集成操作。
- en: 'The `throw` keyword can also be used to intentionally stop the program execution
    flow in certain cases. For example, consider that you are creating a `Person`
    object and that the `Name` property should not be `null` at the time of creation.
    You can enforce on this class a `System.ArgumentException` or `System.ArgumentNullException`,
    as in the following snippet, which uses `ArgumentNullException` to do so:'
  id: totrans-524
  prefs: []
  type: TYPE_NORMAL
  zh: '`throw` 关键字也可以用于在特定情况下故意停止程序执行流程。例如，考虑你正在创建一个 `Person` 对象，并且 `Name` 属性在创建时不应为
    `null`。你可以在这个类上强制执行 `System.ArgumentException` 或 `System.ArgumentNullException`，如下面的代码片段所示，它使用
    `ArgumentNullException` 来执行此操作：'
- en: '[PRE116]'
  id: totrans-525
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: Here, if the value of the `name` argument is `null` or if you only enter space
    characters, `ArgumentNullException` is thrown, and the program does not execute
    successfully. The null/white space condition is checked with the help of the `IsNullOrWhiteSpace`
    function, which can be used for string variables.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，如果 `name` 参数的值为 `null` 或如果你只输入空格字符，则会抛出 `ArgumentNullException` 异常，程序无法成功执行。null/空格条件是通过
    `IsNullOrWhiteSpace` 函数检查的，该函数可用于字符串变量。
- en: Now it's time to practice all that you learned in the previous sections through
    an activity.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 现在是时候通过一个活动来练习你在前面的部分中学到的所有内容了。
- en: 'Activity 1.01: Creating a Guessing Game'
  id: totrans-528
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动 1.01：创建一个猜数字游戏
- en: To complete this activity, you need to create a guessing game using the concepts you
    have learned about and practiced so far in this chapter. In this game, first,
    a random number from one to 10 must be generated, not to be output to the console.
    The console should then prompt the user to input a number and then guess which
    random number has been generated, and the user should get a maximum of five chances.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个活动，你需要使用在本章中学习并实践过的概念来创建一个猜数字游戏。在这个游戏中，首先，必须生成一个1到10之间的随机数，但不能输出到控制台。然后，控制台应提示用户输入一个数字并猜测哪个随机数已被生成，用户最多有五次机会。
- en: Upon every incorrect input, a warning message should be displayed, letting the
    user know how many chances they have left, and if all five chances are exhausted
    with incorrect guesses, the program terminates. However, once the user guesses
    correctly, a success message should be displayed, before the program terminates.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 每次输入错误时，应显示一个警告消息，让用户知道他们还剩下多少次机会，如果所有五次机会都因猜测错误而耗尽，则程序终止。然而，一旦用户猜对了，在程序终止之前应显示一个成功消息。
- en: 'The following steps will help you complete this activity:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 以下步骤将帮助你完成这个活动：
- en: 'Create a variable called `numberToBeGuessed` that is assigned to a random number
    within C#. You can use the following snippet to do so:'
  id: totrans-532
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `numberToBeGuessed` 的变量，将其分配给 C# 中的随机数。你可以使用以下代码片段来完成此操作：
- en: '[PRE117]'
  id: totrans-533
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE117]'
- en: This generates a random number for you, between `0` and `10`. You could replace
    `10` with a higher number if you wanted to make the game a little more difficult,
    or with a smaller number to make it easier, but for this activity, you will use
    `10` as the maximum value.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 这会为你生成一个介于 `0` 和 `10` 之间的随机数。如果你想使游戏稍微困难一些，可以将 `10` 替换为一个更大的数字，或者为了使游戏更容易，可以替换为一个更小的数字，但在这个活动中，你将使用
    `10` 作为最大值。
- en: Create a variable called `remainingChances` that will store the remaining number
    of chances that the user has.
  id: totrans-535
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `remainingChances` 的变量，用于存储用户剩余的机会数。
- en: Create a `numberFound` variable and assign a `false` value to it.
  id: totrans-536
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `numberFound` 的变量，并将其分配一个 `false` 值。
- en: Now, create a `while` loop that will execute while there are still some chances
    remaining. Within this loop, add code to output the number of chances remaining,
    until the correct guess is made. Then, create a variable called `number` that
    will receive the `number` variable is the correct guess, and assign the value
    `true` to the `numberFound` variable if so. If not, the number of remaining chances
    should be reduced by `1`.
  id: totrans-537
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建一个`while`循环，该循环将在仍有机会的情况下执行。在这个循环中，添加代码以输出剩余的机会数量，直到猜出正确的数字。然后，创建一个名为`number`的变量，它将接收`number`变量，如果猜对了，将`true`值分配给`numberFound`变量。如果没有猜对，剩余的机会数量应该减少`1`。
- en: Finally, add code to inform users whether they have guessed the number correctly.
    You can output something such as `Congrats! You've guessed the number with {remainingChanges}
    chances left!` if they guessed correctly. If they ran out of chances, output `You're
    out of chances. The number was {numberToBeGuessed}.`.
  id: totrans-538
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加代码来通知用户他们是否正确猜出了数字。如果他们猜对了，你可以输出类似于`恭喜！你用{remainingChanges}次机会猜对了数字！`的信息。如果他们用完了机会，输出`你用完了机会。数字是{numberToBeGuessed}。`。
- en: Note
  id: totrans-539
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-540
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 本活动的解决方案可以在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: Summary
  id: totrans-541
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter gave you an overview of the fundamentals of C# and what it looks
    like to write programs with it. You explored everything from the variable declaration,
    data types, and basic arithmetic and logical operators to file and exception handling.
    You also explored how C# allocates memory while dealing with value and reference
    types.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 本章为你概述了C#的基础知识以及如何用它来编写程序。你探索了从变量声明、数据类型、基本算术和逻辑运算符到文件和异常处理的各个方面。你还了解了C#在处理值和引用类型时如何分配内存。
- en: In the exercises and activities in this chapter, you were able to solve some
    real-world problems and think of solutions that can be implemented with this language
    and its resources. You learned how to prompt for user inputs in console apps,
    how to handle files within a system, and finally, how to deal with unexpected
    inputs through exception handling.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的练习和活动中，你能够解决一些现实世界的问题，并思考出可以用这种语言及其资源实现解决方案。你学习了如何在控制台应用程序中提示用户输入，如何处理系统中的文件，以及最后如何通过异常处理来处理意外的输入。
- en: The next chapter will cover the essentials of Object-oriented programming, diving
    deeper into the concept of classes and objects. You will also learn about the
    importance of writing clean, concise code that is easy to maintain, and the principles you
    can follow for writing such code.
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将涵盖面向对象编程的精华，深入探讨类和对象的概念。你还将了解编写易于维护的简洁代码的重要性，以及你可以遵循的原则来编写这样的代码。
