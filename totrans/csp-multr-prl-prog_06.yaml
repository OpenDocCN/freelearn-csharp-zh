- en: Chapter 6. Task-based Parallelism
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章。基于任务的并行性
- en: In this chapter we will cover the **Task Parallel Library** (**TPL**) and the
    details of using the `Task` class to write concurrent code.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍**任务并行库**（**TPL**）以及使用`Task`类编写并发代码的细节。
- en: In [Chapter 5](ch05.html "Chapter 5. Lightweight Concurrency – Task Parallel
    Library (TPL)"), *Lightweight Concurrency – Task Parallel Library (TPL)*, we started
    our exploration of lightweight concurrency and .NET's new most preferred way to
    accomplish multithreaded programming—the TPL. In this chapter, we will explore
    task-based parallelism further and show how to wait on tasks or multiple tasks,
    custom scheduling of a task, error handling, and canceling a task.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章。轻量级并发 – 任务并行库 (TPL)")中，*轻量级并发 – 任务并行库 (TPL)*，我们开始了对轻量级并发和.NET中完成多线程编程的新首选方式——TPL的探索。在本章中，我们将进一步探讨基于任务并行性，并展示如何等待任务或多个任务，自定义任务的调度，错误处理以及取消任务。
- en: The TPL gives us an easy way to schedule, run, and coordinate tasks at a higher
    level of abstraction than working directly with threads. As mentioned earlier,
    a task is a set of instructions to carry out an objective, a unit of work if you
    wish. We can define a task in a method called by a delegate or in a lambda expression
    defined directly in the task-creation command.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: TPL为我们提供了一个简单的方法来在比直接与线程工作更高的抽象级别上调度、运行和协调任务。如前所述，任务是一组执行目标的指令，如果你愿意，是一个工作单元。我们可以在由委托调用的方法中定义任务，或者在任务创建命令中直接定义的lambda表达式中定义任务。
- en: When running more than one task concurrently, there will be times when we need
    to wait on one or more tasks to complete before performing a function, or be able
    to cancel one or more tasks if a certain condition arises, or coordinate exception
    handling if one or more tasks throws an error when running in parallel. We will
    discuss all of these scenarios in this chapter and work through examples. By the
    end of this chapter, you will be very comfortable with all the aspects of using
    tasks in parallel in your applications.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 当同时运行多个任务时，有时我们需要在执行函数之前等待一个或多个任务完成，或者在某些条件出现时能够取消一个或多个任务，或者在并行运行时一个或多个任务抛出错误时协调异常处理。我们将在本章中讨论所有这些场景，并通过示例进行操作。到本章结束时，你将对在应用程序中并行使用任务的所有方面感到非常熟悉。
- en: 'In this chapter, you will learn how to:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何：
- en: Wait on a particular task when multiple tasks are running concurrently
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当多个任务同时运行时，等待特定任务
- en: Wait on all or many tasks that are running concurrently
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待所有或多个并发运行的任务
- en: Cancel one or more tasks when certain conditions occur
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在特定条件发生时取消一个或多个任务
- en: Handle exceptions thrown by one or more tasks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理一个或多个任务抛出的异常
- en: Fully coordinate the execution and completion of concurrently running tasks
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全协调并发运行的任务的执行和完成
- en: Waiting for a task to complete
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待任务完成
- en: The first thing we need to do when we execute a task is to know when it has
    completed, and if it returns results, what the results are. Let's see a simple
    example by creating a task, waiting for it to complete, and then checking the
    results.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 执行任务时，我们首先需要知道它何时完成，以及如果它返回结果，结果是什么。让我们通过创建一个任务、等待其完成并检查结果来查看一个简单的示例。
- en: We will do this using a task that doesn't return a result and one that does,
    and see the difference between `Task` and `Task<TResult>`. When a task returns
    a result value, the wait is implicit, and when it doesn't, we need to explicitly
    wait for it.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过一个不返回结果的任务和一个返回结果的任务来完成这项工作，并观察`Task`和`Task<TResult>`之间的区别。当一个任务返回结果值时，等待是隐式的，而当它不返回时，我们需要显式地等待它。
- en: How to do it
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'First, let''s open up Visual Studio and create a new console application called
    `WaitonTask`. Once we have the new project created, we will add the following
    code to the `Program.cs` file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开Visual Studio并创建一个名为`WaitonTask`的新控制台应用程序。一旦我们创建了新项目，我们将在`Program.cs`文件中添加以下代码：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: As you can see from this code, we are creating a task to run for 10 seconds
    and we will wait on the task to finish. This task calls a method named `Worker`
    and is instantiated using a `Task.Factory` and a lambda expression. The task does
    not return a value.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们正在创建一个运行10秒的任务，并将等待该任务完成。此任务调用名为`Worker`的方法，并使用`Task.Factory`和lambda表达式实例化。该任务不返回值。
- en: 'Now, let''s compile and run our new application. The following is an example
    of the output you should see:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编译并运行我们的新应用程序。以下是你应该看到的输出示例：
- en: '![How to do it](img/8321EN_06_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_06_01.jpg)'
- en: As you can see, we first start a task with the `Worker` method and wait on it
    to complete and then we start a task with the `Worker` method and perform a wait
    with a time-out value. Did you notice a difference between the two executions?
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们首先使用`Worker`方法启动一个任务并等待它完成，然后我们再次使用`Worker`方法启动一个任务并执行带有超时值的等待。你注意到两次执行之间的区别了吗？
- en: The first time we run the task, we will wait the full 10 seconds for the task
    to complete. The second time we run the task, we set a timeout and continue on
    before the task completes. Since the task runs for longer than 2 seconds, the
    wait command times out and the program moves on, while the task is still running.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次运行任务时，我们将等待完整的10秒钟直到任务完成。第二次运行任务时，我们设置了一个超时值并在任务完成之前继续执行。由于任务运行时间超过2秒，等待命令超时，程序继续执行，而任务仍在运行。
- en: 'In both of these examples, we have a task that does not return a value. Now,
    let''s change our worker task to return a value and see what happens. Let''s add
    a new method to our program called `Worker1`. Add the following code to the `Worker1`
    method:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个例子中，我们都有一个不返回值的任务。现在，让我们将我们的工作任务改为返回一个值，看看会发生什么。让我们向程序中添加一个新的方法，称为`Worker1`。将以下代码添加到`Worker1`方法中：
- en: '[PRE1]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, in the `Main` method of the `Program.cs` file, add the following two lines
    of code towards the end right before the `Console.ReadLine` command:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在`Program.cs`文件的`Main`方法中，在`Console.ReadLine`命令之前，添加以下两行代码：
- en: '[PRE2]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Now, let''s compile and run our program again. The following is the output
    that you should see when you run the program:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次编译并运行我们的程序。以下是你运行程序时应看到的输出：
- en: '![How to do it](img/8321EN_06_02.jpg)'
  id: totrans-27
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_06_02.jpg)'
- en: Did you notice that the program ran and waited for `TaskC` to complete? Shortly,
    we will get to the `SpinWait` method of the `Thread` class, but for now, why did
    the program wait on `TaskC` to finish running when we did not put a wait command
    in the code for it?
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 你注意到程序运行并等待`TaskC`完成了吗？我们很快就会了解到`Thread`类的`SpinWait`方法，但现在，为什么程序在代码中没有放置等待命令的情况下等待`TaskC`完成？
- en: How it works
  id: totrans-29
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: In the previous exercise, we saw three ways to wait for a task to complete.
    The first two examples used the `Task.Wait` method to tell our program to wait
    on the task. Since the task is running on a different thread, we have to wait
    for it to complete before we continue the execution of the program in our main
    thread. In these two examples, our task does not return a value. In this case,
    we need to explicitly wait on the task to complete if we do not want our main
    thread to continue after starting the task (or at least scheduling it in the threadpool).
    We do this using the `Task.Wait` method in the `Task` class.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，我们看到了等待任务完成的三个方法。前两个例子使用了`Task.Wait`方法来告诉我们的程序等待任务。由于任务是在不同的线程上运行的，我们必须等待它完成，然后才能继续在主线程中执行程序的执行。在这两个例子中，我们的任务不返回任何值。在这种情况下，如果我们不希望主线程在启动任务（或至少在线程池中安排它）后继续执行，我们需要显式地等待任务完成。我们使用`Task`类中的`Task.Wait`方法来完成这个操作。
- en: The first time, we told our program to wait on the task to complete and then
    move on. The second time, we set a timeout value in the `Wait` method. This tells
    our main thread to wait for the amount of time in the timeout parameter and then
    move on. Then we checked the `Task.IsComplete` property to see whether our task
    has completed or not.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 第一次，我们告诉程序等待任务完成并继续执行。第二次，我们在`Wait`方法中设置了一个超时值。这告诉主线程等待超时参数中的时间，然后继续执行。然后我们检查`Task.IsComplete`属性，以查看任务是否已完成。
- en: 'Since the task was set to run for longer than the timeout value, the task was
    still running when our main thread continued execution. That is why the `IsComplete`
    property is `false` and the `else` portion of our `if` statement gets executed:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 由于任务被设置为运行时间超过超时值，当我们的主线程继续执行时，任务仍在运行。这就是为什么`IsComplete`属性是`false`，以及我们的`if`语句的`else`部分被执行的原因：
- en: '[PRE3]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: You can play around with this code and make the task run for less time than
    the timeout value and see what happens.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以尝试修改这段代码，让任务运行的时间少于超时值，看看会发生什么。
- en: Next, we ran a task using the `Worker1` method that returns a `double` value.
    What did we see here? We did not place a `Task.Wait` command but our main program
    still waited on the task to complete before continuing on with its execution.
    Why is that?
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用返回`double`值的`Worker1`方法运行了一个任务。我们在这里看到了什么？我们没有放置`Task.Wait`命令，但我们的主程序仍然在任务完成之前等待，然后继续执行。为什么是这样？
- en: We know it waited until the task was completed because when we wrote the `Task.Result`
    value to the console, it had a value and was not `null`. In this case, we do not
    need to use the `Task.Wait` method explicitly because the main thread will wait
    on the task to complete; it needs to wait until the `Task.Result` property is
    set. By defining a task with a return value, we are telling our main thread implicitly
    to wait on the task to complete.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们知道它等待直到任务完成，因为当我们将`Task.Result`值写入控制台时，它有一个值并且不是`null`。在这种情况下，我们不需要显式使用`Task.Wait`方法，因为主线程将等待任务完成；它需要等待直到`Task.Result`属性被设置。通过定义一个带有返回值的任务，我们是在隐式地告诉我们的主线程等待任务完成。
- en: So, as we have seen, if we do not return a value in our task, then we need to
    explicitly tell our program to wait. However, if we return a value, we are implicitly
    telling our program to wait on the task to complete.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如我们所看到的，如果我们不在任务中返回值，那么我们需要明确告诉我们的程序等待。然而，如果我们返回一个值，我们就是隐式地告诉我们的程序等待任务完成。
- en: Next, we will see how to control the execution of our main thread when we start
    many concurrent tasks at once. In this case, if our tasks return values, we might
    not implicitly want to wait on every task to complete. Maybe we just want to wait
    on one task to complete.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到如何在我们同时启动多个并发任务时控制主线程的执行。在这种情况下，如果我们的任务返回值，我们可能不希望隐式地等待每个任务完成。也许我们只想等待一个任务完成。
- en: In our current program, we used the `Thread.SpinWait` method. This method is
    different from the `Thread.Sleep` method. The `Thread.Sleep` method waits for
    a specified time whereas the `SpinWait` method starts a loop for the specified
    iterations passed to the method. So, in this case, the speed of the processor
    will dictate the duration because the clock speed will determine how fast it can
    complete the number of iterations. By using this instead of a `Sleep` method,
    it also allows the scheduler to perform context switching if thread priorities
    dictate.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们当前的程序中，我们使用了`Thread.SpinWait`方法。这种方法与`Thread.Sleep`方法不同。`Thread.Sleep`方法等待指定的时间，而`SpinWait`方法则开始一个循环，循环次数由传递给方法的指定迭代次数决定。因此，在这种情况下，处理器的速度将决定持续时间，因为时钟速度将决定它完成迭代次数的速度。通过使用这种方法而不是`Sleep`方法，它还允许调度器在线程优先级指示的情况下执行上下文切换。
- en: Waiting for multiple tasks to complete
  id: totrans-40
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 等待多个任务完成
- en: In the previous section, we examined how to explicitly and implicitly wait on
    a task to complete. Now, let's see how we can control execution and waiting when
    we start many tasks instead of just one.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们探讨了如何显式和隐式地等待任务完成。现在，让我们看看当我们启动多个任务而不是一个任务时，我们如何控制执行和等待。
- en: Sometimes, we may want to wait on one task out of a group to finish. Sometimes,
    we might want to wait on all of the tasks to finish, and other times we might
    want to wait on a certain condition of tasks to finish before proceeding.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能只想等待一组任务中的一个任务完成。有时，我们可能想等待所有任务完成，有时我们可能想等待任务满足某个条件后才能继续。
- en: 'The following screenshot shows all of the `Wait` and `When` methods provided
    with the `Task` class. The `Wait` methods are as shown:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了与`Task`类一起提供的所有`Wait`和`When`方法。`Wait`方法如下所示：
- en: '![Waiting for multiple tasks to complete](img/8321EN_06_03.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![等待多个任务完成](img/8321EN_06_03.jpg)'
- en: 'The `When` methods are as shown:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`When`方法如下所示：'
- en: '![Waiting for multiple tasks to complete](img/8321EN_06_04.jpg)'
  id: totrans-46
  prefs: []
  type: TYPE_IMG
  zh: '![等待多个任务完成](img/8321EN_06_04.jpg)'
- en: Both images are references from [http://msdn.microsoft.com/en-us/library/system.threading.tasks.task_methods(v=vs.110).aspx](http://msdn.microsoft.com/en-us/library/system.threading.tasks.task_methods(v=vs.110).aspx).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个图像都是来自[http://msdn.microsoft.com/en-us/library/system.threading.tasks.task_methods(v=vs.110).aspx](http://msdn.microsoft.com/en-us/library/system.threading.tasks.task_methods(v=vs.110).aspx)的引用。
- en: We will demonstrate how to perform different `Wait` and `When` techniques in
    this chapter, but this is to give you further ideas on what is possible.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章中演示如何执行不同的`Wait`和`When`技术，但这只是为了给你更多关于可能性的想法。
- en: Let's start by creating a simple program to demonstrate how the `WaitAll` method
    works by populating three circles with random numbers once three tasks complete.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建一个简单的程序开始，通过在三个任务完成时用随机数字填充三个圆圈来演示`WaitAll`方法的工作原理。
- en: How to do it
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'To get started, we need to create a WPF application using Visual Studio. Open
    Visual Studio and create a new WPF project called `RandomCircles`. Once we have
    created this project, proceed by performing the following steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始，我们需要使用Visual Studio创建一个WPF应用程序。打开Visual Studio，创建一个名为`RandomCircles`的新WPF项目。一旦我们创建了此项目，就按照以下步骤进行操作：
- en: 'Go into the design mode in Visual Studio and add the following controls to
    the `MainWindow.xaml` file:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入Visual Studio的设计模式，并将以下控件添加到`MainWindow.xaml`文件中：
- en: Add three Ellipse controls and name them `Circle1`, `Circle2`, and `Circle3`.
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加三个椭圆控件，并分别命名为`Circle1`、`Circle2`和`Circle3`。
- en: Set their height and width properties to `120` for all three circles. This is
    done in the `MainWindow.xaml` file using the **Design** mode in Visual Studio.
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将三个圆的高度和宽度属性都设置为`120`。这是在Visual Studio的**设计**模式下在`MainWindow.xaml`文件中完成的。
- en: Next, add three textboxes and place them inside the circles. Name them `text1`,
    `text2`, and `text3`. Set the `Text` property on all three to an empty string
    and make their `Background` property the same color as the `Fill` property on
    the Ellipse controls.
  id: totrans-55
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，添加三个文本框，并将它们放置在圆内。分别命名为`text1`、`text2`和`text3`。将所有三个的`Text`属性设置为空字符串，并使它们的`Background`属性与椭圆控件的`Fill`属性颜色相同。
- en: Next, add a button control and name it `btnRandomAll`. Set the `Content` property
    on this control to `Random All`.
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接下来，添加一个按钮控件，并命名为`btnRandomAll`。将此控件上的`Content`属性设置为`Random All`。
- en: 'Now, your `MainWindow.xaml` file should look like the following screenshot:'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，您的`MainWindow.xaml`文件应该看起来像以下截图：
- en: '![How to do it](img/8321EN_06_05.jpg)'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_06_05.jpg)'
- en: Next, let's go to the `MainWindow.xaml.cs` code behind this file. We need to
    add a `using` statement for the `Threading` namespace.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们转到这个文件的代码后部`MainWindow.xaml.cs`。我们需要为`Threading`命名空间添加一个`using`语句。
- en: '[PRE4]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `System.Threading.Tasks` namespace should already be included when you created
    the WPF project, but check to make sure whether it is there.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当您创建WPF项目时，`System.Threading.Tasks`命名空间应该已经包含在内，但请检查它是否真的在那里。
- en: 'Now, let''s add a worker method to provide work for the tasks to perform, which
    we are about to create. Create a `Worker1` method that is `private` and returns
    a string value. Add the following code to it:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加一个工作方法来为即将创建的任务提供工作。创建一个名为`Worker1`的`private`方法，它返回一个字符串值。向其中添加以下代码：
- en: '[PRE5]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Note
  id: totrans-65
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '`SpinWait` is used here to demonstrate how processor speed can affect the speed
    of a function. `SpinWait` is very inefficient and does consume CPU resources more
    than `Sleep()`.'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`SpinWait`在这里用来演示处理器速度如何影响函数的速度。`SpinWait`非常低效，并且确实比`Sleep()`消耗更多的CPU资源。'
- en: 'Next, let''s create an event handler for `btnRandomAll`—a click event called
    `btnRandomAll_Click`. Inside this method, add the following code:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们为`btnRandomAll`创建一个事件处理程序——一个名为`btnRandomAll_Click`的点击事件。在这个方法内部，添加以下代码：
- en: '[PRE6]'
  id: totrans-68
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: That should be all you need to have a program that runs three tasks in separate
    threads. Each of these tasks will spin for a random time. The main thread will
    wait on all of these tasks to complete and then return a string that has the random
    number used by the task and the current time in milliseconds.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该就是您需要的，以便有一个可以在单独的线程中运行三个任务的程序。每个任务都会随机运行一段时间。主线程将等待所有这些任务完成，然后返回一个字符串，其中包含任务使用的随机数和当前时间的毫秒数。
- en: 'Finally, let''s compile and run our new program. The following is what random
    circles should look like when it is first started:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们编译并运行我们的新程序。以下是在程序首次启动时随机圆应该看起来像的样子：
- en: '![How to do it](img/8321EN_06_06.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_06_06.jpg)'
- en: 'Now, click on the **Random All** button once and see what the output looks
    like. The following is what we got when we ran it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击一次**随机全部**按钮，看看输出结果是什么样子。以下是我们运行它时得到的结果：
- en: '![How to do it](img/8321EN_06_07.jpg)'
  id: totrans-73
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_06_07.jpg)'
- en: 'Now, click on the **Random All** button a second time and see what the program
    looks like. The following screenshot is what we got:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，再次点击**随机全部**按钮，看看程序看起来像什么。以下截图是我们得到的结果：
- en: '![How to do it](img/8321EN_06_08.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_06_08.jpg)'
- en: 'Now, let''s make some changes to our program and try running it again. Make
    the following changes:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对我们的程序做一些修改并再次尝试运行它。进行以下修改：
- en: Add a new Ellipse control and name it `Circle4`.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的椭圆控件，并命名为`Circle4`。
- en: Add a new textbox control and name it `text4` and set the `Text` property to
    an empty string.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个新的文本框控件，命名为`text4`，并将`Text`属性设置为空字符串。
- en: Add another button control and name it `btnRandomFirst` and set the `Content`
    property to `RandomFirst`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加另一个按钮控件，命名为`btnRandomFirst`，并将`Content`属性设置为`RandomFirst`。
- en: 'Add an event handler to the button, `btnRandomFirst`, and name it `btnRandomFirst_Click`.
    Add the following code to the event handler:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为按钮添加一个事件处理器，命名为`btnRandomFirst_Click`，并添加以下代码到事件处理器中：
- en: '[PRE7]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, let''s compile and run our program. The following is the output before
    an action is taken:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编译并运行我们的程序。以下是在采取行动之前的输出：
- en: '![How to do it](img/8321EN_06_09.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![如何做](img/8321EN_06_09.jpg)'
- en: 'Now, click on the **Random First** button once and the output should look like
    the following screenshot:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击一次**随机第一个**按钮，输出应该看起来像下面的截图：
- en: '![How to do it](img/8321EN_06_10.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![如何做](img/8321EN_06_10.jpg)'
- en: 'Finally, let''s click on the **Random First** button a second time and look
    at the results. They should look like the following screenshot:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们再次点击**随机第一个**按钮，看看结果。它们应该看起来像下面的截图：
- en: '![How to do it](img/8321EN_06_11.jpg)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![如何做](img/8321EN_06_11.jpg)'
- en: How it works
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Let's take a minute to go through what we just did with this program.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟回顾一下我们刚才用这个程序做了什么。
- en: First, our `Worker1` method that performs our *tasks* is a simple worker bee.
    It generates a random number and then does a `Thread.SpinWait` for that number
    of iterations. Then it returns the current time in milliseconds. So, every time
    this method is run as a task in a separate thread, it will run for a random amount
    of time. If multiple copies of this method are running in different threads, then
    they will each finish at a different time because `SpinWait` will run for a different
    randomly generated number of iterations.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们的`Worker1`方法执行我们的*任务*是一个简单的工蜂。它生成一个随机数，然后对该数进行`Thread.SpinWait`迭代。然后它返回当前时间的毫秒数。所以每次这个方法作为一个任务在单独的线程中运行时，它将运行一个随机的时间。如果这个方法在不同线程中运行多个副本，那么它们将各自在不同的时间完成，因为`SpinWait`将运行一个不同随机生成的迭代次数。
- en: 'When you click on the **Random All** button, the event handler is fired. The
    event handler starts three separate tasks each running the `Worker1` method using
    the following command:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你点击**随机全部**按钮时，事件处理器被触发。事件处理器开始运行三个单独的任务，每个任务都运行`Worker1`方法，使用以下命令：
- en: '[PRE8]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We created a `Task` array with a string value `TResult` using this command:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用以下命令创建了一个带有字符串值`TResult`的`Task`数组：
- en: '[PRE9]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, we wait on all of the tasks in the tasks array using this command:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用以下命令等待任务数组中的所有任务：
- en: '[PRE10]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Then, we display the results of each task and see that they each have a different
    random number and finish at a different time even though each task is executing
    the same method.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们显示每个任务的结果，并看到它们各自有不同的随机数，完成时间也不同，尽管每个任务都在执行相同的方法。
- en: 'Next, we created a second button that does much of the same work except for
    this time instead of the `Task.WaitAll` command, we use this command:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们创建了一个第二个按钮，它执行的工作与第一个按钮类似，但这次我们使用的是以下命令而不是`Task.WaitAll`命令：
- en: '[PRE11]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: So, in this case, we only wait for any of the three tasks to complete before
    continuing execution in our main thread. You can verify this by clicking on the
    **Random First** button many times. Each time it can be either task 0, 1, or 2
    that finishes first.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在这种情况下，我们只等待三个任务中的任何一个完成，然后才在主线程中继续执行。你可以通过多次点击**随机第一个**按钮来验证这一点。每次可能是任务0、1或2先完成。
- en: Take some time to play with these two commands and make sure you have a full
    understanding of how each works.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 花一些时间来玩这两个命令，确保你完全理解它们是如何工作的。
- en: We will not spend time on this book playing with the `Continue`, `ContinueAll`,
    `When`, and `WhenAll` methods of the `Task` class, but take some time to experiment
    with these functionalities. These methods allow you to execute a task when other
    tasks have completed. So, you can chain task executions together. The alternative
    to these is to wait on tasks to complete and then start new tasks. The `Continue`
    and `When` methods allow you to combine this into one statement.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这本书中，我们将不会花时间来玩`Task`类的`Continue`、`ContinueAll`、`When`和`WhenAll`方法，但花一些时间来实验这些功能。这些方法允许你在其他任务完成时执行任务。因此，你可以将任务执行串联起来。这些方法的替代方案是在任务完成后再启动新任务。`Continue`和`When`方法允许你将它们合并为一个语句。
- en: In the next section, we will explore canceling tasks. Depending on your requirements,
    you might want to cancel a task that you have started, before it ends.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨取消任务。根据你的需求，你可能想在任务结束之前取消你已经开始的任务。
- en: Canceling a task
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消任务
- en: Let's explore canceling a task. Now that we know how to start one or more tasks
    and how to coordinate waiting on one or more of these tasks, what if something
    happens after we have started a group of tasks and we need to stop them?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探讨如何取消任务。既然我们已经知道如何启动一个或多个任务以及如何协调等待一个或多个这些任务，那么在我们启动了一组任务之后，如果发生了一些事情需要我们停止它们怎么办？
- en: Task cancellation is accomplished in the .NET framework by using **cancellation
    tokens**. The delegate used when running a task needs to have code to support
    cancelation and then any other code that needs to cancel a task can request cancelation
    of the task.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在.NET框架中，通过使用**取消令牌**来实现任务取消。在运行任务时使用的委托需要包含支持取消的代码，然后任何需要取消任务的其他代码可以请求取消任务。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The `CancellationToken` structure in .NET manages notification that an operation
    should be canceled. It has a property, `IsCancellationRequested`, that you can
    use to see if a cancellation request has been issued. This structure is a member
    of the `System.Threading` namespace and is used by threads and tasks to manage
    cancellation requests in a multithreaded environment.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的`CancellationToken`结构管理通知操作应该被取消。它有一个属性`IsCancellationRequested`，您可以使用它来查看是否已发出取消请求。此结构是`System.Threading`命名空间的一个成员，并由线程和任务在多线程环境中用于管理取消请求。
- en: Merely requesting to cancel a task will not cancel the task. The task delegate
    must support cancellation tokens. There are two ways that a delegate can choose
    to cancel. The delegate can simply return from execution, or it can throw an `OperationCanceledException`
    using the `ThrowIfCancellationRequested` method.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 仅请求取消任务并不会取消任务。任务委托必须支持取消令牌。委托可以选择取消的两种方式。委托可以简单地从执行中返回，或者可以使用`ThrowIfCancellationRequested`方法抛出`OperationCanceledException`。
- en: 'There are two main differences to these two methods of cancelation. If the
    delegate just returns from execution, then the following happens:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种取消方法有两个主要区别。如果委托只是从执行中返回，那么会发生以下情况：
- en: The task is put in a state of `TaskStatus.RanToCompletion` instead of `TaskStatus.Canceled`.
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务被置于`TaskStatus.RanToCompletion`状态而不是`TaskStatus.Canceled`。
- en: The code requesting to cancel the task does not know if the task simply finished
    or was canceled before finishing.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求取消任务的代码不知道任务是否在完成之前被取消。
- en: 'If the task delegate implements the latter method for canceling (throwing an
    `OperationCanceledException`), then the following happens:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 如果任务委托实现了取消的后者方法（抛出`OperationCanceledException`），那么会发生以下情况：
- en: The task is put in a state of `TaskStatus.Canceled`.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 任务被置于`TaskStatus.Canceled`状态。
- en: The requesting code can check this status and determine if the task was canceled
    or just finished.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请求代码可以检查此状态并确定任务是被取消还是只是完成了。
- en: So, now we will create a WPF application to allow the user to cancel tasks.
    We will demonstrate how to create cancellation tokens, monitor the task state
    to see if it is canceled, and then do some processing when it is canceled. This
    will also use the `Task.ContinueWith` method. This method allows us to execute
    a task when another task has completed.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们将创建一个WPF应用程序，允许用户取消任务。我们将演示如何创建取消令牌，监控任务状态以查看是否已取消，然后在取消时进行一些处理。这也会使用`Task.ContinueWith`方法。此方法允许我们在另一个任务完成后执行任务。
- en: In our application, we will start 10 tasks. Each task will take an integer parameter
    as input and will multiply it by the numbers from 1 to 10 million and take a sum
    of the results. It will then return a `double` value that is the result. While
    this may not be the world's most exciting computation, it will take a little time
    depending on your processor speed.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的应用程序中，我们将启动10个任务。每个任务将接受一个整数参数作为输入，并将该参数乘以从1到1000万的数字，然后取结果的和。然后它将返回一个`double`类型的值，即结果。虽然这可能不是世界上最令人兴奋的计算，但它将根据您的处理器速度花费一些时间。
- en: We will start each task with a task cancelation token pass to it and create
    `ContinueWith` tasks for it. One will *continue with* if the task runs to completion,
    and the other will *continue with* if the task is canceled. We will also have
    a **Cancel** button that allows you to cancel at any time and stop the tasks in
    progress.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用任务取消令牌启动每个任务，并为它创建`ContinueWith`任务。一个将在任务运行到完成时继续执行，另一个将在任务被取消时继续执行。我们还将有一个**取消**按钮，允许您随时取消并停止正在进行的任务。
- en: Let's get started.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: How to do it
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: Open up Visual Studio and create a new WPF application called `TaskCancel`.
    In the designer window in the `MainWindow.xaml` file, let's add the following
    items.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并创建一个新的 WPF 应用程序，命名为 `TaskCancel`。在 `MainWindow.xaml` 文件的 designer
    窗口中，让我们添加以下项。
- en: 'Add two button controls: one named `btnStart` and other named `btnCancel`.'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加两个按钮控件：一个命名为 `btnStart`，另一个命名为 `btnCancel`。
- en: 'Next, add a click event handler for each button: `btnStart_Click` and `btnCancel_Click`
    respectively.'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为每个按钮添加一个点击事件处理程序：分别为 `btnStart_Click` 和 `btnCancel_Click`。
- en: Add a text block control named `textBlock1`.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个名为 `textBlock1` 的文本块控件。
- en: 'Your `MainWindow.xaml` file should look like the following screenshot:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你的 `MainWindow.xaml` 文件应该看起来像下面的截图：
- en: '![How to do it](img/8321EN_06_12.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_06_12.jpg)'
- en: 'Now, move to the `MainWindow.xaml.cs` code behind the file. Let''s add the
    following items:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到 `MainWindow.xaml.cs` 文件的后端代码。让我们添加以下项：
- en: 'Add a `using` statement for the `System.Threading` namespace:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `System.Threading` 命名空间添加一个 `using` 语句：
- en: '[PRE12]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Then, inside the class definition at the top, let''s add our cancelation token:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在顶部类定义中，让我们添加我们的取消令牌：
- en: '[PRE13]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next, let''s add a method that will execute inside our 10 tasks. We will call
    this method `AddMultiple`. It takes an integer parameter and returns a value that
    is the datatype `double`. Add the following code to it:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个将在我们 10 个任务中执行的方法。我们将称这个方法为 `AddMultiple`。它接受一个整数参数，并返回一个 `double`
    类型的值。向其中添加以下代码：
- en: '[PRE14]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Then, let''s add the code to the click event handler of `btnStart` that will
    start the 10 tasks:'
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们将代码添加到 `btnStart` 的点击事件处理程序中，该处理程序将启动 10 个任务：
- en: '[PRE15]'
  id: totrans-135
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, let''s add the code to the click event handler of `btnCancel`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们将代码添加到 `btnCancel` 的点击事件处理程序中：
- en: '[PRE16]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: That is all we have to do. Now, let's compile and run our application. But this
    time, let's not run it through Visual Studio. We will run the application directly.
    Go to the `bin\Release` folder in our project directory and double-click on the
    `TaskCancel.exe` application. We will explain shortly why we are doing this and
    what happens when we run it in Visual Studio.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是我们必须要做的。现在，让我们编译并运行我们的应用程序。但这次，我们不要通过 Visual Studio 运行它。我们将直接运行应用程序。转到项目目录中的
    `bin\Release` 文件夹，双击 `TaskCancel.exe` 应用程序。我们将简要解释为什么这样做，以及我们在 Visual Studio 中运行它时会发生什么。
- en: 'When you run the application, it should look like the following screenshot:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 当你运行应用程序时，它应该看起来像下面的截图：
- en: '![How to do it](img/8321EN_06_13.jpg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_06_13.jpg)'
- en: 'Now, click on the **Start** button. Then click on the **Cancel** button. You
    can decide how fast to click on the **Cancel** button but you should see an output
    like the following screenshot:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，点击 **开始** 按钮。然后点击 **取消** 按钮。你可以决定以多快的速度点击 **取消** 按钮，但你应该看到以下截图中的输出：
- en: '![How to do it](img/8321EN_06_14.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_06_14.jpg)'
- en: If you try running it in Visual Studio directly, you will notice that when you
    click on the **Cancel** button, an unhandled exception occurs. You can press *F5*
    a couple of times and it will continue on. But why does this happen?
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试直接在 Visual Studio 中运行它，你会注意到当你点击 **取消** 按钮时，会发生一个未处理的异常。你可以按几次 *F5*，它将继续运行。但为什么会发生这种情况？
- en: The `ThrowIfCancellationRequested` method has *cooperative cancellation*. This
    throws an exception to indicate that it has accepted the cancellation requested
    and will stop. This exception is handled by .NET in the TPL and shouldn't be handled
    by your code. Since Visual Studio looks for all unhandled exceptions and shows
    them in debug mode, you will see it when running the application in debug mode
    through Visual Studio. There is a way to turn this off through the **Options-Debugging**
    settings under **Tools**, but we do not recommend it because it can mask other
    exceptions that you want to see. Nevertheless, the exception we encounter here
    is a nuisance when debugging.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ThrowIfCancellationRequested` 方法具有 **协作取消**。这会抛出一个异常，表示它已接受取消请求并将停止。这个异常由
    .NET 中的 TPL 处理，不应该由你的代码处理。由于 Visual Studio 会寻找所有未处理的异常，并在调试模式下显示它们，所以当你通过 Visual
    Studio 调试模式运行应用程序时，你会看到它。有一种方法可以通过在 **工具** 下的 **选项-调试** 设置中关闭它，但我们不建议这样做，因为它可能会掩盖你想要看到的其他异常。尽管如此，我们在调试中遇到的这个异常是一个麻烦。 '
- en: How it works
  id: totrans-145
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: Now that we've successfully canceled running tasks, let's see how we did it.
    First, we defined a cancellation token using `CancellationTokenSourcets`. Then
    we instantiated it using `ts = new CancellationTokenSource()`. This gives us a
    cancellation token that we can work with.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功取消了正在运行的任务，让我们看看我们是如何做到的。首先，我们使用`CancellationTokenSource`定义了一个取消令牌。然后我们使用`ts
    = new CancellationTokenSource()`实例化它。这给我们提供了一个我们可以与之工作的取消令牌。
- en: Let's skip, briefly, to the end. To cancel tasks, we just call the token's `Cancel`
    method, `ts.Cancel()`, in the **Cancel** button's click event handler. This will
    indicate to any task, which is using this cancelation token, that they need to
    cancel. Now it is up to the tasks to monitor the token and perform the cancelation.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要地跳到结尾。要取消任务，我们只需在**取消**按钮的点击事件处理程序中调用令牌的`Cancel`方法，即`ts.Cancel()`。这将向任何使用此取消令牌的任务指示它们需要取消。现在，任务需要监控令牌并执行取消操作。
- en: 'So, let''s take a look at the **Start** button''s click method. Here, we create
    and start 10 tasks using the following code:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们看看**开始**按钮的点击方法。在这里，我们使用以下代码创建并启动了10个任务：
- en: '[PRE17]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, we call the `Task.Factory.StartNew` command and pass it the delegate for
    the task to execute and the cancellation token.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们调用`Task.Factory.StartNew`命令，并传递给任务执行和取消令牌的委托。
- en: 'Then, we also call the `ContinueWith` command to tell the task what to do after
    it finishes. We set up two of these depending on how the task finishes:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们也调用`ContinueWith`命令来告诉任务在完成后要做什么。我们根据任务如何完成设置两个这样的命令：
- en: '[PRE18]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: For the first one, we pass the parameter, `TaskContinuationOptions.OnlyOnCanceled`,
    and for the second one, we pass the parameter, `TaskContinuationOptions.OnlyOnRanToCompletion`.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 对于第一个，我们传递参数`TaskContinuationOptions.OnlyOnCanceled`，对于第二个，我们传递参数`TaskContinuationOptions.OnlyOnRanToCompletion`。
- en: So, if the task is canceled, the second `ContinueWith` command is executed and,
    if the task runs to completion, the first `ContinueWith` command is executed.
    In each of these `ContinueWith` commands, we pass a lambda expression to execute,
    which prints the results of the task. This is how we update the UI with the status
    of each task, once it has completed.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果任务被取消，第二个`ContinueWith`命令将被执行，如果任务运行到完成，第一个`ContinueWith`命令将被执行。在这些`ContinueWith`命令中的每一个，我们传递一个要执行的lambda表达式，它打印出任务的输出。这就是我们如何更新每个任务完成后的UI状态。
- en: From the output you can see which tasks run to completion and which tasks are
    canceled. Also, note that the output is not in sequential order. Since the 10
    tasks are scheduled with the threadpool and the different cores on the machine
    we run have different workloads, the tasks finish in different orders.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 从输出中你可以看到哪些任务运行到完成，哪些任务被取消。此外，请注意输出不是按顺序排列的。由于10个任务是由线程池和机器上不同的核心以及不同的工作负载来计划的，因此任务完成的顺序不同。
- en: Next, we will take a look at error handling with tasks.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将查看任务中的错误处理。
- en: Task exception handling
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务异常处理
- en: Well, we have learned how to start, coordinate, and cancel tasks. Now, let's
    talk about error handling with tasks. In C#, when we discuss error handling, we
    are really talking about the `try..catch..finally` structure. In this book, we
    assume you are familiar with the operation of a `try..catch` block.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，我们已经学习了如何开始、协调和取消任务。现在，让我们来谈谈任务中的错误处理。在C#中，当我们讨论错误处理时，我们实际上是在谈论`try..catch..finally`结构。在这本书中，我们假设你已经熟悉`try..catch`块的操作。
- en: A task has a lifecycle of states that it can be in. A task can be idle (scheduled),
    running, pending, cancelled, faulted, or completed. Each task has a `status` property
    that defines the current state of the task. We saw this in the last section and
    used `OnlyOnCanceled` and `OnlyOnRanToCompletion` as the options for `TaskContinuationOptions`
    for our `ContinueWith` methods.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 任务有一个可以处于的状态生命周期。任务可以是空闲（已计划）、正在运行、挂起、已取消、有故障或已完成。每个任务都有一个`status`属性，它定义了任务当前的状态。我们在上一节中看到了这一点，并使用`OnlyOnCanceled`和`OnlyOnRanToCompletion`作为`TaskContinuationOptions`的选项来为我们的`ContinueWith`方法。
- en: So, when we talk about exception handling with TPL, we are referring to faulted
    tasks. There are several ways a task can reach a faulted status, for example,
    when the task delegate fails and throws an exception. A **faulted task** is basically
    a task that resulted in an error and carries the exception with it.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们谈论使用TPL进行异常处理时，我们指的是有故障的任务。任务可以通过几种方式达到有故障的状态，例如，当任务委托失败并抛出异常时。一个**有故障的任务**基本上是一个导致错误并携带异常的任务。
- en: 'Your code will incur an exception if you perform one of the following on a
    faulted task:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在故障任务上执行以下操作之一，您的代码将引发异常：
- en: Waiting on a task
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 等待任务
- en: Using the task's result value
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用任务的结果值
- en: Performing an `Await` on the task
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对任务执行`Await`
- en: So, when you use the `Wait`, `WaitAll`, `Await`, or `Result` methods of a task,
    you should surround these statements with a `try..catch` block. The first two
    will always throw an exception of the `AggregateException` type, which is a container
    for multiple exceptions. The `Await` will throw the actual exception occurred
    by the task's delegate.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当您使用任务的`Wait`、`WaitAll`、`Await`或`Result`方法时，应该用`try..catch`块包围这些语句。前两者将始终抛出`AggregateException`类型的异常，它是一个多个异常的容器。`Await`将抛出任务委托实际发生的异常。
- en: These are the basics of task exception handling. We want to do a `try..catch`
    around the `Result`, `Wait`, or `Await` of a task.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是任务异常处理的基本知识。我们希望在任务的`Result`、`Wait`或`Await`周围执行`try..catch`。
- en: 'But what if we start a task and do not care about waiting on it or its results,
    but we want to know if it incurs an exception? How do we know if a start-and-forget
    task has a problem? In this case, we can use a simple technique with the help
    of the `ContinueWith` command. Look at the following command:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果我们启动一个任务，并不关心等待它或其结果，但我们想知道它是否引发了异常？我们如何知道一个启动后忘记的任务是否有问题？在这种情况下，我们可以使用`ContinueWith`命令的简单技术。看看以下命令：
- en: '[PRE19]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: In this case, we create a task to execute on a `ContinueWith` command if the
    task is in an `OnlyOnFaulted` state.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果任务处于`OnlyOnFaulted`状态，我们创建一个任务来在`ContinueWith`命令上执行。
- en: So, you can perform exception handling with a `try..catch` on the result while
    waiting on a task or, if you are not waiting on the task or result, you can create
    a `ContinueWith` task to handle the exception.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以在等待任务时对结果执行`try..catch`异常处理，或者如果您没有等待任务或结果，您可以创建一个`ContinueWith`任务来处理异常。
- en: Summary
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we have looked at ways to wait on a task, cancel, chain, and
    perform exception handling with tasks. We have now covered all of the aspects
    that need to work with tasks in the TPL and the techniques needed to handle all
    of the scenarios your design might encounter.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了等待任务、取消、链式操作以及使用任务执行异常处理的方法。我们现在已经涵盖了所有需要在TPL中与任务一起工作的方面以及处理您的设计可能遇到的所有场景所需的技巧。
- en: We encourage you to further explore the techniques presented in this chapter
    and explore the world of task-based parallelism. The days of working directly
    with threads and the `BackgroundWorker` component will soon become a distant memory.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您进一步探索本章中介绍的技巧，并探索基于任务的并行世界的奥秘。直接与线程和`BackgroundWorker`组件工作的日子很快就会成为遥远的记忆。
- en: These last two chapters have been an overview of TPL and task-based parallelism.
    In the next chapter, we will cover data-based parallelism and working with data
    collections in a concurrent manner.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 最后这两个章节是关于TPL和基于任务的并行概述。在下一章中，我们将介绍基于数据的并行以及以并发方式处理数据集合。
