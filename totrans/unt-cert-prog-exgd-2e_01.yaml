- en: '*Chapter 1*: Setting Up and Structuring Our Project'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第一章*：设置和构建我们的项目'
- en: For some time, Unity has been issuing exams that cover a range of different
    skills for people who are either graduates, self-taught, or are classed as veterans
    in their field.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在一段时间内，Unity一直在发布涵盖不同技能的考试，这些技能适用于毕业生、自学成才者或在其领域中被归类为资深人士的人。
- en: If we check the prerequisites on Unity's website ([https://unity.com/products/unity-certifications/professional-programmer](https://unity.com/products/unity-certifications/professional-programmer)),
    they tell us that this exam isn't for absolute beginners and you need at least
    2 years of experience working with Unity and computer programming, including C#.
    This book will take you through the process of becoming as familiar as possible
    with Unity and its services, to the point where it might feel like a beginners'
    course; however, I expect you to know the fundamentals of C# programming, such
    as what an `if` statement is, what a function does, and what a class represents.
    If you don't, I would recommend reading Harrison Ferrone's *Learning C# by Developing
    Games with Unity 2020* book first ([https://www.packtpub.com/product/learning-c-by-developing-games-with-unity-2020-fifth-edition/9781800207806](https://www.packtpub.com/product/learning-c-by-developing-games-with-unity-2020-fifth-edition/9781800207806)).
    Be aware that this exam is based on Unity 2020 LTS. This is the second edition
    of the Unity Professional Programmer exam. You will gain no real benefit following
    this book installing Unity 2021 and upwards. If anything, you run the risk of
    becoming disconnected from the learning process of this book as the Editor and
    general functionality may differ.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们在Unity网站上检查先决条件（[https://unity.com/products/unity-certifications/professional-programmer](https://unity.com/products/unity-certifications/professional-programmer)），他们会告诉我们，这项考试不是为绝对初学者准备的，你需要至少2年的Unity和计算机编程经验，包括C#。这本书将带你通过熟悉Unity及其服务的过程，直到可能感觉像是一门入门课程；然而，我期望你知道C#编程的基础知识，比如`if`语句是什么，函数的作用，以及类代表什么。如果你不知道，我建议你首先阅读Harrison
    Ferrone的《通过Unity 2020开发游戏学习C#》（[https://www.packtpub.com/product/learning-c-by-developing-games-with-unity-2020-fifth-edition/9781800207806](https://www.packtpub.com/product/learning-c-by-developing-games-with-unity-2020-fifth-edition/9781800207806)）这本书。请注意，这项考试基于Unity
    2020 LTS。这是Unity专业程序员考试的第二个版本。如果你跟随这本书安装Unity 2021及以上版本，你将不会获得任何实际的好处。相反，你可能会因为编辑器和一般功能可能不同而与这本书的学习过程脱节。
- en: As you can imagine, it is sometimes difficult to gauge what level a programmer
    is at with their experience. Imagine what it's like for an employer to recruit
    someone. Often, a programmer is judged by their portfolio, but what happens if
    you're a graduate without one or you lack a large quantity of work because you've
    been too busy studying? Perhaps you've been a programmer for years but can't show
    any recent work due to signing non-disclosure agreements? Some employers might
    look at your CV and not even look at your portfolio as the qualifications just
    don't look impressive enough. The tests a potential employer can put a developer
    through can also be unbalanced, unfair, unrealistic, and not challenging enough;
    it's likely that the employer has grabbed a programmer's questionnaire template
    off the internet to test you.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所想，有时很难评估一个程序员的水平。想象一下雇主招聘员工的情况。通常，程序员会根据他们的作品集来评判，但如果你是一个没有作品集的毕业生，或者因为你忙于学习而缺乏大量工作，会发生什么？也许你已经做了多年的程序员，但由于签署了保密协议，无法展示任何最近的工作？一些雇主可能会查看你的简历，甚至不查看你的作品集，因为资格看起来并不那么令人印象深刻。潜在雇主可以给开发者进行的测试也可能是不平衡的、不公平的、不切实际的，而且挑战性不足；很可能是雇主从互联网上抓取了一个程序员的问卷调查模板来测试你。
- en: However, having qualifications from Unity itself sends a clear message that
    you've been tested and covered all the fields that acknowledge you as a certified
    Unity programmer. Even if you have a decent portfolio showing a level of standardization
    and focus, having qualifications from Unity can give you the edge over someone
    else in a job application.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，从Unity本身获得资格，清楚地表明你已经接受了测试，并覆盖了所有认可你为认证Unity程序员的领域。即使你有一个相当不错的作品集，展示了标准化和专注的水平，拥有Unity的资格也能在求职申请中给你带来优势。
- en: 'This book serves two main purposes:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本书有两个主要目的：
- en: To take you through a fun, simple, side-scrolling shooter project with some
    downloadable art assets and sounds that will cover the core objectives in Unity's
    exam
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带您通过一个有趣、简单、横向卷轴射击项目，该项目包含可下载的艺术资源和声音，将涵盖Unity考试的核心目标
- en: To get you as ready for the exam as possible with regular testing and reviewing
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过定期的测试和复习，尽可能让你为考试做好准备
- en: So, if you feel like you don't need to carry out the project, skip to the very
    end of this book to try out the final mock test—actually, I recommend you do this
    now. Flick to the back of the book, take the test, and if you don't do as well
    as you planned (that is, score over 75%), at least you know you have something
    to learn, and working through the project might help. Don't take the exam too
    soon after taking the mock test if you aren't happy with your score—you will be
    going up against your own muscle memory, rather than the knowledge itself.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果你觉得你不需要执行项目，请跳到本书的最后一部分尝试最终的模拟测试——实际上，我建议你现在就做。翻到书的背面，参加测试，如果你没有达到你计划的成绩（即得分超过
    75%），至少你知道你还有东西要学，完成项目可能会有所帮助。如果你对模拟测试的成绩不满意，不要立即参加考试——你将面对的是自己的肌肉记忆，而不是知识本身。
- en: Unity has split the necessary areas of this exam into six core objectives. We
    will cover what these objectives are in this chapter before introducing our side-scrolling
    shooter project, which will cover the majority of the objectives. We will also
    cover specialized subjects outside of the project, such as networking, VR, and
    more, in the [*Appendix*](B18381_Appendix_Epub.xhtml#_idTextAnchor245) section
    of this book.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 将本考试的必要领域划分为六个核心目标。在本章中，我们将在介绍我们的侧滚动射击项目之前，介绍这些目标是什么，该项目将涵盖大多数目标。我们还将在本书的[*附录*](B18381_Appendix_Epub.xhtml#_idTextAnchor245)部分介绍项目之外的专业主题，例如网络、VR
    等。
- en: Throughout the following chapters, we will refresh ourselves with the general
    practices of coding—a bit like the dos and don'ts when coding a project. Then,
    we will get to grips with the genre of the game and, hopefully, get you thinking
    about how to set up a game framework. Finally, we will download and set up our
    empty project in Unity and learn about Unity services.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将通过编码的一般实践来刷新自己——有点像在项目编码时的“该做和不该做”。然后，我们将了解游戏类型，并希望让你思考如何设置游戏框架。最后，我们将下载并设置我们的空项目在
    Unity 中，并了解 Unity 服务。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: The six core objectives
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 六个核心目标
- en: Overview of design patterns
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计模式的概述
- en: The SOLID principles
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SOLID 原则
- en: Designing the Killer Wave game
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计 Killer Wave 游戏
- en: The Killer Wave game framework
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Killer Wave 游戏框架
- en: Setting up Unity 2020 LTS
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置 Unity 2020 LTS
- en: Setting up your Unity project
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的 Unity 项目
- en: We won't be doing any coding in this chapter as our focus is on what Unity wants
    from you in the exam. We will discuss an overview of the methodology and structuring
    code with design patterns. You may feel tempted to skip some parts because you
    simply aren't interested, but remember the only reason I am mentioning the majority
    of this stuff is it's highly likely to come up in the exam. So, please don't feel
    like I'm punishing you on purpose!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们不会进行任何编码，因为我们的重点是 Unity 在考试中希望从你那里得到的内容。我们将讨论方法论的概述和与设计模式相关的代码结构。你可能想跳过一些部分，因为你根本不感兴趣，但请记住，我之所以提到大多数这些东西，是因为它们很可能在考试中出现。所以，请不要觉得我是故意惩罚你！
- en: The next section will detail the core objectives covered in this chapter.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将详细介绍本章涵盖的核心目标。
- en: The core exam skills covered in this chapter
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 本章涵盖了核心的考试技巧
- en: '*Working in professional software development teams*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '*在专业软件开发团队中工作*：'
- en: Setting up your Unity project
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置你的 Unity 项目
- en: Recognize techniques for structuring scripts for modularity, readability, and
    reusability.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别用于构建模块化、可读性和可重用性的脚本结构技术。
- en: Technical requirements
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Check out the following video to see the *Code in Action*: [https://bit.ly/3klZRqf](https://bit.ly/3klZRqf).'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看*代码的实际应用*：[https://bit.ly/3klZRqf](https://bit.ly/3klZRqf)。
- en: The six core objectives
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 六个核心目标
- en: The exam will mainly focus on scripting and the use of Unity's **Application
    Programming Interface** (**API**), Animation Controller, particles, rendering,
    and more. The whole idea is to get you familiar with what Unity has to offer you
    as a programmer. Unity has categorized their exam into core sections, which is
    a nice way of separating the workload for the exam.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 考试将主要关注脚本编写和 Unity 的 **应用程序编程接口** (**API**)、动画控制器、粒子、渲染等的使用。整个想法是让你熟悉 Unity
    作为程序员所能提供的内容。Unity 将他们的考试划分为核心部分，这是一种很好的方式，可以分离考试的工作量。
- en: 'The six core objectives are as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 六个核心目标如下：
- en: Programming core interactions
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程核心交互
- en: Working in the art pipeline
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在艺术管线中工作
- en: Developing application systems
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开发应用程序系统
- en: Programming for scene and environment design
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编程用于场景和环境设计
- en: Optimizing performance and platforms
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化性能和平台
- en: Working in professional software development teams
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在专业软件开发团队中工作
- en: Let's look at these in more detail.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看这些内容。
- en: Programming core interactions
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编程核心交互
- en: When we load up our first blank scene in Unity, we will be controlling objects
    (or, as Unity likes to call them, **game objects**), moving, rotating, and/or
    expanding them. Not only can you adjust or transform these game objects, but you
    can also give them components to make them behave like a camera, a light, and/or
    a piece of animation, and so on. Each one of these components will typically have
    properties and values. So, for example, a camera component will have properties
    adjusting its field of view, its background color, and a few other camera-related
    things. Another example of a component is Rigidbodies. A Rigidbody component is
    typically used when you want a collision to happen between two game objects. Or
    what would you want the game object to do when it makes contact with another game
    object? Will it blow up? Will it collect the other game object? Will it knock
    it out of the way where one has a greater force? Unity wants you to know how to
    use these components and game objects. They also want you to know how you can
    control these objects with a control pad or keyboard controls as if they are characters
    in a computer game. This may already sound daunting, but you don't need to be
    a math teacher to be successful (but it's great if you are!). What's so brilliant
    about Unity is that it does a lot of the hard work for you. All you need to know
    is what you want and how you want to use it.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在Unity中加载第一个空白场景时，我们将控制对象（或者，正如Unity喜欢称呼的，**游戏对象**），移动、旋转和/或扩展它们。你不仅可以调整或转换这些游戏对象，还可以为它们添加组件，使它们表现得像摄像机、灯光和/或动画片段等。每个组件通常都会有属性和值。例如，摄像机组件将会有调整其视野、背景颜色和其他一些与摄像机相关属性的属性。另一个组件的例子是刚体。刚体组件通常用于当你想要两个游戏对象之间发生碰撞时。或者当游戏对象接触另一个游戏对象时，你希望它做什么？它会爆炸吗？它会收集另一个游戏对象吗？它会将其推出，因为有一个更大的力量？Unity希望你知道如何使用这些组件和游戏对象。他们还希望你知道如何使用控制板或键盘控制来控制这些对象，就像它们是电脑游戏中的角色一样。这听起来可能已经令人畏惧，但你不需要成为数学老师就能成功（但如果你是那就太好了！）。Unity的出色之处在于它为你做了很多艰苦的工作。你所需要知道的只是你想要什么以及你想要如何使用它。
- en: 'To pass the exam, you need to know how to do the following:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过考试，你需要知道以下内容：
- en: Implement and configure game object behavior and physics
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置游戏对象行为和物理
- en: Implement and configure inputs and controls
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置输入和控件
- en: Implement and configure camera views and movement
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现和配置摄像机视图和移动
- en: Let's move on to the second Unity exam core objective—the art.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到第二个Unity考试核心目标——艺术。
- en: Working in the art pipeline
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在艺术管线中工作
- en: As you know, this is a programming exam, so why do we have an exam objective
    that refers to art? Well, as a programmer, it's highly likely that you will be
    manipulating game objects to do the things mentioned in the exam objectives. You
    might not just move something around—you may also want to change a game object's
    color. For example, instead of having a car game object that's dull and flat,
    you may want it to be shiny and reflective with a gold tint. For this to happen,
    a game object typically has a material assigned to it that you can apply maps
    with. These maps can contain colors, marks, and dents.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，这是一场编程考试，那么为什么我们的考试目标中会提到艺术呢？好吧，作为一个程序员，你很可能需要操作游戏对象来完成考试目标中提到的事情。你可能不只是移动某个东西——你可能还想要改变游戏对象的颜色。例如，与其拥有一个单调、平面的汽车游戏对象，你可能会想要它闪闪发光、具有金色色调。为了实现这一点，游戏对象通常会被分配一个材料，你可以应用贴图。这些贴图中可以包含颜色、标记和凹痕。
- en: All these maps and their properties will alter, change, or enhance your game
    object to what is known as a pipeline, which is the process of your game object
    becoming something more than its original form. If you want the game object's
    car wheels to turn around, then how can you do that? You may not have an animator
    to do this. You also may be asked to animate a scene's lighting in the code and
    not manually tweak its properties. You're not expected to be a master at animation
    or lighting, but Unity wants you to know the basics. It might not be the artist's
    job to include snow or rain in your game, and it's likely that you will have to
    use a particle system to create these effects. How will you change its properties
    to change from a light drizzle to a thunderstorm in code? If you don't know, don't
    worry—you will be introduced to these components and their properties soon.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些地图及其属性都将改变、更改或增强你的游戏对象，使其成为所谓的管道，这是你的游戏对象变成比其原始形式更多的事情的过程。如果你想让游戏对象的汽车轮子转动，你该如何做到这一点？你可能没有动画师来做这件事。你也可能被要求在代码中动画化场景的照明，而不是手动调整其属性。你不需要成为动画或照明的专家，但Unity希望你了解基础知识。可能不是艺术家的工作是在你的游戏中包含雪或雨，你很可能会使用粒子系统来创建这些效果。你将如何更改其属性，在代码中将它从轻微的细雨变为雷暴？如果你不知道，不要担心——你很快就会介绍这些组件及其属性。
- en: 'To pass the exam, you also need to know how to do the following:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过考试，你还需要知道如何做以下事情：
- en: Understand materials, textures, and shaders and write scripts that interact
    with Unity's rendering API
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解材质、纹理和着色器，并编写与Unity渲染API交互的脚本
- en: Understand lighting and write scripts that interact with Unity's lighting API
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解照明，并编写与Unity照明API交互的脚本
- en: Understand two-dimensional and three-dimensional animation and write scripts
    that interact with Unity's animation API
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解二维和三维动画，并编写与Unity动画API交互的脚本
- en: Understand particle systems and effects and write scripts that interact with
    Unity's particle system API
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解粒子系统和效果，并编写与Unity粒子系统API交互的脚本
- en: Let's now move on to the third Unity exam core objective, where we focus on
    interfaces, storing data, and being aware of multiplayer functionality.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈第三个Unity考试核心目标，我们将重点关注接口、存储数据和了解多人游戏功能。
- en: Developing application systems
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开发应用程序系统
- en: I wouldn't say that this is a core objective as such; it's more of a cluster
    of things Unity has tied into one bundle and labeled it "core." So, let's break
    this down and work out what they want from us. Developing application systems
    is focused on how Unity communicates with the user and stores their information.
    This is where a **User Interface** (**UI**) needs to contain the right guidance
    and information; but also, from a technical point of view, it needs to be positioned
    correctly no matter what ratio the screen size is. UI can also be used in-game
    in the form of a minimap guiding the player through a maze, showing them where
    enemies are. UI can also be used for advertising and displaying information from
    a different computer server online. When information is taken from the player,
    how sensitive is this information? Should it be stored locally with low security?
    Do we need encryption? Should it be stored in a different file format online?
    Finally, Unity is currently getting rid of their multiplayer network system, called
    UNet, and replacing it with something brand-spanking new. This means we only need
    to be aware of Unity's network and prepare for a few general networking exam questions.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会说这是一个核心目标，这更像是一系列Unity将其捆绑在一起并标记为“核心”的事情。因此，让我们将其分解，弄清楚他们希望我们从哪里得到。开发应用程序系统关注Unity如何与用户通信并存储他们的信息。这就是为什么用户界面（UI）需要包含正确的指导和信息；但从技术角度来看，无论屏幕尺寸比例如何，它都需要正确定位。UI也可以在游戏中以最小图的形式使用，引导玩家通过迷宫，显示敌人位置。UI还可以用于在线广告和显示来自不同计算机服务器的信息。当从玩家那里获取信息时，这些信息有多敏感？是否应该以低安全性存储在本地？我们需要加密吗？是否应该以不同的文件格式存储在网络上？最后，Unity目前正在淘汰他们的多人网络系统，称为UNet，并替换为全新的系统。这意味着我们只需要了解Unity的网络并准备一些通用的网络考试问题。
- en: 'To pass the exam, you need to know how to do the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过考试，你需要知道如何做以下事情：
- en: Interpret scripts for application interface flow such as menu systems, UI navigation,
    and application settings
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释应用界面流程的脚本，例如菜单系统、UI导航和应用设置
- en: Interpret scripts for user-controlled customization, such as character creators,
    inventories, storefronts, and in-app purchases
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解释用户控制的定制脚本，例如角色创建器、库存、店面和在应用内购买
- en: Analyze scripts for user progression features, such as scoring, leveling, and
    in-game economies, by utilizing technologies such as Unity Analytics and PlayerPrefs
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过利用Unity Analytics和PlayerPrefs等技术，分析用户进度功能脚本，例如得分、等级和游戏内经济
- en: Analyze scripts for two-dimensional overlays, such as **Heads-Up Displays**
    (**HUDs**), minimaps, and advertisements
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析二维叠加脚本，例如**抬头显示**（**HUDs**）、小地图和广告
- en: Identify scripts for saving and retrieving application and user data
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别保存和检索应用程序和用户数据的脚本
- en: Recognize and evaluate the impact of networking and multiplayer functionality
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别和评估网络和多玩家功能的影响
- en: Let's move on to the fourth Unity exam core objective, where we'll focus again
    on game objects.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到第四个Unity考试核心目标，我们将再次关注游戏对象。
- en: Programming for the scene and environment design
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 场景和环境设计的编程
- en: This core exam objective sounds similar to the first core objective, where we
    introduced the game object; however, this time we are concentrating more on the
    management of the object. When is a game object made? How is it made? How do we
    get rid of it when we don't need it anymore? Should we destroy it? Or do we label
    it as destroyed but store it elsewhere in the scene to save memory? We can also
    look at few common components, such as the Nav Mesh Agent, which is used typically
    for artificial intelligence, and understand what a game object would do if, for
    example, it's a character that knows when to patrol, chase an enemy, or hide.
    We will also need to know about the audio component and mixer, how we can manipulate
    them, and how to create echo effects. Yet again, we have a situation as with the
    animation and art—we don't need to be amazing at these skills, we just need to
    know that they exist.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这个核心考试目标听起来与第一个核心目标相似，我们在那里介绍了游戏对象；然而，这次我们更专注于对象的管理。游戏对象何时被创建？它是如何被创建的？当我们不再需要它时，我们如何处理它？我们应该销毁它吗？或者我们将其标记为已销毁，但在场景的另一个地方存储以节省内存？我们还可以看看一些常见的组件，例如用于人工智能的Nav
    Mesh Agent，了解如果它是一个知道何时巡逻、追击敌人或隐藏的角色，游戏对象会做什么。我们还需要了解音频组件和混音器，我们如何操作它们，以及如何创建回声效果。再次，我们面临的情况与动画和艺术一样——我们不需要在这些技能上表现出色，我们只需要知道它们存在。
- en: 'To pass the exam, you need to know how to do the following:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过考试，你需要知道以下内容：
- en: Determine scripts for implementing audio assets
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定实现音频资源的脚本
- en: Identify methods for implementing game object instantiation, destruction, and
    management
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别实现游戏对象实例化、销毁和管理的方法
- en: Determine scripts for pathfinding with the Unity navigation system
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定使用Unity导航系统进行路径查找的脚本
- en: Let's move on to the fifth Unity exam core objective, which is about knowing
    what to do when you've broken something and how to check performance issues.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到第五个Unity考试核心目标，这是关于当你破坏了某些东西时该做什么以及如何检查性能问题。
- en: Optimizing performance and platforms
  id: totrans-70
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 优化性能和平台
- en: Any programmer will encounter problems, and it's sometimes helpful to know about
    the problem before you have to solve it. This Unity exam core objective is about
    tracking and fixing your own issues. Sometimes, you will need to step through
    your code to find a game-breaking bug, or you might want to know why a game is
    stuttering at a certain point when it is played. This is where you would use one
    of Unity's handy tools, such as the profiler, to monitor performance. You will
    be able to strip back the components to see whether you're dealing with a physics
    issue or whether your second scene is taking a long time to load, for example.
    Being able to solve your own problems with Unity's tools is the key point of this
    core objective. Other examples of issues that Unity wants you to think about are,
    for example, if you are going to build a virtual reality app, where would the
    UI be placed, if at all? Do you need to be more aware of your frames per second?
    These are the types of questions we will cover in the book.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 任何程序员都会遇到问题，在解决问题之前了解问题有时是有帮助的。这个Unity考试的核心目标是关于跟踪和修复你自己的问题。有时，你需要逐步检查你的代码以找到破坏游戏的bug，或者你可能想知道为什么当游戏在某个特定点播放时会出现卡顿。这就是你将使用Unity的一些实用工具，如分析器，来监控性能的时候。你将能够剥离组件，以确定你是在处理物理问题，还是你的第二个场景加载时间过长，例如。能够使用Unity的工具解决自己的问题是这个核心目标的关键点。Unity希望你考虑的其他问题示例包括，例如，如果你要构建一个虚拟现实应用程序，UI将放在哪里，如果有的话？你是否需要更加关注你的每秒帧数？这些是我们将在书中讨论的问题类型。
- en: 'To pass the exam, you need to know how to do the following:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过考试，你需要了解以下内容：
- en: Evaluate errors and performance issues using tools such as the Unity profiler.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity分析器等工具评估错误和性能问题。
- en: Identify optimizations to address requirements for specific build platforms
    and/or hardware configurations.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 识别针对特定构建平台和/或硬件配置的优化需求。
- en: Determine common UI affordances and optimizations for XR platforms.
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确定XR平台上的常见UI功能和优化。
- en: Let's now move on to your sixth and final Unity exam core objective, working
    with people.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续讨论你的第六个也是最后一个Unity考试核心目标，与人合作。
- en: Working in professional software development teams
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在专业软件开发团队中工作
- en: Working with others in a professional environment and sharing and working with
    each others' code can be tricky if a decent structure isn't in place. Things such
    as version control can help, where each member can "push" their work to Unity's
    server (or the cloud as it's known in general terms) for others to share and work
    from. Some users might work remotely, or you could all work remotely. There are
    different types of version control; the most typical one used is called `git`.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在专业环境中与他人合作，并共享和协作他人的代码可能会很棘手，如果缺乏合理的结构。版本控制等工具可以帮助，其中每个成员都可以将他们的工作“推送”到Unity的服务器（或通常所说的云）上，以便其他人可以共享并从中工作。一些用户可能远程工作，或者你们所有人都可以远程工作。存在不同类型的版本控制；最典型的一个被称为`git`。
- en: 'To pass the exam, you need to know how to do the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过考试，你需要了解以下内容：
- en: Demonstrate knowledge of developer testing and its impact on the software development
    process, including the Unity profiler and traditional debugging and testing techniques
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 展示对开发者测试及其对软件开发过程影响的了解，包括Unity分析器和传统的调试和测试技术
- en: Recognize techniques for structuring scripts for modularity, readability, and
    reusability
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 认识到用于构建模块化、可读性和可重用性的脚本结构技术
- en: That's it! If you know the content of these six objective cores, you will pass.
    This book will cover all of these problems and issues within the project that
    we will be talking about later on in this chapter. How will you know whether you've
    successfully met your objectives? I will be throwing questions at you every few
    chapters to see how you are getting on. If you fail or don't do too well, then
    I see that as a good thing because you'll know exactly what you need to focus
    on and revisit before taking the exam.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！如果你知道这六个核心目标的内容，你将能够通过考试。本书将涵盖我们在本章后面将要讨论的项目中的所有这些问题和挑战。你将如何知道你是否成功地达到了你的目标？我将在每几章中提出问题，看看你的进展如何。如果你失败了或者表现不佳，那么我认为这是一个好事，因为这将让你清楚地知道你需要专注于哪些内容，并在考试前重新审视。
- en: Anyway, this is all to come. Next, I want to talk about design patterns. Given
    that we are coding, it's a good idea to talk about structuring code, following
    decent methods, and not creating code that can get tangled into a mess if there
    isn't enough planning in place.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，这些都将在后续内容中展开。接下来，我想谈谈设计模式。鉴于我们正在编码，讨论代码结构、遵循合理的方法以及在没有足够规划的情况下不会陷入混乱的代码是很合适的。
- en: Overview of design patterns
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计模式概述
- en: At the beginning of this book, I mentioned that I will cover as much of Unity
    as possible, even though it is expected that you have been using Unity for at
    least 2 years before taking the exam. With regard to the fundamentals of programming,
    we will obviously be applying C# code. So, I expect that you are familiar with
    things such as functions, methods, `if` statements, classes, inheritance, polymorphism,
    and so on. I will explain what I'm doing and what you should be doing for each
    bit of code I present, but I won't be going through the basics of each segment
    of code.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的开头，我提到我将尽可能多地涵盖Unity，即使预期你在参加考试之前已经使用了至少2年的Unity。至于编程的基础知识，我们将显然应用C#代码。因此，我期望你对函数、方法、`if`语句、类、继承、多态等事物熟悉。我将解释我在代码中做了什么，以及你应该对每一块代码做什么，但不会讲解代码每个部分的原理。
- en: Design patterns are typical solutions to problems you are likely going to come
    across, and if you have a pattern that can solve a problem, then you should use
    it. Creating applications yourself, with your own workflow is great, but if you
    can explain an issue to another programmer using design pattern terms, it shows
    that you know what you are talking about and if they are a good programmer, they'll
    likely know what you are talking about as well. The more patterns you know, the
    more flexible and standardized your code will be, and you are likely going to
    need more than one pattern. Otherwise, you'll be forcing your code down a structure
    that might not suit it and this will just cause problems.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是解决你可能会遇到的问题的典型解决方案，如果你有一个可以解决问题的模式，那么你应该使用它。自己创建应用程序，使用自己的工作流程是很好的，但如果你能用设计模式的术语向另一位程序员解释一个问题，这表明你知道你在说什么；如果他们是优秀的程序员，他们很可能也明白你在说什么。你了解的模式越多，你的代码就越灵活和标准化，你很可能需要不止一个模式。否则，你可能会强迫你的代码适应一个可能不适合它的结构，这只会造成问题。
- en: 'The batch of 23 design patterns that are considered to be the foundation of
    all patterns was created by **the gang of four**. If you want to check out who
    the gang are and all of their 23 patterns, then go to [https://www.packtpub.com/gb/application-development/hands-design-patterns-c-and-net-core](https://www.packtpub.com/gb/application-development/hands-design-patterns-c-and-net-core).
    All of these patterns are divided into three categories—creational, structural,
    and behavioral:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 被认为是所有模式基础的23个设计模式是由**四人帮**创建的。如果你想了解“四人帮”是谁以及他们的所有23个模式，请访问[https://www.packtpub.com/gb/application-development/hands-design-patterns-c-and-net-core](https://www.packtpub.com/gb/application-development/hands-design-patterns-c-and-net-core)。所有这些模式被分为三类——创建型、结构型和行为型：
- en: '**Creational**: These patterns are designed to deal with the creation of objects—how
    and where an object is made.'
  id: totrans-88
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**创建型**：这些模式旨在处理对象的创建——对象是如何以及在哪里被创建的。'
- en: '**Structural**: These patterns are built to show the relationships between
    entities.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**结构型**：这些模式旨在展示实体之间的关系。'
- en: '**Behavioral**: These patterns are designed to deal with how objects communicate
    with each other.'
  id: totrans-90
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**行为型**：这些模式旨在处理对象之间的通信方式。'
- en: Ideally, after you pass your exam, try and visit more patterns. Get used to
    them as it will help you with your future roles. If you are interested in learning
    more about C# and design patterns, I recommend reading *Hands-On Design Patterns
    with C# and .NET Core* ([https://www.packtpub.com/application-development/hands-design-patterns-c-and-net-core](https://www.packtpub.com/application-development/hands-design-patterns-c-and-net-core)).
    This book isn't based on Unity but on C# .NET core, which means it contains coding
    libraries that overlap with Unity's. Unity contains elements of .NET and the more
    advanced you become as a programmer, the more you will inevitably start dipping
    into .NET. However, that is beyond the scope of this book. Let's return to our
    overview of some of the design patterns that you may be questioned about in the
    exam. The first pattern is **Builder**, so let's check it out.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 理想情况下，在你通过考试后，尽量多地去了解更多的设计模式。习惯它们，因为这将有助于你未来的角色。如果你对学习更多关于 C# 和设计模式感兴趣，我推荐阅读
    *《动手实践 C# 和 .NET Core 设计模式》* ([https://www.packtpub.com/application-development/hands-design-patterns-c-and-net-core](https://www.packtpub.com/application-development/hands-design-patterns-c-and-net-core))。这本书不是基于
    Unity，而是基于 C# .NET core，这意味着它包含了与 Unity 重叠的编码库。Unity 包含了 .NET 的元素，而你作为程序员越高级，不可避免地会开始深入研究
    .NET。然而，这超出了本书的范围。让我们回到我们对可能在考试中问到的一些设计模式的概述。第一个模式是 **Builder**，让我们来看看它。
- en: Builder
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Builder
- en: The first design pattern from the gang of four is the **Builder** design pattern.
    This design is typically used to make alterations to an object. If you can imagine
    a series of specifications to create a custom spaceship, we would (or not) need
    windows, thrusters, wings, lasers, missiles, and whatever else. Putting this down
    in code could easily get too busy and end up with something bad such as a list
    of parameters in a constructor.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 四大设计模式中的第一个是 **Builder** 设计模式。这种设计通常用于对对象进行修改。如果你能想象一系列规格来创建一个定制的飞船，我们可能（或不）需要窗户、推进器、机翼、激光、导弹以及其他任何东西。将这些放入代码中可能会变得过于复杂，最终得到一些糟糕的东西，比如构造函数中的参数列表。
- en: 'The following code is an example of a poorly built spaceship with a bloated
    number of parameters in its instance:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码是一个例子，展示了一个构建得不好的飞船，其实例中包含了许多膨胀的参数：
- en: '[PRE0]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Another nightmare could be a series of subclasses where each possible combination
    is made for each spaceship:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个噩梦可能是一系列子类，其中每个可能的组合都为每个飞船制作：
- en: '[PRE1]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Both of these examples **we don't want to do**. Our code will bloat and in the
    long run, will be more difficult for us or anyone else to maintain.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们都不希望做这两个例子。我们的代码将会膨胀，从长远来看，将对我们或任何其他人来说都更难以维护。
- en: The Builder design pattern will typically hold an interface with all the different
    parts for your spaceship (boosters, weapons, and so on) methods.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: Builder 设计模式通常包含一个接口，其中包含你飞船的所有不同部分（助推器、武器等）的方法。
- en: When it comes to making the ship, we will have a class that will inherit the
    methods from the interface and each method can take values to specify whether
    the ship has missiles or windows, and if so how many of them.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到制作飞船时，我们将有一个类，它将继承接口的方法，每个方法都可以接受值来指定飞船是否有导弹或窗户，以及如果有，有多少个。
- en: 'The following diagram shows how the **Builder** design pattern works:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了 **Builder** 设计模式的工作原理：
- en: '![Figure 1.1 – Builder design pattern'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.1 – 构建者设计模式'
- en: '](img/Figure_1.01_B18381.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.01_B18381.jpg](img/Figure_1.01_B18381.jpg)'
- en: Figure 1.1 – Builder design pattern
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1 – 构建者设计模式
- en: Further Information
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'If you would like to know more about the Builder pattern with regards to its
    code, you can go to the following link and install a demo of the code running
    in Unity:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于 Builder 模式的代码信息，你可以访问以下链接并安装一个在 Unity 中运行的代码演示：
- en: '[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns)'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns)'
- en: Let's now move on to the next design pattern—**Singleton**—where we can have
    a control point from which the majority of your code sends and receives data.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们继续到下一个设计模式——**Singleton**，在这个模式中，我们可以有一个控制点，大多数代码从这个点发送和接收数据。
- en: Singleton
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Singleton
- en: The **Singleton** design pattern isn't really much of a pattern as such, but
    more of a common practice that some programmers love or hate, or both! I'll explain
    why shortly.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 单例（**Singleton**）设计模式实际上并不是一个模式，而更像是一种程序员爱恨交加的常见实践！我很快就会解释原因。
- en: 'The **Singleton** pattern acts as the core location that code will likely come
    from and go to. Our primary thought with **Singleton** is there is only one of
    its kind, for example, one game manager script, one level manager script, one
    audio manager: not multiples of the same instance. These types of scripts will
    exist in your Unity scene and likely will never get removed. If they do get removed
    or don''t exist, then one—and only one—is instantiated. You can use the **Singleton**
    pattern for a manager type of object that overlooks a game, or it could hold what
    level the player is on, how much time is left in the level, what types of enemies
    will be used in this level, and so on. It''s a central common point that the game
    will not want to forget or have multiple versions of. Like all design patterns,
    it makes sense that it''s called **Singleton** because there should be only one
    of its instances.'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 单例（**Singleton**）模式充当代码可能来自和前往的核心位置。我们对单例（**Singleton**）的主要想法是只有一个实例，例如，一个游戏管理脚本、一个关卡管理脚本、一个音频管理器：不是相同实例的多个副本。这些类型的脚本将存在于你的Unity场景中，并且可能永远不会被移除。如果它们被移除或不存在，那么只有一个实例会被实例化。你可以使用单例（**Singleton**）模式为管理类型对象，它可以监督游戏，或者它可以保存玩家所在的关卡、关卡剩余时间、在这个关卡中将使用的敌人类型等等。这是一个游戏不希望忘记或拥有多个版本的中心通用点。像所有设计模式一样，它之所以被称为单例（**Singleton**），是因为应该只有一个其实例。
- en: So, this sounds like a good design pattern. However, it is argued that the **Singleton**
    pattern holds too much control over the rest of the project's code and can also
    jeopardize other design patterns, especially if you have a system that depends
    on things being in a particular order. Also, it goes against the SOLID principles—the
    guide on how code should be treated—which I'll cover later on in this chapter.
    The **single responsibility principle**, in short, means a script shouldn't contain
    more than what it's originally built for. As you can imagine, the **Singleton**
    pattern can easily get complicated as it carries multiple responsibilities. The
    success of design patterns is heavily dependent on what a designer feels comfortable
    with; it also depends on what is required for the project. In any case, **Singleton**
    is still a popular pattern, and we will use it in this project.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这似乎是一个很好的设计模式。然而，有人认为单例（**Singleton**）模式对项目代码的其他部分控制过多，也可能危害其他设计模式，特别是如果你有一个依赖于特定顺序的系统。它还违反了SOLID原则——关于代码应该如何被对待的指南，我将在本章后面讨论。简而言之，**单一职责原则**意味着脚本不应该包含比它最初构建时更多的内容。正如你可以想象的那样，单例（**Singleton**）模式可以很容易地变得复杂，因为它承担了多个职责。设计模式的成功在很大程度上取决于设计师的舒适度；它还取决于项目的要求。无论如何，单例（**Singleton**）仍然是一个流行的模式，我们将在本项目中使用它。
- en: Coming back to the definition of **Singleton**, we can describe it as a pattern
    that ensures a class has only one instance and provides a global point of access
    to it.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 回到单例（**Singleton**）的定义，我们可以将其描述为一个确保类只有一个实例并提供全局访问点的模式。
- en: 'The following diagram shows how the **Singleton** design pattern works:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了单例（**Singleton**）设计模式的工作原理：
- en: '![Figure 1.2 – Singleton design pattern'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.2 – Singleton设计模式]'
- en: '](img/Figure_1.02_B18381.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.02_B18381.jpg]'
- en: Figure 1.2 – Singleton design pattern
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: Figure 1.2 – Singleton设计模式
- en: Further Information
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'If you would like to know more about the Singleton pattern with regards to
    its code, you can go to the following link and install a demo of the code running
    in Unity:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要了解更多关于单例（**Singleton**）模式及其代码的信息，你可以访问以下链接并安装Unity中运行的代码演示：
- en: '[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns)'
- en: Let's move on to the next design pattern, **Abstract Factory**, which focuses
    on making a mold of common traits that can be given extra features later.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续下一个设计模式，**抽象工厂（Abstract Factory**），它专注于创建一个可以后来添加额外特性的通用特性模板。
- en: Abstract Factory
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象工厂
- en: The **Abstract Factory** pattern is designed to cover common traits that multiple
    objects share. For example, if I want to make enemies attack your player, I want
    all the enemies to have a health bar, and I also want them to take damage from
    your player. With **Abstract Factory**, I can create a mold, so no matter what
    enemy is created, they will have these two properties, instead of having to create
    them each time for each enemy. This design makes things easier and more uniform
    for your project.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '**抽象工厂**模式旨在涵盖多个对象共享的常见特性。例如，如果我想让敌人攻击玩家，我希望所有敌人都有一个生命条，并且我也希望它们能够从玩家那里受到伤害。使用**抽象工厂**，我可以创建一个模具，无论创建什么敌人，它们都将具有这两个属性，而不是每次为每个敌人单独创建它们。这种设计使得项目中的事情更加容易和统一。'
- en: 'The following diagram shows how the **Abstract Factory** design pattern works:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了**抽象工厂**设计模式的工作原理：
- en: '![Figure 1.3 – Abstract Factory design pattern'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.3 – 抽象工厂设计模式](img/Figure_1.03_B18381.jpg)'
- en: '](img/Figure_1.03_B18381.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.03 – 抽象工厂设计模式](img/Figure_1.03_B18381.jpg)'
- en: Figure 1.3 – Abstract Factory design pattern
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.3 – 抽象工厂设计模式
- en: Further Information
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'If you would like to know more about the Abstract Factory pattern with regards
    to its code, you can go to the following link and install a demo of the code running
    in Unity:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于抽象工厂模式及其代码的信息，你可以访问以下链接并安装一个在Unity中运行的代码演示：
- en: '[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '[Unity认证程序员考试指南第二版中的设计模式](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns)'
- en: The next design pattern is **Prototype**. This is useful for creating clones
    of an existing object.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个设计模式是**原型**。这个模式对于创建现有对象的克隆非常有用。
- en: Prototype
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 原型
- en: This is another simple pattern that carries some similarities to the **Abstract
    Factory** pattern, except this pattern creates a clone of the object it's attached
    to. So, this is less of a factory and more like a daisy chain creating itself.
    Another way this could be looked at, without going into too much detail, is that
    it mimics Unity's own prefab system ([https://docs.unity3d.com/Manual/Prefabs.html](https://docs.unity3d.com/Manual/Prefabs.html)).
    With Unity's prefab system, you can drag and drop one game object to instantiate
    another. The difference with **Prototype** is that this is achieved through code
    and because of this, we could—if we wanted to—add even more code to make this
    pattern more intelligent compared to just instantiating an object alone.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个另一个简单的模式，它和**抽象工厂**模式有一些相似之处，但这个模式创建的是它所附加对象的克隆。因此，这更像是一个自我创建的链环，而不是一个工厂。从另一个角度来看，不深入细节的话，它模仿了Unity自己的预制系统([https://docs.unity3d.com/Manual/Prefabs.html](https://docs.unity3d.com/Manual/Prefabs.html))。使用Unity的预制系统，你可以拖放一个游戏对象来实例化另一个对象。与**原型**的区别在于，这是通过代码实现的，因此，如果我们愿意，我们可以添加更多的代码来使这个模式比仅仅实例化一个对象更加智能。
- en: A good example of using this design pattern is something such as an enemy spawner
    in a game. If we had a small army of the same enemies rushing to the player coming
    from the same point, then this would work well.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个设计模式的一个很好的例子是在游戏中使用敌人生成器。如果我们有一支小军队的相同敌人从相同点冲向玩家，那么这将非常有效。
- en: 'The following diagram shows how the **Prototype** design pattern works:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表显示了**原型**设计模式的工作原理：
- en: '![Figure 1.4 – Prototype design pattern'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.4 – 原型设计模式](img/Figure_1.04_B18381.jpg)'
- en: '](img/Figure_1.04_B18381.jpg)'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.04 – 原型设计模式](img/Figure_1.04_B18381.jpg)'
- en: Figure 1.4 – Prototype design pattern
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.4 – 原型设计模式
- en: Further Information
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'If you would like to know more about the Prototype pattern with regards to
    its code, you can go to the following link and install a demo of the code running
    in Unity:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于原型模式及其代码的信息，你可以访问以下链接并安装一个在Unity中运行的代码演示：
- en: '[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns)'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '[Unity认证程序员考试指南第二版中的设计模式](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns)'
- en: Let's move on to the next design pattern—**Object Pool**, which, this time,
    isn't from the gang of four but is worth mentioning as it is common and should
    be implemented when dealing with a large number of game objects to save system
    resources.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到下一个设计模式——**对象池**，这次它不是来自四人帮，但值得提及，因为它很常见，并且在处理大量游戏对象以节省系统资源时应该实现。
- en: Object Pool
  id: totrans-143
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象池
- en: This design pattern is more of a good practice tool, rather than an actual design
    pattern; however, it's recognized like one. Let's jump into an example to explain.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 这个设计模式更像是一个良好的实践工具，而不是一个真正的设计模式；然而，它被认可为一种。让我们通过一个例子来解释。
- en: Imagine you are creating a game for a mobile device, and you want your game
    to support as many types of mobile devices as possible, even the really old phones
    that aren't very powerful. Your game consists of lots of bullets being fired across
    the screen. A typical way of making bullets fire would be to instantiate them,
    and when they leave the screen or hit an enemy, the bullet plays an exploding
    animation, makes a sound, and then destroys itself as it isn't required anymore.
    This applies to every bullet fired. Well, what if I told you all that you needed
    was 10 bullets in total and none of these bullets would be destroyed? This is
    the idea behind **Object Pool**; the bullets can be outside the game view where
    the player can't see them. When the player fires the bullet, the first bullet
    is moved into position next to the player, then when the bullet makes contact,
    it plays its exploding animation, makes its sound, and moves off the screen with
    the other nine bullets. This saves your mobile device resources as it's only dealing
    with 10 bullets, or however many the player can fire on the screen, at once.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 想象你正在为移动设备开发一款游戏，并且希望你的游戏能够支持尽可能多的移动设备类型，甚至包括那些性能并不强大的旧手机。你的游戏中有许多子弹在屏幕上发射。一种典型的发射子弹的方式是实例化它们，当子弹离开屏幕或击中敌人时，子弹播放爆炸动画，发出声音，然后销毁自己，因为不再需要它了。这适用于每颗发射的子弹。好吧，如果告诉你总共只需要
    10 颗子弹，而且这些子弹都不会被销毁，你会怎么想？这就是 **对象池** 的理念；子弹可以放在游戏视图之外，玩家看不到它们。当玩家发射子弹时，第一颗子弹被移动到玩家旁边，然后当子弹接触时，它播放爆炸动画，发出声音，并与其他九颗子弹一起离开屏幕。这节省了移动设备的资源，因为它一次只处理
    10 颗子弹，或者玩家在屏幕上可以发射的子弹数量。
- en: 'The following diagram shows how the **Object Pool** design pattern works:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 以下图表展示了 **对象池** 设计模式的工作原理：
- en: '![Figure 1.5 – Object Pool design pattern'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.5 – Object Pool design pattern](img/Figure_1.05_B18381.jpg)'
- en: '](img/Figure_1.05_B18381.jpg)'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.05_B18381.jpg]'
- en: Figure 1.5 – Object Pool design pattern
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.5 – 对象池设计模式
- en: Further Information
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 更多信息
- en: 'If you would like to know more about Object Pool with regards to its code,
    you can go to the following link and install a demo of the code running in Unity:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于对象池的代码信息，你可以访问以下链接并安装一个在 Unity 中运行的代码演示：
- en: '[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns)'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns](https://github.com/PacktPublishing/Unity-Certified-Programmer-Exam-Guide-Second-Edition/tree/main/Patterns)'
- en: Let's move on to the last design pattern, which is also not from the gang of
    four but again is common enough to talk about.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续到最后一个设计模式，这个模式也不是来自四人帮，但同样足够常见，值得讨论。
- en: Dependency Injection
  id: totrans-154
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: This pattern is often implemented with general C# applications and website development
    where you have the option of using constructors to set up each class. Unity doesn't
    really like using these constructors ([https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors))
    due to inheriting monobehaviour (which comes automatically with every newly created
    Unity script—see [https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html)
    for more information). You can, of course, remove monobehavior, but then you start
    losing a large amount of functionality with Unity. But the point of **Dependency
    Injection** is that you can have classes to do different things because they have
    received data from abstraction.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这个模式通常在通用的C#应用程序和网站开发中实现，在这些应用中，你可以选择使用构造函数来设置每个类。Unity并不喜欢使用这些构造函数（[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/constructors)），因为它是从继承monobehaviour（每个新创建的Unity脚本都会自动带有）中来的（更多信息请参阅[https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html)）。当然，你可以移除monobehavior，但这样你将失去Unity的大量功能。但**依赖注入**的目的是，你可以有执行不同任务的类，因为它们已经从抽象中接收到了数据。
- en: I have seen this design pattern mentioned in the exam, so I'll give you a brief
    overview of this design and its relationship with Unity from my perspective. Even
    though you will see more of an emulated version of the design, it would be good
    to mimic it for Unity projects. It's about understanding how far you can spread
    your code into separate dependencies, driving each class instead of clustering
    a bunch of properties into one script. The benefit of doing something like this
    is it introduces flexibility into your code without having a knock-on effect on
    other properties.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我在考试中看到过这个设计模式，所以我会从我的角度给你简要概述一下这个设计和它与Unity的关系。尽管你将看到更多的是设计的一个模拟版本，但模仿它对于Unity项目来说还是很有好处的。这关乎于理解你如何将你的代码分散到不同的依赖中，驱动每个类而不是将一堆属性聚集成一个脚本。这样做的好处是，它为你的代码引入了灵活性，而不会对其他属性产生连锁反应。
- en: 'The following diagram shows how **Dependency Injection** simply supplies one
    object to another:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示显示了**依赖注入**如何简单地为一个对象提供另一个对象：
- en: '![Figure 1.6 – Dependency Injection design pattern'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.6 – 依赖注入设计模式'
- en: '](img/Figure_1.06_B18381.jpg)'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_1.06_B18381.jpg)'
- en: Figure 1.6 – Dependency Injection design pattern
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.6 – 依赖注入设计模式
- en: Elements of this design are implemented in the project and are referred to as
    the **Dependency Injection** pattern, but in practice, we also cover the Dependency
    inversion principle in the SOLID principles in the next section.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 该设计模式的项目中实现了其元素，并被称为**依赖注入**模式，但在实践中，我们也在下一节中涵盖了SOLID原则中的依赖反转原则。
- en: This was a sample of all the many design patterns out there that can make you
    stand out from the rest of the Unity programmers. From my experience at university
    and from progressing through Unity programmer roles, these patterns aren't used
    enough. However, if you understand them (as you will in these projects), log them
    so you don't forget, and whenever you start or join a project, think of what patterns
    go with the roles you choose or are given. It's very tempting to just jump in
    and start coding, but this is where you might run into dead ends or oversized
    classes.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一份所有可以让你在众多Unity程序员中脱颖而出的众多设计模式的样本。根据我在大学期间的经历以及通过Unity程序员角色的进步，这些模式并没有得到足够的运用。然而，如果你理解了它们（正如你将在这些项目中看到的那样），记录下来以免忘记，并且每次你开始或加入一个项目时，都要考虑一下与你选择或分配的角色相匹配的模式。直接跳入并开始编码是非常诱人的，但这也可能是你遇到死胡同或过度庞大类的地方。
- en: Let's move on and look at the SOLID principles of coding. I have mentioned them
    briefly a couple of times – consider them a guideline for what makes a good programmer.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续前进，看看编码的SOLID原则。我简要地提到了它们几次——把它们视为一个指导方针，了解什么是一个好的程序员。
- en: The SOLID principles
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SOLID原则
- en: When you are planning and coding your projects within Unity as an **Object-Oriented
    Programming** (**OOP**) practitioner—programming that is based on objects containing
    data—patterns are a great way of making things uniform, saving time, and, hopefully,
    relating to other programmers who share the same patterns with you.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当你作为一个**面向对象编程**（**OOP**）实践者，在Unity中规划和编码你的项目——基于包含数据的对象进行编程——模式是使事物统一、节省时间的好方法，并且希望与使用相同模式的程序员建立联系。
- en: However, you won't always have a design pattern for all of your projects and
    it may not be practical to try and force plans that simply aren't practical. If
    we brush the design patterns to one side, there is an even deeper methodology
    to programming—the SOLID principles. These principles are guidelines that remind
    OOP programmers what they should be thinking about when coding projects. They
    outline what you should and shouldn't be doing with your code. Yes, you could
    ignore the SOLID principles, and even ignore design patterns, but difficulties
    will occur and increase the risk of you coding yourself into a dead end and creating
    multiple errors when you change a single line of code. You'll have colleagues
    scratching their heads not knowing what your code is doing, as well as inefficient
    classes and methods that potentially slow down your system—the list goes on. It's
    very easy to not follow a plan and be keen to just get the job done. Eventually,
    this will haunt you and you will have to accept that you need a plan and you need
    to follow rules, especially if your project expands, even if it's just you coding
    the project.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你并不总是为你的所有项目都有设计模式，并且尝试强制实施不切实际的计划可能并不实用。如果我们把设计模式放在一边，还有更深层次的编程方法——SOLID原则。这些原则是指导方针，提醒面向对象编程程序员在编码项目时应该考虑什么。它们概述了你应该和不应该用你的代码做什么。是的，你可以忽略SOLID原则，甚至忽略设计模式，但困难将会发生，并增加你编码到死胡同和更改一行代码时产生多个错误的风险。你的同事会挠头，不知道你的代码在做什么，以及可能减慢你的系统的低效类和方法——列表还在继续。不遵循计划并急于完成任务是非常容易的。最终，这会困扰你，你必须接受你需要一个计划，你需要遵守规则，尤其是如果你的项目扩展了，即使只是你自己编码项目也是如此。
- en: 'The five SOLID principles are as follows:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 五个SOLID原则如下：
- en: Single responsibility principle
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Open/closed principle
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: Liskov substitution principle
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 李斯克夫替换原则
- en: Interface segregation principle
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: Dependency inversion principle
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: Let's look at each one in more detail, starting with the "S" in SOLID—the single
    responsibility principle.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地看看每一个，从SOLID中的"S"——单一职责原则开始。
- en: Single responsibility principle
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: '*A class should only have a single purpose; changes to the class should be
    specific to affect the specification of the class alone.*'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '*一个类应该只有一个目的；对类的更改应该仅针对类的规格。*'
- en: This means that we should keep classes simple and not give our classes multiple
    roles. If you have a class that handles bullets, don't let any extra features
    fall into it; save them for another class. A common problem that programmers come
    across is making a class that constantly grows and mutates. This will eventually
    create problems and typically results in refactoring code, especially if you want
    to add something specific to your class, which can have an effect on the other
    properties tied to it.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着我们应该保持类简单，不要让我们的类承担多个角色。如果你有一个处理子弹的类，不要让任何额外的功能落入其中；将它们留给另一个类。程序员经常遇到的一个常见问题是创建一个不断增长和变化的类。这最终会引发问题，通常会导致重构代码，尤其是当你想向你的类添加特定内容时，这可能会影响与之相关的其他属性。
- en: Let's now move on to the "O" in SOLID—the open/closed principle.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们转向SOLID中的"O"——开放/封闭原则。
- en: Open/closed principle
  id: totrans-178
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放/封闭原则
- en: '*Scripting should be open to being extended but closed for modification.*'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '*脚本应该易于扩展但不易于修改。*'
- en: Create a class that supports extra work being applied to it without having to
    constantly revisit and modify your original class. For example, if I have a spaceship
    that fires a bullet and I want to add different types of weapons, I want to avoid
    adding any more to the original script. If I want to add 50 weapons, my original
    script would simply keep growing to an unwieldy size. Ideally, this weapon script
    should be able to receive an extension that can swap out what weapon is fired,
    so even if I had 50 weapons, the script wouldn't need to change; it would just
    swap out the weapon from the extension. Something such as an interface ([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface))
    or an abstract class ([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract))
    that receives the weapon type would work well with this. If the class is encouraged
    to grow and cater to all these weapons, you will start violating the **single
    responsibility principle**.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个类，使其能够支持对其应用额外的工作，而无需不断回访和修改你的原始类。例如，如果我有一艘能够发射子弹的宇宙飞船，并且我想添加不同类型的武器，我不想在原始脚本中添加任何更多内容。如果我想添加50种武器，我的原始脚本会简单地不断增长，变得难以控制。理想情况下，这个武器脚本应该能够接收一个扩展，可以替换发射的武器，即使我有50种武器，脚本也不需要改变；它只需从扩展中替换武器。例如，一个接口([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/interface))或一个接收武器类型的抽象类([https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/abstract))与这个功能配合得很好。如果鼓励类增长并适应所有这些武器，你将开始违反**单一职责原则**。
- en: Let's now move on to the "L" in SOLID—the Liskov substitution principle.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈SOLID原则中的“L”——里氏替换原则。
- en: Liskov substitution principle
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 里氏替换原则
- en: '*Content in objects should have the ability to be replaced with an instance
    of a subtype without altering the base of the object itself.*'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '*对象中的内容应该能够用子类型的一个实例替换，而不会改变对象本身的基类*。'
- en: If a class inherits from another class, the inherited class should be able to
    access the original base class as if it was the original class. But what does
    that mean? So, in theory, the child class should be able to be used in the same
    manner as the parent class.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类从另一个类继承，那么继承的类应该能够像访问原始基类一样访问原始基类。但这是什么意思呢？所以，从理论上讲，子类应该能够以与父类相同的方式被使用。
- en: The main benefit of this is you can have a class with a method containing values
    that can be overridden for a particular object. For example, if a car is factory-made,
    its default color when leaving the factory is white. Several of these white cars
    can be sprayed with different colors even though it is the same car; the color
    is being overridden by another factory.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法的主要好处是你可以有一个包含可以针对特定对象重写值的方法的类。例如，如果一辆车是工厂制造的，那么它出厂时的默认颜色是白色。即使这些白色汽车是同一款车，也可以喷上不同的颜色；颜色被另一个工厂所覆盖。
- en: By default, a base class could, for example, return a default value, while a
    child class using the same method could override it for its own. If this principle
    was ignored, you will likely end up using a lot of `if` statements to cover each
    child's class method, which would then involve expanding code, which then violates
    the two previous principles we spoke about.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，基类可以返回一个默认值，而使用相同方法的子类可以对其进行覆盖。如果忽略这个原则，你可能会使用大量的`if`语句来覆盖每个子类的类方法，这将涉及代码的扩展，从而违反了我们之前提到的两个原则。
- en: Let's now move on to the "I" in SOLID—the interface segregation principle.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来谈谈SOLID原则中的“I”——接口隔离原则。
- en: Interface segregation principle
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口隔离原则
- en: '*Specific interfaces are better than one general interface.*'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '*特定的接口优于一个通用的接口*。'
- en: This one is fairly simple—when implementing interfaces, try to keep them light
    and interchangeable with other classes and methods, as opposed to having one huge
    interface that will likely be redundant to the specific class you are inheriting
    from. For example, an interface can contain variables for health points, defense,
    strength, and so on. If I was going to apply this to a character, this would make
    sense, but if I also applied it to an apple, it wouldn't so much. However, I would
    still have to implement it on the apple as it's an interface.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 这个相当简单——在实现接口时，尽量保持它们轻量级，并且可以与其他类和方法互换，而不是有一个巨大的接口，这个接口可能对你继承的具体类来说是多余的。例如，一个接口可以包含健康点数、防御、力量等变量。如果我要将这个应用到角色上，这就有意义了，但如果我也将它应用到苹果上，那就没有这么多了。然而，我仍然必须将它应用到苹果上，因为它是接口。
- en: Let's now move on to the "D" in SOLID—the dependency inversion principle.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续到SOLID中的“D”——依赖倒置原则。
- en: Dependency inversion principle
  id: totrans-192
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖倒置原则
- en: '*Lean on abstractions and not concretions.*'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: '*依赖抽象而非具体实现。*'
- en: Abstract classes can be used to cover a general field of classes, which is ideal
    for something such as a gun script. You can have multiple different types of guns
    with different shot powers, bullet counts, and so on. Otherwise, you will rely
    on the specific gun class, which can then lead to multiple variants and class
    calls to that specific gun class. Abstraction means that no matter how many gun
    classes there are, it won't affect other scripts catering for all the variants.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类可以用来覆盖一个类的通用领域，这对于像枪脚本这样的东西来说是非常理想的。你可以有多个不同类型的枪，具有不同的射击功率、子弹数量等等。否则，你将依赖于特定的枪类，这可能导致对该特定枪类的多个变体和类调用。抽象意味着无论有多少枪类，都不会影响为所有变体提供服务的其他脚本。
- en: In summary, the SOLID principles encourage you to cut up your code into segments
    and remove expanding classes. It encourages you to look for other ways of writing
    your code instead of creating a chain reaction when a new piece of code is written.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，SOLID原则鼓励你将代码分割成多个部分，并移除不断扩展的类。它鼓励你寻找编写代码的其他方法，而不是在编写新代码时引发连锁反应。
- en: So, when it comes to a project, if you ignore the SOLID principles and design
    patterns, you will survive but you will be creating a mold of what your next project
    will be like. Eventually, it will turn into a bad habit and it'll become more
    difficult to retrain yourself. Speaking of projects, let's check out the game
    design brief for the game we are going to make—Killer Wave!
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当涉及到一个项目时，如果你忽略了SOLID原则和设计模式，你可能会存活下来，但你将会塑造出你下一个项目将是什么样的样子。最终，这会变成一个坏习惯，而且重新训练自己会变得更加困难。说到项目，让我们来看看我们即将制作的《致命波浪》游戏的设计概要！
- en: Designing the Killer Wave game
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计《致命波浪》游戏
- en: This will be our prototype/demo for a futuristic classic side-scrolling shooter,
    where we get to power up the ship and destroy the enemies that come at the player
    in a killer wave! We have spoken about design patterns and solid principles, and
    we are going to examine them in more detail, including all of the six core objectives
    for the Unity programmer exam. We will go through structuring the game, breaking
    it up into a framework of segments. We need to understand the relationship between
    each class and know how to expand our code without it upsetting what we've already
    written.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是我们的原型/演示，一个未来经典侧滚动射击游戏，我们可以升级我们的飞船并摧毁以致命波浪形式向玩家进攻的敌人！我们已经讨论了设计模式和SOLID原则，我们将更详细地研究它们，包括Unity程序员考试的六个核心目标。我们将通过构建游戏结构，将其分解成框架的各个部分。我们需要了解每个类之间的关系，并知道如何扩展我们的代码，而不会破坏我们已写的内容。
- en: We will cover particle effects with an environment of stars whizzing past and
    ship thrusters with multiple particle colors. We will animate enemy ships and
    use Unity's own API to animate our environment scene. The list is quite long,
    but if we go through this project, we will not only be ready to tackle the Unity
    programmer exam, but we will also be ready to expand on this project and take
    on other projects with the correct approach; so, let's check out the following
    set of instructions (or a brief would describe it better) for making Killer Wave.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用星星飞驰的环境来覆盖粒子效果，以及具有多种粒子颜色的船推进器。我们将动画化敌舰，并使用Unity自带的API来动画化我们的环境场景。清单相当长，但如果我们完成这个项目，我们不仅将准备好应对Unity程序员考试，而且我们也将准备好以正确的方法扩展这个项目并承担其他项目；所以，让我们来看看以下制作《致命波浪》的指令集（或者用概要来描述它会更好）。
- en: Game design brief
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 游戏设计概要
- en: '**Title**: Killer Wave'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '**标题**：杀手波'
- en: '**Genre**: Side-scrolling shooter'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '**类型**：横版射击游戏'
- en: '**Platform**: PC/Mobile'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '**平台**：PC/移动'
- en: '**Target audience**: Age 10+'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标受众**：10岁以上'
- en: '**Game concept**: In space with enemies rushing past the player, players need
    to shoot and destroy as many enemies as possible within a limited number of lives
    before the end of the level. Enemies come in two forms—wave and flee. The third
    level will feature a large flying-robot boss that the player will chase off.'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏概念**：在太空中，玩家需要在有限的生命值内尽可能多地射击和摧毁敌人，直到关卡结束。敌人有两种形式——波和逃跑。第三级将出现一个大型飞行机器人Boss，玩家需要将其驱逐。'
- en: '**Game flow and mechanics**: The player will be in a small spaceship that can
    be controlled with the keyboard/joypad cursor controls and fired with the *Ctrl*
    or *Command* key from its position and can travel right. The level will end when
    the player has traveled to the end of the stage from left to right.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: '**游戏流程和机制**：玩家将操控一个小型飞船，可以使用键盘/手柄光标控制移动，并使用*Ctrl*或*Command*键从当前位置发射，可以向右移动。当玩家从左到右穿越到舞台的尽头时，关卡结束。'
- en: '**Constraints**: The player has three lives when the game is not connected
    to the internet. The player will be contained within the screen boundaries.'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '**限制**：当游戏未连接到互联网时，玩家有三条生命。玩家将被限制在屏幕边界内。'
- en: '**Visuals**: HUD—in-game score, in-game lives, game title, level title, game-over
    title.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '**视觉效果**：HUD——游戏得分、游戏生命值、游戏标题、关卡标题、游戏结束标题。'
- en: '**Enemy wave**: Featured in all three levels. These enemies will be instantiated
    to travel in a sine-wave pattern moving at a slow rate from the right to the left
    of the screen. The enemy will fly independently or within a group of the same
    enemy type, creating a trail.'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: '**敌波**：出现在所有三个级别中。这些敌人将以正弦波模式从屏幕右侧向左侧缓慢移动。敌人可以独立飞行，也可以在同一类型的敌人群体中飞行，留下轨迹。'
- en: '**Enemy flees**: This enemy will be placed in dotted areas of the third level.
    Their behavior will move away from the player if in range. If the range is lost,
    the enemy remains still. If contact is made with the player, the player will lose
    health and the enemy will die.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**敌人逃跑**：这种敌人将被放置在第三级的虚线区域内。如果处于范围内，它们的行为将是远离玩家。如果失去范围，敌人将保持静止。如果与玩家接触，玩家将失去生命值，敌人将死亡。'
- en: '**Enemy boss**: The boss is seen during the third level and greets the player,
    only to then zoom off out of the screen view with the player automatically chasing
    them.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '**敌人Boss**：Boss出现在第三级，向玩家打招呼，然后迅速从屏幕视图中消失，玩家自动追击。'
- en: We now have a taste of what the game will be like. As a programmer, we need
    to think not only about how the game is made but also how to expand on it. We
    need to think about how to structure the levels and how we structure the enemies.
    How do we do this? Do we need to consider changing the design of each level on
    the fly without slowing down development? If you can think of all the things involved
    in how a game is going to be made and what parts need breaking down, you'll save
    yourself a lot of time in development. We are next going to talk about the structure
    of the game.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经尝到了游戏将是什么样的。作为一个程序员，我们不仅需要考虑游戏是如何制作的，还需要考虑如何扩展它。我们需要考虑如何构建关卡和如何构建敌人。我们如何做到这一点？我们是否需要考虑在开发过程中不减速的情况下动态改变每个关卡的设计？如果你能想到所有与游戏制作相关的事情以及哪些部分需要分解，你将在开发过程中节省很多时间。接下来，我们将讨论游戏的架构。
- en: The Killer Wave game framework
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 杀手波游戏框架
- en: We now roughly know what type of game we're going to make. Don't worry too much
    about the exact details as it will not affect the development phase. Our main
    focus will be the framework of the game; we'll focus on cosmetics in a later chapter.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在大致知道了我们要制作的游戏类型。不必过于担心具体细节，因为它不会影响开发阶段。我们的主要关注点将是游戏的框架；我们将在后面的章节中关注外观。
- en: It's very easy to jump into game development and make it up as you go along—sometimes,
    that's half of the fun. But when it comes to the fundamentals of creating any
    application, we need to know where to throw our creativity and logic by sticking
    to a particular development process. Ideally, you need a framework.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 进入游戏开发非常容易，可以边做边想——有时，这本身就是一半的乐趣。但是，当涉及到创建任何应用程序的基本原理时，我们需要知道如何通过坚持特定的开发流程来发挥我们的创造力和逻辑。理想情况下，你需要一个框架。
- en: Before I carry on presuming you know what a framework is, let's just consider
    it as an overall blueprint—a plan of how all our pieces of code are going to talk
    to each other. Frameworks are similar to design patterns—the plan of the code
    is set out and ideally shouldn't be expanded on because we're sticking to a plan.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 在我继续假设您知道什么是框架之前，让我们先将其视为一个整体蓝图——一个规划，说明我们所有的代码片段将如何相互交流。框架类似于设计模式——代码的规划已经确定，理想情况下不应该扩展，因为我们正在坚持一个计划。
- en: Yes, we know some design patterns, but if the overall flow and direction of
    our code are lacking scope, we are likely going to run into issues with working
    ourselves into a dead end. Sometimes, developers think that because they've learned
    a single framework, they can use it to build any application and they use it with
    every project.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 是的，我们知道一些设计模式，但如果我们代码的整体流程和方向缺乏范围，我们很可能会遇到自己陷入死胡同的问题。有时，开发者认为因为他们已经学习了一个框架，他们就可以用它来构建任何应用程序，并且他们在每个项目中都使用它。
- en: This, of course, is not how we should do it. The more we know about our patterns,
    the easier the flow of the code will be when it comes to extending our overall
    master plan or the game's framework.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们不应该这样做。我们对模式了解得越多，当我们扩展整体主计划或游戏框架时，代码的流程就会越容易。
- en: There are hundreds of ways of making this demo with multiple patterns and frameworks.
    The one we will follow here is my version, but if you have a better one or one
    you feel more comfortable with, go for it. As long as you understand the process
    described in the upcoming chapters and you make use of Unity's APIs on the way,
    I would encourage you to do this; otherwise, just follow along with our examples.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 制作这个演示有多种方式，可以使用多种模式和框架。我们将遵循的是我的版本，但如果您有一个更好的版本或您感觉更舒适，请随意使用。只要您理解即将到来的章节中描述的过程，并在过程中使用
    Unity 的 API，我会鼓励您这样做；否则，只需跟随我们的示例即可。
- en: So, with that said, let's move on to our framework for the game.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，既然这样，让我们继续我们的游戏框架。
- en: Framework
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 框架
- en: To start off, we will break down what we are going to need for the game. The
    first things I tend to think of are the player, what the player does, and what's
    going to interact with our player. We also know that there will be a list of enemies.
    Finally, the game will likely have multiple scenes, so we need to think about
    how each individual asset will be set up within each disposable scene. As always,
    things need breaking down into classes and we need to plan the importance of how
    classes are connected to each other. The following is how I've broken down the
    game design brief into separate classes.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将分解我们为游戏所需的内容。我首先想到的是玩家、玩家做什么以及什么将与我们的玩家交互。我们还知道将有一个敌人列表。最后，游戏可能有多场景，因此我们需要考虑每个单独的资产如何在每个可丢弃的场景中设置。像往常一样，事情需要分解成类，我们需要规划类之间连接的重要性。以下是我如何将游戏设计概述分解成单独的类的。
- en: 'These are the **class responsibilities**:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是 **类职责**：
- en: '`SceneManager` will globally tell all the classes what scene the user is on
    (for example, the title screen, level 1, the menu screen, and so on).'
  id: totrans-224
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SceneManager` 将全局告知所有类用户处于哪个场景（例如，标题屏幕、第 1 级、菜单屏幕等）。'
- en: '`GameManager` communicates with all the game objects and communicates with
    other managers; it is in charge of the game''s loop process.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameManager` 与所有游戏对象通信，并与其他管理器通信；它负责游戏的循环过程。'
- en: '`ScoreManager` reads and writes the score data when offline and updates the
    score UI.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ScoreManager` 在离线时读取和写入分数数据，并更新分数用户界面。'
- en: '`PlayerShipBuild` receives and sets customization settings to `PlayerSpawner`.'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerShipBuild` 接收并设置定制设置到 `PlayerSpawner`。'
- en: '`EnemySpawner` is similar to `PlayerSpawner` but it can manage all different
    types of enemies.'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnemySpawner` 类似于 `PlayerSpawner`，但它可以管理所有不同类型的敌人。'
- en: '`Enemy` refers to multiple enemy classes—for example, if an enemy that shoots
    is made, it will go in this location of the framework. If an enemy moves or acts
    differently, it will also be put into the same allocation.'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enemy` 指的是多个敌人类——例如，如果创建了一个射击敌人，它将进入框架的这个位置。如果敌人移动或行为不同，它也将被放入相同的分配。'
- en: '`EnemyBullet` travels at a set rate and removes itself after a set time or
    if it makes contact with the scenery.'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EnemyBullet` 以设定速率移动，并在设定时间后或与场景接触后移除自己。'
- en: '`PlayerSpawner` launches the player in a certain location of the screen and
    keeps its hierarchy in order.'
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerSpawner` 在屏幕的某个位置启动玩家并保持其层次结构有序。'
- en: '`Player` fires bullets, receives input controls from the user, and is removed
    if contact is made with the scenery, enemy, or enemies'' bullets.'
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Player` 发射子弹，接收用户的输入控制，如果与场景、敌人或敌人的子弹接触，则被移除。'
- en: '`PlayerBullet` travels at a set rate, removes and damages the enemy, and removes
    itself after a set time or if it makes contact with the scenery.'
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerBullet` 以固定的速度移动，移除并损坏敌人，并在设定的时间后或与场景接触后移除自身。'
- en: '`ShopPiece` handles the content of the player''s ship upgrade selections.'
  id: totrans-234
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShopPiece` 处理玩家船升级选择的内 容。'
- en: '`SOShopSelection` holds the data types that are used in each grid selection
    in the shop menu.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOShopSelection` 保存商店菜单中每个网格选择中使用的数据类型。'
- en: '`SOActorModel` holds the common variables for each class it is connected to.
    As an example, all moving objects have a speed setting; this includes player bullets,
    enemy bullets, enemy ships, and so on.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SOActorModel` 保存与其连接的每个类的公共变量。例如，所有移动对象都有一个速度设置；这包括玩家子弹、敌人子弹、敌人飞船等等。'
- en: '`IActorTemplate` isn''t a class but an interface. An interface works a bit
    like a contract to whatever it is connected to. For example, this interface wants
    the class connected to it to have functions titled `Attack()`, `Die()`, and so
    on. The class must include these functions, even if they are empty. You should,
    hopefully, already know what an interface is; we will be using them frequently
    in this book. For more information about interfaces, check out [https://learn.unity.com/tutorial/interfaces](https://learn.unity.com/tutorial/interfaces).'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IActorTemplate` 不是一个类，而是一个接口。接口有点像与它连接的任何东西的合同。例如，这个接口希望连接到它的类具有名为 `Attack()`、`Die()`
    等的函数。类必须包含这些函数，即使它们是空的。希望你已经知道接口是什么；我们将在本书中频繁使用它们。有关接口的更多信息，请参阅 [https://learn.unity.com/tutorial/interfaces](https://learn.unity.com/tutorial/interfaces)。'
- en: The following diagram shows the visual relationship between each class that
    we have just listed. These diagrams are typically called **Unified Model Language**
    (**UML**) ([https://www.c-sharpcorner.com/UploadFile/nipuntomar/uml-diagrams-part-1/](https://www.c-sharpcorner.com/UploadFile/nipuntomar/uml-diagrams-part-1/)).
    We could have used a more detailed diagram than the following one, but for the
    purpose of keeping things as simple as possible, we will just refer to the classes
    with boxes and names.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图表展示了我们刚刚列出的每个类之间的视觉关系。这些图表通常被称为**统一建模语言**（**UML**）([https://www.c-sharpcorner.com/UploadFile/nipuntomar/uml-diagrams-part-1/](https://www.c-sharpcorner.com/UploadFile/nipuntomar/uml-diagrams-part-1/))。我们本可以使用比下面更详细的图表，但为了尽可能保持简单，我们只需用方框和名称来指代类。
- en: 'Some of you may find this shell-looking framework complex, but both sides mirror
    each other and control the responsibilities of either game object separately.
    Let''s have a look at this in more detail:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 一些同学可能会觉得这个看起来像壳的框架比较复杂，但两边是镜像的，并且分别控制游戏对象的职责。让我们更详细地看看：
- en: '![Figure 1.7 – Killer Wave''s UML'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.7 – 杀手波特的 UML'
- en: '](img/Figure_1.07_B18381.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_1.07_B18381.jpg)'
- en: Figure 1.7 – Killer Wave's UML
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.7 – 杀手波特的 UML
- en: Each gray box represents a class that is mentioned in the preceding list; the
    lines between each box indicate their dependency on the class. The `PlayerSpawner`
    class, for example, will need to be coupled with the `GameManager` class to notify
    it of what is happening to the `Player` class; the `Player` class will need to
    send and receive information such as lives, enemy kill count, and other stats
    to the `GameManager` class directly. If we want to move our score over to be stored
    on the device, then we can link this to our `ScoreManager` class. The main takeaway
    from this diagram is that if a line is connected to either box, there will be
    communication between the classes.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 每个灰色方框代表前面列表中提到的类；方框之间的线条表示它们对类的依赖关系。例如，`PlayerSpawner` 类将需要与 `GameManager`
    类耦合，以通知它 `Player` 类正在发生的事情；`Player` 类将需要直接向 `GameManager` 类发送和接收有关生命、敌人击杀数和其他统计数据等信息。如果我们想将我们的分数移动到设备上存储，那么我们可以将其链接到我们的
    `ScoreManager` 类。从这个图表中我们可以得出的主要结论是，如果一条线连接到任一方框，则将在类之间进行通信。
- en: UMLs are not a prime focus for the exam, but they should be mentioned at this
    stage given that we are creating a plan for the game. I personally like creating
    UMLs, in a way; as long as the flow of the game is understood, we shouldn't worry
    about finalizing every detail.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: UML 不是考试的重点，但鉴于我们正在为游戏制定计划，在这个阶段应该提到它们。我个人喜欢创建 UML，从某种意义上说；只要理解了游戏的流程，我们就不必担心最终确定每个细节。
- en: So, now we have an idea of how the game works, how we are going to break it
    up into segments, and how segments are related to each other. The next step is
    to prepare our version of Unity and start planning how to bring the game over
    to this piece of software.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们有了关于游戏如何工作的概念，我们将如何将其分解成段，以及段与段之间的关系。下一步是准备我们的Unity版本，并开始规划如何将游戏迁移到这个软件上。
- en: Setting up Unity
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Unity
- en: Unity typically brings out a new version of their software every 2 weeks. You
    might expect this to cause problems with keeping up to date with the latest version
    for the exam. To date, Unity doesn't update their exams annually, so the exam
    and our project relate to Unity 2020 LTS. Unity will always keep updating and
    introducing new components and features with their future releases, but the prime
    fundamentals should remain the same.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: Unity通常每两周就会推出一个新版本的软件。您可能会预期这会导致在考试中跟上最新版本时出现问题。到目前为止，Unity并没有每年更新他们的考试，因此考试和我们的项目与Unity
    2020 LTS相关。Unity将始终通过未来的发布不断更新和引入新的组件和功能，但基本原理应该保持不变。
- en: 'This book is designed for users who have been using Unity for at least 2 years,
    so I''ll assume you at least have a free account with them, and a copy of Unity
    installed. If not, here is the license activation guide from their 2020 LTS documentation:
    [https://docs.unity3d.com/2020.2/Documentation/Manual/LicensesAndActivation.html](https://docs.unity3d.com/2020.2/Documentation/Manual/LicensesAndActivation.html).'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 本书是为那些至少使用Unity两年以上的用户设计的，因此我假设您至少拥有他们的免费账户，并且安装了Unity的副本。如果没有，这里提供了他们2020 LTS文档中的许可激活指南：[https://docs.unity3d.com/2020.2/Documentation/Manual/LicensesAndActivation.html](https://docs.unity3d.com/2020.2/Documentation/Manual/LicensesAndActivation.html)。
- en: Once you have created a free account, you can download the Unity Hub. This will
    hold a reference to the version of Unity you have installed and also your projects.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您创建了免费账户，您就可以下载Unity Hub。这将保存您安装的Unity版本和您的项目。
- en: 'You can download and install the Unity Hub from here: [https://unity3d.com/get-unity/download](https://unity3d.com/get-unity/download).'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从这里下载并安装Unity Hub：[https://unity3d.com/get-unity/download](https://unity3d.com/get-unity/download)。
- en: Once you have done that, you can grab a free copy of Unity 2020 LTS.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 完成上述操作后，您就可以获取Unity 2020 LTS的免费副本。
- en: 'You can download Unity 2020 LTS from their archives:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以从他们的存档中下载Unity 2020 LTS：
- en: Go to [https://unity3d.com/unity/qa/lts-releases](https://unity3d.com/unity/qa/lts-releases).
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往[https://unity3d.com/unity/qa/lts-releases](https://unity3d.com/unity/qa/lts-releases)。
- en: Click on either of the LTS Release 2020 links from the list.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击列表中的任意一个LTS Release 2020链接。
- en: Then click on the **Unity Hub** button from the scrolling window.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后从滚动窗口中点击**Unity Hub**按钮。
- en: Follow the rest of the instructions to download Unity 2020 LTS.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照其余说明下载Unity 2020 LTS。
- en: 'It''s worth noting, at this point, that when going through the installation
    procedure, you should be sure to have an IDE installed. If you don''t, Unity recommends
    downloading **Microsoft Visual Studio Community 2019**. All our scripting will
    take place in this application. The following screenshot shows the recommended
    IDE selected:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在安装过程中，您应该确保已经安装了一个IDE。如果没有，Unity建议下载**Microsoft Visual Studio Community
    2019**。所有的脚本都将在这个应用程序中编写。以下截图显示了推荐的IDE选择：
- en: '![Figure 1.8 – Select Microsoft Visual Studio Community 2019 from the Unity
    Hub and if you are planning on installing an Android version of the game, tick
    all three boxes next to the *'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.8 – 从Unity Hub中选择Microsoft Visual Studio Community 2019，如果您计划安装游戏的Android版本，请勾选旁边的所有三个复选框]'
- en: '](img/Figure_1.08_B18381.jpg)'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.08_B18381.jpg]'
- en: Figure 1.8 – Select Microsoft Visual Studio Community 2019 from the Unity Hub
    and if you are planning on installing an Android version of the game, tick all
    three boxes next to the *
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.8 – 从Unity Hub中选择Microsoft Visual Studio Community 2019，如果您计划安装游戏的Android版本，请勾选旁边的所有三个复选框。
- en: Information Note
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 信息通知
- en: If you plan to install any Unity project on a mobile phone, tablet, and so on,
    then make sure you select the relevant support files. In this book, we will lightly
    cover the Android version. Our prime focus will be running our game in the Unity
    Editor.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您计划在手机、平板电脑等设备上安装任何Unity项目，请确保您选择了相关的支持文件。在这本书中，我们将简要介绍Android版本。我们的主要重点是运行游戏在Unity编辑器中。
- en: Once you have installed Unity, you can run the Unity Hub program.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦您安装了Unity，您就可以运行Unity Hub程序。
- en: Starting our project through Unity Hub
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 通过Unity Hub启动我们的项目
- en: At this point, you have installed Unity 2020 LTS, registered as a Unity user,
    and have a shortcut to run the Unity Hub program.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您已经安装了 Unity 2020 LTS，注册为 Unity 用户，并且有一个快捷方式来运行 Unity Hub 程序。
- en: Unity Hub is mainly used to keep a collection of the different versions of Unity
    installed, as well as a list of the projects that are on your system and in the
    cloud with Unity's own cloud storage software.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: Unity Hub 主要用于保存安装的不同版本的 Unity，以及系统上和 Unity 自有云存储软件中的项目列表。
- en: When you run Unity Hub, please make sure you are signed in as a registered user,
    as discussed in the previous section.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行 Unity Hub 时，请确保您已登录为注册用户，如前一小节所述。
- en: 'Load up Unity Hub and sign in, if you haven''t already:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 Unity Hub 并登录，如果您还没有的话：
- en: 'The following screenshot shows you where to sign in on Unity Hub:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下截图显示了您在 Unity Hub 中登录的位置：
- en: '![Figure 1.9 – Sign in to your Unity account'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.9 – 登录您的 Unity 账户]'
- en: '](img/Figure_1.09_B18381.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.09_B18381.jpg]'
- en: Figure 1.9 – Sign in to your Unity account
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.9 – 登录您的 Unity 账户
- en: 'Once signed in, go to the **Projects** tab (denoted with **1** in the following
    screenshot) at the top left of Unity Hub and select the down arrow next to **New**
    (denoted with **2**) to pick the version of Unity to run this project, as shown:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 登录后，转到 Unity Hub 顶部的左侧的 **项目** 标签（如下截图所示用 **1** 标记），然后选择 **新** 旁边的向下箭头（如下截图所示用
    **2** 标记）以选择运行此项目的 Unity 版本，如下所示：
- en: '![Figure 1.10 – Create a new project in the Unity HUB'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.10 – 在 Unity HUB 中创建一个新项目]'
- en: '](img/Figure_1.10_B18381.jpg)'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.10_B18381.jpg]'
- en: Figure 1.10 – Create a new project in the Unity HUB
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.10 – 在 Unity HUB 中创建一个新项目
- en: From the dropdown, you should see a copy of **Unity 2020 LTS**, which we installed
    from the archive link in the previous section. Select **Unity 2020 LTS**.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从下拉菜单中，您应该看到 **Unity 2020 LTS** 的一个副本，这是我们从前一小节中的存档链接中安装的。选择 **Unity 2020 LTS**。
- en: 'The last screen before the Unity Editor is launched is a selection between
    two templates:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器启动之前的最后一个屏幕是两个模板之间的选择：
- en: '**3D**: The Unity Editor starts in a three-dimensional view.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3D**：Unity 编辑器以三维视图启动。'
- en: '**2D**: The UnityEditor starts in a two-dimensional view.'
  id: totrans-280
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2D**：Unity 编辑器以二维视图启动。'
- en: 'Let''s create our Unity project:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建我们的 Unity 项目：
- en: Select **3D**.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **3D**。
- en: Give your project a name. I'm calling mine `KillerWave`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 给您的项目起一个名字。我的是 `KillerWave`。
- en: Add a location where you want the Unity project to be stored.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加您想要存储 Unity 项目的位置。
- en: 'Click **Create project**:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **创建项目**：
- en: '![Figure 1.11 – Select a 3D project template with a name and location to create
    a project. Be sure you have Unity 2020 LTS selected at the top of the Hub window'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.11 – 选择一个带有名称和位置的 3D 项目模板以创建项目。确保您在 Hub 窗口的顶部选择了 Unity 2020 LTS]'
- en: '](img/Figure_1.11_B18381.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.11_B18381.jpg]'
- en: Figure 1.11 – Select a 3D project template with a name and location to create
    a project. Be sure you have Unity 2020 LTS selected at the top of the Hub window
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.11 – 选择一个带有名称和位置的 3D 项目模板以创建项目。确保您在 Hub 窗口的顶部选择了 Unity 2020 LTS
- en: 'It doesn''t really matter which of the templates you pick, as once the Unity
    Editor loads, all that we need to do to change between **2D** and **3D** is press
    *2* on our keyboard, or click the **2D** button at the top of the **Scene** window,
    as in the following screenshot:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 您选择的模板实际上并不重要，因为一旦 Unity 编辑器加载，我们只需按键盘上的 *2* 或者在 **Scene** 窗口的顶部点击 **2D** 按钮即可在
    **2D** 和 **3D** 之间切换，如下截图所示：
- en: '![Figure 1.12 – 2D and 3D mode in the Unity Editor'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 1.12 – Unity 编辑器中的 2D 和 3D 模式]'
- en: '](img/Figure_1.12_B18381.jpg)'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_1.12_B18381.jpg]'
- en: Figure 1.12 – 2D and 3D mode in the Unity Editor
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.12 – Unity 编辑器中的 2D 和 3D 模式
- en: After clicking **Create project**, you are presented with the Unity Editor.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 点击 **创建项目** 后，您将看到 Unity 编辑器。
- en: 'Next, we will remove Unity''s current folder setup and scene and replace it
    with our own by follow these steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将通过以下步骤移除 Unity 的当前文件夹设置和场景，并用我们自己的替换：
- en: In the `Scenes` folder and press delete on your keyboard.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scenes` 文件夹中，按键盘上的删除键。
- en: A window will appear asking to confirm deleting the scene.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 将出现一个窗口，要求确认删除场景。
- en: Click on **Delete**.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **删除**。
- en: At the top of the Unity Editor, select **File | Save As...**
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Unity 编辑器顶部，选择 **文件 | 另存为...**
- en: Be sure your project is being saved in your project's `Assets` folder.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保您的项目正在保存到您的项目 `Assets` 文件夹中。
- en: Name the scene `testLevel`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将场景命名为 `testLevel`。
- en: Click on **Save.**
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **保存**。
- en: Let's now go in a little deeper and check our account to find out more information
    about our project by using the Unity Dashboard.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们深入一点，通过使用Unity Dashboard检查我们的账户，以了解更多关于我们项目的信息。
- en: The dashboard
  id: totrans-303
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仪表板
- en: 'With your Unity account, you have access to more information about your account
    and other services, such as **Cloud Build**. In a potential exam question, you
    may be asked what and where the dashboard is and where you would find details
    about your projects. Here is how you access the dashboard:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 使用您的Unity账户，您可以访问有关账户和其他服务（如**Cloud Build**）的更多信息。在可能的考试问题中，您可能会被问及仪表板是什么以及您在哪里可以找到有关项目的详细信息。以下是您如何访问仪表板的方法：
- en: 'Click on the **Dashboard** link in the top-right corner of the **Services**
    window:'
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**服务**窗口右上角的**Dashboard**链接：
- en: '![Figure 1.20 – Location of the Dashboard link'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: '![图1.20 – Dashboard链接的位置'
- en: '](img/Figure_1.20_B18381.jpg)'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 1.20 – Dashboard链接的位置](img/Figure_1.20_B18381.jpg)'
- en: Figure 1.13 – Location of the Dashboard link
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.13 – Dashboard链接的位置
- en: 'Within the **Unity Dashboard** browser, you will be presented with a series
    of options and details specifically to do with Analytics (in [*Chapter 11*](B18381_11_Epub.xhtml#_idTextAnchor190),
    *Storing Data and Audio Mixer*, we discuss storing/manipulating online data),
    cloud building (briefly mentioned in the following information box), and more:'
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Unity Dashboard**浏览器中，您将看到一系列与Analytics（在[*第11章*](B18381_11_Epub.xhtml#_idTextAnchor190)，*存储数据与音频混音器*中讨论了存储/操作在线数据）、云构建（在以下信息框中简要提及）等相关的选项和详细信息：
- en: '![](img/Figure_1.21_B18381.jpg)'
  id: totrans-310
  prefs: []
  type: TYPE_IMG
  zh: '![图1.21_B18381.jpg](img/Figure_1.21_B18381.jpg)'
- en: Figure 1.14 – Unity Dashboard with Project Members highlighted
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 图1.14 – 突出显示项目成员的Unity Dashboard
- en: This is the Unity Dashboard where Unity has multiple services to help your game
    become more popular with your audience. We can monitor players' performance and
    look for any issues within our game. Without getting too distracted with the Unity
    dashboard as a whole, we are automatically loaded into our project (Killer Wave).
    Here, we can check useful things such as who is working on the project, and can
    add/remove members.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 这是Unity Dashboard，Unity在这里提供了多项服务，帮助您的游戏更受观众喜爱。我们可以监控玩家的表现，并查找游戏中的任何问题。不要被整个Unity仪表板分散注意力，我们自动加载到我们的项目（Killer
    Wave）中。在这里，我们可以检查一些有用的事情，例如谁在参与项目，并可以添加/删除成员。
- en: Cloud Build
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: Cloud Build
- en: Build your pushed projects online for multiple platforms (for example, Android,
    iOS, PC, and so on). This saves you and others in your team the hassle of switching
    platforms, building on a local machine, and waiting until you can start using
    your Unity project again. If developers in the same team are all building slightly
    different versions of the same build, this can be inefficient and cause issues.
    With Cloud Build, you are given a build number, which helps you keep tabs on the
    current version build.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 在线构建您推送的项目，适用于多个平台（例如，Android、iOS、PC等）。这为您和您的团队成员节省了切换平台、在本地机器上构建以及等待再次开始使用Unity项目的麻烦。如果同一团队的开发者都在构建同一构建的不同版本，这可能会效率低下并引发问题。使用Cloud
    Build，您将获得一个构建编号，这有助于您跟踪当前版本构建。
- en: Wow, we have covered a lot and it's only [*Chapter 1*](B18381_01_Epub.xhtml#_idTextAnchor016)!
    You have covered some of the most important stuff that isn't common knowledge
    when it comes to being a Unity developer. When I started as a developer, I thought
    it was just about getting cubes moving and jumping and firing other cubes and
    then prettying them up. In some ways, it is, but we need to make sure we avoid
    a lack of structure in Unity projects as things can fall apart quickly without
    it, especially when it comes to expanding a project. We will dig deeper into all
    of the things we have mentioned in this chapter, but for now, let's just recap
    what we have covered.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 哇，我们已经涵盖了这么多内容，但这只是[*第1章*](B18381_01_Epub.xhtml#_idTextAnchor016)！您已经覆盖了一些作为Unity开发者不常见的最重要内容。当我作为开发者开始时，我以为这仅仅是让立方体移动、跳跃、发射其他立方体以及使它们看起来更漂亮。在某种程度上，确实如此，但我们需要确保我们在Unity项目中避免缺乏结构，因为没有它，事情可能会迅速崩溃，尤其是在扩展项目时。我们将更深入地探讨本章中提到的所有内容，但现在，让我们先回顾一下我们已经覆盖的内容。
- en: Summary
  id: totrans-316
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you were introduced to the six core objectives of the exam.
    You may have skipped on to the final mock exam and scored well, and you may want
    to increase your score and carry on with the project that we are gearing ourselves
    up for. With regards to the project, we have an idea of a few design patterns
    that we can implement as the project goes on (such as **Singleton** for manager
    scripts) and these patterns will be built within the game framework. We know what
    the SOLID principles are, and we mustn't forget them as our project expands.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你被介绍了考试的六个核心目标。你可能已经跳到了最后的模拟考试并且取得了好成绩，你可能想要提高你的分数并继续我们正在准备的项目。关于项目，随着项目的进行，我们有一些设计模式的想法可以实施（例如，用于管理脚本的**单例模式**），这些模式将在游戏框架内构建。我们知道SOLID原则是什么，随着我们项目的扩展，我们不应该忘记它们。
- en: In the next chapter, we are going to start setting up our camera and light in
    the `testLevel` scene. We'll also bring in our player ship and hook it up with
    some controls so that we can move and shoot bullets. The first enemy will be imported
    with its own wave attack pattern. We will also be looking into what scriptable
    objects are and how they can benefit programmers and designers.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始设置`testLevel`场景中的相机和灯光。我们还将引入我们的玩家飞船，并将其与一些控制连接起来，以便我们可以移动和射击子弹。第一个敌人将带有自己的波浪攻击模式导入。我们还将研究可脚本化对象是什么以及它们如何为程序员和设计师带来好处。
