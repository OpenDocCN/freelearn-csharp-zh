- en: '17'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '17'
- en: Optimizing Unity UI
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化Unity UI
- en: '**Optimization** is the process that we use to make sure that our game runs
    smoothly and the framerate is consistent. Through optimization we first locate
    resources within our game that are reducing our game’s performance and then implement
    solutions that will improve that performance.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化**是我们用来确保游戏运行顺畅且帧率一致的过程。通过优化，我们首先定位到游戏中降低游戏性能的资源，然后实施解决方案以提升性能。'
- en: There are lots of things that can cause a game to have poor performance or low
    framerate. This can include things like unoptimized lighting, poorly written scripts,
    large assets, and improper UI construction. Since this is a UI book, we’ll focus
    only on how improving your UI construction can improve your performance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 有很多因素可能导致游戏性能不佳或帧率低。这包括诸如未优化的光照、编写不良的脚本、大型资源和不当的UI构建等问题。由于这是一本关于UI的书，我们将仅关注如何通过改进UI构建来提升性能。
- en: 'In this chapter, I will discuss the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我将讨论以下内容：
- en: Key terms and basic information related to optimization
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与优化相关的关键术语和基本信息
- en: An overview of the tools provided within unity that can help you determine how
    performant your game is
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity内提供的工具概述，这些工具可以帮助你确定你的游戏性能如何
- en: Various optimization strategies for UI
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: UI的各种优化策略
- en: Before you can optimize your UI, you need to learn how to tell if it is performant
    or not. Let’s review some basic terms and principles of graphics rendering.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在你能够优化UI之前，你需要学习如何判断它是否具有性能。让我们回顾一下图形渲染的基本术语和原则。
- en: Note
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This chapter will only cover performance profiling on a basic level and its
    focus will be more on things you can do to build better UI. If, by the end of
    the chapter, you’d like more information on performance profiling, I suggest the
    following resource: [https://unity.com/how-to/best-practices-for-profiling-game-performance#gpu-bound](https://unity.com/how-to/best-practices-for-profiling-game-performance#gpu-bound)'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将仅涵盖基本层面的性能分析，其重点将更多地放在你可以做的事情来构建更好的UI上。如果你在章节结束时想了解更多关于性能分析的信息，我建议以下资源：[https://unity.com/how-to/best-practices-for-profiling-game-performance#gpu-bound](https://unity.com/how-to/best-practices-for-profiling-game-performance#gpu-bound)
- en: Optimization basics
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化基础
- en: As I stated earlier, optimization is the process that we use to make sure that
    our application runs smoothly, and the framerate is consistent. We want to optimize
    our game to ensure that all players have the same experience regardless of the
    conditions in which they are playing. So, for example, if we are making a PC game,
    we want to make sure that every player has the same experience regardless of the
    power of their machine. We also want to make sure if a player has many things
    rendering on the screen, the game does not lag compared to when there were less
    things rendering on the screen.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如我之前所述，优化是我们用来确保应用程序运行顺畅、帧率一致的过程。我们希望优化我们的游戏，确保所有玩家无论在何种条件下玩游戏都能有相同的体验。例如，如果我们正在制作PC游戏，我们希望确保每个玩家无论其机器的功率如何，都能有相同的体验。我们还希望确保如果一个玩家在屏幕上渲染了很多东西，游戏与屏幕上渲染较少东西时的延迟相比不会变慢。
- en: We do not want the frame rate to reduce, and we do not want the inputs to lag.
    This is extremely important for things like games. In something like a first-person
    shooter or platform this could a lag in input could mean a player loses a match
    or falls off a cliff.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望帧率降低，也不希望输入延迟。这对像游戏这样的应用来说非常重要。在第一人称射击游戏或平台游戏中，输入延迟可能导致玩家输掉比赛或从悬崖上掉下来。
- en: Let’s review some basic terminology that you hear often when discussing optimization.
    First, we’ll start with a common metric for determining an application’s performance.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下在讨论优化时经常听到的基本术语。首先，我们将从确定应用程序性能的常用指标开始。
- en: Frame Rate
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 帧率
- en: '**Framerate** is one metric in which we measure our application’s optimization.
    It’s a good metric, because it’s not just something that is happening in the background
    that the user never notices. Users can see and notice changes in framerate, so
    measuring its performance measures how our users experience our games.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '**帧率**是我们衡量应用程序优化的一项指标。这是一个很好的指标，因为它不仅仅是用户在后台无法察觉的事情。用户可以看到并注意到帧率的变化，因此测量其性能可以衡量我们的用户是如何体验我们的游戏的。'
- en: Framerate can be measured in **frames per second** (**fps**) or time in milliseconds.
    The goal is to have a consistent framerate regardless of what is happening in
    the game.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 帧率可以用每秒帧数（**fps**）或毫秒时间来衡量。目标是无论游戏中的情况如何，都要保持一致的帧率。
- en: When measuring framerate in frames per second, each individual frame renders
    out in a certain amount of time. Let’s say you have a goal of 60 fps. You would
    need to make sure that all aspects of your application can run at 60 fps. So,
    your goal is to have a consistent number of frames per second. Therefore, when
    we set a fps benchmark, that means we want our application to run at that fps
    consistently across all parts of the application. We don’t want our game to run
    at 60 fps at the beginning and then dip when our UI opens.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 当以每秒帧数来测量帧率时，每个单独的帧都会在特定的时间内渲染出来。假设你的目标是60 fps。你需要确保应用程序的各个方面都能以60 fps运行。因此，你的目标是每秒保持一致的帧数。因此，当我们设置fps基准时，这意味着我们希望应用程序在整个应用程序的所有部分都能以该fps持续运行。我们不希望我们的游戏在开始时以60
    fps运行，然后在UI打开时下降。
- en: Another way to measure framerate is time in milliseconds. Every frame takes
    some amount of time to render. We want that amount of time to be as low as possible
    for each frame. 10 ms per frame is the equivalent of 60 fps and is a good time
    in milliseconds.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 测量帧率的另一种方式是毫秒时间。每个帧都需要一定的时间来渲染。我们希望每个帧的渲染时间尽可能低。每帧10毫秒相当于60 fps，这是一个很好的毫秒时间。
- en: Now that we’ve discussed what frame rate is, let’s talk about where resources
    are used on our computer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 既然我们已经讨论了帧率是什么，那么让我们来谈谈资源在我们的计算机上是如何被使用的。
- en: GPU and CPU
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: GPU和CPU
- en: When trying to optimize your game, you will investigate your game’s resources
    to determine where the most resources are being used. You will want to identify
    whether the issues are on the GPU or CPU. The **Central Processing Unit** (**CPU**)
    is the brain of the computer. The **Graphics Processing Unit** (**GPU**), is what
    renders images. Whether our resources are on the GPU or CPU will determine the
    optimization solution.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试优化你的游戏时，你将调查游戏资源以确定资源使用最多的地方。你将想要确定问题是在GPU还是CPU上。**中央处理单元**（**CPU**）是计算机的大脑。**图形处理单元**（**GPU**）是渲染图像的部分。我们的资源是在GPU还是CPU上，这将决定优化解决方案。
- en: Examples of problems on the CPU are too many instructions, meaning too many
    scripts are running or the scripts take too long to run. Problems with the GPU
    tend to mean too many things are being rendered. The CPU does still play a part
    in rendering, however, as the CPU gives out the instructions and tells the GPU
    what to render. Often when discussing GPU and CPU, you’ll hear the term **draw
    calls**. A draw call is when the CPU tells the GPU it needs to draw (or display)
    something on the screen. In general, you want to reduce the number of draw calls
    your game makes.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: CPU上的问题示例包括指令过多，意味着运行了太多的脚本或者脚本运行时间过长。GPU的问题通常意味着渲染了太多的东西。然而，CPU在渲染中仍然扮演着一定的角色，因为CPU给出指令并告诉GPU要渲染什么。通常在讨论GPU和CPU时，你会听到**draw
    calls**这个术语。draw call是指CPU告诉GPU需要在屏幕上绘制（或显示）某物。一般来说，你希望减少游戏产生的draw call数量。
- en: We’ll discuss GPU and CPU and how various choices we make designing our UI are
    affected by GPU and CPU more thoroughly in future sections of this chapter.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后续部分更深入地讨论GPU和CPU，以及我们在设计UI时所做的各种选择如何受到GPU和CPU的影响。
- en: Now that we’ve covered some basic concepts of optimization, let’s review some
    tools provided by Unity that help us with optimization.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了一些优化基本概念，让我们回顾一下Unity提供的有助于优化的工具。
- en: Tools for determining performance
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能测定工具
- en: When determining your game’s performance, you may use what is called benchmarking.
    **Benchmarking** allows you to see how well your app is running at various times
    under given conditions. When benchmarking, you collect performance metrics and
    establish a baseline, or benchmark metric. You then compare subsequent results
    to that benchmark to see if the metric has improved or worsened. This lets you
    know if changes you have made have affected your game’s performance.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定游戏性能时，你可以使用所谓的基准测试。**基准测试**允许你在给定条件下查看应用程序在不同时间运行得如何。在基准测试中，你收集性能指标并建立基准，或基准指标。然后，你将后续结果与该基准进行比较，以查看指标是否有所改善或恶化。这让你知道你所做的更改是否影响了游戏性能。
- en: There are a few tools provided by Unity that can help you assess the performance
    of your game by providing you performance metrics. Let’s look at those tools now.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了一些工具，可以帮助您通过提供性能指标来评估游戏性能。现在让我们看看这些工具。
- en: Note
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Be aware of the environment and what you are benchmarking. It’s recommended
    that you benchmark on your target platform. That way you can determine the minimum
    standard device you plan to run your game on. The performance of your game will
    only get better with a better device.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意环境以及您正在基准测试的内容。建议您在目标平台上进行基准测试。这样，您可以确定您计划在哪个最低标准设备上运行游戏。随着设备的升级，您游戏的性能将得到提升。
- en: Statistics window
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 统计窗口
- en: One simple way to view the performance of your game is through the **Statistics**
    window (or **Stats** windows) of the **Game** view.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 查看您游戏性能的一个简单方法是通过**游戏**视图中的**统计**窗口（或**Stats**窗口）。
- en: '![Figure 17.1: Analyzing the Stats Window](img/B18327_17_01.jpg)'
  id: totrans-33
  prefs: []
  type: TYPE_IMG
  zh: '![图17.1：分析统计窗口](img/B18327_17_01.jpg)'
- en: 'Figure 17.1: Analyzing the Stats Window'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.1：分析统计窗口
- en: If you select the **Stats** button in the top right corner of your **Game**
    view, you’ll see various information about your project. Under the **Graphics**
    section, you’ll see frame rate in both frames per second and time in milliseconds.
    This will continuously change as it is based on each frame. You also see information
    about the CPU main thread and render thread.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在**游戏**视图的右上角选择**Stats**按钮，您将看到有关项目的一些信息。在**图形**部分，您将看到每秒帧数和以毫秒为单位的时间。这将根据每一帧持续变化。您还可以看到关于CPU主线程和渲染线程的信息。
- en: If you’re using frame rate as your benchmark, you can watch the framerate values
    here and see how they change over time. Remember, the goal is consistency.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以帧率作为基准，您可以在此处查看帧率值，并查看它们随时间的变化。记住，目标是保持一致性。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about the stats window, here: [https://learn.unity.com/tutorial/working-with-the-stats-window-2019-3?uv=2019.4#](https://learn.unity.com/tutorial/working-with-the-stats-window-2019-3?uv=2019.4#)'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于统计窗口的信息：[https://learn.unity.com/tutorial/working-with-the-stats-window-2019-3?uv=2019.4#](https://learn.unity.com/tutorial/working-with-the-stats-window-2019-3?uv=2019.4#)
- en: The **Stats** window gives some at a glance basic information about your game’s
    performance. However, if you want a more in-depth breakdown of how your game is
    running, you can use the Unity Profiler.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '**统计**窗口提供了关于您游戏性能的一些直观的基本信息。然而，如果您想深入了解游戏运行情况，可以使用Unity Profiler。'
- en: Unity Profiler
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity Profiler
- en: The Profiler shows you detailed information about your game’s performance. To
    view the Profiler, select **Window** | **Analysis** | **Profiler**. When you play
    the game, you can then see which items are responsible for performance issues.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: Profiler显示了您游戏性能的详细信息。要查看Profiler，请选择**窗口** | **分析** | **Profiler**。当您玩游戏时，您可以看到哪些项目导致了性能问题。
- en: '![Figure 17.2: Viewing the Unity Profiler](img/B18327_17_02.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图17.2：查看Unity Profiler](img/B18327_17_02.jpg)'
- en: 'Figure 17.2: Viewing the Unity Profiler'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.2：查看Unity Profiler
- en: Within the **Profiler**, you can select the UI Modules only to narrow down how
    each of your individual UI elements are affecting your performance.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Profiler**中，您可以选择仅UI模块，以缩小每个UI元素对性能的影响。
- en: '![Figure 17.3: Enabling only the UI Profiler Modules](img/B18327_17_03.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图17.3：仅启用UI Profiler模块](img/B18327_17_03.jpg)'
- en: 'Figure 17.3: Enabling only the UI Profiler Modules'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.3：仅启用UI Profiler模块
- en: After doing so, you can see information about each individual Canvas.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些操作后，您可以看到每个Canvas的信息。
- en: '![Figure 17.4: Observing the UI Objects in the Profiler](img/B18327_17_04.jpg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![图17.4：在Profiler中观察UI对象](img/B18327_17_04.jpg)'
- en: 'Figure 17.4: Observing the UI Objects in the Profiler'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.4：在Profiler中观察UI对象
- en: Note
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about the Unity Profiler and how to use it here: [https://docs.unity3d.com/Manual/Profiler.xhtml](https://docs.unity3d.com/Manual/Profiler.xhtml)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于Unity Profiler及其使用方法：[https://docs.unity3d.com/Manual/Profiler.xhtml](https://docs.unity3d.com/Manual/Profiler.xhtml)
- en: If you’re interested in how items in your game are being batched, you can use
    the Unity Frame Debugger.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您对游戏中物品的批处理方式感兴趣，可以使用Unity Frame Debugger。
- en: Unity Frame Debugger
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity Frame Debugger
- en: The Frame Debugger can help you troubleshoot batching issues with your UI. You
    can access the Frame Debugger via **Window** | **Analysis** | **Frame Debugger**.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: Frame Debugger可以帮助您解决UI的批处理问题。您可以通过**窗口** | **分析** | **Frame Debugger**访问Frame
    Debugger。
- en: '![Figure 17.5: Reviewing the Frame Debugger](img/B18327_17_05.jpg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![图17.5：审查帧调试器](img/B18327_17_05.jpg)'
- en: 'Figure 17.5: Reviewing the Frame Debugger'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图17.5：审查帧调试器
- en: Enabling the Frame Debugger will allow you to see various rendering events.
    Clicking on them will step forward in the Game window, giving you a preview of
    the event. This will show you which items are being combined into batches.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 启用帧调试器将允许您查看各种渲染事件。点击它们将在游戏窗口中前进，为您提供事件的预览。这将显示哪些项目被组合到批次中。
- en: Note
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can learn more about the Frame Debugger here: [https://docs.unity3d.com/Manual/frame-debugger-window.xhtml](https://docs.unity3d.com/Manual/frame-debugger-window.xhtml)'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在此处了解更多关于帧调试器的信息：[https://docs.unity3d.com/Manual/frame-debugger-window.xhtml](https://docs.unity3d.com/Manual/frame-debugger-window.xhtml)
- en: Now that we’ve discussed the basics of optimization, we can start talking about
    ways to optimize your UI.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经讨论了优化的基础知识，我们可以开始讨论优化UI的方法。
- en: Basic Unity UI Optimization Strategies
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本的Unity UI优化策略
- en: Remember, each Canvas has its own Canvas Renderer component. Canvases combine
    all their elements into batches that are rendered together. A Canvas is considered
    **dirty**, if its geometry needs to be rebuilt. One of the main goals of optimizing
    UI is to reduce the number of times a Canvas or its elements are considered dirty,
    to reduce the number of times that the Canvas needs to be rebatched. With that
    in mind, let’s look at some techniques for optimizing Unity UI.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，每个画布都有自己的画布渲染器组件。画布将所有元素组合成一起渲染的批次。如果一个画布的几何形状需要重建，则该画布被认为是**脏的**。优化UI的主要目标之一是减少画布或其元素被认为是脏的次数，以减少画布需要重新批次的次数。考虑到这一点，让我们看看一些优化Unity
    UI的技术。
- en: Using multiple Canvases and Canvas Hierarchies
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用多个画布和画布层次结构
- en: Whenever an element on a Canvas is modified, the Canvas is considered dirty,
    and a draw call is sent to the GPU. If there are multiple items on the Canvas,
    all the items on the Canvas will need to be reanalyzed to determine how best they
    should be drawn. So, changing one element on the Canvas requires the CPU to rebuild
    every element on the Canvas, potentially causing a sudden surge in CPU usage.
    Due to this, you should put your UI on multiple Canvases.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每当画布上的一个元素被修改时，画布被认为是脏的，并且会向GPU发送一个绘制调用。如果画布上有多个项目，所有画布上的项目都需要重新分析，以确定它们应该如何最好地绘制。因此，修改画布上的一个元素需要CPU重建画布上的每个元素，这可能会导致CPU使用量突然增加。因此，你应该将UI放在多个画布上。
- en: When determining how to group your Canvases, consider how often the items on
    the Canvas will need to be changed. It is good practice to group all static UI
    element on separate Canvases from items that are dynamic. This will stop the static
    items from having to be redrawn whenever the dynamic items change. Additionally,
    split dynamic elements into Canvases based on when they will update, trying to
    keep ones that update at the same time together.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在确定如何分组您的画布时，考虑画布上的项目需要更改的频率。将所有静态UI元素分组到与动态项目分开的单独画布上是一种良好的做法。这将阻止静态元素在动态元素更改时需要重新绘制。此外，根据它们将何时更新，将动态元素拆分到画布中，尽量将同时更新的元素放在一起。
- en: Other aspects to consider when attempting to reduce draw calls on Canvases are
    the elements z-coordinates, textures, and materials. Grouping UI elements based
    on these properties can also reduce your CPU usage with regards to UI.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在尝试减少画布上的绘制调用时，还需要考虑元素的z坐标、纹理和材质。根据这些属性对UI元素进行分组也可以减少与UI相关的CPU使用量。
- en: Minimizing the use of Layout Groups
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 最小化使用布局组
- en: '`GetComponent` for each parent object that has a Layout Groups. This makes
    nested Layout Groups very non-performant.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetComponent`用于每个具有布局组的父对象。这使得嵌套布局组非常低效。'
- en: To avoid this, you could simply not use Layout Groups. Instead, you could use
    Anchors and write your own layout code for dynamically placing items.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种情况，您可以直接不使用布局组。相反，您可以使用锚点并编写自己的布局代码来动态放置项目。
- en: Avoiding them entirely isn’t necessarily the best solution for everyone, however,
    so if you do choose to use them, try to avoid nested Layout Groups or layout groups
    with very large amounts of children. You can also choose to use layout groups
    for dynamic elements only and avoid them with static elements. You can also disable
    them as soon as dynamic UI has been properly positioned.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 完全避免它们并不一定是每个人的最佳解决方案，因此，如果你选择使用它们，尽量避免嵌套布局组或具有大量子项的布局组。你也可以选择只为动态元素使用布局组，并避免使用静态元素。你还可以在动态UI正确定位后立即禁用它们。
- en: Hiding objects appropriately
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适当地隐藏对象
- en: If you want to hide elements on a Canvas, it is best to disable the entire Canvas
    component if possible. Remember, the Canvas component is what renders the UI,
    so disabling the Canvas component will cause it to stop rendering. It is recommended
    you disable the Canvas component rather than simply changing the visibility of
    the Canvas, because the Canvas component will continue to make draw calls, even
    if it is not visible. Disabling the component does not cause the Canvas to rebuild.
    This is less expensive than enabling and disabling the Canvas GameObject, as that
    will trigger the `OnEnable` and `OnDisable` methods.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在画布上隐藏元素，如果可能的话，最好禁用整个画布组件。记住，画布组件是渲染UI的部分，因此禁用画布组件会导致它停止渲染。建议你禁用画布组件，而不是简单地改变画布的可见性，因为即使画布不可见，它也会继续进行绘制调用。禁用组件不会导致画布重建。这比启用和禁用画布GameObject更节省资源，因为这将触发`OnEnable`和`OnDisable`方法。
- en: If you want to hide everything in your game with UI, for example you have a
    pause menu that completely covers your screen, you should stop the camera from
    rendering anything in your game other than the UI. For example, if you have a
    menu that completely covers the screen, even though you cannot see the items behind
    the menu, they are still being rendered.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要隐藏游戏中带有UI的所有内容，例如你有一个完全覆盖屏幕的暂停菜单，你应该停止相机渲染游戏中的任何内容，除了UI。例如，如果你有一个完全覆盖屏幕的菜单，即使你看不到菜单后面的项目，它们仍然被渲染。
- en: Appropriately time object pooling enabling and disabling
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适当地安排对象池的启用和禁用
- en: '**Object pooling** is an optimization technique used to reduce the number of
    times repeatable objects are created (or instantiated). When object pooling, you
    place a collection of disabled objects in a pool at the start of the game and
    then, rather that instantiating those objects while the game is playing, you pull
    them from the pool.'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '**对象池**是一种优化技术，用于减少可重复使用对象创建（或实例化）的次数。在对象池中，你会在游戏开始时将一组禁用对象放置在池中，然后，而不是在游戏进行时实例化这些对象，你从池中取出它们。'
- en: Object pooling is a great way to improve the performance of your game, because
    it reduces the number of times an object has to be created by creating a collection
    of objects that can be reused.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对象池是提高游戏性能的绝佳方式，因为它通过创建可以重复使用的对象集合来减少对象必须创建的次数。
- en: Note
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'For more information on the concept of object pooling, visit the following
    site: [https://learn.unity.com/tutorial/introduction-to-object-pooling](https://learn.unity.com/tutorial/introduction-to-object-pooling)'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 有关对象池概念的更多信息，请访问以下网站：[https://learn.unity.com/tutorial/introduction-to-object-pooling](https://learn.unity.com/tutorial/introduction-to-object-pooling)
- en: Because reparenting UI objects causes a Canvas to be marked as dirty, you want
    to carefully time your disabling, enabling, and reparenting when using an object
    pool. Since dynamic changes to elements within a Canvas cause the Canvas to send
    a draw call to the GPU, inappropriately parenting items before or after disabling
    them, can double up your draw calls unnecessarily. The goal, is to not cause the
    objects in the pool to send any draw calls to the GPU. So, objects in the pool
    should only ever be parented to the pool in a disabled state.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 由于重新父化UI对象会导致画布被标记为脏，因此在使用对象池时，你需要仔细安排禁用、启用和重新父化的时间。由于Canvas内部元素的动态更改会导致Canvas向GPU发送绘制调用，因此在禁用它们之前或之后不适当地父化项目，可能会不必要地加倍你的绘制调用。目标是确保池中的对象不会向GPU发送任何绘制调用。因此，池中的对象应该始终以禁用状态附加到池中。
- en: If you are placing an object in an object pool, disable it, then reparent it
    into the pool. By making sure it is disabled before being placed in the pool,
    you will remove the need for the pool to need rebuilding. Conversely, if you want
    to remove an object from the pool, reparent it, then enable it. This too will
    remove the need for the pool to send a draw call.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你将对象放入对象池中，请先禁用它，然后将其重新父级到池中。通过确保在放入池之前将其禁用，你可以消除池需要重建的需求。相反，如果你想从池中移除对象，请先重新父级，然后启用它。这同样可以消除池发送绘制调用的需求。
- en: Reducing Raycast computations
  id: totrans-81
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 减少射线路径计算
- en: Every UI Image component has the property **Raycast Target**. By default, this
    is selected. If you do not wish for your UI element to block raycasts, disable
    this to reduce raycasting checks.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 UI Image 组件都有 **射线路径目标** 属性。默认情况下，这是选中的。如果你不希望你的 UI 元素阻止射线路径，请禁用它以减少射线路径检查。
- en: '![Figure 17.6: The Raycast Target property](img/B18327_17_06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.6：射线路径目标属性](img/B18327_17_06.jpg)'
- en: 'Figure 17.6: The Raycast Target property'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.6：射线路径目标属性
- en: Additionally, if your UI is not interactable at all, you can remove the Graphic
    Raycaster component to remove the unnecessary calculation it causes.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你的 UI 完全不可交互，你可以移除 Graphic Raycaster 组件，以消除它引起的非必要计算。
- en: '![Figure 17.7: The Graphic Raycaster component](img/B18327_17_07.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 17.7：图形射线路径组件](img/B18327_17_07.jpg)'
- en: 'Figure 17.7: The Graphic Raycaster component'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 17.7：图形射线路径组件
- en: Using the basic Unity UI optimization strategies covered in this chapter will
    have you well on your way to creating UI that does not inversely affect the performance
    of your game.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 使用本章中介绍的基本 Unity UI 优化策略，将使你能够创建不会反向影响游戏性能的 UI。
- en: Summary
  id: totrans-89
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we discussed the basics of optimizing Unity UI. We reviewed
    some fundamental concepts of optimizing in Unity, looked at the tools that allow
    us to assess our game’s performance, and then discussed strategies for creating
    performant UI.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们讨论了优化 Unity UI 的基础知识。我们回顾了 Unity 优化的一些基本概念，查看允许我们评估游戏性能的工具，然后讨论了创建高性能
    UI 的策略。
- en: Note
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'This chapter focused only on how to improve the performance of your game through
    UI. But remember there are multiple aspects of your game that can cause it to
    have performance issues. For a good resource on improving the performance of all
    aspects of your game, I suggest reviewing the free ebook provided by unity on
    optimization: [https://resources.unity.com/games/performance-optimization-e-book-console-pc](https://resources.unity.com/games/performance-optimization-e-book-console-pc)'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 本章仅关注如何通过 UI 提高游戏性能。但请记住，你的游戏有多个方面可能导致性能问题。为了获得关于提高游戏所有方面性能的良好资源，我建议查看 Unity
    提供的免费电子书：[https://resources.unity.com/games/performance-optimization-e-book-console-pc](https://resources.unity.com/games/performance-optimization-e-book-console-pc)
- en: In the next chapter, we’ll talk about a new UI system created by unity called
    the new unity UI toolkit. It can be used to create UI not only during runtime
    but also within the editor. Thus, it can be used to help you create tools to improve
    your workflow.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将讨论由 Unity 创建的新 UI 系统，称为新的 Unity UI 工具包。它不仅可以在运行时创建 UI，还可以在编辑器中创建。因此，它可以用来帮助你创建工具以改进你的工作流程。
- en: Further reading
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'For more information on optimizing UI, I recommend the following resources:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 关于优化 UI 的更多信息，我推荐以下资源：
- en: '[https://learn.unity.com/tutorial/optimizing-unity-ui#](https://learn.unity.com/tutorial/optimizing-unity-ui#)'
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://learn.unity.com/tutorial/optimizing-unity-ui#](https://learn.unity.com/tutorial/optimizing-unity-ui#)'
- en: '[https://unity.com/how-to/unity-ui-optimization-tips](https://unity.com/how-to/unity-ui-optimization-tips)'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://unity.com/how-to/unity-ui-optimization-tips](https://unity.com/how-to/unity-ui-optimization-tips)'
- en: '[https://www.youtube.com/watch?v=FPotgj_NHK4](https://www.youtube.com/watch?v=FPotgj_NHK4)'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://www.youtube.com/watch?v=FPotgj_NHK4](https://www.youtube.com/watch?v=FPotgj_NHK4)'
