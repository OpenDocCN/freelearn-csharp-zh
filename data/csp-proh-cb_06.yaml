- en: Chapter 6. Making Apps Responsive with Asynchronous Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 6 章。使用异步编程使应用程序响应
- en: 'This chapter will introduce you to asynchronous programming. This chapter will
    cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将向您介绍异步编程。本章将涵盖以下食谱：
- en: Return types of asynchronous functions
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步函数的返回类型
- en: Handling tasks in asynchronous programming
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程中的任务处理
- en: Exception handling in asynchronous programming
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 异步编程中的异常处理
- en: Introduction
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Asynchronous programming is an exciting feature in C#. It allows you to continue
    program execution on the main thread while a long-running task runs in its own
    thread separately from the main thread. When this long-running task is complete,
    it will let the main thread know that it has completed (or failed). The benefit
    of asynchronous programming is that it improves the responsiveness of your application.
    The best way to learn and understand asynchronous programming is to experience
    it. The following recipes will illustrate some of the basics to you.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程是 C# 中的一项激动人心的特性。它允许你在主线程上继续程序执行的同时，一个长时间运行的任务在其自己的线程中单独运行，与主线程分开。当这个长时间运行的任务完成时，它会通知主线程它已经完成（或失败）。异步编程的好处是它提高了应用程序的响应性。了解和掌握异步编程的最佳方式是亲身体验。以下食谱将向您展示一些基本概念。
- en: Return types of asynchronous functions
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步函数的返回类型
- en: 'In asynchronous programming, the `async` methods can have three possible return
    types. These are:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在异步编程中，`async` 方法可以有三种可能的返回类型。这些是：
- en: '`void`'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`void`'
- en: '`Task`'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task`'
- en: '`Task<TResult>`'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Task<TResult>`'
- en: We will have a look at each return type in the following recipe.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在接下来的食谱中查看每种返回类型。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: What could be the use of a `void` return type in asynchronous methods? Generally,
    `void` is used with event handlers. Just bear in mind that `void` returns nothing,
    so you can't wait for it. Therefore, if you call a `void` return type asynchronous
    method, your calling code should be able to continue executing code without having
    to wait for the asynchronous method to complete.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 异步方法中 `void` 返回类型有什么用？通常，`void` 与事件处理器一起使用。请记住，`void` 不返回任何内容，因此您不能等待它。因此，如果您调用返回类型为
    `void` 的异步方法，您的调用代码应该能够在不需要等待异步方法完成的情况下继续执行代码。
- en: With asynchronous methods that have a return type of `Task`, you can utilize
    the `await` operator to pause the execution of the current thread until the called
    asynchronous method has completed. Keep in mind that an asynchronous method that
    returns a type of `Task` basically does not return an operand. Therefore, if it
    was written as a synchronous method, it would be a `void` return type method.
    This statement might be confusing, but it will become clear in the following recipes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于返回类型为 `Task` 的异步方法，您可以使用 `await` 操作符暂停当前线程的执行，直到被调用的异步方法完成。请记住，返回类型为 `Task`
    的异步方法基本上不返回操作数。因此，如果它被编写为同步方法，它将是一个 `void` 返回类型的方法。这个声明可能有些令人困惑，但在接下来的食谱中会变得清晰。
- en: Finally, asynchronous methods that have a `return` statement have a return type
    of `TResult`. In other words, if the asynchronous method returns a Boolean, you
    would create an asynchronous method with a return type of `Task<bool>`.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，具有 `return` 语句的异步方法具有 `TResult` 返回类型。换句话说，如果异步方法返回布尔值，您将创建一个返回类型为 `Task<bool>`
    的异步方法。
- en: Let's start with the `void` return type asynchronous method.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从返回类型为 `void` 的异步方法开始。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Create a new class library by right-clicking on your solution and selecting
    **Add** and then **New Project** from the context menu:![How to do it…](img/B05391_06_01.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过右键单击您的解决方案并从上下文菜单中选择 **添加**，然后选择 **新建项目** 来创建一个新的类库：![如何操作…](img/B05391_06_01.jpg)
- en: From the **Add New Project** dialog screen, select **Class Library** from the
    installed templates and call your class `Chapter6`:![How to do it…](img/B05391_06_02.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **新建项目** 对话框屏幕上，从已安装的模板中选择 **类库**，并将您的类命名为 `Chapter6`：![如何操作…](img/B05391_06_02.jpg)
- en: Your new class library will be added to your solution with a default name of
    `Class1.cs`, which we renamed to `Recipes.cs` in order to distinguish the code
    properly. You can, however, rename your class to whatever you like, if it makes
    more sense to you.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的新类库将以默认名称 `Class1.cs` 添加到您的解决方案中，我们将它重命名为 `Recipes.cs` 以便正确地区分代码。然而，如果您觉得更合适，您可以将您的类重命名为任何您喜欢的名称。
- en: To rename your class, simply click on the class name in **Solution Explorer**
    and select **Rename** from the context menu:![How to do it…](img/B05391_06_03.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重命名您的类，只需在 **解决方案资源管理器** 中单击类名，并从上下文菜单中选择 **重命名**：![如何操作…](img/B05391_06_03.jpg)
- en: Visual Studio will ask you to confirm the new names of all references to the
    code element **Class1** in the project. Just click on **Yes**:![How to do it…](img/B05391_06_04.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio 将要求您确认项目中所有对代码元素 **Class1** 的引用的新名称。只需点击 **是**：![如何操作…](img/B05391_06_04.jpg)
- en: The next step is to add another new project. Right-click on the solution and
    select **Add** and then **New Project** from the context menu:![How to do it…](img/B05391_06_05.jpg)
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是添加另一个新项目。在解决方案上右键单击，并从上下文菜单中选择 **添加**，然后选择 **新项目**：![如何操作…](img/B05391_06_05.jpg)
- en: This time, you will be creating a new Windows Forms application for your solution.
    We need to do this so that we can create a button click event. We called our project
    `winformAsync`:![How to do it…](img/B05391_06_06.jpg)
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这次，您将为您的解决方案创建一个新的 Windows Forms 应用程序。我们需要这样做，以便我们可以创建一个按钮点击事件。我们称我们的项目为 `winformAsync`：![如何操作…](img/B05391_06_06.jpg)
- en: Your **Solution Explorer** will now look similar to the following screenshot,
    with the Winforms application added:![How to do it…](img/B05391_06_07.jpg)
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 您的 **解决方案资源管理器** 现在将类似于以下截图，其中添加了 Winforms 应用程序：![如何操作…](img/B05391_06_07.jpg)
- en: After you have added your Winforms application, add a reference to the `Chapter6`
    class you created earlier. To do this, right-click on **References** under the
    **winformAsync** project and click on the **Add Reference** menu item from the
    context menu:![How to do it…](img/B05391_06_10.jpg)
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您添加了 Winforms 应用程序后，添加对您之前创建的 `Chapter6` 类的引用。为此，在 **winformAsync** 项目的 **引用**
    下右键单击，并从上下文菜单中选择 **添加引用** 菜单项：![如何操作…](img/B05391_06_10.jpg)
- en: From the **Reference Manager** screen, select the `Chapter6` class, which is
    found under the **Projects** | **Solution** node in the tree view to the left.
    Then, click on the **OK** button:![How to do it…](img/B05391_06_11.jpg)
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **引用管理器** 屏幕中，选择位于左侧树视图中的 **项目** | **解决方案** 节点下的 `Chapter6` 类，然后单击 **确定**
    按钮：![如何操作…](img/B05391_06_11.jpg)
- en: Another important step is to set the **winformAsync** project as the startup
    project in the solution. To do this, right-click the **winformAsync** project
    and select the **Set as StartUp Project** menu item from the context menu:![How
    to do it…](img/B05391_06_12.jpg)
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一个重要步骤是将 **winformAsync** 项目设置为解决方案中的启动项目。为此，右键单击 **winformAsync** 项目，并从上下文菜单中选择
    **设置为启动项目** 菜单项：![如何操作…](img/B05391_06_12.jpg)
- en: On the **winformAsync** form designer, open **Toolbox** and select the **Button**
    control, which is found under the **All Windows Forms** node:![How to do it…](img/B05391_06_08.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **winformAsync** 表单设计器中，打开 **工具箱** 并选择位于 **所有 Windows Forms** 节点下的 **按钮**
    控件：![如何操作…](img/B05391_06_08.jpg)
- en: Drag the button control onto the **Form1** designer:![How to do it…](img/B05391_06_09.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮控件拖放到 **Form1** 设计器中：![如何操作…](img/B05391_06_09.jpg)
- en: 'With the button control selected, double-click on the control to create the
    click event in the code behind. Visual Studio will insert the event code for you:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择了按钮控件后，双击控件以在代码后面创建点击事件。Visual Studio 将为您插入事件代码：
- en: '[PRE0]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Change the `button1_Click` event and add the `async` keyword to the click event.
    This is an example of a `void` returning an asynchronous method:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改 `button1_Click` 事件并添加 `async` 关键字到点击事件。这是一个返回 `void` 的异步方法的示例：
- en: '[PRE1]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `Chapter6` class library, add a new class called `AsyncDemo`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Chapter6` 类库中，添加一个名为 `AsyncDemo` 的新类：
- en: '[PRE2]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next method to add to the `AsyncDemo` class is the asynchronous method
    that returns `TResult` (in this case, a Boolean). This method simply checks whether
    the current year is a leap year. It then returns a Boolean to the calling code:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要添加到 `AsyncDemo` 类的下一个方法是返回 `TResult`（在这种情况下，一个布尔值）的异步方法。此方法简单地检查当前年份是否为闰年，然后向调用代码返回一个布尔值：
- en: '[PRE3]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The next method to add is the `void` returning method that returns a `Task`
    type so that it allows you to await the method. The method itself does not return
    any result, making it a `void` returning method. However, in order to use the
    `await` keyword, you return the `Task` type from this asynchronous method:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个要添加的方法是返回 `Task` 类型的 `void` 返回方法，这样它允许您等待方法。该方法本身不返回任何结果，因此它是一个返回 `void`
    的方法。然而，为了使用 `await` 关键字，您需要从此异步方法返回 `Task` 类型：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, add a method that will call the previous asynchronous methods and
    display the result of the leap year check. You will notice that we are using the
    `await` keyword with both method calls:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，添加一个方法来调用前面的异步方法并显示闰年检查的结果。您会注意到我们在两个方法调用中都使用了`await`关键字：
- en: '[PRE5]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the button click, add the following code that calls the long-running task
    asynchronously:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮点击中，添加以下代码以异步调用长时间运行的任务：
- en: '[PRE6]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Running your application will display the Windows Forms application:![How to
    do it…](img/B05391_06_13.jpg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序将显示Windows窗体应用程序：![如何操作…](img/B05391_06_13.jpg)
- en: Before clicking on the **button1** button, ensure that the **Output** window
    is visible:![How to do it…](img/B05391_06_14.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击**button1**按钮之前，确保**输出**窗口是可见的：![如何操作…](img/B05391_06_14.jpg)
- en: From the **View** menu, click on the **Output** menu item or type *Ctrl* + *Alt*
    + *O* to display the **Output** window. This will allow us to see the `Console.Writeline()`
    outputs as we have added them to the code in the `Chapter6` class and in the Windows
    application.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**视图**菜单中，点击**输出**菜单项或按*Ctrl* + *Alt* + *O*显示**输出**窗口。这将允许我们看到`Console.Writeline()`输出，因为我们已经将它们添加到`Chapter6`类和Windows应用程序中的代码中。
- en: Clicking on the **button1** button will display the outputs to our **Output**
    window. Throughout this code execution, the form remains responsive:![How to do
    it…](img/B05391_06_15.jpg)
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**button1**按钮将在我们的**输出**窗口中显示输出。在整个代码执行过程中，窗体保持响应：![如何操作…](img/B05391_06_15.jpg)
- en: 'Finally, you can also use the `await` operator in separate calls. Modify the
    code in the `LongTask()` method as follows:'
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，您还可以在单独的调用中使用`await`运算符。按照以下方式修改`LongTask()`方法中的代码：
- en: '[PRE7]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: How it works…
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In the preceding code, we have seen the `void` returning type asynchronous method
    that was used in the `button1_Click` event. We also created a `Task` returning
    method that returns nothing (that would be a `void` if used in synchronous programming),
    but returning `Task` type allows us to await the method. Finally, we created a
    `Task<TResult>` returning method that performs some task and returns the result
    to the calling code.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，我们看到了在`button1_Click`事件中使用的返回`void`类型的异步方法。我们还创建了一个返回`Task`类型的方法，该方法不返回任何内容（如果用于同步编程，则将是`void`），但返回`Task`类型允许我们等待该方法。最后，我们创建了一个返回`Task<TResult>`类型的方法，它执行一些任务并将结果返回给调用代码。
- en: Handling tasks in asynchronous programming
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程中的任务处理
- en: '**Task-Based Asynchronous Pattern** (**TAP**) is now the recommended method
    to create asynchronous code. It executes asynchronously on a thread from the thread
    pool and does not execute synchronously on the main thread of your application.
    It allows us to check the task''s state by calling the `Status` property.'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '**基于任务的异步模式**（**TAP**）现在是创建异步代码的推荐方法。它在一个线程池的线程上异步执行，而不会在您应用程序的主线程上同步执行。它允许我们通过调用`Status`属性来检查任务的状态。'
- en: Getting ready
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a task to read a very large text file. This will be accomplished
    using an asynchronous `Task`.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个任务来读取一个非常大的文本文件。这将通过异步的`Task`来完成。
- en: How to do it…
  id: totrans-58
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Create a large text file (we called ours `taskFile.txt`) and place it in your
    `C:\temp` folder:![How to do it…](img/B05391_06_16.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个大的文本文件（我们将其命名为`taskFile.txt`），并将其放置在您的`C:\temp`文件夹中：![如何操作…](img/B05391_06_16.jpg)
- en: 'In the `AsyncDemo` class, create a method called `ReadBigFile()` that returns
    a `Task<TResult>` type, which will be used to return an integer of bytes read
    from our big text file:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AsyncDemo`类中，创建一个名为`ReadBigFile()`的方法，该方法返回`Task<TResult>`类型，它将用于返回从我们的大文本文件中读取的字节数：
- en: '[PRE8]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add the following code to open and read the file bytes. You will see that we
    are using the `ReadAsync()` method that asynchronously reads a sequence of bytes
    from the stream and advances the position in that stream by the number of bytes
    read from that stream. You will also notice that we are using a buffer to read
    those bytes:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到打开和读取文件字节的操作中。您将看到我们正在使用`ReadAsync()`方法，该方法异步地从流中读取一系列字节，并通过从该流中读取的字节数在流中前进位置。您还会注意到我们正在使用一个缓冲区来读取这些字节：
- en: '[PRE9]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Exceptions you can expect to handle from the `ReadAsync()` method are `ArgumentNullException`,
    `ArgumentOutOfRangeException`, `ArgumentException`, `NotSupportedException`, `ObjectDisposedException`
    and `InvalidOperatorException`.
  id: totrans-65
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 您可能需要处理的`ReadAsync()`方法异常包括`ArgumentNullException`、`ArgumentOutOfRangeException`、`ArgumentException`、`NotSupportedException`、`ObjectDisposedException`和`InvalidOperatorException`。
- en: 'Finally, add the final section of code just after the `var readBytes = bigFile.ReadAsync(bigFileBuffer,
    0, (int)bigFile.Length);` line that uses a lambda expression to specify the work
    that the task needs to perform. In this case, it is to read the bytes in the file:'
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`var readBytes = bigFile.ReadAsync(bigFileBuffer, 0, (int)bigFile.Length);`行之后立即添加代码的最后一部分，该部分使用lambda表达式来指定任务需要执行的工作。在这种情况下，是要读取文件中的字节：
- en: '[PRE10]'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: If not done so in the previous recipe, add a button to your Windows Forms application's
    Forms Designer. On the **winformAsync** form designer, open **Toolbox** and select
    the **Button** control, which is found under the **All Windows Forms** node:![How
    to do it…](img/B05391_06_08.jpg)
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在之前的菜谱中没有这样做，请将按钮添加到Windows窗体应用程序的窗体设计器中。在**winformAsync**窗体设计器中，打开**工具箱**并选择**按钮**控件，该控件位于**所有Windows窗体**节点下：![如何操作…](img/B05391_06_08.jpg)
- en: Drag the button control onto the **Form1** designer:![How to do it…](img/B05391_06_09.jpg)
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮控件拖放到**Form1**设计器中：![如何操作…](img/B05391_06_09.jpg)
- en: 'With the button control selected, double-click the control to create the click
    event in the code behind. Visual Studio will insert the event code for you:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择按钮控件后，双击控件以在代码后创建点击事件。Visual Studio将为您插入事件代码：
- en: '[PRE11]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Change the `button1_Click` event and add the `async` keyword to the click event.
    This is an example of a `void` returning an asynchronous method:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`button1_Click`事件并给点击事件添加`async`关键字。这是一个返回`void`的异步方法的示例：
- en: '[PRE12]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Now, make sure that you add code to call the `AsyncDemo` class''s `ReadBigFile()`
    method asynchronously. Remember to read the result from the method (which are
    the bytes read) into an integer variable:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，请确保您添加代码以异步调用`AsyncDemo`类的`ReadBigFile()`方法。请记住将方法的结果（即读取的字节）读取到整数变量中：
- en: '[PRE13]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Running your application will display the Windows Forms application:![How to
    do it…](img/B05391_06_13.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序将显示Windows窗体应用程序：![如何操作…](img/B05391_06_13.jpg)
- en: Before clicking on the **button1** button, ensure that the **Output** window
    is visible:![How to do it…](img/B05391_06_14.jpg)
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击**button1**按钮之前，请确保**输出**窗口是可见的：![如何操作…](img/B05391_06_14.jpg)
- en: From the **View** menu, click on the **Output** menu item or type *Ctrl* + *Alt*
    + *O* to display the **Output** window. This will allow us to see the `Console.Writeline()`
    outputs as we have added them to the code in the `Chapter6` class and in the Windows
    application.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**视图**菜单中，点击**输出**菜单项或按*Ctrl* + *Alt* + *O*显示**输出**窗口。这将允许我们看到在`Chapter6`类和Windows应用程序中添加的`Console.Writeline()`输出。
- en: Clicking on the **button1** button will display the outputs in our **Output**
    window. Throughout this code execution, the form remains responsive:![How to do
    it…](img/B05391_06_17.jpg)
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**button1**按钮将在我们的**输出**窗口中显示输出。在整个代码执行过程中，窗体保持响应：![如何操作…](img/B05391_06_17.jpg)
- en: Note
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Take note though that the information displayed in your **Output** window will
    differ from the screenshot. This is because the file you used is different from
    mine.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，显示在您的**输出**窗口中的信息将与截图不同。这是因为您使用的文件与我的不同。
- en: How it works…
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The task is executed on a separate thread from the thread pool. This allows
    the application to remain responsive while the large file is being processed.
    Tasks can be used in multiple ways to improve your code. This recipe is but one
    example.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 任务在单独的线程池线程上执行。这允许在处理大文件时应用程序保持响应。可以通过多种方式使用任务来改进您的代码。这个菜谱只是其中的一个例子。
- en: Exception handling in asynchronous programming
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程中的异常处理
- en: Exception handling in asynchronous programming has always been a challenge.
    This was especially true in the catch blocks. As of C# 6, you are now allowed
    to write asynchronous code inside the `catch` and `finally` block of your exception
    handlers.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 异步编程中的异常处理一直是一个挑战。这在捕获块中尤其如此。从C# 6开始，你现在可以在异常处理程序的`catch`和`finally`块中编写异步代码。
- en: Getting ready
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: The application will simulate the action of reading a logfile. Assume that a
    third-party system always makes a backup of the logfile before processing it in
    another application. While this processing is happening, the logfile is deleted
    and recreated. Our application, however, needs to read this logfile on a periodic
    basis. We, therefore, need to be prepared for the case where the file does not
    exist in the location we expect it in. Therefore, we will purposely omit the main
    logfile, so that we can force an error.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将模拟读取日志文件的动作。假设第三方系统在另一个应用程序中处理日志文件之前，总是先备份日志文件。当这个处理正在进行时，日志文件被删除并重新创建。然而，我们的应用程序需要定期读取这个日志文件。因此，我们需要准备好文件可能不在我们预期的位置的情况。因此，我们将故意省略主日志文件，以便我们可以强制产生错误。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Create a text file and two folders to contain the logfiles. We will, however,
    only create a single logfile in the `BackupLog` folder. The `MainLog` folder will
    remain empty:![How to do it…](img/B05391_06_18.jpg)
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个文本文件和两个文件夹来包含日志文件。然而，我们将在`BackupLog`文件夹中只创建一个日志文件。`MainLog`文件夹将保持为空：![如何操作…](img/B05391_06_18.jpg)
- en: 'In our `AsyncDemo` class, write a method to read the main logfile in the `MainLog`
    folder:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们的`AsyncDemo`类中，编写一个方法来读取`MainLog`文件夹中的主日志文件：
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Create a second method to read the backup file in the `BackupLog` folder:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`BackupLog`文件夹中创建一个读取备份文件的第二个方法：
- en: '[PRE15]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-94
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In actual fact, we would probably only create a single method to read the logfiles,
    passing only the path as a parameter. In a production application, creating a
    class and overriding a method to read the different logfile locations would be
    a better approach. For the purposes of this recipe, however, we specifically wanted
    to create two separate methods so that the different calls to the asynchronous
    methods are clearly visible in the code.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 实际上，我们可能只会创建一个方法来读取日志文件，只传递路径作为参数。在生产应用程序中，创建一个类并重写方法来读取不同的日志文件位置会是一个更好的方法。然而，对于本配方，我们特别希望创建两个独立的方法，以便在代码中清楚地看到对异步方法的调用。
- en: 'We will then create a main `ReadLogFile()` method that tries to read the main
    logfile. As we have not created the logfile in the `MainLog` folder, the code
    will throw a `FileNotFoundException`. It will then run the asynchronous method
    and await that in the `catch` block of the `ReadLogFile()` method (something that
    was impossible in the previous versions of C#), returning the bytes read to the
    calling code:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个主要的`ReadLogFile()`方法，尝试读取主日志文件。由于我们尚未在`MainLog`文件夹中创建日志文件，代码将抛出`FileNotFoundException`。然后，它将在`ReadLogFile()`方法的`catch`块中运行异步方法并等待（这是在C#的先前版本中不可能做到的），将读取的字节返回给调用代码：
- en: '[PRE16]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If not done so in the previous recipe, add a button to your Windows Forms application's
    Forms Designer. On the **winformAsync** Forms Designer, open **Toolbox** and select
    the **Button** control, which is found under the **All Windows Forms** node:![How
    to do it…](img/B05391_06_08.jpg)
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果在先前的配方中没有这样做，请将按钮添加到Windows Forms应用程序的窗体设计器中。在**winformAsync**窗体设计器中打开**工具箱**并选择**按钮**控件，该控件位于**所有Windows窗体**节点下：![如何操作…](img/B05391_06_08.jpg)
- en: Drag the button control onto the **Form1** designer:![How to do it…](img/B05391_06_09.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将按钮控件拖动到**Form1**设计器上：![如何操作…](img/B05391_06_09.jpg)
- en: 'With the button control selected, double-click on the control to create the
    click event in the code behind. Visual Studio will insert the event code for you:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择按钮控件后，双击控件以在代码后创建点击事件。Visual Studio将为您插入事件代码：
- en: '[PRE17]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Change the `button1_Click` event and add the `async` keyword to the click event.
    This is an example of a `void` returning an asynchronous method:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改`button1_Click`事件并给点击事件添加`async`关键字。这是一个返回`void`的异步方法的示例：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we will write the code to create a new instance of the `AsyncDemo` class
    and attempt to read the main logfile. In a real-world example, it is at this point
    that the code does not know that the main logfile does not exist:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将编写代码来创建`AsyncDemo`类的新实例并尝试读取主日志文件。在现实世界的例子中，代码在这个时候并不知道主日志文件不存在：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Running your application will display the Windows Forms application:![How to
    do it…](img/B05391_06_13.jpg)
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的应用程序将显示Windows窗体应用程序：![如何操作…](img/B05391_06_13.jpg)
- en: Before clicking on the **button1** button, ensure that the **Output** window
    is visible:![How to do it…](img/B05391_06_14.jpg)
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在点击**button1**按钮之前，确保**输出**窗口是可见的：![如何操作…](img/B05391_06_14.jpg)
- en: From the **View** menu, click on the **Output** menu item or type *Ctrl* + *Alt*
    + *O* to display the **Output** window. This will allow us to see the `Console.Writeline()`
    outputs as we have added them to the code in the `Chapter6` class and in the Windows
    application.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**视图**菜单中，点击**输出**菜单项或按*Ctrl* + *Alt* + *O*键以显示**输出**窗口。这将允许我们看到`Console.Writeline()`的输出，因为我们已经将它们添加到了`Chapter6`类和Windows应用程序中的代码。
- en: To simulate a file not found exception, we deleted the file from the `MainLog`
    folder. You will see that the exception is thrown, and the `catch` block runs
    the code to read the backup logfile instead:![How to do it…](img/B05391_06_19.jpg)
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了模拟文件未找到异常，我们从`MainLog`文件夹中删除了文件。您将看到异常被抛出，并且`catch`块运行了读取备份日志文件的代码：![如何操作…](img/B05391_06_19.jpg)
- en: How it works…
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: The fact that we can await in `catch` and `finally` blocks allows developers
    much more flexibility, because asynchronous results can consistently be awaited
    throughout the application. As you can see from the code we wrote, as soon as
    the exception was thrown, we asynchronously read the file read method for the
    backup file.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在`catch`和`finally`块中等待的事实，为开发者提供了更多的灵活性，因为异步结果可以在整个应用程序中一致地等待。正如您从我们编写的代码中可以看到的，一旦异常被抛出，我们就异步地读取了备份文件的读取方法。
