- en: '6'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Implementing Interfaces and Inheriting Classes
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is about deriving new types from existing ones using **object-oriented
    programming** (**OOP**). You will learn how to use operators as an alternative
    method to implement simple functionality, and you will learn how to use generics
    to make your code safer and more performant. You will learn about delegates and
    events to exchange messages between types. You will implement interfaces for common
    functionality. You will create a derived class to inherit from a base class to
    reuse functionality, override an inherited type member, and use polymorphism.
    Finally, you will learn how to create extension methods and cast between classes
    in an inheritance hierarchy.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: In an online-only section, you will see the differences between reference and
    value types and how they are stored in memory. You will find links to online materials
    at the end of this chapter.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a class library and console application
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Static methods and overloading operators
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making types safely reusable with generics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Raising and handling events
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing interfaces
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with `null` values
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting from classes
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Casting within inheritance hierarchies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting and extending .NET types
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Summarizing custom type choices
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up a class library and console application
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will start by defining a solution with two projects, like the one created
    in *Chapter 5*, *Building Your Own Types with Object-Oriented Programming*. Even
    if you completed all the exercises in that chapter, follow the instructions below
    so that you start this chapter with fresh working projects:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
- en: 'Use your preferred code editor to create a new project, as defined in the following
    list:'
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Class Library** / `classlib`'
  id: totrans-18
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `PacktLibrary`'
  id: totrans-19
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter06`'
  id: totrans-20
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Framework: .NET 9.0 (Standard-Term Support)'
  id: totrans-21
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Add a new project, as defined in the following list:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Project template: **Console App** / `console`'
  id: totrans-23
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Project file and folder: `PeopleApp`'
  id: totrans-24
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Solution file and folder: `Chapter06`'
  id: totrans-25
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Framework: .NET 9.0 (Standard-Term Support)'
  id: totrans-26
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Do not use top-level statements: Cleared'
  id: totrans-27
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Enable native AOT publish: Cleared'
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, both projects target .NET 9 and, therefore, use the C# 13 compiler
    by default.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, rename the file named `Class1.cs` to `Person.cs`.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In both projects, add `<ItemGroup>` to globally and statically import the `System.Console`
    class, as shown in the following markup:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In `Person.cs`, delete any existing statements and define a `Person` class,
    as shown in the following code:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'In the `PeopleApp` project, add a project reference to `PacktLibrary`, as shown
    in the following markup:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'In `Program.cs`, delete the existing statements, write statements to create
    an instance of `Person`, and then write information about it to the console, as
    shown in the following code:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: If you use Visual Studio, configure the startup project for the solution as
    the current selection.
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and note the result, as shown in the following
    output:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Static methods and overloading operators
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is specifically about methods that apply to two instances of the
    same type. It is not about the more general case of methods that apply to zero,
    one, or more than two instances. Remember that static methods do not require an
    object instance. They are called directly using the class name.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: I wanted to think of some methods that would apply to two `Person` instances
    that could also become binary operators, like `+` and `*`. What would adding two
    people together represent? What would multiplying two people represent? The obvious
    answers are getting married and having babies.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
- en: 'We will design our methods to enable us to model the story of Lamech and his
    two wives and their children, as described at the following link:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.kingjamesbibleonline.org/Genesis-4-19/](https://www.kingjamesbibleonline.org/Genesis-4-19/)'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: We might want two instances of `Person` to be able to marry and procreate. We
    can implement this by writing methods and overriding operators. Instance methods
    are actions that an object does to itself; static methods are actions the type
    does.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: Which you choose depends on what makes the most sense for the action.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Having both static and instance methods to perform similar
    actions often makes sense. For example, `string` has both a `Compare` static method
    and a `CompareTo` instance method. This puts the choice of how to use the functionality
    in the hands of the programmers using your type, giving them more flexibility.'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: Implementing functionality using methods
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s start by implementing some functionality by using both static and instance
    methods:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add properties with private backing storage fields to indicate
    if that person is married and to whom, as shown in the following code:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In `Person.cs`, add one instance method and one static method that will allow
    two `Person` objects to marry, as shown in the following code:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Note the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: In the `static` method, the `Person` objects are passed as parameters named
    `p1` and `p2`, and guard clauses are used to check for `null` values. If either
    is already married to the other, an exception is thrown; otherwise, they are each
    added to each other’s list of spouses. You can model this differently if you want
    to allow two people to have multiple marriage ceremonies. In that case, you might
    choose to not throw an exception and instead do nothing. Their state of marriage
    would remain the same. Additional calls to `Marry` would not change if they are
    married or not. In this scenario, I want you to see that the code recognizes that
    they are already married by throwing an exception.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the instance method, a call is made to the `static` method, passing the current
    person (`this`) and the `partner` they want to marry.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning!** Although instance methods can call static methods, the opposite
    is not true. A static method cannot call an instance method because there isn’t
    an object instance to call it on.'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add an instance method to the `Person` class that will output
    the spouses of a person if they are married, as shown in the following code:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In `Person.cs`, add one instance method and one static method to the `Person`
    class that will allow two `Person` objects to procreate if they are married to
    each other, as shown in the following code:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-63
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Note the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: In the `static` method named `Procreate`, the `Person` objects that will procreate
    are passed as parameters named `p1` and `p2`.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A new `Person` class named `baby` is created with a name composed of a combination
    of the two people who have procreated. This could be changed later by setting
    the returned `baby` variable’s `Name` property. Although we could add a third
    parameter to the `Procreate` method for the baby name, we will define a binary
    operator later, and they cannot have third parameters. So, for consistency, we
    will just return the baby reference and let the calling code set the name of it.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `baby` object is added to the `Children` collection of both parents and
    then returned. Classes are reference types, meaning a reference to the `baby`
    object stored in memory is added, not a clone of the `baby` object.
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the instance method named `ProcreateWith`, the `Person` object to procreate
    with is passed as a parameter named `partner`, and that, along with `this`, which
    represents the current object, is passed to the static `Procreate` method to reuse
    the method implementation. `this` is a keyword that references the current instance
    of the class. It is a convention to use different method names for related static
    and instance methods, but not to the extent that you would fail to match standard
    English meaning.
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, that could mean naming both methods the same, as in the example of `Marry(x,
    y)` for the static method name and `x.Marry(y)` for the instance method name.
    More commonly, it would mean using a different method name, for example, `Procreate(x,
    y)` for the static method name and `x.ProcreateWith(y)` for the instance method
    name, or `Compare(x, y)` for the static method name and `x.CompareTo(y)` for the
    instance method name.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: A method that creates a new object, or modifies an existing
    object, should return a reference to that object so that the caller can access
    the results.'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '5\. In `Program.cs`, create three people and have them marry and then procreate
    with each other, noting that to add a double-quote character into a `string`,
    you must prefix it with a backslash character like this, `\"`, as shown in the
    following code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I used a `for` instead of a `foreach` statement so that I could use the `i`
    variable with the indexer to access each child.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
- en: '6\. Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: As you have just seen, for functionality that applies to two instances of an
    object type, it is easy to provide both static and instance methods to implement
    the same functionality. Neither static nor instance methods are best in all scenarios,
    and you cannot predict how your type might be used. It is best to provide both
    to allow a developer to use your types in the way that best fits their needs.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s see how we can add a third way to provide the same functionality for
    two instances of a type.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: Implementing functionality using operators
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `System.String` class has a `static` method named `Concat` that concatenates
    two `string` values and returns the result, as shown in the following code:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Calling a method like `Concat` works, but it might be more natural for a programmer
    to use the `+` symbol operator to “add” two `string` values together, as shown
    in the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: A well-known biblical phrase is *Go forth and multiply*, meaning to procreate.
    Let’s write code so that the `*` (multiply) symbol will allow two `Person` objects
    to procreate. And we will use the `+` operator to marry two people.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: 'We do this by defining a `static` operator for the `*` symbol. The syntax is
    rather like a method, because in effect, an operator *is* a method, but it uses
    a symbol instead of a method name, which makes the syntax more concise:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, create a `static` operator for the `+` symbol, as shown in
    the following code:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-86
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The return type for an operator does not need to match the types passed as parameters
    to the operator, but the return type cannot be `void`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, create a `static` operator for the `*` symbol, as shown in
    the following code:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '**Good Practice**: Unlike methods, operators do not appear in IntelliSense
    lists for a type or a type instance when you enter a dot (`.`). For every operator
    that you define, make a method as well, because it may not be obvious to a programmer
    that the operator is available. The implementation of the operator can then call
    the method, reusing the code you have written. A second reason to provide a method
    is that operators are not supported by every language compiler; for example, although
    arithmetic operators like `*` are supported by Visual Basic and F#, there is no
    requirement that other languages support all operators supported by C#. You have
    to read the type definition or the documentation to discover whether operators
    are implemented.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, comment out the statement that calls the static `Marry` method
    to marry Zillah and Lamech, and replace it with an `if` statement that uses the
    `+` operator to marry them, as shown in the following code:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In `Program.cs`, after calling the `Procreate` method and before the statements
    that write the children to the console, use the `*` operator for Lamech to have
    two more babies with his wives, Adah and Zillah, as highlighted in the following
    code:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '**More Information**: To learn more about operator overloading, you can read
    the documentation at the following link:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/operators/operator-overloading)'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
- en: Making types safely reusable with generics
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In 2005, with C# 2 and .NET Framework 2, Microsoft introduced a feature named
    **generics**, which enables your types to be more safely reusable and efficient.
    It does this by allowing a programmer to pass types as parameters, like how you
    can pass objects as parameters.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
- en: This topic is only about types that need to provide flexibility for the types
    they work with. For example, collection types need to be able to store multiple
    instances of any type. That flexibility can be provided either by using the `System.Object`
    type or generics. For other scenarios that do not need type flexibility, the use
    of non-generic types is good practice.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Working with non-generic types
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, let’s look at an example of working with a non-generic type so that you
    can understand the problems that generics are designed to solve, such as weakly
    typed parameters and values, and performance problems caused by using `System.Object`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Collections.Hashtable` can be used to store multiple key-value pairs,
    each with a unique key that can later be used to quickly look up its value. Both
    the key and value can be any object because they are declared as `System.Object`.
    Although this provides flexibility, it is slow, and bugs are easier to introduce
    because no type checks are made when adding items.'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, create an instance of the non-generic collection, `System.Collections.Hashtable`,
    and then add four items to it, as shown in the following code:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Note that three items have a unique integer key to look them up. The last item
    has a `Person` object as its key to look it up. This is valid in a non-generic
    collection.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to define a `key` with the value of `2` and use it to look up
    its value in the *hash* table, as shown in the following code:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Add statements to use the `harry` object to look up its value, as shown in
    the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Run the `PeopleApp` project and note that it works, as shown in the following
    output:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Although the code works, there is potential for mistakes because literally any
    type can be used for the key or value. If another developer used your variable
    named `lookupObject` and expected all the items to be a certain type, they might
    cast them to that type and get exceptions because some values might be a different
    type. A lookup object with lots of items would also give poor performance.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Avoid types in the `System.Collections` namespace. Use types
    in the `System.Collections.Generics` and related namespaces instead. If you need
    to use a library that uses non-generic types, then of course you will have to
    use non-generic types. This is an example of what is commonly referred to as technical
    debt.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
- en: Working with generic types
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`System.Collections.Generic.Dictionary<TKey, TValue>` can be used to store
    multiple values, each with a unique key that can later be used to quickly look
    up its value. Both the key and value can be any object, but you must tell the
    compiler what the types of the key and value will be when you first instantiate
    the collection. You do this by specifying types for the **generic parameters**
    in angle brackets `<>`, `TKey`, and `TValue`.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: When a generic type has one definable type, it should be
    named `T`, for example, `List<T>`, where `T` is the type stored in the list. When
    a generic type has multiple definable types, it should use `T` as a name prefix
    and have a sensible name, for example, `Dictionary<TKey, TValue>`.'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: Generics provides flexibility, is faster, and makes bugs easier to avoid because
    type checks are made when adding items at compile time. We will not need to explicitly
    specify the `System.Collections.Generic` namespace that contains `Dictionary<TKey,
    TValue>` because it is implicitly and globally imported by default.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code to solve the problem by using generics:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, create an instance of the generic lookup collection `Dictionary<TKey,
    TValue>` and then add four items to it, as shown in the following code:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Note the compile error when using `harry` as a key, as shown in the following
    output:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Replace `harry` with `4`.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to set the `key` to `3`, and use it to look up its value in
    the dictionary, as shown in the following code:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Run the `PeopleApp` project and note that it works, as shown in the following
    output:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: You have now seen the difference between non-generic and generic types that
    need the flexibility to store any type. You know to always use generic collection
    types if possible. Unless you are unlucky enough to be forced to use a legacy
    non-generic library, you never need to write code that uses non-generic types
    that can store any type again.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: Just because it is good practice to use generic collection types in preference
    to non-generic collection types does not mean the more general case is also true.
    Non-generic non-collection types and other types that do not need the flexibility
    to work with any type are used all the time. Collection types just happen to be
    the most common type that benefits from generics.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Raising and handling events
  id: totrans-133
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Methods are often described as *actions that an object can perform, either on
    itself or on related objects*. For example, `List<T>` can add an item to itself
    or clear itself, and `File` can create or delete a file in the filesystem.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: Events are often described as *actions that happen to an object*. For example,
    in a user interface, `Button` has a `Click` event, a click being something that
    happens to a button. Also, `FileSystemWatcher` listens to the filesystem for change
    notifications and raises events like `Created` and `Deleted`, which are triggered
    when a directory or file changes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: Another way to think of events is that they provide a way of exchanging messages
    between objects.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: Events are built on **delegates**, so let’s start by having a look at what delegates
    are and how they work.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Calling methods using delegates
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You have already seen the most common way to call or execute a method: using
    the `.` operator to access the method using its name. For example, `Console.WriteLine`
    tells the `Console` type to call its `WriteLine` method.'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: The other way to call or execute a method is to use a delegate. If you have
    used languages that support **function pointers**, then think of a delegate as
    being a **type-safe method pointer**.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: In other words, a delegate contains the memory address of a method that must
    match the same signature as the delegate, enabling it to be called safely with
    the correct parameter types.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: The code in this section is illustrative and not meant to be typed into a project.
    You will explore code like this in the next section, so for now, just read the
    code and try to understand its meaning.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, imagine there is a method in the `Person` class that must have
    a `string` type passed as its only parameter, and it returns an `int` type, as
    shown in the following code:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'I can call this method on an instance of `Person` named `p1` like this:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Alternatively, I can define a delegate with a matching signature to call the
    method indirectly. Note that the names of the parameters do not have to match.
    Only the types of parameters and return values must match, as shown in the following
    code:'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '**Good Practice**: A `delegate` is a reference type like a `class`, so if you
    define one in `Program.cs`, then it must be at the bottom of the file. It would
    be best to define it in its own class file, for example, `Program.Delegates.cs`.
    If you defined a delegate in the middle of `Program.cs`, then you would see the
    following compiler error: `CS8803: Top-level statements must precede namespace
    and type declarations`.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, I can create an instance of the delegate, point it at the method, and
    finally, call the delegate (which calls the method), as shown in the following
    code:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Examples of delegate use
  id: totrans-152
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You are probably thinking, *“What’s the point of that?”*
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: It provides flexibility. For example, we could use delegates to create a queue
    of methods that need to be called in order. Queuing actions that need to be performed
    is common in services to provide improved scalability.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Another example is to allow multiple actions to execute in parallel. Delegates
    have built-in support for asynchronous operations that run on a different thread,
    which can provide improved responsiveness.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: The most important example is that delegates allow us to implement events to
    send messages between different objects that do not need to know about each other.
    Events are an example of loose coupling between components because they do not
    need to know about each other; they just need to know the event signature.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: 'Status: It’s complicated'
  id: totrans-157
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Delegates and events are two of the most confusing features of C# and can take
    a few attempts to understand, so don’t worry if you feel lost as we walk through
    how they work! Move on to other topics and come back again another day when your
    brain has had the opportunity to process the concepts while you sleep.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Defining and handling delegates
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Microsoft has two predefined delegates for use as events. They both have two
    parameters:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: '`object? sender`: This parameter is a reference to the object raising the event
    or sending the message. The `?` indicates that this reference could be `null`.'
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventArgs e` or `TEventArgs e`: This parameter contains additional relevant
    information about the event. For example, in a GUI app, you might define `MouseMoveEventArgs`,
    which has properties for the `X` and `Y` coordinates for the mouse pointer. A
    bank account might have a `WithdrawEventArgs` with a property for the `Amount`
    to withdraw.'
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Their signatures are simple, yet flexible, as shown in the following code:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '**Good Practice**: When you want to define an event in your own type, you should
    use one of these two predefined delegates.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: 'Some types provide “empty” values for when you need an instance, but it doesn’t
    need to have any particular value. For example:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
- en: '`string.Empty` is an empty string value `""`. It is better to use `string.Empty`
    than `""` because every time you use `""` the compiler must instantiate a new
    empty string instance. You can think of `string.Empty` as a global single instance
    of an empty string. Sharing it is more efficient than creating your own new instances
    every time you need to reference an empty string value.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventArgs.Empty` is an empty `EventArgs` value. Use it when you must conform
    to the built-in event delegates that require an `EventArgs` instance to be passed
    as a parameter, but it doesn’t need any particular value because it won’t be read
    or used in the method anyway.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You might have a delegate defined, as shown in the following code:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In that case, there are multiple ways to call the delegate, as shown in the
    following code examples:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
- en: 'Use its variable name, `Shout`:'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE32]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Use its `Invoke` method to call it synchronously:'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE33]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Use its `BeginInvoke` method to call it asynchronously, without a callback
    function or any state:'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE34]'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: The `BeginInvoke` method is beyond the scope of this book, but I have included
    it so that you know it exists.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: 'Delegates and their method handlers have a potentially many-to-many relationship.
    One delegate can have one method handler. But one delegate can also have many
    method handlers (you will do this when you hook up `Shout` to both `Harry_Shout`
    and `Harry_Shout_2`). And many delegates can reference one method handler, or
    any combination of these. Let’s explore delegates and events:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to the `Person` class and note the following points, as shown
    in the following code:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It defines an `EventHandler` delegate field named `Shout`.
  id: totrans-181
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines an `int` field to store `AngerLevel`.
  id: totrans-182
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It defines a method named `Poke`.
  id: totrans-183
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Each time a person is poked, their `AngerLevel` increments. Once their `AngerLevel`
    reaches three, they raise the `Shout` event, but only if there is at least one
    event delegate pointing at a method defined somewhere else in the code; that is,
    it is not `null`:'
  id: totrans-184
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE35]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Checking whether an object is not `null` before calling one of its methods
    is very common. C# 6 and later allow `null` checks to be simplified inline using
    a `?` symbol before the `.` operator, as shown in the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: '`Shout?.Invoke(this, EventArgs.Empty);`'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
- en: In the `PeopleApp` project, add a new class file named `Program.EventHandlers.cs`.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.EventHandlers.cs`, delete any existing statements, and then add
    a method with a matching signature that gets a reference to the `Person` object
    from the `sender` parameter and outputs some information about them, as shown
    in the following code:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '**Good Practice**: Microsoft’s convention for method names that handle events
    is `ObjectName_EventName`. In this project, `sender` will always be a `Person`
    instance, so the `null` checks are not necessary, and the event handler could
    be much simpler with just the `WriteLine` statement. However, it is important
    to know that these types of `null` checks make your code more robust in cases
    of event misuse.'
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can have as many methods as you like to be event handlers, named whatever
    you like, as long as the method signature matches the delegate signature. This
    means you could have 50 `Person` instances, each with their own method, or have
    one method that they all share. The methods can be declared at any level that
    makes sense for the scenario and matches the access levels set (like `protected`,
    `private`, `public`, and so on). One of the key benefits of delegates and events
    is loose binding between components so maximum flexibility is desired.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to assign the method to the delegate field,
    and then add statements to call the `Poke` method four times, as shown in the
    following code:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Run the `PeopleApp` project and view the result. Note that Harry says nothing
    the first two times he is poked, and only gets angry enough to shout once he’s
    been poked at least three times, as shown in the following output:'
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  id: totrans-196
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In Step 3, note that the `sender` is checked to make sure it is a `Person`
    instance, and if it is, then it is assigned to a local variable named `p`, as
    shown in the following code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The first statement does two things at once, which needs more explanation. The
    parameter named `sender` is declared to be of type `object`. This means we cannot
    just say `sender.Name` or `sender.AngerLevel`. We need to cast `sender` to a local
    variable that is explicitly defined as `Person`. We also need to check that `sender`
    actually is a `Person`.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do both things at once in a single expression: `sender is not Person
    p`. This expression will return `true` if `sender` is not a `Person`, and hence
    the statement executes `return` so the method immediately returns. Or the expression
    returns `false` if `sender` is a `Person`, and sender will be stored in the local
    variable named `p`, which is of type `Person`. After that, we can use expressions
    like `p.Name` and `p.AngerLevel`.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
- en: Defining and handling events
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You’ve now seen how delegates implement the most important functionality of
    events: the ability to define a signature for a method that can be implemented
    by a completely different piece of code, calling that method and any others that
    are hooked up to the delegate field.'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
- en: But what about events? There is less to them than you might think.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
- en: When assigning a method to a delegate field, you should not use the simple assignment
    operator as we did in the preceding example.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
- en: Delegates are multicast, meaning that you can assign multiple delegates to a
    single delegate field. Instead of the `=` assignment, we could have used the `+=`
    operator so that we could add more methods to the same delegate field. When the
    delegate is called, all the assigned methods are called, although you have no
    control over the order in which they are called. Do not use events to implement
    a queuing system to buy concert tickets; otherwise, the wrath of millions of Swifties
    will fall upon you.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: 'If the `Shout` delegate field already referenced one or more methods, by assigning
    another method, that method would replace all the others. With delegates that
    are used for events, we usually want to make sure that a programmer only ever
    uses either the `+=` operator or the `-=` operator to assign and remove methods:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
- en: 'To enforce this, in `Person.cs`, add the `event` keyword to the delegate field
    declaration, as highlighted in the following code:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Build the `PeopleApp` project and note the compiler error message, as shown
    in the following output:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: This is (almost) all that the `event` keyword does! If you will never have more
    than one method assigned to a delegate field, then technically you do not need
    events, but it is still good practice to indicate your meaning and that you expect
    a delegate field to be used as an event.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, modify the comment and the method assignment to use `+=` instead
    of just `=`, as highlighted in the following code:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Run the `PeopleApp` project and note that it has the same behavior as before.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.EventHandlers.cs`, create a second event handler for Harry’s `Shout`
    event, as shown in the following code:'
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In `Program.cs`, after the statement that assigns the `Harry_Shout` method
    to the `Shout` event, add a statement to attach the new event handler to the `Shout`
    event too, as shown highlighted in the following code:'
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'Run the `PeopleApp` project, view the result. Note that both event handlers
    execute whenever an event is raised, which only happens once the anger level is
    three or more, as shown in the following output:'
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In Windows desktop development, imagine that you have three buttons: `AddButton`,
    `SaveButton`, and `DeleteButton`. Each button has very different functionality.
    Good practice would be to create three methods to handle their `Click` events,
    named `AddButton_Click`, `SaveButton_Click`, and `DeleteButton_Click`. Each would
    have a different implementation code.'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: 'But now, imagine you have 26 buttons: `AButton`, `BButton`, `CButton`, and
    so on, up to `ZButton`. Each button has the same functionality: to filter a list
    of people by the first letter of their name. Good practice would be to create
    one method to handle their `Click` events, perhaps named `AtoZButtons_Click`.
    This method would have an implementation code that would use the `sender` parameter
    to know which button was clicked, and therefore how to apply the filtering, but
    otherwise be the same for all the buttons.'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
- en: That’s it for events. Now, let’s look at interfaces.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: Implementing interfaces
  id: totrans-224
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Interfaces are a way to implement standard functionality and connect different
    types to make new things. Think of them like the studs on top of LEGO™ bricks,
    which allow them to “stick” together, or electrical standards for plugs and sockets.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: If a type implements an interface, then it makes a promise to the rest of .NET
    that it supports specific functionality. Therefore, they are sometimes described
    as contracts.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Common interfaces
  id: totrans-227
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Table 6.1* shows some common interfaces that your types might implement:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: '| **Interface** | **Method(s)** | **Description** |'
  id: totrans-229
  prefs: []
  type: TYPE_TB
- en: '| `IComparable` | `CompareTo(other)` | This defines a comparison method that
    a type implements to order or sort its instances. |'
  id: totrans-230
  prefs: []
  type: TYPE_TB
- en: '| `IComparer` | `Compare(first, second)` | This defines a comparison method
    that a secondary type implements to order or sort instances of a primary type.
    |'
  id: totrans-231
  prefs: []
  type: TYPE_TB
- en: '| `IDisposable` | `Dispose()` | This defines a disposal method to release unmanaged
    resources more efficiently than waiting for a finalizer. See the *Releasing unmanaged
    resources* section later in this chapter for more details. |'
  id: totrans-232
  prefs: []
  type: TYPE_TB
- en: '| `IFormattable` | `ToString(format, culture)` | This defines a culture-aware
    method to format the value of an object into a string representation. |'
  id: totrans-233
  prefs: []
  type: TYPE_TB
- en: '| `IFormatter` | `Serialize(stream, object)``Deserialize(stream)` | This defines
    methods to convert an object to and from a stream of bytes for storage or transfer.
    |'
  id: totrans-234
  prefs: []
  type: TYPE_TB
- en: '| `IFormatProvider` | `GetFormat(type)` | This defines a method to format inputs
    based on a language and region. |'
  id: totrans-235
  prefs: []
  type: TYPE_TB
- en: 'Table 6.1: Some common interfaces that your types might implement'
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
- en: Comparing objects when sorting
  id: totrans-237
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common interfaces that you will want to implement in your types
    that represent data is `IComparable`. If a type implements one of the `IComparable`
    interfaces, then arrays and collections containing instances of that type can
    be sorted.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
- en: This is an example of an abstraction for the concept of sorting. To sort any
    type, the minimum functionality would be the ability to compare two items and
    decide which goes before the other. If a type implements that minimum functionality,
    then a sorting algorithm can use it to sort instances of that type in any way
    the sorting algorithm wants.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IComparable` interface has one method named `CompareTo`. This has two
    variations, one that works with a nullable `object` type and one that works with
    a nullable generic type `T`, as shown in the following code:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: The `in` keyword specifies that the type parameter `T` is contravariant, which
    means that you can use a less derived type than that specified. For example, if
    `Employee` derives from `Person`, then both can be compared to each other.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `string` type implements `IComparable` by returning `-1` if
    the `string` should be sorted before the `string` is compared to, `1` if it should
    be sorted after, and `0` if they are equal. The `int` type implements `IComparable`
    by returning `-1` if the `int` is less than the `int` being compared to, `1` if
    it is greater, and `0` if they are equal.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: '`CompareTo` return values can be summarized as shown in *Table 6.2*:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
- en: '| **this before other** | **this is equal to other** | **this after other**
    |'
  id: totrans-245
  prefs: []
  type: TYPE_TB
- en: '| -1 | 0 | 1 |'
  id: totrans-246
  prefs: []
  type: TYPE_TB
- en: 'Table 6.2: Summary of the CompareTo return values'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we implement the `IComparable` interface and its `CompareTo` method
    for the `Person` class, let’s see what happens when we try to sort an array of
    `Person` instances without implementing this interface, including some that are
    `null` or have a `null` value for their `Name` property:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
- en: In the `PeopleApp` project, add a new class file named `Program.Helpers.cs`.
  id: totrans-249
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.Helpers.cs`, delete any existing statements. Then define a method
    for the `partial` `Program` class that will output all the names of a collection
    of people passed as a parameter, with a title beforehand, as shown in the following
    code:'
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In `Program.cs`, add statements that create an array of `Person` instances,
    call the `OutputPeopleNames` method to write the items to the console, and then
    attempt to sort the array and write the items to the console again, as shown in
    the following code:'
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  id: totrans-253
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'Run the `PeopleApp` project and an exception will be thrown. As the message
    explains, to fix the problem, our type must implement `IComparable`, as shown
    in the following output:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'In `Person.cs`, after inheriting from `object`, add a comma and enter `IComparable<Person?>`,
    as highlighted in the following code:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Your code editor will draw a red squiggle under the new code to warn you that
    you have not yet implemented the method you promised to. Your code editor can
    write the skeleton implementation for you.
  id: totrans-258
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Click on the light bulb and then click **Implement interface**.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Scroll down to the bottom of the `Person` class to find the method that was
    written for you, as shown in the following code:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Delete the statement that throws the `NotImplementedException` error.
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements to handle variations of input values, including `null`. Call
    the `CompareTo` method of the `Name` field, which uses the `string` type’s implementation
    of `CompareTo`. Return the result, as shown in the following code:'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We have chosen to compare two `Person` instances by comparing their `Name` fields.
    `Person` instances will, therefore, be sorted alphabetically by their name. `null`
    values will be sorted to the bottom of the collection. Storing the calculated
    `position` before returning it is useful when debugging. I’ve also used more round
    brackets than the compiler needs to make the code easier for me to read. If you
    prefer fewer brackets, then feel free to remove them.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
- en: Also, note that the final `else` statement will never execute because the logic
    of the `if` and `else` `if` clauses means it will only execute when `this` (the
    current object instance) is `null`. In that scenario, the method could not execute
    anyway since the object wouldn’t exist! I wrote the `if` statement to exhaustively
    cover all combinations of `null` and not `null` for `other` and `this`, but the
    last of those combinations could, in practice, never happen.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project. Note that this time it works as it should, sorted
    alphabetically by name, as shown in the following output:'
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '**Good Practice**: If you want to sort an array or collection of instances
    of your type, then implement the `IComparable` interface.'
  id: totrans-269
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Comparing objects using a separate class
  id: totrans-270
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Sometimes, you won’t have access to the source code for a type, and it might
    not implement the `IComparable` interface. Luckily, there is another way to sort
    instances of a type. You can create a separate type that implements a slightly
    different interface, named `IComparer`:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PacktLibrary` project, add a new class file named `PersonComparer.cs`,
    containing a class implementing the `IComparer` interface that will compare two
    people, that is, two `Person` instances. Implement it by comparing the length
    of their `Name` fields, or if the names are the same length, then compare the
    names alphabetically, as shown in the following code:'
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  id: totrans-273
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'In `Program.cs`, add statements to sort the array using an alternative implementation,
    as shown in the following code:'
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  id: totrans-275
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Run the `PeopleApp` project, and view the result of sorting the people by the
    length of their names and then alphabetically, as shown in the following output:'
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  id: totrans-277
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: This time, when we sort the `people` array, we explicitly ask the sorting algorithm
    to use the `PersonComparer` type instead so that the people are sorted with the
    shortest names first, like `Adam`, and the longest names last, like `Richard`.
    When the lengths of two or more names are equal, they are sorted alphabetically,
    like `Jenny` and `Simon`.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
- en: Implicit and explicit interface implementations
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interfaces can be implemented implicitly and explicitly. Implicit implementations
    are simpler and more common. Explicit implementations are only necessary if a
    type must have multiple methods with the same name and signature. Personally,
    the only time I can remember ever having to explicitly implement an interface
    is when writing the code example for this book.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
- en: For example, both `IGamePlayer` and `IKeyHolder` might have a method called
    `Lose` with the same parameters because both a game and a key can be lost. The
    members of an interface are always and automatically `public` because they have
    to be accessible for another type to implement them!
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: 'In a type that must implement both interfaces, only one implementation of `Lose`
    can be the implicit method. If both interfaces can share the same implementation,
    there is no problem, but if not, then the other `Lose` method will have to be
    implemented differently and called explicitly, as shown in the following code:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  id: totrans-283
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Although the implementation of `IGamePlayer.Lose` in `Human` is `private`, the
    `IGamePlayer.Lose` member itself has an access modifier of `public`, so if we
    cast the `Human` instance into the interface type, then that `Lose` implementation
    is accessible.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: '**Warning!** Method access modifiers in an implementation type must match the
    method definition in the interface. For example, the `Lose` method in the interface
    is `public`, so the method implementation in the class must also be `public`.'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: Defining interfaces with default implementations
  id: totrans-286
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A language feature introduced in C# 8 is the **default implementation** for
    an interface. This allows an interface to contain implementation. This breaks
    the clean separation between interfaces that define a contract and classes and
    other types that implement them. It is considered by some .NET developers to be
    a perversion of the language.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see it in action:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `PacktLibrary` project, add a new file named `IPlayable.cs`, and modify
    the statements to define a public `IPlayable` interface with two methods to `Play`
    and `Pause`, as shown in the following code:'
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  id: totrans-290
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'In the `PacktLibrary` project, add a new class file named `DvdPlayer.cs`, and
    modify the statements in the file to implement the `IPlayable` interface, as shown
    in the following code:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: This is useful, but what if we decide to add a third method named `Stop`? Before
    C# 8, this would be impossible once at least one type is implemented in the original
    interface. One of the main traits of an interface is that it is a fixed contract.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: C# 8 allows you to add new members to an interface after release if those new
    members have a default implementation. C# purists do not like the idea, but for
    practical reasons, such as avoiding breaking changes or having to define a whole
    new interface, it is useful, and other languages such as Java and Swift enable
    similar techniques.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: Support for default interface implementations requires some fundamental changes
    to the underlying platform, so they are only supported with C# if the target framework
    is .NET 5 or later, .NET Core 3 or later, or .NET Standard 2.1\. They are, therefore,
    not supported by .NET Framework.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s add a default implementation to the interface:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `IPlayable` interface to add a `Stop` method with a default implementation,
    as highlighted in the following code:'
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Build the `PeopleApp` project, and note that the projects compile successfully
    despite the `DvdPlayer` class not implementing `Stop`. In the future, we could
    override the default implementation of `Stop` by implementing it in the `DvdPlayer`
    class.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Although controversial, default implementations in interfaces might be useful
    in scenarios where the most common implementation is known at the time of defining
    the interface. Therefore, it is best if the interface defines that implementation
    once, and then most types that implement that interface can inherit it without
    needing to implement their own. However, if the interface definer does not know
    how the member should or even could be implemented, then it is a waste of effort
    to add a default implementation because it will always be replaced.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
- en: Think about the `IComparable` interface that you saw earlier in this chapter.
    It defines a `CompareTo` method. What might a default implementation of that method
    be? Personally, I think it’s obvious that there is no default implementation that
    would make any practical sense. The least-worst implementation that I can think
    of would be to compare the `string` values returned from calling `ToString` on
    the two objects. However, every type really should implement its own `CompareTo`
    method. You are likely to find the same with 99.9% of the interfaces you use.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at how to work with null values.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: Working with null values
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What if a variable does not yet have a value? How can we indicate that? C# has
    the concept of a `null` value, which can be used to indicate that a variable has
    not been set.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are unsure of the difference between reference types and value types
    in .NET, then I recommend that you read the following online-only section before
    you continue with this section: [https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md).'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Making a value type nullable
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By default, **value types** like `int` and `DateTime` must always have a *value*,
    hence their name. Sometimes, for example, when reading values stored in a database
    that allows empty, missing, or `null` values, it is convenient to allow a value
    type to be `null`. We call this a **nullable value type**.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: You can enable this by adding a question mark as a suffix to the type when declaring
    a variable.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example. We will create a new project because some of the null
    handling options are set at the project level:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
- en: Use your preferred code editor to add a new **Console App**/`console` project
    named `NullHandling` to the `Chapter06` solution.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `NullHandling.csproj`, add an `<ItemGroup>` to globally and statically import
    the `System.Console` class.
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, delete the existing statements, and then add statements to
    declare and assign values, including `null`, two `int` variables, one suffixed
    with `?` and one not, as shown in the following code:'
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  id: totrans-313
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Build the project and note the compile error, as shown in the following output:'
  id: totrans-314
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  id: totrans-315
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'Comment out the statement that gives the compile error, as shown in the following
    code:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: 'Run the project and view the result, as shown in the following output:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: The second line is blank because it outputs the `null` value.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: 'Add statements to use alternative syntax, as shown in the following code:'
  id: totrans-321
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE65]'
  id: totrans-322
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: Click on `Nullable<int>` and press *F12*, or right-click and choose **Go To
    Definition**.
  id: totrans-323
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Note that the generic value type, `Nullable<T>`, must have a type `T`, which
    is a `struct`, or a value type. It has useful members like `HasValue`, `Value`,
    and `GetValueOrDefault`, as shown in *Figure 6.1*:'
  id: totrans-324
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_06_01.png)'
  id: totrans-325
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.1: Revealing Nullable<T> members'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: When you append a `?` after a `struct` type, you change
    it to a different type. For example, `DateTime?` becomes `Nullable<DateTime>`.'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
- en: Understanding null-related initialisms
  id: totrans-328
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Before we see some code, let’s review some commonly used initialisms in *Table
    6.3*:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '| **Initialism** | **Meaning** | **Description** |'
  id: totrans-330
  prefs: []
  type: TYPE_TB
- en: '| NRT | Nullable Reference Type | This is a compiler feature introduced with
    C# 8 and enabled by default in new projects with C# 10, which performs static
    analysis of your code at design time and shows warnings of potential misuse of
    `null` values for reference types. |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
- en: '| NRE | `NullReferenceException` | This is an exception thrown at runtime when
    **dereferencing** a `null` value, also known as accessing a variable or member
    on an object that is `null`. |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
- en: '| ANE | `ArgumentNullException` | This is an exception thrown at runtime by
    a method, property, or indexer invocation when an argument or value is `null`,
    and when the business logic determines that it is not valid. |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
- en: 'Table 6.3: Commonly used initialisms'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: Understanding nullable reference types
  id: totrans-335
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The use of the `null` value is so common, in so many languages, that many experienced
    programmers never question the need for its existence. However, there are many
    scenarios where we could write better, simpler code if a variable is not allowed
    to have a `null` value.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: The most significant change to the C# 8 language compiler was the introduction
    of checks and warnings for nullable and non-nullable reference types. *“But wait!”*,
    you are probably thinking. *“Reference types are already nullable!”*
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: And you would be right, but in C# 8 and later, reference types can be configured
    to warn you about `null` values by setting a file- or project-level option, enabling
    this useful new feature. Since this is a big change for C#, Microsoft decided
    to make the feature an opt-in.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: It will take several years for this new C# language compiler feature to make
    an impact, since thousands of existing library packages and apps will expect the
    old behavior. Even Microsoft did not have time to fully implement this new feature
    in all the main .NET packages until .NET 6\. Important libraries like `Microsoft.Extensions`
    for logging, dependency injections, and configuration were not annotated until
    .NET 7.
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
- en: 'During the transition, you can choose between several approaches for your own
    projects:'
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: '**Default**: For projects created using .NET 5 or earlier, no changes are needed.
    Non-nullable reference types are not checked. For projects created using .NET
    6 or later, nullability checks are enabled by default, but this can be disabled
    by either deleting the `<Nullable>` entry in the project file or setting it to
    `disable`.'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opt-in project and opt-out files**: Enable the feature at the project level,
    and for any files that need to remain compatible with old behavior, opt out. This
    was the approach Microsoft used internally while it updated its own packages to
    use this new feature.'
  id: totrans-342
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Opt-in files**: Only enable the NRT feature for individual files.'
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Warning!** This NRT feature does not *prevent* `null` values – it just *warns*
    you about them, and the warnings can be disabled, so you still need to be careful!
    For example, using the `?` character to declare a variable as nullable does not
    allow `null` values, it just disables the warning, as shown in the following code:'
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  id: totrans-345
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: Controlling the nullability warning check feature
  id: totrans-346
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To enable the nullability warning check feature at the project level, have
    the `<Nullable>` element set to `enable` in your project file, as highlighted
    in the following markup:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'To disable the nullability warning check feature at the project level, have
    the `<Nullable>` element set to `disable` in your project file, as highlighted
    in the following markup:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE68]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: You could also remove the `<Nullable>` element completely because the default,
    if not explicitly set, is disabled.
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
- en: 'To disable the feature at the file level, add the following at the top of a
    code file:'
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE69]'
  id: totrans-353
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'To enable the feature at the file level, add the following at the top of a
    code file:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  id: totrans-355
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: Disabling null and other compiler warnings
  id: totrans-356
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You could decide to enable the nullability feature at the project or file level
    but then disable some of the 50+ warnings related to it. Some common nullability
    warnings are shown in *Table 6.4*:'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
- en: '| **Code** | **Description** |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
- en: '| `CS8600` | Converting a null literal or a possible null value to a non-nullable
    type |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
- en: '| `CS8601` | A possible null reference assignment |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
- en: '| `CS8602` | A dereference of a possibly null reference |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
- en: '| `CS8603` | A possible null reference return |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
- en: '| `CS8604` | A possible null reference argument for a parameter |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
- en: '| `CS8618` | A non-nullable field `<field_name>` must contain a non-null value
    when exiting a constructor. Consider declaring the field as nullable |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
- en: '| `CS8625` | Cannot convert a null literal to a non-nullable reference type
    |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
- en: '| `CS8655` | The switch expression does not handle some null inputs (it is
    not exhaustive) |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
- en: 'Table 6.4: Common nullability warnings'
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: 'You can disable compiler warnings for a whole project. To do so, add a `NoWarn`
    element with a semicolon-separated list of compiler warning codes, as shown in
    the following markup:'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE71]'
  id: totrans-369
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: 'To disable compiler warnings at the statement level, you can disable and then
    restore a specified compiler warning to temporarily suppress it for a block of
    statements, as shown in the following code:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE72]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: These techniques can be used for any compiler warnings, not just those related
    to nullability.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
- en: Declaring non-nullable variables and parameters
  id: totrans-373
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you enable NRTs and you want a reference type to be assigned the `null` value,
    then you will have to use the same syntax to make a value type nullable, that
    is, adding a `?` symbol after the type declaration.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
- en: 'So, how do NRTs work? Let’s look at an example. When storing information about
    an address, you might want to force a value for the street, city, and region,
    but the building can be left blank, that is, `null`:'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: In the `NullHandling` project, add a class file named `Address.cs`.
  id: totrans-376
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Address.cs`, delete any existing statements and then add statements to
    declare an `Address` class with four fields, as shown in the following code:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE73]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE73]'
- en: 'After a few seconds, note the warnings about non-nullable fields, like `Street`
    not being initialized, as shown in *Figure 6.2*:'
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_06_02.png)'
  id: totrans-380
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.2: Warning messages about non-nullable fields in the Error List window'
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
- en: 'Assign the empty `string` value to the `Street` field, and define constructors
    to set the other fields that are non-nullable, as highlighted in the following
    code:'
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE74]'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'In `Program.cs`, import the namespace to use `Address`, as shown in the following
    code:'
  id: totrans-384
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE75]'
  id: totrans-385
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE75]'
- en: 'In `Program.cs`, add statements to instantiate an `Address` and set its properties,
    as shown in the following code:'
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE76]'
  id: totrans-387
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE76]'
- en: 'Note the `Warning` `CS8625` on setting the `Street` but not the `Building`,
    as shown in the following output:'
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE77]'
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE77]'
- en: 'Append an exclamation mark to `null` when setting `Street`, as highlighted
    in the following code:'
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE78]'
  id: totrans-391
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note that the warning disappears.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add statements that will dereference the `Building` and `Street` properties,
    as shown in the following code:'
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE79]'
  id: totrans-394
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Note the `Warning CS8602` on setting the `Building` but not the `Street`, as
    shown in the following output:'
  id: totrans-395
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE80]'
  id: totrans-396
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE80]'
- en: At runtime it is still possible for an exception to be thrown when working with
    `Street`, but the compiler should continue to warn you of potential exceptions
    when working with `Building` so that you can change your code to avoid them.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the null-conditional operator to return `null` instead of accessing the
    `Length`, as shown in the following code:'
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE81]'
  id: totrans-399
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE81]'
- en: 'Run the console app, and note that the statement that accesses the `Length`
    of the `Building` outputs a `null` value (blank line), but a runtime exception
    occurs when we access the `Length` of the `Street`, as shown in the following
    output:'
  id: totrans-400
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE82]'
  id: totrans-401
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'Wrap the statement that accesses the `Street` length in a null check, as shown
    in the following code:'
  id: totrans-402
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE83]'
  id: totrans-403
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE83]'
- en: It is worth reminding yourself that an NRT is only about asking the compiler
    to provide warnings about potential `null` values that might cause problems. It
    does not actually change the behavior of your code. It performs a static analysis
    of your code at compile time.
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
- en: This explains why the new language feature is named **nullable reference types**
    (**NRTs**). Starting with C# 8, unadorned reference types can become non-nullable,
    and the same syntax is used to make a reference type nullable, as it is used for
    value types.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
- en: Suffixing a reference type with `?` does not change the type. This is different
    from suffixing a value type with `?`, which changes its type to `Nullable<T>`.
    Reference types can already have `null` values. All you do with **NRTs** is tell
    the compiler that you expect it to be `null`, so the compiler does not need to
    warn you. However, this does not remove the need to perform `null` checks throughout
    your code.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
- en: Now let’s look at language features to work with `null` values that change the
    behavior of your code and work well as a complement to NRTs.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
- en: Checking for null
  id: totrans-408
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Checking whether a nullable reference type or value type variable currently
    contains `null` is important because if you do not, a `NullReferenceException`
    can be thrown, which results in an error. You should check for a `null` value
    before using a nullable variable, as shown in the following code:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE84]'
  id: totrans-410
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: 'C# 7 introduced `is` combined with the `!` (`not`) operator as an alternative
    to `!=`, as shown in the following code:'
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE85]'
  id: totrans-412
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'C# 9 introduced `is not` as an even clearer alternative, as shown in the following
    code:'
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  id: totrans-414
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '**Good Practice**: Although you would traditionally use the expression `(thisCouldBeNull
    != null)`, this is no longer considered good practice because the developer could
    have overloaded the `!=` operator to change how it works. Using pattern matching
    with `is null` and `is not null` is the only guaranteed way to check for `null`.
    For many developers, it is still instinctual to use `!=`, so I apologize in advance
    if you catch me still using it!'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the `is` operator cannot be overloaded by a developer, its behavior is
    guaranteed. Both the `==` and `!=` operators could be overloaded by a developer
    so their behavior could change. The .NET team has now consistently implemented
    their null checks using `is`, so I recommend that you do the same, as you can
    see at the following link:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
- en: '[https://twitter.com/Dave_DotNet/status/1764995927868076428](https://twitter.com/Dave_DotNet/status/1764995927868076428)'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
- en: The term *overriding* is about altering or extending the behavior of an inherited
    method in the context of object-oriented inheritance. *Overloading* occurs when
    you provide a new implementation for an existing operator or method.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to use a member of a variable that might be `null`, use the **null-conditional
    operator**, `?.`, as shown in the following code:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE87]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: 'Sometimes, you want to either assign a variable to a result or use an alternative
    value, such as `3`, if the variable is `null`. You do this using the **null-coalescing
    operator**, `??`, as shown in the following code:'
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  id: totrans-422
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: Checking for null in method parameters
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Even if you enable NRTs, when defining methods with parameters, it is good practice
    to check for `null` values.
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
- en: 'In earlier versions of C#, you would have to write `if` statements to check
    for `null` parameter values and then throw an `ArgumentNullException` for any
    parameter that is `null`, as shown in the following code:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  id: totrans-426
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'C# 10 introduced a convenience method to throw an exception if an argument
    is `null`, as shown in the following code:'
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE90]'
  id: totrans-428
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: 'C# 11 previews proposed and introduced a new `!!` operator that does this for
    you, as shown in the following code:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE91]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The `if` statement and throwing of the exception would be done for you. The
    code is injected and executed before any statements that you write.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
- en: This proposal was controversial within the C# developer community. Some would
    prefer the use of attributes to decorate parameters instead of a pair of characters.
    The .NET product team said they reduced the .NET libraries by more than 10,000
    lines of code by using this feature.
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
- en: 'That sounds like a good reason to use it to me! And no one must use it if they
    choose not to. Unfortunately, the team eventually decided to remove the feature,
    so now we all have to write the null checks manually. If you’re interested in
    this story, then you can read more about it at the following link:'
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/#remove-parameter-null-checking-from-c-11](https://devblogs.microsoft.com/dotnet/csharp-11-preview-updates/#remove-parameter-null-checking-from-c-11)'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
- en: I include this story in this book because I think it’s an interesting example
    of Microsoft being transparent, by developing .NET in the open and listening to
    and responding to feedback from the community.
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: Always remember that nullable is a warning check, not an
    enforcement. You can read more about the compiler warnings relating to `null`
    at the following link:'
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
- en: '[https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/nullable-warnings](https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-messages/nullable-warnings)'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
- en: That’s more than enough talk about “nothing”! Let’s look at the meat of this
    chapter, inheritance.
  id: totrans-438
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from classes
  id: totrans-439
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The `Person` type we created earlier derived (inherited) from `System.Object`.
    Now, we will create a subclass that inherits from `Person`:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `Employee.cs`.
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify its contents to define a class named `Employee` that derives from `Person`,
    as shown in the following code:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE92]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'In the `PeopleApp` project, in `Program.cs`, add statements to create an instance
    of the `Employee` class, as shown in the following code:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE93]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE94]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: Note that the `Employee` class has inherited all the members of `Person`.
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
- en: Extending classes to add functionality
  id: totrans-449
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we will add some employee-specific members to extend the class:'
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Employee.cs`, add statements to define two properties, for an employee
    code and the date they were hired (we do not need to know a start time, so we
    can use the `DateOnly` type), as shown in the following code:'
  id: totrans-451
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE95]'
  id: totrans-452
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'In `Program.cs`, add statements to set John’s employee code and hire date,
    as shown in the following code:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE96]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE97]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: Hiding members
  id: totrans-457
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, the `WriteToConsole` method is inherited from `Person`, and it only
    outputs the employee’s name and date and time of birth. We might want to change
    what this method does for an employee:'
  id: totrans-458
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Employee.cs`, add statements to redefine the `WriteToConsole` method, as
    highlighted in the following code:'
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE98]'
  id: totrans-460
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Run the `PeopleApp` project, view the result, and note that the first line
    of output is before the employees were hired; hence, it has a default date, as
    shown in the following output:'
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE99]'
  id: totrans-462
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Your code editor warns you that your method now hides the method from `Person`
    by drawing a squiggle under the method name, the **PROBLEMS**/**Error List** window
    includes more details, and the compiler will output a warning when you build and
    run the console application, as shown in *Figure 6.3*:'
  id: totrans-463
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B22322_06_03.png)'
  id: totrans-464
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.3: Hidden method warning'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
- en: 'As the warning describes, you should hide this message by applying the `new`
    keyword to the method, indicating that you are deliberately replacing the old
    method, as highlighted in the following code:'
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  id: totrans-467
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: Make this fix now.
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the this and base keywords
  id: totrans-469
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are two special C# keywords that can be used to refer to the current
    object instance or the base class that it inherits from:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
- en: '`this`: It represents the current object instance. For example, in the `Person`
    class instance members (but not in static members), you could use the expression
    `this.Born` to access the `Born` field of the current object instance. You rarely
    need to use it, since the expression `Born` would also work. It is only when there
    is a local variable also named `Born` that you would need to use `this.Born` to
    explicitly say you are referring to the field, not the local variable.'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`base`: It represents the base class that the current object inherits from.
    For example, anywhere in the `Person` class, you could use the expression `base.ToString()`
    to call the base class implementation of that method.'
  id: totrans-472
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You will (hopefully) remember from *Chapter 5*, *Building Your Own Types with
    Object-Oriented Programming*, that to access static members, you must use the
    type name.
  id: totrans-473
  prefs: []
  type: TYPE_NORMAL
- en: Overriding members
  id: totrans-474
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Rather than hiding a method, it is usually better to **override** it. You can
    only override it if the base class chooses to allow overriding, by applying the
    `virtual` keyword to any methods that should allow overriding.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see an example:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to write the value of the `john` variable
    to the console using its `string` representation, as shown in the following code:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE101]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'Run the `PeopleApp` project and note that the `ToString` method is inherited
    from `System.Object`, so the implementation returns the namespace and type name,
    as shown in the following output:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE102]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'In `Person.cs` (not in the `Employee` class!), override this behavior by adding
    a `ToString` method to output the name of the person as well as the type name,
    as shown in the following code:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE103]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: The `base` keyword allows a subclass to access members of its superclass, that
    is, the **base class** that it inherits or derives from.
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Good Practice**: Some code editors like Visual Studio will automatically
    add a call to the base class member when you override a member. To decide if you
    need to keep the call or not, view the tooltip or definition of the member. For
    example, in *Chapter 10*, *Working with Data Using Entity Framework Core*, you
    will override a method of the `DbContext` class named `OnConfiguring`. If you
    hover over the method name, its tooltip tells you “The base implementation does
    nothing.” If you **Go To Definition** (*F12*) of the method, you will see that
    it does nothing, as shown in the following code:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE104]'
  id: totrans-485
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: The method only exists in the base class so that subclasses can override it
    and then EF Core can call your code when it needs to configure the data context.
    It would be a waste for your overridden method implementation to call the base
    implementation.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and view the result. Now, when the `ToString` method
    is called, it outputs the person’s name, as well as returning the base class’s
    implementation of `ToString`, as shown in the following output:'
  id: totrans-487
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE105]'
  id: totrans-488
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: '**Good Practice**: Many real-world APIs, for example, Microsoft’s Entity Framework
    Core, Castle’s DynamicProxy, and Optimizely CMS’s content models, require the
    properties that you define in your classes to be marked as `virtual` so that they
    can be overridden. Carefully decide which of your methods and property members
    should be marked as `virtual`.'
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting from abstract classes
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier in this chapter, you learned about interfaces that can define a set
    of members that a type must have to meet a basic level of functionality. These
    are very useful, but their main limitation is that until C# 8 they could not provide
    any implementation of their own.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
- en: This is a particular problem if you still need to create class libraries that
    will work with .NET Framework and other platforms that do not support .NET Standard
    2.1.
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
- en: In those earlier platforms, you could use an **abstract class** as a sort of
    halfway house between a pure interface and a fully implemented class.
  id: totrans-493
  prefs: []
  type: TYPE_NORMAL
- en: When a class is marked as `abstract`, this means that it cannot be instantiated
    because you have indicated that the class is not complete. It needs more implementation
    before it can be instantiated.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
- en: For example, the `System.IO.Stream` class is `abstract` because it implements
    common functionality that all streams would need but is not complete. Therefore,
    it is useless without more implementation that is specific to the type of stream,
    so you cannot instantiate it using `new Stream()`.
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s compare the two types of interface and the two types of class, as shown
    in the following code:'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE106]'
  id: totrans-497
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Choosing between an interface and an abstract class
  id: totrans-498
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have now seen examples of implementing the concept of abstraction using
    either an interface or an `abstract` class. Which should you pick? Now that an
    interface can have default implementations for its members, is the `abstract`
    keyword for a class obsolete?
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
- en: Well, let’s think about a real example. `Stream` is an `abstract` class. Would
    or could the .NET team use an interface for that today?
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
- en: Every member of an interface must be `public` (or at least match the interface’s
    access level, which could be `internal` if it should only be used in the class
    library that it’s defined in). An `abstract` class has more flexibility in its
    members’ access modifiers.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
- en: Another advantage of an `abstract` class over an interface is that serialization
    often does not work for an interface. So, no, we still need to be able to define
    abstract classes.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
- en: Preventing inheritance and overriding
  id: totrans-503
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You can prevent another developer from inheriting from your class by applying
    the `sealed` keyword to its definition. For example, no one can inherit from Scrooge
    McDuck, as shown in the following code:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE107]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: An example of `sealed` in .NET is the `string` class. Microsoft has implemented
    some extreme optimizations inside the `string` class that could be negatively
    affected by your inheritance, so Microsoft prevents that.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
- en: 'You can prevent someone from further overriding a `virtual` method in your
    class by applying the `sealed` keyword to the method. For example, no one can
    change the way Lady Gaga sings, as shown in the following code:'
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE108]'
  id: totrans-508
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: You can only seal an overridden method.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
- en: Understanding polymorphism
  id: totrans-510
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have now seen two ways to change the behavior of an inherited method. We
    can *hide* it using the `new` keyword (known as **non-polymorphic inheritance**),
    or we can *override* it (known as **polymorphic inheritance**).
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
- en: Both ways can access members of the base or superclass by using the `base` keyword,
    so what is the difference?
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
- en: It all depends on the type of variable holding a reference to the object. For
    example, a variable of the `Person` type can hold a reference to a `Person` class,
    or any type that derives from `Person`.
  id: totrans-513
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s see how this could affect your code:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Employee.cs`, add statements to override the `ToString` method so that
    it writes the employee’s name and code to the console, as shown in the following
    code:'
  id: totrans-515
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE109]'
  id: totrans-516
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In `Program.cs`, write statements to create a new employee named Alice stored
    in a variable of type `Employee`. Also, store Alice in a second variable of type
    `Person`, and then call both variables’ `WriteToConsole` and `ToString` methods,
    as shown in the following code:'
  id: totrans-517
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE110]'
  id: totrans-518
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE111]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: When a method is hidden with `new`, the compiler is not smart enough to know
    that the object is an `Employee`, so it calls the `WriteToConsole` method in `Person`.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
- en: When a method is overridden with `virtual` and `override`, the compiler is smart
    enough to know that although the variable is declared as a `Person` class and
    the object itself is an `Employee` class, and therefore, the `Employee` implementation
    of `ToString` is called.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
- en: 'The member modifiers and the effect they have are summarized in *Table 6.5*:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
- en: '| **Variable type** | **Member modifier** | **Method executed** | **In class**
    |'
  id: totrans-524
  prefs: []
  type: TYPE_TB
- en: '| `Person` |  | `WriteToConsole` | `Person` |'
  id: totrans-525
  prefs: []
  type: TYPE_TB
- en: '| `Employee` | `new` | `WriteToConsole` | `Employee` |'
  id: totrans-526
  prefs: []
  type: TYPE_TB
- en: '| `Person` | `virtual` | `ToString` | `Employee` |'
  id: totrans-527
  prefs: []
  type: TYPE_TB
- en: '| `Employee` | `override` | `ToString` | `Employee` |'
  id: totrans-528
  prefs: []
  type: TYPE_TB
- en: 'Table 6.5: Member modifiers and the effect they have'
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
- en: In my opinion, polymorphism is academic to most programmers. If you get the
    concept, that’s cool; but if not, I suggest that you don’t worry about it. Some
    people like to make others feel inferior by saying understanding polymorphism
    is important for all C# programmers, but in my opinion, it’s not. There are thousands
    of other topics that your time and effort will be better spent on.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
- en: You can have a successful career with C# and never need to be able to explain
    polymorphism, just as a racing car driver doesn’t need to explain the engineering
    behind fuel injection.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
- en: '**Good Practice**: You should use `virtual` and `override` rather than `new`
    to change the implementation of an inherited method whenever possible.'
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
- en: Casting within inheritance hierarchies
  id: totrans-533
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Casting** between types is subtly different from converting between types.
    Casting is between similar types, like between a 16-bit integer and a 32-bit integer,
    or between a superclass and one of its subclasses. **Converting** is between dissimilar
    types, such as between text and a number.'
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
- en: For example, if you need to work with multiple types of `stream`, then instead
    of declaring specific types of stream like `MemoryStream` or `FileStream`, you
    could declare an array of `Stream`, the supertype of `MemoryStream`, and `FileStream`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
- en: Implicit casting
  id: totrans-536
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous example, you saw how an instance of a derived type can be stored
    in a variable of its base type (or its base’s base type, and so on). When we do
    this, it is called **implicit casting**.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
- en: Explicit casting
  id: totrans-538
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The opposite of implicit casting is explicit casting, and you must use parentheses
    around the type you want to cast into as a prefix to do it:'
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add a statement to assign the `aliceInPerson` variable to
    a new `Employee` variable, as shown in the following code:'
  id: totrans-540
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE112]'
  id: totrans-541
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'Your code editor displays a red squiggle and a compile error, as shown in *Figure
    6.4*:'
  id: totrans-542
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_06_04.png)'
  id: totrans-543
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.4: A missing explicit cast compile error'
  id: totrans-544
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the statement to prefix the assigned variable name with a cast to the
    `Employee` type, as shown highlighted in the following code:'
  id: totrans-545
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE113]'
  id: totrans-546
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE113]'
- en: Avoiding casting exceptions
  id: totrans-547
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The compiler is now happy; however, because `aliceInPerson` might be a different
    derived type, like `Student` instead of `Employee`, we need to be careful. In
    a real application with more complex code, the current value of this variable
    could have been set to a `Student` instance, and then this statement would throw
    an `InvalidCastException` error at runtime.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
- en: Using is to check a type
  id: totrans-549
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can handle this by writing a `try` statement, but there is a better way.
    We can check the type of an object using the `is` keyword:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
- en: 'Wrap the explicit cast statement in an `if` statement, as highlighted in the
    following code:'
  id: totrans-551
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE114]'
  id: totrans-552
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-553
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE115]'
  id: totrans-554
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE115]'
- en: '**Good Practice**: You could simplify the code further using a declaration
    pattern, and this will avoid the need to perform an explicit cast, as shown in
    the following code:'
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE116]'
  id: totrans-556
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: This technique of both checking and casting was covered in *Chapter 3*, *Controlling
    Flow, Converting Types, and Handling Exceptions*.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
- en: What if you want to execute a block of statements when Alice is *not* an employee?
  id: totrans-558
  prefs: []
  type: TYPE_NORMAL
- en: 'In the past, you would have had to use the `!` (not) operator, as shown in
    the following code:'
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE117]'
  id: totrans-560
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: 'With C# 9 and later, you can use the `not` keyword, as shown in the following
    code:'
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE118]'
  id: totrans-562
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: Using as to cast a type
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Alternatively, you can use the `as` keyword to cast a type. Instead of throwing
    an exception, the `as` keyword returns `null` if the type cannot be cast:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to cast Alice using the `as` keyword, and then
    check whether the return value is not null, as shown in the following code:'
  id: totrans-565
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE119]'
  id: totrans-566
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE119]'
- en: Since accessing a member of a `null` variable will throw a `NullReferenceException`
    error, you should always check for `null` before using the result.
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-568
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE120]'
  id: totrans-569
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE120]'
- en: '**Good Practice**: Use the `is` and `as` keywords to prevent throwing exceptions
    when casting between derived types. If you don’t do this, you must write `try`-`catch`
    statements for `InvalidCastException`.'
  id: totrans-570
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting and extending .NET types
  id: totrans-571
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET has pre-built class libraries containing hundreds of thousands of types.
    Rather than creating your own completely new types, you can often get a head start
    by deriving from one of Microsoft’s types to inherit some or all its behavior,
    and then overriding or extending it.
  id: totrans-572
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting exceptions
  id: totrans-573
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As an example of inheritance, we will derive a new type of exception:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `PersonException.cs`.
  id: totrans-575
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the contents of the file to define a class named `PersonException` with
    three constructors, as shown in the following code:'
  id: totrans-576
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE121]'
  id: totrans-577
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE121]'
- en: Unlike ordinary methods, constructors are not inherited, so we must explicitly
    declare and explicitly call the `base` constructor implementations in `System.Exception`
    (or whichever exception class you derived from) to make them available to programmers
    who might want to use those constructors with our custom exception.
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Person.cs`, add statements to define a method that throws an exception
    if a date/time parameter is earlier than a person’s date and time of birth, as
    shown in the following code:'
  id: totrans-579
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE122]'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'In `Program.cs`, add statements to test what happens when employee John Jones
    tries to time-travel too far back, as shown in the following code:'
  id: totrans-581
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE123]'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE123]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-583
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE124]'
  id: totrans-584
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE124]'
- en: '**Good Practice**: When defining your own exceptions, give them the same three
    constructors that explicitly call the built-in ones in `System.Exception`. Other
    exceptions that you might inherit from may have more.'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
- en: Extending types when you can’t inherit
  id: totrans-586
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Earlier, we saw how the `sealed` modifier can be used to prevent inheritance.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft has applied the `sealed` keyword to the `System.String` class so that
    no one can inherit and potentially break the behavior of strings.
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
- en: Can we still add new methods to strings? Yes, if we use a language feature named
    **extension methods**, which was introduced with C# 3.0\. To properly understand
    extension methods, we need to review static methods first.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
- en: Using static methods to reuse functionality
  id: totrans-590
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since the first version of C#, we’ve been able to create `static` methods to
    reuse functionality, such as the ability to validate that a `string` contains
    an email address. The implementation will use a regular expression that you will
    learn more about in *Chapter 8*, *Working with Common .NET Types*.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s write some code:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `StringExtensions.cs`.
  id: totrans-593
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify `StringExtensions.cs`, as shown in the following code, and note the
    following:'
  id: totrans-594
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The class imports a namespace to handle regular expressions.
  id: totrans-595
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `IsValidEmail` method is `static`, and it uses the `Regex` type to check
    for matches against a simple email pattern that looks for valid characters before
    and after the `@` symbol:'
  id: totrans-596
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE125]'
  id: totrans-597
  prefs:
  - PREF_IND
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'In `Program.cs`, add statements to validate two examples of email addresses,
    as shown in the following code:'
  id: totrans-598
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE126]'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE126]'
- en: 'Run the `PeopleApp` project and view the result, as shown in the following
    output:'
  id: totrans-600
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE127]'
- en: This works, but extension methods can reduce the amount of code we must type
    and simplify the usage of this function.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
- en: Using extension methods to reuse functionality
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'It is easy to turn `static` methods into extension methods:'
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
- en: 'In `StringExtensions.cs`, add the `static` modifier before the class, and then
    add the `this` modifier before the `string` type, as highlighted in the following
    code:'
  id: totrans-605
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  id: totrans-606
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE128]'
- en: '**Good Practice**: These two changes tell the compiler that it should treat
    the method as one that extends the `string` type.'
  id: totrans-607
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to use the extension method for `string` values
    that need to be checked for valid email addresses, as shown in the following code:'
  id: totrans-608
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  id: totrans-609
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE129]'
- en: Note the subtle simplification in the syntax to call the `IsValidEmail` method.
    The older, longer syntax still works too.
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
- en: 'The `IsValidEmail` extension method now appears to be a method just like all
    the actual instance methods of the `string` type, such as `IsNormalized`, except
    with a small down arrow on the method icon to indicate an extension method, as
    shown in *Figure 6.5*:'
  id: totrans-611
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B22322_06_05.png)'
  id: totrans-612
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6.5: Extension methods appear in IntelliSense alongside instance methods'
  id: totrans-613
  prefs: []
  type: TYPE_NORMAL
- en: Run the `PeopleApp` project and view the result, which will be the same as before.
  id: totrans-614
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Good Practice**: Extension methods cannot replace or override existing instance
    methods. You cannot, for example, redefine the `Insert` method. The extension
    method will appear as an overload in IntelliSense, but an instance method will
    be called in preference to an extension method with the same name and signature.'
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
- en: Although extension methods might not seem to give a big benefit, in *Chapter
    11*, *Querying and Manipulating Data Using LINQ*, you will see some extremely
    powerful uses of extension methods.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
- en: Method chaining or fluent style
  id: totrans-617
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Method chaining, also known as fluent style, is a programming technique where
    multiple method calls are chained together in a single statement. This is achieved
    by having each method return an instance of the same object (often the object
    the method was called on), enabling a sequence of method calls on the same object.
    This style is popular in C# for creating readable and concise code, especially
    for configuring objects or building complex queries.
  id: totrans-618
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider this `Person` class:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE130]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'To construct a `Person` instance, you can chain method calls, as shown in the
    following code:'
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  id: totrans-622
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: Extension methods allow adding new methods to existing types without modifying
    their source code or creating a new derived type. When combined with method chaining,
    this can enhance the readability and functionality of existing classes.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
- en: 'Suppose you have a `Car` class, as shown in the following code:'
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE132]'
  id: totrans-625
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'You can create extension methods to enable method chaining for the `Car` class:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  id: totrans-627
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: 'Now you can use these extension methods to chain method calls on a Car object:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE134]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'The benefits of method chaining include:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
- en: '**Readability**: The code is more readable and resembles natural language'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Conciseness**: Reduces the need for repetitive code'
  id: totrans-632
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Configurability**: Allows the flexible and easy configuration of objects'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: But the potential drawbacks of method chaining include debugging difficulty
    because long chains can be harder to debug, and misleading code because if not
    used carefully, it can lead to less intuitive code, especially when dealing with
    nullable objects or complex logic.
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
- en: '**Good practice**: When method chaining, use clear method names to ensure they
    clearly indicate their purpose, return `this` or the object itself to maintain
    the chain, and carefully consider how to handle potential errors or exceptions
    within chained methods.'
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
- en: Method chaining and the fluent style, especially when combined with extension
    methods in C#, provide clean, readable, and maintainable code.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
- en: Summarizing custom type choices
  id: totrans-637
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have covered OOP and the C# features that enable you to define your
    own types, let’s summarize what you’ve learned.
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
- en: Categories of custom types and their capabilities
  id: totrans-639
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Categories of custom types and their capabilities are summarized in *Table
    6.6*:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
- en: '| **Type** | **Instantiation** | **Inheritance** | **Equality** | **Memory**
    |'
  id: totrans-641
  prefs: []
  type: TYPE_TB
- en: '| `class` | Yes | Single | Reference | Heap |'
  id: totrans-642
  prefs: []
  type: TYPE_TB
- en: '| `sealed` `class` | Yes | None | Reference | Heap |'
  id: totrans-643
  prefs: []
  type: TYPE_TB
- en: '| `abstract` `class` | No | Single | Reference | Heap |'
  id: totrans-644
  prefs: []
  type: TYPE_TB
- en: '| `record` or `record` `class` | Yes | Single | Value | Heap |'
  id: totrans-645
  prefs: []
  type: TYPE_TB
- en: '| `struct` or `record` `struct` | Yes | None | Value | Stack |'
  id: totrans-646
  prefs: []
  type: TYPE_TB
- en: '| `interface` | No | Multiple | Reference | Heap |'
  id: totrans-647
  prefs: []
  type: TYPE_TB
- en: 'Table 6.6: Categories of custom types and their capabilities'
  id: totrans-648
  prefs: []
  type: TYPE_NORMAL
- en: It is best to think about these differences by starting with the “normal” case
    and then spotting the differences in other cases. For example, a “normal” `class`
    can be instantiated with `new`, it supports single inheritance, it uses memory
    reference equality, and its state is stored in heap memory.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let’s highlight what is different about the more specialized types of classes:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
- en: A `sealed` class does not support inheritance.
  id: totrans-651
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `abstract` class does not allow instantiation with `new`.
  id: totrans-652
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A `record` class uses value equality instead of reference equality.
  id: totrans-653
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can do the same for other types compared to a “normal” class:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
- en: A `struct` or `record struct` does not support inheritance, it uses value equality
    instead of reference equality, and its state is stored in stack memory.
  id: totrans-655
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `interface` does not allow instantiation with `new` and supports multiple
    inheritance.
  id: totrans-656
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mutability and records
  id: totrans-657
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A common misconception is that `record` types are immutable, meaning their
    instance property and field values cannot be changed after initialization. However,
    the mutability of a `record` type actually depends on how the `record` is defined.
    Let’s explore mutability:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
- en: In the `PacktLibrary` project, add a new class file named `Mutability.cs`.
  id: totrans-659
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify `Mutability.cs`, as shown in the following code, and note the following:'
  id: totrans-660
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE135]'
  id: totrans-661
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE135]'
- en: 'In the `PeopleApp` project, in `Program.cs`, create an instance of each type,
    setting the initial `Name` value to `Bob`, and then modify the `Name` property
    to `Bill`. You will see the two types that are immutable after initialization
    because they will give the compiler error `CS8852`, as shown in the following
    code:'
  id: totrans-662
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE136]'
  id: totrans-663
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE136]'
- en: Note that record `C1` is mutable and `C2` is immutable. Note that `S1` and `S2`
    are mutable and `S3` is immutable.
  id: totrans-664
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Comment out the two statements that cause compiler errors.
  id: totrans-665
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Microsoft made some interesting design choices with records. Make sure you remember
    the subtle differences in behavior when combining record, class, and struct, and
    use different types of declaration of each.
  id: totrans-666
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Comparing inheritance and implementation
  id: totrans-667
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For me, the terms *inherit* and *implement* are different, and in the early
    days of C# and .NET you could strictly apply them to classes and interfaces, respectively.
    For example, the `FileStream` class inherits from the `Stream` class, and the
    `Int32` `struct` implements the `IComparable` interface.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
- en: '*Inherit* implies some functionality that a subclass gets “for free” by inheriting
    from its **base**, or **superclass**. *Implement* implies some functionality that
    is NOT inherited but instead MUST be provided by the subclass. This is why I chose
    to title this chapter *Implementing Interfaces and Inheriting Classes*.'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
- en: Before C# 8, interfaces were always purely contracts. There was no functionality
    in an interface that you could inherit. In those days, you could strictly use
    the term *implement* for interfaces that represent a list of members that your
    type must implement, and *inherit* for classes with functionality that your type
    can inherit and potentially override.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
- en: With C# 8, interfaces can now include default implementations, making them more
    like abstract classes, and the term *inherit* for an interface that has default
    implementations does make sense. But I feel uncomfortable with this capability,
    as do many other .NET developers, because it messes up what used to be a clean
    language design. Default interfaces also require changes to the underlying .NET
    runtime, so they cannot be used with legacy platforms like .NET Standard 2.0 class
    libraries and .NET Framework.
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
- en: Classes can also have abstract members, for example, methods or properties without
    any implementation, just like an interface could have. When a subclass inherits
    from this class, it MUST provide an implementation of those abstract members,
    and the base class must be decorated with the `abstract` keyword to prevent it
    from being instantiated using `new` because it is missing some functionality.
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
- en: Reviewing illustrative code
  id: totrans-673
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s review some example code that illustrates some of the important differences
    between types.
  id: totrans-674
  prefs: []
  type: TYPE_NORMAL
- en: 'Note the following:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
- en: To simplify the code, I have left out access modifiers like `private` and `public`.
  id: totrans-676
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Instead of normal brace formatting, to save vertical space I have put all the
    method implementations in one statement, for example:'
  id: totrans-677
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE137]'
  id: totrans-678
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE137]'
- en: Using “I” as a prefix for interfaces is a convention, not a requirement. It
    is useful to highlight interfaces using this prefix, since only interfaces support
    multiple inheritance.
  id: totrans-679
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Here’s the code:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE138]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: Practicing and exploring
  id: totrans-682
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Test your knowledge and understanding by answering some questions, getting some
    hands-on practice, and exploring this chapter’s topics with more in-depth research.
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.1 – Online material
  id: totrans-684
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Online material can be extra content written by me for this book, or it can
    be references to content created by Microsoft or third parties.
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
- en: Managing memory with reference and value types
  id: totrans-686
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read the following online-only section to learn how to manage memory with reference
    and value types:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-memory.md)'
  id: totrans-688
  prefs: []
  type: TYPE_NORMAL
- en: Writing better code
  id: totrans-689
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Read the following online-only section to learn how to use analyzers to write
    better code:'
  id: totrans-690
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/ch06-writing-better-code.md](https://github.com/markjprice/cs13net9/blob/main/docs/ch06-writing-better-code.md)'
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
- en: Exercise 6.2 – Practice creating an inheritance hierarchy
  id: totrans-692
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Explore inheritance hierarchies by following these steps:'
  id: totrans-693
  prefs: []
  type: TYPE_NORMAL
- en: Add a new console app named `Exercise_Inheritance` to your `Chapter06` solution.
  id: totrans-694
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a class named `Shape` with properties named `Height`, `Width`, and `Area`.
  id: totrans-695
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add three classes that derive from it—`Rectangle`, `Square`, and `Circle`—with
    any additional members you feel are appropriate and that override and implement
    the `Area` property correctly.
  id: totrans-696
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In `Program.cs`, add statements to create one instance of each shape, as shown
    in the following code:'
  id: totrans-697
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE139]'
  id: totrans-698
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Run the console app and ensure that the result looks like the following output:'
  id: totrans-699
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE140]'
  id: totrans-700
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Exercise 6.3 – Test your knowledge
  id: totrans-701
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Answer the following questions:'
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
- en: What is a delegate?
  id: totrans-703
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is an event?
  id: totrans-704
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How are a base class and a derived class related, and how can the derived class
    access the base class?
  id: totrans-705
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the difference between the `is` and `as` operators?
  id: totrans-706
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword is used to prevent a class from being derived from or a method
    from being further overridden?
  id: totrans-707
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword is used to prevent a class from being instantiated with the `new`
    keyword?
  id: totrans-708
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword is used to allow a member to be overridden?
  id: totrans-709
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪个关键字用于允许成员被重写？
- en: What’s the difference between a destructor and a deconstruct method?
  id: totrans-710
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 析构函数和解构方法的区别是什么？
- en: What are the signatures of the constructors that all exceptions should have?
  id: totrans-711
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 所有异常都应该有的构造函数的签名是什么？
- en: What is an extension method, and how do you define one?
  id: totrans-712
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 扩展方法是什么，以及如何定义一个？
- en: Exercise 6.4 – Explore topics
  id: totrans-713
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习6.4 – 探索主题
- en: 'Use the links on the following page to learn more about the topics covered
    in this chapter:'
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 使用下一页上的链接了解本章涵盖的主题：
- en: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes)'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes](https://github.com/markjprice/cs13net9/blob/main/docs/book-links.md#chapter-6---implementing-interfaces-and-inheriting-classes)'
- en: Summary
  id: totrans-716
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you learned about:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了以下内容：
- en: Operators
  id: totrans-718
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运算符
- en: Generic types
  id: totrans-719
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型
- en: Delegates and events
  id: totrans-720
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 委托和事件
- en: Implementing interfaces
  id: totrans-721
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现接口
- en: Memory usage differences between reference and value types
  id: totrans-722
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 引用类型和值类型之间的内存使用差异
- en: Working with null values
  id: totrans-723
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与空值一起工作
- en: Deriving and casting types using inheritance
  id: totrans-724
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用继承派生和转换类型
- en: Base and derived classes, how to override a type member, and using polymorphism
  id: totrans-725
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基类和派生类，如何重写类型成员，以及使用多态
- en: In the next chapter, you will learn how .NET is packaged and deployed, and in
    subsequent chapters, the types that it provides you with to implement common functionality,
    such as file handling and database access.
  id: totrans-726
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习.NET是如何打包和部署的，在随后的章节中，它为你提供的类型以实现常见功能，例如文件处理和数据库访问。
