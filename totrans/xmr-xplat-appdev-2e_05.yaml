- en: Chapter 5. XamChat for iOS
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章 XamChat for iOS
- en: In this chapter, we will develop the iOS portion of our cross-platform XamChat
    application. Since we are using the MVVM design pattern, most of the work we will
    be doing will be in the View layer of the application. We will mainly be working
    with native iOS APIs and understanding how we can apply them leverage the shared
    code in our portable class library. Since Xamarin.iOS enables us to call Apple
    APIs directly, our iOS app will be indistinguishable from an application developed
    in Objective-C or Swift.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将开发我们的跨平台XamChat应用程序的iOS部分。由于我们正在使用MVVM设计模式，我们将要做的大部分工作将在应用程序的视图层。我们将主要使用原生iOS
    API，并了解我们如何利用便携式类库中的共享代码来应用它们。由于Xamarin.iOS允许我们直接调用Apple API，我们的iOS应用程序将无法与使用Objective-C或Swift开发的程序区分开来。
- en: To begin writing the iOS version of XamChat, create a new **Single View Application**
    under the **iOS** section. Name the project `XamChat.iOS` or some other appropriate
    name of your choice. The project template will automatically create a controller
    with an unfamiliar name; go ahead and delete it. We will create our own controllers
    as we go.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始编写XamChat的iOS版本，请在**iOS**部分下创建一个新的**单视图应用程序**。将项目命名为`XamChat.iOS`或您选择的任何其他适当名称。项目模板将自动创建一个具有不熟悉名称的控制器；请继续删除它。我们将随着工作的进行创建自己的控制器。
- en: 'In this chapter, we will cover the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下内容：
- en: The basics of an iOS application
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: iOS应用程序的基本知识
- en: The use of `UINavigationController`
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`UINavigationController`
- en: Implementing a login screen
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现登录界面
- en: Segues and `UITableView`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 转场和`UITableView`
- en: Adding a friends list
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加好友列表
- en: Adding a list of messages
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加消息列表
- en: Composing messages
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息的编写
- en: Understanding the basics of an iOS app
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解iOS应用程序的基本知识
- en: Before we start developing our app, let's review the main settings of the application.
    Apple uses a file named `Info.plist` to store important information about any
    iOS app. These settings are used when an iOS application is installed on a device
    by the Apple App Store. We will begin development on any new iOS application by
    filling out the information in this file.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始开发我们的应用程序之前，让我们回顾一下应用程序的主要设置。Apple使用名为`Info.plist`的文件来存储有关任何iOS应用程序的重要信息。这些设置用于当iOS应用程序通过Apple应用商店安装到设备上时。我们将通过填写此文件中的信息开始任何新的iOS应用程序的开发。
- en: 'Xamarin Studio provides a neat menu to modify values in the `Info.plist` file,
    as shown in the following screenshot:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio提供了一个方便的菜单来修改`Info.plist`文件中的值，如下面的截图所示：
- en: '![Understanding the basics of an iOS app](img/00033.jpeg)'
  id: totrans-14
  prefs: []
  type: TYPE_IMG
  zh: '![理解iOS应用程序的基本知识](img/00033.jpeg)'
- en: 'The most important settings are as follows:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的设置如下：
- en: '**Application Name**: This is the title below an app''s icon in iOS. Note that
    this is not the same as the official name of your app in the iOS App Store.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序名称**：这是iOS中应用程序图标下的标题。请注意，这与您在iOS应用商店中应用程序的官方名称不同。'
- en: '**Bundle Identifier**: This is your app''s bundle identifier or bundle ID.
    It is a unique name to identify your application. The convention is to use a reverse
    domain naming style beginning with your company name, such as `com.packt.xamchat`.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捆绑标识符**：这是您的应用程序的捆绑标识符或捆绑ID。这是一个独特的名称，用于标识您的应用程序。惯例是使用以您的公司名称开始的反向域名命名风格，例如`com.packt.xamchat`。'
- en: '**Version**: This is a version number for your application such as `1.0.0`.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：这是您的应用程序的版本号，例如`1.0.0`。'
- en: '**Devices**: In this field you can select **iPhone/iPod**, **iPad**, or **Universal**
    (all devices) for your application.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**：在此字段中，您可以为您的应用程序选择**iPhone/iPod**、**iPad**或**通用**（所有设备）。'
- en: '**Deployment Target**: This is the minimum iOS version your application runs
    on.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署目标**：这是您的应用程序运行的最小iOS版本。'
- en: '**Main Interface**: This is the main storyboard file for your app that declares
    most of the UI of your application. iOS will automatically load this file and
    open the root controller as the initial screen to be displayed.'
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主界面**：这是您的应用程序的主要故事板文件，它声明了应用程序的大部分UI。iOS将自动加载此文件，并将根控制器作为初始屏幕打开。'
- en: '**Supported Device Orientations**: These are the different positions your application
    will be able to rotate to and support.'
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的设备方向**：这是您的应用程序能够旋转到的不同位置。'
- en: There are other settings for app icons, splash screens, and so on. You can also
    toggle between the **Advanced** or **Source** tabs to configure additional settings
    that Xamarin does not provide a user-friendly menu for.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他设置，如应用程序图标、启动画面等。您还可以在**高级**或**源**选项卡之间切换，以配置Xamarin不提供用户友好菜单的附加设置。
- en: 'Configure the following settings for our application:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 为我们的应用程序配置以下设置：
- en: '**Application Name**: `XamChat`'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序名称**：`XamChat`'
- en: '**Bundle Identifier**: `com.yourcompanyname.xamchat`; make sure that you name
    future apps beginning with `com.yourcompanyname`'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**捆绑标识符**：`com.yourcompanyname.xamchat`；请确保您将未来的应用程序命名为以`com.yourcompanyname`开头'
- en: '**Version**: This can be any version number you prefer, but it should just
    not be left blank'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本**：可以是您喜欢的任何版本号，但请不要留空'
- en: '**Devices**: **iPhone/iPod**'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**设备**：**iPhone/iPod**'
- en: '**Deployment Target**: 7.0 (you can also target 8.0, but we aren''t using any
    iOS 8-specific APIs in this app)'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**部署目标**：7.0（您也可以选择8.0，但在这个应用程序中我们没有使用任何iOS 8特定的API）'
- en: '**Supported Device Orientations**: Only select **Portrait**'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的设备方向**：仅选择**纵向**'
- en: You can find some additional settings for Xamarin iOS applications if you right-click
    on your project and select **Options**. It is a good idea to know what is available
    for iOS-specific projects in Xamarin Studio.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在项目上右键单击并选择**选项**，您可以找到一些Xamarin iOS应用程序的附加设置。了解Xamarin Studio中iOS特定项目可用的选项是个好主意。
- en: Let's discuss some of the most important options.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一些最重要的选项。
- en: Navigate to the **iOS Build** | **General** tab as shown in the following screenshot:![Understanding
    the basics of an iOS app](img/00034.jpeg)
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图导航到**iOS 构建** | **通用**选项卡：![理解iOS应用程序的基本知识](img/00034.jpeg)
- en: 'You have the following options under this tab:'
  id: totrans-34
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此选项卡下，您有以下选项：
- en: '**SDK version**: This is the version of the iOS SDK to compile your application
    with. It is generally best to use **Default**.'
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SDK 版本**：这是编译应用程序的iOS SDK版本。通常最好使用**默认**。'
- en: '**Linker behavior**: Xamarin has implemented a feature called **linking**.
    The linker will strip any code that will never be called within your assemblies.
    This keeps your application small and allows them to ship a stripped-down version
    of the core Mono framework with your app. Except for debug builds, it is best
    to use the **Link SDK assemblies only** option. We will cover linking in the next
    chapter.'
  id: totrans-36
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**链接器行为**：Xamarin实现了一个名为**链接**的功能。链接器将删除在您的程序集中永远不会被调用的任何代码。这使您的应用程序保持小巧，并允许它们与您的应用程序一起发布核心Mono框架的精简版。除了调试构建外，最好使用**仅链接SDK程序集**选项。我们将在下一章中介绍链接。'
- en: '**Optimize PNG files for iOS**: Apple uses a custom PNG format to speed up
    the loading of PNGs within your app. You can turn this off to speed up builds,
    or if you plan on optimizing the images yourself.'
  id: totrans-37
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**优化 iOS PNG 文件**：Apple使用自定义PNG格式来加快应用程序中PNG的加载速度。您可以选择关闭此选项以加快构建速度，或者如果您计划自己优化图像。'
- en: '**Enable debugging**: Turning this on allows Xamarin to include extra information
    with your app to enable debugging from Xamarin Studio.'
  id: totrans-38
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用调试**：开启此选项允许Xamarin在应用程序中包含额外的信息，以便从Xamarin Studio进行调试。'
- en: '**Additional mtouch arguments**: This field is for passing extra command-line
    arguments to the Xamarin compiler for iOS. You can check out the complete list
    of these arguments at [http://iosapi.xamarin.com](http://iosapi.xamarin.com).'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**额外的 mtouch 参数**：此字段用于向Xamarin编译器传递额外的命令行参数。您可以在[http://iosapi.xamarin.com](http://iosapi.xamarin.com)查看这些参数的完整列表。'
- en: Navigate to **iOS Build** | **Advanced** tab as shown in the following screenshot:![Understanding
    the basics of an iOS app](img/00035.jpeg)
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下截图导航到**iOS 构建** | **高级**选项卡：![理解iOS应用程序的基本知识](img/00035.jpeg)
- en: 'You have the following options under this tab:'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在此选项卡下，您有以下选项：
- en: '**Supported architectures**: Here, the options are **ARMv7**, **ARMv7s**, and
    a **FAT** version that includes both. These are instruction sets that different
    iOS device processors support. If you really care about performance, you might
    consider selecting the option to support both; however, this will make your application
    larger.'
  id: totrans-42
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**支持的架构**：这里，选项包括**ARMv7**、**ARMv7s**和包含两者的**FAT**版本。这些是不同iOS设备处理器支持的指令集。如果您真的关心性能，您可能需要考虑选择支持两者的选项；然而，这将使您的应用程序更大。'
- en: '**Use LLVM optimizing compiler**: Checking this compiles the code that is smaller
    and runs faster, but it takes longer to compile. **LLVM** stands for **Low Level
    Virtual Machine**.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 LLVM 优化编译器**：勾选此选项将编译出更小且运行速度更快的代码，但编译时间会更长。**LLVM**代表**低级虚拟机**。'
- en: '**Enable generic value type sharing**: This is an option specific to Mono that
    draws better performance from C# generics with value types. It has the downside
    of making the application slightly larger, but I would recommend that you leave
    it on.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用通用值类型共享**：这是一个针对 Mono 的特定选项，可以从 C# 通用值类型中获得更好的性能。缺点是会使应用程序略微增大，但我建议您保留此选项。'
- en: '**Use SGen generational garbage collector**: This uses the new Mono garbage
    collector in your app. I would recommend that you turn this on if you really need
    good performance with the **garbage collector** (**GC**) or are working on an
    app that needs to be responsive in real time, such as a game. It is probably safe
    to turn this on by default now, as the SGen garbage collector is very stable.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用 SGen 代际垃圾回收器**：这将在您的应用程序中使用新的 Mono 垃圾回收器。如果您确实需要良好的性能并且垃圾回收器（**GC**）或正在开发需要实时响应的应用程序，例如游戏，我建议您启用此功能。现在默认启用可能是安全的，因为
    SGen 垃圾回收器非常稳定。'
- en: '**Use the reference counting extension (preview)**: This is currently an experimental
    feature, but improves the general memory usage of native objects that are accessible
    from C#. These native object''s reference is managed by the GC instead of a backing
    field on the object when using this setting. Since it is still in preview, you
    should be careful when using this option.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用引用计数扩展（预览版）**：这是一个当前处于实验阶段的功能，但可以改善从 C# 访问的本地对象的内存使用。当使用此设置时，这些本地对象的引用由
    GC 管理而不是对象上的后备字段。由于它仍在预览中，使用此选项时应谨慎。'
- en: 'You have the following options under **iOS Bundle Signing**:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **iOS 包签名** 下，您有以下选项：
- en: '**Identity**: This is the certificate to identify the app''s creator for deploying
    the application to devices. We''ll cover more on this in later chapters.'
  id: totrans-48
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份**：这是用于将应用程序部署到设备的创建者身份的证书。我们将在后面的章节中详细介绍。'
- en: '**Provisioning profile**: This is a specific profile that deploys the app to
    a device. This works in tandem with Identity, but also declares the distribution
    method, and the devices that can install the app.'
  id: totrans-49
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**配置文件**：这是一个将应用程序部署到设备的特定配置文件。它与身份协同工作，但还声明了分发方法和可以安装应用程序的设备。'
- en: '**Custom Entitlements**: This file contains additional settings to be applied
    to the provisioning profile, and it contains other specific declarations for the
    app such as iCloud or push notifications. The project template for iOS apps includes
    a default `Entitlements.plist` file for new projects.'
  id: totrans-50
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义权限**：此文件包含应用于配置文件的其他设置，并包含对应用程序的其他特定声明，例如 iCloud 或推送通知。iOS 应用程序的模板项目包括一个默认的
    `Entitlements.plist` 文件用于新项目。'
- en: '**iOS Application**: These settings are identical to what you see in the `Info.plist`
    file.'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**iOS 应用程序**：这些设置与您在 `Info.plist` 文件中看到的是相同的。'
- en: For this application, you can leave all these options at their defaults. When
    making a real iOS application on your own, you should consider changing many of
    these as per your application's needs.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此应用程序，您可以将所有这些选项保留在默认设置。当您自己制作真正的 iOS 应用程序时，您应该考虑根据应用程序的需求更改其中许多设置。
- en: Using UINavigationController
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 UINavigationController
- en: In iOS applications, the key class that manages navigation between different
    controllers is the `UINavigationController` class. The navigation controller is
    the most basic building block of navigation on iOS, so it is the best choice to
    start with most of the iOS applications. It is a parent controller that contains
    several child controllers in a stack. Users can move forward by putting new controllers
    on top of the stack or using a built-in back button to pop a controller off the
    stack and navigate to the previous screen.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 iOS 应用程序中，管理不同控制器之间导航的关键类是 `UINavigationController` 类。导航控制器是 iOS 上导航的最基本构建块，因此它是大多数
    iOS 应用程序的最佳起点。它是一个包含多个子控制器在堆栈中的父控制器。用户可以通过将新控制器放在堆栈顶部或使用内置的返回按钮从堆栈中弹出控制器来前进，从而导航到上一个屏幕。
- en: Methods in Navigation Controllers
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 导航控制器中的方法
- en: 'The following are the methods in Navigation Controllers:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是在导航控制器中的方法：
- en: '`SetViewControllers`: This sets an array of child controllers. It has a value
    to optionally animate the transition.'
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SetViewControllers`：这设置一个子控制器数组。它有一个可选的值来动画过渡。'
- en: '`ViewControllers`: This is a property to get or set the array of child controllers
    without an option for animations.'
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewControllers`：这是一个获取或设置子控制器数组的属性，没有动画选项。'
- en: '`PushViewController`: This places a new child controller at the top of the
    stack with an option to display an animation.'
  id: totrans-59
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PushViewController`：这将在堆栈顶部放置一个新的子控制器，并可以选择显示动画。'
- en: '`PopViewControllerAnimated`: This pops off the child controller at the top
    of the stack with an option to animate the transition.'
  id: totrans-60
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PopViewControllerAnimated`：这将带有动画选项从堆栈顶部的子控制器中弹出。'
- en: '`PopToViewController`: This pops to the specified child controller, removing
    all controllers above it. It provides an option to animate the transition.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PopToViewController`：这将弹出指定的子控制器，移除其上方的所有控制器。它提供了一个动画转换的选项。'
- en: '`PopToRootViewController`: This removes all the child controllers except the
    bottom-most controller. It includes an option to display an animation.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PopToRootViewController`：这将移除除了最底层的控制器之外的所有子控制器。它包括一个显示动画的选项。'
- en: '`TopViewController`: This is a property that returns the child controller that
    is currently on top of the stack.'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TopViewController`：这是一个属性，它返回当前位于堆栈顶部的子控制器。'
- en: Tip
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: It is important to note that using the option for animations will cause a crash
    if you try to modify the stack during the animation. To fix this situation, either
    use the `SetViewControllers` method and set the entire list of child controllers,
    or refrain from using the animations during a combination of transitions.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，如果在使用动画选项的同时尝试修改动画过程中的堆栈，将会导致崩溃。为了解决这个问题，你可以使用`SetViewControllers`方法并设置整个子控制器列表，或者避免在组合转换中使用动画。
- en: Setting up a Navigation Controller
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置导航控制器
- en: 'Perform the following steps to set up a Navigation Controller:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤以设置导航控制器：
- en: Double-click on the `MainStoryboard.storyboard` file to open it in Xamarin Studio.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`MainStoryboard.storyboard`文件以在Xamarin Studio中打开它。
- en: Remove the controller that was created by the project template.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除由项目模板创建的控制器。
- en: Drag a **Navigation Controller** element from the **Toolbox** pane on the right-hand
    side onto the storyboard.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从右侧的**工具箱**面板中拖动一个**导航控制器**元素到故事板中。
- en: Notice that a default **View Controller** element was created as well as a **Navigation
    Controller** element.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，除了**视图控制器**元素外，还创建了一个**导航控制器**元素。
- en: You will see a **segue** that connects the two controllers. We'll cover this
    concept in more detail later in the chapter.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你将看到一个**segue**连接了两个控制器。我们将在本章的后面更详细地介绍这个概念。
- en: Save the storyboard file.
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存故事板文件。
- en: 'If you run the application at this point, you will have a basic iOS app with
    a status bar at the top, a navigation controller that contains a navigation bar
    with a default title, and a child controller that is completely white, as shown
    in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你将拥有一个基本的iOS应用程序，顶部有一个状态栏，一个包含默认标题的导航控制器，以及一个完全白色的子控制器，如下面的截图所示：
- en: '![Setting up a Navigation Controller](img/00036.jpeg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![设置导航控制器](img/00036.jpeg)'
- en: Implementing the login screen
  id: totrans-76
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现登录屏幕
- en: Since the first screen of our application will be a login screen, let's begin
    by setting up the appropriate views in the storyboard file. We will implement
    the login screen using Xamarin Studio to write the C# code, and its iOS designer
    to create iOS layouts in our storyboard file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们应用程序的第一个屏幕将是一个登录屏幕，让我们首先在故事板文件中设置适当的视图。我们将使用Xamarin Studio编写C#代码来实现登录屏幕，并使用iOS设计器在我们的故事板文件中创建iOS布局。
- en: Creating a LoginController class
  id: totrans-78
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建LoginController类
- en: 'Return to the project in Xamarin Studio and perform the following steps:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 返回Xamarin Studio中的项目并执行以下步骤：
- en: Double-click on the `MainStoryboard.storyboard` file to open it in the iOS designer.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`MainStoryboard.storyboard`文件以在iOS设计器中打开它。
- en: Select your view controller and click on the **Properties** pane and select
    the **Widget** tab.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的视图控制器，点击**属性**面板并选择**小部件**选项卡。
- en: Enter `LoginController` into the **Class** field.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类**字段中输入`LoginController`。
- en: Notice that the `LoginController` class is generated for you. You can create
    a `Controllers` folder and move the file in it if you wish.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 注意，`LoginController`类已经为你生成了。如果你愿意，你可以创建一个`Controllers`文件夹并将文件移入其中。
- en: 'The following screenshot shows you what the controller''s settings will look
    like in Xamarin Studio after the changes have been made:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了在做出更改后，Xamarin Studio中控制器的设置将看起来是什么样子：
- en: '![Creating a LoginController class](img/00037.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![创建LoginController类](img/00037.jpeg)'
- en: Modifying the controller's layout
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 修改控制器的布局
- en: 'Now let''s modify the layout of the controller by performing the following
    steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们通过以下步骤修改控制器的布局：
- en: Double-click on the `MainStoryboard.storyboard` file a second time to return
    to the iOS designer.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`MainStoryboard.storyboard`文件第二次，以返回到iOS设计器。
- en: Tap on the navigation bar and edit the **Title** field to read `Login`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击导航栏并编辑**标题**字段，使其显示为`登录`。
- en: Drag two text fields onto the controller. Position and size them appropriately
    for the username and password entries. You might also want to remove the default
    text to make the fields blank.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个文本字段拖放到控制器中。适当地定位和调整它们的大小，以适应用户名和密码输入。你可能还想删除默认文本，使字段为空。
- en: For the second field, check the **Secure Text Entry** checkbox. This will set
    the control to hide the characters for the password field.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于第二个字段，勾选**安全文本输入**复选框。这将使控件隐藏密码字段的字符。
- en: You might also want to fill out the **Placeholder** field for `Username` and
    `Password` respectively.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你可能还想分别为`用户名`和`密码`填写**占位符**字段。
- en: Drag a button onto the controller. Set the button's **Title** to `Login`.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个按钮拖放到控制器中。设置按钮的**标题**为`登录`。
- en: Drag an activity indicator onto the controller. Check the **Animating** and
    **Hidden** checkboxes.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将活动指示器拖放到控制器中。勾选**动画**和**隐藏**复选框。
- en: Next, create an outlet for each of the controls by filling out the **Name**
    field. Name the outlets `username`, `password`, `login`, and `indicator` respectively.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，为每个控件创建一个出口，通过填写**名称**字段。将出口命名为`username`、`password`、`login`和`indicator`。
- en: Save the storyboard file and take a look at `LoginController.designer.cs`.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存故事板文件，并查看`LoginController.designer.cs`。
- en: 'You will see that Xamarin Studio has generated properties for each of the outlets:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 你会发现Xamarin Studio为每个出口生成了属性：
- en: '![Modifying the controller''s layout](img/00038.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![修改控制器的布局](img/00038.jpeg)'
- en: Go ahead and compile the application to make sure that everything is okay. At
    this point, we also need to add a reference to the `XamChat.Core` project created
    in the previous chapter.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 继续编译应用程序以确保一切正常。在此阶段，我们还需要将`XamChat.Core`项目添加为引用，该项目是在上一章中创建的。
- en: Registering and subscribing view models and services
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册和订阅视图模型和服务
- en: 'Next, let''s set up our iOS application to register all of its view models
    and other services that will be used throughout the application. We will use the
    `ServiceContainer` class that we created in [Chapter 4](part0036_split_000.html#page
    "Chapter 4. XamChat – a Cross-platform App"), *XamChat – a Cross-platform App*,
    to set up the dependencies throughout our application. Open `AppDelegate.cs` and
    add the following method:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设置我们的iOS应用程序以注册其所有视图模型和其他将在整个应用程序中使用的服务。我们将使用在[第4章](part0036_split_000.html#page
    "第4章。XamChat – 一个跨平台应用")中创建的`ServiceContainer`类，*XamChat – 一个跨平台应用*，来设置我们应用程序中的依赖项。打开`AppDelegate.cs`并添加以下方法：
- en: '[PRE0]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Down the road, we will replace the fake services with the real ones. Now, let''s
    add the login functionality to `LoginController.cs`. First, add `LoginViewModel`
    to a member variable at the top of the class as follows:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在以后，我们将用真实的服务替换假的服务。现在，让我们将登录功能添加到`LoginController.cs`中。首先，将`LoginViewModel`添加到类顶部的成员变量中，如下所示：
- en: '[PRE1]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This will pull a shared instance of `LoginViewModel` into a local variable in
    the controller. This is the pattern that we will use throughout the book in order
    to pass a shared view model from one class to another.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这将把`LoginViewModel`的共享实例拖入控制器中的局部变量。这是我们将在整本书中使用的模式，以便将共享视图模型从一个类传递到另一个类。
- en: 'Next, override `ViewDidLoad` to hook up the view model''s functionality with
    the views set up in outlets as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，重写`ViewDidLoad`以将视图模型的功能与在出口中设置的视图连接起来，如下所示：
- en: '[PRE2]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We'll add the code to navigate to a new screen later in the chapter.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章的后面添加代码以导航到新屏幕。
- en: 'Next, let''s hook up the `IsBusyChanged` event to actually perform an action
    as follows:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将`IsBusyChanged`事件连接起来，以便执行以下操作：
- en: '[PRE3]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now you might be wondering, why we subscribe to the event in this manner. The
    problem is that the `LoginViewModel` class will last through your application's
    lifetime, while the `LoginController` class will not. If we subscribed to the
    event in `ViewDidLoad`, but didn't unsubscribe later, then our application will
    have a memory leak. We also avoided using a lambda expression for the event since
    it would otherwise be impossible to unsubscribe the event. Note that we don't
    have the same problem with the `TouchUpInside` event on the button, since it will
    live in memory as long as the controller does. This is a common problem with events
    in C#, which is why it is a good idea to use the preceding pattern on iOS.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可能想知道，为什么我们以这种方式订阅事件。问题是`LoginViewModel`类将贯穿你的应用程序生命周期，而`LoginController`类则不会。如果我们订阅了`ViewDidLoad`中的事件，但没有在之后取消订阅，那么我们的应用程序将出现内存泄漏。我们还避免了使用lambda表达式来处理事件，因为这会使取消订阅事件变得不可能。请注意，我们在按钮的`TouchUpInside`事件上没有遇到相同的问题，因为它将像控制器一样在内存中持续存在。这是C#中事件的一个常见问题，这就是为什么在iOS上使用前面提到的模式是一个好主意。
- en: If you run the application now, you should be able to enter a username and password,
    as shown in the following screenshot. When you press **Login**, you should see
    the indicator appear and all the controls disabled. Your application will correctly
    be calling the shared code, and should function correctly when we add a real web
    service.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你应该能够输入用户名和密码，如下面的截图所示。当你按下**登录**时，你应该看到指示器出现，所有控件被禁用。你的应用程序将正确调用共享代码，并且在我们添加真正的web服务时应该能够正确运行。
- en: '![Registering and subscribing view models and services](img/00039.jpeg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![注册和订阅视图模型和服务](img/00039.jpeg)'
- en: Using segues and UITableView
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用segue和UITableView
- en: A segue is a transition from one controller to another. In the same way, a storyboard
    file is a collection of controllers and their views attached together by segues.
    This, in turn, allows you to see the layouts of each controller and the general
    flow of your application at the same time.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: segue是从一个控制器到另一个控制器的过渡。同样，一个storyboard文件是由segue连接在一起的控制器和它们的视图的集合。这反过来又允许你同时看到每个控制器的布局和应用程序的一般流程。
- en: 'There are just a few categories of segue, which are as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: segue只有几种类型，如下所示：
- en: '**Push**: This is used within a navigation controller. It pushes a new controller
    to the top of the navigation controller''s stack. Push uses the standard animation
    technique for navigation controllers and is generally the most commonly used segue.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**推送**：这用于导航控制器内部。它将新的控制器推送到导航控制器堆栈的顶部。推送使用导航控制器的标准动画技术，通常是使用最频繁的segue。'
- en: '**Relationship**: This is used to set a child controller of another controller.
    For example, the root controller of a navigation controller, container views,
    or split view controllers in an iPad application.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系**：这用于设置另一个控制器的子控制器。例如，导航控制器的根控制器、容器视图或iPad应用程序中的分割视图控制器。'
- en: '**Modal**: On using this, a controller presented modally will appear on top
    of the parent controller. It will cover the entire screen until dismissed. There
    are several types of different transition animations available.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模式**：使用此模式时，一个模态控制器将出现在父控制器之上。它将覆盖整个屏幕，直到被取消。有几种不同的过渡动画可供选择。'
- en: '**Custom**: This is a custom segue that includes an option for a custom class,
    which subclasses `UIStoryboardSegue`. This gives you fine-grained control over
    the animation and how the next controller is presented.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自定义**：这是一个包含自定义类选项的自定义segue，该类是`UIStoryboardSegue`的子类。这让你可以精细控制动画以及下一个控制器的呈现方式。'
- en: 'Segues also use the following pattern while executing:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在执行过程中，segue还使用以下模式：
- en: The destination controller and its views are created.
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 目标控制器及其视图被创建。
- en: The segue object, a subclass of `UIStoryboardSegue`, is created. This is normally
    only important for custom segues.
  id: totrans-123
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建了一个segue对象，它是`UIStoryboardSegue`的子类。这通常只对自定义segue很重要。
- en: The `PrepareForSegue` method is called on the source controller. This is a good
    place to run any custom code before a segue begins.
  id: totrans-124
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在源控制器上调用`PrepareForSegue`方法。这是一个在segue开始前运行任何自定义代码的好地方。
- en: The segue's `Perform` method is called and the transition animation is started.
    This is where the bulk of the code resides for a custom segue.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用segue的`Perform`方法并开始过渡动画。这是自定义segue代码的主要部分。
- en: In the Xamarin.iOS designer, you have the choice of either firing a segue automatically
    from a button or table view row, or just giving the segue an identifier. In the
    second case, you can start the segue yourself by calling the `PerformSegue` method
    on the source controller using its identifier.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在Xamarin.iOS设计器中，你可以选择从按钮或表格视图行自动触发segues，或者只是给segues一个标识符。在第二种情况下，你可以通过在源控制器上调用其标识符的`PerformSegue`方法来自己启动segues。
- en: 'Now, let''s set up a new segue by setting up some aspects of our `MainStoryboard.storyboard`
    file by performing the following steps:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过执行以下步骤设置一个新的segues，通过设置`MainStoryboard.storyboard`文件的一些方面来设置：
- en: Double-click on the `MainStoryboard.storyboard` file to open it in the iOS designer.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`MainStoryboard.storyboard`文件以在iOS设计器中打开它。
- en: Add a new **Table View Controller** to the storyboard.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在故事板中添加一个新的**表格视图控制器**。
- en: Select your view controller and navigate to the **Properties** pane and the
    **Widget** tab.
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的视图控制器，并导航到**属性**面板和**小部件**选项卡。
- en: Enter `ConversationsController` into the **Class** field.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类**字段中输入`ConversationsController`。
- en: Scroll down under the **View Controller** section and enter **Title** of `Conversations`.
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**视图控制器**部分下方滚动，并输入`Conversations`的**标题**。
- en: Create a segue from `LoginController` to `ConversationsController` by clicking
    while holding *Ctrl* and dragging the blue line from one controller to the other.
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击并按住*Ctrl*，从`LoginController`拖动蓝色线到另一个控制器来创建从`LoginController`到`ConversationsController`的segues。
- en: Select the **push** segue from the popup that appears.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从出现的弹出菜单中选择**推送**segues。
- en: Select the segue by clicking on it and give it an **Identifier** of `OnLogin`.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击并选择segues，给它一个**标识符**为`OnLogin`。
- en: Save the storyboard file.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存故事板文件。
- en: 'Your storyboard will look something similar to what is shown in the following
    screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 你的故事板将看起来类似于以下截图所示：
- en: '![Using segues and UITableView](img/00040.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![使用segues和UITableView](img/00040.jpeg)'
- en: 'Open `LoginController.cs`, and modify the line of code that we marked as `TODO`
    earlier in this chapter as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 打开`LoginController.cs`，并修改本章前面标记为`TODO`的代码行如下：
- en: '[PRE4]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now if you build and run the application, you will navigate to the new controller
    after a successful log in. The segue will be performed, and you will see the built-in
    animation provided by the navigation controller.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你构建并运行应用程序，你将在成功登录后导航到新的控制器。将执行segues，你将看到导航控制器提供的内置动画。
- en: Next, let's set up the table view on the second controller. We are using a powerful
    class on iOS called `UITableView`. It is used in many situations and is very similar
    to the concept of a list view on other platforms. The `UITableView` class is controlled
    by another class called `UITableViewSource`. It has methods that you need to override
    to set up how many rows should exist and how these rows should be displayed on
    the screen.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设置第二个控制器上的表格视图。我们在iOS上使用一个强大的类`UITableView`。它在许多情况下都得到使用，并且与其他平台上的列表视图概念非常相似。`UITableView`类由另一个名为`UITableViewSource`的类控制。它有你需要覆盖的方法来设置应该有多少行以及这些行应该如何显示在屏幕上。
- en: Tip
  id: totrans-143
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: Note that `UITableViewSource` is a combination of `UITableViewDelegate` and
    `UITableViewDataSource`. I prefer to use `UITableViewSource` for simplicity, since
    many times using both of the other two classes would be required.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`UITableViewSource`是`UITableViewDelegate`和`UITableViewDataSource`的组合。我更喜欢使用`UITableViewSource`以保持简单，因为很多时候需要使用这两个其他类中的任何一个。
- en: 'Before we jump in and start coding, let''s review the most commonly used methods
    on `UITableViewSource`, which are as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编码之前，让我们回顾一下在`UITableViewSource`中最常用的方法，如下所示：
- en: '`RowsInSection`: This method allows you to define the number of rows in a section.
    All the table views have a number of sections and rows. By default, there is only
    one section; however, it is a requirement to return the number of rows in a section.'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RowsInSection`：此方法允许你定义一个部分中的行数。所有的表格视图都有部分和行数。默认情况下，只有一个部分；然而，返回部分中的行数是一个要求。'
- en: '`NumberOfSections`: This is the number of sections in the table view.'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NumberOfSections`：这是表格视图中部分的数目。'
- en: '`GetCell`: This method must return a cell for each row and should be implemented.
    It is up to the developer to set up how a cell should look like; you can also
    implement code to recycle the cells as you scroll. Recycling cells will yield
    better performance while scrolling.'
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCell`：此方法必须为每一行返回一个单元格，并且应该实现。开发者负责设置单元格的外观；你还可以实现代码，在滚动时回收单元格。回收单元格将在滚动时提供更好的性能。'
- en: '`TitleForHeader`: This method, if overridden, is the simplest way to return
    a string for the title. Each section in a table view has a standard header view,
    by default.'
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TitleForHeader`：如果重写此方法，返回标题字符串的最简单方式。表格视图中的每个部分都有一个标准的头部视图，默认情况下。'
- en: '`RowSelected`: This method will be called when the user selects a row.'
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RowSelected`：当用户选择一行时，将调用此方法。'
- en: There are additional methods that you can override, but these will get you by
    in most situations. You can also set up custom headers and footers if you need
    to develop a custom styled table view.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以重写额外的方法，但这些都足以应对大多数情况。如果你需要开发具有自定义样式的表格视图，你也可以设置自定义头部和尾部。
- en: 'Now, let''s open the `ConversationsController.cs` file, and create a nested
    class inside `ConversationsController` as follows:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开 `ConversationsController.cs` 文件，并在 `ConversationsController` 中创建一个嵌套类，如下所示：
- en: '[PRE5]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We implemented the two required methods to set up a table view: `RowsInSection`
    and `GetCell`. We returned the number of conversations found on the view model
    and set up our cell for each row. We also used `UITableViewCellAccessory.DisclosureIndicator`
    to add an indicator for the users to know that they can click on the row.'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们实现了设置表格视图所需的两个方法：`RowsInSection` 和 `GetCell`。我们返回了在视图模型中找到的对话数量，并为每一行设置了我们的单元格。我们还使用了
    `UITableViewCellAccessory.DisclosureIndicator` 来为用户提供一个指示器，让他们知道可以点击该行。
- en: Notice our implementation of recycling cells. Calling `DequeueReusableCell`
    with a cell identifier will return a `null` cell the first time around. If `null`,
    you should create a new cell using the same cell identifier. Subsequent calls
    to `DequeueReusableCell` will return an existing cell, enabling you to reuse it.
    You can also define the `TableView` cells in the storyboard file, which is useful
    for custom cells. Our cell here is very simple, so it is easier to define it from
    the code. Recycling cells is important on mobile platforms to preserve memory
    and provide the user with a very fluid scrolling table.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们实现的重用单元格。使用带有单元格标识符的 `DequeueReusableCell` 调用将第一次返回一个 `null` 单元格。如果为 `null`，你应该使用相同的单元格标识符创建一个新的单元格。随后的
    `DequeueReusableCell` 调用将返回一个现有的单元格，使你能够重用它。你还可以在故事板文件中定义 `TableView` 单元格，这对于自定义单元格非常有用。我们这里的单元格非常简单，因此从代码中定义它更容易。在移动平台上重用单元格对于节省内存和为用户提供非常流畅的滚动表格非常重要。
- en: 'Next, we need to set up the `TableView` source on `TableView`. Add some changes
    to our `ConversationsController` class as follows:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `TableView` 上设置 `TableView` 的源。按照以下步骤修改我们的 `ConversationsController`
    类：
- en: '[PRE6]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: So when the view appears, we will load our list of conversations. Upon completion
    of this task, we'll reload the table view so that it displays our list of conversations.
    If you run the application, you'll see a few conversations appear in the table
    view after logging in, as shown in the following screenshot. Down the road, everything
    will operate in the same manner when we load the conversations from a real web
    service.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当视图出现时，我们将加载我们的对话列表。完成此任务后，我们将重新加载表格视图，以便它显示我们的对话列表。如果你运行应用程序，你将在登录后看到一些对话出现在表格视图中，如下面的截图所示。将来，当我们从真实的网络服务加载对话时，一切都将以相同的方式运行。
- en: '![Using segues and UITableView](img/00041.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![使用转场和UITableView](img/00041.jpeg)'
- en: Adding a friends list screen
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加朋友列表屏幕
- en: The next fairly important screen is that of our friends list. When creating
    a new conversation, the app will load a list of friends to start a conversation
    with. We'll follow a very similar pattern to load our list of conversations.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个相当重要的屏幕是我们朋友的列表。当创建新的对话时，应用将加载一个朋友列表以开始对话。我们将遵循一个非常相似的模式来加载我们的对话列表。
- en: 'To begin, we''ll create `UIBarButtonItem` that navigates to a new controller
    named `FriendsController` by performing the following steps:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将创建 `UIBarButtonItem`，通过执行以下步骤导航到一个名为 `FriendsController` 的新控制器：
- en: Double-click on the `MainStoryboard.storyboard` file to open it in the iOS designer.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击 `MainStoryboard.storyboard` 文件以在 iOS 设计器中打开它。
- en: Add a new **Table View Controller** to the storyboard.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在故事板中添加一个新的 **表格视图控制器**。
- en: Select your view controller and click on the **Properties** pane and make sure
    you have selected the **Widget** tab.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的视图控制器，点击 **属性** 面板，确保你已经选择了 **小部件** 选项卡。
- en: Enter `FriendsController` in the **Class** field.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **类** 字段中输入 `FriendsController`。
- en: Scroll down to the **View Controller** section, enter `Friends` in the **Title**
    field.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到 **视图控制器** 部分，在 **标题** 字段中输入 `Friends`。
- en: Drag a **Navigation Item** from the **Toolbox** pane onto the `ConversationsController`.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **工具箱** 面板拖动一个 **导航项** 到 `ConversationsController`。
- en: Create a new **Bar Button Item** element and place it in the top-right corner
    of the new navigation bar.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**栏按钮项**元素，并将其放置在新导航栏的右上角。
- en: In the **Properties** pane of the bar button, set its **Identifier** to **Add**.
    This will use the built-in plus button, which is commonly used throughout iOS
    applications.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在按钮栏的**属性**面板中，将其**标识符**设置为**添加**。这将使用内置的加号按钮，这在iOS应用程序中普遍使用。
- en: Create a segue from **Bar Button Item** to the `FriendsController` by holding
    *Ctrl* and dragging the blue line from the bar button to the next controller.
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按住*Ctrl*并从栏按钮拖动蓝色线条到下一个控制器，创建从**栏按钮项**到`FriendsController`的转换。
- en: Select the **push** segue from the popup that appears.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从出现的弹出窗口中选择**推送**转换。
- en: Save the storyboard file.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存故事板文件。
- en: 'Your changes to the storyboard should look something similar to what is shown
    in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 你对故事板的更改应类似于以下截图所示：
- en: '![Adding a friends list screen](img/00042.jpeg)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![添加朋友列表屏幕](img/00042.jpeg)'
- en: You will see a new `FriendsController` class that Xamarin Studio has generated
    for you. If you compile and run the application, you'll see the new bar button
    item we created. Clicking on it will take you to the new controller.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 你将看到一个Xamarin Studio为你生成的新的`FriendsController`类。如果你编译并运行应用程序，你会看到我们创建的新栏按钮项。点击它将带你到新的控制器。
- en: 'Now, let''s implement `UITableViewSource` to display our friends list. Start
    with a new nested class inside `FriendsController` as follows:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现`UITableViewSource`来显示我们的朋友列表。从在`FriendsController`内部创建一个新的嵌套类开始，如下所示：
- en: '[PRE7]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Just as before, we implemented table cell recycling and merely set the text
    on the label for each friend. We used `cell.AccessoryView` to indicate to the
    user that each cell is clickable and starts a new conversation. We disabled the
    user interaction on the button just to allow the row to be selected when the user
    clicks on the button. Otherwise, we'd have to implement a click event for the
    button.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们实现了表格单元格回收，并且只为每个朋友设置了标签上的文本。我们使用`cell.AccessoryView`来向用户指示每个单元格是可点击的，并开始一个新的对话。我们禁用了按钮的用户交互，以便在用户点击按钮时可以选择行。否则，我们就必须为按钮实现一个点击事件。
- en: 'Next, we''ll need to modify `FriendsController` in the same way as we did for
    conversations, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要像修改对话一样修改`FriendsController`，如下所示：
- en: '[PRE8]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This will function exactly as the conversations list. The controller will load
    the friends list asynchronously and refresh the table view. If you compile and
    run the application, you''ll be able to navigate to the screen and view the sample
    friend list we created in [Chapter 4](part0036_split_000.html#page "Chapter 4. XamChat
    – a Cross-platform App"), *XamChat – a Cross-platform App*, as shown in the following
    screenshot:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 这将完全像对话列表一样工作。控制器将异步加载朋友列表并刷新表格视图。如果你编译并运行应用程序，你将能够导航到屏幕并查看我们在[第4章](part0036_split_000.html#page
    "第4章。XamChat – 一个跨平台应用")中创建的示例朋友列表，如以下截图所示：
- en: '![Adding a friends list screen](img/00043.jpeg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![添加朋友列表屏幕](img/00043.jpeg)'
- en: Adding a list of messages
  id: totrans-184
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加消息列表
- en: Now let's implement the screen to view a conversation or list of messages. We
    will try to model the screen after the built-in text message application on iOS.
    To do so, we will also cover the basics of how to create custom table view cells.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们实现查看对话或消息列表的屏幕。我们将尝试模仿iOS内置的短信应用程序。为此，我们还将介绍如何创建自定义表格视图单元格的基础知识。
- en: 'To start, we''ll need a new `MessagesController` class to perform the following
    steps:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个新的`MessagesController`类来执行以下步骤：
- en: Double-click on the `MainStoryboard.storyboard` file to open it in the iOS designer.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`MainStoryboard.storyboard`文件以在iOS设计器中打开它。
- en: Add a new **Table View Controller** to the storyboard.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在故事板中添加一个新的**表格视图控制器**。
- en: Select your view controller and click on the **Properties** pane and make sure
    you have selected the **Widget** tab.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择你的视图控制器，点击**属性**面板，并确保你已选择**小部件**选项卡。
- en: Enter `MessagesController` in the **Class** field.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**类**字段中输入`MessagesController`。
- en: Scroll down to the **View Controller** section, enter `Messages` in the **Title**
    field.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 滚动到**视图控制器**部分，在**标题**字段中输入`Messages`。
- en: Create a segue from `ConversationsController` to `MessagesController` by holding
    *Ctrl* and dragging the blue line from one controller to the other.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按住*Ctrl*并将蓝色线条从一个控制器拖动到另一个控制器，从`ConversationsController`创建到`MessagesController`的转换。
- en: Select the **push** segue from the popup that appears. Enter the **Identifier**
    `OnConversation` in the **Properties** pane.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从出现的弹出窗口中选择**推送**转换。在**属性**面板中输入**标识符**`OnConversation`。
- en: Now, create two **Table View Cells** in the table view in `MessagesController`.
    You can reuse the existing one created, by default.
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`MessagesController`中的表格视图中创建两个**表格视图单元格**。你可以通过默认创建的现有一个来重用。
- en: Enter `MyMessageCell` and `TheirMessageCell` respectively into the **Class**
    field for each cell.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别将`MyMessageCell`和`TheirMessageCell`输入到每个单元格的**类**字段中。
- en: Set the **Identifier** to `MyCell` and `TheirCell` respectively on each cell.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分别在每个单元格上将**标识符**设置为`MyCell`和`TheirCell`。
- en: Save the storyboard file.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存故事板文件。
- en: 'Xamarin Studio will generate three files: `MessagesController.cs`, `MyMessageCell.cs`,
    and `TheirMessageCell.cs`. You might decide to keep things organized by creating
    a `Views` folder and moving the cells into it. Likewise, you can move the controller
    to a `Controllers` folder.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: Xamarin Studio将生成三个文件：`MessagesController.cs`、`MyMessageCell.cs`和`TheirMessageCell.cs`。你可以通过创建一个`Views`文件夹并将单元格移动到其中来保持事物有序。同样，你也可以将控制器移动到`Controllers`文件夹。
- en: 'Now let''s implement a base class for both these cells to inherit from:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们为这两个单元格实现一个基类：
- en: '[PRE9]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: We will override the `Update` method later and take the appropriate action for
    each cell type. We need this class to make things easier while interacting with
    both the types of cells from `UITableViewSource`.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在稍后重写`Update`方法并为每种单元格类型采取适当的行动。我们需要这个类来使与`UITableViewSource`中的两种单元格类型交互更容易。
- en: 'Now open `MessagesController.cs` and implement `UITableViewSource` inside a
    nested class, as follows:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在打开`MessagesController.cs`并在嵌套类中实现`UITableViewSource`，如下所示：
- en: '[PRE10]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: We added some logic to check whether a message is from a current user to decide
    on the appropriate table cell identifier. Since we have a base class for both
    cells, we can cast to `BaseMessageCell` and use its `Update` method.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一些逻辑来检查消息是否来自当前用户，以决定适当的表格视图标识符。由于我们为两个单元格都有一个基类，我们可以将其转换为`BaseMessageCell`并使用其`Update`方法。
- en: 'Now let''s make the changes to our `MessagesController` file to load our list
    of messages and display them:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们修改`MessagesController`文件以加载我们的消息列表并显示它们：
- en: '[PRE11]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The only thing new here is where we set the `Title` property to the username
    of the conversation.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 这里唯一的新内容是我们将`Title`属性设置为对话的用户名。
- en: 'To complete our custom cells, we will need to make more changes in Xcode by
    performing the following steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成我们的自定义单元格，我们需要在Xcode中执行以下步骤进行更多更改：
- en: Double-click on the `MainStoryboard.storyboard` file to open it in the iOS designer.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 双击`MainStoryboard.storyboard`文件以在iOS设计器中打开它。
- en: Drag a new **Label** onto both the custom cells.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的**标签**拖放到自定义单元格上。
- en: Use some creativity to style both labels. I chose to make the text in `MyMessageCell`
    blue and `TheirMessageCell` green. I set **Alignment** on the label to the right
    aligned in `TheirMessageCell`.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用一些创意来设计这两个标签。我选择将`MyMessageCell`中的文本设置为蓝色，将`TheirMessageCell`设置为绿色。我在`TheirMessageCell`中将标签的**对齐方式**设置为右对齐。
- en: For the **Name** of each cell, enter `message`.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对于每个单元格的**名称**，输入`message`。
- en: Save the storyboard file and return.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存故事板文件并返回。
- en: 'Now add the following `Update` method to both `MyMessageCell.cs` and `TheirMessageCell.cs`:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将以下`Update`方法添加到`MyMessageCell.cs`和`TheirMessageCell.cs`中：
- en: '[PRE12]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: It is a bit strange to have duplicated the code for each cell, but it is the
    simplest approach to take advantage of the outlets Xamarin Studio generated based
    on the storyboard file. You could also have chosen to use the same class for both
    cells (even with a different layout in Xcode); however, you then lose the ability
    to have different code in each cell.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每个单元格重复代码有点奇怪，但这是利用Xamarin Studio基于故事板文件生成的输出端口的最简单方法。你也可以选择为两个单元格使用相同的类（即使在Xcode中有不同的布局）；然而，这样你将失去在每个单元格中拥有不同代码的能力。
- en: 'If you run the application now, you will be able to view the messages list,
    as displayed in the following screenshot:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在运行应用程序，你将能够查看消息列表，如下面的截图所示：
- en: '![Adding a list of messages](img/00044.jpeg)'
  id: totrans-218
  prefs: []
  type: TYPE_IMG
  zh: '![添加消息列表](img/00044.jpeg)'
- en: Composing messages
  id: totrans-219
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息的编写
- en: For the final piece of our application, we need to implement some custom functionality
    that Apple doesn't provide with their APIs. We need to add a text field with a
    button that appears to be attached to the bottom of the table view. Most of this
    will require writing code and wiring up a lot of events.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们应用程序的最后一部分，我们需要实现一些苹果在他们的API中没有提供的自定义功能。我们需要添加一个带有按钮的文本字段，该按钮看起来像是附着在表格视图的底部。这大部分需要编写代码和连接大量事件。
- en: 'Let''s begin by adding some new member variables to our `MessagesController`
    class as follows:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向我们的`MessagesController`类添加一些新的成员变量开始，如下所示：
- en: '[PRE13]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'We will place the text field and bar buttons inside the toolbar, as shown in
    the following code. The `NSObject` fields will be an example of iOS''s event system
    called **notifications**. We''ll see how these are used shortly:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文本字段和工具栏按钮放置在工具栏内，如下面的代码所示。`NSObject`字段将是一个iOS事件系统**通知**的示例。我们很快就会看到这些是如何使用的：
- en: '[PRE14]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Much of this work involves setting up a basic UI. It is not something we can
    do inside Xcode, because it's a custom UI in this case. We create a text field,
    bar button item, and toolbar from C# and add them to our navigation controller's
    view. This will display the toolbar at the top of the table view, no matter where
    it is scrolled to. Another trick we used was to add a footer view to the table
    view, which is of the same height as the toolbar. This will simplify some animations
    that we'll set up later.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 这项工作的大部分涉及设置基本的UI。在这种情况下，我们无法在Xcode中完成这项工作，因为它是一个自定义UI。我们使用C#创建一个文本字段、工具栏按钮和工具栏，并将它们添加到我们的导航控制器视图中。这将显示在表格视图顶部的工具栏，无论它滚动到何处。我们使用的另一个技巧是将一个页脚视图添加到表格视图中，其高度与工具栏相同。这将简化我们稍后设置的某些动画。
- en: 'Now we will need to modify `ViewWillAppear` as follows:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要按照以下方式修改`ViewWillAppear`：
- en: '[PRE15]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Most of these changes are straightforward, but notice our use of iOS notifications.
    Xamarin has provided a C# friendly way to subscribe to notifications. There is
    a static nested class named `Notifications` inside various `UIKit` classes that
    provide notifications. Otherwise, you would have to use the `NSNotificationCenter`
    class, which is not as easy to use. To unsubscribe from these events, we merely
    need to dispose `NSObject` that is returned.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 这些更改中的大多数都很直接，但请注意我们使用iOS通知的方式。Xamarin提供了一个C#友好的方式来订阅通知。在提供通知的各种`UIKit`类中有一个名为`Notifications`的静态嵌套类。否则，您将不得不使用`NSNotificationCenter`类，这并不那么容易使用。要取消订阅这些事件，我们只需销毁返回的`NSObject`。
- en: 'So let''s add an override for `ViewWillDisapper` to clean up these events,
    as follows:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们为`ViewWillDisapper`添加一个覆盖，以清理这些事件，如下所示：
- en: '[PRE16]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Next, let''s set up our methods for these events, as follows:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们设置这些事件的函数，如下所示：
- en: '[PRE17]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: That is quite a bit of code, but not too difficult. `OnIsBusyChanged` is used
    to disable some of our views while it is loading. `ScrollToEnd` is a quick method
    to scroll the table view to the end. We need this for the sake of usability. Some
    math is required because Apple does not provide a built-in method for this.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码相当多，但并不太难。`OnIsBusyChanged`用于在加载时禁用一些视图。`ScrollToEnd`是一个快速方法，用于将表格视图滚动到末尾。我们需要这样做是为了提高可用性。需要一些数学知识，因为苹果没有提供内置的方法来做这个。
- en: On the other hand, `OnKeyboardNotification` has quite a lot going on. We used
    the built-in animation system for iOS to set up an animation when the keyboard
    appears or hides. We use this to move views around for the onscreen keyboard.
    Using the animation system is quite easy; call `UIView.BeginAnimations`, modify
    some views, and then finish up with `UIView.CommitAnimations`. We also used a
    few more values from the keyboard to time our animation identically with the keyboard's
    animations.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，`OnKeyboardNotification`有很多事情要做。我们使用了iOS内置的动画系统来设置当键盘出现或隐藏时的动画。我们使用这个来移动视图以适应屏幕键盘。使用动画系统相当简单；调用`UIView.BeginAnimations`，修改一些视图，然后使用`UIView.CommitAnimations`完成。我们还使用了键盘的一些其他值来使我们的动画与键盘的动画同步。
- en: 'Last but not least, we need to implement a function to send a new message as
    follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 最后但同样重要的是，我们需要实现一个函数来发送一条新消息，如下所示：
- en: '[PRE18]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This code is also fairly straightforward. After sending the message, we merely
    need to reload the table, hide the keyboard, and then make sure we scroll to the
    bottom to see the new message, as shown in the following screenshot. Using the
    `async` keyword makes this easy.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也很直接。在发送消息后，我们只需重新加载表格，隐藏键盘，然后确保我们滚动到底部以查看新消息，如下面的截图所示。使用`async`关键字使这变得容易。
- en: '![Composing messages](img/00045.jpeg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![编写消息](img/00045.jpeg)'
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered the basic settings that Apple and Xamarin provide
    for developing iOS applications. This includes the `Info.plist` file and project
    options in Xamarin Studio. We covered `UINavigationController`, the basic building
    block for navigation in iOS applications, and implemented a login screen complete
    with username and password fields. Next, we covered iOS segues and the `UITableView`
    class. We implemented the friends list screen using `UITableView`, and the messages
    list screen, also using `UITableView`. Lastly, we added a custom UI functionality;
    a custom toolbar floating at the bottom of the messages list.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 Apple 和 Xamarin 为开发 iOS 应用程序提供的基本设置。这包括 `Info.plist` 文件和 Xamarin
    Studio 中的项目选项。我们介绍了 `UINavigationController`，这是 iOS 应用程序导航的基本构建块，并实现了一个包含用户名和密码字段的登录屏幕。接下来，我们介绍了
    iOS 的 segues 和 `UITableView` 类。我们使用 `UITableView` 实现了好友列表屏幕，以及消息列表屏幕，同样也是使用 `UITableView`。最后，我们添加了自定义
    UI 功能；一个在消息列表底部浮动的自定义工具栏。
- en: After completing this chapter, you will have a partially functional iOS version
    of XamChat. You will have a deeper understanding of the iOS platform and tools,
    and fairly good knowledge to apply to building your own iOS applications. Take
    it upon yourself to implement the remaining screens that we did not cover in the
    chapter. If you get lost, feel free to review the full sample application included
    with this book. In the next chapter, we will develop the Android UI for XamChat
    using the native Android APIs. A lot of our steps will be very similar to what
    we did on iOS, and we will be working mainly with the View layer of the MVVM design
    pattern.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章内容后，你将拥有一个部分功能的 iOS 版本 XamChat。你将对 iOS 平台和工具有更深入的了解，并且具备相当好的知识来应用于构建你自己的
    iOS 应用程序。请自行实现本章未涵盖的剩余屏幕。如果你感到困惑，可以随意查阅本书附带的全样本应用程序。在下一章中，我们将使用原生 Android API
    开发 XamChat 的 Android UI。我们的大部分步骤将与在 iOS 上所做的工作非常相似，我们将主要与 MVVM 设计模式中的 View 层进行工作。
