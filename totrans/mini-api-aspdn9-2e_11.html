<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-135">
    <a id="_idTextAnchor165">
    </a>
    
     11
    
   </h1>
   <h1 id="_idParaDest-136">
    <a id="_idTextAnchor166">
    </a>
    
     Utilizing Asynchronous Programming for Scalability
    
   </h1>
   <p>
    
     Whenever we execute a function, we expect a result, but what happens between the request and the
    
    
     
      outputted result?
     
    
   </p>
   <p>
    
     Imagine you’re in town, and you have a bunch of errands to run, but you’re also hungry and need to eat lunch.
    
    
     You walk into a pizza shop, situated within a shopping mall.
    
    
     The shop cooks fresh pizza to order.
    
    
     It takes around fifteen minutes for the pizza to be prepped and then cooked.
    
    
     You can wait around in the shop until the pizza is done, but you need to go to the bank, which has a branch across the road.
    
    
     The pizza store owner is a friend of yours and agrees to text you when your pizza is ready to pick up.
    
    
     You have an opportunity to get something else done while your pizza is cooking; that’s a much better use of
    
    
     
      your time.
     
    
   </p>
   <p>
    
     This is a simple analogy for an
    
    <strong class="bold">
     
      asynchronous
     
    </strong>
    
     function.
    
    
     The act of walking into the pizza shop is the
    
    <a id="_idIndexMarker441">
    </a>
    
     function starting, and you running over to the bank while it is cooking is the function running.
    
    
     When your phone beeps with a text to say the pizza is ready, that is the function returning
    
    
     
      its output.
     
    
   </p>
   <p>
    
     This example demonstrates the benefits of an asynchronous function, which allows for the execution of other tasks while waiting for a specific operation to complete.
    
    
     Cooking your pizza doesn’t block your overall goal, which is to run
    
    
     
      your errands.
     
    
   </p>
   <p>
    
     If the pizza shop owner was a lot less friendly and demanded that you wait in the shop until the pizza was done, that would be an example
    
    <a id="_idIndexMarker442">
    </a>
    
     of a
    
    <strong class="bold">
     
      synchronous
     
    </strong>
    
     operation, the opposite of asynchronous.
    
    
     Synchronous operations block the progression of your overall goal (running your errands) until the current operation
    
    
     
      is complete.
     
    
   </p>
   <p>
    
     Where possible, we want to reap the benefits of asynchronous programming for operations that are executing as part of
    
    
     
      minimal APIs.
     
    
   </p>
   <p>
    
     In this chapter, we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Understanding and implementing asynchronous patterns in a
     
     
      
       minimal API
      
     
    </li>
    <li>
     
      Common pitfalls
     
     
      
       and challenges
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-137">
    <a id="_idTextAnchor167">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     The code for this chapter is available in the GitHub repository at:
    
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     
      https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9
     
    </a>
    
     .
    
    
     Visual Studio with the .NET 9 SDK is required to run
    
    
     
      the code.
     
    
   </p>
   <h1 id="_idParaDest-138">
    <a id="_idTextAnchor168">
    </a>
    
     Understanding and implementing asynchronous patterns in a minimal API
    
   </h1>
   <p>
    
     The opening pizza
    
    <a id="_idIndexMarker443">
    </a>
    
     analogy is hopefully a good, high-level illustration of the difference between asynchronous and synchronous programming.
    
    
     Asynchronous programming is significant in minimal APIs because it provides a lot of flexibility for managing the conversations between client and server.
    
    
     It is particularly beneficial to long-running operations, where the overall performance of a request would be compromised by operations running in a linear fashion, with each operation blocking
    
    
     
      the other.
     
    
   </p>
   <p>
    
     Asynchronous programming also provides scalability benefits, allowing APIs to cope with high demand.
    
    
     This is achieved by ensuring that threads are not blocked.
    
    
     Operations in an asynchronous endpoint can register callbacks to ensure that the execution thread can continue running other tasks until that callback is resolved.
    
    
     This brings with it other resource benefits such as better management of the thread pool, lower CPU consumption, and decreased memory footprint.
    
    
     All of these things are crucial for minimal APIs, which are designed to be as straightforward and efficient
    
    
     
      as possible.
     
    
   </p>
   <h2 id="_idParaDest-139">
    <a id="_idTextAnchor169">
    </a>
    
     Task-based asynchronous pattern
    
   </h2>
   <p>
    
     .NET has seen
    
    <a id="_idIndexMarker444">
    </a>
    
     the use of several different asynchronous programming patterns on its journey from .NET
    
    <a id="_idIndexMarker445">
    </a>
    
     Framework to  .NET core.
    
    
     In the .NET Framework days, the
    
    <strong class="bold">
     
      Task-based Asynchronous Pattern
     
    </strong>
    
     (
    
    <strong class="bold">
     
      TAP
     
    </strong>
    
     ) was the preferred method for managing asynchronous execution.
    
    
     Introduced in the Task Parallel Library in .NET 4, it uses
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Task&lt;T&gt;
     
    </strong>
    
     to represent asynchronous operations and to provide a way to handle their results or exceptions.
    
    
     The explicit implementation of the TAP is now obsolete in .NET 9, but the example is effective at demonstrating asynchronous operations.
    
    
     If we were to use it in a minimal API, it would be situated in the body of an endpoint, with the establishment of a
    
    <strong class="source-inline">
     
      Task&lt;T&gt;
     
    </strong>
    
     , which would execute a long-running task.
    
    
     We would then start the
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     while at the same time telling it what logic it should call back to once it has finished.
    
    
     We can see this in this example, which runs a task to grab data from another API and then continues by checking the result
    
    <a id="_idIndexMarker446">
    </a>
    
     before returning a response to
    
    
     
      the
     
    
    
     <a id="_idIndexMarker447">
     </a>
    
    
     
      client:
     
    
   </p>
   <pre class="source-code">
app.MapGet("/fetch-data", (HttpContext httpContext) =&gt;
{
    HttpClient client = new HttpClient();
    string url =
        "https://jsonplaceholder.typicode.com/posts/1";
    // Initiate the asynchronous operation and return a
    // continuation task
    return client.GetStringAsync(url).ContinueWith(task =&gt;
    {
        if (task.IsCompletedSuccessfully)
        {
            // Task completed successfully, return the data
            return httpContext.Response.WriteAsJsonAsync(
                new { data = task.Result }
            );
        }
        else if (task.IsFaulted)
        {
            // Task faulted, handle the exception
            var errorMessage =
                task.Exception.Flatten().InnerException
                    ?.Message ?? "An error occurred";
            httpContext.Response.StatusCode =
                StatusCodes.Status500InternalServerError;
            return httpContext.Response.WriteAsJsonAsync(
                new { error = errorMessage }
            );
        }
        else
        {
            // If task was cancelled or some other state,
            // handle accordingly
            httpContext.Response.StatusCode =
                StatusCodes.Status500InternalServerError;
            return httpContext.Response.WriteAsJsonAsync(
                new { error = "Unknown error occurred." }
            );
        }
    });
});</pre>
   <p>
    
     While this code can
    
    <a id="_idIndexMarker448">
    </a>
    
     demonstrate
    
    <a id="_idIndexMarker449">
    </a>
    
     asynchronous execution in an API endpoint, it could be a lot more readable.
    
    
     Fortunately, back in .NET Framework 4.5 and .NET 5, the
    
    <strong class="source-inline">
     
      async/await
     
    </strong>
    
     keywords
    
    
     
      were introduced.
     
    
   </p>
   <h2 id="_idParaDest-140">
    <a id="_idTextAnchor170">
    </a>
    
     TAP with async/await
    
   </h2>
   <p>
    
     The
    
    <strong class="source-inline">
     
      async/await
     
    </strong>
    
     keywords
    
    <a id="_idIndexMarker450">
    </a>
    
     made
    
    <a id="_idIndexMarker451">
    </a>
    
     asynchronous
    
    <a id="_idIndexMarker452">
    </a>
    
     programming more accessible by allowing us to write asynchronous code that resembles synchronous code.
    
    
     This went a long way toward making asynchronous code more readable and therefore understandable.
    
    
     In a minimal API, where we’re aiming to be economical with the real estate in our IDE, this is
    
    
     
      very valuable.
     
    
   </p>
   <p>
    
     This is what the endpoint from the last example looks like when using
    
    <strong class="source-inline">
     
      async/await
     
    </strong>
    
     instead of using the original
    
    
     
      Task-based syntax:
     
    
   </p>
   <pre class="source-code">
app.MapGet(
    "/fetch-data-async-await",
    async (HttpContext httpContext) =&gt;
{
    HttpClient client = new HttpClient();
    string url =
        "https://jsonplaceholder.typicode.com/posts/1";
    try
    {
        // Asynchronously fetch data from the external
        // service
        string data = await client.GetStringAsync(url);
        await httpContext.Response.WriteAsJsonAsync(
            new { data}
        );
    }
    catch (HttpRequestException ex)
    {
        // Handle error (e.g., network issues, server
        // problems)
        httpContext.Response.StatusCode =
            StatusCodes.Status500InternalServerError;
        await httpContext.Response.WriteAsJsonAsync(
            new
            {
                error =
                    "Error fetching data: " + ex.Message
            });
    }
    catch (Exception ex)
    {
        // Handle any other exceptions
        httpContext.Response.StatusCode =
            StatusCodes.Status500InternalServerError;
        await httpContext.Response.WriteAsJsonAsync(
            new
            {
                error =
                    "An unexpected error occurred: " +
                        ex.Message
            });
    }
});</pre>
   <p>
    
     It’s hopefully clear to see that the section of code in the second example, which starts the asynchronous call to the other API, is much cleaner and shorter than its counterpart in the
    
    
     
      first example.
     
    
   </p>
   <p>
    
     In minimal APIs, we don’t need to do much to make an API endpoint compatible with
    
    <strong class="source-inline">
     
      async/await
     
    </strong>
    
     .
    
    
     Notice how, in the second example that uses
    
    <strong class="source-inline">
     
      async/await
     
    </strong>
    
     , the endpoint has the
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     keyword preceding the lambda expression defined after the route.
    
    
     This, like in regular .NET functions and methods, allows for the use of the
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     keyword in the body of the function.
    
    
     Without the
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     keyword,
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     is
    
    
     
      not supported.
     
    
   </p>
   <p>
    
     The first example did not use the
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     keyword, but it was ultimately still able to create an asynchronous operation.
    
    
     This may look like a contradiction until we consider that as well as
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     is notably absent from the first example.
    
    
     So, it’s important to remember that the
    
    <strong class="source-inline">
     
      async
     
    </strong>
    
     keyword is not a pre-requisite for any asynchronous code in a minimal API, but it allows for the use of
    
    <strong class="source-inline">
     
      await
     
    </strong>
    
     , and therefore a simpler implementation
    
    <a id="_idIndexMarker453">
    </a>
    
     of
    
    <a id="_idIndexMarker454">
    </a>
    
     asynchronous
    
    <a id="_idIndexMarker455">
    </a>
    
     operations that resemble
    
    
     
      synchronous ones.
     
    
   </p>
   <p>
    
     By using
    
    <strong class="source-inline">
     
      async/await
     
    </strong>
    
     , we can implement the TAP in a
    
    
     
      streamlined fashion.
     
    
   </p>
   <h2 id="_idParaDest-141">
    <a id="_idTextAnchor171">
    </a>
    
     Asynchronous processing pattern
    
   </h2>
   <p>
    
     There is another well
    
    <a id="_idIndexMarker456">
    </a>
    
     defined pattern
    
    <a id="_idIndexMarker457">
    </a>
    
     that achieved asynchronous execution known as the
    
    <strong class="bold">
     
      Asynchronous
     
    </strong>
    
     <strong class="bold">
      
       Processing Pattern
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Sometimes referred to as
    
    <strong class="bold">
     
      deferred processing
     
    </strong>
    
     , this pattern can be somewhat complex compared to the TAP, but the
    
    <a id="_idIndexMarker458">
    </a>
    
     principle is the same.
    
    
     The flow of control is returned to the consumer of the function while other long-running operations
    
    <a id="_idIndexMarker459">
    </a>
    
     are completed.
    
    
     However, in this pattern, the consumer of the function is not the API application’s main
    
    <a id="_idIndexMarker460">
    </a>
    
     thread, but the client making the request to the
    
    
     
      API endpoint.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 1
      
     </em>
    
    <em class="italic">
     
      .1
     
    </em>
    
     demonstrates execution via
    
    
     
      deferred processing:
     
    
   </p>
   <div><div><img alt="Figure 11.1: Deferred processing spanning two client requests" src="img/B20968_11_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 11.1: Deferred processing spanning two client requests
    
   </p>
   <p>
    
     We can turn the current
    
    <a id="_idIndexMarker461">
    </a>
    
     example
    
    <a id="_idIndexMarker462">
    </a>
    
     into a version that uses deferred processing relatively easily.
    
    
     First, we would need to make an endpoint that starts execution of the long-running task, but then immediately acknowledges the caller by returning a status code.
    
    
     However, a status code on its own will not suffice.
    
    
     We must return a callback URL for the client.
    
    
     This URL will route to another endpoint, which will check to see whether our long-running operation has completed.
    
    
     If it has, it will retrieve the relevant data before returning it to the client as a response.
    
    
     If the operation has not been completed, it will still respond to the client, indicating that the operation is
    
    
     
      still running.
     
    
   </p>
   <p>
    
     Let’s start by creating the first endpoint, which will acknowledge the client’s request for the long-running operation to start.
    
    
     We’ll also create a dictionary to hold responses waiting to be collected by clients
    
    
     
      via callbacks:
     
    
   </p>
   <pre class="source-code">
var results = new ConcurrentDictionary&lt;Guid, string&gt;();
// Endpoint to start the long-running background task
app.MapPost("/start-process", async () =&gt;
{
});</pre>
   <p>
    
     The dictionary has been added as a
    
    <strong class="source-inline">
     
      ConcurrentDictionary
     
    </strong>
    
     because it is thread-safe, meaning that .NET will automatically manage scenarios where it is accessed by multiple concurrent
    
    <a id="_idIndexMarker463">
    </a>
    
     threads.
    
    
     An
    
    <a id="_idIndexMarker464">
    </a>
    
     example would be  if there are multiple requests to
    
    
     
      the API.
     
    
   </p>
   <p>
    
     Next, inside the body of the
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     endpoint, we generate a
    
    <strong class="source-inline">
     
      GUID
     
    </strong>
    
     to represent the pending request, as well as a string version of the
    
    <strong class="source-inline">
     
      GUID
     
    </strong>
    
     that can be referenced in the
    
    
     
      callback response:
     
    
   </p>
   <pre class="source-code">
var requestId = Guid.NewGuid();
var requestIdStr = requestId.ToString();</pre>
   <p>
    
     All that remains now is to start the long-running task, before returning the
    
    <strong class="source-inline">
     
      GUID
     
    </strong>
    
     to the client so that they can use it in the callback request to see whether their result is ready
    
    
     
      for retrieval:
     
    
   </p>
   <pre class="source-code">
// Start the long-running task
_ = Task.Run(async () =&gt;
{
    await Task.Delay(10000); // Simulate a long-running
                             // task (10 seconds)
    results[requestId] = $"Result for {requestIdStr}";
    // Store result in dictionary
});
// Respond with the request ID
return Results.Ok(new { RequestId = requestIdStr });</pre>
   <p>
    
     Now that the client has a unique identifier in the form of the returned
    
    <strong class="source-inline">
     
      GUID
     
    </strong>
    
     , it can be used in a second request to get
    
    
     
      the result.
     
    
   </p>
   <p>
    
     Let’s create a
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     endpoint for this purpose.
    
    
     The endpoint will be a lot simpler than the first.
    
    
     It will simply attempt to find an entry in the dictionary that has a key matching the passed-in
    
    <strong class="source-inline">
     
      GUID
     
    </strong>
    
     parameter.
    
    
     If the dictionary contains the requested key-value pair, the original long-running operation is completed.
    
    
     Otherwise, it must still be running or was never initiated.
    
    
     The
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     endpoint
    
    <a id="_idIndexMarker465">
    </a>
    
     must
    
    <a id="_idIndexMarker466">
    </a>
    
     handle both of
    
    
     
      these scenarios:
     
    
   </p>
   <pre class="source-code">
// Endpoint to get the result based on the request ID
app.MapGet("/get-result/{requestId}", (string requestId) =&gt;
{
    if (Guid.TryParse(requestId, out var guid) &amp;&amp;
        results.TryGetValue(guid, out var result))
    {
        return Results.Ok(new { Result = result });
    }
    return Results.NotFound(new { Error =
        "Result not found or not yet completed."
    });
});</pre>
   <p>
    
     Go ahead and try calling these two endpoints, one after the other.
    
    
     If you request the second endpoint within less than ten seconds of the first one, you should get a
    
    <strong class="source-inline">
     
      404 NOTFOUND
     
    </strong>
    
     result with the
    
    <strong class="bold">
     
      Result not found or not yet completed
     
    </strong>
    
     message and then get the expected
    
    <strong class="source-inline">
     
      GUID
     
    </strong>
    
     result after ten seconds.
    
    
     This will have demonstrated deferred processing in a
    
    
     
      simple way.
     
    
   </p>
   <p>
    
     To expand your practice of this execution pattern, you should attempt more elaborate use cases, such as
    
    <a id="_idIndexMarker467">
    </a>
    
     running
    
    <a id="_idIndexMarker468">
    </a>
    
     complicated mathematical calculations or making database or network requests in
    
    
     
      the background.
     
    
   </p>
   <h1 id="_idParaDest-142">
    <a id="_idTextAnchor172">
    </a>
    
     Common pitfalls and challenges
    
   </h1>
   <p>
    
     Asynchronous
    
    <a id="_idIndexMarker469">
    </a>
    
     programming brings with it a series of pitfalls and challenges.
    
    
     Let’s go through some examples of things that you should be vigilant about when writing asynchronous code in a
    
    
     
      minimal API:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Deadlocks
      
     </strong>
     
      : A deadlock
     
     <a id="_idIndexMarker470">
     </a>
     
      occurs when concurrent operations cannot complete due to blocking.
     
     
      In a minimal API, this can be seen when the main thread is blocked.
     
     
      In the following example, the use of
     
     <strong class="source-inline">
      
       Task.Run
      
     </strong>
     
      can cause a deadlock because it blocks the
     
     
      
       main thread:
      
     
     <pre class="source-code">
// Deadlock-prone code
public async Task&lt;IActionResult&gt; GetData()
{
    var data = Task.Run(() =&gt;
        GetDataFromDatabase()).Result; // Blocking
                                       // call
    return Ok(data);
}</pre>
     <p class="list-inset">
      
       The way to avoid
      
      <a id="_idIndexMarker471">
      </a>
      
       deadlocks would simply be to use
      
      <strong class="source-inline">
       
        await
       
      </strong>
      
       when running the task, to ensure that the call does not block the
      
      
       
        main thread:
       
      
     </p>
     <pre class="source-code">public async Task&lt;IActionResult&gt; GetData()
{
    var data = await Task.Run(() =&gt;
        GetDataFromDatabase());
    return Ok(data);
}</pre>
    </li>
    <li>
     <strong class="bold">
      
       Resource Management
      
     </strong>
     
      : Where
     
     <a id="_idIndexMarker472">
     </a>
     
      possible, minimal API code that manages resources such as database connections or file handles should be disposed of appropriately in an
     
     
      
       asynchronous context.
      
     
     <p class="list-inset">
      
       Any resource that implements
      
      <strong class="source-inline">
       
        IDisposable
       
      </strong>
      
       can make use of a
      
      <strong class="source-inline">
       
        using
       
      </strong>
      
       statement to automatically dispose of the resource when no longer in use.
      
      
       However, when writing asynchronous code for resources, try to use
      
      <strong class="source-inline">
       
        IDisposableAsync
       
      </strong>
      
       where
      
      <a id="_idIndexMarker473">
      </a>
      
       available.
      
      
       This means you use
      
      <strong class="source-inline">
       
        await
       
      </strong>
      
       in conjunction with a
      
      
       <strong class="source-inline">
        
         using
        
       </strong>
      
      
       
        statement:
       
      
     </p>
     <pre class="source-code">
public async Task&lt;IActionResult&gt; GetData()
{
    await using (var dbContext = new DbContext())
    {
        var data = await dbContext.GetDataAsync();
        return Ok(data);
    }
}</pre>
    </li>
    <li>
     <strong class="bold">
      
       Race conditions
      
     </strong>
     
      : A race condition
     
     <a id="_idIndexMarker474">
     </a>
     
      is the result of multiple threads accessing and modifying shared data concurrently.
     
     
      For example, if you have a static field in your minimal API, and an endpoint that accesses it for modification, you must remember that requests can execute concurrently, with multiple clients potentially running the endpoint logic at the same time.
     
     
      This would cause the static field in your API to become inconsistent and therefore inaccurate.
     
     
      You must ensure that each operation against shared data is
     
     <em class="italic">
      
       atomic
      
     </em>
     
      –  a single operation must complete before
     
     
      
       another occurs:
      
     
     <pre class="source-code">
private static int _counter = 0;
public async Task&lt;IResult&gt; IncrementCounter()
{
    var newCounterValue = _counter + 1;
    await Task.Delay(100); // Simulate async work
    _counter = newCounterValue;
    return Results.Ok(_counter);
}</pre>
     <p class="list-inset">
      
       In this example, multiple requests to
      
      <strong class="source-inline">
       
        IncrementCounter
       
      </strong>
      
       can lead to an inconsistent state
      
      
       
        of
       
      
      
       <strong class="source-inline">
        
         _counter
        
       </strong>
      
      
       
        .
       
      
     </p>
     <p class="list-inset">
      
       The solution to
      
      <a id="_idIndexMarker475">
      </a>
      
       this problem is to use a synchronization mechanism to manage the state of a shared value.
      
      
       The most common synchronization mechanism is
      
      <strong class="source-inline">
       
        lock
       
      </strong>
      
       , which uses an
      
      <strong class="source-inline">
       
        object
       
      </strong>
      
       to block execution against a particular value while a thread is accessing it.
      
      
       This means
      
      <em class="italic">
       
        locking
       
      </em>
      
       it from access by other threads, forcing them to wait
      
      
       
        their turn:
       
      
     </p>
     <pre class="source-code">private static int _counter = 0;
private static readonly object _counterLock =
    new object();
public async Task&lt;IActionResult&gt; IncrementCounter()
{
    lock (_counterLock)
    {
        var newCounterValue = _counter + 1;
        _counter = newCounterValue;
    }
    await Task.Delay(100); // Simulate async work
    return Ok(_counter);
}</pre>
     <p class="list-inset">
      
       This example shows the establishment and execution of a
      
      <strong class="source-inline">
       
        lock
       
      </strong>
      
       to ensure that
      
      <strong class="source-inline">
       
        _counter
       
      </strong>
      
       is updated by one thread at a time, eliminating the possibility of race conditions occurring within
      
      
       
        the API.
       
      
     </p>
    </li>
   </ul>
   <p>
    
     Asynchronous
    
    <a id="_idIndexMarker476">
    </a>
    
     programming can add a new layer of complexity to any minimal API project, but we’ve demonstrated in this chapter that with careful attention, it can be a powerful tool in optimizing API efficiency.
    
    
     Let’s recap the areas covered in
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-143">
    <a id="_idTextAnchor173">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     We opened this chapter with the pizza store analogy.
    
    
     We introduced  asynchronous programming by likening it to a takeout food order that you don’t simply wait for, but instead continue your ongoing tasks until the pizza is ready for you
    
    
     
      to collect.
     
    
   </p>
   <p>
    
     We then laid the foundations for understanding how asynchronous code can benefit a minimal API, with its optimal use of hardware resources and scope for
    
    
     
      application scalability.
     
    
   </p>
   <p>
    
     We explored some common asynchronous programming patterns, namely the TAP and deferred execution patterns, with examples of how the use of
    
    <strong class="source-inline">
     
      async/await
     
    </strong>
    
     can make asynchronous code more readable by making it look more like synchronous code.
    
    
     We explored how Deferred Execution can make an API asynchronous at the client level, allowing the client to receive an acknowledgment that their request has been received, along with a unique identifier for them to reference, stretching the overall end-to-end execution across multiple
    
    
     
      API requests.
     
    
   </p>
   <p>
    
     Finally, we addressed the common challenges asynchronous programming presents, particularly in minimal APIs, with three common examples.
    
    
     The first was deadlocks, in which execution can no longer be continued on a global scale due to contention between multiple threads or operations.
    
    
     Next was poor resource management, in which the code does not account for the asynchronous context when disposing of connections to external resources.
    
    
     Lastly, we looked at  race conditions, the classic example of multiple operations competing to update the state of a shared value or resource, causing inconsistent behavior and the creation of
    
    
     
      inaccurate data.
     
    
   </p>
   <p>
    
     No software developer can easily escape the need to manage asynchronous execution, especially in a .NET minimal API.
    
    
     Thus, practicing vigilance, combined with good testing and the profiling techniques learned earlier in the book, can go a long way to making the experience as painless
    
    
     
      as possible.
     
    
   </p>
   <p>
    
     Next, we will explore a critical method for optimizing the performance of any minimal API –
    
    
     
      caching.
     
    
   </p>
  </div>
 </body></html>