<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-99"><a id="_idTextAnchor016"/>5</h1>
<h1 id="_idParaDest-100">Building Interactive VR Experiences</h1>
<p>In this chapter, we delve into the world of more complex VR applications, empowering you to craft immersive and interactive experiences for a wide range of use cases. You will learn how to use the powerful Unity engine to create interactive VR apps without code and with C#.</p>
<p>The beauty of this chapter lies in its practical approach. You’ll acquire hands-on skills to construct a VR environment that mirrors the responsiveness and realism of our natural world. Though some background in C# could be advantageous, it is by no means a prerequisite. Our tutorial is designed to be beginner-friendly, allowing anyone with an interest in XR applications to follow along comfortably.</p>
<p>This chapter is split into the following topics:</p>
<ul>
<li>Building interactive VR experiences without code</li>
<li>Building interactive VR experience with C#</li>
</ul>
<h1 id="_idParaDest-101">Technical requirements</h1>
<p>Before we embark on this exciting journey, let’s ensure you meet the needed technical requirements to power through this chapter. Besides having the most recent version of Unity installed, you also need to have either <em class="italic">Windows</em>/<em class="italic">Linux</em>/<em class="italic">Mac</em> or <em class="italic">Android Build Support</em> enabled, depending on whether your VR device is running standalone or in PC-based VR mode. If you are unsure whether your PC or laptop meets the hardware requirements of Unity, have a look at this page: <a href="https://docs.unity3d.com/Manual/system-requirements.html">https://docs.unity3d.com/Manual/system-requirements.html</a>.</p>
<h1 id="_idParaDest-102">Building interactive VR experiences without code</h1>
<p>After<a id="_idIndexMarker402"/> exploring the demo scene in <a href="B20869_03.xhtml#_idTextAnchor009"><em class="italic">Chapter 3</em></a>, let’s build interactive VR experiences ourselves, starting with a virtual car exhibition. In the experience we are going to build, the user should be able to walk around the ground via continuous movement (walking with the joystick) and via teleportation (only to teleportation anchors).</p>
<p>To kick off our experience, create a new project by following the <em class="italic">Setting up a VR project in Unity and the XR Interaction Toolkit</em> section in <a href="B20869_03.xhtml#_idTextAnchor009"><em class="italic">Chapter 3</em></a>. If you have followed the steps in <a href="B20869_03.xhtml#_idTextAnchor009"><em class="italic">Chapter 3</em></a>, you can just open the existing project for this chapter and go through the following steps.</p>
<p>Once your <a id="_idIndexMarker403"/>project is loaded, begin by creating a new empty scene. This can be done by navigating to <code>CarExhibition</code>.</p>
<p>By double clicking on it, you’re now inside the newly created scene that contains only a <strong class="bold">Main Camera</strong> and a <strong class="bold">Directional Light</strong>. You can delete the <strong class="bold">Main Camera</strong>, as it is not needed.</p>
<p>Before we delve into the VR Setup, we must first set the stage for our interaction. In this case, this means creating a dedicated area to house our two car exhibits. For the sake of simplicity, we’ll be fashioning our exhibition ground from a simple cube primitive. Achieve this by right-clicking in the Scene Hierarchy and selecting <code>20</code>, <code>0.1</code>, <code>20</code>). Now, rename the cube <code>ground</code>. This will form the foundation of our car exhibition.</p>
<p>The next section details how we can import cars from the Asset Store.</p>
<h2 id="_idParaDest-103">Importing cars from the Asset Store</h2>
<p>Animating cars in<a id="_idIndexMarker404"/> our scene requires the prerequisite step of importing them. Let’s walk through the process of importing the <code>simple cars pack</code> from the Unity Asset Store:</p>
<ol>
<li>Go to the Unity Asset Store (<a href="https://assetstore.unity.com/">https://assetstore.unity.com/</a>). Search for the <code>simple cars pack</code> or, for a more direct route, access the package page via this link<a id="_idTextAnchor017"/>: <a href="https://assetstore.unity.com/packages/3d/vehicles/land/simple-cars-pack-97669">https://assetstore.unity.com/packages/3d/vehicles/land/simple-cars-pack-97669</a>.</li>
<li>After adding the package to your assets, find the <strong class="bold">Open in Unity</strong> button and click on it.</li>
<li>This action should prompt the Unity application to open, presenting you with the option to import the package. Please proceed with the <strong class="bold">Import</strong> operation.</li>
<li>Once the import is successful, journey to the package’s directory in the project window. The path you’re looking for is <strong class="bold">Assets</strong> | <strong class="bold">Simple Vehicle Pack</strong> | <strong class="bold">Prefabs</strong>.</li>
<li>Unleash the taxi into the scene at coordinates (<code>-6</code>,<code>0</code>,<code>0</code>) and adjust its scale to (<code>2</code>,<code>2</code>,<code>2</code>).</li>
</ol>
<p>Occasionally, you <a id="_idIndexMarker405"/>might encounter a peculiar magenta hue on the object. This typically implies that the associated materials are missing or incompatible with the current rendering pipeline. To rectify this issue, go through the following steps:</p>
<ol>
<li><em class="italic">URP Installation</em>: Before proceeding, ensure you have the URP installed, as it’s not included by default in the VR Template project. If it’s not installed, go to <strong class="bold">Window</strong> | <strong class="bold">Package Manager</strong>. Then, search for the URP and install it.</li>
<li>Head to <code>Assets</code> | <code>Simple Vehicle Pack</code> | <code>Materials</code> | <code>Cars_1</code>.</li>
<li>With the <code>Cars_1</code> material selected, alter the <strong class="bold">Shader</strong> drop-down menu in the <strong class="bold">Inspector</strong> window to <strong class="bold">URP | </strong><strong class="bold">Lit</strong>.</li>
<li>Then, click on the small torus symbol next to <code>cars_albedo</code> to the <code>cars_metallic</code> to the <strong class="bold">Metallic Map</strong>, and <strong class="bold">cars_AO</strong> to the <strong class="bold">Occlusion Map</strong>.<p class="list-inset">This should restore the car’s normal appearance.</p></li>
<li>Repeat this process for <code>Bus_1</code>, <code>Bus_2</code>, and <code>Cars_2</code> materials, ensuring the corresponding <code>bus_albedo</code>, <code>bus_albedo_2</code>, <code>bus_metallic</code>, <code>bus _AO</code>, and <code>cars_albedo_2</code> textures are assigned to the relevant maps.</li>
</ol>
<p class="callout-heading">Note</p>
<p class="callout">You may have noticed that making manual adjustments can be quite time-consuming. Fortunately, Unity offers a more streamlined solution for such scenarios. The <strong class="bold">Render Pipeline Converter</strong> is designed to handle bulk conversions of assets and shaders to the URP format. Here’s how to use it:</p>
<p class="callout">1. Go to <strong class="bold">Window</strong> | <strong class="bold">Rendering</strong> | <strong class="bold">Render </strong><strong class="bold">Pipeline Converter</strong>.</p>
<p class="callout">2. In the opened window, select the materials or shaders you want to convert.</p>
<p class="callout">3. Click <strong class="bold">Convert</strong>. The tool will then attempt to automatically adjust your selected materials or shaders for compatibility with URP.</p>
<p class="callout">Do keep in mind that while this is convenient for bulk operations, you might still need to verify each material to ensure it is converted correctly.</p>
<p>With this <a id="_idIndexMarker406"/>task completed, revisit the <code>Assets</code> | <code>Simple Vehicle Pack</code> | <code>Prefabs</code> and let your creativity run wild by placing all the vehicles from the asset into our scene. Please note that in addition to the Taxi, we’re particularly interested in the <code>Police_car</code>, positioned at (<code>6</code>,<code>0</code>,<code>0</code>).</p>
<p>Now that our cars have arrived at the scene, we’re ready to add the player and button prefabs in the next section.</p>
<h2 id="_idParaDest-104">Adding the player, teleport anchors, and button to the scene</h2>
<p>Before we begin implementing our game logic into the VR experience, we must first add some additional GameObjects and prefabs to our scenes that are just as important for its functionality as the cars themselves. Let’s start with adding the player.</p>
<h3>Adding the player</h3>
<p>Let’s imagine<a id="_idIndexMarker407"/> our scene as a stage and ourselves as the directors. In our toolbox, we’ve got this lovely XR Interaction setup prefab, a sort of puppet we can animate around our virtual stage. We highly recommend using the XR Interaction Toolkit version <em class="italic">2.5.1</em> by following the <em class="italic">Installing the XR Interaction Toolkit and Samples</em> section in <a href="B20869_03.xhtml#_idTextAnchor009"><em class="italic">Chapter 3</em></a>. While the toolkit is consistently updated, newer versions might come with different prefabs. Let’s add and <a id="_idIndexMarker408"/>configure this prefab using the following steps:</p>
<ol>
<li>The XR Interaction setup prefab is easy to find; it’s nestled in the <code>Assets</code> | <code>Samples</code> | <code>XR Interaction Toolkit</code> folder. Search for the version you have, maybe it’s <em class="italic">2.5.1</em>, as recommended, or something newer. Then, dig through <strong class="bold">Starter Assets</strong> till you find <strong class="bold">Prefabs</strong>.</li>
<li>Get the <code>Prefabs</code> folder and drag it right on the scene. Adjust it as needed to sit right at the center, at coordinates (<code>0</code>,<code>0</code>,<code>0</code>).</li>
</ol>
<p>Successfully, we’ve integrated a player into our scene. Now, let’s enhance the experience by setting up teleport anchors at various points of interest within our environment.</p>
<h3>Setting up two teleport anchors</h3>
<p>For <a id="_idIndexMarker409"/>those new to VR, a great way to prevent motion sickness is to restrict movement to teleportation. The XR Interaction Toolkit provides us with three teleportation prefab options: <strong class="bold">Teleport Anchor</strong>, <strong class="bold">Snapping Teleport Anchor</strong>, and <strong class="bold">Teleportation Area</strong>. Think of <strong class="bold">Snapping Teleport Anchor</strong> as a specific point on our stage where the teleportation ray snaps to. In contrast, with <strong class="bold">Teleport Anchor</strong>, the teleportation ray will glide without snapping. However, both anchors essentially serve the same purpose: they’re designated spots where users can teleport. On the other hand, <strong class="bold">Teleportation</strong> <strong class="bold">Areas</strong> are expansive zones allowing user teleportation within their boundaries.</p>
<p>For this particular scene, we will be using two snapping teleport anchors to ensure users teleport only to specific locations. Here’s how we can set them up:</p>
<ol>
<li>In our project window, navigate to <code>Assets</code> | <code>Samples</code> | <code>XR Interaction Toolkit</code> | <code>2.5.1</code> | <code>Starter Assets</code> | <code>DemoSceneAssets</code> | <code>Prefabs</code> | <code>Teleport</code>. Within this location, you’ll come across the just-described <strong class="bold">Teleport</strong> <strong class="bold">Anchor</strong>, <strong class="bold">Snapping Teleport Anchor</strong>, and <strong class="bold">Teleportation Area</strong>.</li>
<li>Drag the snapping teleport anchor from the <code>Teleport</code> folder and drop it into the <code>Taxi Teleport Anchor</code>. Position it at coordinates (<code>-2</code>, <code>0</code>, <code>0</code>) and scale it to (<code>2</code>, <code>1</code>, <code>2</code>).</li>
<li>Drag and drop another snapping teleport anchor into the <code>Police_car Teleport Anchor</code>. Position it at (<code>2</code>, <code>0</code>, <code>0</code>) and scale it to the same size as the previous anchor: (<code>2</code>, <code>1</code>, <code>2</code>).</li>
</ol>
<p>Once <a id="_idIndexMarker410"/>set up, your scene should resemble what’s illustrated in <em class="italic">Figure 5</em><em class="italic">.1</em>.</p>
<div><div><img alt="Figure 5.1 – ﻿The taxi and the police car with their teleport anchors" src="img/B20869_05_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – The taxi and the police car with their teleport anchors</p>
<p>Next, we’ll enhance the <code>Taxi Teleport Anchor</code> by adding a push button directly onto it.</p>
<h3>Adding a push button for the taxi animation</h3>
<p>To make<a id="_idIndexMarker411"/> our push button for the taxi animation stand out and be easily accessible, we’re going to place it on a pedestal created using a cylinder. This cylinder will serve as the button’s dedicated stand:</p>
<ol>
<li>To create this pedestal, right-click in the <code>Taxi Button Stand</code>. Adjust its size to dimensions (<code>0.2</code>, <code>0.5</code>, <code>0.2</code>) and position it at (<code>-2.7</code>, <code>0.55</code>, <code>0</code>).</li>
<li>To find the <code>Assets</code> | <code>Samples</code> | <code>XR Interaction Toolkit</code> | <code>2.5.1</code> | <code>Starter Assets</code> | <code>DemoSceneAssets</code> | <code>Prefabs</code> | <code>Interactables</code>. Once you've found it, drag and drop it onto the <code>Taxi Button Stand</code> in the <code>5</code>, <code>5</code>, <code>5</code>) and adjust its y-coordinate to <code>1.075</code> so it sits correctly on the pedestal.</li>
</ol>
<p>Refer <a id="_idIndexMarker412"/>to <em class="italic">Figure 5</em><em class="italic">.2</em> to ensure that your scene looks as expected with the newly added push button. In the subsequent section, we’ll focus on setting up text buttons for the police car animations.</p>
<div><div><img alt="Figure 5.2 – ﻿The taxi button stand we just added to the scene" src="img/B20869_05_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – The taxi button stand we just added to the scene</p>
<h3>Adding text buttons for police car animations</h3>
<p>For our <a id="_idIndexMarker413"/>police<a id="_idIndexMarker414"/> car, we’ll create a canvas that holds two buttons, enabling users to either shrink or enlarge the police car.</p>
<h4>Setting up the canvas</h4>
<ol>
<li>Begin by <a id="_idIndexMarker415"/>creating a canvas: right-click in the hierarchy and select <strong class="bold">XR</strong> | <strong class="bold">UI</strong> <strong class="bold">Canvas</strong>.</li>
<li>Adjust its size dimensions. The correct size for our purpose is (<code>0.001</code>, <code>0.001</code>, <code>0</code>), making it a square. This scaling is essential for optimal viewing in the VR environment.</li>
<li>Position the canvas at coordinates (<code>3</code>,<code>1</code>,<code>-1</code>) and rotate it (<code>0</code>, <code>90</code>, <code>0</code>) towards the player’s direction.</li>
<li>If you’re facing difficulties altering the UI Canvas properties, head to the Inspector window of the canvas component. Here, change the <strong class="bold">Render Mode</strong> from <strong class="bold">Screen Space – Overlay</strong> to <strong class="bold">World Space</strong>.</li>
</ol>
<h4>Adjusting the Canvas components</h4>
<ol>
<li value="1">With<a id="_idIndexMarker416"/> the canvas selected in the <strong class="bold">Scene Hierarchy</strong>, open the <strong class="bold">Inspector</strong> window. Click on <strong class="bold">Add Component</strong> to attach new components to the canvas.</li>
<li>First, add a <code>5</code>.</li><li class="upper-roman">Choose <strong class="bold">Middle Center</strong> for <strong class="bold">Child Alignment</strong>.</li><li class="upper-roman">Check <strong class="bold">Child Force Expand</strong> for both width and height.</li><li class="upper-roman">For visual appeal, add an <strong class="bold">Image</strong> component to the canvas. In the <strong class="bold">Image</strong> component’s settings, set the source image to <strong class="bold">UISprite</strong> and choose a background <a id="_idIndexMarker417"/>color that complements your scene.</li></ol></li>
</ol>
<h4>Adding the buttons</h4>
<ol>
<li value="1">Navigate to <code>Assets</code> | <code>Samples</code> | <code>XR Interaction Toolkit</code><code>2.5.1</code> | <code>Starter Assets</code> | <code>Prefabs</code> | <code>DemoSceneAssets</code> | <code>Prefabs</code> | <code>UI</code>. Here, you should find the <strong class="bold">TextButton</strong> prefab.</li>
<li>Drag and<a id="_idIndexMarker418"/> drop this prefab onto the <strong class="bold">Canvas</strong> twice. This will automatically place two <strong class="bold">TextButton</strong> prefabs as child objects beneath the <strong class="bold">Canvas</strong>. Due to the <strong class="bold">Vertical Layout Group</strong>, they’ll be aligned neatly.</li>
<li>Scale them to (<code>0.4</code>, <code>0.4</code>, <code>0</code>) and rename the first button as <code>Scale Big Button</code> and the second one as <code>Scale </code><code>Small Button</code>.</li>
</ol>
<h4>Labeling the buttons</h4>
<p>Modify <a id="_idIndexMarker419"/>the child text object of each button by unfolding them twice. With the <code>Text</code> GameObject selected, head to the Inspector window and search for the text component. Label one button as <code>Scale Big</code> and the other as <code>Scale Small</code>.</p>
<p>By following these steps, you’ll have a neatly organized UI ready for your police car animations, as shown in <em class="italic">Figure 5</em><em class="italic">.3</em>.</p>
<div><div><img alt="Figure 5.3 – ﻿The text buttons for the police car animations" src="img/B20869_05_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – The text buttons for the police car animations</p>
<p>Now our <a id="_idIndexMarker420"/>stage is set, it’s ready for the show and should look like<a id="_idTextAnchor018"/> <em class="italic">Figure 5</em><em class="italic">.4</em>.</p>
<div><div><img alt="Figure 5.4 – ﻿The current status of the CarExhibition scene" src="img/B20869_05_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – The current status of the CarExhibition scene</p>
<p>Up next, we’re going to learn about the puppet strings, or in other words, the button events we can manipulate in Unity.</p>
<h2 id="_idParaDest-105">Interactable events that can be triggered</h2>
<p>Interactable events, particularly <a id="_idIndexMarker421"/>those<a id="_idIndexMarker422"/> found in the <strong class="bold">XR Simple Interactable</strong> component, play a pivotal role in enhancing user experience. Such events, often tied to push buttons, facilitate diverse interactions within VR environments. There are many different options for interactable events. Imagine you are in a virtual reality car exhibition where you can interact with push buttons next to each car. Here’s how these events<a id="_idIndexMarker423"/> might <a id="_idIndexMarker424"/>apply in this scenario:</p>
<ul>
<li><strong class="bold">First Hover Entered</strong>: You approach a car and point at its information button for the first time. This event triggers a subtle glow around the button indicating it is selected.</li>
<li><strong class="bold">Hover Entered</strong>: Each time you point at the button, the event renews the glow, showing that the button is currently the focus of your attention.</li>
<li><strong class="bold">Hover Exited</strong>: As soon as your hand or pointer moves away from the button, the glow dissipates, indicating that the button is no longer selected.</li>
<li><strong class="bold">Last Hover Exited</strong>: The final time you move away from the button, the glow dissipates, and it seems as though the button subtly moves back to its original position, indicating that it’s no longer in focus.</li>
<li><strong class="bold">First Select Entered</strong>: The first time you press the information button, this event is triggered. It might cause the car’s information panel to appear with a smooth animation.</li>
<li><strong class="bold">Select Entered</strong>: Each time you press the button, the car’s information panel appears, whether it’s the first press or not.</li>
<li><strong class="bold">Select Exited</strong>: When you release the button, the panel begins to fade, indicating the end of the interaction.</li>
<li><strong class="bold">Last Select Exited</strong>: The final time you release the button, it seems as though the panel not only fades but also shrinks back into the button, signifying the interaction’s conclusion.</li>
<li><strong class="bold">Activated</strong>: This event could be tied to a button in the car that starts the engine. Upon pressing, you hear the car’s engine roar to life.</li>
<li><strong class="bold">Deactivated</strong>: When you press the button to turn off the car’s engine, this event is triggered. You hear the engine wind down to a stop.</li>
</ul>
<p>This sequence of <a id="_idIndexMarker425"/>events provides a natural, intuitive interaction flow for the user, enhancing the immersive feel of the VR car exhibition.</p>
<p>In the next section, we’ll delve into how to choreograph these interactions and bring animations to life without writing a single line of code.</p>
<h2 id="_idParaDest-106">Understanding animations and animator systems</h2>
<p>Unity’s <strong class="bold">animation system</strong> functions<a id="_idIndexMarker426"/> like a<a id="_idIndexMarker427"/> mechanism for manipulating GameObjects by controlling their movement, rotation, size, color, and so on. It works by defining keyframes, which are specific<a id="_idIndexMarker428"/> states at certain times, and constructing an animation clip from these keyframes.</p>
<p>Consider the example of a virtual door. An animation clip can illustrate the door’s movement from closed to open, and another clip can depict the door returning to its closed position.</p>
<p>To ensure smooth transitions between these clips, Unity’s <strong class="bold">Animator Controller</strong> is used. This is a control system that directs the timing and sequence of the animation clips, transitioning between them based on specific conditions.</p>
<p>For the door example, the Animator Controller would manage the clips for opening and closing the door and transitioning between them at the right moment, possibly based on user input.</p>
<p>Here are other examples that<a id="_idIndexMarker429"/> can be crafted using Unity’s animation system:</p>
<ul>
<li><strong class="bold">Object movement</strong>: For an object moving across the screen, the animation system can create the movement, but additional scripting may be required to control it based on user interaction</li>
<li><strong class="bold">Object rotation</strong>: A constantly spinning gear can be animated, but player-based control of the spin requires code</li>
<li><strong class="bold">Object scaling</strong>: Scaling animation can depict an object’s growth, but linking this to other factors, such as energy level, requires scripting</li>
<li><strong class="bold">Color change</strong>: An animation can be made for a changing light color, but synchronizing it with game conditions requires coding</li>
<li><strong class="bold">Camera movement</strong>: Camera movement between characters can be created using keyframes, but complex interactions with player movement might need additional code</li>
<li><strong class="bold">Blend shapes</strong>: Facial expressions can be controlled using blend shapes, but they may need to be scripted to correspond to specific game dialogues</li>
<li><strong class="bold">UI animations</strong>: A graphical UI element, such as a flashing button, can be animated, but stopping the animation when certain conditions are met (e.g., a race begins) requires a script</li>
</ul>
<p>As <a id="_idIndexMarker430"/>seen in<a id="_idIndexMarker431"/> these examples, the animation system in Unity provides a powerful tool for bringing objects and scenes to life. However, adding scripts or coding to these animations unlocks a higher level of refinement and interactivity.</p>
<p>In general, coding enables us to create animations in Unity that can respond to various inputs and game states, making them more dynamic. Coding also provides precise control over the animation, allowing for complex logic and customized interactions that cannot be achieved with Unity’s animation system alone.</p>
<p>While Unity’s animation system may not have the same level of complexity and fine control that coding offers, it still holds a significant place as a primary tool for creating interactions within Unity. The visual interface and intuitive controls allow for a rapid and user-friendly way to animate GameObjects, even without delving into scripts. This makes it accessible to both novice and experienced developers, enabling them to add life and movement to their game scenes.</p>
<p>In the next section of this chapter, we will only be using the animation system, demonstrating how powerful and useful it can be on its own. Through hands-on examples, you’ll see how it’s possible to achieve engaging and interactive animations without relying on coding and how this tool can become a vital part of your XR development toolkit.</p>
<h2 id="_idParaDest-107">Animating a 360-degree car rotation</h2>
<p>Let’s dive<a id="_idIndexMarker432"/> into the world of animation. Think of a spinning top: it goes round and round, and we want our taxi to do the same when we push a button. The twist is that when we let go of the button, the taxi should stop spinning. Sound fun? Here’s how we’ll make it happen using the magic of Unity’s animation system and UnityEvents without writing a line of code.</p>
<p>First <a id="_idIndexMarker433"/>things first, we need to choreograph this spin for our taxi. Imagine it as a pirouette, a 360-degree turn on the taxi’s y-axis. Go through the following steps to bring this dance to life:</p>
<ol>
<li>Right-click in the <code>Assets</code> folder and select <strong class="bold">Create</strong> | <strong class="bold">Folder</strong>.</li>
<li>Select the taxi object in your scene and go to <code>RotateCar</code>, and save it in our newly minted <code>Animations</code> folder.</li>
<li>Define a 360-degree rotation for the y-axis by selecting <strong class="bold">Transform</strong> | <strong class="bold">Rotation</strong> and modifying your keyframes as shown in <em class="italic">Figure 5</em><em class="italic">.5</em>.</li>
</ol>
<div><div><img alt="Figure 5.5 – ﻿The modified Keyframes to define a 360-degree rotation for the y-axis" src="img/B20869_05_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – The modified Keyframes to define a 360-degree rotation for the y-axis</p>
<p class="list-inset">Set the initial keyframes at <code>0:00</code> with <code>0</code> as the rotation; this is our taxi’s starting pose. Then, leap to <code>0:10</code> and give the <code>355</code>-degree spin. Why not 360? That would be like turning on a dime, too abrupt for our gentle spin.</p>
<ol>
<li value="4">Click on the <code>RotateCar</code> animation clip in the project window to view its settings in the Inspector. In the Inspector, give the <strong class="bold">Loop Time</strong> box a check to tell our taxi to keep repeating its spin.</li>
<li>Attach an <code>RotateCar</code> animation clip into the <strong class="bold">Controller</strong> field of the <strong class="bold">Animator</strong> component.</li>
</ol>
<p>This will start <a id="_idIndexMarker434"/>our Taxi’s twirl right when we step into our virtual world. But remember, we want the spin to start only when we push the button. It’s time to make that happen:</p>
<ol>
<li>First, we need to open the Animator Controller. Select the <strong class="bold">Animator Controller</strong> for our Taxi and double-click it to open the Animator Controller window.</li>
<li>Like a blank canvas, right-click in the <code>Idle</code>; it’s the calm before the Taxi’s spinning storm.</li>
<li>Next, right-click on the <code>Idle</code> state and set it as the <strong class="bold">Layer Default State</strong>. This tells the Animator Controller to start in this state, doing nothing when the scene begins.</li>
<li>We then make a bridge from the <code>Idle</code> state to the <code>RotateCar</code> state: the state that initiates our taxi’s spin. To do this, right-click on <code>Idle</code>, choose <code>RotateCar</code>.</li>
<li>Now let’s navigate to the <code>Rotate</code>. This parameter will initiate the transition from the <code>Idle</code> state to the <code>RotateCar</code> state.</li>
<li>Click on the arrow representing the transition from <code>Idle</code> to <code>RotateCar</code>. In the <code>Rotate</code> parameter that we just created, as shown in <em class="italic">Figure 5</em><em class="italic">.6</em>.</li>
</ol>
<div><div><img alt="Figure 5.6 – ﻿The Inspector window showing the newly added condition: the Rotate trigger" src="img/B20869_05_06.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.6 – The Inspector window showing the newly added condition: the Rotate trigger</p>
<ol>
<li value="7">Next, we <a id="_idIndexMarker435"/>need to halt our taxi’s spin once the button is released. Right-click on the <code>RotateCar</code> state, choose <code>Idle</code> state.</li>
<li>Go back to the <code>StopRotation</code>. This will initiate the transition from the <code>RotateCar</code> state back to <code>Idle</code>. Your parameters should now match what’s shown in <em class="italic">Figure 5</em><em class="italic">.7</em>.</li>
</ol>
<div><div><img alt="Figure 5.7 – ﻿The Parameters tab of the Animator window showing both newly added parameters" src="img/B20869_05_07.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – The Parameters tab of the Animator window showing both newly added parameters</p>
<ol>
<li value="9">Click on the transition arrow that goes from the <code>RotateCar</code> to the <code>Idle</code> state this time. Under <code>StopRotation</code> parameter as we did with the <code>Rotate</code> parameter earlier. Your <strong class="bold">Animator</strong> window<a id="_idIndexMarker436"/> should n<a id="_idTextAnchor019"/>ow resemble <em class="italic">Figure 5</em><em class="italic">.8</em>.</li>
</ol>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 5.8 – ﻿The Animator window showing the current states and their transitions" src="img/B20869_05_08.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – The Animator window showing the current states and their transitions</p>
<ol>
<li value="10">Select the <code>Animator.SetTrigger()</code>. Think of it as the cue for our Taxi to start or stop its dance. When the button is pressed (<code>Rotate</code>, and when the button is released (<code>StopRotation</code>. If set up correctly, your events will mirror those in <em class="italic">Figure 5</em><em class="italic">.9</em>.</li>
</ol>
<div><div><img alt="Figure 5.9 – ﻿The Select Entered and Select Excited events" src="img/B20869_05_09.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.9 – The Select Entered and Select Excited events</p>
<p>Well done! Your<a id="_idIndexMarker437"/> taxi is now set to dance to your button’s beats, spinning a full circle each time you press it. Don’t forget to try it out: give that button a good press and watch the taxi perform its 360-degree spin.</p>
<p>In the next section, we’ll delve into the magic of 2D text buttons on a canvas, learning how they can change a police car’s size to make it shrink or grow at the press of a button.</p>
<h2 id="_idParaDest-108">Scaling a police car</h2>
<p>Imagine the<a id="_idIndexMarker438"/> compelling possibilities of incorporating two additional interactive features in our VR auto show: one button to miniaturize the car and another to magnify it. Similar to our earlier interactions, we will employ a set of procedures, but this time with 2D buttons on a canvas. First, we create two animation clips that capture the essence of the car’s transformation as it scales up and down. Next, we create an Animator Controller: a crucial component that defines and manages the animation states. Lastly, we assign the corresponding trigger events to the button.</p>
<p>Let’s bring this magic to life with the following steps:</p>
<ol>
<li>Select the police car in the hierarchy. Open the Animation window (<code>ScaleCar</code> and store it in the <code>Animations</code> folder.</li>
<li>Now, let’s <a id="_idIndexMarker439"/>choreograph the transformation. On the timeline in the Animation window, mark the beginning (<code>0:00</code>) and the end (<code>1:00</code>) with keyframes (the diamond icon). At the beginning, the scale of the car (<code>0</code>. At the end, the scale should be at its largest size; let’s go with <code>3</code>. This gives us an animation that sees the car scaling from minuscule to massive.</li>
<li>We don’t want our car continuously growing and shrinking. So, in the Inspector, uncheck the <strong class="bold">Loop </strong><strong class="bold">Time</strong> box.</li>
<li>Our police car needs an <code>ScaleCar</code><strong class="bold"> </strong>animation clip into the <strong class="bold">Controller</strong> field of the <strong class="bold">Animator Component</strong>.</li>
<li>We’ve got the growing part down, now let’s work on the shrinking. Create a second animation clip named <code>ShrinkCar</code>.</li>
<li>Similar to <em class="italic">step 2</em>, mark the beginning and the end with keyframes. This time, at the beginning, the scale of the car should be at its largest size (<code>3</code>). At the end, the scale should be at its smallest size (<code>0</code>). We’ve now reversed the transformation, creating an animation that shrinks the car from massive to minuscule.</li>
</ol>
<p>By now, we’ve successfully created two animation clips and an Animator Controller. If we were to play the scene, the police car would scale up once thanks to the unchecked loop checkbox and the absence of the downscaling animation in our Animation Controller. We’re one step closer to our transforming car. Ready for the next part? Let’s dive in.</p>
<p>Now, it’s time to make our police car dance to our tune. We want it to change sizes when we wish and be idle when we don’t. That’s where the Animator Controller comes in. It’s our maestro, dictating when the car grows, shrinks, or takes a breather. Here’s how we bring <a id="_idIndexMarker440"/>this to life:</p>
<ol>
<li>First, we need to open the Animator Controller. Locate the one assigned to the police car in the project window and double-click to open it.</li>
<li>Remember our shrinking dance? Drag and drop the <code>ShrinkCar</code> animation clip into the <strong class="bold">Animator Controller</strong> window. It now has both the growing and shrinking routines.</li>
<li>Now, we need a state of rest, a breather in between our dance routines. Right-click in the <code>Idle</code>. It’s like the calm before the storm.</li>
<li>We don’t want our car to start dancing right away when the curtain rises. So, set the <code>Idle</code> state as the default state. This ensures that when the scene begins, our car stands still, awaiting its cue.</li>
<li>Our maestro is ready to conduct. Right-click on the <code>Idle</code> state and choose <code>ScaleCar</code> and another time to the <code>ShrinkCar</code> states. Now, we’ve set the stage for our car to transition from standing idle to growing big and shrinking small.</li>
<li>But what cues the transitions? We need to set trigger parameters for this. In the <code>ScaleBig</code> and <code>ScaleSmall</code>.</li><li class="upper-roman">Select the transition arrows. Under <code>ScaleBig</code> cues the transition from <code>Idle</code> to <code>ScaleCar</code>, while <code>ScaleSmall</code> cues the transition from <code>Idle</code> to <code>ShrinkCar</code>.</p><p class="list-inset">The dance is never one-way. Our car needs to move smoothly from growing to shrinking and vice versa. So, create transitions from <code>ShrinkCar</code> to <code>ScaleCar</code><code>ScaleBig</code> trigger for the lower and the <code>ScaleSmall</code> trigger for the upper transition arrow, as shown in <em class="italic">Figure 5</em><em class="italic">.10</em>.</p></li>
</ol>
<p class="IMG---Figure"> </p>
<div><div><img alt="Figure 5.10 – ﻿The Animator Controller of the police car" src="img/B20869_05_10.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.10 – The Animator Controller of the police car</p>
<p>Voila! Our <a id="_idIndexMarker441"/>police car is now ready to twirl to our commands. Try out the scene and watch as it gracefully grows and shrinks at your will by testing or deploying the scene onto your VR headset, as described in the <em class="italic">Deploying and testing VR experiences onto different VR platforms or simulators</em> section in <a href="B20869_03.xhtml#_idTextAnchor009"><em class="italic">Chapter 3</em></a>. It’s a delightful sight, isn’t it?</p>
<h1 id="_idParaDest-109">Building interactive VR experiences with C#</h1>
<p>So far, we <a id="_idIndexMarker442"/>have added interactions to our scene just by using Unity’s Animation system without writing a single line of code. In the next sections, you will learn how you can use scripting with C# to add even more complex breaths of air into your GameObjects and scene.</p>
<p>The first question we are going to answer is this: when do we need to write C# code for our animations and interactions?</p>
<h2 id="_idParaDest-110">Understanding when to use C# for animations and interactions</h2>
<p>It’s important<a id="_idIndexMarker443"/> to understand that Unity’s animation and animator systems and the use of C# scripting are not mutually exclusive. They are often used together, with the animator controlling predefined animations and C# adding interactivity based on user input or other game events.</p>
<p>In the previous section, we rotated and scaled cars based using Unity’s animation and animator systems. These systems are primarily used to create predefined animations. We can divide this process into the following three steps:</p>
<ol>
<li><strong class="bold">Initialization event</strong>: First, an event must occur to start the animation. This can be a button press, game event, collision, or any other trigger. In our example, to scale and rotate the cars, we used a physical push button and a 2D UI button. Unity’s built-in animation and animator systems are largely designed around the idea of predefined animations that are triggered under specific conditions. These conditions are typically defined within the Animator Controller itself and are usually based on parameters that you set up ahead of time, such as a boolean to track if a character is jumping or a trigger that gets activated when a button is pressed. This means that, with the built-in system, we do not have the ability to trigger animations based on virtually any event or condition in our game and have to work with the available events.</li>
<li><strong class="bold">Animation</strong>: Using Unity’s animation system, we define what changes during the animation (position, rotation, scale, etc.) by creating keyframes. For instance, we changed the rotation and scale of the cars with keyframes.</li>
<li><code>ShrinkCar</code> state to a <code>ScaleCar</code> state.</li>
</ol>
<p>This system is perfect for creating animations that are predefined and occur under specific conditions; for instance, character animations (walking, running, jumping) or environmental animations (door opening, elevator moving).</p>
<p>While Unity’s built-in system <a id="_idIndexMarker444"/>excels at predefined animations, C# comes into play when animations need to respond dynamically to user input or other game events. Here, we follow similar steps as before:</p>
<ol>
<li><strong class="bold">Initialization event</strong>: The event that starts an animation can be anything, such as button presses, user input, or changes in the game state. The biggest difference with Unity’s built-in system is that with C# scripts, you have much greater flexibility and control over the initialization events for your animations. For instance, you can respond to complex sequences of input, such as a fighting game action combo. You can base animations on game logic or game state, such as an enemy’s health level or the player’s current score. You can trigger animations based on collisions, entering/exiting certain zones, or other physics events.</li>
<li><strong class="bold">AI Decisions</strong>: You can initiate animations based on the decisions made by an AI system. In a multiplayer game, you can trigger animations based on network events, such as another player’s actions.</li>
<li><strong class="bold">Animation</strong>: Animations can be created in two ways:<ul><li>You can use the animation system to create keyframes as before and then use C# to control the playback of these animations (for example, play, pause, stop, or alter speed).</li><li>Alternatively, you can use C# to modify the properties of GameObjects directly, creating animations programmatically.</li></ul></li>
<li><strong class="bold">State control</strong>: With C#, you gain more direct control over when and how animations and transitions occur. You can create conditions based on any aspect of your game’s state, not just parameters in the Animator Controller. For example, you could change an NPC’s animation based on the player’s health or inventory.</li>
</ol>
<p>Using C# for animations is ideal when the animation needs to respond in complex ways to the game state or user input. This is especially the case in the following scenarios:</p>
<ul>
<li><strong class="bold">Real-time user input</strong>: You often use C# to animate GameObjects in response to real-time user input. For example, in a flight simulator, you might animate the plane’s control surfaces (such as the ailerons, elevators, and rudder) based on the player’s joystick input. Since the exact position of these surfaces depends on the player’s input, it’s not something that can be predetermined with keyframes.</li>
<li><strong class="bold">Physics-based animations</strong>: If your animation needs to incorporate or respond to physics, it often makes sense to animate it programmatically. For example, in a pool game, the balls move and spin based on physics calculations rather than predefined paths.</li>
<li><strong class="bold">Procedurally generated content</strong>: When the content of your game is procedurally generated, you often need to animate things programmatically because the exact nature of the animations can’t be predetermined. For instance, in a rogue-like dungeon crawler, the layout of the dungeon and the placement of enemies are generated on the fly, so any animations related to these elements would also need to be generated at runtime.</li>
<li><strong class="bold">Complex AI behavior</strong>: When creating complex AI behavior, you might use C# to animate GameObjects based on the AI’s decision-making processes. For instance, an enemy character might have an idle animation, a walk animation, and an attack animation, and you can use C# to decide which one to play based on the AI’s current state and the player’s position.</li>
</ul>
<p>Now that we<a id="_idIndexMarker445"/> have understood the scenarios in which it is useful to use C# for animations and interactions, let’s put our new knowledge to use by scaling a car using a slider in the following section. This would fall under the “real-time user input” category. When we want to scale a car using a slider, it’s the user input (moving the slider) that’s driving the animation (the scaling of the car). This kind of interaction can’t be predefined with keyframes because the exact scale of the car depends on the player’s input at any given moment. But before we add these to our scene, we first need to understand the very basics of the C# language, which are explained in the following section.</p>
<h2 id="_idParaDest-111">Understanding scripting with C# in Unity</h2>
<p>Creating scripts<a id="_idIndexMarker446"/> for VR development in Unity involves using C#. As a high-level language, it simplifies many computing complexities, making it user-friendly compared to languages such as C++.</p>
<p>Through its <a id="_idIndexMarker447"/>strong, static typing, C# helps you spot programming errors before running a game in Unity, which is incredibly helpful for developers. Additionally, it’s good at managing memory use, as it minimizes the risk of <strong class="bold">memory leaks</strong>—a <a id="_idIndexMarker448"/>situation where a game eats up an increasing amount of memory, potentially causing crashes.</p>
<p>C# is supported by Microsoft, which ensures you get reliable help, plenty of tools to work with, and access to a big community of other developers. And, importantly, just like Unity, C# works across many platforms.</p>
<p>When using C# in Unity, your coding is mostly event-based. This means you override certain Unity functions that get triggered at specific times, such as the <code>Start()</code> or <code>Update()</code> functions of a game.</p>
<p>Now, when it comes to using C# for VR development in Unity, there are three key object-oriented programming concepts you’ll need to understand: variables, functions, and classes. Let’s get to know these a bit better.</p>
<h3>Variables</h3>
<p><strong class="bold">Variables</strong> are like <a id="_idIndexMarker449"/>storage boxes that your script uses to hold data. Every variable has a type, which tells you what kind of data it can hold. For example, if you’re using the XR Interaction Toolkit, you might have variables to store things such as the position of a VR controller, the state of an object in the virtual world, and so on. Let's see an example of how we can use variables in the context of a C# script for Unity with the following code snippet:</p>
<pre class="source-code">
public class XRGrab : MonoBehaviour
{
    public XRGrabInteractable grabInteractable;
    private bool isGrabbed = false;
}</pre>
<p>In the<a id="_idIndexMarker450"/> preceding code, <code>grabInteractable</code> is an <code>XRGrabInteractable</code> object that represents a VR object that can be interacted with. <code>isGrabbed</code> is a private Boolean variable tracking whether the object is currently grabbed or not.</p>
<h3>Functions</h3>
<p>Think of <strong class="bold">functions</strong> (or methods) in C# as <a id="_idIndexMarker451"/>cooking recipes. Just like a recipe provides step-by-step instructions to cook a specific dish, a function in C# consists of a set of instructions that performs a specific task. You can reuse these recipes multiple times, either within the same script or across different scripts.</p>
<p>In Unity, there are some special functions, such as unique cooking recipes, that are triggered at specific times during the life cycle of a script. Here is an overview of them:</p>
<ul>
<li> <code>Awake()</code>: This is like an alarm clock for your script. This function rings when the script first wakes up (or loads). Often, it’s used to set up variables or the state of the game.</li>
<li><code>Start()</code>: This is the runner on their mark, ready to start the race. This function gets called right before the first frame of the game is displayed. It’s also used to set things up, but unlike <code>Awake()</code>, it won’t run if the script isn’t enabled.</li>
<li><code>Update()</code>: This function is the heart of your game, beating once per frame. It’s usually used for tasks that need to happen regularly, such as moving objects around, checking for user input, and so on.</li>
<li><code>FixedUpdate()</code>: This is like <code>Update()</code>, but it runs at a consistent pace, no matter the frame rate. It’s typically used for physics-related tasks.</li>
<li><code>LateUpdate()</code>: This is the function that tidies up after everyone else. It runs after all <code>Update()</code> functions have done their thing, doing any tasks that need to happen after everything else.</li>
<li><code>OnEnable()</code>: This method is a special Unity method that gets called whenever the object this script is attached to becomes active in the game.</li>
</ul>
<p>Now, when<a id="_idIndexMarker452"/> it comes to VR interactions, Unity’s XR Interaction Toolkit provides its own set of special functions that react to VR actions. Here are a few important ones you’ll want to know about:</p>
<ul>
<li><code>OnSelectEntered()</code>: This function is called when you select an interactable object in VR. Imagine it as the moment when you point at a virtual object with your VR controller.</li>
<li><code>OnSelectExited()</code>: This function is the moment when you stop selecting an interactable object. Think of it as letting go of the object you were pointing at.</li>
<li><code>OnActivate()</code>: This is when you activate an interactable object. It’s a bit like pressing a button while you’re already holding the object.</li>
<li><code>OnDeactivate()</code>: This is when you deactivate the object. It’s like letting go of the button you just pressed.</li>
<li><code>OnHoverEntered()</code>: This function gets called when you start hovering over an interactable object. This could be used to make the object light up, for instance.</li>
<li><code>OnHoverExited()</code>: This function is when you stop hovering over an object.</li>
</ul>
<p>These functions can be combined in different ways to create all sorts of interactions in the virtual world. It’s like stacking building blocks together to create something more complex.</p>
<h3>Classes</h3>
<p><code>MonoBehaviour</code>, <code>ScriptableObject</code>, or others to illustrate the characteristics of classes in C#. Let’s go through an example class called <code>XRGrab</code>, which inherits from the base class, <code>MonoBehaviour</code>. The first section of this class consists of the following:</p>
<pre class="source-code">
public class XRGrab : MonoBehaviour
{
    public XRGrabInteractable grabInteractable;
    private bool isGrabbed = false;</pre>
<p>In the<a id="_idIndexMarker454"/> preceding example, the <code>XRGrab</code> class consists of two fields. <code>public XRGrabInteractable grabInteractable</code> is a reference to an <code>XRGrabInteractable</code> object. This script is typically attached to a GameObject that you want to make interactable in a VR or AR setting; for example, an object the user should be able to grab. <code>isGrabbed</code> is a boolean variable that keeps track of whether the interactable object is currently grabbed.</p>
<p>The next section of our class consists of methods. The first method of our class is called <code>OnEnable()</code>:</p>
<pre class="source-code">
    void OnEnable()
    {
        grabInteractable.onSelectEntered
            .AddListener(Grabbed);
        grabInteractable.onSelectExited
            .AddListener(Released);
    }</pre>
<p>The <code>OnEnable()</code> method adds <code>Grabbed()</code> and <code>Released()</code> methods as listeners to the <code>onSelectEntered</code> and <code>onSelectExited</code> events of the <code>grabInteractable</code> object. This means when the user interacts with the object in the VR/AR world by selecting it, the <code>Grabbed()</code> method will be called, and when the user stops interacting with it and hence deselects it, the <code>Released()</code> method will be called.</p>
<p>Let’s have a look at what both of these methods might look like:</p>
<ul>
<li>Here's the <code>Grabbed()</code> method:<pre class="source-code">
    void Grabbed(SelectEnterEventArgs args)</pre><pre class="source-code">
    {</pre><pre class="source-code">
        isGrabbed = true;</pre><pre class="source-code">
    }</pre><p class="list-inset">The <code>Grabbed()</code> method sets <code>isGrabbed</code> to true, indicating that the object has been grabbed.</p></li>
<li>Here's the <code>Released()</code> method:<pre class="source-code">
    void Released(SelectExitEventArgs args)</pre><pre class="source-code">
    {</pre><pre class="source-code">
        isGrabbed = false;</pre><pre class="source-code">
    }</pre><pre class="source-code">
}</pre><p class="list-inset">The <code>Released()</code> method sets <code>isGrabbed</code> to false, indicating that the object has been released.</p></li>
</ul>
<p>As you <a id="_idIndexMarker455"/>can see, scripting in Unity using C# involves defining variables to hold data, implementing functions to manipulate that data or implement gameplay, and organizing these variables and functions into classes that represent objects or concepts in your game. The Unity engine then uses these scripts to drive the behavior of GameObjects within your scenes.</p>
<p>In the realm of C#, class names typically <a id="_idIndexMarker456"/>follow the <strong class="bold">PascalCase convention</strong>, where each word begins with an uppercase letter and underscores are absent. You have the freedom to select any name that pleases you, as long as it complies with the general naming conventions of C#. Here are the naming guidelines:</p>
<ul>
<li>Names should commence with an uppercase letter instead of an underscore or a digit.</li>
<li>Names can incorporate letters and digits but not underscores.</li>
<li>Spaces or special characters should not be part of the name.</li>
<li>Lastly, the name must not be a reserved word in C#. Words such as “class”, “int”, “void”, and so on are reserved and cannot be employed as a name. This is because they have specific meanings in C#, as they are part of its syntax. The compiler expects them to be used in specific ways, so using them as identifiers would cause confusion and lead to compilation errors.</li>
</ul>
<p>And that’s a <a id="_idIndexMarker457"/>gentle introduction to scripting in Unity for VR development. Don’t worry if it still sounds a bit complex; like with any language, practice makes perfect, and this is exactly what you are going to do in the next section!</p>
<h2 id="_idParaDest-112">Scaling a bus using a slider and C#</h2>
<p>We are about to<a id="_idIndexMarker458"/> embark on an exciting task: enriching our car exhibition experience by adding a dynamic scaling feature to a bus. Previously, we used fixed animations to scale a police car. However, this time, we will scale a bus in real time based on user interaction with a slider.</p>
<p>With<a id="_idIndexMarker459"/> these steps, we will achieve our objective. So, let’s dive in:</p>
<ol>
<li>First, we need to bring the bus into our scene. Go to <code>Assets</code> | <code>Simple Vehicle Pack</code> | <code>Prefabs</code>, drag and drop <code>Bus_2</code> into the scene. Position it at coordinates (<code>0,0,-6</code>), with a <code>-90</code> degree rotation on the y-axis.</li>
<li>Next, we require a slider and a descriptive text that indicates that the bus can be scaled using the slider. To accomplish this, we first need to create a canvas. Right-click in the hierarchy and select <code>0.01,0.01,0</code>), position it at (<code>0,1.5,-5</code>), and rotate it to (<code>0,180,0</code>). Now it is facing the player’s direction. Note that you must set the <code>Bus Scale Canvas</code> for clarity.<p class="list-inset">One thing is missing before adding UI elements to the canvas: the <strong class="bold">Vertical Layout Group</strong> component. Let’s add this in the Inspector and change the <strong class="bold">Child Alignment</strong> property to the <strong class="bold">Upper Center</strong>. This ensures that both the slider and text will be vertically aligned at the upper center of the canvas.</p></li>
<li>Next, we can add the slider. Right-click on the <code>0</code> and the <code>5</code>, allowing the bus to be scaled between these values. Let’s rename the slider to <code>Bus Scale Slider</code> for distinction.</li>
<li>For <a id="_idIndexMarker460"/>enhanced user experience, we will also place a text above the slider. Add a <code>Slider</code> GameObject by right-clicking on <code>Bus Scale Slider</code>, select <code>Bus </code><code>Scale Text</code>.</li>
</ol>
<p>We have<a id="_idIndexMarker461"/> now set up the slider, which serves as our initialization event, as shown in <em class="italic">Figure 5</em><em class="italic">.11</em>.</p>
<div><div><img alt="Figure 5.11 – ﻿The bus scale slider" src="img/B20869_05_11.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.11 – The bus scale slider</p>
<p>Following this, we will link this with the scaling animation and state control via a single C# script. The idea is to bind the slider’s value to the bus’s scale.</p>
<p>Before proceeding with scripting, it’s advisable to maintain organization by creating a new folder:</p>
<ol>
<li>Right-click in the <code>Assets</code> folder, choose <code>Scripts</code>.</li>
<li>Inside <a id="_idIndexMarker462"/>this new folder, create a new C# script and rename it <code>BusScaler</code>. This script will be our primary tool in bringing dynamic scaling to life.</li>
<li>Now double-click on the script. This will open it in the IDE that is installed on your computer. This is the code we are going to develop.</li>
</ol>
<h3>Writing the animation script</h3>
<p>The following <a id="_idIndexMarker463"/>explanations guide you on how the main components of the <code>BusScaler</code> script interact with each other:</p>
<ol>
<li>Start with the following two lines of code to define your namespaces:<pre class="source-code">
using UnityEngine;</pre><pre class="source-code">
using UnityEngine.UI;</pre><p class="list-inset">The first step of any C# script in Unity is to include <code>using</code> keyword is used to include namespaces in the script. <code>UnityEngine</code> contains all the classes needed for creating games in Unity, while <code>UnityEngine.UI</code> contains classes for creating and manipulating UI elements.</p></li>
<li>The class declaration follows next. In our script, let's declare a new class named <code>BusScaler</code> with the following code sequence:<pre class="source-code">
public class BusScaler : MonoBehaviour</pre><p class="list-inset">This class inherits from <code>MonoBehaviour</code>, which is the base class for all Unity scripts.</p></li>
<li>Next, declare the variables of the <code>BusScaler</code> class with the following code sequence:<pre class="source-code">
public GameObject bus;</pre><pre class="source-code">
public Slider slider;</pre><p class="list-inset">The <code>public</code> keyword means these variables can be accessed from other scripts and can also be set from Unity’s <code>bus</code> variable will hold the bus object in the scene and the <code>slider</code> variable will hold the slider UI object in the scene.</p></li>
<li>Next, let's override<a id="_idIndexMarker465"/> the <code>Awake()</code> function to set up initial settings and references before the game starts. This includes setting the initial scale of the bus to <code>1</code> on the x-, y-, and z-axes. We do this with the following code snippet:<pre class="source-code">
private void Awake()</pre><pre class="source-code">
{</pre><pre class="source-code">
bus.transform.localScale = new Vector3(1f, 1f, 1f);</pre><pre class="source-code">
}</pre></li>
<li>Our final step is to override the <code>Update()</code> function. Type or paste in the following lines of code:<pre class="source-code">
private void Update()</pre><pre class="source-code">
{</pre><pre class="source-code">
float scaleValue = slider.value;</pre><pre class="source-code">
bus.transform.localScale = new Vector3(scaleValue, scaleValue, scaleValue);</pre><pre class="source-code">
}</pre><p class="list-inset">This code retrieves the value of the slider (which ranges between its minimum and maximum values set in Unity’s Inspector) and sets the scale of the bus to this value on the x-, y-, and z-axes. This means if the slider’s value is <code>0.5</code>, the bus will be half its original size.</p></li>
</ol>
<h3>Testing our animation</h3>
<p>Now that <a id="_idIndexMarker466"/>our C# script is finished, there are only a few steps left to complete until we can test our animation:</p>
<ol>
<li>In our C# script, the class <code>BusScaler</code> is derived from <code>MonoBehaviour</code>. To utilize this script, it needs to be associated with a GameObject within the Unity editor. To do this, right-click in the hierarchy and select <code>Bus </code><code>Scaler Controller</code>.</li>
<li>Next, you can drag your script and drop it into the <strong class="bold">Inspector</strong> panel of this new GameObject. This action will attach your script as a component.</li>
<li>Upon doing this, you’ll notice that the public fields <code>bus</code> and <code>slider</code> become visible in the script component within the Unity editor. These fields need to be populated with the actual <code>bus</code> GameObject and the slider object this script will interact with. To do this, simply drag and drop these objects into the corresponding field, as shown in <em class="italic">Figure 5</em><em class="italic">.12</em>.</li>
</ol>
<div><div><img alt="Figure 5.12 – ﻿The Inspector window of the Bus Scaler Controller with the bus and slider objects placed into their corresponding fields in the Bus Scaler script" src="img/B20869_05_12.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.12 – The Inspector window of the Bus Scaler Controller with the bus and slider objects placed into their corresponding fields in the Bus Scaler script</p>
<ol>
<li value="4">The final step before you can test your interactive slider is to place a teleport anchor in front of it. This can be done by going back to our toolbox and navigating to <code>Assets</code> | <code>Samples</code> | <code>XR </code><code>Interaction Toolkit</code>:<ol><li class="upper-roman">Here, you’ll find the <code>Bus </code><code>Teleport Anchor</code>.</li><li class="upper-roman">Position<a id="_idIndexMarker467"/> this anchor at coordinates (<code>0</code>,<code>0</code>,<code>-2.5</code>) and adjust its size to (<code>2</code>,<code>1</code>,<code>2</code>). With this setup, the user can now teleport to a position in front of the slider, enabling them to scale the bus interactively, as shown in <em class="italic">Figure 5</em><em class="italic">.13</em>.</li></ol></li>
</ol>
<div><div><img alt="Figure 5.13 – ﻿How the bus is scaled when the user interacts with the slider in VR" src="img/B20869_05_13.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.13 – How the bus is scaled when the user interacts with the slider in VR</p>
<p>Hurray, you have successfully completed all the steps needed for this animation. Now, it is time to explore your interactive VR scene once more. For this, follow the steps described in the <em class="italic">Deploying and testing VR experiences onto different VR platforms or simulators</em> section of <a href="B20869_03.xhtml#_idTextAnchor009"><em class="italic">Chapter 3</em></a>.</p>
<h1 id="_idParaDest-113">Summary</h1>
<p>In this chapter, you have learned how to add interactivity into your VR scenes in Unity, using both code-dependent and code-free methods. By now, having successfully navigated through the steps provided in this chapter, you should have brought your Unity scene to life and acquired a solid understanding of and established a comfort level in deciding when to opt for Unity’s animator system and when to leverage the power of C# for your interactive scene creation needs.</p>
<p>We’ve delved into the intricacies of triggering button events and utilizing the animator system, thereby equipping you with the skills to create simple yet effective interactions in your VR landscape without having to write a line of code. For more intricate interaction designs, you should now feel very familiar with the essential functions of C# in Unity and be familiar with the robust functionalities provided by the XR Interaction Toolkit.</p>
<p>Be it industrial applications or academic projects, these skills and techniques should empower you to create immersive VR scenes in Unity using the XR Interaction Toolkit and its demo scene. You should feel ready to apply what you've learned to your unique use cases.</p>
<p>But our journey does not end here. In the forthcoming chapter, we’ll broaden our horizon by venturing into the creation of interactive AR and MR experiences in Unity. This will ensure that you are comprehensively equipped to add interactions across the spectrum of XR scenes. Let’s continue our exciting exploration into the world of immersive technology.</p>
</div>
</body></html>