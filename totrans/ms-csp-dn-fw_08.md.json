["```cs\n{\n  \"name\": \"ExpressApp1\",\n  \"version\": \"0.0.0\",\n  \"description\": \"ExpressApp1\",\n  \"main\": \"app.js\",\n  \"author\": {\n    \"name\": \"Marino\",\n    \"email\": \"\"\n  },\n  \"dependencies\": {\n    \"express\": \"3.4.4\",\n    \"jade\": \"*\",\n    \"stylus\": \"*\"\n  }\n}\n```", "```cs\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nnamespace ConsoleRoselyn1\n{\n  class Person\n  {\n    public int id { get; set; }\n    public string Name { get; set; }\n    public int Age { get; set; }\n    internal Person Create()\n    {\n      Person p = new Person();\n      p.id = 1;\n      p.Name = \"Chris Talline\";\n      p.Age = 33;\n      return p;\n    }\n    internal string PersonData()\n    {\n      var p = Create();\n      return p.id.ToString() + \"-\" + p.Name + \"-\" + \n        p.Age.ToString();\n    }\n  }\n}\n```", "```cs\n// Fist, we localize and load the file to check out\nstring filename = @\"[Path-to-your-Project]\\Person.cs\";\nstring content = File.ReadAllText(filename);\n// Now we have to analyze the contents\n// So, we use the same class as before. Notice \n// it returns a SyntaxTree object.\nSyntaxTree tree = CSharpSyntaxTree.ParseText(content);\n```", "```cs\nClassDeclarationSyntax personClass = root.DescendantNodes().OfType<ClassDeclarationSyntax>().First();\nConsole.WriteLine(\"Class names\");\nConsole.WriteLine(\"-----------\");\nConsole.WriteLine(personClass.Identifier);\n```", "```cs\nConsole.WriteLine(\"\\nMethod names\");\nConsole.WriteLine(\"------------\");â€©personClass.DescendantNodes().OfType<MethodDeclarationSyntax>().ToList().ForEach(method => Console.WriteLine(method.Identifier));\n```", "```cs\n// And the properties\nConsole.WriteLine(\"\\nProperties\");\nConsole.WriteLine(\"----------\");\npersonClass.DescendantNodes()\n.OfType<PropertyDeclarationSyntax>().ToList()\n.ForEach(property => Console.WriteLine(property.Identifier));\n```", "```cs\nusing Microsoft.CodeAnalysis;\nusing Microsoft.CodeAnalysis.Diagnostics;\nusing System.Collections.Immutable;\nusing System.Linq;\n\nnamespace Analyzer2\n{\n  [DiagnosticAnalyzer(LanguageNames.CSharp)]\n  public class Analyzer2Analyzer : DiagnosticAnalyzer\n  {\n    public const string DiagnosticId = \"Analyzer2\";\n\n    // You can change these strings in the Resources.resx file. If you do not want your analyzer to be localize-able, you can use regular strings for Title and MessageFormat.\n    // See https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Localizing%20Analyzers.md for more on localization\n    private static readonly LocalizableString Title = new LocalizableResourceString(nameof(Resources.AnalyzerTitle), Resources.ResourceManager, typeof(Resources));\n    private static readonly LocalizableString MessageFormat = new LocalizableResourceString(nameof(Resources.AnalyzerMessageFormat), Resources.ResourceManager, typeof(Resources));\n    private static readonly LocalizableString Description = new LocalizableResourceString(nameof(Resources.AnalyzerDescription), Resources.ResourceManager, typeof(Resources));\n    private const string Category = \"Naming\";\n\n    private static DiagnosticDescriptor Rule = new DiagnosticDescriptor(DiagnosticId, Title, MessageFormat, Category, DiagnosticSeverity.Warning, isEnabledByDefault: true, description: Description);\n\n    public override ImmutableArray<DiagnosticDescriptor> SupportedDiagnostics { get { return ImmutableArray.Create(Rule); } }\n\n    public override void Initialize(AnalysisContext context)\n    {\n      // TODO: Consider registering other actions that act on syntax instead of or in addition to symbols\n      // See https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Analyzer%20Actions%20Semantics.md for more information\n      context.RegisterSymbolAction(AnalyzeSymbol, SymbolKind.NamedType);\n    }\n\n    private static void AnalyzeSymbol(SymbolAnalysisContext context)\n    {\n      // TODO: Replace the following code with your own analysis, generating Diagnostic objects for any issues you find\n      var namedTypeSymbol = (INamedTypeSymbol)context.Symbol;\n\n      // Find just those named type symbols with names containing lowercase letters.\n      if (namedTypeSymbol.Name.ToCharArray().Any(char.IsLower))\n      {\n        // For all such symbols, produce a diagnostic.\n        var diagnostic = Diagnostic.Create(Rule, namedTypeSymbol.Locations[0], namedTypeSymbol.Name);\n\n        context.ReportDiagnostic(diagnostic);\n      }\n    }\n  }\n}\n```", "```cs\ninterface Calculator {\n  increment?: number,\n  clear(): void,\n  result(): number,\n  add(n: number): void,\n  add(): void,\n  new (s: string): Element;\n}\n```", "```cs\nmodule Utilities {\n  // export generates a \"closure\" in JS \n  export class Tracker2 {\n    count = 0;\n    start() {\n      // Something starts here...\n      // Check the generated JS\n    }\n  }\n}\n```", "```cs\nvar t = new Utilities.Tracker2();\nt.start();\n```", "```cs\nmodule Acme.core.Utilities {\n  export var x: number = 7;\n  export class Tracker2 {\n    count = 0;\n    start() {\n      // Something here \n    }\n  }\n}\n// This requires \"nested access\"\nAcme.core.Utilities.x;\n```", "```cs\n// Use of the \"Import\" technique\nimport ACU = Acme.core.Utilities;\nACU.x;\nvar h = new ACU.Tracker2();\n```", "```cs\ndeclare var document: Document;\ndocument.title = \"Hello\";  // Ok because document has been declared\n```", "```cs\ndeclare var $;\n```", "```cs\nnamespace myNS {\n  var insideStr = \"Inside a Module\";\n  export function greeter() {\n    return insideStr;\n  }\n}\nmyNS.greeter();\nmyNS.insideStr;\n```", "```cs\nclass PointWithColor {\n  x: number;\n  y: number;\n  // Private members \n  private color: string;\n  constructor(x: number, y: number) {\n    this.x = x;\n    this.y = y;\n    this.color = \"Blue\"; // Intellisense -in- the class\n  }\n  distance() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  // We can also (ES5) turn distance into a property\n  get distanceP() {\n    return Math.sqrt(this.x * this.x + this.y * this.y);\n  }\n  // And declare static members\n  static origin = new PointWithColor(0, 0)\n}\n```", "```cs\nclass PointWithColor2 {\n  // Private members \n  private color: string;\n  // The following declaration produces the same effect \n  // as the previous as for accessibility of its members \n  // Even, assigning default values\n  constructor(public x: number = 0, public y: number = 0) {\n    this.color = \"Red\"; \n  }\n  distance() { return Math.sqrt(this.x * this.x + this.y * this.y); }\n  get distanceP() { return Math.sqrt(this.x * this.x + this.y * this.y); }\n  static origen = new PointWithColor(0, 0)\n}\n```", "```cs\nclass PointWithColor3D extends PointWithColor {\n  // It uses the base class constructor, otherwise\n  // creates a customized one.\n  constructor(x: number, y: number, public z: number) {\n    super(x, y);\n  }\n  // Method overloading \n  distance() {\n    var d = super.distance();\n    return Math.sqrt(d * d + this.z * this.z);\n  }\n}\n```", "```cs\nadd(x: number, y: number): number {\n    return x + y;\n}\n```", "```cs\ninterface Person {\n    name: string, \n    age?: number  // the age is optional\n}\n\nfunction add(person: Person) {\n    var name = person.name; // Ok\n}\n\nadd({ name: \"Peter\" });  // Ok\nadd({ age: 37 });  // Error, name required\nadd({ name: \"Irene\", age: 17 });  // Ok\n```", "```cs\n// Declare and initialize\nvar person: {\n    name: string;\n    age: number;\n    emails: string[];\n} = {\n        name: 'John',\n        age: 5,\n        emails: ['john@site.com', 'john@anothersite.net']\n    }\n```", "```cs\nfunction funcWithLambda(x: () => string) {\n    x(); // Intellisense\n}\n```", "```cs\ninterface Thing {\n    a: number;\n    b: string;\n    doSomething(s: string, n?: number): string; //methods\n    // Method overloading\n    doSomething(n: number): number;\n}\n\nfunction process(x: Thing) {\n    x.doSomething(\"hola\"); // Intellisense\n    x.doSomething(3); // Ok\n}\n```", "```cs\n// Methods with properties\n// Equivalent to the previous + data\ninterface Thing3 {\n    a: number;\n    b: string;\n    // Here we add a field data to doSomething\n    doSomething: {\n        (s: string): string;\n        (n: number): number;\n        data: any;\n    };\n}\n```", "```cs\nfunction callThing3(x: Thing3) {\n    x.doSomething(\"hello\"); // Intellisense (overloading)\n    x.doSomething(3);\n    x.doSomething.data; // method with properties\n}\n```", "```cs\ninterface Thing4 {\n    // Constructor\n    new (s: string): Element;\n    // Indexer\n    [index: number]: Date;\n}\n\nfunction callThing4(x: Thing4) {\n    // return new x(\"abc\").getAttribute() -> returns Element\n    return x[0].getDay(); // Date info\n}\n```", "```cs\ninterface Counter {\n    delete(): void;\n    add(x: number): void;\n    result(): number;\n}\n\nfunction createCounter(): Counter {\n    var total = 0;\n    return {\n        delete: function () { total = 0 },\n        add: function (value: number) {\n            total += value;\n        },\n        result: function () { return total; }\n    };\n}\n\nvar a = createCounter();\na.add(5); //Ok\n\n// It's also useful for event handlers\nwindow.onmousemove = function (e) {\n    var pos = e.clientX; // Intellisense in the event\n    // You can use the \"Go to Definition\" option ->\n    // which takes you to \"lib.d.ts\" library\n}\n```", "```cs\nclass OverloadedClass {\n    overloadedMethod(aString: string): void;\n    overloadedMethod(aNumber: number, aString: string): void;\n    overloadedMethod(aStringOrANumber: any, aString?: string): void {\n        // Version checking is performed on the first argument\n        if (aStringOrANumber && typeof aStringOrANumber == \"number\")\n            alert(\"Second version: aNumber = \" + aStringOrANumber +\n                \", aString = \" + aString);\n        else\n            alert(\"First version: aString = \" + aStringOrANumber);\n    }\n}\n```", "```cs\ninterface Mountain {\n    name: string;\n    height: number;\n}\n// Mountain interface declared\nvar mountains: Mountain[] = [];\n// Every added element is checked\nmountains.push({\n    name: 'Pico de Orizaba',\n    height: 5636,\n});\nmountains.push({\n    name: 'Denali',\n    height: 6190\n});\nmountains.push({\n    name: 'Mount Logan',\n    height: 5956\n});\n\nfunction compareHeights(a: Mountain, b: Mountain) {\n    if (a.height > b.height) {\n        return -1;\n    }\n    if (a.height < b.height) {\n        return 1;\n    }\n    return 0;\n}\n// Array.sort method expects a comparer which takes 2 arguments\nvar mountainsByHeight = mountains.sort(compareHeights);\n// Read the first element of the array (Highest)\nvar highestMoutain = mountainsByHeight[0];\nconsole.log(highestMoutain.name); // Denali\n```", "```cs\n// JavaScript source code\nfunction sortByName(arg) {\n  var result = arg.slice(0);\n  result.sort(function (x, y) {\n    return x.name.localCompare(y.name);\n  });\n  return result;\n};\n```", "```cs\ninterface Person {\n  name: string, \n  age: number\n}\nfunction sortByName(arg: Person[]) {}\n```", "```cs\ninterface Entity {\n  name: string,\n  price: number, \n  id : number\n}\n\nvar hardware: Entity[] = [\n  { name: \"Mouse\", price: 9.95, id: 3 },\n  { name: \"Keyboard\", price: 27.95, id: 1 },\n  { name: \"Printer\", price: 49.95, id: 2 },\n  { name: \"Hard Drive\", price: 72.95, id: 4 },\n];\n\nfunction sortByName(a: Entity[]) {\n  var result = a.slice(0);\n\n  result.sort(function (x, y) {\n    return x.name.localeCompare(y.name);\n  });\n  return result;\n}\nwindow.onload = () => {\n  var sorted = sortByName(hardware);\n  sorted.map((e) => {\n    var elem = document.createElement(\"p\");\n    document.body.insertAdjacentElement(\"beforeEnd\", elem);\n    elem.innerText = e.name.toString() + \" - \" + e.price.toString();\n  });\n}\n```", "```cs\nwindow.onmousemove = function (e) {\n  alert(\"Mouse moved at X coord: \" + e.clientX);\n};\n```"]