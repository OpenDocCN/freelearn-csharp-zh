- en: Chapter 6.  Sequences - The Core of Data Processing Patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will take a deep dive into one of the most essential and
    utterly important arrangements of functional programming, that is, sequences.
    The ability to represent any data transformation as a composition of atomic functions
    applied to the elements of an arbitrary enumerable data container is a must for
    a functional programmer. The goal of this chapter is to help you acquire this
    mental skill. The way towards this goal is paved by the following topics covered
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: Review the basic data transformations and partition the immense host of standard
    library data transformation functions by handful of underlying processing patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Consider the duality of sequence data generators being at once a data and an
    on-demand calculation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cover how a sequence generalizes arbitrary collections by enumerating them,
    which represents the pull data transformation pattern
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Further consider just another pattern of using generated sequences for data
    drilling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Wrap up by practically exploring how the usage of sequences affects the code
    performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic sequence transformations
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s revisit the functional solution of the sample problem from [Chapter
    1](text00015.html#page "Chapter 1. Begin Thinking Functionally") , *Begin Thinking
    Functionally* . It represents the common functional pattern of *finding a given
    property of the collection* as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: From the given string literal representing 1000 consecutive single digit characters,
    make a collection of the collections represented by chunks of just five consecutive
    single digit characters of the original collection. Each chunk takes the inner
    characters of a five character-wide stencil aligned first with the left-hand side
    border of the string literal. The stencil then gets moved to the right by a single
    character before extracting the next sub collection. This sliding of the stencil
    to the right is continued until the right-hand side borders of both the stencil
    and the literal get aligned. To be exact, the main sequence consists of 996 such
    five character sub sequences.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note that the originally sought-for property of the maximal product of five
    consecutive digits at this point is substituted with a similar property of the
    sequence of elements, each representing a candidate group from which the sought-for
    property originates. It is worth pointing out that in order to solve the original
    problem, *all* elements of this secondary sequence must be taken into account
    (other patterns may differ in this respect, for example, *finding any sequence
    element with a given property* ).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform a complete scan of the substitute sequence, looking for the maximal
    value of the sought-for property, which is the product of the constituents of
    the inner sequence representing an element of the outer sequence that substitutes
    the original string literal.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Those of you who are attentive to detail may have already spotted the similarity
    of the preceding solution approach to the  **MapReduce** ([https://en.wikipedia.org/wiki/MapReduce](https://en.wikipedia.org/wiki/MapReduce)
    ) pattern, just without the possible partitioning and parallelization of the **map**
    phase for now. This similarity is not coincidental. After implementing a serious
    amount of F# **ETL** ([https://en.wikipedia.org/wiki/Extract,_transform,_load](https://en.wikipedia.org/wiki/Extract,_transform,_load)
    ) tasks, big and small for enterprise **Line of Business** ( **LOB** ) applications,
    I can conclude that the part of the F# core library covering basic operations
    upon enumerable sequences, namely the `Collections.seq` library module of the
    **Microsoft.FSharp.Collections** ([https://msdn.microsoft.com/en-us/library/ee353635.aspx](https://msdn.microsoft.com/en-us/library/ee353635.aspx)
    ) namespace, has already distilled the typical functional patterns of data sequence
    processing. Any effective F# developer should be conversant in representing a
    sought-for data transformation solution at hand into a combination of these library
    functions from `Collections.seq` .
  prefs: []
  type: TYPE_NORMAL
- en: Based on my own experience, this set of 70 library functions (for version 4.0
    of F#) is hard to grok when you consider it as a list that is just alphabetically
    ordered by the function name. It is hard to memorize what exactly this or that
    function is doing without distinguishing their commonalities and differences.
    This perception can be facilitated if we start seeing a certain data transformation
    pattern being implemented by each of these functions. These patterns stem from
    years of accumulated experience in applying functional programming to data processing
    and are coined into the selection of functions that the F# designers have slated
    for inclusion into the core library.
  prefs: []
  type: TYPE_NORMAL
- en: 'I believe that by observing the `Collection.seq` library constituents from
    this data processing pattern relationship angle, the following function groups
    can be distinguished:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Aggregates** : These functions traverse the sequence in its entirety, returning
    a single value calculated upon the sequence elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Generators** : These functions produce sequences "out of thin air", or seriously,
    sequences of special kinds (such as empty typed sequence) and sequences defined
    either by a quantitative relation between the element and its sequence order number
    or just by a recurrently defined function deriving the next element based on the
    previous element(s).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Wrappers and Type Converters** : These functions either wrap the entire sequence
    into a useful property (caching is a good example of a wrap) or just convert the
    sequence to other collection types (lists or arrays).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Appliers** : These functions just traverse the sequence, applying the given
    calculation to each element for the sake of a side effect, for example, to print
    out sequence elements as strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Recombinators** : These functions shuffle the sequence or extract its elements
    in a type-uniform manner; in other words, for a sequence of type `''T` dealing
    exclusively with `seq<''T>` or `''T` objects. For example, create a new sequence
    by skipping the first 100 elements of the original one.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filters** : These functions are concerned with the selection of elements
    that conform to an arbitrary condition(s). For example, try to find the first
    element of a sequence for which a given predicate function returns true.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Mappers** : These functions change shape and/or the type of the original
    sequence(s) by producing a transformed sequence(s), for example, a zipping function
    that takes two input sequences and produces the single result sequence with each
    element being a tuple that combines elements from both input sequences sharing
    the same order number.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Equipped with this classification approach, I've partitioned the library functions
    by the following set of patterns. Under each pattern, all the relevant library
    functions are listed along with their signatures. I encourage you to explore the
    signatures in order to spot the commonalities responsible for each group formation.
  prefs: []
  type: TYPE_NORMAL
- en: Additional information for those of you who are eager to dig deeper is given
    in the `Ch6_1.fsx` script of this book's accompanying code, where the use of each
    of the library functions is illustrated by a brief code sample.
  prefs: []
  type: TYPE_NORMAL
- en: The aggregation pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The generation pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The wrapping and type conversion pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The application pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The recombination pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The filtering pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The mapping pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The sequence: Duality of data and calculation'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What makes the F# sequence so ambient and versatile is its dual nature. Being
    a strongly typed generic data collection, it exposes the contained data via two
    archetypal .NET interfaces of the `System.Collections.Generic` namespace, namely
    `IEnumerable<T>` ([https://msdn.microsoft.com/en-us/library/9eekhta0(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/9eekhta0(v=vs.110).aspx)
    ) and `IEnumerator<T>` ([https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx)
    ).
  prefs: []
  type: TYPE_NORMAL
- en: 'These interfaces personify the classic data pull protocol, where a data consumer
    actively pulls data from the producer. Indeed, the type of `seq<''T>` in the F#
    is defined as the following abbreviation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The preceding line of code means in practice that each F# sequence is a data
    collection, which can be traversed by getting an *enumerator* that allows you
    to stir through the sequence from its head towards its tail, obtaining the values
    of its elements. The enumerator itself can be obtained using the `GetEnumerator()`
    method of the `IEnumerable<'T>` interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the enumerator, which in turn implements the `IEnumerator<''T>` interface,
    the sequence can be traversed using the pair of members that constitute this interface:
    the `Current` property, which gets the value of the sequence element at the current
    position of the enumerator, and the `MoveNext()` method, which advances the position
    of the enumerator to the next element of the sequence.'
  prefs: []
  type: TYPE_NORMAL
- en: Rather boring, right? Well, it might be boring when being applied to *materialized*
    data collections such as the F# list, where all elements exist in the physical
    memory space. However, nothing in the preceding scheme insists upon the element
    materialization! It doesn't require much mental effort to imagine `IEnumerator<'T>`
    being implemented by a calculation that returns the freshly constructed value
    of `'T` in response to getting the `Current` property, and for `MoveNext()` ,
    it just advances the imaginable current position marker of the sequence. The whole
    arrangement is *immaterial* with regard to the memory space occupied by elements,
    as there is no need to keep more than just one materialized `Current` element,
    right? With that, you just rediscovered the inner workings of the F# sequences!
  prefs: []
  type: TYPE_NORMAL
- en: Sequence as a lazy data collection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The F# sequences do not eagerly materialize data elements in the memory. This
    feature aligns very well with the data pull protocol. That is, the current sequence
    element is not required unless the sequence enumerator has reached its position
    in the sequence after a series of `MoveNext()` method invocations and the element
    value has been demanded via getting the enumerator's `Current` property.
  prefs: []
  type: TYPE_NORMAL
- en: However, in order to really master the F# sequences, it is important that you
    understand its nuances. In particular, it is important to be aware of whether
    sequence elements are materialized or not. If a sequence has been calculated on
    the enumerator's demand and is not being converted from a materialized collection,
    such as a list or an array, or is not cached, then there is normally no backing
    memory where sequence element values are persisted. On the contrary, if a sequence
    has been produced from a concrete collection by a library function, for example,
    `Seq.ofList` , then at least one instance of the original list must be present
    for the entire lifespan of the derived collection, as this list can be completely
    arbitrary and no way exists to recreate it from scratch in a manner similar to
    a sequence being re-enumerated multiple times if the re-enumeration is cheap and
    performance considerations do not prompt for caching.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence as a calculation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As I've just mentioned, a sequence can be an enumeration atop a concrete data
    collection where the enumerator is implemented on the collection's side. However,
    more interesting cases represent sequences that have an enumerator that programmatically
    generates sequence elements upon the traversal pull demand. These might be different,
    syntactically sugared forms as sequence comprehensions, sequence computation expressions,
    or standard library functions representing the *generator pattern* considered
    at the beginning of the chapter. As a last resort, a sequence can be brought to
    life in a fully de-sugared manner by implementing some required interfaces. The
    last approach is the most tedious and error-prone; however, it grants unprecedented
    flexibility in comparison to other methods. In a majority of development situations,
    the custom sequence enumerator implementation is unwarranted; however, there might
    be some situations where there is simply no alternative to the custom implementation.
    This topic will be my next subject.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence as an enumerator interface wrapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although implementing a custom sequence is a tedious task, it's not rocket science.
    I'm going to walk you through the process and make you *understand* it. No matter
    how simple or complex the custom sequence is, the implementation process will
    be the same.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, what do you think defines the sequence behavior? Apparently,
    it is not syntactic constructions used for sequence traversing, and it does not
    matter whether it''s sugared or not sugared. All implementation specifics are
    abstracted by the entity standing behind any sequence (and even more broadly,
    behind any .NET collection): the **enumerator** . Enumerator is a class that must
    implement the previously mentioned strongly typed interface `IEnumerator<''T>`
    ([https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/78dfe2yb(v=vs.110).aspx)
    ) of the `System.Collections.Generic` namespace. In turn, `IEnumerator<''T>` inherits
    from two other interfaces: the routine `System.IDisposable` interface and the
    legacy untyped `IEnumerator` interface of the `System.Collections` namespace.
    (Pay attention to the difference between typed `System.Collections.Generic` and
    untyped `System.Collections` namespaces). `IEnumerator<''T>` overrides the `Current`
    property and inherits the `MoveNext()` and `Reset()` methods of the `IEnumerator`
    interface. As these relationships between involved components are quite intricate,
    I have provided a component relationship diagram in the following figure to facilitate
    comprehension:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sequence as an enumerator interface wrapper](img/Image00023.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The relationship between components constituting the F# sequence implementation
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering these intricacies, the implementation plan for any custom F# sequence
    is as following:'
  prefs: []
  type: TYPE_NORMAL
- en: Provide a custom `Enumerator` class for the sequence that implements `System.Collections.Generic.IEnumerator<'T>`
    , `System.Collections.IEnumerator` , and `System.IDisposable` interfaces. For
    the first interface, just implement an override of the `Current` property, and
    the rest of the implementation goes into nongeneric `IEnumerator` .
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide a factory function that is similar to the `GetEnumerator()` methods
    of generic .NET collections that have a `unit ->` `System.Collections.Generic.IEnumerator<'T>`
    signature. This function constructs the requested instance of the enumerator passing
    through its own arguments directly to the constructor, then it upcasts the constructed
    instance into `System.Collections.Generic.IEnumerator<'T>` and returns the result
    as a function of the previously listed signature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Provide another factory function, this time to build a sought-for sequence out
    of the function built in Step 2.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As this may still sound a bit complicated, let''s take a quick walk-through.
    I want us to implement the easiest thing: a strongly typed empty sequence, which
    is a sequence without elements, when its enumerator does not have anything to
    enumerate.'
  prefs: []
  type: TYPE_NORMAL
- en: At the same time, apparently, it must be a normal sequence similar to any other
    native sequence from .NET libraries or a sugared one constructed with the F# language
    facilities or core libraries. Let's do this.
  prefs: []
  type: TYPE_NORMAL
- en: Step 1 - The custom enumerator implementation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The behavior of an empty sequence is pretty straightforward: both typed and
    untyped versions of the `Current` property never have a chance to work as any
    attempt to enumerate empty sequence must immediately terminate; `MoveNext()` always
    returns `false` , indicating that the end of the sequence has already been reached.
    Expressed in the F# code, these considerations are shown in the following snippet
    (`Ch6_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As mentioned earlier, `System.Collections.Generic.IEnumerator<'T>` overrides
    `Current` and inherits `MoveNext()` and `Reset()` of `System.Collections.IEnumerator`
    . Both `Current` properties use the typed default value; the `Current` property
    of the untyped enumerator boxes this default value according to the specification.
    Step 1 is now complete.
  prefs: []
  type: TYPE_NORMAL
- en: Step 2 - The custom enumerator factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Step 2 is quite simple, especially in our case, where the implemented sequence
    does not have any specifics to be communicated to the enumerator at the time of
    construction as shown in the following code (`Ch6_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Step 2 is now complete too.
  prefs: []
  type: TYPE_NORMAL
- en: Step 3 - The custom sequence factory
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This one is a breeze, thanks to the great **object expressions** ([https://msdn.microsoft.com/en-us/library/dd233237.aspx](https://msdn.microsoft.com/en-us/library/dd233237.aspx)
    ) feature of the F# as shown (`Ch6_2.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here we go; it is easy to spot that this particular piece does not in any way
    depend on the produced sequence and is a good candidate to be a member of a Helpers
    library. The implementation is complete.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now is a perfect moment to give it a test drive to check whether everything
    is really OK and that I did not miss anything. The results of a concise testing
    are reflected in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Step 3 - The custom sequence factory](img/Image00024.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Testing the implemented empty sequence
  prefs: []
  type: TYPE_NORMAL
- en: 'The empty sequence is created with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then some checks are performed as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ss |> Seq.isEmpty` , as expected, returns `true`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ss |> Seq.length` , as expected, equals `0`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An attempt to skip some elements with `ss |> Seq.skip 10` fails with the expected
    diagnostics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Before we switch to the next topic, I want to reiterate this: the de-sugared
    custom sequence implementation using bare .NET interfaces is not much fun. The
    good thing about it is that in most situations, you simply do not need to descend
    to this level. Syntactically sugared language constructions and core library functions
    will do the same job. However, once in a while, you will need to do something
    special, such as counting the number of times your code traverses a sequence,
    and this technique will be at your service.'
  prefs: []
  type: TYPE_NORMAL
- en: Sequence of an indefinite length as a design pattern
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The conventional engineering vision of data transformations is that they occur
    over finite collections materialized in the memory, hence allowing these collections
    to be enumerated with `Seq.length` , yielding a number of elements. However, the
    F# sequences (as well as .NET `IEnumerable<T>` per se) grant the following generalization:
    in some cases, a more math-centric vision might be useful, which suggests looking
    at sequences as countable but not necessarily finite.'
  prefs: []
  type: TYPE_NORMAL
- en: 'A meticulous reader may immediately object that the  *countable* entity, when
    applied to practical computing, is necessarily finite because eventually, it is
    limited by underlying physical hardware, which comes out in boundary values, for
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: However, I would oppose this objection by saying that this mere consideration
    does not in any way limit the length of the F# sequences that might be produced.
    As a proof, let's implement at the low level without using any F# syntactic sugar
    the **repeater** , or sequence that when being given an element of any type returns
    the endless repetition of the given element.
  prefs: []
  type: TYPE_NORMAL
- en: 'I will begin with a plain vanilla `IEnumerator<''T>` implementation as shown
    in the following code (`Ch6_3.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet is quite straightforward. The `Repeater<'T>` type defines
    a class with which the single default constructor obtains the element to be repeated
    as `repeated` and persists it within the class instance as `_repeated` .
  prefs: []
  type: TYPE_NORMAL
- en: Then, as a fulfillment of the `System.Collections.Generic.IEnumerator<'T>` contract,
    this interface is implemented with the single property `Current` returning the
    persisted `_repeated` value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, the implementation of the nongeneric `System.Collections.IEnumerator`
    interface follows with its three contract methods. Here is the place where the
    desired sequence behavior is coined: the `Current` untyped property also returns
    a persisted `_repeated` value, but this time, it''s boxed according to the contract,
    yielding `obj` . The `MoveNext()` method, as Energizer Bunny says, should keep
    going, going, going... so that it always returns `true` , which means that the
    next element is available no matter what. The `Reset()` legacy method is just
    a stub.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, a bogus implementation of `System.IDisposable` that is required by
    the `IEnumerator<'T>` contract completes the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, for the usage convenience, I add a thin wrapper that upcasts the implemented
    interface of `Repeater<''T>` to the explicit `System.Collections.Generic.IEnumerator<''T>`
    as shown in the following code (`Ch6_3.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, a generic `makeSeq` shim function provides the conversion of any `IEnumerator<''T>`
    into the corresponding `seq<''T>` sequence by implementing both generic and nongeneric
    flavors of `IEnumerable` as shown in the following code (`Ch6_3.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `enumerator` argument provides the underlying `IEnumerator<'T>` for
    both implementations of `IEnumerable` constituting an arbitrary F# `seq` .
  prefs: []
  type: TYPE_NORMAL
- en: 'It''s time for field tests! Executing the freshly created `makeSeq` function
    with three different arguments that represent the `repeat ''.''` , `repeat 42`
    , and `repeat` `"Hooray!"` enumerators in FSI yields sequences of indefinite length
    of the corresponding types, as demonstrated in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sequence of an indefinite length as a design pattern](img/Image00025.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Generating sequences of indefinite length
  prefs: []
  type: TYPE_NORMAL
- en: 'However, how can we prove that these sequences are indeed of indefinite length?
    Ironically, only by counting elements: if for any indiscriminately big number,
    the sequence yields that many elements, then that is the proof that these sequences
    are of indefinite length. Unfortunately, this is exactly where we hit the already
    mentioned counting problem: counting might be effectively limited by the underlying
    hardware.'
  prefs: []
  type: TYPE_NORMAL
- en: But wait a minute; .NET provides a numeric type that, for all practical purposes,
    represents an arbitrarily large countable **System.Numerics.BigInteger** ([https://msdn.microsoft.com/en-us/library/system.numerics.biginteger(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.numerics.biginteger(v=vs.110).aspx)
    ). So, it would be nice to base the counting on this type.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assuming that you are not afraid of challenges, it would be a good exercise
    to implement a generic technique of counting not limited by standard `int` . For
    F#, this task is not very complicated. I would suggest the following idiomatic
    approach (`Ch6_3.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The `traverse` counting function is inlined in order to allow the compiler to
    build the compiled code aligned with the type on argument `n` picked for the counting.
    The `n` argument of `traverse` represents the amount of elements expected to be
    generated. The second `traverse` argument `s` represents a generic unlimited sequence
    generator. `makeSeq` with a given generic repetitive element makes a perfect second
    argument for `traverse` .
  prefs: []
  type: TYPE_NORMAL
- en: The sequence counting enumerator can be elegantly expressed as `Seq.zip` zipping
    together the presumably unlimited length sequence of `makeSeq` and a limited length
    sequence that has exactly the expected arbitrarily large (within boundaries that
    the underlying type allows) number of elements. As zipping stops upon reaching
    the end of the shorter sequence, the `counter` value represents exactly the desired
    enumerator obtained from the zipper expression result.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, I traverse the obtained enumerator until it stops yielding elements
    keeping track of the last traversed element. This `last` element, which is apparently
    a tuple of the last element number and the unbound sequence element, is returned
    as the evidence of arbitrary length. The following screenshot demonstrates how
    the field tests passed. The first test shows how `traverse` worked with the `BigInteger`
    counter; the second test just illustrates how to produce the sequence that is
    10 elements longer than `System.Int32.MaxValue` :'
  prefs: []
  type: TYPE_NORMAL
- en: '![Sequence of an indefinite length as a design pattern](img/Image00026.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Checking out unlimited sequence workings
  prefs: []
  type: TYPE_NORMAL
- en: Another interesting experiment would be to generate a sequence longer than `System.Int64.MaxValue`
    , which I leave to you as an exercise. My only concern is the time duration it
    may take to complete. My rough estimate shows that at the rate of 1,000,000 elements
    traversed per second, it would take no less than the next 29 centuries to complete;
    so, some serious revisions of the method and optimizations of the implementation
    may be due.
  prefs: []
  type: TYPE_NORMAL
- en: Generating the F# sequences
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As you had a chance to notice recently, generating sequences with the de-sugared
    .NET way has a fair amount of moving parts and, frankly, is not the best *one
    fits all* use case. Fortunately, F# provides enough support through syntactic
    sugar as well as library functions, making the generation of sequences of finite
    and infinite lengths a breeze. Let's take a peek at them.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence comprehensions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sequence comprehensions allow you to represent a sequence as a special kind
    of expression, namely **sequence expression** ([https://msdn.microsoft.com/en-us/library/dd233209.aspx](https://msdn.microsoft.com/en-us/library/dd233209.aspx)
    ). Or, the other way around, sequence expression, when being evaluated, yields
    a sequence.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence comprehensions may take plenty of forms. We'll be discussing some that
    are typical.
  prefs: []
  type: TYPE_NORMAL
- en: Ranges
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These are the simplest forms of comprehensions, producing sequences from ranges.
    Observe that ranges are not limited to just numeric ones; any type supporting
    the `''get_One''` operator is fine too as shown here (`Ch6_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Maps
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'These expressions generalize ranges by allowing the projection of one or more
    enumerations into something of another type. Also, note that the enumeration definition
    can be very flexible: from a simple range to nested enumerations to just another
    sequence as shown here (`Ch6_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Arbitrary sequence expressions
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'All sequence comprehensions represent the idiomatic F# syntax sugar related
    to the extremely powerful mechanism of **computation expressions** ([https://msdn.microsoft.com/en-us/library/dd233182.aspx](https://msdn.microsoft.com/en-us/library/dd233182.aspx)
    ), in particular, providing a convenient syntax for dreaded *M-word things* ,
    also known as **monads** . **Computation expressions** represent the extremely
    powerful F# pattern of sequencing and combining computations. They may be custom
    built; however, F# also offers some built-in computation expressions: along with
    **sequence expressions** , there are **asynchronous workflows** and **query expressions**
    as well. I will be covering built-in computation expressions in the upcoming chapters
    of this book.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Arbitrary sequence expressions are just computations wrapped by `seq { and
    }` tokens, although in contrast to the  **ranges** and **maps** covered earlier,
    computations can be pretty much anything. Two constructs within sequence expression
    tokens play a special role as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`yield <expression>` makes the expression value the next element of the final
    sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`yield! <sequence expression>` (reads *yield-bang* ) appends the sequence expression
    operand to the end of the final sequence'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The presence of `yield!` turns arbitrary sequence expressions into extremely
    powerful data transformations. In particular, as `seq {...}` is still an expression,
    being used as a return value of recursive functions, this pattern allows you to
    extremely succinctly and elegantly implement sequences of finite and infinite
    length, in particular, easily turn any finite sequence into an infinite circular
    one, which is often very convenient for the partitioning of other sequences through
    the element markup.
  prefs: []
  type: TYPE_NORMAL
- en: Enough words; let's look at some code!
  prefs: []
  type: TYPE_NORMAL
- en: 'I begin with a sample demonstrating how the entire pattern match construct
    can be nested into a sequence expression in order to detect when the sequence
    should halt. The following snippet produces a descending sequence of an integer
    from any non-negative number down to zero (`Ch6_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: Note how generation halting is achieved by returning `unit` instead of yielding
    the next element.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, so good. Now let''s generate just an endless sequence of alternating
    strings as shown (`Ch6_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'To wrap up the theme, look at how elegantly the circularization of any arbitrary
    sequence can be achieved as shown here (`Ch6_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Deserves two bangs that are required in the definition above to arrange the
    circularization indeed.
  prefs: []
  type: TYPE_NORMAL
- en: Library functions generating sequences
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now I turn to the support for sequence generation that the F# core libraries
    provide.
  prefs: []
  type: TYPE_NORMAL
- en: Seq.init
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This method is for sequences of predefined length as the length sits right
    in the function signature. This is quite a simple function that assumes but does
    not prescribe a projection of the current element number. Here goes a sample with
    a projection of the sequence number in a string performed in the **tacit** ([https://en.wikipedia.org/wiki/Tacit_programming](https://en.wikipedia.org/wiki/Tacit_programming)
    ) manner (`Ch6_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Seq.initInfinite
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'This function is very similar to the previous one, but it is missing the first
    argument indeed, as shown here (`Ch6_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Pretty much nothing has changed, but the underlying abstraction is more powerful
    than the finite variant. Unfortunately, the power of abstraction can be easily
    hurt by the implementation limitation that shrewd F# programmers may guess: it
    has only as many element sequence numbers as the hardware architecture allows.
    This is easy to check with the following little hack (`Ch6_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Ouch, it hurts!
  prefs: []
  type: TYPE_NORMAL
- en: Seq.unfold
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: 'The `Seq.unfold` library function, which concludes the matter of sequence generation,
    is my favorite. Instead of bothering with sequence numbers, its projection function
    unwraps the recurrent relationship between the current and the next element. It
    also demonstrates a very smart manner of addressing the halt problem by prescribing
    the projection result as `option` when returning `None` signals to stop generating
    further elements. Let''s look at this library function in action using rather
    worn down by bloggers and Academia **Fibonacci numbers** ([https://en.wikipedia.org/wiki/Fibonacci_number](https://en.wikipedia.org/wiki/Fibonacci_number)
    ) as an example shown here (`Ch6_4.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: After some years of using F#, I'm still excited what clarity of intent it allows!
    The projection function literally explains itself, so I do not have anything to
    add.
  prefs: []
  type: TYPE_NORMAL
- en: Sequence and the code performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Sequences are, without doubt, extremely powerful members of the functional
    programmer tool belt. However, they are not free of *gotchas* that may hurt the
    performance badly. It is best that they are known and avoided. A few of them are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunate materialization, which may be either unnecessary/premature elements
    materialization or the other way around, missing elements materialization.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data laziness, in concert with the non-preserving once current element values,
    can severely hurt the performance in a situation where the algorithm requires
    multiple traversals or where calculating elements is expensive. The developer
    should be able to compensate for these detrimental factors by applying patterns
    such as **caching** and/or **memoization** .
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Often, when composing data processing pipelines, the developer may carelessly
    use a library function that unexpectedly requires them to enumerate the entire
    sequence. This is not necessarily a bad thing, but it should be used sparingly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With all the aesthetic beauty of sequences of indefinite length, if misdemeanors
    mentioned in the previous bullet point just hurt the performance of finite length
    sequences, the first such negligence upon an indefinite length sequence simply
    *kills!* Beware and proceed with due caution when dealing with unlimited length
    sequences!
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sequence caching
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: F# language creators were nice enough to provide an out-of-the-box tool for
    caching, namely the `Seq.cache` library function. It should be used in a situation
    where lazy materialization is not a killer, but element generation is not cheap
    and repetitive enumerations are really required. Let me demonstrate how easy putting
    caching to work would be.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, I need an indicator of the enumerator consumption. This is not
    complicated for those who already have experience working with sequence guts.
    Let''s slightly modify our good old `makeSeq` function as following (`Ch6_5.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we are ready to see how the caching works as shown here (`Ch6_5.fsx` ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: First, in the absence of any caching, `Seq.sum` and `Seq.length` each imposed
    an independent sequence traversal, which the presence of two enumerator alerts
    confirms.
  prefs: []
  type: TYPE_NORMAL
- en: Then, after wrapping the working sequence with `Seq.cache` , I repeat the calculation
    using the wrapper sequence. As expected, we notice only a single enumerator alert
    to populate the cache; the second traversal did not leave any traces as it went
    through the cache.
  prefs: []
  type: TYPE_NORMAL
- en: To be sure, just reissue the calculation. Now, all the data come from the cache,
    and no traversals of the original sequence take place at all.
  prefs: []
  type: TYPE_NORMAL
- en: The fusion of sequence transformations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I want to wrap up this chapter by demonstrating a pattern known as **fusion**
    . It is not conceptually difficult: imagine that you have a composition of functions
    that collectively transform a data sequence. At some point, your implementation
    requires multiple traversals of the sequence. However, the compiler in principle,
    or the human in practice, may optimize the transformation, so multiple traversals
    have now fused into just the single one.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform fusion in practice, reusing our `makeSeq` implementation as
    the indicator of obtaining enumerators as shown in the following code (`Ch6_5.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The preceding naive implementation of `average` traverses the sequence twice,
    of which the enumeration alerts give the evidence.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, rewriting the implementation of `average` less naively as `averageFused`
    ends up in the fusion of these traversals as shown in the following code (`Ch6_5.fsx`
    ):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: The single enumeration alert confirms my statement completely.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covers one of the cornerstones of the F# data processing, namely
    sequences. The existing F# core sequence library allows you to apply all typical
    patterns of functional data processing.
  prefs: []
  type: TYPE_NORMAL
- en: When you feel an urge to implement just another custom function for sequence
    processing, the first thing you need to do is determine which known pattern groups
    it would belong to and then check twice whether this function is really not implemented
    already or whether it can be simply composed from the remaining library functions.
    Recollect the *Minimizing moving parts over hiding them*  section from [Chapter
    1](text00015.html#page "Chapter 1. Begin Thinking Functionally") , *Begin Thinking
    Functionally* . Core libraries are minimalistic sets of such high-quality parts,
    so sticking to them eventually positively influences the quality and readability
    of your code.
  prefs: []
  type: TYPE_NORMAL
- en: You obtained plenty of details about the inner workings of the F# sequences
    and should now be able to produce sequences by a variety of means by dealing,
    when appropriate, with conceptually clean sequences of indefinite length.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, I provided some sequence performance clues and considerations accompanied
    by some practical optimization coding, leaving you in a good position for further
    mastery.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, I will revisit the subject of functions as you should now
    be ready to pick up some advanced techniques on top of the already acquired skills.
  prefs: []
  type: TYPE_NORMAL
