<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer140">
<h1 class="chapter-number" id="_idParaDest-269"><a id="_idTextAnchor279"/>12</h1>
<h1 id="_idParaDest-270"><a id="_idTextAnchor280"/>Dealing with Brownfield Projects</h1>
<p>I cringe whenever I hear <strong class="bold">brownfield project</strong>, and probably you do too. Design decisions are already taken, code is already written by previous developers, and code quality varies between one class and another; brownfields are not for the faint-hearted. </p>
<p>As there could be multiple definitions for the term brownfield, I want to start by defining it here, so we are all on the same page. From this book’s perspective, a brownfield project is a project not covered by unit tests and was probably written a while ago. It might have been covered by other types of tests than unit tests, but we will still refer to it as a brownfield. Some techies also refer to it as a <strong class="bold">legacy project</strong>.</p>
<p>As you have already figured out, we have dedicated a whole chapter to brownfields as there are challenges in introducing TDD or unit testing to such projects. We will discuss those challenges and how to overcome them. </p>
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Analyzing the challenges</li>
<li>The strategy for enabling TDD</li>
<li>Refactoring for unit testing</li>
</ul>
<p>By the end of this chapter, you will better understand what you need to look for when enabling unit testing for your project. You will also get an insight into required code changes.</p>
<h1 id="_idParaDest-271"><a id="_idTextAnchor281"/>Technical requirements</h1>
<p>The code for this chapter can be found at the following GitHub repository: </p>
<p><a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch12">https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch12</a></p>
<h1 id="_idParaDest-272"><a id="_idTextAnchor282"/>Analyzing the challenges</h1>
<p>In the previous chapters, we’ve been talking about adding new features while starting from the unit tests end (testing first). We<a id="_idIndexMarker832"/> relied on having a new functionality or modifying an existing functionality that is already covered by existing unit tests. This is not the case for brownfields as, when trying to apply TDD, you will face some of these challenges:</p>
<ul>
<li><strong class="bold">Dependency injection support</strong>: Some<a id="_idIndexMarker833"/> legacy frameworks do not natively support DI, which is necessary for unit tests.</li>
<li><strong class="bold">Code modification challenges</strong>: Changes <a id="_idIndexMarker834"/>to code that are not covered by tests (of any type) can introduce new bugs.</li>
<li><strong class="bold">Time and effort challenges</strong>: Introducing the <a id="_idIndexMarker835"/>ability to unit test the code requires time and effort.</li>
</ul>
<p>Let’s go through each challenge in detail, so you can consider them when the time comes.</p>
<h2 id="_idParaDest-273"><a id="_idTextAnchor283"/>Dependency injection support</h2>
<p>In this book, before learning about unit testing or TDD, we had to introduce DI. DI is what allows you to separate <a id="_idIndexMarker836"/>your code into units/components; it is <a id="_idIndexMarker837"/>a natural requirement for unit testing. There are two challenges in enabling DI – framework support and refactoring work. Let’s dig deeper.</p>
<h3>Framework support for DI</h3>
<p>This is a .NET book, so we are only<a id="_idIndexMarker838"/> interested in legacy .NET frameworks that do not support DI natively. In the early 2000s, while unit testing was becoming a trend, Microsoft was more interested in migrating developers<a id="_idIndexMarker839"/> from <strong class="bold">Visual Basic 6</strong> (<strong class="bold">VB6</strong>) and <strong class="bold">Active Server Pages</strong> (<strong class="bold">ASP</strong>), thus enabling native <a id="_idIndexMarker840"/>DI in the early days of .NET was not on the priority list. </p>
<p>Therefore, Win Forms and ASP.NET Web Forms were born with no native DI support. Surely, you can hack the framework and add some support for DI. Still, when you start shifting from the norms of a framework, you alienate other developers working on the code base and introduce subtle bugs and complexity to the design.</p>
<p>More modern frameworks, such as WPF, and ASP.NET MVC from the classical .NET Framework allowed dependency injection through third-party DI containers. Today, with ASP.NET Core, DI is natively supported using Microsoft-built DI containers.</p>
<p>If you have a project that is built on a legacy framework with no native support for DI, such as Win Forms and ASP.NET Web Forms, I would say the effort put into bending these frameworks to enable unit testing needs to be weighed against the benefits of having unit tests. Maybe you<a id="_idIndexMarker841"/> can invest this effort in applying other types of testing to the project instead. Obviously, migrating the project into a modern framework solves this problem, but that has its own challenges as well.</p>
<p>If the framework supports DI natively or can support DI with little effort, then you are in luck, but is that all? Clearly, now you have to refactor everything to enable DI.</p>
<h3>Refactoring for DI support</h3>
<p>We dedicated <a href="B18370_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a><em class="italic">, Understanding Dependency Injection by Example,</em> to discussing DI, so we<a id="_idIndexMarker842"/> will not go into details here. What we need to do when we plan to introduce unit tests or TDD is to make sure we are using DI to inject components.</p>
<p>Ideally, all your components need to be injected through constructor injection, and instantiating a variable should not be done in the method or property code. With that said, consider the following unwelcome code:</p>
<pre class="source-code">MyComponent component = <strong class="bold">new</strong> MyComponent();</pre>
<p>When you have code that is not unit tested, you’ll probably find that all the components are instantiated in the code, and no DI container is used. In this case, you will have to go through the cases of direct instantiation and modify them to support DI. We will see an example of this at the end of this chapter.</p>
<p>Not all cases of direct instantiation will require you to refactor them for DI. Some cases are part of a standard library that you could unit test, but you shouldn’t. Take this line as an example:</p>
<pre class="source-code">var uriBuilder = new UriBuilder(url);</pre>
<p>In this example, we had no intention of injecting the <strong class="source-inline">UriBuilder</strong> class, so you might not need to change the code because the class is not relying on an external dependency. Accordingly, injecting the class is not beneficial, but actually, it adds a bit of unnecessary effort.</p>
<p>In brief, to make the <a id="_idIndexMarker843"/>code unit testable, all the components need to be DI-ready. Depending on how big your project is and the way you want to implement it (such as iteratively), it will take time and effort.</p>
<p>Introducing DI is not the only challenge; modifying the code will pose a new challenge as well.</p>
<h2 id="_idParaDest-274"><a id="_idTextAnchor284"/>Code modification challenges</h2>
<p>When you are adding non-unit tests to your project, you are working externally to the code and some of the <a id="_idIndexMarker844"/>activities can be as follows:</p>
<ul>
<li>Testing the UI with an automation tool such as Selenium or Cypress. The tests will deal with the application like an external user.</li>
<li>Doing integration testing by performing an end-to-end call, say on an API endpoint.</li>
<li>Load testing a project by creating multiple instances of the application.</li>
<li>Penetration testing by trying to hack into the application externally.</li>
</ul>
<p>All these activities do not require changing the code, but unit testing requires the production code to be in a certain shape.</p>
<p>When changing the code to enable unit testing, we risk breaking it. Imagine having a bug that found its way to production and the irony of the business hearing <em class="italic">it broke because we added tests</em>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">I would be lying if I said that you have to change the code for unit testing because you can use an isolation testing framework, which would allow you to unit test the code without changing it. However, this would be the last resort if you really want to unit test and you cannot change the code. We’ll discuss this further later in this chapter.</p>
<p>There are solutions to change the code that will reduce the possibility of breaking, so follow along.</p>
<h2 id="_idParaDest-275"><a id="_idTextAnchor285"/>Time and effort challenges</h2>
<p>The process of enabling dependency injection and refactoring the code into components that act as units is mentally challenging and time-consuming.</p>
<p>Think of approaching the <a id="_idIndexMarker845"/>process iteratively by dividing it into your sprints (or iterations, or whatever you call them) or by blocking some iterations and implementing your changes.</p>
<p>The challenge here is to justify to the business the time spent in introducing unit testing and enabling TDD, as from their perspective, you still have the same product, the same number of bugs, and nothing is fixed, but you have just added tests. Obviously, you and I know that unit testing will guard the code against future bugs and add documentation, but the challenge is to convey this to the business. The next chapter is going to tackle dealing with the business when introducing TDD and unit testing, so I will stop here.</p>
<p>All these challenges have solutions; after all, we work in software! The next sections will address them with different strategies.</p>
<h1 id="_idParaDest-276"><a id="_idTextAnchor286"/>The strategy of enabling TDD</h1>
<p>Now is the time to discuss solutions to the <a id="_idIndexMarker846"/>challenges described in the previous section. Since <em class="italic">a picture is worth a thousand words</em>, I will present a workflow diagram that should clarify how to introduce unit testing into a brownfield project:</p>
<div>
<div class="IMG---Figure" id="_idContainer138">
<img alt="Figure 12.1 – The workflow of enabling TDD in a project " height="1124" src="image/Figure_12.1_B18370.jpg" width="1183"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.1 – The workflow of enabling TDD in a project</p>
<p>Let’s go through the <a id="_idIndexMarker847"/>diagram and our options.</p>
<h2 id="_idParaDest-277"><a id="_idTextAnchor287"/>Consider rewriting</h2>
<p>You might consider rewriting <a id="_idIndexMarker848"/>because the existing project might be based on an old framework with fewer developers and less support. However, the rewriting idea is controversial. If you tell the business that the project requires rewriting, you will be their least favorite individual. Trust me; nobody wants to hear this. However, good rewriting doesn’t need to be a big bang; it can be divided into smaller chunks of upgrades and can be appended to sprints. Obviously, choosing a modern framework that supports DI natively or through a third party is out of the question.</p>
<p>There are many ways to rewrite <a id="_idIndexMarker849"/>software, which are beyond the scope of this book. But if you are rewriting, you can start the new pieces with TDD, and the problem would be sorted!</p>
<h2 id="_idParaDest-278"><a id="_idTextAnchor288"/>Changing code</h2>
<p>In some settings, the code is too<a id="_idIndexMarker850"/> tangled to be changed, or sometimes the business doesn’t like the idea of changing the code for whatever reason. If you are facing one of these situations, then ask yourself whether it is worth adding unit tests or whether this effort should be put into other types of testing. Obviously, other types of tests will do good, although unit testing would even be more beneficial.</p>
<p>Unit testing can be done without DI; hence, you don’t need to change the code. Here you go, I let the secret out! But for <a id="_idIndexMarker851"/>this to work, you will have to use a <strong class="bold">test isolation framework</strong>. A test isolation framework makes some changes to the way components are loaded externally without touching the code.</p>
<p>For example, consider this class:</p>
<pre class="source-code">public class Warehouse 
{ 
    public Dictionary&lt;string, int&gt; Products { get; } 
    …
}</pre>
<p>Notice that the class does not implement an interface, and the <strong class="source-inline">Products</strong> property is not virtual. Let’s see<a id="_idIndexMarker852"/> how the <strong class="bold">JustMock</strong> <strong class="bold">test isolation framework</strong> by Telerik would unit test code related to this class:</p>
<pre class="source-code">[Fact]
public void Complete_SampleInventory_IsCompleted() 
{
    // Arrange
    var order = new Order("trouser", 1); 
    <strong class="bold">var warehouse = new Warehouse(); </strong>
    <strong class="bold">Mock.Arrange(() =&gt; warehouse.Products)</strong>
<strong class="bold">      </strong>.Returns(<strong class="bold">new Dictionary&lt;string, int&gt;() { </strong>
<strong class="bold">        { "shirt", 12}, </strong>
<strong class="bold">        { "trouser", 5}</strong>
<strong class="bold">    }</strong>); 
 
    // Act
    order.Complete(warehouse); 
 
    // Assert
    Assert.True(order.IsCompleted); 
}</pre>
<p>In this code block, we only care about the two highlighted lines. <strong class="bold">JustMock</strong> was able to mock the <strong class="source-inline">Products</strong> property on the <strong class="source-inline">Warehouse</strong> class, although the property is not virtual and the <strong class="source-inline">warehouse</strong> object is not instantiated with the help of the mock library.</p>
<p>JustMock did some magic here, it made the <strong class="source-inline">Warehouse</strong> class mockable, despite that <strong class="source-inline">Warehouse</strong> doesn’t have an interface and <strong class="source-inline">Products</strong> is not virtual. No DI was required!</p>
<p>However, the isolation <a id="_idIndexMarker853"/>framework’s magic is not liked by most TDD practitioners, as it leads to bad programming practices. Plus, these frameworks are not free. They definitely solve a problem when you want to avoid code changes, but they pose the question, is it worth the effort and the cost?</p>
<p>Going through the hassle of having a dependency on a non-standard way of testing will require training, maintenance, and licensing costs, which should be weighed against utilizing any framework. </p>
<h2 id="_idParaDest-279"><a id="_idTextAnchor289"/>Native support for DI</h2>
<p>Some frameworks within .NET have no notion of DI – Win Forms and Web Forms are perfect examples. You can<a id="_idIndexMarker854"/> force them to support DI, but this means bending the framework and being on your own. Sometimes, you can try to isolate the UI layer and unit test what is underneath it. That is good enough in this case.</p>
<p>What I want to say is having a framework that doesn’t natively support plugging in a DI container or has one that is built in, such as ASP.NET Core, will cost you more effort and will shift you away from the norm.</p>
<p>I would avoid unit testing such frameworks and promote the quality by employing other testing categories.</p>
<h2 id="_idParaDest-280"><a id="_idTextAnchor290"/>Test coverage prior to unit test</h2>
<p>Code changes will lead to bugs, but<a id="_idIndexMarker855"/> what about careful code changes? Well, yes, it will still lead to bugs! Bugs will come when you change code, no matter how careful you are. So, what is your bug hunting plan?</p>
<p>If you plan to change the code for unit testing, your code should have high coverage at first by other types of tests, mainly automation and integration. These tests will help to point out where you’ve broken the code before it gets to production.</p>
<p>The logical question coming up is, if I have high coverage with other types of tests, why do I need unit tests? The answers are as follows:</p>
<ul>
<li>If your project is still in development, then you will need unit tests. Also, preferably add new features in TDD style.</li>
<li>You can change the balance of all the available tests to unit tests once your project can support them, as unit tests have advantages over other tests that we’ve discussed earlier in this book, in <a href="B18370_04.xhtml#_idTextAnchor097"><em class="italic">Chapter 4</em></a>, <em class="italic">Real Unit Testing with Test Doubles</em>.</li>
</ul>
<p>If your code is in maintenance mode and the coverage is already high, then I would argue that adding unit tests is not very useful. In this case, TDD would not be applicable as TDD is a companion of new features or features change.</p>
<p>My advice is not to change the code if it is not covered by tests, as your valuable effort in advancing the project might be countered by production bugs. Maybe the effort should be put into other tests or rewriting.</p>
<p>Every project is different and the strategies we have mentioned here are just points to consider. You should <a id="_idIndexMarker856"/>consider adding these to your train of thought when you plan the introduction of unit tests into a brownfield.</p>
<p>Next, we will see samples of changing legacy code to allow unit testing.  </p>
<h1 id="_idParaDest-281"><a id="_idTextAnchor291"/>Refactoring for unit testing</h1>
<p>When you write in TDD, your<a id="_idIndexMarker857"/> code is unit testable from the first moment. This is because you took into consideration DI scenarios. Brownfield code almost always has no consideration for DI, and it will have to change to accommodate it.</p>
<p>In this section, we will cover the scenarios that you have to change, and then we will go through an example of a sample refactoring at the end of this section.</p>
<h2 id="_idParaDest-282"><a id="_idTextAnchor292"/>Variables instantiated in the code</h2>
<p>Whenever you see a <strong class="source-inline">new</strong> keyword in the <a id="_idIndexMarker858"/>code that is instantiating a library or a service, then most probably, this needs refactoring. Take the following example of code in a method:</p>
<pre class="source-code">var obj = <strong class="bold">new</strong> Foo();
obj.DoBar();</pre>
<p>The previous line means we cannot inject a test double for <strong class="source-inline">Foo</strong>, so the code needs to change to inject it.</p>
<p>The next thing to do is to check whether <strong class="source-inline">Foo</strong> implements an interface for the methods you are using from this class. Let me break the bad news for you here – keep your expectations low; you most probably won’t find that the class implements an interface for the methods you are using unless you are consuming a well-designed and sophisticated framework.</p>
<p>In the next few sections, we will go through the process of making the code testable.</p>
<h3>Creating an interface for your own class</h3>
<p>If you own the code in <strong class="source-inline">Foo</strong> and you can <a id="_idIndexMarker859"/>change it, great! Your code can change from:</p>
<pre class="source-code">class Foo
{
    public void DoBar();
}</pre>
<p>To this class and an additional interface, <strong class="source-inline">IFoo</strong>:</p>
<pre class="source-code">interface IFoo
{
    void DoBar();
}
class Foo : IFoo
{
    public void DoBar();
}</pre>
<p>This is easy. But what if the source code of this class is not accessible to you, or you are not allowed to change the source code?</p>
<h3>Creating an interface for a third-party class</h3>
<p>Adding an interface for a class you do<a id="_idIndexMarker860"/> not own is not possible. You <a id="_idIndexMarker861"/>have to go through another pattern, usually referred to as a wrapper class. You will need to create a new class and interface, as such:</p>
<pre class="source-code">interface IFooWrapper
{
    void DoBar();
}
class FooWrapper : IFooWrapper
{
    private Foo _foo = new();
    public void DoBar() =&gt; _foo.DoBar();
}</pre>
<p>You can see that we have wrapped the <strong class="source-inline">Foo</strong> class with another class to intercept the calls to the <strong class="source-inline">DoBar</strong> method. This would allow us to add an interface in the same way we can add an interface to a class <a id="_idIndexMarker862"/>we own.</p>
<p>There is a bit of extra work here, but you will get used to it, and it will become straightforward after a couple of class changes.</p>
<p>Now that we have an interface for our class, we can go to the second step, DI.</p>
<h3>Injecting your components</h3>
<p>How you do dependency injection<a id="_idIndexMarker863"/> depends on the library you are using (ASP.NET Core, Win Forms, among others) and the way you’ve wired up your DI container. Let’s take an ASP.NET Core WebAPI project. To wire up your newly created or updated class, write code similar to the following in <strong class="source-inline">Program.cs</strong>:</p>
<pre class="source-code">builder.Services.AddScoped&lt;IFoo, Foo&gt;();</pre>
<p>Or the following code:</p>
<pre class="source-code">builder.Services.AddScoped&lt;IFooWrapper, FooWrapper&gt;();</pre>
<p>Obviously, the lifespan scope (transient, scoped, or singleton) will change based on the <strong class="source-inline">Foo</strong> class.</p>
<p>Once you’ve done the modification, you can refactor your controller to inject <strong class="source-inline">FooWrapper</strong>:</p>
<pre class="source-code">public class MyService
{
    private readonly IFooWrapper _foo;
    public MyService(IFooWrapper foo)
    {
        _foo = foo;
    }
    public void BarIt()
    {
        _foo.DoBar();
    }
}</pre>
<p>We introduced a <strong class="source-inline">wrapper</strong> class and an interface so we can follow along with a familiar DI pattern, so the previous code became possible.</p>
<p>Now, you can go ahead <a id="_idIndexMarker864"/>and implement whatever unit testing you want to put in place, as you can inject a test double for <strong class="source-inline">FooWrapper</strong> at test time.</p>
<p>The instantiation scenario is sorted. Let’s explore another refactoring pattern.</p>
<h2 id="_idParaDest-283"><a id="_idTextAnchor293"/>Static members replacement</h2>
<p>Static methods, which include <a id="_idIndexMarker865"/>extension methods, are simple, occupy fewer coding lines, and produce beautiful code. However, they are evil when it comes to dependency injection; as per the explanation in <a href="B18370_02.xhtml#_idTextAnchor037"><em class="italic">Chapter 2</em></a>, <em class="italic">Understanding Dependency Injection by Example</em>, static <a id="_idIndexMarker866"/>methods are not unit test friendly.</p>
<p><strong class="source-inline">Date.Now</strong> looks innocent, and <strong class="source-inline">Now</strong> is a read-only static property. If you want your unit test to freeze the time, for example, say you want to test what happens on February 29 (leap year), you can’t do that. The solution to this one is a wrapper, as discussed earlier. This is what you can do to make <strong class="source-inline">Now</strong> an instance method rather than a static method:</p>
<pre class="source-code">public interface IDateTimeWrapper
{
    DateTime Now { get; }
}
public class DateTimeWrapper : IDateTimeWrapper
{
    public DateTime Now =&gt; DateTime.Now;
}</pre>
<p>We’ve done exactly what we’ve done earlier where we did not have control over the class (few sections back). We <a id="_idIndexMarker867"/>enabled DI support by introducing the wrapper pattern to the <strong class="source-inline">DateTime</strong> class. Now, you can inject <strong class="source-inline">DateTimeWrapper</strong> at runtime and use a test double for unit testing.</p>
<p>If you have control over the class, you might want to change the static member to an instance one (non-static) or introduce an additional instance member and keep the static member: </p>
<pre class="source-code">Interface IFoo
{
    string PropWrapper { get; }
}
class Foo : IFoo
{
    public static string Prop =&gt; …
    <strong class="bold">public string PropWrapper =&gt; Foo.Prop;</strong>
}</pre>
<p>This is a way to expose your static property as an instance property. You will also have to use the <strong class="source-inline">PropWrapper</strong> wrapper property instead of the non-wrapped one, <strong class="source-inline">Prop</strong>, in the rest of your code. In the previous example, we added an additional property, but you could also refactor the code to replace the static property if it makes sense.</p>
<h3>Changing the consumer to rely on an instance member</h3>
<p>The code consuming the previous <strong class="source-inline">Foo</strong> class might look like this:</p>
<pre class="source-code">public class Consumer 
{
    public void Bar()
    {
        …
        var baz = Foo.Prop;
        …
    }
}</pre>
<p>After refactoring <strong class="source-inline">Foo</strong> as per the<a id="_idIndexMarker868"/> previous section, the implementation here can change into a unit-testable format, as follows:</p>
<pre class="source-code">public class Consumer 
{
    private readonly IFoo _foo;
    public Consumer(IFoo foo)
    {
        _foo = foo;
    }
    public void Bar()
    {
        …
        var baz = _foo.PropWrapper;
        …
    }
}</pre>
<p>You can see that we have injected <strong class="source-inline">IFoo</strong> into the <strong class="source-inline">Consumer</strong> class and we have used another property, <strong class="source-inline">PropWrapper</strong>.</p>
<p>Instantiated classes and static member calls can be easily spotted. However, the most notable thing about legacy code is <a id="_idIndexMarker869"/>that it doesn’t have a structure, and a component cannot be easily noticed and tested. So for this, we will have to make more changes.</p>
<h2 id="_idParaDest-284"><a id="_idTextAnchor294"/>Changing code structure</h2>
<p>The code in the brownfield<a id="_idIndexMarker870"/> project might be in a format that isn’t unit testable. One popular structure is the controller’s action method with <a id="_idIndexMarker871"/>all the code written inside it:</p>
<pre class="source-code">public void Post()
{
    // plenty of code lines
}</pre>
<p>Here, we need to get the code into a unit-testable structure. I would choose an architecture such as DDD, as per <em class="italic">Part 2</em> of this book, where we’ve used services and domain objects. </p>
<p>The previous sample code works fine, but it is not unit testable. You can find the full listing in the <strong class="source-inline">WeatherForecasterBefore</strong> directory of this chapter in the <strong class="source-inline">WeatherForecastController.cs</strong> GitHub file:</p>
<pre class="source-code">public class WeatherForecastController : ControllerBase
{
    public async Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt;
    GetReal([FromQuery]decimal lat, [FromQuery]decimal lon)
    {
        var res = (await OneCallAsync(lat, lon)).ToArray();
        …
        for (int i = 0; i &lt; wfs.Length; i++)
        {
            …
            wf.Summary = MapFeelToTemp(wf.TemperatureC);
        }
        return wfs;
    }
    <strong class="bold">private static async</strong>
        <strong class="bold">Task&lt;IEnumerable&lt;(DateTime,decimal)&gt;&gt; OneCallAsync</strong>(
        decimal latitude, decimal longitude)
    {
        var uriBuilder = new UriBuilder(
        "https://api.openweathermap.org/data/2.5/onecall");
        …
        <strong class="bold">var httpClient = new HttpClient();</strong>
    }
    private static string MapFeelToTemp(int temperatureC)
    {
        …
    }
}</pre>
<p>Clearly, most of the code is<a id="_idIndexMarker872"/> omitted for brevity. The code will call a third-party service called Open Weather, and get the<a id="_idIndexMarker873"/> forecast for the next 5 days for a certain geographical coordinate. It will then analyze the temperature and produce a word that describes the temperature feel, such as <em class="italic">Freezing</em> or <em class="italic">Balmy</em>.</p>
<p>The previous code also instantiates a <strong class="source-inline">HttpClient</strong> instance, which means there is no easy way of avoiding calling<a id="_idIndexMarker874"/> the third party whenever we try to unit test this.</p>
<p>Next, we shall invest some thoughts into changing this code into testable components.</p>
<h3>Analyzing code change for a testable format</h3>
<p>The code that we’ve just seen <a id="_idIndexMarker875"/>can be made into components in several ways, and there is no one way to do it. This code does two things, so we can think of two components that will encompass all the code functionality:</p>
<ul>
<li>Calling Open Weather and obtaining a forecast </li>
<li>Obtaining the forecast and analyzing it</li>
</ul>
<p>The idea here is to have the controller with no business logic and if there is no business logic, then we will not need to unit test the controller. The controller, in general, should have no business logic, and it should do a single<a id="_idIndexMarker876"/> job – deliver <strong class="bold">data transfer objects </strong>(<strong class="bold">DTOs</strong>) to views (as of Model-View-Controller views).</p>
<p>We will give the following names to our components:</p>
<ul>
<li><strong class="source-inline">OpenWeatherService</strong></li>
<li><strong class="source-inline">WeatherAnalysisService</strong></li>
</ul>
<p>The whole call to obtain the forecast and the temperature feeling analysis would look like this:</p>
<div>
<div class="IMG---Figure" id="_idContainer139">
<img alt="Figure 12.2 – Workflow by components " height="259" src="image/Figure_12.2_B18370.jpg" width="1206"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 12.2 – Workflow by components</p>
<p>The client will call the APIs to obtain the forecast with the feeling. The weather forecast controller will receive the call and pass it to the weather analysis service, which loads the Open Weather service and calls<a id="_idIndexMarker877"/> an external dependency to obtain the weather.</p>
<p>Next, we will see what the code looks like after our refactoring. </p>
<h3>The final testable code</h3>
<p>There are levels of refactoring invasiveness <a id="_idIndexMarker878"/>when you want to enable unit testing. I chose an aggressive level, but you might choose to refactor less code.</p>
<p>You can see the whole refactored code in the <strong class="bold">WeatherForecasterAfter</strong> directory.</p>
<p>Now the controller looks like this:</p>
<pre class="source-code">public class WeatherForecastController : ControllerBase
{
    private readonly IWeatherAnalysisService 
        _weatherAnalysisService;
    public WeatherForecastController(
        IWeatherAnalysisService weatherAnalysisService)
    {
        _weatherAnalysisService = weatherAnalysisService;
    }
    [HttpGet]
    public async Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; 
        GetReal(
       [FromQuery]decimal? lat, [FromQuery]decimal? lon)
    {
        if (lat is null || lon is null)
        {
            return await _weatherAnalysisService
               .GetForecastWeatherAnalysis();
        }
        return await _weatherAnalysisService
         .GetForecastWeatherAnalysis(lat.Value, lon.Value);
    }
}</pre>
<p>The controller is almost<a id="_idIndexMarker879"/> empty, compared to how it was before. The action method in the controller is mapping the API call to the right service.</p>
<p>This is the <strong class="source-inline">OpenWeatherService</strong> class:</p>
<pre class="source-code">public class WeatherAnalysisService : 
    IWeatherAnalysisService
{
    …
    private readonly IopenWeatherService
        _openWeatherService;
    public WeatherAnalysisService(
        IOpenWeatherService openWeatherService)
    {
        _openWeatherService = openWeatherService;
    }
    public async Task&lt;IEnumerable&lt;WeatherForecast&gt;&gt; 
       GetForecastWeatherAnalysis(decimal lat, decimal lon)
    {
        OneCallResponse res = await 
            _openWeatherService.OneCallAsync(…)
        …
    }
    private static string MapFeelToTemp(int temperatureC)
    {
        …
    }
}</pre>
<p>The class contains the logic of mapping the feeling to the temperature and calling <strong class="source-inline">OpenWeatherService</strong>. The service<a id="_idIndexMarker880"/> doesn’t know how the Open Weather APIs are called.</p>
<p>Finally, let’s look at <strong class="source-inline">OpenWeatherService</strong>:</p>
<pre class="source-code">public class OpenWeatherService : IOpenWeatherService
{
    …
    public OpenWeatherService(string apiKey, 
        HttpClient httpClient)
    {
        _apiKey = apiKey;
        _httpClient = httpClient;
    }
    public async Task&lt;OneCallResponse&gt; OneCallAsync(
        decimal latitude, decimal longitude, 
        IEnumerable&lt;Excludes&gt; excludes, Units unit)
    {
        …
    }
}</pre>
<p>The job of this service is to wrap the HTTP call to the internet Open Weather APIs with code.</p>
<p>The full unit tests for the newly added services can be found in the source code directory with the rest of the services.</p>
<p>Remember that we are<a id="_idIndexMarker881"/> doing the refactoring while assuming the code has undergone other types of testing. Aggressively refactoring code is time-consuming, especially for the first set of refactors, but remember that refactoring is also paying back part of the technical debt of the project. The code is now documented by the unit test as well, so this is a step forward.</p>
<h1 id="_idParaDest-285"><a id="_idTextAnchor295"/>Summary</h1>
<p>In this chapter, we discussed the implications of enabling unit testing for a brownfield project. We’ve gone through the considerations to allow you to decide whether it is worth it and all the things that you have to watch for while progressing with the process.</p>
<p>As a developer, you will encounter brownfield projects that went up in value and would benefit from unit tests and TDD. Hopefully, this chapter equipped you with the required knowledge to tackle them.</p>
<p>Deciding to introduce TDD into your organization is not a straightforward process. The next chapter will go through the process and prepare you for some scenarios that you would face.</p>
<h1 id="_idParaDest-286"><a id="_idTextAnchor296"/>Further reading </h1>
<p>To learn more about the topics discussed in the chapter, you can refer to the following links: </p>
<ul>
<li><em class="italic">JustMock (Isolation Framework from Telerik)</em>: <a href="https://docs.telerik.com/devtools/justmock%0D">https://docs.telerik.com/devtools/justmock</a></li>
<li><em class="italic">Microsoft Fakes (Isolation Framework that comes with VS Enterprise)</em>: <a href="https://docs.microsoft.com/en-us/visualstudio/test/isolating-code-under-test-with-microsoft-fakes%0D">https://docs.microsoft.com/en-us/visualstudio/test/isolating-code-under-test-with-microsoft-fakes</a></li>
<li><em class="italic">TypeMock (Isolation Framework for classical .NET Framework)</em>: <a href="https://www.typemock.com">https://www.typemock.com</a></li>
</ul>
</div>
</div>
</body></html>