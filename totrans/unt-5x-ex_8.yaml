- en: Chapter 8. Continuing with Intelligent Enemies
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第8章。继续智能敌人
- en: 'This last chapter continues with the previous one and completes the AI project
    by focusing on the theory and related coding underpinning an intelligent enemy.
    The enemy will demonstrate three main behaviors: patrolling, chasing, and attacking.
    In this chapter, we will dive into the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一章继续上一章的内容，通过关注智能敌人的理论和相关编码来完善AI项目。敌人将展示三种主要行为：巡逻、追逐和攻击。在本章中，我们将深入以下主题：
- en: How to plan and code an AI system for enemy characters
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何规划和编码敌方角色的AI系统
- en: How to code Finite State Machines (FSMs)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何编码有限状态机（FSM）
- en: How to create the line-of-sight functionality
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何创建视线功能
- en: Note
  id: totrans-5
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The starting project and assets can be found in the book companion files in
    the `Chapter08/Start` folder. You can start here and follow along with this chapter
    if you don't have your own project already.
  id: totrans-6
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 起始项目和资源可以在本书配套文件中的 `Chapter08/Start` 文件夹中找到。如果您还没有自己的项目，可以从这里开始，并跟随本章内容进行学习。
- en: Enemy AI – range of sight
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 敌方AI – 视野范围
- en: Let's now start developing enemy AI by thinking about our functional requirements.
    The enemies in the scene will begin in patrol mode, wandering the level from place
    to place searching for the player character. If the player is spotted, the enemy
    will change from patrolling and begin chasing the player, attempting to move closer
    to them for an attack. If the enemy reaches within attacking range of the player,
    the enemy will change from chasing to attacking. If the player outruns the enemy
    and successfully loses them, the enemy should stop chasing and return to patrolling
    again, searching for the player as they were doing initially. This, in sum, describes
    our needed enemy AI behavior.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在通过思考我们的功能需求来开始开发敌方AI。场景中的敌人将开始巡逻模式，在关卡中四处游荡，寻找玩家角色。如果发现玩家，敌人将改变巡逻状态，开始追逐玩家，试图靠近他们进行攻击。如果敌人到达玩家的攻击范围内，敌人将改变追逐状态，转为攻击状态。如果玩家跑得比敌人快并成功摆脱他们，敌人应该停止追逐并再次回到巡逻状态，像最初一样寻找玩家。总的来说，这描述了我们需要的敌方AI行为。
- en: To achieve this behavior, we'll need to code the line of sight functionality
    for the enemy. The enemy relies on being able to see the player character or determining
    whether the player is visible to the enemy at any one moment. This helps the enemy
    decide whether they should patrol or chase the player character. To code this,
    refer to the following code from the source file, `LineSight.cs`. This script
    file should be attached to the enemy character created so far from the previous
    chapter.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 为了实现这种行为，我们需要为敌人编码视线功能。敌人依赖于能够看到玩家角色或确定玩家在任何时刻是否对敌人可见。这有助于敌人决定他们是否应该巡逻或追逐玩家角色。为了编码这个功能，请参考以下来自源文件
    `LineSight.cs` 的代码。这个脚本文件应该附加到上一章创建的敌方角色上。
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Code Sample 8.1
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 8.1
- en: 'The following points summarize the code sample:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `LineSight` class should be attached to any enemy character object. Its
    purpose is to calculate whether a direct line of sight is available between the
    player and enemy.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LineSight` 类应该附加到任何敌方角色对象上。它的目的是计算玩家和敌人之间是否存在直接的视线。'
- en: The `CanSeeTarget` variable is a Boolean (`True`/`False`), which is updated
    on a per frame basis to describe whether the enemy can see the player *right now*
    (for this frame). `True` means that the player is in sight of the enemy, and `false`
    means that the player is not visible.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CanSeeTarget` 变量是一个布尔值（`True`/`False`），它每帧更新一次，以描述敌人是否现在（对于这一帧）可以看到玩家。`True`
    表示玩家在敌人的视线中，而 `false` 表示玩家不可见。'
- en: The `FieldOfView` variable is a floating point value that determines an angular
    margin on either side of the enemy eye-point, inside which objects (like the player)
    can be seen. The higher this value, the more chance the enemy has of seeing the
    player.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FieldOfView` 变量是一个浮点值，它决定了敌人眼睛点两侧的角边距，在这个范围内可以看见对象（如玩家）。这个值越高，敌人看到玩家的机会就越大。'
- en: The `InFOV` function returns `true` or `false` to indicate whether the player
    is within the enemy field of view. This ignores whether the player is occluded
    behind a wall or solid object (like a pillar). It simply takes the position of
    the enemy eyes, determines a vector to the player, and measures the angle between
    the forward vector and player. It compares this to the field of view, and returns
    `true` if the angle between enemy and player is less than the `FieldOfView` variable.
    In short, this function can tell you whether the enemy would see the player if
    there were a clear line of sight.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InFOV` 函数返回 `true` 或 `false`，以指示玩家是否在敌人的视野范围内。这忽略了玩家是否被墙壁或固体物体（如柱子）遮挡。它只是取敌人眼睛的位置，确定指向玩家的向量，并测量前向向量与玩家之间的角度。它将这个角度与视野进行比较，如果敌人与玩家之间的角度小于
    `FieldOfView` 变量，则返回 `true`。简而言之，这个函数可以告诉你如果视线清晰，敌人是否能看到玩家。'
- en: The `ClearLineOfSight` function returns `true` or `false` to indicate whether
    there are any physical obstacles (Colliders), such as walls or props, between
    the enemy eye point and player. This does not consider whether the player is within
    the enemy field of view. This function, in combination with the `InFOV` function,
    can determine whether the enemy has a clear line of sight to the player and is
    within the field of view, and thus, whether the player is visible.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ClearLineOfSight` 函数返回 `true` 或 `false`，以指示敌人眼睛点和玩家之间是否存在任何物理障碍（碰撞器），如墙壁或道具。这不考虑玩家是否在敌人的视野范围内。这个函数与
    `InFOV` 函数结合使用，可以确定敌人是否对玩家有清晰的视线并且在其视野范围内，从而确定玩家是否可见。'
- en: The `OnTriggerStay` and `OnTriggerExit` functions are called when the player
    is within a trigger volume surrounding the enemy and when the player leaves this
    volume respectively. As we'll see, a sphere collider can be attached to the enemy
    character object to represent its horizon of view. This means the total distance,
    or radius, inside which the enemy could see the player, provided they were within
    the field of view and a clear line of sight existed.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当玩家位于围绕敌人的触发体积内时，会调用 `OnTriggerStay` 和 `OnTriggerExit` 函数，而当玩家离开这个体积时也会调用。正如我们将看到的，可以将球体碰撞器附加到敌人角色对象上，以表示其视野范围。这意味着敌人可以看到玩家的总距离，或半径，前提是他们位于视野范围内并且存在清晰的视线。
- en: Now, attach the `LineSight.cs` script file to the enemy character in the scene
    as well as a Sphere Collider component (marked as a Trigger) to approximate the
    viewing horizon of the enemy. See *Figure 8.1*. Leave the **Field of View** setting
    at `45`, although this can be increased, if needed, to around `90` to tweak the
    effectiveness of the enemy viewing range.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将 `LineSight.cs` 脚本文件附加到场景中的敌人角色上，以及一个球体碰撞器组件（标记为触发器），以近似敌人的观察视野。参见 *图 8.1*。将
    **Field of View** 设置保留在 `45`，尽管如果需要，可以增加到大约 `90` 以调整敌人观察范围的有效性。
- en: '![Code Sample 8.1](img/B05118_08_01.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 8.1](img/B05118_08_01.jpg)'
- en: 'Figure 8.1: Adding a horizon to the NPC'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.1：为 NPC 添加视野
- en: The **Eye Point** field is, by default, set to **None**, which represents a
    null value. This should refer to a specific location on the enemy character that
    acts as the eye point—the place from which the character can see. To create this
    point, add a new and empty game object to the scene using the application menu,
    **GameObject** | **Create Empty**. Name the object `Eye Point`, activate its visibility
    from the **Inspector** using a Gizmo icon (so that it can be visible even when
    deselected), and then add it as a child object to the enemy. Afterward, position
    the object to the character eye point, making sure that the forward vector is
    facing in the same direction. See *Figure 8.2:*
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，**Eye Point** 字段设置为 **None**，表示空值。这应该指的是敌人角色上的一个特定位置，该位置充当眼睛点——角色可以从中看到的地方。要创建这个点，使用应用程序菜单中的
    **GameObject** | **Create Empty** 添加一个新的空游戏对象到场景中。将对象命名为 `Eye Point`，通过 Gizmo
    图标从 **Inspector** 中激活其可见性（即使未选中也能可见），然后将它作为子对象添加到敌人上。之后，将对象定位到角色眼睛点，确保前向向量朝向相同的方向。参见
    *图 8.2*：
- en: '![Code Sample 8.1](img/B05118_08_02.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 8.1](img/B05118_08_02.jpg)'
- en: 'Figure 8.2: Adding an EyePoint'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.2：添加 EyePoint
- en: 'Now, drag and drop the Eye Point object from the **Hierarchy** panel to the
    **Eye Point** field for the LineSight component in the **Inspector**. This specifies
    the Eye Point object as the eye point for the enemy character. This will be used
    in determining whether the enemy can see the player. Having a separate eye point
    object like this is useful as opposed to using the character position, which is
    typically at the feet location and not the eye. See *Figure 8.3*:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将**层次**面板中的Eye Point对象拖放到**检查器**中LineSight组件的**Eye Point**字段。这指定Eye Point对象为敌人角色的眼睛点。这将用于确定敌人是否能看见玩家。与使用通常位于脚部位置的字符位置相比，拥有这样一个独立的眼睛点对象是有用的。请参见*图8.3*：
- en: '![Code Sample 8.1](img/B05118_08_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例8.1](img/B05118_08_03.jpg)'
- en: 'Figure 8.3: Defining the eye point for an NPC'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3：定义NPC的眼睛点
- en: 'Finally, the `LineSight` script determines the player location by first finding
    the player object in the scene using the **Player** tag. Consequently, make sure
    that the **Player** is tagged or labeled using the **Player** tag. See *Figure
    8.4*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，`LineSight`脚本通过首先在场景中使用**Player**标签找到玩家对象来确定玩家位置。因此，请确保**Player**使用**Player**标签进行了标记或标记。请参见*图8.4*：
- en: '![Code Sample 8.1](img/B05118_08_04.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例8.1](img/B05118_08_04.jpg)'
- en: 'Figure 8.4: Tagging the player object'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4：标记玩家对象
- en: Now take your game for a test run. When you approach the NPC object, the **Can
    See Target** field will be enabled. See *Figure 8.5*. Good work! The line of sight
    functionality is now completed. Let's move on!
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在运行一下你的游戏。当你接近NPC对象时，**Can See Target**字段将被启用。请参见*图8.5*。做得好！视线功能现在已完成。让我们继续前进！
- en: '![Code Sample 8.1](img/B05118_08_05.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例8.1](img/B05118_08_05.jpg)'
- en: 'Figure 8.5: Testing the line of sight functionality'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5：测试视线功能
- en: An overview of Finite State Machines
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 有限状态机的概述
- en: To create the AI for an NPC object, in addition to the line of sight code that
    we already have, we need to use **Finite State Machines** (**FSMs**). An FSM is
    not a *thing* or feature of Unity, nor is it a tangible aspect of the C# language.
    Rather, an FSM is a concept, framework, or idea that we can apply in code to achieve
    specific AI behaviors. It comes from a specific way of thinking about intelligent
    characters. Specifically, we can summarize the NPC for our level as existing within
    one of three possible states at any one time. These are patrol (when the enemy
    is wandering around), chase (when the enemy is running after the player), and
    attack (when the enemy has reached the player and is attacking). Each of these
    modes is a State and requires a unique and specific behavior and the enemy can
    be in only one of these three states at any one time. The enemy cannot, for example,
    be patrolling and chasing simultaneously or patrolling and attacking, because
    this wouldn't make sense within the logic of the world and game.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要为NPC对象创建AI，除了我们已有的视线代码外，我们还需要使用**有限状态机**（**FSM**）。FSM不是Unity的*东西*或功能，也不是C#语言的实体方面。相反，FSM是一个概念、框架或想法，我们可以将其应用于代码以实现特定的AI行为。它源于对智能角色的特定思考方式。具体来说，我们可以总结我们的NPC在任意时刻存在于三种可能的状态之一。这些是巡逻（当敌人四处游荡时）、追逐（当敌人追击玩家时）和攻击（当敌人到达玩家并攻击时）。这些模式中的每一个都是一个状态，需要独特和特定的行为，敌人一次只能处于这三个状态中的一个。例如，敌人不能同时巡逻和追逐，或者巡逻和攻击，因为这不符合世界的逻辑和游戏。
- en: In addition to the states themselves, there is a rule set or group of connections
    between the states that determines when one state should change or move into another.
    For example, an NPC should only move from patrolling to chasing if they can see
    the player and they are not already attacking. Similarly, the NPC should only
    move from attacking to patrolling if they cannot see the player and they are not
    already patrolling or chasing. Thus, the combination of the States and rules governing
    their connections form a Finite State Machine. Consequently, any implementation
    in code that represents this behavior functionally is an FSM. There is no right
    or wrong way to code an FSM per se. There are simply different ways, some of which
    are better or worse for particular ends.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 除了状态本身之外，还有一组规则或状态之间的连接组，它决定了何时一个状态应该改变或移动到另一个状态。例如，NPC 只有在可以看到玩家且尚未攻击的情况下，才应该从巡逻状态移动到追逐状态。同样，NPC
    只有在看不到玩家且尚未巡逻或追逐的情况下，才应该从攻击状态移动到巡逻状态。因此，状态及其连接规则的组合形成了一个有限状态机。因此，任何在功能上表示这种行为的代码实现都是
    FSM。编码 FSM 本身没有对错之分。只是有不同方式，其中一些对于特定目的来说更好或更差。
- en: 'In this section, we''ll code the FSM using Coroutines. Let''s start by creating
    the main structure. Refer to the following code in the file, `AI_Enemy.cs`:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用协程编写 FSM。让我们首先创建主结构。参考文件 `AI_Enemy.cs` 中的以下代码：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-39
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on Coroutines can be found at the online Unity documentation
    at [http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html).
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于协程的信息可以在 Unity 在线文档中找到：[http://docs.unity3d.com/Manual/Coroutines.html](http://docs.unity3d.com/Manual/Coroutines.html)。
- en: Code Sample 8.2
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 8.2
- en: 'The following points summarize the code sample:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `AI_Enemy` class created so far does not represent the full and complete
    FSM but just the skeleton for its beginning. It illustrates the general structure.
    It features a single coroutine for each state.
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 到目前为止创建的 `AI_Enemy` 类并不代表完整的完整状态机（FSM），而只是其开始阶段的框架。它展示了总体结构。它为每个状态提供了一个协程。
- en: The `CurrentState` variable defines a property that selects the active state,
    terminating all existing coroutines and initiating the relevant one.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CurrentState` 变量定义了一个属性，用于选择活动状态，终止所有现有协程并启动相关的协程。'
- en: Each state coroutine will run on a frame-safe infinite loop for as long as the
    state is active, allowing the enemy object to update its behavior, as we'll see
    shortly.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个状态协程将在状态激活期间在一个帧安全的无穷循环中运行，允许敌人对象更新其行为，正如我们很快将看到的。
- en: 'Before proceeding, make sure that the `AI_Enemy` script is attached to the
    NPC object. See *Figure 8.6*:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，请确保 `AI_Enemy` 脚本已附加到 NPC 对象上。参见 *图 8.6*：
- en: '![Code Sample 8.2](img/B05118_08_06.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 8.2](img/B05118_08_06.jpg)'
- en: 'Figure 8.6: Attaching the AI script to the NPC character'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6：将 AI 脚本附加到 NPC 角色上
- en: The Patrol state
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 巡逻状态
- en: 'The first of the three states to implement for the NPC AI is the Patrol State.
    In the previous chapter, we configured an animated patrol object, which the NPC
    should follow continuously during this state. The patrol object moves around the
    level from a predefined animation asset, changing from one position to the next.
    However, previously, the NPC simply followed this object without end, whereas
    the Patrol State requires the NPC to consider whether the player can be seen on
    its route. If it can, the state should change. To support this functionality,
    the Patrol State and Start function of the `AI_Enemy` class has been coded, as
    featured in the following code:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 NPC AI 需要实现的三个状态中的第一个是巡逻状态。在上一章中，我们配置了一个动画巡逻对象，NPC 应在此状态下持续跟随。巡逻对象在关卡内从预定义的动画资源中移动，从一个位置移动到下一个位置。然而，之前
    NPC 只是简单地跟随这个对象，而没有尽头，而巡逻状态要求 NPC 考虑玩家是否在其路线上可见。如果可见，状态应该改变。为了支持这个功能，已经编写了 `AI_Enemy`
    类的巡逻状态和启动函数，如下面的代码所示：
- en: '[PRE2]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Code Sample 8.3
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 8.3
- en: 'The following points summarize the code sample:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `Start` function sets the initial state of the enemy character to Patrol.
    The coroutine AIPatrol handles this state.
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Start` 函数将敌人角色的初始状态设置为巡逻。协程 AIPatrol 处理此状态。'
- en: The AIPatrol coroutine loops infinitely for as long as the `Patrol` state is
    active. Remember that an infinite loop is not necessarily a bad thing when used
    in a coroutine and in combination with a yield statement. This allows prolonged
    behaviors to be coded neatly and easily over time.
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AIPatrol`协程在`Patrol`状态活动期间无限循环。请记住，在协程中使用无限循环并不一定是坏事，尤其是在与`yield`语句结合使用时。这允许长时间的行为可以整洁且易于随时间编码。'
- en: The `SetDestination` function is called to send `NavMeshAgent` to the specified
    destination. This is followed by a `pathPending` check, which is a variable of
    the `NavMeshAgent`. This check waits until the `pathPending` variable is false,
    indicating that a full traversable path has been calculated from the source to
    the destination. For short and simple journeys, a path may be calculated almost
    immediately, but for paths that are more complex, this can take much longer.
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调用`SetDestination`函数将`NavMeshAgent`发送到指定的目标。这之后是一个`pathPending`检查，这是`NavMeshAgent`的一个变量。这个检查等待`pathPending`变量变为false，这表示从源到目标已经计算出一个完整的可穿越路径。对于短而简单的旅程，路径可能几乎立即计算出来，但对于更复杂的路径，这可能需要更长的时间。
- en: During the Patrol state, we constantly check the `LineSight` component to determine
    whether the enemy has a direct line of sight to the player. If so, the enemy changes
    from the `Patrol` state to the `Chase` state.
  id: totrans-57
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在巡逻状态期间，我们不断检查`LineSight`组件以确定敌人是否有直接视线到玩家。如果有，敌人将从`Patrol`状态变为`Chase`状态。
- en: Remember that the yield return null statement will pause a coroutine until the
    next frame.
  id: totrans-58
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请记住，`yield return null`语句将暂停协程直到下一帧。
- en: 'Now, drag and drop the `AIEnemy` script to the NPC character in the scene,
    if you haven''t already. The `Patrol` mode is configured to track a moving object,
    that is, the enemy will follow a moving destination. A moving destination was
    created in the previous chapter using the **Animation** window to move an object
    around the scene over time, jumping from one place to another. See *Figure 8.7*:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果您还没有这样做，请将`AIEnemy`脚本拖放到场景中的NPC角色上。`Patrol`模式被配置为跟踪一个移动对象，也就是说，敌人将跟随一个移动的目标。在上一章中，使用**动画**窗口移动一个对象在场景中随时间移动，从一个地方跳到另一个地方创建了一个移动目标。见*图8.7*：
- en: '![Code Sample 8.3](img/B05118_08_07.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例8.3](img/B05118_08_07.jpg)'
- en: 'Figure 8.7: Creating movable objects'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7：创建可移动对象
- en: 'To achieve movable objects, create one or more destination object in the scene
    and assign them a **Dest** tag. Remember that the `start` function for `AIEnemy`
    searches the scene for all objects tagged as **Dest** and it uses these as destination
    points. See *Figure 8.8*:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现可移动对象，在场景中创建一个或多个目标对象并分配它们一个**Dest**标签。请记住，`AIEnemy`的`start`函数在场景中搜索所有标记为**Dest**的对象，并使用这些作为目标点。见*图8.8*：
- en: '![Code Sample 8.3](img/B05118_08_08.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例8.3](img/B05118_08_08.jpg)'
- en: 'Figure 8.8: Tagging destination objects'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8：标记目标对象
- en: The Chase state
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 追逐状态
- en: 'The Chase state is the second of the three in the enemy FSM. This state connects
    to both the Patrol and Attack states directly. It can be reached in one of two
    ways. If a patrolling NPC establishes a direct line of sight to the player, then
    the NPC changes from patrolling to chasing. Conversely, if an attacking NPC falls
    outside the reach of the player (perhaps because he is running away), the NPC
    resorts to chasing again. From the chasing state itself, it''s possible to move
    either to the Patrol or Attack state, with the inverse conditions as those, which
    lead to chase. That is, if the NPC loses sight of the player, it returns to patrolling
    and, if the NPC reaches within attacking distance of the player, it switches to
    attacking. Consider the following code sample, which amends the `AIEnemy` class
    to support the chase behavior:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: Chase状态是敌人有限状态机（FSM）中的第二个状态。此状态直接连接到巡逻和攻击状态。它可以通过两种方式之一到达。如果一个巡逻的NPC建立了与玩家的直接视线，那么NPC将从巡逻状态变为追逐状态。相反，如果一个攻击的NPC超出了玩家的攻击范围（可能是因为他在逃跑），NPC将再次采取追逐状态。从追逐状态本身，可以移动到巡逻或攻击状态，条件与追逐相反。也就是说，如果NPC失去了对玩家的视线，它将返回巡逻状态，如果NPC到达玩家攻击范围内，它将切换到攻击状态。考虑以下代码示例，它修改了`AIEnemy`类以支持追逐行为：
- en: '[PRE3]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Code Sample 8.4
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例8.4
- en: 'The following points summarize the code sample:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `AIChase` coroutine is started when the Chase state is entered and, like
    the Patrol state, it repeats on a frame-safe infinite loop for as long as the
    state is active.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当进入追逐状态时，将启动`AIChase`协程，并且像巡逻状态一样，只要状态处于活动状态，它就会在一个帧安全的无限循环中重复。
- en: The `remainingDistance` member variable of the `NavMeshAgent` is used to determine
    whether the NPC has reached within attacking distance of the player.
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NavMeshAgent`类的`remainingDistance`成员变量用于确定NPC是否已经到达攻击玩家的距离范围内。'
- en: The `CanSeeTarget` Boolean variable of the `LineSight` class indicates whether
    the player is visible and is influential in choosing whether the NPC should return
    to patrolling.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`LineSight`类的`CanSeeTarget`布尔变量指示玩家是否可见，并在选择NPC是否应该返回巡逻状态时具有影响力。'
- en: Excellent work! Now give the code a test run in the editor and you have an enemy
    character than can patrol and chase. Splendid!
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的工作！现在在编辑器中运行代码，你将拥有一个可以巡逻和追逐的敌人角色。太棒了！
- en: The Attack state
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 攻击状态
- en: 'The third and final state for the NPC is the Attack state, during which the
    NPC is continually attacking the player. This state can only be reached from the
    Chase state. During a chase, the NPC must determine whether they have reached
    within attacking distance. If so, the NPC must change from chasing to attacking.
    If, during an attack, the player leaves the attacking distance, then the NPC must
    change from attacking to chasing. Consider the following code sample, which includes
    the complete `EnemyAI` class, with all coded and completed states:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: NPC的第三个也是最后一个状态是攻击状态，在这个状态下，NPC会持续攻击玩家。这个状态只能从追逐状态到达。在追逐过程中，NPC必须确定他们是否已经到达攻击距离。如果是这样，NPC必须从追逐状态变为攻击状态。如果在攻击过程中，玩家离开了攻击距离，那么NPC必须从攻击状态变为追逐状态。考虑以下代码示例，它包括了完整的`EnemyAI`类，以及所有编码和完成的状态：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Code Sample 8.5
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例8.5
- en: 'The following points summarize the code sample:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `AIAttack` coroutine runs on a frame-safe infinite loop for as long as the
    Attack state is active (the enemy will be attacking during this state).
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AIAttack`协程在攻击状态激活期间（在这个状态下敌人将会攻击）运行在一个帧安全的无限循环中。'
- en: The `MaxDamage` variable specifies how much damage the enemy deals to the player
    per second.
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MaxDamage`变量指定了敌人每秒对玩家造成的伤害量。'
- en: The `AIAttack` coroutine relies on the `Health` component to inflict damage.
    This is an additional custom component that encodes health. Both the player and
    enemy should have a health component to represent their health.
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AIAttack`协程依赖于`Health`组件来造成伤害。这是一个额外的自定义组件，用于编码健康值。玩家和敌人都应该有一个健康组件来表示他们的健康状态。'
- en: 'The Health script (`Health.cs`) is referenced by the `AIEnemy` class (the Attack
    State) to inflict damage on the player. For this reason, the player character
    needs a `Health` component attached. The code for this component is included in
    the following code sample:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 健康脚本（`Health.cs`）被`AIEnemy`类（攻击状态）引用，用于对玩家造成伤害。因此，玩家角色需要附加一个`Health`组件。该组件的代码包含在下面的代码示例中：
- en: '[PRE5]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The `Health` script is pretty simple. It maintains a numerical health value
    that, when reduced to `0` or below, will destroy the host game object. This should
    at least be attached to the player character, allowing the NPC to inflict damage
    on approach. It could, however, also be attached to the NPC objects, allowing
    the player to reciprocate an attack. See *Figure 8.9*:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: '`Health`脚本相当简单。它维护一个数值健康值，当减少到`0`或以下时，将销毁宿主游戏对象。这至少应该附加到玩家角色上，允许NPC在接近时造成伤害。然而，它也可以附加到NPC对象上，允许玩家进行反击。参见*图8.9*：'
- en: '![Code Sample 8.5](img/B05118_08_09.jpg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例8.5](img/B05118_08_09.jpg)'
- en: 'Figure 8.9: Configuring player health'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9：配置玩家健康
- en: 'Great, we''re almost ready to test this project. First, make a prefab from
    the enemy object, if you''ve not already done so, by dragging and dropping the
    NPC game object from either the **Scene** view or **Hierarchy** panel to the **Project**
    panel. Then, add as many enemies as you want to the level. See *Figure 8.10*:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了，我们几乎准备好测试这个项目了。首先，如果你还没有这样做，通过将NPC游戏对象从**场景**视图或**层次结构**面板拖放到**项目**面板来从敌人对象创建一个预制体。然后，将你想要的敌人数量添加到关卡中。参见*图8.10*：
- en: '![Code Sample 8.5](img/B05118_08_10.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例8.5](img/B05118_08_10.jpg)'
- en: 'Figure 8.10: Creating an NPC prefab'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10：创建NPC预制体
- en: 'Now, test the level by pressing the play icon on the toolbar and you should
    have a complete environment in which intelligent enemies can seek, chase, and
    attack the player with a significant degree of believability. In some cases, you
    may need to tweak or refine the enemy FOV to better match your surroundings and
    character type. Good work! See *Figure 8.11*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过在工具栏上按下播放图标来测试水平，你应该拥有一个完整的环境，其中智能敌人可以以相当逼真的程度寻找、追逐和攻击玩家。在某些情况下，你可能需要调整或细化敌人的视野范围（FOV），以更好地匹配你的环境和角色类型。干得好！参见*图8.11*：
- en: '![Code Sample 8.5](img/B05118_08_11.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例8.5](img/B05118_08_11.jpg)'
- en: 'Figure 8.11: The completed level'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11：完成的关卡
- en: Summary
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Excellent! You've now reached the end of the AI project as well as the end of
    the book. In completing this project, you've assembled a complete terrain, an
    NPC prefab, and a series of scripts that work together strategically to create
    the appearance of intelligence, and this is *good enough* for AI. For games, AI
    refers to nothing more than *intelligent-looking* objects and the techniques that
    create them. Great! Furthermore, in reaching the end of this book and completing
    all four projects, you are now equipped with a varied and critically important
    skillset to develop professional-grade games in both 2D and 3D.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！你现在已经完成了AI项目，也完成了这本书。在完成这个项目的过程中，你组装了一个完整的地图、一个NPC预制件以及一系列协同工作的脚本，这些脚本策略性地创建出智能的外观，这对于AI来说已经足够好了。对于游戏来说，AI不过是指那些*看起来智能*的对象以及创建它们的技巧。太棒了！此外，在完成这本书并完成所有四个项目后，你现在已经具备了一组多样且至关重要的技能，可以开发2D和3D的专业级游戏。
