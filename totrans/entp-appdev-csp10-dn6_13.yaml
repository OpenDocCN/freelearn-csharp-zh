- en: '*Chapter 10*: Creating an ASP.NET Core 6 Web API'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In recent times, web services have become an important part of web application
    development. With ever-changing requirements and increased business complexity,
    it is very important to loosely couple various components/layers involved in web
    application development, and there is nothing better than decoupling the **user
    interface** (**UI**) part of the application with the core business logic. This
    is where the simplicity of web services using a RESTful approach (where **REST**
    stands for **REpresentational State Transfer**) helps us to develop scalable web
    applications.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will learn how to build RESTful services using an ASP.NET
    Core web **application programming interface** (**API**), and along the way, we
    will build all the required APIs for our e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ll be covering the following topics in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to REST
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the internals of an ASP.NET Core 6 web API
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling requests using controllers and actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integration with the data layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding **Google Remote Procedure Call** (**gRPC**)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For this chapter, you will require a basic knowledge of C#, .NET Core, web APIs,
    **HyperText Transfer Protocol** (**HTTP**), Azure, **dependency injection** (**DI**),
    Postman, and the .NET **command-line interface** (**CLI**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter10/TestApi](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter10/TestApi).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more code examples, refer to the following link: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to REST
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: REST is an architectural guideline for building a web service. Primarily, it
    defines a set of constraints that can be followed while designing a web service.
    One of the key principal REST approaches recommends that APIs should be designed
    around resources and should be media- and protocol-agnostic. The underlying implementation
    of the API is independent of the client consuming the API.
  prefs: []
  type: TYPE_NORMAL
- en: 'Considering an example of our e-commerce application, let''s say we are searching
    for a product on the UI using a product''s search field. There should be an API
    that is created for products, and here, products are nothing but a resource in
    the context of an e-commerce application. The `GET` operation on product entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The response of the API should be independent of the client that is calling
    the API—that is, in this case, we are using a browser to load a list of products
    on the product search page. However, the same API can be consumed in a mobile
    application as well without any changes. Secondly, in this case, in order to retrieve
    product information internally, an application may be using one or more physical
    data stores; however, that complexity is hidden from the client application, and
    the API is exposed to the client as a single business entity—products. Although
    REST principles do not dictate the protocol to be HTTP, the majority of RESTful
    services are built over HTTP. Some key design principles/constraints/rules of
    HTTP-based RESTful APIs are outlined here:'
  prefs: []
  type: TYPE_NORMAL
- en: Identify the business entities of the system and design APIs around those resources.
    In the case of our e-commerce application, all our APIs would be around resources
    such as products, orders, payments, and users.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: REST APIs should have a uniform interface that assists in making them independent
    of the client. As all the APIs need to be resource-oriented, each resource is
    uniquely identified by a URI; additionally, various operations on resources are
    uniquely identified by HTTP verbs such as `GET`, `POST`, `PUT`, `PATCH`, and `DELETE`.
    For example, `GET` (`http://ecommerce.packt.com/products/1`) should be used to
    retrieve a product with an`1`. Similarly, `DELETE` (`http://ecommerce.packt.com/products/1`)
    should be used to delete a product.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As HTTP is stateless, REST dictates a number of things for RESTful APIs. What
    this means is that APIs should be atomic and conclude the processing of a request
    within the same call. Any subsequent request, even from the same client (same
    **Internet Protocol** (**IP**) address), is treated as a new request. For example,
    if an API accepts an authentication token, it should accept authentication for
    each request. One major advantage of statelessness is the scalability that servers
    can eventually achieve, as a client can make an API call to any of the available
    servers and still receive the same response.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Apart from sending back a response, APIs should make use of HTTP status codes
    and response headers to send any additional information to the client. For example,
    if a response can be cached, an API should send the relevant response headers
    to the client so that it can be cached. `1xx` for information, `2xx` for success,
    `3xx` for redirection, `4xx` for client errors, and `5xx` for server errors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: APIs should give information about the resource such that clients should be
    easily able to discover it without any prior information relating to the resource—that
    is, there should follow the principle of **Hypermedia as the Engine of Application
    State** (**HATEOAS**). For example, if there is an API to create a product, once
    a product is created, the API should respond with the URI of that resource so
    that the client can use that to retrieve the product later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Refer to the following response for an API that retrieves a list of all products
    (`GET /products`) and has information to retrieve further details regarding each
    product:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The preceding example is one way to implement the *HATEOAS* principle, but it
    can be designed in a more descriptive way, such as a response containing information
    about accepted HTTP verbs and relationships.
  prefs: []
  type: TYPE_NORMAL
- en: The REST maturity model
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'These are various guidelines that an API should follow in order for it to be
    RESTful. However, not all the principles need to be followed to make it perfectly
    RESTFUL; it''s more important that an API should fulfill the business goal rather
    than being 100% REST-compliant. Leonard Richardson, an expert on RESTful API design,
    came up with the following model to categorize the maturity of an API:'
  prefs: []
  type: TYPE_NORMAL
- en: '`POST` URI to perform all operations will fall under this category. An example
    would be a **Simple Object Access Protocol** (**SOAP**)-based web service that
    has a single URI, and all operations are segregated based on the SOAP envelope.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level 1—Resources**: All resources are URI-driven, and APIs that have a dedicated
    URI pattern per resource fall under this maturity model.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`GET` and `DELETE` using the same URI with different HTTP verbs falls under
    this maturity model. Most enterprise application RESTful APIs fall under this
    category.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Level 3—HATEOAS**: APIs that are designed with all additional discovery information
    (the URI for the resources; various operations that the resource supports) fall
    under this maturity model. Very few APIs are compliant with this maturity level;
    however, as discussed earlier, it''s important that our APIs fulfill the business
    objective and are as compliant as possible with RESTful principles, rather than
    100% compliant but not fulfilling the business objective.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram illustrates Richardson''s maturity model:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.1 – Richardson''s maturity model'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.1_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.1 – Richardson's maturity model
  prefs: []
  type: TYPE_NORMAL
- en: Up to now, we have discussed various principles of REST architecture. In the
    next section, let's get into using an ASP.NET Core web API for which we will create
    various RESTful services in our e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the internals of an ASP.NET Core 6 web API
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**ASP.NET Core** is a unified framework that runs on top of .NET Core and is
    used to develop web applications (MVC/Razor), RESTful services (web API), and—most
    recently—web assembly-based client applications (Blazor apps). The fundamental
    design of ASP.NET Core applications is based on the **Model-View-Controller**
    (**MVC**) pattern, which divides code into three primary categories, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Model**: This is a **plain old CLR object** (**POCO**) class that holds the
    data and is used to pass data between various layers of the application. Layers
    include passing data between the *repository* class and the *service* class or
    passing information back and forth between the *client* and *server*. The model
    primarily represents the resource state or the domain model of the application
    and contains information that you have requested.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, if we wanted to store user profile information, this can be represented
    by the `UserInformation` POCO class and can contain all the profile information.
    This will be further used to pass between repositories and service classes and
    can also be serialized into **JavaScript Object Notation** (**JSON**)/**Extensible
    Markup Language** (**XML**) before being sent back to the client. In enterprise
    applications, we will encounter different types of models while creating models
    for our e-commerce application in the *Integration with the data layer* section.
  prefs: []
  type: TYPE_NORMAL
- en: '**View**: These are the pages that represent UIs. All our models retrieved
    from controllers are bound to various **HyperText Markup Language** (**HTML**)
    controls on views and are presented to users. Views are usually common in MVC/Razor
    applications; for web API applications, the process ends with serializing models
    as a response.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Microsoft.AspNetCore.Mvc.ControllerBase` class to define controllers.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, in a web application developed using ASP.NET Core, whenever a request comes
    from a client (browser, mobile apps, and similar sources), it goes through the
    ASP.NET Core request pipeline and reaches a controller that interacts with the
    data store to populate models/view-models and send them back either as a response
    in the form of JSON/XML or to a view to further bind the response and present
    it to the user.
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is a clear **separation of concerns** (**SOC**) where
    a controller is not aware of any UI aspect and performs the business logic in
    the current context and responds via models; views, on the other hand, receive
    models and use them to present them to the user in HTML pages. This SOC easily
    helps to unit test the application, as well as maintain and scale it as needed.
    MVC patterns are not only applicable to web applications and can be used for any
    application that requires an SOC.
  prefs: []
  type: TYPE_NORMAL
- en: As the focus of this chapter is to build RESTful services, we will focus on
    an ASP.NET Core web API in this chapter and discuss ASP.NET MVC and Razor Pages
    in [*Chapter 11*](B18507_11_Epub.xhtml#_idTextAnchor1228), *Creating an ASP.NET
    Core 6 Web Application*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To develop RESTful services, many frameworks are available, but here are a
    few advantages of going with ASP.NET Core on .NET 6:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cross-platform support**: Unlike ASP.NET, which used to be part of the .NET
    Framework (which is coupled with the Windows operating system), ASP.NET Core is
    now part of the application, thereby eliminating platform dependency and making
    it compatible with all platforms.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Highly customizable request pipelines**: Use middlewares and support to inject
    various out-of-the-box modules, such as logging and configuration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IIS` and `HTTP.sys`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By default, Kestrel is the HTTP server used in ASP.NET Core templates; however,
    that can be overridden as required.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '**Strong tooling support**: This comes in the form of **Visual Studio Code**
    (**VS Code**), Visual Studio, and the DOTNET CLI, along with project templates,
    which means developers can start working on implementing the business logic with
    very little setup.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Open sourced**: Finally, the entire framework is open sourced and is available
    at [https://github.com/aspnet/AspNetCore](https://github.com/aspnet/AspNetCore).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, we now know why we picked ASP.NET Core as our framework to develop RESTful
    services. Let''s now look into some key components that assist in the execution
    of the request and create a sample web API by using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Once the preceding command is successfully executed, let''s navigate to the
    `TestApi` folder and open it in VS Code to see the various files that are generated,
    as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.2 – Test web API project in VS Code'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.2_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.2 – Test web API project in VS Code
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see a `Program` class used to bootstrap the application, and settings
    files, such as `appsettings.json`, that are used to run a web API project, and
    there is also `WeatherForecast`, which is a model class used in the controller
    class. Let's examine each of the components of `TESTAPI` in the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: The Program class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `Program` class is used to bootstrap web API projects in ASP.NET Core 6\.
    Let''s look at the activities performed by this class in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Program` class is the entry point for our web API, and it tells ASP.NET
    Core to begin execution whenever someone executes the web API project. Primarily,
    this is the class that is used to bootstrap the application. Unlike earlier versions
    of ASP.NET Core applications, by default we don't have a `Startup` class—that
    is, the `Program` class has everything that we need—and to keep the code minimal,
    we further rely on C# 10's top-level statements and global using statements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since this is the entry point, we need to ensure all components such as the
    web server, routing, and configuration, get initialized and loaded, and that is
    what the `CreateBuilder` method of the `WebApplication` class helps with. It primarily
    creates an object of `WebApplicationBuilder`, which can be used to configure the
    HTTP request pipeline.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`WebApplicationBuilder` is inherited from the `IApplicationBuilder` interface,
    which is nothing but the `Host` is nothing more than an object that encapsulates
    these components, such as the HTTP server defaulted to Kestrel, all the middleware
    components, and any additional services—such as logging—that are injected. Finally,
    the `Build()` method is called to run actions and initialize the `Host` object.
    The `Run()` method is called to keep the `Host` object running.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have the `Host` object loaded with all the default components and
    it is up and running, let''s examine whether we can inject additional ASP.NET
    Core classes/application-specific classes (repositories, services, options) and
    middlewares. Consider the following points:'
  prefs: []
  type: TYPE_NORMAL
- en: 'This `WebApplicationBuilder` object is used to inject any ASP.NET Core-provided
    services so that applications can use those services. A few common services that
    enterprise applications can inject are shown in the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Apart from services provided by ASP.NET Core, we can also inject any custom
    services specific to our application—for example, `ProductService` can be mapped
    to `IProductService` and can be made available for the entire application. Primarily,
    this is the place we can use to plumb anything into the DI container, as explained
    in [*Chapter 5*](B18507_05_Epub.xhtml#_idTextAnchor445), *Dependency Injection
    in .NET 6*.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, all services, including ASP.NET Core services and custom services,
    can be plumbed into the application and are available as extension methods of
    `IServiceCollection`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we have an object of the `WebApplication` class that can be used to integrate
    all the middlewares required to be applied to the request pipeline. This object
    primarily controls how applications respond to HTTP requests—that is, how applications
    should respond to exceptions, how they should respond to static files, or how
    URI routing should happen. All can be configured using this object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Additionally, any specific handling on a request pipeline—such as calling a
    custom middleware or adding specific response headers, or even defining a specific
    endpoint—can be injected using the `WebApplication` object. So, apart from what
    we saw earlier, the following code snippet shows a few common additional configurations
    that can be integrated using the `WebApplication` object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, `app.UseEndpoints` is configuring a response for a URI that matches `/subscribe`.
    `app.UseEndPoints` works alongside routing rules and is explained in the *Handling
    requests using controllers and actions* section, while `app.Use`, on the other
    hand, is used to add an inline middleware. In this case, we are removing `X-Powered-By`
    and `Server` response headers from the response.
  prefs: []
  type: TYPE_NORMAL
- en: Since ASP.NET Core 6 supports something called `Program` class alone can be
    used to build a fully working API; however, for enterprise applications, it is
    good to segregate APIs for easier maintenance and better readability, hence in
    our enterprise applications, we will be using APIs with the controller, which
    is supported by `MapControllers` middleware and is configured by calling `app.`
    `MapControllers()`.
  prefs: []
  type: TYPE_NORMAL
- en: To sum up, the `Program` class plays a vital role in bootstrapping the application
    and then customizing application services and HTTP request/response pipelines
    as needed.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now see how middlewares help in customizing the HTTP request/response
    pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core 6 still supports using the `Startup` class, and the `Configure`
    and `ConfigureServices` methods can be used as-is.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding middleware
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have been referring to middleware for a while now, so let''s understand
    what middlewares are and how we can we build one and use it in our enterprise
    application. Middlewares are classes that intercept incoming requests, perform
    some processing on the requests, and then hand them over to the next middleware
    or skip them as required. Middlewares are bidirectional, hence all middlewares
    intercept both requests and responses. Let''s assume that an API retrieves product
    information and, in the process, it goes through various middlewares. Representing
    them in pictorial form would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.3 – Middleware processing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.3_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.3 – Middleware processing
  prefs: []
  type: TYPE_NORMAL
- en: Each middleware has an instance of `Microsoft.AspNetCore.Http.RequestDelegate`.
    As a result of using this, the middleware invokes the next middleware. So, flows
    would typically process the request as per some processing logic that you want
    the middleware to perform on the request and then invoke `RequestDelegate` to
    hand the request over to the next middleware in the pipeline.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we take an analogy from manufacturing, it would be like an assembly line
    in a manufacturing process, where parts are added/modified from workstation to
    workstation until a final product is produced. In the previous diagram, let''s
    consider each middleware as a workstation, so it will be going through the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The following explanation of each middleware is just a hypothetical explanation
    for our understanding; the internal workings of these middlewares differ slightly
    from what is explained here. More details can be found here: [https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder?view=aspnetcore-3.1&viewFallbackFrom=aspnetcore-6.0](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.builder?view=aspnetcore-3.1&viewFallbackFrom=aspnetcore-6.0).'
  prefs: []
  type: TYPE_NORMAL
- en: '`UseHttpsRedirection`: An HTTP request arrives for `GET/Products` and is inspected
    for the protocol. If the request is via HTTP, a redirect is sent back through
    the HTTP status code; if the request is on HTTPS, it''s handed over to the next
    middleware.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`UseStaticFiles`: If the request is for a static file (usually detected based
    on the extension—the **Multipurpose Media Extensions** (**MIME**) type), this
    middleware processes the request and sends the response back, or else hands the
    request on to the next middleware. Here, as you can see, if the request is for
    a static file, the rest of the pipeline is not even executed as this middleware
    can process the complete request, thereby reducing the load on the server for
    any unwanted processing and also reducing the response time. This process is also
    known as **short-circuiting**, which every middleware can support.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`UseRouting`: The request is inspected further, and the controller/action that
    can process the request is identified. If there isn''t any match, this middleware
    usually responds with a `404` HTTP status code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`UseAuthorization`: Here, if the controller/action needs to be available for
    authenticated users, then this middleware will look for any valid token in the
    header and respond accordingly.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once the controller gets the data from services/repositories, the response goes
    through the same middlewares in reverse order—that is, `UseAuthorization` first,
    followed by `UseHttpsRedirection`—and the response is processed as needed.
  prefs: []
  type: TYPE_NORMAL
- en: As mentioned earlier, all middlewares are installed using the `Program` class
    and are configured using the object of the `WebApplication` class. The order of
    middleware execution would precisely follow the way it is configured in the `Program`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: Armed with this understanding, let's create a middleware that will be used to
    handle exceptions across the RESTful services of our e-commerce application, so
    instead of adding `try…catch` blocks in the code, we will create a middleware
    that gets installed at the beginning of the request pipeline and then catches
    any exceptions throughout.
  prefs: []
  type: TYPE_NORMAL
- en: Building a custom middleware
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: As the middleware is going to be reused across all RESTful services, we will
    add the middleware to the `Packt.Ecommerce.Common` project inside the `Middlewares`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first create a POCO class that represents the response in case of errors.
    This model will typically hold an error message, a `ExceptionResponse` inside
    the `Models` folder of the `Packt.Ecommerce.Common` project and add the following
    code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, create another POCO class that can hold the configuration to toggle the
    behavior of sending an inner exception in our response. This class will be populated
    using the `Options` pattern, which was discussed in [*Chapter 6*](B18507_06_Epub.xhtml#_idTextAnchor473),
    *Configuration in .NET 6*. Since it needs to hold only one setting, it will have
    one property. Add a class file named `ApplicationSettings` in the `Options` folder
    and then add the following code to it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: This class will be extended further for any configuration that will be common
    across all our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'Navigate to the `Middlewares` folder and create a class named `ErrorHandlingMiddleware`.
    As we discussed, one of the key properties in any middleware is a property of
    the `RequestDelegate` type. Additionally, we will add a property for `ILogger`
    to log the exception to our logging provider, and finally, we will add a property
    of the `bool` `includeExceptionDetailsInResponse` type to hold a flag that controls
    masking the inner exception. With this, here''s what the `ErrorHandlingMiddleware`
    class will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Add a parameterized constructor where we inject `RequestDelegate` and `ILogger`
    for our logging provider and `IOptions<ApplicationSettings>` for configuration
    and assign them to the properties created earlier. Here, again, we are relying
    on the constructor injection of ASP.NET Core to instantiate the respective objects.
    With this, here''s what the constructor of `ErrorHandlingMiddleWare` will look
    like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, add an `InvokeAsync` method that will have the logic to process the
    request and then call the next middleware using `RequestDelegate`. Since this
    is an exception-handling middleware as part of our logic, all we are going to
    do is wrap the request in a `try…catch` block. In the `catch` block, we will log
    it to the respective logging provider using `ILogger`, and finally send an object,
    `ExceptionResponse`, back as the response. With this, here''s what `InvokeAsync`
    will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we can inject this middleware into the `Program` class with the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: 'Since this is an exception handler, it is recommended to configure it as early
    as possible in the `Program` class so that any exceptions in all subsequent middlewares
    are caught. Additionally, we need to ensure that we map the `ApplicationSettings`
    class to a configuration, so add the following code to the `Program` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the relevant section to `appsettings.json`, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, if there is an error in any of our APIs, the response will look like the
    one shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: 'From the preceding code snippet, we can take `CorrelationIdentifier`, which
    is `03410a51b0475843936943d3ae04240c`, search the value in our logging provider,
    **Application Insights**, and we can ascertain additional information regarding
    the exception, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.4 – Tracing CorrelationIdentifier in Application Insights'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.4_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.4 – Tracing CorrelationIdentifier in Application Insights
  prefs: []
  type: TYPE_NORMAL
- en: '`CorrelationIdentifier` is extremely helpful in production environments where
    there is no inner exception.'
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion regarding middleware. In the next section, let's
    look at what **controllers** and **actions** are and how they help in handling
    requests.
  prefs: []
  type: TYPE_NORMAL
- en: Handling requests using controllers and actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Controllers** are the fundamental blocks for handling requests for designing
    RESTful servicers using an ASP.NET Core web API. These are the primary classes
    that hold the logic to process requests, which includes retrieving data from a
    database, inserting a record into a database, and so on. Controllers are classes
    where we define methods to process requests. These methods usually include validating
    the input, talking to a data store, applying business logic (in enterprise applications,
    controllers will also call service classes), and—finally—serializing the response
    and sending it back to the client using HTTP protocols in JSON/XML form.'
  prefs: []
  type: TYPE_NORMAL
- en: All these methods that hold the logic to process requests are known as **actions**.
    All requests received by the HTTP server are handed over to action methods using
    a routing engine. However, a routing engine transfers requests to actions based
    on certain rules that can be defined in a request pipeline. These rules are what
    we define in routing. Let's see how a URI for handling requests is mapped to a
    particular action in a controller.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding ASP.NET Core routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Up to now, we have seen that any HTTP request goes through the middleware and
    is finally handed over to the controller or an endpoint defined in the `configure`
    method, but who is responsible for this handover to a controller/endpoint, and
    how does ASP.NET Core know which controller and method inside the controller to
    trigger? That is what the routing engine is for, and this was injected when adding
    the following middlewares:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: Here, `app.UseRouting()` injects `Microsoft.AspNetCore.Routing.EndpointRoutingMiddleware`,
    which is used to make all routing decisions based on the URI. The primary job
    of this middleware is to set the instance of the `Microsoft.AspNetCore.Http.Endpoint`
    method with the value of the action that needs to be executed for a particular
    URI.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we are trying to get the details of a product according to
    its ID and have a product controller that has the `GetProductById` method to fulfill
    this request, when we make an API call to the `api/products/1` URI, putting a
    breakpoint in a middleware after `EndpointRoutingMiddleware` shows you that an
    instance of the `Endpoint` class is available with information regarding the action
    that matches the URI and should be executed. We can see this in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.5 – Routing middlewares'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.5_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.5 – Routing middlewares
  prefs: []
  type: TYPE_NORMAL
- en: This object would be null if there wasn't any matching controller/action. Internally,
    `EndpointRoutingMiddleware` uses the URI, query string parameters, and HTTP verbs
    and request headers to find the correct match.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the correct action method is identified, it''s the job of `app.UseEndPoints`
    to hand over control to the action method identified by the `Endpoint` object
    and execute it. `UseEndPoints` injects `Microsoft.AspNetCore.Routing.EndpointMiddleware`
    to execute the appropriate method to fulfill a request. One important aspect of
    populating an appropriate `EndPoint` object is the various URIs that are configured
    inside `UseEndPoints` that can be achieved through the static extension methods
    available in ASP.NET Core. For example, if we want to configure just controllers,
    we can use `MapControllers` extension methods, which add endpoints for all actions
    in controllers for `UseRouting` to match further. If we are building RESTful APIs,
    it is recommended to use `MapControllers` extensions. However, there are many
    such extension methods for the following extensions that are commonly used:'
  prefs: []
  type: TYPE_NORMAL
- en: '`MapGet`/`MapPost`: These are extension methods that can match specific patterns
    for `GET`/`POST` verbs and execute the request. They accept two parameters, one
    being the pattern of the URI and the second being the request delegate that can
    be used to execute when the pattern is matched. For example, the following code
    can be used to match the `/aboutus` route and respond with the text `Welcome to
    default products route`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE80]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`MapRazorPages`: This extension method is used if we are using Razor Pages
    and need to route to appropriate pages based on routes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MapControllerRoute`: This extension method can be used to match controllers
    with a specific pattern; for example, the following code can be seen in the ASP.NET
    Core MVC template, which matches methods based on a pattern:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE81]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The request URI is split based on the forward slash (`/`) and is matched to
    the controller, action method, and ID. So, if you wanted to match a method in
    a controller, you need to pass the controller name (ASP.NET Core automatically
    suffixes the `controller` keyword) and method name in the URI.
  prefs: []
  type: TYPE_NORMAL
- en: Optionally, the ID can be passed as a parameter to that method. For example,
    if I have `GetProducts` in `ProductsController`, you would be calling it using
    the absolute URI, `products/GetProducts`. This kind of routing is known as **conventional
    routing** and is a good fit for UI-based web applications, and so can be seen
    in the ASP.NET Core MVC template.
  prefs: []
  type: TYPE_NORMAL
- en: This concludes our discussion of the basics of routing; there are many such
    extension methods available in ASP.NET Core that can be plumbed into the request
    pipeline based on application requirements. Now, let's look at attribute-based
    routing, a routing technique recommended for RESTful services built using ASP.NET
    Core.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect of routing, as with any other middleware sequence,
    is that injection is very important, and `UseRouting` should be called before
    `UseEndpoints`.
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-based routing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For RESTful services, conventional routing contravenes a few REST principles,
    especially the principle that states that the operation on entities performed
    by the action method should be based on HTTP verbs; so, ideally, in order to get
    products, the URI should be `GET api/products`.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is where attribute-based routing comes into play, in which routes are
    defined using attributes either at the controller level or at the action method
    level, or both. This is achieved using the `Microsoft.AspNetCore.Mvc.Route` attribute,
    which takes a string value as an input parameter and is used to map the controller
    and action. Let''s take an example of `ProductsController`, which has the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the `Route` attribute at the controller level, we are passing the value
    `api/[controller]`, which means that any URI matching `api/products` is mapped
    to this controller, where `products` is the name of the controller. Using the
    `controller` keyword inside square brackets is a specific way of telling ASP.NET
    Core to map the controller name automatically to the route.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you want to stick to a specific name irrespective of the controller
    name, this can be used without square brackets. As a best practice, it is recommended
    to decouple controller names with routes. Hence, for our e-commerce application,
    we will go with exact values in routes—that is, `ProductsController` will have
    a route prefix of `[Route("api/products")]`.
  prefs: []
  type: TYPE_NORMAL
- en: The `Route` attribute can also be added to action methods and can be used to
    additionally identify specific methods uniquely. Here, we are also passing a string
    that can be used to identify the method. For example, `[Route("GetProductById/{id}")]`
    would be matched to the `api/products/GetProductById/1` URI, and the value inside
    the curly brackets is a dynamic value that can be passed as a parameter to the
    action method and matched with the parameter name.
  prefs: []
  type: TYPE_NORMAL
- en: 'What this means is that in the preceding code, there is an ID parameter, and
    the value inside the curly brackets should also be named `ID` so that ASP.NET
    Core can map values from the URI to the `method` parameter. Hence, for the `api/products/1`
    URI, the ID parameter in the `GetProductById` method will have a value of `1`
    if the route attribute looks like this: `[Route("{id}")]`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the HTTP verb is represented by attributes such as `[HttpGet]`, which
    will be used to map the HTTP verb from the URI to the method. The following table
    shows various examples and possible matches, assuming that `ProductsController`
    has `[Route("api/products")]`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 10.1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_10.1.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.1
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the name of the method is immaterial here and so is not part
    of the URI matching unless it is specified in the `Route` attribute.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'One important aspect is that the web API supports the reading of parameters
    from various locations within a request, be it in the request body, header, query
    string, or URI. The following documentation covers the various options available:
    [https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-6.0#binding-source-parameter-inference](https://docs.microsoft.com/en-us/aspnet/core/web-api/?view=aspnetcore-6.0#binding-source-parameter-inference).'
  prefs: []
  type: TYPE_NORMAL
- en: 'A summary of an entire API routing in ASP.NET Core could be represented as
    follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.6 – ASP.NET Core API routing'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.6_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.6 – ASP.NET Core API routing
  prefs: []
  type: TYPE_NORMAL
- en: Attribute-based routing is more RESTful, and we will follow this kind of routing
    in our e-commerce services. Now, let's look at the various helper classes available
    in ASP.NET Core that can be used to simplify the building of RESTful services.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'The `{id}` expression in routing is known as a **routing constraint**, and
    ASP.NET Core comes with a varied set of such routing constraints that can also
    be found here: [https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-6.0#route-constraint-reference](https://docs.microsoft.com/en-us/aspnet/core/fundamentals/routing?view=aspnetcore-6.0#route-constraint-reference).'
  prefs: []
  type: TYPE_NORMAL
- en: The ControllerBase class, the ApiController attribute, and the ActionResult
    class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we go back to any of the controllers created hitherto, you can see that
    all the controllers are inherited from the `ControllerBase` class. In ASP.NET
    Core, `ControllerBase` is an abstract class that provides various helper methods
    that assist in handling requests and responses. For example, if I wanted to send
    an HTTP status code `400` (bad request), there is a `BadRequest` helper method
    in `ControllerBase` that can be used to send an HTTP status code of `400`; otherwise,
    we have to manually create an object and populate it with the HTTP status code
    `400`. There are many such helper methods in `ControllerBase` that are available
    out of the box; however, not every API controller needs to be inherited from the
    `ControllerBase` class. All helper methods from the `ControllerBase` class are
    mentioned here: [https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-3.1&viewFallbackFrom=aspnetcore-6.0](https://docs.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.mvc.controllerbase?view=aspnetcore-3.1&viewFallbackFrom=aspnetcore-6.0).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This brings us to a discussion as to what the return type of our controller
    methods should be because there could be at least two possible responses for any
    API in general, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A successful response with a 2xx status code that possibly responds with a resource
    or a list of resources
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A validation failure case with a 4xx status code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To handle such scenarios, we need to create a generic type that can be used
    to send different response types, and this is where ASP.NET Core''s `IActionResult`
    and `ActionResult` types come into play, providing us with derived response types
    for various scenarios. A few important response types that `IActionResult` supports
    are listed here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OkObjectResult`: This is a response type that sets the HTTP status code to
    `200` and adds the resource to the body of the response containing the details
    of the resource. This type is ideal for all APIs that respond with a resource
    or a list of resources—for example, get products.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NotFoundResult`: This is a response type that sets the HTTP status code to
    `404` and has an empty body. This can be used if a particular resource is not
    found. However, in the case of a resource not found, we will use `NoContentResult`
    (`204`), as `404` will also be used for an API not found.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BadRequestResult`: This is a response type that sets the HTTP status code
    to `400` and contains an error message in the response body. This is ideal for
    any validation failures.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreatedAtActionResult`: This is a response type that sets the HTTP status
    code to `201` and can add the newly created resource URI to the response. This
    is ideal for APIs that create resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these response types are inherited from `IActionResult`, and there are methods
    available in the `ControllerBase` class that can create these objects; so, `IActionResult`,
    along with `ControllerBase`, would solve most of the business requirements, and
    this is what we will have as the return type for all our API controller methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final important class available in ASP.NET Core that comes in handy is
    the `ApiController` class, which can be added as an attribute to the controller
    class or to an assembly, and adds the following behaviors to our controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: It disables conventional routing and makes attribute-based routing mandatory.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It validates models automatically, so we don't need to explicitly call `ModelState.IsValid`
    in every method. This behavior is very useful in the case of insert/update methods.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'It facilitates automatic parameter mapping from the body/route/header/query
    strings. What this means is that we don''t specify whether a parameter of an API
    is going to be part of the body or route. For example, in the following code snippet,
    we don''t need to explicitly say that the ID parameter is going to be part of
    the route as `ApiController` automatically uses something known as `[FromRoute]`:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE98]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Similarly, in the following code snippet, `ApiController` will automatically
    add `[FromBody]` based on the inference rules:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE99]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: A couple of other behaviors that `ApiController` adds are inferring request
    content to multipart/form data and more detailed error responses, as per [https://tools.ietf.org/html/rfc7807.](https://tools.ietf.org/html/rfc7807.)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, all in all, `ControllerBase`, `ApiController`, and `ActionResult` provide
    various helper methods and behaviors, thereby providing developers with all the
    tools needed to write RESTful APIs and allowing them to focus on business logic
    while writing APIs using ASP.NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: With this foundation, let's design various APIs for our e-commerce application
    in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Integration with the data layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The response from our APIs may or may not look like our domain models. Instead,
    their structure can resemble the fields that the UI or Views need to bind; hence,
    it is recommended to create a separate set of POCO classes that integrate with
    our UI. These POCOs are known as **Data Transfer Objects** (**DTOs**).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will implement our DTOs' domain logic integrating with the
    data layer and integrate the cache services discussed in [*Chapter 8*](B18507_08_Epub.xhtml#_idTextAnchor714),
    *All You Need to Know about Caching*, using the Cache-Aside pattern, and then—finally—implement
    the required RESTful APIs using controllers and actions. Along the way, we will
    use the `HTTPClient` factory for our service-to-service communication, and the
    `AutoMapper` library for mapping domain models to DTOs.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will pick a product service that is part of `Packt.Ecommerce.Product`, a
    web API project using .NET 6, and discuss its implementation in detail. By the
    end of this section, we will have implemented the projects highlighted in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.7 – Product service and DTOs'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.7_B18507.png)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.7 – Product service and DTOs
  prefs: []
  type: TYPE_NORMAL
- en: 'A similar implementation is replicated across all RESTful services with slight
    modifications in business logic, as required, but the high-level implementation
    remains the same across the following various services:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Packt.Ecommerce.DataAccess`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.Ecommerce.Invoice`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.Ecommerce.Order`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.Ecommerce.Payment`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Packt.Ecommerce.UserManagement`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To start with, we will have the corresponding section in `appsettings.json`,
    which is shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: 'For the local development environment, we will use **Manage User Secrets**
    (as explained at [https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&tabs=windows](https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?view=aspnetcore-6.0&tabs=windows))
    and set the following values. However, once the service is deployed, it will make
    use of Azure Key Vault, as explained in [*Chapter 6*](B18507_06_Epub.xhtml#_idTextAnchor473),
    *Configuration in .NET 6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: Let's begin by creating DTOs for the Products API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating DTOs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The key requirements in terms of product services are to provide the ability
    to search for products, view additional details relating to the products, and
    then proceed with the purchase. Since a listing of products can have limited details,
    let''s create a POCO (all DTOs are created in the `Packt.Ecommerce.DTO.Models`
    project) and name it `ProductListViewModel`. This class will have all the properties
    that we want to show on the product''s list page, and it should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, these are minimum fields that are usually displayed on any
    e-commerce application. Hence, we will go with these fields, but the idea is to
    extend as the application evolves. Here, the `Id` and `Name` properties are important
    properties as those will be used to query the database once the user wants to
    retrieve all further details regarding the product. We are annotating the `Id`
    property with the `JsonProperty(PropertyName = "id")` attribute to ensure that
    the property name remains as `Id` during serialization and deserialization. This
    is important because, in our Cosmos DB instance, we are using `Id` as the key
    for most of the containers. Let''s now create another POCO that represents the
    details of a product, as shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE150]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE151]'
  prefs: []
  type: TYPE_PRE
- en: So, in this DTO, apart from `Id` and `Name`, one of the important properties
    is `Etag`, which will be used for entity tracking to avoid concurrent overwrites
    on an entity. For example, if two users access a product and user A updates it
    before user B, using `Etag`, we can stop user B from overwriting user A's changes
    and force user B to take the latest copy of the product prior to updating. The
    `AddProductAsync(ProductDetailsViewModel product)` method in [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/Controllers](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/Controllers)
    follows this pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Another important aspect is that we are using ASP.NET Core's built-in validation
    attributes on our model to define all constraints on the models. Primarily, we
    will be using the `[Required]` attribute and any relevant attributes, as per [https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-6.0#built-in-attributes](https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation?view=aspnetcore-6.0#built-in-attributes).
  prefs: []
  type: TYPE_NORMAL
- en: All the DTOs would be part of the `Packt.Ecommerce.DTO.Models` project as they
    will be reused in our ASP.NET MVC application, which will be used to build the
    UI of our e-commerce application. Now, let's look at the contracts needed for
    the `Products` service.
  prefs: []
  type: TYPE_NORMAL
- en: Service-class contracts
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Add a `Contracts` folder to `Packt.Ecommerce.Product` and create a contract/interface
    of a product''s service class, for which we will refer to our requirements and
    define methods as needed. To start with, it will have all the methods to perform
    **create, read, update, and delete** (**CRUD**) operations on products based on
    that interface, and these will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE152]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE153]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE154]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE155]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE156]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE157]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE158]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE159]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE160]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE161]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE162]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE163]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE164]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE165]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE166]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that we are returning `Task` in all methods, thereby sticking
    to our asynchronous approach discussed in [*Chapter 4*](B18507_04_Epub.xhtml#_idTextAnchor205),
    *Threading and Asynchronous Operations*.
  prefs: []
  type: TYPE_NORMAL
- en: The mapper class using AutoMapper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The next thing that we will need is a way to transform our domain models to
    DTOs, and here, we will use a well-known library called `AutoMapper` (please refer
    to [https://docs.automapper.org/en/stable/Getting-started.html](https://docs.automapper.org/en/stable/Getting-started.html)
    for more details) to configure and add the following packages:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Automapper`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AutoMapper.Extensions.Microsoft.DependencyInjection`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To configure `AutoMapper`, we need to define a class that inherits from `AutoMapper.Profile`
    and then defines the mapping between various domain models and DTOs. Let''s add
    an `AutoMapperProfile` class to the `Packt.Ecommerce.Product` project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE167]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE168]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE169]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE170]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE171]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE172]'
  prefs: []
  type: TYPE_PRE
- en: '`AutoMapper` comes with many inbuilt methods for mapping, one of these being
    `CreateMap`, which accepts source and destination classes and maps them based
    on the same property names. Any property that does not have the same name can
    be manually mapped using the `ForMember` method. Since `ProductDetailsViewModel`
    has a one-to-one mapping with our domain model, `CreateMap` should be good enough
    for their mapping. For `ProductListViewModel`, we have an additional field, `AverageRating`,
    for which we wanted to calculate the average of all the ratings given for a particular
    product. To keep it simple, we will use the `Average` method from `Linq` and then
    map it to the average rating. For modularization, we will have this in a separate
    method, `MapEntity`, which looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE173]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE174]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE175]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE176]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE177]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE178]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE179]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE180]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE181]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE182]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE183]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE184]'
  prefs: []
  type: TYPE_PRE
- en: Now, modify the constructor to call this method. Refer to [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/AutoMapperProfile.cs](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/services/Packt.Ecommerce.Product/AutoMapperProfile.cs)
    for the complete implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final step involved in setting up `AutoMapper` is to inject it as one of
    the services, for which we will use the `WebApplicationBuilder` object of the
    `Program` class, using the following line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE185]'
  prefs: []
  type: TYPE_PRE
- en: As explained earlier, this will inject the `AutoMapper` library into our API,
    and this will then allow us to inject `AutoMapper` into various services and controllers.
    Let's now look at the configuration of the `HttpClient` factory, which is used
    for calling the data access service.
  prefs: []
  type: TYPE_NORMAL
- en: HttpClient factory for service-to-service calls
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To retrieve data, we must call APIs exposed by our data access service defined
    in `Packt.Ecommerce.DataAccess`. For this, we need a resilient library that can
    effectively use the available sockets, allowing us to define a circuit breaker
    as well as retry/timeout policies. `IHttpClientFactory` is ideal for such scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: One common issue with `HttpClient` is the potential `SocketException` error,
    which happens as `HttpClient` leaves the `HttpClient` as a static/singleton—which
    has its own overheads—while connecting to multiple services. These issues are
    summarized at [https://softwareengineering.stackexchange.com/questions/330364/should-we-create-a-new-single-instance-of-httpclient-for-all-requests](https://softwareengineering.stackexchange.com/questions/330364/should-we-create-a-new-single-instance-of-httpclient-for-all-requests),
    and these are all now addressed by `IhttpClientFactory`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure `IHttpClientFactory`, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Install `Microsoft.Extensions.Http`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We will be configuring `IHttpClientFactory` using typed clients, so add a `Services`
    folder and a `ProductsService` class and inherit them from `IProductService`.
    For now, leave the implementation empty. Now, map `IProductService` and `ProductsService`
    in the `Program` class using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE186]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are defining the timeout for `HttpClient` used by `ProductsService`
    as `5` minutes and additionally configuring a policy for retries and a circuit
    breaker.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a circuit-breaker policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To define these policies, we will use a library called `Polly` (refer to [https://github.com/App-vNext/Polly](https://github.com/App-vNext/Polly)
    for the official documentation), which gives out-of-the-box resiliency and fault-handling
    capabilities. Install the `Microsoft.Extensions.Http.Polly` package and then add
    the following static method to the `Program` class that defines our circuit-breaker
    policy:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE187]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE188]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE189]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE190]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE191]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE192]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are saying that the circuit would be opened if there are 5 failures
    within 30 seconds. A circuit breaker assists in avoiding unnecessary HTTP calls
    where there is a critical failure that cannot be fixed with a retry.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a retry policy
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s add our retry policy, which is a bit smarter compared with the
    standard retries that retire within a specified timeframe. So, we define a policy
    that will affect a retry and HTTP service calls on five occasions, and each retry
    would have a time difference in seconds at a rate of power of two. The code is
    illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add some randomness in terms of the time variation, we will use a `Random`
    class of C# to generate a random number and add it to the time gap. This random
    generation will be as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE193]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE194]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE195]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE196]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE197]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE198]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE199]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE200]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE201]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE202]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE203]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE204]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE205]'
  prefs: []
  type: TYPE_PRE
- en: Here, `retry` is an integer that increments by one with every retry. With this,
    add a static method to the `Program` class that has the preceding logic.
  prefs: []
  type: TYPE_NORMAL
- en: This completes our `HTTPClient` factory configuration, and `ProductsService`
    can use constructor injection to instantiate `IHttpClientFactory`, which can be
    further used to create `HttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: With all this configuration, we can now implement our service class. Let's look
    at that in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing service classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s now implement `ProductsService`, starting by defining various properties
    that we have now built and instantiating them using constructor injections, as
    shown in the following code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE206]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE207]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE208]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE209]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE210]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE211]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE212]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE213]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE214]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE215]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE216]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE217]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE218]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE219]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE220]'
  prefs: []
  type: TYPE_PRE
- en: 'All our services are going to use the same exception-handling middleware we
    defined in this chapter, so during service-to-service calls, if there is a failure
    in another service, the response would be of the `ExceptionResponse` type. Hence,
    let''s create a private method, so deserialize the `ExceptionResponse` class and
    raise it accordingly. This is required because `HttpClient` would represent success
    or failure while using the `IsSuccessStatusCode` and `StatusCode` properties,
    so if there is an exception, we need to check `IsSuccessStatusCode` and rethrow
    it. Let''s call this method `ThrowServiceToServiceErrors` and refer to the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE221]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE222]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE223]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE224]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE225]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now implement the `GetProductsAsync` method, in which we will use `CacheService`
    to retrieve data from the cache, and if it is not available in the cache, we will
    call the data access service using `HttpClient`, and finally map the `Product`
    domain''s model to a DTO and return it asynchronously. The code will look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE226]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE227]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE228]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE229]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE230]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE231]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE232]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE233]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE234]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE235]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE236]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE237]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE238]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE239]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE240]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE241]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE242]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE243]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE244]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE245]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE246]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE247]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE248]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE249]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE250]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE251]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE252]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE253]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE254]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE255]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE256]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE257]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE258]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE259]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE260]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE261]'
  prefs: []
  type: TYPE_PRE
- en: We will follow a similar pattern and implement `AddProductAsync`, `UpdateProductAsync`,
    `GetProductByIdAsync`, and `DeleteProductAsync`. The only difference in each of
    these methods would be to use the relevant `HttpClient` method and handle them
    accordingly. Now that we have our service implemented, let's implement our controller.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing action methods in the controller
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s first inject the service created in the previous section into the ASP.NET
    Core 6 DI container so that we can use constructor injection to create an object
    of `ProductsService`. We will do this in the `Program` class using the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE262]'
  prefs: []
  type: TYPE_PRE
- en: Also, ensure that all the required framework components—such as `ApplicationSettings`,
    `CacheService`, and `AutoMapper`—are configured.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a controller to the `Controllers` folder and name it `ProductsController`
    with the default route as `api/products`, and then add an `IProductService` property
    and inject it using constructor injection. The controller should implement five
    action methods, each calling one of the service methods, and use various out-of-the-box
    helper methods and attributes discussed in *The ControllerBase class, the* *ApiController
    attribute, and the ActionResult class* section of this chapter. The methods for
    retrieving specific products and creating a new product are shown in the following
    code block:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE263]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE264]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE265]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE266]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE267]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE268]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE269]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE270]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE271]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE272]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE273]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE274]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE275]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE276]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE277]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE278]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE279]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE280]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE281]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE282]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE283]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE284]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE285]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE286]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE287]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE288]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE289]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE290]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE291]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE292]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE293]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE294]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE295]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE296]'
  prefs: []
  type: TYPE_PRE
- en: 'The method implementation is self-explanatory and based purely on the fundamentals
    discussed in the *Handling requests using controllers and actions* section of
    this chapter. Similarly, we will implement all the other methods (`Delete`, `Update`,
    and `Get` all products) by calling the corresponding service method and returning
    the relevant `ActionResult`. With that, we will have APIs shown in the following
    table to handle various scenarios related to the product entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Table 10.2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Table_10.2.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Table 10.2
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Another common scenario with APIs is to have an API that supports file upload/download.
    The upload scenario is achieved by passing `IFormFile` as an input parameter to
    the API. This serializes the uploaded file and can also save on the server. Similarly,
    for file downloading, `FileContentResult` is available and can stream files to
    any client. This is left to you as an activity to explore further.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the testing API, we will use Postman ([https://www.postman.com/downloads/](https://www.postman.com/downloads/)).
    All Postman collections can be found under the `Solution Items` folder file, `Mastering
    enterprise application development Book.postman_collection.json`. To import a
    collection once Postman has been installed, perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Postman, and then click on **File**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click `Mastering enterprise application development Book.postman_collection.json`
    file and then click on **Import**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A successful import will show the collection in the **Collections** menu of
    Postman, as depicted in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.8 – Collections in Postman'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.8_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.8 – Collections in Postman
  prefs: []
  type: TYPE_NORMAL
- en: This completes our `Products` RESTful service implementation. All the other
    services mentioned at the beginning of this section are implemented in a similar
    way, where each of them is an individual web API project and handles the relevant
    domain logic for that entity.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding gRPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As per `grpc.io`, gRPC is a high-performance, open source universal RPC framework.
    Originally developed by Google, gRPC uses HTTP/2 for transport and a **Protocol
    Buffer** (**protobuf**) as the interface description language. gRPC is a contract-based
    binary communication system, and it is available across multiple ecosystems. The
    following diagram from gRPC''s official documentation (https://grpc.io) illustrates
    client-server interaction using gRPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.9 – gRPC client-server interaction'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.9_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.9 – gRPC client-server interaction
  prefs: []
  type: TYPE_NORMAL
- en: As with many distributed systems, gRPC is based on the idea of defining a service
    and specifying an interface with methods that can be invoked remotely, along with
    contracts. In gRPC, the server implements the interface and runs the gRPC server
    to handle client calls. The client side has the stub, which provides the same
    interface as defined by the server. The client calls the stub in the same way
    as it invokes methods in any other local object to invoke a method on the server.
  prefs: []
  type: TYPE_NORMAL
- en: By default, data contracts use `.proto` extension. In a protobuf, the data is
    structured as a logical record of the information contained in fields. In the
    upcoming section, we will learn about how to define a protobuf in Visual Studio
    for a .NET 6 application.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the official documentation to learn more about gRPC: [https://grpc.io](https://grpc.io).
    To learn more about protobufs, refer to [https://developers.google.com/protocol-buffers/docs/overview](https://developers.google.com/protocol-buffers/docs/overview).'
  prefs: []
  type: TYPE_NORMAL
- en: Given the benefits of high performance, language-agnostic implementation, and
    reduced network usage associated with the protobuf of gRPC, many teams are exploring
    the use of gRPC in their endeavors to build microservices.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will learn how to build a gRPC server and client in
    .NET 6.
  prefs: []
  type: TYPE_NORMAL
- en: Building a gRPC server in .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'After making its first appearance in .NET Core 3.0, gRPC has become a first-class
    citizen in the .NET ecosystem. Fully managed gRPC implementation is now available
    in .NET. Using Visual Studio 2022 and .NET 6, we can create gRPC server and client
    applications easily. Let''s create a gRPC service using the gRPC service template
    in Visual Studio, shown in the following screenshot, and name it `gRPCDemoService`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 10.10 – gRPC Visual Studio 2022 project template'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.10_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.10 – gRPC Visual Studio 2022 project template
  prefs: []
  type: TYPE_NORMAL
- en: 'This will create a solution with a sample gRPC service named `GreetService`.
    Let''s now understand the solution created with the template. The solution created
    will have a package reference to `Grpc.AspNetCore`. This will have the libraries
    required to host the gRPC service and a code generator for the `.proto` files.
    This solution will have a proto file created for `GreetService` under the `Protos`
    solution folder. The following code defines the `Greeter` service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE297]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE298]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE299]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE300]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Greeter` service has only one method named `SayHello`, which takes the
    input parameter as `HelloRequest` and returns a message of the `HelloReply` type.
    `HelloRequest` and `HelloReply` messages are defined in the same proto file, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE301]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE302]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE303]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE304]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE305]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE306]'
  prefs: []
  type: TYPE_PRE
- en: '`HelloRequest` has one field named `name`, and `HelloReply` has one field named
    `message`. The number next to the field shows the ordinal position of the field
    in the buffer. The proto files are compiled with the `Protobuf` compiler to generate
    stub classes with all the plumbing required. We can specify the kind of stub classes
    to generate from the properties of the proto file. Since this is a server, it
    will have the configuration set to **Server only**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s look at the `GreetService` implementation. This will appear as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE307]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE308]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE309]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE310]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE311]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE312]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE313]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE314]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE315]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE316]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE317]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE318]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE319]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE320]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE321]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE322]'
  prefs: []
  type: TYPE_PRE
- en: '`GreetService` inherits from `Greeter.GreeterBase`, which is generated by the
    protobuf compiler. The `SayHello` method is overridden to provide the implementation
    so as to return a greeting to the caller by constructing `HelloReply`, as defined
    in the proto file.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To expose gRPC services in a .NET 6 application, all the required gRPC services
    are to be added to the service collection by calling `AddGrpc` in the `Program`
    class. The `GreeterService` gRPC service is exposed by calling `MapGrpcService`,
    as illustrated in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE323]'
  prefs: []
  type: TYPE_PRE
- en: That is everything that is required to expose a gRPC service in a .NET 6 application.
    In the next section, we will implement a .NET 6 client to consume `GreeterService`.
  prefs: []
  type: TYPE_NORMAL
- en: Building a gRPC client in .NET
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As specified at the start of this *Understanding gRPC* section, .NET 6 has
    very good tooling for building a gRPC client as well. In this section, we will
    be building a gRPC client in a console application. Here are the steps to follow
    for you to accomplish this:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a .NET 6 console application and name it `gRPCDemoClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, right-click on the project and click on the **Add** | **Service reference…**
    menu items. This will open the **Connected Services** tab, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.11 – gRPC Connected Services tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.11_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.11 – gRPC Connected Services tab
  prefs: []
  type: TYPE_NORMAL
- en: Select **gRPC** in the **Add service reference** dialog, and then click on **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `greet.proto` file from `gRPCDemoService`, and then click on the `Client`
    stub classes:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 10.12 – Adding a gRPC service reference'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_10.12_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 10.12 – Adding a gRPC service reference
  prefs: []
  type: TYPE_NORMAL
- en: This will also add the required `Google.Protobuf`, `Grpc.Net.ClientFactory`,
    and `Grpc.Tools` NuGet packages to the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, add the following code to the `Program` class of the `gRPCDemoClient`
    project:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE324]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this code snippet, we are creating a gRPC channel to the `gRPCDemoService`
    endpoint, and then instantiating `Greeter.GreeterClient`, which is a stub to `gRPCDemoService`,
    by passing in the gRPC channel.
  prefs: []
  type: TYPE_NORMAL
- en: Now, to invoke the service, we just need to call the `SayHelloAsync` method
    on the stub by passing the `HelloRequest` message. This call will return `HelloReply`
    from the service.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Up to now, we have created a simple gRPC service and a console client for that
    service. In the next section, we will learn about `grpcurl`, which is a generic
    client to test gRPC services.
  prefs: []
  type: TYPE_NORMAL
- en: Testing gRPC services
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To test or invoke a REST service, we use tools such as Postman or Fiddler. `grpcurl`
    is a command-line utility that helps us to interact with gRPC services. Using
    `grpcurl`, we can test gRPC services without building client apps. `grpcurl` is
    available for download from [https://github.com/fullstorydev/grpcurl](https://github.com/fullstorydev/grpcurl).
  prefs: []
  type: TYPE_NORMAL
- en: 'Once `grpcurl` is downloaded, we can call `GreeterService` using the following
    command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE325]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Currently, gRPC applications can only be hosted in Azure App Service and **Internet
    Information Services** (**IIS**), hence we did not leverage gRPC in the demo e-commerce
    application that is hosted on Azure App Service. However, there is a version of
    the e-commerce application in this chapter demo, where obtaining a product according
    to its ID is exposed as a gRPC endpoint in a self-hosted service.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basic principles of REST and also designed enterprise-level
    RESTful services for our e-commerce application.
  prefs: []
  type: TYPE_NORMAL
- en: Along the way, we got to grips with the various web API internals of an ASP.NET
    Core 6 web API—including routing and sample middleware—and became familiar with
    tools for testing our services, while learning how to handle requests using a
    controller and its actions, which we also learned to build. Also, we saw how to
    create and test basic gRPC client and server applications in .NET 6\. You should
    now be able to confidently build RESTful services using an ASP.NET Core 6 web
    API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will go through the fundamentals of ASP.NET MVC, build
    our UI layer using ASP.NET MVC, and integrate it with our APIs.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following HTTP verbs is recommended for creating a resource?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `GET`
  prefs: []
  type: TYPE_NORMAL
- en: b. `POST`
  prefs: []
  type: TYPE_NORMAL
- en: c. `DELETE`
  prefs: []
  type: TYPE_NORMAL
- en: d. `PUT`
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following HTTP status codes represents `No Content`?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `200`
  prefs: []
  type: TYPE_NORMAL
- en: b. `201`
  prefs: []
  type: TYPE_NORMAL
- en: c. `202`
  prefs: []
  type: TYPE_NORMAL
- en: d. `204`
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: d**'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following middlewares is used to configure routing?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `UseDeveloperExceptionPage()`
  prefs: []
  type: TYPE_NORMAL
- en: b. `UseHttpsRedirection()`
  prefs: []
  type: TYPE_NORMAL
- en: c. `UseRouting()`
  prefs: []
  type: TYPE_NORMAL
- en: d. `UseAuthorization()`
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: c**'
  prefs: []
  type: TYPE_NORMAL
- en: If a controller is annotated with the `[ApiController]` attribute, do I need
    to class `ModelState.IsValid` explicitly in each action method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. Yes—model validation isn't part of the `ApiController` attribute, hence you
    need to call `ModelState.Valid` in each action method.
  prefs: []
  type: TYPE_NORMAL
- en: b. No—model validation is handled as part of the `ApiController` attribute,
    hence `ModelState.Valid` is triggered automatically for all action items.
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: b**'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/implement-resilient-applications/use-httpclientfactory-to-implement-resilient-http-requests)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/signalr/introduction?view=aspnetcore-6.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/tutorials/web-api-help-pages-using-swagger?view=aspnetcore-6.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/grpc/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/grpc/?view=aspnetcore-6.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/odata/overview](https://docs.microsoft.com/en-us/odata/overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
