<html><head></head><body>
        <section>

                            <header class="header-title chapter-title">
                    Interoperability with Win32 and WinForm
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Hosting WinForm controls in WPF applications</li>
<li>Hosting WPF controls in WinForm applications</li>
<li>Calling Win32 APIs from WPF applications</li>
<li>Embedding ActiveX controls in WPF applications</li>
</ul>
<h1 id="uuid-ec896b77-581e-4c4f-be6c-ca6513f85ca2" class="">Introduction</h1>
<p>The term <strong>interoperability</strong> describes the capability of different applications to exchange data via a common set of exchangeable formats. It is a characteristic of the product or system, whose interfaces are completely understood, to work with other products or systems.</p>
<p>WPF and Windows Forms present two different architectures for creating application interfaces. The <kbd>WindowsFormsHost</kbd> and <kbd>ElementHost</kbd> classes are used to implement the interoperation capabilities between these two.</p>
<p>Similarly, WPF provides interoperability with Win32 programs, which are written in unmanaged C++ code:</p>
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/8a955b43-8436-49ad-a54f-f6832f9ef5d3.png" style=""/></div>
<p>In this chapter, we will start with interoperation between WPF and WinForm, demonstrating the way to host a WinForm control in a WPF application and a WPF control in a WinForm application. Then, we will move forward to learn interoperability between WPF and Win32, followed by embedding ActiveX controls inside WPF.</p>
<h1 id="uuid-79a35db2-826d-4d9e-b596-93d7d4d08434">Hosting WinForm controls in WPF applications</h1>
<p>Though <strong>Windows Platform Foundation</strong> (<strong>WPF</strong>) provides a huge set of controls with a rich set of features, there can still be chances of various cases when you have some <strong>Windows Form</strong> (<strong>WinForm</strong>) controls that are not available in WPF. There could be some cases too, when you are porting your WinForm application to WPF, where you have no other choice than reusing existing controls and/or forms, as the reimplementation will burn huge efforts. So, what needs to be done in such cases?</p>
<p>WPF provides a way to reuse existing controls from Windows Forms and host them inside it (whether in a control, a window, or a page). This is called interoperation between the two platforms as they present two different architectures for creating application interfaces.</p>
<p>The <kbd>System.Windows.Forms.Integration</kbd> namespace provides you with the classes that enable the common interoperation scenarios, whereas the <kbd>WindowsFormsHost</kbd> class provides you with the capability to implement the interoperation.</p>
<p>When implementing interoperation between the two technologies to host a Windows Forms control inside WPF, the following scenarios may occur applicable:</p>
<ul>
<li>One or more WinForm controls can be hosted in WPF</li>
<li>One or more composite controls can be hosted in a WPF element</li>
<li>One or more ActiveX controls can also be hosted in WPF</li>
<li>The WinForm container controls containing other WinForm controls can also be hosted</li>
<li>You can also host a master/detail form with WPF as master, WinForm as details, and/or WinForm as master, and WPF as details</li>
</ul>
<div class="packt_infobox">A point to note is that multilevel hybrid controls are not supported. A <strong>multilevel hybrid control</strong> contains a control from one technology inside a control from another technology.</div>
<p>In this recipe, we will take WinForm's <kbd>PropertyGrid</kbd> control as an example, which is not available in WPF, and will host it inside a WPF window using the <kbd>WindowsFormsHost</kbd> control.</p>
<h2 id="uuid-05e39110-4586-4b54-9812-a425e4e29d8c">Getting ready</h2>
<p>Let's start by creating a new WPF application. Open your Visual Studio IDE, and create a new project named <kbd>CH11.WinFormInWpfXamlDemo</kbd>. Make sure to select <span class="packt_screen">WPF App</span> as the project template.</p>
<h2 id="uuid-efcdccf0-37d6-4c77-bf89-9b1834ca5abd">How to do it...</h2>
<p>Follow these steps to host a WinForm control inside a WPF application window and map its properties:</p>
<ol>
<li>Begin with opening the WPF application window. From <span class="packt_screen">Solution Explorer</span>, open the <kbd>MainWindow.xaml</kbd> file.</li>
</ol>
<p> </p>
<ol start="2">
<li>Let's split the default <kbd>Grid</kbd> panel to have two columns. The second column will have a width based on its child elements, and the first column will accommodate the rest of the space. Add the following XAML mark-up inside <kbd>Grid</kbd> to split it by the specific requirement:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid.ColumnDefinitions&gt; 
    &lt;ColumnDefinition Width="*"/&gt; 
    &lt;ColumnDefinition Width="Auto"/&gt; 
&lt;/Grid.ColumnDefinitions&gt; </pre>
<ol start="3">
<li>Place a <kbd>TextBlock</kbd> control inside the first cell (0<sup>th</sup> column) of <kbd>Grid</kbd>, name it as <kbd>txtBlock</kbd>, and set <kbd>Hello World!</kbd> as its <kbd>Text</kbd> property:</li>
</ol>
<pre style="padding-left: 90px">&lt;TextBlock x:Name="txtBlock" 
           Grid.Column="0" 
           Margin="8" 
           Text="Hello World!"/&gt; </pre>
<ol start="4">
<li>Now, after the <kbd>TextBlock</kbd> control, add a <kbd>&lt;WindowsFormsHost&gt; &lt;/WindowsFormsHost&gt;</kbd> element. When added, this will throw the following design-time error message—<span class="packt_screen">WindowsFormsHost is not supported in a Windows Presentation Foundation (WPF) project</span>. This is because the required assembly to resolve the <kbd>WindowsFormsHost</kbd> element is not referenced in this project:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ad6839aa-df5f-4164-8fc9-085f7bb081cb.png" style=""/></div>
<ol start="5">
<li>To add the dependent assembly references in the project, right-click on the project node and select <span class="packt_screen">Add</span> | <span class="packt_screen">Reference...</span> from the context menu entries.</li>
<li>From the <span class="packt_screen">Reference Manager</span> dialog window, check the following two assembly references (<span class="packt_screen">System.Windows.Forms</span> and <span class="packt_screen">WindowsFormsIntegration</span>) and click <span class="packt_screen">OK</span>, which will add the references in the project:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/fa791620-0266-4ab1-87b6-6ead98c6e89f.png" style=""/></div>
<ol start="7">
<li>Check the XAML file now. The preceding design-time error will now go away, as the required assembly reference has been established.</li>
<li>Position the <kbd>&lt;WindowsFormsHost&gt;</kbd> in the second column (<kbd>Grid.Column="1"</kbd>) and set its <kbd>Width</kbd> property to <kbd>300</kbd>.</li>
<li>Now, inside the <kbd>WindowsFormsHost</kbd> element, place another element of type <kbd>PropertyGrid</kbd>.</li>
</ol>
<p> </p>
<ol start="10">
<li>You need to add the XMLNS namespace for the <kbd>PropertyGrid</kbd> to resolve from the <kbd>System.Windows.Forms</kbd> assembly. As shown in the following screenshot, click the lightbulb icon, or simply press <em><span class="KeyPACKT">CTRL</span> +</em> to add the required XMLNS entry to the <kbd>MainWindow.xaml</kbd> file:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/8c81326c-b495-4a67-a651-228715a18d0b.png"/></div>
<ol start="11">
<li>Alternatively, you can add the following XMLNS declaration to the <kbd>Window</kbd> tag:</li>
</ol>
<pre style="padding-left: 90px">xmlns:forms="clr-namespace:System.Windows.Forms; 
             assembly=System.Windows.Forms" </pre>
<ol start="12">
<li>Add <kbd>x:Name="propertyGrid"</kbd> to the <kbd>PropertyGrid</kbd> element to define it with a name. This will be useful later when we want to access it from the code. Here's the complete XAML markup of the <kbd>Grid</kbd> that we will be using here:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;Grid.ColumnDefinitions&gt; 
        &lt;ColumnDefinition Width="*"/&gt; 
        &lt;ColumnDefinition Width="Auto"/&gt; 
    &lt;/Grid.ColumnDefinitions&gt; 
    &lt;TextBlock x:Name="txtBlock" 
               Grid.Column="0" 
               Margin="8" 
               Text="Hello World!"/&gt; 
    &lt;WindowsFormsHost Width="300" 
                      Grid.Column="1"&gt; 
        &lt;forms:PropertyGrid x:Name="propertyGrid"/&gt; 
    &lt;/WindowsFormsHost&gt; 
&lt;/Grid&gt;</pre>
<ol start="13">
<li>Once done, let's run the application. You will see the following output, having text and an empty property grid:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/dedc978f-07d7-4a35-a9f9-121cd026d1b9.png" style=""/></div>
<ol start="14">
<li>Let's navigate to the code behind file (<kbd>MainWindow.xaml.cs</kbd>) of the application window.</li>
<li>Just after the <kbd>InitializeComponent()</kbd> call inside the constructor of <kbd>MainWindow</kbd>, add the following line, <kbd>propertyGrid.SelectedObject = txtBlock;</kbd>, to set the <kbd>SelectionObject</kbd> property of the property grid that we have already added in the UI. After this change, the code will look as follows:</li>
</ol>
<pre style="padding-left: 90px">public partial class MainWindow : Window 
{ 
    public MainWindow() 
    { 
        InitializeComponent(); 
 
        propertyGrid.SelectedObject = txtBlock; 
    } 
}</pre>
<ol start="16">
<li>Let's run the application again. This time you will see that the property grid contains a set of properties, pointing to the <kbd>txtBlock</kbd> control placed in the window:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/40af7fae-9137-4880-8fd5-af19c60a5bfa.png" style=""/></div>
<ol start="17">
<li>Scroll up the property grid and change the <span class="packt_screen">FontSize</span> property inside the grid to <kbd>40</kbd>. This will have immediate effect to the font-size of the text that we have added in the UI:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/06b8a6e8-b9ae-4102-a59a-08fc1ce367be.png" style=""/></div>
<ol start="18">
<li>Similarly, change some other properties such as <span class="packt_screen">HorizontalAlignment</span>, <span class="packt_screen">VerticalAlignment</span>, <span class="packt_screen">FontStyle</span>, <span class="packt_screen">FontWeight</span>, <span class="packt_screen">Foreground</span>, and so on, and see the effect on the screen:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/41f289b2-2629-4ce7-abfb-834d1d555a24.png" style=""/></div>
</li>
</ol>
<h2 id="uuid-d71735e8-5359-4ce4-8a75-0821adf583a1">How it works...</h2>
<p>The <kbd>PropertyGrid</kbd> control, part of the .NET Framework, allows you to browse, view, and edit the properties of one or more objects. It uses reflection to retrieve and display properties of any object or type.</p>
<div class="packt_infobox"><strong>Reflection</strong> is a technology that allows you to retrieve the type information at runtime.</div>
<p>If you are using WinForm, you will be able to use the <kbd>PropertyGrid</kbd> control easily from the control toolbar. But, unfortunately, this control is not available in WPF. To use this inside a WPF application, you will need to use the interoperability of WPF and WinForm. For this to work, we need to use the <kbd>WindowsFormsHost</kbd> class.</p>
<p>The <kbd>WindowsFormsHost</kbd> class allows you to host a Windows Forms control on a WPF page. It is part of the <kbd>System.Windows.Forms.Integration</kbd> namespace and it is available inside the <kbd>WindowsFormsIntegration.dll</kbd> assembly. That's the reason why we had to reference the <kbd>System.Windows.Forms</kbd> and <kbd>WindowsFormsIntegration</kbd> assemblies inside the project.</p>
<div class="packt_infobox">The default location for the <kbd>WindowsFormsIntegration.dll</kbd> assembly is <kbd>%programfiles%Reference AssembliesMicrosoftFrameworkv3.0</kbd>, which comes with the other WPF assemblies.</div>
<p>Once the hosting of the WinForm control is successful inside a WPF window, you can then set/get its properties. In the preceding example, we assigned the <kbd>txtBlock</kbd> control (which is a WPF control) as the <kbd>SelectedObject</kbd> property of the <kbd>propertyGrid</kbd> control (which is a WinForm control). Thus, when you run the application, it uses reflection to retrieve all the properties exposed by the <kbd>TextBlock</kbd> control (<kbd>txtBlock</kbd>) and populates those inside the <kbd>PropertyGrid</kbd> with the default values set to each one of them. When you modify a property value at runtime, it changes the associated control based on the selection. Hence, you can see a change in the UI of <kbd>TextBlock</kbd>, when you change the <kbd>FontSize</kbd>, <kbd>Foreground</kbd>, and other properties.</p>
<h2 id="uuid-174e99c8-25b8-4018-afd3-b9f7eee9febf">There's more...</h2>
<p>Though most of the properties work with <kbd>WindowsFormsHost</kbd>, there are some limitations with <strong>z-order</strong> and transformations when used in a hybrid application. By default, the <kbd>WindowsFormsHost</kbd> elements are drawn on top of other WPF elements, and thus there exists no-effect of the z-order property on that.</p>
<p>If you want to enable z-ordering, set the <kbd>IsRedirected</kbd> property of the <kbd>WindowsFormsHost</kbd> to <kbd>True</kbd>, and the <kbd>CompositionMode</kbd> property to either <kbd>CompositionMode.Full</kbd> or <kbd>CompositionMode.OutputOnly</kbd>.</p>
<p>As the WinForm controls do not support proper scaling and rotating features, the <kbd>WindowsFormsHost</kbd> element does not scale or rotate with other WPF elements. To enable these transforming features, such as z-ordering, set the <kbd>IsRedirected</kbd> property to <kbd>True</kbd> and the <kbd>CompositionMode</kbd> property to either <kbd>CompositionMode.Full</kbd> or <kbd>CompositionMode.OutputOnly</kbd>.</p>
<h1 id="uuid-a1440aaa-2a0c-49fe-bee1-c423fe958d55">Hosting WPF controls in WinForm applications</h1>
<p>As WPF provides a rich user interface to applications, you may want to apply the same to your existing applications. But when you have a large Windows Form application project, where you already made a large investment, you won't like to reinvest on the same to scrap it and rewrite the entire project in WPF.</p>
<p>In such cases, WPF interoperation with WinForms is ideal. Using this, you can embed a WPF control inside a form and leverage the additional features of WPF, wherever possible.</p>
<p>In the previous recipe, we learned how to host WinForm controls into a WPF application. But in this recipe, we will learn the reverse, that is, how to host a <strong>WPF composite control</strong> in a <strong>Windows Forms</strong> application. We will learn this by following some simple walkthrough steps. You can extend this procedure later to host more complex applications and controls.</p>
<p>This walkthrough will basically be divided into two logical parts. In the first part, we will build a WPF UserControl, and in the second part, we will host it inside a form window.</p>
<h2 id="uuid-fac98162-275d-443b-a385-4898934ec1d4">Getting ready</h2>
<p>Before we start with this recipe to host a WPF control in a Windows Form, make sure that Visual Studio is up and running.</p>
<h2 id="uuid-a1a7fd33-cee9-4786-9e98-21044cfac286">How to do it...</h2>
<p>Let's follow these steps to create a WPF composite control and host it inside the Windows Form:</p>
<ol>
<li>First, let's create a <strong>WPF User Control Library</strong> project. To do this, from <span class="packt_screen">Solution Explorer</span>, right-click on the existing solution and select <span class="packt_screen">Add</span> | <span class="packt_screen">New Project...</span> from the context menu.</li>
</ol>
<p> </p>
<ol start="2">
<li>Select <span class="packt_screen">WPF User Control Library (.NET Framework)</span> as the project template, name it as <kbd>CH11.WpfUserControlLibrary</kbd>, and click the <span class="packt_screen">OK</span> button, as shown in the following screenshot:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/d503d6b6-8e16-4829-9585-75f93348ee2a.png"/></div>
<ol start="3">
<li>Once the project gets created by Visual Studio, you will find a user control named <kbd>UserControl1.xaml</kbd>, inside the project folder. From <span class="packt_screen">Solution Explorer</span>, double-click on it to open it.</li>
<li>Divide the default <kbd>Grid</kbd> of the <kbd>UserControl1</kbd> into two columns. Set the first column as stretchable to occupy maximum available space and set the second column as <kbd>Auto</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid.ColumnDefinitions&gt; 
    &lt;ColumnDefinition Width="*"/&gt; 
    &lt;ColumnDefinition Width="Auto"/&gt; 
&lt;/Grid.ColumnDefinitions&gt; </pre>
<ol start="5">
<li>Place a <kbd>TextBox</kbd> control inside the first column and name it as <kbd>searchBox</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;TextBox x:Name="searchBox" 
         Grid.Column="0" 
         MinWidth="100" 
         Margin="4"/&gt;</pre>
<ol start="6">
<li>Place a <kbd>Button</kbd> control, named <kbd>searchButton</kbd>, and place it inside the second column of the <kbd>Grid</kbd>. Set its <kbd>Content</kbd> property to <span class="packt_screen">Search</span> and register its <kbd>Click</kbd> event with <kbd>OnSearchButtonClicked</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Button x:Name="searchButton" 
        Content="Search" 
        Grid.Column="1" 
        Padding="8 2" 
        Margin="4" 
        Click="OnSearchButtonClicked"/&gt; </pre>
<ol start="7">
<li>Here's the complete XAML of <kbd>Grid</kbd>:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;Grid.ColumnDefinitions&gt; 
        &lt;ColumnDefinition Width="*"/&gt; 
        &lt;ColumnDefinition Width="Auto"/&gt; 
    &lt;/Grid.ColumnDefinitions&gt; 
 
    &lt;TextBox x:Name="searchBox" 
             Grid.Column="0" 
             MinWidth="100" 
             Margin="4"/&gt; 
    &lt;Button x:Name="searchButton" 
            Content="Search" 
            Grid.Column="1" 
            Padding="8 2" 
            Margin="4" 
            Click="OnSearchButtonClicked"/&gt; 
&lt;/Grid&gt; </pre>
<ol start="8">
<li>Now, press <em><span class="KeyPACKT">F7</span></em> to navigate to the code behind the <kbd>UserControl1.xaml.cs</kbd> file.</li>
<li>Insert the following event implementation inside the class:</li>
</ol>
<pre style="padding-left: 90px">private void OnSearchButtonClicked(object sender,  
                                   RoutedEventArgs e) 
{ 
    MessageBox.Show("You searched for: {" +  
                     searchBox.Text + "}"); 
}</pre>
<ol start="10">
<li>Now, it's time to integrate the created user control inside a Windows Form. For this, we need a WinForm project. Let's add the new project inside the solution. To do this, from <span class="packt_screen">Solution Explorer</span>, right-click on the solution file and select <span class="packt_screen">Add</span> | <span class="packt_screen">New Project...</span> from the context menu. Use the following <span class="packt_screen">Windows Forms App (.NET Framework)</span> template during project creation. Name it as <kbd>CH11.WpfInWinFormDemo</kbd> and click the <span class="packt_screen">OK</span> button:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img src="assets/93863ea5-9950-4f1a-a495-ca0c8b9bc5e4.png"/></div>
<ol start="11">
<li>Once the project gets created, you need to add the reference of the UserControl Library into this project. To do so, right-click on the <span class="packt_screen">References</span> node of the <kbd>CH11.WpfInWinFormDemo</kbd> project and then click <span class="packt_screen">Add Reference...</span> from the context menu.</li>
</ol>
<p> </p>
<ol start="12">
<li>From the <span class="packt_screen">Reference Manager</span> dialog, as shown in the following screenshot, expand the <span class="packt_screen">Projects</span> entry, select the desired library project (in our case, it is <span class="packt_screen">CH11.WpfUserControlLibrary</span>), and click <span class="packt_screen">OK</span>. This will add the reference of the library into the project:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3f3fab58-6c54-4f50-af77-3a04b9b3bfe7.png"/></div>
<ol start="13">
<li>Also, add the following assembly references—<kbd>PresentationCore</kbd>, <kbd>PresentationFramework</kbd>, <kbd>System.Xaml</kbd>, <kbd>WindowsBase</kbd>, and <kbd>WindowsFormsIntegration</kbd> inside the project. These are required to use WPF controls and host them.</li>
<li>Rebuild the solution and make sure that the solution is building without any errors. This step also ensures that the library project gets compiled and becomes discoverable in the main project.</li>
<li>From <span class="packt_screen">Solution Explorer</span>, double-click on the <kbd>Form1.cs</kbd> file to open it.</li>
</ol>
<p> </p>
<ol start="16">
<li>Now, open the <span class="packt_screen">Toolbox</span>, and as shown in the following screenshot, drag the <span class="packt_screen">ElementHost</span> element to the form (<kbd>Form1.cs</kbd>), from the <span class="packt_screen">WPF Interoperability</span> section:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/56707bef-7d48-49df-a0ed-6775ede02851.png" style=""/></div>
<ol start="17">
<li>Expand the small arrow-head of the <kbd>ElementHost</kbd> element to select the hosted content. As shown in the following screenshot, click on the <span class="packt_screen">Select Hosted Content</span> combo and select <span class="packt_screen">UserControl1</span> to host inside it:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/790bf580-b88a-4f97-a0f4-610b7444a53a.png" style=""/></div>
<ol start="18">
<li>Alternatively, you can also drag <span class="packt_screen">UserControl1</span> from the toolbox. In this case, Visual Studio will add the <kbd>ElementHost</kbd> and configure it to load the UserControl that you have dragged to the form. Once done, resize the control and position it inside the form:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f7cb1f72-94f8-4bb4-8657-0a2f1cba0ac8.png" style=""/></div>
<ol start="19">
<li>Now rebuild the solution again and run the form application (<kbd>CH11.WpfInWinFormDemo</kbd>). You will see a form window on the screen, containing the WPF UserControl that we have created. It basically consists of a <kbd>TextBox</kbd> and a <kbd>Button</kbd>.</li>
<li>Enter some text in the search box and click the button. You will see the message box pop up on the screen, containing the text that you have entered:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a0e2448a-1224-40bb-86e5-fe80394dc819.png" style=""/></div>
<h2 id="uuid-a339a3cc-aaf7-4356-bd2d-2716b62ffe6a">How it works...</h2>
<p>To host the <strong>WPF composite control</strong>, the <kbd>ElementHost</kbd> object is used inside the Windows Forms host application. The <kbd>ElementHost</kbd> class is part of the <kbd>System.Windows.Forms.Integration</kbd> namespace, and thus you will need to reference the <kbd>WindowsFormsIntegration.dll</kbd> in the project.</p>
<p>To host a WPF element in a Windows Form, you must assign it to the <kbd>Child</kbd> property of the <kbd>ElementHost</kbd> control. If it is required, use the <kbd>PropertyMap</kbd> property to assign the custom mappings between an <kbd>ElementHost</kbd> and its hosted WPF element. Optionally, you can use the boolean <kbd>BackColorTransparent</kbd> property to set a transparent background to the hosted element.</p>
<h1 id="uuid-e2b80087-622a-44bd-b02d-5d9c46675950">Calling Win32 APIs from WPF applications</h1>
<p>Windows Presentation Foundation and Win32 interpolation can work as different approaches. You can either host a Win32 application in a WPF application, a WPF application in a Win32 application, or call a Win32 API from WPF by importing the specified system DLL. These are often useful when you have already invested a lot in Win32 applications and now you would like to build a rich WPF application by utilizing the existing code.</p>
<p>In this recipe, we will learn how to call a Win32 API from a WPF. We will use a simple example to launch a browser window and then activate/refresh the browser window from our WPF code.</p>
<h2 id="uuid-0e3b2f90-f77a-468b-bfdf-bcdeaba741ba">Getting ready</h2>
<p>Get started by creating a WPF application. Open your Visual Studio IDE, and create a new project named <kbd>CH11.Win32ApiCallDemo</kbd>. Make sure to select <span class="packt_screen">WPF App (.NET Framework)</span> as the project template.</p>
<h2 id="uuid-a620efe7-36b4-4781-9d23-0fe11aabe783">How to do it...</h2>
<p>Follow these steps to give a call to Win32 APIs from WPF applications:</p>
<ol>
<li>First, we need to set up the project. Once the project gets created by Visual Studio, right-click on the <span class="packt_screen">References</span> node of the project.</li>
<li>Select the context menu entry <span class="packt_screen">Add Reference...</span> to add assembly references.</li>
</ol>
<p> </p>
<ol start="3">
<li>From the <span class="packt_screen">Reference Manager</span> dialog, search for <span class="packt_screen">forms</span>, and select <span class="packt_screen">System.Windows.Forms</span> from the list. Click <span class="packt_screen">OK</span> to add the reference:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/527e8f84-db19-4208-ada0-bf771ca78cdc.png"/></div>
<ol start="4">
<li>Now, from <span class="packt_screen">Solution Explorer</span>, navigate to the <kbd>MainWindow.xaml</kbd> file.</li>
<li>Replace the existing <kbd>Grid</kbd> panel with the following markup, which contains a <kbd>TextBox</kbd> (<kbd>address</kbd>) and three <kbd>Button</kbd> controls (<kbd>goButton</kbd>, <kbd>bringToFrontButton</kbd>, and <kbd>refreshButton</kbd>):</li>
</ol>
<pre style="padding-left: 90px">&lt;StackPanel Margin="10"&gt; 
    &lt;TextBlock Text="Enter website URL:" 
               Foreground="Gray" 
               Margin="4 0"/&gt; 
 
    &lt;StackPanel Orientation="Horizontal"&gt; 
        &lt;TextBox x:Name="address" 
                 Text="http://www.kunal-chowdhury.com" 
                 Width="250" 
                 Margin="4"/&gt; 
 
        &lt;Button x:Name="goButton" 
                Content="Go..." 
                Padding="8 2" 
                Margin="4" 
                Click="OnGoClicked"/&gt; 
 
        &lt;Button x:Name="bringToFrontButton" 
                Content="BringToFront" 
                Padding="8 2" 
                Margin="4" 
                Click="OnBringToFrontClicked"/&gt; 
 
        &lt;Button x:Name="refreshButton" 
                Content="Refresh" 
                Padding="8 2" 
                Margin="4" 
                Click="OnRefreshClicked"/&gt; 
    &lt;/StackPanel&gt; 
&lt;/StackPanel&gt; </pre>
<ol start="6">
<li>Once the UI is ready, it's time to create the button click event implementations. Press <em><span class="KeyPACKT">F7</span></em> within the XAML page to navigate to its code behind. Alternatively, you can open the <kbd>MainWindow.xaml.cs</kbd> file from <span class="packt_screen">Solution Explorer</span>.</li>
<li>In the code behind the file, add the following namespaces:</li>
</ol>
<pre style="padding-left: 90px">using System; 
using System.Diagnostics; 
using System.Runtime.InteropServices; 
using System.Windows; 
using System.Windows.Forms; </pre>
<ol start="8">
<li>Now, inside the <kbd>MainWindow</kbd> class, add the following declarations and make sure that the <kbd>DllImport</kbd> attribute and the <kbd>Process</kbd> class are discoverable:</li>
</ol>
<pre style="padding-left: 90px">[DllImport("User32.dll")] 
static extern int SetForegroundWindow(IntPtr hWnd); 
 
private static Process process = new Process(); </pre>
<ol start="9">
<li>Let's implement the <kbd>OnGoClicked</kbd> event handler. Copy the following code to launch Internet Explorer with the specified URL address, which is <kbd>http://www.kunal-chowdhury.com</kbd> in our case:</li>
</ol>
<pre style="padding-left: 90px">private void OnGoClicked(object sender,  
 RoutedEventArgs e) 
{ 
    goButton.IsEnabled = false; 
    process.StartInfo.FileName = "iexplore.exe"; 
    process.StartInfo.Arguments = address.Text; 
    process.Start(); 
}</pre>
<ol start="10">
<li>Let's implement the <kbd>OnBringToFrontClicked</kbd> event handler to bring the launched Internet Explorer window to the front, if it lost its focus. Copy the following code to get the <kbd>MainWindowHandle</kbd> of the process instance and call the Win32 API method, <kbd>SetForegroundWindow</kbd>:</li>
</ol>
<pre style="padding-left: 90px">private void OnBringToFrontClicked(object sender,  
 RoutedEventArgs e) 
{ 
    if (process != null) 
    { 
        var ptr = process.MainWindowHandle; 
        SetForegroundWindow(ptr); 
    } 
} </pre>
<ol start="11">
<li>Now, let's add the event implementation of the <span class="packt_screen">Refresh</span> button. Add the following <kbd>OnRefreshClicked</kbd> handler inside the class file to activate the Internet Explorer window and then call the <em><span class="KeyPACKT">F5</span></em> key of the keyboard to refresh the said browser window:</li>
</ol>
<pre style="padding-left: 90px">private void OnRefreshClicked(object sender,  
 RoutedEventArgs e) 
{ 
    if (process != null) 
    { 
        IntPtr ptr = process.MainWindowHandle; 
        SetForegroundWindow(ptr); 
        SendKeys.SendWait("{F5}"); 
    } 
} </pre>
<ol start="12">
<li>As the code implementation is done, let's run the application. You will see the following UI on the screen:
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/6187bcb6-2f5c-4a23-bf9d-e1f2e6405b5c.png" style=""/></div>
</li>
<li>As the address field of the application is already populated, click on the <span class="packt_screen">Go...</span> button. This will launch Internet Explorer and will navigate to the address specified:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/b8b57c2c-0eda-402e-9fdf-d3b434e03db9.png"/></div>
<ol start="14">
<li>Now, click on the application window. This will bring the application to the front.</li>
<li>Now click the <span class="packt_screen">BringToFront</span> button, which will activate Internet Explorer and bring it to the front.</li>
</ol>
<p> </p>
<ol start="16">
<li>Similarly, click on the application window, and then click on the <span class="packt_screen">Refresh</span> button. This time, Internet Explorer will activate and refresh the content of the window:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/f86b8888-e7a2-486c-9f13-70f57861c619.png"/></div>
<h2 id="uuid-f65a069c-0f1e-4a01-a1fc-b275c8ad49fd">How it works...</h2>
<p>When you click the <span class="packt_screen">Go...</span> button of the application window, this creates the new process of the Internet Explorer (<kbd>iexplore.exe</kbd>) window and opens the URL specified to the process as its <kbd>Arguments</kbd>, once we call the <kbd>process.Start()</kbd> method.</p>
<p>When you click the <span class="packt_screen">BringToFront</span> button, it retrieves the handle of the main window of the process and passes it as parameter to the <kbd>SetForegroundWindow</kbd> Win32 API method. The said API method brings the thread into the foreground and activates the window.</p>
<div class="packt_infobox">A process can set the foreground window only if one of the following conditions is satisfied:<br/>
<ul>
<li>The process itself is a foreground process</li>
<li>It was started by a foreground process</li>
<li>The process is being debugged</li>
<li>The foreground process is not a Modern Application or the Start screen</li>
<li>No menus are active</li>
</ul>
</div>
<p>The <kbd>DllImport</kbd> attribute indicates that the attributed method is exposed by an unmanaged <strong>dynamic-link library</strong> (<strong>DLL</strong>) as a static entry point. In our case, it's the <kbd>User32.dll</kbd> file.</p>
<p>When you click on the <span class="packt_screen">Refresh</span> button, just like the <span class="packt_screen">BringToFront</span> button, it first activates the Internet Explorer window by bringing it to the front. The keyboard input is then being directed to the window.</p>
<div class="packt_infobox">Note that an application can't force a window to the foreground if the user is working on another window. In this case, the window will flash in the task bar to notify the user.</div>
<p>The <kbd>SendKeys.SendWait("{F5}")</kbd> method call sends the given key (<em><span class="KeyPACKT">F5</span></em>, in our case) to the active application, and then waits for the messages to be processed. As we have passed the <em><span class="KeyPACKT">F5</span></em> key here, it will call the <kbd>refresh</kbd> method of the browser. Make sure that <kbd>System.Windows.Forms</kbd> is properly referenced in the project, for the <kbd>SendKeys.SendWait</kbd> method to work.</p>
<h1 id="uuid-32f3d84b-09f3-4cb2-99fa-683529b0fef6">Embedding ActiveX controls in WPF applications</h1>
<p>WPF also supports <strong>ActiveX</strong>, which you can easily embed in a WPF application. This is not feature specific to WPF, but it works because of interoperability with Windows Forms. The WinForm acts as an intermediate layer between the two.</p>
<p>There are several ActiveX controls present, which can be easily embedded in any WPF application. In this recipe, we will learn how to embed an ActiveX control by following some simple steps. We will demonstrate it using the <strong>Microsoft Terminal Services Control</strong> that ships with Windows.</p>
<h2 id="uuid-1d0f43a8-f57f-489d-a1b9-e299c5c67cad">Getting ready</h2>
<p>Make sure Visual Studio is up and running. Create a new WPF project and name it as <kbd>CH11.ActiveXDemo</kbd>.</p>
<h2 id="uuid-6a27ad47-d16e-4f1b-8723-5a67fcaab8de">How to do it...</h2>
<p>Follow these steps to generate the required libraries for the <strong>Microsoft Terminal Services ActiveX</strong> control and embed it inside our WPF application:</p>
<ol>
<li>The first step is to generate the required libraries of our ActiveX control. This is required to get a managed and Windows Forms compatible definition of the relevant type. To do this, open <strong>Visual Studio Developer Command Prompt</strong> and navigate to an empty folder (let's say, <kbd>D:libs</kbd>).</li>
<li>Now, in the Command Prompt, enter the following command to generate the managed definitions of the Terminal Service DLL:</li>
</ol>
<pre style="padding-left: 90px">  <strong>aximp c:WindowsSystem32mstscax.dll</strong>  </pre>
<ol start="3">
<li>This will generate two DLL files, named <kbd>MSTSCLib.dll</kbd> and <kbd>AxMSTSCLib.dll</kbd>, in the same folder (<kbd>D:libs</kbd>, in our case):
<div class="packt_figure CDPAlignCenter CDPAlign"><img src="assets/7c71dc2d-ae3a-4cc3-a80b-9c3dee2c8e61.png" style=""/></div>
</li>
<li>Let's copy those DLLs in our project folder. Create a folder named <kbd>libs</kbd>, inside the root folder of our project, and copy both files there.</li>
</ol>
<p> </p>
<ol start="5">
<li>Now, add the references of those binaries into our project. Navigate back to Visual Studio, and from <span class="packt_screen">Solution Explorer</span>, right-click on the <span class="packt_screen">References</span> node. Then, click <span class="packt_screen">Add Reference...</span> from the context menu.</li>
<li>From the <span class="packt_screen">Reference Manager</span> dialog window, click <span class="packt_screen">Browse...</span> to add the references.</li>
<li>Select both <span class="packt_screen">MSTSCLib.dll</span> and <span class="packt_screen">AxMSTSCLib.dll</span>, as shown in the following screenshot and click <span class="packt_screen">Add</span>, which will add the selection to the <span class="packt_screen">Reference Manager</span>:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7f1cbf53-5796-4072-9867-92105f2914ea.png" style=""/></div>
<ol start="8">
<li>Search for <kbd>forms</kbd>, inside the <span class="packt_screen">Reference Manager</span> dialog, and select <span class="packt_screen">System.Windows.Forms</span> and <span class="packt_screen">WindowsFormsIntegration</span> dlls.</li>
<li>Click <span class="packt_screen">OK</span> to confirm adding the references of the four assembly files.</li>
<li>Now open the <kbd>MainWindow.xaml</kbd> file and add the following XMLNS attribute to it:</li>
</ol>
<pre style="padding-left: 90px"/>
<ol start="11">
<li>Replace the existing <kbd>Grid</kbd> panel with the following markup:</li>
</ol>
<pre style="padding-left: 90px">&lt;Grid&gt; 
    &lt;WindowsFormsHost&gt; 
        &lt;lib:AxMsTscAxNotSafeForScripting  
                         x:Name="terminal" 
                         Height="500" Width="1000"/&gt; 
    &lt;/WindowsFormsHost&gt; 
&lt;/Grid&gt; </pre>
<ol start="12">
<li>Go to the code behind the file by pressing the <em><span class="KeyPACKT">F7</span></em> key. Alternatively, you can open <kbd>MainWindow.xaml.cs</kbd> from <span class="packt_screen">Solution Explorer</span>.</li>
<li>Inside the constructor of the <kbd>MainWindow</kbd> class, add the following, just after the <kbd>InitializeComponent()</kbd> method call, and replace the IP with the one that you want to connect:</li>
</ol>
<pre style="padding-left: 90px">terminal.Server = "192.168.0.10"; 
terminal.Connect(); </pre>
<ol start="14">
<li>Now, run the application. You will see the terminal host launched in our WPF application embedded inside it, and pointing to the remote machine for which the IP address has been provided as the <kbd>terminal.Server</kbd> name. Here's how the application will look:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ec435514-a923-4d63-bc81-b847b8288be8.png"/></div>
<ol start="15">
<li>Within that application window, you can now log in to the system and access the desktop, files, and programs remotely.</li>
</ol>
<h2 id="uuid-4a5e57e3-76c7-41a8-98e1-0c75967e5eb9">How it works...</h2>
<p>The ActiveX DLL for <strong>Microsoft Terminal Services</strong> (the <kbd>mstscax.dll</kbd> file) resides in the <kbd>%WINDIR%System32</kbd> directory. The <strong>ActiveX Importer</strong> (<kbd>AXIMP.EXE</kbd>), which is part of the <strong>.NET Framework component</strong> of the Windows SDK, generates two DLLs (<kbd>MSTSCLib.dll</kbd> and <kbd>AxMSTSCLib.dll</kbd>) from that ActiveX DLL.</p>
<p>The first DLL, <kbd>MSTSCLib.dll</kbd>, contains the managed definitions of the unmanaged interfaces, classes, structures, and enums, defined in the type library contained inside the ActiveX DLL (<kbd>mstscax.dll</kbd>). This is generally named with the library name from the original type library.</p>
<p>The second DLL, <kbd>AxMSTSCLib.dll</kbd>, is named the same but with an <kbd>Ax</kbd> prefix. This contains a Windows Forms control corresponding to each ActiveX class. The Windows Forms representation of the ActiveX control is added to <kbd>WindowsFormsHost</kbd>.</p>
<p>In our example, the <kbd>AxMsTscAxNotSafeForScripting</kbd> control is used in XAML, inside <kbd>WindowsFormsHost</kbd>, to perform the interaction. Its <kbd>Server</kbd> property, from the code behind the class, has been set to a simple string, pointing to the remote system's IP address or machine name, discoverable from the host.</p>
<p>When you are ready, the <kbd>Connect()</kbd> call to the instance of the terminal control (<kbd>AxMsTscAxNotSafeForScripting</kbd>) connects to the remote system. You can additionally provide <kbd>Domainname</kbd> , <kbd>Username</kbd>, and other properties to the terminal instance, before calling the <kbd>Connect()</kbd> method.</p>


            </article>

            
        </section>
    </body></html>