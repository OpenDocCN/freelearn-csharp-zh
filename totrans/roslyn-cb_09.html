<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Design and Implement a New C# Language Feature</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will cover the following recipes:</p>
<ul>
<li>Designing syntax and grammar for a new C# language feature</li>
<li>Implementing parser support for <span>a new C# language feature</span></li>
<li>Implementing binding/semantic analysis support for <span>a new C# language feature</span></li>
<li>Implementing lowering/code generation support for <span>a new C# language feature</span></li>
<li>Writing unit tests for C# parsing, binding, and codegen phases</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction</h1>
                </header>
            
            <article>
                
<p><span>This chapter enables developers to design a new C# language feature and implement various compiler phases for this language feature</span>. On a high level, the C# compiler has following important phases:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="85" src="assets/f8321116-8694-43b3-9228-c3657aada528.png" width="707"/></div>
<ul>
<li><strong>Lexical Analysis</strong> (<a href="https://en.wikipedia.org/wiki/Lexical_analysis">https://en.wikipedia.org/wiki/Lexical_analysis</a>): This transforms the sequence of characters in a source file to into tokens such as keywords, identifiers, operators, and so on. <kbd>Lexer.Lex</kbd> (<a href="http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Parser/Lexer.cs,5ad0cc36317d33e7">http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Parser/Lexer.cs,5ad0cc36317d33e7</a>) is the primary entry point into the C# lexer that fetches the next token and increments the current position within the source text. For example, consider the following source code:</li>
</ul>
<pre style="padding-left: 90px">
<strong>class C</strong><br/><strong>{</strong><br/><strong> void Method(int x)</strong><br/><strong> {</strong><br/><strong>  x = x + 1;</strong><br/><strong> }</strong><br/><strong>}</strong>
</pre>
<p>This gets transformed into the following sequence of tokens during lexical analysis (white space and newline trivia excluded for brevity):</p>
<pre>
class (Keyword) C (IdToken)<br/>{ (OpenBraceToken)<br/> void (Keyword) Method (IdToken) ( (OpenParenToken) int (Keyword) x (IdToken) ) (CloseParenToken)<br/> { (OpenBraceToken)<br/>  x (IdToken) = (EqualsToken) x (IdToken) + (PlusToken) 1 (NumericalLiteralToken) ; (SemiColonToken)<br/> } (CloseBraceToken)<br/>} (CloseBraceToken)<em><br/></em>
</pre>
<ul>
<li><strong>Syntax Analysis</strong> (<a href="https://en.wikipedia.org/wiki/Parsing">https://en.wikipedia.org/wiki/Parsing</a>)<span>: This transforms the sequence of tokens generated from the lexical analysis phase into a syntax tree with nodes, tokens, and trivia. It also verifies that the syntax conforms to the C# language specification and generates syntax diagnostics.</span> <kbd>SyntaxFactory.ParseCompilationUnit</kbd> (<a href="http://source.roslyn.io/#q=SyntaxFactory.ParseCompilationUnit">http://source.roslyn.io/#q=SyntaxFactory.ParseCompilationUnit</a>) <span>is the primary entry point into the C# language parser that generates a</span> <kbd>CompilationUnitSyntax</kbd> <span>node, which is then used to create a</span> <kbd>SyntaxTree</kbd> <span>rooted at this node (see</span> <kbd>CSharpSyntaxTree.Create</kbd> (<a href="http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Syntax/CSharpSyntaxTree.cs,d40da3b7b4e39486">http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Syntax/CSharpSyntaxTree.cs,d40da3b7b4e39486</a>)<span>). For the preceding example source code and lexical tokens, we get the following syntax tree:</span></li>
</ul>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="390" src="assets/8011f62c-a48f-4348-b206-feff2e00f4a5.png" width="497"/></div>
<ul>
<li><strong>Semantic Analysis or Binding</strong> (<a href="https://en.wikipedia.org/wiki/Semantic_analysis_(compilers)">https://en.wikipedia.org/wiki/Semantic_analysis_(compilers)</a>)<span>: Transforms the syntax tree generated from the parsing phase into a bound tree with</span> <kbd>BoundNodes</kbd><span>. A bound tree is essentially an abstract syntax tree with rich semantic information associated with each node in the tree.</span> <span>All the semantic information provided by the</span> <kbd>SemanticModel</kbd> <span>APIs at the CodeAnalysis layer is from the bound nodes associated with the syntax.</span> <span>This phase analyzes the semantics of source code, such as type checking, method overload resolution, conversions, and so on, and generates semantic diagnostics.</span> <span>The primary entry points for binding statements and expressions are</span> <kbd>Binder.BindStatement</kbd> <span>(<a href="http://source.roslyn.io/#q=Binder.BindStatement">http://source.roslyn.io/#q=Binder.BindStatement</a>) and</span> <kbd>Binder.BindExpression</kbd> (<a href="http://source.roslyn.io/#q=Binder.BindExpression">http://source.roslyn.io/#q=Binder.BindExpression</a>), <span>respectively. For the preceding example, the following bound tree is generated for the method body for</span> <kbd>Method</kbd><span>:</span></li>
</ul>
<pre style="padding-left: 90px">
<strong>BoundBlockStatement</strong> (1 statements) (Syntax: '{ ... }')<br/>  <strong>BoundExpressionStatement</strong> (Syntax: 'x = x + 1;')<br/>    <strong>BoundSimpleAssignmentExpression</strong> (Type: System.Int32) (Syntax: 'x = x + 1')<br/>      Left: <strong>BoundParameterReferenceExpression</strong> (Type: System.Int32) (Syntax: 'x')<br/>      Right: <strong>BoundBinaryOperatorExpression</strong> (IntegerAdd) (Type: System.Int32) (Syntax: 'x + 1')<br/>          Left: <strong>BoundParameterReferenceExpression</strong> (Type: System.Int32) (Syntax: 'x')<br/>          Right: <strong>BoundLiteralExpression</strong> (Type: System.Int32, Constant: 1) (Syntax: '1')
</pre>
<ul>
<li><strong>Lowering</strong>: This transforms the bound tree generated from the binding phase into a simplified bound tree. For example, a bound <em>for</em> loop node gets rewritten into a bound block with labels and conditional jumps (see <kbd>LocalRewriter.RewriteForStatement</kbd> (<a href="http://source.roslyn.io/#q=RewriteForStatement">http://source.roslyn.io/#q=RewriteForStatement</a>)). <kbd>LocalRewriter.Rewrite</kbd> (<a href="http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Lowering/LocalRewriter/LocalRewriter.cs,c30511823bc3c19f">http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Lowering/LocalRewriter/LocalRewriter.cs,c30511823bc3c19f</a>) is the primary entry point to lower each method block in the compilation.</li>
<li><strong>Flow analysis</strong> (<a href="https://en.wikipedia.org/wiki/Data-flow_analysis">https://en.wikipedia.org/wiki/Data-flow_analysis</a>): This phase performs basic data flow and control flow analysis of the lowered bound tree to generate unreachable code and uninitialized variable diagnostics. <kbd>FlowAnalysisPass.Rewrite</kbd> (<a href="http://source.roslyn.io/#q=FlowAnalysisPass.Rewrite">http://source.roslyn.io/#q=FlowAnalysisPass.Rewrite</a>) is the primary entry point into the flow analysis phase.</li>
<li><strong>Code generation</strong> (<a href="https://en.wikipedia.org/wiki/Code_generation_(compiler)">https://en.wikipedia.org/wiki/Code_generation_(compiler)</a>): This transforms lowered bound tree into MSIL represented with a sequence of bytes that gets emitted into a .NET assembly. <kbd>CodeGenerator.Generate</kbd> (<a href="http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/CodeGen/CodeGenerator.cs,c28190700f8e314c">http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/CodeGen/CodeGenerator.cs,c28190700f8e314c</a>) is the primary entry point into the code generator. For the preceding code example, the C# compiler generates the following MSIL for <kbd>Method</kbd>:</li>
</ul>
<pre style="padding-left: 90px">
.method private hidebysig instance void Method(int32 x) cil managed<br/>{<br/>  // Code size 7 (0x7)<br/>  .maxstack 8<br/>  IL_0000: nop<br/>  IL_0001: ldarg.1<br/>  IL_0002: ldc.i4.1<br/>  IL_0003: add<br/>  IL_0004: starg.s x<br/>  IL_0006: ret<br/>} // end of method C::Method
</pre>
<div class="packt_infobox">You can read a more detailed overview of Roslyn at <a href="https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview">https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview</a>.<a href="https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview"/></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">New language feature: Switch Operator (?::)</h1>
                </header>
            
            <article>
                
<p>In this chapter, we will design a new C# langauge feature that we call <em>Switch operator (?::)</em>. This feature is derived from two existing C# language constructs: switch statement (<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch">https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/switch</a>) and conditional operator <kbd>(?:)</kbd> (<a href="https://docs.microsoft.com/en-us/cpp/cpp/conditional-operator-q">https://docs.microsoft.com/en-us/cpp/cpp/conditional-operator-q</a>). It allows writing conditional expressions that can switch on multiple values of the expression and return a corresponding value or a default value. For example, consider the following switch statement that computes a string representation for an integral expression:</p>
<pre>
public string GetString(int expression)<br/>{<br/> string expressionStr;<br/> switch (expression)<br/> {<br/>  case 1:<br/>   expressionStr = "One";<br/>   break;<br/><br/>  case 2:<br/>   expressionStr = "Two";<br/>   break;<br/><br/>  case 3:<br/>   expressionStr = "Three";<br/>   break;<br/><br/>  default:<br/>   expressionStr = "More than three";<br/>   break;<br/> }<br/><br/> return expressionStr;<br/>}
</pre>
<p>This code basically switches on different possible values of the <em>expression</em> and returns a descriptive string for its runtime value. The underlying intent of the user is to just return a mapped expression for different possible values of <em>expression</em>, with some default value. The switch operator designed in this chapter will allow you to rewrite the preceding code using a single expression:</p>
<pre>
string expressionStr = expression ?: [1, 2, 3] : ["One", "Two", "Three", "More than three"];
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Designing syntax and grammar for a new C# language feature</h1>
                </header>
            
            <article>
                
<p><span><strong>Syntax</strong> and <strong>Grammar</strong> are the core elements for implementing a new language feature. This section will enable you to define the syntax (nodes and tokens) and grammar for a new C# language feature:</span> Switch operator <kbd>(?::)</kbd><span>. For details on the intended functionality of this operator, read the section <em>New language feature:</em></span> <em>Switch Operator (?::)</em> <span>at the start of this chapter.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting Started</h1>
                </header>
            
            <article>
                
<p><span>You need to ensure that you have enlisted and built Roslyn sources with <em>VS2017</em> tag on your machine. For further guidance, refer to the recipe, <em>Setting up Roslyn enlistment</em> in<br/>
<a href="a7277d51-330b-45f3-aa10-5a9453afe569.xhtml">Chapter 8</a>, <em>Contribute Simple Functionality to Roslyn C# Compiler Open Source Code</em>.</span></p>
<div class="packt_tip">For the steps in the recipe that mention <em>Define ... in the C# language specification</em>, the reader should create a new GitHub issue on (<a href="https://github.com/dotnet/roslyn/issues/new">https://github.com/dotnet/roslyn/issues/new</a>) with labels Language-C# and Area-Language Design and get the specification reviewed by the language team. If approved, the reviewers will ensure that it gets added to the C# language specification.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Define the grammar for the new ternary operator <kbd>?::</kbd> in the C# language specification :</li>
</ol>
<pre style="padding-left: 90px">
switch-expression:<br/> null-coalescing-expression<br/> null-coalescing-expression ?: bracketed-argument-list : bracketed-argument-list<br/> <br/> bracketed-argument-list:<br/> [ argument-list ]
</pre>
<ol start="2">
<li>Define the compile time semantics associated with the new operator and the switch expression in C# language specification:</li>
</ol>
<p style="padding-left: 60px">A switch expression of the form <kbd>expr ?: [label1, label2, ..., labeln] : [val1, val2, ..., valn, valn+1]</kbd> has the following compile time semantics:</p>
<ul>
<li>The governing type of the switch expression is established by the same set of rules as the governing type of a switch statement.</li>
<li>The first bracketed argument list <kbd>[label1, label2, ..., labeln]</kbd> must contain expressions labeli with a constant value that is implicitly convertible to the switch governing type. A compile-time error occurs if two or more <kbd>labeli</kbd> in the same switch expression specify the same constant value.</li>
<li>The second bracketed argument list <kbd>[val1, val2, ..., valn, valn+1]</kbd> controls the type of the switch expression resultant value. Applying the following checks to each pair vali and valj in the list must yield the same value for type Z; otherwise, a compile time error occurs:
<ul>
<li>If <kbd>vali</kbd> has type X and <kbd>valj</kbd> has type Y then:
<ul>
<li>If an implicit conversion exists from X to Y, but not from Y to X, then Y is the type of the expression (Z = Y).</li>
<li>If an implicit conversion exists from Y to X, but not from X to Y, then X is the type of the expression (Z = X).</li>
<li>Otherwise, no expression type can be determined, and a compile-time error occurs.</li>
</ul>
</li>
<li>If only one of <kbd>vali</kbd> and <kbd>valj</kbd> has a type, and both <kbd>vali</kbd> and <kbd>valj</kbd> are implicitly convertible to a type Z, then that is the type of the expression.</li>
<li>Otherwise, no expression type can be determined, and a compile-time error occurs.</li>
</ul>
</li>
</ul>
<ol start="3">
<li>Define the associativity and precedence for the new operator in the C# language specification:</li>
</ol>
<p style="padding-left: 90px">The switch operator is right-associative, meaning that operations are grouped from right to left.<br/>
The switch operator has the same precedence as other ternary operators (such as conditional operator <kbd>?:</kbd>).</p>
<ol start="4">
<li>Define the runtime execution semantics of the switch expression in the C# language specification:</li>
</ol>
<p style="padding-left: 60px">A switch expression is evaluated as follows:</p>
<ul>
<li class="mce-root">The expression expr is evaluated and converted to the governing type.</li>
<li class="mce-root">If one of the n constants, say <kbd>labeli</kbd>, specified in the first bracketed list in the same switch expression is equal to the value of the expression <kbd>expr</kbd>, then expression <kbd>vali</kbd> in the second bracketed list is evaluated and converted to type Z and becomes the resultant value of the expression.</li>
<li class="mce-root">If none of the n constants specified in the first bracketed list in the same switch expression is equal to the value of the expression <kbd>expr</kbd>, then the last expression <kbd>valn+1</kbd> in the second bracketed list is evaluated and converted to type Z and becomes the resultant value of the expression.</li>
</ul>
<ol start="5">
<li>Open <kbd>Roslyn.sln</kbd> in Visual Studio 2017 and open source file <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\Syntax\SyntaxKind.cs</kbd>. Add new <kbd>SyntaxKinds</kbd> for the <kbd>QuestionColonToken</kbd> and <kbd>SwitchExpression</kbd> at lines 77 and 334, respectively:</li>
</ol>
<pre style="padding-left: 90px">
<span class="pl-en">QuestionColonToken</span><span> = </span><span class="pl-c1">8284</span><span>,<br/></span>...<br/><span class="pl-en">SwitchExpression</span><span> = </span><span class="pl-c1">8658</span><span>,</span>
</pre>
<ol start="6">
<li><span>Open source file</span> <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\Syntax\Syntax.xml</kbd> <span>and add XML definition for the new syntax node</span> <kbd>SwitchExpressionSyntax</kbd> <span>with fields</span> <kbd>Expression</kbd><em>,</em> <kbd>QuestionColonToken</kbd><em>,</em> <kbd>Labels</kbd><em>,</em> <kbd>ColonToken</kbd><em>,</em> <span>and</span> <kbd>Values</kbd> <span>at line 686:</span></li>
</ol>
<pre style="padding-left: 90px">
  &lt;Node Name="<strong>SwitchExpressionSyntax</strong>" Base="<strong>ExpressionSyntax</strong>"&gt;<br/>    &lt;Kind Name="SwitchExpression"/&gt;<br/>    &lt;Field Name="<strong>Expression</strong>" Type="<strong>ExpressionSyntax</strong>"&gt;<br/>      &lt;PropertyComment&gt;<br/>        &lt;summary&gt;ExpressionSyntax node representing the expression of the switch expression.&lt;/summary&gt;<br/>      &lt;/PropertyComment&gt;<br/>    &lt;/Field&gt;<br/>    &lt;Field Name="<strong>QuestionColonToken</strong>" Type="<strong>SyntaxToken</strong>"&gt;<br/>      &lt;Kind Name="QuestionColonToken"/&gt;<br/>      &lt;PropertyComment&gt;<br/>        &lt;summary&gt;SyntaxToken representing the question mark.&lt;/summary&gt;<br/>      &lt;/PropertyComment&gt;<br/>    &lt;/Field&gt;<br/>    &lt;Field Name="<strong>Labels</strong>" Type="<strong>BracketedArgumentListSyntax</strong>"&gt;<br/>      &lt;PropertyComment&gt;<br/>        &lt;summary&gt;BracketedArgumentListSyntax node representing comma separated labels to switch on.&lt;/summary&gt;<br/>      &lt;/PropertyComment&gt;<br/>    &lt;/Field&gt;<br/>    &lt;Field Name="<strong>ColonToken</strong>" Type="<strong>SyntaxToken</strong>"&gt;<br/>      &lt;Kind Name="ColonToken"/&gt;<br/>      &lt;PropertyComment&gt;<br/>        &lt;summary&gt;SyntaxToken representing the colon.&lt;/summary&gt;<br/>      &lt;/PropertyComment&gt;<br/>    &lt;/Field&gt;<br/>    &lt;Field Name="<strong>Values</strong>" Type="<strong>BracketedArgumentListSyntax</strong>"&gt;<br/>      &lt;PropertyComment&gt;<br/>        &lt;summary&gt;BracketedArgumentListSyntax node representing the comma separated expression results.&lt;/summary&gt;<br/>      &lt;/PropertyComment&gt;<br/>    &lt;/Field&gt;<br/>    &lt;TypeComment&gt;<br/>      &lt;summary&gt;Class which represents the syntax node for switch expression.&lt;/summary&gt;<br/>    &lt;/TypeComment&gt;<br/>    &lt;FactoryComment&gt;<br/>      &lt;summary&gt;Creates a SwitchExpressionSyntax node.&lt;/summary&gt;<br/>    &lt;/FactoryComment&gt;<br/>  &lt;/Node&gt;
</pre>
<ol start="7">
<li>Build the project <kbd>CSharpCodeAnalysis</kbd> to auto generate the source code for the new <kbd>SwitchExpressionSyntax</kbd> node added earlier. Note that the build will fail with a bunch of <em>RS0016</em> errors as we haven't added the new public types to the public API surface.</li>
<li><span>Switch back to source file</span> <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\Syntax\SyntaxKind.cs</kbd> <span>and invoke the code fix at line 334 defining the</span> <kbd>SwitchExpression</kbd> using <em>Ctrl</em> + <em>.</em> and apply <span class="packt_screen">Fix all occurrences</span> in <span class="packt_screen">Projec</span>t to fix all <em>RS0016</em> diagnostics:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="438" src="assets/9ec078ac-f9b2-451c-ac85-92366274d38c.png" width="901"/></div>
<ol start="9">
<li>Build the project again and verify it succeeds this time.</li>
</ol>
<div class="packt_infobox">You can view all the source changes made in this recipe at <a href="https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5">https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In the first half of this recipe, we walked through the steps to define the grammar, compile time, and runtime semantics, associativity and precedence of the new switch expression/operator. In the second half, we defined the new syntax kinds and syntax node in the compiler.</p>
<p>The grammar, <span>associativity, and precedence</span> for the new switch expression is identical to the grammar for the existing conditional ternary expression.</p>
<p>As both the ternary operators come just after the null coalescing operator (??) in the precedence order, the grammar specifies:</p>
<pre>
switch-expression:<br/> null-coalescing-expression<br/> null-coalescing-expression ?: bracketed-argument-list : bracketed-argument-list
</pre>
<p>The grammar specifies the labels and the values for the switch expression to be a comma separated argument list within square brackets, for example, <kbd>[ arg1<sub>,</sub> arg<sub>2</sub>, ..., arg<sub>n</sub> ]</kbd>. Some examples of expressions:</p>
<pre>
// Valid syntax cases<br/>expression ?: [1, 2, 3] : ["One", "Two", "Three", "More than three"];<br/>expression ?: [MethodCall1()] : ["One", "Two", "Three", "More than three"]; // invalid semantics<br/><br/>// Invalid syntax cases<br/>expression ?: [MethodCall1(), 2] : "One"; // argument lists must be bracketed<br/>expression ?: [MethodCall1(), MethodCall2()]; // missing colon and argument list
</pre>
<p>Compile time semantics enforce that the type of the expression being switched on has the same semantic requirements as the switch governing type for a switch statement:</p>
<p>The governing type of a switch statement is established by the switch expression. If the type of the switch expression is sbyte, byte, short, ushort, int, uint, long, ulong, char, string, or an enum-type, then that is the governing type of the switch statement. Otherwise, exactly one user-defined implicit conversion (Section 6.4) must exist from the type of the switch expression to one of the following possible governing types: sbyte, byte, short, ushort, int, uint, long, ulong, char, string. If no such implicit conversion exists, or if more than one such implicit conversion exists, a compile-time error occurs.</p>
<p>Compile time semantics also enforce that:</p>
<ul>
<li>The first bracketed argument list be all constant labels, such that there is an implicit conversion to the switch governing type</li>
<li>The second argument list be of length one greater than the first list and all arguments be expressions, such that they are convertible to a common type <kbd>Z</kbd> with implicit conversions</li>
</ul>
<p>The following are some examples of semantically valid and invalid switch expressions:</p>
<pre>
string expression = ...<br/><br/>// Valid syntax and semantics<br/>expression ?: [1, 2, 3] : ["One", "Two", "Three", "More than three"];<br/><br/>// Invalid semantics, valid syntax<br/>expression ?: [MethodCall1(), 2] : ["One", "Two", "Three"]; // non constant label<br/>expression ?: [1.0] : ["One", "Two"]; // No implicit conversion from label to switch governing type<br/>expression ?: [1] : ["One", 1.0]; // No implicit conversions to a common type between "One" and 1.0
</pre>
<p>Runtime semantics of the switch expression are identical to the switch statement. The expression on which we switch is first evaluated, and its value compared against each label in the first argument list. For a match, we evaluate the corresponding expression in the second list and convert it to type <kbd>Z</kbd> and that becomes the result of the expression. If there is no match, the last expression in the second argument list is evaluated and converted to type <kbd>Z</kbd> and becomes the default result of the expression:</p>
<pre>
Console.WriteLine(expression ?: [1, 2, 3] : ["One", "Two", "Three", "More than three"]);<br/><br/>// expression == 1, prints "One"<br/>// expression == 2, prints "Two"<br/>// expression == 3, prints "Three"<br/>// otherwise, prints "More than three"
</pre>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing parser support for a new C# language feature</h1>
                </header>
            
            <article>
                
<p><span><strong>Lexical analysis</strong> and <strong>Syntax analysis</strong> (<strong>Parsing</strong>) are initial phases of the C# compiler that transform the input source text into a syntax tree with nodes and tokens and reports syntax diagnostics. This section will enable you to add the lexer and parser support for a new C# language feature: <em>Switch operator (?::)</em>. For details on the intended functionality of this operator, read the section <em>New language feature: Switch Operator (?::)</em> at the start of this chapter. For details on the grammar and syntax definitions for this operator, read the previous recipe.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting Started</h1>
                </header>
            
            <article>
                
<p><span>You need to ensure that you have enlisted and built Roslyn sources with <em>VS2017</em> tag on your machine. For further guidance, refer to the recipe, <em>Setting up Roslyn</em></span>, <span><em>enlistment</em> in <a href="a7277d51-330b-45f3-aa10-5a9453afe569.xhtml">Chapter 8</a>, <em>Contribute Simple Functionality to Roslyn C# Compiler Open Source Code</em>.</span></p>
<p>Additionally, git commit <a href="https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5">https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5</a> on your enlistment to get the syntax definitions and build <kbd>CSharpCodeAnalysis</kbd> project.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open <kbd>Roslyn.sln</kbd> in Visual Studio 2017</li>
<li><span>Open source file</span> <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\Parser\Lexer.cs</kbd> <span>and add the</span> highlighted <kbd>else if</kbd> <span>statement at line 565 in the method</span> <kbd>ScanSyntaxToken</kbd><em>:</em></li>
</ol>
<pre style="padding-left: 90px">
case '?': <br/> if (<span>TextWindow.PeekChar() == </span><span class="pl-s"><span class="pl-pds">'</span>?<span class="pl-pds">'</span></span>)<br/> { ...<br/> }<br/><strong> else if (TextWindow.PeekChar() == ':')</strong><br/><strong> {</strong><br/><strong>  TextWindow.AdvanceChar();</strong><br/><strong>  info.Kind = SyntaxKind.QuestionColonToken;</strong><br/><strong> }</strong><br/> else<br/> { ...<br/> }
</pre>
<ol start="3">
<li><span>Open source file</span> <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\Parser\LanguageParser.cs</kbd> <span>and add the</span> highlighted <kbd>else if</kbd> statement at line 9426 in the method <kbd>ParseSubExpressionCore</kbd>:</li>
</ol>
<pre style="padding-left: 90px">
if (tk == SyntaxKind.QuestionToken &amp;&amp; precedence &lt;= Precedence.Ternary)<br/>{ ...<br/>}<br/><strong>else if (tk == SyntaxKind.QuestionColonToken &amp;&amp; precedence &lt;= Precedence.Ternary)</strong><br/><strong>{</strong><br/><strong> var questionColonToken = this.EatToken();</strong><br/><strong> var labels = this.ParseBracketedArgumentList();</strong><br/><strong> var colon = this.EatToken(SyntaxKind.ColonToken);</strong><br/><strong> var values = this.ParseBracketedArgumentList();</strong><br/><strong> leftOperand = _syntaxFactory.SwitchExpression(leftOperand, questionColonToken, labels, colon, values);</strong><br/><strong>}</strong><br/><br/>return leftOperand;
</pre>
<ol start="4">
<li>Go to line 10552 in the same file (method <kbd>CanFollowCast</kbd><em>)</em> add the highlighted case clause:</li>
</ol>
<pre style="padding-left: 90px">
 case SyntaxKind.EndOfFileToken:<br/> <strong>case SyntaxKind.QuestionColonToken:</strong><br/>  return false;
</pre>
<ol start="5">
<li><span>Open source file</span> <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\Syntax\SyntaxKindFacts.cs</kbd> <span>and add the</span> highlighted <span>case clause</span> <span>at line 1278 in the method</span> <kbd>GetText</kbd><em>:</em></li>
</ol>
<pre style="padding-left: 90px">
 case SyntaxKind.XmlProcessingInstructionEndToken:<br/>  return "?&gt;";<br/><strong> case SyntaxKind.QuestionColonToken:</strong><br/><strong>  return "?:";</strong><br/> ...
</pre>
<ol start="6">
<li>Set <kbd>Roslyn.csproj</kbd> as the startup project.</li>
<li>Change the <span class="packt_screen">solution</span> <span class="packt_screen">configuration</span> from <span class="packt_screen">Debug</span> to <span class="packt_screen">Release</span> (to avoid asserts in the binder) and rebuild the solution.</li>
<li>Hit <em>Ctrl</em> + <em>F5</em> to start new instance of VS from the <kbd>RoslynDev</kbd> hive with our local changes.</li>
<li>In the new instance of VS, create a new C# class library project and add the following code, which uses the new switch operator:</li>
</ol>
<pre style="padding-left: 90px">
class Class<br/>{<br/> void M(int expr)<br/> {<br/>  var exprStr = <strong>expr ?: [1, 2, 3] : ["One", "Two", "Three", "More than three"]</strong>;<br/>  System.Console.WriteLine(exprStr);<br/> }<br/>}
</pre>
<ol start="10">
<li>Open the Roslyn syntax visualizer from <span class="packt_screen">View</span> | <span class="packt_screen">Other Windows</span> | <span class="packt_screen">Syntax Visualizer</span> and select the switch expression in the editor to view the parsed syntax nodes and tokens for the expression. For guidance on the syntax visualizer, refer to the recipe, <em>Using Roslyn syntax visualizer to view Roslyn syntax tokens and nodes for a source file</em> in <a href="a7277d51-330b-45f3-aa10-5a9453afe569.xhtml">Chapter 8</a>, <em>Contribute Simple Functionality to Roslyn C# Compiler Open Source Code.</em></li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" src="assets/82e46abf-99ba-4048-8bb6-f028d93192ac.png"/></div>
<ol start="11">
<li>Verify that there are no squiggles or intellisense errors in the error list:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="296" src="assets/0aa474cb-ee17-4fef-9386-9796ee60a144.png" width="899"/></div>
<ol start="12">
<li>Remove the colon token and the second bracketed argument list, that is, <kbd>: ["One", "Two", "Three", "More than three"]</kbd>, and verify you get syntax errors for missing tokens in the switch expression:</li>
</ol>
<p>Â </p>
<pre style="padding-left: 90px">
Error CS1003 Syntax error, ':' expected ClassLibrary &lt;%PROJECT_DIR%&gt;\ClassLibrary\Class1.cs 5<br/>Error CS1003 Syntax error, '[' expected ClassLibrary &lt;%PROJECT_DIR%&gt;\ClassLibrary\Class1.cs 5<br/>Error CS1003 Syntax error, ']' expected ClassLibrary &lt;%PROJECT_DIR%&gt;\ClassLibrary\Class1.cs 5
</pre>
<ol start="13">
<li>Revert step 11 and try to build the project and verify it fails with <kbd>CSC : error CS7038: Failed to emit module 'ClassLibrary'</kbd> as we have not implemented any binding or code generation for the new construct.</li>
</ol>
<div class="packt_infobox"><span>You can view all the source changes made in this recipe at</span> <a href="https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569">https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569</a>.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we added basic lexer and parser support for the <span>switch</span> operator (?:). Lexer is primarily responsible for scanning the text and generating tokens. LanguageParser is responsible for parsing the lexed tokens and generate syntax tree with nodes and tokens.</p>
<p>Let's walk through our code changes in this recipe. We added the following highlighted code to the lexer:</p>
<pre>
case '?': <br/> if (<span>TextWindow.PeekChar() == </span><span class="pl-s"><span class="pl-pds">'</span>?<span class="pl-pds">'</span></span>)<br/> { ...<br/> }<br/><strong> else if (TextWindow.PeekChar() == ':')</strong><br/><strong> {</strong><br/><strong>  TextWindow.AdvanceChar();</strong><br/><strong>  info.Kind = SyntaxKind.QuestionColonToken;</strong><br/><strong> }</strong><br/> else<br/> { ...<br/> }
</pre>
<p>In the original code, when we were scanning the text and identify a <kbd>'?'</kbd> character, we peeked at the next character to identify it is another <kbd>'?'</kbd> character (the ?? null coalescing operator) or a whitespace (the <kbd>?</kbd> token for the conditional operator). Our new code adds an additional check for whether the next character is <kbd>':'</kbd> (the <kbd>?:</kbd> token for the switch operator). If so, it advances the current character in the text window and sets the syntax kind for the current token to <kbd>SyntaxKind.QuestionColonToken</kbd>.</p>
<p>We added the following highlighted code to the parser:</p>
<pre>
if (tk == SyntaxKind.QuestionToken &amp;&amp; precedence &lt;= Precedence.Ternary)<br/>{ ...<br/>}<br/><strong>else if (tk == SyntaxKind.QuestionColonToken &amp;&amp; precedence &lt;= Precedence.Ternary)</strong><br/><strong>{</strong><br/><strong> var questionColonToken = this.EatToken();</strong><br/><strong> var labels = this.ParseBracketedArgumentList();</strong><br/><strong> var colon = this.EatToken(SyntaxKind.ColonToken);</strong><br/><strong> var values = this.ParseBracketedArgumentList();</strong><br/><strong> leftOperand = _syntaxFactory.SwitchExpression(leftOperand, questionColonToken, labels, colon, values);</strong><br/><strong>}</strong>
</pre>
<p>We extended the original code that parsed the <kbd>QuestionToken</kbd> in the parser to also check for the <kbd>QuestionColonToken</kbd> and ternary precedence. If so, we eat the next token as the <kbd>questionColonToken</kbd>. Then, we attempt to parse the <kbd>labels</kbd> as a bracketed argument list by invoking <kbd>ParseBracketedArgumentList</kbd> (this code already exists in the language parser for parsing the bracketed argument list for a dictionary initializer). This is followed by parsing the colon token by invoking <kbd>EatToken</kbd> with the expected syntax kind for the colon token. This method handles both the valid and invalid token cases:</p>
<pre>
protected SyntaxToken EatToken(SyntaxKind kind)<br/>{<br/> Debug.Assert(SyntaxFacts.IsAnyToken(kind));<br/> <br/> var ct = this.CurrentToken;<br/> if (ct.Kind == kind)<br/> {<br/>  MoveToNextToken();<br/>  return ct;<br/> }<br/> <br/> //slow part of EatToken(SyntaxKind kind)<br/> return CreateMissingToken(kind, this.CurrentToken.Kind, reportError: true);<br/>}
</pre>
<p>For a valid token of the expected kind, it moves to the next token and returns the current colon token. If the next token is not of the expected kind, it generates a missing token and also reports a syntax diagnostic for the missing token:</p>
<pre>
<em>Error CS1003 Syntax error, <strong>':' expected</strong> ClassLibrary &lt;%PROJECT_DIR%&gt;\ClassLibrary\Class1.cs 5</em>
</pre>
<p>Finally, we parse the <em>values</em> as another bracketed argument list. We invoke the newly auto generated syntax factory helper <kbd>SwitchExpression</kbd> to generate a <kbd>SwitchExpressionSyntax</kbd> node with the parsed tokens.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing binding/semantic analysis support for a new C# language feature</h1>
                </header>
            
            <article>
                
<p><span><strong>Semantic analysis</strong> (<strong>Binding)</strong> is the intermediate phase of the C# compiler that transforms syntax trees into C# bound trees and reports semantic diagnostics. This section will enable you to add the binding support for a new C# language feature:</span> <kbd>Switch operator (?::)</kbd><span>. For details on the intended functionality of this operator, read the section,</span> <em>New language feature: Switch Operator (?::)</em> <span>at the start of this chapter. For details on the grammar and syntax definitions for this operator, read the first recipe of this chapter, <em>Designing syntax and grammar for a new C# language feature</em>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting Started</h1>
                </header>
            
            <article>
                
<p><span>You need to ensure that you have enlisted and built Roslyn sources with <em>VS2017</em> tag on your machine. For further guidance, refer to the recipe, <em>Setting up Roslyn enlistment</em> in <a href="a7277d51-330b-45f3-aa10-5a9453afe569.xhtml">Chapter 8</a>, <em>Contribute Simple Functionality to Roslyn C# Compiler Open Source Code</em>.</span></p>
<p>Additionally, the following two git commits on your enlistment to get the syntax definitions and parser support, respectively, and build <kbd>CSharpCodeAnalysis</kbd> project:</p>
<ul>
<li><a href="https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5">https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5</a></li>
<li><a href="https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569">https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol>
<li>Open <kbd>Roslyn.sln</kbd> in Visual Studio 2017</li>
<li><span>Open source file</span> <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\BoundTree\BoundNodes.xml</kbd> <span>and add the following</span> <kbd>BoundSwitchOperator</kbd> <span>definition</span> <span><span>at line 437<em>:</em></span></span></li>
</ol>
<pre style="padding-left: 90px">
&lt;Node Name="<strong>BoundSwitchOperator</strong>" Base="BoundExpression"&gt;<br/> &lt;!-- Non-null type is required for this node kind --&gt;<br/> &lt;Field Name="<strong>Type</strong>" Type="TypeSymbol" Override="true" Null="disallow"/&gt;<br/><br/> &lt;Field Name="<strong>Expression</strong>" Type="BoundExpression"/&gt;<br/> &lt;Field Name="<strong>Labels</strong>" Type="ImmutableArray&amp;lt;BoundExpression&amp;gt;"/&gt;<br/> &lt;Field Name="<strong>Values</strong>" Type="ImmutableArray&amp;lt;BoundExpression&amp;gt;"/&gt;<br/>&lt;/Node&gt;
</pre>
<ol start="3">
<li><span>Open source file</span> <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\Binder\Binder_Expression.cs</kbd> <span>and add the</span> <kbd>switch</kbd> section <span>at line 535 in the method</span> <kbd>BindExpressionInternal</kbd>:</li>
</ol>
<pre style="padding-left: 90px">
case SyntaxKind.SwitchExpression:<br/> return BindSwitchOperator((SwitchExpressionSyntax)node, diagnostics);
</pre>
<ol start="4">
<li><span>Copy the method implementations for</span> <kbd>BindSwitchOperator</kbd> <span>and</span> <kbd>BindSwitchOperatorArguments</kbd> <span>from the attached code sample source file</span> <kbd>CSharpCodeAnalysis\Binder_Operators.cs</kbd> <span>and paste them into</span> <span>source file</span> <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\Binder\Binder_Operators.cs</kbd> <span>at line 3521.</span></li>
<li><span>Copy the partial type definition for</span> <kbd>BoundSwitchOperator</kbd> <span>from the attached code sample source file</span> <kbd>CSharpCodeAnalysis\Expression.cs</kbd> <span>and paste it into</span> <span>source file</span> <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\BoundTree\Expression.cs</kbd> <span>at line 1221.</span></li>
<li>Add a new source file <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_SwitchOperator.cs</kbd> to the project <kbd>CSharpCodeAnalysis</kbd> with a stub implementation of the lowering for the switch operator copied from <kbd>CSharpCodeAnalysis\LocalRewriter_SwitchOperator.cs</kbd>:</li>
</ol>
<pre style="padding-left: 90px">
public override BoundNode <strong>VisitSwitchOperator</strong>(BoundSwitchOperator node)<br/>{<br/> // TODO: Implement lowering for switch operator.<br/> return MakeLiteral(node.Syntax,<br/>  ConstantValue.Create($"CodeGen not yet implemented for: '{node.Syntax.ToString()}'"),<br/>  _compilation.GetSpecialType(SpecialType.System_String));<br/>}
</pre>
<ol start="7">
<li>Add stub flow analysis implementation for the switch operator to <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\FlowAnalysis\PreciseAbstractFlowPass_Switch.cs</kbd> at line 260:</li>
</ol>
<pre style="padding-left: 90px">
public override BoundNode <strong>VisitSwitchOperator</strong>(BoundSwitchOperator node)<br/>{<br/> // TODO: Implement flow analysis for switch operator.<br/> return null;}
</pre>
<ol start="8">
<li>Build project <kbd>csc.csproj</kbd> to generate <kbd>%REPO_ROOT%\Binaries\Debug\Exes\csc\csc.exe</kbd> with our local changes.</li>
<li>Create a new source file, say <kbd>test.cs</kbd>, with the following source code:</li>
</ol>
<pre style="padding-left: 90px">
class Class<br/>{<br/> public static void Main(string[] args)<br/> {<br/>  System.Console.WriteLine(args.Length ?: [0, 1, 2] : ["Zero", "One", "Two", "More than two"]);<br/> }}
</pre>
<ol start="10">
<li>Compile this source file with locally built <kbd>csc.exe</kbd> and verify that the build succeeds.</li>
<li>Run the generated executable <kbd>test.exe</kbd> and verify it runs fine, but the output is still not the expected result due to a stub codegen implementation for the switch operator:</li>
</ol>
<div class="mce-root CDPAlignCenter CDPAlign"><img class="image-border" height="181" src="assets/2f6edcd0-fffb-4765-9b60-8f661c836e6d.png" width="471"/></div>
<div class="packt_infobox"><span>You can view all the source changes made in this recipe at <a href="https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236">https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236</a></span>.<span><a href="https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we added basic binding/semantic analysis support for the <span>switch</span> operator <kbd>(?:)</kbd>, which enabled us to compile and execute source code with this new operator. Note that this is not a comprehensive implementation of the binding phase for this operator, and requires further work such as enhanced error reporting. See the next section, <em>There's more...</em>, in this recipe for further details.</p>
<p>The C# binder is responsible for semantic analysis of the syntax tree produced by the parser. It t<span>ransforms the syntax tree into a bound tree with</span> <kbd>BoundNodes</kbd>, which <span>is essentially an abstract syntax tree with rich semantic information associated with each node in the tree.</span></p>
<p>We first added a new BoundNode definition for the switch operator, <kbd>BoundSwitchOperator</kbd><strong>,</strong> into a template file <kbd>BoundNodes.xml</kbd>:</p>
<pre>
&lt;Node Name="<strong>BoundSwitchOperator</strong>" Base="BoundExpression"&gt;<br/> &lt;!-- Non-null type is required for this node kind --&gt;<br/> &lt;Field Name="<strong>Type</strong>" Type="TypeSymbol" Override="true" Null="disallow"/&gt;<br/><br/> &lt;Field Name="<strong>Expression</strong>" Type="BoundExpression"/&gt;<br/> &lt;Field Name="<strong>Labels</strong>" Type="ImmutableArray&amp;lt;BoundExpression&amp;gt;"/&gt;<br/> &lt;Field Name="<strong>Values</strong>" Type="ImmutableArray&amp;lt;BoundExpression&amp;gt;"/&gt;<br/>&lt;/Node&gt;
</pre>
<p>Note the difference between syntax nodes and bound nodes for the switch operator. We no longer store any purely syntactic information, such as the question colon token or the brackets around the argument list. The expression on which the switch operates is expected to bind to a <kbd>BoundExpression</kbd>, and labels and values are also expected be a list of bound expressions.</p>
<p>Building the project <kbd>CSharpCodeAnalysis</kbd> runs a generator tool over BoundNodes.xml file as a pre-build step to auto-generate <kbd>BoundNodes.generated.cs</kbd> file with the source definitions for the bound nodes.</p>
<div class="packt_tip"><kbd>BoundNodes.generated.cs</kbd> is no longer automatically generated during the build of <kbd>CSharpCodeAnalysis</kbd> project in the latest Roslyn master branch, which was a post <em>VS2017</em> change. On the latest sources, you must explicitly run the following script to auto-generate this code: <a href="https://github.com/dotnet/roslyn/blob/master/build/scripts/generate-compiler-code.cmd">https://github.com/dotnet/roslyn/blob/master/build/scripts/generate-compiler-code.cmd</a>.<a href="https://github.com/dotnet/roslyn/blob/master/build/scripts/generate-compiler-code.cmd"/></div>
<p>The core binding support involved appending the switch case in <kbd>BindExpressionInternal</kbd> to handle the syntax node of <kbd>SyntaxKind.SwitchExpression</kbd> and invoke <kbd>BindSwitchOperator</kbd> method.</p>
<p>We added the new method <kbd>BindSwitchOperator</kbd> to the binder to handle top level binding of the <kbd>SwitchExpressionSyntax</kbd> node:</p>
<pre>
private BoundSwitchOperator <em><strong>BindSwitchOperator</strong></em>(SwitchExpressionSyntax node, DiagnosticBag diagnostics)<br/>{<br/> BoundExpression switchExpr = BindValue(node.Expression, diagnostics, BindValueKind.RValue);<br/> ImmutableArray&lt;BoundExpression&gt; labelsExpr = BindSwitchOperatorArguments(node.Labels, diagnostics);<br/> ImmutableArray&lt;BoundExpression&gt; valuesExpr = BindSwitchOperatorArguments(node.Values, diagnostics);<br/><br/> // TODO: Add semantic validation for arguments and diagnostics.<br/> TypeSymbol type = valuesExpr.Length &gt; 1 ? valuesExpr[0].Type : CreateErrorType();<br/> bool hasErrors = type.IsErrorType();<br/><br/> return new BoundSwitchOperator(node, switchExpr, labelsExpr, valuesExpr, type, hasErrors);<br/>}
</pre>
<p>We bind the expression of the switch operator as a value using <kbd>BindValue</kbd> (<a href="http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder_Expressions.cs,608d49de0066ede1,references">http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/Binder/Binder_Expressions.cs,608d49de0066ede1,references</a>) invocation. This guarantees that we have an actual expression with a value, rather than a type, as the node's expression. For example, we get the following semantic error when this is violated:</p>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="322" src="assets/d78108e5-7438-4828-8deb-afeeeba71ede.png" width="905"/></div>
<p>We added the new method, <kbd>BindSwitchOperatorArguments</kbd>, to bind the <kbd>Labels</kbd> and <kbd>Values</kbd> of the switch operator:</p>
<pre>
private ImmutableArray&lt;BoundExpression&gt; BindSwitchOperatorArguments(BracketedArgumentListSyntax node, DiagnosticBag diagnostics)<br/>{<br/> AnalyzedArguments analyzedArguments = AnalyzedArguments.GetInstance();<br/> ImmutableArray&lt;BoundExpression&gt; arguments;<br/> try<br/> {<br/>  BindArgumentsAndNames(node, diagnostics, analyzedArguments);<br/>  arguments = BuildArgumentsForErrorRecovery(analyzedArguments);<br/> }<br/> finally<br/> {<br/>  analyzedArguments.Free();<br/> }<br/><br/> return arguments;<br/>}
</pre>
<p>This method invokes the existing binder method, <kbd>BindArgumentsAndNames</kbd> (<a href="http://source.roslyn.io/#q=BindArgumentsAndNames">http://source.roslyn.io/#q=BindArgumentsAndNames</a>), to bind the argument list and then build arguments for error recovery.</p>
<p>We also added a stub partial type implementation for <kbd>BoundSwitchOperator</kbd> for implementing <kbd>IOperation</kbd> (<a href="http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/IOperation.cs,7743f66521e66763">http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/IOperation.cs,7743f66521e66763</a>) APIs:</p>
<pre>
// <strong>TODO: Implement IOperation support for switch operator.</strong><br/>internal partial class BoundSwitchOperator<br/>{<br/> protected override OperationKind ExpressionKind =&gt; OperationKind.None;<br/><br/> public override void Accept(OperationVisitor visitor)<br/> {<br/>  visitor.VisitNoneOperation(this);<br/> }<br/><br/> public override TResult Accept&lt;TArgument, TResult&gt;(OperationVisitor&lt;TArgument, TResult&gt; visitor, TArgument argument)<br/> {<br/>  return visitor.VisitNoneOperation(this, argument);<br/> }<br/>}
</pre>
<div class="packt_infobox"><kbd>IOperation</kbd> is a new experimental feature that is currently being implemented in the compiler layers to expose the semantics associated with the compiler bound nodes as a publically supported API. The API is not released or publically supported as of VS2017, which may or may not change in a future release.</div>
<p>Additionally, we added stub implementations for flow analysis and lowering to enable us to build source code with the switch operator, though the generated MSIL or the output of the compiled executable is not the same as the expected final outcome. More specifically, the lowering implementation just replaced the entire <kbd>BoundSwitchOperator</kbd> node with a bound string literal stating that codegen is not yet implemented for the new switch operator:</p>
<pre>
 return MakeLiteral(node.Syntax,<br/>  ConstantValue.Create($"CodeGen not yet implemented for: '{node.Syntax.ToString()}'"),<br/>  _compilation.GetSpecialType(SpecialType.System_String));
</pre>
<p>Refer to the next recipe in this chapter for implementing lowering support for the operator.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">There's more...</h1>
                </header>
            
            <article>
                
<p>The current binder implementation of the switch operator has a bunch of pending work items, primarily related to more comprehensive semantic validation and error generation. The validation items to be implemented are:</p>
<ol>
<li>Add semantic validation that the expression of the switch operator has a type as per the requirements of a switch governing type; otherwise, generate a compile time error.</li>
<li>Add new compiler diagnostics for argument list validations. For example:
<ul>
<li>Ensure that the number of expressions in values is one greater than the number of expression in labels; otherwise, generate a compile time error.</li>
<li>Ensure that the labels are all compile time constants with implicit conversions to the switch governing type. If not, generate required compile time errors.</li>
</ul>
</li>
<li>Validate that the types of the expressions in Values are implicitly convertible to a common type Z, which is the type of the expression.</li>
</ol>
<p>These items are left as an exercise for the reader. For further guidance on implementing a new semantic error in the compiler code base, refer to recipe, <em>Implementing a new semantic error in the C# compiler code base,</em> in <a href="a7277d51-330b-45f3-aa10-5a9453afe569.xhtml">Chapter 8</a>, <em>Contribute Simple Functionality to Roslyn C# Compiler Open Source Code.</em></p>
<p>We also added basic stub implementations for the following pieces, which need further enhancements:</p>
<ol>
<li><kbd>IOperation</kbd> support the switch operator: This will involve creating a new <kbd>OperationKind</kbd> (<a href="http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/IOperationKind.cs,bf7324631c03b2e7">http://source.roslyn.io/#Microsoft.CodeAnalysis/Operations/IOperationKind.cs,bf7324631c03b2e7</a>) for the switch expression, adding a new interface, say <kbd>ISwitchChoiceExpression</kbd>, with the following API shape and then implementing this interface on the <kbd>BoundSwitchOperator</kbd>.</li>
</ol>
<pre style="padding-left: 90px">
 /// &lt;summary&gt;<br/> /// Represents a C# switch operator.<br/> /// &lt;/summary&gt;<br/> /// &lt;remarks&gt;<br/> /// This interface is reserved for implementation by its associated APIs. We reserve the right to<br/> /// change it in the future.<br/> /// &lt;/remarks&gt;<br/> public interface ISwitchChoiceExpression : IOperation<br/> {<br/>  /// &lt;summary&gt;<br/>  /// Switch expression to be tested.<br/>  /// &lt;/summary&gt;<br/>  IOperation SwitchExpression { get; }<br/> <br/>  /// &lt;summary&gt;<br/>  /// List of labels to compare the switch expression against.<br/>  /// &lt;/summary&gt;<br/>  ImmutableArray&lt;IOperation&gt; SwitchLabels { get; }<br/> <br/>  /// &lt;summary&gt;<br/>  /// List of values corresponding to the labels.<br/>  /// &lt;/summary&gt;<br/>  ImmutableArray&lt;IOperation&gt; SwitchValues { get; }<br/> }
</pre>
<ol start="2">
<li>Add lowering support for the switch operator: This is covered in the next recipe.</li>
<li>Add flow analysis support for the switch operator: This is not covered in this book, but should be implemented to ensure we report proper flow analysis diagnostics in code involving the switch operator.</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing lowering/code generation support for a new C# language feature</h1>
                </header>
            
            <article>
                
<p><span><strong>Lowering</strong> is an intermediate phase that executes after binding and transforms high level bound trees into simplified bound trees. These simplified bound trees are provided to the <strong>Code Generation</strong> phase and converted into MSIL and emitted into a .NET assembly. This section will enable you to add the lowering support for a new C# language feature:</span> Switch operator <kbd>(?::)</kbd><span>. This will enable you to write, compile, and correctly execute C# programs with the new operator. For details on the intended functionality of this operator, read the section, <em>New language feature: Switch Operator (?::)</em> at the start of this chapter. For details on the grammar and syntax definitions for this operator, read the first recipe of this chapter, <em>Designing syntax and grammar for a new C# language feature</em>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting Started</h1>
                </header>
            
            <article>
                
<p><span>You need to ensure that you have enlisted and built Roslyn sources with <em>VS2017</em> tag on your machine. For further guidance, refer to the recipe <em>Setting up Roslyn enlistment</em> in <a href="a7277d51-330b-45f3-aa10-5a9453afe569.xhtml">Chapter 8</a>, <em>Contribute Simple Functionality to Roslyn C# Compiler Open Source Code</em>.</span></p>
<p>Additionally, the following three git commits on your enlistment to get the syntax definitions, parser support and binder support, respectively, and build <kbd>CSharpCodeAnalysis</kbd> project:</p>
<ul>
<li><a href="https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5">https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5</a></li>
<li><a href="https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569">https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569</a></li>
<li><a href="https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236">https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol start="1">
<li>Open <kbd>Roslyn.sln</kbd> in Visual Studio 2017</li>
<li><span>Copy the method implementations for</span> <kbd>VisitSwitchOperator</kbd> <span>and</span> <kbd>RewriteSwitchOperator</kbd> <span>from the attached code sample source file</span> <kbd>CSharpCodeAnalysis\LocalRewriter_SwitchOperator.cs</kbd> <span>and paste them into source file</span> <kbd>%REPO_ROOT%\src\Compilers\CSharp\Portable\Lowering\LocalRewriter\LocalRewriter_SwitchOperator.cs</kbd>.</li>
<li>Build project <kbd>csc.csproj</kbd> to generate <kbd>%REPO_ROOT%\Binaries\Debug\Exes\csc\csc.exe</kbd> with our local changes.</li>
<li>Create a new source file, say <kbd>test.cs</kbd>, with the following source code:</li>
</ol>
<pre style="padding-left: 90px">
class Class<br/>{<br/> public static void Main(string[] args)<br/> {<br/>  System.Console.WriteLine(args.Length ?: [0, 1, 2] : ["Zero", "One", "Two", "More than two"]);<br/> }<br/>}
</pre>
<ol start="5">
<li>Compile this source file with locally built <kbd>csc.exe</kbd> and verify that the build succeeds.</li>
</ol>
<ol start="6">
<li>Run the generated executable <kbd>test.exe</kbd> with a different number of arguments and verify the corresponding outputs are as expected from the switch operator.</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="332" src="assets/4585ef22-787d-4ff1-827a-33444ef00026.png" width="851"/></div>
<ol start="7">
<li>Execute the <kbd>ildasm.exe test.exe</kbd> command and verify the MSIL for the generated executable contains sequential checks of the switch expression against the list of labels and conditional branches to the corresponding values:</li>
</ol>
<pre style="padding-left: 90px">
.method public hidebysig static void Main(string[] args) cil managed<br/>{<br/> .entrypoint<br/> // Code size 51 (0x33)<br/> .maxstack 8<br/> IL_0000: nop<br/> IL_0001: ldarg.0<br/> IL_0002: ldlen<br/> IL_0003: conv.i4<br/> IL_0004: brfalse.s IL_0027<br/> IL_0006: ldarg.0<br/> IL_0007: ldlen<br/> IL_0008: conv.i4<br/> IL_0009: ldc.i4.1<br/> IL_000a: beq.s IL_0020<br/> IL_000c: ldarg.0<br/> IL_000d: ldlen<br/> IL_000e: conv.i4<br/> IL_000f: ldc.i4.2<br/> IL_0010: beq.s IL_0019<br/> IL_0012: ldstr "More than two"<br/> IL_0017: br.s IL_001e<br/> IL_0019: ldstr "Two"<br/> IL_001e: br.s IL_0025<br/> IL_0020: ldstr "One"<br/> IL_0025: br.s IL_002c<br/> IL_0027: ldstr "Zero"<br/> IL_002c: call void [mscorlib]System.Console::WriteLine(string)<br/> IL_0031: nop<br/> IL_0032: ret<br/>} // end of method Class::Main
</pre>
<div class="packt_infobox"><span>You can view all the source changes made in this recipe at <a href="https://github.com/mavasani/roslyn/commit/2c1ec4dc60ab0a64b7e9c01d1ec9a1fbcaa611da">https://github.com/mavasani/roslyn/commit/2c1ec4dc60ab0a64b7e9c01d1ec9a1fbcaa611da</a>.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How it works...</h1>
                </header>
            
            <article>
                
<p>In this recipe, we added basic lowering support for the <span>switch</span> operator <kbd>(?:</kbd>), which enabled us to compile and execute source code with this new operator and give expected runtime results. Note that this is not an optimal implementation of the lowering/code generation phase for this operator, and requires further work to generate optimized MSIL. This is left as an exercise for the reader.</p>
<p>The C# lowering phase is responsible for transforming the initial bound tree from the binder into a simpler bound tree that can be operated by the code generation phase. The code generation phase operates on the lowered bound tree and transforms it into MSIL<span>.</span> In this recipe, we added lowering support for the switch operator that rewrites a switch operator into nested conditional branches.</p>
<p>Let's take an example to clarify the lowering algorithm. Consider the switch expression used in our recipe:</p>
<pre>
args.Length ?: [0, 1, 2] : ["Zero", "One", "Two", "More than two"]
</pre>
<p>This operator gets rewritten into following lowered (pseudo)code:</p>
<pre>
args.Length == 0<br/>  jump to label Val0<br/>args.Length == 1<br/>  jump to label Val1<br/>args.Length == 2<br/>  jump to label Val2<br/>result = "More than two"<br/>  jump to label Exit<br/>Val2:<br/> result = "Two"<br/>   jump to label Exit<br/>Val1:<br/> result = "One"<br/>   jump to label Exit<br/>Val0:<br/> result = "Zero"<br/>   jump to label Exit<br/>Exit:
</pre>
<p>We walk through each constant and compare the value of the expression against this constant. If it succeeds, we jump to a label and evaluate the corresponding switch operator value, load it into the result, and jump to the exit label. If the check fails, then we recursively operate on the remaining labels and values, until the expression doesn't match any constant and we evaluate the last (default) value.</p>
<p>Let's now walk through the details of the code added in the lowering phase that implements the preceding algorithm. <kbd>LocalRewriter</kbd> type implements the bound tree lowering/rewrite. This type is essentially an implementation of <kbd>BoundTreeRewriter</kbd> (<a href="http://source.roslyn.io/#q=BoundTreeRewriter">http://source.roslyn.io/#q=BoundTreeRewriter</a>), which uses a visitor pattern to visit the entire bound tree. It has an overridable <em>VisitXXX</em> method for every bound node to convert it into a simpler rewritten bound node and return the rewritten node. We override the <kbd>VisitSwitchOperator</kbd> method as follows:</p>
<p>Â </p>
<pre>
/// &lt;summary&gt;<br/>/// Rewrite switch operator into nested conditional operators.<br/>/// &lt;/summary&gt;<br/>public override BoundNode <strong>VisitSwitchOperator</strong>(BoundSwitchOperator node)<br/>{<br/> // just a fact, not a requirement (VisitExpression would have rewritten otherwise)<br/> Debug.Assert(node.ConstantValue == null);<br/><br/> var rewrittenExpression = VisitExpression(node.Expression);<br/> var rewrittenLabels = node.Labels.SelectAsArray(l =&gt; VisitExpression(l));<br/> var rewrittenValues = node.Values.SelectAsArray(l =&gt; VisitExpression(l));<br/> var rewrittenType = VisitType(node.Type);<br/> var booleanType = _compilation.GetSpecialType(SpecialType.System_Boolean);<br/><br/> return RewriteSwitchOperator(<br/>  node.Syntax,<br/>  rewrittenExpression,<br/>  rewrittenLabels,<br/>  rewrittenValues,<br/>  rewrittenType,<br/>  booleanType);<br/>}
</pre>
<p>A general requirement and pattern of bound tree rewriter is to first visit each of the child nodes of the bound node and use the rewritten child nodes for the core rewrite functionality. We first rewrite the switch expression, then the labels, values, and the expression type. We also fetch the well-known System.Boolean type to be used in the rewrite helper. We pass all these values into the core rewrite method, <kbd>RewriteSwitchOperator</kbd>:</p>
<pre>
private static BoundExpression <strong>RewriteSwitchOperator</strong>(<br/> SyntaxNode syntax,<br/> BoundExpression rewrittenExpression,<br/> ImmutableArray&lt;BoundExpression&gt; rewrittenLabels,<br/> ImmutableArray&lt;BoundExpression&gt; rewrittenValues,<br/> TypeSymbol rewrittenType,<br/> TypeSymbol booleanType)<br/>{<br/> Debug.Assert(rewrittenLabels.Length &gt;= 1);<br/> Debug.Assert(rewrittenLabels.Length + 1 == rewrittenValues.Length);<br/><br/> var label = rewrittenLabels[0];<br/> var consequence = rewrittenValues[0];<br/> var condition = new BoundBinaryOperator(label.Syntax, BinaryOperatorKind.Equal, rewrittenExpression, label, null, null, LookupResultKind.Viable, booleanType);<br/> BoundExpression alternative = rewrittenLabels.Length &gt; 1 ?<br/>  RewriteSwitchOperator(syntax, rewrittenExpression, rewrittenLabels.RemoveAt(0), rewrittenValues.RemoveAt(0), rewrittenType, booleanType) :<br/>  rewrittenValues[1];<br/> return new BoundConditionalOperator(label.Syntax, condition, consequence, alternative, null, rewrittenType);<br/>}
</pre>
<p>The rewrite method first validates that we are operating on a switch operator with one or more labels, and the count of values is one more than the count of the values (otherwise we would have generated a binding error and the lowering phase wouldn't have executed).</p>
<p>This method uses a recursive approach to rewrite the switch operator. We first generate a <kbd>BoundBinaryOperator</kbd> with the <kbd>==</kbd> operator. The <kbd>rewrittenExpression</kbd> is the left of the operator, and the first label in the <kbd>rewrittenLabels</kbd> is the right. This forms our <kbd>condition</kbd> bound node. The first value in <kbd>rewrittenValues</kbd> list is the <kbd>consequence</kbd>.</p>
<p>If we have more than one <kbd>rewrittenLabels</kbd>, then we recursively invoke <kbd>RewriteSwitchOperator</kbd> using only the remaining <kbd>rewrittenLabels</kbd> and <kbd>rewrittenValues</kbd> <span>except the first ones in each list, and this becomes the</span> <kbd>alternative</kbd><span>. Otherwise, the second label in the current</span> <kbd>rewrittenValues</kbd> <span>list becomes the</span> alternative<span>.</span></p>
<p><span>Finally, we use the preceding</span> <kbd>condition</kbd> <span>(</span><kbd>BoundBinaryOperator</kbd><span>),</span> <kbd>consequence</kbd> <span>(first rewritten value) and</span> <kbd>alternative</kbd> <span>(recursive rewrite of rest the of the expression) to create a</span> <kbd>BoundConditionalOperator</kbd> <kbd>condition ? consequence : alternative</kbd> <span>and return that as the final rewritten node<em>.</em></span></p>
<div class="packt_infobox">As the lowered bound tree has no new bound node kind, we did not require the adding of any new codegen support (it already handled conditional branches). Refer to the <kbd>CodeGenerator</kbd> (<a href="http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/CodeGen/CodeGenerator.cs,8838d807a9a1d615">http://source.roslyn.io/#Microsoft.CodeAnalysis.CSharp/CodeGen/CodeGenerator.cs,8838d807a9a1d615</a>) type for any implementation details of the code generator.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Writing unit tests for C# parsing, binding, and codegen phases</h1>
                </header>
            
            <article>
                
<p><span>This section will enable you to add unit tests for a new C# language feature:</span> Switch operator <kbd>(?::)</kbd>. <span>For details on the intended functionality of this operator, read the section, <em>New language feature: Switch Operator (?::)</em></span>, <span>at the start of this chapter.</span></p>
<p><span>C# compiler has the following set of unit test projects in Roslyn.sln:</span></p>
<ul>
<li><kbd>CSharpCompilerSyntaxTest</kbd>: This unit tests for parsing and syntax errors.</li>
<li><kbd>CSharpCompilerSemanticTest</kbd><span>: This unit tests for semantic errors and semantic model APIs.</span></li>
<li><kbd>CSharpCompilerSymbolTest</kbd><span>: This unit tests for symbols defined in the compiler layer.</span></li>
<li><kbd>CSharpCommandLineTest</kbd><span>: This unit tests for the compiler's command line options.</span></li>
<li><kbd>CSharpCompilerEmitTest</kbd><span>: This unit tests for the code generation phase that verifies the generated MSIL.</span></li>
</ul>
<p><span>In this section, we will add unit tests to</span> <kbd>CSharpCompilerSyntaxTest</kbd><strong>,</strong> <kbd>CSharpCompilerSemanticTest</kbd> <span>and</span> <kbd>CSharpCompilerEmitTest</kbd> <span>for parsing, binding, and codegen support, respectively</span><span>.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Getting Started</h1>
                </header>
            
            <article>
                
<p><span>You need to ensure that you have enlisted and built Roslyn sources with <em>VS2017</em> tag on your machine. For further guidance, refer to the recipe, <em>Setting up Roslyn enlistment</em> in <a href="a7277d51-330b-45f3-aa10-5a9453afe569.xhtml">Chapter 8</a>, <em>Contribute Simple Functionality to Roslyn C# Compiler Open Source Code</em>.</span></p>
<p>Additionally, the following four git commits on your enlistment to get the syntax definitions, parser support, binder support, and lowering support for the new operator and build <kbd>CSharpCodeAnalysis</kbd> project:</p>
<ul>
<li><a href="https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5">https://github.com/mavasani/roslyn/commit/4b50f662c53e1b9fc83f81a819f29d11b85505d5</a></li>
<li><a href="https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569">https://github.com/mavasani/roslyn/commit/24144442e4faa9c54fe2a4b519455a1a45c29569</a></li>
<li><a href="https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236">https://github.com/mavasani/roslyn/commit/7a666595c8bf8d5e8c897540ec85ae3fa9fc5236</a></li>
<li><a href="https://github.com/mavasani/roslyn/commit/2c1ec4dc60ab0a64b7e9c01d1ec9a1fbcaa611da">https://github.com/mavasani/roslyn/commit/2c1ec4dc60ab0a64b7e9c01d1ec9a1fbcaa611da</a></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How to do it...</h1>
                </header>
            
            <article>
                
<ol start="1">
<li>Open <kbd>Roslyn.sln</kbd> in Visual Studio 2017.</li>
<li>Open source file <kbd>&lt;%REPO_ROOT%&gt;\src\Compilers\CSharp\Test\Syntax\Parsing\ExpressionParsingTests.cs</kbd>.</li>
<li>[Parsing Test] Add the following new unit test at the end of the source file:</li>
</ol>
<pre style="padding-left: 90px">
[Fact]<br/>public void TestSwitchExpression()<br/>{<br/> var text = @"expr ?: [0, 1, 2] : [""Zero"", ""One"", ""Two"", ""More than two""]";<br/> var expr = SyntaxFactory.ParseExpression(text);<br/><br/> Assert.NotNull(expr);<br/> Assert.Equal(SyntaxKind.SwitchExpression, expr.Kind());<br/> Assert.Equal(text, expr. ToString());<br/> Assert.Equal(0, expr.Errors().Length);<br/><br/> var switchExpr = (SwitchExpressionSyntax)expr;<br/> Assert.NotNull(switchExpr.Expression);<br/> Assert.Equal("expr", switchExpr.Expression.ToString());<br/><br/> Assert.NotNull(switchExpr.QuestionColonToken);<br/> Assert.False(switchExpr.QuestionColonToken.IsMissing);<br/><br/> Assert.NotNull(switchExpr.Labels.OpenBracketToken);<br/> Assert.False(switchExpr.Labels.OpenBracketToken.IsMissing);<br/> Assert.Equal(3, switchExpr.Labels.Arguments.Count);<br/> Assert.Equal("0", switchExpr.Labels.Arguments[0].ToString());<br/> Assert.Equal("1", switchExpr.Labels.Arguments[1].ToString());<br/> Assert.Equal("2", switchExpr.Labels.Arguments[2].ToString());<br/> Assert.NotNull(switchExpr.Labels.CloseBracketToken);<br/> Assert.False(switchExpr.Labels.CloseBracketToken.IsMissing);<br/><br/> Assert.NotNull(switchExpr.ColonToken);<br/> Assert.False(switchExpr.ColonToken.IsMissing);<br/><br/> Assert.NotNull(switchExpr.Values.OpenBracketToken);<br/> Assert.False(switchExpr.Values.OpenBracketToken.IsMissing);<br/> Assert.Equal(4, switchExpr.Values.Arguments.Count);<br/> Assert.Equal(@"""Zero""", switchExpr.Values.Arguments[0].ToString());<br/> Assert.Equal(@"""One""", switchExpr.Values.Arguments[1].ToString());<br/> Assert.Equal(@"""Two""", switchExpr.Values.Arguments[2].ToString());<br/> Assert.Equal(@"""More than two""", switchExpr.Values.Arguments[3].ToString());<br/> Assert.NotNull(switchExpr.Values.CloseBracketToken);<br/> Assert.False(switchExpr.Values.CloseBracketToken.IsMissing);<br/>}<br/><br/> CreateCompilationWithMscorlib(source).VerifyDiagnostics();<br/>}
</pre>
<ol start="4">
<li>Build the test project <kbd>CSharpCompilerSyntaxTest</kbd> and execute the unit test on a command-line console using the command line copied from the project's <kbd>Debug</kbd> property page and appending <kbd>-method</kbd> switch for the newly added unit test:</li>
</ol>
<pre style="padding-left: 90px">
&lt;%USERS_FOLDER%&gt;\.nuget\packages\xunit.runner.console\2.2.0-beta4-build3444\tools\xunit.console.x86.exe "&lt;%REPO_ROOT%&gt;\Binaries\Debug\UnitTests\CSharpCompilerSyntaxTest\Roslyn.Compilers.CSharp.Syntax.UnitTests.dll" -html "&lt;%REPO_ROOT%&gt;\Binaries\Debug\UnitTests\CSharpCompilerSyntaxTest\xUnitResults\Roslyn.Compilers.CSharp.Syntax.UnitTests.html" -noshadow -method Microsoft.CodeAnalysis.CSharp.UnitTests.ExpressionParsingTexts.TestSwitchExpression
</pre>
<ol start="5">
<li>Verify the unit test passes successfully:</li>
</ol>
<div class="CDPAlignCenter CDPAlign"><img class="image-border" height="208" src="assets/322e1701-d411-41a3-9893-3ec9bc11616c.png" width="742"/></div>
<div class="packt_tip">If you get a <kbd>DirectoryNotFoundException</kbd>, ensure that the test results directory exists on the machine: <kbd>&lt;%REPO_ROOT%&gt;\Binaries\Debug\UnitTests\CSharpCompilerSyntaxTest\xUnitResults</kbd>.</div>
<ol start="6">
<li>[Binding Test] Open source file <kbd>&lt;%REPO_ROOT%&gt;\src\Compilers\CSharp\Test\Semantic\Semantics\BindingTests.cs</kbd></li>
<li>Add the following new unit test to the source file:</li>
</ol>
<pre style="padding-left: 90px">
[Fact]<br/>public void TestSwitchExpressionBinding()<br/>{<br/> var source =<br/>@"<br/>class Class<br/>{<br/> public static void Main(string[] args)<br/> {<br/> System.Console.WriteLine(args.Length ?: [0, 1, 2] : [""Zero"", ""One"", ""Two"", ""More than two""]);<br/> }<br/>}<br/>";<br/> var compilation = CreateCompilationWithMscorlib(source);<br/> compilation.VerifyDiagnostics();<br/><br/> var tree = compilation.SyntaxTrees[0];<br/> var model = compilation.GetSemanticModel(tree);<br/><br/> var switchExp = (SwitchExpressionSyntax)tree.GetRoot().DescendantNodes().Where(n =&gt; n.IsKind(SyntaxKind.SwitchExpression)).Single();<br/> Assert.Equal(@"args.Length ?: [0, 1, 2] : [""Zero"", ""One"", ""Two"", ""More than two""]", switchExp.ToString());<br/> var symbolInfo = model.GetSymbolInfo(switchExp);<br/> Assert.Null(symbolInfo.Symbol);<br/> var typeInfo = model.GetTypeInfo(switchExp);<br/> Assert.NotNull(typeInfo.Type);<br/> Assert.Equal("string", typeInfo.Type.ToString());<br/><br/> symbolInfo = model.GetSymbolInfo(switchExp.Expression);<br/> Assert.NotNull(symbolInfo.Symbol);<br/> Assert.Equal("System.Array.Length", symbolInfo.Symbol.ToString());<br/><br/> typeInfo = model.GetTypeInfo(switchExp.Expression);<br/> Assert.NotNull(typeInfo.Type);<br/> Assert.Equal("int", typeInfo.Type.ToString());<br/><br/> Assert.Equal(3, switchExp.Labels.Arguments.Count);<br/> var constantValue = model.GetConstantValue(switchExp.Labels.Arguments[0].Expression);<br/> Assert.True(constantValue.HasValue);<br/> Assert.Equal(0, constantValue.Value);<br/> typeInfo = model.GetTypeInfo(switchExp.Labels.Arguments[0].Expression);<br/> Assert.NotNull(typeInfo.Type);<br/> Assert.Equal("int", typeInfo.Type.ToString());<br/><br/> Assert.Equal(4, switchExp.Values.Arguments.Count);<br/> constantValue = model.GetConstantValue(switchExp.Values.Arguments[0].Expression);<br/> Assert.True(constantValue.HasValue);<br/> Assert.Equal("Zero", constantValue.Value);<br/> typeInfo = model.GetTypeInfo(switchExp.Values.Arguments[0].Expression);<br/> Assert.NotNull(typeInfo.Type);<br/> Assert.Equal("string", typeInfo.Type.ToString());<br/>}
</pre>
<p>Â </p>
<ol start="8">
<li>Build the test project <kbd>CSharpCompilerSemanticTest</kbd> and execute the unit test on a command line console by using the command line copied from the project's <kbd>Debug</kbd> property page and appending <kbd>-method</kbd> switch for the newly added unit test:</li>
</ol>
<pre style="padding-left: 90px">
&lt;%USERS_FOLDER%&gt;\.nuget\packages\xunit.runner.console\2.2.0-beta4-build3444\tools\xunit.console.x86.exe "&lt;%REPO_ROOT%&gt;\Binaries\Debug\UnitTests\CSharpCompilerSemanticTest\Roslyn.Compilers.CSharp.Semantic.UnitTests.dll" -html "&lt;%REPO_ROOT%&gt;\Binaries\Debug\UnitTests\CSharpCompilerSemanticTest\xUnitResults\Roslyn.Compilers.CSharp.Semantic.UnitTests.html" -noshadow -method Microsoft.CodeAnalysis.CSharp.UnitTests.Semantics.BindingTests.TestSwitchExpressionBinding
</pre>
<ol start="9">
<li>Verify the unit test passes successfully.</li>
<li>[CodeGen Test] Open source file <kbd>&lt;%REPO_ROOT%&gt;\src\Compilers\CSharp\Test\Emit\CodeGen\CodeGenTests.cs</kbd>.</li>
<li>Add the following new unit test to the source file:</li>
</ol>
<pre style="padding-left: 90px">
[Fact]<br/>public void TestSwitchExpressionCodeGen()<br/>{<br/> string source = @"<br/>class Class<br/>{<br/> public static void Main(string[] args)<br/> {<br/> System.Console.WriteLine(args.Length ?: [0, 1, 2] : [""Zero"", ""One"", ""Two"", ""More than two""]);<br/> }<br/>}";<br/><br/> var compilation = CompileAndVerify(source, options: TestOptions.DebugExe);<br/> compilation.VerifyIL("Class.Main", @"<br/>{<br/> // Code size 51 (0x33)<br/> .maxstack 2<br/> IL_0000: nop<br/> IL_0001: ldarg.0<br/> IL_0002: ldlen<br/> IL_0003: conv.i4<br/> IL_0004: brfalse.s IL_0027<br/> IL_0006: ldarg.0<br/> IL_0007: ldlen<br/> IL_0008: conv.i4<br/> IL_0009: ldc.i4.1<br/> IL_000a: beq.s IL_0020<br/> IL_000c: ldarg.0<br/> IL_000d: ldlen<br/> IL_000e: conv.i4<br/> IL_000f: ldc.i4.2<br/> IL_0010: beq.s IL_0019<br/> IL_0012: ldstr ""More than two""<br/> IL_0017: br.s IL_001e<br/> IL_0019: ldstr ""Two""<br/> IL_001e: br.s IL_0025<br/> IL_0020: ldstr ""One""<br/> IL_0025: br.s IL_002c<br/> IL_0027: ldstr ""Zero""<br/> IL_002c: call ""void System.Console.WriteLine(string)""<br/> IL_0031: nop<br/> IL_0032: ret<br/>}<br/>");<br/>}
</pre>
<ol start="12">
<li>Build the test project <kbd>CSharpCompilerEmitTest</kbd> and execute the unit test on a command-line console by using the command line copied from the project's <kbd>Debug</kbd> property page and appending <kbd>-method</kbd> switch for the newly added unit test:</li>
</ol>
<pre style="padding-left: 90px">
&lt;%USERS_FOLDER%&gt;\.nuget\packages\xunit.runner.console\2.2.0-beta4-build3444\tools\xunit.console.x86.exe "&lt;%REPO_ROOT%&gt;\Binaries\Debug\UnitTests\CSharpCompilerEmitTest\xUnitResults\Roslyn.Compilers.CSharp.Emit.UnitTests.html" -noshadow -method Microsoft.CodeAnalysis.CSharp.UnitTests.CodeGen.CodeGenTests.TestSwitchExpressionCodeGen
</pre>
<ol start="13">
<li>Verify the unit test passes successfully.</li>
</ol>
<div class="packt_tip">You can also execute the unit tests inside Visual Studio using the <span class="packt_screen">Test Explorer</span> window, but the test discovery for <em>Roslyn.sln</em> is quite slow due to thousands of unit tests across the solution. Hence, you might have to wait for a few minutes before you can execute the first unit test.</div>
<div class="packt_infobox"><span>You can view all the source changes made in this recipe at <a href="https://github.com/mavasani/roslyn/commit/ca1b555aef3d3f5dbe4efecda3580822d382a56f">https://github.com/mavasani/roslyn/commit/ca1b555aef3d3f5dbe4efecda3580822d382a56f</a></span>.<span><a href="https://github.com/mavasani/roslyn/commit/ca1b555aef3d3f5dbe4efecda3580822d382a56f"/></span></div>


            </article>

            
        </section>
    </body></html>