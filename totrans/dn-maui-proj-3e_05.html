<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-100"><a id="_idTextAnchor399"/>5</h1>
<h1 id="_idParaDest-101"><a id="_idTextAnchor400"/>A Matchmaking App with a Rich UX Using Animations</h1>
<p>In this chapter, we will create the base functionality for a matchmaking app. We won’t be rating people, however, because of privacy issues. Instead, we will download images from a random source on the internet. This project is for anyone who wants an introduction to how to write reusable controls. We will also look at using animations to make our application feel nicer to use. This app will not be a <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>) application since we want to isolate the creation and usage of a control from the slight overhead of MVVM.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Creating a custom control</li>
<li>Styling the app to look like a photo, with descriptive text beneath it</li>
<li>Creating animations using .NET MAUI</li>
<li>Subscribing to custom events</li>
<li>Reusing the custom control over and over again</li>
<li>Handling pan gestures</li>
</ul>
<h1 id="_idParaDest-102"><a id="_idTextAnchor401"/><a id="_idTextAnchor402"/>Technical requirements</h1>
<p>To be able to complete this chapter’s project, you will need to have Visual Studio for Mac or Windows installed, as well as the necessary .NET MAUI workloads. See <em class="italic">Chapter 1</em>,<em class="italic"> Introduction to .NET MAUI</em>, for more details on how to set up your environment.</p>
<p>You can find the full source for the code in this chapter at <a href="https://github.com/PackPublishing/MAUI-Projects-3rd-Edition">https://github.com/PackPublishing/MAUI-Projects-3rd-Edition</a>.</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor403"/>Project overview</h1>
<p>Many of us have been there, faced with the conundrum of whether to swipe left or right. All of a sudden, you may find yourself wondering: <em class="italic">How does this work? How does the swipe magic happen?</em> Well, in this project, we’re going to learn all about it. We will start by defining a <code>MainPage</code> file in which the images of our application will reside. After that, we will implement the image control, and gradually add the <strong class="bold">graphical user interface</strong> (<strong class="bold">GUI</strong>) and functionality to it until we have nailed the perfect swiping experience.</p>
<p><a id="_idTextAnchor404"/>The build time for this project is about 90 minutes.</p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor405"/>Creating the matchmaking app</h1>
<p>In this project, we will learn more about creating reusable controls that can be added to an <strong class="bold">Extensible Application Markup Language</strong> (<strong class="bold">XAML</strong>) page. To keep things simple, we will not be using MVVM, but bare-metal .NET MAUI without any data binding. What we aim to create is an app that allows the user to swipe images, either to the right or the left, just as most popular matchmaking applications do.</p>
<p>Well, let’s get started by creating the project!</p>
<h2 id="_idParaDest-105"><a id="_idTextAnchor406"/>Setting up the project</h2>
<p>This project, like all the rest, is a <strong class="bold">File</strong> | <strong class="bold">New</strong> | <strong class="bold">Project...</strong>-style project. This means that we will not be importing any code at all. So, this first section is all about creating the project and setting up the basic project structure.</p>
<p>Let’s get started!</p>
<h3><a id="_idTextAnchor407"/><a id="_idTextAnchor408"/><a id="_idTextAnchor409"/>Creating the new project</h3>
<p>So, let’s begin.</p>
<p><a id="_idTextAnchor410"/>The first step is to create a new .NET MAUI project:</p>
<ol>
<li>Open Visual Studio 2022 and select <strong class="bold">Create a </strong><strong class="bold">new project</strong>:</li>
</ol>
<div><div><img alt="Figure 5.1 – Visual Studio 2022" src="img/B19214_05_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.1 – Visual Studio 2022</p>
<p class="list-inset"><a id="_idTextAnchor411"/>This will open the <strong class="bold">Create a new </strong><strong class="bold">project</strong> wizard.</p>
<ol>
<li value="2">In the search field, type <code>maui</code> and select the <strong class="bold">.NET MAUI App</strong> item from the list:</li>
</ol>
<div><div><img alt="Figure 5.2 – Create a new project" src="img/B19214_05_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.2 – Create a new project</p>
<ol>
<li value="3">Cl<a id="_idTextAnchor412"/>ick <strong class="bold">Next</strong>.</li>
<li>Complete the next step of the wizard by naming your project. We will be calling our application <code>Swiper</code> in this case. Move on to the next dialog box by clicking <strong class="bold">Create</strong>, as illustrated in the following screenshot:</li>
</ol>
<div><div><img alt="Figure 5.3 – Configure your new project" src="img/B19214_05_3.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.3 – Configure your new project</p>
<ol>
<li value="5">Cli<a id="_idTextAnchor413"/>ck <strong class="bold">Next</strong>.</li>
<li>The last step will prompt you for the version of .NET Core to support. At the time of writing, .NET 6 is available as <strong class="bold">Long-Term Support</strong> (<strong class="bold">LTS</strong>), and .NET 7 is available as <strong class="bold">Standard Term Support</strong>. For this book, we will assume that you will be using .NET 7:</li>
</ol>
<div><div><img alt="Figure 5.4 – Additional information" src="img/B19214_05_4.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.4 – Additional information</p>
<ol>
<li value="7">Finalize the setup by clicking <strong class="bold">Create</strong> and wait for Visual Studio to create the project.</li>
</ol>
<p>Just like that, the app has been created. Let’s start by designing the <code>MainPage</code> file.</p>
<h3>Desi<a id="_idTextAnchor414"/><a id="_idTextAnchor415"/><a id="_idTextAnchor416"/><a id="_idTextAnchor417"/>gning the MainPage file</h3>
<p>A brand new .NET MAUI Shell app named <code>Swiper</code> has been created, with a single page called <code>MainPage.xaml</code>. This is in the root of the project. We will need to replace the default XAML template with a new layout that will contain our <code>Swiper</code> control.</p>
<p>Let’s edit the already existing <code>MainPage.xaml</code> file by replacing the default content with what we need:</p>
<ol>
<li>Open the <code>MainPage.xaml</code> file.</li>
<li>Replace the content of the page with the following highlighted XAML code:<pre class="source-code">
&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;ContentPage
  xmlns=http://schemas.microsoft.com/dotnet/2021/maui
  
  
  x:Class="Swiper.MainPage"&gt;
<strong class="bold">  &lt;Grid Padding="0,40" x:Name="MainGrid"&gt;</strong>
<strong class="bold">    &lt;Grid.RowDefinitions&gt;</strong>
<strong class="bold">      &lt;RowDefinition Height="400" /&gt;</strong>
<strong class="bold">      &lt;RowDefinition Height="*" /&gt;</strong>
<strong class="bold">    &lt;/Grid.RowDefinitions&gt;</strong>
<strong class="bold">    &lt;Grid Grid.Row="1" Padding="30"&gt;</strong>
<strong class="bold">        &lt;!-- Placeholder for later --&gt;</strong>
<strong class="bold">    &lt;/Grid&gt;</strong>
<strong class="bold">  &lt;/Grid&gt;</strong>
&lt;/ContentPage&gt;</pre></li> </ol>
<p>The XAML code within the <code>ContentPage</code> node defines two grids in the application. A grid is simply a container for other controls. It positions those controls based on rows and columns. The outer grid, in this case, defines two rows that will cover the entire available area of the screen. The first row is 400 units high and the second row, with <code>Height="*"</code>, uses the rest of the available space.</p>
<p>The inner grid, which is defined within the first grid, is assigned to the second row with the <code>Grid.Row="1"</code> attribute. The row and column indexes are zero-based, so <code>"1"</code> actually refers to the second row. We will add some content to this grid later in this chapter, but we’ll leave it empty for now.</p>
<p>Both grids define their padding. You could enter a single number, meaning that all sides will have the same padding, or – as in this case – enter two numbers. We have entered <code>0,40</code>, which means that the left- and right-hand sides should have <code>0</code> units of padding and the top and bottom should have <code>40</code> units of padding. There is also a third option, with four digits, which sets the padding of the <em class="italic">left-hand</em> side, the <em class="italic">top</em>, the <em class="italic">right-hand</em> side, and the <em class="italic">bottom</em>, in that specific order.</p>
<p>The last thing to notice is that we give the outer grid a name, <code>x:Name="MainGrid"</code>. This will make it directly accessible from the code-behind defined in the <code>MainPage.xaml.cs</code> file. Since we are not using MVVM in this example, we will need a way to access the grid<a id="_idTextAnchor418"/> without data binding.</p>
<h2 id="_idParaDest-106">Crea<a id="_idTextAnchor419"/>ting the Swiper control</h2>
<p>The main part of this project involves creating the <code>Swiper</code> control. A control, in a general sense, is a self-contained <code>ContentView</code>, as opposed to <code>ContentPage</code>, which is what XAML pages are. It can be added to any XAML page as an element, or in code in the code-behind file. We will be adding the control from code in this project.</p>
<h3>Crea<a id="_idTextAnchor420"/><a id="_idTextAnchor421"/><a id="_idTextAnchor422"/>ting the control</h3>
<p>Creating the <code>Swiper</code> control is a straightforward process. We just need to make sure that we select the correct item template, which is <strong class="bold">Content View</strong>, by doing the following:</p>
<ol>
<li>In the <code>Swiper</code> project, create a folder called <code>Controls</code>.</li>
<li>Right-click on the <code>Controls</code> folder, select <strong class="bold">Add</strong>, and then click <strong class="bold">New item...</strong>.</li>
<li>Select <strong class="bold">C# Items</strong> and then <strong class="bold">.NET MAUI</strong> from the left pane of the <strong class="bold">Add New Item</strong> dialog box.</li>
<li>Select the <strong class="bold">.NET MAUI ContentView (XAML)</strong> item. Make sure you don’t select the <strong class="bold">.NET MAUI ContentView (C#)</strong> option; this only creates a C# file and not an XAML file.</li>
<li>Name the control <code>SwiperControl.xaml</code>.</li>
<li>Click <strong class="bold">Add</strong>.<p class="list-inset">Refer to the following screenshot to view the preceding information:</p></li>
</ol>
<div><div><img alt="Figure 5.5 – Add New Item" src="img/B19214_05_5.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Add New Item</p>
<p>This <a id="_idTextAnchor423"/>adds an XAML file for the UI and a C# code-behind file. It should look as follows:</p>
<div><div><img alt="Fi﻿﻿gure 5.6 – Solution layout" src="img/B19214_05_6.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Fi<a id="_idTextAnchor424"/><a id="_idTextAnchor425"/>gure 5.6 – Solution layout</p>
<h3>Defining the main grid</h3>
<p>Let’s set the basic structure of the <code>Swiper</code> control:</p>
<ol>
<li>Open the <code>SwiperControl.xaml</code> file.</li>
<li>Replace the content with the highlighted code in the following code block:<pre class="source-code">
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;ContentView 
             
             x:Class="Swiper.Controls.SwiperControl"&gt;
&lt;ContentView.Content&gt;
<strong class="bold">  &lt;Grid&gt;</strong>
<strong class="bold">    &lt;Grid.ColumnDefinitions&gt;</strong>
<strong class="bold">      &lt;ColumnDefinition Width="100" /&gt;</strong>
<strong class="bold">      &lt;ColumnDefinition Width="*" /&gt;</strong>
<strong class="bold">      &lt;ColumnDefinition Width="100" /&gt;</strong>
<strong class="bold">    &lt;/Grid.ColumnDefinitions&gt;</strong>
<strong class="bold">    &lt;!-- ContentView for photo here --&gt;</strong>
<strong class="bold">    &lt;!-- StackLayout for like here --&gt;</strong>
<strong class="bold">    &lt;!-- StackLayout for deny here --&gt;</strong>
<strong class="bold">  &lt;/Grid&gt;</strong>
&lt;/ContentView.Content&gt;
&lt;/ContentView&gt;</pre></li> </ol>
<p>This defines a grid with three columns. The leftmost and rightmost columns will take up 100 units of space, and the center will occupy the rest of the available space. The spaces on the sides will be areas in which we will add labels to highlight the choice that the user has made. We’ve also added three comments that act as placeholders for the XAML code to come in.</p>
<p>We will continue by adding additional XAML to create the photo layout.</p>
<h3>Adding<a id="_idTextAnchor426"/><a id="_idTextAnchor427"/><a id="_idTextAnchor428"/> a content view for the photo</h3>
<p>Now, we will extend the <code>SwiperControl.xaml</code> file by adding a definition of what we want the photo to look like. Our final result will look like <em class="italic">Figure 5</em><em class="italic">.7</em>. Since we are going to pull images off the internet, we’ll display a loading text to make sure that the user gets feedback on what’s going on. To make it look like an instantly printed photo, we added some handwritten text under the photo, as can be seen in the following figure:</p>
<div><div><img alt="Figure 5.7 – The photo UI design" src="img/B19214_05_7.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.7 – The photo UI design</p>
<p>The preceding figure shows what we would like the photo to look like. To make this a reality, we need to add some XAML code to the <code>SwiperControl</code> file by doing the following:</p>
<ol>
<li>Open <code>SwiperControl.xaml</code>.</li>
<li>Add the highlighted XAML code following the <code>&lt;!-- ContentView for photo here --&gt;</code> comment. Make sure that you do not replace the entire <code>ContentView</code> control for the page; just add this under the comment, as illustrated in the following code block. The rest of the page should be untouched:<pre class="source-code">
<strong class="bold">&lt;!-- ContentView for photo here --&gt;</strong>
  &lt;ContentView x:Name="photo" Padding="40" Grid.ColumnSpan="3" &gt;
    &lt;Grid x:Name="photoGrid" BackgroundColor="Black" Padding="1" &gt;
      &lt;Grid.RowDefinitions&gt;
        &lt;RowDefinition Height="*" /&gt;
        &lt;RowDefinition Height="40" /&gt;
      &lt;/Grid.RowDefinitions&gt;
      &lt;BoxView Grid.RowSpan="2" BackgroundColor="White" /&gt;
<a id="_idTextAnchor429"/>      &lt;Image x:Name="image" Margin="10" BackgroundColor="#AAAAAA" Aspect="AspectFill" /&gt;
      &lt;Label x:Name="loadingLabel" Text="Loading..." TextColor="White" FontSize="Large" FontAttributes="Bold" HorizontalOptions="Center" VerticalOptions="Center" /&gt;
      &lt;Label Grid.Row="1" x:Name="descriptionLabel" Margin="10,0" Text="A picture of grandpa" FontFamily="Bradley Hand" /&gt;
    &lt;/Grid&gt;
  &lt;/ContentView&gt;</pre></li> </ol>
<p>A <code>ContentView</code> control defines a new area where we can add other controls. One very important feature of a <code>ContentView</code> control is that it only takes one child control. Most of the time, we would add one of the available layout controls. In this case, we’ll use a <code>Grid</code> control to lay out the control, as shown in the preceding code.</p>
<p>The grid defines two rows:</p>
<ul>
<li>A row for the photo itself, which takes up all the available space when the other rows have been allocated space</li>
<li>A row for the comment, which will be exactly 40 units in height</li>
</ul>
<p>The <code>Grid</code> control itself is set to use a black background and a padding of 1. This, in combination with a <code>BoxView</code> control, which has a white background, creates the frame that we see around the control. The <code>BoxView</code> control is also set to span both rows of the grid (<code>Grid.RowSpan="2"</code>), taking up the entire area of the grid, minus the padding.</p>
<p>The <code>Image</code> control comes next. It has a background color set to a nice gray tone (<code>#AAAAAA</code>) and a margin of 40, which will separate it a bit from the frame around it. It also has a hardcoded name (<code>x:Name="image"</code>), which will allow us to interact with it from the code-behind. The last attribute, called <code>Aspect</code>, determines what we should do if the image control isn’t of the same ratio as the source image. In this case, we want to fill the entire image area, but not show any blank areas. This effectively crops the image either in terms of height or width.</p>
<p>W<a id="_idTextAnchor430"/><a id="_idTextAnchor431"/>e finish off by adding two labels, which also have hardcoded names for later reference.</p>
<p>That’s a wrap on the XAML for now; let’s move on to creating a description for the photo.</p>
<h3>C<a id="_idTextAnchor432"/>reating the DescriptionGenerator class</h3>
<p>At the bottom of the image, we can see a description. Since we don’t have any general descriptions of the images from our upcoming image source, we need to create a generator that makes up descriptions. Here’s a simple, yet fun, way to do it:</p>
<ol>
<li>Create a folder called <code>Utils</code> in the <code>Swiper</code> project.</li>
<li>Create a new class called <code>DescriptionGenerator</code> in that folder.</li>
<li>Add the following code to this class:<pre class="source-code">
internal class DescriptionGenerator
{
  private string[] _adjectives = { "nice", "horrible", "great", "terribly old", "brand new" };
  private string[] _other = { "picture of grandpa", "car", "photo of a forest", "duck" };
  private static Random random = new();
  public string Generate()
  {
    var a = _adjectives[random.Next(_adjectives.Count())];
    var b = _other[random.Next(_other.Count())];
    return $"A {a} {b}";
  }
}</pre></li> </ol>
<p>This class only has one purpose: it takes one random word from the <code>_adjectives</code> array and combines it with a random word from the <code>_other</code> array. By calling the <code>Generate()</code> method, we get a fresh new combination. Feel free to enter your own words in the arrays. Note that the <code>Random</code> instance is a static field. This is because if we create new instances of the <code>Random</code> class that are too close to each other in time, they get seeded with the same value and return the same sequence of random numbers.</p>
<p>Now that we can create a fun description for the photo, we need a way to capture the image and description for the photo.</p>
<h3>C<a id="_idTextAnchor433"/><a id="_idTextAnchor434"/><a id="_idTextAnchor435"/>reating a Picture class</h3>
<p>To abstract all the information about the image we want to display, we’ll create a class that encapsulates this information. There isn’t much information in our <code>Picture</code> class, but it is good coding practice to do this. Proceed as follows:</p>
<ol>
<li>Create a new class called <code>Picture</code> in the <code>Utils</code> folder.</li>
<li>Add the following code to the class:<pre class="source-code">
public class Picture
{
  public Uri Uri { get; init; }
  public string Description { get; init; }
  public Picture()
  {
    Uri = new Uri($"https://picsum.photos/400/400/?random&amp;ts={DateTime.Now.Ticks}");
     var generator = new DescriptionGenerator();
     Description = generator.Generate();
  }
}</pre></li> </ol>
<p>The <code>Picture</code> class has the following two public properties:</p>
<ul>
<li>The <code>Uri</code> property, which points to its location on the internet</li>
<li>A description of that image, exposed as the <code>Description</code> property</li>
</ul>
<p>In the constructor, we create a new URI, which points to a public source of test photos that we can use. The width and height are specified in the query string part of the URI. We also append a random timestamp to avoid the images being cached by .NET MAUI. This generates a unique URI each time we request an image.</p>
<p>We then use the <code>DescriptionGenerator</code> class that we created previously to generate a random description for the image.</p>
<p>Note that the properties don’t define a <code>set</code> method, but instead use <code>init</code>. Since we never need to change the values of <code>URL</code> or <code>Description</code> after the object is created, the properties can be read-only. <code>init</code> only allows the value to be set before the constructor completes. If you try to set the value after the constructor has run, the compiler will generate an error.</p>
<p>Now that we have all the pieces we need to start displaying images, let’s start pulling it all together.</p>
<h3>B<a id="_idTextAnchor436"/><a id="_idTextAnchor437"/><a id="_idTextAnchor438"/>inding the picture to the control</h3>
<p>Let’s begin to wire up the <code>Swiper</code> control so that it starts displaying images. We need to set the source of an image, and then control the visibility of the loading label based on the status of the image. Since we are using an image fetched from the internet, it might take a couple of seconds to download. A good UI will provide the user with proper feedback to help them avoid confusion r<a id="_idTextAnchor439"/>egarding what is going on.</p>
<p>We will begin by setting the source for the image.</p>
<h4>S<a id="_idTextAnchor440"/>etting the source</h4>
<p>The <code>Image</code> control (referred to as <code>image</code> in the code) has a <code>source</code> property. This property is of the <code>ImageSource</code> abstract type. There are a few different types of image sources that you can use. The one we are interested in is the <code>UriImageSource</code> type, which takes a URI, downloads the image, and allows the image control to display it.</p>
<p>Let’s extend the <code>Swiper</code> control so that we can set the source and description:</p>
<ol>
<li>Open the <code>Controls/Swiper.Xaml.cs</code> file (the code-behind for the <code>Swiper</code> control).</li>
<li>Add a <code>using</code> statement for <code>Swiper.Utils</code>  (<code>using Swiper.Utils;</code>) since we will be using the <code>Picture</code> class from that namespace.</li>
<li>Add the following highlighted code to the constructor:<pre class="source-code">
public SwiperControl()
{
  InitializeComponent();
<strong class="bold">  var picture = new Picture();</strong>
<strong class="bold">  descriptionLabel.Text = picture.Description;</strong>
<strong class="bold">  image.Source = new UriImageSource() { Uri = picture.Uri };</strong>
}</pre></li> </ol>
<p>Here, we create a new instance of a <code>Picture</code> class and assign the description to the <code>descriptionLabel</code> control in the GUI by setting the text property of that control. Then, we set the source of the image to a new instance of the <code>UriImageSource</code> class, and assign the URI from the <code>picture</code> instance. This will cause the image to be downloaded from the internet, and display it as soon as it is downloaded.</p>
<p>Next, we will change the visibility of the loading label for positive user feedback.</p>
<h4>C<a id="_idTextAnchor441"/><a id="_idTextAnchor442"/><a id="_idTextAnchor443"/>ontrolling the loading label</h4>
<p>While the image is downloading, we want to show a loading text centered over the image. This is already in the XAML file that we created earlier, so what we need to do is hide it once the image has been downloaded. We will do this by controlling the <code>IsVisibleProperty</code> property (yes, the property is actually named <code>IsVisibleProperty</code>) of the <code>loadingLabel</code> control by setting a binding to the <code>IsLoading</code> property of the image. Any time the <code>IsLoading</code> property is changed on the image, the binding changes the <code>IsVisible</code> property on the label. This is a nice fire-and-forget approach.</p>
<p>You might have noticed that we are using a binding when we said that we wouldn’t be using bindings at the beginning of this chapter. This is used as a shortcut, to avoid us having to write the code that would do essentially the same thing as this binding does. And to be fair, while we did say no MVVM and data binding, we are binding to ourselves, not between classes, so all the code is self-contained inside the <code>Swiper</code> control.</p>
<p>Let’s add the code needed to control the <code>loadingLabel</code> control, as follows:</p>
<ol>
<li>Open the <code>Swiper.xaml.cs</code> code-behind file.</li>
<li>Add the following code marked in bold to the constructor:<pre class="source-code">
public SwiperControl()
{
  InitializeComponent();
  var picture = new Picture();
  descriptionLabel.Text = picture.Description;
  image.Source = new UriImageSource() { Uri = picture.Uri };
<strong class="bold">  loadingLabel.SetBinding(IsVisibleProperty, "IsLoading");</strong>
<strong class="bold">  loadingLabel.BindingContext = image;</strong>
}</pre></li> </ol>
<p>In the preceding code, the <code>loadingLabel</code> control sets a binding to the <code>IsVisibleProperty</code> property, which belongs to the <code>VisualElement</code> class that all controls inherit from. It tells <code>loadingLabel</code> to listen to changes in the <code>IsLoading</code> property of whichever object is assigned to the binding context. In this case, this is the image control.</p>
<p>Next, we will allow the user to “swipe right” or “swipe left.”</p>
<h3>H<a id="_idTextAnchor444"/><a id="_idTextAnchor445"/>andling pan gestures</h3>
<p>A core feature of this app is the pan gesture. A pan gesture is when a user presses on the control and moves it around the screen. We will also add a random rotation to the <code>Swiper</code> control to make it look like there are photos in a stack when we add multiple images.</p>
<p>W<a id="_idTextAnchor446"/>e will start by adding some fields to the <code>SwiperControl</code> class, as follows:</p>
<ol>
<li>Open the <code>SwiperControl.xaml.cs</code> file.</li>
<li>Add the following fields in the code to the class:<pre class="source-code">
private readonly double _initialRotation;
private static readonly Random _random = new Random();</pre></li> </ol>
<p>The first field, <code>_initialRotation</code>, stores the initial rotation of the image. We will set this in the constructor. The second field is a <code>static</code> field containing a <code>Random</code> object. As you might remember, it’s better to create one static random object to make sure multiple random objects don’t get created with the same seed. The seed is based on time, so if we create objects too close in time to each other, they get the same random sequence generated, so it wouldn’t be that random at all.</p>
<p>The next thing we have to do is create an event handler for the <code>PanUpdated</code> event that we will bind to at the end of this section, as follows:</p>
<ol>
<li>Open the <code>SwiperControl.xaml.cs</code> code-behind file.</li>
<li>Add the <code>OnPanUpdated</code> method to the class, like this:<pre class="source-code">
private void OnPanUpdated(object sender, PanUpdatedEventArgs e)
{
  switch (e.StatusType)
  {
    case GestureStatus.Started: PanStarted();
    break;
    case GestureStatus.Running: PanRunning(e);
    break;
    case GestureStatus.Completed: PanCompleted();
    break;
  }
}</pre></li> </ol>
<p>This code is straightforward. We handle an event that takes a <code>PanUpdatedEventArgs</code> object as the second argument. This is a standard method of handling events. We then have a <code>switch</code> clause that checks which status the event refers to.</p>
<p>A<a id="_idTextAnchor447"/> pan gesture can have the following three states:</p>
<ul>
<li><code>GestureStatus.Started</code>: The event is raised once with this state when the panning begins</li>
<li><code>GestureStatus.Running</code>: The event is then raised multiple times, once for each time you move your finger</li>
<li><code>GestureStatus.Completed</code>: The event is raised one last time when you let go</li>
</ul>
<p>For each of these states, we call specific methods that handle the different states. We’ll continue with adding those methods now:</p>
<ol>
<li>Open the <code>SwiperControl.xaml.cs</code> code-behind file.</li>
<li>Add the following three methods to the class, like this:<pre class="source-code">
private void PanStarted()
{
  photo.ScaleTo(1.1, 100);
}
private void PanRunning(PanUpdatedEventArgs e)
{
  photo.TranslationX = e.TotalX;
  photo.TranslationY = e.TotalY;
  photo.Rotation = _initialRotation + (photo.TranslationX / 25);
}
private void PanCompleted()
{
  photo.TranslateTo(0, 0, 250, Easing.SpringOut);
  photo.RotateTo(_initialRotation, 250, Easing.SpringOut);
  photo.ScaleTo(1, 250);
}</pre></li> </ol>
<p>Let’s start by looking at <code>PanStarted()</code>. When the user starts dragging the image, we want to add the effect of it raising a little bit over the surface. This is done by scaling the image by 10%. .NET MAUI has a set of excellent functions to do this. In this case, we call the <code>ScaleTo()</code> method on the image control (named <code>Photo</code>) and tell it to scale to <code>1.1</code>, which corresponds to 10% of its original size. We also tell it to do this within a duration of <code>100</code> <strong class="bold">milliseconds</strong> (<strong class="bold">ms</strong>). This call is also awaitable, which means we can wait for the control to finish animating before executing the next call. In this case, we are going to use a fire-and-forget approach.</p>
<p>Next, we have <code>PanRunning()</code>, which is called multiple times during the pan operation. This takes an argument, called <code>PanUpdatedEventArgs</code>, from the event handler that <code>PanRunning()</code> is called from. We could also just pass in <em class="italic">X</em> and <em class="italic">Y</em> values as arguments to reduce the coupling of the code. This is something that you can experiment with. The method extracts the <em class="italic">X</em> and <em class="italic">Y</em> components from the <code>TotalX</code>/<code>TotalY</code> properties of the event and assigns them to the <code>TranslationX</code>/<code>TranslationY</code> properties of the image control. We also adjust the rotation slightly, based on how far the image has been moved.</p>
<p>The last thing we need to do is restore everything to its initial state when the image is released. This can be done in <code>PanCompleted()</code>. First, we translate (or move) the image back to its original local coordinates (<code>0,0</code>) in <code>250</code> ms. We also added an easing function to make it overshoot the target a bit and then animate back. We can play around with the different predefined easing functions; these are useful for creating nice animations. We do the same to move the image back to its initial rotation. Finally, we scale it back to its original size in <code>250</code> ms.</p>
<p>Now, it’s time to add the code in the constructor that will wire up the pan gesture and set some initial rotation values. Proceed as follows:</p>
<ol>
<li>Open the <code>SwiperControl.xaml.cs</code> code-behind file.</li>
<li>Add the highlighted code to the constructor. Note that there is more code in the constructor, so don’t overwrite the whole method; just add the bold text shown in the following code block:<pre class="source-code">
public SwiperControl()
{
  InitializeComponent();
  var panGesture = new PanGestureRecognizer();
  panGesture.PanUpdated += OnPanUpdated;
  this.GestureRecognizers.Add(panGesture);
  _initialRotation = _random.Next(-10, 10);
  photo.RotateTo(_initialRotation, 100, Easing.SinOut);
  var picture = new Picture();
  descriptionLabel.Text = picture.Description;
  image.Source = new UriImageSource() { Uri = picture.Uri };
  loadingLabel.SetBinding(IsVisibleProperty, "IsLoading");
  loadingLabel.BindingContext = image;
}</pre></li> </ol>
<p>A<a id="_idTextAnchor448"/>ll .NET MAUI controls have a property called <code>GestureRecognizers</code>. There are different types of gesture recognizers, such as <code>TapGestureRecognizer</code> or <code>SwipeGestureRecognizer</code>. In our case, we are interested in the <code>PanGestureRecognizer</code> type. We create a new <code>PanGestureRecognizer</code> instance and subscribe to the <code>PanUpdated</code> event by hooking it up to the <code>OnPanUpdated()</code> method we created earlier. Then, we add it to the <code>Swiper</code> controls <code>GestureRecognizers</code> collection.</p>
<p>After this, we set an initial rotation of the image and make sure we store the current rotation value so that we can modify t<a id="_idTextAnchor449"/>he rotation, and then rotate it back to the original state.</p>
<p>Next, we will wire up the control temporarily so that we can test it out.</p>
<h2 id="_idParaDest-107">T<a id="_idTextAnchor450"/>esting the control</h2>
<p>We now have all the code written to take the control for a test run. Proceed as follows:</p>
<ol>
<li>Open <code>MainPage.xaml.cs</code>.</li>
<li>Add a <code>using</code> statement for the <code>Swiper.Controls</code> (<code>using Swiper.Controls;</code>).</li>
<li>Add the following code marked in bold to the constructor:<pre class="source-code">
public MainPage()
{
  InitializeComponent();
  <strong class="bold">MainGrid.Children.Add(new SwiperControl());</strong>
}</pre></li> </ol>
<p>If all goes well with the build, we should end up with a photo like the one shown in the following figure:</p>
<div><div><img alt="Figure 5.8 – Testing the app" src="img/B19214_05_8.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 5.8 – Testing the app</p>
<p>W<a id="_idTextAnchor451"/>e can also drag the photo around (pan it). Notice the slight lift effect when you begin dragging, and the rotation of the photo based on the amount of translation, which is the t<a id="_idTextAnchor452"/>otal movement. If you let go of the photo, it animates back into place.</p>
<p>Now that we have the <a id="_idIndexMarker572"/>control displaying the photo and can swipe it left or right, we need to act on those swipes.</p>
<h3><a id="_idTextAnchor453"/>Creating decision zones</h3>
<p>A matchmaking app<a id="_idIndexMarker573"/> is nothing without those special drop zones on each side of the screen. We want to do a few things here:</p>
<ul>
<li>When a user drags an image to either side, text should appear that says <code>LIKE</code> or <code>DENY</code> (the decision zones)</li>
<li>When a user drops an image on a decision zone, the app should remove the image from the page</li>
</ul>
<p>We will create these zones by adding some XAML code to the <code>SwiperControl.xaml</code> file and then add the necessary code to make this happen. It is worth noting that the zones are not hotspots for dropping the image, but rather for displaying labels on top of the control surface. The actual drop zones are calculated and determined<a id="_idTextAnchor454"/> based on how far you drag the image.</p>
<p>The first step<a id="_idIndexMarker574"/> is to add the UI for the left and right swipe actions<a id="_idTextAnchor455"/>.</p>
<h3>Extending the grid</h3>
<p>The <code>Swiper</code> control has <a id="_idIndexMarker575"/>three columns (left, right, and center) defined. We want to add some kind of visual feedback to the user if the image is dragged to either side of the page. We will do this by adding a <code>StackLayout</code> control with a <code>Label</code> control on each side.</p>
<p>We will add the right-hand side firs<a id="_idTextAnchor456"/><a id="_idTextAnchor457"/>t.</p>
<h4>Adding the StackLayout for liking photos</h4>
<p>The first <a id="_idIndexMarker576"/>thing we need to do is add the <code>StackLayout</code> control for liking photos on the right-hand side of the control:</p>
<ol>
<li>Open <code>Controls/SwiperControl.xaml</code>.</li>
<li>Add the following code under the <code>&lt;!-- StackLayout for like here --&gt;</code> comment:<pre class="source-code">
&lt;StackLayout Grid.Column="2" x:Name="likeStackLayout" Opacity="0" Padding="0, 100"&gt;
  &lt;Label Text="LIKE" TextColor="Lime" FontSize="30" Rotation=<a id="_idTextAnchor458"/>"30" FontAttributes="Bold" /&gt;
&lt;/StackLayout&gt;</pre></li> </ol>
<p>The <code>StackLayout</code> control is the container of child elements that we want to display. It has a name and is assigned to be rendered in the third column (it says <code>Grid.Column="2"</code> in the code due to the zero indexing). The <code>Opacity</code> property is set to <code>0</code>, making it completely invisible, and the <code>Padding</code> property is adjusted to make it move down a bit from the top.</p>
<p>Inside the <code>StackLayout</code> control, we’ll add the <code>Label</code> control.</p>
<p>Now that we have the right-hand side, let’s add the le<a id="_idTextAnchor459"/><a id="_idTextAnchor460"/>ft.</p>
<h4>Adding the StackLayout for denying photos</h4>
<p>The next <a id="_idIndexMarker577"/>step is to add the <code>StackLayout</code> control for denying photos on the left-hand side of the control:</p>
<ol>
<li>Open <code>Controls/SwiperControl.xaml</code>.</li>
<li>Add the following code under the <code>&lt;!-- StackLayout for deny here --&gt;</code> comment:<pre class="source-code">
&lt;StackLayout x:Name="denyStackLayout" Opacity="0" Padding="0, 100" HorizontalOptions="Start"&gt;
  &lt;Label Text="DENY" TextColor="Red" FontSize="30" Rotation="-20" FontAttributes="Bold" /&gt;
&lt;/StackLayout&gt;</pre></li> </ol>
<p>The setup for the left-hand side <code>StackLayout</code> is the same, except that it should be in the first column, which is the default, so there is no need to add a <code>Grid.Column</code> attribute. We have also specified <code>HorizontalOptions="End"</code>, which means that the content shoul<a id="_idTextAnchor461"/>d be right-justified.</p>
<p>With the UI all set, we can now work on the logic for providing the user visual feedback by adjusting the opacity of the <code>LIKE</code> or <code>DENIED</code> text controls as the photo is pan<a id="_idTextAnchor462"/>ned.</p>
<h3>Determining the screen size</h3>
<p>To be able to calculate<a id="_idIndexMarker578"/> the percentage of how far the user has dragged the image, we need to know the size of the control. This is not determined until the control is laid out by .NET <a id="_idTextAnchor463"/>MAUI.</p>
<p>We will override the <code>OnSizeAllocated()</code> method and add a <code>_screenWidth</code> field in the class to keep track of the current width of the window:</p>
<ol>
<li>Open <code>SwiperControl.xaml.cs</code>.</li>
<li>Add the following code to the file, putting the field at the beginning of the class and the <code>OnSizeAllocated()</code> method below the constructor:<pre class="source-code">
private double _screenWidth = -1;
protected override void OnSizeAllocated(double width, double height)
{
  base.OnSizeAllocated(width, height);
  if (Application.Current.MainPage == null)
  {
    return;
  }
  _screenWidth = Application.Current.MainPage.Width;
}</pre></li> </ol>
<p>The <code>_screenWidth</code> field is used to store the width as soon as we have resolved it. We do this by overriding the <code>OnSizeAllocated()</code> method that is called by .NET MAUI when the size of the control is allocated. This is called multiple times. The first time it’s called is actually before the width and height have been set and before the <code>MainPage</code> property of the current app is set. At this time, the width and height are set to <code>-1</code>, and the <code>Application.Current.MainPage</code> property is <code>null</code>. We look for this state by null-checking <code>Application.Current.MainPage</code> and returning if it is <code>null</code>. We could also have checked for <code>-1</code> values on the width. Either method would work. If it does have a value, however, we want to store it in our <code>_screenWidth</code> field for later use.</p>
<p>.NET MAUI will call the <code>OnSizeAllocated()</code> method any time the frame of the app changes. This is most relevant for <strong class="bold">WinUI</strong> apps since they are in a window that a user can easily change. Android <a id="_idIndexMarker579"/>and iOS apps are less likely to get a call to this method a second time since the app will take up the entire screen’s real e<a id="_idTextAnchor464"/><a id="_idTextAnchor465"/><a id="_idTextAnchor466"/><a id="_idTextAnchor467"/>state.</p>
<h3>Adding code to calculate the state</h3>
<p>To calculate the<a id="_idIndexMarker580"/> state of the image, we need to define what our zones are, and then create a function that takes the current amount of movement and updates the opacity of <a id="_idTextAnchor468"/>the GUI decision zones based on how far we panned the<a id="_idTextAnchor469"/> image.</p>
<h4>Deﬁning a method for calculating the state</h4>
<p>Let’s add<a id="_idIndexMarker581"/> the <code>CalculatePanState()</code> method to calculate how far we have panned the image, and if it should start to affect the GUI, by following these few steps:</p>
<ol>
<li>Open <code>Controls/SwiperControl.xaml.cs</code>.</li>
<li>Add the properties at the top and the <code>CalculatePanState()</code> method anywhere in the class, as shown in the following code block:<pre class="source-code">
private const double DeadZone = 0.4d;
private const double DecisionThreshold = 0.4d;
private void CalculatePanState(double panX)
{
  var halfScreenWidth = _screenWidth / 2;
  var deadZoneEnd = DeadZone * halfScreenWidth;
  if (Math.Abs(panX) &lt; deadZon<a id="_idTextAnchor470"/>eEnd)
  {
    return;
  }
  var passedDeadzone = panX &lt; 0 ? panX + deadZoneEnd : panX - deadZoneEnd;
  var decisionZoneEnd = DecisionThreshold * halfScreenWidth;
  var opacity = passedDeadzone / decisionZoneEnd;
  opacity = double.Clamp(opacity, -1, 1);
  likeStackLayout.Opacity = opacity;
  denyStackLayout.Opacity = -opacity;
}</pre></li> </ol>
<p>We define the following two values as constants:</p>
<ul>
<li><code>DeadZone</code>, which defines that 40% (<code>0.4</code>) of the available space on either side of the center point is a dead zone when panning an image. If we release the image in this zone, it simply returns to the center of the screen without any action being taken.</li>
<li>The next constant is <code>DecisionThreshold</code>, which defines another 40% (<code>0.4</code>) of the available space. This is used for interpolating the opacity of <code>StackLayout</code> on either side of the layout.</li>
</ul>
<p>We then use these values to check the state of the panning action whenever the panning changes. If the absolute panning value of <em class="italic">X</em> (<code>panX</code>) is less than the dead zone, we return without<a id="_idIndexMarker582"/> any action being taken. If not, we calculate how far over the dead zone we have passed and how far into the decision zone we are. We calculate the opacity values based on this interpolation and clamp the value between <code>-1</code> and <code>1</code>.</p>
<p>Finally, we set the opacity to this value for both <code>likeStackLayout</code> and <code>denySta<a id="_idTextAnchor471"/><a id="_idTextAnchor472"/>ckLayout</code>.</p>
<h4>Wiring up the pan state check</h4>
<p>While the image is being panned, we want to update the state, as follows:</p>
<ol>
<li>Open <code>Controls/SwiperControl.xaml.cs</code>.</li>
<li>Add the following code in bold to the <code>PanRunning()</code> method:<pre class="source-code">
private void PanRunning(PanUpdatedEventArgs e)
{
  photo.TranslationX = e.TotalX; photo.TranslationY =<a id="_idTextAnchor473"/> e.TotalY;
  photo.Rotation = _initialRotation + (photo.TranslationX / 25);
  <strong class="bold">CalculatePanState(e.TotalX);</strong>
}</pre></li> </ol>
<p>This addition to the <code>PanRunning()</code> method passes the total amount of movement on the <em class="italic">x axis</em> to <a id="_idIndexMarker583"/>the <code>CalculatePanState()</code> method, to determine if we need to adjust the opacity of either <code>StackLayout</code> on the right or the left of th<a id="_idTextAnchor474"/><a id="_idTextAnchor475"/>e control.</p>
<h3>Adding exit logic</h3>
<p>So far, all is well, except for the fact<a id="_idIndexMarker584"/> that if we drag an image to the edge and let go, the text stays. We need to determine when the user stops dragging the image, and, if so,<a id="_idTextAnchor476"/> whether or not the image is in a decision zone.</p>
<p>Let’s add the code needed to animate the photo back to its origina<a id="_idTextAnchor477"/>l position.</p>
<h4>Checking if the image should exit</h4>
<p>We want a simple function that determines if an image has panned far enough for it to count as an exit of that image. To create such a function, proceed as follows:</p>
<ol>
<li>Open <code>Controls/SwiperControl.xaml.cs</code>.</li>
<li>Add the <code>CheckForExitCriteria()</code> method to the class, as shown in the following code snippet:<pre class="source-code">
private bool CheckForExitCriteria()
{
  var halfScreenWidth = _screenWidth / 2;
  var decisionBreakpoint = DeadZone * halfScreenWidth;
  return (Math.Abs(photo.TranslationX) &gt; decisionBreakpoint);
}</pre></li> </ol>
<p>This function calculates whether we have passed over the dead zone and into the decision zone. We need to use the <code>Math.Abs()</code> method to get the total absolute value to compare it against. We could have used <code>&lt;</code> and <code>&gt;</code> operators as well, but we are using this approach as it is more readable. This is a matter of code style and taste – feel free to do i<a id="_idTextAnchor478"/><a id="_idTextAnchor479"/><a id="_idTextAnchor480"/>t your way.</p>
<h4>Removing the image</h4>
<p>If we determine that an<a id="_idIndexMarker585"/> image has panned far enough for it to exit, we want to animate it off the screen and then remove the image from the page. To do this, proceed as follows:</p>
<ol>
<li>Open <code>Controls/SwiperControl.xaml.cs</code>.</li>
<li>Add the <code>Exit()</code> method to the class, as shown in the following code block:<pre class="source-code">
private void Exit()
{
  MainThread.BeginInvokeOnMainThread(async () =&gt;
  {
    var direction = photo.TranslationX &lt; 0 ? -1 : 1;
    await photo.TranslateTo(photo.TranslationX + (_screenWidth * direction), photo.TranslationY, 200, Easing.CubicIn);
    var parent = Parent as Layout;
    parent?.Children.Remove(this);
  });
}</pre></li> </ol>
<p>Let’s break down the preceding code block to understand what the <code>Exit()</code> method does:</p>
<ol>
<li>We begin by making sure that this call is done on the UI thread, which is also known as the <code>MainThread</code> thread. This is because only the UI thread can do animations.</li>
<li>We also need to run this thread asynchronously so that we can kill two birds with one stone. Since this method is all about animating the image to either side of the screen, we need to determine in which direction to animate it. We do this by determining if the total translation of the image is positive or negative.</li>
<li>Then, we use this value to await a translation through the <code>photo.TranslateTo()</code> call.</li>
<li>We <code>await</code> this call since we don’t want the code execution to continue until it’s done. Once it has finished, we remove the control from the parent’s collection of children, causing it to disappear from existe<a id="_idTextAnchor481"/><a id="_idTextAnchor482"/><a id="_idTextAnchor483"/>nce forever.</li>
</ol>
<h4>Updating PanCompleted</h4>
<p>The decision <a id="_idIndexMarker586"/>regarding whether the image<a id="_idIndexMarker587"/> should disappear or simply return to its original state is triggered in the <code>PanCompleted()</code> method. Here, we will wire up the two methods that we created in the previous two sections. Proceed as follows:</p>
<ol>
<li>Open <code>Controls/SwiperControl.xaml.cs</code>.</li>
<li>Add the following code in bold to the <code>PanCompleted()</code> method:<pre class="source-code">
private void PanCompleted()
{
<strong class="bold">  if (CheckForExitCriteria())</strong>
<strong class="bold">  {</strong>
<strong class="bold">    Exit();</strong>
<strong class="bold">  }</strong>
<strong class="bold">  likeStackLayout.Opacity = 0;</strong>
<strong class="bold">  denyStackLayout.Opacity = 0;</strong>
  photo.TranslateTo(0, 0, 250, Easing.SpringOut);
  photo.RotateTo(_initialRotation, 250, Easing.SpringOut);
  photo.ScaleTo(1, 250);
}</pre></li> </ol>
<p>The last step in this section is to use the <code>CheckForExitCriteria()</code> method, and the <code>Exit()</code> method if those criteria are met. If the exit criteria are not met, we need to reset the state and the opacity of <code>StackLayout</code> to make everything go back to normal.</p>
<p>Now that we can<a id="_idIndexMarker588"/> swipe left or swipe right, let’s <a id="_idIndexMarker589"/>add some events to raise when the <a id="_idTextAnchor484"/><a id="_idTextAnchor485"/>user has swiped.</p>
<h3>Adding events to the control</h3>
<p>The last thing we<a id="_idIndexMarker590"/> have left to do in the control itself is add some events that indicate whether the image has been <em class="italic">liked</em> or <em class="italic">denied</em>. We are going to use a clean interface, allowing for simple use of the control while hiding all the implem<a id="_idTextAnchor486"/><a id="_idTextAnchor487"/><a id="_idTextAnchor488"/>entation details.</p>
<h4>Declaring two events</h4>
<p>To make the control <a id="_idIndexMarker591"/>easier to interact with from the application itself, we’ll need to add events for <code>Like</code> and <code>Deny</code>, as follows:</p>
<ol>
<li>Open <code>Controls/SwiperControl.xaml.cs</code>.</li>
<li>Add two event declarations at the beginning of the class, as shown in the following code snippet:<pre class="source-code">
public event EventHandler OnLike;
public event Ev<a id="_idTextAnchor489"/>entHandler OnDeny;</pre></li> </ol>
<p>These are two standard event declarations with out-of-the-b<a id="_idTextAnchor490"/>ox event handlers.</p>
<h4>Raising the events</h4>
<p>We need to add<a id="_idIndexMarker592"/> code in the <code>Exit()</code> method to raise the events we created earlier, as follows:</p>
<ol>
<li>Open <code>Controls/SwiperControl.xaml.cs</code>.</li>
<li>Add the following code in bold to the <code>Exit()</code> method:<pre class="source-code">
private void Exit()
{
  MainThread.BeginInvokeOnMainThread(async () =&gt;
  {
    var direction = photo.TranslationX &lt; 0 ? -1 : 1;
<strong class="bold">    if (direction &gt; 0)</strong>
<strong class="bold">    {</strong>
<strong class="bold">      OnLike?.Invoke(this, new EventArgs());</strong>
<strong class="bold">    }</strong>
<strong class="bold">    if (direction &lt; 0)</strong>
<strong class="bold">    {</strong>
<strong class="bold">      OnDeny?.Invoke(this, new EventArgs());</strong>
<strong class="bold">    }</strong>
    await photo.TranslateTo(photo.TranslationX + (_screenWidth * direction), photo.TranslationY, 200, Easing.CubicIn);
    var parent = Parent as Layout;
    parent?.Children.Re<a id="_idTextAnchor491"/>move(this);
  });
}</pre></li> </ol>
<p>Here, we inject the code to check whether we are liking or denying an i<a id="_idTextAnchor492"/>mage. We then raise the correct event based on this information.</p>
<p>We are now ready to finalize this app; the <code>Swiper</code> control is complete, so now, we need to add the<a id="_idIndexMarker593"/> right initializatio<a id="_idTextAnchor493"/>n code to finish it.</p>
<h2 id="_idParaDest-108"><a id="_idTextAnchor494"/>Wiring up the Swiper control</h2>
<p>We have now reached<a id="_idIndexMarker594"/> the final part of this chapter. In this section, we are going to wire up the images and make our app a closed-loop app that can be used forever. We will add 10 images that we will download from the internet when the app st<a id="_idTextAnchor495"/>arts up. Each time an image is removed, we’ll si<a id="_idTextAnchor496"/>mply add another one.</p>
<h3>Adding images</h3>
<p>Let’s start by creating <a id="_idIndexMarker595"/>some code that will add the images to the <code>MainView</code> class. First, we will add the initial images; then, we will create a logic model for add<a id="_idTextAnchor497"/>ing a new image to the bottom of the stack each time an ima<a id="_idTextAnchor498"/>ge is liked or denied.</p>
<h4>Adding initial photos</h4>
<p>To make the photos look like they are stacked, we need at least 10 of them. Proceed as follows:</p>
<ol>
<li>Open <code>MainPage.xaml.cs</code>.</li>
<li>Add the <code>AddInitalPhotos()</code> method and <code>InsertPhotoMethod()</code> to the class, as illustrated in the following code block:<pre class="source-code">
private void AddInitialPhotos()
{
  for (int i = 0; i &lt; 10; i++)
  {
    InsertPhoto();
  }
}
private void InsertPhoto()
{
  var photo = new SwiperControl();
  this.MainGrid.Childr<a id="_idTextAnchor499"/>en.Insert(0, photo);
}</pre></li> </ol>
<p>First, we create a method called <code>AddInitialPhotos()</code> that will be called upon startup. This method simply calls the <code>InsertPhoto()</code> method 10 times and adds a new <code>SwiperControl</code> to the <code>MainGrid</code> each time. It inserts the control at the first position in the <a id="_idIndexMarker596"/>stack, effectively putting it at the bottom of the pile since the co<a id="_idTextAnchor500"/>llection of controls is rendered from th<a id="_idTextAnchor501"/>e beginning to the end.</p>
<h4>Making the call from the constructor</h4>
<p>We need to call this method for the magic to happen, so follow these steps to do so:</p>
<ol>
<li>Open <code>MainPage.xaml.cs</code>.</li>
<li>Add the following code in bold to the constructor:<pre class="source-code">
public MainPage()
{
  InitializeComponent();
  <strong class="bold">AddInitialPhotos();</strong>
}</pre></li> </ol>
<p>There isn’t much to say here. Once the <code>MainPage</code> object has been initialized<a id="_idTextAnchor502"/>, we call the method to <a id="_idIndexMarker597"/>add 10 random photos that we will dow<a id="_idTextAnchor503"/>nload from the internet.</p>
<h3>Adding count labels</h3>
<p>We want to add <a id="_idIndexMarker598"/>some values to the app as well. We can do this by adding two labels below the collection of <code>Swiper</code> controls. Each time a user rates an image, we will increment one of two counters and display the result.</p>
<p>So, let’s add the XAML code needed to display the labels:</p>
<ol>
<li>Open <code>MainPage.xaml</code>.</li>
<li>Replace the <code>&lt;!-- Placeholder for later --&gt;</code> comment with the following code marked in bold:<pre class="source-code">
&lt;Grid Grid.Row="1" Padding="30"&gt;
<strong class="bold">  &lt;Grid.RowDefinitions&gt;</strong>
<strong class="bold">    &lt;RowDefinition Height="auto" /&gt;</strong>
<strong class="bold">    &lt;RowDefinition Height="auto" /&gt;</strong>
<strong class="bold">    &lt;RowDefinition Height="auto" /&gt;</strong>
<strong class="bold">    &lt;RowDefinition Height="auto" /&gt;</strong>
<strong class="bold">  &lt;/Grid.RowDefinitions&gt;</strong>
<strong class="bold">  &lt;Label Text="LIKES" /&gt;</strong>
<strong class="bold">  &lt;Label x:Nam<a id="_idTextAnchor504"/>e="likeLabel" Grid.Row="1" Text="0" FontSize="Large" FontAttributes="Bold" /&gt;</strong>
<strong class="bold">  &lt;Label Grid.Row="2" Text="DENIED" /&gt;</strong>
<strong class="bold">  &lt;Label x:Name="denyLabel" Grid.Row="3" Text="0" FontSize="Large" FontAttributes="Bold" /&gt;</strong>
&lt;/Grid&gt;</pre></li> </ol>
<p>This code adds a new <code>Grid</code> control with four auto-height rows. This means that we calculate the height of the content of each row and use this for the layout. It is the same thing as <code>StackLayout</code>, but we wanted to demonstrate a better way of doing this.</p>
<p>We add a <code>Label</code> control in each row and name two of them <code>likeLabel</code> and <code>denyLabel</code>. These two named labels will hold information about how many image<a id="_idTextAnchor505"/>s have been liked and <a id="_idIndexMarker599"/><a id="_idTextAnchor506"/>how many have been denied.</p>
<h3>Subscribing to events</h3>
<p>The last step is <a id="_idIndexMarker600"/>to wire up the <code>OnLike</code> and <code>OnDeny</code> events and dis<a id="_idTextAnchor507"/>play t<a id="_idTextAnchor508"/>he total count to the user.</p>
<h4>Adding methods to update the GUI and respond to events</h4>
<p>We need some<a id="_idIndexMarker601"/> code to update the GUI and keep track of the count. Proceed as follows:</p>
<ol>
<li>Open <code>MainPage.xaml.cs</code>.</li>
<li>Add the following code to the class:<pre class="source-code">
private int _likeCount;
private int _denyCount;
private void UpdateGui()
{
  likeLabel.Text = _likeCount.ToString();
  denyLabel.Text = _denyCount.ToString();
}
private void Handle_OnLike(object sender, EventArgs e)
{
  _<a id="_idTextAnchor509"/>likeCount++;
  InsertPhoto();
  UpdateGui();
}
private void Handle_OnDeny(object sender, EventArgs e)
{
  _denyCount++;
  InsertPhoto();
  UpdateGui();
}</pre></li> </ol>
<p>The two fields at the top of the preceding code block keep track of the number of likes and denies. Since they are value-type variables, they default to zero.</p>
<p>To make the changes of these labels show up in the UI, we’ve created a method called <code>UpdateGui()</code>. This takes the value of the two aforementioned fields and assigns it to the <code>Text</code> properties of both labels.</p>
<p>The two methods that follow are the event handlers that will be handling the <code>OnLike</code> and <code>OnDeny</code> events. They <a id="_idIndexMarker602"/>increase the appropriate field, add a new photo, and then update t<a id="_idTextAnchor510"/>he GUI to reflect the change.</p>
<h4>Wiring up events</h4>
<p>Each time<a id="_idIndexMarker603"/> a new <code>SwiperControl</code> instance is created, we need to wire up the events, as follows:</p>
<ol>
<li>Open <code>MainPage.xaml.cs</code>.</li>
<li>Add the following code in bold to the <code>InsertPhoto()</code> method:<pre class="source-code">
private void InsertPhoto()
{
  var photo = new SwiperControl();
<strong class="bold">  photo.OnDeny += Handle_OnDeny;</strong>
<strong class="bold">  photo.OnLike += Handle_OnLike;</strong>
  this.MainGrid.Children.Insert(0, photo);
}</pre></li> </ol>
<p>The added code wires up the event handlers that we defined earlier. The events make it easy to interact with<a id="_idIndexMarker604"/> our new control. Try it for yourself and have a play around with<a id="_idTextAnchor511"/> the app that you have created.</p>
<h1 id="_idParaDest-109"><a id="_idTextAnchor512"/>Summary</h1>
<p>Good job! In this chapter, we learned how to create a reusable, good-looking control that can be used in any .NET MAUI app. To enhance the <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>) of the app, we used some animations that give the user more visual feedback. We also got creative with the use of XAML to define a GUI of the control that looks like a photo, with a hand-written description.</p>
<p>After that, we used events to expose the behavior of the control back to the <code>MainPage</code> page to limit the contact surface between your app and the control. Most importantly of all, we touched on the subject of <code>GestureRecognizers</code>, which can make our life much easier when dealing with common gestures.</p>
<p>Looking for ideas on how to make this app even better? Try this out: keep a history of the likes and dislikes and add a view to display each collection.</p>
<p>In the next chapter, we will create a photo gallery app using the <code>CollectionView</code> and <code>CarouselView</code> controls. The app will also allow you to favorite photos you like by using storage to keep the favorites list between app runs.</p>
</div>
</body></html>