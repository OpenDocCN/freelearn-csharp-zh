- en: Chapter 5. Lightweight Concurrency – Task Parallel Library (TPL)
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 5 章：轻量级并发 – 任务并行库（TPL）
- en: In .NET 4.0, Microsoft delivered what is called the **Task Parallel Library**
    (**TPL**) and answered users' concerns by developing multithreaded applications.
    TPL allows developers to focus on the functionality that they are trying to implement
    and not get bogged down with managing multiple threads, the threadpool, and the
    number of processing cores available to them.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 4.0 中，微软推出了所谓的 **任务并行库（Task Parallel Library，简称 TPL**），并通过开发多线程应用程序来回应用户的关注。TPL
    允许开发者专注于他们试图实现的功能，而不会因为管理多个线程、线程池和可用的处理器核心数量而陷入困境。
- en: So far, we have covered the `BackgroundWorker` component and the `Thread` class
    to show ways to accomplish multithreaded functionality in a C#/.NET application.
    These two ways to perform multithreaded functionality have been around since the
    very early stages of .NET. The `Thread` class was introduced in Version 1.1 of
    .NET and the `BackgroundWorker` in Version 2.0 of .NET. We classify these methods
    as heavyweight concurrency because they take quite a bit of work from the developer
    and add to the complexity of the code's design. The developer has to manage the
    different threads, and to achieve maximum performance, determine the number of
    processing cores in a machine.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经介绍了 `BackgroundWorker` 组件和 `Thread` 类，以展示在 C#/.NET 应用程序中实现多线程功能的方法。这两种实现多线程功能的方法自
    .NET 早期阶段以来一直存在。`Thread` 类是在 .NET 1.1 版本中引入的，而 `BackgroundWorker` 是在 .NET 2.0
    版本中引入的。我们将这些方法归类为重量级并发，因为它们需要开发者做大量工作，并增加了代码设计的复杂性。开发者必须管理不同的线程，并且为了达到最大性能，需要确定机器中的处理器核心数量。
- en: 'After completing this chapter you will:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 完成本章后，你将：
- en: Have a complete understanding of the Task Parallel Library and the different
    classes that make it up
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 完全理解任务并行库及其构成的不同类
- en: Understand how to create and use the `Task` class
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解如何创建和使用 `Task` 类
- en: Understand how tasks are managed in .NET and the threadpool
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解任务在 .NET 和线程池中的管理方式
- en: Understand the `Parallel` class and how to start tasks using it
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `Parallel` 类以及如何使用它启动任务
- en: Know the evolution of multithreading from heavyweight to lightweight concurrency
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 了解多线程从重量级到轻量级并发的演变
- en: Learn when to use tasks instead of `Threads`
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习何时使用任务而非 `线程`
- en: Understand task parallelism versus data parallelism
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解任务并行与数据并行的区别
- en: Understand concurrent data collection and concurrent data processing
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解并发数据收集和并发数据处理
- en: Task Parallel Library
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务并行库
- en: The Task Parallel Library was introduced as part of .NET with the release of
    Version 4.0\. Originally, it was developed under the name Parallel Extensions,
    which was a joint effort by Microsoft Research and the CLR team. Parallel Extensions
    consisted of the TPL and **Parallel LINQ** (**PLINQ**), which we will cover in
    a later chapter. TPL is now preferred over threads and `BackgroundWorker` components
    to develop multithreaded applications.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 任务并行库（Task Parallel Library，简称TPL）作为 .NET 4.0 版本的一部分被引入。最初，它以并行扩展（Parallel Extensions）的名义开发，这是微软研究院和
    CLR 团队共同的努力成果。并行扩展包括 TPL 和 **并行 LINQ（Parallel LINQ，简称 PLINQ**），我们将在后续章节中介绍。现在，TPL
    被优先考虑用于开发多线程应用程序，而不是线程和 `BackgroundWorker` 组件。
- en: The idea was to create a managed concurrency library to take the multithreaded
    capabilities of .NET to the next level. TPL consists of a set of APIs and public
    types located in the `System.Threading` and `System.Threading.Tasks` namespaces.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 理念是创建一个托管并发库，将 .NET 的多线程能力提升到新的水平。TPL 包含一组位于 `System.Threading` 和 `System.Threading.Tasks`
    命名空间中的 API 和公共类型。
- en: One of the advantages of using TPL over threads is that .NET can dynamically
    scale an application to most effectively use the processing cores of the hardware
    it is running. .NET is smart enough to determine the number of processing cores
    in a machine and manage the `ThreadPool` appropriately. When programming with
    threads directly, the developer has to handle this work. No longer does the developer
    have to determine the number of cores and corresponding threads created to achieve
    maximum performance. If you remember our earlier examples with threads and `BackgroundWorker`
    components, we had to do this in code.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 TPL 而不是线程的一个优点是 .NET 可以动态地调整应用程序，以最有效地使用其硬件的处理器核心。.NET 足够智能，可以确定机器中的处理器核心数量，并适当地管理
    `ThreadPool`。当直接使用线程编程时，开发者必须处理这项工作。开发者不再需要确定核心数量和为达到最大性能而创建的相应线程数量。如果你还记得我们之前关于线程和
    `BackgroundWorker` 组件的例子，我们不得不在代码中这样做。
- en: TPL also manages the `ThreadPool` for us. It handles scheduling of threads,
    cancelation of threads, and state management. This managed `ThreadPool` allows
    .NET to have a higher degree of intelligence in managing tasks versus threads.
    The `Task.Factory` class can be told if a task is a long running one that is not
    CPU-intensive versus a CPU-intensive task. With this information, it can be managed
    by the `ThreadPool` to create a single thread per core (CPU-intensive tasks) or
    multiple threads per core (long running tasks that wait on other resources). This
    is the logic that previously needed to be handled by the developer. Now .NET does
    it for you.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 还为我们管理 `ThreadPool`。它处理线程的调度、取消和状态管理。这个托管的 `ThreadPool` 允许 .NET 在管理任务与线程之间有更高的智能度。`Task.Factory`
    类可以被告知一个任务是否是一个长时间运行的非 CPU 密集型任务，或者是一个 CPU 密集型任务。有了这些信息，它可以通过 `ThreadPool` 来管理，为每个核心创建一个线程（CPU
    密集型任务）或为每个核心创建多个线程（长时间运行的任务等待其他资源）。这是以前需要由开发者处理逻辑。现在 .NET 为你处理。
- en: Next, we will examine the center of the TPL, the `Task` class.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查 TPL 的核心，即 `Task` 类。
- en: Exploring tasks
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索任务
- en: The Task class represents some work that can be done atomically in an asynchronous
    manner. It is an item of work executed and managed on the `ThreadPool` by the
    TPL. It is very similar to a thread but with a higher level of abstraction and
    functionality built around it. It is the central control of the Task Parallel
    Library.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 类代表一些可以以异步方式原子执行的工作。它是 TPL 在 `ThreadPool` 上执行和管理的工作项。它与线程非常相似，但围绕它构建了更高层次的概念和功能。它是任务并行库的中心控制。'
- en: The `Task` class has a complete set of methods for status updates, cancelation,
    exception handling, scheduling, and waiting that allows it to be "lightweight"
    compared to the thread. It can also make more efficient use of system resources
    given the functionality that the TPL provides to manage the `ThreadPool` behind
    the scenes.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 类有一套完整的方法用于状态更新、取消、异常处理、调度和等待，这使得它相对于线程来说更“轻量级”。鉴于 TPL 提供的功能来管理后台的 `ThreadPool`，它还可以更有效地使用系统资源。'
- en: 'Let''s start by creating and executing a task. First, we will create a couple
    of methods that will represent the work to be done. Then we will execute this
    work using tasks. There are two main ways to accomplish this: `Parallel.Invoke`
    and `Task.Factory.StartNew`. Let''s take a look at each. We will start with tasks
    that do not return a value. The next section will look at ways to run tasks that
    return values.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建并执行一个任务。首先，我们将创建几个方法来表示要完成的工作。然后我们将使用任务来执行这项工作。主要有两种方法可以实现这一点：`Parallel.Invoke`
    和 `Task.Factory.StartNew`。让我们分别看看。我们将从不需要返回值的任务开始。下一节将探讨运行返回值的任务的方法。
- en: How to do it
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: We will start by creating a new console application using Visual Studio 2013\.
    We will name our application, `TaskExample`.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用 Visual Studio 2013 创建一个新的控制台应用程序。我们将把我们的应用程序命名为 `TaskExample`。
- en: First, we will add two `using` statements to the `Program.cs` file to allow
    us to work with the TPL classes.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将向 `Program.cs` 文件中添加两个 `using` 语句，以便我们可以使用 TPL 类。
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Next, let''s define three different `static` methods that will represent the
    work done by three tasks: `WriteNumbers`, `WriteWords`, and `WriteColors`. One
    will loop through the first 20 numbers and write each one to the console. The
    other will loop through a sentence and write each word to the console. The final
    one will loop through an array of colors and write each color to the console.
    Now, add the following three methods to your `Program.cs` file:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们定义三个不同的 `static` 方法，它们将代表三个任务完成的工作：`WriteNumbers`、`WriteWords` 和 `WriteColors`。其中一个将遍历前
    20 个数字并将每个数字写入控制台。另一个将遍历一个句子并将每个单词写入控制台。最后一个将遍历一个颜色数组并将每个颜色写入控制台。现在，将以下三个方法添加到您的
    `Program.cs` 文件中：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Finally, we will add code to run each method as a task:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们将添加代码以将每个方法作为任务运行：
- en: '[PRE2]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now, compile and run the application and you should see a console window that
    looks something like this:![How to do it](img/8321EN_05_01.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编译并运行应用程序，你应该会看到一个类似于这样的控制台窗口：![如何操作](img/8321EN_05_01.jpg)
- en: This is a simple example, but allows you to see the three tasks run in separate
    threads with each executing a different method. You can see the thread name of
    each task and you will notice that the threads do not always run concurrently
    in sequence.
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是一个简单的示例，但它让你看到三个任务在单独的线程中运行，每个线程执行不同的方法。你可以看到每个任务的线程名称，并且你会注意到线程并不总是按顺序并发运行。
- en: 'Now, let''s replace the code in the `Main` method with the following code:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们用以下代码替换`Main`方法中的代码：
- en: '[PRE3]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now, rebuild and run the application again. You should see an identical or almost
    identical result.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，重新构建并再次运行应用程序。你应该会看到相同或几乎相同的结果。
- en: Note
  id: totrans-35
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The reason the results may be different is because the three methods are being
    run in three separate threads on three separate cores. So, depending on performance
    and other items running on your computer, the three tasks can run with different
    timings, as a result of which the console output can be in a different order.
  id: totrans-36
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 结果可能不同的原因是三种方法正在三个不同的核心上以三个不同的线程中运行。因此，根据性能和您计算机上运行的其他项目，这三个任务可以以不同的时间运行，这导致控制台输出顺序可能不同。
- en: How it works
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: In the previous exercise, you learned two ways to use the `Task` class to implement
    functionality in a separate thread. These examples take methods that do not return
    a value and instantiate a `Task` class to execute the methods.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个练习中，你学习了两种使用`Task`类在单独的线程中实现功能的方法。这些示例使用不返回值的函数并实例化`Task`类来执行这些方法。
- en: 'The `Task` constructor takes an `Action` delegate:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task`构造函数接受一个`Action`委托：'
- en: '[PRE4]'
  id: totrans-40
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: We use a lambda expression to define the `Action` delegate, which encapsulates
    a method to be performed. Later in this chapter, we will define delegates and
    lambdas in more detail.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用lambda表达式来定义`Action`委托，它封装了一个要执行的方法。在本章的后面部分，我们将更详细地定义委托和lambda表达式。
- en: First, we used the `Task.Start()` method to execute the task. This puts the
    task on the `ThreadPool` and lets .NET manage the execution of it. To instantiate
    the `Task` class, we used a lambda expression in the constructor.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们使用了`Task.Start()`方法来执行任务。这将在`ThreadPool`上放置任务，并让.NET管理其执行。为了实例化`Task`类，我们在构造函数中使用了lambda表达式。
- en: In the second example, we used another class in the TPL and ran the tasks using
    the `Parallel.Invoke()` method. Here, we were able to put all three tasks on the
    `ThreadPool` at once by using this method and the `Action` class.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二个示例中，我们使用了TPL中的另一个类，并使用`Parallel.Invoke()`方法运行了任务。在这里，我们能够通过使用此方法和`Action`类一次将所有三个任务放置在`ThreadPool`上。
- en: We use the `Console.ReadLine()` command to just hold the command window open
    after the execution of the threads has completed. This allows us to study the
    results and control the closing of the window. To close the window, simply press
    the *Enter* key; this will complete the `ReadLine` statement. The console is waiting
    to read a line of input.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`Console.ReadLine()`命令在线程执行完成后保持命令窗口打开。这允许我们研究结果并控制窗口的关闭。要关闭窗口，只需按*Enter*键；这将完成`ReadLine`语句。控制台正在等待读取一行输入。
- en: Tasks with return values
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 返回值的任务
- en: Now, we will take a look at how to start a task that returns a value. In most
    cases, if we care about the result of a task or if a task does some work to be
    consumed by the rest of the program, then we will want the task to return some
    values for us to use. We will demonstrate this by developing a simple console
    application that starts three tasks and then prints the return values of these
    three tasks.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将看看如何启动一个返回值的任务。在大多数情况下，如果我们关心任务的结果，或者任务执行了一些其他程序需要消费的工作，那么我们希望任务返回一些值供我们使用。我们将通过开发一个简单的控制台应用程序来演示这一点，该应用程序启动三个任务，然后打印这三个任务的返回值。
- en: How to do it
  id: totrans-47
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: We will start by creating a new console application using Visual Studio 2013\.
    We will name our application, `TaskExampleWithReturnValues`.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先使用Visual Studio 2013创建一个新的控制台应用程序。我们将把我们的应用程序命名为`TaskExampleWithReturnValues`。
- en: 'Next, place the following code in the `Program` class of `Program.cs`:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将以下代码放置在`Program.cs`中的`Program`类中：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Finally, let''s build and run our application. Your console window should look
    like this:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们构建并运行我们的应用程序。你的控制台窗口应该看起来像这样：
- en: '![How to do it](img/8321EN_05_02.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![如何操作](img/8321EN_05_02.jpg)'
- en: How it works
  id: totrans-53
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'In this example, we use the `Task<TResult>` version of the `Task` class, which
    allows us to specify a return object from the task when it has completed execution.
    The return value will be placed in the `Task.Result` property and will be of the
    type you define in the declaration. So, in the following line of code, we tell
    .NET to create an object of type `Task` that will execute the `WriteNumbers()`
    method and return a `String` value:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在此示例中，我们使用 `Task<TResult>` 版本的 `Task` 类，这允许我们在任务完成执行后指定一个返回对象。返回值将被放置在 `Task.Result`
    属性中，并将是你在声明中定义的类型。因此，在以下代码行中，我们告诉 .NET 创建一个类型为 `Task` 的对象，该对象将执行 `WriteNumbers()`
    方法并返回一个 `String` 值：
- en: '[PRE6]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This is very helpful because it allows us to return any object type.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这非常有用，因为它允许我们返回任何对象类型。
- en: By using the line `Console.WriteLine(t1.Result);`, we automatically tell .NET
    to block or halt the main thread and wait on the `t1` task to complete and return
    the value `t1.Result`. .NET is smart enough to know that we want to wait until
    a value is present before executing this statement. Otherwise, if it is executed
    immediately, the value may or may not be there. If it was not there, we would
    get a null reference error. This is another way to say that using TPL is easier
    than using threads. The TPL API handles these details for you, the developer,
    managing it in the code itself.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用 `Console.WriteLine(t1.Result);` 这行代码，我们自动告诉 .NET 阻塞或暂停主线程，等待 `t1` 任务完成并返回
    `t1.Result` 的值。.NET 足够智能，知道我们希望在执行此语句之前等待一个值的存在。否则，如果立即执行，值可能存在也可能不存在。如果不存在，我们会得到一个空引用错误。这是说使用
    TPL 比使用线程更容易的另一种方式。TPL API 为你，即开发者，处理这些细节，并在代码中自行管理。
- en: Also, in each method, we set the current thread name, so in our output, we can
    see that each of the three tasks operate in a different thread.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在每种方法中，我们设置当前线程的名称，因此在我们的输出中，我们可以看到这三个任务在不同的线程中运行。
- en: Next, we will examine the API in TPL that allows us to use concurrent collections.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将检查 TPL 中的 API，它允许我们使用并发集合。
- en: Concurrent collections
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 并发集合
- en: Another namespace that was introduced in .NET 4.0 is `Systems.Collections.Concurrent`.
    This is not directly a part of TPL, but it is often used in conjunction with TPL
    to provide much of the common parallel design patterns such as producer-consumer
    that we will discuss in [Chapter 9](ch09.html "Chapter 9. Pipeline and Producer-consumer
    Design Patterns"), *Pipeline and Producer-consumer Design Patterns*.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个在 .NET 4.0 中引入的命名空间是 `Systems.Collections.Concurrent`。这并不是 TPL 的直接部分，但它经常与
    TPL 一起使用，以提供许多常见的并行设计模式，例如我们在 [第 9 章](ch09.html "第 9 章。管道和生产者-消费者设计模式") 中将要讨论的生产者-消费者模式，*管道和生产者-消费者设计模式*。
- en: '`System.Collections.Concurrent` provides a thread-safe version of collection
    classes in the `Systems.Collections` namespace. These work very well in conjunction
    with tasks. This namespace has `ConcurrentBag`, which is a collection of objects
    such as `ConcurrentDictionary`, `ConcurrentQueue`, `ConcurrentStack`, and `BlockingCollection`
    to name the most popular ones.'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: '`System.Collections.Concurrent` 提供了 `Systems.Collections` 命名空间中集合类的线程安全版本。这些类与任务一起使用时工作得非常好。此命名空间包含
    `ConcurrentBag`，这是一个包含诸如 `ConcurrentDictionary`、`ConcurrentQueue`、`ConcurrentStack`
    和 `BlockingCollection` 等对象的集合，其中最流行的是这些。'
- en: All of these concurrent collections implement interfaces for the underlying
    collection. This essentially wraps the collection and provides a thread-safety
    mechanism. This is handy for the multithreaded developer because you can use them
    and not have to design thread-safe logic around them.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些并发集合都实现了底层集合的接口。这本质上封装了集合并提供了一个线程安全机制。这对于多线程开发者来说很方便，因为他们可以使用它们，而无需围绕它们设计线程安全逻辑。
- en: In this section, we will look at the `ConcurrentQueue` class and show an example
    of how to use this with tasks to perform a simple multithreaded example. This
    will demonstrate the power and simplicity that TPL provides for multithreaded
    processing. We do not have to worry about locking resources to make them thread-safe.
    We do not have to worry about the number of processing cores on our hardware.
    We do not have to worry about race conditions between variables. And we do not
    have to worry about using global variables in a class to provide thread-safety.
    All of this is handled for us with the classes. We just have to worry about the
    logic.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将查看`ConcurrentQueue`类，并展示如何使用任务来执行一个简单的多线程示例。这将展示TPL为多线程处理提供的强大和简单性。我们不必担心锁定资源以使其线程安全。我们不必担心硬件上的处理核心数量。我们不必担心变量之间的竞态条件。而且我们不必担心在类中使用全局变量来提供线程安全。所有这些都有类来处理。我们只需要关注逻辑。
- en: Having a set of thread-safe collections to be used by many threads makes multithreaded
    design easy. Notice how fewer things we have to account for than our previous
    examples. Before we divided up work, we had to know the number of cores to create
    a thread for. This is handled by `Task` and `ThreadPool` now.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有一组线程安全的集合供多个线程使用，使得多线程设计变得简单。注意我们比之前的例子需要考虑的事情更少。在我们划分工作之前，我们必须知道核心的数量来创建一个线程。现在这由`Task`和`ThreadPool`来处理。
- en: We had to divide our dataset into chunks and give each thread a known chunk
    of the data (that is, in the image-processing example, each thread got a distinct
    section of the image). Also, we had to come back in the end and reassemble the
    results from each thread. We no longer have to worry about these three concerns.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须将数据集划分为块，并给每个线程一个已知的数据块（即在图像处理示例中，每个线程得到图像的一个独立部分）。此外，我们最终必须回来并重新组装每个线程的结果。我们不再需要担心这三个问题。
- en: In this project, we will take a list of numbers from 0 to 5000 (that is, 0 +
    1 + 2 + 3 + 4 and so on) and sum them up by three different threads. We will not
    give each thread a range to sum then add the results from the three, like before.
    We will just use a `ConcurrentQueue` collection with the 5000 numbers in queue
    and have each of the three threads remove items, sum them up, and add the sum
    to the overall total.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将从0到5000（即0 + 1 + 2 + 3 + 4等等）的数字列表中取出，并由三个不同的线程求和。我们不会像以前那样给每个线程一个求和的范围，然后将结果相加。我们只需使用一个包含5000个数字的`ConcurrentQueue`集合，让三个线程分别取出项目，求和，并将求和结果加到总和中。
- en: How to do it
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作
- en: 'Let''s open Visual Studio and create a new console application project named
    `ConcurrentCollection`; then perform the following steps:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们打开Visual Studio并创建一个名为`ConcurrentCollection`的新控制台应用程序项目；然后执行以下步骤：
- en: 'Place the following code in the `Program.cs` file:'
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码放入`Program.cs`文件中：
- en: '[PRE7]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Now, let's build and run the application. What do you think the results will
    be? They should look like the following output:![How to do it](img/8321EN_05_03.jpg)
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们构建并运行应用程序。你认为结果会是什么？它们应该看起来像以下输出：![如何操作](img/8321EN_05_03.jpg)
- en: How it works
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'In this program, we declare a `ConcurrentQueue` object using the following
    statement:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个程序中，我们使用以下语句声明一个`ConcurrentQueue`对象：
- en: '[PRE8]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Then we place into the queue the numbers from 1 to 5000 using the following
    loop:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 然后我们使用以下循环将1到5000的数字放入队列中：
- en: '[PRE9]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, we start three parallel tasks that each dequeue items from the queue
    without having to lock the queue to protect thread-safety because it is a concurrent
    queue. They use the following command to take all the items out of the queue:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们启动三个并行任务，每个任务从队列中取出项目，而无需锁定队列以保护线程安全，因为这是一个并发队列。它们使用以下命令从队列中取出所有项目：
- en: '[PRE10]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: By using this `ConcurrentQueue` object, .NET handles all of the thread-safety
    issues and allows all three tasks to just focus on the work to be performed. They
    all then add their local sums to the `MultiThreadSum` value. But notice that this
    value needs to be locked because it is not thread-safe by default, since three
    separate tasks are all trying to add to it in parallel.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用这个`ConcurrentQueue`对象，.NET处理所有线程安全问题，并允许所有三个任务只关注要执行的工作。然后它们都将各自的局部和添加到`MultiThreadSum`值中。但请注意，这个值需要被锁定，因为它默认不是线程安全的，因为三个单独的任务都在并行尝试向它添加。
- en: So, in the end, no matter how the three independent tasks run, the `MultiThreadSum`
    will always be the same because each number between 1 and 5000 is taken from the
    queue only once and added to the overall sum.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，最终，无论三个独立任务如何运行，`MultiThreadSum`都将保持不变，因为每个介于1到5000之间的数字只从队列中取出一次并加到总和中。
- en: Exploring the TaskFactory class
  id: totrans-82
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索TaskFactory类
- en: A key class of the TPL in the `System.Threading.Tasks` namespace is the `TaskFactory`
    class. `TaskFactory` is used in the creation and scheduling of tasks. The `TaskFactory`
    class has a number of methods that make scheduling and managing tasks very easy.
    These include starting and continuing methods as well as a series of methods that
    conform to the asynchronous programming model that we will cover in [Chapter 11](ch11.html
    "Chapter 11. The Asynchronous Programming Model"), *The Asynchronous Programming
    Model*. Essentially, this class wraps many of the common task design patterns
    into methods for ease of use and development. This is yet another way that TPL
    makes multithreaded development "lightweight".
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: TPL（Task Parallel Library）在`System.Threading.Tasks`命名空间中的一个关键类是`TaskFactory`类。`TaskFactory`用于任务的创建和调度。`TaskFactory`类提供了一系列方法，使得任务的调度和管理变得非常简单。这些方法包括启动和继续方法，以及一系列符合我们将要在[第11章](ch11.html
    "第11章。异步编程模型")“异步编程模型”中介绍的模式的方法。本质上，这个类将许多常见的任务设计模式封装成易于使用和开发的方法。这是TPL使多线程开发变得“轻量级”的另一种方式。
- en: Most of our work with `TaskFactory` will be covered in [Chapter 6](ch06.html
    "Chapter 6. Task-based Parallelism"), *Task-based Parallelism*, and [Chapter 7](ch07.html
    "Chapter 7. Data Parallelism"), *Data Parallelism*, and then again in [Chapter
    11](ch11.html "Chapter 11. The Asynchronous Programming Model"), *The Asynchronous
    Programming Model*. But in this chapter, we will perform a simple example to demonstrate
    how they are used.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 大部分关于`TaskFactory`的工作将在[第6章](ch06.html "第6章。基于任务的并行")“基于任务的并行”和[第7章](ch07.html
    "第7章。数据并行")“数据并行”中介绍，然后再在第11章“异步编程模型”中再次介绍。但在这章中，我们将通过一个简单的示例来演示它们是如何被使用的。
- en: How to do it
  id: totrans-85
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'Let''s start by opening up Visual Studio and creating a new console application
    named `TaskFactoryExample`. Now, let''s add the following code to our `Program.cs`
    file:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从打开Visual Studio并创建一个名为`TaskFactoryExample`的新控制台应用程序开始。现在，让我们将以下代码添加到我们的`Program.cs`文件中：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now, let''s compile and run this application. You should see results as shown
    in the following screenshot:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们编译并运行这个应用程序。你应该会看到以下截图所示的结果：
- en: '![How to do it](img/8321EN_05_04.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![如何实现](img/8321EN_05_04.jpg)'
- en: How it works
  id: totrans-90
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Let''s now examine what we just accomplished and why it worked. You can see
    from the output that we ran five tasks all in different threads and then waited
    on them to complete. First, we created a static `TaskFactory` class to use:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在检查我们刚刚完成的工作以及为什么它有效。你可以从输出中看到我们运行了五个任务，它们都在不同的线程中，然后等待它们完成。首先，我们创建了一个静态的`TaskFactory`类来使用：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: There are several overloads for the `TaskFactory` constructor. The one we used
    just takes a `TaskScheduler` object and we chose the default. In the next section
    of this chapter, we will examine the `TaskScheduler` class in more detail.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskFactory`构造函数有几个重载。我们使用的是只接受`TaskScheduler`对象的那个，我们选择了默认值。在本章的下一节中，我们将更详细地研究`TaskScheduler`类。'
- en: 'Next, we created and ran the five tasks using the `StartNew()` method of the
    `TaskFactory` class, as shown in the following line of code. There are many overloads
    for this method to allow you to create and start tasks according to your requirements
    and design pattern. In [Chapter 6](ch06.html "Chapter 6. Task-based Parallelism"),
    *Task-based Parallelism*, and [Chapter 7](ch07.html "Chapter 7. Data Parallelism"),
    *Data Parallelism*, we will examine more of these:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用`TaskFactory`类的`StartNew()`方法创建了并运行了五个任务，如以下代码行所示。这个方法有很多重载，允许你根据你的需求和设计模式创建和启动任务。在第6章“基于任务的并行”和第7章“数据并行”中，我们将探讨更多这些内容：
- en: '[PRE13]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Let's take a minute to look at the different parameters passed into the `StartNew()`
    method. We passed it a cancellation token, a task-creation option, and a scheduler.
    This allows a lot of the thread management of the task to be handled without having
    to manually do it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟来看看传递给`StartNew()`方法的不同的参数。我们传递了一个取消令牌、任务创建选项和调度器。这允许大量线程管理任务的工作无需手动完成。
- en: 'The cancellation token allows us to tell .NET if the tasks can be canceled
    or not. It also allows us to set a wait handle that is signaled if the task is
    canceled. The task creation options allow for the following settings, which give
    us a lot more control over the task than we had with the thread (referenced from
    [http://msdn.microsoft.com/en-us/library/vstudio/system.threading.tasks.taskcreationoptions](http://msdn.microsoft.com/en-us/library/vstudio/system.threading.tasks.taskcreationoptions)):'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 取消令牌允许我们告诉.NET任务是否可以被取消。它还允许我们设置一个等待句柄，如果任务被取消，则会被信号。任务创建选项允许以下设置，这比我们使用线程时对任务的控制要多得多（参考自[http://msdn.microsoft.com/en-us/library/vstudio/system.threading.tasks.taskcreationoptions](http://msdn.microsoft.com/en-us/library/vstudio/system.threading.tasks.taskcreationoptions))：
- en: '![How it works](img/8321EN_05_05.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作](img/8321EN_05_05.jpg)'
- en: 'We also passed the `TaskFactory` constructor a lambda expression for the `Action`
    object, which tells it what the task should execute:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向`TaskFactory`构造函数传递了一个用于`Action`对象的lambda表达式，它告诉任务应该执行什么：
- en: '[PRE14]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Finally, we performed a `Task.WaitAll` on the list of tasks, so we had to wait
    for all of the tasks to complete. We will see in the next chapter how we can do
    this directly with the `TaskFactory` object:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在任务列表上执行了`Task.WaitAll`，因此我们必须等待所有任务完成。我们将在下一章中看到如何直接使用`TaskFactory`对象来完成这项工作：
- en: '[PRE15]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This is a basic example of using `TaskFactory` but you can see the many benefits
    it provides and how much work is reduced for the developers as compared to using
    straight threads.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个使用`TaskFactory`的基本示例，但你可以看到它提供的许多好处，以及与直接使用线程相比，它为开发者减少了多少工作量。
- en: Task schedulers
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务调度器
- en: One of the main benefits of the Task Parallel Library versus developing using
    the `Thread` class is the `TaskScheduler`. This class does a lot of the logic
    that you had to program into your multithreaded code to achieve maximum performance
    and efficiency. This is what truly makes using TPL "lightweight" concurrency programming.
    The main job of the `TaskScheduler` class is to handle the work of queuing tasks
    to threads, or more specifically, the `ThreadPool`, and managing the `ThreadPool`
    to best utilize the number of processing cores on the machine it is being executed
    on.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 与使用`Thread`类相比，任务并行库的主要优势之一是`TaskScheduler`。这个类执行了你必须编程到你的多线程代码中以实现最大性能和效率的大量逻辑。这正是使用TPL“轻量级”并发编程的真正原因。`TaskScheduler`类的主要任务是处理将任务排队到线程的工作，或者更具体地说，是`ThreadPool`，并管理`ThreadPool`以最好地利用机器上的处理核心数量。
- en: One of the best features of the `TaskScheduler` is that it is an `abstract`
    class that you can derive your own classes from. The `TaskScheduler` allows you
    to schedule tasks on the `ThreadPool` exactly how you need if the default `TaskScheduler`
    does not meet your needs. This gives you the ultimate in flexibility and control.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`TaskScheduler`的一个最佳特性是它是一个`abstract`类，你可以从中派生自己的类。`TaskScheduler`允许你根据需要将任务调度到`ThreadPool`，如果默认的`TaskScheduler`不能满足你的需求。这为你提供了最大的灵活性和控制。'
- en: Let's talk for a minute about the `ThreadPool`. The `ThreadPool` consists of
    a queue (FIFO) of work items for threads in an application domain. Tasks are put
    on this queue until a thread is available to process them. In .NET 4.0, the `ThreadPool`
    was enhanced to improve performance by essentially making the work queue a `ConcurrentQueue`
    collection object, which eliminates the need for the locking logic to make the
    queue thread-safe.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟时间来谈谈`ThreadPool`。`ThreadPool`由一个队列（先进先出）组成，用于存储应用程序域中的线程工作项。任务被放置在这个队列中，直到有可用的线程来处理它们。在.NET
    4.0中，`ThreadPool`通过将工作队列变为`ConcurrentQueue`集合对象来增强性能，从而消除了使队列线程安全的锁定逻辑需求。
- en: Another point to note is that tasks that are not the children of other tasks
    are put in a **global** queue, while tasks that are children of other tasks are
    put in **local** queues of the parent task. So, when a thread is finished processing
    a work item, it first looks in the task's local queue for more work before going
    to the global queue. This is another way .NET 4.0 improved the performance of
    the `ThreadPool`.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个需要注意的点是，不是其他任务子任务的任务被放入一个**全局**队列中，而子任务被放入父任务的**本地**队列中。因此，当一个线程完成处理工作项后，它会先在任务的本地队列中寻找更多的工作，然后再去全局队列。这是.NET
    4.0提高`ThreadPool`性能的另一种方式。
- en: 'The following are four ways that the `TaskScheduler` improves performance of
    the `ThreadPool` and removes work from the developer (referenced from [http://msdn.microsoft.com/en-us/library/dd997402(v=vs.110).aspx](http://msdn.microsoft.com/en-us/library/dd997402(v=vs.110).aspx)):'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为`TaskScheduler`提高`ThreadPool`性能和从开发者那里移除工作的四种方式（参考自[http://msdn.microsoft.com/en-us/library/dd997402(v=vs.110).aspx](http://msdn.microsoft.com/en-us/library/dd997402(v=vs.110).aspx)）：
- en: '![Task schedulers](img/8321EN_05_06.jpg)'
  id: totrans-110
  prefs: []
  type: TYPE_IMG
  zh: '![任务调度器](img/8321EN_05_06.jpg)'
- en: Introducing the Parallel class
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引入Parallel类
- en: The last class we will touch on in this TPL primer is the `Parallel` class.
    This class will be covered in detail in [Chapter 7](ch07.html "Chapter 7. Data
    Parallelism"), *Data Parallelism*, when we discuss data parallelism; but it is
    worth an introduction here. The `Parallel` class is part of the `System.Threading.Tasks`
    namespace and provides functionality for using parallel loops. The two most used
    methods are `Parallel.For` and `Parallel.ForEach`, which allow you to loop through
    a collection and perform logic on each item of the collection concurrently.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在本TPL入门指南中，我们将最后讨论的类是`Parallel`类。这个类将在第7章[数据并行](ch07.html "第7章。数据并行")中详细讨论，当我们讨论数据并行时；但在这里介绍它也是值得的。`Parallel`类是`System.Threading.Tasks`命名空间的一部分，它提供了使用并行循环的功能。最常用的两个方法是`Parallel.For`和`Parallel.ForEach`，允许你遍历一个集合，并对集合中的每个项目并发执行逻辑。
- en: We briefly saw it earlier in this chapter when we used the `Parallel.Invoke`
    method to run a group of tasks in parallel. But its main use is for data parallelism.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在前面章节中简要地看到了它，当时我们使用`Parallel.Invoke`方法并行运行一组任务。但它的主要用途是数据并行。
- en: We can call the `Parallel.For` method using a named method, an anonymous method,
    or a lambda expression.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用命名方法、匿名方法或lambda表达式调用`Parallel.For`方法。
- en: 'The following are examples of the three ways:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 以下为三种方法的示例：
- en: '[PRE16]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the named method version, you would need to write a method called `Method`
    that receives an integer parameter and does not return anything. Using `Parallel.For`
    causes .NET to run each iteration of the loop concurrently. Whether it does this
    or not depends on the number of processing cores and other work going on at the
    same time.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在命名方法版本中，你需要编写一个名为`Method`的方法，该方法接收一个整数参数，不返回任何内容。使用`Parallel.For`会导致.NET并发运行循环的每个迭代。它是否这样做取决于处理器的核心数量以及同时进行的其他工作。
- en: 'The `Parallel.ForEach` method takes an `IEnumerable` data source and an `Action`
    delegate and iterates through the data source and calls the `Action` delegate
    on each item. It also returns a `ParallelLoopResult` object with the results for
    the processing, if there are any. The basic syntax for this is as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.ForEach`方法接受一个`IEnumerable`数据源和一个`Action`委托，遍历数据源并对每个项目调用`Action`委托。如果有的话，它还会返回一个`ParallelLoopResult`对象，其中包含处理结果。这个的基本语法如下：'
- en: '[PRE17]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How to do it
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现
- en: 'Let''s see a simple example. Open Visual Studio, create a new console application
    named `ParallelForEach`, and perform the following steps:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个简单的例子。打开Visual Studio，创建一个名为`ParallelForEach`的新控制台应用程序，并执行以下步骤：
- en: 'Place the following code in the `Program.cs` file:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码放置在`Program.cs`文件中：
- en: '[PRE18]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Now, let's compile and run the application. Your results should look like this:![How
    to do it](img/8321EN_05_07.jpg)
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们编译并运行应用程序。你的结果应该看起来像这样：![如何实现](img/8321EN_05_07.jpg)
- en: How it works
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理
- en: First, we create an `IEnumerable` collection by splitting a sentence into an
    array of strings for each word in the sentence. Then we perform a `Parallel.ForEach`
    looping on each word and simply print the word and current thread ID to the console.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过将句子拆分为字符串数组来创建一个`IEnumerable`集合，每个字符串代表句子中的一个单词。然后我们对每个单词执行`Parallel.ForEach`循环，并将单词和当前线程ID简单地打印到控制台。
- en: Something to note here is that you see thread IDs 8, 9, 10, and 11\. There is
    a separate thread for each iteration of the loop and the thread IDs are not starting
    with 0 or 1\. Remember that the TPL uses `ThreadPool`. So, the `Action` delegate
    is queued as a separate task to the `ThreadPool` for each iteration of the list,
    which has 11 words. The `TaskScheduler` and .NET use the `ThreadPool` as efficiently
    as they can to process these queued tasks concurrently. On my particular machine,
    there are four processing cores. So, it does split the work out between four threads.
    But then, based on the rest of the work the computer is doing, thread 8 handles
    two of the tasks, thread 9 handles seven of the tasks, and thread 10 and 11 handle
    one task each.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的是，你看到线程ID 8、9、10和11。每个循环迭代都有一个单独的线程，线程ID不是从0或1开始的。记住，TPL使用`ThreadPool`。因此，`Action`代表者作为单独的任务被排队到`ThreadPool`中，每个迭代都有11个单词。`TaskScheduler`和.NET尽可能地使用`ThreadPool`来并发处理这些排队的任务。在我的特定机器上，有四个处理核心。所以，它确实在四个线程之间分配了工作。但是，然后，根据计算机正在执行的其他工作，线程8处理了两个任务，线程9处理了七个任务，而线程10和11各自处理了一个任务。
- en: But the thing to note here is that we did not have to manage any of this. Using
    threads directly, we would have had to interrogate the hardware and realize there
    are four processing cores. Then, break the array into four smaller arrays and
    hand each of the smaller arrays to a single thread to achieve maximum performance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 但这里需要注意的是，我们不必管理任何这些。如果我们直接使用线程，我们就必须查询硬件并意识到有四个处理核心。然后，将数组分成四个更小的数组，并将每个较小的数组交给单个线程以实现最大性能。
- en: Delegates and lambda expressions
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 代表者和Lambda表达式
- en: In this chapter, we have used delegates and lambda expressions. These two concepts
    are confusing for some new developers, so let's take a moment to discuss them
    in a little more detail.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们使用了代表者和Lambda表达式。这两个概念对于一些新开发者来说可能很令人困惑，所以让我们花点时间更详细地讨论一下。
- en: Delegates are often used when creating event handlers. A **delegate** defines
    a reference type that encapsulates a method with a certain set of parameters and
    a return type. It functions a lot like a function pointer in C++. It allows us
    to pass a delegate object that can be used to call a method without having to
    know the method at compile time.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建事件处理器时，经常使用代表者（Delegates）。一个**代表者**定义了一个封装了特定参数集和返回类型的引用类型的方法。它的工作方式与C++中的函数指针非常相似。它允许我们传递一个代表者对象，这样我们就可以在编译时不知道方法的情况下调用该方法。
- en: 'In our example, the `Task` constructor takes an `Action` delegate to define
    the *action* to be performed by the task. In our example, we set the method for
    the delegate in the constructor definition, but we do not have to. We can write
    it like this:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，`Task`构造函数接受一个`Action`代表者来定义任务要执行的操作。在我们的例子中，我们在构造函数定义中设置了代表者的方法，但我们可以不这样做。我们可以写成这样：
- en: '[PRE19]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: This way, we declare the `Action` delegate. Then we instantiate it with the
    method `WriteNumbers`, and finally, we instantiate a `Task` object with the delegate.
    Later in the code, we can always change the method the `Action` delegate uses,
    based on business logic. So, we are not bound for this task to have to execute
    the `WriteNumbers` method, every time the task is performed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们声明了`Action`代表者。然后我们使用`WriteNumbers`方法实例化它，最后我们使用代表者实例化一个`Task`对象。在代码的后续部分，我们可以根据业务逻辑更改`Action`代表者使用的方法。因此，我们不需要在每次任务执行时都强制执行`WriteNumbers`方法。
- en: All we need to know at design time is that we want to execute a method with
    no parameters and no return type in this task. This gives us a lot of power and
    flexibility.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在设计时，我们只需要知道我们想在任务中执行一个没有参数和没有返回类型的方法。这给了我们很大的权力和灵活性。
- en: 'A lambda expression is an anonymous function that can be used to create delegates.
    In a lambda expression, there is the lambda operator, `=>`, and the left- and
    right-hand side of this operator. The left-hand side contains any input parameters
    and the right-hand side contains the expression of the code block. Empty parentheses
    represent zero parameters. Let''s look at the following statement:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: Lambda表达式是一个匿名函数，可以用来创建代表者。在Lambda表达式中，有Lambda运算符`=>`以及这个运算符的左右两侧。左侧包含任何输入参数，右侧包含代码块的表达式。空括号表示没有参数。让我们看看以下语句：
- en: '[PRE20]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In this statement, we are using a lambda expression to represent the delegate
    that the `Task` constructor takes as an input: `() => WriteNumbers()`'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个语句中，我们使用Lambda表达式来表示`Task`构造函数接受的代表者：`() => WriteNumbers()`
- en: This lambda expression is telling us that the delegate has no input parameters(`()`)
    and that the code block for the method of the delegate is `WriteNumbers()`.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 这个lambda表达式告诉我们，委托没有输入参数(`()`)，并且委托的方法代码块是`WriteNumbers()`。
- en: So, we can see that in the preceding examples, the `Task` constructor takes
    a delegate reference type and we use a lambda expression to define that delegate.
    By doing this, we have flexibility to change at runtime what method a task will
    execute when it is run. The only constraint at compile time is the parameters
    passed into the delegate and the return type of the delegate.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到，在前面的示例中，`Task`构造函数接受一个委托引用类型，我们使用lambda表达式来定义那个委托。通过这样做，我们可以在运行时灵活地更改任务执行时将执行哪个方法。编译时的唯一约束是传递给委托的参数和委托的返回类型。
- en: Summary
  id: totrans-141
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started our journey into the Task Parallel Library and this
    will be the focus of the rest of the book. You learned about the `Task`, `Action`,
    `TaskFactory`, `Parallel`, and `TaskScheduler` classes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们开始了对任务并行库的探索之旅，这将是本书剩余部分的重点。你学习了`Task`、`Action`、`TaskFactory`、`Parallel`和`TaskScheduler`类。
- en: You also learned what the meaning of lightweight concurrency versus heavyweight
    concurrency is, and started to see the many benefits for the developer.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 你还学习了轻量级并发与重量级并发的含义，并开始看到对开发者的许多好处。
- en: The code examples in this chapter were very simple but designed to get you to
    start thinking from a TPL mindset and out of the `Thread` and `BackgroundWorker`
    mindset. Throughout the rest of this book, we will explore many more detailed
    features of the TPL classes and several common parallel design patterns and how
    they are implemented using TPL.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的代码示例非常简单，但旨在让你开始从TPL思维模式出发，跳出`Thread`和`BackgroundWorker`思维模式。在本书的剩余部分，我们将探索TPL类更多的详细功能以及几个常见的并行设计模式和它们如何使用TPL实现。
- en: 'You should already be able to see just how powerful the TPL is and how much
    of the complexity to make an application designed for concurrency it handles.
    When building a multithreaded application, there are usually four considerations
    that need to be handled by the developer that are not part of a single-threaded
    application; they are listed as follows:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该已经能够看到TPL有多么强大，以及它处理为并发设计应用所涉及到的复杂性的程度。在构建多线程应用时，通常有四个开发者需要处理的考虑因素，这些因素不属于单线程应用；它们如下列出：
- en: What pieces of functionality in the application can we process concurrently?
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以在应用程序中处理哪些功能并发？
- en: How do I manage achieving maximum performance without knowing ahead of time
    what machine it will be running on and how many processing cores it might have?
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何在不事先知道它将在什么机器上运行以及它可能有多少处理核心的情况下，管理以实现最佳性能？
- en: How do I ensure thread-safety in the data and values that overlap between threads?
    Or split the data and values to not overlap?
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何确保重叠在线程之间的数据和值是线程安全的？或者将数据和值分割以避免重叠？
- en: How do I manage and coordinate the different threads?
  id: totrans-149
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我如何管理和协调不同的线程？
- en: Even though we have only just begun discussing TPL, you can already see how
    the last three are handled for you unlike doing concurrent programming with threads
    directly.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们刚刚开始讨论TPL，但你已经可以看到，与直接使用线程进行并发编程相比，后三个问题已经为你处理好了。
- en: The first one is a design decision and, as we discuss common parallel design
    patterns, you will see that TPL helps us there as well.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 第一项是一个设计决策，随着我们讨论常见的并行设计模式，你将看到TPL在这方面也帮了我们大忙。
- en: Now, let's move on to [Chapter 6](ch06.html "Chapter 6. Task-based Parallelism"),
    *Task-based Parallelism*, and start to really become comfortable developing software
    using the TPL.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们继续前进到[第6章](ch06.html "第6章。基于任务的并行处理")，*基于任务的并行处理*，并开始真正熟悉使用TPL开发软件。
