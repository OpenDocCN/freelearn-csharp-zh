<html><head></head><body>
<div id="sbo-rt-content"><div id="_idContainer063">
<h1 class="chapter-number" id="_idParaDest-91"><a id="_idTextAnchor097"/>4</h1>
<h1 id="_idParaDest-92"><a id="_idTextAnchor098"/>Real Unit Testing with Test Doubles</h1>
<p>A unit test differentiates itself from other test categories by using <strong class="bold">test doubles</strong>; actually, you would rarely see a unit test without a test double. </p>
<p>There is a lot of confusion on the web about what that means. My aim in this chapter is to clarify this term so that you can use it in the right context and give you as many explained examples of the topic so you feel confident in selecting the right test double for the test at hand.</p>
<p>In this chapter, we will:</p>
<ul>
<li>Explain the concepts and usage of test doubles</li>
<li>Discuss more testing categories </li>
</ul>
<p>By the end of the chapter, you will understand what is special about unit testing and will be able to use test doubles to start writing realistic unit tests.</p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor099"/>Technical requirements</h1>
<p>The code for this chapter can be found at the following GitHub repository: </p>
<p><a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch04">https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch04</a><a href="https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-.NET/tree/main/ch04%0D"/></p>
<h1 id="_idParaDest-94"><a id="_idTextAnchor100"/>Understanding and using test doubles</h1>
<p>You would rarely write a unit test<a id="_idIndexMarker269"/> without using a <strong class="bold">test double</strong>. Think of the term <em class="italic">double</em> in the same sense as a Hollywood stunt, where a stunt takes the place of a real <a id="_idIndexMarker270"/>actor in some situations. <em class="italic">Test double</em> is an umbrella term for an<a id="_idIndexMarker271"/> object that is used to replace a dependency with a test equivalent (double) for the sake of testing a SUT. They are meant to satisfy one or more of the following requirements:</p>
<p><strong class="bold">Requirement 1</strong>: Enable the test code to compile.</p>
<p><strong class="bold">Requirement 2</strong>: Eliminate side effects according to the unit test requirements.</p>
<p><strong class="bold">Requirement 3</strong>: Embed a canned (predetermined) behavior that relates somehow to the real behavior.</p>
<p><strong class="bold">Requirement 4</strong>: Take a note of and verify the activities that were exerted on a dependency within a unit test (we will name this requirement later as <em class="italic">spying</em>).</p>
<p>We will be referring to these four conditions when we discuss individual test double types, so you may want to <a id="_idIndexMarker272"/>bookmark this section.</p>
<p>Do you want your method to call the payment gateway and execute a transaction while being unit tested? Do you want to <a id="_idIndexMarker273"/>call a third-party API that costs money while you are unit testing? Do you even want to go over the HTTP while you are testing? <em class="italic">Hint</em>: You don’t want, and you shouldn’t.</p>
<p>Let’s understand the different types<a id="_idIndexMarker274"/> of test doubles that can satisfy the four conditions mentioned earlier.</p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor101"/>Types of test doubles</h2>
<p>There are five major types of test doubles—each one is meant to satisfy one or more of the four requirements mentioned earlier. When unit testing, you may use zero or more types of test doubles to satisfy <a id="_idIndexMarker275"/>your tests.</p>
<p>Next, we will discuss dummies, stubs, mocks, and fakes. These four types of test doubles are commonly used with TDD. The fifth type is isolation, which is not used with TDD and is only mentioned here for completeness.</p>
<h3>Dummies</h3>
<p><strong class="bold">Dummies</strong> are a straightforward <a id="_idIndexMarker276"/>type of test double; in fact, I used them earlier. Dummies are meant to be passed to your SUT to let the code compile. If dummies are used in code, then they are supposed to do nothing. Consider the controller class of the WFA application and the <strong class="source-inline">ConvertCToF</strong> method: </p>
<pre class="source-code">// Constructor<a id="_idTextAnchor102"/>
public WeatherForecastController(
    ILogger&lt;WeatherForecastController&gt; logger, 
    IClient client, INowWrapper nowWrapper, 
    IRandomWrapper randomWrapper)
…
public double ConvertCToF(double c)
{
    double f = c * (9d / 5d) + 32;
    _logger.LogInformation("conversion requested");
    return f;
}</pre>
<p>To test the <strong class="source-inline">ConvertCToF</strong>, we have to instantiate a <strong class="source-inline">WeatherForecastController</strong> class. The constructor expects multiple objects to be passed in to instantiate the controller class: <strong class="source-inline">logger</strong>, <strong class="source-inline">client</strong>, <strong class="source-inline">nowWrapper</strong>, and <strong class="source-inline">randomWrapper</strong>. But the <strong class="source-inline">ConvertCToF</strong> is only using <strong class="source-inline">_logger</strong>. Also, we did not want to test the side effect of <strong class="source-inline">_logger</strong> as we are<a id="_idIndexMarker277"/> testing another behavior. For this reason, we decided to use a <strong class="source-inline">NullLogger&lt;&gt;</strong>. We can pass all dummies to our<a id="_idIndexMarker278"/> controller, like this:</p>
<pre class="source-code">var logger = 
    NullLogger&lt;WeatherForecastController&gt;.Instance;
var sut = new WeatherForecastController(logger, null, null,
    null);</pre>
<p>When <strong class="source-inline">logger</strong> is used, it does nothing, and the other <strong class="source-inline">null</strong> values are just passed to make the code compile. In this case, <strong class="source-inline">logger</strong> and the <strong class="source-inline">null</strong> values are acting as dummy test doubles.</p>
<p>Creating <em class="italic">intelligent</em> test doubles when dummies can be used can complicate and blur the intention of your unit test, so use dummies when you can.</p>
<p>Dummies satisfy the first and the second test double requirements that we’ve mentioned previously. They allow the code to compile and also create objects that do nothing when called.</p>
<h3>Stubs</h3>
<p><strong class="bold">Stubs</strong> are classes that respond with canned, pre-coded behavior. They are easy to write, easy to read, and won’t <a id="_idIndexMarker279"/>require a special framework. The caveat is that they<a id="_idIndexMarker280"/> are harder to maintain than mocks. Take the <strong class="source-inline">GetReal()</strong> method of the WFA <a id="_idTextAnchor103"/>controller:</p>
<pre class="source-code">OneCallResponse res = await _client.OneCallAsync
    (GREENWICH_LAT, GREENWICH_LON, new[] {
        Excludes.Current, Excludes.Minutely,
        Excludes.Hourly, Excludes.Alerts }, Units.Metric);
WeatherForecast[] wfs = new WeatherForecast[FORECAST_DAYS];
for (int i = 0; i &lt; wfs.Length; i++)
{
    var wf = wfs[i] = new WeatherForecast();
    wf.Date = res.Daily[i + 1].Dt;
    double forecastedTemp = res.Daily[i + 1].Temp.Day;
    wf.TemperatureC = (int)Math.Round(forecastedTemp);
    wf.Summary = MapFeelToTemp(wf.TemperatureC);
}
return wfs;</pre>
<p>We are using <strong class="source-inline">_client</strong>, a dependency service, <a id="_idTextAnchor104"/>and calling <strong class="source-inline">OneCallAsync</strong> to retrieve the weather data from <em class="italic">OpenWeather</em>. This saves the results in the <strong class="source-inline">res</strong> object. <strong class="source-inline">OneCallResponse</strong> is not what we want to return to the <strong class="source-inline">GetReal()</strong> API consumer. Instead, we want to present the <a id="_idIndexMarker281"/>consumer with a simple output collection of the type <strong class="source-inline">WeatherForecast[]</strong>. For this reason, we have a mapping process that takes<a id="_idIndexMarker282"/> the data coming from <strong class="source-inline">_client.OneCallAsync</strong> and maps it to <strong class="source-inline">WeatherForecast[]</strong>.</p>
<p>In the preceding code, the point that links the mapping process to <em class="italic">OpenWeather</em> is the <strong class="source-inline">OneCallAsync</strong> call: </p>
<div>
<div class="IMG---Figure" id="_idContainer056">
<img alt="Figure 4.1 – The unit we need to test " height="513" src="image/Figure_4.1_B18370.jpg" width="1353"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.1 – The unit we need to test</p>
<p>We want to swap the implementation of <strong class="source-inline">OneCallAsync</strong> with our own stubbed implementation to avoid calling the real RESTful API because the unit that we are testing is the mapping business logic. Luckily, we can swap the implementation using <em class="italic">polymorphism</em>. This can be done through implementing <strong class="source-inline">IClient</strong> ourselves by creating a concrete class called <strong class="source-inline">ClientStub</strong> and writing our own <strong class="source-inline">OneCallAsync</strong> method. Our final design looks like this:</p>
<div>
<div class="IMG---Figure" id="_idContainer057">
<img alt="Figure 4.2 – Client and ClientStub implementing IClient " height="332" src="image/Figure_4.2_B18370.jpg" width="802"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.2 – Client and ClientStub implementing IClient</p>
<p>Let’s <a id="_idIndexMarker283"/>build our <a id="_idIndexMarker284"/>stub class:</p>
<pre class="source-code">public class ClientStub : IClient
{
    private readonly DateTime _now;
    private readonly IEnumerable&lt;double&gt; _sevenDaysTemps;
    public ClientStub(DateTime now, 
                      IEnumerable&lt;double&gt; sevenDaysTemps)
    {
        _now = now;
        _sevenDaysTemps = sevenDaysTemps;
    }
    public Task&lt;OneCallResponse&gt; OneCallAsync(
        decimal latitude, decimal longitude, 
        IEnumerable&lt;Excludes&gt; excludes, Units unit)
    {
        const int DAYS = 7;
        OneCallResponse res = new OneCallResponse();
        res.Daily = new Daily[DAYS];
        for (int i = 0; i &lt; DAYS; i++)
        {
            res.Daily[i] = new Daily();
            res.Daily[i].Dt = _now.AddDays(i);
            res.Daily[i].Temp = new Temp();
            res.Daily[i].Temp.Day = 
              _sevenDaysTemps.ElementAt(i);
        }
        return Task.FromResult(res);
    }
}</pre>
<p>Notice the following in the preceding code:</p>
<ul>
<li><strong class="source-inline">ClientStub</strong> implements <strong class="source-inline">IClient</strong>, and it should provide an implementation for <strong class="source-inline">OneCallAsync</strong> to satisfy the contract.</li>
<li>The constructor allows the<a id="_idIndexMarker285"/> user of the class to provide the <strong class="source-inline">DateTime</strong> and the seven days temperature.</li>
<li>The <strong class="source-inline">OneCallAsync</strong> method has a made-up, stubbed implementation that generates a <strong class="source-inline">OneCallResponse</strong> return.</li>
</ul>
<p>Now that we have written the<a id="_idIndexMarker286"/> class, we can put it into practice. There are several test criteria that we want to test. Here is the first test with the first criteria:</p>
<pre class="source-code">public async Task
    GetReal_NotInterestedInTodayWeather_WFStartsFromNextDay()
{
    // Arrange
    const double nextDayTemp = 3.3;
    const double day5Temp = 7.7;
    var today = new DateTime(2022, 1, 1);
    var realWeatherTemps = new double[] 
        {2, nextDayTemp, 4, 5.5, 6, day5Temp, 8};
    <strong class="bold">var clientStub = new ClientStub(today, </strong>
        <strong class="bold">realWeatherTemps);</strong>
    var controller = new WeatherForecastController(
        null!, <strong class="bold">clientStub</strong>, null!, null!);
    // Act
    IEnumerable&lt;WeatherForecast&gt; wfs = await 
        controller.GetReal();
    // Assert
    Assert.Equal(3, wfs.First().TemperatureC);
}</pre>
<p>Notice that we are deciding what day it is. This is our way of freezing the day so that the test can execute anytime. We are also deciding what the weather is going to be for the next 7 days, starting from our made-up day. We need to do this to be able to instantiate <strong class="source-inline">ClientStub</strong> so that it can respond according to these values.</p>
<p>From the name of the test, which should be structured as <strong class="source-inline">Method_Condition_Expectation</strong>, we can figure out what we are trying to do in this test. The weather that we get in reality contains 7 days starting from today, but what we return in <strong class="source-inline">WeatherForecast[]</strong> is the forecast from the next day onward for the next 5 days. Therefore, we<a id="_idIndexMarker287"/> ignore today’s weather and use it nowhere.</p>
<p>The stub has shielded us from<a id="_idIndexMarker288"/> reaching to the real weather service and provided the canned values that we included in the <strong class="source-inline">Arrange</strong> section. If we were to call the real service, we would get unpredictable weather, from a test point of view, for unpredictable days (depending on when we run the test), which wouldn’t make us able to write our <strong class="source-inline">Assert</strong> criteria. </p>
<p>This test is not enough to have good coverage of all the criteria that should be tested. You can find more tests for the <strong class="source-inline">GetReal</strong> method using the <strong class="source-inline">ClientStub</strong> class in the source code for this chapter in the <strong class="source-inline">WeatherForecastControllerTests</strong> class. The tests are:</p>
<pre class="source-code">GetReal_5DaysForecastStartingNextDay_
    WF5ThDayIsRealWeather6ThDay
GetReal_ForecastingFor5DaysOnly_WFHas5Days
GetReal_WFDoesntConsiderDecimal_
    RealWeatherTempRoundedProperly
GetReal_TodayWeatherAnd6DaysForecastReceived_
    RealDateMatchesNextDay
GetReal_TodayWeatherAnd6DaysForecastReceived_
    RealDateMatchesLastDay</pre>
<p>I encourage you to have a look at the companion code to familiarize yourself with other examples.</p>
<h4>Spies</h4>
<p><strong class="bold">Spies</strong> are extra functionality<a id="_idIndexMarker289"/> added to a stub class to reveal what happened inside the stub. For <a id="_idIndexMarker290"/>example, consider this business requirement where we need to ensure that we are only passing metric temperature (degrees Celsius) requests to <em class="italic">OpenWeather</em>.</p>
<p>We need to modify our stub to reveal what has been passed to <strong class="source-inline">OneCallAsync</strong>. The new code in the stub will look like this:</p>
<pre class="source-code"><strong class="bold">public Units? LastUnitSpy { get; set; }</strong>
public Task&lt;OneCallResponse&gt; OneCallAsync(decimal latitude, 
    decimal longitude, IEnumerable&lt;Excludes&gt; excludes, 
      Units unit)
{
    <strong class="bold">LastUnitSpy = unit;</strong>
    const int DAYS = 7;
    // the rest of the code did not change</pre>
<p>We have added a property called <strong class="source-inline">LastUnitSpy</strong> to store the last requested unit and ended it with the <strong class="source-inline">Spy</strong> suffix as a convention. Our unit test will look like this:</p>
<pre class="source-code">public async Task 
    GetReal_RequestsToOpenWeather_MetricUnitIsUsed()
{
    // Arrange
    var realWeatherTemps = new double[] { 1,2,3,4,5,6,7 };
    var clientStub = new ClientStub(
        default(DateTime), realWeatherTemps);
    var controller = new WeatherForecastController(null!, 
        clientStub, null!, null!);
    
    // Act
    var _ = await controller.GetReal();
    // Assert
    Assert.NotNull(clientStub.LastUnitSpy);
    <strong class="bold">Assert.Equal(Units.Metric, </strong>
        <strong class="bold">clientStub.LastUnitSpy!.Value);</strong>
}</pre>
<p>Notice that in this test, we did not populate the forecast temperature with meaningful values and used default <strong class="source-inline">DateTime</strong>. This emphasized to future test readers (other developers reading the code) that we don’t care in this test for the variation of these parameters. We just wanted dummy objects to instantiate the <strong class="source-inline">clientStub</strong> object.</p>
<p>The last assert has <a id="_idIndexMarker291"/>validated receiving <strong class="source-inline">Units.Metric</strong>, which satisfies our business requirement.</p>
<p>You can add spies on-demand<a id="_idIndexMarker292"/> according to your tests and you can organize them in the way you like and hopefully, by now, the idea behind calling it <em class="italic">spy</em> makes sense.</p>
<h4>Pros and cons of using stubs</h4>
<p>Using stubs is simple <a id="_idIndexMarker293"/>and leads to readable code. Not needing to learn any special<a id="_idIndexMarker294"/> stubbing framework is also an advantage.</p>
<p>The problem with stubbing is that the more sophisticated your scenarios are, the more stub classes you need (<strong class="source-inline">ClientStub2</strong> and <strong class="source-inline">ClientStub3</strong>) or the cleverer your stub implementation needs to be. Your stub should contain minimal <em class="italic">cleverness</em> and business logic. In real-life scenarios, your stubs will be chunky and harder to maintain if you and your team are not careful about maintaining them.</p>
<h4>Recap of the previous scenario</h4>
<p>We have followed these steps to unit test the <strong class="source-inline">GetReal()</strong> method:</p>
<ul>
<li>We realized that <strong class="source-inline">_client</strong> is a dependency used by our SUT.</li>
<li>We want to isolate our <strong class="source-inline">GetReal</strong> method from calling the real OpenWeather, so we need to provide an alternative behavior for <strong class="source-inline">_client</strong>.</li>
<li><strong class="source-inline">_client</strong> is an object of a class that implements the <strong class="source-inline">IClient</strong> interface.</li>
<li>At runtime, the SUT is instantiated by the start up class. <strong class="source-inline">Client</strong>, which is provided by a third-party library, is passed to  SUT. This <strong class="source-inline">Client</strong>, which implements <strong class="source-inline">IClient</strong>, provides a means for retrieving the real weather data from <em class="italic">OpenWeather</em>.</li>
<li>Unit testing should not extend the test to a third party and should restrict the test to the SUT.</li>
<li>To bypass calling the real service, we stubbed a class and called it <strong class="source-inline">ClientStub</strong>, and implemented <strong class="source-inline">IClient</strong>. <strong class="source-inline">ClientStub</strong> contains an implementation to generate made-up weather data.</li>
<li>We wrote our unit test<a id="_idIndexMarker295"/> following the unit test name convention and the AAA structure.</li>
<li>Our SUT constructor requires an instance of <strong class="source-inline">IClient</strong>, so we passed <strong class="source-inline">ClientStub</strong> to it.</li>
<li>We can now test our SUT.</li>
</ul>
<p>Stubs satisfy the first three<a id="_idIndexMarker296"/> test double requirements of those we stated previously. Also, with the help of spies, they satisfy the fourth requirement.</p>
<p>The same stubbing process is used for the rest of the unit tests for the GetReal method. Some teams use stubs as the main type of test doubles and other teams prefer to use mocks, which naturally leads us to our next topic.</p>
<h3>Mocks</h3>
<p><strong class="bold">Mocks</strong> have great similarities <a id="_idIndexMarker297"/>with stubs, but rather than having the implementation of stubs done in regular coding, they use a <em class="italic">trick</em> to generate a behavior without having<a id="_idIndexMarker298"/> to implement a complete class. Mocks use third-party libraries to reduce the amount of coding involved to create a test double.</p>
<h4>Mocking libraries</h4>
<p>With mocks, you have to use a third-party library or build your own—heaven forbid. Two popular libraries for .NET are <strong class="bold">Moq</strong> (pronounced <em class="italic">mock you</em>) and <strong class="bold">NSubstitute</strong>.</p>
<ul>
<li>Moq started gaining<a id="_idIndexMarker299"/> popularity in 2010. It relies heavily on lambda expressions, which made it<a id="_idIndexMarker300"/> less verbose compared to its peers at that time. If you like lambda expressions, then Moq is for you.</li>
<li>NSubstitute was also released near Moq time. Its focus<a id="_idIndexMarker301"/> is to provide a readable syntax for <a id="_idIndexMarker302"/>mocking.</li>
</ul>
<p>Both libraries are mature in features and have a great online community. This book will use <em class="italic">NSubstitute</em>, but will also give you a quick introduction to Moq in the appendix.</p>
<p>To install NSubstitute, you can go to the unit test project directory and execute the following code:</p>
<p class="source-code">dotnet add package NSubstitute</p>
<p class="source-code">dotnet add package NSubstitute.Analyzers.CSharp</p>
<p>The second line is optional. It adds the C# NSubstitute analyzers, which uses Roslyn to add code analysis during compilation to detect possible errors. Also, it adds the capability for VS to give you hints to improve your mocks code.</p>
<p>You now have the NSubstitute library installed and ready to use.</p>
<h4>Example using mocks</h4>
<p>Mocks and stubs <a id="_idIndexMarker303"/>can be used interchangeably, so a good way of understanding them is to start from our previous stub implementation. Let’s take the same example that we used in the stubs, which is testing <strong class="source-inline">GetReal</strong>. In that example, we used stubbing as our test double. Now, we use mocking, so we take the same test above and replace the <strong class="source-inline">Arrange</strong> part with this:</p>
<pre class="source-code">// Arrange
…
<strong class="bold">//var clientStub = new ClientStub(today, realWeatherTemps);</strong>
<strong class="bold">var clientMock = Substitute.For&lt;IClient&gt;();</strong>
clientMock.OneCallAsync(<strong class="bold">Arg.Any&lt;decimal&gt;(),</strong>
  <strong class="bold">Arg.Any&lt;decimal&gt;(), Arg.Any&lt;IEnumerable&lt;Excludes&gt;&gt;(),</strong>
  <strong class="bold">Arg.Any&lt;Units&gt;()</strong>)
  <strong class="bold">.Returns</strong>(x =&gt; 
  {
      const int DAYS = 7;
      OneCallResponse res = new OneCallResponse();
      res.Daily = new Daily[DAYS];
      for (int i = 0; i &lt; DAYS; i++)
      {
          res.Daily[i] = new Daily();
          res.Daily[i].Dt = today.AddDays(i);
          res.Daily[i].Temp = new Temp();
          res.Daily[i].Temp.Day = 
            realWeatherTemps.ElementAt(i);
      }
      return Task.FromResult(res);
  });
var controller = new WeatherForecastController(null!, 
  <strong class="bold">clientMock</strong>, null!, null!);</pre>
<p>When using stubs, we coded an entire class so that we can instantiate it, as you can see in the commented line. In<a id="_idIndexMarker304"/> mocking the magical method from NSubstitute, <strong class="source-inline">Substitute.For</strong> created a concrete class from <strong class="source-inline">IClient</strong> and instantiated it all in one simple line.</p>
<p>However, the created object, <strong class="source-inline">clientMock</strong>, does not have any implementation for the <strong class="source-inline">OneCallAsync</strong>, so we have used NSubstitute methods to say: whichever parameter (<strong class="source-inline">Is.Any&lt;&gt;</strong>), that is passed to the <strong class="source-inline">OneCallAsync</strong> method, <strong class="source-inline">Return</strong> what is described in the provided lambda. The lambda content is the same content that was used in the <strong class="source-inline">ClientStub</strong> before.</p>
<p>We have dynamically attached a method implementation to an object that we just created with a couple of lines of code. This is pretty impressive and has less code than its previous stub counterpart. Mocking libraries have the ability to create a concrete implementation of an abstraction and, in advanced scenarios, they can mock concrete classes and substitute part of their implementation.</p>
<p>Of course, if you are using mocking, the <strong class="source-inline">ClientStub</strong> stubbing class that we used in the stubbing example is not needed. You only pick one or the other.</p>
<p>I have created a test class called <strong class="source-inline">WeatherForecastControllerTestsWithMocking</strong> to differentiate from the one that uses a stub. In a real-life project, you wouldn’t do that as you will be typically using stubbing or mocking. This chapter and <em class="italic">Part 2</em>, <em class="italic">Building an Application with TDD</em>, will have dozens of examples that use mocks.</p>
<h4>Spies</h4>
<p>When it comes to mocking, we<a id="_idIndexMarker305"/> rarely use the term <em class="italic">spy</em> because the spy functionality is always embedded in the mocking framework. Spying in stubs is something you need to code, while for mocks, spying is built in. To illustrate this, it’s best to take the spying-with-a-stub example that we presented earlier and make it spying with mock:</p>
<pre class="source-code">public async Task 
    GetReal_RequestsToOpenWeather_MetricUnitIsUsed()
{
    // Arrange
    // Code is the same as in the previous test
    // Act
    var _ = await controller.GetReal();
    // Assert
    await clientMock<strong class="bold">.Received()</strong>.OneCallAsync(
      Arg.Any&lt;decimal&gt;(), Arg.Any&lt;decimal&gt;(), 
      Arg.Any&lt;IEnumerable&lt;Excludes&gt;&gt;(), 
      <strong class="bold">Arg.Is&lt;Units&gt;(x =&gt; x == Units.Metric)</strong>);
}</pre>
<p>The <strong class="source-inline">Arrange</strong> and <strong class="source-inline">Act</strong> sections have not changed; we are only ignoring the output of the act stage. What has <a id="_idIndexMarker306"/>changed is our assertion. NSubstitute provides a method to spy on the passed parameters called <strong class="source-inline">Received</strong> and combines it with <strong class="source-inline">Arg.Is</strong> to verify what was passed.</p>
<p>This is the first example where the <strong class="source-inline">Assert</strong> section does not use xUnit’s <strong class="source-inline">Assert</strong> class. This is perfectly legal, as the <strong class="source-inline">Received()</strong> method is an assertion method itself.</p>
<h4>Pros and cons of using mocks</h4>
<p>Mocks produce succinct code. They <a id="_idIndexMarker307"/>are slightly harder to read than plain code (code without a mocking library) if we compare them to stubs.</p>
<p>The drawback of mocks is that you depend on a library such as NSubstitute, and there is a learning curve associated with<a id="_idIndexMarker308"/> that. Also, some practitioners don’t like the magic that mock libraries employ to attach behavior dynamically and prefer to keep things more obvious by using plain code (stubs).</p>
<p>Next, I summarize the differences between mocks and stubs.</p>
<h4>Mocks versus stubs</h4>
<p>The difference between<a id="_idIndexMarker309"/> mocks and stubs is important, as you need to be armed with <a id="_idIndexMarker310"/>logic to choose the best technique to suit you. Here is a quick list of differences:</p>
<ul>
<li>Both mocks and stubs are categorized as test doubles, and you can use one or the other in your project based on the project requirements or the team preference, although in the industry, mocks are used more often than stubs.</li>
<li>Mocks are implemented with the help of a third-party library such as Moq or NSubstitute, while <a id="_idIndexMarker311"/>stubs do not rely on a library.</li>
<li>Mocks are less verbose than stubs, but their syntax is slightly harder to read than plain code.</li>
<li>Mocks are claimed to<a id="_idIndexMarker312"/> do some magic, which some practitioners believe corrupts the unit test, while stubs are plain code with no magic.</li>
</ul>
<p class="callout-heading">Important Note</p>
<p class="callout">The difference between mocks and stubs is a popular interview question. It is also important to expand on the answer and mention that both are test double types and are mainly used with unit testing.</p>
<h4>Recap of the previous scenario</h4>
<p>To recap, we had the <a id="_idIndexMarker313"/>same scenario as of the stub, but when stubbing, we have added a class to contain our stub and used it in the unit test. In mocking, we have used a mocking framework that facilitated including our implementation within the body of the unit test.</p>
<p>Mocks satisfy all test double requirements that we stated above. I hope the previous examples have given you a flavor of mocking. Next, we will explore another test double type.</p>
<h3>Fakes</h3>
<p><strong class="bold">Fakes</strong> are libraries that <a id="_idIndexMarker314"/>mimic part or all of a real-life equivalent, and they <a id="_idIndexMarker315"/>exist in order to facilitate testing.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">The term <em class="italic">fake</em> has multiple definitions in the industry. This chapter is using the definition by Martin Fowler (<a href="https://martinfowler.com/bliki/TestDouble.xhtml">https://martinfowler.com/bliki/TestDouble.xhtml</a>), as follows: “<em class="italic">Fake objects actually have working implementations, but usually take some shortcut which makes them not suitable for production (an InMemoryTestDatabase is a good example).</em>”</p>
<p class="callout">One confusing name is a .NET<a id="_idIndexMarker316"/>framework called Microsoft Fakes that does isolation!</p>
<p class="callout">One of the most popular examples library called <strong class="bold">FakeItEasy</strong> that does mocks. Also, Microsoft has a framework called Microsoft Fakes that does isolation!</p>
<p>One of the most popular <a id="_idIndexMarker317"/>examples of a fake within the .NET library is <em class="italic">Entity Framework Core In-Memory Database Provider</em>. This is a quote from the Microsoft documentation (<a href="https://docs.microsoft.com/en-us/ef/core/providers/in-memory">https://docs.microsoft.com/en-us/ef/core/providers/in-memory</a>):</p>
<p><em class="italic">This database provider allows Entity Framework Core to be used with an in-memory database. The in-memory database can be useful for testing, […]. The in-memory database is designed for testing only</em>.</p>
<p>When storing in memory, it is<a id="_idIndexMarker318"/> easy to wipe and recreate the storage while executing every individual unit test. That helps in repeating the tests without worrying about the changed state of the data. Although, if the storage was persisted on disk, say with a real database (SQL Server, Cosmos, Mongo or others), then resetting the data before every test is not a simple task. The volatile nature of an in-memory database is suitable for unit testing.</p>
<p>If <em class="italic">Test A</em> changed a username from <strong class="source-inline">JohnDoe</strong> to <strong class="source-inline">JohnSmith</strong> and <em class="italic">Test B</em> tried to change <strong class="source-inline">JohnDoe</strong> to <strong class="source-inline">JaneSmith</strong>, <em class="italic">Test B</em> will definitely fail if the changes that <em class="italic">Test A</em> had done were permanent (persisted to a physical disk database). Using a volatile in-memory database can make resetting<a id="_idIndexMarker319"/> the data easier in between every test. This is an important unit test principle known as <strong class="bold">No Interdependency</strong>.</p>
<p>Fakes are meant to help provide an implementation of a complex system to try to make your unit tests more realistic. If you have a system that uses a relational database and relies on EF Core, then the previous provider might help when unit testing:</p>
<div>
<div class="IMG---Figure" id="_idContainer058">
<img alt="Figure 4.3 – In-memory storage versus production storage " height="511" src="image/Figure_4.3_B18370.jpg" width="854"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.3 – In-memory storage versus production storage</p>
<p>Fakes satisfy the first <a id="_idIndexMarker320"/>three test double requirements of those we stated earlier. If fakes <a id="_idIndexMarker321"/>were to embed spying behavior, they would satisfy the fourth requirement.</p>
<p>In <em class="italic">Part 2</em>, <em class="italic">Building an Application with TDD</em>, we will be using this provider and we will show the usage of fakes.</p>
<h3>Isolation</h3>
<p><strong class="bold">Isolation</strong> is not something you do <a id="_idIndexMarker322"/>with TDD, but I have added a limited introduction here for <a id="_idIndexMarker323"/>completeness. Isolation bypasses traditional DI all together and uses a different technique for DI known as <strong class="bold">shim</strong>. Shim involves modifying<a id="_idIndexMarker324"/> compiled code behavior at runtime for injection.</p>
<p>Owing to the complexity of the functionality of isolation frameworks, there aren’t many of them in .NET. Here are possibly the only two frameworks available for .NET <strong class="bold">Core</strong>:</p>
<ul>
<li><strong class="bold">Microsoft Fakes</strong>: Available<a id="_idIndexMarker325"/> with the <a id="_idIndexMarker326"/>Enterprise version of Visual Studio</li>
<li><strong class="bold">Telerik JustMock</strong>: A third-party<a id="_idIndexMarker327"/> commercial<a id="_idIndexMarker328"/> tool. It also has an open source restricted implementation called <strong class="bold">JustMock Lite</strong>.</li>
</ul>
<p>I am unaware of a fully-featured isolation library that has a permissive, or free, license for .NET 5 and above.</p>
<p>Isolation frameworks are primarily used to unit test legacy systems, where you cannot change the production code to support DI. Therefore, the isolation framework injects the dependencies into the SUT at runtime. The reason they are not used with TDD is that TDD is about adding tests while gradually <em class="italic">modifying</em> production code, but isolation is not meant to modify the production code. Despite the fact you can use isolation frameworks to unit test greenfield projects, they are not the best tools for the job.</p>
<p>Although isolation frameworks exist to target legacy code, I don’t believe that applying unit tests to code that cannot change is the best use of a team’s time. I cover this in more detail in <a href="B18370_12.xhtml#_idTextAnchor279"><em class="italic">Chapter 12</em></a>, <em class="italic">Dealing with Brownfield Projects</em>.</p>
<h2 id="_idParaDest-96"><a id="_idTextAnchor105"/>What should I use for TDD?</h2>
<p>Let’s start with the process of<a id="_idIndexMarker329"/> elimination. Isolation and isolation frameworks may not be used in the context of TDD as they are incompatible.</p>
<p>Dummies can coexist with all types of test doubles. Using a <strong class="source-inline">NullLogger&lt;&gt;</strong> service where the logger is not used or passing null arguments is going to happen in most of your unit tests. So, use a dummy when you can; in fact, using dummies should take precedence over other types if this is possible.</p>
<p>Teams usually use mocks or stubs, but not both unless the project is in a transitional state from one to the other. The debate of which one is better cannot be resolved in this book, it is all over the internet. However, given that stubs are harder to maintain and they need to be built up manually, mocks can do better as a start. Begin with mocks, get experienced, and then you can decide whether stubs can serve you better.</p>
<p>Finding appropriate fakes is a hit and miss. Sometimes, you can find a well-implemented fake such as the EF Core In-Memory Database Provider, and sometimes you might find an open source fake for some popular system. Sometimes, you may be unfortunate and have to create one yourself. But fakes are used in conjunction with mocks or stubs; as we will see in <em class="italic">Part 2</em> of the book, they are not one or the other. They add value to your tests, and you need to decide when to use them on a case-by-case basis.</p>
<p><em class="italic">In summary, for any object that should not be part of the SUT or for an unused dependency, use a dummy. To build and test dependencies, use mocks. Add fakes where it makes sense. </em></p>
<p>The meaning of stubs, mocks, and fakes will vary, and the definitions are muddled. I have tried to use the most common terminology in the industry. What is important is understanding all the test<a id="_idIndexMarker330"/> double options that we can use and using them appropriately. </p>
<p>Test doubles are what make unit testing different from other categories. This can be clarified further when we discuss other testing categories to better understand the uniqueness of unit testing.</p>
<h1 id="_idParaDest-97"><a id="_idTextAnchor106"/>More testing categories</h1>
<p>You’ve probably heard about plenty of testing categories other than unit testing. There is <strong class="bold">integration testing</strong>, <strong class="bold">regression testing</strong>, <strong class="bold">automation testing</strong>, <strong class="bold">load testing</strong>, <strong class="bold">pen testing</strong>, <strong class="bold">component testing</strong>—and the list goes on. Well, we won’t cover all these test categories, as explaining them all will not fit in this book. What we will do instead is discuss the two categories that have commonalities with unit testing. The first one is <strong class="bold">integration testing</strong> and the second one is what I call <strong class="bold">Sintegration testing</strong>. We will also have an honorable mention of <strong class="bold">acceptance testing</strong> due to its importance in building a full test categories suite.</p>
<p>Unit testing, integration testing, and Sintegration testing have one major difference that sets them apart. It is how they deal with dependencies. Understanding the differences will help clarify how unit testing fits into the test ecosystem.</p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor107"/>Integration testing</h2>
<p>Integration testing is, fortunately, easy<a id="_idIndexMarker331"/> to understand. It is exactly like a unit test, but with real dependencies, not with test doubles. An integration test executes an endpoint, such as a method or an API, which will trigger all the real dependencies, including external systems such as a DB and tests the outcome against a criterion.</p>
<h3>Example</h3>
<p>The xUnit framework can also<a id="_idIndexMarker332"/> execute integration and Sintegration tests, so to show an example, we can create an integration test project in the same way we created a unit test project. From your console, go to your solution directory and execute the following:</p>
<p class="source-code">dotnet new xunit -o Uqs.Weather.Tests.<strong class="bold">Integration</strong> -f net6.0</p>
<p class="source-code">dotnet sln add Uqs.Weather.Tests.Integration</p>
<p>We have just created an integration test project using the <em class="italic">xUnit framework</em> and added it to our solution. Our integration test will be going over HTTP and will be deserializing the JSON values, so we will need to do this:</p>
<p class="source-code">cd Uqs.Weather.Tests.Integration</p>
<p class="source-code">dotnet add package System.Net.Http.Json</p>
<p>This will add the .NET JSON NuGet package to your Integration test.</p>
<p class="callout-heading">Important Note</p>
<p class="callout">Notice that the integration test project is not referencing <strong class="source-inline">Uqs.Weather</strong>. This is because the integration test project will trigger the RESTful API through HTTP and does not need to use any type from <strong class="source-inline">Uqs.Weather</strong>. </p>
<p>In this example, we want to<a id="_idIndexMarker333"/> test getting 5 days, starting from the next day:</p>
<pre class="source-code">private const string BASE_ADDRESS = "https://localhost:7218";
private const string API_URI = "/WeatherForecast/
    GetRealWeatherForecast";
private record WeatherForecast(DateTime Date, 
    int TemperatureC, int TemperatureF, string? Summary);</pre>
<p>On the class level, we add these fields. They specify the address of the service, which is pointing to my local ma<a id="_idTextAnchor108"/>chine, and also specify the URI of the SUT. By looking at the <strong class="source-inline">WeatherForecast</strong> class from <strong class="source-inline">Uqs.Weather</strong>, I know that I am getting back an array of <strong class="source-inline">WeatherForecast</strong> of five fields. So, I have constructed a similar record to the expected data that will come from the RESTful API call.</p>
<p>My integration test looks like this:</p>
<pre class="source-code">public async Task 
    GetRealWeatherForecast_Execute_GetNext5Days()
{
    // Arrange
    HttpClient httpClient = new HttpClient
    { BaseAddress = new Uri(BASE_ADDRESS) };
    var today = DateTime.Now.Date;
    var next5Days = new[] { today.AddDays(1),
       today.AddDays(2), today.AddDays(3),
       today.AddDays(4), today.AddDays(5) };
    // Act
    var httpRes = await httpClient.GetAsync(API_URI);
    // Assert
    var wfs = await 
    httpRes.Content.ReadFromJsonAsync&lt;WeatherForecast[]&gt;();
    for(int i = 0;i &lt; 5;i++)
    {
        Assert.Equal(next5Days[i], wfs[i].Date.Date);
    }
}</pre>
<p>We don’t know on which day the test is going to execute, so we are fetching today’s date and then calculating the dates of the next 5 days. We are creating and setting up an <strong class="source-inline">HttpClient</strong> to issue an HTTP call.</p>
<p>In <strong class="source-inline">Act</strong>, we are calling the RESTful API’s endpoint.</p>
<p>In <strong class="source-inline">Assert</strong>, we are converting the returned value from JSON to the <strong class="source-inline">record</strong> class that we created earlier and checking that we are getting the next 5 days.</p>
<p>This test requires a<a id="_idIndexMarker334"/> different setup to run than the way we were running unit tests before. This is an out-of-process test, which means that the API is running on one process and the test is running on another process. The two processes are communicating with each other via HTTP. So, to run this test, we first need to initiate the REST API process. Right-click on <strong class="bold">Uqs.Weather</strong> | <strong class="bold">Debug</strong> | <strong class="bold">Start Without Debugging</strong>. Then this will launch Kestrel web server in a console window and make our API ready for an HTTP call.</p>
<p>Now, you can go ahead and execute the integration test in a similar fashion to executing unit tests.</p>
<h4>Activities triggered by this test</h4>
<p>The API call that we have just executed in our integration test triggered multiple dependencies to generate the <a id="_idIndexMarker335"/>output. These are a few of the triggered dependencies:</p>
<ul>
<li>The network, including the HTTPS connection, between the integration test and the ASP.NET Web API host</li>
<li>The ASP.NET Web API host, which spun a process and displayed in a console window</li>
<li>The routing code that analyzed the request and spun the right action method in the controller</li>
<li>The DI container that decided which object to create and inject</li>
<li>The HTTPS connection between <strong class="source-inline">Uqs.Weather</strong> and the <em class="italic">OpenWeather</em> API</li>
</ul>
<p>We know that each of<a id="_idIndexMarker336"/> these dependencies works on its own. By executing this test, we made sure that all our components are integrated and work well together. The following diagram shows a hint of what happened when we executed the test:</p>
<div>
<div class="IMG---Figure" id="_idContainer059">
<img alt="Figure 4.4 – Request/response going through the dependencies " height="354" src="image/Figure_4.4_B18370.jpg" width="1562"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.4 – Request/response going through the dependencies</p>
<p>These are not all the components, as I have missed some, but hopefully, you’ve got the idea.</p>
<h4>Points to note</h4>
<p>This is our first integration test in this book (and the last one), and I would like to point out the differences between this test <a id="_idIndexMarker337"/>and its unit test equivalent:</p>
<ul>
<li>We do not know the day in advance—we have to determine the date dynamically, while in our unit test, we had a pre-configured day in the <strong class="source-inline">Assert</strong> section.</li>
<li>There are no test doubles, and everything is executing the real objects.</li>
<li>We had two processes running; one is the web server that hosts the API, and the other is our integration test. Unit tests were calling directly, in-process.</li>
<li>There is a probability of failure that is not related to the test. The test could fail due to:<ul><li>Firewall issues</li>
<li>The <em class="italic">OpenWeather</em> service is down</li>
<li>Exceeding the number of calls permitted by our <em class="italic">OpenWeather</em> license</li>
<li>ASP.NET Web server has not started</li>
<li>The routing module is not configured properly</li>
<li>Other environmental issues</li>
</ul></li>
<li>This test, while not measured, will take a longer time as it is communicating between two processes, hitting multiple components, and then going over HTTPS, which includes <a id="_idIndexMarker338"/>serialization/deserialization and encryption/decryption. Although the execution time is unnoticeable, having 10 seconds of integration tests will add up.</li>
</ul>
<h3>Unit testing versus integration testing</h3>
<p>Integration tests and <a id="_idIndexMarker339"/>unit tests are great tools, and comparing them might imply using one over the other. This is not the case as both complement each other. Integration <a id="_idIndexMarker340"/>testing is good at testing a full cycle call, while unit testing is good at testing various scenarios of business logic. They have separate roles in quality assurance; the problem arises if they step on each other’s toes. </p>
<p class="callout-heading">Important Note</p>
<p class="callout">The difference between unit and integration testing is a common interview question that allows the interviewer to assess whether the candidate understands dependency management, test doubles, unit testing, and integration testing.</p>
<h4>Advantages of integration tests over unit tests</h4>
<p>Here are the advantages that might<a id="_idIndexMarker341"/> lead us to use integration tests over unit tests:</p>
<ul>
<li>Integration tests check the real behavior that mimics what the end client might do, while unit tests check what the developer thinks the system should do.</li>
<li>Integration tests are easier to write and understand as they are regular code that doesn’t use test doubles and doesn’t care about DI.</li>
<li>Integration tests can cover scenarios that unit tests cannot cover efficiently, such as the integration between the components of the whole system and DI container registration.</li>
<li>Integration tests can be applied to legacy systems or greenfield systems. In fact, integration tests are one of the recommended ways to test legacy systems, while unit tests require code refactoring to be introduced into brownfield projects.</li>
<li>Some integration tests, like the example above, can be written in a language-agnostic way. So, the previous test could have been written in F#, Java, or Python, or by a tool such as Postman, while unit tests use the same language as the production code (C#, in our case).</li>
</ul>
<h4>Advantages of unit tests over integration tests</h4>
<p>Here are some advantages<a id="_idIndexMarker342"/> that might lead us to use unit over integration tests:</p>
<ul>
<li>Unit tests are much faster to execute, and this is very important when running hundreds of tests and looking for a short feedback loop, especially before integrating the code or releasing to an environment.</li>
<li>Unit tests have predictable results and are not affected by time, third-party service availability, or environmental intermittent issues.</li>
<li>Unit tests are repeatable as they do not persist any data, while integration tests might change the data permanently, which may make subsequent tests unreliable. This happens when writing and editing. Our example above was reading (Getting), so it did not suffer from this problem.</li>
<li>Unit tests are easier to deploy to CI/CD pipelines (we will demonstrate this in <a href="B18370_11.xhtml#_idTextAnchor265"><em class="italic">Chapter 11</em></a>, <em class="italic">Implementing Continuous Integration with GitHub Actions</em>).</li>
<li>Spotting bugs in unit tests is done sooner and can be pinpointed faster than finding the same bug in integration tests.</li>
<li>Unit tests can run during<a id="_idIndexMarker343"/> feature development, while an integration test can only be added when a feature is fully ready.</li>
</ul>
<h3>Confusing unit and integration tests</h3>
<p>Frameworks such as xUnit or NUnit are used in various integration test implementations. The term <em class="italic">Unit</em> in the framework names might mislead some developers to think what is written<a id="_idIndexMarker344"/> in these projects is unit tests. Add to that using the <em class="italic">AAA convention</em> and the method name convention, and this might mislead as <a id="_idIndexMarker345"/>well. In fact, I used these conventions in the previous integration test, but using the same convention of a unit test does not make a test a unit test.</p>
<p>Setting up the infrastructure and building the CI pipeline will vary based on the type of test being implemented. Although they look the same, it is important to differentiate between them to understand the level of tasks and maintenance required.</p>
<p>Given that they look the same, how do you spot one or the other? There is a telltale, if they are not relying on the real dependency, they are most likely to be unit tests. If they are using real objects that would trigger real external dependencies, chances are they are not unit tests.</p>
<h2 id="_idParaDest-99"><a id="_idTextAnchor109"/>Sintegration testing</h2>
<p>A <strong class="bold">Sintegration</strong> test is a<a id="_idIndexMarker346"/> midway between integration testing and unit testing. Integration testing relies on real components, while unit testing relies on test doubles. Sintegration testing tries to solve the shortcomings of integration testing by mixing elements of unit testing:</p>
<div>
<div class="IMG---Figure" id="_idContainer060">
<img alt="Figure 4.5 – Unit, Sintegration, and integration testing " height="472" src="image/Figure_4.5_B18370.jpg" width="1575"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.5 – Unit, Sintegration, and integration testing</p>
<p>I have found some developers referring to this type of test as a <strong class="bold">component test</strong>. But a component test, in software <a id="_idIndexMarker347"/>engineering, means something different, and I feel the developers were—rightly—more concerned about what it does than naming it correctly. This test category has these<a id="_idIndexMarker348"/> distinctive features, as outlined here:</p>
<ul>
<li>Substitutes (swaps) some dependencies with their real counterpart</li>
<li>Simulates some real dependencies by building fakes (the fakes of test doubles)</li>
</ul>
<p>For the <em class="italic">S</em> at the beginning of <em class="italic">s</em>ubstitute, <em class="italic">s</em>wap, and <em class="italic">s</em>imulate, and for its resemblance to integration tests, I gave it the name <em class="italic">Sintegration testing</em>. As always, let me clarify Sintegration tests with an example.</p>
<h3>Example</h3>
<p>Let’s assume that we<a id="_idIndexMarker349"/> have a web project that uses logging, service bus queues, and Cosmos DB. The logging logs to the cloud, so it needs cloud connectivity. The queue is also a cloud component, and Cosmos DB is a cloud component as well.</p>
<p>Let’s also assume that we have a series of APIs to deal with the user profile, such as the <strong class="source-inline">UpdateName</strong> API and the <strong class="source-inline">ChangePassword</strong> API. A Sintegration test can do the following:</p>
<ul>
<li>Use the Kestrel web server and have the same features as per production, as Kestrel is flexible enough to run on-demand on local machines, test, and production environments.</li>
<li>Writing logs will require access to the cloud, so we inject a <strong class="source-inline">NullLogger&lt;&gt;</strong> service that will ignore logging but will let the system work.</li>
<li>Queues are only available on the cloud, so we replaced this with a fake in-memory queue that can be easily wiped between tests.</li>
<li>Cosmos DB does not have an in-memory implementation, but the cloud version can be easily wiped between test runs. So, we use the same .NET Cosmos DB client library, but we point to a different database—the Sintegration Tests Cosmos DB, at test time.</li>
</ul>
<p>Here is a project<a id="_idIndexMarker350"/> component diagram of what the system would look like:</p>
<div>
<div class="IMG---Figure" id="_idContainer061">
<img alt="Figure 4.6 – Executing Sintegration tests " height="619" src="image/Figure_4.6_B18370.jpg" width="1115"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.6 – Executing Sintegration tests</p>
<p>The Sintegration tests in this scenario use fakes, dummies, and real components. They cover part of the integration in the system, on the other hand, the queues and DB can be easily wiped between individual tests to make sure no Sintegration test is affecting other tests.</p>
<p>Sintegration testing started<a id="_idIndexMarker351"/> gaining traction in recent years; perhaps the movement from the classical .NET Framework to .NET has surfaced this type of testing as .NET Core libraries are no longer dependent on specific Windows components, such as the IIS web server. Also, ASP.NET Core has specific implementations that allowed this type of testing, whereas, in the past, these implementations were not part of the framework. One of these implementations is having a Kestrel web server as part of .NET and being able to spin it easily without relying on a special deployment.</p>
<p>This was a quick overview of Sintegration tests. While Sintegration tests are not part of TDD, they are important to understand as they are related to unit tests.</p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor110"/>Acceptance tests</h2>
<p><strong class="bold">Acceptance testing</strong> is the testing of a <a id="_idIndexMarker352"/>complete functionality or a feature end-to-end. One popular tool for acceptance tests that is used for <a id="_idIndexMarker353"/>websites is <strong class="bold">Selenium</strong>. You might<a id="_idIndexMarker354"/> find this category of testing under different <a id="_idIndexMarker355"/>names, such <a id="_idIndexMarker356"/>as <strong class="bold">functional testing</strong>, <strong class="bold">system testing</strong>, and <strong class="bold">automated testing</strong>.</p>
<h3>Example</h3>
<p>A test that simulates a user’s<a id="_idIndexMarker357"/> action of updating their name, then pressing the <strong class="bold">Update</strong> button, and then checking whether the name is updated. This example tests a full workflow of different actions, probably in the same order that the user would trigger them.</p>
<p>Think of acceptance tests as multiple integration tests executing successively. These tests are fragile and slow, so they are better kept at a minimum. On the other hand, they are a necessity in a system as they cover areas not covered by unit tests and Sintegration tests.</p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor111"/>Choosing test categories</h2>
<p>After reading about the three test types—namely, unit, Sintegration, and integration—and the additional acceptance<a id="_idIndexMarker358"/> tests, what tests should you write? The answer, surprisingly, is all four (if possible). However, integration tests can be omitted if both Sintegration and acceptance tests are implemented.</p>
<h3>The testing triangle</h3>
<p>There is an industry <a id="_idIndexMarker359"/>concept known as the <strong class="bold">testing triangle</strong> that states the essential test categories to be implemented and the number of tests in each category. However, as with all software engineering concepts, the categories of the essential tests vary per triangle. Let’s look at the testing triangle for a greenfield project:</p>
<div>
<div class="IMG---Figure" id="_idContainer062">
<img alt="Figure 4.7 – Testing triangle " height="423" src="image/Figure_4.7_B18370.jpg" width="637"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 4.7 – Testing triangle</p>
<p>The triangle in the preceding image advocates more unit tests than the other two testing categories. Assume you are experienced with the three mentioned tests. You will find that implementing unit tests takes the least amount of time compared to the other two and takes a few seconds to execute hundreds of them (after compiling and loading the code).</p>
<p>Discussing this triangle with respect to brownfield projects will be covered in <a href="B18370_12.xhtml#_idTextAnchor279"><em class="italic">Chapter 12</em></a>, <em class="italic">Dealing with Brownfield Projects</em>. Hopefully, debating integration test and Sintegration test have helped you to better understand what a unit test is.</p>
<h1 id="_idParaDest-102"><a id="_idTextAnchor112"/>Summary</h1>
<p>In this chapter, we compared unit tests with its siblings: <em class="italic">integration</em> and <em class="italic">Sintegration</em> <em class="italic">tests</em>. We listed test doubles and gave an example of each, and we have also seen xUnit and NSubstitute in action.</p>
<p>Our journey with understanding unit testing and test doubles will not stop here, but we will cover more examples of the two topics across the rest of the book.</p>
<p>So far, you can consider the experience from this chapter to take you to TDD level 3 out of 5! And now, you should be able to write a basic unit test that uses test doubles.</p>
<p>We have not covered the advantages and disadvantages of unit testing—yes, it has disadvantages! We have also not covered how TDD relates to unit testing and the best practices of unit testing because this is the role of the next chapter, <em class="italic">Test-Driven Development Explained</em>.</p>
<h1 id="_idParaDest-103"><a id="_idTextAnchor113"/>Further reading</h1>
<p>To learn more about the topics discussed in the chapter, you can refer to the following links:</p>
<ul>
<li><em class="italic">Martin Fowler’s definition of test doubles</em>: <a href="https://martinfowler.com/bliki/TestDouble.xhtml%0D">https://martinfowler.com/bliki/TestDouble.xhtml</a></li>
<li><em class="italic">NSubstitute</em>: <a href="https://nsubstitute.github.io">https://nsubstitute.github.io</a></li>
</ul>
</div>
</div>
</body></html>