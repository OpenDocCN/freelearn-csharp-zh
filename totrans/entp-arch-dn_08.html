<html><head></head><body>
<div id="_idContainer076">
<h1 class="chapter-number" id="_idParaDest-160"><a id="_idTextAnchor271"/><span class="koboSpan" id="kobo.1.1">8</span></h1>
<h1 id="_idParaDest-161"><a id="_idTextAnchor272"/><span class="koboSpan" id="kobo.2.1">Service Orientation and APIs</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Now that we have explained many principles and several methods, we are going to move on to chapters that will be a bit more technical and thus will show more examples being applied to our demonstration application. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will explain the notion of </span><em class="italic"><span class="koboSpan" id="kobo.4.1">service</span></em><span class="koboSpan" id="kobo.5.1"> from the IT perspective and will try to place services in the history of IT to give you a good understanding of what they are for and what they have brought to the industry. </span><span class="koboSpan" id="kobo.5.2">There are still shortcomings, of course, but web-oriented architecture and web services in general bring huge value to the software industry when they are correctly designed (which, sadly, is far from </span><span class="No-Break"><span class="koboSpan" id="kobo.6.1">being common).</span></span></p>
<p><span class="koboSpan" id="kobo.7.1">After this examination of the history of services, we will detail the characteristics of a good service-based architecture (I am not using the expression </span><em class="italic"><span class="koboSpan" id="kobo.8.1">Service-Oriented Architecture</span></em><span class="koboSpan" id="kobo.9.1"> for a precise reason, as you will discover shortly) and explain how their current evolution, namely REST APIs, can be of benefit to many </span><span class="No-Break"><span class="koboSpan" id="kobo.10.1">software systems.</span></span></p>
<p><span class="koboSpan" id="kobo.11.1">Finally, we will show how the architecture patterns seen in the previous chapter apply to the definition of services for the demo application. </span><span class="koboSpan" id="kobo.11.2">To do so, we will of course use REST APIs since they are at the core of every modern approach to IT system architecture. </span><span class="koboSpan" id="kobo.11.3">We will come back to the notion of standards, which was heavily discussed in </span><a href="B21293_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.12.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.13.1">, and explain which ones can be used in our demonstration system. </span><span class="koboSpan" id="kobo.13.2">Finally, we will explain what we can do when no standards exist or apply, and this will form the transition point to the </span><span class="No-Break"><span class="koboSpan" id="kobo.14.1">next chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.15.1">In this chapter, we’ll cover the </span><span class="No-Break"><span class="koboSpan" id="kobo.16.1">following points:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.17.1">Looking at the history of </span><span class="No-Break"><span class="koboSpan" id="kobo.18.1">service orientation</span></span></li>
<li><span class="koboSpan" id="kobo.19.1">Characteristics of </span><span class="No-Break"><span class="koboSpan" id="kobo.20.1">a service</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Application to our </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">demonstration system</span></span></li>
</ul>
<h1 id="_idParaDest-162"><a id="_idTextAnchor273"/><span class="koboSpan" id="kobo.23.1">Looking at the history of service orientation</span></h1>
<p><span class="koboSpan" id="kobo.24.1">First of all, let’s start</span><a id="_idIndexMarker386"/><span class="koboSpan" id="kobo.25.1"> with a bit of history. </span><span class="koboSpan" id="kobo.25.2">it may be because I am an old-timer and have been programming for the past 37 years, with 25 of them in industrial contexts, but I think it is always interesting to know where we are coming from as this explains a lot of what technologies today have been created for, and what they still miss. </span><span class="koboSpan" id="kobo.25.3">This way, not only can we anticipate the shortcomings of certain techniques and software artifacts, but we also avoid the risk of not using them to their full </span><a id="_idIndexMarker387"/><span class="koboSpan" id="kobo.26.1">potential, as intended by their creators. </span><span class="koboSpan" id="kobo.26.2">Unrolling the history of technologies has yet another advantage: while strolling along this path, you may stumble upon an old but still interesting technology that may better fit your context than the new kid on the block. </span><span class="koboSpan" id="kobo.26.3">This does not happen so often, but when it does and you can solve your IT problem with a battle-hardened, yet simpler technology than the tools generally used at present, it can provide you a huge boost in maintenance time and performance. </span><span class="koboSpan" id="kobo.26.4">For example, files-based interop may seem laughable to someone using web APIs every day, but in particular, contexts where asynchronous is better, security is not a problem, independence of the process is an advantage, and avoiding the deployment of a web server is a time-saver, they can be the </span><span class="No-Break"><span class="koboSpan" id="kobo.27.1">perfect solution.</span></span></p>
<p><span class="koboSpan" id="kobo.28.1">So, let’s start this journey with interop techniques, and in particular begin with why we </span><span class="No-Break"><span class="koboSpan" id="kobo.29.1">need them</span><a id="_idTextAnchor274"/><span class="koboSpan" id="kobo.30.1">.</span></span></p>
<h2 id="_idParaDest-163"><a id="_idTextAnchor275"/><span class="koboSpan" id="kobo.31.1">The long-awaited reusability</span></h2>
<p><span class="koboSpan" id="kobo.32.1">Making two parts of a software entity interop with each other is a concept almost as old as programming itself since it is related to reusability. </span><span class="koboSpan" id="kobo.32.2">For a common function to not need to be typed twice, there needs to be a way to separate it from the rest of the code that is different, and make it callable, one way or another, by these pieces of code. </span><span class="koboSpan" id="kobo.32.3">This can be easily schematized as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.33.1">Figure 8</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.34.1">.1</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer065">
<span class="koboSpan" id="kobo.36.1"><img alt="Figure 8.1 – Reusing common code" src="image/B21293_08_01.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.37.1">Figure 8.1 – Reusing common code</span></p>
<p><span class="koboSpan" id="kobo.38.1">Code duplication is a problem (although the Don’t Repeat Yourself principle may have its own shortcomings and every programming choice is always a compromise), so putting some code in common is generally a valuable orientation. </span><span class="koboSpan" id="kobo.38.2">There are lots of ways to organize this, and reusability has been sought after like the Graal in IT for many years, </span><span class="No-Break"><span class="koboSpan" id="kobo.39.1">even decades.</span></span><a id="_idTextAnchor276"/></p>
<h2 id="_idParaDest-164"><a id="_idTextAnchor277"/><span class="koboSpan" id="kobo.40.1">Routines and avoiding punching additional paper cards</span></h2>
<p><span class="koboSpan" id="kobo.41.1">The first </span><a id="_idIndexMarker388"/><span class="koboSpan" id="kobo.42.1">attempt at reusability came from an era that most of you will not even know about, where programs existed in the form of paper cards punched with holes to provide instructions to the computer. </span><span class="koboSpan" id="kobo.42.2">This actually came from the Jacquard weaving mechanisms where these paper cards were used to control cloth threads in semi-automated machines to make certain figures and weaving patterns appear in the resulting cloth. </span><span class="koboSpan" id="kobo.42.3">Repeatability was already possible by using the same card again and again, but the reuse of a pattern on a given card was done by punching the card many times in the exact same way, resulting in a long manual process and involving the risk of errors. </span><span class="koboSpan" id="kobo.42.4">Also, each application, composed of boxes with punched cards in the exact order, had to contain every single instruction. </span><span class="koboSpan" id="kobo.42.5">Due to the fixed number of instructions that could fit on a card, it was practically impossible that a card could be reused in another stack. </span><span class="koboSpan" id="kobo.42.6">Even if it was possible, extracting the right card, using it, and then returning it to the right position in the stack would have been too dangerous for both applications involved, particularly with regard to duplicating the paper card, even if it was a </span><span class="No-Break"><span class="koboSpan" id="kobo.43.1">manual operation.</span></span></p>
<p><span class="koboSpan" id="kobo.44.1">Then came the idea of routines and sending the code back to a given address of the program to make it repeat some part of its instructions. </span><span class="koboSpan" id="kobo.44.2">The notion associated with the infamous (but still worthy) </span><strong class="source-inline"><span class="koboSpan" id="kobo.45.1">GOTO</span></strong><span class="koboSpan" id="kobo.46.1"> instruction was born, and it saved many instructions in the programs that followed. </span><span class="koboSpan" id="kobo.46.2">But there was a problem: routines could only be used inside a single program. </span><span class="koboSpan" id="kobo.46.3">Admittedly, it helped reduce their size. </span><span class="koboSpan" id="kobo.46.4">Nonetheless, when creating a new program, it was still necessary to type in the same code – and we’re talking about a time when copy-paste simply did not exist. </span><span class="koboSpan" id="kobo.46.5">So, there was a need for something better. </span><span class="koboSpan" id="kobo.46.6">This is what we are going to explore in the </span><span class="No-Break"><span class="koboSpan" id="kobo.47.1">coming sections</span><a id="_idTextAnchor278"/><span class="koboSpan" id="kobo.48.1">.</span></span></p>
<h2 id="_idParaDest-165"><a id="_idTextAnchor279"/><span class="koboSpan" id="kobo.49.1">Libraries and the capacity to share instructions between programs</span></h2>
<p><span class="koboSpan" id="kobo.50.1">The next evolution of reuse was the </span><a id="_idIndexMarker389"/><span class="koboSpan" id="kobo.51.1">concept of </span><strong class="bold"><span class="koboSpan" id="kobo.52.1">libraries</span></strong><span class="koboSpan" id="kobo.53.1">, where the common code is placed in a different file than the original calling bits of code. </span><span class="koboSpan" id="kobo.53.2">This is simple but efficient, as virtually every piece of code—to this day—exists as text content stored in files. </span><span class="koboSpan" id="kobo.53.3">Though many other approaches have been attempted to make interop universal, libraries in the form of .NET assemblies with </span><strong class="source-inline"><span class="koboSpan" id="kobo.54.1">.dll</span></strong><span class="koboSpan" id="kobo.55.1"> files, or Java modules in </span><strong class="source-inline"><span class="koboSpan" id="kobo.56.1">.jar</span></strong><span class="koboSpan" id="kobo.57.1"> archives, are still the foundations of reuse, and universality is not far when Base Class Libraries like the one from Microsoft are evidence for all .NET programmers. </span><span class="koboSpan" id="kobo.57.2">For this particular framework that started under the strict control of Microsoft and progressively flourished into open-source availability, history has been a blessing, since lots of libraries are simply implemented once and for all. </span><span class="koboSpan" id="kobo.57.3">Java, on the other side, started as a more open</span><a id="_idIndexMarker390"/><span class="koboSpan" id="kobo.58.1"> platform but became progressively more closed after the buying of Sun by Oracle. </span><span class="koboSpan" id="kobo.58.2">Though things start to unify a bit (at the price of a slower evolution), there still are many libraries to do the same thing within the Java ecosystem. </span><span class="koboSpan" id="kobo.58.3">I remember being flabbergasted with my first professional developments in Java, after five years of .NET, by the fact that there was not a single XML parser library, but many of them, each being the best at one thing: Xerces being good at streaming analysis; Xalan recognized as the quickest at fully loading an XML DOM; some other library handling the DTD schemas and validation better; and so on. </span><span class="koboSpan" id="kobo.58.4">For someone used to having only </span><strong class="source-inline"><span class="koboSpan" id="kobo.59.1">System.Xml</span></strong><span class="koboSpan" id="kobo.60.1"> to think about, that was a huge surprise and a big disappointment, since it made the learning curve all of a sudden dramatically steeper than the closeness of the platform and language led me </span><span class="No-Break"><span class="koboSpan" id="kobo.61.1">to expect.</span></span></p>
<p><span class="koboSpan" id="kobo.62.1">Anyhow, libraries are certainly the most widespread approach for reuse in programming platforms and exist in almost all modern languages, be it JavaScript, Python, C or C++, and so on. </span><span class="koboSpan" id="kobo.62.2">Though libraries also have their difficulties, not only in the versioning and forward-compatibility areas but also in the ease of copying a file, which sometimes ends up in multiple copies in a code base (which goes against the initial goal of reuse), they remain the go-to approach when reuse is necessary. </span><span class="koboSpan" id="kobo.62.3">Of course, as far as interop is needed, they have pronounced shortcomings since they are only usable in their own execution platforms: though bridges may exist, a Java library can only be used by a Java program, a .NET assembly can only be called by another .NET assembly, and so on. </span><span class="koboSpan" id="kobo.62.4">This is a problem that has occupied IT engineers for a long time and is where lots of solutions </span><span class="No-Break"><span class="koboSpan" id="kobo.63.1">have appear</span><a id="_idTextAnchor280"/><span class="koboSpan" id="kobo.64.1">ed.</span></span></p>
<h2 id="_idParaDest-166"><a id="_idTextAnchor281"/><span class="koboSpan" id="kobo.65.1">Attempts at general interoperability</span></h2>
<p><span class="koboSpan" id="kobo.66.1">The main solution to the aforementioned limitation was to create libraries that contained code in a compiled form, in such a way that the machine code was usable from any caller, whatever language was used to create the calling program, as long as it was also compiled in machine-readable code. </span><span class="koboSpan" id="kobo.66.2">The difficulty there was mostly technical: calling one such library was not as simple as using a function name and attributes. </span><span class="koboSpan" id="kobo.66.3">Also, there was still a limitation due to the platform of compilation. </span><span class="koboSpan" id="kobo.66.4">There was indeed no way to execute a Windows library inside a Linux operating system and </span><span class="No-Break"><span class="koboSpan" id="kobo.67.1">vice versa.</span></span></p>
<p><span class="koboSpan" id="kobo.68.1">Microsoft actually tried to go a bit further in this direction by introducing the notion of OS-controlled components. </span><span class="koboSpan" id="kobo.68.2">These reusable units were not directly available as files but as entities known by the operating system itself: their concrete form was still filed, with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">.dll</span></strong><span class="koboSpan" id="kobo.70.1"> extension, but when </span><em class="italic"><span class="koboSpan" id="kobo.71.1">registered</span></em><span class="koboSpan" id="kobo.72.1">, Windows would make the functions available to any program even if it did not have access to the original file. </span><span class="koboSpan" id="kobo.72.2">In addition to being a repository for application customization, the registry also stores the necessary information for </span><a id="_idIndexMarker391"/><span class="koboSpan" id="kobo.73.1">the </span><strong class="bold"><span class="koboSpan" id="kobo.74.1">Component Object Model</span></strong><span class="koboSpan" id="kobo.75.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.76.1">COM</span></strong><span class="koboSpan" id="kobo.77.1">); in fact, it even started its career in Windows 3.11 mostly for this use. </span><span class="koboSpan" id="kobo.77.2">Together with COM, a Microsoft technology called Dynamic Data Exchange allowed application components to be inserted into one another. </span><span class="koboSpan" id="kobo.77.3">This is what you use today when you open an Excel worksheet inside a Word document and see the </span><span class="No-Break"><span class="koboSpan" id="kobo.78.1">menus adapt.</span></span></p>
<p><span class="koboSpan" id="kobo.79.1">After </span><a id="_idIndexMarker392"/><span class="koboSpan" id="kobo.80.1">COM came extensions such as COM+, then for </span><strong class="bold"><span class="koboSpan" id="kobo.81.1">Distributed COM</span></strong><span class="koboSpan" id="kobo.82.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.83.1">DCOM</span></strong><span class="koboSpan" id="kobo.84.1">), which </span><a id="_idIndexMarker393"/><span class="koboSpan" id="kobo.85.1">was an attempt at breaking out of the perimeter of the local computer and introducing remote execution of components. </span><span class="koboSpan" id="kobo.85.2">These did not have the same success as the latest innovation in this vein of components, called ActiveX. </span><span class="koboSpan" id="kobo.85.3">ActiveX was a technology built on COM to make it easier to integrate graphical components into applications, instead of just functions. </span><span class="koboSpan" id="kobo.85.4">It was even possible to embed these in web applications by delivering them within the browser. </span><span class="koboSpan" id="kobo.85.5">At a time when browser security was not as extended as today, it provided lots of interesting features, but the technology is </span><span class="No-Break"><span class="koboSpan" id="kobo.86.1">now outdated.</span></span></p>
<p><span class="koboSpan" id="kobo.87.1">Other technologies for distributed components existed, such as Enterprise Java Beans and all platforms using CORBA, but they had the same limitations as DCOM and did not exhibit the level of low coupling that was initially promised. </span><span class="koboSpan" id="kobo.87.2">Version control was left to the maintainer of the platform, no capacity existed for a relationship with the presentation layer, and other shortcomings made for a limited future for these technologies that are nowadays </span><span class="No-Break"><span class="koboSpan" id="kobo.88.1">pure legacy.</span></span></p>
<p><span class="koboSpan" id="kobo.89.1">In fact, interoperation in the form of components might have been too humble to really reach the state of an ever-lasting technology such as ASCII, Unicode, HTTP, and some other norms that are so widely used, including as the basis for new approaches, that they will be around for the foreseeable future of software. </span><span class="koboSpan" id="kobo.89.2">Components started inside the perimeter of a single machine and never found a way to step out. </span><span class="koboSpan" id="kobo.89.3">A completely universal approach was necessary to make the next step, and it concerned bringing interoperability and reuse to a whole network of computers – and to be worth it, this had to be in the biggest network of all, </span><span class="No-Break"><span class="koboSpan" id="kobo.90.1">the Int</span><a id="_idTextAnchor282"/><span class="koboSpan" id="kobo.91.1">ernet.</span></span></p>
<h2 id="_idParaDest-167"><a id="_idTextAnchor283"/><span class="koboSpan" id="kobo.92.1">Using web standards to try and get universal</span></h2>
<p><span class="koboSpan" id="kobo.93.1">The next milestone </span><a id="_idIndexMarker394"/><span class="koboSpan" id="kobo.94.1">in our history of interop concerns web services, in the general acceptance of the term, meaning providing a service through web standards. </span><span class="koboSpan" id="kobo.94.2">The web was the obvious way to make this next step since its foundations of HTTP, TCP/IP, Unicode, and XML were already available and offered a good part of the foundation such a universal interop technology </span><span class="No-Break"><span class="koboSpan" id="kobo.95.1">would need.</span></span></p>
<p><span class="koboSpan" id="kobo.96.1">The first attempt at web services (or what we could call </span><em class="italic"><span class="koboSpan" id="kobo.97.1">reusable functions over the internet</span></em><span class="koboSpan" id="kobo.98.1">) was implemented </span><a id="_idIndexMarker395"/><span class="koboSpan" id="kobo.99.1">with technologies such as </span><strong class="bold"><span class="koboSpan" id="kobo.100.1">Simple Object Access Protocol (SOAP)</span></strong><span class="koboSpan" id="kobo.101.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.102.1">Web Service Description Language (WSDL)</span></strong><span class="koboSpan" id="kobo.103.1">, and since these standards were alone in the field, they simply</span><a id="_idIndexMarker396"/><span class="koboSpan" id="kobo.104.1"> preempted the term </span><em class="italic"><span class="koboSpan" id="kobo.105.1">web service</span></em><span class="koboSpan" id="kobo.106.1">, which became the accepted jargon for SOAP- and WSDL-compatible expositions. </span><span class="koboSpan" id="kobo.106.2">SOAP was about standardizing the XML content of requests and responses over HTTP to make them look like function calls, with an envelope, attributes with types, possible metadata, and so on. </span><span class="koboSpan" id="kobo.106.3">WSDL was the norm used to express the associated contract, in short, the grammar that was supposed to be used in SOAP messages. </span><span class="koboSpan" id="kobo.106.4">There were additional </span><a id="_idIndexMarker397"/><span class="koboSpan" id="kobo.107.1">norms such as </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">Universal Description, Discovery, and Integration (UDDI)</span></strong><span class="koboSpan" id="kobo.109.1">, for example, but these fell short of their objectives and quickly declined. </span><span class="koboSpan" id="kobo.109.2">This was also the case for lots of the so-called </span><em class="italic"><span class="koboSpan" id="kobo.110.1">WS-*</span></em><span class="koboSpan" id="kobo.111.1"> standards – WS-Authentication, WS-Routing, and other syntax additions to the web-service grammar that were intended to allow for </span><span class="No-Break"><span class="koboSpan" id="kobo.112.1">complementary features.</span></span></p>
<p><span class="koboSpan" id="kobo.113.1">These solutions gained a lot of momentum in the industry in the 2000s and were at their strongest in the early 2010s. </span><span class="koboSpan" id="kobo.113.2">In fact, they generated a whole architecture known as </span><strong class="bold"><span class="koboSpan" id="kobo.114.1">Service Oriented Architecture (SOA)</span></strong><span class="koboSpan" id="kobo.115.1">. </span><span class="koboSpan" id="kobo.115.2">SOA</span><a id="_idIndexMarker398"/><span class="koboSpan" id="kobo.116.1"> should have remained a generic term, but it has become associated with particular architectures and software. </span><span class="koboSpan" id="kobo.116.2">Also, software manufacturers heavily invested in </span><em class="italic"><span class="koboSpan" id="kobo.117.1">SOA tools</span></em><span class="koboSpan" id="kobo.118.1">, making companies believe that central middleware was all they needed to reach interop, while people knowledgeable in interoperability knew that this was only one part of the deal, with semantic and functional interoperability being, in fact, more critical and more complex to obtain than technical interoperability, which is generally the last mile in </span><span class="No-Break"><span class="koboSpan" id="kobo.119.1">the process.</span></span></p>
<p><span class="koboSpan" id="kobo.120.1">This of course led to lots of critics of SOA, and many articles in the mid-2010s announced the death of SOA and its failure to reach its goals. </span><span class="koboSpan" id="kobo.120.2">In the meantime, its spread was still huge in the industry and lots of technologies had a rebirth </span><a id="_idTextAnchor284"/><span class="koboSpan" id="kobo.121.1">due </span><span class="No-Break"><span class="koboSpan" id="kobo.122.1">to SOA.</span></span></p>
<h2 id="_idParaDest-168"><a id="_idTextAnchor285"/><span class="koboSpan" id="kobo.123.1">The steps in middleware</span></h2>
<p><span class="koboSpan" id="kobo.124.1">Middleware applications in particular were pumped up by the SOA architecture and, even when they were not based on SOAP and WSDL, they were able to adapt to it. </span><strong class="bold"><span class="koboSpan" id="kobo.125.1">Enterprise Application Integration</span></strong><span class="koboSpan" id="kobo.126.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.127.1">EAI</span></strong><span class="koboSpan" id="kobo.128.1">) was an old dream and supposed that centralized </span><a id="_idIndexMarker399"/><span class="koboSpan" id="kobo.129.1">adapters made it possible for many applications in a system to talk to each other, with the EAI platform translating every message from one format to the target format. </span><span class="koboSpan" id="kobo.129.2">Of course, its centralized aspect was a </span><strong class="bold"><span class="koboSpan" id="kobo.130.1">Single Point of Failure</span></strong><span class="koboSpan" id="kobo.131.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.132.1">SPoF</span></strong><span class="koboSpan" id="kobo.133.1">) and</span><a id="_idIndexMarker400"/><span class="koboSpan" id="kobo.134.1"> quite a drawback. </span><span class="koboSpan" id="kobo.134.2">If you add to this an update of the EAI bricks, which is needed every time any of the applications change its version, it is no wonder that these customized systems never </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">reached maturity.</span></span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.136.1">Extract, Transform, Load</span></strong><span class="koboSpan" id="kobo.137.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.138.1">ETL</span></strong><span class="koboSpan" id="kobo.139.1">) is a </span><a id="_idIndexMarker401"/><span class="koboSpan" id="kobo.140.1">set of data manipulation tools, but they can be classified as middleware applications, particularly since lots of interoperability streams between applications </span><a id="_idIndexMarker402"/><span class="koboSpan" id="kobo.141.1">in common information systems are really pure data transfer, and not business function calls. </span><span class="koboSpan" id="kobo.141.2">Of course, this is a crude middleware, but the quality of the data is more important than the sophistication of the tool, and a well-controlled ETL can go a long way in structuring streams of information. </span><span class="koboSpan" id="kobo.141.3">Still, ETLs are not completely adapted to digital transformation, and it can be easy to lose control of them. </span><span class="koboSpan" id="kobo.141.4">One of the companies I have consulted for had such a messy system of ETL jobs, with more than a thousand of them kicking up every night, that the whole system needed a dedicated tool to orchestrate the jobs in a precise sequence for them to end up in clean data in the morning. </span><span class="koboSpan" id="kobo.141.5">With the never-ending addition of new jobs, time started to become scarce during the low-activity periods, and after using simple solutions such as adding more server power and parallelizing what could be parallelized, it reached a point where the whole system would finish its work only after the offices had opened. </span><span class="koboSpan" id="kobo.141.6">This, of course, became an important problem that had to be dealt with using radical decisions. </span><span class="koboSpan" id="kobo.141.7">To make it worse, the jobs were so interdependent and brittle that there was never a night where all jobs passed and it was necessary to run a few correcting jobs during operations, or—for the riskiest ones—to simply wait for the next night to, hopefully, get the clean data. </span><span class="koboSpan" id="kobo.141.8">For informational purposes (and may it serve as a warning as well, since the sheer number of jobs makes the diagram almost unreadable), the following diagram shows a graph of the chronological execution of the jobs. </span><span class="koboSpan" id="kobo.141.9">This diagram is meant to be an overview of complex jobs; text readability is </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">not intended.</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer066">
<span class="koboSpan" id="kobo.143.1"><img alt="Figure 8.2 – Complex job orchestration" src="image/B21293_08_2.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.144.1">Figure 8.2 – Complex job orchestration</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.145.1">Message-Oriented Middlewares (MOMs)</span></strong><span class="koboSpan" id="kobo.146.1"> already </span><a id="_idIndexMarker403"/><span class="koboSpan" id="kobo.147.1">existed for some time but got a kick from SOA and AMQP, ActiveMQ, MSMQ, and RabbitMQ gaining some market visibility by introducing robustness in message delivery (the WS-Reliability and WS-ReliableMessaging standards never really made it to the top, particularly because reliability needs to be ensured at the application level and not only in the messaging layer). </span><span class="koboSpan" id="kobo.147.2">Even in</span><a id="_idIndexMarker404"/><span class="koboSpan" id="kobo.148.1"> today’s architecture, which does not use SOAP web services anymore, a MOM is useful to ensure full-featured transportation of particularly important messages in the system. </span><span class="koboSpan" id="kobo.148.2">Some MOM proponents argue that all messages should pass through the middleware, preventing applications from talking directly from one to the other, but this has a toll on performance and we will show that functional standards for messages allow the removal of the </span><span class="No-Break"><span class="koboSpan" id="kobo.149.1">mediation layer.</span></span></p>
<p><span class="koboSpan" id="kobo.150.1">As far as the mediation layer is concerned, MOMs benefited a lot from a standard way of manipulating messages that were defined by Hohpe and Wolf (</span><a href="https://www.enterpriseintegrationpatterns.com/"><span class="koboSpan" id="kobo.151.1">https://www.enterpriseintegrationpatterns.com/</span></a><span class="koboSpan" id="kobo.152.1">), called </span><strong class="bold"><span class="koboSpan" id="kobo.153.1">Enterprise Integration Patterns</span></strong><span class="koboSpan" id="kobo.154.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.155.1">EIP</span></strong><span class="koboSpan" id="kobo.156.1">). </span><span class="koboSpan" id="kobo.156.2">EIP</span><a id="_idIndexMarker405"/><span class="koboSpan" id="kobo.157.1"> defines some standard bricks for handling software messages, such as Multiplex, Content-Based Router, Enrich, and so on. </span><span class="koboSpan" id="kobo.157.2">By combining these basic bricks of message transformation or routing, a MOM was able to handle almost all possible functional situations. </span><span class="koboSpan" id="kobo.157.3">Apache Camel is the reference open-source EIP implementation, and it is used in many middlewares. </span><span class="koboSpan" id="kobo.157.4">The term </span><em class="italic"><span class="koboSpan" id="kobo.158.1">bricks</span></em><span class="koboSpan" id="kobo.159.1"> is particularly adapted to these patterns, as they can be explained with actual, concrete, Lego™ bricks: I have often used these to visually explain the concepts of software system architecture and in particular, how to make it evolve with minimal impact by introducing a mediation layer with composable actions, each of them handled by a simple assembly of Technical Lego™ bricks, as shown in </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.160.1">Figure 8</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.161.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.162.1">:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer067">
<span class="koboSpan" id="kobo.163.1"><img alt="Figure 8.3 – Enterprise Integration Patterns simulated with Lego(TM) bricks" src="image/B21293_08_3.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.164.1">Figure 8.3 – Enterprise Integration Patterns simulated with Lego(TM) bricks</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.165.1">Enterprise Service Buses</span></strong><span class="koboSpan" id="kobo.166.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.167.1">ESBs</span></strong><span class="koboSpan" id="kobo.168.1">) are </span><a id="_idIndexMarker406"/><span class="koboSpan" id="kobo.169.1">the natural evolution of MOM and SOA, colliding with the principles of the internet. </span><span class="koboSpan" id="kobo.169.2">An ESB integrates all the technologies we have talked about in a system where there is no centralization anymore: the network (in TCP/UDP) is the only thing that remains central and its ability to adapt delivery is used to improve </span><a id="_idIndexMarker407"/><span class="koboSpan" id="kobo.170.1">robustness to a node failure. </span><span class="koboSpan" id="kobo.170.2">At the same time, the </span><em class="italic"><span class="koboSpan" id="kobo.171.1">Store &amp; Forward</span></em><span class="koboSpan" id="kobo.172.1"> pattern is used to make sure that the messages can almost never be lost since they are persisted and only deleted when the next destination has confirmed that they persisted under their control. </span><span class="koboSpan" id="kobo.172.2">ESBs had just about everything that was needed to reach the complete functional goal of interoperability in systems that were internet-scaled. </span><span class="koboSpan" id="kobo.172.3">But still, they failed, or at least did not succeed as much as would be expected for the ideal solution to such an important problem in the IT industry. </span><span class="koboSpan" id="kobo.172.4">In fact, ESBs added all the necessary features, but this was their doom. </span><span class="koboSpan" id="kobo.172.5">Since they could make everything, their heavy, complex machinery required extensive expertise to</span><a id="_idTextAnchor286"/><span class="koboSpan" id="kobo.173.1"> run </span><span class="No-Break"><span class="koboSpan" id="kobo.174.1">and maintain.</span></span></p>
<h2 id="_idParaDest-169"><a id="_idTextAnchor287"/><span class="koboSpan" id="kobo.175.1">The most recent evolution – REST APIs</span></h2>
<p><span class="koboSpan" id="kobo.176.1">Then came REST, which</span><a id="_idIndexMarker408"/><span class="koboSpan" id="kobo.177.1"> is a much lighter way of creating web-based APIs, and this changed the ecosystem quite radically again. </span><strong class="bold"><span class="koboSpan" id="kobo.178.1">REpresentational State Transfer (REST)</span></strong><span class="koboSpan" id="kobo.179.1"> had been defined before 2000 but became really </span><a id="_idIndexMarker409"/><span class="koboSpan" id="kobo.180.1">famous in the early 2010s. </span><span class="koboSpan" id="kobo.180.2">In the 2020s, though the part of the legacy software is huge and SOAP web services continue to be exploited, no new project would start based on these old technologies and virtually every new API project is using REST, or at least some degraded, not really “</span><span class="No-Break"><span class="koboSpan" id="kobo.181.1">RESTful” approach.</span></span></p>
<p><span class="koboSpan" id="kobo.182.1">In a few words, REST</span><a id="_idIndexMarker410"/><span class="koboSpan" id="kobo.183.1"> is about going back to the basic mechanisms of HTTP to allow function calls on the web. </span><span class="koboSpan" id="kobo.183.2">For example, instead of sending the code of the operation in the envelope as SOAP does, REST uses HTTP verbs such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">GET</span></strong><span class="koboSpan" id="kobo.185.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.186.1">POST</span></strong><span class="koboSpan" id="kobo.187.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.188.1">PUT</span></strong><span class="koboSpan" id="kobo.189.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.190.1">PATCH</span></strong><span class="koboSpan" id="kobo.191.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.192.1">DELETE</span></strong><span class="koboSpan" id="kobo.193.1"> to instruct the server on what should be done. </span><span class="koboSpan" id="kobo.193.2">Instead of sending function calls, it deals with resources just as HTTP does with the more-known HTML pages or images that are served through the web; it just happens that these resources are functionally oriented, such as a customer or a contract. </span><span class="koboSpan" id="kobo.193.3">Each of these business entities has URLs just like a web page or resource has. </span><span class="koboSpan" id="kobo.193.4">Their representation can be in HTML but is more suited to XML or JSON, the latter of which is also lighter than its predecessor XML. </span><span class="koboSpan" id="kobo.193.5">Hypermedia, format negotiation, and headers are also used for the equivalent interop function. </span><span class="koboSpan" id="kobo.193.6">Authorization is simply left to the equivalent feature in any HTTP call, using Basic Authentication, Bearer tokens, and so on. </span><span class="koboSpan" id="kobo.193.7">In short, REST stripped the web-based interop to the bone and eliminated every ounce of fat to focus on the pure and complete use of existing standards. </span><span class="koboSpan" id="kobo.193.8">REST does not actually need anything else beyond existing standards such as HTTP, JSON or XML, and Unicode. </span><span class="koboSpan" id="kobo.193.9">In this way, it is more a practice than a </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">new protocol.</span></span></p>
<p><span class="koboSpan" id="kobo.195.1">And it worked… It actually worked so well that commentators on the internet did not hesitate to talk about SOA 2.0, or even </span><em class="italic"><span class="koboSpan" id="kobo.196.1">SOA made right</span></em><span class="koboSpan" id="kobo.197.1">. </span><span class="koboSpan" id="kobo.197.2">Some introduced new architectural terms such as </span><em class="italic"><span class="koboSpan" id="kobo.198.1">Web-Oriented Application</span></em><span class="koboSpan" id="kobo.199.1"> to separate this approach from the original SOA. </span><span class="koboSpan" id="kobo.199.2">The best proof of success for REST is that no editor has built on its fame to try and impose a proprietary implementation: REST works well because it does not add anything but reduces any software layer to nil since everything already exists, and engineers only have to use it in the</span><a id="_idTextAnchor288"/><span class="koboSpan" id="kobo.200.1"> way it </span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">was intended.</span></span></p>
<h2 id="_idParaDest-170"><a id="_idTextAnchor289"/><span class="koboSpan" id="kobo.202.1">What we are missing to reach actual service reusability</span></h2>
<p><span class="koboSpan" id="kobo.203.1">This is where we are at the moment of writing this book, and there is absolutely no doubt that the situation will keep evolving, but we have reached a point where actual web-based interop, including between two separate entities, is an everyday reality for lots of companies, which is already a huge victory in itself. </span><span class="koboSpan" id="kobo.203.2">Sure, we can always go further, but the main path has been paved and the remaining tasks now are mostly about spreading good practices in this way of interoperating rather than imagining a new approach that overcomes any </span><span class="No-Break"><span class="koboSpan" id="kobo.204.1">current shortcomings.</span></span></p>
<p><span class="koboSpan" id="kobo.205.1">In fact, most </span><a id="_idIndexMarker411"/><span class="koboSpan" id="kobo.206.1">of the remaining problems are the presence of mediation connectors due to the lack of accepted formats for functional data exchange. </span><span class="koboSpan" id="kobo.206.2">If we want to reach the ideal place where global, universal interop will not be an issue anymore but rather a problem of the past, we would need to have an indisputable standard for each of the data streams. </span><span class="koboSpan" id="kobo.206.3">This is of course not possible and we are very far from such a satisfying state, but some precise, very widespread, and technically easy forms of exchange are currently covered. </span><span class="koboSpan" id="kobo.206.4">For example, authentication and identification are now well implemented by OpenID Connect, SAML, JSON Web Tokens, SCIM, and a few other norms. </span><span class="koboSpan" id="kobo.206.5">Sure, there are lots of legacy software and even expert engineers that do not use these, but the general orientation is that they are the future and everyone globally accepts this and works towards these norms, which will become convenience standards in the future, just as ASCII and Unicode are for text binary representations. </span><span class="koboSpan" id="kobo.206.6">A few other domains are covered, or at least have nice, fully-featured norms that could solve the problem, such as CMIS for electronic document exchanges or BPMN 2.0 for </span><span class="No-Break"><span class="koboSpan" id="kobo.207.1">workflow modeling.</span></span></p>
<p><span class="koboSpan" id="kobo.208.1">But the vast majority of exchanges are not covered by an indisputable standard and legions of connectors are still developed to establish correspondence between applications. </span><span class="koboSpan" id="kobo.208.2">This is a major waste of resources in global IT today, as these mediation connectors do not add any additional value to customers and end users. </span><span class="koboSpan" id="kobo.208.3">But the reality is that crafting a standard takes a lot of time, as we have seen in </span><a href="B21293_02.xhtml#_idTextAnchor038"><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.209.1">Chapter 2</span></em></span></a><span class="koboSpan" id="kobo.210.1">. </span><span class="koboSpan" id="kobo.210.2">Let’s try to focus on the positive, though: the movement is now active and the situation is getting better every year, with a strong interop foundation where the technical bits are now considered solved. </span><span class="koboSpan" id="kobo.210.3">Only the semantics and functional interop remain to be handled. </span><span class="koboSpan" id="kobo.210.4">This will be the subject of the next chapter but, before talking about this, we need to come back to the very notion of </span><em class="italic"><span class="koboSpan" id="kobo.211.1">service</span></em><span class="koboSpan" id="kobo.212.1"> and explain how a good service should be defined. </span><span class="koboSpan" id="kobo.212.2">We will then use these principles to draft the first services for our demonstration system using the architecture principles shown in the previous chapter and applying them to the demo application that has been shown previously and that we will develop in greater detail throughout</span><a id="_idTextAnchor290"/><span class="koboSpan" id="kobo.213.1"> the rest of </span><span class="No-Break"><span class="koboSpan" id="kobo.214.1">the book.</span></span></p>
<h1 id="_idParaDest-171"><a id="_idTextAnchor291"/><span class="koboSpan" id="kobo.215.1">Characteristics of a service</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.216.1">Service</span></strong><span class="koboSpan" id="kobo.217.1"> is such</span><a id="_idIndexMarker412"/><span class="koboSpan" id="kobo.218.1"> a blurry designation that a complete section will be necessary to give a good sense—rather than a single defi</span><a id="_idTextAnchor292"/><span class="koboSpan" id="kobo.219.1">nition—of </span><span class="No-Break"><span class="koboSpan" id="kobo.220.1">this concept.</span></span></p>
<h2 id="_idParaDest-172"><a id="_idTextAnchor293"/><span class="koboSpan" id="kobo.221.1">As a service explained</span></h2>
<p><span class="koboSpan" id="kobo.222.1">The</span><a id="_idIndexMarker413"/><span class="koboSpan" id="kobo.223.1"> expression </span><em class="italic"><span class="koboSpan" id="kobo.224.1">as a service</span></em><span class="koboSpan" id="kobo.225.1"> is used in many formulations: </span><strong class="bold"><span class="koboSpan" id="kobo.226.1">SaaS</span></strong><span class="koboSpan" id="kobo.227.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.228.1">Software as a Service</span></strong><span class="koboSpan" id="kobo.229.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.230.1">PaaS </span></strong><span class="koboSpan" id="kobo.231.1">for </span><strong class="bold"><span class="koboSpan" id="kobo.232.1">Platform as a Service</span></strong><span class="koboSpan" id="kobo.233.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.234.1">CaaS</span></strong><span class="koboSpan" id="kobo.235.1"> for </span><strong class="bold"><span class="koboSpan" id="kobo.236.1">Containers as a Service</span></strong><span class="koboSpan" id="kobo.237.1">, and </span><a id="_idIndexMarker414"/><span class="koboSpan" id="kobo.238.1">so on. </span><span class="koboSpan" id="kobo.238.2">Have you ever</span><a id="_idIndexMarker415"/><span class="koboSpan" id="kobo.239.1"> considered why such different things use this common denomination? </span><span class="koboSpan" id="kobo.239.2">This in itself gives maybe the best definition of what a service is: something that benefits from the advantages of something else without having to deal with the usually-associated externalities. </span><span class="koboSpan" id="kobo.239.3">A hotel room is a service because you benefit from a bed and a roof without needing to buy and maintain a house, or even clean the room. </span><span class="koboSpan" id="kobo.239.4">SaaS is a service because you can use the software (manipulating its interface, storing data and retrieving it, realizing complex computations, and exporting the results) without having to install the software, buy a long-term license, operate it, install new versions, and so on. </span><span class="koboSpan" id="kobo.239.5">IaaS is a service because it offers what you expect from infrastructure (CPU power, RAM, I/O, storage, network bandwidth, and use) without you needing to worry about the hardware aspect of buying servers, operating them, renting some room, sorting electricity and cooling, securing them physically, renewing the hardware when there is a failure, and </span><span class="No-Break"><span class="koboSpan" id="kobo.240.1">so on.</span></span></p>
<p><span class="koboSpan" id="kobo.241.1">This explanation of the </span><em class="italic"><span class="koboSpan" id="kobo.242.1">as a service</span></em><span class="koboSpan" id="kobo.243.1"> expression was necessary because the word </span><em class="italic"><span class="koboSpan" id="kobo.244.1">service</span></em><span class="koboSpan" id="kobo.245.1"> by itself is very generic and one may be a bit lost as to why we talk about </span><em class="italic"><span class="koboSpan" id="kobo.246.1">service-oriented architecture</span></em><span class="koboSpan" id="kobo.247.1">, then web services in the sense of SOAP web services, then services in the context of the web, and so on. </span><span class="koboSpan" id="kobo.247.2">When we talk about service in this book, we really mean service as a software function that is proposed to a user without them having to work on its implementation: the user does not have to know which platform is used, where the servers are, and so on. </span><span class="koboSpan" id="kobo.247.3">They only have to know the minimal information possible, namely a URL and the contract defining the exchange grammar, to interoperate with </span><span class="No-Break"><span class="koboSpan" id="kobo.248.1">the service.</span></span></p>
<p><span class="koboSpan" id="kobo.249.1">Does this remind you of something? </span><span class="koboSpan" id="kobo.249.2">Depending on only the functional definition of something, without any software-associated constraint? </span><span class="koboSpan" id="kobo.249.3">This is something that has already been exposed in the book, in particular where we talked about the four-layer CIGREF </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">map model:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer068">
<span class="koboSpan" id="kobo.251.1"><img alt="Figure 8.4 – Decoupling illustrated with the CIGREF map" src="image/B21293_08_4.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.252.1">Figure 8.4 – Decoupling illustrated with the CIGREF map</span></p>
<p><span class="koboSpan" id="kobo.253.1">When talking</span><a id="_idIndexMarker416"/><span class="koboSpan" id="kobo.254.1"> about providing a </span><em class="italic"><span class="koboSpan" id="kobo.255.1">function</span></em> <em class="italic"><span class="koboSpan" id="kobo.256.1">as a service</span></em><span class="koboSpan" id="kobo.257.1">, one can view it as having something in the second layer from the top (the Business Capability Map) without having to worry about how it is implemented in the third and fourth la</span><a id="_idTextAnchor294"/><span class="koboSpan" id="kobo.258.1">yers (the </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">technical ones).</span></span></p>
<h2 id="_idParaDest-173"><a id="_idTextAnchor295"/><span class="koboSpan" id="kobo.260.1">Getting rid of middleware altogether</span></h2>
<p><span class="koboSpan" id="kobo.261.1">The nice advantage of the </span><em class="italic"><span class="koboSpan" id="kobo.262.1">as-a-service</span></em><span class="koboSpan" id="kobo.263.1"> approach is that it allows us to get rid of the middleware altogether. </span><span class="koboSpan" id="kobo.263.2">Indeed, what we really want to avoid is the direct, point-to-point interop that causes a lot of coupling, as shown in the </span><span class="No-Break"><span class="koboSpan" id="kobo.264.1">following diagram:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer069">
<span class="koboSpan" id="kobo.265.1"><img alt="Figure 8.5 – Point-to-point interoperation" src="image/B21293_08_05.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.266.1">Figure 8.5 – Point-to-point interoperation</span></p>
<p><span class="koboSpan" id="kobo.267.1">But the </span><a id="_idIndexMarker417"/><span class="koboSpan" id="kobo.268.1">middleware, while introducing an indirection layer, poses two problems. </span><span class="koboSpan" id="kobo.268.2">The first one is that it introduces an additional software complexity, which can be hard to maintain. </span><span class="koboSpan" id="kobo.268.3">The second one is that we are still in the software layer of the CIGREF map, and this means that, if done badly (without standardizing the messages), we could very well end up with two steps of coupling instead of simplifying it! </span><span class="koboSpan" id="kobo.268.4">The following schema expresses this </span><span class="No-Break"><span class="koboSpan" id="kobo.269.1">potential danger:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.270.1"><img alt="Figure 8.6 – Interoperation through a middleware" src="image/B21293_08_06.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.271.1">Figure 8.6 – Interoperation through a middleware</span></p>
<p><span class="koboSpan" id="kobo.272.1">ESBs are often presented as a solution to avoid a centralized entity, but the way they actually work still implies the presence—though distributed—of software agents that can </span><span class="No-Break"><span class="koboSpan" id="kobo.273.1">cause coupling:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.274.1"><img alt="Figure 8.7 – Interoperation with Enterprise Service Bus" src="image/B21293_08_07.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.275.1">Figure 8.7 – Interoperation with Enterprise Service Bus</span></p>
<p><span class="koboSpan" id="kobo.276.1">One way </span><a id="_idIndexMarker418"/><span class="koboSpan" id="kobo.277.1">to avoid this coupling is to standardize the messages from a functional point </span><span class="No-Break"><span class="koboSpan" id="kobo.278.1">of view:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer072">
<span class="koboSpan" id="kobo.279.1"><img alt="Figure 8.8 – Interoperation with standardized decoupled functions" src="image/B21293_08_08.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.280.1">Figure 8.8 – Interoperation with standardized decoupled functions</span></p>
<p><span class="koboSpan" id="kobo.281.1">But if we reach this state where a functional standard has been created, the middleware actually does not need to map data anymore or translate any format, because the </span><strong class="source-inline"><span class="koboSpan" id="kobo.282.1">f</span></strong><span class="koboSpan" id="kobo.283.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">f'</span></strong><span class="koboSpan" id="kobo.285.1"> functions are actually the same (otherwise they would not have been included in a single stream of data). </span><span class="koboSpan" id="kobo.285.2">The middleware’s sole functions remain routing, authentication, and some other features that can simply be realized by HTTP and do not need any middleware. </span><span class="koboSpan" id="kobo.285.3">Thus, the</span><a id="_idIndexMarker419"/><span class="koboSpan" id="kobo.286.1"> intermediate simply disappears and we reach the ideal situation that was </span><span class="No-Break"><span class="koboSpan" id="kobo.287.1">expressed previously:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer073">
<span class="koboSpan" id="kobo.288.1"><img alt="Figure 8.9 – Principle of decoupling by indirection" src="image/B21293_08_09.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.289.1">Figure 8.9 – Principle of decoupling by indirection</span></p>
<p><span class="koboSpan" id="kobo.290.1">Here, the only difficulty remaining is a functional one, that of describing the business-related need. </span><span class="koboSpan" id="kobo.290.2">Admittedly, this can be a very difficult thing to do, but the main difference is that this is intrinsic complexity that we need to overcome in any case (otherwise the software will simply not work correctly) and not accidental, technical complexity that steps into our design phase and adds unnecessary problems of versioning, maintenance, and so on. </span><span class="koboSpan" id="kobo.290.3">This is the essence of decoupling and making it easier for the system </span><span class="No-Break"><span class="koboSpan" id="kobo.291.1">to evolve.</span></span></p>
<p><span class="koboSpan" id="kobo.292.1">Again, even though this is something we should strive to achieve in as many cases as possible and definitely a way to create some low-coupling interop, this kind of interaction is not always easy to realize. </span><span class="koboSpan" id="kobo.292.2">MOM and other middleware systems will not be retired any time soon, as they remain a good choice to interoperate complex messages, apply mediation, and ensure robustness of delivery when it is not possible to put in place a complete standardization of messages in</span><a id="_idTextAnchor296"/><span class="koboSpan" id="kobo.293.1"> the </span><span class="No-Break"><span class="koboSpan" id="kobo.294.1">information system.</span></span></p>
<h2 id="_idParaDest-174"><a id="_idTextAnchor297"/><span class="koboSpan" id="kobo.295.1">External interop finally becoming a reality</span></h2>
<p><span class="koboSpan" id="kobo.296.1">All of this</span><a id="_idIndexMarker420"/><span class="koboSpan" id="kobo.297.1"> may sound a bit theoretical, but this approach is what enables us to finally reach the stage where the interop between software </span><strong class="source-inline"><span class="koboSpan" id="kobo.298.1">A</span></strong><span class="koboSpan" id="kobo.299.1"> and software </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">B</span></strong><span class="koboSpan" id="kobo.301.1"> in the preceding diagrams (</span><em class="italic"><span class="koboSpan" id="kobo.302.1">Figures 8.5</span></em><span class="koboSpan" id="kobo.303.1"> to </span><em class="italic"><span class="koboSpan" id="kobo.304.1">8.9</span></em><span class="koboSpan" id="kobo.305.1">) does not depend on middleware or other artifacts that get in the way and make it complicated. </span><span class="koboSpan" id="kobo.305.2">The best way to show this is to provide a few </span><span class="No-Break"><span class="koboSpan" id="kobo.306.1">practical examples.</span></span></p>
<p><span class="koboSpan" id="kobo.307.1">In a company I worked for in the past, two customers (a regional council and a town) wanted to interop in such a way that, when the regional council added an association to its list, the city would automatically receive the information and store it in its own database, provided that it was the given city of registration. </span><span class="koboSpan" id="kobo.307.2">The way this was done necessitated some important preliminary work that had been done by my employer, which was to define a standard format for French associations. </span><span class="koboSpan" id="kobo.307.3">Since we knew the subject well, this took only a few days and we proposed this format to the French government for publication in their open source forge as they did not have any existing standard for this. </span><span class="koboSpan" id="kobo.307.4">This format was the functional contract between the two customers. </span><span class="koboSpan" id="kobo.307.5">They agreed that, whatever changes they might make to their software, the content of the association JSON would always be the following (this extract is highly simplified and translated into English for </span><span class="No-Break"><span class="koboSpan" id="kobo.308.1">improved readability):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.309.1">
{
    "name": "Old-time developers of Brittany",
    "registrationNumber": "FR-56-973854763",
    "organizationType": "uri:ORGANIZATIONS:ASSOCIATIONS",
    "creationDate": "2019-01-04T12:00:00Z",
    "representatives": [
        {
            "role": "accountant",
            "lastName": "Gouigoux",
            "firstName": "JP"
        }
    ],
    "legalAddress" : {
        "streetNumber": 282,
        "cityName": "Saint-Nazaire",
        "zipCode": "44600"
    }
}</span></pre> <p><span class="koboSpan" id="kobo.310.1">It happened</span><a id="_idIndexMarker421"/><span class="koboSpan" id="kobo.311.1"> that the regional council was already a customer before this project, so they already were using our moral person referential software based on this format. </span><span class="koboSpan" id="kobo.311.2">So, on this side, we only had to customize the event management system to call the second customer callback address whenever the events of creation, modification, or removal of an association happened. </span><span class="koboSpan" id="kobo.311.3">This was done with the </span><span class="No-Break"><span class="koboSpan" id="kobo.312.1">following grammar:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.313.1">
{
    "webhooks": [
        {
            "topic": "POST+*/api/organizations",
            "callback": "https://saint-nazaire.fr/referentiel_associations/modules/index.php?refOrga={registrationNumber},
            "method": "PUT",
            "filter": "organizationType=='uri:ORGANIZATIONS:ASSOCIATIONS' and zipCode=='44600'"
        }
        {
            "topic": "PUT+*/api/organizations/{registrationNumber}",
            "callback": "https://saint-nazaire.fr/referentiel_associations/modules/index.php?refOrga={registrationNumber},
            "method": "PUT",
            "filter": "organizationType=='uri:ORGANIZATIONS:ASSOCIATIONS' and zipCode=='44600'"
        }
        {
            "topic": "PATCH+*/api/organizations/{registrationNumber}",
            "callback": "https://saint-nazaire.fr/referentiel_associations/modules/index.php?refOrga={registrationNumber},
            "method": "PUT",
            "filter": "organizationType=='uri:ORGANIZATIONS:ASSOCIATIONS' and zipCode=='44600'"
        }
        {
            "topic": "DELETE+*/api/organizations/{registrationNumber}",
            "callback": "https://saint-nazaire.fr/referentiel_associations/modules/index.php?refOrga={registrationNumber}&amp;setActive=false,
            "method": "PUT",
            "filter": "organizationType=='uri:ORGANIZATIONS:ASSOCIATIONS' and zipCode=='44600'"
        }
    ]
}</span></pre> <p><span class="koboSpan" id="kobo.314.1">To give a bit of explanation, webhooks are registrations of an external system to events emitted by the given application. </span><span class="koboSpan" id="kobo.314.2">In our case, when the regional council actors’ referential service received data of a new organization or a change in existing data, through the referential service’s API methods, associated events were raised and the aforementioned customization file extract associated these with calls of the provided URL. </span><span class="koboSpan" id="kobo.314.3">This URL was exposed by the second customer (the city of Saint-Nazaire) using PHP (but the specific technology doesn’t matter). </span><span class="koboSpan" id="kobo.314.4">When, for example, we applied </span><strong class="source-inline"><span class="koboSpan" id="kobo.315.1">POST</span></strong><span class="koboSpan" id="kobo.316.1"> to a new organization, the callback URL was called with the identifier of the created entity along with the </span><strong class="source-inline"><span class="koboSpan" id="kobo.317.1">PUT</span></strong><span class="koboSpan" id="kobo.318.1"> verb. </span><span class="koboSpan" id="kobo.318.2">This is also where we introduced the fact that the city was only interested in associations (not all organizations), and in particular, the ones based in their territory, with the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.319.1">filter</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.320.1"> attribute.</span></span></p>
<p><span class="koboSpan" id="kobo.321.1">The URL</span><a id="_idIndexMarker422"/><span class="koboSpan" id="kobo.322.1"> implementation was then free to work as it pleased, without any dependence on the emitter. </span><span class="koboSpan" id="kobo.322.2">In some operations, the fact that there was an event on a given identifier was enough (for example, to deactivate the association in case of a </span><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">DELETE</span></strong><span class="koboSpan" id="kobo.324.1"> order in the regional council information system). </span><span class="koboSpan" id="kobo.324.2">In some other cases, for example when an association was created, the JSON content—the exact grammar of which was agreed upon between the two participants—would be retrieved through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.325.1">GET</span></strong><span class="koboSpan" id="kobo.326.1"> operation owing to the identifier obtained in the callback (where there was a use for all information of the association) or simply read in the body of the callback call (as the most important data were sent there, using the same contractual grammar, </span><span class="No-Break"><span class="koboSpan" id="kobo.327.1">of course).</span></span></p>
<p><span class="koboSpan" id="kobo.328.1">This example proved to be a successful experiment, as each of the customers was then free to evolve their systems in the way they wanted, changing technologies or other parameters without their partner even needing to know about it. </span><span class="koboSpan" id="kobo.328.2">At some point, the city would be interested in associations outside its own zip-code area and could simply register a new webhook content with the updated filter. </span><span class="koboSpan" id="kobo.328.3">This did not impact the emitter of the event, not even in its authorization scheme: if the city had requested to be called for associations outside its department (a French geographical unit between a region and a city), the event would have been sent, but reading the information with the help of the identifier received would simply end up in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.329.1">403 Forbidden</span></strong><span class="koboSpan" id="kobo.330.1"> HTTP status code. </span><span class="koboSpan" id="kobo.330.2">This particular mechanism was something that initially made us decide to never send any data in the callback request in order to simplify authorization mechanisms. </span><span class="koboSpan" id="kobo.330.3">But, at some point, it was decided that forcing the called entity to always reply with a </span><strong class="source-inline"><span class="koboSpan" id="kobo.331.1">GET</span></strong><span class="koboSpan" id="kobo.332.1"> call to obtain the name and basic information of a new association was a waste of bandwidth. </span><span class="koboSpan" id="kobo.332.2">Performance was not so much an issue, but simplicity was more important in this context than the risk of authorization mishaps, since this data is public in</span><a id="_idTextAnchor298"/><span class="koboSpan" id="kobo.333.1"> France and easy </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">to obtain.</span></span></p>
<h2 id="_idParaDest-175"><a id="_idTextAnchor299"/><span class="koboSpan" id="kobo.335.1">Interop made real with standards</span></h2>
<p><span class="koboSpan" id="kobo.336.1">The preceding example demonstrated a case where a particular data schema (we call this a </span><em class="italic"><span class="koboSpan" id="kobo.337.1">pivotal format</span></em><span class="koboSpan" id="kobo.338.1">, but </span><a id="_idIndexMarker423"/><span class="koboSpan" id="kobo.339.1">we will come back to this in more detail at the end of this chapter and in the next one) had to be devised to exchange data in a free and decoupled manner. </span><span class="koboSpan" id="kobo.339.2">But an even better case is where this contract already exists in the industry. </span><span class="koboSpan" id="kobo.339.3">This is another practical case I had the pleasure of dealing with, in particular, because the small company I worked for by then forced a much bigger one to comply with our way of working, simply because we used a recognized standard. </span><span class="koboSpan" id="kobo.339.4">Let me explain the </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">situation better…</span></span></p>
<p><span class="koboSpan" id="kobo.341.1">Our flagship </span><a id="_idIndexMarker424"/><span class="koboSpan" id="kobo.342.1">application, a kind of ERP, generates PDF documents and other binary files, and these should be stored. </span><span class="koboSpan" id="kobo.342.2">For quite some time, those would be stored alongside the database in a network share or, sometimes, in a dedicated server accessed through a UNC link. </span><span class="koboSpan" id="kobo.342.3">Electronic document management systems started to become mainstream after a few years and we needed to adapt our application so that it could use these systems to store documents. </span><span class="koboSpan" id="kobo.342.4">The natural choice for this was the Content Management Interoperability Services norm, as OASIS published a fully-featured 1.1 version supporting multiple metadata schemas, classification, versioning, and many more functions that we did not even need. </span><span class="koboSpan" id="kobo.342.5">It also happened that this was the only standard in use in this functional area, which makes for a very easy </span><span class="No-Break"><span class="koboSpan" id="kobo.343.1">architectural decision.</span></span></p>
<p><span class="koboSpan" id="kobo.344.1">So we ended up using a few operations from the standard (in the first step, we only needed to create documents, add metadata and binary content to them, and then retrieve documents through a query on their metadata content), which took us a few weeks to add to our application. </span><span class="koboSpan" id="kobo.344.2">Customers were quite satisfied because a simple customization of the software would make documents appear in their Alfresco or Nuxeo EDM systems, since these applications are natively CMIS 1.1 compatible. </span><span class="koboSpan" id="kobo.344.3">But what really demonstrated the importance of such a normative approach was the first time we had to deal with a customer equipped with a proprietary EDM: the editor, a quite large company, with an important footprint in the information system of our common customer, wanted us to make changes to our application in order to support their proprietary web services in order to send documents and metadata. </span><span class="koboSpan" id="kobo.344.4">After an initial refusal from us, the situation got a bit tense but we were lucky that the information system owner was a clever person who understood perfectly the value of low coupling. </span><span class="koboSpan" id="kobo.344.5">She intelligently asked what the effort would be for one partner if she had to select another </span><a id="_idIndexMarker425"/><span class="koboSpan" id="kobo.345.1">supplier for the services this one talked to. </span><span class="koboSpan" id="kobo.345.2">The EDM provider stated that they would not have to do anything if our company was replaced by another one. </span><span class="koboSpan" id="kobo.345.3">As far as our company was concerned, I explained that—in the reverse hypothesis—we would have to rewrite some parts of the code to adapt to another proprietary protocol. </span><span class="koboSpan" id="kobo.345.4">This was enough for the customer, even if she was not a technical expert, to realize that something was wrong with this way of operating and to demand that a standard-based, contractual communication channel was used. </span><span class="koboSpan" id="kobo.345.5">Disapproved by the customer, the EDM provider had no choice but to implement, at its own cost, support for the CMIS standard in </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">its product.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">This proved a very satisfying experience for </span><span class="No-Break"><span class="koboSpan" id="kobo.348.1">many reasons:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.349.1">First, I have to admit that replaying David against Goliath was one of the best ego boosts I had in </span><span class="No-Break"><span class="koboSpan" id="kobo.350.1">my career.</span></span></li>
<li><span class="koboSpan" id="kobo.351.1">Second, we went out of the meeting without having anything to add to our software, since it was </span><span class="No-Break"><span class="koboSpan" id="kobo.352.1">already CMIS-ready.</span></span></li>
<li><span class="koboSpan" id="kobo.353.1">Third, the customer appreciated our expertise in helping them reach a better, more evolutive, system and not trying to push them into a vendor lock-in situation as the other </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.354.1">partner</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.355.1"> did.</span></span></li>
<li><span class="koboSpan" id="kobo.356.1">Fourth, the interop project was technically very easy to lead because we would simply provide the partner with a Postman collection of the API calls we needed to work and they were able to validate them from the CMIS norm point of view. </span><span class="koboSpan" id="kobo.356.2">There were no “hidden parameters” in the interop calls, everything was explicit and strictly regulated through the OASIS standard. </span><span class="koboSpan" id="kobo.356.3">We only had one tweak to add in the case </span><span class="No-Break"><span class="koboSpan" id="kobo.357.1">of authentication.</span></span></li>
<li><span class="koboSpan" id="kobo.358.1">Finally, even the initially reluctant partner admitted at the end of the project that this approach helped to avoid the ping-pong effect in the project, where both partners reject responsibility for a non-working call to the other, ending up in a global loss of time and the customer not being satisfied. </span><span class="koboSpan" id="kobo.358.2">And I am truly convinced that the CMIS support would open new opportunities for their </span><a id="_idTextAnchor300"/><span class="koboSpan" id="kobo.359.1">product further down </span><span class="No-Break"><span class="koboSpan" id="kobo.360.1">the line.</span></span></li>
</ul>
<h2 id="_idParaDest-176"><a id="_idTextAnchor301"/><span class="koboSpan" id="kobo.361.1">Keeping complete compatibility</span></h2>
<p><span class="koboSpan" id="kobo.362.1">All this sounds</span><a id="_idIndexMarker426"/><span class="koboSpan" id="kobo.363.1"> like a beautiful dream, with pink unicorns and rainbows everywhere, but having great APIs using international standards and norms does not prevent one last danger in interop. </span><span class="koboSpan" id="kobo.363.2">Actually, it is quite the reverse, and the cleaner and more usable an API is, the bigger this danger is. </span><span class="koboSpan" id="kobo.363.3">Sounds weird, doesn’t it? </span><span class="koboSpan" id="kobo.363.4">Welcome to</span><a id="_idIndexMarker427"/><span class="koboSpan" id="kobo.364.1"> Hyrum’s Law (</span><a href="https://www.hyrumslaw.com/"><span class="koboSpan" id="kobo.365.1">https://www.hyrumslaw.com/</span></a><span class="koboSpan" id="kobo.366.1">), which states </span><span class="No-Break"><span class="koboSpan" id="kobo.367.1">the following:</span></span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.368.1">With a sufficient number of users of an API,</span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.369.1">it does not matter what you promise in the contract:</span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.370.1">all observable behaviors of your system</span></p>
<p class="author-quote"><span class="koboSpan" id="kobo.371.1">will be depended on by somebody.</span></p>
<p><span class="koboSpan" id="kobo.372.1">The more successful your API gets, the more important forward compatibility becomes as it is impossible to break the uses of many clients. </span><span class="koboSpan" id="kobo.372.2">But after all, this is just the flip side of success and not a bad price to pay if your API is the most used in your context, which ensures a large market share and notable income. </span><span class="koboSpan" id="kobo.372.3">Hyrum’s Law is harsher because even some parts of the API that you have no formal engagement with will become things that get you into trouble. </span><span class="koboSpan" id="kobo.372.4">A sudden change in performance, for example, might make it impossible for one of your biggest customers to continue working with your API. </span><span class="koboSpan" id="kobo.372.5">Even a smaller, non-contractual, modification may get you into this kind of trouble. </span><span class="koboSpan" id="kobo.372.6">You know what? </span><span class="koboSpan" id="kobo.372.7">Even removing a bug might make some of your API users unhappy because—in some twisted way—their system depended on this particular behavior to operate. </span><span class="koboSpan" id="kobo.372.8">That may sound silly but it occurs more widely than you may imagine. </span><span class="koboSpan" id="kobo.372.9">After all, it is very common that some API users consume response attributes by their order instead of </span><span class="No-Break"><span class="koboSpan" id="kobo.373.1">their identifier.</span></span></p>
<p><span class="koboSpan" id="kobo.374.1">To a certain extent, Hyrum’s Law can be considered as the API equivalent to the Liskhov substitution principle in object-oriented programming: even if a class can replace another one by implementing the same interface, if its behavior is not the same when the function calls have the same parameter values, then actual compatibility (and thus su</span><a id="_idTextAnchor302"/><span class="koboSpan" id="kobo.375.1">bstitutability) is </span><span class="No-Break"><span class="koboSpan" id="kobo.376.1">not achieved.</span></span></p>
<h2 id="_idParaDest-177"><a id="_idTextAnchor303"/><span class="koboSpan" id="kobo.377.1">Managing APIs</span></h2>
<p><span class="koboSpan" id="kobo.378.1">Even if this is more of an operational concern, managing a number of APIs, with all the authorization </span><a id="_idIndexMarker428"/><span class="koboSpan" id="kobo.379.1">access issues, logging, and possibly invoicing for API consumption, follow-up of versions, and so on can make for a tough challenge. </span><span class="koboSpan" id="kobo.379.2">Some dedicated software products exist for this under the common name of </span><em class="italic"><span class="koboSpan" id="kobo.380.1">API gateways</span></em><span class="koboSpan" id="kobo.381.1">. </span><span class="koboSpan" id="kobo.381.2">They generally are implemented in the form of reverse proxies that act as a frontal server, hiding the actual </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">API expositions.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">Depending on whether you need a very low-coupled system or a very integrated one, you could respectively use systems such as WSO² or Ocelot (in the case of an ASP.NET im</span><a id="_idTextAnchor304"/><span class="koboSpan" id="kobo.384.1">plementation of your </span><span class="No-Break"><span class="koboSpan" id="kobo.385.1">API system).</span></span></p>
<h2 id="_idParaDest-178"><a id="_idTextAnchor305"/><span class="koboSpan" id="kobo.386.1">Inversion of dependency for services</span></h2>
<p><span class="koboSpan" id="kobo.387.1">If you remember the following schema from the previous chapter, you will recall that a port and adapter pattern is used in order for the satellite modules to depend on the main one that implements the business domain model, even if the calls come from the latter and go to </span><span class="No-Break"><span class="koboSpan" id="kobo.388.1">the former:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer074">
<span class="koboSpan" id="kobo.389.1"><img alt="Figure 8.10 – Hexagonal architecture" src="image/B21293_08_10.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.390.1">Figure 8.10 – Hexagonal architecture</span></p>
<p><span class="koboSpan" id="kobo.391.1">This is simply the </span><a id="_idIndexMarker429"/><span class="koboSpan" id="kobo.392.1">principle of dependency inversion applied to architecture, with the description of a conventional interface being called by one module, without knowing what implementation</span><a id="_idIndexMarker430"/><span class="koboSpan" id="kobo.393.1"> is used behind this interface. </span><span class="koboSpan" id="kobo.393.2">In </span><strong class="bold"><span class="koboSpan" id="kobo.394.1">Object-Oriented Programming (OOP)</span></strong><span class="koboSpan" id="kobo.395.1"> code, this is generally done by </span><span class="No-Break"><span class="koboSpan" id="kobo.396.1">object injection.</span></span></p>
<p><span class="koboSpan" id="kobo.397.1">In service-oriented systems, and in particular, when using web APIs, the indirection level is done by the URL that the caller uses without knowing what is behind it. </span><span class="koboSpan" id="kobo.397.2">If having a dependency on this module is not a problem, then the call can be direct. </span><span class="koboSpan" id="kobo.397.3">But if the business domain module calls an API, a direct dependency is not a good idea for evolution and a way has got to be found in order to reverse </span><span class="No-Break"><span class="koboSpan" id="kobo.398.1">the dependency.</span></span></p>
<p><span class="koboSpan" id="kobo.399.1">This is generally done by using some kind of callback mechanism, where the domain model module is instructed from the outside (the dependency, in our case) with the URL it should call, possibly in its customization but also in the runtime initialization steps. </span><span class="koboSpan" id="kobo.399.2">In the first explanation of the preceding webhooks, this is what happened when the town needed a change of filter on the events the regional council should take into account for informing the town: it would not be normal for the regional council to depend on the town, since the town is the functional requester of the information. </span><span class="koboSpan" id="kobo.399.3">This is why the best way for the town to provide the callback URL to the regional council is by registering for the events, possibly through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.400.1">/</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">subscribe</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.402.1"> API.</span></span></p>
<p><span class="koboSpan" id="kobo.403.1">This way, we</span><a id="_idIndexMarker431"/><span class="koboSpan" id="kobo.404.1"> reach a nice separation of responsibilities, as the regional council is responsible for </span><span class="No-Break"><span class="koboSpan" id="kobo.405.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.406.1">Exposing an API that allows clients to create, modify, and remove organizations from the data referential service’s </span><span class="No-Break"><span class="koboSpan" id="kobo.407.1">persistence mechanism</span></span></li>
<li><span class="koboSpan" id="kobo.408.1">Exposing an API that allows clients (possibly other ones, possible the same ones) to register for events </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">on organizations</span></span></li>
<li><span class="koboSpan" id="kobo.410.1">Calling the URL provided by these clients upon registration whenever the event appears in </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">the code</span></span></li>
<li><span class="koboSpan" id="kobo.412.1">Applying the filter provided upon registration to only emit </span><span class="No-Break"><span class="koboSpan" id="kobo.413.1">requested events</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.414.1">On the other end, the town is responsible for </span><span class="No-Break"><span class="koboSpan" id="kobo.415.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.416.1">Registering on the organization referential for the events it needs </span><span class="No-Break"><span class="koboSpan" id="kobo.417.1">to observe</span></span></li>
<li><span class="koboSpan" id="kobo.418.1">Providing a URL for callbacks that is reachable, and points to the </span><span class="No-Break"><span class="koboSpan" id="kobo.419.1">necessary implementation</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.420.1">When this kind of event-based mechanism is used for every interaction to provide a very low degree of coupling, the jargon term</span><a id="_idIndexMarker432"/><span class="koboSpan" id="kobo.421.1"> is </span><strong class="bold"><span class="koboSpan" id="kobo.422.1">Event-Driven Architecture</span></strong><span class="koboSpan" id="kobo.423.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.424.1">EDA</span></strong><span class="koboSpan" id="kobo.425.1">). </span><span class="koboSpan" id="kobo.425.2">In its most advanced form, EDA adds lots of very precisely defined responsibilities to allow for </span><span class="No-Break"><span class="koboSpan" id="kobo.426.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.427.1">Different authentication and authorization methods for the registration and </span><span class="No-Break"><span class="koboSpan" id="kobo.428.1">emission mechanisms</span></span></li>
<li><span class="koboSpan" id="kobo.429.1">Management of robustness of delivery by reapplying the calls if necessary and, if needed, warning an administrator that, after a certain amount of tries, the event has been stored for later emission to certain </span><span class="No-Break"><span class="koboSpan" id="kobo.430.1">registered clients</span></span></li>
<li><span class="koboSpan" id="kobo.431.1">Handling high volumes </span><span class="No-Break"><span class="koboSpan" id="kobo.432.1">of events</span></span></li>
<li><span class="koboSpan" id="kobo.433.1">Handling large numbers of </span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">registered clients</span></span></li>
<li><span class="koboSpan" id="kobo.435.1">Service-level agreement management, among many </span><span class="No-Break"><span class="koboSpan" id="kobo.436.1">other features</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.437.1">In its correct </span><a id="_idIndexMarker433"/><span class="koboSpan" id="kobo.438.1">implementation, an EDA-based system is the most accomplished outcome of decoupling in software systems, allowing for a completely transparent evolution of the different modules and linear performance. </span><span class="koboSpan" id="kobo.438.2">But despite its long theoretical existence, there are very few actual implementations </span><span class="No-Break"><span class="koboSpan" id="kobo.439.1">of this.</span></span></p>
<p><span class="koboSpan" id="kobo.440.1">Now that the notion of </span><em class="italic"><span class="koboSpan" id="kobo.441.1">service</span></em><span class="koboSpan" id="kobo.442.1"> has been presented and studied from various points of view, we are going to return to our sample information syste</span><a id="_idTextAnchor306"/><span class="koboSpan" id="kobo.443.1">m and apply this new knowledge </span><span class="No-Break"><span class="koboSpan" id="kobo.444.1">to it.</span></span></p>
<h1 id="_idParaDest-179"><a id="_idTextAnchor307"/><span class="koboSpan" id="kobo.445.1">Application to our demonstration system</span></h1>
<p><span class="koboSpan" id="kobo.446.1">Now that</span><a id="_idIndexMarker434"/><span class="koboSpan" id="kobo.447.1"> the notion of </span><em class="italic"><span class="koboSpan" id="kobo.448.1">service</span></em><span class="koboSpan" id="kobo.449.1"> should hold any secrets for you, it is time to see some practical applications of what we have covered on our demonstration system to reinforce the takeaways from this chapter. </span><span class="koboSpan" id="kobo.449.2">Since we aim at something modern, the choice is quite obvious that the different modules of the example system will interact with each other through REST APIs. </span><span class="koboSpan" id="kobo.449.3">As much as possible, we will try to keep the middleware as transparent as we can. </span><span class="koboSpan" id="kobo.449.4">We may need some connectors for mediation in some cases, but other than that, applications will talk to centralized APIs that will then be implemented separately (this will be done using the concept of service in the container or</span><a id="_idTextAnchor308"/><span class="koboSpan" id="kobo.450.1">chestrator that will be put </span><span class="No-Break"><span class="koboSpan" id="kobo.451.1">in place).</span></span></p>
<h2 id="_idParaDest-180"><a id="_idTextAnchor309"/><span class="koboSpan" id="kobo.452.1">Interfaces needing analysis</span></h2>
<p><span class="koboSpan" id="kobo.453.1">First, we will start with a hexagonal architecture diagram to list all the business domain models and their dependencies. </span><span class="koboSpan" id="kobo.453.2">The C4 approach used in the previous chapter showed that we will need at least three business domains, namely books, authors, </span><span class="No-Break"><span class="koboSpan" id="kobo.454.1">and sales.</span></span></p>
<p><span class="koboSpan" id="kobo.455.1">If we concentrate on books, for example, the dependencies are the persistence mechanism, the authors cache module, the books’ GUI system, the books’ API controller, and some technical satellites such as logging, and identity and authorization management. </span><span class="koboSpan" id="kobo.455.2">This can be schematized </span><span class="No-Break"><span class="koboSpan" id="kobo.456.1">as follows:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer075">
<span class="koboSpan" id="kobo.457.1"><img alt="Figure 8.11 – An example of hexagonal architecture" src="image/B21293_08_11.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.458.1">Figure 8.11 – An example of hexagonal architecture</span></p>
<p><span class="koboSpan" id="kobo.459.1">In terms of the </span><a id="_idIndexMarker435"/><span class="koboSpan" id="kobo.460.1">Agile approach, I am not saying that this contains all the interfaces that will be present at the end of our journey together. </span><span class="koboSpan" id="kobo.460.2">But in order to keep this exercise as realistic as possible, I am creating the sample information system at the same time as I write the book, in order not to leave anything hidden and so that you can follow the precise method of design that I recommend, and that I of course try to </span><span class="No-Break"><span class="koboSpan" id="kobo.461.1">follow myself.</span></span></p>
<p><span class="koboSpan" id="kobo.462.1">So, now that the first interfaces have been listed, we need to be a bit more precise than just a name. </span><span class="koboSpan" id="kobo.462.2">What are they going to do? </span><span class="koboSpan" id="kobo.462.3">How will they be designed to provide for clean, future-proof usage? </span><span class="koboSpan" id="kobo.462.4">Most importantly, how are these choices going to reflect the business/IT alignment principles that I have pu</span><a id="_idTextAnchor310"/><span class="koboSpan" id="kobo.463.1">shed forward since the </span><span class="No-Break"><span class="koboSpan" id="kobo.464.1">first chapters?</span></span></p>
<h2 id="_idParaDest-181"><a id="_idTextAnchor311"/><span class="koboSpan" id="kobo.465.1">Using norms and standards</span></h2>
<p><span class="koboSpan" id="kobo.466.1">Since I have spoken so much about the crucial importance of norms and standards, it would have been a terrible signal not to start with them for the precise definition of the interfaces. </span><span class="koboSpan" id="kobo.466.2">And describing more precisely the interfaces we talked about in the previous section is as easy as can be when we use a standard because we simply need to name it (and possibly cite the version of it that will be used) and all the operations, formats, semantics, and other functions of the standard are immediately clearly defined through the documentation of </span><span class="No-Break"><span class="koboSpan" id="kobo.467.1">the standard.</span></span></p>
<p><span class="koboSpan" id="kobo.468.1">For example, let’s</span><a id="_idIndexMarker436"/><span class="koboSpan" id="kobo.469.1"> start with the authentication and identification service. </span><span class="koboSpan" id="kobo.469.2">For this particular interface, we will use the OpenID Connect protocol, based on OAuth 2.0 (RFC 6749) and using JSON Web Tokens (RFC 7519), the JWT profile for OAuth 2.0 itself being standardized (RFC 7523). </span><span class="koboSpan" id="kobo.469.3">Again, the great thing about norms and standards is that they greatly simplify our work. </span><span class="koboSpan" id="kobo.469.4">If I had to describe with the same degree of precision the use of an interface without a standard, this chapter would be extra long. </span><span class="koboSpan" id="kobo.469.5">For this service, citing a few RFCs (and of course, in the next chapters, using good implementations of these norms) is enough to make </span><span class="No-Break"><span class="koboSpan" id="kobo.470.1">everything explicit.</span></span></p>
<p><span class="koboSpan" id="kobo.471.1">How about the database interface or, to be more precise, the persistence interface? </span><span class="koboSpan" id="kobo.471.2">The decision is to use a NoSQL document-based approach since it sounds the most adapted to the business entities we talked about and the volumetry we want to address. </span><span class="koboSpan" id="kobo.471.3">It may not be a very well-known fact about MongoDB, but most protocols used are open standards, and are, in fact, used by many other NoSQL database implementations. </span><span class="koboSpan" id="kobo.471.4">If you want to improve on your local MongoDB database, all you need to do to switch to an Atlas service or an Azure CosmosDB instance is to change the connection string, as everything works the same. </span><span class="koboSpan" id="kobo.471.5">The MongoDB Wire Protocol Specification is licensed under a Creative Commons </span><em class="italic"><span class="koboSpan" id="kobo.472.1">Attribution-NonCommercial-ShareAlike 3.0</span></em><span class="koboSpan" id="kobo.473.1"> license. </span><span class="koboSpan" id="kobo.473.2">The BSON format (</span><a href="https://bsonspec.org/#/specification"><span class="koboSpan" id="kobo.474.1">https://bsonspec.org/#/specification</span></a><span class="koboSpan" id="kobo.475.1">) used is documented openly and can be implemented by any software. </span><span class="koboSpan" id="kobo.475.2">And the list goes on. </span><span class="koboSpan" id="kobo.475.3">In addition to the appropriate adaptation of the software to our needs and the fact it is easy to create a free database, the standardized aspect is the cherry on top that makes MongoDB a sound choice for our </span><span class="No-Break"><span class="koboSpan" id="kobo.476.1">sample application.</span></span></p>
<p><span class="koboSpan" id="kobo.477.1">OK, now on to authorizations! </span><span class="koboSpan" id="kobo.477.2">There</span><a id="_idIndexMarker437"/><span class="koboSpan" id="kobo.478.1"> happens to</span><a id="_idIndexMarker438"/><span class="koboSpan" id="kobo.479.1"> exist two main norms around software authorization management, namely </span><strong class="bold"><span class="koboSpan" id="kobo.480.1">eXtensible Access Control Markup Language</span></strong><span class="koboSpan" id="kobo.481.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.482.1">XACML</span></strong><span class="koboSpan" id="kobo.483.1">) and </span><strong class="bold"><span class="koboSpan" id="kobo.484.1">Open Policy Agent</span></strong><span class="koboSpan" id="kobo.485.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.486.1">OPA</span></strong><span class="koboSpan" id="kobo.487.1">). </span><span class="koboSpan" id="kobo.487.2">In our sample application, we will use the second one, as it is more modern, less complex, and easier to implement together with our REST API approach. </span><span class="koboSpan" id="kobo.487.3">Actually, it may be argued that OPA is to XACML as REST APIs are to SOAP. </span><span class="koboSpan" id="kobo.487.4">One important thing: the presence of a norm does not mean you have to implement it fully: you simply use the parts of it that you need. </span><span class="koboSpan" id="kobo.487.5">This particular case of authorization management is the right context to explain this: if your access rights are quite easy (the </span><strong class="source-inline"><span class="koboSpan" id="kobo.488.1">admin</span></strong><span class="koboSpan" id="kobo.489.1"> role has all rights, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.490.1">operator</span></strong><span class="koboSpan" id="kobo.491.1"> can read and write entities based on a portfolio, and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.492.1">reader</span></strong><span class="koboSpan" id="kobo.493.1"> role can only read data, for example), then using OPA would not be the right choice, as it would add lots of overhead. </span><span class="koboSpan" id="kobo.493.2">Of course, the real question, again, is to take time into account. </span><span class="koboSpan" id="kobo.493.3">Of course, by the end of the book, our sample application will be so simple that using OPA would be over-dimensioning. </span><span class="koboSpan" id="kobo.493.4">However the goal of this exercise is to show how to work if we aim at a real, industrial, freely evolving information system. </span><span class="koboSpan" id="kobo.493.5">And since we operate under the hypothesis that rights management is going to be more complicated, then we will start right away with the adapted interface, which means OPA 1.0 in </span><span class="No-Break"><span class="koboSpan" id="kobo.494.1">our case.</span></span></p>
<p><span class="koboSpan" id="kobo.495.1">The </span><a id="_idIndexMarker439"/><span class="koboSpan" id="kobo.496.1">logging feature is a bit of a different situation because this is not something directly functional, but rather a technical feature. </span><span class="koboSpan" id="kobo.496.2">However this does not mean that the same approach of standardization should not be used. </span><span class="koboSpan" id="kobo.496.3">The only difference is that this level of indirection will not be standardized at the international level as with other norms, but rather locally to the platform. </span><span class="koboSpan" id="kobo.496.4">Our sample application being implemented mostly uses .NET Core, so we will use whatever is standard for this technology, and there happens to be a standard global interface in </span><strong class="source-inline"><span class="koboSpan" id="kobo.497.1">Microsoft.Extensions.Logging</span></strong><span class="koboSpan" id="kobo.498.1"> called </span><strong class="source-inline"><span class="koboSpan" id="kobo.499.1">ILogger</span></strong><span class="koboSpan" id="kobo.500.1">, which exists also as a generic class </span><strong class="source-inline"><span class="koboSpan" id="kobo.501.1">ILogger&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.502.1">. </span><span class="koboSpan" id="kobo.502.2">We will return in the technical chapters to see how to use it and maybe we will even spice it up by using a semantic logging system such as Serilog. </span><span class="koboSpan" id="kobo.502.3">But for now, suffice it to say that the logging mechanism will be standardized </span><span class="No-Break"><span class="koboSpan" id="kobo.503.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.504.1">It is worth noting that some players in the field currently work towards a first level of standardization, such as Elastic with the ECS specification (see </span><a href="https://www.elastic.co/guide/en/ecs/current/ecs-reference.html"><span class="koboSpan" id="kobo.505.1">https://www.elastic.co/guide/en/ecs/current/ecs-reference.html</span></a><span class="koboSpan" id="kobo.506.1"> for details). </span><span class="koboSpan" id="kobo.506.2">As Elastic is one of the major publishers of observation platforms and the specification is open source, we can place some hope in the spreading of this as</span><a id="_idTextAnchor312"/><span class="koboSpan" id="kobo.507.1"> a standard, although only time </span><span class="No-Break"><span class="koboSpan" id="kobo.508.1">will tell.</span></span></p>
<h2 id="_idParaDest-182"><a id="_idTextAnchor313"/><span class="koboSpan" id="kobo.509.1">Where do I find norms and standards?</span></h2>
<p><span class="koboSpan" id="kobo.510.1">When I teach or consult about business/IT alignment and in particular about this need to refer to norms and standards, the same question always comes up at some point: </span><em class="italic"><span class="koboSpan" id="kobo.511.1">How do we search for norms?</span></em><span class="koboSpan" id="kobo.512.1"> I should say that I am really astonished by this question, and for </span><span class="No-Break"><span class="koboSpan" id="kobo.513.1">several reasons:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.514.1">Finding them is as easy as any internet search and virtually all of them are public, with the need to be as visible as possible in order to achieve their goals, so there is absolutely no technical difficulty in finding them. </span><span class="koboSpan" id="kobo.514.2">It shows that most people working in the IT industry (and with the number of people I have trained or taught, I do have significant statistics) are ignorant of the standards of their industry, which is quite annoying. </span><span class="koboSpan" id="kobo.514.3">I can understand that not a lot of people know BPMN 2.0, for example, as processes are a specific use case, and not all applications need a workflow engine. </span><span class="koboSpan" id="kobo.514.4">But how can some architects not know about OAuth 2.0, since this is used almost everywhere on the internet and almost all software applications need some kind of authentication at </span><span class="No-Break"><span class="koboSpan" id="kobo.515.1">some point?</span></span></li>
<li><span class="koboSpan" id="kobo.516.1">Even some people outside of the profession know some of the most identified providers of norms and standards, such as ISO or IETF. </span><span class="koboSpan" id="kobo.516.2">Even just the term </span><strong class="bold"><span class="koboSpan" id="kobo.517.1">Request For Comments (RFC)</span></strong><span class="koboSpan" id="kobo.518.1"> is</span><a id="_idIndexMarker440"/><span class="koboSpan" id="kobo.519.1"> understood by many people. </span><span class="koboSpan" id="kobo.519.2">Granted, some IT-specific organizations producing norms, such as OASIS, are lesser known. </span><span class="koboSpan" id="kobo.519.3">But then again, the </span><strong class="bold"><span class="koboSpan" id="kobo.520.1">World Wide Web Consortium</span></strong><span class="koboSpan" id="kobo.521.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.522.1">W3C</span></strong><span class="koboSpan" id="kobo.523.1">) is a </span><a id="_idIndexMarker441"/><span class="koboSpan" id="kobo.524.1">very active and recognized institution. </span><span class="koboSpan" id="kobo.524.2">So how come people asking this question do not have the reflex to start with these organizations and search them for what </span><span class="No-Break"><span class="koboSpan" id="kobo.525.1">they need?</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.526.1">For some </span><a id="_idIndexMarker442"/><span class="koboSpan" id="kobo.527.1">customers, I even created a whitepaper at some point with almost a hundred norms and standards used in the business context I was working in at the time (public and government organizations) because this question came back all the time and I wanted to have a quick answer, not only telling them where to find what they needed, but providing them with the answers already found for them. </span><span class="koboSpan" id="kobo.527.2">This is for a simple reason: because I found out that the real issue was not that these people did not know “where to find the norm,” but because it indicated doubts in their ability to use them. </span><span class="koboSpan" id="kobo.527.3">Norms and standards can be a bit intimidating with their hundreds of pages explaining all the possible cases. </span><span class="koboSpan" id="kobo.527.4">Even simple RFCs are indeed not easy </span><span class="No-Break"><span class="koboSpan" id="kobo.528.1">to read.</span></span></p>
<p><span class="koboSpan" id="kobo.529.1">But there are other answers to this </span><span class="No-Break"><span class="koboSpan" id="kobo.530.1">as well:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.531.1">First, finding the right norm and starting to use it does not require you to read the norm specification. </span><span class="koboSpan" id="kobo.531.2">In fact, only if you need to implement large parts of it will you gain a benefit from </span><span class="No-Break"><span class="koboSpan" id="kobo.532.1">reading it.</span></span></li>
<li><span class="koboSpan" id="kobo.533.1">In most cases, you will use components that implement the norm and all you have to do is check that they are recognized, </span><span class="No-Break"><span class="koboSpan" id="kobo.534.1">well-established modules.</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.535.1">For example, in </span><a id="_idIndexMarker443"/><span class="koboSpan" id="kobo.536.1">order to use OpenID Connect in our sample information system, we will basically need to know nothing about the protocol itself since we will rely on Apache Keycloak, which implements it in a transparent way for us. </span><span class="koboSpan" id="kobo.536.2">All we have to deal with is the choice of identity provider and some customizations made easy by the </span><span class="No-Break"><span class="koboSpan" id="kobo.537.1">Keycloak GUI.</span></span></p>
<p><span class="koboSpan" id="kobo.538.1">Even if you have to dive into the details of the norms, most of the time, you will only need to understand a very small portion of them. </span><span class="koboSpan" id="kobo.538.2">For example, in our sample application, we will certainly need at some point to implement some kind of support for binary documents for authors’ contracts; which means we will of course use CMIS 1.1 since this is the recognized standard for this use case. </span><span class="koboSpan" id="kobo.538.3">But as we will only send documents, add binaries and metadata, and query documents in return, we may only use 10% of the </span><span class="No-Break"><span class="koboSpan" id="kobo.539.1">whole norm.</span></span></p>
<p><span class="koboSpan" id="kobo.540.1">Finally, a good norm is normally quite spread out and used internationally already. </span><span class="koboSpan" id="kobo.540.2">So, reading the full-blown specification is always an interesting read but let’s be honest: the way you will be exposed to the standards in the first steps is simply by mimicking some sample calls that you will find on reference websites and adapt to your needs. </span><span class="koboSpan" id="kobo.540.3">Only if you reach a certain level of complexity will it be easier at some point to find the exact nitty-gritty detail </span><a id="_idTextAnchor314"/><span class="koboSpan" id="kobo.541.1">of implementation in the full text of </span><span class="No-Break"><span class="koboSpan" id="kobo.542.1">the RFC.</span></span></p>
<h2 id="_idParaDest-183"><a id="_idTextAnchor315"/><span class="koboSpan" id="kobo.543.1">Pivotal format for the other interfaces</span></h2>
<p><span class="koboSpan" id="kobo.544.1">And for the last part of this subject, the next question that arises is, logically: </span><em class="italic"><span class="koboSpan" id="kobo.545.1">What do we do when there is no norm or standard for </span></em><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.546.1">our context?</span></em></span></p>
<p><span class="koboSpan" id="kobo.547.1">My first reflexive reply to this question is always, “</span><em class="italic"><span class="koboSpan" id="kobo.548.1">Are you willing to bet that there is indeed no norm I can show you on this?”</span></em><span class="koboSpan" id="kobo.549.1"> Most of the time, this question goes back to the previous one and just shows that the person asking it is simply not comfortable with norms, or is afraid as they think it is going to be difficult (where in reality, on the contrary, norms free you from all the difficult design aspects). </span><span class="koboSpan" id="kobo.549.2">Because, let’s face it, we have norms for virtually everything today. </span><span class="koboSpan" id="kobo.549.3">All right, there may be fewer norms in IT than in the mechanical domain. </span><span class="koboSpan" id="kobo.549.4">But there are standards for every common feature. </span><span class="koboSpan" id="kobo.549.5">You have norms for all generic techniques, norms for every entity used in international data transfers, and for every common human activity including banking, insurance, travel, and so on. </span><span class="koboSpan" id="kobo.549.6">You even have an ISO-Gender norm (ISO/CEI 5218) for representing human genders in </span><span class="No-Break"><span class="koboSpan" id="kobo.550.1">numeric format.</span></span></p>
<p><span class="koboSpan" id="kobo.551.1">The second part of the answer concerns what we should do when there is indeed no applicable norm for your context. </span><span class="koboSpan" id="kobo.551.2">And the answer to this has already been given a bit earlier in this chapter: you then create what is </span><a id="_idIndexMarker444"/><span class="koboSpan" id="kobo.552.1">called a </span><strong class="bold"><span class="koboSpan" id="kobo.553.1">pivotal format</span></strong><span class="koboSpan" id="kobo.554.1">, which has the same goal of standardization as a real norm, but limited to your own context. </span><span class="koboSpan" id="kobo.554.2">Of course, it is always better to aim at something universal. </span><span class="koboSpan" id="kobo.554.3">Not only because, you never know, but your format may become a norm if you put enough effort into it and other people have an interest in it (this is the way norms appear: it always starts with the effort of an individual </span><a id="_idIndexMarker445"/><span class="koboSpan" id="kobo.555.1">who knows the business domain extremely well and makes the effort to transcribe their knowledge into something technical, which is then agreed upon by other participants as a sound basis for exchanges). </span><span class="koboSpan" id="kobo.555.2">But also because aiming at something universal will make your pivotal format as close to a norm as possible, with as many resulting advantages </span><span class="No-Break"><span class="koboSpan" id="kobo.556.1">as possible.</span></span></p>
<p><span class="koboSpan" id="kobo.557.1">And the rule for this is to fall back on existing norms as quickly as possible. </span><span class="koboSpan" id="kobo.557.2">Sure, there does not seem to exist an international norm for the concept of authoring (though the Dublin Core </span><strong class="source-inline"><span class="koboSpan" id="kobo.558.1">creator</span></strong><span class="koboSpan" id="kobo.559.1"> attribute allows us to draw a link between a resource and the person or organization that authored this resource), but since it points to individual persons, lots of other related norms will quickly apply, such as Social Security Numbers for unique identification, ISO 8601 for the date of authoring, and so on. </span><span class="koboSpan" id="kobo.559.2">The same applies to books: of course, we may not find the perfect standard to precisely address what we need for our sample application, and in particular its persistence system, but there are nonetheless norms for languages (ISO 639), internationally-recognized standard codes for registered book </span><a id="_idIndexMarker446"/><span class="koboSpan" id="kobo.560.1">identification such as </span><strong class="bold"><span class="koboSpan" id="kobo.561.1">International Standard Book Numbers (ISBNs)</span></strong><span class="koboSpan" id="kobo.562.1">, and standards for virtually everything we will set out to record in the descriptions of the books in </span><span class="No-Break"><span class="koboSpan" id="kobo.563.1">our system.</span></span></p>
<p><span class="koboSpan" id="kobo.564.1">Now, the real question is what to put in the book and author’s pivotal format? </span><span class="koboSpan" id="kobo.564.2">And this is such a huge question that it will necessitate a chapter on its own. </span><span class="koboSpan" id="kobo.564.3">The good news is that the f</span><a id="_idTextAnchor316"/><span class="koboSpan" id="kobo.565.1">ollowing chapter will explain how to </span><span class="No-Break"><span class="koboSpan" id="kobo.566.1">answer this.</span></span></p>
<h1 id="_idParaDest-184"><a id="_idTextAnchor317"/><span class="koboSpan" id="kobo.567.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.568.1">In this chapter, I have used a short historical approach (a detailed one would be a book in itself) to explain what the stakes at play are in service orientation and how this seemingly simple yet hard-to-define word of </span><em class="italic"><span class="koboSpan" id="kobo.569.1">service</span></em><span class="koboSpan" id="kobo.570.1"> has been implemented in the past decades. </span><span class="koboSpan" id="kobo.570.2">We are definitely not at the end of the story yet, but nowadays, it seems the best approach is to use REST APIs with a middleware, reduced as much as possible through the use of norms and standards. </span><span class="koboSpan" id="kobo.570.3">This not only avoids the costly mediation connectors that translate one format to another, since everybody in the interaction talks the same language but also helps us know whether our design is the right one since consortiums and experts have thought a lot about this </span><span class="No-Break"><span class="koboSpan" id="kobo.571.1">business domain.</span></span></p>
<p><span class="koboSpan" id="kobo.572.1">Standardized APIs are what make it easy today to change some parts of important information systems without breaking them. </span><span class="koboSpan" id="kobo.572.2">They allow for international banking, much more efficient insurance systems, simplified travel abroad, and many other feats of the industrialized </span><span class="No-Break"><span class="koboSpan" id="kobo.573.1">IT world.</span></span></p>
<p><span class="koboSpan" id="kobo.574.1">We talked about norms, but also compatibility, the evolution of services, how services will be integrated through interfaces, and much more. </span><span class="koboSpan" id="kobo.574.2">By the end of this chapter, we came back to our sample application and showed which norms would be used to implement a few of the services it will expose. </span><span class="koboSpan" id="kobo.574.3">Now a difficult question remains: when there is no standard format for a business need and we need to create a pivotal format (of course, using norms as much as possible for its inner attributes), how do we determine the content of this format? </span><span class="koboSpan" id="kobo.574.4">The best answer I have is to use </span><strong class="bold"><span class="koboSpan" id="kobo.575.1">Domain-Driven Design </span></strong><span class="koboSpan" id="kobo.576.1">(</span><strong class="bold"><span class="koboSpan" id="kobo.577.1">DDD</span></strong><span class="koboSpan" id="kobo.578.1">). </span><span class="koboSpan" id="kobo.578.2">And this is the subject of the </span><span class="No-Break"><span class="koboSpan" id="kobo.579.1">next chapter.</span></span></p>
</div>
</body></html>