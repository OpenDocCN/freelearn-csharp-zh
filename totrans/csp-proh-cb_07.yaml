- en: Chapter 7. High Performance Programming Using Parallel and Multithreading in
    C#
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章.使用C#中的并行和多线程进行高性能编程
- en: 'This chapter takes a look at improving your code''s performance using multithreading
    and parallel programming. In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将探讨如何使用多线程和并行编程来提高代码的性能。在本章中，我们将介绍以下菜谱：
- en: Creating and aborting a low-priority background thread
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和终止一个低优先级的后台线程
- en: Increasing maximum thread pool size
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加最大线程池大小
- en: Creating multiple threads
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建多个线程
- en: Locking one thread until the contended resources are available
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 锁定一个线程直到有争议的资源可用
- en: Invoking parallel calls to methods using `Parallel.Invoke`
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `Parallel.Invoke` 调用方法进行并行调用
- en: Using a parallel `foreach` loop to run multiple threads
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用并行 `foreach` 循环来运行多个线程
- en: Cancelling a parallel `foreach` loop
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消并行 `foreach` 循环
- en: Catching errors in parallel `foreach` loops
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并行 `foreach` 循环中捕获错误
- en: Debugging multiple threads
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试多个线程
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: If you can find a single-core CPU in a computer today, it will probably mean
    that you are standing in a museum. Every new computer today utilizes the advantages
    of multiple cores. Programmers can take advantage of this extra processing power
    in their own applications. As applications have grown in size and complexity,
    in many cases they actually need to utilize multithreading.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你今天能在电脑上找到一个单核CPU，那可能意味着你站在一个博物馆里。今天每台新电脑都利用了多核的优势。程序员可以在自己的应用程序中利用这种额外的处理能力。随着应用程序的大小和复杂性的增长，在许多情况下，它们实际上需要利用多线程。
- en: While not every situation is always suited for the implementation of multithreaded
    code logic, it is good to know how to use multithreading to improve the performance
    of your applications. This chapter will take you through the fundamentals of this
    exciting technology in C# programming.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然并非所有情况都适合实现多线程代码逻辑，但了解如何使用多线程来提高应用程序的性能是很好的。本章将带你了解C#编程中这项激动人心的技术的核心。
- en: Creating and aborting a low-priority background thread
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建和终止一个低优先级的后台线程
- en: The reason we want to have a look at a background thread specifically is because
    by default, all threads created by the main app thread or `Thread` class constructor
    are foreground threads. So, what exactly separates a foreground thread from a
    background thread? Well, background threads are identical to foreground threads
    with the exception that if all foreground threads are terminated, the background
    threads are stopped too. This is useful if you have a process in your application
    that must not stop the application from terminating. In other words, while your
    application is running, the background thread must continue to run.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之所以特别关注后台线程，是因为默认情况下，由主应用程序线程或 `Thread` 类构造函数创建的所有线程都是前台线程。那么，前台线程和后台线程究竟有什么区别呢？好吧，后台线程与前台线程相同，唯一的区别是，如果所有前台线程都终止了，后台线程也会停止。这在你的应用程序中有一个必须防止应用程序终止的过程时很有用。换句话说，当你的应用程序运行时，后台线程必须继续运行。
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a simple application that defines the thread created as a background
    thread. It will then suspend, resume, and abort the thread.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个简单的应用程序，该应用程序定义的线程被创建为后台线程。然后它将挂起、恢复和终止线程。
- en: How to do it…
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Create a new class library by right-clicking on your solution and selecting
    **Add** and then **New Project** from the context menu:![How to do it…](img/B05391_07_01.jpg)
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在解决方案上右键单击并从上下文菜单中选择**添加**然后**新建项目**来创建一个新的类库：![如何操作…](img/B05391_07_01.jpg)
- en: From the **Add New Project** dialog screen, select **Class Library** from the
    installed templates and call your class `Chapter7`:![How to do it…](img/B05391_07_02.jpg)
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**添加新项目**对话框屏幕中，从已安装的模板中选择**类库**，并将你的类命名为 `Chapter7`：![如何操作…](img/B05391_07_02.jpg)
- en: Your new class library will be added to your solution with a default name `Class1.cs,`
    which we renamed to `Recipes.cs` in order to distinguish the code properly. You
    can, however, rename your class to whatever you like if that makes more sense
    to you.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你的新类库将以默认名称 `Class1.cs` 添加到你的解决方案中，我们将它重命名为 `Recipes.cs` 以便正确区分代码。然而，如果你觉得这样更有意义，你可以将你的类重命名为任何你喜欢的名字。
- en: To rename your class, simply click on the class name in **Solution Explorer**
    and select **Rename** from the context menu:![How to do it…](img/B05391_07_03.jpg)
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要重命名你的类，只需在**解决方案资源管理器**中单击类名，然后从上下文菜单中选择**重命名**：![如何操作…](img/B05391_07_03.jpg)
- en: Visual Studio will ask you to confirm a rename of all references to the code
    element **Class1** in the project. Just click on **Yes**:![How to do it…](img/B05391_07_04.jpg)
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Visual Studio将要求你确认重命名项目中所有对代码元素**Class1**的引用。只需点击**是**：![如何操作…](img/B05391_07_04.jpg)
- en: 'The following class is added to your `Chapter7` library project:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下类被添加到你的`Chapter7`库项目中：
- en: '[PRE0]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Inside the `Recipes` class, add a method called `DoBackgroundTask()` with the
    `public void` modifiers, and add the following console output to it:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Recipes`类内部，添加一个名为`DoBackgroundTask()`的方法，并使用`public void`修饰符，向其中添加以下控制台输出：
- en: '[PRE1]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Note
  id: totrans-28
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Make sure that you have added the `using` statements for `System.Threading`
    and `static System.Console` to your `using` statements.
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 确保你已经为`System.Threading`和`static System.Console`添加了`using`语句。
- en: Inside the console application called `CodeSamples`, added previously, add a
    reference to the `Chapter7` class library by right-clicking on **References**
    under the `CodeSamples` project and selecting **Add Reference** from the context
    menu:![How to do it…](img/B05391_07_05.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在之前添加的名为`CodeSamples`的控制台应用程序内部，通过在`CodeSamples`项目下的**引用**上右键单击并从上下文菜单中选择**添加引用**来添加对`Chapter7`类库的引用：![如何操作…](img/B05391_07_05.jpg)
- en: In the **Reference Manager** window, select the `Chapter7` solution by going
    to **Projects** | **Solutions**. This will allow you to use the classes we just
    created in your console application:![How to do it…](img/B05391_07_06.jpg)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**参考管理器**窗口中，通过访问**项目** | **解决方案**选择`Chapter7`解决方案。这将允许你在你的控制台应用程序中使用我们刚刚创建的类：![如何操作…](img/B05391_07_06.jpg)
- en: 'In the `void Main` method, create a new instance of your `Recipes` class and
    add it to a new thread called `backgroundThread`. Define this newly created thread
    to be a background thread and then start it. Finally, set the thread to sleep
    for five seconds. We need to do this because we have created a background thread
    that is set to sleep for three seconds. Background threads do not prohibit foreground
    threads from terminating. Therefore, if the main application thread (which is
    by default a foreground thread) terminates before the background thread completes,
    the application will terminate and also terminate the background thread:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`void Main`方法中，创建你`Recipes`类的一个新实例并将其添加到名为`backgroundThread`的新线程中。将这个新创建的线程定义为后台线程，然后启动它。最后，让线程休眠五秒钟。我们需要这样做，因为我们创建了一个设置为休眠三秒的后台线程。后台线程不会阻止前台线程终止。因此，如果主应用程序线程（默认为前台线程）在后台线程完成之前终止，应用程序将终止，并且也会终止后台线程：
- en: '[PRE2]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-34
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Please note that you might need to add the `using System.Threading`; directive.
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 请注意，你可能需要添加`using System.Threading`指令。
- en: Run your console application by pressing *F5*. You will see that we have created
    a background thread with a normal priority:![How to do it…](img/B05391_07_07.jpg)
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过按*F5*键运行你的控制台应用程序。你会看到我们创建了一个具有正常优先级的后台线程：![如何操作…](img/B05391_07_07.jpg)
- en: 'Let''s modify our thread and set its priority down to low. Add this line of
    code to your console application: `backgroundThread.Priority = ThreadPriority.Lowest;`.
    This line will downgrade the thread priority:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们修改我们的线程并将其优先级降低到低。将以下代码行添加到你的控制台应用程序中：`backgroundThread.Priority = ThreadPriority.Lowest;`。这一行将降低线程优先级：
- en: '[PRE3]'
  id: totrans-38
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Run your console application again. This time, you will see that the thread
    priority has been set to the lowest priority:![How to do it…](img/B05391_07_08.jpg)
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行你的控制台应用程序。这次，你会看到线程优先级已被设置为最低优先级：![如何操作…](img/B05391_07_08.jpg)
- en: 'Go back to your `DoBackgroundTask()` method and add `Thread.CurrentThread.Abort();`
    right before `Thread.Sleep(3000);` is called. This line will prematurely kill
    the background thread. Your code should look like this:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到你的`DoBackgroundTask()`方法，并在调用`Thread.Sleep(3000);`之前添加`Thread.CurrentThread.Abort();`。这一行将提前终止后台线程。你的代码应该看起来像这样：
- en: '[PRE4]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: When you run your console application, you will see that the thread is aborted
    before the `Thread.Sleep` method is called. Aborting a thread in this way, however,
    is generally not recommended:![How to do it…](img/B05391_07_09.jpg)
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你运行你的控制台应用程序时，你会看到线程在调用`Thread.Sleep`方法之前被终止。然而，以这种方式终止线程通常是不推荐的：![如何操作…](img/B05391_07_09.jpg)
- en: How it works…
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作…
- en: Being able to create a background thread is a great way to work on a different
    thread from the main thread while not interfering with the process of the main
    application thread. Another added benefit is that the background thread is terminated
    as soon as the main application thread is completed. This process ensures that
    your application will terminate gracefully.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 能够创建后台线程是在不干扰主应用程序线程进程的情况下在主线程之外工作的好方法。另一个附加的好处是，一旦主应用程序线程完成，后台线程就会立即终止。这个过程确保您的应用程序将优雅地终止。
- en: Increasing maximum thread pool size
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 增加最大线程池大小
- en: The thread pool in .NET resides in the `System.Threading.ThreadPool` class.
    Generally, there is a lot of discussion around creating your own threads as opposed
    to using the thread pool. Popular thinking dictates that the thread pool should
    be used for brief jobs. This is because the thread pool is limited in size. There
    are many other processes in the system that will use the thread pool. You therefore
    do not want your application to hog all the threads in the thread pool.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: .NET中的线程池位于`System.Threading.ThreadPool`类中。通常，关于创建自己的线程而不是使用线程池有很多讨论。流行观点认为，线程池应该用于短期任务。这是因为线程池的大小有限。系统中还有许多其他进程会使用线程池。因此，您不希望您的应用程序占用线程池中的所有线程。
- en: The rule is that you can't set the number of maximum worker or completion threads
    to be less than the number of processors on your computer. You are also not allowed
    to set the maximum worker or completion threads to less than the minimum thread
    pool size.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 规则是您不能将最大工作线程或完成线程的数量设置得少于您计算机上的处理器数量。您也不得将最大工作线程或完成线程的数量设置得少于最小线程池大小。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will read the number of processors on the current computer. Then, we will
    get the minimum and maximum allowable thread pool size, generate a random number
    between the minimum and maximum thread pool size, and set the maximum number of
    threads on the thread pool.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将读取当前计算机上的处理器数量。然后，我们将获取最小和最大允许的线程池大小，生成一个介于最小和最大线程池大小之间的随机数，并设置线程池上的最大线程数。
- en: How to do it…
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Create a new method called `IncreaseThreadPoolSize()` in the `Recipes` class:'
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Recipes`类中创建一个新的方法`IncreaseThreadPoolSize()`：
- en: '[PRE5]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Start by adding the code to read the number of processors on the current machine
    using `Environment.ProcessorCount`:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，通过使用`Environment.ProcessorCount`添加读取当前机器上处理器数量的代码：
- en: '[PRE6]'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Next, we will retrieve the maximum and minimum threads available in the thread
    pool:'
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将检索线程池中可用的最大和最小线程数：
- en: '[PRE7]'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we will generate a random number between the maximum and minimum number
    of threads in the thread pool:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将生成一个介于线程池中最大和最小线程数之间的随机数：
- en: '[PRE8]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We now need to attempt to set the maximum number of threads in the thread pool
    by calling the `SetMaxThreads` method and setting it to our new random maximum
    value for the worker threads and the completion port threads. Any requests above
    this maximum number will be queued until the thread pool threads become active
    again. If the `SetMaxThreads` method is successful, the method will return true;
    otherwise, it will return `false`. It is a good idea to ensure that the `SetMaxThreads`
    method is successful:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要尝试通过调用`SetMaxThreads`方法并将它设置为工作线程和完成端口线程的新随机最大值来设置线程池中的最大线程数。任何超过此最大数的请求都将排队，直到线程池线程再次活跃。如果`SetMaxThreads`方法成功，该方法将返回`true`；否则，它将返回`false`。确保`SetMaxThreads`方法成功是一个好主意：
- en: '[PRE9]'
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Worker threads is the maximum number of worker threads in the thread pool, while
    the completion port threads is the maximum number of asynchronous I/O threads
    in the thread pool.
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 工作线程是线程池中的最大工作线程数，而完成端口线程是线程池中的最大异步I/O线程数。
- en: 'When you have added all the code in the steps listed, your `IncreaseThreadPoolSize()`
    method should look like this:'
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您已将步骤中列出的所有代码添加完毕后，您的`IncreaseThreadPoolSize()`方法应如下所示：
- en: '[PRE10]'
  id: totrans-64
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Head on over to your console application and create a new instance of your
    `Recipe` class, and call the `IncreaseThreadPoolSize()` method:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直接进入您的控制台应用程序，创建一个新的`Recipe`类实例，并调用`IncreaseThreadPoolSize()`方法：
- en: '[PRE11]'
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Finally, run your console application and take note of the output:![How to do
    it…](img/B05391_07_10.jpg)
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行您的控制台应用程序并注意输出：![如何操作…](img/B05391_07_10.jpg)
- en: How it works…
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: From the console application, we can see that the processor count is `8`. The
    minimum number of thread pool threads, therefore, also equals 8\. We then read
    the maximum thread pool size and generate a random number between the minimum
    and maximum numbers. Lastly, we set the maximum thread pool size to our randomly
    generated minimum and maximum.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 从控制台应用程序中，我们可以看到处理器数量是`8`。因此，线程池的最小线程数也等于8。然后我们读取最大线程池大小，并在最小和最大数字之间生成一个随机数。最后，我们将最大线程池大小设置为随机生成的最小和最大值。
- en: While this is only a proof of concept and not something one would do in a production
    application (setting the thread pool to a random number), it clearly illustrates
    the ability to set the thread pool to a value specified by the developer.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这只是一个概念验证，并不是在生产应用程序中会做的事情（将线程池设置为随机数），但它清楚地说明了将线程池设置为开发人员指定的值的能力。
- en: Tip
  id: totrans-71
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提示
- en: The code in this recipe was compiled for 32 bit. Try changing your application
    to a 64-bit application and run the code again. See the difference 64 bit makes.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中的代码是为32位编译的。尝试将您的应用程序更改为64位应用程序并再次运行代码。看看64位带来的差异。
- en: Creating multiple threads
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建多个线程
- en: Sometimes, we need to create multiple threads. Before we can continue, however,
    we need to wait for these threads to complete doing whatever they need to do.
    For this, the use of tasks is best suited.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们需要创建多个线程。然而，在我们继续之前，我们需要等待这些线程完成它们需要做的任何事情。为此，使用任务是最合适的。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have added the `using System.Threading.Tasks;` statement
    to the top of your `Recipes` class.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 确保您已将`using System.Threading.Tasks;`语句添加到`Recipes`类的顶部。
- en: How to do it…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Create a new method called `MultipleThreadWait()` in your `Recipes` class.
    Then, create a second method called `RunThread()` with the `private` modifier,
    which takes an integer of seconds to make the thread sleep. This will simulate
    the process of doing some work for a variable amount of time:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的`Recipes`类中创建一个名为`MultipleThreadWait()`的新方法。然后，创建一个名为`RunThread()`的第二个方法，使用`private`修饰符，它接受一个整数秒数来使线程休眠。这将模拟进行一段时间工作的过程：
- en: '[PRE12]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-80
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In reality, you would probably not call the same method. You could, for all
    intents and purposes, call three separate methods. Here, however, for the sake
    of simplicity, we will call the same method with different sleep durations.
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在现实中，你可能不会调用相同的方法。从所有目的来看，你可以调用三个不同的方法。然而，为了简单起见，我们将使用不同的睡眠时长调用相同的方法。
- en: 'Add the following code to your `MultipleThreadWait()` method. You will notice
    that we are creating three tasks that then create three threads. We will then
    fire off these three threads and make them sleep for `3`, `5`, and `2` seconds.
    Finally, we will call the `Task.WaitAll` method to wait before continuing the
    execution of the application:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到您的`MultipleThreadWait()`方法中。您会注意到我们创建了三个任务，然后创建了三个线程。然后我们将启动这三个线程，并使它们分别休眠`3`、`5`和`2`秒。最后，我们将调用`Task.WaitAll`方法等待，然后再继续执行应用程序：
- en: '[PRE13]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, in the `RunThread()` method, we will read the current thread ID and then
    make the thread sleep for the amount of milliseconds supplied. This is just the
    integer value for the seconds multiplied by `1000`:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`RunThread()`方法中，我们将读取当前线程ID，然后使线程休眠指定的毫秒数。这仅仅是秒的整数值乘以`1000`：
- en: '[PRE14]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'When you have completed the code, your `Recipes` class should look like this:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当您完成代码后，您的`Recipes`类应该看起来像这样：
- en: '[PRE15]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Finally, add a new instance of the `Recipe` class to your console application
    and call the `MultipleThreadWait()` method:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，将`Recipe`类的新实例添加到您的控制台应用程序中，并调用`MultipleThreadWait()`方法：
- en: '[PRE16]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Run your console application and view the output produced:![How to do it…](img/B05391_07_11.jpg)
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行您的控制台应用程序并查看产生的输出：![如何做…](img/B05391_07_11.jpg)
- en: How it works…
  id: totrans-91
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: You will notice that three threads (`thread 9`, `thread 10`, and `thread 11`)
    are created. These are then paused by making them sleep for various amounts of
    time. After each thread wakes, the code waits for all three threads to complete
    before continuing the execution of the application code.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您会注意到创建了三个线程（`thread 9`、`thread 10`和`thread 11`）。然后通过使它们休眠不同时间来暂停这些线程。在每个线程唤醒后，代码将等待所有三个线程完成，然后再继续执行应用程序代码。
- en: Locking one thread until the contended resources are available
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 锁定一个线程直到有争议的资源可用
- en: There are instances where we want to give sole access to a process to a specific
    thread. We can do this using the `lock` keyword. This will execute this process
    in a thread-safe manner. Therefore, when a thread runs the process, it will gain
    exclusive access to the process for the duration of the lock scope. If another
    thread tries to gain access to the process inside the locked code, it will be
    blocked and have to wait its turn until the lock is released.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们希望将特定线程对进程的独占访问权。我们可以使用`lock`关键字来实现这一点。这将以线程安全的方式执行此进程。因此，当线程运行进程时，它将在锁的作用域内获得对进程的独占访问权。如果另一个线程试图在锁定代码内访问进程，它将被阻塞并必须等待直到锁被释放。
- en: Getting ready
  id: totrans-95
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this example, we will use tasks. Make sure that you have added the `using
    System.Threading.Tasks;` statement to the top of your `Recipes` class.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个例子，我们将使用任务。确保你已经将`using System.Threading.Tasks;`语句添加到你的`Recipes`类的顶部。
- en: How to do it…
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'In the `Recipes` class, add an object called `threadLock` with the `private`
    modifier. Then, add two methods called `LockThreadExample()` and `ContendedResource()`
    that take an integer of seconds to sleep as a parameter:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Recipes`类中，添加一个名为`threadLock`的对象，并使用`private`修饰符。然后，添加两个名为`LockThreadExample()`和`ContendedResource()`的方法，这两个方法接受一个表示睡眠秒数的整数作为参数：
- en: '[PRE17]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note
  id: totrans-100
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is considered a best practice to define the object to lock on as private.
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 被认为是一种最佳实践，将锁定对象定义为私有。
- en: 'Add three tasks to the `LockThreadExample()` method. They will create threads
    that try to access the same section of code simultaneously. This code will wait
    until all the threads have completed before terminating the application:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`LockThreadExample()`方法中添加三个任务。它们将创建尝试同时访问相同代码段的线程。此代码将在所有线程完成之前等待，然后终止应用程序：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the `ContendedResource()` method, create a lock using the `private` `threadLock`
    object and then make the thread sleep for the amount of seconds passed to the
    method as a parameter:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ContendedResource()`方法中，使用`private`的`threadLock`对象创建一个锁，然后使线程睡眠方法传递给方法的秒数：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Back in the console application, add the following code to instantiate a new
    `Recipes` class and call the `LockThreadExample()` method:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，添加以下代码以实例化一个新的`Recipes`类并调用`LockThreadExample()`方法：
- en: '[PRE20]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the console application and see the information output to the console window:![How
    to do it…](img/B05391_07_12.jpg)
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，查看信息输出到控制台窗口：![如何做…](img/B05391_07_12.jpg)
- en: How it works…
  id: totrans-109
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: We can see that `thread 11` gained exclusive access to the contended resource.
    At the same time, `thread 11` and `thread 12` tried to access the contended resource
    locked by `thread 11`. This then caused the other two threads to wait until `thread
    11` had completed and released the lock. The result of this is that the code is
    executed in an orderly manner, as can be seen in the console window output. Each
    thread waits its turn until it can access the resource and lock its thread.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到`thread 11`获得了对竞争资源的独占访问权。同时，`thread 11`和`thread 12`试图访问由`thread 11`锁定的竞争资源。这导致其他两个线程必须等待直到`thread
    11`完成并释放锁。结果是代码按顺序执行，如控制台窗口输出所示。每个线程等待它的轮次，直到它可以访问资源并锁定其线程。
- en: Invoking parallel calls to methods using Parallel.Invoke
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Parallel.Invoke调用方法的并行调用
- en: '`Parallel.Invoke` allows us to execute tasks in (you guessed it) parallel.
    Sometimes, you need to perform operations simultaneously and, in so doing, speed
    up processing. You can therefore expect that the total time taken to process the
    tasks is equal to the longest running process. Using `Parallel.Invoke` is quite
    easy.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.Invoke`允许我们以（你猜对了）并行的方式执行任务。有时，你需要同时执行操作，这样就可以加快处理速度。因此，可以预期处理任务的总时间等于运行时间最长的进程。使用`Parallel.Invoke`相当简单。'
- en: Getting ready
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: Make sure that you have added the `using System.Threading.Tasks;` statement
    to the top of your `Recipes` class.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经将`using System.Threading.Tasks;`语句添加到你的`Recipes`类的顶部。
- en: How to do it…
  id: totrans-115
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Start off by creating two methods in the `Recipes` class called `ParallelInvoke()`
    and `PerformSomeTask()`, which take an integer of seconds to sleep as the parameter:'
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Recipes`类中创建两个名为`ParallelInvoke()`和`PerformSomeTask()`的方法，这两个方法接受一个表示睡眠秒数的整数作为参数：
- en: '[PRE21]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Add the following code to the `ParallelInvoke()` method. This code will call
    `Paralell.Invoke` to run the `PerformSomeTask()` method:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`ParallelInvoke()`方法中。此代码将调用`Paralell.Invoke`来运行`PerformSomeTask()`方法：
- en: '[PRE22]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In the `PerformSomeTask()` method, make the thread sleep for the amount of
    seconds passed to the method as the parameter (converting the seconds to milliseconds
    by multiplying it by `1000`):'
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PerformSomeTask()`方法中，让线程休眠的方法参数指定的秒数（通过将秒数乘以`1000`将其转换为毫秒）：
- en: '[PRE23]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When you have added all the code, your `Recipes` class should look like this:'
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你添加了所有代码后，你的`Recipes`类应该看起来像这样：
- en: '[PRE24]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the console application, instantiate a new instance of the `Recipes` class
    and call the `ParallelInvoke()` method:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，实例化`Recipes`类的一个新实例并调用`ParallelInvoke()`方法：
- en: '[PRE25]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Run the console application and look at the output produced in the console window:![How
    to do it…](img/B05391_07_13.jpg)
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行控制台应用程序，查看控制台窗口中产生的输出：![如何做到这一点…](img/B05391_07_13.jpg)
- en: How it works…
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Because we are running all these threads in parallel, we can assume that the
    longest process will denote the total duration of the all the tasks. This means
    that the total duration of the process will be 5 seconds because the longest task
    will take 5 seconds to complete (we set `thread 10` to sleep for a maximum of
    5 seconds).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们正在并行运行所有这些线程，我们可以假设最长的过程将表示所有任务的总持续时间。这意味着整个过程的持续时间将是5秒，因为最长的任务将花费5秒来完成（我们将`thread
    10`设置为最多休眠5秒）。
- en: As we can see, the time difference between the start and the end of `Parallel.Invoke`
    is exactly 5 seconds.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所见，`Parallel.Invoke`的开始和结束之间的时间差正好是5秒。
- en: Using a parallel foreach loop to run multiple threads
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用并行`foreach`循环运行多个线程
- en: A while ago, during a work retreat (yes, the company I work for is really that
    cool), Graham Rook, who is one of my colleagues, showed me a parallel `foreach`
    loop. It certainly speeds up processing a great deal. But here's the rub. It makes
    no sense using a parallel `foreach` loop if you're dealing with small amounts
    of data or little tasks. The parallel `foreach` loop excels when there is bulk
    processing to do or huge amounts of data to process.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 很久以前，在一次工作 retreat（是的，我工作的公司真的很酷），我的同事之一Graham Rook向我展示了一个并行`foreach`循环。它确实大大加快了处理速度。但是，这里的问题是。如果你处理的是少量数据或小任务，使用并行`foreach`循环是没有意义的。并行`foreach`循环在需要大量处理或处理大量数据时表现最佳。
- en: Getting ready
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will start off by looking at where the parallel `foreach` loop does not perform
    better than the standard `foreach` loop. For this, we will create a small list
    of 500 items and just iterate over the list, writing the items to the console
    window.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先来看看并行`foreach`循环在性能上并不优于标准`foreach`循环的地方。为此，我们将创建一个包含500个项目的列表，并遍历列表，将项目写入控制台窗口。
- en: For the second example that illustrates the power of the parallel `foreach`
    loop, we will use the same list and create a file for each item in the list. The
    power and benefit of the parallel `foreach` loop will be evident in the second
    example.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明并行`foreach`循环的强大功能，我们将使用相同的列表并为列表中的每个项目创建一个文件。在第二个示例中，并行`foreach`循环的强大功能和好处将变得明显。
- en: How to do it…
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Start off by creating two methods in the `Recipes` class. Call one method `ReadCollectionForEach()`
    and pass it a parameter of `List<string>`. Create a second method called `ReadCollectionParallelForEach()`
    that also accepts a parameter of `List<string>`:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Recipes`类中创建两个方法。调用一个方法`ReadCollectionForEach()`并传递一个`List<string>`参数。创建第二个方法，称为`ReadCollectionParallelForEach()`，它也接受一个`List<string>`参数：
- en: '[PRE26]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'In the `ReadCollectionForEach()` method, add a standard `foreach` loop that
    will iterate over the collection of strings passed to it and write the value it
    finds to the console window. Then, clear the console window. Use a timer to keep
    track of the total seconds elapsed during the `foreach` loop:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`ReadCollectionForEach()`方法中，添加一个标准的`foreach`循环，该循环将遍历传递给它的字符串集合，并将找到的值写入控制台窗口。然后，清除控制台窗口。使用计时器来跟踪`foreach`循环期间的总秒数：
- en: '[PRE27]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the second method, called `ReadCollectionParallelForEach()`, do the same.
    However, instead of using a standard `foreach` loop, add a `Parallel.ForEach`
    loop. You will notice that the `Parallel.ForEach` loop looks slightly different.
    The signature of `Parallel.ForEach` requires that you pass it an enumerable data
    source (`List<string> intCollection`) and define an action, which is the delegate
    that is invoked for every iteration (`integer`):'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二个方法，称为`ReadCollectionParallelForEach()`中，做同样的事情。然而，不是使用标准的`foreach`循环，而是添加一个`Parallel.ForEach`循环。你会注意到`Parallel.ForEach`循环看起来略有不同。`Parallel.ForEach`的签名要求你传递一个可枚举的数据源（`List<string>
    intCollection`）并定义一个操作，即每次迭代时被调用的委托（`integer`）：
- en: '[PRE28]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'When you have added all the required code, your `Recipes` class should look
    like this:'
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你添加了所有必要的代码后，你的 `Recipes` 类应该看起来像这样：
- en: '[PRE29]'
  id: totrans-143
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'In the console application, create the `List<string>` collection and pass it
    to the two methods created in the `Recipes` class. You will notice that we are
    only creating a collection of 500 items. After the code is completed, return the
    time elapsed in seconds and output it to the console window:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，创建 `List<string>` 集合并将其传递给 `Recipes` 类中创建的两个方法。你会注意到我们只创建了一个包含 500
    个项目的集合。代码完成后，返回经过的时间（以秒为单位）并将其输出到控制台窗口：
- en: '[PRE30]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Run your application. From the output displayed, you will see that the performance
    gain using the `Parallel.ForEach` loop is negligible. In fact, in this case, the
    `Parallel.ForEach` loop only improved performance by 0.4516 percent:![How to do
    it…](img/B05391_07_14.jpg)
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用程序。从显示的输出中，你会看到使用 `Parallel.ForEach` 循环的性能提升是可以忽略不计的。实际上，在这种情况下，`Parallel.ForEach`
    循环只将性能提升了 0.4516 百分比：![如何做…](img/B05391_07_14.jpg)
- en: 'Let''s use a different example now. We will create a process-intensive task
    and measure the performance gain that the `Parallel.ForEach` loop will give us.
    Create two methods called `CreateWriteFilesForEach()` and `CreateWriteFilesParallelForEach()`,
    which both take the `List<string>` collection as the parameter:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在让我们使用一个不同的例子。我们将创建一个密集型任务，并测量 `Parallel.ForEach` 循环将为我们带来的性能提升。创建两个名为 `CreateWriteFilesForEach()`
    和 `CreateWriteFilesParallelForEach()` 的方法，这两个方法都接受 `List<string>` 集合作为参数：
- en: '[PRE31]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Add the following code to the `CreateWriteFilesForEach()` method. This code
    starts the timer and executes the standard `foreach` loop on the `List<string>`
    object. It then writes the elapsed time out to the console window:'
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `CreateWriteFilesForEach()` 方法中。此代码启动计时器，并在 `List<string>` 对象上执行标准的
    `foreach` 循环。然后，将经过的时间写入控制台窗口：
- en: '[PRE32]'
  id: totrans-150
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Inside the `foreach` loop, add the code to check whether a file exists with
    the specific name created by appending the `integer` value to the filename portion
    of the `filePath` variable. Create the file (ensuring that you use `Dispose` method
    in order not to lock the file when trying to write to it) and write some text
    to the newly created file:'
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `foreach` 循环内部，添加代码以检查是否已使用 `filePath` 变量的文件名部分附加的 `integer` 值创建了一个具有特定名称的文件。创建该文件（确保在尝试写入时使用
    `Dispose` 方法以避免锁定文件），并将一些文本写入新创建的文件：
- en: '[PRE33]'
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Next, add this code to the `CreateWriteFilesParallelForEach()` method, which
    basically performs the same function as the `CreateWriteFilesForEach()` method,
    but uses a `Parallel.ForEach` loop to create and write files:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，将以下代码添加到 `CreateWriteFilesParallelForEach()` 方法中，该方法基本上与 `CreateWriteFilesForEach()`
    方法执行相同的函数，但使用 `Parallel.ForEach` 循环来创建和写入文件：
- en: '[PRE34]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add the slightly modified file-creation code inside the `Parallel.ForEach`
    loop:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Parallel.ForEach` 循环内部添加略微修改的文件创建代码：
- en: '[PRE35]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'When you are done, your code needs to look like this:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你完成时，你的代码需要看起来像这样：
- en: '[PRE36]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Heading over to the console application, modify the `List<string>` object slightly
    and increase the count from `500` to `1000`. Then, call the file methods created
    in the `Recipes` class:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到控制台应用程序，稍微修改 `List<string>` 对象，并将计数从 `500` 增加到 `1000`。然后，调用 `Recipes` 类中创建的文件方法：
- en: '[PRE37]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Finally, when you are ready, make sure that you have the `C:\temp\output` directory
    and that there aren't any other files in that directory. Run your application
    and review the output to the console window. This time round, we can see that
    the `Parallel.ForEach` loop has made a huge difference. The performance gain is
    massive and heralds a 60.7074 percent performance increase over the standard `foreach`
    loop:![How to do it…](img/B05391_07_15.jpg)
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，当你准备好时，请确保你有 `C:\temp\output` 目录，并且该目录中没有其他文件。运行你的应用程序并查看控制台窗口的输出。这一次，我们可以看到
    `Parallel.ForEach` 循环产生了巨大的差异。性能提升非常显著，比标准的 `foreach` 循环提高了 60.7074 百分比：![如何做…](img/B05391_07_15.jpg)
- en: How it works…
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: From the examples used in this recipe, it is clear that the use of the parallel
    `foreach` loop should be considered carefully. If you are dealing with relatively
    low volumes of data or non-process intensive transactions, the parallel `foreach`
    loop will not benefit your application's performance much. In some instances,
    the standard `foreach` loop could be much faster than the parallel `foreach` loop.
    If, however, you find your application running into performance issues when processing
    large amounts of data or running processor-intensive tasks, give the parallel
    `foreach` loop a try. It just might surprise you.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 从本食谱中使用的示例中可以看出，在使用并行 `foreach` 循环时应该仔细考虑。如果你处理的是相对较低的数据量或非处理密集型事务，并行 `foreach`
    循环不会对你的应用程序性能带来太多好处。在某些情况下，标准的 `foreach` 循环可能比并行 `foreach` 循环快得多。然而，如果你在处理大量数据或运行处理器密集型任务时发现应用程序出现性能问题，可以尝试使用并行
    `foreach` 循环。它可能会让你感到惊讶。
- en: Cancelling a parallel foreach loop
  id: totrans-164
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消并行 `foreach` 循环
- en: When dealing with parallel `foreach` loops, the obvious question is how one
    would terminate the loop prematurely based on a certain condition, such as a timeout.
    As it turns out, the parallel `foreach` loop is quite easy to terminate prematurely.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在处理并行 `foreach` 循环时，一个明显的问题是，如何根据某个条件（如超时）提前终止循环。实际上，并行 `foreach` 循环很容易提前终止。
- en: Getting ready
  id: totrans-166
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a method that takes a collection of items and loops through this
    collection in a parallel `foreach` loop. It will also be aware of a timeout value
    that, if exceeded, will terminate the loop and exit the method.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个方法，该方法接受一个项目集合，并在这个集合中以并行 `foreach` 循环的方式遍历。它还将知道一个超时值，如果超过，将终止循环并退出方法。
- en: How to do it…
  id: totrans-168
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Start off by creating a new method called `CancelParallelForEach()` in the
    `Recipes` class, which takes two parameters. One is a collection of `List<string>`,
    while the other is an integer specifying a timeout value. When the timeout value
    is exceeded, the `Parallel.ForEach` loop must terminate:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 `Recipes` 类中创建一个名为 `CancelParallelForEach()` 的新方法，它接受两个参数。一个是 `List<string>`
    集合，另一个是指定超时值的整数。当超时值超过时，`Parallel.ForEach` 循环必须终止：
- en: '[PRE38]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Inside the `CancelParallelForEach()` method, add a timer to keep track of the
    elapsed time. This will signal the loop that the timeout threshold has been exceeded
    and that the loop needs to exit. Create the `Parallel.ForEach` method, defining
    a state. In each iteration, check the elapsed time against the timeout, and if
    the time is exceeded, break out of the loop:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CancelParallelForEach()` 方法内部，添加一个计时器来跟踪经过的时间。这将向循环发出信号，表示超时阈值已超过，循环需要退出。创建
    `Parallel.ForEach` 方法，定义一个状态。在每次迭代中，将经过的时间与超时时间进行比较，如果时间超过，则跳出循环：
- en: '[PRE39]'
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the console application, create the `List<string>` object and add `1000`
    items to it. Call the `CancelParallelForEach()` method with a timeout of only
    `5` seconds:'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，创建 `List<string>` 对象并添加 `1000` 个项目到其中。使用 `5` 秒的超时时间调用 `CancelParallelForEach()`
    方法：
- en: '[PRE40]'
  id: totrans-174
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Run your console application and review the output results:![How to do it…](img/B05391_07_16.jpg)
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的控制台应用程序并查看输出结果：![如何操作…](img/B05391_07_16.jpg)
- en: How it works…
  id: totrans-176
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: You can see from the console window output that as soon as the elapsed time
    exceeded the timeout value, the parallel loop was notified to cease the execution
    of iterations beyond the current iteration at the system's earliest convenience.
    Having this kind of control over the `Parallel.ForEach` loop allows developers
    to avoid runaway loops and give the user control to cancel a loop operation by
    clicking on a button, or automatically having the application terminate when the
    timeout value has been reached.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以从控制台窗口输出中看到，一旦经过的时间超过超时值，并行循环就会在系统最早方便的时候通知停止执行当前迭代之后的迭代。这种对 `Parallel.ForEach`
    循环的控制能力允许开发者避免失控的循环，并允许用户通过点击按钮来取消循环操作，或者当超时值达到时，应用程序自动终止。
- en: Catching errors in parallel foreach loops
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在并行 `foreach` 循环中捕获错误
- en: With parallel `foreach` loops, developers can wrap the loop in a `try` `catch`
    statement. Care needs to be taken, however, because the `Parallel.ForEach` will
    throw `AggregatedException`, which has the exceptions it encounters over several
    threads rolled into one.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 使用并行 `foreach` 循环，开发者可以将循环包裹在 `try` `catch` 语句中。然而，需要注意，`Parallel.ForEach` 将会抛出
    `AggregatedException`，它将多个线程中遇到的异常合并为一个。
- en: Getting ready
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will create a `List<string>` object that contains a collection of machine
    IP addresses. The `Parallel.ForEach` loop will check the IP addresses to see whether
    the machines on the other end of the given IP are alive. It does this by pinging
    the IP address. The method that performs the `Parallel.ForEach` loop will also
    be given the minimum required alive machines as an integer value. If the minimum
    number of machines alive is not met, an exception is thrown.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个包含机器IP地址集合的`List<string>`对象。`Parallel.ForEach`循环将检查IP地址以查看给定IP地址另一端的机器是否存活。它是通过ping
    IP地址来做到这一点的。执行`Parallel.ForEach`循环的方法还将获得所需存活机器的最小数量作为整数值。如果未达到存活机器的最小数量，则会抛出异常。
- en: How to do it…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'In the `Recipes` class, add a method called `CheckClientMachinesOnline()` that
    takes as parameters a `List<string>` collection of IP addresses and an integer
    that specifies the minimum number of machines required to be online. Add a second
    method called `MachineReturnedPing()` that will receive an IP address to ping.
    For our purpose, we will just return `false` to mimic a dead machine (the ping
    to the IP address timed out):'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Recipes`类中，添加一个名为`CheckClientMachinesOnline()`的方法，该方法接受一个`List<string>`集合的IP地址和一个指定所需在线的最小机器数量的整数作为参数。添加第二个名为`MachineReturnedPing()`的方法，该方法将接收一个要ping的IP地址。为了我们的目的，我们将只返回`false`来模拟一个死机（ping到IP地址超时）：
- en: '[PRE41]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Inside the `CheckClientMachinesOnline()` method, add the `Parallel.ForEach`
    loop and create the `ParallelOptions` variable, which will specify the degree
    of parallelism. Wrap all this code inside a `try` `catch` statement and catch
    `AggregateException`:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CheckClientMachinesOnline()`方法内部，添加`Parallel.ForEach`循环并创建`ParallelOptions`变量，该变量将指定并行度。将所有这些代码包裹在一个`try`
    `catch`语句中，并捕获`AggregateException`：
- en: '[PRE42]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Inside the `Parallel.ForEach` loop, write the code to check whether the machine
    is online by calling the `MachineReturnedPing()` method. In our example, this
    method will always return `false`. You will notice that we are keeping track of
    the offline machine count via the `Interlocked.Increment` method. This is just
    a way of incrementing a variable across the threads of the `Parallel.ForEach`
    loop:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Parallel.ForEach`循环内部，编写代码通过调用`MachineReturnedPing()`方法来检查机器是否在线。在我们的示例中，此方法将始终返回`false`。你会注意到我们通过`Interlocked.Increment`方法跟踪离线机器的数量。这仅仅是一种在`Parallel.ForEach`循环的线程之间增加变量的方式：
- en: '[PRE43]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'If you have added all the code correctly, your `Recipes` class will look like
    this:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你已经正确添加了所有代码，你的`Recipes`类将看起来像这样：
- en: '[PRE44]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the console application, create the `List<string>` object to store a collection
    of dummy IP addresses. Instantiate your `Recipes` class and call the `CheckClientMachinesOnline()`
    method, passing the collection of IP addresses and a minimum number of machines
    required to be online to it:'
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制台应用程序中，创建一个`List<string>`对象来存储一组模拟的IP地址。实例化你的`Recipes`类并调用`CheckClientMachinesOnline()`方法，将IP地址集合和所需在线的最小机器数量传递给它：
- en: '[PRE45]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Run your application and review the output in the console window:![How to do
    it…](img/B05391_07_17.jpg)
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行你的应用程序，并在控制台窗口中查看输出：![如何操作…](img/B05391_07_17.jpg)
- en: How it works…
  id: totrans-194
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理…
- en: From the console window output, you can see that the minimum number of machines
    required to be online was not achieved. The application then threw an exception
    and caught it from the `Parallel.ForEach` loop. Being able to handle exceptions
    in parallel loops such as this one is essential to maintain the stability of your
    application by being able to handle exceptions as they occur.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 从控制台窗口输出中，你可以看到所需的最小在线机器数量没有达到。应用程序随后抛出了异常，并在`Parallel.ForEach`循环中捕获了它。能够处理此类并行循环中的异常对于通过处理发生的异常来维护应用程序的稳定性至关重要。
- en: We encourage you to play around a little with the `Parallel.ForEach` loop and
    drill into some of the inner methods of the `AggregareException` class to really
    understand it better.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励你稍微尝试一下`Parallel.ForEach`循环，并深入研究`AggregareException`类的内部方法，以更好地理解它。
- en: Debugging multiple threads
  id: totrans-197
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试多个线程
- en: Debugging multiple threads in Visual Studio is tricky, especially since these
    threads are all running at the same time. Luckily, we have a few tools available
    to us as developers to use to get a better understanding of what is happening
    in our multithreaded applications.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中调试多个线程很棘手，尤其是这些线程都在同时运行。幸运的是，我们作为开发者有一些工具可以使用，以更好地了解我们的多线程应用程序中正在发生的事情。
- en: Getting ready
  id: totrans-199
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: While debugging multithreaded applications, you can access various windows by
    going to **Debug** | **Windows** in Visual Studio.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试多线程应用程序时，你可以通过在Visual Studio中转到**调试** | **窗口**来访问各种窗口。
- en: How to do it…
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: Start debugging your multithreaded application after adding a breakpoint somewhere
    in the code. You can access various debugging windows by going to **Debug** |
    **Windows** in Visual Studio:![How to do it…](img/B05391_07_18.jpg)
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中添加断点后开始调试你的多线程应用程序。你可以通过在Visual Studio中转到**调试** | **窗口**来访问各种调试窗口：![如何操作…](img/B05391_07_18.jpg)
- en: 'The first window available to you is the **Threads** window. Access it by going
    to **Debug** | **Windows** in Visual Studio or type *Ctrl* + *Alt* + *H*. In here,
    you can right-click on a thread to watch and flag it. If you have given your threads
    names, you will see that name appear in the **Name** column. To give your thread
    a name, you could add the following code to your application, which runs the method
    on a separate thread:'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可供你访问的第一个窗口是**线程**窗口。通过在Visual Studio中转到**调试** | **窗口**或按*Ctrl* + *Alt* + *H*来访问它。在这里，你可以右键单击一个线程来监视和标记它。如果你给你的线程命名了，你将在**名称**列中看到那个名称。要给你的线程命名，你可以在你的应用程序中添加以下代码，该代码在单独的线程上运行方法：
- en: '[PRE46]'
  id: totrans-204
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: You will also be able to see the currently active thread in the debugger. It
    will be marked with a yellow arrow. Then, there is the managed ID, which is the
    same ID you would have used to create the unique thread name earlier on.
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你还能够在调试器中看到当前活动的线程。它将被一个黄色箭头标记。然后是托管ID，这是你之前用来创建唯一线程名称的相同ID。
- en: 'The **Location** column displays the current method that the thread is in.
    The **Threads** window allows you to view the stack of the thread by double-clicking
    on the **Location** field. You can also freeze and thaw threads. Freezing stops
    a thread from executing, while thawing allows the frozen thread to continue as
    normal:'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '**位置**列显示了线程当前所在的方法。**线程**窗口允许你通过双击**位置**字段来查看线程的堆栈。你还可以冻结和解冻线程。冻结会停止线程执行，而解冻允许冻结的线程正常继续：'
- en: '![How to do it…](img/B05391_07_19.jpg)'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作…](img/B05391_07_19.jpg)'
- en: The **Tasks** window can be accessed by going to **Debug** | **Windows** or
    by holding down *Ctrl* + *Shift* + *D* and then pressing *K*. You will notice
    that the thread you flagged earlier in the **Threads** window is also flagged
    here in the **Tasks** window. The status of the task shows the status at that
    moment and can be **Active**, **Deadlocked**, **Waiting**, **Scheduled**, or **Completed**:![How
    to do it…](img/B05391_07_20.jpg)
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**任务**窗口可以通过转到**调试** | **窗口**或按住*Ctrl* + *Shift* + *D*然后按*K*来访问。你会注意到在**线程**窗口中之前标记的线程在这里的**任务**窗口中也被标记了。任务的状态显示了那一刻的状态，可以是**活动**、**死锁**、**等待**、**已调度**或**完成**：![如何操作…](img/B05391_07_20.jpg)'
- en: The **Parallel Stacks** window can be accessed by going to **Debug** | **Windows**
    in Visual Studio or by holding down *Ctrl* + *Shift* + *D*, and then pressing
    the *S* key. Here, you can see a graphical view of the tasks and threads. You
    can switch between the **Threads** and **Tasks** view by making a selection in
    the dropdown list in the upper-left corner of the **Parallel Stacks** window:![How
    to do it…](img/B05391_07_21.jpg)
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**并行堆栈**窗口可以通过在Visual Studio中转到**调试** | **窗口**或按住*Ctrl* + *Shift* + *D*，然后按*S*键来访问。在这里，你可以看到任务和线程的图形视图。你可以在**并行堆栈**窗口的右上角的下拉列表中选择，在**线程**和**任务**视图之间切换：![如何操作…](img/B05391_07_21.jpg)'
- en: Changing the selection to **Tasks** will show you the current tasks in the debug
    session:![How to do it…](img/B05391_07_22.jpg)
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将选择更改为**任务**将显示调试会话中的当前任务：![如何操作…](img/B05391_07_22.jpg)
- en: The next window, and undoubtedly my favorite is the **Parallel Watch** window.
    It is in fact identical to the standard **Watch** window in Visual Studio, but
    this watches values across all threads in your application. You can type in any
    valid C# expression into **Parallel Watch** and see the values as they are at
    that moment in the debug session. As you can see, we have added the `sleepSeconds`
    variable and the name of the thread to the watch:![How to do it…](img/B05391_07_23.jpg)
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个窗口，无疑是我最喜欢的，是**并行监视**窗口。实际上，它与Visual Studio中的标准**监视**窗口相同，但这是监视应用程序中所有线程的值。你可以在**并行监视**中输入任何有效的C#表达式，并看到在调试会话中的那一刻的值。正如你所看到的，我们添加了`sleepSeconds`变量和线程名称到监视中：![如何操作…](img/B05391_07_23.jpg)
- en: How it works…
  id: totrans-212
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Being able to use the debugging tools for multithreaded applications effectively
    in Visual Studio makes it much easier to understand the structure of your application
    and helps you identify possible bugs, bottlenecks, and areas of concern.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 能够在 Visual Studio 中有效地使用多线程应用的调试工具，使您更容易理解您应用程序的结构，并帮助您识别可能的错误、瓶颈和关注区域。
- en: We encourage you to learn more about the various debugging windows available
    to you.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 我们鼓励您了解您可用的各种调试窗口。
