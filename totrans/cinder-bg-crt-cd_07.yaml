- en: Chapter 7. Working with Images – Real-time Postprocessing and Effects
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第7章. 与图像一起工作 – 实时后处理和效果
- en: In this chapter we will talk about basic approaches of using built-in Cinder
    classes for applying effects to still and moving images.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论使用内置Cinder类的基本方法来对静态和动态图像应用效果。
- en: 'In this chapter we will learn the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习以下内容：
- en: Understanding the difference between CPU and GPU image processing
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解CPU和GPU图像处理之间的区别
- en: Applying basic effects to images
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对图像应用基本效果
- en: Looping through pixels of an image as well as a movie frame
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 遍历图像像素以及电影帧
- en: Making use of the pixel-level access
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 利用像素级访问
- en: Introducing Texture, Surface, and Channel
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍纹理、表面和通道
- en: 'In [Chapter 5](ch05.html "Chapter 5. Making Use of Images – Loading and Displaying"),
    *Making Use of Images – Loading and Displaying*, we already learned how to load
    an image into Cinder. The following is the essence of the code we used there:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](ch05.html "第5章. 利用图像 – 加载和显示")中，*利用图像 – 加载和显示*，我们已经学习了如何将图像加载到Cinder中。以下是我们当时使用的代码的精华：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'With this line of code we load pixels from the `image.jpg` image file into
    the GPU memory. `Texture` is meant for storing the image data but not for manipulating
    or displaying it. To show the image on the screen, we use the following line of
    code:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此行代码，我们将`image.jpg`图像文件中的像素加载到GPU内存中。`Texture`用于存储图像数据，但不用于操作或显示。要在屏幕上显示图像，我们使用以下行代码：
- en: '[PRE1]'
  id: totrans-11
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Say we want to do some image processing in between the load and draw stages.
    To process images on the GPU (where the image data is stored by the `Texture`
    objects), we would use shaders. Shaders make use of the OpenGL Shading Language
    and we won't go in detail about this now as it is way outside the scope of this
    book.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 假设我们想在加载和绘制阶段之间进行一些图像处理。要在GPU上处理图像（图像数据由`Texture`对象存储），我们会使用着色器。着色器使用OpenGL着色语言，我们不会在这里详细介绍，因为这远远超出了本书的范围。
- en: There is another way of processing the image, that is by loading the image on
    the CPU. To make use of the CPU, we have to use the `Surface` class. It is similar
    to the `Texture` class but the main difference is that it stores the image data
    on the CPU. By loading an image on the CPU, we can do the image processing with
    the C++ code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种处理图像的方法是在CPU上加载图像。为了使用CPU，我们必须使用`Surface`类。它与`Texture`类类似，但主要区别在于它在CPU上存储图像数据。通过在CPU上加载图像，我们可以使用C++代码进行图像处理。
- en: 'To draw a surface, we will need to convert it to a `Texture` instance. It is
    possible to convert the `Surface` data to the `Texture` class instances for drawing
    something similar to the following:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要绘制一个表面，我们需要将其转换为`Texture`实例。可以将`Surface`数据转换为`Texture`类实例以绘制类似以下内容：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: By performing the preceding code, we create a GPU friendly texture for displaying
    it on the screen.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过执行前面的代码，我们创建了一个适合在屏幕上显示的GPU友好纹理。
- en: There is a third image datatype in Cinder, the `Channel` class. If the `Surface`
    class is able to hold red, green, blue, and alpha values in separate channels
    within one object, then `Channel` makes use of just one channel (can hold one
    of the channels mentioned) and can be used to store grayscale images.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: Cinder中存在第三种图像数据类型，即`Channel`类。如果`Surface`类能够在单个对象内部的不同通道中存储红色、绿色、蓝色和alpha值，那么`Channel`仅使用一个通道（可以存储上述提到的任何一个通道）并可用于存储灰度图像。
- en: 'It is possible to create a `Surface` instance from a `Channel` class by adding
    the following line:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过添加以下行从`Channel`类创建一个`Surface`实例：
- en: '[PRE3]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The preceding line of code makes it is possible to create a high-quality, grayscale
    image as a `Channel` class instance by passing a `Surface` instance to the `Channel`
    directly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 上一行代码使得通过直接传递`Surface`实例到`Channel`类，可以创建一个高质量的灰度图像作为`Channel`类实例成为可能。
- en: '[PRE4]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Applying the grayscale effect
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用灰度效果
- en: In the previous section, we already discussed one of the basic effects that
    can be applied in almost every image processing software out there, grayscale.
    Let's create a simple application that loads an image and converts it to grayscale
    by using methods we just discussed.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们已经讨论了几乎可以在所有图像处理软件中应用的基本效果之一，即灰度。让我们创建一个简单的应用程序，通过使用我们刚刚讨论的方法加载图像并将其转换为灰度。
- en: Open up **TinderBox** and make a new application with the name `BasicEffects`.
    Place an image (let's call it `OurImage.png`, I will be using a simple, digitally
    enhanced hand-drawn sketch from my own archives) in the assets directory of the
    project and open the `xcode/BasicEffects.xcodeproj` project file. Windows users
    can open the `vc10\BasicEffects.sln` file.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**TinderBox**，创建一个名为`BasicEffects`的新应用程序。将一个图像（让我们称它为`OurImage.png`，我将使用从我自己的档案中提取的一个简单、数字化增强的手绘草图）放入项目的`assets`目录中，并打开`xcode/BasicEffects.xcodeproj`项目文件。Windows用户可以打开`vc10/BasicEffects.sln`文件。
- en: 'Open `BasicEfectsApp.cpp` in your editor and include a couple of headers that
    we will need later:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在你的编辑器中打开`BasicEfectsApp.cpp`，并包含我们稍后需要的几个头文件：
- en: '[PRE5]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now declare the variables/objects of type `Texture` and `Surface` as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在声明`Texture`和`Surface`类型的变量/对象如下：
- en: '[PRE6]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Also, load an image into the `surface` object and pass it to the `Texture`
    constructor so we can draw it afterwards (this goes in to the `setup()` method
    implementation):'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，将图像加载到`surface`对象中，并将其传递给`Texture`构造函数，以便我们之后可以绘制它（这将在`setup()`方法实现中完成）：
- en: '[PRE7]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Finally go to the `draw()` method implementation and add the following lines
    of code to draw the texture:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，进入`draw()`方法实现，并添加以下代码行以绘制纹理：
- en: '[PRE8]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Before we draw the texture, we need to make sure that it actually exists.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们绘制纹理之前，我们需要确保它确实存在。
- en: When you compile and run the project our image should appear on the screen.
    If it does not, make sure that the image really exists in our project's `assets`
    directory and that the image filename argument in the `loadAsset("OurImage.png")`
    is correct.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编译并运行项目时，我们的图像应该出现在屏幕上。如果它没有出现，请确保图像确实存在于我们项目的`assets`目录中，并且`loadAsset("OurImage.png")`中的图像文件名参数是正确的。
- en: 'We have made the very basic structure for image processing on the CPU. To make
    the image in grayscale, we will make use of the `Channel` class. First, we will
    include the `Channel.h` file as follows:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在CPU上为图像处理创建了非常基本的结构。为了将图像转换为灰度，我们将使用`Channel`类。首先，我们将按照以下方式包含`Channel.h`文件：
- en: '[PRE9]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, in the `setup()` method implementation, where we load the image, create
    a `Channel` instance from the `Surface` instance and construct the texture by
    using the newly created channel:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在`setup()`方法实现中，我们加载图像，从`Surface`实例创建一个`Channel`实例，并使用新创建的通道来构建纹理：
- en: '[PRE10]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Compile and run the project. The following screenshot is a comparison image
    that shows the difference between the result when we use the `Surface` object
    for constructing a texture and `Channel`:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目。以下截图是对比图像，显示了当我们使用`Surface`对象构建纹理和`Channel`之间的差异：
- en: '![Applying the grayscale effect](img/9564_07_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![应用灰度效果](img/9564_07_01.jpg)'
- en: The image is automatically converted to grayscale once we pass it to the `Channel`
    constructor and we use the result for creating the texture. You should see it
    yourself when you compile and run the program.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们将图像传递给`Channel`构造函数，图像就会自动转换为灰度，我们使用这个结果来创建纹理。当你编译并运行程序时，你应该自己看到这一点。
- en: Using threshold
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用阈值
- en: Now we are going to use some per-pixel manipulation. We will choose one certain
    threshold value between 0 and 255 and compare each channel of each pixel to that
    value. If the value is above the threshold, we will change the channel value to
    maximum (255). If the value is less, we will change it to the minimum (0).
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将使用一些逐像素操作。我们将选择一个介于0到255之间的特定阈值值，并将每个像素的每个通道与该值进行比较。如果值高于阈值，我们将通道值更改为最大值（255）。如果值较低，我们将将其更改为最小值（0）。
- en: Note
  id: totrans-44
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Previously we were using floating point numbers from 0 to 1 to describe R, G,
    and B channels. When using `Surface` objects and images in general, you might
    want to know that each pixel of each channel of the `Surface (Surface8u)` object
    consists of 8 bits that can hold 256 values from 0 to 255 if not defined otherwise.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 之前我们使用0到1之间的浮点数来描述R、G和B通道。当使用`Surface`对象和图像时，你可能想知道`Surface (Surface8u)`对象的每个通道的每个像素由8位组成，可以存储256个值（从0到255），除非未定义。
- en: As we are dealing with a still image, we have to do this process only once,
    in the `setup()` methodbetween the `surface` and `texture` object initialization.
    We will make use of a really handy helper class, `Surface::Iter`, that will allow
    us to loop seamlessly through lines (rows) and individual pixels of each line.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们处理的是静态图像，我们只需要在`setup()`方法中在`surface`和`texture`对象初始化之间执行此过程一次。我们将使用一个非常实用的辅助类`Surface::Iter`，它将允许我们无缝地遍历每一行（行）和每一行的单个像素。
- en: 'So this is the code that we have to add to the `setup()` method implementation
    between the `surface` and `texture` variable initialization lines as follows:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这是我们必须添加到`setup()`方法实现中`surface`和`texture`变量初始化行之间的代码，如下所示：
- en: '[PRE11]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: First we define the threshold, all the values above that will be changed to
    255 and all the values below or equal will be changed to 0\. Say goodbye to smooth
    gradients. Next we get the area of the image that we will change. To change the
    whole image, we have to get the bounds of the whole surface. We have to get an
    iterator (`iter`) to construct a nice nested loop afterwards. Finally we use the
    iterator to loop through all the lines (rows) and pixels (columns inside the row)
    of the surface and change it's pixels one by one.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们定义阈值，所有高于该阈值的值将更改为255，所有低于或等于该阈值的值将更改为0。再见了，平滑的渐变。接下来，我们获取我们将要更改的图像区域。为了更改整个图像，我们必须获取整个表面的边界。我们必须获取一个迭代器（`iter`），以便之后构建一个漂亮的嵌套循环。最后，我们使用迭代器遍历表面的所有行（行）和像素（行内的列），逐个更改像素。
- en: 'Don''t forget to change the `Texture` initialization (you have to use our `Surface`
    instance again instead of `Channel`):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记更改`Texture`的初始化（您必须再次使用我们的`Surface`实例而不是`Channel`）：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note that we initialize the texture after we make changes to the pixels of the
    surface. Every time you make changes to the `Surface` object that you will be
    using as a `Texture` afterwards, you have to reinitialize the `texture` variable
    from the changed `Surface` object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在更改表面的像素后初始化纹理。每次您更改将用作`Texture`的`Surface`对象时，您都必须从更改后的`Surface`对象重新初始化`texture`变量。
- en: 'Compile and run the project, and see what happens! The following screenshot
    shows the comparison between the source image and the one with our threshold filter
    applied:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目，看看会发生什么！以下屏幕截图显示了应用了我们的阈值滤镜的源图像与目标图像的比较：
- en: '![Using threshold](img/9564_07_02.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![使用阈值](img/9564_07_02.jpg)'
- en: Try to experiment a bit by changing the threshold value and the way pixel values
    are being changed before we move on to the next part.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续下一部分之前，尝试通过改变阈值值和像素值变化的方式做一些实验。
- en: Animating effects
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 动画效果
- en: 'Let''s make a simple effect animation by using the tricks we just learned and
    the `update()` method. We have to modify the code in the `setup()` method implementation
    so it looks similar to the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过使用我们刚刚学到的技巧和`update()`方法制作一个简单的效果动画。我们必须修改`setup()`方法实现中的代码，使其看起来类似于以下内容：
- en: '[PRE13]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Next we have to cut and paste all the code except the `surface` initialization
    to the `update()` method implementation as follows:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须将除了`surface`初始化之外的所有代码剪切并粘贴到`update()`方法实现中，如下所示：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With that done, compile and run the project, and see what happens:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，编译并运行项目，看看会发生什么：
- en: '![Animating effects](img/9564_07_03.jpg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![动画效果](img/9564_07_03.jpg)'
- en: In the preceding screenshot you can see an animation that looks like some kind
    of acid eating and that transforms all the surfaces of the image.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的屏幕截图中，您可以看到一种类似酸液侵蚀的动画，它将图像的所有表面都转换了。
- en: Applying effects to moving images
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将效果应用于移动图像
- en: We just saw how to get moving effects, let's try to add effects to a moving
    image.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚看到了如何获得动态效果，现在让我们尝试将效果添加到移动图像上。
- en: Before we do that, it is a good idea to make a copy of our project (`BasicEffects`).
    Let's rename the folder of the new project to `BasicEffectsMotion`. Open the project
    file (`xcode/BasicEffects.xcodeproj` on Ma OS X or `vc10\BasicEffects.sln` on
    Windows).
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在做之前，制作我们项目（`BasicEffects`）的副本是个好主意。将新项目的文件夹重命名为`BasicEffectsMotion`。打开项目文件（在Mac
    OS X上为`xcode/BasicEffects.xcodeproj`，在Windows上为`vc10\BasicEffects.sln`）。
- en: Note
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For Windows users, you will have to add `QTMLClient.lib` and `CVClient.lib`
    to **Linker** | **Input** | **Additional Dependencies** in the project properties.
    You will also have to add path to the QuickTime SDK (`C:\QuickTimeSDK-7.3\Libraries`)
    in **Linker** | **General** | **Additional Library Directories** in the project
    properties. You can access project properties from the menu bar by clicking on
    **Project** | **BasicEffects Properties**.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 对于Windows用户，您需要在项目属性中**链接** | **输入** | **附加依赖项**下添加`QTMLClient.lib`和`CVClient.lib`。您还必须在项目属性中**链接**
    | **常规** | **附加库目录**下添加QuickTime SDK的路径（`C:\QuickTimeSDK-7.3\Libraries`）。您可以通过菜单栏点击**项目**
    | **基本效果属性**来访问项目属性。
- en: First we need to find a movie file that we can use. [http://vimeo.com/groups/freehd](http://vimeo.com/groups/freehd)
    seems a good place where you can find free video footage. I found one with a footage
    of an industrial site.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要找到一个我们可以使用的电影文件。[http://vimeo.com/groups/freehd](http://vimeo.com/groups/freehd)似乎是一个可以找到免费视频片段的好地方。我找到了一个工业场地的片段。
- en: 'Place the movie file in the `assets` folder of the project, open the code editor,
    and start with including the `QuickTime.h` file:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 将电影文件放在项目的`assets`文件夹中，打开代码编辑器，并从包含`QuickTime.h`文件开始：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In case you are using the AppRewrite version of Cinder, you should know that
    QuickTime has been made as a separate block. Blocks are extensions of Cinder that
    you can add to your project when you need a specific extra functionality.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Cinder的AppRewrite版本，你应该知道QuickTime已经被作为一个单独的块。块是Cinder的扩展，当你需要特定的额外功能时，你可以将其添加到你的项目中。
- en: 'Next we have to declare some new variables. Since we have a surface and a texture
    already, we just need to declare a variable for the movie:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须声明一些新的变量。由于我们已经有了一个表面和一个纹理，我们只需要声明一个用于电影的变量：
- en: '[PRE16]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'With that done, let''s move to the `setup()` method part and load the movie
    by adding the following highlighted code:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 完成这些后，让我们转到`setup()`方法部分，通过添加以下高亮代码来加载电影：
- en: '[PRE17]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next we have to copy each frame to a surface and transform that surface to
    a texture so we can draw it on the screen. Let''s move to the `update()` method
    implementation to do that, remove all the previous code and add the following:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须将每一帧复制到一个表面，并将该表面转换为纹理，这样我们就可以在屏幕上绘制它。让我们转到`update()`方法实现，进行以下操作，删除所有之前的代码，并添加以下内容：
- en: '[PRE18]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'As loading the movie is an asynchronous process, we have to check if there
    is a surface before we pass it to the texture. In the same way we have to check
    if we have a texture before we draw it. Change the `gl::draw` part in the `draw()`
    method to the following:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 由于加载电影是一个异步过程，在我们将其传递给纹理之前，我们必须检查是否存在一个表面。同样，在绘制之前，我们必须检查是否有纹理。将`draw()`方法中的`gl::draw`部分更改为以下内容：
- en: '[PRE19]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We need to make sure that the movie is being drawn within the bounds of our
    application window. We make sure of that by passing the result of the `getWindowBounds()`
    function as the second parameter to the `gl::draw()` function.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要确保电影在应用程序窗口的边界内绘制。我们通过将`getWindowBounds()`函数的结果作为`gl::draw()`函数的第二个参数来确保这一点。
- en: 'Compile and run the project now. You should see the movie playing. Now we are
    going to combine this with the effect we made earlier. Find the place in the `update()`
    method between the `surface` and `texture` initialization (I left a comment `//
    add effects here` there). Add the following code there:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在编译并运行项目。你应该能看到电影正在播放。现在我们将结合之前制作的效果。在`update()`方法中找到`surface`和`texture`初始化之间的位置（我在那里留下了一个注释`//
    add effects here`）。在那里添加以下代码：
- en: '[PRE20]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'As you probably must have already guessed, now we have to declare the `addR`,
    `addG`, and `addB` variables and set their initial values as follows:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如你可能已经猜到的，现在我们必须声明`addR`、`addG`和`addB`变量，并按照以下方式设置它们的初始值：
- en: '[PRE21]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Compile and run the project. You should see the colors of the movie changing
    as shown in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 编译并运行项目。你应该能看到电影的颜色变化，如下面的截图所示：
- en: '![Applying effects to moving images](img/9564_07_04.jpg)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![将效果应用于动态图像](img/9564_07_04.jpg)'
- en: Experiment with the `addR`, `addG`, and `addB` values to see what kind of different
    effects you are able to get out of this.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 通过调整`addR`、`addG`和`addB`的值来实验，看看你能得到什么样的不同效果。
- en: Summary
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned the basic methods of applying effects to still and
    moving images. It is possible to do a lot more by studying the raw image processing
    algorithms and applying them as per-pixel operations. So if you do that and you
    are able to reproduce most of the image effects that one can find in Photoshop
    or Gimp—congratulations! You may also want to bring your knowledge to the next
    level by learning something about shaders and OpenGL Shading Language.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了将效果应用于静态和动态图像的基本方法。通过研究原始图像处理算法并将它们作为按像素操作应用，可以做更多的事情。所以如果你那样做，并且能够重现大多数在Photoshop或Gimp中可以找到的图像效果——恭喜！你也许还希望通过学习有关着色器和OpenGL着色语言的知识，将你的知识提升到下一个层次。
