- en: '*Chapter 7*: Gallery: Editing Virtual Objects'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第 7 章*：画廊：编辑虚拟对象'
- en: 'In this chapter, we will continue building the project we started previously
    in [*Chapter 6*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136), *Gallery: Building
    an AR App*, where we created an AR gallery that lets users place virtual framed
    photos on their real-world walls. In this chapter, we will build out more features
    related to interacting with and editing virtual objects that have already been
    added to a scene. Specifically, we''ll let users select an object for editing,
    including moving, resizing, deleting, and replacing the image in the picture frame.
    In the process, we''ll add new input actions, make use of Unity collision detection,
    and see more C# coding techniques using the Unity API.'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将继续构建我们在[*第 6 章*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136)中开始的项目，*画廊：构建
    AR 应用程序*，在那里我们创建了一个 AR 画廊，允许用户将虚拟相框照片放置在他们的现实世界墙壁上。在本章中，我们将构建更多与交互和编辑已添加到场景中的虚拟对象相关的功能。具体来说，我们将允许用户选择一个对象进行编辑，包括移动、调整大小、删除和替换相框中的图像。在这个过程中，我们将添加新的输入动作，利用
    Unity 碰撞检测，并看到更多使用 Unity API 的 C# 编码技术。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中，我们将涵盖以下主题：
- en: Detecting collisions to avoid intersecting objects
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 检测碰撞以避免相交对象
- en: Building an edit mode and edit menu UI
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建编辑模式和编辑菜单 UI
- en: Using a physics raycast to select an object
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用物理射线投射选择对象
- en: Adding touch input actions to drag to move and pinch to scale
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加触摸输入动作以拖动移动和捏合缩放
- en: C# coding and the Unity API, including collision hooks and vector geometry
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: C# 编码和 Unity API，包括碰撞钩子和矢量几何
- en: By the end of this chapter, you'll have a working AR application with many user
    interactions implemented.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将拥有一个具有许多用户交互功能的运行中的 AR 应用程序。
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To complete the project in this chapter, you will need Unity installed on your
    development computer, connected to a mobile device that supports augmented reality
    applications (see [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013),
    *Setting Up for AR Development*, for instructions). We will also assume you have
    created the *ARGallery* scene that we started in [*Chapter 6*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136),
    *Gallery: Building an AR App*, where you''ll also find additional dependencies
    detailed for you in the *Technical requirements* section. You can find that scene,
    as well as the one we will build in this chapter, in this book''s GitHub repository
    at [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成本章的项目，你需要在你的开发计算机上安装 Unity，并将其连接到一个支持增强现实应用程序的移动设备（有关说明，请参阅[*第 1 章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)，*为
    AR 开发设置*）。我们还将假设你已经创建了我们在[*第 6 章*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136)，*画廊：构建
    AR 应用程序*中开始创建的 *ARGallery* 场景。你将在 *技术要求* 部分找到有关该场景的详细信息。你可以在本书的 GitHub 存储库中找到该场景，以及我们将在本章中构建的场景，网址为
    [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation)。
- en: Note that in this book's repository, some of the scripts (and classes) for this
    chapter have been post-fixed with `07`, such as `AddPictureMode07`, to distinguish
    them from the corresponding scripts that were written for the previous chapter.
    In your own project, you can leave the un-post-fixed name as is when you edit
    the existing scripts described in this chapter.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在本书的存储库中，本章的一些脚本（和类）已被后缀加上 `07`，例如 `AddPictureMode07`，以区分它们与为上一章编写的相应脚本。在你自己的项目中，当你编辑本章中描述的现有脚本时，可以保留未后缀的名称。
- en: Creating an Edit mode
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建编辑模式
- en: 'To get started with this chapter, you should have the *ARGallery* scene open
    in Unity where we left off at the end of [*Chapter 6*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136),
    *Gallery: Building an AR App*. To recap, after launching the app, it starts by
    initializing the AR session and scanning to detect features in your real-world
    environment. Once the vertical planes (walls) have been detected, the main menu
    will be presented. Here, the user can tap the **Add** button, which opens an image
    select menu where the user can pick a photo to use. Then, the user will be prompted
    to tap on a trackable vertical plane to place the framed photo on. Once the photo
    is hanging on their wall, the user is returned to Main-mode.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 要开始本章，你应该在Unity中打开*ARGallery*场景，我们在[*第6章*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136)的末尾停止，*画廊：构建AR应用*。为了回顾，启动应用后，它首先初始化AR会话并扫描以检测真实世界环境中的特征。一旦检测到垂直平面（墙壁），主菜单将显示出来。在这里，用户可以轻触**添加**按钮，这将打开一个图像选择菜单，用户可以从中选择要使用的照片。然后，用户将被提示轻触可追踪的垂直平面以放置框架照片。一旦照片挂在他们的墙上，用户将返回主模式。
- en: In this chapter, we'll let users modify existing virtual framed photos that
    have been added to the scene. The first step is for the user to select an existing
    object to edit from Main-mode, which then activates EditPicture-mode for the selected
    object. When an object is selected and being edited, it should be highlighted
    so that it's apparent which object has been selected.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将允许用户修改已添加到场景中的现有虚拟框架照片。第一步是用户从主模式中选择要编辑的现有对象，然后激活所选对象的编辑图片模式。当对象被选中并进行编辑时，应该突出显示，以便明显知道哪个对象已被选中。
- en: Using the AR user framework that's been developed for this book, we will start
    by adding an EditPicture-mode UI to the scene. First, we'll create the edit menu
    user interface, including multiple buttons for various edit functions, and an
    Edit-mode controller script for managing it.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 使用为本书开发的AR用户框架，我们将首先向场景中添加一个EditPicture模式UI。首先，我们将创建编辑菜单用户界面，包括用于各种编辑功能的多个按钮，以及一个用于管理的Edit模式控制器脚本。
- en: Creating an edit menu UI
  id: totrans-16
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建编辑菜单UI
- en: 'To create the UI for editing a placed picture, we''ll make a new **EditPicture
    UI** panel. It''s simpler to duplicate the existing **Main UI** and adapt it.
    Perform the following steps:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建放置图片的UI，我们将创建一个新的**EditPicture UI**面板。复制现有的**Main UI**并适应它会更简单。执行以下步骤：
- en: In the `EditPicture UI`. Delete any child objects, including **Add Button**,
    by *right-clicking* **| Delete**.
  id: totrans-18
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`EditPicture UI`中，通过**右键单击**| **删除**删除任何子对象，包括**添加按钮**。
- en: Create a subpanel for the menu by *right-clicking* `Edit Menu`.
  id: totrans-19
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在`编辑菜单`上**右键单击**来创建菜单的子面板。
- en: Use `175`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`175`。
- en: I set my background `55`.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将我的背景设置为`55`。
- en: Select `layout`, and select **Horizontal Layout Group**.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`布局`，然后选择**水平布局组**。
- en: On the **Horizontal Layout Group** component, check the **Control Child Size
    | Width** and **Height** checkboxes. (Leave the others at their default values,
    **Use Child Scale** unchecked, and **Child Force Expand** checked). The **Edit
    Menu** panel looks like this in the **Inspector** window:![Figure 7.1 – The Edit
    Menu panel settings
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**水平布局组**组件上，勾选**控制子大小 | 宽度**和**高度**复选框。（将其他选项保留为默认值，**使用子缩放**未勾选，**子强制扩展**勾选）。在**检查器**窗口中，**编辑菜单**面板看起来如下所示：![图7.1
    – 编辑菜单面板设置
- en: '](img/Figure_7.01-EditMenu-inspector.jpg)'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01-EditMenu-inspector.jpg)'
- en: Figure 7.1 – The Edit Menu panel settings
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.1 – 编辑菜单面板设置
- en: Now, we will add four buttons to the menu. Begin by *right-clicking* `Replace
    Image Button`.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将向菜单中添加四个按钮。首先，在`替换图像按钮`上**右键单击**。
- en: Select its child text object, set the `Replace Image`, and set `48`.
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择其子文本对象，设置`替换图像`并将`48`。
- en: '*Right-click* the **Replace Image** button and select **Duplicate** (or *Ctrl
    + D*). Repeat this two more times so that there are four buttons in total.'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**替换图像**按钮上**右键单击**并选择**复制**（或*Ctrl + D*）。重复此操作两次，以便总共有四个按钮。
- en: Rename the buttons and change the text on the buttons so that they read as `Replace
    Frame`, `Remove Picture`, and `Done`.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重命名按钮并更改按钮上的文本，使其显示为`替换框架`、`移除图片`和`完成`。
- en: 'We may not use the **Replace Frame** feature soon, so disable that button by
    unchecking its **Interactable** checkbox in the **Button** component. The resulting
    menu will look as follows:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们可能不会很快使用**替换框架**功能，因此通过在**按钮**组件中取消勾选其**交互性**复选框来禁用该按钮。结果菜单将如下所示：
- en: '![Figure 7.2 – Edit Menu buttons'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.2 – 编辑菜单按钮](img/Figure_7.02-EditMenubuttons.jpg)'
- en: '](img/Figure_7.02-EditMenubuttons.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_7.01-EditMenu-inspector.jpg)'
- en: Figure 7.2 – Edit Menu buttons
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.2 – 编辑菜单按钮
- en: 'Add the panel to the UI Controller, as follows:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤将面板添加到 UI 控制器中：
- en: To add the panel to the UI Controller, in the **Hierarchy** window, select the
    **UI Canvas** object.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将面板添加到 UI 控制器中，在 **层次结构** 窗口中选择 **UI Canvas** 对象。
- en: In the **Inspector** window, at the bottom right of the **UI Controller** component,
    click the **+** button to add an item to the UI Panels dictionary.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 窗口中，在 **UI 控制器** 组件的右下角，点击 **+** 按钮向 UI 面板字典中添加一个条目。
- en: Enter `EditPicture` in the **Id** field.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Id** 字段中输入 `EditPicture`。
- en: Drag the **EditPicture UI** game object from the **Hierarchy** window onto the
    **Value** slot.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **EditPicture UI** 游戏对象从 **层次结构** 窗口拖动到 **值** 插槽。
- en: The next step is to create an **EditPicture** mode object and controller script.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是创建一个 **EditPicture** 模式对象和控制器脚本。
- en: Creating EditPicture mode
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 EditPicture 模式
- en: As you now know, our framework manages interaction modes by activating game
    objects under the Interaction Controller. Each mode has a control script that
    displays the UI for that mode and handles any user interactions until certain
    conditions are met; then, it transitions to a different mode. In terms of our
    EditPicture-mode, its control script will have a `currentPicture` variable that
    specifies which picture is being edited, a `DoneEditing` function that returns
    the user to Main-mode, among other features.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所知，我们的框架通过激活交互控制器下的游戏对象来管理交互模式。每个模式都有一个控制脚本，用于显示该模式的 UI 并处理任何用户交互，直到满足某些条件；然后，它将过渡到不同的模式。就我们的
    EditPicture 模式而言，其控制脚本将有一个 `currentPicture` 变量，用于指定正在编辑的图片，一个 `DoneEditing` 函数，用于将用户返回到主模式，以及其他功能。
- en: 'Create a new C# script named `EditPictureMode` and begin to write it, as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 脚本，命名为 `EditPictureMode` 并开始编写，如下所示：
- en: '[PRE0]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, we can add it to our **Interaction Controller** object, as follows:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将其添加到我们的 **交互控制器** 对象中，如下所示：
- en: In the `EditPicture Mode`.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `EditPicture Mode`。
- en: Drag the `EditPictureMode` script from the **Project** window onto the **EditPicture
    Mode** object, adding it as a component.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `EditPictureMode` 脚本从 **项目** 窗口拖动到 **EditPicture Mode** 对象上，将其添加为组件。
- en: Now, we'll add the mode to the Interaction Controller. In the **Hierarchy**
    window, select the **Interaction Controller** object.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将模式添加到交互控制器中。在 **层次结构** 窗口中，选择 **交互控制器** 对象。
- en: In the **Inspector** window, at the bottom right of the **Interaction Controller**
    component, click the **+** button to add an item to the **Interaction Modes**
    dictionary.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **检查器** 窗口中，在 **交互控制器** 组件的右下角，点击 **+** 按钮向 **交互模式** 字典中添加一个条目。
- en: Enter `EditPicture` in the **Id** field.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Id** 字段中输入 `EditPicture`。
- en: Drag the **EditPicture Mode** game object from the **Hierarchy** window onto
    the **Value** slot.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **EditPicture Mode** 游戏对象从 **层次结构** 窗口拖动到 **值** 插槽。
- en: With that, we have created an `UIController`. After this, we created an `EditPictureMode`
    script that is controlled by `InteractionController`.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，我们就创建了一个 `UIController`。在此之后，我们创建了一个由 `InteractionController` 控制的 `EditPictureMode`
    脚本。
- en: With this set up, the next thing we must do is enhance Main-mode so that it
    detects when the user taps on an existing **FramedPhoto** and can start EditPicture-mode
    for the selected object.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个设置，接下来我们必须增强主模式，使其能够检测用户是否点击了现有的 **FramedPhoto**，并可以为选定的对象启动 EditPicture
    模式。
- en: Selecting a picture to edit
  id: totrans-53
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择要编辑的图片
- en: While in Main-mode, the user should be able to tap on an existing picture to
    edit it. Utilizing the Unity Input System, we will add a new `SelectObject` input
    action. Then, we'll have the `MainMode` script listen for that action's messages,
    find which picture was tapped using a `Raycast`, and enable Edit-mode on that
    picture. Let's get started!
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 当处于主模式时，用户应该能够点击现有的图片进行编辑。利用 Unity 输入系统，我们将添加一个新的 `SelectObject` 输入动作。然后，我们将让
    `MainMode` 脚本监听该动作的消息，使用 `Raycast` 找到被点击的图片，并启用该图片的编辑模式。让我们开始吧！
- en: Defining a SelectObject input action
  id: totrans-55
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 SelectObject 输入动作
- en: 'We will start by adding a `SelectObject` action to the **AR Input Actions**
    asset by performing the following steps:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过以下步骤将 `SelectObject` 动作添加到 **AR 输入动作** 资产中：
- en: In the `Assets/Inputs/` folder) to open it for editing (alternatively, use its
    **Edit Asset** button).
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Assets/Inputs/` 文件夹中打开它进行编辑（或者使用其 **编辑资产** 按钮）。
- en: In the middle `SelectObject`.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中间的 `SelectObject`。
- en: In the rightmost **Properties** section, select **Action Type | Value** and
    **Control Type | Vector 2**.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最右侧的 **属性** 部分，选择 **动作类型 | 值** 和 **控制类型 | 向量 2**。
- en: In the middle **Actions** section, select the **<No Binding>** child. Then,
    in the **Properties** section, select **Path | Touchscreen | Primary Touch | Position**
    to bind this action to a primary screen touch.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中间的**动作**部分，选择**<无绑定>**子项。然后，在**属性**部分，选择**路径 | 触摸屏 | 主要触摸 | 位置**以将此动作绑定到主屏幕触摸。
- en: Press **Save Asset** (unless **Auto-Save** is enabled).
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按**保存资产**（除非已启用**自动保存**）。
- en: 'The updated **AR Input Actions** asset is shown in the following screenshot:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 更新的**AR输入动作**资产如图所示：
- en: '![Figure 7.3 – AR Input Actions asset with the SelectObject action added'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.3 – 添加了SelectObject动作的AR输入动作资产'
- en: '](img/Figure_7.03-imputaction-selectobject.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_7.03-imputaction-selectobject.jpg]'
- en: Figure 7.3 – AR Input Actions asset with the SelectObject action added
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.3 – 添加了SelectObject动作的AR输入动作资产
- en: Although we're defining this action with the same touchscreen binding that we
    used for the `PlaceObject` action we created earlier (**Touchscreen Primary Position**),
    it serves a somewhat different purpose (tap-to-select versus tap-to-place). For
    example, perhaps, in the future, if you decide to use a *double-tap* for selecting
    an item instead of a single tap, you can simply change its input action.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们使用与之前创建的`PlaceObject`动作相同的触摸屏绑定来定义此动作（**触摸屏主要位置**），但它具有不同的用途（点击选择与点击放置）。例如，也许在未来，如果你决定使用**双击**来选择项目而不是单击，你可以简单地更改其输入动作。
- en: Now, we can add the code for this action.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加这个动作的代码。
- en: Replacing the MainMode script
  id: totrans-68
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换MainMode脚本
- en: 'First, because we''re deviating from the default `MainMode` script provided
    in the `ARFramework` template, we should make a new, separate script for this
    project. Perform the following steps to copy and edit the new `GalleryMainMode`
    script:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，因为我们正在偏离`ARFramework`模板中提供的默认`MainMode`脚本，我们应该为这个项目创建一个新的、独立的脚本。执行以下步骤以复制和编辑新的`GalleryMainMode`脚本：
- en: In the `Project` window's `Scripts/` folder, select the **MainMode** script.
    Then, from the main menu bar, select **Edit | Duplicate**.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在“项目”窗口的“脚本/”文件夹中，选择**MainMode**脚本。然后，从主菜单栏中选择**编辑 | 复制**。
- en: Rename the new file `GalleryMainMode`.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新文件重命名为`GalleryMainMode`。
- en: You'll see a namespace error in the `MainMode` class.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会在`MainMode`类中看到一个命名空间错误。
- en: 'Open `GalleryMainMode`, as highlighted here:'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 打开`GalleryMainMode`，如图所示：
- en: '[PRE1]'
  id: totrans-74
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the script. Then, back in Unity, in the **Hierarchy** window, select the
    **Main Mode** game object (under **Interaction Controller**).
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。然后，在Unity中，在**层次**窗口中，选择**Main Mode**游戏对象（在**交互控制器**下）。
- en: Drag the **GalleryMainMode** script onto the **Main Mode** object, adding it
    as a new component.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**GalleryMainMode**脚本拖放到**Main Mode**对象上，添加为新组件。
- en: Remove the previous **Main Mode** component from the **Main Mode** object.
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Main Mode**对象中移除之前的**Main Mode**组件。
- en: Now, we're ready to enhance the behavior of Main-mode.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备好增强主模式的行为。
- en: Selecting an object from Main-mode
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 选择主模式下的对象
- en: When the user taps the screen, the `GalleryMainMode` script will get the touch
    position and use a Raycast to determine whether one of the `PlacedPhoto` objects
    was selected. If so, it will enable **EditPicture** mode on that picture.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户点击屏幕时，`GalleryMainMode`脚本将获取触摸位置并使用Raycast来确定是否选择了`PlacedPhoto`对象之一。如果是，它将启用该图片的**编辑图片**模式。
- en: We have seen Raycasts previously in our tap-to-place scripts, including `AddPictureMode`.
    In that case, our scripts used the `Physics.Raycast` function ([https://docs.unity3d.com/ScriptReference/Physics.Raycast.html](https://docs.unity3d.com/ScriptReference/Physics.Raycast.html)).
    As part of the Unity Physics system, it requires the raycast-able object to have
    a **Collider** (which **FramedPhoto** does, and I'll show you soon).
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前在点击放置脚本中看到过Raycasts，包括`AddPictureMode`。在那个例子中，我们的脚本使用了`Physics.Raycast`函数([https://docs.unity3d.com/ScriptReference/Physics.Raycast.html](https://docs.unity3d.com/ScriptReference/Physics.Raycast.html))。作为Unity物理系统的一部分，它要求射线投射对象具有**Collider**（**FramedPhoto**具有，我很快会向你展示）。
- en: Also, we will be using the AR Camera's `ScreenPointToRay` function to define
    the 3D ray that corresponds to the touch position that we're going to Raycast
    into the scene.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们还将使用AR摄像头的`ScreenPointToRay`函数来定义与将要进行Raycast的触摸位置相对应的3D射线。
- en: 'To add this, open the `GalleryMainMode` script for editing and follow these
    steps:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加此功能，打开`GalleryMainMode`脚本进行编辑，并按照以下步骤操作：
- en: 'We''re going to listen for Input System events, so to begin, we need to add
    a `using` statement for that namespace. Ensure the following line is at the top
    of the file:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将监听输入系统事件，因此首先需要为该命名空间添加一个`using`语句。确保以下行位于文件顶部：
- en: '[PRE2]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'We need a reference to tell `EditPictureMode` which object to edit. Add it
    to the top of the class, as follows:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个引用来告诉`EditPictureMode`要编辑哪个对象。将其添加到类的顶部，如下所示：
- en: '[PRE3]'
  id: totrans-87
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We''re going to be using `Camera.main` shortcut. (This requires the AR Camera
    to be tagged as `MainCamera`, which should be done from the scene template.) Add
    a private variable at the top of the class and initialize it using `Start`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用`Camera.main`快捷方式。（这要求AR相机被标记为`MainCamera`，这应该从场景模板中完成。）在类的顶部添加一个私有变量，并使用`Start`进行初始化：
- en: '[PRE4]'
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now for the meat of our task – add the following `OnSelectObject` and `FindObjectToEdit`
    functions:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们来处理任务的主体部分 - 添加以下`OnSelectObject`和`FindObjectToEdit`函数：
- en: '[PRE5]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Let's walk through this code together. The `OnSelectObject` function is automatically
    called when the `SelectObject` Input System action is used (the `On` prefix is
    a standard Unity convention for event interfaces). It grabs `Vector2 touchPosition`
    from the input value and passes it to our private `FindObjectToEdit` function.
    (You don't need to separate this into two functions, but I did for clarity.)
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们一起分析这段代码。当使用`SelectObject`输入系统动作时，`OnSelectObject`函数会自动调用（`On`前缀是Unity中事件接口的标准约定）。它从输入值中获取`Vector2
    touchPosition`并将其传递给我们的私有`FindObjectToEdit`函数。（您不需要将其分成两个函数，但我这样做是为了清晰。）
- en: '`FindObjectToEdit` gets the 3D ray corresponding to the touch position by calling
    `camera.ScreenPointToRay`. This is passed to `Physics.Raycast` to find an object
    in the scene that intersects with the ray. Rather than casting to every possible
    object, we''ll limit it to ones on a layer named `PlacedObjects` using its `layermask`.
    (For this, we need to make sure **FramedPhoto** is assigned to this layer, which
    we''ll do soon.)'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindObjectToEdit`通过调用`camera.ScreenPointToRay`获取与触摸位置对应的3D射线。将其传递给`Physics.Raycast`以在场景中找到一个与射线相交的对象。我们不会对每个可能的对象进行投射，而是将其限制在名为`PlacedObjects`的图层上，使用其`layermask`。（为此，我们需要确保**FramedPhoto**被分配到这个图层，我们很快就会这样做。）'
- en: Information – Layer Name, Layer Number, and Layermask
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 信息 - 图层名称、图层编号和图层遮罩
- en: A `LayerMask.NameToLayer`) and shifting one bit to the left that many times.
    To manage the layers in your project and see what name has been assigned to each
    layer number, click the **Layers** button in the top-right corner of the Editor.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将`LayerMask.NameToLayer`左移多次来管理项目中的图层并查看每个图层编号分配了什么名称。要管理项目中的图层并查看每个图层编号分配了什么名称，请点击编辑器右上角的**图层**按钮。
- en: If the raycast gets a hit, we must grab a reference to the `FramedPhoto` component
    in the prefab and pass it to the `EditPictureMode` component. Then, the app will
    transition to EditPicture-mode.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 如果射线投射命中，我们必须获取预制体中`FramedPhoto`组件的引用并将其传递给`EditPictureMode`组件。然后，应用将过渡到编辑图片模式。
- en: 'Save the script. Now, let''s fix the housekeeping things on our game objects
    that I mentioned: set the camera tag to `MainCamera`, set the `PlacedObjects`
    layer, and ensure **FramedPhoto** has a collider component. In Unity, do the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本。现在，让我们修复我提到的游戏对象上的家务事：将相机标签设置为`MainCamera`，设置`PlacedObjects`图层，并确保**FramedPhoto**具有碰撞器组件。在Unity中，执行以下操作：
- en: In the **Hierarchy** window, with the **Main Mode** game object selected, drag
    the **EditPicture Mode** object from the **Hierarchy** window into the **Inspector**
    window and drop it onto the **Gallery Main Mode | Edit Mode** slot.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**主模式**游戏对象，将**编辑图片模式**对象从**层次结构**窗口拖动到**检查器**窗口，并将其放置在**画廊主模式
    | 编辑模式**槽中。
- en: In the scene **Hierarchy**, unfold **AR Session Origin** and select its child
    **AR Camera**. In the top-left position of the **Inspector** window, verify that
    **Tag** (atop the **Inspector** window) is set to **MainCamera**. If not, set
    it now.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景**层次结构**中，展开**AR会话原点**并选择其子**AR Camera**。在**检查器**窗口的左上角，验证**标签**（位于**检查器**窗口顶部）是否设置为**MainCamera**。如果不是，现在设置它。
- en: Next, open the **FramedPhoto** prefab for editing by *double-clicking* the asset
    in the **Project** window.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，通过在**项目**窗口中双击资产来打开**FramedPhoto**预制体进行编辑。
- en: With its root `PlacedObjects`.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其根`PlacedObjects`。
- en: If the layer named `PlacedObjects` doesn't exist, select `PlacedObjects` to
    one of the empty slots. In the `PlacedObjects`.
  id: totrans-102
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果名为`PlacedObjects`的图层不存在，选择`PlacedObjects`并将其分配给一个空槽。在`PlacedObjects`中。
- en: You will then be prompted with the question **Do you want to set layer to PlacedObjects
    for all child objects as well?**. Click **Yes, Change Children**.
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你将随后被提示问题**你想要将所有子对象层设置为PlacedObjects吗？**。点击**是，更改子对象**。
- en: While we're here, let's also verify that the prefab has a collider, as required
    for `Physics.Raycast`. If you recall, when we constructed the prefab, we started
    with an **Empty** game object for the root and added another **Empty** child for
    **AspectScaler**. Then, we added a 3D Cube for the **Frame** object. Click this
    **Frame** object.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们在这里时，让我们也验证预制件是否有一个碰撞器，这是`Physics.Raycast`所必需的。如果你还记得，当我们构建预制件时，我们从一个**空**的游戏对象作为根开始，并为**AspectScaler**添加了另一个**空**子对象。然后，我们为**框架**对象添加了一个3D立方体。点击这个**框架**对象。
- en: In the **Inspector** window, you will see that the **Frame** object already
    has a **Box Collider**. Perfect. Note that if you press its **Edit Collider**
    button, you can see (and edit) the collider's shape in the **Scene** window, as
    shown in the following screenshot, where its edges are outlined and there are
    little handles to move the faces. But there's no need for us to change it here:![Figure
    7.4 – Editing the Box Collider of the Frame object
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，你会看到**框架**对象已经有一个**盒子碰撞器**。完美。注意，如果你按下它的**编辑碰撞器**按钮，你可以在**场景**窗口中看到（并编辑）碰撞器的形状，如图所示，其边缘被勾勒出来，并且有一些小把手可以移动面。但在这里我们不需要改变它：![图7.4
    – 编辑框架对象的盒子碰撞器
- en: '](img/Figure_7.04-FrameBoxCollider.jpg)'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.04-FrameBoxCollider.jpg)'
- en: Figure 7.4 – Editing the Box Collider of the Frame object
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.4 – 编辑框架对象的盒子碰撞器
- en: Save the prefab and exit the prefab editor to get back to the Scene hierarchy.
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存预制件并退出预制件编辑器回到场景层次结构。
- en: If you were to **Build and Run** the scene now, and then add a picture to a
    wall, when you tap on that picture, it should hide the main menu and show the
    edit menu. Now, we need a way to get back from Edit-mode to Main-mode. Let's wire
    up the **Done** button.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在要**构建并运行**场景，然后向墙上添加一张图片，当你点击那张图片时，它应该隐藏主菜单并显示编辑菜单。现在，我们需要一种方法从编辑模式回到主模式。让我们连接**完成**按钮。
- en: Wiring the Done edit button
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接完成编辑按钮
- en: 'In this section, we will set up the `EnableMode` in `InteractionController`.
    Follow these steps:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将设置`InteractionController`中的`EnableMode`。按照以下步骤操作：
- en: In the **Hierarchy** window, select the **Done** button, which should be located
    under **UI Canvas | EditPicture UI | Edit Menu**.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**完成**按钮，它应该位于**UI Canvas | EditPicture UI | Edit Menu**下。
- en: In the **Inspector** window, click the **+** button on the bottom right of the
    **Button | OnClick** area to add a new event action.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，点击**按钮 | OnClick**区域右下角的**+**按钮添加一个新的事件动作。
- en: Drag the **Interaction Controller** object from the **Hierarchy** window and
    drop it onto the **Object** slot of the **OnClick** action.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中将**Interaction Controller**对象拖动到**OnClick**动作的**对象**槽中。
- en: In the function select list, choose **InteractionController | EnableMode**.
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在函数选择列表中，选择**InteractionController | EnableMode**。
- en: Type `Main` into the mode string parameter slot.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在模式字符串参数槽中输入`Main`。
- en: Now, if you **Build and Run** the scene where you have a picture instantiated
    in the scene and tap the picture, you'll switch to Edit-mode and see the edit
    menu. Tap the **Done** button to get back to Main-mode.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你**构建并运行**的场景中有一个图片实例化，并点击图片，你会切换到编辑模式并看到编辑菜单。点击**完成**按钮回到主模式。
- en: This is progress. But if there's more than one picture on your wall, it's not
    obvious which one is currently being edited. We need to highlight the currently
    selected picture.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 这是个进步。但如果你的墙上有多张图片，当前正在编辑的是哪一张并不明显。我们需要突出显示当前选中的图片。
- en: Highlighting the selected picture
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突出显示选中的图片
- en: 'There are many ways to highlight objects in Unity to indicate that an object
    has been selected by the user. Often, you''ll find that a custom shader will do
    the trick (there are many on the Asset Store). The decision comes down to what
    "look" you want. Do you want to change the selected object''s color tint, draw
    a wireframe outline, or create some other effect? Instead of doing this and to
    keep things easy, I''ll just introduce a "highlight" game object in the **FramedPhoto**
    prefab as a thin yellow box that extends from the edges of the frame. Let''s make
    that now:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中有许多方法可以突出显示对象，以指示用户已选择该对象。通常，你会发现自定义着色器可以做到这一点（在资源商店中有很多）。决策取决于你想要的“外观”。你想要改变所选对象的着色，绘制线框轮廓，还是创建其他效果？为了保持简单，我将只介绍一个“高亮”游戏对象，在**FramedPhoto**预制件中作为一个从框架边缘延伸的细黄色框。让我们现在就来做这个：
- en: Open the **FramedPhoto** prefab for editing by *double-clicking* it in the **Project**
    window.
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在**项目**窗口中**双击**它来编辑**FramedPhoto**预制件。
- en: In the `Highlight`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Highlight`中。
- en: Set its `1.05, 1.05, 0.005`) so that it is thin and extends past the edges of
    the frame.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其`1.05, 1.05, 0.005`)，使其变薄并延伸到框架的边缘。
- en: Set its `0, 0, -0.025`).
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置其`0, 0, -0.025`）。
- en: Create a yellow material. In the `Materials/` folder (create one if needed)
    and select `Highlight Material`.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个黄色材质。在`Materials/`文件夹中（如果需要则创建一个）并选择`Highlight Material`。
- en: Set **Highlight Material | Shader | Universal Render Pipeline | Unlit**.
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置**高亮材质 | 着色器 | 通用渲染管线 | 无光照**。
- en: Set its **Base Map** color (using the color swatch) to yellow.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将其**基础图**颜色（使用颜色样本）设置为黄色。
- en: 'Drag **Highlight Material** onto the **Highlight** game object. The **Scene**
    view should now look as follows:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**高亮材质**拖放到**高亮**游戏对象上。现在**场景**视图应该如下所示：
- en: '![Figure 7.5 – FramedPhoto with highlight'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.5 – 带有高亮的框架照片]'
- en: '](img/Figure_7.05-FameHighlight.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '![图7.05 – 带有高亮的框架照片](img/Figure_7.05-FameHighlight.jpg)'
- en: Figure 7.5 – FramedPhoto with highlight
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.5 – 带有高亮的框架照片
- en: 'We can now control this from the `FramedPhoto` script. You may want the highlight
    the picture for different reasons, but for this project, I''ve decided that when
    the object is selected and highlighted, that means it is being edited. So, we
    can toggle the highlight when making the object editable. Open the script in your
    editor and make the following changes:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以从`FramedPhoto`脚本中控制这个。你可能出于不同的原因想要突出显示图片，但在这个项目中，我决定当对象被选择并突出显示时，这意味着它正在被编辑。因此，我们可以在使对象可编辑时切换高亮。在你的编辑器中打开脚本并做出以下更改：
- en: 'Declare a variable for `highlightObject`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`highlightObject`变量：
- en: '[PRE6]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Add a function to toggle the highlight:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个切换高亮的函数：
- en: '[PRE7]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Ensure the picture isn''t highlighted at the beginning:'
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保图片在开始时不会被突出显示：
- en: '[PRE8]'
  id: totrans-138
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Add a `BeingEdited` function. This will be called when the object is being
    edited. It''ll highlight the object and enable other editing behavior later. Likewise,
    when we stop editing and pass a `false` value, the object will be un-highlighted:'
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`BeingEdited`函数。当对象正在编辑时，将调用此函数。它将突出显示对象，并在稍后启用其他编辑行为。同样，当我们停止编辑并传递`false`值时，对象将被取消突出显示：
- en: '[PRE9]'
  id: totrans-140
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Save the script. In Unity, select the root **FramedPhoto** object.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。在Unity中，选择根**FramedPhoto**对象。
- en: Drag the **Highlight** object from the **Hierarchy** window onto the **Framed
    Photo | Highlight Object** slot.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**高亮**对象从**层次结构**窗口拖动到**Framed Photo | 高亮对象**槽中。
- en: 'This is great! Now, we can update `EditPictureMode` to tell the picture when
    it''s being edited or not. Open the `EditPictureMode` script and make the following
    edits:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这很棒！现在，我们可以更新`EditPictureMode`来告诉图片它是否正在被编辑。打开`EditPictureMode`脚本并做出以下修改：
- en: 'Add the `BeingEdited` call to `OnEnable`:'
  id: totrans-144
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BeingEdited`调用添加到`OnEnable`中：
- en: '[PRE10]'
  id: totrans-145
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Also, add the `BeingEdited` call to `OnDisable` for when it''s not being edited;
    that is, when Edit-mode has been exited:'
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，当它不是正在编辑时（即退出编辑模式时），将`BeingEdited`调用添加到`OnDisable`中：
- en: '[PRE11]'
  id: totrans-147
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Notice that although we would never intentionally enter Edit-mode without `currentPicture`
    defined, I've added null checks in case the mode is activated or deactivated during
    the app startup or teardown sequences.
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，尽管我们绝不会故意在没有定义`currentPicture`的情况下进入编辑模式，但我已经添加了空值检查，以防在应用程序启动或关闭序列中激活或关闭该模式。
- en: If you play the scene now and add a picture, when you tap the picture via Main-mode,
    Edit-mode will become enabled, and the picture will be highlighted. When you exit
    back to Main-mode, the picture will be un-highlighted.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在播放场景并添加一张图片，当你通过主模式触摸图片时，编辑模式将变为启用，图片将被突出显示。当你退出到主模式时，图片将被取消突出显示。
- en: Let's keep going. Suppose you have multiple pictures on your walls. Currently,
    when you're editing one picture and you want to edit a different one, you must
    press `EditMode` script.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续。假设你在墙上有多张图片。目前，当你正在编辑一张图片，并想要编辑另一张时，你必须按下`EditMode`脚本。
- en: Selecting an object from Edit mode
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 从编辑模式中选择对象
- en: 'When in Edit-mode for one picture, to let the user choose a different picture
    without exiting Edit-mode, we can use the same `EditPictureMode` script for editing
    and make the following changes:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当在一个图片的编辑模式下时，为了让用户在不退出编辑模式的情况下选择另一张图片，我们可以使用相同的`EditPictureMode`脚本进行编辑，并做出以下更改：
- en: 'We''re going to listen for Input System events, so to begin, we need to add
    a `using` statement for that namespace. Ensure the following line is at the top
    of the file:'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将监听输入系统事件，因此首先，我们需要为该命名空间添加一个`using`语句。确保以下行位于文件顶部：
- en: '[PRE12]'
  id: totrans-154
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Add a private `camera` variable at the top of the class and initialize it in
    `Start`:'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部添加一个私有的`camera`变量，并在`Start`方法中初始化它：
- en: '[PRE13]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `OnSelectObject` action listener will call `FindObjectToEdit`. Like in
    `GalleryMainMode`, it does a Raycast on the `PlacedObjects` layer. But now, we
    must check whether it has hit an object other than the current picture. If so,
    we must stop editing `currentPicture` and make the new selection current:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnSelectObject`动作监听器将调用`FindObjectToEdit`。就像在`GalleryMainMode`中一样，它对`PlacedObjects`层进行Raycast。但现在，我们必须检查它是否击中了除当前图片之外的对象。如果是这样，我们必须停止编辑`currentPicture`并使新选择成为当前选择：'
- en: '[PRE14]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To summarize, when you have more than one `currentPicture` object being edited.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，当你有多个正在编辑的`currentPicture`对象时。
- en: 'Here''s another problem: if you''ve been playing with the project, you may
    have noticed that you can place pictures on top of one another, or actually, *inside*
    one another, as they do not seem to have any physical presence! Oops. Let''s fix
    this.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个问题：如果你一直在玩这个项目，你可能已经注意到你可以将图片放在彼此的上面，或者实际上，*在里面*，因为它们似乎没有任何物理存在！哎呀。让我们修复这个问题。
- en: Avoiding intersecting objects
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免相交的对象
- en: In Unity, to specify that an object should participate in the Unity Physics
    system, you must add a **Rigidbody** component to the GameObject. Adding a Rigidbody
    gives an object mass, velocity, collision detection, and other physical properties.
    We can use this to prevent objects from intersecting. In many games and XR apps,
    Rigidbody is important for applying motion forces to objects to let them bounce
    when they collide, for example.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，为了指定一个对象应参与Unity物理系统，你必须向GameObject添加一个**Rigidbody**组件。添加Rigidbody会给对象质量、速度、碰撞检测和其他物理属性。我们可以使用它来防止对象相交。在许多游戏和XR应用中，Rigidbody对于将运动力应用到对象上以使它们在碰撞时弹跳非常重要，例如。
- en: In our project, if a picture collides with another picture, it should simply
    move out of the way so that they're never intersecting. But it should also stay
    flush with the wall plane. Although a Rigidbody allows you to constrain movement
    along any of the **X**, **Y**, and **Z** directions, these are the orthogonal
    world space planes, not the arbitrary angled wall plane. In the end, I decided
    to position the picture manually when a collision is detected rather than using
    physics forces. My solution is to constrain the position (and rotation) of all
    the pictures so that physics forces won't move them. Then, I can use the collision
    as a trigger to manually move the picture out of the way.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，如果一张图片与另一张图片发生碰撞，它应该简单地让开，这样它们就永远不会相交。但它也应该与墙面保持齐平。尽管Rigidbody允许你沿**X**、**Y**和**Z**方向中的任何一个方向约束运动，但这些是正交的世界空间平面，而不是任意角度的墙面平面。最终，我决定在检测到碰撞时手动定位图片，而不是使用物理力。我的解决方案是约束所有图片的位置（和旋转），这样物理力就不会移动它们。然后，我可以用碰撞作为触发器，手动将图片移开。
- en: Information – Collision Versus Trigger Detection
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 信息 - 碰撞与触发检测对比
- en: When two GameObjects with `OnCollisionEnter`, `OnCollisionStay`, and `OnCollisionExit`
    to hook into these events.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个GameObject具有`OnCollisionEnter`、`OnCollisionStay`和`OnCollisionExit`以挂钩到这些事件时。
- en: However, you can completely disable Unity applying physical forces by marking
    a Collider as `OnTriggerEnter`, `OnTriggerStay`, and `OnTriggerExit` to hook into
    these events.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可以通过将Collider标记为`OnTriggerEnter`、`OnTriggerStay`和`OnTriggerExit`来完全禁用Unity应用物理力，以挂钩到这些事件。
- en: 'To add collision detection to the **FramedPhoto** prefab, follow these steps:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 要将碰撞检测添加到**FramedPhoto**预制体，请按照以下步骤操作：
- en: In the **Project** window, locate and *double-click* on the **FramedPhoto**
    prefab to open it for editing.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**窗口中，找到并**双击****FramedPhoto**预制体以打开它进行编辑。
- en: Ensure you have selected the root **FramedPhoto** object in the **Hierarchy**
    window.
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保你在**层次结构**窗口中选择了根**框架照片**对象。
- en: In the `rigidbody`, and add a **Rigidbody** to the object.
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`刚体`中，并为对象添加一个**刚体**。
- en: 'Unfold the **Constraints** properties and check all six boxes; that is, **Freeze
    Position: X, Y, Z** and **Freeze Rotation: X, Y, Z**.'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开**约束**属性并检查所有六个框；即**冻结位置：X, Y, Z**和**冻结旋转：X, Y, Z**。
- en: Uncheck its **Use Gravity** checkbox. (This is not necessary since we set constraints,
    but I like to be clear about this anyway.)
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消勾选其**使用重力**复选框。（这并不是必要的，因为我们已经设置了约束，但我还是喜欢明确这一点。）
- en: We need a **Collider**. As we've seen, there is one on the **Frame** child object.
    So, select the **Frame** game object.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要一个**碰撞体**。正如我们所见，**框架**子对象上有一个。因此，选择**框架**游戏对象。
- en: In the **Inspector** window, in its **Box Collider** component, check the **Is
    Trigger** checkbox.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，在其**盒子碰撞体**组件中，勾选**是触发器**复选框。
- en: To avoid any problems, disable (or remove) other colliders in the prefab. Namely,
    remove **Mesh Collider** from **Image** and **Box Collider** from **Highlight**.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了避免任何问题，禁用（或删除）预制件中的其他碰撞体。具体来说，从**图像**中删除**网格碰撞体**，从**高亮**中删除**盒子碰撞体**。
- en: Now, we can handle the collision trigger and move the picture out of the way
    when another picture is in the same space. We just want to make sure it moves
    along the wall. We can make use of the fact that the wall plane's normal vector
    (the vector that's perpendicular to the surface of the plane) is also the forward
    direction vector of our picture prefab since we originally placed it there. Also,
    we only want to consider collisions with objects on the placed object plane (for
    example, not the AR tracked plane objects).
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以处理碰撞触发器，并在另一张图片在同一空间时将其移开。我们只想确保它沿着墙壁移动。我们可以利用墙壁平面的法向量（垂直于平面表面的向量）也是我们图片预制件的向前方向向量的事实，因为我们最初就是将其放置那里的。此外，我们只想考虑与放置对象平面上的对象（例如，不是AR跟踪平面对象）的碰撞。
- en: My algorithm determines the distance between this picture and the other intersecting
    picture, in 3D. Then, it finds the direction to move this picture in by projecting
    the distance vector onto the wall plane and scaling it. The picture will continue
    moving away from the other frames until it is no longer intersecting.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我的算法确定这张图片与其他相交图片之间的距离，在3D中。然后，它通过将距离向量投影到墙壁平面上并缩放它来找到移动这张图片的方向。图片将继续移动，直到不再与框架相交。
- en: 'Let''s write the code for this. Open the `FramedPhoto` script for editing and
    follow these steps:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写这段代码。打开`FramedPhoto`脚本进行编辑并按照以下步骤操作：
- en: 'Begin by adding a reference to the `collider` and `layer` numbers at the top
    of the class, as follows:'
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在类的顶部添加对`collider`和`layer`编号的引用，如下所示：
- en: '[PRE15]'
  id: totrans-180
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Initialize the `layer` number from its name. It''s good to initialize this
    ahead of time because `OnTriggerStay` may be called every frame:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从其名称初始化`层`编号。提前初始化这很好，因为`OnTriggerStay`可能会每帧被调用：
- en: '[PRE16]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'We''ll use `OnTriggerStay` here, which is called with each update while the
    object is colliding with another object, as follows:'
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将在这里使用`OnTriggerStay`，它在对象与另一个对象碰撞时每次更新时被调用，如下所示：
- en: '[PRE17]'
  id: totrans-184
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Save the script. In Unity, drag the **Frame** object (which has a Box Collider)
    from the **Hierarchy** window onto the **Framed Photo | Bounding Collider** slot.
    The **Framed Photo** component now looks as follows:![Figure 7.6 – Framed Photo
    component properties, including Bounding Collider
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。在Unity中，从**层次结构**窗口中将**框架**对象（具有盒子碰撞体）拖动到**框架照片 | 边界碰撞体**槽中。**框架照片**组件现在看起来如下：![图7.6
    – 框架照片组件属性，包括边界碰撞体
- en: '](img/Figure_7.06-framedphoto-bounding.jpg)'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_7.06-framedphoto-bounding.jpg)'
- en: Figure 7.6 – Framed Photo component properties, including Bounding Collider
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图7.6 – 框架照片组件属性，包括边界碰撞体
- en: Save the prefab and return to the scene **hierarchy**.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存预制件并返回到场景**层次结构**。
- en: When you play the scene now, place a picture on a wall, and then place another
    picture in the same space, the new picture will move away from the first one until
    they're no longer colliding.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 当你现在播放场景时，将一张图片放在墙上，然后在同一空间放置另一张图片，新图片将远离第一张图片，直到它们不再碰撞。
- en: Now that we can have many pictures on our walls, you might want to learn how
    to remove one from the scene. We'll look at this in the next section.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以在墙上放置许多图片，你可能想学习如何从场景中删除一张图片。我们将在下一节中探讨这个问题。
- en: Deleting a picture
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 删除图片
- en: 'Deleting the picture that is being edited is straightforward. We just need
    to destroy the `currentPicture` GameObject and go back to Main-mode. Perform the
    following steps:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 删除正在编辑的图片很简单。我们只需要销毁`currentPicture` GameObject并返回Main-mode。执行以下步骤：
- en: 'Open the `EditPictureMode` script and add the following function:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`EditPictureMode`脚本并添加以下函数：
- en: '[PRE18]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Save the script.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: In Unity, in the **Hierarchy** window, select **Remove Button** (located under
    **UI Canvas | EditPicture UI | Edit Menu**).
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，在**Hierarchy**窗口中，选择**Remove Button**（位于**UI Canvas | EditPicture UI
    | Edit Menu**下）。
- en: In the **Inspector**, click the **+** button at the bottom right of the **Button
    | OnClick** area.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Inspector**中，点击**Button | OnClick**区域右下角的**+**按钮。
- en: Drag the **EditPicture Mode** object from the **Hierarchy** window onto the
    **OnClick Object** slot.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**EditPicture Mode**对象从**Hierarchy**窗口拖到**OnClick Object**槽中。
- en: From the function selection, choose **EditPictureMode | DeletePicture**.
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从函数选择中，选择**EditPictureMode | DeletePicture**。
- en: When you play the scene, create a picture, go into EditPicture-mode, and then
    tap the **Remove Picture** button, the picture will be deleted from the scene,
    and you will be back in Main-mode.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当您播放场景时，创建一个图片，进入EditPicture-mode，然后点击**Remove Picture**按钮，图片将从场景中删除，您将回到Main-mode。
- en: We now have two of the Edit menu buttons operating – **Remove Picture** and
    **Done**. Now, let's add the feature that lets you change the picture in an existing
    **FramedPhoto** from the **Image Select** menu panel.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有两个编辑菜单按钮正在运行——**Remove Picture**和**Done**。现在，让我们添加一个功能，允许您从**Image Select**菜单面板更改现有**FramedPhoto**中的图片。
- en: Replacing the picture's image
  id: totrans-202
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 替换图片的图像
- en: When you add a picture from the Main menu, the Select Image menu is displayed.
    From here, you can pick a picture. At this point, you will be prompted to add
    a **FramedPhoto** to the scene using the image you selected. We implemented this
    by adding a separate **SelectImage Mode**. We now want to make that mode serve
    two purposes. It's called from Main-mode when you're adding a new, framed photo
    to the scene, and it's called from EditPicture-mode when you want to replace the
    image of an existing framed photo that's already in the scene. This requires us
    to refactor the code.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 当您从主菜单添加图片时，将显示选择图片菜单。从这里，您可以挑选一张图片。此时，您将被提示使用所选图片在场景中添加一个**FramedPhoto**。我们通过添加一个单独的**SelectImage
    模式**来实现这一点。现在我们希望这个模式能够服务于两个目的。当您在场景中添加新的、带框的图片时，它从Main-mode调用，当您想要替换场景中已经存在的带框图片的图片时，它从EditPicture-mode调用。这要求我们重构代码。
- en: 'Currently, when we build the Select Image buttons (in the `ImageButtons` script)
    we have it configure and enable AddPicture-mode directly. Instead, it now needs
    to depend on how SelectImage-mode is being used, so we''ll move that code from
    `ImageButtons` to `SelectImageMode`, as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，当我们构建选择图片按钮（在`ImageButtons`脚本中）时，我们直接配置并启用AddPicture-mode。相反，现在它需要依赖于SelectImage-mode的使用方式，因此我们将从`ImageButtons`移动到`SelectImageMode`的代码，如下所示：
- en: 'Edit the `SelectImageMode` script and add a reference to `AddPictureMode` at
    the top of the class:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`SelectImageMode`脚本，并在类顶部添加对`AddPictureMode`的引用：
- en: '[PRE19]'
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Then, add a public `ImageSelected` function:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一个公共的`ImageSelected`函数：
- en: '[PRE20]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Edit the `ImageButtons` script and add a reference to `SelectImageMode` at
    the top of the class:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`ImageButtons`脚本，并在类顶部添加对`SelectImageMode`的引用：
- en: '[PRE21]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then, replace the `OnClick` code with a call to `ImageSelected`, which we just
    wrote:'
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将`OnClick`代码替换为对`ImageSelected`的调用，这是我们刚刚编写的：
- en: '[PRE22]'
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This refactoring has not added any new functionality, but it restructures the
    code for `SelectImageMode` to decide how the modal menu will be used. Now, let's
    edit `SelectImageMode` again and add support for replacing the `currentPicture`
    image.
  id: totrans-213
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这次重构没有添加任何新功能，但它重构了`SelectImageMode`的代码结构，以决定如何使用模态菜单。现在，让我们再次编辑`SelectImageMode`并添加替换`currentPicture`图像的支持。
- en: 'At the top of the `SelectImageMode` script, add the following declarations:'
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SelectImageMode`脚本顶部添加以下声明：
- en: '[PRE23]'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Then, update the `ImageSelected` function, as follows:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，更新`ImageSelected`函数，如下所示：
- en: '[PRE24]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'At the top of the `GalleryMainMode` class, add a reference to `SelectImageMode`:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GalleryMainMode`类顶部添加对`SelectImageMode`的引用：
- en: '[PRE25]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Then, add a `SelectImageToAdd` function, as follows:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，添加一个`SelectImageToAdd`函数，如下所示：
- en: '[PRE26]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We just need to remember to update the **Add** button **OnClick** action before
    we're done.
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们只需要记得在我们完成之前更新**Add**按钮的**OnClick**动作。
- en: 'Likewise, now, we can add a `SelectImageToReplace` function to the `EditPictureMode`
    script. Declare `selectImage` at the top of the class:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，现在，我们可以在`EditPictureMode`脚本中添加一个`SelectImageToReplace`函数。在类的顶部声明`selectImage`：
- en: '[PRE27]'
  id: totrans-224
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Then, add the function, as follows:'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，添加以下功能：
- en: '[PRE28]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Save all the scripts. Now, we need to connect it up in Unity, including setting
    the **Add** and **Replace Image** buttons'' **OnClick** actions, and then setting
    the new **SelectImage Mode** parameters. Back in Unity, starting with the **Add**
    button, follow these steps:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有脚本。现在，我们需要在Unity中连接它们，包括设置**添加**和**替换图片**按钮的**OnClick**动作，然后设置新的**SelectImage
    Mode**参数。回到Unity中，从**添加**按钮开始，按照以下步骤操作：
- en: In the **Hierarchy** window, select the **Add** button under **UI Canvas | Main
    UI**.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择位于**UI画布 | Main UI**下的**添加**按钮。
- en: From the **Hierarchy** window, drag the **Main Mode** game object (under **Interaction
    Controller**) onto the **Button | OnClick** action's **Object** slot.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口，将**Main Mode**游戏对象（位于**交互控制器**下）拖动到**按钮 | OnClick**动作的**对象**槽位。
- en: In the **Function** selector, choose **Gallery Main Mode | Select Image To Add**.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**功能**选择器中，选择**Gallery Main Mode | 选择添加的图片**。
- en: Now, we'll wire up the **Replace Image** button, which is located under **UI
    Canvas | EditPicture UI | Edit Menu**.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将连接**替换图片**按钮，该按钮位于**UI画布 | EditPicture UI | 编辑菜单**下。
- en: In the **Inspector** window, on its **Button** component, click the **+** button
    at the bottom right of the **OnClick** actions.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，在其**按钮**组件上，点击**OnClick**动作右下角的**+**按钮。
- en: From the **Hierarchy** window, drag the **EditPicture Mode** game object onto
    the **OnClick** **Object** slot.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口，将**EditPicture Mode**游戏对象拖动到**OnClick** **对象**槽位。
- en: In the **Function** selector, choose **Edit Picture Mode | Select Image To Replace**.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**功能**选择器中，选择**Edit Picture Mode | 选择替换的图片**。
- en: The buttons are now set up. All we have to do now is assign the other references.
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 按钮现在已设置好。我们现在只需分配其他引用。
- en: In the **Hierarchy** window, select the **Main Mode** game object (under **Interaction
    Controller**).
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**Main Mode**游戏对象（位于**交互控制器**下）。
- en: Drag the **SelectImage Mode** object from the **Hierarchy** window onto the
    **Select Image** slot.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**SelectImage Mode**对象从**层次结构**窗口拖动到**选择图片**槽位。
- en: In the **Hierarchy** window select the **SelectImage Mode** game object (under
    **Interaction Controller**).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择**SelectImage Mode**游戏对象（位于**交互控制器**下）。
- en: Drag the **AddPicture Mode** object from the **Hierarchy** window onto the **Add
    Picture** slot.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AddPicture Mode**对象从**层次结构**窗口拖动到**添加图片**槽位。
- en: Drag the **EditPicture Mode** object from the **Hierarchy** window onto the
    **Edit Picture** slot.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**EditPicture Mode**对象从**层次结构**窗口拖动到**编辑图片**槽位。
- en: In the **Hierarchy** window, select the **EditPicture Mode** game object (under
    **Interaction Controller**).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**EditPicture Mode**游戏对象（位于**交互控制器**下）。
- en: Drag the **SelectImage Mode** object from the **Hierarchy** window onto the
    **Select Image** slot.
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**SelectImage Mode**对象从**层次结构**窗口拖动到**选择图片**槽位。
- en: In the **Hierarchy** window, select the **Image Buttons** game object (under
    **UI Canvas | SelectImage UI**).
  id: totrans-243
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择位于**UI画布 | SelectImage UI**下的**Image Buttons**游戏对象。
- en: Drag the **SelectImage Mode** object from the **Hierarchy** window onto the
    **Select Image** slot.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**SelectImage Mode**对象从**层次结构**窗口拖动到**选择图片**槽位。
- en: That should do it!
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 这样就完成了！
- en: In summary, we have refactored the `ImageButtons` script to call `SelectImageMode.ImageSelected`
    when a button is pressed. `SelectImageMode` will know whether the user is adding
    a new picture or replacing the image with an existing one. In the former case,
    the modal was called from Main-mode. In the latter case, the modal was called
    from EditPicture-mode and has an `isReplacing` flag set.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 总结一下，我们已经重构了`ImageButtons`脚本，以便在按钮按下时调用`SelectImageMode.ImageSelected`。`SelectImageMode`将知道用户是添加新图片还是用现有图片替换图片。在前一种情况下，模式是从Main-mode调用的。在后一种情况下，模式是从EditPicture-mode调用的，并且设置了`isReplacing`标志。
- en: Go ahead and **Build and Run** the scene. Add a picture and then edit it. Then,
    tap the **Replace Image** button. The **Select Image** menu should appear. At
    this point, you can pick another image, and it will replace the one in the currently
    selected **FramedPhoto**. There are more features you could add to this project,
    including letting the user choose a different frame for their pictures.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 继续构建并运行场景。添加一张图片，然后编辑它。然后，点击**替换图片**按钮。应该会出现**选择图片**菜单。此时，你可以选择另一张图片，它将替换当前选中的**FramedPhoto**中的图片。你还可以为这个项目添加更多功能，包括让用户为他们的图片选择不同的相框。
- en: Replacing the frame
  id: totrans-248
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 替换相框
- en: 'The last **Edit** button we must implement is **Replace Frame**. I will leave
    this feature up to you to build since at this point, you may have the skills to
    work through this challenge on your own. A basic solution may be to keep the current
    **FramedPhoto** prefab and let the user just pick a different color for the frame.
    Alternatively, you could define separate frame objects within the **FramedPhoto**
    prefab, perhaps using models found on the Asset Store or elsewhere, and pick a
    frame that enables one or another frame object. Here are some suggestions regarding
    where to find models:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 我们必须实现的最后一个**编辑**按钮是**替换相框**。我将把这个功能留给你来构建，因为在这个时候，你可能已经具备了自己解决这个挑战的技能。一个基本的解决方案可能是保留当前的**FramedPhoto**预制体，并让用户只需为相框选择不同的颜色。或者，你可以在**FramedPhoto**预制体中定义单独的相框对象，可能使用在资产商店或其他地方找到的模型，并选择一个允许一个或另一个相框对象的功能。以下是一些关于在哪里找到模型的建议：
- en: '*Classic Picture Frame*: [https://assetstore.unity.com/packages/3d/props/furniture/classic-picture-frame-59038](https://assetstore.unity.com/packages/3d/props/furniture/classic-picture-frame-59038)'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*经典相框*: [https://assetstore.unity.com/packages/3d/props/furniture/classic-picture-frame-59038](https://assetstore.unity.com/packages/3d/props/furniture/classic-picture-frame-59038)'
- en: '*Turbosquid:* [https://www.turbosquid.com/3d-model/free/picture-frame](https://www.turbosquid.com/3d-model/free/picture-frame)'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*Turbosquid:* [https://www.turbosquid.com/3d-model/free/picture-frame](https://www.turbosquid.com/3d-model/free/picture-frame)'
- en: So far, we've been interacting with the placed object indirectly through the
    Edit menu buttons. Next, we'll consider directly interacting with the virtual
    object.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们一直是通过编辑菜单按钮间接与放置的对象交互。接下来，我们将考虑直接与虚拟对象交互。
- en: Interacting to edit a picture
  id: totrans-253
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过交互编辑图片
- en: We will now implement the ability to move and resize a virtual object we have
    placed in the AR scene. For this, I've decided to give the object being edited
    responsibility for its own interactions. That is, when **FramedPhoto** is being
    edited, it'll listen for input action events and move or resize itself.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在将实现移动和调整我们在AR场景中放置的虚拟对象大小的能力。为此，我决定让正在编辑的对象负责自己的交互。也就是说，当**FramedPhoto**正在编辑时，它将监听输入动作事件并移动或调整自己。
- en: I've also decided to implement these features as separate components, `MovePicture`
    and `ResizePicture`, on the **FramedPhoto** prefab. This will only be enabled
    while **FramedPhoto** is being edited. First, let's ensure that instantiated **FramedPhoto**
    objects receive Input Action messages so that they can respond to user input.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 我还决定将这些功能作为独立的组件实现，分别是`MovePicture`和`ResizePicture`，在**FramedPhoto**预制体上。这将在**FramedPhoto**正在编辑时启用。首先，让我们确保实例化的**FramedPhoto**对象接收输入动作消息，以便它们能够响应用户输入。
- en: Ensuring FramedPhoto objects receive Input Action messages
  id: totrans-256
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 确保FramedPhoto对象接收输入动作消息
- en: 'We are currently using the Unity Input System, which lets you define and configure
    user input actions, as well as listening for those action events with a Player
    Input component. Currently, the scene has one Player Input component, attached
    to the Interaction Controller game object. The component is configured to broadcast
    messages down the local hierarchy. Therefore, if we want the `FramedPhoto` script
    to receive input action messages (which we now do), we must make sure the **FramedPhoto**
    object instances are children of the Interaction Controller. Let''s simply parent
    the **FramedPhoto** objects under the **AddPicture Mode** game object where it''s
    instantiated, as follows:'
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们目前正在使用Unity输入系统，它允许你定义和配置用户输入动作，以及通过玩家输入组件监听这些动作事件。目前，场景中有一个玩家输入组件，附加到交互控制器游戏对象上。该组件配置为向下广播消息。因此，如果我们想让`FramedPhoto`脚本接收输入动作消息（我们现在就是这样做的），我们必须确保**FramedPhoto**对象实例是交互控制器的子对象。让我们简单地将**FramedPhoto**对象作为其实例化的**AddPicture
    Mode**游戏对象的子对象，如下所示：
- en: Edit the `AddPictureMode` script.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`AddPictureMode`脚本。
- en: 'In the `PlaceObject` function, set the spawned object''s parent as the **AddPicture
    Mode** game object by adding this line of code:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`PlaceObject`函数中，通过添加以下代码行将生成的对象的父对象设置为**AddPicture Mode**游戏对象：
- en: '[PRE29]'
  id: totrans-260
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The instantiated **FramedPhoto** prefabs will now be parented by the **AddPicture
    Mode** game object.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 实例化的**FramedPhoto**预制件现在将由**AddPicture Mode**游戏对象作为父对象。
- en: Information – Scene Organization and Input Action Messages
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 信息 - 场景组织和输入动作消息
- en: It's advisable to consider how you will organize your scene object hierarchy
    and where to place instantiated objects. For example, generally, I'd prefer to
    keep all our **FramedPhotos** in a separate root object container. If we did that
    now, we would have to set **Player Input Behavior** to invoke events, instead
    of broadcasting messages down the local hierarchy. And then, scripts responding
    to those input actions would subscribe (add listeners) to those messages (see
    [https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/manual/Components.html#notification-behaviors](mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/manual/Components.html#notification-behaviors)).
    On the other hand, for tutorial projects such as the ones in this book, I've decided
    that using the built-in input action messages is cleaner and more straightforward
    to explain.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 建议您考虑如何组织场景对象层次结构以及放置实例化对象的位置。例如，通常，我更喜欢将所有我们的**FramedPhotos**保存在一个单独的根对象容器中。如果我们现在这么做，我们就必须将**Player
    Input Behavior**设置为调用事件，而不是向下广播消息到本地层次结构。然后，响应这些输入动作的脚本将订阅（添加监听器）到这些消息（见[https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/manual/Components.html#notification-behaviors](mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/manual/Components.html#notification-behaviors)）。另一方面，对于本书中的教程项目等，我决定使用内置的输入动作消息会更简洁且更容易解释。
- en: Let's start by creating the empty scripts and adding them to the scene. Then,
    we'll build them out.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从创建空脚本并将它们添加到场景中开始。然后，我们将构建它们。
- en: Adding the interaction components
  id: totrans-265
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加交互组件
- en: 'To expedite the implementation, we must create the script files first by performing
    the following steps:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了加快实现速度，我们必须首先通过执行以下步骤来创建脚本文件：
- en: In your `MovePicture`.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`MovePicture`。
- en: Create another new C# script named `ResizePicture`.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建另一个新的C#脚本，命名为`ResizePicture`。
- en: Open the **FramedPhoto** prefab for editing.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**FramedPhoto**预制件进行编辑。
- en: Drag the **MovePicture** script and the **ResizePicture** script from the **Project**
    assets folder onto the root **FramedPhoto** object.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**MovePicture**脚本和**ResizePicture**脚本从**Project**资产文件夹拖到根**FramedPhoto**对象上。
- en: 'Edit the `FramedPhoto` script in your code editor. Add the following declarations
    at the top of the class:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的代码编辑器中编辑`FramedPhoto`脚本。在类的顶部添加以下声明：
- en: '[PRE30]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Initialize it in `Awake` and start with the components disabled:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Awake`中初始化它，并开始时禁用组件：
- en: '[PRE31]'
  id: totrans-274
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Then, enable these components when editing:'
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在编辑时启用这些组件：
- en: '[PRE32]'
  id: totrans-276
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We've now prepared ourselves to add the move and resize direct manipulation
    features to the `FramedPhoto` object. These will be separate components that are
    enabled only while the picture is in EditPicture mode.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经准备好向`FramedPhoto`对象添加移动和调整大小直接操作功能。这些将作为单独的组件，仅在编辑图片模式下启用。
- en: OK. Let's start by interactively moving the picture along the wall by dragging
    it with our finger on the screen.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。让我们先通过在屏幕上用手指拖动图片来交互式地沿墙移动图片。
- en: Using our finger to move the picture
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用我们的手指移动图片
- en: 'We will start by implementing the drag-to-move feature by adding a `MoveObject`
    action to the **AR Input Actions** asset. Like the **SelectObject** action (and
    **PlaceObject**) that we already have, this will be bound to the touchscreen''s
    primary touch position. We''ll keep this action separate from the others, for
    example, should you decide to use a different interaction technique, such as a
    touch and hold, to start the dragging operation. But for now, we can just copy
    the other one, as follows:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先通过向**AR Input Actions**资产添加`MoveObject`动作来实现拖动移动功能。就像我们已有的**SelectObject**动作（和**PlaceObject**）一样，这将绑定到触摸屏的主要触摸位置。我们将把这个动作与其他动作分开，例如，如果你决定使用不同的交互技术，比如触摸并保持以开始拖动操作，我们可以这么做。但就目前而言，我们只需复制另一个，如下所示：
- en: In the `Assets/Inputs/` folder) to open it for editing (or use its **Edit Asset**
    button).
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Assets/Inputs/`文件夹中打开它进行编辑（或使用其**Edit Asset**按钮）。
- en: In the middle section, *right-click* the **SelectObject** action and select
    **Duplicate**.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中间部分，右键单击**SelectObject**动作并选择**Duplicate**。
- en: Rename the new one `MoveObject`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新脚本重命名为`MoveObject`。
- en: Press **Save Asset** (unless **Auto-Save** is enabled).
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 **Save Asset**（除非已启用 **Auto-Save**）。
- en: 'Now, we can add the code that will listen for this action. Edit the `MovePicture`
    script and write the following:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加监听此操作的代码。编辑 `MovePicture` 脚本并写下以下内容：
- en: '[PRE33]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This code is very similar to that in the `AddPictureMode` script. It's using
    **AR Raycast Manager** to find a trackable plane and place the object so that
    it's flush with the plane and upright. The difference is that we're not instantiating
    a new object, we're just updating the transform of the existing one. And we're
    doing this continuously, so long as the input action events are being generated
    (that is, so long as the user is touching the screen).
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与 `AddPictureMode` 脚本中的代码非常相似。它使用 **AR Raycast Manager** 来找到一个跟踪平面并将对象放置在平面与对象垂直对齐的位置。不同之处在于我们不是实例化一个新对象，我们只是更新现有对象的变换。我们这样做是持续的，只要输入动作事件正在生成（也就是说，只要用户在触摸屏幕）。
- en: The `OnMoveObject` function is skipped if the input action message is received
    but this component is not enabled. It also checks that the user is not tapping
    a UI element (an event system object), such as one of our edit menu buttons.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 如果接收到输入动作消息但此组件未启用，则跳过 `OnMoveObject` 函数。它还检查用户是否没有轻触 UI 元素（一个事件系统对象），例如我们编辑菜单按钮之一。
- en: Try it out. If you play the scene, create a picture, and begin editing it, you
    should be able to drag the picture with your finger and it will move along the
    wall plane. In fact, since we are raycasting each update, it could find a newer,
    refined tracked plane as you're dragging, or even move the picture to a different
    wall.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。如果你播放场景，创建一个图片，并开始编辑它，你应该能够用手指拖动图片，它会沿着墙面移动。实际上，由于我们每次更新都会进行射线投射，它可能会在你拖动时找到一个新的、更精确的跟踪平面，甚至将图片移动到另一面墙上。
- en: 'As we mentioned previously, if you tap the screen on any tracked plane, the
    current picture will "jump" to that location. If that is not your desired behavior,
    we can check that the initial touch is on the current picture before we start
    updating the transform position. The modified code is as follows:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，如果你在任意一个已跟踪平面上轻触屏幕，当前图片将“跳转”到该位置。如果这不是你期望的行为，我们可以在开始更新变换位置之前检查初始触摸是否在当前图片上。修改后的代码如下：
- en: 'Declare and initialize references to `camera` and `layerMask`:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明并初始化对 `camera` 和 `layerMask` 的引用：
- en: '[PRE34]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Add a raycast to `MoveObject` to ensure the touch is on a picture before you
    move it:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MoveObject` 中添加射线投射以确保在移动之前触摸在图片上：
- en: '[PRE35]'
  id: totrans-294
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Currently, we only have the tracked planes visible in AddPicture-mode. I think
    it would be useful to also show them in Edit-mode. We can use the same `ShowTrackablesOnEnable`
    script we wrote in a previous chapter that''s already been applied to the **AddPicture
    Mode** game object. Add this as follows:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们只在 AddPicture 模式下显示跟踪平面。我认为在 Edit 模式下显示它们也会很有用。我们可以使用之前章节中编写的相同的 `ShowTrackablesOnEnable`
    脚本，该脚本已经应用于 **AddPicture 模式** 游戏对象。按照以下步骤添加：
- en: In the **Hierarchy** window, select the **EditPicture Mode** game object (under
    **Interaction Controller**).
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 窗口中，选择 **EditPicture 模式** 游戏对象（位于 **Interaction Controller**
    下）。
- en: Locate the `ShowTrackablesOnEnable` script in your Project `Scripts/` folder.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目 `Scripts/` 文件夹中找到 `ShowTrackablesOnEnable` 脚本。
- en: From the **Hierarchy** window, drag the **AR Session Origin** game object onto
    the **Show Trackables On Enable | Session Origin** slot.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 **Hierarchy** 窗口中，将 **AR Session Origin** 游戏对象拖到 **Show Trackables On Enable
    | Session Origin** 插槽中。
- en: Drag the script onto the **EditPicture Mode** object, adding it as a component.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将脚本拖到 **EditPicture 模式** 对象上，添加为组件。
- en: Now, when **EditPicture Mode** is enabled, the trackable planes will be displayed.
    When it's disabled and you go back to Main-mode, they'll be hidden again.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当 **EditPicture 模式** 启用时，可跟踪的平面将会显示。当它被禁用并且你回到主模式时，它们将再次隐藏。
- en: Next, we'll implement the pinch-to-resize feature.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将实现捏合调整大小功能。
- en: Pinching to resize the picture
  id: totrans-302
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 捏合以调整图片大小
- en: 'To implement pinch-to-resize, we''ll also use an Input Action, but this will
    require a two-finger touch. As such, the action is not simply returning a single
    value (for example, Vector2). So, this time, we''ll use a **PassThrough** Action
    Type. Add it by performing the following steps:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现捏合调整大小，我们也将使用一个输入动作，但这需要一个两指触摸。因此，动作不仅仅返回一个单一值（例如，Vector2）。所以这次，我们将使用 **PassThrough**
    动作类型。按照以下步骤添加它：
- en: Edit the **AR Input Actions** asset, as we did previously.
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 **AR Input Actions** 资产，就像我们之前做的那样。
- en: In the middle `ResizeObject`.
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在中间的 `ResizeObject`。
- en: In the rightmost **Properties** section, select **Action Type | Pass Through**,
    and **Control Type | Vector 2**.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最右侧的**属性**部分，选择**动作类型 | 传递**，以及**控制类型 | 向量2**。
- en: 'In the middle **Actions** section, select the **<No Binding>** child. Then,
    in the **Properties** section, select **Properties | Path | Touchscreen | Touch
    #1 | Position** to bind this action to a second finger screen touch.'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '在中间的**动作**部分，选择**<无绑定>**子项。然后，在**属性**部分，选择**属性 | 路径 | 触摸屏 | 触摸 #1 | 位置**以将此动作绑定到第二个手指屏幕触摸。'
- en: Press **Save Asset** (unless **Auto-Save** is enabled).
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下**保存资产**（除非已启用**自动保存**）。
- en: 'Now, we can add the code to listen for this action. Edit the `ResizePicture`
    script and write it as follows. In the first part of the script, we declare several
    properties that we can use to tweak the behavior of the script from the Unity
    Inspector. `pinchspeed` lets you adjust the sensitivity of the pinch, while `minimumScale`
    and `maximumScale` let you limit how small or big the user will end up making
    the picture, respectively. Follow these steps:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加代码来监听这个动作。编辑`ResizePicture`脚本，并按照以下方式编写。在脚本的第一个部分，我们声明了几个属性，我们可以使用这些属性在Unity检查器中调整脚本的行为。`pinchspeed`允许你调整捏合的灵敏度，而`minimumScale`和`maximumScale`允许你分别限制用户最终将图片缩放到多小或多大的程度。按照以下步骤操作：
- en: 'Begin the script with the following code:'
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以以下代码开始脚本：
- en: '[PRE36]'
  id: totrans-311
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Note that I declared an empty `Start()` function. This is needed because a `MonoBehaviour`
    component without a `Start` or `Update` function cannot be disabled (you'll see
    this for yourself if you remove `Start` from the code and look at it in the **Inspector**
    window – you'll see that the **Enable** checkbox is missing).
  id: totrans-312
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意，我声明了一个空的`Start()`函数。这是必需的，因为没有`Start`或`Update`函数的`MonoBehaviour`组件无法被禁用（如果你从代码中移除`Start`并在**检查器**窗口中查看，你会看到**启用**复选框不见了）。
- en: 'The `OnResizeObject` function is the listener for the input action messages.
    Because we specified the Action Type as `Touchscreen` to get the first and second
    finger touches. Then, we can pass those touch positions to our `TouchToResize`
    function:'
  id: totrans-313
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`OnResizeObject`函数是输入动作消息的监听器。因为我们指定了动作类型为`Touchscreen`以获取第一和第二根手指的触摸。然后，我们可以将这些触摸位置传递给我们的`TouchToResize`函数：'
- en: '[PRE37]'
  id: totrans-314
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'The `TouchToResize` algorithm is straightforward. It gets the distance between
    the two finger touches (in screen pixels) and compares it against the previous
    distance. Dividing the new distance by the previous distance gives us the percentage
    change, which we can use to directly modify the transform scale. It seems to work
    pretty well for me:'
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`TouchToResize`算法很简单。它获取两个手指触摸之间的距离（屏幕像素），并将其与之前的距离进行比较。将新距离除以旧距离给出百分比变化，我们可以直接使用它来修改变换的缩放。对我来说，这似乎工作得相当好：'
- en: '[PRE38]'
  id: totrans-316
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Try it out. If you play the scene, create a picture, and begin editing it,
    you should be able to use two fingers to resize the picture, pinching your fingers
    together to make it smaller and un-pinching them apart to increase the picture''s
    size. Here''s a screen capture from my phone with some pictures arranged on my
    dining room wall, all of which are various sizes:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试一下。如果你播放场景，创建一个图片，并开始编辑它，你应该能够使用两只手指来调整图片大小，通过捏合手指来缩小图片，通过分开手指来增大图片的大小。以下是我手机上的屏幕截图，展示了我在餐厅墙上排列的一些图片，它们的大小各不相同：
- en: '![Figure 7.7 – Virtual framed photos arranged on my dining room wall'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 7.7 – 我餐厅墙上排列的虚拟相框照片]'
- en: '](img/Figure_7.07-diningroom.jpg)'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 7.07-餐厅](img/Figure_7.07-diningroom.jpg)'
- en: Figure 7.7 – Virtual framed photos arranged on my dining room wall
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.7 – 我餐厅墙上排列的虚拟相框照片
- en: In this section, we looked at how to directly interact with virtual objects.
    Using input actions, we added features using the touchscreen to drag and move
    a picture on a wall, as well as pinching to resize a picture.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们探讨了如何直接与虚拟对象交互。使用输入动作，我们添加了使用触摸屏拖动和移动墙上图片的功能，以及捏合来调整图片大小的功能。
- en: We could improve this by adding a Cancel Edit feature that restores the picture
    to its pre-edited state. One way to do this is to make a temporary copy of the
    object when it enters edit mode, and then restore or discard it if the user cancels
    or saves their changes, respectively.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过添加一个取消编辑功能来改进这一点，该功能可以将图片恢复到编辑前的状态。一种方法是在对象进入编辑模式时创建一个临时副本，然后在用户取消或保存更改时恢复或丢弃它。
- en: Another feature worth considering is persisting the picture object arrangements
    between sessions, so that the app saves your pictures when you exit the app and
    restores them when you restart the app. This is an advanced topic that I will
    not cover in this book since it is outside of Unity AR Foundation itself. Each
    provider has its own proprietary solutions. If you're interested, take a look
    at *ARCore Cloud Anchors*, which is supported by Unity *ARCore Extensions* ([https://developers.google.com/ar/develop/unity-arf/cloud-anchors/overview](https://developers.google.com/ar/develop/unity-arf/cloud-anchors/overview))
    and *ARKit ARWorldMap* ([https://developer.apple.com/documentation/arkit/arworldmap](https://developer.apple.com/documentation/arkit/arworldmap)),
    as exposed in the Unity *ARKit XR Plugin* ([https://docs.unity3d.com/Packages/com.unity.xr.arkit@4.0/api/UnityEngine.XR.ARKit.ARWorldMap.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arkit@4.0/api/UnityEngine.XR.ARKit.ARWorldMap.html)).
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得考虑的功能是在会话之间持久化图片对象排列，以便在退出应用时保存你的图片，并在重新启动应用时恢复它们。这是一个高级主题，我不会在本书中介绍，因为它超出了Unity
    AR Foundation本身。每个提供商都有自己的专有解决方案。如果你感兴趣，可以查看*ARCore Cloud Anchors*，它由Unity *ARCore
    Extensions*支持([https://developers.google.com/ar/develop/unity-arf/cloud-anchors/overview](https://developers.google.com/ar/develop/unity-arf/cloud-anchors/overview))和*ARKit
    ARWorldMap*([https://developer.apple.com/documentation/arkit/arworldmap](https://developer.apple.com/documentation/arkit/arworldmap))，如Unity
    *ARKit XR插件*([https://docs.unity3d.com/Packages/com.unity.xr.arkit@4.0/api/UnityEngine.XR.ARKit.ARWorldMap.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arkit@4.0/api/UnityEngine.XR.ARKit.ARWorldMap.html))所公开。
- en: This concludes our exploration of, and building, an AR photo gallery project.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对构建AR照片画廊项目的探索和构建。
- en: Summary
  id: totrans-325
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, you expanded on the AR gallery project we began in [*Chapter
    6*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136)*, Gallery: Building an AR
    App*. That project left us with the ability to place framed photos on our walls.
    In this chapter, you added the ability to edit virtual objects in the scene.'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你扩展了我们从[*第6章*](B15145_06_Final_SB_epub.xhtml#_idTextAnchor136)*，画廊：构建AR应用*开始的AR画廊项目。该项目使我们能够将装裱的照片放置在墙上。在本章中，你增加了在场景中编辑虚拟对象的能力。
- en: You implemented the ability to select an existing virtual object in Main-mode,
    where the selected object is highlighted and the app goes into EditPicture-mode.
    Here, there is an edit menu with buttons for **Replace Image**, **Replace Frame**,
    **Remove Picture**, and **Done** (return to Main-mode). The **Replace Image**
    feature displayed the same **SelectImage** modal menu that is used when we're
    creating (adding) new pictures. We had to refactor the code to make it reusable.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 你实现了在主模式中选择现有虚拟对象的能力，所选对象被突出显示，应用进入编辑图片模式。在这里，有一个编辑菜单，包含**替换图片**、**替换框架**、**删除图片**和**完成**（返回主模式）按钮。**替换图片**功能显示了与我们在创建（添加）新图片时使用的相同的**选择图片**模态菜单。我们必须重构代码以使其可重用。
- en: While placing and moving a picture on the wall, you implemented a feature to
    avoid overlapping or colliding objects, automatically moving the picture away
    from the other ones. After that, you implemented some direct interactions with
    the virtual objects by using touch events to drag a picture to a new location.
    You also implemented pinching to resize pictures on the wall. Finally, you learned
    how to use more Unity APIs from C#, including collision trigger hooks and vector
    geometry.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 当你在墙上放置和移动图片时，你实现了一个功能，以避免重叠或碰撞的对象，自动将图片移开。之后，你通过使用触摸事件拖动图片到新位置，实现了与虚拟对象的直接交互。你还实现了捏合来调整墙上图片的大小。最后，你学习了如何从C#中使用更多的Unity
    API，包括碰撞触发钩子和矢量几何。
- en: In the next chapter, we'll begin a new project while using a different AR tracking
    mechanism – tracked images – as we build a project for visualizing 3D data; namely,
    the planets in our Solar System.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将开始一个新的项目，同时使用不同的AR跟踪机制——跟踪图像——在构建一个可视化3D数据的项目时；即，我们太阳系中的行星。
