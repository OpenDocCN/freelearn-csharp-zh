<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-72"><a id="_idTextAnchor074" class="calibre6 pcalibre1 pcalibre"/>5</h1>
<h1 id="_idParaDest-73" class="calibre5"><a id="_idTextAnchor075" class="calibre6 pcalibre1 pcalibre"/>Designing Optimized User Interfaces with C# for Unity Games</h1>
<p class="calibre3">Welcome to <a href="B22017_05.xhtml#_idTextAnchor074" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 5</em></a>, where we will learn how to optimize <strong class="bold">user interfaces</strong> (<strong class="bold">UIs</strong>) for our Unity games using the versatile capabilities of C#. This chapter equips you with practical skills to enhance the performance of your UI and ensure a smooth user experience. The first skill focuses on utilizing C# for efficient UI optimization, maximizing the performance of your UI elements. Following this, we delve into strategies for creating an optimized UI system in C#, providing insights into structuring and managing views effectively. Throughout this chapter, the presented system acts as a flexible framework, allowing you to customize and optimize UI elements based on your game’s unique requirements. Let’s dive into the world of optimized UIs, leveraging the power of C# to refine the performance and functionality of your Unity game interfaces.</p>
<p class="calibre3">In this chapter, we’re going to cover the following main topics:</p>
<ul class="calibre10">
<li class="calibre11">Introducing UI design in gaming</li>
<li class="calibre11">Best practices and optimizing techniques for UI</li>
<li class="calibre11">UI system using C#<a id="_idTextAnchor076" class="calibre6 pcalibre1 pcalibre"/></li>
</ul>
<h1 id="_idParaDest-74" class="calibre5"><a id="_idTextAnchor077" class="calibre6 pcalibre1 pcalibre"/>Technical requirements</h1>
<p class="calibre3">All the code files of this chapter can be found at: <a href="https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2005" class="calibre6 pcalibre1 pcalibre">https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2005</a>.</p>
<h1 id="_idParaDest-75" class="calibre5"><a id="_idTextAnchor078" class="calibre6 pcalibre1 pcalibre"/>Introducing UI design in gaming</h1>
<p class="calibre3">In the exciting<a id="_idIndexMarker311" class="calibre6 pcalibre1 pcalibre"/> world of making games, the UI is like the link between the player and the cool virtual world made by game creators. UI design isn’t just about making things look good; it’s super important in shaping how players experience the game. This section talks about why UI design is a big deal in games and how it really affects how much players get into the game and how much they like it:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">The </strong><strong class="bold">first impression</strong>:<p class="calibre3">Think of the UI as the <a id="_idIndexMarker312" class="calibre6 pcalibre1 pcalibre"/>first hello between the game and the player. A well-made UI grabs attention, sets the vibe, and makes the game look and feel unique. Whether you’re on the main menu or playing the game, every part adds up to the first feeling you get when you start playing.</p></li>
<li class="calibre11"><strong class="bold">Enhancing </strong><strong class="bold">player immersion:</strong><p class="calibre3">Playing a game should feel like you’re right there in the action. A well-thought-out UI blends smoothly with the game, so you stay focused on playing without getting distracted. Whether it’s cool movements, matching themes, or easy controls, the UI becomes a big part of the game’s story.</p></li>
<li class="calibre11"><strong class="bold">Guiding </strong><strong class="bold">user interaction:</strong><p class="calibre3">The UI is like a helpful guide showing players what to do in the game. From health bars to markers for quests, each thing gives important information without confusing players. Making the UI clear and simple is super important so that players can think about their moves and the tricky parts of the game, not figuring out the buttons.</p></li>
<li class="calibre11"><strong class="bold">Impact on </strong><strong class="bold">player engagement:</strong><p class="calibre3">A UI that’s easy to understand and looks good really keeps players interested. If moving around menus is smooth and the game responds well, players want to spend more time playing. On the flip side, a badly made UI can make players frustrated, not want to play, and ruin the fun.</p></li>
<li class="calibre11"><strong class="bold">Adapting to </strong><strong class="bold">diverse platforms:</strong><p class="calibre3">Since we play games on all kinds of devices now, the UI has to work well on everything. It’s like speaking different languages for each device, making sure the game feels right no matter whether you’re using a computer, console, or phone.</p></li>
</ul>
<p class="calibre3">Making the UI in games <a id="_idIndexMarker313" class="calibre6 pcalibre1 pcalibre"/>is like finding the right mix of making things look good and work well. It’s about picking colors and fonts, how things are spaced out, and also making sure everything runs smoothly. Using C# in Unity lets game makers use these cool design ideas and make interfaces that not only look awesome but also do their job well.</p>
<p class="calibre3">As we go through this chapter, we’ll check out the basic ideas behind UI design and see how C# can help make really great UIs that make playing games even more awesome.</p>
<p class="calibre3">Transitioning to best practices and optimization techniques for UIs, we’ll explore strategies to enhance UI performance and responsiveness nex<a id="_idTextAnchor079" class="calibre6 pcalibre1 pcalibre"/>t.</p>
<h1 id="_idParaDest-76" class="calibre5"><a id="_idTextAnchor080" class="calibre6 pcalibre1 pcalibre"/>Best practices and optimization techniques for UIs</h1>
<p class="calibre3">In this section, we are going to talk about some optimization techniques for UIs along with some best practices to have a better performance. Let’s get started.</p>
<h2 id="_idParaDest-77" class="calibre7"><a id="_idTextAnchor081" class="calibre6 pcalibre1 pcalibre"/>Splitting up Canvases</h2>
<p class="calibre3"><strong class="bold">Issue</strong>: <em class="italic">Modifying a single element on the UI Canvas triggers a complete Canvas refresh, </em><em class="italic">impacting performance.</em></p>
<p class="calibre3">The<a id="_idIndexMarker314" class="calibre6 pcalibre1 pcalibre"/> Unity UI relies on the Canvas as its fundamental component. It creates meshes representing UI elements, refreshes these meshes when there are changes, and sends draw calls to the GPU for actual UI display.</p>
<p class="calibre3">Mesh generation is resource-intensive, requiring UI Elements to be grouped into batches for efficiency in draw calls. Due to the cost of batch regeneration, it’s essential to minimize unnecessary refreshes. The challenge arises when even a single element changes on a Canvas, prompting a full Canvas re-evaluation to determine the optimal way to redraw its elements.</p>
<p class="calibre3">Many users construct their entire game’s UI on a single Canvas with numerous elements. Altering just one element can lead to a significant CPU spike, consuming multiple milliseconds.</p>
<p class="calibre3"><strong class="bold">Solution</strong>: Divide your Canvases.</p>
<p class="calibre3">Each Canvas functions as an independent entity, segregating its elements from those on other Canvases. Leverage the Unity GUI’s support for multiple Canvases by segmenting your Canvases, addressing the batching challenges within Unity UI.</p>
<p class="calibre3">Nested Canvases <a id="_idIndexMarker315" class="calibre6 pcalibre1 pcalibre"/>offer another solution, enabling the creation of complex hierarchical UIs without the need to consider the spatial arrangement of elements across Canvases. Child Canvases additionally insulate content from both their parent and sibling Canvases. They maintain individual geometry and conduct independent batching. An effective strategy for segmentation is based on the refresh frequency of elements. Place static UI Elements on a distinct Canvas, reserving smaller sub-Canvases for dynamic elements that update simultaneously. Additionally, ensure uniformity in Z values, materials, and textures for all UI Elements on each Canvas.</p>
<p class="calibre3">In our game, let me illustrate with an example. We’ll set up a Canvas for the overall scene and, within this main canvas, each panel will function as an individual Canvas. This means that when we make updates, such as to the HUD canvas during gameplay, we won’t be affecting the <strong class="bold">Pause</strong> panel or any other panels. It’s crucial to ensure that every panel or view has its dedicated canvas component, preventing performance issues when updates are applied.</p>
<p class="calibre3">The following figure shows the division of the gameplay scene canvases into smaller sub-canvases.</p>
<div><div><img alt="Figure 5.1 – GamePlayCanvas hierarchy" src="img/B22017_05_1.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.1 – GamePlayCanvas hierarchy</p>
<p class="calibre3">The following <a id="_idIndexMarker316" class="calibre6 pcalibre1 pcalibre"/>figure shows the <strong class="bold">GamePlayCanvas</strong> which contains all canvases:</p>
<div><div><img alt="Figure 5.2 – GamePlayCanvas GameObject" src="img/B22017_05_2.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.2 – GamePlayCanvas GameObject</p>
<p class="calibre3">The following <a id="_idIndexMarker317" class="calibre6 pcalibre1 pcalibre"/>figure shows the <strong class="bold">PauseCanvas</strong> which is a child of <strong class="bold">GamePlayCanvas</strong>:</p>
<div><div><img alt="Figure 5.3 – PauseCanvas GameObject" src="img/B22017_05_3.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.3 – PauseCanvas GameObject</p>
<h2 id="_idParaDest-78" class="calibre7"><a id="_idTextAnchor082" class="calibre6 pcalibre1 pcalibre"/>Avoiding too many Graphic Raycasters and turning off Raycast Target</h2>
<p class="calibre3"><strong class="bold">Issue #1</strong>: <em class="italic">Not using Graphic </em><em class="italic">Raycaster well</em></p>
<p class="calibre3">The <strong class="bold">Graphic Raycaster</strong> helps<a id="_idIndexMarker318" class="calibre6 pcalibre1 pcalibre"/> with turning your clicks or taps on the screen into things the game understands. It’s like a translator between your actions and the game’s UI, figuring out what you’re touching and sending that information to the right parts of the game. You need this thing on every screen that needs your touch, even on smaller screens inside the big one. But it goes through all the places you touch on the screen and checks whether they’re inside a UI’s area, which can be a bit much.</p>
<p class="calibre3">Even though it’s called a Graphic Raycaster, it doesn’t exactly cast rays. By default, it only cares about UI graphics. It looks at all the UI parts that want to know when you touch them and checks whether the spot where you touch matches up with the UI parts that are set up to respond.</p>
<p class="calibre3">The problem is that not all UI parts want to be bothered when you touch them.</p>
<p class="calibre3"><code>Image</code> component – we only turn it off for images that you can’t interact with:</p>
<div><div><img alt="Figure 5.4 – RayCast Target variable" src="img/B22017_05_4.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.4 – RayCast Target variable</p>
<p class="calibre3"><strong class="bold">Issue #2</strong>: <em class="italic">Sometimes the Graphic Raycaster does more than just </em><em class="italic">translate touches.</em></p>
<p class="calibre3">When you set <strong class="bold">Render Mode</strong> on your Canvas to <strong class="bold">Worldspace Camera</strong> or <strong class="bold">Screen Space Camera</strong>, a blocking mask can be added. This mask determines whether the Raycaster will cast rays using 2D or 3D physics, determining whether any physics object obstructs the user’s ability to interact with the UI.</p>
<p class="calibre3"><strong class="bold">Solution</strong>: Casting<a id="_idIndexMarker320" class="calibre6 pcalibre1 pcalibre"/> rays via 2D or 3D physics can be resource-intensive, so use this feature judiciously. To minimize the number of Graphic Raycasters, exclude them from non-interactive UI Canvases since, in such cases, there is no need to check for interaction events.</p>
<p class="calibre3">In the following figure, you can see the <strong class="bold">Graphic </strong><strong class="bold">Raycaster</strong> component:</p>
<div><div><img alt="Figure 5.5 – Graphic Raycaster component" src="img/B22017_05_5.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.5 – Graphic Raycaster component</p>
<h2 id="_idParaDest-79" class="calibre7"><a id="_idTextAnchor083" class="calibre6 pcalibre1 pcalibre"/>Efficiently managing UI object pools</h2>
<p class="calibre3"><strong class="bold">Issue</strong>: <em class="italic">Inefficient practices in UI </em><em class="italic">object pooling</em></p>
<p class="calibre3">Frequently, individuals<a id="_idIndexMarker321" class="calibre6 pcalibre1 pcalibre"/> engage in pooling UI objects by first changing their parent and then disabling them, resulting in unnecessary complications.</p>
<p class="calibre3"><strong class="bold">Solution</strong>: Optimize for deactivating the object first before reassigning its parent within the pool.</p>
<p class="calibre3">This strategy ensures that the original hierarchy is dirtied only once. Once the object is reparented, there’s no need for an additional round of hierarchy changes, and the new hierarchy remains unaffected. When extracting an object from the pool, follow the sequence of reparenting it first, updating your data, and then activating it to maintain efficiency.</p>
<h2 id="_idParaDest-80" class="calibre7"><a id="_idTextAnchor084" class="calibre6 pcalibre1 pcalibre"/>Hiding a Canvas the right way</h2>
<p class="calibre3"><strong class="bold">Issue</strong>: <em class="italic">Uncertain about efficiently hiding </em><em class="italic">a Canvas</em></p>
<p class="calibre3">There are<a id="_idIndexMarker322" class="calibre6 pcalibre1 pcalibre"/> times when you want to keep UI Elements and Canvases out of sight. But how can you achieve this in an effective manner?</p>
<p class="calibre3"><code>Canvas</code> component itself.</p>
<p class="calibre3">By disabling the <code>Canvas</code> component, you stop the generation of draw calls to the GPU, rendering the Canvas invisible. Importantly, the Canvas retains its vertex buffer, preserving all meshes and vertices. Consequently, re-enabling it doesn’t trigger a rebuild; it simply resumes drawing.</p>
<p class="calibre3">Furthermore, deactivating the <code>Canvas</code> component avoids initiating the resource-intensive <code>OnDisable</code>/<code>OnEnable</code> callbacks within the Canvas hierarchy. Just exercise caution when disabling child components that execute computationally demanding per-frame code.</p>
<h2 id="_idParaDest-81" class="calibre7"><a id="_idTextAnchor085" class="calibre6 pcalibre1 pcalibre"/>Efficient implementation of animations for UI Elements</h2>
<p class="calibre3"><strong class="bold">Issue</strong>: <em class="italic">Implementing animators on </em><em class="italic">the UI</em></p>
<p class="calibre3">When<a id="_idIndexMarker323" class="calibre6 pcalibre1 pcalibre"/> animators are applied to the UI, they consistently affect UI Elements in every frame, even when the animation value remains constant.</p>
<p class="calibre3"><strong class="bold">Solution</strong>: Employ code for UI animation.</p>
<p class="calibre3">Restrict the use of animators to dynamic UI Elements that undergo constant changes. For elements that infrequently change or experience temporary alterations triggered by events, opt for coding your animations or utilizing a tweening system, a system you can make through code or you can use third-party assets for that. Various effective solutions for this purpose can be found on the Unity Asset Store. For our game, we will use the free <code>DoTween</code> package for this.</p>
<h2 id="_idParaDest-82" class="calibre7"><a id="_idTextAnchor086" class="calibre6 pcalibre1 pcalibre"/>Effective handling of fullscreen UIs</h2>
<p class="calibre3"><strong class="bold">Issue</strong>: <em class="italic">Performance issues with </em><em class="italic">fullscreen UIs</em></p>
<p class="calibre3">When a <a id="_idIndexMarker324" class="calibre6 pcalibre1 pcalibre"/>pause or start screen occupies the entire display, the remaining elements of the game continue rendering in the background, potentially leading to performance problems.</p>
<p class="calibre3"><strong class="bold">Solution</strong>: Hide everything else.</p>
<p class="calibre3">If you present a screen that overlays the entire scene, deactivate the camera responsible for rendering the 3D scene. Likewise, disable Canvas elements positioned beneath the top Canvas.</p>
<p class="calibre3">Contemplate reducing <code>Application.targetFrameRate</code> when engaging a fullscreen UI, as there is no necessity for updates at a <strong class="bold">60 </strong><strong class="bold">fps</strong> rate.</p>
<p class="calibre3">Now that we have understood the best practices and optimization techniques for the UI, let’s move on to the next section where we will explore some architectural patterns.</p>
<h1 id="_idParaDest-83" class="calibre5"><a id="_idTextAnchor087" class="calibre6 pcalibre1 pcalibre"/>Introducing architecture patterns (MVC and MVVM)</h1>
<p class="calibre3">In the world of game development, organizing and managing the UI is crucial for creating<a id="_idIndexMarker325" class="calibre6 pcalibre1 pcalibre"/> engaging and efficient experiences. Two widely used architectural patterns – namely, <strong class="bold">Model-View-Controller</strong> (<strong class="bold">MVC</strong>) and <strong class="bold">Model-View-ViewModel</strong> (<strong class="bold">MVVM</strong>) – provide frameworks for structuring UI elements in a way that <a id="_idIndexMarker326" class="calibre6 pcalibre1 pcalibre"/>enhances clarity and maintainability. MVC separates the application into three interconnected components — the <strong class="bold">model</strong> for data and logic, the <strong class="bold">view</strong> for the user interface, and the <strong class="bold">controller</strong> for managing user input. On the other hand, MVVM introduces <strong class="bold">ViewModel</strong> as a mediator between the model and the view, simplifying presentation logic and data binding, which is the automatic synchronization of data between the UI and the underlying data model in software applications. In this section, we will explore the practical application of these patterns in Unity game development, offering insights and guidance to help you make informed decisions about structuring your game’s UI.</p>
<h2 id="_idParaDest-84" class="calibre7"><a id="_idTextAnchor088" class="calibre6 pcalibre1 pcalibre"/>Understanding MVC – a teamwork of three roles</h2>
<p class="calibre3">In the following figure, you can see the arrangement of the MVC pattern and how its components interact.</p>
<div><div><img alt="Figure 5.6 – MVC structure" src="img/B22017_05_6.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.6 – MVC structure</p>
<p class="calibre3">Let’s understand a<a id="_idIndexMarker327" class="calibre6 pcalibre1 pcalibre"/> little bit more about the MVC structure:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Model</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Essence</em>: Represents the data and business logic of the application</li><li class="calibre11"><em class="italic">Unity implementation</em>: Often implemented as <strong class="source-inline1">ScriptableObject</strong> or regular C# class instances</li><li class="calibre11"><em class="italic">Role</em>: Manages data, enforces business rules, and communicates changes to the view</li></ul></li>
<li class="calibre11"><strong class="bold">View</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Essence</em>: Represents the UI elements, responsible for displaying data to the user</li><li class="calibre11"><em class="italic">Unity implementation</em>: Comprises Unity UI components, such as <strong class="source-inline1">Canvas</strong>, <strong class="source-inline1">Text</strong>, <strong class="source-inline1">Image</strong>, and so on</li><li class="calibre11"><em class="italic">Role</em>: Renders the data from the model and handles user input interactions, forwarding them to the controller</li></ul></li>
<li class="calibre11"><strong class="bold">Controller</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Essence</em>: Acts as an intermediary between the model and the view, handling user input and updating the model and view accordingly</li><li class="calibre11"><em class="italic">Unity implementation</em>: A <strong class="source-inline1">MonoBehaviour</strong> script attached to Unity UI elements or game objects.</li><li class="calibre11"><em class="italic">Role</em>: Listens for<a id="_idIndexMarker328" class="calibre6 pcalibre1 pcalibre"/> user input, updates the model, and instructs the view to reflect changes</li></ul></li>
<li class="calibre11"><strong class="bold">Interaction flow</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">User input</em>: Captured by the controller</li><li class="calibre11"><em class="italic">Model update</em>: The controller updates the model based on user input</li><li class="calibre11"><em class="italic">View update</em>: The view receives notifications from the model and updates the UI accordingly</li></ul></li>
<li class="calibre11"><strong class="bold">Pros </strong><strong class="bold">in Unity</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Simplicity</em>: Well suited for smaller projects and straightforward UI structures</li><li class="calibre11"><em class="italic">Unity compatibility</em>: Aligns seamlessly with Unity’s built-in UI system</li></ul></li>
<li class="calibre11"><strong class="bold">Cons </strong><strong class="bold">in Unity</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Potential complexity</em>: May lead to increased complexity as the project grows</li><li class="calibre11"><em class="italic">Data binding challenges</em>: Achieving efficient data binding might require additional effort</li></ul></li>
</ul>
<p class="calibre3">Let’s move on to understanding the next architectural pattern, MVVM.</p>
<h2 id="_idParaDest-85" class="calibre7"><a id="_idTextAnchor089" class="calibre6 pcalibre1 pcalibre"/>Understanding MVVM – a mix of views and models</h2>
<p class="calibre3">In the following <a id="_idIndexMarker329" class="calibre6 pcalibre1 pcalibre"/>figure, you can see the arrangement of the MVVM pattern and how its components interact:</p>
<div><div><img alt="Figure 5.7 – MVVM structure" src="img/B22017_05_7.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.7 – MVVM structure</p>
<p class="calibre3">Let’s understand a <a id="_idIndexMarker330" class="calibre6 pcalibre1 pcalibre"/>little bit more about the MVVM structure:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Model</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Essence</em>: Represents the data and business logic, similar to MVC</li><li class="calibre11"><em class="italic">Unity implementation</em>: <strong class="source-inline1">ScriptableObject</strong> or regular C# class instances, much like in MVC</li><li class="calibre11"><em class="italic">Role</em>: Manages data, enforces business rules, and communicates changes to the view</li></ul></li>
<li class="calibre11"><strong class="bold">View</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Essence</em>: Represents the UI, responsible for displaying data</li><li class="calibre11"><em class="italic">Unity implementation</em>: Unity UI components, same as in MVC</li><li class="calibre11"><em class="italic">Role</em>: Renders the data from the model and handles user input interactions, forwarding them to the controller</li></ul></li>
<li class="calibre11"><strong class="bold">ViewModel</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Essence</em>: Acts <a id="_idIndexMarker331" class="calibre6 pcalibre1 pcalibre"/>as an intermediary between the model and the view, exposing properties and commands</li><li class="calibre11"><em class="italic">Unity implementation</em>: A <strong class="source-inline1">MonoBehaviour</strong> script that facilitates data binding</li><li class="calibre11"><em class="italic">Role</em>: Simplifies data binding by exposing data and logic for the view to bind to directly</li></ul></li>
<li class="calibre11"><strong class="bold">Interaction flow</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">User input</em>: Captured by the view or directly by the ViewModel</li><li class="calibre11"><em class="italic">Model update</em>: The ViewModel updates the model based on user input</li><li class="calibre11"><em class="italic">View update</em>:  When data changes occur in the model, they automatically update the view through data binding</li></ul></li>
<li class="calibre11"><strong class="bold">Pros </strong><strong class="bold">in Unity</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Enhanced data binding</em>: Streamlines the process of updating the UI in response to changes in the underlying data</li><li class="calibre11"><em class="italic">Testability</em>: ViewModel components can be tested independently, fostering maintainability</li></ul></li>
<li class="calibre11"><strong class="bold">Cons </strong><strong class="bold">in Unity</strong>:<ul class="calibre16"><li class="calibre11"><em class="italic">Learning curve</em>: May pose a learning curve for developers unfamiliar with the pattern</li><li class="calibre11"><em class="italic">Overhead of abstraction</em>: Introducing an additional layer with the ViewModel might be considered over-engineering for smaller projects</li></ul></li>
</ul>
<p class="calibre3">Now that we <a id="_idIndexMarker332" class="calibre6 pcalibre1 pcalibre"/>understand what MVC and MVVM are, let’s explore how to decide between them for our project based on certain factors.</p>
<h2 id="_idParaDest-86" class="calibre7"><a id="_idTextAnchor090" class="calibre6 pcalibre1 pcalibre"/>Choosing the right path for Unity UI</h2>
<p class="calibre3">The<a id="_idIndexMarker333" class="calibre6 pcalibre1 pcalibre"/> following points explain why we would choose MVC in Unity:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Well-established compatibility</strong>: Unity’s built-in UI system aligns naturally with the principles of MVC</li>
<li class="calibre11"><strong class="bold">Simplicity for smaller projects</strong>: For smaller projects or when simplicity is crucial, MVC can be a pragmatic choice</li>
</ul>
<p class="calibre3">The following points explain why we would choose MVVM in Unity:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Data-driven complexity</strong>: MVVM shines in scenarios demanding efficient data binding and complex UI structures</li>
<li class="calibre11"><strong class="bold">Scaling for larger projects</strong>: MVVM facilitates scalability and maintainability, making it a robust choice for larger endeavors</li>
</ul>
<p class="calibre3">The following points will help you select your approach:</p>
<ul class="calibre10">
<li class="calibre11"><strong class="bold">Consider project size</strong>: MVC’s simplicity may be advantageous for smaller projects, while MVVM’s enhanced data binding and testability are beneficial for larger endeavors</li>
<li class="calibre11"><strong class="bold">Evaluate data binding needs</strong>: If efficient data binding is crucial, MVVM might be the preferred choice</li>
</ul>
<p class="calibre3">The<a id="_idIndexMarker334" class="calibre6 pcalibre1 pcalibre"/> journey through Unity UI development is a dynamic exploration, guided by the architectural choices of MVC and MVVM. While MVC offers simplicity and familiarity, MVVM introduces a layer of abstraction, elevating data binding and testability. As you navigate the Unity UI architecture, consider the specific needs of your project, the complexity of your UI, and the familiarity of your development team. Whether adhering to the clarity of MVC or embracing the sophistication of MVVM, the path you choose defines not only the structure of your UI but also the foundation of an immersive player experience. For our game, we will go with the MVC structure.</p>
<h2 id="_idParaDest-87" class="calibre7"><a id="_idTextAnchor091" class="calibre6 pcalibre1 pcalibre"/>Practical suggestions for enhancing your UI development</h2>
<p class="calibre3">Here are <a id="_idIndexMarker335" class="calibre6 pcalibre1 pcalibre"/>some tips that can be beneficial for you while working on UI.</p>
<ul class="calibre10">
<li class="calibre11">Create Prefabs for the most frequently used elements:<ul class="calibre16"><li class="calibre11">For this, consider using the title text as an example and attaching components to it. This makes it easier to implement changes later, as any modifications will impact all the elements in the game. Additionally, you can create images and any other UI elements.</li></ul></li>
<li class="calibre11">Use Sprite Atlases:<ul class="calibre16"><li class="calibre11">A Sprite Atlas is a feature in Unity that allows you to pack multiple Sprite textures into a single texture asset. This is particularly useful for optimizing and improving the performance of your game, as it reduces the number of draw calls by combining multiple Sprites into one texture.</li></ul><p class="calibre3">Here are some key points about Sprite Atlas in Unity:</p><ul class="calibre16"><li class="calibre11"><strong class="bold">Draw call optimization</strong>: By using Sprite Atlases, Unity can efficiently render multiple Sprites with a single draw call, which can significantly improve performance, especially on mobile devices.</li><li class="calibre11"><strong class="bold">Grouping textures</strong>: Sprite Atlases enable you to group multiple Sprites or textures together, making it easier to manage and organize your game assets.</li><li class="calibre11"><strong class="bold">Texture packing</strong>: Unity’s Sprite Atlas system performs automatic texture packing, arranging individual Sprites within the Atlas to minimize wasted space and optimize texture usage.</li><li class="calibre11"><strong class="bold">Mipmapping</strong>: Sprite Atlases support mipmapping, which helps improve the rendering quality of textures when they are viewed from a distance.</li><li class="calibre11"><strong class="bold">Atlas variants</strong>: Unity allows you to create different variants of Sprite Atlases for different platforms or screen resolutions, ensuring optimal performance across various devices.</li><li class="calibre11"><strong class="bold">Integration with Unity Editor</strong>: You can create and manage Sprite Atlases directly within the Unity Editor, making it convenient for game developers to visualize and adjust their assets.</li></ul></li>
<li class="calibre11">Design <a id="_idIndexMarker336" class="calibre6 pcalibre1 pcalibre"/>alignment using a transparent image overlay:<ul class="calibre16"><li class="calibre11">When provided with a designer’s view sample, you can overlay an image representing the final result with slight transparency. This allows you to align and organize the view according to the design.</li></ul></li>
<li class="calibre11">Using the UI Extensions package:<ul class="calibre16"><li class="calibre11">Discover the UI Extensions package, a valuable toolkit that significantly amplifies the capabilities of Unity’s native UI system. Here’s an overview of its key features:<ul class="calibre16"><li class="calibre11"><strong class="bold">Extensive controls</strong>: With over 70 additional UI controls, it offers advanced text fields (auto-complete, password masking, multi-line), sliders, progress bars, checkboxes, toggles, color pickers, dropdowns, list views, tree views, grids, tooltips, modal windows, context menus, toolbars, docking panels, and more.</li><li class="calibre11"><strong class="bold">Customization flexibility</strong>: Enjoy extensive customization options for existing UI elements, including the addition of shadows, outlines, and other visual effects, animation of properties (position, color, size), and the creation of custom layouts and interactions.</li><li class="calibre11"><strong class="bold">Utility functions</strong>: Benefit from various helpful utility functions for easy alignment and positioning of elements. Moreover, discover a shortcut for anchoring elements to corners, particularly useful for managing multiple resolutions, especially in mobile games.</li></ul></li></ul><p class="calibre3">This <a id="_idIndexMarker337" class="calibre6 pcalibre1 pcalibre"/>package provides a robust set of tools and features, making UI development in Unity more flexible and efficient.</p></li>
</ul>
<p class="calibre3">Now that we understand practical tips and architectural pattern (MVC and MVVM) structures, let’s dive into creating a UI system using C# to efficiently handle UI behavior in our Unity project.</p>
<h1 id="_idParaDest-88" class="calibre5"><a id="_idTextAnchor092" class="calibre6 pcalibre1 pcalibre"/>Creating a UI system using C#</h1>
<p class="calibre3">In this <a id="_idIndexMarker338" class="calibre6 pcalibre1 pcalibre"/>section, we will create a C# system for handling UI behavior, leveraging optimization tips and the MVC structure to achieve our objectives. This involves creating a <code>UIManager</code> class to oversee views, a <code>BaseView</code> class containing core view logic, and a practical example demonstrating the implementation of the UI system.</p>
<h2 id="_idParaDest-89" class="calibre7"><a id="_idTextAnchor093" class="calibre6 pcalibre1 pcalibre"/>The UIManager class</h2>
<p class="calibre3">To kick <a id="_idIndexMarker339" class="calibre6 pcalibre1 pcalibre"/>off this system, we’ll establish a base class called <code>UIManager</code>. This<a id="_idIndexMarker340" class="calibre6 pcalibre1 pcalibre"/> class will handle the invocation of <code>show</code> and <code>hide</code> functions for views and will act as a container for all the views. For each scene, we’ll create a child of <code>UIManager</code>, responsible for controlling the views within that specific scene. This scene-specific manager will hold all the views, providing us with better control over them. This setup allows us to hide all views, ensuring that only one view is active at a time, which is advantageous for performance.</p>
<p class="calibre3">The <a id="_idIndexMarker341" class="calibre6 pcalibre1 pcalibre"/>following code block provides a sample of the <code>UIManager</code> base class, which<a id="_idIndexMarker342" class="calibre6 pcalibre1 pcalibre"/> includes generic functions for showing and hiding views:</p>
<pre class="source-code">
public class UIManager : Singleton&lt;UIManager&gt;
{
    public GenericDictionary&lt;Type, BaseView&gt; views = new GenericDictionary&lt;Type, BaseView&gt;();
    private BaseView lastActiveView;
    protected override void Awake()
    {
        base.Awake();
    }
    // Register a view with the UIManager
    public void RegisterView&lt;T&gt;(T view) where T : BaseView
    {
        if (view != null &amp;&amp; !views.ContainsKey(typeof(T)))
        {
            views.Add(typeof(T), view);
        }
    }
    // Show a view
    public void ShowView&lt;T&gt;() where T : BaseView
    {
        if (views.ContainsKey(typeof(T)))
        {
            var view = views[typeof(T)];
            // Show the new view
            view.Show();
            lastActiveView = view;
        }
        else
        {
            Debug.LogError("The View Of Type is Not Exist " + typeof(T).ToString());
        }
    }
    public void HideView&lt;T&gt;()
    {
        if (views.ContainsKey(typeof(T)))
        {
            var view = views[typeof(T)];
            if (view.IsVisible())
                view.Hide();
        }
    }
    // Hide the currently active view
    public void HideActiveView()
    {
        if (lastActiveView != null)
        {
            lastActiveView.Hide();
            lastActiveView = null;
        }
    }
    public BaseView GetView(Type viewType)
    {
        if (views.ContainsKey(viewType)) return views[viewType];
        else return null;
    }
    public T GetView&lt;T&gt;()
    {
        if (views.ContainsKey(typeof(T))) return (T)Convert.ChangeType(views[typeof(T)], typeof(T));
        else return (T)Convert.ChangeType(null, typeof(T));
    }
}</pre> <p class="calibre3">In the <a id="_idIndexMarker343" class="calibre6 pcalibre1 pcalibre"/>preceding code block, we employed generic functions to<a id="_idIndexMarker344" class="calibre6 pcalibre1 pcalibre"/> handle the showing and hiding of views based on their type directly, avoiding the use of strings for improved performance.</p>
<p class="calibre3">We begin by registering the view and adding it to the dictionary, enabling us to hide or show it throughout the gameplay session. Additionally, we have functions to retrieve the view when needed, allowing access or performing specific actions on that view.</p>
<h3 class="calibre9">Utilizing UIManager</h3>
<p class="calibre3">To utilize <a id="_idIndexMarker345" class="calibre6 pcalibre1 pcalibre"/>this class, we can create child classes for each scene and either attach this component to a GameObject or simply place it on the main canvas of the scene.</p>
<p class="calibre3">As evident in the upcoming code block, we have <code>HUDManager</code>, which inherits from <code>UIManager</code>. We will attach it to the main canvas of the gameplay scene to manage and control all views associated with this scene:</p>
<pre class="source-code">
    public class HUDManager : UIManager
    {
        //Override Methods or Add new Logic here
    }</pre> <p class="calibre3">In the following figure, you’ll notice the <code>HUDManager</code> component connected to the main canvas:</p>
<div><div><img alt="Figure 5.8 – The HUDManager component" src="img/B22017_05_8.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.8 – The HUDManager component</p>
<p class="calibre3">Now, we<a id="_idIndexMarker346" class="calibre6 pcalibre1 pcalibre"/> can proceed to the other key component of the UI system, which is the <code>BaseView</code> class.</p>
<h2 id="_idParaDest-90" class="calibre7"><a id="_idTextAnchor094" class="calibre6 pcalibre1 pcalibre"/>The BaseView class</h2>
<p class="calibre3">In the <a id="_idIndexMarker347" class="calibre6 pcalibre1 pcalibre"/>UI system, we require a foundational class for all views, encompassing <a id="_idIndexMarker348" class="calibre6 pcalibre1 pcalibre"/>core functions that define the view’s behavior, actions, or logic during <code>hide</code> and <code>show</code> operations. While the UI manager is responsible for invoking these functions, the underlying logic resides in the base class. We predominantly utilize <code>hide</code> and <code>show</code> canvas processes for efficiency, and for animations during these operations, we leverage the <code>DoTween</code> package.</p>
<p class="calibre3">In the following code block, you’ll find the <code>BaseView</code> class along with its core functions:</p>
<pre class="source-code">
    public abstract class BaseView : MonoBehaviour
    {
        private Canvas canvas;
        public bool isActiveView;
        public GameData gameData;
        public UITween tweenComponent;
        protected virtual void Start()
        {
            canvas = GetComponent&lt;Canvas&gt;();
        }
        // Show this view
        public virtual void Show()
        {
            isActiveView = true;
            canvas.enabled = true;
            gameObject.SetActive(true);
            PlayTweens(true);
            ShowView();
        }
        public virtual void ShowView()
        {
        }
        // Hide this view
        public virtual void Hide()
        {
            PlayTweens(false);
        }
        private void OnOutTweenComplete()
        {
            isActiveView = false;
            canvas.enabled = false;
        }
        public virtual void HideCanvas()
        {
            canvas.enabled = false;
        }
        // Return true if this view is currently visible
        public bool IsVisible()
        {
            return canvas.enabled;
        }
        private void PlayTweens(bool state)
        {
            if (state)
            {
                tweenComponent?.PlayInTween();
            }
            else
            {
                if (tweenComponent == null)
                {
                    OnOutTweenComplete();
                }
                else
                {
                    tweenComponent.PlayOutTween(OnOutTweenComplete);
                }
            }
        }
    }</pre> <p class="calibre3">The <code>BaseView</code> class serves<a id="_idIndexMarker349" class="calibre6 pcalibre1 pcalibre"/> as a foundational element within our UI system, facilitating essential functionalities crucial for managing views in Unity projects. At its core, this class offers methods to both show and hide views seamlessly. Moreover, it seamlessly integrates with <code>tween</code> components, enabling the application of animations during view transitions. Beyond its fundamental functions, the <code>BaseView</code> class provides a suite of auxiliary methods, offering invaluable support for implementing the intricate logic of our game.</p>
<p class="calibre3">Now that we understand the functionality of the <code>BaseView</code> class, let’s proceed to grasp the functionality of the <code>UITween</code> component, which is utilized for animating the views.</p>
<h3 class="calibre9">The UITween component</h3>
<p class="calibre3">The <code>UITween</code> component <a id="_idIndexMarker350" class="calibre6 pcalibre1 pcalibre"/>serves as a wrapper that I’ve<a id="_idIndexMarker351" class="calibre6 pcalibre1 pcalibre"/> created for utilizing <code>DoTween</code>, simplifying the process of adding and removing animations in the Inspector for showing or hiding views.</p>
<p class="calibre3">You can locate all of these classes and additional resources in the GitHub repository, the link to which is mentioned in the Technical requirements section.</p>
<p class="calibre3">In the following figure, you’ll observe the <code>UITween</code> component. This serves as a sample class, and we can adjust it to suit our game.</p>
<div><div><img alt="Figure 5.9 – The UITween component" src="img/B22017_05_9.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.9 – The UITween component</p>
<h3 class="calibre9">Utilizing BaseView</h3>
<p class="calibre3">To<a id="_idIndexMarker352" class="calibre6 pcalibre1 pcalibre"/> utilize the <code>BaseView</code> class, all you need to do is create a child class for each view in the game, enabling the use of core functions. Afterward, you can incorporate specific logic for each view.</p>
<p class="calibre3">In the following code block, you’ll see an example of the <code>BaseView</code> class usage:</p>
<pre class="source-code">
    public class TopBarView : BaseView
    {
        protected override void Start()
        {
            base.Start();
            StartUIManager.Instance.RegisterView&lt;TopBarView&gt;(this);
            Show();
        }
       //Add here logic for displaying the currencies for the player
    }</pre> <p class="calibre3">The <code>TopBar</code> class, functioning<a id="_idIndexMarker353" class="calibre6 pcalibre1 pcalibre"/> as a view class, will be responsible for displaying elements such as the player’s currency in the game. Simply attach the <code>TopBar</code> class to a <code>TopBar</code> Canvas GameObject in your game scene, and you’re done.</p>
<p class="calibre3">In the following figure, you’ll observe the <code>TopBarView</code> component attached to its canvas:</p>
<div><div><img alt="Figure 5.10 – The TopBarView component" src="img/B22017_05_10.jpg" class="calibre4"/>
</div>
</div>
<p class="img---caption" lang="en-US" xml:lang="en-US">Figure 5.10 – The TopBarView component</p>
<p class="calibre3">This <a id="_idIndexMarker354" class="calibre6 pcalibre1 pcalibre"/>system serves as an abstract framework for the UI system, providing a foundation that can be customized or extended with additional logic as needed for the game. Feel free to tailor and expand upon this structure according to the specific requirements of your game.</p>
<p class="calibre3">Next, let’s take an example to see how MVVM would be implemented.</p>
<h2 id="_idParaDest-91" class="calibre7"><a id="_idTextAnchor095" class="calibre6 pcalibre1 pcalibre"/>Implementing MVVM</h2>
<p class="calibre3">Implementing <a id="_idIndexMarker355" class="calibre6 pcalibre1 pcalibre"/>the MVVM  structure in Unity involves separating the logic and data management from the UI elements. Let’s look at an example implementation of MVVM in Unity.</p>
<p class="calibre3">In the following code block, <code>PlayerData</code> represents the data structure, such as player level and score:</p>
<pre class="source-code">
// Model
public class PlayerData
{
    public int playerLevel;
    public int playerScore;
}</pre> <p class="calibre3">In the following code block, <code>PlayerViewModel</code> acts as an intermediary between the model and the view. It holds the logic for data manipulation and exposes properties that the view can bind to:</p>
<pre class="source-code">
// ViewModel
public class PlayerViewModel : MonoBehaviour
{
    private PlayerData playerData;
    // Properties for data binding
    public int PlayerLevel =&gt; playerData.playerLevel;
    public int PlayerScore =&gt; playerData.playerScore;
    private void Start()
    {
        playerData = new PlayerData();
    }
    public void UpdatePlayerData(int level, int score)
    {
        playerData.playerLevel = level;
        playerData.playerScore = score;
    }
}</pre> <p class="calibre3">In the <a id="_idIndexMarker356" class="calibre6 pcalibre1 pcalibre"/>following code block, <code>PlayerView</code> represents the UI elements and is responsible for displaying data from <code>ViewModel</code>. It subscribes to <code>ViewModel</code> events and updates UI elements based on changes in <code>ViewModel</code>:</p>
<pre class="source-code">
// View
public class PlayerView : MonoBehaviour
{
    [SerializeField] private PlayerViewModel playerViewModel;
    private void Start()
    {
        // Subscribe to ViewModel events
        playerViewModel.UpdatePlayerData(1, 100); // Example initialization
    }
    private void Update()
    {
        // Example of data binding
        Debug.Log("Player Level: " + playerViewModel.PlayerLevel);
        Debug.Log("Player Score: " + playerViewModel.PlayerScore);
    }
}</pre> <p class="calibre3">This <a id="_idIndexMarker357" class="calibre6 pcalibre1 pcalibre"/>structure allows for a clear separation of concerns, with <code>ViewModel</code> handling the logic and data manipulation while the view focuses solely on UI representation. Data binding ensures that changes in <code>ViewModel</code> automatically reflect in the view, promoting a more organized and maintainable code base.</p>
<h1 id="_idParaDest-92" class="calibre5"><a id="_idTextAnchor096" class="calibre6 pcalibre1 pcalibre"/>Summary</h1>
<p class="calibre3">In this chapter, we learned how to improve our game interfaces using C#. We started by getting better at making the parts of the UI work faster. Then, we figured out ways to organize and control the different views in our game. The skills you picked up here gave you the tools to make your UI look good and run smoothly based on what your game needs.</p>
<p class="calibre3">In the upcoming <a href="B22017_06.xhtml#_idTextAnchor098" class="calibre6 pcalibre1 pcalibre"><em class="italic">Chapter 6</em></a>, we’ll dive into handling game data using C#. We’ll learn how to organize and save game information in Unity. These skills will help us manage game progress, save and load game states, and create features that use stored data. As you continue on this coding adventure, you’ll discover new ways to handle game data effectively with C#. Get ready for more coding challenges in the upcoming chapter. Happy coding!</p>
</div>
</body></html>