<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops" epub:prefix="z3998: http://www.daisy.org/z3998/2012/vocab/structure/#" lang="en" xml:lang="en">
<head>
    <title>Functional Programming with F#</title>
    <link href="css/style.css" rel="stylesheet" type="text/css"/>
    <link href="68851547a55f.css" rel="stylesheet" type="text/css"/>
  </head>
  <body>
    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functional Programming with F#</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we will learn how to build functional programs with F# that leverage .NET Core. We will also master data access layer implementation for microservices that use a SQL Server vNext database.</p>
<p>The topics to be covered in this chapter are:</p>
<ul>
<li>Introduction to functional programming</li>
<li>Introduction to F#</li>
<li>Data access layer with F#</li>
<li>Querying SQL vNext with F#</li>
</ul>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to functional programming</h1>
                </header>
            
            <article>
                
<p>We briefly discussed functional programming and F# in <a href="ch01.html">Chapter 1</a>, <em>Getting Started</em>. In the F# primer section, we said that functional programming treats programs as mathematical expressions and evaluates expressions. It focuses on functions and constants, which don't change like variables and states. Functional programming solves complex problems with simple code; it is a very efficient programming technique for writing bug-free applications; for example, the null exception can be avoided using this technique.</p>
<p>Functional programming is language-agnostic, which means it is not language-specific. Functional programming focuses on a structured approach; it doesn't have multiple entry and exit points. It doesn't have goto statements, so it is easy to create small modules and create large modules using small blocks of structured code (or in other words sub-modules), which increases the re-usability of code. One function can be used as the input of another function and that function can output a new function.</p>
<p>Here are some rules which make it easy for us to understand functional programming:</p>
<ul>
<li>In functional programming, a function's output never gets affected by outside code changes and the function always gives the same result for the same parameters. This gives us confidence in the function's behavior that it will give the expected result in all the scenarios, and this is helpful for multithread or parallel programming.</li>
<li>In functional programming, variables are immutable, which means we cannot modify a variable once it is initialized, so it is easy to determine the value of a variable at any given point at program runtime.</li>
<li>Functional programming works on referential transparency, which means it doesn't use assignment statements in a function. For example, if a function is assigning a new value to a variable such as shown here:</li>
</ul>
<pre style="padding-left: 60px">Public int sum(x)<br/>{<br/>x = x + 20 ;<br/>return x;<br/>}</pre>
<p style="padding-left: 60px">This is changing the value of <kbd>x,</kbd> but if we write it as shown here:</p>
<pre style="padding-left: 60px">Public int sum(x)<br/>{<br/>return x + 20 ;<br/>}</pre>
<p style="padding-left: 60px">This is not changing the variable value and the function returns the same result.</p>
<ul>
<li>Functional programming uses recursion for looping. A recursive function calls itself and runs till the condition is satisfied.</li>
</ul>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functional programming features</h1>
                </header>
            
            <article>
                
<p>Let's discuss some functional programming features:</p>
<ul>
<li class="h3">Higher-order functions</li>
<li class="h3">Purity</li>
<li class="h3">Recursion</li>
<li class="h3">Currying</li>
<li class="h3">Closure</li>
<li class="h3">Function composition</li>
</ul>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Higher-order functions (HOF)</h1>
                </header>
            
            <article>
                
<p>One function can take an input argument as another function and it can return a function. This originated from calculus and is widely used in functional programming. Order can be determined by domain and range of order such as order <kbd>0</kbd> has no function data and order <kbd>1</kbd> has a domain and range of order <kbd>0</kbd>, if order is higher than <kbd>1</kbd>, it is called a higher-order function. For example, the <kbd>ComplexCalc</kbd> function takes another function as input and returns a different function as output:</p>
<pre>open System<br/>let sum y = x+x<br/>let divide y = x/x<br/>Let ComplexCalc func = (func 2)<br/>Printfn(ComplexCalc sum) // 4<br/>Printfn(ComplexCalc divide) //1</pre>
<p>In the previous example, we created two functions,&#160;<kbd>sum</kbd> and <kbd>divide</kbd>. We pass these two functions as parameters to the <kbd>ComplexCalc</kbd> function, and it returns a value of&#160;<kbd>4</kbd> and <kbd>1</kbd>, respectively.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Purity</h1>
                </header>
            
            <article>
                
<p>In functional programming, a function is referred to as a pure function if all its input arguments are known and all its output results are also well known and declared; or we can say the input and output result has no side-effects. Now, you must be curious to know what the side-effect could be, let's discuss it.</p>
<p>Let's look at the following example:</p>
<pre>Public int sum(int x)<br/>{<br/>return x+x; <br/>}</pre>
<p>In the previous example, the function <kbd>sum</kbd> takes an integer input and returns an integer value and predefined result. This kind of function is referred to as a pure function. Let's investigate the following example:</p>
<pre>Public void verifyData()<br/>{<br/>  Employee emp = OrgQueue.getEmp();<br/>  If(emp != null)<br/>  {<br/>    ProcessForm(emp);<br/>  }<br/>}</pre>
<p>In the preceding example, the <kbd>verifyData()</kbd> function does not take any input parameter and does not return anything, but this function is internally calling the&#160;<kbd>getEmp()</kbd> function so&#160;<kbd>verifyData()</kbd> depends on the <kbd>getEmp()</kbd> function. If the output of <kbd>getEmp()</kbd> is not null, it calls another function, called&#160;<kbd>ProcessForm()</kbd>&#160;and we pass the&#160;<kbd>getEmp()</kbd> function output as input for <kbd>ProcessForm(emp)</kbd>. In this example, both the functions, <kbd>getEmp()</kbd> and <kbd>ProcessForm(),</kbd> are unknown at the&#160;<kbd>verifyData()</kbd> function level call, also <kbd>emp</kbd> is a hidden value. This kind of program, which has hidden input and output, is treated as a side-effect of the program. We cannot understand what it does in such functions. This is different from encapsulation; encapsulation hides the complexity but in such function, the functionality is not clear and input and output are unreliable. These kinds of function are referred to as impure functions.</p>
<p>Let's look at the main concepts of pure functions:</p>
<ul>
<li><strong>Immutable data</strong>: Functional programming works on immutable data, it removes the side-effect of variable state change and gives guarantee of an expected result.</li>
<li><strong>Referential transparency</strong>: Large modules can be replaced by small code blocks and reuse any existing modules. For example, if&#160;<kbd>a = b*c</kbd> and <kbd>d = b*c*e</kbd> then the value of <kbd>d</kbd> can be written as&#160;<kbd>d = a*e</kbd>.</li>
<li><strong>Lazy evaluation</strong>: Referential transparency and immutable data give us the flexibility to calculate the function at any given point of time and we will get the same result, because a variable will not change its state at any time.</li>
</ul>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Recursion</h1>
                </header>
            
            <article>
                
<p>In functional programming, looping is performed by recursive functions. In F#, to make a function recursive, we need to use the&#160;<kbd>rec</kbd><span>&#160;keyword</span>. By default, functions are not recursive in F#, we have to rectify this explicitly using the&#160;<kbd>rec</kbd> keyword. Let's take an example:</p>
<pre>let rec summation x = if x = 0 then 0 else x + summation(x-1)<br/>printfn "The summation of first 10 integers is- %A" (summation 10)</pre>
<p>In this code, we used the keyword <kbd>rec</kbd> for the recursion function and if the value passed is <kbd>0</kbd> , the sum would be <kbd>0</kbd>;&#160;otherewise it will add <kbd>x + summation(x-1)</kbd>, like <kbd>1+0</kbd> then <kbd>2+1</kbd> and so on.<span>&#160;</span>We should take care with recursion because it can consume memory heavily.<span>&#160;</span></p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Currying</h1>
                </header>
            
            <article>
                
<p>This converts a function with multiple input parameter to a function which takes one parameter at a time, or we can say it breaks the function into multiple functions, each taking one parameter at a time. Here is an example:</p>
<pre>int sum = (a,b) =&gt; a+b<br/>int sumcurry = (a) =&gt;(b) =&gt; a+b<br/>sumcurry(5)(6) // 11<br/>int sum8 = sumcurry(8) // b=&gt; 8+b<br/>sum8(5) // 13</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Closure</h1>
                </header>
            
            <article>
                
<p>Closure is a feature which allows us to access a variable which is not in the scope of the current module. It is a way of implementing lexically scoped named binding, for example:</p>
<pre>int add = x=&gt; y=&gt; x+y<br/>int addTen = add(10)<br/>addTen(5) // this will return 15<br/><br/></pre>
<p>In this example, the <kbd>add()</kbd> function is internally called by the <kbd>addTen()</kbd> function. In an ideal world, the variables&#160;<kbd>x</kbd> and <kbd>y</kbd> should not be accessible when the <kbd>add()</kbd> function finishes its execution, but when we are calling the function <kbd>addTen()</kbd>, it returns&#160;<kbd>15</kbd>. So, the state of the function <kbd>add()</kbd> is saved though code execution is finished, otherwise there is no way of knowing the&#160;<kbd>add(10)</kbd> value, where <kbd>x = 10</kbd>. We are able to find the value of <kbd>x</kbd> because of lexical scoping and this is called closure.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Function composition</h1>
                </header>
            
            <article>
                
<p>As we discussed earlier about HOF, function composition means getting two functions together to create a third new function where the output of a function is the input of another function.</p>
<p>There are <em>n</em> number of functional programming features. Functional programming is a technique to solve problems and write code in an efficient way. It is not language-specific, but many languages support functional programming. We can also use non-functional languages (such as C#) to write programs in a functional way. F# is a Microsoft programming language for concise and declarative syntax. We will learn more about F# in the next section.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Introduction to F#</h1>
                </header>
            
            <article>
                
<p>In <a href="ch01.html">Chapter 1</a>, <em>Getting Started</em>, we discussed the F# language and its functional programming features, basic keywords, operators, and variable declarations. We also looked at the difference between F# and C#, functions, and the basic input-output syntax. In this section, we will discuss F# in more detail.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Basics of classes</h1>
                </header>
            
            <article>
                
<p>Classes are types of object which can contain functions, properties, and events. An F# class must have a parameter and a function attached like a member. Both properties and functions can use the <kbd>member</kbd> keyword. The following is the class definition syntax:</p>
<pre>type [access-modifier] type-name [type-params] [access-modifier] (parameter-list) [ as identifier ] =<br/>[ class ]<br/>[ inherit base-type-name(base-constructor-args) ]<br/>[ let-bindings ]<br/>[ do-bindings ]<br/>member-list<br/> [ end ]<br/><br/>// Mutually recursive class definitions:<br/><br/>type [access-modifier] type-name1 ...<br/>and [access-modifier] type-name2 ...</pre>
<p>Let’s discuss the preceding syntax for class declaration:</p>
<ul>
<li><kbd>type</kbd>:&#160;In the F# language, class definition starts with a&#160;<kbd>type</kbd> keyword.</li>
<li><kbd>access-modifier</kbd>: The F# language supports three access modifiers—<kbd>public</kbd>, <kbd>private</kbd>, and <kbd>internal</kbd>. By default, it considers the&#160;<kbd>public</kbd> modifier if no other access modifier is provided. The&#160;<kbd>Protected</kbd> keyword is not used in the F# language, and the reason is that it will become object oriented rather than functional programming. For example, F# usually calls a member using a lambda expression and if we make a member type protected and call an object of a different instance, it will not work.</li>
<li><kbd>type-name</kbd>:&#160;It is any of the previously mentioned valid identifiers; the default access modifier is <kbd>public</kbd>.</li>
<li><kbd>type-params</kbd>: It defines optional generic type parameters.</li>
<li><kbd>parameter-list</kbd>: It defines constructor parameters; the default access modifier for the primary constructor is <kbd>public</kbd>.</li>
<li><kbd>identifier</kbd>: It is used with the optional <kbd>as</kbd> keyword, the&#160;<kbd>as</kbd>&#160;keyword gives a name to an instance variable which can be used in the type definition to refer to the instance of the type.</li>
<li><kbd>Inherit</kbd>: This keyword allows us to specify the base class for a class.</li>
<li><kbd>let-bindings</kbd>: This is used to declare fields or function values in the context of a class.</li>
<li><kbd>do-bindings</kbd>: This is useful for the execution of code to create an object</li>
<li><kbd>member-list</kbd>: The <kbd>member-list</kbd> comprises extra constructors, instance and static method declarations,&#160;<span>abstract bindings,</span> interface declarations, and <span>event&#160;</span>and <span>property&#160;</span>declarations.</li>
</ul>
<p>Here is an example of a class:</p>
<pre>type StudentName(firstName,lastName) = <br/>member this.FirstName = firstName<br/>member this.LastName = lastName</pre>
<p>In the previous example, we have not defined the parameter type. By default, the program considers it as a string value but we can explicitly define a data type, as follows:</p>
<pre>type StudentName(firstName:string,lastName:string) = <br/>member this.FirstName = firstName<br/>member this.LastName = lastName</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Constructor of a class</h1>
                </header>
            
            <article>
                
<p>In F#, the constructor works in a different way to any other .NET language. The constructor creates an instance of a class. A parameter list defines the arguments of the primary constructor and class. The constructor contains <kbd>let</kbd> and <kbd>do</kbd> bindings, which we will discuss next. We can add multiple constructors, apart from the primary constructor, using the <kbd>new</kbd> keyword and it must invoke the primary constructor, which is defined with the class declaration. The syntax of defining a new constructor is as shown:</p>
<pre>new (argument-list) = constructor-body</pre>
<p>Here is an example to explain the concept. In the following code, the <kbd>StudentDetail</kbd> class has two constructors: a primary constructor that takes two arguments and another constructor that takes no arguments:</p>
<pre>type StudentDetail(x: int, y: int) =<br/>do printfn "%d %d" x y<br/>new() = StudentDetail(0, 0)</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">A let and do binding</h1>
                </header>
            
            <article>
                
<p>A <kbd>let</kbd> and <kbd>do</kbd> binding creates the primary constructor of a class and runs when an instance of a class is created.</p>
<p>A function is compiled into a member if it has a <kbd>let</kbd> binding. If the <kbd>let</kbd> binding is a value which is not used in any function or member, then it is compiled into a local variable of a constructor; otherwise, it is compiled into a field of the class.</p>
<p>The <kbd>do</kbd> expression executes the initialized code. As any extra constructors always call the primary constructor,&#160;<kbd>let</kbd> and <kbd>do</kbd> bindings always execute, irrespective of which constructor is called.</p>
<p>Fields that are created by <kbd>let</kbd> bindings can be accessed through the methods and properties of the class, though they cannot be accessed from static methods, even if the static methods take an instance variable as a parameter:</p>
<pre>type Student(name) as self =<br/>    let data = name<br/>    do<br/>        self.PrintMessage()<br/>        member this.PrintMessage() = printf " Student name is %s" data</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Generic type parameters</h1>
                </header>
            
            <article>
                
<p>F# also supports a generic parameter type. We can specify multiple generic type parameters separated by a comma. The syntax of a generic parameter declaration is as follows:</p>
<pre>type MyGenericClassExample&lt;'a&gt; (x: 'a) =<br/>   do printfn "%A" x</pre>
<p>The type of the parameter infers where it is used. In the following code, we call the&#160;<kbd>MyGenericClassExample</kbd>&#160;method and pass a sequence of tuples, so here the parameter type became a sequence of tuples:</p>
<pre>let g1 = MyGenericClassExample( seq { for i in 1 .. 10 -&gt; (i, i*i) } )</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Properties</h1>
                </header>
            
            <article>
                
<p>Values related to an object are represented by properties. In object-oriented programming, properties represent data associated with an instance of an object. The following snippet shows two types of property syntax:</p>
<pre>// Property that has both get and set defined.<br/><br/>[ attributes ]<br/>[ static ] member [accessibility-modifier] [self-  identifier.]PropertyName<br/>    with [accessibility-modifier] get() =<br/>    get-function-body<br/>    and [accessibility-modifier] set parameter =<br/>    set-function-body<br/><br/>// Alternative syntax for a property that has get and set.<br/><br/>[ attributes-for-get ]<br/>[ static ] member [accessibility-modifier-for-get] [self-identifier.]PropertyName =<br/>    get-function-body<br/>    [ attributes-for-set ]<br/>    [ static ] member [accessibility-modifier-for-set] [self-   <br/>    identifier.]PropertyName<br/>    with set parameter =<br/>    set-function-body<br/><br/></pre>
<p>There are two kinds of property declaration:</p>
<ul>
<li><strong>Explicitly specify the value</strong>: We should use the explicit way to implement the property if it has non-trivial implementation. We should use a member keyword for the explicit property declaration.</li>
<li><strong>Automatically generate the value</strong>: We should use this when the property is just a simple wrapper for a value.</li>
</ul>
<p>There are many ways of implementing an explicit property syntax based on need:</p>
<ul>
<li><strong>Read-only</strong>: Only the&#160;<kbd>get()</kbd> method</li>
<li><strong>Write-only</strong>: Only the&#160;<kbd>set()</kbd> method</li>
<li><strong>Read/write</strong>: Both&#160;<kbd>get()</kbd> and <kbd>set()</kbd> methods</li>
</ul>
<p>&#160;An example is shown as follows:</p>
<pre>// A read-only property.<br/>member this.MyReadOnlyProperty = myInternalValue<br/>// A write-only property.<br/>member this.MyWriteOnlyProperty with set (value) = myInternalValue &lt;- value<br/>// A read-write property.<br/>member this.MyReadWriteProperty<br/>    with get () = myInternalValue<br/>    and set (value) = myInternalValue &lt;- value</pre>
<p>Backing stores are private values that contain data for properties. The keyword,&#160;<kbd>member val</kbd>&#160;instructs the compiler to create backing stores automatically and then gives an expression to initialize the property. The F# language supports immutable types, but if we want to make a property mutable, we should use <kbd>get</kbd> and <kbd>set</kbd>. As shown in the following example, the <kbd>MyClassExample</kbd> class has two properties: <kbd>propExample1</kbd> is read-only and is initialized to the argument provided to the primary constructor, and <kbd>propExample2</kbd> is a settable property initialized with a string value <kbd>".Net Core 2.0"</kbd>:</p>
<pre>type MyClassExample(propExample1 : int) =<br/>member val propExample1 = property1<br/>member val propExample2 = ".Net Core 2.0" with get, set</pre>
<div class="packt_tip">Automatically implemented properties don't work efficiently with some libraries, for example, Entity Framework. In these cases, we should use explicit properties.</div>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Static and instance properties</h1>
                </header>
            
            <article>
                
<p>There can be further categorization of properties as static or instance properties. Static, as the name suggests, can be invoked without any instance. The self-identifier is neglected by the&#160;<kbd>static</kbd> property while it is necessary for the instance property. The following is an example of the&#160;<kbd>static</kbd> property:</p>
<pre>static member MyStaticProperty<br/>    with get() = myStaticValue<br/>    and set(value) = myStaticValue &lt;- value</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Abstract properties</h1>
                </header>
            
            <article>
                
<p>Abstract properties have no implementation and are fully abstract. They can be virtual. It should not be <kbd>private</kbd> and if one accessor is <kbd>abstract</kbd> all others must be <kbd>abstract</kbd>. The following is an example of the&#160;<kbd>abstract</kbd> property and how to use it:</p>
<pre>// Abstract property in abstract class.<br/>// The property is an int type that has a get and<br/>// set method<br/>[&lt;AbstractClass&gt;]<br/>type AbstractBase() =<br/>   abstract Property1 : int with get, set<br/><br/>// Implementation of the abstract property<br/>type Derived1() =<br/>   inherit AbstractBase()<br/>   let mutable value = 10<br/>   override this.Property1 with get() = value and set(v : int) = value <br/>   &lt;- v<br/><br/>// A type with a "virtual" property.<br/>type Base1() =<br/>   let mutable value = 10<br/>   abstract Property1 : int with get, set<br/>   default this.Property1 with get() = value and set(v : int) = value <br/>   &lt;- v<br/><br/>// A derived type that overrides the virtual property<br/>type Derived2() =<br/>   inherit Base1()<br/>   let mutable value2 = 11<br/>   override this.Property1 with get() = value2 and set(v) = value2 &lt;- v</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Inheritance and casts</h1>
                </header>
            
            <article>
                
<p>In F#, the inherit keyword is used while declaring a class. The following is the syntax:&#160;</p>
<pre>type MyDerived(...) = inherit MyBase(...) </pre>
<p>In a derived class, we can access all methods and members of the base class, but it should not be a private member. To refer to base class instances in the F# language, the base keyword is used.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Virtual methods and overrides</h1>
                </header>
            
            <article>
                
<p><strong>&#160;</strong>In F#, the&#160;<kbd>abstract</kbd> keyword is used to declare a virtual member. So, here we can write a complete definition of the <kbd>member</kbd> as we use <kbd>abstract</kbd> for virtual. F# is not similar to other .NET languages. Let's have a look at the following example:</p>
<pre>type MyClassExampleBase() =<br/>   let mutable x = 0<br/>   abstract member virtualMethodExample : int -&gt; int<br/>   default u. virtualMethodExample (a : int) = x &lt;- x + a; x<br/><br/>type MyClassExampleDerived() =<br/>   inherit MyClassExampleBase ()<br/>   override u. virtualMethodExample (a: int) = a + 1</pre>
<p>In the previous example, we declared a virtual method,&#160;<kbd>virtualMethodExample</kbd>, in a base class,&#160;<kbd>MyClassExampleBase</kbd>, and overrode it in a derived class,&#160;<kbd>MyClassExampleDerived</kbd>.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Constructors and inheritance</h1>
                </header>
            
            <article>
                
<p>An inherited class constructor must be called in a derived class. If a base class constructor contains some arguments, then it takes parameters of the derived class as input. In the following example, we will see how derived class arguments are passed in the base class constructor with inheritance:</p>
<pre>type MyClassBase2(x: int) =<br/>   let mutable z = x * x<br/>   do for i in 1..z do printf "%d " i<br/><br/><br/></pre>
<pre>type MyClassDerived2(y: int) =<br/>   inherit MyClassBase2(y * 2)<br/>   do for i in 1..y do printf "%d " i</pre>
<p>If a class has multiple constructors, such as <kbd>new(str)</kbd> or <kbd>new()</kbd>, and this class is inherited in a derived class, we can use a base class constructor to assign values. For example, <kbd>DerivedClass</kbd>, which inherits <kbd>BaseClass</kbd>, has <kbd>new(str1,str2)</kbd>, and in place of the first string, we pass&#160;<kbd>inherit BaseClass(str1)</kbd>. Similarly for blank, we wrote&#160;<kbd>inherit BaseClass()</kbd>. Let's explore the following example for more detail:</p>
<pre>type BaseClass =<br/>    val string1 : string<br/>    new (str) = { string1 = str }<br/>    new () = { string1 = "" }<br/><br/>type DerivedClass =<br/>    inherit BaseClass<br/><br/>    val string2 : string<br/>    new (str1, str2) = { inherit BaseClass(str1); string2 = str2 }<br/>    new (str2) = { inherit BaseClass(); string2 = str2 }<br/><br/>let obj1 = DerivedClass("A", "B")<br/>let obj2 = DerivedClass("A")</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Functions and lambda expressions</h1>
                </header>
            
            <article>
                
<p>A lambda expression is one kind of anonymous function, which means it doesn't have a name attached to it. But if we want to create a function which can be called, we can use the <kbd>fun</kbd> keyword with a lambda expression. We can pass the input parameter in the lambda function, which is created using the <kbd>fun</kbd> keyword. This function is quite similar to a normal F# function. Let's see a normal F# function and a lambda function:</p>
<pre>// Normal F# function<br/>let addNumbers a b = a+b<br/>// Evaluating values<br/>let sumResult = addNumbers 5 6 <br/>// Lambda function and evaluating values<br/>let sumResult = (fun (a:int) (b:int) -&gt; a+b) 5 6<br/>// Both the function will return value sumResult = 11</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Handling data – tuples, lists, record types, and data manipulation</h1>
                </header>
            
            <article>
                
<p>F# supports many data types, for example:</p>
<ul>
<li><strong>Primitive types</strong>: <kbd>bool</kbd>, <kbd>int</kbd>, <kbd>float</kbd>, <kbd>string</kbd> values.</li>
<li><strong>Aggregate type</strong>:&#160;<kbd>class</kbd>, <kbd>struct</kbd>, <kbd>union</kbd>, <kbd>record</kbd>, and <kbd>enum</kbd>&#160;</li>
<li><strong>Array</strong>: <kbd>int[]</kbd>, <kbd>int[ , ]</kbd>, and <kbd>float[ , , ]</kbd></li>
<li><strong>Tuple</strong>: <kbd>type1 * type2 *</kbd>&#160;like (<kbd>a,1,2,true</kbd>) type is—<kbd>char * int * int * bool</kbd></li>
<li><strong>Generic</strong>: <kbd>list&lt;’x&gt;</kbd>, dictionary <kbd>&lt; ’key, ’value&gt;</kbd></li>
</ul>
<p>In an F# function, we can pass one tuple instead of multiple parameters of different types. Declaration of a&#160;<kbd>tuple</kbd> is very simple and we can assign values of a <kbd>tuple</kbd> to different variables, for example:</p>
<pre>let tuple1 = 1,2,3<br/><br/>// assigning values to variables , v1=1, v2= 2, v3=3<br/><br/>let v1,v2,v3 = tuple1<br/><br/>// if we want to assign only two values out of three, use “_” to skip the value. Assigned values: v1=1, //v3=3<br/><br/>let v1,_,v3 = tuple</pre>
<p>In the preceding examples, we saw that&#160;<kbd>tuple</kbd> supports pattern matching. These are option types and an option type in F# supports the idea that the value may or not be present at runtime.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">List</h1>
                </header>
            
            <article>
                
<p>List is a generic type implementation. An F# list is similar to a linked list implementation in any other functional language. It has a special opening and closing bracket construct, a short form of the standard empty list (<kbd>[ ]</kbd>) syntax:</p>
<pre>let empty = [] // This is an empty list of untyped type or we can say     //generic type. Here type is: 'a list<br/><span>let intList = [10;20;30;40] // this is an integer type list</span></pre>
<p>The <kbd>cons</kbd> operator is used to prepend an item to a list using a double colon&#160;<kbd>cons(prepend,::)</kbd>. To append another list to one list, we use the append operator—<kbd>@</kbd>:</p>
<pre>// prepend item x into a list<br/>let addItem xs x = x :: xs <br/>let newIntList = addItem intList 50 // add item 50 in above list //“intlist”, final result would be- [50;10;20;30;40]<br/><br/>// using @ to append two list<br/>printfn "%A" (["hi"; "team"] @ ["how";"are";"you"])<br/>// result – ["hi"; "team"; "how";"are";"you"]</pre>
<p>Lists are decomposable using pattern matching into a head and a tail part, where the head is the first item in the list and the tail part is the remaining list, for example:</p>
<pre>printfn "%A" newIntList.Head<br/>printfn "%A" newIntList.Tail<br/>printfn "%A" newIntList.Tail.Tail.Head<br/>let rec listLength (l: 'a list) =<br/>    if l.IsEmpty then 0<br/>        else 1 + (listLength l.Tail)<br/>printfn "%d" (listLength newIntList)</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Record type</h1>
                </header>
            
            <article>
                
<p>The <kbd>class</kbd>, <kbd>struct</kbd>, <kbd>union</kbd>, <kbd>record</kbd>, and <kbd>enum</kbd> types come under aggregate types. The record type is one of them, it can have <em>n</em> number of members of any individual type. Record type members are by default immutable but we can make them mutable. In general, a record type uses the members as an immutable data type. There is no way to execute logic during instantiation as a record type don't have constructors. A record type also supports match expression, depending on the values inside those records, and they can also again decompose those values for individual handling, for example:</p>
<pre>type Box = {width: float ; height:int }<br/>let giftbox = {width = 6.2 ; height = 3 }</pre>
<p>In the previous example, we declared a <kbd>Box</kbd> with <kbd>float</kbd>&#160;a value <kbd>width</kbd> and an integer <kbd>height</kbd>. When we declare&#160;<kbd>giftbox</kbd>, the compiler automatically detects its type as <kbd>Box</kbd> by matching the value types. We can also specify type like this:</p>
<pre>let giftbox = {Box.width = 6.2 ; Box.height = 3 }</pre>
<p>or</p>
<pre>let giftbox : Box = {width = 6.2 ; height = 3 }</pre>
<p>This kind of type declaration is used when we have the same type of fields or field type declared in more than one type. This declaration is called a record expression.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Object-oriented programming in F#</h1>
                </header>
            
            <article>
                
<p>F# also supports implementation inheritance, the creation of object, and interface instances. In F#, constructed types are fully compatible .NET classes which support one or more constructors. We can implement a&#160;<kbd>do</kbd> block with code logic, which can run at the time of class instance creation. The constructed type supports inheritance for class hierarchy creation. We use the&#160;<kbd>inherit</kbd> keyword to inherit a class. If the member doesn't have implementation, we can use the&#160;<kbd>abstract</kbd> keyword for declaration. We need to use the <kbd>abstractClass</kbd> attribute on the class to inform the compiler that it is abstract. If the <kbd>abstractClass</kbd> attribute is not used and <kbd>type</kbd> has all abstract members, the F# compiler automatically creates an <kbd>interface</kbd> type. Interface is automatically inferred by the compiler as shown in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="204" width="369" src="assets/0f70fe4c-bfb1-46c7-bc41-22531b0061d0.png"/></div>
<p>The&#160;<kbd>override</kbd>&#160;keyword is used to override the base class implementation; to use the base class implementation of the same member, we use the&#160;<kbd>base</kbd> keyword.</p>
<p>In F#, interfaces can be inherited from another interface. In a class, if we use the construct interface, we have to implement all the members in the interface in that class, as well. In general, it is not possible to use interface members from outside the class instance, unless we upcast the instance type to the required interface type.</p>
<p>To create an instance of a class or interface, the object expression syntax is used. We need to override virtual members if we are creating a class instance and need member implementation for interface instantiation:</p>
<pre>type IExampleInterface = <br/>    abstract member IntValue: int with get<br/>    abstract member HelloString: unit -&gt; string<br/><br/>type PrintValues() = <br/>    interface IExampleInterface with<br/>        member x.IntValue = 15<br/>        member x.HelloString() = sprintf "Hello friends %d" (x :&gt; <br/>        IExampleInterface).IntValue<br/><br/>let example = <br/>    let varValue = PrintValues() :&gt; IExampleInterface<br/>    { new IExampleInterface with<br/>        member x.IntValue = varValue.IntValue<br/>        member x.HelloString() = sprintf "&lt;b&gt;%s&lt;/b&gt;" <br/>        (varValue.HelloString()) }<br/><br/>printfn "%A" (example.HelloString())</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Exception handling</h1>
                </header>
            
            <article>
                
<p>The&#160;<kbd>exception</kbd>&#160;keyword is used to create a custom exception in F#; these exceptions adhere to Microsoft best practices, such as constructors supplied, serialization support, and so on. The keyword <kbd>raise</kbd> is used to throw an exception. Apart from this, F# has some helper functions, such as <kbd>failwith</kbd>, which throws a failure exception at F# runtime, and <kbd>invalidop</kbd>, <kbd>invalidarg</kbd>, which throw the .NET Framework standard type invalid operation and invalid argument exception, respectively.</p>
<p><kbd>try</kbd>/<kbd>with</kbd> is used to catch an exception; if an exception occurred on an expression or while evaluating a value, then the&#160;<kbd>try</kbd>/<kbd>with</kbd> expression could be used on the right side of the value evaluation and to assign the value back to some other value. <kbd>try</kbd>/<kbd>with</kbd> also supports pattern matching to check an individual exception type and extract an item from it.&#160;<kbd>try</kbd>/<kbd>finally</kbd> expression handling depends on the actual code block. Let's take an example of declaring and using a custom exception:</p>
<pre>exception MyCustomExceptionExample of int * string<br/>   raise (MyCustomExceptionExample(10, "Error!"))</pre>
<p>In the previous example, we created a custom exception called&#160;<kbd>MyCustomExceptionExample,</kbd> using the <kbd>exception</kbd> keyword, passing value fields which we want to pass. Then we used the <kbd>raise</kbd> keyword to raise exception passing values, which we want to display while running the application or throwing the exception. However, as shown here, while running this code, we don't get our custom message in the error value and the standard exception message is displayed:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/91765e3a-daf7-4587-b354-bd4fa2c4c6df.png"/></div>
<p>We can see in the previous screenshot that the exception message doesn't contain the message that we passed. In order to display our custom error message, we need to override the standard message property on the exception type. We will use pattern matching assignment to get two values and up-cast the actual type, due to the internal representation of the exception object.</p>
<p>If we run this program again, we will get the custom message in the exception:</p>
<pre>exception MyCustomExceptionExample of int * string<br/> with<br/>        override x.Message = <br/>            let (MyCustomExceptionExample(i, s)) = upcast x<br/>            sprintf "Int: %d Str: %s" i s<br/>   <br/> raise (MyCustomExceptionExample(20, "MyCustomErrorMessage!"))</pre>
<p>Now, we will get the following error message:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/7a334951-89eb-43d2-a946-359d7c4bb5e6.png"/></div>
<p>In the previous screenshot, we can see our custom message with integer and string values included in the output. We can also use the helper function,&#160;<kbd>failwith</kbd>, to raise a failure exception, as it includes our message as an error message, as follows:</p>
<pre>failwith "An error has occurred"</pre>
<p>The preceding error message can be seen in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img height="336" width="596" src="assets/998a4b62-ba78-4fd6-95eb-ae01ae6220a6.png"/></div>
<p>Here is a detailed exception screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/a29b4a48-f087-4184-9a18-1d6906e7d23f.png"/></div>
<p>An example of the&#160;<kbd>invalidarg</kbd> helper function follows. In this factorial function, we are checking that the value of <kbd>x</kbd> is greater than zero. For cases where <kbd>x</kbd> is less than <kbd>0</kbd>, we call&#160;<kbd>invalidarg</kbd>, pass <kbd>x</kbd> as the parameter name that is invalid, and then some error message saying the value should be greater than 0. The <kbd>invalidarg</kbd> helper function throws an invalid argument exception from the standard system namespace in .NET:</p>
<pre>let rec factorial x = <br/>    if x &lt; 0 then invalidArg "x" "Value should be greater than zero"<br/>    match x with <br/>    | 0 -&gt; 1<br/>    | _ -&gt; x * (factorial (x - 1))</pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Data access layer with F#</h1>
                </header>
            
            <article>
                
<p>The F# type provider feature gives the flexibility to access different types of data, such as databases, structured types (that is, JSON, XML, CSV, HTML) and web-scale data.</p>
<p>First, let's look at data access resources.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">CSV, HTML, JSON, and XML data</h1>
                </header>
            
            <article>
                
<p>In F# applications and scripts, <kbd>FSharp.Data.dll</kbd> is used to implement the functionality to access data. It is also useful for structured file formats such as JSON, XML and for consuming freebase services. A sample document structure is used for type safe access to the document; it works as a type provider, like the CSV type provider takes a CSV sample as input and creates a column format data for that sample.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Providers</h1>
                </header>
            
            <article>
                
<p>F# supports different types of provider, such as:</p>
<ul>
<li><kbd>HtmlProvider&lt;&gt;</kbd></li>
<li><kbd>JsonProvider&lt;&gt;</kbd></li>
<li><kbd>XmlProvider&lt;&gt;</kbd></li>
<li><kbd>WorldBankDataProvider&lt;&gt;</kbd></li>
<li><kbd><span>CsvProvider&lt;&gt;</span></kbd></li>
</ul>
<p>Let's discuss one of them, for example, the CSV type provider. The <kbd>FSharp.Data</kbd>&#160;NuGet package contains <kbd>CsvProvider</kbd>. We can pass a <kbd>.csv</kbd> file and can read other <kbd>.csv</kbd> files; for example, we created a <kbd>.csv</kbd> file as follows:</p>
<div class="CDPAlignCenter CDPAlign"><img height="133" width="300" src="assets/2b94d1a6-7324-412d-927d-9dcc439fe0df.png"/></div>
<p>Now, we have another <kbd>.csv</kbd> file which we want to read:</p>
<div class="CDPAlignCenter CDPAlign"><img height="134" width="228" src="assets/17bfca3d-c442-4757-9c16-da1a4e3d17f9.png"/></div>
<p>Here is a code snippet:</p>
<pre>open FSharp.Data<br/><br/>  type Books = CsvProvider&lt;"..\ExampleCSV.csv"&gt;<br/>  let Saleitems = Books.Load("..\ExampleCSV-2.csv")<br/>  let firstRow = Saleitems.Rows |&gt; Seq.head</pre>
<p>Let's see what values are calculated by the F# compiler for <kbd>Salesitem</kbd>, as the&#160;<kbd>ExampleCSV</kbd> file is passed, for example:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/cba4b196-ef5b-4374-ac90-48401a08ae84.png"/></div>
<p>Here, we can see the compiler is able to detect the header name and took it from the second <kbd>.csv</kbd> file. We can control column types by customizing them using the&#160;<kbd>InferRows</kbd> static parameter of <kbd>CsvProvider</kbd>. To use the full file, we can pass <kbd>0</kbd>. If the first row of a file is not a header, then we can pass the&#160;<kbd>HasHeaders</kbd> static parameter value to <kbd>false</kbd>, for example:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/42b792ae-5584-4f09-87c1-902afbfc51cf.png"/></div>
<p>The <kbd>FSharp.Data</kbd> library also contains helpers for parsing JSON, HTML files, and helpers to send HTTP requests. It is available with the name <kbd>FSharp.Data</kbd> on NuGet.</p>
<p>JSON.NET is a JSON framework for .NET. It has full support with F# serialization from and to JSON. We can install using NuGet by using the command:</p>
<pre><strong>Install -Package Newtonsoft.Json</strong></pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Data access tools</h1>
                </header>
            
            <article>
                
<p>We discussed data type providers earlier. F# also has dynamic API support for faster and dynamic data retrieval. It contains CSV, HTML, JSON parsers, and also tools for HTTP request parsing. Let's briefly&#160;<span>discuss&#160;</span><span>each of them:</span></p>
<ul>
<li><strong>CSV parser</strong>:&#160;To access data dynamically, we can use the CSV parser. The afore mentioned CSV provider is built on top of the F# CSV parser. The&#160;<kbd>FSharp.Data</kbd> namespace has the&#160;<kbd>CsvFile</kbd> type, which provides two methods for loading data: the&#160;<kbd>Parse</kbd> method for string data, and the&#160;<kbd>Load</kbd> method for reading data from a file or any web source (example: <kbd>CsvFIle.Load(&lt;file path&gt;)</kbd>).</li>
<li><strong>HTML parser</strong>:&#160;It parses HTML documents into the DOM. When it gets parsed into DOM, F# supports many extension functions for HTML DOM elements, to extract information from the web page. Let's see an example where we will search <kbd>.NET Core</kbd> in Google and parse the first search result page, getting all URLs and hyperlinks:</li>
</ul>
<pre style="padding-left: 60px">open FSharp.Data<br/>let resultsDocument = HtmlDocument.Load("http://www.google.co.in/search?q=.NET Core")</pre>
<p style="padding-left: 60px">In the previous code, using <kbd>HtmlDocument.Load(),</kbd> we are parsing the web page into DOM. <kbd>resultsDocument</kbd> contains all data from the page, as this method will make a synchronous web call. We can also make an asynchronous call using the method,&#160;<kbd>HtmlDocument.AsyncLoad()</kbd>. To extract data from the result document, we first find all HTML anchor tags and then find all <kbd>href</kbd>&#160;tags to get the link and its text:</p>
<pre style="padding-left: 60px">let x =<br/>    resultsDocument.Descendants ["a"]<br/>    |&gt; Seq.choose (fun x -&gt;<br/>           x.TryGetAttribute("href")<br/>           |&gt; Option.map (fun a -&gt; x.InnerText(), a.Value())<br/>    )<br/>let Z =<br/>    x<br/>    |&gt; Seq.filter (fun (name, url) -&gt; <br/>                    name &lt;&gt; "Cached" &amp;&amp; name &lt;&gt; "Similar" &amp;&amp;  <br/>                    url.StartsWith("/url?"))<br/>    |&gt; Seq.map (fun (name, url) -&gt; name, url.Substring(0, <br/>    url.IndexOf("&amp;sa=")).Replace("/url?q=", ""))<br/>    |&gt; Seq.toArray</pre>
<p style="padding-left: 60px">The output will show all first page search results for <kbd>.NET Core</kbd> in Google. The result looks like this:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/299b1578-dbb6-44fc-b43a-0edcf4267fb7.png"/></div>
<ul>
<li><strong>JSON Parser</strong>: The same as the CSV provider, the JSON provider is built on top of the JSON parser. We need the same library for all the parsers:&#160;<kbd>FSharp.Data.dll</kbd>. It has the&#160;<kbd>JsonValue</kbd>&#160;type for parsing. Here is an example:</li>
</ul>
<pre style="padding-left: 60px">open FSharp.Data<br/>let empInfo =<br/>  JsonValue.Parse(""" <br/>    { "name": "Neha", "Company": "Microsoft","Projects": [ "Proj1",    <br/>    "Proj2" ] } """)</pre>
<p style="padding-left: 60px"><kbd>FSharp.Data.Extensions</kbd> supports many extension methods such as <kbd>value.Properties()</kbd>&#160;and gives a list of properties of a record node.</p>
<ul>
<li><strong>HTTP Utilities</strong>: In the&#160;<kbd>FSharp.Data</kbd> namespace, we have HTTP utilities, which are easy and quick for HTTP requests, post data or responses such as get status code. HTTP has a few overloaded methods,&#160;<kbd>requestString</kbd> and <kbd>AsyncRequest</kbd> or <kbd>AsyncRequestString</kbd> and <kbd>AsyncRequest</kbd>; these can create a simple request synchronously or asynchronously, respectively. Here is an example:</li>
</ul>
<pre style="padding-left: 60px">open FSharp.Data<br/>Http.RequestString("http://rishabhverma.net ")<br/><br/>// Download web site asynchronously<br/>async { let! html = Http.AsyncRequestString("http://rishabhverma.net ")<br/>        printfn "%d" html.Length }<br/>        |&gt; Async.Start<br/><br/>// Verifying the response:<br/>let response = Http.Request("http://rishabhverma.net/algorithmics-science-and-art/", silentHttpErrors = true)<br/><br/>// Examine information about the response<br/>response.Headers<br/>response.Cookies<br/>response.ResponseUrl<br/>response.StatusCode</pre>
<p>Here is the result:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/9ff45d98-d657-4f55-af0e-4b88dd0c30df.png"/></div>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">SQL data access</h1>
                </header>
            
            <article>
                
<p>In F#, there are multiple libraries for SQL data access. We can browse them in NuGet; a few of them are discussed as follows:</p>
<ul>
<li><kbd>FSharp.Data.SqlClient</kbd>:&#160;This library provides <kbd>SqlCommandProvider</kbd>, which gives type safe access to transactional SQL languages. <kbd>SqlProgrammabilityProvider</kbd> provides quick access to a SQL server <strong>stored procedure</strong> (<strong>SP</strong>), tables, and functions, and <kbd>SqlEnumProvider</kbd> generates an&#160;<kbd>enum</kbd> type on the ground of static lookup data from an ADO.NET-compliant source.<br/>
To install the&#160;<kbd>FSharp.Data.SqlClient</kbd> library from NuGet, use the following command:</li>
</ul>
<pre style="padding-left: 60px"><strong>PM&gt; Install-Package FSharp.Data.SqlClient</strong></pre>
<ul>
<li><kbd>FSharp.Data.SQLProvider</kbd>: <kbd>SQLProvider</kbd> is a general .NET/Mono SQL database provider. This library supports automatic constraint navigation, CRUD operations with identity support, asynchronous operations, LINQ query, functions, SP support, record types mapping, .NET Core/.NET Standard, and so on. <kbd>SQLProvider</kbd> has explicit implementation for SQL Server, SQLite, Oracle, MySQL, MSAccess, Firebird, and so on. SQL Server and MS Access don't require third-party ADO.NET connector objects, the rest all require this.<br/>
To install the&#160;<kbd>FSharp.Data.SqlProvider</kbd> library from NuGet, use the following command:</li>
</ul>
<pre style="padding-left: 60px" class="mce-root"><strong>PM&gt; Install-Package SQLProvider</strong></pre>
<ul>
<li>The <kbd>SqlDataConnection</kbd>: <kbd>SqlDataConnection</kbd> type provider generates types, for data in SQL DB on live connections. It is for accessing SQL using LINQ queries. It requires a Microsoft SQL server. We need three references in a F# project—<kbd>FSharp.Data.TypeProviders</kbd>, <kbd>System.Data</kbd>, and <kbd>System.Data.Linq</kbd>. Here is an example:</li>
</ul>
<pre style="padding-left: 60px">type dbSchemaExample = SqlDataConnection&lt;"Data Source=SERVER\INSTANCENAME;Initial Catalog=MyDatabase;Integrated Security=SSPI;"&gt;<br/><br/>let db = dbSchemaExample.GetDataContext()</pre>
<ul>
<li>The&#160;<kbd>SqlEntityConnection</kbd>: <kbd>SqlEntityConnection</kbd> type provider is for accessing SQL through LINQ queries and Entity Framework. It works with many databases. We need <kbd>System.Data.Linq</kbd>, <kbd>System.Data.Entity</kbd>,&#160;and <kbd>Microsoft.FSharp.Data.TypeProviders</kbd> references. Here is an example:</li>
</ul>
<pre style="padding-left: 60px">type private EntityConnectionExample = SqlEntityConnection&lt;ConnectionString="Server=SERVER\InstanceName;Initial Catalog=microsoft;Integrated Security=SSPI;MultipleActiveResultSets=true",Pluralize = true&gt;</pre>
<ul>
<li><strong>ADO.NET</strong>: It provides data access services and functionality for writing managed code and consistent data source access for SQL Server, and also data sources exposed through OLEDB or XML. Customers can use ADO.NET to connect with any data source to retrieve, manipulate, and update data. It can perform all CRUD operations. ADO.NET also supports frontend database creation, and middle-tier objects for application, tools, or browsers.</li>
</ul>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Web data access</h1>
                </header>
            
            <article>
                
<p>The <kbd>FSharp.Data</kbd> library provides many type providers, and in F# it is very easy to integrate these data stores in programming. Additional web data stores can be accessed using JSON, XML, and CSV format support of F#.</p>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Querying SQL vNext with F#</h1>
                </header>
            
            <article>
                
<p>SQL vNext is Microsoft's major release for SQL open source and platform-independent DBs. It has introduced major features of the relational database to Linux: in-memory OLTP, in-memory columnstores, transparent data encryption, Always Encrypted, and row-level security, to make SQL Server the platform of choice across operating systems. It provides us with development language selection options, on-premise or cloud options, and operating system options such as Linux (Red Hat, SUSE, and Ubuntu), and Linux-based Docker containers or windows, adaptive query processing, SQL graphs, improvements to analysis services, reporting services, and integration services.</p>
<p>It has new features such as integration services; till now SQL Server 2016 SSIS package execution was limited to one machine, but now integration services give high-performance package execution by distributing execution on multiple machines like parallel execution on different servers. It involves:</p>
<ul>
<li><strong>SSIS Scale Out Master</strong>:&#160;It is for scaling out management and receives package execution requests from the user</li>
<li><strong>SSIS Scale Out Worker</strong>:&#160;It pulls execution tasks from the scaled out master and works on package execution</li>
</ul>
<p>In an F# program, we can read data using the LINQ query by writing in F# languages or by using ADO.NET classes, such as <kbd>SqlCommand</kbd>. Mostly ADO.NET classes are used when we need a simple query call but while calling SP, we must add multiple parameters using <kbd>SqlParameter</kbd> in this approach. We can use dynamic operators for dynamic invocations in F#. As we saw providers have helper functions, which are used but each has many drawbacks. Let's discuss how to define a query and create helper functions with parameters. Here is some example code for illustration:</p>
<pre>open FSharp.Data<br/>open System.Data.SqlClient<br/><br/>type SqlQueryExample =<br/>    {<br/>        Query : string<br/>        Parameters : (string * obj) list<br/>    }</pre>
<p>To get <kbd>Sqlconnection</kbd> and other ADO.NET methods, install the NuGet package of <kbd>System.Data.SqlClient</kbd>. In the preceding code, we defined a type <kbd>SqlQueryExample</kbd>,where <kbd>Query</kbd> is a string and <kbd>Parameters</kbd> is a tuple type. We created a module,&#160;<kbd>QueryHelpersForFsharp</kbd>, where we defined <kbd>param</kbd> which takes two values,&#160;<kbd>name</kbd> and <kbd>value</kbd>, and a function,&#160;<kbd>sqlFunction</kbd> which takes two parameters,&#160;<kbd>query</kbd> and <kbd>parameters</kbd>; we are assigning these values:</p>
<pre>module QueryHelpersForFsharp =<br/><br/>    let param name value =<br/>        ( name, value )<br/><br/>    let sqlFunction query parameters =<br/>        {</pre>
<pre>            Query = query<br/>            Parameters = parameters<br/>        }</pre>
<p>We can use the preceding module and use&#160;<kbd>sqlFunction</kbd> and the&#160;<kbd>param</kbd>&#160;parameter to run a <kbd>query.</kbd> The&#160;<kbd>sqlFunction.query&lt;type&gt;</kbd> function will run the query and it will convert each data row into a specified type object. <kbd>Query</kbd> is not created in the same place where the&#160;<kbd>query</kbd> execution code is written. It is a separate piece of code:</p>
<pre>open QueryHelpersForFsharp<br/><br/>let employeeDetail empId empName =<br/>    sqlFunction<br/>        """<br/>        SELECT empId, empName<br/>          FROM Employee<br/>        OFFSET @EmpId ROWS<br/>         FETCH<br/>          NEXT @EmpName ROWS ONLY<br/>        ;<br/>        """<br/>        [<br/>            param "EmpId" empId<br/>            param "EmpName" empName<br/>        <br/>type employeeDetail =<br/>    {<br/>        EmpId : int<br/>        EmpName : string<br/>    }<br/><br/>let query = employeeDetail request.EmpId request.EmpName<br/>let EmployeeAsync = Sql.query&lt;employeeDetail&gt; connectString query</pre>
<p>Let's see an example of data insertion using the ADO.NET function by <kbd>FsSql</kbd>. We will create an entity that is one row of a table and insert it into the DB:</p>
<pre>open FSharp.Data<br/>open System.Data.SqlClient<br/>open System<br/><br/><br/>type Employee() =<br/>    member val Id = 0 with get,set<br/> <br/>    member val EmpId = Guid.Empty with get,set<br/>    member val JoiningDate = DateTimeOffset.MinValue with get,set<br/>    member val LeftOrganizationOn = DateTimeOffset.MinValue with  <br/>    get,set<br/>    member val Name = string with get,set<br/>    member val ReportingTo = string with get,set<br/>    member val Salary = 0.0m with get,set</pre>
<p>To insert records, we created a type,&#160;<kbd>changeQueryObject</kbd>, which has <kbd>query</kbd> as string type and <kbd>parameters</kbd> as the&#160;<kbd>SqlParameter</kbd> type <kbd>list</kbd>. We created a <kbd>private&#160;insert ()</kbd>&#160;method which takes <kbd>Employee</kbd> data as input, and here <kbd>query</kbd> has the&#160;<kbd>insert sql query</kbd> string and <kbd>parameter</kbd> contains a list of <kbd>SqlParameters</kbd>:</p>
<pre>type changeQueryObject =<br/>{<br/>    query : string;<br/>    parameters : Sql.Parameter list;<br/>}<br/>let private insert (employee : Employee ) =<br/>{<br/>    query = "INSERT INTO \"intersect\".\"Employee\"(<br/>                         empId, joiningDate, leftOrganizationOn, name,   <br/>                         reportingTo, salary)<br/>             VALUES (@empId, @joiningDate, @leftOrganizationOn, @name,     <br/>             @reportingTo, @salary);<br/>             RETURNING id;";<br/>    parameters = [<br/>                 P("@empId", employee.EmpId);<br/>                 P("@joiningDate", employee.JoiningDate);<br/>                 P("@leftOrganizationOn", employee.LeftOrganizationOn);<br/>                 P("@name", employee.Name);<br/>                 P("@reportingTo", employee.ReportingTo);<br/>                 P("@salary", employee.Salary);<br/>             ]<br/>}</pre>
<p>To execute this, code the following:</p>
<pre><strong>let executeScalar (queryObj : changeQueryObject) = </strong><strong>sql.ExecScalar queryObj.query queryObj.parameters</strong></pre>


            </article>

            
        </section>
    </div>


    <div id="sbo-rt-content"><section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed functional programming and its features, such as higher-order functions, purity, lazy evaluation, currying, and so on. We learned about F# basics such as classes, <kbd>let</kbd> and <kbd>do</kbd> bindings, generic type parameters, properties in F#, how to write functions and lambda expressions in F#, exception handling, and so on. Also, we saw different types of data provider in F# and how different types of data parser work. We also learned about querying SQL vNext with F#.&#160;This brings us towards the end of this book but our journey of learning has just got started.</p>
<p>&#160;</p>


            </article>

            
        </section>
    </div>
</body>
</html>