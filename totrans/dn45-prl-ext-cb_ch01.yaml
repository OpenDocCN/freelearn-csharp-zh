- en: Chapter 1. Getting Started with Task Parallel Library
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Waiting for tasks to finish
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Returning results from a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Passing data to a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a child task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lazy task execution
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling task exceptions using try/catch block
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling task exceptions with AggregateException.Handle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancelling a task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancelling one of many tasks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: At the beginning of the personal computer era, there was no concept of multiple
    threads offered by an operating system. Typically, operating system code and application
    code ran on a single thread of execution. The problem with this was that if a
    single application misbehaved, or simply took a long time to execute, the whole
    machine would stall, and often had to be rebooted.
  prefs: []
  type: TYPE_NORMAL
- en: As the development of the Windows operating systems progressed, Microsoft realized
    that they needed to improve this situation. In the Windows NT kernel, each application
    runs in its own process. A process is a collection of resources in which a virtual
    address space is allocated for each application. The advent of these processes
    ensured that code and data being used by one application could not be accessed
    and corrupted by another application, thus improving the reliability of the system.
  prefs: []
  type: TYPE_NORMAL
- en: Each process in Windows was also given its own thread. A thread is an operating
    system construct that functions like a virtual CPU. At any given moment, one of
    these threads is allowed to run on the physical CPU for a slice of time. When
    the time for a thread to run expires, it is swapped off of the CPU for another
    thread. Therefore, if a single thread enters an infinite loop, it can't monopolize
    all of the CPU time on the system. At the end of its time slice, it will be switched
    out for another thread.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, computers with multiple processors began to appear. These multiple
    processor machines were able to execute multiple threads at once. It became possible
    for an application to spawn new threads to run a compute-bound process asynchronously,
    thus gaining a performance improvement.
  prefs: []
  type: TYPE_NORMAL
- en: Over the past few years, the trend in processor development has shifted from
    making processors faster and faster, to making processors with multiple CPU cores
    on a single physical processor chip. Individuals who purchase these new machines
    expect their investment to pay off in terms of applications which are able to
    run efficiently across the available processor cores. Maximizing the utilization
    of the computing resources provided by the next generation of multi-core processors
    requires a change in the way the code is written.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET framework has supported writing multi-threaded applications from the
    beginning, but the complexity of doing so has remained just out of reach for many
    .NET developers. To fully take the advantage of multi-threading, you needed to
    know quite a bit about how Windows works under the hood. For starters, you had
    to create and manage your own threads, which can be a demanding task as the number
    of threads in an application grows, and can often be the source of hard-to-find
    bugs.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, help has arrived. Starting in .NET 4.0, Microsoft introduced the .NET
    Parallel Extensions, which gave us a new runtime, new class library types (the
    **Task Parallel Library** (**TPL**)), and new diagnostic tools to help with the
    inherent complexities of parallel programming.
  prefs: []
  type: TYPE_NORMAL
- en: The TPL isn't just a collection of new types. It's a completely new way of thinking
    about parallel programming. No longer do we need to think in terms of threads.
    With the TPL, we can now think in terms of `task`. With this new task-based model,
    we just need to figure out the pieces of our application that can execute concurrently,
    and convert those pieces into tasks. The runtime will take care of managing and
    creating all of the underlying threads that actually do the work. The `System.Threading.Task`
    class in itself is just a wrapper for passing a delegate, which is a data structure
    that refers to a `static` method or to a class instance, and an instance method
    of that class.
  prefs: []
  type: TYPE_NORMAL
- en: A TPL `task` still uses the classic thread pool internally, but the heavy lifting
    of spinning up new threads to carry out the `tasks` and determining the optimum
    number of threads required to take full advantage of the hardware, is all done
    by the runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will take a look at the basics of creating a parallel `task`.
    You will learn how to pass data into a `Task` using the `Task` state object, returning
    data from a `Task`, cancelling the `Task`, and handling exceptions within a `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Tasks` are an abstraction in the .NET framework to represent asynchronous
    units of work. In some ways, a task resembles the creation of a classic .NET thread,
    but provides a higher level of abstraction, which makes your code easier to write
    and read.'
  prefs: []
  type: TYPE_NORMAL
- en: We will look at the three basic ways to create and run a new task.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Parallel.Invoke()` method: This method provides an easy way to run any
    number of concurrent statements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Task.Start()` method: This method starts a task and schedules it for execution
    with `TaskScheduler`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `Task.Factory.StartNew()` method: This method creates and starts a task
    using `Task.Factory`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this recipe, we will create a new task using each of these three methods.
    To give our tasks something to do, we will be using `WebClient` to read the text
    of three classic books. We will then split the words of each book into a string
    array, and display a count of the words in each book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Ok, let's start building a `Console` application that demonstrates the various
    ways to create a parallel task.
  prefs: []
  type: TYPE_NORMAL
- en: Launch Visual Studio 2012.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a new project using the C# **Console Application** project template, and
    assign `SimpleTasks` as the **Solution name** as shown in the following screenshot:![How
    to do it…](img/0225OT_01_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` statements at the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Downloading the example code**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You can download the example code files for all Packt books you have purchased
    from your account at [http://www.packtpub.com](http://www.packtpub.com). If you
    purchased this book elsewhere, you can visit [http://www.packtpub.com/support](http://www.packtpub.com/support)
    and register to have the files e-mailed directly to you.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'First, let''s create a task using `Parallel.Invoke`. Add the following code
    to the `Main` method of the `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s start `task` using the `Start` method of the `Task` object. Add
    the following code to the `Main` method of the `Program` class just below the
    code for the previous step:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, let''s create `task` using `Task.Factory.StartNew`. Add the following
    code to the `Main` method of the `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot. Note that the exact order of the text you
    see may vary as `tasks` run asynchronously:![How to do it…](img/0225OT_01_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Parallel.Invoke` method can implicitly create and run any number of statements
    concurrently by passing an action delegate for each delegate of work to be done.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: It is worth noting however, that the number of `tasks` actually created by `Parallel.Invoke`
    may or may not be equal to the number of delegates passed in, especially if there
    are a large number of delegates.
  prefs: []
  type: TYPE_NORMAL
- en: Using `Task.Start()` or `Task.Factory.StartNew()` creates new tasks explicitly.
    The new `tasks` will be allocated threads by the `ThreadPool` class, which handles
    the actual creation of the threads the `tasks` use for carrying out their work.
    As developers, we are shielded from all of this thread creation work, because
    it is done for us by the `Task` object.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a task, you are really just creating a wrapper around a delegate
    of work to be performed. The delegate can be a named delegate and anonymous method,
    or a lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: So, which of these methods of creating `task` is the best? `Task.Factory.StartNew`
    is usually the preferred method, because it is more efficient in terms of the
    synchronization costs. Some amount of synchronization cost is incurred when using
    `Thread.Start`, because it is necessary to ensure that another thread is not simultaneously
    calling start on the same `Task` object. When using `Task.Factory.StartNew`, we
    know that the task has already been scheduled by the time `task` reference is
    handed back to our code.
  prefs: []
  type: TYPE_NORMAL
- en: Note also that you can't call `Start()` on a task that has already run and completed.
    If you need the tasks to do the work again, you need to create new `task` with
    the same delegate of work.
  prefs: []
  type: TYPE_NORMAL
- en: For the remainder of this book, we will primarily be using `Task.Factory.StartNew`.
  prefs: []
  type: TYPE_NORMAL
- en: Waiting for tasks to finish
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When developing a parallel application, you will often have situations where
    a task must be completed before the main thread can continue processing. The Task
    Parallel Library includes several methods that allow you to wait for one or more
    parallel `tasks` to complete. This recipe will cover two such methods: `Task.Wait()`
    and `Task.WaitAll()`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe we will be creating three tasks, all of which read in the text
    classic books and produce a `word count`. After we create the first task, we will
    wait for it to complete using `Task.Wait()`, before starting the second and third
    task. We will then wait for both the second and third tasks to complete using
    `Task.WaitAll()` before writing a message to the console.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a `Console` application that demonstrates how to wait for `task`
    completion.
  prefs: []
  type: TYPE_NORMAL
- en: Launch Visual Studio 2012.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Start a new project using the C# **Console Application** project template, and
    assign `WordCount` as the **Solution name**.![How to do it…](img/0225OT_01_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` statements at the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of the `Program` class, add a character array containing
    the basic punctuation marks. We will use this array in `string.Split()` to eliminate
    punctuation marks. Also add a string `constant` for the `user-agent` header of
    the `WebClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'OK, now let''s create our first task. This task will use `WebClient` to read
    the *Origin of Species* by Darwin, and get its word count. Enter the following
    code in the `Main` method of the `Program` class just below the previous statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, just below the previous task, write the following statements to wait on
    the task, and write a message to the `Console` application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Below the previous statement, enter the code to create the second and third
    tasks. These tasks are very similar to the first task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's use `Task.WaitAll()` to wait for the second and third task to
    complete, then prompt the user to exit the program. `Task.WaitAll()` takes an
    array of `task` as its parameter, and can be used to wait for any number of tasks
    to complete.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot. Note that the exact order of the last few
    lines of text may still vary depending on the execution order of the second and
    third tasks.![How to do it…](img/0225OT_01_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Although `Task.Wait()` and `Task.WaitAll()` are fairly self-explanatory, both
    have several overloads that offer different functionalities.
  prefs: []
  type: TYPE_NORMAL
- en: '`Task.Wait()` can take either an `Int32` or `TimeSpan` parameter to specify
    a specific period of time to wait. It can also accept a `CancellationToken` token
    parameter for cancellation, which will be covered later in the chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Task.WaitAll()` always takes an array of `Task` as its first parameter, and
    has a second parameter which can be an `Int32` or `TimeSpan` as in `Task.Wait`.'
  prefs: []
  type: TYPE_NORMAL
- en: Another useful method not shown in the recipe is `Task.WaitAny()`. `WaitAny`
    is very similar to `WaitAll`, except that it waits for only one `Task` in the
    array of `Task` to complete. The first `Task` of `Task` array to finish, completes
    the wait condition, and execution of the main thread is allowed to move forward.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that when you call one of the `Wait` methods, the runtime
    will check to see if the task you are waiting on has started executing. If `task`
    has started executing, then the thread that called `Wait` will block until `task`
    has finished executing. However, if `task` has not started running, then the runtime
    may execute the task using the thread that calls `Wait`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The various overloads and behaviors of `Task.Wait`, `Task.WaitAll`, and `Task.WaitAny`
    are shown in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| `Wait()` | Waits for the task to complete execution. |'
  prefs: []
  type: TYPE_TB
- en: '| `Wait(CancellationToken)` | Waits for the task to complete execution or `CancellationToken`
    to be set. |'
  prefs: []
  type: TYPE_TB
- en: '| `Wait(Int32)` | Waits for task to complete or number of milliseconds to pass.
    A value of `-1` waits indefinitely. |'
  prefs: []
  type: TYPE_TB
- en: '| `Wait(TimeSpan)` | Waits for the task to complete execution or specified
    timespan to pass. |'
  prefs: []
  type: TYPE_TB
- en: '| `Wait(Int32, CancellationToken)` | Waits for task to complete, number of
    milliseconds to pass, or `CancellationToken` to be set. |'
  prefs: []
  type: TYPE_TB
- en: '| `WaitAll(Task[])` | Waits for all of the tasks in array to complete execution.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `WaitAll(Task[], Int32)` | Waits for all of the tasks in the array to complete
    execution or number of milliseconds to pass. A value of `-1` waits indefinitely.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `WaitAll(Task[], CancellationToken)` | Waits for all of the tasks in array
    to complete execution or for a `CancellationToken` to be set. |'
  prefs: []
  type: TYPE_TB
- en: '| `WaitAll(Task[], TimeSpan)` | Waits for all of the tasks in array to complete
    execution or specified timespan to pass. |'
  prefs: []
  type: TYPE_TB
- en: '| `WaitAll(Task[], Int32, CancellationToken)` | Waits for all of the tasks
    in array to complete execution, number of milliseconds to pass, or `CancellationToken`
    to be set. |'
  prefs: []
  type: TYPE_TB
- en: '| `WaitAny(Task[])` | Waits for any of the tasks in the array to complete execution.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `WaitAny(Task[], Int32)` | Waits for any of the tasks in array to complete
    execution or number of milliseconds to pass. A value of `-1` waits indefinitely.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `WaitAny(Task[], CancellationToken)` | Waits for any of the tasks in array
    to complete execution or for a `CancellationToken` to be set. |'
  prefs: []
  type: TYPE_TB
- en: '| `WaitAny(Task[], TimeSpan)` | Waits for any of the tasks in array to complete
    execution or specified timespan to pass. |'
  prefs: []
  type: TYPE_TB
- en: '| `WaitAny(Task[], Int32, CancellationToken)` | Waits for any of the tasks
    in array to complete execution, number of milliseconds to pass, or `CancellationToken`
    to be set. |'
  prefs: []
  type: TYPE_TB
- en: Returning results from a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So far, our tasks have not returned any values. However, it is often necessary
    to return a result from a task so it can be used in another part of our application.
    This functionality is provided by the `Result` property of `Task<TResult`>.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be creating a solution similar with tasks similar to
    the previous solution, but each of our three tasks return a result which can then
    be used to display the word count to the user.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go to Visual Studio and see how we can return result values from our tasks.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the C# **Console Application** project template, and
    assign `WordCount2` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` statements are at the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of the `Program` class, add a character array containing
    the basic punctuation marks. We will use this array in `string.Split()` to eliminate
    punctuation marks. Also add a string constant for the `WebClient` `user-agent`
    header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Start by creating three tasks of type `Task<int>` named `task1`, `task2`, and
    `task3`. Your tasks should look as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Immediately below your tasks, add `Console.Writeline()` statements that use
    `Task.Result` to display the results to the user. The remainder of the `Main`
    method should now look as shown in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following:![How to do it…](img/0225OT_01_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Task<TResult>` subclasses the standard `Task` class and provides the additional
    feature of the ability to return a value. This is done by switching from providing
    an `Action` delegate to providing a `Func<TResult>` delegate.'
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that calling the `Task.Result` accessor will ensure that
    the asynchronous operation is complete before returning, so this is another method
    of waiting for a task to complete. Once the result of `Task` is available, it
    will be stored and returned immediately on later calls to the `Result` accessor.
  prefs: []
  type: TYPE_NORMAL
- en: Passing data to a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can supply the data used by `task` by passing an instance of `System.Action<object>`
    and an object representing the data to be used by the action.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be revisiting our WordCount example, but this time we
    will be parameterizing the data the tasks will act upon.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The ability to pass data into a task allows us to create a single task that
    can operate on multiple pieces of input data. Let''s create a `Console` application
    so we can see how this works:'
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the C# **Console Application** project template and
    assign `WordCount3`as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` statements at the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of the `Program` class, add a character array containing
    the basic punctuation marks. We will use this array in `string.Split()` to eliminate
    punctuation marks. Also add a constant string for the `WebClients` user-agent
    task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this recipe, let''s create a `new Dictionary` instance that can hold our
    book titles and URLs. Immediately after the previous statement, add the following
    code to create and initialize the `dictionary`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This time we will be creating anonymous tasks in a loop. We still would like
    to wait for the tasks to complete before prompting the user to exit the program.
    We need a collection to hold our tasks, so we can pass them to `Task.WaitAll()`
    and wait for completion. Below the previous statement, create a `List<Task>` to
    hold our tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we want to create a `for` loop to loop through `KeyValuePairs` in the
    dictionary. Let's put the `for` loop below the previous statement.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Inside the body of your `for` loop, put the definition of `task`, and add it
    to your task list as follows. Note the `KeyValuePair` being passed into `task`
    is in the form of an object. In the delegate body, we cast this object back to
    a `KeyValuePair`. Other than that, task is pretty much the same.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `for` loop, let''s finish things up by waiting on the tasks to complete
    using `Task.WaitAll()` and prompting the user to exit. The last few lines should
    be as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_01_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By passing data to `Task` using the state feature, we now have a very powerful
    model for task creation, because we can create many tasks at once, each having
    the same code statements in the body and passing in the data that `Task` operates
    on. It also makes our code much more concise and readable.
  prefs: []
  type: TYPE_NORMAL
- en: 'In our application we need to pass two items of data into the `task`: a book
    title and the URL of the book, so we created `dictionary`.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We would also want to wait on all of these tasks to complete before we prompt
    the user to exit, so we need to create a collection that can be converted to an
    array of tasks to hold our `Task` objects. In this case, we made a list of tasks.
    In the body of our look that creates the tasks, we will add the tasks to the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In our loop, we will pass in each of `KeyValuePairs` in `dictionary` as an object,
    using the `Task(Action<Object>, Object)` constructor. This syntax is just a bit
    odd because you actually refer to the `state` object twice.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The key takeaway here is that the only way to pass data to a `Task` constructor
    is using `Action<Object>`. To use the members of a specific type, you must convert
    or explicitly cast the data back to the desired type in the body of the `Task`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Creating a child task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Code that is running a task can create another task with the `TaskCreationOptions.AttachedToParent
    set`. In this case, the new task becomes a child of the original or parent task.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will be using a simplified version of the WordCount solution
    that uses a parent task to get the text of one book into a string array, and then
    spins up a child task to print the results.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's return to our WordCount solution, so we can see how to create a child
    task and attach it to a parent.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the C# **Console Application** project template, and
    assign `WordCount4` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` statements at the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `Main` method of the `Program` class, add a character array containing
    the basic punctuation marks. We will use this array in `string.Split()` to eliminate
    punctuation marks. Also, add a constant string for the `WebClient` `user-agent`
    header.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, let's create the basic structure of our parent task. This is very similar
    to the other tasks we have created so far, and takes no parameters, and returns
    no values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, right after the comment in the parent task, let's create a child task
    to print the results and set the `AttachedToParent` option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, just below the close of the parent task, let''s wait for the parent
    task to complete, and prompt the user to exit the application with the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That's pretty much it. In Visual Studio 2012, press *F5* to run the project.
    You should see output as shown in the following screenshot:![How to do it…](img/0225OT_01_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Using `TaskCreationOptions.AttachedToParent` expresses structured parallelism.
    The parent task will wait for the child task to finish, so at the end of our program,
    all we have to do is wait for the parent task.
  prefs: []
  type: TYPE_NORMAL
- en: The nested child task, itself, is just an ordinary `task` created in the delegate
    of another `task`. A parent task may create any number of child tasks, limited
    only by system resources.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create a nested task without using `TaskCreationOptions.AttachedToParent`.
    The only real difference is that the nested tasks created without this option
    are essentially independent from the outer task. A task created with the `TaskCreationOptions.AttachedToParent`
    option set is very closely synchronized with the parent.
  prefs: []
  type: TYPE_NORMAL
- en: The outer task could also use the `DenyChildAttach` option to prevent other
    tasks from attaching as child tasks. However, the same outer task could still
    create an independent nested task.
  prefs: []
  type: TYPE_NORMAL
- en: Lazy task execution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lazy initialization of an object means that object creation is deferred until
    the object is actually used by your program. If you have a parallel task that
    you want to execute only when the value returned from the task is actually needed,
    you can combine lazy task execution with the `Task.Factory.StartNew` method.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we will return to our, by now familiar WordCount solution, to
    show you how to execute a parallel task and compute a word count for our book,
    only when we display the result to the console.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a console application that demonstrates how we can defer task creation
    until the result of the task is needed.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the C# **Console Application** project template, and
    assign `WordCount5` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the following `using` statements at the top of your `Program` class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The first step is to declare `System.Threading.Task<int>` for lazy initialization.
    In the `Main` method of your `Program` class, put a `Lazy` declaration as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Inside the `Lazy` initialization declaration, place the code to create to task.
    The entire statement should now look as the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we just need to write the result to the `Console`. Just add the following
    code to the end of your program:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: All done. In Visual Studio 2012, press *F5* to run the project. You should see
    the output as shown in the following screenshot:![How to do it…](img/0225OT_01_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`System.Lazy<T>` creates a thread safe Lazy initialization of an object. Lazy
    initialization is primarily used to improve performance and avoid computational
    overhead until necessary. You can pass a delegate (remember that System Threading
    Task is just a wrapper around a delegate) to the `System.Lazy` constructor, and
    as we have done in this recipe, you can use a lambda expression to specify a `factory`
    method for object creation. This keeps all of the initialization code in one place.'
  prefs: []
  type: TYPE_NORMAL
- en: '`Lazy` initialization occurs the first time the `System.Lazy<T>.Value` property
    is accessed.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling task exceptions using try/catch block
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's face it; sometimes things just go wrong with our code. Even with the simplified
    parallel programming model provided by the TPL, we still need to be able to handle
    our exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: 'Tasks use `System.AggregateException` to consolidate multiple failures into
    a single exception object. In this recipe, we will take a look at the simplest
    way to handle `System.AggregateException` in our `tasks`: the `try`/`catch` blocks.'
  prefs: []
  type: TYPE_NORMAL
- en: The try-catch statement consists of a try block followed by one of more catch
    blocks, which specify handlers for different exceptions. The try block contains
    the guarded code that may cause the exception.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe we need to turn off the Visual Studio 2012 Exception Assistant.
    The Exception Assistant appears whenever a runtime exception is thrown, and intercepts
    the exception before it gets to our handler.
  prefs: []
  type: TYPE_NORMAL
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exceptions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **user-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    ready…](img/0225OT_01_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's return to our WordCount solution so we can see how to handle an `AggregateException`
    thrown by a parallel task.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the C# **Console Application** project template and
    assign `WordCount6` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` statements are at the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'For this recipe, we will just need a single task. The task will be very similar
    to our other word count tasks, but in this one we will simulate a problem with
    the `System.Net.WebClient` by creating and throwing a `System.Net.WebException`.
    In the `Main` method of your `Program` class, create `System.Task` that looks
    as the following `Task`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Just below the `Task`, let's put in our `try`/`catch` blocks as shown in the
    following code snippet. In the `catch` block, we will want to specifically catch
    `System.AggregateException`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's implement the body of our `try` block. The body of the `try` block
    should be as shown in the following code snippet. There are a couple of subtle
    but important concepts in here that will be explained later in the chapter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, let''s implement the body of our `catch` block. It should look as shown
    in the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the `catch` block, let's finish up by prompting the user to exit, and
    waiting on the user to hit *Enter*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_01_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All of this stuff has been pretty self-explanatory so far, but handling exceptions
    in task involves a couple of subtleties that need to be pointed out.
  prefs: []
  type: TYPE_NORMAL
- en: The task itself is pretty straightforward. Other than throwing the `System.Net.WebException`,
    there is nothing out of the ordinary here.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at the try/catch blocks. The first statement in the
    `try` block `System.Threading.Task.Wait()` to wait on task completion. However,
    there is another purpose here. Unhandled exceptions thrown inside a `task` are
    swallowed by the runtime and wrapped up in `System.AggregateException`. It is
    your job to handle this.
  prefs: []
  type: TYPE_NORMAL
- en: The TPL also has the concept of `AggregateException` being observed. If `AggregateException`
    is raised by your task, it will only be handled if it is currently being observed.
    This is very important to understand. If you never take an action that causes
    the exceptions to be observed, you are going to have a problem. When the `Task`
    object is garbage collected, the `Finalize` method of the `task` will see that
    the `task` had unobserved exceptions, and it will throw`System.AggregateException`.
    You will not be able to catch an exception thrown by the finalizer thread and
    your process will be terminated.
  prefs: []
  type: TYPE_NORMAL
- en: 'So how to you observe an `AggregateException`, you ask? The `Systm.Threading.Task`
    class has a few methods and properties call triggers that cause `System.AggregateException`
    to be observed. A few of these are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Task.Wait
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task.WaitAny
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task.WaitAll
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Task.Result
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using any of these `trigger` methods indicates to the runtime that you are interested
    in observing any `System.AggregateException` that occurs. If you do not use one
    of the `trigger` methods on the `Task` class, the TPL will not raise any `AggregateException`,
    and an unhandled exception will occur.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at the `catch` block. `System.AggregateException` can
    wrap many individual exception objects. In our `catch` block, we need to loop
    through `AggregateException.InnerExceptions` to take a look at all of the individual
    exceptions that occurred in a task.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that there is really no way to correlate an exception
    from the `AggregateExcetion.InnerExceptions` collection back to the particular
    `task` that threw an exception. All you really know is that some operation threw
    an `Exception`.
  prefs: []
  type: TYPE_NORMAL
- en: '`System.AggregateException` overrides the `GetBaseException` method of exception,
    and returns the innermost exception, which is the initial cause of the problem.'
  prefs: []
  type: TYPE_NORMAL
- en: Handling task exceptions with AggregateException.Handle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will look at another way to handle `System.AggregateException`,
    by using the `AggregateException.Handle` method. The `Handler` method invokes
    a handler function for each exception wrapped in `AggregateException`.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we need to turn off the Visual Studio 2012 Exception Assistant.
    The Exception Assistant appears whenever a runtime exception is thrown and intercepts
    the exception before it gets to our handler.
  prefs: []
  type: TYPE_NORMAL
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exceptions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Uncheck the **user-unhandled** checkbox next to **Common Language Runtime Exceptions**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's take a look at how we can use `AggregateException.Handle` to provide an
    alternate method to handling exceptions in a parallel application.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will return to our **WordCount6** project, and modify it
    to handle our exceptions in a different way. Start Visual Studio 2012 and open
    the **WordCount6** project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The first step is to define our handler function that will be invoked when
    we call `AggregateException.Handle`. Following the `Main` method of your `Program`
    class, add a new `private static handler` method that returns a bool. It should
    look as the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The only other step here is to replace the body of your `catch` block with
    a call to `System.AggregateException.Handle`, passing in the `HandleWebExceptions`
    predicate. The updated `try`/`catch` block should look as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Those are the only modifications necessary. In Visual Studio 2012, press *F5*
    to run the project. You should see output as shown in the following screenshot:![How
    to do it…](img/0225OT_01_11.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`AggregateException.Handle()` takes a predicate that you supply, and the predicate
    will be invoked once for every exception wrapped in `System.AggregateException`.'
  prefs: []
  type: TYPE_NORMAL
- en: The predicate itself just needs to contain the logic to handle the various exception
    types that you expect, and to return true or false to indicate whether the exception
    was handled.
  prefs: []
  type: TYPE_NORMAL
- en: If any of the exceptions went unhandled, they will be wrapped in a new `System.AggregateException`
    and thrown.
  prefs: []
  type: TYPE_NORMAL
- en: Cancelling a task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up to this point, we have focused on creating, running, and handling exceptions
    in `tasks`. Now we will begin to take a look at using `System.Threading.CancellationTokenSource`
    and `System.Threading.CancellationToken` to cancel `tasks`.
  prefs: []
  type: TYPE_NORMAL
- en: This recipe will show how to cancel a single task.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a console application that shows how to cancel a parallel task.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the C# **Console Application** project template, and
    assign `WordCount7` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` statements at the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Let''s start by creating `CancellationTokenSource` and getting our `CancellationToken`.
    In the `Main` method of your `Program` class, add the following statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now we need to create our `Task` and pass `CancellationToken` into the constructor.
    Right after the previous line, put in the following `Task` definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the body of our `Task`, we need to check the `IsCancellationRequested` property
    of `CancellationToken`. If it has been, we dispose of our resource and throw `OperationCancelledException`.
    If not, we do our usual work. Enter the following code into the body of `Task`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Right after the task, put in the following lines to write the cancellation status
    to the `Console`, and then call the `Cancel` method of `TokenSource`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The following are the last statements put in a condition to check whether the
    task has been cancelled or faulted before we try to write out the results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, we'll finish up by prompting the user to exit and waiting for the input.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see the output
    as shown in the following screenshot:![How to do it…](img/0225OT_01_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The basic idea of cancelling `task` is that we create `CancellationTokenSource`,
    obtain `CancellationToken` from it, and then pass `CancellationToken` onto the
    `Task` constructor. Once we have done that, we can call the `Cancel` method on
    the `CancellationTokenSource` to cancel the task.
  prefs: []
  type: TYPE_NORMAL
- en: That's all easy enough. However, inside `task` we have a couple of options on
    how to handle the cancellation.
  prefs: []
  type: TYPE_NORMAL
- en: If your task has resources that need to be cleaned up (such as the `WebClient`),
    you need to check the cancellation tokens `IsCancellationRequested` property,
    then dispose of the resources, and throw a new `OperationCancelledException`.
  prefs: []
  type: TYPE_NORMAL
- en: The other option, if your task doesn't use resources which need to be explicitly
    cleaned up, is to use the token `ThrowIsCancellationRequested()`, which will ensure
    the task transitions to a status of cancelled in a single statement.
  prefs: []
  type: TYPE_NORMAL
- en: If you need to execute `task` and prevent it from being cancelled, you can obtain
    a special `CancellationToken` that is not associated with any `CancellationTokenSource`
    from the static `CancellationToken.None` property, and pass this token to `Task`.
    Since there is no associated `CancellationTokenSource`, it is not possible to
    call `Cancel` for this token, and any code that is checking the `CancellationToken.IsCancellationRequested`
    property will always get back a false.
  prefs: []
  type: TYPE_NORMAL
- en: There's more…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can register one or more methods to be called when `CancellationTokenSource`
    is cancelled, by registering a `callback` method with the `CancellationToken.Register`
    method. You just need to pass `Action<Object>`, and optionally, a state value
    will be passed to `callback` and a `Boolean`, indicating whether to invoke the
    delegate using `SynchronizationContext` of the calling thread to the `Register`
    method. Passing in a value of false means the thread that calls `Cancel` will
    invoke the registered methods synchronously. If you pass true, the callbacks will
    be sent to `SynchronizationContext`, which determines which thread will invoke
    the callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: The `Register` method of `CancellationToken` returns a `CancellationTokenRegistration`
    object. To remove a registered callback from `CancellationTokenSource`, so it
    doesn't get invoked, call the `Dispose` method of the `CancellationTokenRegistration`
    object.
  prefs: []
  type: TYPE_NORMAL
- en: You can also create `CancellationTokenSource` by linking other `CancellationTokenSource`
    objects together. The new composite `CancellationTokenSource` will be cancelled,
    if any of the linked `CancellationTokenSource` objects are cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: Cancelling one of many tasks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have seen how to cancel a task, let's take a look at how we can
    use `CancellationToken` to cancel multiple tasks with a single call to `CancellationTokenSource.Cancel()`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now let's return to our WordCount example and create a `Console` application
    that provides for the cancellation of multiple tasks with single `CancellationToken`.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the C# **Console Application** project template, and
    assign `WordCount8` as the **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` statements at the top of your `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, let's create a `helper` method to display errors and cancellation status.
    Since we have multiple tasks, it's better to have this logic all in one place.
    Following the `Main` method of your `Program` class, create a `static` method
    call `HandleExceptions` which will display the errors and task status to the user.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, at the top of the `Main` method, create `CancellationTokenSource` and
    get our `CancellationToken`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we need to create our tasks and our array of `delimiters`. The tasks are
    the same as in the recipe for cancelling a single task. The key here is that we
    are passing the same `CancellationToken` in for all three tasks.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'OK, let''s finish up by calling `CancellationTokenSource.Cancel()` , checking
    the results, and catching the exceptions. The remainder of the `Main` method should
    look as the following code snippet:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    as shown in the following screenshot:![How to do it…](img/0225OT_01_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Functionally, cancelling multiple tasks is the same as cancelling a single task.
    In fact, the Parallel Extensions team has put a lot of work into making cancellation
    of various parallel structures very similar, as you will see as we go through
    the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'All that is necessary to cancel multiple tasks is to create `CancellationToken`,
    then pass that token into all of the tasks you wish to cancel as shown in the
    following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
