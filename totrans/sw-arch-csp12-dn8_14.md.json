["```cs\nsyntax = \"proto3\"; \n```", "```cs\noption csharp_namespace = \"FakeSource\"; \n```", "```cs\nimport \"google/protobuf/timestamp.proto\"; \n```", "```cs\npackage purchase; \n```", "```cs\nmessage PurchaseMessage {\n  string id = 1;\n  google.protobuf.Timestamp time = 2;\n  string location = 3;\n  int32 cost =4;\n  google.protobuf.Timestamp purchaseTime = 5;\n} \n```", "```cs\nmessage PurchaseMessage {\n  string id = 1;\n  int32 cost =4;\n  google.protobuf.Timestamp purchaseTime = 5;\n  Reseller reseller = 7;\n} \n```", "```cs\nmessage PurchaseMessage {\n  ...\n  repeated Product products = 3;\n  ...\n} \n```", "```cs\nmessage PurchaseMessage {\n  ...\n  map<string, int> attributes = 3;\n  ...\n} \n```", "```cs\nmessage PurchaseMessage {\n  message Product {\n    int32 id = 1;\n    string name = 2;\n    uint32 cost = 3;\n    uint32 quantity = 4;\n  }\n  ...\n  repeated Product products = 3;\n  ...\n} \n```", "```cs\nenum ColorType {\n    RED = 0;\n    GREEN = 1;\n    ...\n  } \n```", "```cs\nmessage Payload {\n    ...\n}\nmessage Error {\n    ...\n}\nmessage ResponseMessage {\n  one of result {\n    Error error = 1;\n    Person payload = 2;\n  }\n} \n```", "```cs\nResponseMessage  response = ...;\nswitch (response.ResultCase)\n{\n    case ResponseMessage.ResultOneofCase.Payload:\n        HandlePayload(response. Payload);\n        break;\n    case ResponseMessage.ResultOneofCase.Error:\n        HandleError(response.Error);\n        break;\n    default:\n        throw new ArgumentException();\n} \n```", "```cs\nimport \"google/protobuf/wrappers.proto\" \n```", "```cs\nsyntax = \"proto3\"\nimport \"google/protobuf/duration.proto\"; \nimport \"google/protobuf/timestamp.proto\";\nmessage PurchaseMessage {\n  string id = 1;\n  google.protobuf.Timestamp time = 2;\n  string location = 3;\n  int32 cost =4;\n  google.protobuf.Timestamp purchaseTime = 5;\n  google.protobuf.Duration travelDuration = 6;\n} \n```", "```cs\nmessage ProtoDecimal {\n// Whole units part of the decimal\n    int64 units = 1;\n    // Nano units of the decimal (10^-9)\n// Must be same sign as units\n    sfixed32 nanos = 2;\n} \n```", "```cs\npublic partial class DecimalValue\n{\n    private const decimal nanoFactor = 1000000000m;\n\n    public static implicit operator decimal(ProtoDecimal pDecimal)\n    {\n        return pDecimal.Units + pDecimal.Nanos / nanoFactor;\n    }\n    public static implicit operator ProtoDecimal (decimal value)\n    {\n        return new ProtoDecimal\n          {\n             Units = decimal.ToInt32(value),\n             Nanos= decimal.ToInt32((value - Units) * nanoFactor),\n          };\n    }\n} \n```", "```cs\nusing Google.Protobuf;\n...\nPurchaseMessage purchase = ....\nbyte[]? body = null;\nusing (var stream = new MemoryStream())\n{\n    purchase.WriteTo(stream);\n    stream.Flush();\n    body = stream.ToArray();\n} \n```", "```cs\nByte[] body = ...\nPurchaseMessage? message = null;\nusing (var stream = new MemoryStream(body))\n{\n    message = PurchaseMessage.Parser.ParseFrom(stream);\n} \n```", "```cs\nservice Counter {\n  // Accepts a counting request\nrpc Count (CountingRequest) returns (CountingReply);\n //Get current count for a given time slot\nrpc GetCount (TimeSlotRequest) returns (TimeSlotDataReply);\n} \n```", "```cs\n...\nimport \"google/protobuf/empty.proto\";\n...\nservice Counter {\n  ...\n  rpc AllSlots(google.protobuf.Empty) return (AllDataReply);\n} \n```", "```cs\npublic class CounterService: Counter.CounterBase\n{\n    ...\n    public override async  Task<CountingReply> Count(\n          CountingRequest request, ServerCallContext context)\n    {\n        CountingReply reply =...\n          return reply;\n    }\n} \n```", "```cs\nservice StreamExample {\n  rpc Echo (stream MyMessage) returns (stream MyMessage);\n} \n```", "```cs\npublic override async Task Echo(\n     IAsyncStreamReader<MyMessage> requestStream\n      IServerStreamWriter<MyMessage> responseStream,\n      ServerCallContext context){\n     ...\n          While(...)\n          {\n             bool inputFinished =  !await requestStream.MoveNext();\n             var current = requestStream.Current;\n             ...\n             await responseStream.WriteAsync(result);\n          }\n} \n```", "```cs\nvar call = client.Echo();\n...\nawait call.RequestStream.WriteAsync(...);\n...\nbool inputFinished =  ! await call.ResponseStream.MoveNext();\nvar current = call.ResponseS.Current;\n...\ncall.RequestStream.CompleteAsync(); \n```", "```cs\npublic interface IMessageQueue\n{\n    public Task<IList<QueueItem>> Top(int n);\n    public Task Dequeue(IEnumerable<QueueItem> items);\n    public Task Enqueue(QueueItem item);\n} \n```", "```cs\nbuilder.Services.AddHostedService<MyHostedService>(); \n```", "```cs\npublic class ProcessPurchases : BackgroundService\n{\n    IServiceProvider services;\n    public ProcessPurchases(IServiceProvider services)\n    {\n        this.services = services;\n    }\n    protected override async Task ExecuteAsync(CancellationToken stoppingToken)\n    {\n        bool queueEmpty = false;\n        while (!stoppingToken.IsCancellationRequested)\n        {\n           while (!queueEmpty && !stoppingToken.IsCancellationRequested)\n           {\n             ...\n           }\n            await Task.Delay(100, stoppingToken);\n            queueEmpty = false;\n        }\n    }\n} \n```", "```cs\nusing (var scope = services.CreateScope())\n{\n    IMessageQueue queue = scope.ServiceProvider.GetRequiredService<IMessageQueue>();\n\n    var toProcess = await queue.Top(10);\n    if (toProcess.Count > 0)\n    {\n        Task<QueueItem?>[] tasks = new Task<QueueItem?>[toProcess.Count];\n        for (int i = 0; i < tasks.Length; i++)\n        {\n            tasks[i] = toExecute();\n        }\n        await Task.WhenAll(tasks);\n        await queue.Dequeue(tasks.Select(m => m.Result)\n           .Where(m => m != null).OfType<QueueItem>());\n    }\n    else queueEmpty = true;\n} \n```", "```cs\nrabbitmq-plugins enable rabbitmq_management \n```", "```cs\nprotected override async Task ExecuteAsync(CancellationToken stoppingToken)\n{\n    while (!stoppingToken.IsCancellationRequested)\n    {\n        try\n        {\n            var factory = new ConnectionFactory() { HostName = \"localhost\" };\n            using (var connection = factory.CreateConnection())\n            using (var channel = connection.CreateModel())\n            {\n                channel.QueueDeclare(queue: \"purchase_queue\",\n                                     durable: true,\n                                     exclusive: false,\n                                     autoDelete: false,\n                                     arguments: null);\n                channel.BasicQos(prefetchSize: 0, prefetchCount: 1, global:                                false);\n                var consumer = new EventingBasicConsumer(channel);\n                consumer.Received += async (sender, ea) =>\n                {\n                    // Message received even handler\n                    ...\n                };\n                channel.BasicConsume(queue: \"purchase_queue\",\n                            autoAck: false,\n                            consumer: consumer);\n                 await Task.Delay(1000, stoppingToken);\n            }\n         }\n        catch { }\n    }\n} \n```", "```cs\nif (stoppingToken.IsCancellationRequested)\n{\n    channel.Close();\n    connection.Close();\n    return;\n} \n```", "```cs\nusing (var scope = services.CreateScope())\n{\n  try\n  {\n  // actual application dependent message processing\n  ...\n  }\n  catch {\n    ((EventingBasicConsumer)sender).Model.BasicNack(ea.DeliveryTag, false, true);\n  }\n} \n```", "```cs\nvar body = ea.Body.ToArray();\nMyMessageClass? message = null;\nusing (var stream = new MemoryStream(body))\n{\n    message = PurchaseMessage.Parser.ParseFrom(stream);\n} \n```", "```cs\nif(success)\n    ((EventingBasicConsumer)sender).Model\n        .BasicAck(ea.DeliveryTag, false);\nelse\n    ((EventingBasicConsumer)sender).Model\n        .BasicNack(ea.DeliveryTag, false, true); \n```"]