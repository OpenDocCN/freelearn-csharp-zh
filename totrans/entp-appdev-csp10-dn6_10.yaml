- en: '*Chapter 8*: All You Need to Know about Caching'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：关于缓存你需要知道的一切'
- en: Caching is one of the key system design patterns that help in scaling any enterprise
    application along with improving response time. Any web application typically
    involves reading and writing data from and to a data store, which is usually a
    relational database such as SQL Server or a NoSQL database such as Cosmos DB.
    However, reading data from the database for every request is not efficient, especially
    when the data hasn't changed. This is because databases usually persist data to
    disk and it's a costly operation to load the data from disk and send it back to
    the browser client (or device in the case of mobile/desktop applications) or user.
    This is where caching comes into play.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是帮助企业应用扩展并提高响应时间的关键系统设计模式之一。任何Web应用通常都涉及从数据存储中读取和写入数据，这些数据存储通常是关系型数据库，如SQL
    Server，或NoSQL数据库，如Cosmos DB。然而，对于每个请求从数据库中读取数据并不高效，尤其是当数据没有变化时。这是因为数据库通常将数据持久化到磁盘，从磁盘加载数据并将其发送回浏览器客户端（或移动/桌面应用程序中的设备）或用户的操作是成本高昂的。这就是缓存发挥作用的地方。
- en: Cache stores can be used as a primary source for retrieving data, falling back
    to the original data store only when the required data is not available in the
    cache, thus giving a faster response to the consuming application. When using
    caches this way, we also need to ensure that the cached data is expired/refreshed
    as and when the data in the original data store is updated.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存存储可以用作检索数据的主要来源，只有当所需数据不在缓存中时才回退到原始数据存储，从而为消费应用程序提供更快的响应。当以这种方式使用缓存时，我们还需要确保当原始数据存储中的数据更新时，缓存中的数据会过期/刷新。
- en: 'In this chapter, we will learn about various techniques for caching data in
    .NET 6 applications as well as various caching components and the platforms available
    that can be integrated with a .NET 6 application. We will cover the following
    topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将学习在.NET 6应用程序中缓存数据的各种技术，以及可以与.NET 6应用程序集成的各种缓存组件和平台。我们将涵盖以下主题：
- en: Introduction to caching
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存简介
- en: Understanding the components of caching
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解缓存组件
- en: Caching platforms
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存平台
- en: Designing a cache abstraction layer using distributed caching
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用分布式缓存设计缓存抽象层
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'A basic understanding of .NET Core, C#, Azure, and the .NET CLI is required.
    The code for the chapter can be found here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter08).'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 需要基本了解.NET Core、C#、Azure和.NET CLI。本章的代码可以在此处找到：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter08](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter08)。
- en: 'The instructions for the code examples can be found here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application).'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例的说明可以在此处找到：[https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application)。
- en: Introduction to caching
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存简介
- en: There are multiple ways to improve the performance of an application and caching
    is one of the key techniques used in enterprise applications. A **cache** is like
    a temporary data store, with a limited size and limited data, but has much faster
    data access compared to the original data source and usually holds only a subset
    of the data, the most frequently used data that does not change often.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 有多种方法可以提高应用程序的性能，缓存是企业在应用中使用的关键技术之一。**缓存**就像一个临时数据存储，具有有限的大小和有限的数据，但与原始数据源相比，数据访问速度要快得多，通常只存储数据的一个子集，即最常使用且不经常变化的数据。
- en: A **cache store** could be as simple as the RAM of the computer that is used
    by the process during execution, or it could be something such as Redis, which
    uses both memory and disks to store data. The key thing here is that it is usually
    on hardware that has a lower access time compared to the original storage layer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**缓存存储**可能只是计算机的RAM，该RAM在执行过程中被进程使用，或者它可能是像Redis这样的东西，它使用内存和磁盘来存储数据。这里的关键是它通常位于比原始存储层访问时间更低的硬件上。'
- en: Caching can be implemented at every layer in the architecture so that data can
    be retrieved from the layer closest to the user. For example, in any web application,
    the moment a URL is typed in the browser and we press *Enter*, it goes through
    various web components that are involved in loading the web application, starting
    with the browser, proxies, and DNS, to the web server and database. Caching is
    something that can be applied at all these layers.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存可以在架构的每一层实现，以便从最接近用户的那一层检索数据。例如，在任何Web应用中，当我们输入URL并在浏览器中按下*Enter*键时，它会通过加载Web应用所涉及的各个Web组件，从浏览器、代理和DNS开始，到Web服务器和数据库。缓存是可以在所有这些层应用的东西。
- en: If data is cached in the browser, it can be loaded immediately. It can alternatively
    fall back to a higher layer if data is not available in the layer closest to the
    user, thus reducing the load on higher layers that are shared across multiple
    users, such as the application server and database tier.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 如果数据在浏览器中缓存，它可以立即加载。如果没有在用户最近的那一层找到数据，它可以回退到更高一层，从而减少共享多个用户的更高层（如应用服务器和数据库层）的负载。
- en: 'The following figure depicts this discussion at a high level, where a request
    is flowing through various layers and is moved to a higher layer only when data
    is not available (represented by the dotted line) in the cache:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 下图以高层次描述了这一讨论，其中请求在各个层之间流动，并且只有在缓存中没有数据（用虚线表示）时才会移动到更高层：
- en: '![Figure 8.1 – Cache layers in a request flow'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 请求流程中的缓存层'
- en: '](img/Figure_8.1_B18507.jpg)'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.1_B18507.jpg)'
- en: Figure 8.1 – Cache layers in a request flow
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 请求流程中的缓存层
- en: Let's discuss some of these layers in application architecture where data can
    be cached.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们讨论一下应用架构中可以缓存数据的一些这些层。
- en: Client caching
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端缓存
- en: Commonly requested data can be cached on the client side to avoid unnecessary
    round trips to the server. For example, Microsoft's Outlook app downloads the
    most recent emails from the server and keeps a copy of them on the client side,
    and then periodically syncs for new emails. If there is a need to search for an
    email that isn't already downloaded, it goes back to the server.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 常请求的数据可以在客户端缓存，以避免不必要的往返服务器。例如，微软的Outlook应用从服务器下载最新的电子邮件，并在客户端保留副本，然后定期同步新邮件。如果需要搜索尚未下载的电子邮件，它将返回服务器。
- en: Similarly, browsers can cache various resources and responses from a web application
    based on certain headers, and subsequent requests for the same resource load from
    the browser cache. For example, all JavaScript files, image files, and CSS are
    usually cached on the browser for a certain period. Also, a response from an API
    can be cached by sending appropriate response headers. This is also known as **HTTP
    caching** or **response caching**, which is discussed in detail in a later section.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，浏览器可以根据某些头部信息缓存来自Web应用的多种资源和响应，并且对相同资源的后续请求将从浏览器缓存中加载。例如，所有JavaScript文件、图像文件和CSS通常会在浏览器中缓存一定时间。此外，通过发送适当的响应头部，API的响应也可以被缓存。这被称为**HTTP缓存**或**响应缓存**，将在后面的章节中详细讨论。
- en: Content Delivery Network (CDN)
  id: totrans-24
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内容分发网络（CDN）
- en: A **Content Delivery Network** (**CDN**) is a set of servers that are globally
    distributed and are usually used to serve static content such as HTML, CSS, and
    video. Whenever an application requests a resource, if the CDN is enabled, the
    system will first look to load the resource from the CDN server that is physically
    closest to the user. However, if it is not available on the CDN server, the resource
    is retrieved from the server and is cached in the CDN to serve subsequent requests.
    Netflix is one such great example that heavily relies on its custom-built CDN
    to deliver content to users.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**内容分发网络**（**CDN**）是一组全球分布的服务器，通常用于提供静态内容，如HTML、CSS和视频。每当应用请求一个资源时，如果启用了CDN，系统将首先尝试从物理上最接近用户的CDN服务器加载该资源。然而，如果该资源不在CDN服务器上，它将从服务器检索并缓存到CDN中，以服务于后续请求。Netflix就是这样一个很好的例子，它严重依赖其定制的CDN来向用户交付内容。'
- en: Microsoft also comes with Azure CDN, which is primarily used to serve static
    content. Also, Microsoft's CDN gives an option to integrate with Azure Storage,
    which we will be using in our e-commerce application to serve various product
    images. Similarly, AWS has Amazon Cloudfront and Google Cloud offers Cloud CDN
    as part of their respective e-storage offerings.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 微软还提供了Azure CDN，主要用于服务静态内容。此外，微软的CDN还提供了与Azure存储集成的选项，我们将在我们的电子商务应用中使用它来服务各种产品图片。类似地，AWS有Amazon
    Cloudfront，而Google Cloud则在其各自的云存储服务中提供Cloud CDN。
- en: Web server caching
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Web服务器缓存
- en: Although CDNs are great for static content, they come with additional costs
    and maintenance overhead in terms of refreshing data from application servers.
    To overcome these limitations, applications can use web servers or reverse proxies
    to serve static content. A lightweight NGINX server is one such example that can
    be used to serve static content.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然CDN对于静态内容非常出色，但它们在从应用服务器刷新数据方面会带来额外的成本和维护开销。为了克服这些限制，应用可以使用Web服务器或反向代理来服务静态内容。一个轻量级的NGINX服务器就是这样一个例子，它可以用来服务静态内容。
- en: Web servers can also cache dynamic content, such as an API response coming from
    the application server. Web servers such as NGINX or IIS, when configured as a
    reverse proxy, can be further used to cache dynamic content, thereby reducing
    the load on the application server by serving requests from its cache.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: Web服务器也可以缓存动态内容，例如来自应用服务器的API响应。当配置为反向代理时，如NGINX或IIS这样的Web服务器可以进一步用于缓存动态内容，从而通过从其缓存中服务请求来减轻应用服务器的负载。
- en: Note
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: NGINX is an open source solution that is primarily known for its web server
    capabilities; however, it can also be used as a reverse proxy, for load balancing,
    and more. For further reading, please refer to [https://www.nginx.com/](https://www.nginx.com/).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: NGINX是一个开源解决方案，主要以其Web服务器功能而闻名；然而，它也可以用作反向代理、负载均衡等。欲了解更多信息，请参阅[https://www.nginx.com/](https://www.nginx.com/)。
- en: Database caching
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据库缓存
- en: Increasingly, database servers cache certain components of a query; for example,
    SQL Server usually has cache execution plans and also has a data buffer to cache,
    and MongoDB keeps recently queried data in memory for faster retrieval. So, it
    is good to tweak these settings to improve the performance of the application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 越来越多的数据库服务器会缓存查询的某些组件；例如，SQL Server通常有缓存执行计划，并且还有一个数据缓冲区用于缓存，MongoDB则将最近查询的数据保存在内存中以实现快速检索。因此，调整这些设置以改善应用性能是很好的。
- en: Note
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Database caching doesn't guarantee that subsequent execution of the same query
    executes with zero CPU consumption; that is, it is not practically free. The same
    query in subsequent requests executes at a faster pace.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 数据库缓存并不能保证相同查询的后续执行不会消耗CPU资源；也就是说，它并不是真正免费的。在后续请求中，相同的查询执行速度会更快。
- en: Application caching
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用缓存
- en: 'Application caching can be achieved by caching data retrieved from the storage
    layer within the application server. This is mostly done in the following two
    ways:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 应用缓存可以通过在应用服务器内部缓存从存储层检索到的数据来实现。这通常以下两种方式完成：
- en: Stored in the memory of the application server, also known as in-memory caching
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在应用服务器的内存中，也称为内存缓存
- en: Stored in an external store, such as Redis or Memcached, that has a faster access
    time as compared to the underlying original data store
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储在外部存储中，如Redis或Memcached，其访问速度比底层原始数据存储更快
- en: Application caching usually involves integrating extra code within the application
    logic to cache data. So, whenever a request for data is made, the application
    first looks in the cache. But if it's not available in the cache, the application
    will fall back to the original data store, such as a database. Usually, the size
    of the application cache is limited compared to the original data store, so internally,
    application caching platforms will employ various algorithms such as **Least Recently
    Used** (**LRU**) or **Least Frequently Used** (**LFU**) to clean up the data stored
    in the cache. We will discuss more about caching platforms in the *Caching platforms*
    section.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应用缓存通常涉及在应用逻辑中集成额外的代码以缓存数据。因此，每当请求数据时，应用首先会在缓存中查找。但如果缓存中没有，应用将回退到原始数据存储，如数据库。通常，应用缓存的大小与原始数据存储相比有限，因此，应用缓存平台将采用各种算法，如**最近最少使用**（**LRU**）或**最少使用频率**（**LFU**）来清理缓存中存储的数据。我们将在*缓存平台*部分讨论更多关于缓存平台的内容。
- en: Another important point to consider for application caches is data invalidation,
    which is how frequently data needs to be expired or synced with the original data
    source. So, things such as cache expiry and various strategies to update the cache
    with the original data store (read-through, write-through) need to be considered.
    We will discuss more cache invalidation/refresh strategies in the *Cache access
    patterns* section.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 对于应用程序缓存来说，另一个需要考虑的重要点是数据失效，即数据需要多频繁地过期或与原始数据源同步。因此，需要考虑诸如缓存过期以及用原始数据存储更新缓存的各种策略（读透，写透）。我们将在*缓存访问模式*部分讨论更多的缓存失效/刷新策略。
- en: Understanding the components of caching
  id: totrans-42
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解缓存的组件
- en: Before we understand the various possible cache stores/platforms available in
    .NET 6 applications, we need to understand the various components of caching that
    are available in .NET 6 and how to use them in enterprise applications. Along
    the way, we will also cover various cache eviction strategies and techniques to
    keep the cache in sync with original data stores.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们了解.NET 6应用程序中可用的各种可能的缓存存储/平台之前，我们需要了解.NET 6中可用的各种缓存组件以及如何在企业应用程序中使用它们。在这个过程中，我们还将涵盖各种缓存淘汰策略和技术，以保持缓存与原始数据存储同步。
- en: Response caching
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应缓存
- en: 'Response caching is a caching technique supported by HTTP to cache the response
    to a request made using HTTP or HTTPS either on the client (for example, a browser)
    or an intermediate proxy server. From an implementation standpoint, this is controlled
    by setting the appropriate value for the `Cache-Control` header in both requests
    and responses. A typical `Cache-Control` header will look as follows:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 响应缓存是HTTP支持的一种缓存技术，用于缓存使用HTTP或HTTPS发出的请求的响应，无论是在客户端（例如，浏览器）还是中间代理服务器上。从实现的角度来看，这通过在请求和响应中设置适当的`Cache-Control`头值来控制。一个典型的`Cache-Control`头将如下所示：
- en: '[PRE0]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: In this case, if the header is present in the response, the server is telling
    the client/proxy (public) that the client can cache the response for 10 seconds
    (`max-age=10`). However, the client can still override it and cache it for a shorter
    duration; that is, if both the request and response set the cache headers, the
    cache duration would be the minimum of both.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，如果响应中存在该头，服务器正在告诉客户端/代理（公开）客户端可以缓存响应10秒（`max-age=10`）。然而，客户端仍然可以覆盖它并缓存更短的时间；也就是说，如果请求和响应都设置了缓存头，则缓存持续时间将是两者中的最小值。
- en: 'Along with `max-age`, as per the HTTP specification ([https://tools.ietf.org/html/rfc7234#section-5.2](https://tools.ietf.org/html/rfc7234#section-5.2)),
    `Cache-Control` can additionally hold the following values:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`max-age`之外，根据HTTP规范（[https://tools.ietf.org/html/rfc7234#section-5.2](https://tools.ietf.org/html/rfc7234#section-5.2)），`Cache-Control`还可以包含以下值：
- en: '**Public**: The response can be cached anywhere – client/server/intermediate
    proxy server.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**公开**：响应可以缓存在任何地方 – 客户端/服务器/中间代理服务器。'
- en: '**Private**: The response can be stored for a specific user but not in a shared
    cache server; for example, it can be stored in the client browser or application
    server.'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**私有**：响应可以存储在特定用户处，但不能存储在共享缓存服务器上；例如，它可以存储在客户端浏览器或应用服务器中。'
- en: '**No-cache**: The response cannot be cached.'
  id: totrans-51
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**No-cache**：响应不能被缓存。'
- en: 'Other headers that play a role in response caching are the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在响应缓存中起作用的其它头包括以下内容：
- en: '**Age**: This is a response header indicating the duration for which an object
    is present in the cache (proxy/browser). The accepted value is an integer and
    represents the duration in seconds.'
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Age**：这是一个响应头，表示对象在缓存（代理/浏览器）中存在的时间长度。接受的值是一个整数，表示秒数。'
- en: '`Vary` is set to the `user-agent` value, responses are uniquely cached per
    `user-agent`.'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Vary`设置为`user-agent`值，每个`user-agent`的响应将唯一缓存。'
- en: 'The following screenshot shows response headers related to the cache for a
    sample request in Postman:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的截图显示了Postman中一个示例请求相关的缓存响应头：
- en: '![Figure 8.2 – Sample response with Cache-Control and Vary headers'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – 带有Cache-Control和Vary头的示例响应'
- en: '](img/Figure_8.2_B18507.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.2_B18507.jpg)'
- en: Figure 8.2 – Sample response with Cache-Control and Vary headers
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – 带有Cache-Control和Vary头的示例响应
- en: 'The following sequence diagram shows a sample API built using ASP.NET Core
    6 that has response caching middleware enabled:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的序列图显示了使用ASP.NET Core 6构建的具有启用响应缓存中间件的示例API：
- en: '![Figure 8.3 – Response cache sequence diagram'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.3 – 响应缓存序列图'
- en: '](img/Figure_8.3_B18507.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.3_B18507.jpg)'
- en: Figure 8.3 – Response cache sequence diagram
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.3 – 响应缓存序列图
- en: 'After creating a new ASP.NET Core 6 MVC/Web API application, or using an existing
    ASP.NET Core 6 MVC/Web API application, to configure response caching, the following
    code changes are required:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建新的ASP.NET Core 6 MVC/Web API应用程序或使用现有的ASP.NET Core 6 MVC/Web API应用程序后，要配置响应缓存，需要以下代码更改：
- en: Add `builder.Services.AddResponseCaching()` to `Program.cs` and add the required
    middleware using `app.UseResponseCaching()`. This middleware holds the required
    logic to cache data. Ensure this middleware is injected before `app.UseEndpoints`.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Program.cs`中添加`builder.Services.AddResponseCaching()`，并使用`app.UseResponseCaching()`添加所需的中间件。此中间件包含缓存数据的所需逻辑。确保在`app.UseEndpoints`之前注入此中间件。
- en: Handle the response to set cache headers either through custom middleware or
    using the `ResponseCache` attribute.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过自定义中间件或使用`ResponseCache`属性来处理响应以设置缓存头。
- en: Note
  id: totrans-66
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: '`UseCors` must be called before `UseResponseCaching` when using CORS middleware.
    For further information on this ordering, please refer to [https://github.com/dotnet/AspNetCore.Docs/blob/master/aspnetcore/fundamentals/middleware/index.md](https://github.com/dotnet/AspNetCore.Docs/blob/master/aspnetcore/fundamentals/middleware/index.md).'
  id: totrans-67
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在使用CORS中间件时，必须先调用`UseCors`然后调用`UseResponseCaching`。有关此顺序的更多信息，请参阅[https://github.com/dotnet/AspNetCore.Docs/blob/master/aspnetcore/fundamentals/middleware/index.md](https://github.com/dotnet/AspNetCore.Docs/blob/master/aspnetcore/fundamentals/middleware/index.md)。
- en: 'The `ResponseCache` attribute can be used for the entire controller or specific
    methods in a controller, and it accepts the following key properties:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseCache`属性可用于整个控制器或控制器中的特定方法，并接受以下键属性：'
- en: '`Duration`: A numeric value that sets the `max-age` value in the response header'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Duration`：一个数值，用于设置响应头中的`max-age`值'
- en: '`ResponseCacheLocation`: An enum that takes three values – `Any`, `Client`,
    and `None` – and further sets the `Cache-Control` header to `public`, `private`,
    or `no-store`'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ResponseCacheLocation`：一个枚举，接受三个值 - `Any`、`Client`和`None` - 并进一步设置`Cache-Control`头为`public`、`private`或`no-store`'
- en: '`VaryByHeader`: A string that controls cache behavior to cache based on a specific
    header'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VaryByHeader`：一个字符串，用于控制基于特定头的缓存行为'
- en: '`VaryByQueryKeys`: An array of strings that accepts key values on which basis
    data is cached'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`VaryByQueryKeys`：一个字符串数组，接受基于其缓存数据的关键值'
- en: 'A typical method with the `ResponseCache` attribute looks like this:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 带有`ResponseCache`属性的一个典型方法看起来像这样：
- en: '[PRE1]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: '[PRE2]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '[PRE3]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: This method would be cached for `500` seconds based on a unique `user-agent`
    header and `Id` value. If any of these values change, a response is served from
    the server, otherwise, it's served from the cache middleware.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法将基于唯一的`user-agent`头和`Id`值缓存`500`秒。如果这些值中的任何一个发生变化，则从服务器提供响应，否则从缓存中间件提供。
- en: As you can see here, we need to prefix the `ResponseCache` attribute to every
    controller/method. So, if the application has many controllers/methods, this could
    be a maintenance overhead since, in order to make any changes to the way data
    is cached (such as changing the `Duration` value), we need to apply the change
    at the controller/method level, and that's where cache profiles come into play.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如您在此处所见，我们需要为每个控制器/方法前缀添加`ResponseCache`属性。因此，如果应用程序有多个控制器/方法，这可能是一个维护开销，因为为了更改数据缓存的方式（例如更改`Duration`值），我们需要在控制器/方法级别应用更改，这正是缓存配置文件发挥作用的地方。
- en: 'So, instead of setting properties individually, we can group them and give
    them a name in `Program.cs`, and that name can be used in the `ResponseCache`
    attribute. So, for the preceding properties, we can create a cache profile by
    adding the code shown here in `Program.cs`:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不必单独设置属性，我们可以将它们分组，并在`Program.cs`中给它们一个名称，该名称可以在`ResponseCache`属性中使用。因此，对于前面的属性，我们可以在`Program.cs`中通过添加以下代码创建一个缓存配置文件：
- en: '[PRE8]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'And on the controller, call this cache profile using `CacheProfileName`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器上，使用`CacheProfileName`调用此缓存配置文件：
- en: '[PRE17]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: For an MVC application, `CacheProfile` can be configured in `services.AddControllersWithViews()`.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 对于MVC应用程序，可以在`services.AddControllersWithViews()`中配置`CacheProfile`。
- en: Distributed caching
  id: totrans-96
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式缓存
- en: 'As we know, in a distributed system, the data store is split across multiple
    servers. Similarly, distributed caching is an extension of traditional caching
    in which cached data is stored in more than one server in a network. Before we
    get into distributed caching, here''s a quick recap of the **CAP theorem**:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，在分布式系统中，数据存储被分散在多个服务器上。同样，分布式缓存是传统缓存的扩展，其中缓存数据存储在网络的多个服务器上。在我们深入了解分布式缓存之前，这里快速回顾一下**CAP定理**：
- en: '**C** stands for consistency, meaning the data is consistent across all the
    nodes and each node has the same copy of the data.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**C** 代表一致性，意味着数据在所有节点上都是一致的，每个节点都有相同的数据副本。'
- en: '**A** stands for availability, meaning the system is available, and the failure
    of one node doesn''t cause the system to go down.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**A** 代表可用性，意味着系统是可用的，一个节点的故障不会导致系统崩溃。'
- en: '**P** stands for partition-tolerant, meaning the system doesn''t go down even
    if the communication between nodes goes down.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**P** 代表分区容错，意味着即使节点之间的通信中断，系统也不会崩溃。'
- en: As per the CAP theorem, any distributed system can only achieve two of the preceding
    principles, and as distributed systems must be partition-tolerant (P), we can
    only achieve either consistency (C) of data or high availability (A) of data.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 根据CAP定理，任何分布式系统只能实现上述两个原则中的两个，并且由于分布式系统必须是分区容错的（P），我们只能实现数据的一致性（C）或数据的高可用性（A）。
- en: So, distributed caching is a cache strategy in which data is stored in multiple
    servers/nodes/shards outside the application server. Since data is distributed
    across multiple servers, if one server goes down, another server can be used as
    a backup to retrieve data.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，分布式缓存是一种缓存策略，其中数据存储在应用服务器之外的多台服务器/节点/分片中。由于数据分布在多台服务器上，如果一台服务器宕机，另一台服务器可以作为备份来检索数据。
- en: For example, if our system wanted to cache countries, states, and cities, and
    if there are three caching servers in a distributed caching system, hypothetically
    there is a possibility that one of the cache servers will cache countries, another
    one will cache states, and one will cache cities (of course, in a real-time application,
    data is split in a much more complex way).
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们的系统想要缓存国家、州和城市，并且在一个分布式缓存系统中有三台缓存服务器，假设其中一台缓存服务器将缓存国家，另一台缓存州，还有一台缓存城市（当然，在实际应用中，数据的分割方式要复杂得多）。
- en: 'Also, each server will additionally act as a backup for one or more entities.
    So, on a high level, one type of distributed cache system looks as shown:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，每台服务器还将作为一个或多个实体的备份。因此，从高层次来看，一种分布式缓存系统看起来如下所示：
- en: '![Figure 8.4 – Distributed caching high-level representation'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.4 – 分布式缓存高级表示'
- en: '](img/Figure_8.4_B18507.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.4_B18507.jpg)'
- en: Figure 8.4 – Distributed caching high-level representation
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.4 – 分布式缓存高级表示
- en: As you can see, while reading data, it is read from the primary server, and
    if the primary server is not available, the caching system will fall back to the
    secondary server. Similarly, for writes, write operations are not complete until
    data is written to the primary as well as the secondary server. Until this operation
    is completed, read operations can be blocked, hence compromising the availability
    of the system. Another strategy for writes could be background synchronization,
    which will result in the eventual consistency of data, hence compromising the
    consistency of data until synchronization is completed. Going back to the CAP
    theorem, most distributed caching systems fall under the category of CP or AP.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在读取数据时，数据是从主服务器读取的，如果主服务器不可用，缓存系统将回退到辅助服务器。同样，对于写入操作，只有在数据被写入主服务器和辅助服务器之后，写入操作才算完成。在此操作完成之前，读取操作可能会被阻塞，从而影响系统的可用性。对于写入操作，另一种策略可以是后台同步，这将导致数据最终一致性，因此在同步完成之前，数据的一致性可能会受到影响。回到CAP定理，大多数分布式缓存系统属于CP或AP类别。
- en: 'The following are a few of the distributed caching providers that are integrated
    with .NET 6 applications:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些与.NET 6应用程序集成的分布式缓存提供商：
- en: Redis Cache
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Redis Cache
- en: Memcached
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Memcached
- en: Couchbase
  id: totrans-112
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Couchbase
- en: SQL Server
  id: totrans-113
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server
- en: NCache
  id: totrans-114
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: NCache
- en: This can be further extended to any cluster orchestration platform, for example,
    **Terracotta**, which takes care of managing various nodes and can distribute
    data to all nodes.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以进一步扩展到任何集群编排平台，例如，**Terracotta**，它负责管理各种节点，并将数据分发到所有节点。
- en: Although distributed caching has a lot of benefits, one possible disadvantage
    of distributed caching as opposed to single-server caching or in-process caching
    could be the introduced latency due to the possible extra hop and serialization/deserialization.
    So, if applications rely heavily on cached data, the design can consider a combination
    of in-memory cache and distributed cache. However, most scenarios are covered
    by integrating a well-implemented distributed caching system such as Redis, which
    we will cover later in this chapter.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管分布式缓存有很多好处，但与单服务器缓存或进程内缓存相比，分布式缓存的一个可能缺点可能是由于可能的额外跳转和序列化/反序列化而引入的延迟。因此，如果应用严重依赖于缓存数据，设计可以考虑内存缓存和分布式缓存的组合。然而，大多数场景都可以通过集成一个良好实现的分布式缓存系统（如Redis）来覆盖，我们将在本章后面讨论这一点。
- en: Cache access patterns
  id: totrans-117
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cache access patterns
- en: 'Once object data is cached, there needs to be a design in place that takes
    care of refreshing the cache. Multiple cache access patterns can be implemented
    to handle this. A few key patterns are as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦对象数据被缓存，就需要一个设计来处理缓存的刷新。可以实现多种缓存访问模式来处理这种情况。以下是一些关键模式：
- en: Cache-aside pattern
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Cache-aside pattern
- en: Read-through/write-through
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Read-through/write-through
- en: Refresh-ahead
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Refresh-ahead
- en: Write-behind
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Write-behind
- en: Let's discuss each in detail.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们逐一详细讨论。
- en: Cache-aside pattern
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cache-aside pattern
- en: As the name suggests, in the cache-aside pattern, the cache store is kept alongside
    the data store. In this pattern, the application code checks for data availability
    in the cache store. If it's not available in the cache store, the data is retrieved
    from the underlying data store and is updated in the cache. Subsequent requests
    would again query the data in the cache and if the data is available in the cache,
    it will be served from the cache. The cache-aside pattern relies on the concept
    of lazy loading, discussed in [*Chapter 4*](B18507_04_Epub.xhtml#_idTextAnchor205),
    *Threading and Asynchronous Operations*, and populates as and when data is accessed
    for the first time; a subsequent request for the same entity would be loaded from
    cache.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，在缓存-旁路模式中，缓存存储与数据存储一起保留。在这个模式中，应用程序代码会检查缓存存储中的数据可用性。如果缓存存储中没有数据，则从底层数据存储中检索数据，并在缓存中更新。后续请求将再次查询缓存中的数据，如果数据在缓存中可用，则将从缓存中提供服务。缓存-旁路模式依赖于懒加载的概念，这在[*第4章*](B18507_04_Epub.xhtml#_idTextAnchor205)中讨论过，*线程和异步操作*，并且当数据首次被访问时填充；对同一实体的后续请求将加载自缓存。
- en: The expiry of data in the cache store should be handled while updating the data
    in the original data store, and then subsequent reads will add the updated data
    to the cache again.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在更新原始数据存储中的数据时，应该处理缓存存储中数据的过期。
- en: 'The following are the advantages of this pattern:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个模式的优势：
- en: Simplified implementation compared to the read-through/write-through patterns
    covered in the next section. As the cache isn't the primary data source in the
    application, we do not need additional classes to synchronize the cache store
    with the data store.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与下一节中介绍的读取/写入模式相比，实现简化。由于缓存不是应用中的主要数据源，我们不需要额外的类来同步缓存存储与数据存储。
- en: As it relies on the lazy loading principle, the cache is populated only when
    any data is accessed at least once.
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它依赖于懒加载原则，缓存仅在访问任何数据至少一次时才会被填充。
- en: 'However, there are a few cons associated with this pattern:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这个模式也有一些缺点：
- en: It leads to the possibility of a greater number of cache misses. Cache misses
    should always be minimal as they introduce latency in the application due to the
    additional hop.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可能导致缓存未命中次数增加的可能性。缓存未命中应该始终保持在最小，因为它们会由于额外的跳转而引入应用的延迟。
- en: If cache expiry is missed during data updates, it can lead to stale data in
    the cache. This can occur if data is updated by a background/external process
    that doesn't have information on the caching system.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在数据更新期间错过缓存过期，可能会导致缓存中的数据过时。这可能发生在数据由没有缓存系统信息的后台/外部进程更新时。
- en: One way to mitigate issues with expiration is to set the **Time to Live** (**TTL**)
    for each entity so that objects are automatically expired after a certain period.
    However, the TTL duration needs to be carefully evaluated after monitoring the
    data refresh rate. Another common practice in the case of the cache-aside pattern
    is to prepopulate the cache store during the startup of the application as this
    helps in reducing the number of cache misses. Most enterprise applications usually
    implement a caching layer using the cache-aside pattern and prepopulate it with
    master data rather than transactional data.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 一种减轻过期问题的方法是为每个实体设置**生存时间**（**TTL**），这样对象在一段时间后就会自动过期。然而，在监控数据刷新率后，需要仔细评估TTL持续时间。在缓存旁路模式的情况下，另一种常见做法是在应用程序启动时预先填充缓存存储，因为这有助于减少缓存未命中次数。大多数企业应用程序通常使用缓存旁路模式实现缓存层，并用主数据而不是事务数据预先填充它。
- en: Read-through/write-through
  id: totrans-134
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 读取/写入
- en: In read-through/write-through, the application directly reads/writes data from
    the cache store; that is, the application uses it as a primary store and the cache
    layer is responsible for loading the data in the cache and also for writing any
    updates from the cache store back to the original store.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在读取/写入中，应用程序直接从缓存存储读取/写入数据；也就是说，应用程序将其用作主存储，缓存层负责在缓存中加载数据，并负责将任何从缓存存储更新的数据写回原始存储。
- en: When the application wants to read an entity, it will directly request it from
    the cache store. If that entity is available in the cache, a response is returned.
    However, if it isn't present in the cache, the caching layer requests it from
    the original data store, which is updated in the cache for future use, and then
    the response is returned from the cache layer.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序想要读取一个实体时，它将直接从缓存存储请求它。如果该实体存在于缓存中，则返回响应。然而，如果它不在缓存中，缓存层将从原始数据存储请求它，该数据存储在缓存中更新以供将来使用，然后从缓存层返回响应。
- en: 'When updating an entity, the following steps occur:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 更新实体时，以下步骤发生：
- en: It is first updated in the cache.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先更新到缓存中。
- en: The cache layer writes it back to the original data store.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 缓存层将其写回原始数据存储。
- en: 'The major advantages of this kind of system are as follows:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 这种类型系统的优点如下：
- en: Significant load reduction on the original data store, which is usually a database,
    as in most enterprise applications, all the calls would be served from the cache
    apart from calls from the cache layer to the data store.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在原始数据存储（通常是一个数据库）上显著减少负载，因为在大多数企业应用程序中，所有调用都会从缓存提供服务，除了从缓存层到数据存储的调用。
- en: Simplified application code as it only interacts with one store, unlike the
    cache-aside pattern, which interacts with the cache store as well as a data store
    from within the application code.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 简化的应用程序代码，因为它只与一个存储进行交互，而与缓存旁路模式不同，后者不仅与缓存存储交互，还与应用程序代码内的数据存储交互。
- en: 'A few disadvantages of this pattern are as follows:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式的几个缺点如下：
- en: An additional mechanism is required to synchronize data between the cache and
    data store.
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要一个额外的机制来同步缓存和数据存储之间的数据。
- en: Cache updating becomes a bit tricky as it involves additional complexity to
    refresh the cache store.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存更新变得有些棘手，因为它涉及到刷新缓存存储的额外复杂性。
- en: Refresh-ahead
  id: totrans-146
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预刷新
- en: The refresh-ahead strategy allows you to load data into the cache store asynchronously;
    that is, in this design, the application still talks directly to the cache store.
    However, the cache layer periodically refreshes the data before the data in the
    cache expires. The refresh happens asynchronously for the entries that were accessed
    most recently and are refreshed from the original store asynchronously before
    their expiration. This way, there won't be any latency in the application if any
    item cache is expired.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 预刷新策略允许您异步地将数据加载到缓存存储中；也就是说，在这个设计中，应用程序仍然直接与缓存存储通信。然而，缓存层会在缓存中的数据过期之前定期刷新数据。对于最近访问过的条目，刷新是异步发生的，并在它们过期之前从原始存储异步刷新。这样，如果任何缓存项已过期，应用程序中就不会有任何延迟。
- en: Write-behind
  id: totrans-148
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 写入后
- en: In the write-behind strategy, data is updated into the cache store first and
    asynchronously updated back to the data store, as opposed to the write-through
    strategy in which data is immediately updated to the data store. One of the key
    advantages of this strategy is reduced latency. However, as data is updated asynchronously
    (writing to the data store and cache store are two different transactions) to
    the data store, there should be a rollback mechanism implemented in case there
    is ever a failure.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在写入后策略中，数据首先更新到缓存存储，然后异步更新回数据存储，这与写入策略不同，在写入策略中，数据会立即更新到数据存储。这种策略的一个关键优点是降低了延迟。然而，由于数据是异步更新的（写入数据存储和缓存存储是两个不同的交易），因此应该实现回滚机制，以防万一出现故障。
- en: Typically, this is much more complex to implement as opposed to write-through
    due to the additional handling needed to avoid any data loss during asynchronous
    updates, but it's still a good pattern to integrate if there is a requirement
    to have the cache store as the primary source.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，与写入策略相比，实现起来要复杂得多，因为需要额外的处理来避免在异步更新期间发生数据丢失，但如果需要将缓存存储作为主要数据源，这仍然是一个很好的集成模式。
- en: 'All the patterns discussed up to now can be visualized at a high level as shown
    in the following figure:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止讨论的所有模式都可以在以下图中以高层次可视化：
- en: '![Figure 8.5 – Cache patterns'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.5 – 缓存模式'
- en: '](img/Figure_8.5_B18507.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.5_B18507.jpg)'
- en: Figure 8.5 – Cache patterns
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.5 – 缓存模式
- en: Up to now, we have seen various caching patterns and strategies. In the next
    section, we will discuss various cache providers and their integration with .NET
    6 applications.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了各种缓存模式和策略。在下一节中，我们将讨论各种缓存提供程序及其与 .NET 6 应用程序的集成。
- en: Caching platforms
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存平台
- en: '.NET 6 supports multiple caching platforms. A few of the commonly used cache
    platforms are as follows:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 6 支持多个缓存平台。以下是一些常用的缓存平台：
- en: '`w3wp.exe`.'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w3wp.exe`。'
- en: '**Distributed cache**: Data is stored across multiple servers. The data stores
    that can be integrated with .NET 6 applications are SQL Server, Redis, and NCache.'
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**分布式缓存**：数据存储在多个服务器上。可以与 .NET 6 应用程序集成的数据存储包括 SQL Server、Redis 和 NCache。'
- en: In-memory cache
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内存缓存
- en: 'To configure memory caching, after creating a new ASP.NET Core 6 MVC/Web API
    application, or for an existing ASP.NET Core 6 MVC/Web API application, the following
    code changes are required:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置内存缓存，在创建新的 ASP.NET Core 6 MVC/Web API 应用程序后，或者对于现有的 ASP.NET Core 6 MVC/Web
    API 应用程序，需要以下代码更改：
- en: Add `builder.Services.AddMemoryCache()` to `Program.cs`. The `MemoryCache` class
    is a built-in implementation of `IMemoryCache` in .NET 6 and would be available
    in any C# class via `IMemoryCache`. It is instantiated using constructor injection.
    Object creation happens using `IMemoryCache` and create an instance of `MemoryCache`
    using constructor injection.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中添加 `builder.Services.AddMemoryCache()`。`MemoryCache` 类是 .NET
    6 中 `IMemoryCache` 的内置实现，可以在任何 C# 类中通过 `IMemoryCache` 使用。它通过构造函数注入进行实例化。对象创建是通过
    `IMemoryCache` 进行的，并使用构造函数注入创建 `MemoryCache` 的实例。
- en: '`MemoryCache` exposes many methods, but a few important ones are `Get` (to
    get the value of a key), `Set` (to insert a key and its value), and `Remove` (to
    remove a key (cache expiration)).'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`MemoryCache` 提供了许多方法，但其中一些重要的是 `Get`（获取键的值）、`Set`（插入键及其值）和 `Remove`（移除键（缓存过期））。'
- en: 'While creating a cache object (using `Set` or other methods), the memory cache
    can be configured for various parameters using `MemoryCacheEntryOptions`. The
    following properties are supported:'
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建缓存对象（使用 `Set` 或其他方法）时，可以使用 `MemoryCacheEntryOptions` 对内存缓存进行各种参数的配置。以下属性是支持的：
- en: 'a. `SetAbsoluteExpiration`: The absolute `TimeSpan` or the exact date and time
    (`DateTime`) until which the cache is valid.'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 'a. `SetAbsoluteExpiration`: 缓存的绝对有效时间，即缓存有效的确切日期和时间（`DateTime`）。'
- en: 'b. `SetSlidingExpiration`: The inactive time for the cache after which the
    cache entry is removed from the cache. For example, a sliding expiration value
    of 5 seconds will wait for the cache entry to be inactive for 5 seconds. Sliding
    expiration should always be less than absolute expiration as the cache would expire
    after the absolute expiration duration has been reached irrespective of the sliding
    expiration duration.'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 'b. `SetSlidingExpiration`: 缓存条目在缓存中变为非活动状态后的无效时间。例如，5秒的滑动过期值将等待缓存条目非活动5秒。滑动过期值应始终小于绝对过期值，因为无论滑动过期值如何，缓存都会在达到绝对过期时间后过期。'
- en: 'c. `SetPriority`: As cache size is limited while performing cache eviction
    (`SetPriority` can be used to set the priority for a cache entry through a `CacheItemPriority`
    enum. Its default value is `CacheItemPriority.Normal`.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: c. `SetPriority`：在执行缓存淘汰时，缓存大小是有限的（可以使用 `SetPriority` 通过 `CacheItemPriority`
    枚举设置缓存条目的优先级。其默认值是 `CacheItemPriority.Normal`）。
- en: 'A simple Web API controller with memory cache integration as per the preceding
    steps will look like this:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 按照前面的步骤集成的简单 Web API 控制器，带有内存缓存集成，将如下所示：
- en: '[PRE18]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '[PRE24]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-178
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '[PRE30]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '[PRE38]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-194
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: '[PRE48]'
  id: totrans-199
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-201
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: '[PRE55]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: As you can see, this code is self-explanatory and has an API using an in-memory
    cache.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，此代码是自我解释的，并使用内存缓存提供了一个 API。
- en: 'One additional method that is available in `MemoryCache` is the integration
    of a callback method that is available through `RegisterPostEvictionCallback`.
    This is an extension method in `MemoryCacheEntryOptions` that accepts a `PostEvictionDelegate`
    delegate and a callback is triggered during cache entry expiration. The signature
    of `PostEvictionDelegate` is as follows:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: '`MemoryCache` 中可用的一种附加方法是使用 `RegisterPostEvictionCallback` 集成回调方法。这是 `MemoryCacheEntryOptions`
    中的一个扩展方法，它接受一个 `PostEvictionDelegate` 委托，并在缓存条目过期时触发回调。`PostEvictionDelegate`
    的签名如下：'
- en: '[PRE56]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: 'So, that means the callback that we pass to `RegisterPostEvictionCallback`
    should follow the same signature, and as you can see, all the input parameters
    are self-explanatory. So, let''s add a callback method and update `cacheEntryOptions`
    as follows:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这意味着我们传递给 `RegisterPostEvictionCallback` 的回调应该遵循相同的签名，如您所见，所有输入参数都是自我解释的。因此，让我们添加一个回调方法并更新
    `cacheEntryOptions`，如下所示：
- en: '[PRE57]'
  id: totrans-211
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-212
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'The code map of the weather controller is shown in the following screenshot:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 天气控制器的代码映射如下截图所示：
- en: '![Figure 8.6 – Weather controller code map'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.6 – 天气控制器代码映射'
- en: '](img/Figure_8.6_B18507.jpg)'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.6_B18507.jpg)'
- en: Figure 8.6 – Weather controller code map
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.6 – 天气控制器代码映射
- en: Once we run this code, we can see that any subsequent calls to the controller
    after the absolute expiration of 50 seconds will trigger a callback and log the
    reason as `Expiration`. Once this is deployed to `AppService`, the callback is
    automatically triggered. Only for debugging purposes would we need to make another
    call.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们运行此代码，我们就可以看到在 50 秒的绝对过期后对控制器的任何后续调用都将触发回调，并将原因记录为 `Expiration`。一旦部署到 `AppService`，回调将自动触发。只有出于调试目的，我们才需要再次调用。
- en: Distributed cache
  id: totrans-221
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式缓存
- en: Having discussed in-memory cache, let's move on to the other cache platforms
    that can be configured for distributed caching. Distributed caching, just like
    distributed storage systems, distributes the cache data to multiple servers to
    primarily support scaling. In this section, we will look at the different types
    of distributed cache, starting with SQL.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论了内存缓存之后，让我们继续探讨其他可以配置为分布式缓存的缓存平台。分布式缓存，就像分布式存储系统一样，将缓存数据分布到多个服务器上，主要是为了支持扩展。在本节中，我们将查看不同类型的分布式缓存，从
    SQL 开始。
- en: SQL
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: SQL
- en: 'Distributed caching can be implemented with various stores, one of them being
    SQL Server. The first step to using SQL Server for distributed caching is to create
    the required SQL table that will store cache entries. The entire setup for SQL
    as a distributed caching store involves the following steps:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式缓存可以使用各种存储实现，其中之一是 SQL Server。使用 SQL Server 进行分布式缓存的第一步是创建存储缓存条目的所需 SQL 表。将
    SQL 作为分布式缓存存储的整个设置涉及以下步骤：
- en: 'Open a command line in the administrator prompt and run the following command
    to install the `dotnet-sql-cache` package globally:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在管理员提示符中打开命令行并运行以下命令以全局安装 `dotnet-sql-cache` 包：
- en: '[PRE62]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: 'This is how it appears:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它的样子：
- en: '![Figure 8.7 – Installing the sql-cache package using the .NET CLI'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.7 – 使用 .NET CLI 安装 sql-cache 包'
- en: '](img/Figure_8.7_B18507.jpg)'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.7_B18507.jpg)'
- en: Figure 8.7 – Installing the sql-cache package using the .NET CLI
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.7 – 使用 .NET CLI 安装 sql-cache 包
- en: 'Create the required database (on-premises or using Azure SQL) and run the following
    command to create the table that stores cache data:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建所需的数据库（本地或使用 Azure SQL）并运行以下命令以创建存储缓存数据的表：
- en: '[PRE63]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: In this command, we are passing the connection string of the database (update
    it accordingly when running it locally) as one parameter and the other is the
    name of the table (`cache` is the name of the table in the preceding snippet).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个命令中，我们传递数据库的连接字符串（在本地运行时相应更新）作为参数之一，另一个是表的名称（`cache` 是前一个片段中表的名称）。
- en: '![Figure 8.8 – Creating a SQL table for distributed caching'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.8 – 为分布式缓存创建 SQL 表'
- en: '](img/Figure_8.8_B18507.jpg)'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.8_B18507.jpg)'
- en: Figure 8.8 – Creating a SQL table for distributed caching
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.8 – 为分布式缓存创建 SQL 表
- en: 'Once the command has run successfully, if we open the SQL server in SSMS, we
    will see a table as shown in the following screenshot that has the columns and
    indexes required for optimization:'
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦命令成功运行，如果我们打开 SSMS 中的 SQL 服务器，我们将看到如下所示的表，其中包含用于优化的列和索引：
- en: '![Figure 8.9 – Cache table in SQL distributed caching from SSMS'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.9 – SSMS 中 SQL 分布式缓存的缓存表'
- en: '](img/Figure_8.9_B18507.jpg)'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.9_B18507.jpg)'
- en: Figure 8.9 – Cache table in SQL distributed caching from SSMS
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.9 – SSMS 中 SQL 分布式缓存的缓存表
- en: Create a Web API application and install NuGet `Microsoft.Extensions.Caching.SqlServer`
    (either through the **Package Manager Console** (**PMC**) or using the .NET CLI).
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 Web API 应用程序并安装 NuGet 包 `Microsoft.Extensions.Caching.SqlServer`（通过 **包管理控制台**（**PMC**）或使用
    .NET CLI）。
- en: 'In `Program.cs`, add the following code:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中添加以下代码：
- en: '[PRE64]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'To insert data into the cache, we need to make use of `IDistributedCache`,
    and the object will be created via constructor injection. So, clean up all the
    code in `WeatherForecastController` (the default controller created during the
    creation of the ASP.NET Core 6 Web API project) and add the following code (a
    Web API controller that has a `Get` method):'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要将数据插入缓存，我们需要使用 `IDistributedCache`，该对象将通过构造函数注入创建。因此，清理 `WeatherForecastController`（在创建
    ASP.NET Core 6 Web API 项目期间创建的默认控制器）中的所有代码，并添加以下代码（一个具有 `Get` 方法的 Web API 控制器）：
- en: '[PRE65]'
  id: totrans-245
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE65]'
- en: 'Add the following `Get` method, which uses `distributedCache` and saves data
    to the cache store (SQL in this case):'
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `Get` 方法，它使用 `distributedCache` 并将数据保存到缓存存储（在这种情况下为 SQL）：
- en: '[PRE66]'
  id: totrans-247
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE66]'
- en: 'Run the application and we can see that the cache entry is getting stored in
    the SQL database, as shown in the following screenshot:'
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序后，我们可以看到缓存条目正被存储在 SQL 数据库中，如下面的屏幕截图所示：
- en: '![](img/Figure_8.10_B18507.jpg)'
  id: totrans-249
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_8.10_B18507.jpg)'
- en: Figure 8.10 – Cache table in SQL distributed caching
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.10 – SQL 分布式缓存的缓存表
- en: As you can see, the code is very much like the `MemoryCache` code, except that
    we use `IDistributedCache` here to read/write data to cache and `DistributedCacheEntryOptions`
    for setting additional properties during cache entry creation.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，代码与 `MemoryCache` 代码非常相似，只是我们在这里使用 `IDistributedCache` 来读写缓存数据，并使用 `DistributedCacheEntryOptions`
    在创建缓存条目时设置额外的属性。
- en: 'A few recommendations for using SQL Server as a distributed caching store are
    as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 SQL Server 作为分布式缓存存储的一些建议如下：
- en: SQL Server can be picked if the existing application does not support stores
    such as Redis. For example, an on-premises application that only integrates with
    SQL Server can easily extend SQL Server for caching purposes.
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果现有应用程序不支持 Redis 等存储，可以选择 SQL Server。例如，仅与 SQL Server 集成的本地应用程序可以轻松扩展 SQL Server
    以用于缓存目的。
- en: The cache database should be different from the application database as using
    the same databases can cause bottlenecks and defeats the purpose of using a cache.
  id: totrans-254
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存数据库应与应用程序数据库不同，因为使用相同的数据库可能会导致瓶颈并违背使用缓存的目的。
- en: The built-in implementation of `IDistributedCache` for SQL Server is `SqlServerCache`
    and does not support serializing a different schema for the caching table. Any
    customization has to be manually overridden by implementing `IDistributedCache`
    in a custom class.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server 的 `IDistributedCache` 内置实现是 `SqlServerCache`，它不支持为缓存表序列化不同的模式。任何自定义都必须通过在自定义类中实现
    `IDistributedCache` 来手动覆盖。
- en: Up until now, we have seen in-memory caching and distributed caching using SQL
    Server. In the next section, we will see how to use Redis (one of the recommended
    stores and a widely used store for caching) for distributed caching in .NET 6
    applications.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经看到了使用 SQL Server 进行内存缓存和分布式缓存的示例。在下一节中，我们将看到如何在 .NET 6 应用程序中使用 Redis（推荐的存储之一，也是广泛用于缓存的存储）进行分布式缓存。
- en: Redis
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Redis
- en: Redis is an in-memory data store that is used for various purposes, such as
    databases, cache stores, and even as a message broker. The core data structure
    that Redis supports is key-value pairs where the value could be something as simple
    as a string, to a custom complex data type (nested classes). Redis works with
    an in-memory dataset and can also persist data to disk on a per-need basis. Redis
    also internally supports replication and automatic partitioning with Redis Cluster.
    With all these features available out of the box, it's an ideal store for distributed
    caching.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: Redis 是一个内存数据存储，用于各种目的，如数据库、缓存存储，甚至作为消息代理。Redis 支持的核心数据结构是键值对，其中值可以是简单的字符串，也可以是自定义的复杂数据类型（嵌套类）。Redis
    与内存数据集一起工作，并且可以根据需要将数据持久化到磁盘。Redis 还内部支持 Redis 集群的复制和自动分区。由于所有这些功能都是开箱即用的，因此它是一个理想的分布式缓存存储。
- en: 'Azure provides a managed instance for Redis servers known as **Azure Cache
    for Redis**, and just like any other PaaS service, it is managed by Microsoft.
    This allows application developers to integrate it as is and leave the infrastructure
    overhead of maintaining, scaling, and upgrading the Redis server to Microsoft.
    Azure Cache for Redis can be used for distributed caching and can be easily integrated
    into .NET 6 applications using the following steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: Azure 提供了一个名为 **Azure Cache for Redis** 的 Redis 服务器托管实例，就像任何其他 PaaS 服务一样，由 Microsoft
    管理。这允许应用程序开发者直接集成它，并将维护、扩展和升级 Redis 服务器的基础设施开销留给 Microsoft。Azure Cache for Redis
    可用于分布式缓存，并且可以使用以下步骤轻松集成到 .NET 6 应用程序中：
- en: 'First, create an instance of Azure Cache for Redis as outlined at [https://docs.microsoft.com/en-in/azure/azure-cache-for-redis/quickstart-create-redis](https://docs.microsoft.com/en-in/azure/azure-cache-for-redis/quickstart-create-redis).
    Navigate to **Access keys** and copy the value under **Primary connection string**,
    as shown in the following screenshot:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，根据 [https://docs.microsoft.com/en-in/azure/azure-cache-for-redis/quickstart-create-redis](https://docs.microsoft.com/en-in/azure/azure-cache-for-redis/quickstart-create-redis)
    中的说明创建 Azure Cache for Redis 的实例。导航到 **访问密钥** 并复制 **主连接字符串** 下的值，如图所示：
- en: '![Figure 8.11 – Cache key from Azure Cache for Redis'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.11 – Azure Cache for Redis 的缓存键'
- en: '](img/Figure_8.11_B18507.jpg)'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.11_B18507.jpg)'
- en: Figure 8.11 – Cache key from Azure Cache for Redis
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.11 – Azure Cache for Redis 的缓存键
- en: Create an ASP.NET Core 6 Web API application and install the NuGet `Microsoft.Extensions.Caching.StackExchangeRedis`
    package.
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 ASP.NET Core 6 Web API 应用程序并安装 NuGet 包 `Microsoft.Extensions.Caching.StackExchangeRedis`。
- en: 'In `Program.cs`, add the following code:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Program.cs` 中添加以下代码：
- en: '[PRE67]'
  id: totrans-266
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE67]'
- en: Update the default `WeatherForecastController` controller with the same code
    as shown in the previous *SQL* section.
  id: totrans-267
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用与上一节 *SQL* 中所示相同的代码更新默认的 `WeatherForecastController` 控制器。
- en: Run the application and we can see that data gets stored in the cache for 10
    seconds. Any calls within 50 seconds to this API will retrieve data from the cache.
  id: totrans-268
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行应用程序后，我们可以看到数据在缓存中存储了 10 秒。在 50 秒内对 API 的任何调用都将从缓存中检索数据。
- en: 'Azure Cache for Redis also comes with a console that allows us to query the
    Redis server using Redis CLI commands. The console can be found in the Azure portal
    by navigating to the overview left menu of the Redis instance. Querying it for
    the `Weather` key will give us the results shown in the following screenshot:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: Azure Cache for Redis 还附带一个控制台，允许我们使用 Redis CLI 命令查询 Redis 服务器。可以通过导航到 Redis
    实例的左侧菜单概览来在 Azure 门户中找到该控制台。查询 `Weather` 键将给出以下截图所示的结果：
- en: '![Figure 8.12 – Redis console'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.12 – Redis 控制台'
- en: '](img/Figure_8.12_B18507.jpg)'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.12_B18507.jpg)'
- en: Figure 8.12 – Redis console
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.12 – Redis 控制台
- en: If we go with the Premium tier of Azure Cache for Redis, it also supports multiple
    shards to support higher volumes of data and geo-replication for high availability.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择 Azure Cache for Redis 的 Premium 层，它还支持多个分片以支持更高的数据量，并支持高可用性的地理复制。
- en: Additionally, to add/remove keys from the cache store, there are the `GetAsync`
    and `SetAsync` methods, which can be used to store more complex types or any type
    other than string. However, these methods return/accept `Task<byte[]>`, so the
    application needs to handle serialization/deserialization, which can be seen in
    the reusable caching library.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，为了从缓存存储中添加/删除键，还有 `GetAsync` 和 `SetAsync` 方法，可以用来存储更复杂的数据类型或任何非字符串类型。然而，这些方法返回/接受
    `Task<byte[]>`，因此应用程序需要处理序列化/反序列化，这在可重用的缓存库中可以看到。
- en: Redis is the most preferred cache store for enterprise applications, and in
    our e-commerce application, we will use Azure Cache for Redis as our cache store.
    Some additional information about Azure Cache for Redis can be found at [https://docs.microsoft.com/en-in/azure/azure-cache-for-redis/](https://docs.microsoft.com/en-in/azure/azure-cache-for-redis/).
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: Redis是企业应用程序中最受欢迎的缓存存储，在我们的电子商务应用程序中，我们将使用Azure Cache for Redis作为我们的缓存存储。有关Azure
    Cache for Redis的更多信息，可以在[https://docs.microsoft.com/en-in/azure/azure-cache-for-redis/](https://docs.microsoft.com/en-in/azure/azure-cache-for-redis/)找到。
- en: Other providers
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 其他提供者
- en: 'As you can see, distributed caching in .NET 6 applications is driven by `IDistributedCache`,
    and whichever store''s implementation is injected in the `Program` class cache
    store is configured accordingly. Additionally, there are two more providers that
    .NET 6 has a built-in implementation for:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，.NET 6应用程序中的分布式缓存是由`IDistributedCache`驱动的，并且`Program`类中的缓存存储配置将根据注入的存储实现进行相应配置。此外，.NET
    6还内置了两个其他提供者：
- en: '`IDistributedCache`. NCache can be integrated like Redis or SQL. However, the
    NCache server needs to be configured locally for development and can be configured
    in IaaS using virtual machines or PaaS using app services.'
  id: totrans-278
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IDistributedCache`。NCache可以像Redis或SQL一样集成。然而，NCache服务器需要在本地进行配置以用于开发，并且可以使用IaaS中的虚拟机或PaaS中的应用服务进行配置。'
- en: '`AddDistributedMemoryCache`): This is another built-in implementation of `IDistributedCache`
    and can be used similarly. It can be used for unit testing. Since it''s not a
    distributed cache and uses process memory, it is not recommended for multiple
    application server scenarios. The only difference between `AddMemoryCache(IMemoryCache)`
    and `AddDistributedMemoryCache(IDistributedCache)` is that the latter one requires
    serialization to store complex data. So, if there is a type that cannot be serialized
    and needs to be cached, go with `IMemoryCache`, otherwise go with `IDistributedCache`.'
  id: totrans-279
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddDistributedMemoryCache`): 这是`IDistributedCache`的另一个内置实现，可以类似地使用。它可以用于单元测试。由于它不是分布式缓存并且使用进程内存，因此不建议在多个应用程序服务器场景中使用。`AddMemoryCache(IMemoryCache)`和`AddDistributedMemoryCache(IDistributedCache)`之间的唯一区别是后者需要序列化以存储复杂数据。因此，如果存在无法序列化且需要缓存的类型，请使用`IMemoryCache`，否则请使用`IDistributedCache`。'
- en: In enterprise applications, `IDistributedCache` can address all the caching
    layer implementation, and a combination of in-memory cache for a development/testing
    environment and Redis for a production environment would be ideal. If your application
    is hosted on a single server, you can go with an in-memory cache but that's very
    rare for production applications, hence it is most recommended to go with distributed
    caching.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，`IDistributedCache`可以处理所有缓存层实现，对于开发/测试环境使用内存缓存，对于生产环境使用Redis将是一个理想的选择。如果您的应用程序托管在单个服务器上，您可以使用内存缓存，但在生产应用程序中这种情况非常罕见，因此最推荐使用分布式缓存。
- en: So, based on all the principles and patterns that we've discussed, we will design
    a cache abstraction layer to be used in an e-commerce application, which is discussed
    in the next section.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，基于我们讨论的所有原则和模式，我们将设计一个用于电子商务应用程序的缓存抽象层，这将在下一节中讨论。
- en: Designing a cache abstraction layer using distributed caching
  id: totrans-282
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用分布式缓存设计缓存抽象层
- en: In enterprise applications, it's always good to have a wrapper class on top
    of an underlying cache implementation as it abstracts the core logic of caching
    and can also be used as one single class that holds application-wide default cache
    entry options.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用程序中，在底层缓存实现之上有一个包装类总是很好的，因为它抽象了缓存的核心理念，也可以用作一个包含应用程序范围内默认缓存条目选项的单个类。
- en: 'We will be implementing a cache wrapper class with an underlying store as Azure
    Cache for Redis using the `IDistributedCache` implementation. It''s a .NET Standard
    2.1 class library; the source code for this library is available in the `Packt.Ecommerce.Caching`
    project. Any class that wants to cache data should inject `IDistributedCacheService`
    using constructor injection and can call the following various methods:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个缓存包装类，其底层存储为Azure Cache for Redis，使用`IDistributedCache`实现。这是一个.NET Standard
    2.1类库；该库的源代码位于`Packt.Ecommerce.Caching`项目中。任何想要缓存数据的类都应该使用构造函数注入`IDistributedCacheService`，并可以调用以下各种方法：
- en: '`AddOrUpdateCacheAsync<T>`: Adds or updates cache entries of type `T` asynchronously'
  id: totrans-285
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddOrUpdateCacheAsync<T>`: 异步添加或更新类型为`T`的缓存条目'
- en: '`AddOrUpdateCacheStringAsync`: Adds or updates cache entries of the string
    type asynchronously'
  id: totrans-286
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddOrUpdateCacheStringAsync`：异步添加或更新字符串类型的缓存条目'
- en: '`GetCacheAsync<T>`: Gets cache entries of type `T` asynchronously'
  id: totrans-287
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCacheAsync<T>`：异步获取类型为 `T` 的缓存条目'
- en: '`GetCacheStringAsync`: Gets cache entries of the string type asynchronously'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetCacheStringAsync`：异步获取字符串类型的缓存条目'
- en: '`RefreshCacheAsync`: Refreshes cache entries asynchronously'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RefreshCacheAsync`：异步刷新缓存条目'
- en: '`RemoveCacheAsync`: Removes cache entries asynchronously'
  id: totrans-290
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveCacheAsync`：异步移除缓存条目'
- en: '`DistributedCacheService` is the wrapper class that inherits `IDistributedCacheService`
    and implements all the preceding methods. Additionally, `IDistributedCache` and
    `DistributedCacheEntryOptions` are configured in this class to use distributed
    caching.'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: '`DistributedCacheService` 是继承自 `IDistributedCacheService` 并实现所有上述方法的包装类。此外，在这个类中配置了
    `IDistributedCache` 和 `DistributedCacheEntryOptions` 以使用分布式缓存。'
- en: 'For serialization and deserialization, we will use `System.Text.Json`, a custom
    `IEntitySerializer` interface, and the `EntitySerializer` class is created with
    the following methods:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 对于序列化和反序列化，我们将使用 `System.Text.Json`，一个自定义的 `IEntitySerializer` 接口，以及使用以下方法创建的
    `EntitySerializer` 类：
- en: '`SerializeEntityAsync<T>`: Serializes the specified object to a byte array
    asynchronously'
  id: totrans-293
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SerializeEntityAsync<T>`：异步将指定的对象序列化为字节数组'
- en: '`DeserializeEntityAsync<T>`: Deserializes the specified stream asynchronously'
  id: totrans-294
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeserializeEntityAsync<T>`：异步反序列化指定的流'
- en: The `IEntitySerializer` implementation is injected into the `DistributedCacheService`
    class using constructor injection and is used for serialization and deserialization.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`IEntitySerializer` 的实现通过构造函数注入注入到 `DistributedCacheService` 类中，并用于序列化和反序列化。'
- en: Note
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please refer to the *Serialization performance comparison* article, which talks
    about benchmarking various serializers. You can find it at [https://maxondev.com/serialization-performance-comparison-c-net-formats-frameworks-xmldatacontractserializer-xmlserializer-binaryformatter-json-newtonsoft-servicestack-text/](https://maxondev.com/serialization-performance-comparison-c-net-formats-frameworks-xmldatacontractserializer-xmlserializer-binaryformatter-json-newtonsoft-servicestack-text/).
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅 *序列化性能比较* 文章，该文章讨论了各种序列化程序的基准测试。您可以在 [https://maxondev.com/serialization-performance-comparison-c-net-formats-frameworks-xmldatacontractserializer-xmlserializer-binaryformatter-json-newtonsoft-servicestack-text/](https://maxondev.com/serialization-performance-comparison-c-net-formats-frameworks-xmldatacontractserializer-xmlserializer-binaryformatter-json-newtonsoft-servicestack-text/)
    找到它。
- en: The implementation of `DistributedCacheService` and `EntitySerializer` follows
    all the asynchronous principles discussed in [*Chapter 4*](B18507_04_Epub.xhtml#_idTextAnchor205),
    *Threading and Asynchronous Operations*, and the configuration as explained in
    [*Chapter 6*](B18507_06_Epub.xhtml#_idTextAnchor473)*, Configuration in .NET 6*.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: '`DistributedCacheService` 和 `EntitySerializer` 的实现遵循在 [*第 4 章*](B18507_04_Epub.xhtml#_idTextAnchor205)，*线程和异步操作*
    中讨论的所有异步原则，以及在第 [*第 6 章*](B18507_06_Epub.xhtml#_idTextAnchor473)*，.NET 6 中的配置*中解释的配置。'
- en: 'Finally, in an API/MVC application, perform these steps:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在 API/MVC 应用程序中，执行以下步骤：
- en: Install the NuGet `Microsoft.Extensions.Caching.StackExchangeRedis` package.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 NuGet 包 `Microsoft.Extensions.Caching.StackExchangeRedis`。
- en: 'Configure caching by adding the following code snippet to `Program.cs`:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过将以下代码片段添加到 `Program.cs` 来配置缓存：
- en: '[PRE68]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE68]'
- en: 'From a configuration standpoint, two properties are added to `appsettings.json`,
    as shown here:'
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从配置的角度来看，向 `appsettings.json` 中添加了两个属性，如下所示：
- en: '[PRE69]'
  id: totrans-304
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE69]'
- en: 'Any class that wants to cache data needs to add a reference to the `Packt.Ecommerce.Caching`
    project and inject `IDistributedCacheService`, and can call the aforementioned
    methods to read/update/insert data in the cache store. The following is a code
    snippet of a method using the cache service:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 任何想要缓存数据的类都需要添加对 `Packt.Ecommerce.Caching` 项目的引用，并注入 `IDistributedCacheService`，然后可以调用上述方法来读取/更新/插入缓存存储中的数据。以下是一个使用缓存服务的代码片段：
- en: '[PRE70]'
  id: totrans-306
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-308
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-311
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-317
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-319
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-321
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-323
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-324
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: '[PRE89]'
  id: totrans-325
  prefs: []
  type: TYPE_PRE
  zh: '[PRE89]'
- en: '[PRE90]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-327
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: '[PRE92]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE92]'
- en: Here, we are using the cache-aside pattern and checking for the `Country` key
    in the cache store first. If found, return it from the function, otherwise retrieve
    it from the database and insert it into the cache, and then return from the function.
    We will heavily use the cache service in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040),
    *Creating an ASP.NET Core 6 Web API*.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用缓存旁路模式，首先检查缓存存储中的 `Country` 键。如果找到，则从函数中返回它，否则从数据库中检索它并将其插入缓存，然后从函数中返回。我们将在
    [*第 10 章*](B18507_10_Epub.xhtml#_idTextAnchor1040)，*创建 ASP.NET Core 6 Web API*
    中大量使用缓存服务。
- en: As you can see, we have used a few of the patterns that we discussed in earlier
    sections. There are also a few additional considerations discussed in the next
    section, which need to be kept in mind while designing the cache layer in an enterprise
    application.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所看到的，我们已经使用了之前章节中讨论的一些模式。在下一节中还将讨论一些额外的考虑因素，这些因素在设计企业应用中的缓存层时需要牢记。
- en: Caching considerations
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 缓存考虑因素
- en: 'Having a cache layer is critical for improving performance and scalability
    in enterprise applications. Hence, the following are a few factors that need to
    be considered while developing the caching layer:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 在企业应用中，拥有一个缓存层对于提高性能和可扩展性至关重要。因此，在开发缓存层时需要考虑以下因素：
- en: If we are building a new application, then Azure Cache for Redis can be the
    starting point using the `IDistributedCache` implementation as it can easily be
    plumbed into the application with a few lines of code. However, this comes at
    a cost that needs to be evaluated.
  id: totrans-333
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们正在构建一个新的应用程序，那么可以使用`IDistributedCache`实现作为起点，使用Azure Cache for Redis，因为它可以很容易地通过几行代码集成到应用程序中。然而，这需要评估相应的成本。
- en: For an existing project, the current infrastructure plays a critical role and
    SQL can be the default choice if SQL Server is already being used as a data store.
    However, it's good to benchmark the performance of SQL against Redis, and a decision
    can be taken accordingly.
  id: totrans-334
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于一个现有的项目，当前的基础设施起着至关重要的作用，如果已经使用SQL Server作为数据存储，那么SQL可以成为默认的选择。然而，对SQL与Redis的性能进行基准测试是个好主意，并据此做出相应的决策。
- en: Having a wrapper class on the underlying cache store is a good approach as it
    decouples the application from the cache store and makes the code more flexible
    and easily maintained in case of future changes in the cache store.
  id: totrans-335
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在底层缓存存储上有一个包装类是一个好的方法，因为它将应用程序与缓存存储解耦，并使得代码在缓存存储未来发生变化时更加灵活且易于维护。
- en: The methods of `IMemoryCache` and `IDistributedCache` are not thread-safe. For
    example, say a thread queries a key from the cache and finds it isn't there in
    the cache, and falls back to the original data store. While data is retrieved
    from the original store if another thread queries the same key, it won't wait
    for the first thread to finish reading from the database. The second thread will
    also end up falling back to the database. So, thread safety needs to be handled
    explicitly, possibly in the wrapper class.
  id: totrans-336
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IMemoryCache`和`IDistributedCache`的方法不是线程安全的。例如，假设一个线程从缓存中查询一个键，发现它不在缓存中，然后回退到原始数据存储。当从原始存储检索数据时，如果另一个线程查询相同的键，它不会等待第一个线程完成从数据库的读取。第二个线程也将回退到数据库。因此，需要显式处理线程安全性，可能是在包装类中。'
- en: Response caching should be implemented along with application caching for even
    more optimization.
  id: totrans-337
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除了应用缓存之外，还应实现响应缓存以实现进一步的优化。
- en: '`If-None-Match` request header and if there is a match, the server returns
    `304` (no change) and the client can reuse the cached version of the data. For
    ETag, there is no built-in implementation on the server side, so a filter or middleware
    can be used to implement server-side logic.'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`If-None-Match`请求头，如果匹配，服务器返回`304`（无变化），客户端可以重用数据的缓存版本。对于ETag，服务器端没有内置的实现，因此可以使用过滤器或中间件来实现服务器端逻辑。'
- en: Although we used JSON serialization in our implementation, there are other formats,
    such as BSON or protocol buffers, that should be evaluated for serialization and
    deserialization.
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尽管我们在实现中使用了JSON序列化，但还有其他格式，如BSON或协议缓冲区，应该评估用于序列化和反序列化。
- en: Just like any other component in application development for caching, there
    is no one-size-fits-all solution. So, the preceding points should be evaluated
    and an appropriate caching solution implemented accordingly.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 正如任何其他用于缓存的开发中的应用组件一样，没有一种适合所有情况的解决方案。因此，应该评估前面提到的点，并相应地实施适当的缓存解决方案。
- en: Summary
  id: totrans-341
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned about various caching techniques, patterns, and
    their benefits in improving application performance. Furthermore, we learned about
    HTTP caching, how response caching can be integrated into an API response, and
    further various available caching providers and their integration with .NET 6
    applications. We also learned how to implement distributed caching using `IDistributedCache`
    and built a cache abstraction layer that will be used in subsequent chapters for
    caching requirements. Some of the key information and skills that we learned about
    along the way were why and when caching is needed and how to implement caching
    in .NET 6 applications.
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了各种缓存技术、模式和它们在提高应用程序性能方面的好处。此外，我们还学习了HTTP缓存，如何将响应缓存集成到API响应中，以及各种可用的缓存提供者和它们与.NET
    6应用程序的集成。我们还学习了如何使用`IDistributedCache`实现分布式缓存，并构建了一个缓存抽象层，该层将在后续章节中用于缓存需求。我们在学习过程中了解的一些关键信息和技能包括为什么和何时需要缓存，以及如何在.NET
    6应用程序中实现缓存。
- en: In the next chapter, we will look at various data stores and providers in .NET
    6 and their integration with .NET 6 applications.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨.NET 6中的各种数据存储和提供者及其与.NET 6应用程序的集成。
- en: Questions
  id: totrans-344
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Which of the following values for the `Cache-Control` header allows the response
    to be stored in any server (client/server/proxy)?
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个`Cache-Control`头部的值允许响应存储在任何服务器（客户端/服务器/代理）中？
- en: a. `Private`
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: a. `私有`
- en: b. `Public`
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: b. `公共`
- en: c. `No-cache`
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: c. `No-cache`
- en: '**Answer: b**'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
- en: In a multiple-application server scenario, which of the following caching platforms
    should we choose?
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在多应用服务器场景中，我们应该选择以下哪个缓存平台？
- en: a. Distributed caching
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: a. 分布式缓存
- en: b. In-memory caching
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: b. 内存缓存
- en: '**Answer: a**'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：a**'
- en: 'True or false: In the cache-aside pattern, data is first updated in the cache
    store and then in the underlying data store.'
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 判断对错：在缓存旁路模式中，数据首先更新在缓存存储中，然后是在底层数据存储中。
- en: a. True
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: a. 正确
- en: b. False
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: b. 错误
- en: '**Answer: b**'
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：b**'
- en: Which of the following caches is best suited to store static files and image
    files and supports geo-replication?
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下哪个缓存最适合存储静态文件和图像文件并支持地理复制？
- en: a. Web server caching
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: a. 网络服务器缓存
- en: b. Application caching
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: b. 应用程序缓存
- en: c. Content Delivery Network (CDN)
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: c. 内容分发网络（CDN）
- en: '**Answer: c**'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '**答案：c**'
- en: Further reading
  id: totrans-363
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'You can read more about caching here:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在此处了解更多有关缓存的信息：
- en: '[https://github.com/Alachisoft/NCache](https://github.com/Alachisoft/NCache)'
  id: totrans-365
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/Alachisoft/NCache](https://github.com/Alachisoft/NCache)'
- en: '[https://redis.io/](https://redis.io/)'
  id: totrans-366
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://redis.io/](https://redis.io/)'
- en: '[https://aws.amazon.com/redis/](https://aws.amazon.com/redis/)'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://aws.amazon.com/redis/](https://aws.amazon.com/redis/)'
- en: '[https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-configure#redis-console](https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-configure#redis-console)'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-configure#redis-console](https://docs.microsoft.com/en-us/azure/azure-cache-for-redis/cache-configure#redis-console)'
- en: Features (terracotta.org)
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 功能（terracotta.org）
