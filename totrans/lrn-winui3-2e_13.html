<html><head></head><body>
		<div><h1 id="_idParaDest-255" class="chapter-number"><a id="_idTextAnchor570"/>13</h1>
			<h1 id="_idParaDest-256"><a id="_idTextAnchor571"/>Take Your App Cross-Platform with Uno Platform</h1>
			<p><strong class="bold">Uno Platform</strong> allows<a id="_idIndexMarker947"/> developers to write XAML markup and C# code in a single code base and deploy the application to multiple platforms. Uno currently supports iOS, Android, Windows, macOS, Linux, Tizen, and the web (with <strong class="bold">WebAssembly</strong>). Uno <a id="_idIndexMarker948"/>Platform uses the same XAML syntax as WinUI, allowing WinUI developers to easily make the jump to Uno while reusing much of their existing XAML and C# code. We will look at how <a id="_idIndexMarker949"/>the <strong class="bold">My Media Collection</strong> sample app can be adapted to run on some of these other platforms with Uno Platform.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>The history of Uno Platform and discuss its current capabilities</li>
				<li>How to configure Visual Studio to create Uno Platform projects</li>
				<li>Adapting existing WinUI views and ViewModels for reuse in Uno projects</li>
				<li>Running and debugging an Uno Platform application on Android using the <strong class="bold">Windows Subsystem for </strong><strong class="bold">Android</strong> (<strong class="bold">WSA</strong>)</li>
				<li>Running your application in the browser natively with WebAssembly</li>
			</ul>
			<p>By the end of this chapter, you will understand how to take a WinUI application built with the Windows App SDK and port it to multiple platforms outside the Windows ecosystem with Uno Platform.</p>
			<h1 id="_idParaDest-257"><a id="_idTextAnchor572"/>Technical requirements</h1>
			<p>To follow along with the examples in this chapter, the following software is required:</p>
			<ul>
				<li>Windows 11 version 22000.0 or later with WSA installed from the Microsoft Store. To use WSA, 16 GB of RAM is recommended.</li>
				<li>Visual Studio 2022 or later with the <strong class="bold">.NET Desktop Development</strong> workload configured for Windows App SDK development.</li>
				<li>If you want to build and run an iOS or macOS version of the sample application, you will need a Mac running macOS 12.5 or later with Xcode 14 or later installed from the App Store.</li>
				<li>To target Android devices, you can install the <strong class="bold">.NET Multi-platform App UI development</strong> workload in the Visual Studio Installer. This will install a supported version of the <strong class="bold">Android SDK</strong>.</li>
			</ul>
			<h1 id="_idParaDest-258"><a id="_idTextAnchor573"/>An overview of Uno Platform</h1>
			<p>Uno Platform<a id="_idIndexMarker950"/> is an open source UI framework that installs as an extension to Visual Studio. It is cross-platform, with the ability to target Windows, iOS, Android, macOS, Linux, and WebAssembly. With a single C# and WinUI XAML code base, you can target all of these platforms. While the Uno Platform team recommends Visual Studio for the <a id="_idIndexMarker951"/>best experience, you can build Uno applications with Visual Studio Code or the <strong class="bold">JetBrains Rider</strong> IDE. The pros and cons of each development environment are discussed on Uno Platform’s <strong class="bold">Get Started</strong> documentation: <a href="https://platform.uno/docs/articles/get-started.html?tabs=windows#select-your-development-environment">https://platform.uno/docs/articles/get-started.html?tabs=windows#select-your-development-environment</a>.</p>
			<p>Uno Platform was first released in May 2018 and has been growing in popularity in recent years. They have also added to their supported platforms and shifted from UWP to WinUI 3 in their XAML support. This year, in their 4.10.13 release, they even added support for embedding <strong class="bold">.NET MAUI</strong> controls <a id="_idIndexMarker952"/>within Uno Platform apps, with support for an extensive number of third-party controls. We won’t be covering .NET MAUI embedding in this chapter, but you can explore this exciting feature in their documentation: <a href="https://platform.uno/docs/articles/external/uno.extensions/doc/Overview/Maui/MauiOverview.html">https://platform.uno/docs/articles/external/uno.extensions/doc/Overview/Maui/MauiOverview.html</a>.</p>
			<p>Speaking of .NET MAUI, you are probably wondering why a developer may choose Uno Platform over Microsoft’s cross-platform successor<a id="_idIndexMarker953"/> to <strong class="bold">Xamarin.Forms</strong>. One reason why WinUI developers would choose Uno Platform is <em class="italic">familiarity</em>. Uno apps are created with WinUI XAML, so there is no learning curve. The .NET MAUI XAML<a id="_idIndexMarker954"/> is slightly different than WinUI. If targeting Linux and web browsers is important to you, .NET MAUI applications cannot currently target either of these platforms, whereas Uno Platform can. If you or the designers in your company use <strong class="bold">Figma</strong> to <a id="_idIndexMarker955"/>create user interfaces, you’ll find the Uno Platform Figma plugin will give your team a great head-start when building your next application.</p>
			<p>Uno Platform<a id="_idIndexMarker956"/> is open source. On their GitHub repository (<a href="https://github.com/unoplatform/uno">https://github.com/unoplatform/uno</a>), you can track open issues, submit pull requests to improve the framework, or get insights into their latest releases. If you want to try Uno Platform before getting it installed and building your first app, you can open their interactive <strong class="bold">Uno Playground</strong> in <a id="_idIndexMarker957"/>your browser at <a href="https://playground.platform.uno/#wasm-start:">https://playground.platform.uno/#wasm-start:</a></p>
			<div><div><img src="img/B20908_13_01.jpg" alt="Figure 13.1 – Exploring the Uno Playground in a web browser"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Exploring the Uno Playground in a web browser</p>
			<p>The <a id="_idIndexMarker958"/>Uno Playground sample app runs interactively in the browser with WebAssembly. You can make changes to the XAML in the left panel and watch it update the preview on the right in real time.</p>
			<p>The other browser-based resource you can explore is<a id="_idIndexMarker959"/> the <strong class="bold">Uno Gallery</strong> (<a href="https://gallery.platform.uno/">https://gallery.platform.uno/</a>). In the<a id="_idIndexMarker960"/> Uno Gallery, you can explore controls, theming capabilities, and other UI and non-UI features of Uno Platform. For example, on the gallery’s page for the <strong class="bold">Button</strong> control, you can see how the control will be rendered in <a id="_idIndexMarker961"/>different styles – <strong class="bold">Material</strong>, <strong class="bold">Fluent</strong>, or <strong class="bold">Cupertino</strong> designs:</p>
			<div><div><img src="img/B20908_13_02.jpg" alt="Figure 13.2 – Exploring the Button control in the Uno Gallery"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – Exploring the Button control in the Uno Gallery</p>
			<p>Spend some time reviewing these online resources before we continue to create our first project with Uno Platform.</p>
			<h1 id="_idParaDest-259"><a id="_idTextAnchor574"/>Creating your first Uno Platform project</h1>
			<p>In this section, we are<a id="_idIndexMarker962"/> going to create a new Uno Platform project that will be the basis of our cross-platform version of the <em class="italic">My Media Collection</em> application that we created in several of the earlier chapters of this book. Before we can create a new Uno Platform project, we need to install the extension:</p>
			<ol>
				<li>Start by opening Visual Studio and go to <strong class="bold">Extensions</strong> | <strong class="bold">Manage Extensions</strong> to open the <strong class="bold">Manage </strong><strong class="bold">Extensions</strong> window.</li>
				<li>In the <code>Uno Platform</code>.</li>
				<li>The <strong class="bold">Uno Platform</strong> extension should be the first result. Click <strong class="bold">Install</strong> and restart Visual Studio to complete the installation.</li>
				<li>When you open Visual Studio again, select <strong class="bold">Create a </strong><strong class="bold">new project</strong>.</li>
				<li>In the <code>Uno Platform</code>. You will get several results for the different Uno Platform project types.</li>
				<li>Select the <strong class="bold">Uno Platform App</strong> template and click <strong class="bold">Next</strong>.</li>
				<li>Name the<a id="_idIndexMarker963"/> project <code>UnoMediaCollection</code> and select <strong class="bold">Create</strong>. This will launch <strong class="bold">Uno Platform </strong><strong class="bold">Template Wizard</strong>:</li>
			</ol>
			<div><div><img src="img/B20908_13_03.jpg" alt="Figure 13.3 – Uno Platform Template Wizard"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Uno Platform Template Wizard</p>
			<ol>
				<li value="8">On<a id="_idIndexMarker964"/> the <strong class="bold">Select startup type</strong> page, select the <strong class="bold">Customize</strong> button on the <strong class="bold">Default</strong> type.<p class="list-inset">This will open the detailed steps of the wizard. From here, you can configure all of the available Uno Platform options. We will leave most of these as default, but let’s step through each page.</p></li>
				<li>On the <strong class="bold">Framework</strong> page, the default is currently <strong class="bold">.NET 7.0</strong>, but it may be <strong class="bold">.NET 8.0</strong> when you are reading this book. You can leave the default selection.</li>
				<li>On the <strong class="bold">Platforms</strong> page, we are going to only work with <strong class="bold">Windows</strong>, <strong class="bold">Android</strong>, and <strong class="bold">WebAssembly</strong>. You can unselect the other platforms.</li>
				<li>On the <code>MyMediaCollection</code> application.</li>
				<li>On the <strong class="bold">Theme</strong> page, select <strong class="bold">Fluent</strong> to use the same Fluent design of the original application.</li>
				<li>On the <strong class="bold">Extensions</strong> page, you can remove <strong class="bold">Localization</strong> and change <strong class="bold">Navigation</strong> to <strong class="bold">Blank</strong>.</li>
				<li>You can uncheck the <strong class="bold">Unit Tests</strong> and <strong class="bold">UI Tests</strong> options on the <strong class="bold">Testing</strong> page. We won’t get into testing in this chapter.</li>
				<li>You can leave the default settings on the <strong class="bold">Projects</strong>, <strong class="bold">Features</strong>, <strong class="bold">Authentication</strong>, and <strong class="bold">Application</strong> pages. To learn more about these options, you can review the Uno Platform documentation: <a href="https://platform.uno/docs/articles/get-started-vs-2022.html#create-an-application">https://platform.uno/docs/articles/get-started-vs-2022.html#create-an-application</a>.</li>
				<li>Click <strong class="bold">Create</strong> to generate the projects and start working with them in Visual Studio. If Visual Studio prompts you to reload any projects, click <strong class="bold">Reload</strong>.</li>
				<li>Follow the <strong class="bold">Verify your developer environment</strong> steps on the Uno welcome screen in Visual Studio:</li>
			</ol>
			<div><div><img src="img/B20908_13_04.jpg" alt="Figure 13.4 – Uno Platform welcome screen"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Uno Platform welcome screen</p>
			<p class="list-inset">The <code>uno-check</code> command-line utility does a great job of diagnosing potential development environment issues and automatically fixing them. You should allow it to fix any issues it identifies before continuing. You may need to reboot your system after it’s done. Do this and open the project again before continuing to the next step.</p>
			<ol>
				<li value="18">Make<a id="_idIndexMarker965"/> sure the <code>UnoMediaCollection.Windows</code> project is set as the startup project and start debugging. The app should launch and display a window containing a <strong class="bold">Hello Uno </strong><strong class="bold">Platform</strong> message:</li>
			</ol>
			<div><div><img src="img/B20908_13_05.jpg" alt="Figure 13.5 – Running UnoMediaCollection as a Windows app"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Running UnoMediaCollection as a Windows app</p>
			<p>That’s it! We’ve<a id="_idIndexMarker966"/> got a running app to use as our starting point. In the next section, we will learn more about the structure of the projects as we reuse code from the <code>MyMediaCollection</code> project to enhance <code>UnoMediaCollection</code>.</p>
			<h1 id="_idParaDest-260"><a id="_idTextAnchor575"/>Migrating WinUI XAML markup and code to Uno Platform</h1>
			<p>In this section, we are<a id="_idIndexMarker967"/> going to take the <code>UnoMediaCollection</code> solution that we created in the previous section and migrate<a id="_idIndexMarker968"/> the code from an earlier version of <code>MyMediaCollection</code>. This will give us a cross-platform version of the application that we will run on Windows, Android, and WebAssembly in the sections ahead.</p>
			<p>In order to keep things simple for our first project, we are going to migrate the code from the completed <code>MyMediaCollection</code> solution found in the completed code for <a href="B20908_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a>, <em class="italic">Exploring WinUI Controls</em>. If you don’t have a copy of that code, you can get it from GitHub here: <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter05/Complete">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/main/Chapter05/Complete</a>. The easiest way to follow along with the instructions is to download the solution, but you can also create each class in the Uno Project solution and copy and paste the WinUI project code from the GitHub editor.</p>
			<p>We are going to use the code from <a href="B20908_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a> because the SQLite database hasn’t been added yet at this point. Adding code with file access to a Uno Platform project is possible but more complicated. It requires writing <a id="_idIndexMarker969"/>some <strong class="bold">platform-specific code</strong>. This code will be conditionally executed, depending on the platform where the application is currently running. Using SQLite on most platforms is relatively straightforward, but local file access on WebAssembly is not as easy. You can read more about platform-specific code on Uno Platform in their documentation: <a href="https://platform.uno/docs/articles/platform-specific-csharp.html">https://platform.uno/docs/articles/platform-specific-csharp.html</a>.</p>
			<p>If <a id="_idIndexMarker970"/>working offline is not a<a id="_idIndexMarker971"/> concern, the best option for data access across all these platforms is to create a lightweight web service to handle your data access. Doing this also means adding an identity solution to ensure each user is accessing their own data. Uno Platform has some documentation on consuming a web API, if you’re interested in pursuing this option on your own: <a href="https://platform.uno/docs/articles/howto-consume-webservices.html">https://platform.uno/docs/articles/howto-consume-webservices.html</a>.</p>
			<p>Now, let’s start our WinUI project migration to Uno Platform.</p>
			<h2 id="_idParaDest-261"><a id="_idTextAnchor576"/>Migrating the WinUI project code</h2>
			<p>It’s time to get<a id="_idIndexMarker972"/> started with our cross-platform transformation of <code>MyMediaCollection</code>. We’ll start by importing the C# classes from the old project:</p>
			<ol>
				<li>Start by opening the <code>UnoMediaCollection</code> solution from the previous section and create four new folders in the <code>UnoMediaCollection</code> project: <code>Enums</code>, <code>Interfaces</code>, <code>Model</code>, and <code>ViewModels</code>. We’ll also be adding classes from the <code>Services</code> folder, but that folder already exists in the new project:</li>
			</ol>
			<div><div><img src="img/B20908_13_06.jpg" alt="Figure 13.6 – The new folders added to the UnoMediaCollection project"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – The new folders added to the UnoMediaCollection project</p>
			<ol>
				<li value="2">Right-click<a id="_idIndexMarker973"/> the <code>Enums</code> folder and select <code>Enums</code> folder in the WinUI <code>MyMediaCollection</code> project, select the <code>ItemType.cs</code> and <code>LocationType.cs</code> files, and click <strong class="bold">Add</strong>.</li>
				<li>Open each newly added file and change the <code>namespace</code> to <code>UnoMediaCollection.Enums</code>.</li>
				<li>We’re going to repeat these steps for each of the remaining folders. Next, add the existing <code>IDataService.cs</code> and <code>INavigationService.cs</code> files to the <code>Interfaces</code> folder.</li>
				<li>In <code>IDataService</code>, change the <code>namespace</code> to <code>UnoMediaCollection.Interfaces</code> and update the <code>using</code> statements to the following:<pre class="source-code">
using UnoMediaCollection.Enums;
using UnoMediaCollection.Model;</pre><p class="list-inset">You can <a id="_idIndexMarker974"/>remove any other <code>using</code> statements, as they’re part of <a id="_idIndexMarker975"/>the <code>INavigationService</code>, you can update the <code>namespace</code> to <code>UnoMediaCollection.Interfaces</code> and remove the <code>using </code><code>System;</code> statement.</li>
				<li>Add the existing <code>MediaItem.cs</code> and <code>Medium.cs</code> files to the <code>Model</code> folder.</li>
				<li>Modify <code>MediaItem</code> to look like this (changes highlighted):<pre class="source-code">
using <strong class="bold">UnoMediaCollection.Enums;</strong>
namespace <strong class="bold">UnoMediaCollection.Model</strong>
{
    public class MediaItem
    {
        public int Id { get; set; }
        public <strong class="bold">string?</strong> Name { get; set; }
        public ItemType MediaType { get; set; }
        public <strong class="bold">Medium?</strong> MediumInfo { get; set; }
        public LocationType Location { get; set; }
    }
}</pre></li>				<li>Modify the <code>Medium</code> class to look like this:<pre class="source-code">
using <strong class="bold">UnoMediaCollection.Enums;</strong>
namespace <strong class="bold">UnoMediaCollection.Model</strong>
{
    public class Medium
    {
        public int Id { get; set;  }
        public <strong class="bold">string?</strong> Name { get; set; }
        public ItemType MediaType { get; set; }
    }
}</pre></li>				<li>Add the existing <code>DataService.cs</code> and <code>NavigationService.cs</code> files to the <code>Services</code> folder.</li>
				<li>In <code>DataService</code>, update the <code>namespace</code> to <code>UnoMediaCollection.Services</code> and update your <code>using</code> statements to only <a id="_idIndexMarker976"/>contain these three statements:<pre class="source-code">
using UnoMediaCollection.Enums;
using UnoMediaCollection.Interfaces;
using UnoMediaCollection.Model;</pre></li>				<li>In <code>NavigationService</code>, update the <code>namespace</code> to <code>UnoMediaCollection.Services</code> and change the accessor of the <code>AppFrame</code> variable from <code>private static</code> to <code>internal static</code>. We’ll need to set this value from <code>App.cs</code> later. Also, update the <code>using</code> statements to contain only these two statements:<pre class="source-code">
using UnoMediaCollection.Interfaces;
using System.Collections.Concurrent;</pre></li>				<li>Add the <a id="_idIndexMarker977"/>existing <code>ItemDetailsViewModel.cs</code> and <code>MainViewModel.cs</code> files to the <code>ViewModels</code> folder.</li>
				<li>In <code>ItemDetailsViewModel</code>, change the <code>namespace</code> to <code>UnoMediaCollection.ViewModels</code> and modify the <code>using</code> statements to contain these four statements:<pre class="source-code">
using UnoMediaCollection.Enums;
using UnoMediaCollection.Interfaces;
using UnoMediaCollection.Model;
using System.Collections.ObjectModel;</pre></li>				<li>In <code>MainViewModel</code>, change the <code>namespace</code> to <code>UnoMediaCollection.ViewModels</code> and update the <code>using</code> statements to contain only these four statements:<pre class="source-code">
using Microsoft.UI.Xaml.Input;
using UnoMediaCollection.Interfaces;
using UnoMediaCollection.Model;
using System.Collections.ObjectModel;</pre><p class="list-inset">All the changes so far are relatively simple. The Uno Platform project already uses the NuGet packages that we referenced in the WinUI project, so the code is very compatible.</p></li>				<li>Before we move on to the two views, let’s make the necessary changes to <code>App.cs</code>. We need to set up <code>NavigationService</code> and register our services and ViewModel classes with the IoC container. First, add these three <code>using</code> statements to the <code>App</code> class:<pre class="source-code">
using UnoMediaCollection.Interfaces;
using UnoMediaCollection.Services;
using UnoMediaCollection.ViewModels;</pre></li>				<li>Rename <a id="_idIndexMarker978"/>the <code>Host</code> variable to <code>HostContainer</code> to match the name from our WinUI project and make it <code>internal static</code>:<pre class="source-code">
internal static IHost? HostContainer { get; private set; }</pre></li>				<li>Add the following code to the beginning of the <code>OnLaunched</code> method, right before the <code>builder</code> object is created:<pre class="source-code">
var navigationService = new NavigationService(<strong class="bold">new Frame()</strong>);
navigationService.Configure(nameof(MainPage), typeof(MainPage));
navigationService.Configure(nameof(ItemDetailsPage), typeof(ItemDetailsPage));</pre><p class="list-inset">This creates the <code>navigationService</code> class, which will later be registered in the IoC container and registers the two views for navigation. I’ve highlighted the one difference from the code in the original WinUI project. We’re temporarily passing <code>new Frame()</code> into the constructor. Later in the method, we’ll set <code>AppFrame</code> to the <code>rootFrame</code> created toward the end of the <code>OnLaunched</code> method.</p></li>				<li>Next, update the <code>ConfigureServices</code> block in <code>OnLaunched</code> to look like this:<pre class="source-code">
.ConfigureServices((context, services) =&gt;
{
    services.AddSingleton&lt;INavigationService&gt;(navigationService);
    services.AddSingleton&lt;IDataService, DataService&gt;();
    services.AddTransient&lt;MainViewModel&gt;();
    services.AddTransient&lt;ItemDetailsViewModel&gt;();
})</pre><p class="list-inset">This registers our classes with the IoC container just like we did in our WinUI project.</p></li>				<li>Update the <code>Host = builder.Build();</code> line of code in <code>OnLaunched</code> to <code>HostContainer = </code><code>builder.Build();</code>.</li>
				<li>Finally, immediately before the <code>MainWindow.Activate();</code> call at the end of <code>OnLaunched</code>, add this line of<a id="_idIndexMarker979"/> code to update the <code>AppFrame</code> static variable in <code>NavigationService</code>:<pre class="source-code">
NavigationService.AppFrame = rootFrame;</pre></li>			</ol>
			<p>That’s everything we need to add and update except for the two views. The code won’t compile successfully yet because we referenced <code>ItemsDetailsPage</code> in <code>OnLaunched</code> but haven’t added it yet. We’ll take care of that in the next section.</p>
			<h2 id="_idParaDest-262"><a id="_idTextAnchor577"/>Migrating the WinUI XAML views</h2>
			<p>In this section, we’ll finish the<a id="_idIndexMarker980"/> additions and changes to the <code>UnoMediaCollection</code> project and run the Windows version of the application. Let’s start with <code>ItemDetailsView</code>:</p>
			<ol>
				<li>Right-click the <code>UnoMediaCollection</code> project and select <strong class="bold">Add</strong> | <strong class="bold">New Item</strong>.</li>
				<li>In the <code>ItemDetailsPage.xaml</code>, and click <strong class="bold">Add</strong>:</li>
			</ol>
			<div><div><img src="img/B20908_13_07.jpg" alt="Figure 13.7 – Adding the ItemDetailsPage to the project"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – Adding the ItemDetailsPage to the project</p>
			<ol>
				<li value="3">Open <code>ItemDetailsPage.xaml.cs</code> and replace the contents of the class with the following code from the <a id="_idIndexMarker981"/>WinUI project:<pre class="source-code">
public ItemDetailsPage()
{
    ViewModel = App.HostContainer.Services.GetService&lt;ItemDetailsViewModel&gt;();
    this.InitializeComponent();
}
public ItemDetailsViewModel ViewModel;
protected override void OnNavigatedTo(NavigationEventArgs e)
{
    base.OnNavigatedTo(e);
    var itemId = (int)e.Parameter;
    if (itemId &gt; 0)
    {
        ViewModel.InitializeItemDetailData(itemId);
    }
}</pre><p class="list-inset">Note that <a id="_idIndexMarker982"/>we’re not migrating any of the user settings code following the <code>InitializeComponent</code> call in the constructor. We’ll keep things simple for our first migration attempt.</p></li>				<li>You can also remove all <code>using</code> statements from the <code>ItemDetailsPage</code> class except for the following:<pre class="source-code">
using UnoMediaCollection.ViewModels;</pre></li>				<li>Open <code>ItemDetailsPage.xaml</code> and replace the child contents of the <code>Page</code> with the contents of the <code>Page</code> from the <code>ItemDetailsPage.xaml</code> in the WinUI project. Do not replace the <code>Page</code> itself because the namespaces differ.</li>
				<li>Remove this <code>SplitButton.Resources</code> block because we won’t be using <code>TeachingTip</code>. We removed the code behind that relies on saving user preferences to the filesystem. Without that, it would appear every time the page opens:<pre class="source-code">
&lt;SplitButton.Resources&gt;
    &lt;TeachingTip x:Name="SavingTip"
                    Target="{x:Bind SaveButton}"
                    Title="Save and create new"
                    Subtitle="Use the dropdown button option to save your item and create another."&gt;
    &lt;/TeachingTip&gt;
&lt;/SplitButton.Resources&gt;</pre></li>				<li>Open <code>MainPage.xaml.cs</code> and add the<a id="_idIndexMarker983"/> following <code>using</code> statement:<pre class="source-code">
using UnoMediaCollection.ViewModels;</pre></li>				<li>The contents of the <code>MainPage</code> class will be similar to <code>ItemDetailsPage</code>:<pre class="source-code">
public MainPage()
{
    ViewModel = App.HostContainer.Services.GetService&lt;MainViewModel&gt;();
    this.InitializeComponent();
}
public MainViewModel ViewModel;
protected override void OnNavigatedTo(NavigationEventArgs e)
{
    base.OnNavigatedTo(e);
    if (e.NavigationMode == NavigationMode.Back)
    {
        ViewModel.PopulateData();
    }
}</pre><p class="list-inset">This is <a id="_idIndexMarker984"/>slightly different than the implementation of <code>MainPage</code> in the WinUI project. We added an override of <code>OnNavigatedTo</code>. On some platforms, the list of items on <code>MainPage</code> was not updating after adding an item on <code>ItemDetailsPage</code>. Calling <code>PopulateData()</code> on <code>MainViewModel</code> when the user is navigating <code>Back</code> solved the behavior. This was an issue on both Android and WebAssembly. The Windows project worked as expected.</p></li>				<li>Open <code>MainPage.xaml</code> and replace the entire child contents of the <code>Page</code> from the <code>Page</code> in <code>MainPage.xaml</code>. Like we did in <code>ItemDetailsPage.xaml</code>, be careful not to replace the <code>Page</code> itself due to namespace differences.</li>
				<li>Finally, add the following <code>using</code> declaration to the <code>Page</code> element in <code>MainPage</code>:<pre class="source-code">
xmlns:model="using:UnoMediaCollection.Model"</pre><p class="list-inset">The <code>MediaItem</code> model class is referenced by <code>DataTemplate</code> in our <code>ListView</code> and requires this <code>using</code> declaration.</p></li>			</ol>
			<p>Those are all the <a id="_idIndexMarker985"/>changes needed to get the application ready to run with Uno Platform. We didn’t have to change our XAML controls at all, outside of removing <code>TeachingTip</code>.</p>
			<p>Let’s run the Windows version of the application to make sure everything works as expected. Make sure <code>UnoMediaCollection.Windows</code> is set as the startup project and run the application. It should look something like this when it launches:</p>
			<div><div><img src="img/B20908_13_08.jpg" alt="Figure 13.8 – Running the Windows project with Uno Platform"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.8 – Running the Windows project with Uno Platform</p>
			<p>It looks exactly like the <a href="B20908_05.xhtml#_idTextAnchor114"><em class="italic">Chapter 5</em></a> version of our WinUI application. If you try adding, editing, or removing items, everything should work as expected. Great work! That was pretty simple. Let’s move on and try using the application on Android with WSA.</p>
			<h1 id="_idParaDest-263"><a id="_idTextAnchor578"/>Running on Android with WSA</h1>
			<p>Running and debugging<a id="_idIndexMarker986"/> Android applications on Windows is fast and easy with WSA. The easiest way to install WSA on Windows 11 is to <a id="_idIndexMarker987"/>install <strong class="bold">Amazon Appstore</strong> from the Microsoft Store. You can get the app here: <a href="https://aka.ms/AmazonAppstore">https://aka.ms/AmazonAppstore</a>.</p>
			<div><div><img src="img/B20908_13_09.jpg" alt="Figure 13.9 – The Amazon Appstore app in the Microsoft Store"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.9 – The Amazon Appstore app in the Microsoft Store</p>
			<p>Install the<a id="_idIndexMarker988"/> app and follow the prompts to install WSA as part of the process. When it has finished with the initial installation, you will need to restart your computer to complete the WSA installation and configuration:</p>
			<div><div><img src="img/B20908_13_10.jpg" alt="Figure 13.10 – Completing the Amazon Appstore installation"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.10 – Completing the Amazon Appstore installation</p>
			<p>After the<a id="_idIndexMarker989"/> reboot is complete, find the Amazon Appstore app in your Windows Start menu and launch it. You will see WSA start up first:</p>
			<div><div><img src="img/B20908_13_11.jpg" alt="Figure 13.11 – Starting the WSA process"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.11 – Starting the WSA process</p>
			<p>Keep <a id="_idIndexMarker990"/>Amazon Appstore running in the background to ensure your Android system remains active. You can minimize the window if you like. The other thing you will have to do to use WSA from Visual Studio is to ensure <strong class="bold">Developer mode</strong> is turned on. Launch <strong class="bold">Windows Subsytem for Android</strong> from the Start menu. This will open the WSA <strong class="bold">System</strong> settings page. Select <strong class="bold">Advanced settings</strong> from the left navigation panel to open the <strong class="bold">Advanced </strong><strong class="bold">settings</strong> page:</p>
			<div><div><img src="img/B20908_13_12.jpg" alt="Figure 13.12 – The WSA System settings"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.12 – The WSA System settings</p>
			<p>If <strong class="bold">Developer mode</strong> isn’t turned on, turn it on now. The last preparation step is to connect the <strong class="bold">Android SDK</strong> to the <a id="_idIndexMarker991"/>WSA for our debugging session. To do this, you’ll need to find where your Android SDK is installed. It should be at this path if it was installed with your Visual Studio installation:</p>
			<pre class="console">
c:\Program Files (x86)\Android\android-sdk\</pre>			<p>You will need to run the following command from a command prompt. Open a terminal or command window in the <code>platform-tools</code> subfolder of your SDK location. This is the command if you are running within <strong class="bold">PowerShell</strong>. I am using <strong class="bold">Windows Terminal</strong> with a PowerShell window:</p>
			<pre class="console">
.\adb connect 127.0.0.1:58526</pre>			<p>If you get the <code>failed to authenticate to 127.0.0.1:58526</code> message, check whether there is a WSA pop-up dialog behind your other windows. Click the <code>adb connect</code> command each time you start debugging with WSA.</p>
			<p>It’s time to run the Android version of our application with WSA. Update the startup project to be <strong class="bold">UnoMediaCollection.Mobile</strong>:</p>
			<div><div><img src="img/B20908_13_13.jpg" alt="Figure 13.13 – Updating the startup project to run on mobile"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.13 – Updating the startup project to run on mobile</p>
			<p>If the WSA is<a id="_idIndexMarker992"/> still active, you should see <strong class="bold">Microsoft Corporation Subsystem for Android</strong> followed by an Android version number on the <strong class="bold">Debug</strong> button. Start debugging and wait a few minutes. Compiling, deploying, and running an Android application can take a bit longer than the Windows version. When the application launches, it should look something like this:</p>
			<div><div><img src="img/B20908_13_14.jpg" alt="Figure 13.14 – Running the UnoMediaCollection application on Android with the WSA"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.14 – Running the UnoMediaCollection application on Android with the WSA</p>
			<p>Everything should<a id="_idIndexMarker993"/> function just as it did on Windows, but there could be slightly more lag in the UI, depending on the performance of your system. The cool thing about using the WSA is that you can resize your application’s window to test the UI layout in different aspect ratios. Give it a try.</p>
			<p>If you have an<a id="_idIndexMarker994"/> Android emulator configured in the Android SDK on your system, you can also try selecting that on the <strong class="bold">Debug</strong> button and running it there. It will look something like this on a traditional phone emulator image:</p>
			<div><div><img src="img/B20908_13_15.jpg" alt="Figure 13.15 – Running the application on an Android emulator"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.15 – Running the application on an Android emulator</p>
			<p>We’re up and running <a id="_idIndexMarker995"/>on Android. In many cases, switching platforms is as easy as changing the startup project. Let’s finish up by trying our application on the web with WebAssembly.</p>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor579"/>Running in the browser with WebAssembly</h1>
			<p>In this final section, we will try <a id="_idIndexMarker996"/>running the application in the browser with WebAssembly. Uno Platform makes it easy to do, but like Android, the compilation and deployment can take a little time. That’s because the entire application needs to run client-side within the browser. That means that in addition to deploying our application, all its dependencies (even a version of the .NET runtime) also need to be deployed.</p>
			<p>This is one reason why the adoption of WebAssembly hasn’t been as fast as many anticipated. The first-time load performance of these apps can be sluggish at best. Uno Platform published a blog post about optimizing WebAssembly performance with Uno Platform applications. If you plan to pursue this option, you should read this post: <a href="https://platform.uno/blog/optimizing-uno-platform-webassembly-applications-for-peak-performance/">https://platform.uno/blog/optimizing-uno-platform-webassembly-applications-for-peak-performance/</a>.</p>
			<p>Change the startup project to <code>UnoMediaCollection.Wasm</code> and start debugging. You’ll notice a command window launch in the background, hosting the web server that deploys the WebAssembly application. Next, a browser window will open. While the application is deploying and loading, you’ll see a Uno Platform logo acting as a splash screen. When the application loads, it will look like this:</p>
			<div><div><img src="img/B20908_13_16.jpg" alt="Figure 13.16 – Running the Uno Platform application in a browser with WebAssembly"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.16 – Running the Uno Platform application in a browser with WebAssembly</p>
			<p>Try using the application. It should function exactly as it did on other platforms. While a few of the visuals may differ from platform to platform, Uno Platform promises near-pixel-perfect applications on each supported platform.</p>
			<p>If you would<a id="_idIndexMarker997"/> like to explore debugging further, there are some differences when debugging WebAssembly applications. The Uno Platform documentation has some great information on this: <a href="https://platform.uno/docs/articles/external/uno.wasm.bootstrap/doc/debugger-support.html">https://platform.uno/docs/articles/external/uno.wasm.bootstrap/doc/debugger-support.html</a>.</p>
			<p>That is all we will be doing in this section with WebAssembly and Uno Platform. Let’s wrap up and review what we’ve learned in this chapter.</p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor580"/>Summary</h1>
			<p>In this chapter, we learned all about Uno Platform. WinUI developers can take their Windows development experience and leverage it to build applications for every platform. While we focused on Visual Studio and Windows development here, with Visual Studio, VS Code, and JetBrains Rider, you can build your Uno Platform applications from any platform. We started with a basic <em class="italic">Hello World</em>-style application and imported the code and XAML from our WinUI project to create a cross-platform version of the application with very few changes. We also learned how you can leverage WSA to debug resizable Android applications on Windows without configuring an emulator. Finally, we ran our application in the browser with Uno Platform and WebAssembly. You’re ready to try Uno Platform for yourself and test some of the other platforms that it supports.</p>
			<p>In the next (and final) chapter, we will discover how to deploy WinUI 3 applications to the Microsoft Store, via <strong class="bold">WinGet</strong>, or with enterprise deployment options.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor581"/>Questions</h1>
			<ol>
				<li>What are two deployment options when debugging Android applications with Visual Studio?</li>
				<li>What are two application design patterns supported by Uno Platform?</li>
				<li>What XAML schemas are supported by Uno Platform?</li>
				<li>When was the first Uno Platform release?</li>
				<li>What client-side web technology can .NET and Uno Platform developers leverage to run applications natively in the browser?</li>
				<li>What two online resources does Uno Platform provide to test their controls and components in your browser?</li>
				<li>What design tool can you leverage to design your Uno Platform applications before developing them in your favorite IDE?</li>
			</ol>
		</div>
	</body></html>