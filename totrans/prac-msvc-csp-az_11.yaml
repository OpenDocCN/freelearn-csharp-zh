- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging and Monitoring
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With a microservices solution, many services can interact with each other. When
    one service fails, the complete solution should not break. In the previous chapter,
    we covered different kinds of tests to find issues early. Here, we’ll look at
    finding issues in production as early as possible – probably before a user sees
    a problem.
  prefs: []
  type: TYPE_NORMAL
- en: To find issues when the application is running and see how the application runs
    successfully, the solution needs to be enhanced to offer telemetry data. With
    **logging**, we see what’s going on; based on different log levels, we can differentiate
    between informational logs and errors. With **metrics** data, we can monitor counters,
    such as memory and CPU consumption, and the number of HTTP requests. We will also
    write custom counters to see the number of games played and the number of game
    moves needed for a win. **Distributed tracing** gives information on how services
    interact. Who is making calls to this service? Where does this error originate
    from?
  prefs: []
  type: TYPE_NORMAL
- en: '**OpenTelemetry** is an industry standard – a collection of APIs that allows
    different languages and tools to instrument, generate, collect, and export telemetry
    data. The .NET APIs for logging, metrics, and distributed tracing support OpenTelemetry,
    and this is what this chapter is about. We’ll use **Prometheus** and **Grafana**,
    which have great graphical views for an on-premises solution, as well as **Azure
    Application Insights** for the solution to run with the Microsoft Azure cloud.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Add log messages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use and create metrics data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use distributed tracing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor with Azure Application Insights
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitor with Prometheus and Grafana
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With this chapter, as with the previous chapters, you need an Azure subscription
    and Docker Desktop. To create all the Azure resources for the solution, you can
    use the Azure Developer CLI – `azd up` creates all the resources. Check the README
    file of this chapter in the repository for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in this GitHub repository: [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/).'
  prefs: []
  type: TYPE_NORMAL
- en: In the `ch11` folder, you’ll see these projects with the result of this chapter.
    This chapter adds the Prometheus launch profile with the `launchsettings.json`
    file of the `AppHost` project. This also sets the `ASPNETCORE_ENVIRONMENT` and
    `DOTNETCORE_ENVIRONMENT` environment variables to `Prometheus`. The default launch
    profile uses services running with Microsoft Azure. The Prometheus launch profile
    is used to run Prometheus and Grafana, which can be used easily in an on-premises
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the important projects for this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.AppHost` – The .NET Aspire host project.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.ServiceDefaults` – Common service configuration. This project
    is enhanced with service configurations for monitoring.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GamesAPI` – The service project is enhanced with logging, metrics,
    and distributed tracing.*   `Codebreaker.Bot` – This project has monitoring information
    included and will be used to play games that can be monitored.*   `grafana` folder
    contains configuration files that are used within the Grafana Docker container.*   The
    `prometheus` folder contains a configuration file that is used by the Prometheus
    Docker container.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can start with the source code from the previous chapter to integrate the
    features from this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding log messages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To see what’s going on successfully or not when running the solution, we add
    log messages. The important parts of understanding the concept of logging are
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**The source**: Who writes log information – what is the category name?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The log provider**: Where is log information written to?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**The log level**: What is the level of the log message? Is it just information
    or an error?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Filtering**: What information is logged?'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The source is defined using the `ILogger<T>` generic interface. With this generic
    interface, the category name is taken from the class name of the generic parameter
    type. In case you use the `ILoggerFactory` interface instead of `ILogger<T>`,
    the category name is passed by invoking the `CreateLogger` method. Examples of
    category names used by .NET are `Microsoft.EntityFrameworkCore.Database.Command`,
    `System.Net.Http.HttpClient`, and `Microsoft.Hosting.Lifetime`. Having hierarchical
    names helps with common configuration settings.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define where log messages are written, log providers are configured with
    the startup of the application. The `CreateBuilder` method of the `WebApplication`
    class configures multiple log providers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ConsoleLogProvider` to write log messages to the console'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DebugLoggerProvider`, which only writes messages to the debug output window
    when a debugger is attached'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`EventSourceLoggerProvider`, which writes log messages using **Event Tracing
    for Windows** (**ETW**) on Windows and the **Linux Trace Toolkit: next generation**
    (**LTTng**) on Linux'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With the AOT ASP.NET Core application that was created in [*Chapter 5*](B21217_05.xhtml#_idTextAnchor110),
    the `CreateSlimBuilder` method was used. `CreateSlimBuilder` only configures the
    console provider; other providers need to be added manually.
  prefs: []
  type: TYPE_NORMAL
- en: The `ILogger` interface defines a `Log` method with a `LogLevel` enum value
    containing `Trace` (0) – `Debug` – `Information` – `Warning` – `Error` – `Critical`
    (5) – `None` (6) values. With this, we can configure to only write `Warning`-level
    messages and higher or write every message specifying the `Trace` level and higher).
    This configuration can be different based on the provider and the source.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following snippet shows a customized configuration with a JSON configuration
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `Logging` section with the configuration is accessed within the implementation
    of the `CreateBuilder` method at startup. Here, we can customize the logging configuration.
    With this configuration file, the default log level is specified with the `LogLevel:Default`
    key. Here, logging is set to `Information`, thus `Debug` and `Trace` log messages
    are not written. This default configuration is changed with log categories that
    start with `Microsoft.AspNetCore`. With this category, only warnings, errors,
    and critical messages are written. With the `LogLevel` key as a subkey to `Logging`,
    all log providers are configured, unless the configuration for the provider is
    overwritten. Here, this is done for the `EventSource` log provider. The `Default`
    log level is set to `Warning`.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s add logging to the games API.
  prefs: []
  type: TYPE_NORMAL
- en: Creating strongly typed log messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The games API service makes use of `ILogger` extension methods such as `LogError`
    and `LogInformation`, when writing log messages, we use custom log methods as
    shown next. Let’s add a `Log` class to define all log messages with the games
    API project:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Infrastructure/Log.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The `LoggerMessage` attribute is used by a source generator. For methods that
    are annotated with this attribute, the logger source generator creates an implementation.
    The method needs to be `void` with an `ILogger` parameter. The method can also
    be defined as an extension method, as is the case here. Parameter names need to
    match the expressions used within the `Message` property, such as `gameId`, `move`,
    and `result`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before the log message is written, the generated logging code checks if the
    log level is enabled. Sometimes, it can be useful to create custom methods that
    make use of generated methods, as shown in the next code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Infrastructure/Log.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The `GameEnded` method checks the `Game` object to see if it’s a victory or
    not, and depending on this, either the `GameWon` or the `GameLost` logging method
    is invoked. Before using any CPU and memory for this process (logging could also
    need to enumerate collections to produce useful log messages), it’s good practice
    to verify if this should be done at all – if the log level is enabled. This is
    checked using the `logger.IsEnabled` method and passing the log level.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Writing logs, don’t use interpolated strings such as `logger.LogInformation($"log
    message {expression}");`. Instead, use `logger.LogInformation("log message {expression}",
    expression);`. The second form supports structured logging. The message string
    passed is a template. With this template, the content within the curly braces
    can be used to create an index, and (depending on the log collector) you can query
    for all log entries containing this term. Also, using the formatted string allocates
    a new string that needs to be garbage-collected. With the second version, there’s
    just one string for all log entries written.
  prefs: []
  type: TYPE_NORMAL
- en: Check the GitHub repo for more methods defined with the `Log` class. Next, let’s
    use this class to write log messages.
  prefs: []
  type: TYPE_NORMAL
- en: Writing log messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Log messages are mainly written from the `GamesService` class, thus we need
    to change the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: With the updated constructor, the generic version of the `ILogger` interface
    is injected. The type parameter specifies the category name for logging.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, the `GamesService` class is enhanced with logging, distributed
    tracing, and metrics functionality. That’s why you see all these changes in the
    final code in the source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `StartGameAsync` method is enhanced with logging:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The `GamesFactory` class can throw an exception of type `CodebreakerException`.
    This is caught to write a log message and to re-throw the exception. The exception
    will be dealt with by the endpoint implementation to finally return a specific
    HTTP result. Here, we just want to log this information and re-throw the exception.
  prefs: []
  type: TYPE_NORMAL
- en: For generic exceptions, a strongly typed `Error` method is defined by the `Log`
    class and used to write this message. The `InvalidGameType` method writes a log
    message with the `Warning` level. Here, the client probably sent an invalid (or
    currently not accepted) game type. While this shouldn’t happen, it’s usually an
    issue with the client, and we don’t have to deal with it on the service side.
    It’s just good to know about such clients. The `Error` method writes a log message
    with the `Error` level. It could be useful to check for more specific error types
    and create additional messages.
  prefs: []
  type: TYPE_NORMAL
- en: On a successful invocation, a log message is written by invoking the `GameStarted`
    method of the `Log` class, which has the `Informational` level set.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s check the log messages with .NET Aspire next.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing logs with the .NET Aspire dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The .NET Aspire-generated `Codebreaker.ServiceDefaults` library contains logging
    configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.ServiceDefaults/Extensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `AddOpenTelemetry` method adds the `OpenTelemetry` logger to the logger
    factory. This provider is configured to include formatted messages and to include
    logging scopes. Setting `IncludeFormattedMessage` to `true` specifies that if
    log templates are used (which we did), formatted messages are also included when
    creating log records for OpenTelemetry. By default, this would not be the case.
    Setting `IncludeScopes` to `true` specifies to include logging scope IDs with
    logs, which allows us to see a hierarchy of log messages when using the `BeginScope`
    method of the `ILogger` interface to define scopes. The `ConfigureOpenTelemetry`
    method is invoked from within the `AddServiceDefaults` method, which in turn is
    invoked both from the games API and the bot service.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this logging configuration in place, it’s time to start the services locally,
    running the .NET Aspire dashboard. Start the application and solution and let
    the bot service play some games. Then, open the .NET Aspire dashboard and select
    **Console Logs** within the **Monitoring** category. Here, you’ll see log outputs
    for games that have been started, as shown in *Figure 11**.1*. You can also see
    log outputs from **Entity Framework Core** (**EF Core**), including queries done
    and ASP.NET Core logs – unless the level is set to not show informational messages:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Logs with the .NET Aspire dashboard](img/B21217_11_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Logs with the .NET Aspire dashboard
  prefs: []
  type: TYPE_NORMAL
- en: 'Also, open the logs from the bot service. The bot service writes log output
    with every move set after the result is received to show how successful the move
    was and how many remaining options are available, as shown in *Figure 11**.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Logs from the bot service](img/B21217_11_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Logs from the bot service
  prefs: []
  type: TYPE_NORMAL
- en: 'When you open `GameId` placeholder we’ve written with the `GameStarted` event,
    as shown in *Figure 11**.3*. Other data, such as the `RequestPath` placeholder,
    is coming from .NET activities, which we’ll look at later in the *Using distributed*
    *tracing* section:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Structured logging](img/B21217_11_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Structured logging
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `GameId`, set the game identifier as the value, and read all the logs
    related to this game. Here, you easily can follow a single gameplay with the moves
    set, as shown in *Figure 11**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Structured logging with a GameId filter](img/B21217_11_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Structured logging with a GameId filter
  prefs: []
  type: TYPE_NORMAL
- en: After writing logs, let’s get started with metrics data.
  prefs: []
  type: TYPE_NORMAL
- en: Using metrics data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metrics data is used to monitor counts such as CPU and memory consumption or
    the length of an HTTP queue. This information can be used to analyze resources
    needed by services and can scale the services accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: With metrics data, we get some counts. Such counts can be used for scaling services,
    based on memory or CPU consumption, or the length of an HTTP queue.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s check the built-in metrics data before we add custom metrics.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring built-in .NET metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'As mentioned, .NET offers much built-in metrics data that can be monitored
    using the `dotnet counters` .NET tool (install it via `dotnet tool install dotnet-counters
    -g` as a global tool), and many counts are already available from the .NET Aspire
    dashboard by opening the **Metrics** view. *Figure 11**.5* shows the .NET-managed
    heap size of the games API service at a time the bot played several games in parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Metrics](img/B21217_11_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Metrics
  prefs: []
  type: TYPE_NORMAL
- en: With many applications, you don’t need to create custom metrics data – but some
    custom counts might be interesting to see, and it’s not hard to add these, as
    shown in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom metrics data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With the `Codebreaker` solution, we are interested in knowing about the number
    of active games that are just played, the time it takes from one game move to
    another, the time it takes to complete a game, and how many games are won versus
    lost.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With all the data we collect, we need to pay attention to the **General Data
    Protection Regulation** (**GDPR**). Not storing any user-related data with logging
    and metrics information, we are on the safe side.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create a new `GamesMetrics` class that contains all the counters needed:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The fields defined within the `GameMetrics` class are for the `Meter` class,
    which is needed to create all the different metric instruments. This class is
    defined within the `System.Diagnostics.Metrics` namespace. This class is responsible
    for creating all the different instruments needed to monitor metrics data. The
    `Meter` type needs a name that is used to specify what metrics data we are interested
    in. The value for the version is optional.
  prefs: []
  type: TYPE_NORMAL
- en: The `Counter` type is used to count the number of games won and lost and for
    all invalid game moves. `Counter` can be used for positive values, and most metrics
    viewers show the number of counts per second but can also show cumulative values.
    The `UpDownCounter` type is used for positive and negative values. We use this
    for the number of games active. Every time a game ends, a decrement will be made.
    The `Histogram` type is of special interest. This metrics instrument can be used
    to show arbitrary values. Here, this instrument is used to show the time it takes
    to complete a game, the time a user needs between game moves, and the number of
    moves needed to win a game.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the constructor of the `GamesMetrics` class, the `Meter` class and the
    instruments are created and initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '`IMeterFactory` is a new interface since .NET 8\. This allows the creation
    of metrics types via `IMeterFactory` is injected with the `GamesMetrics` constructor
    to create a `Meter` instance and instruments. `CreateCounter`, `CreateUpDownCounter`,
    and `CreateHistogram` are the methods to create the different metric instruments.
    The name of the instrument, the unit, and the description are assigned upon creating
    the instruments.'
  prefs: []
  type: TYPE_NORMAL
- en: Before using these counters, let’s add tags.
  prefs: []
  type: TYPE_NORMAL
- en: Creating tags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing metrics data, `GameMetrics` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '`CreateGameTypeTag` is a helper method to create a tag with the name `GameType`
    and set the value passed with the method parameter. Similarly, `CreateGameIdTag`
    is a method to create a tag for `GameId`.'
  prefs: []
  type: TYPE_NORMAL
- en: Now, we are ready to create methods using the instruments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating strongly typed methods for metrics data
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `GameStarted` method is for writing metrics data on creating a new game:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: When nobody listens to metrics data, there’s no need to take any action. Before
    writing values to an instrument, it should be verified that the instrument is
    enabled. If nobody listens to the meter, the counters are disabled.
  prefs: []
  type: TYPE_NORMAL
- en: To write the delta time between moves, we need to remember the time of the previous
    move. For this, the `GameMetrics` class holds the `_moveTimes` dictionary. This
    dictionary uses the game ID for the key and the last time for the latest move
    (or game start) value. Calculating this information is only necessary when the
    `_moveThinkTime` instrument is used.
  prefs: []
  type: TYPE_NORMAL
- en: The counter that’s incremented at the start of the game is `_activeGamesCounter`.
    With `UpDownCounter`, the `Add` method is used to change the counter value. The
    second – optional – argument of the `Add` method allows passing tags. Here, a
    tag for the game type is added. This allows us to check the metrics data filtered
    based on the game type. It’s interesting to compare the active game counts based
    on the different game types.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write a histogram value, we implement the `MoveSet` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Infrastructure/GamesMetrics.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: With the implementation of `MoveSet`, for the received game ID, we get the previous
    recorded time from the dictionary, calculate the delta with the new time, use
    the `Record` method of the `Histogram` instrument to write the data, and write
    the new received time to the dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: On ending the game, the `GameEnded` method is implemented. Here, multiple instruments
    are used, but this method just needs a simple implementation to check for every
    instrument to be enabled and write the counts accordingly. Check the source code
    repository for the complete code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can change the implementation of the `GamesService` class to use a
    `GamesMetrics` instance.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting and using metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s update the `GamesService` class for metrics data:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: All that needs to be done is to inject the `GamesMetrics` class and invoke the
    `GameStarted` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Of course, the `GamesMetrics` class needs configuration within the **DI** **container**
    (**DIC**):'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: The `AddMetrics` extension method registers an implementation for the `IMeterFactory`
    interface. The `GamesMetrics` class is registered as a singleton – to create the
    instruments once. We also configure the `GamesMetrics` class with OpenTelemetry
    – this way, we have a listener, and these metrics will be shown with the .NET
    Aspire dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we could run the application. However, the unit tests for the `GamesService`
    class no longer compile because of this additional parameter. Let’s update this
    before we continue.
  prefs: []
  type: TYPE_NORMAL
- en: Updating unit tests to inject metrics types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `GamesService` class uses a concrete type – it injects the `GamesMetrics`
    type. This cannot be mocked directly, but we can mock the `IMeterFactory` interface
    to create a `GamesMetrics` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code snippet shows an implementation of the `IMeterFactory` interface
    to be used for unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Tests/TestMeterFactory.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: To implement the `IMeterFactory` interface, `Create` and `Dispose` methods need
    to be implemented. With the `Create` method, a new `Meter` instance is created
    using name, version, and tag information.
  prefs: []
  type: TYPE_NORMAL
- en: 'This `TestMeterFactory` class can now be used to create an instance of the
    `GamesService` class for the unit test:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Tests/GamesServiceTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Creating a new `GamesMetrics` instance, the `TestMeterFactory` class is created.
    The unit test for the `GamesService` class now builds successfully again.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The GitHub contains an additional parameter, `ActivitySource`, when invoking
    the `GamesService` constructor. The `ActivitiySource` is added in the section
    *Using distributed tracing*, and requires an adaption of the unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: There’s also a unit test for the `GamesMetrics` class needed, which we’ll do
    next.
  prefs: []
  type: TYPE_NORMAL
- en: Creating unit tests to verify metrics
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Metric data can be important business information easily shown on monitors in
    the office. What’s going on with the application? How active are users? Is an
    error rate going up? While metrics information is not important for orders coming
    in and being processed, if metrics data is not written, it can easily be missed
    that something is not working – thus creating unit tests for metrics data should
    be part of creating custom metric types.
  prefs: []
  type: TYPE_NORMAL
- en: First, let’s create a skeleton to return an `IMeterFactory` instance and a `GamesMetrics`
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: Meter factory skeleton
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The following code snippet defines the skeleton used by the `GamesMetrics`
    unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Tests/GamesMetricsTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Here, we need the real implementation of the `IMeterFactory` Interface. This
    is configured with the DIC for the unit test – along with the `GamesMetrics` singleton.
    The `CreateMeterFactorySkelton` method now gets the `IMeterFactory` and `GameMetrics`
    instances from the DIC.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Using this skeleton, we can create unit tests for all `GameMetrics` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.Tests/GamesMetricsTests.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: For easy unit testing of metrics classes, the `MetricCollector` class defined
    in the `Microsoft.Extensions.Diagnostics.Testing` NuGet package in the `Microsoft.Extensions.Diagnostics.Metrics.Testing`
    namespace can register as a listener for the metrics data and collect this information.
    It’s also great for debugging purposes to have the metrics instruments enabled.
  prefs: []
  type: TYPE_NORMAL
- en: After the `IMeterFActory` and `GamesMetrics` objects are returned from the skeleton,
    a collector is created. You need to create a collector for every instrument that
    needs to be tested. The generic type parameter and the name of the instrument
    need to match. The `MoveSet` method of the `GamesMetrics` class records the time
    between the previous move (or the game start) and the current move. Using `Assert.Single`,it’s
    verified that exactly one measurement is written to the collector. With `Assert.Equal`,
    it’s checked that this one recording contains the value 10\. If you calculate
    the values from `_gameStartTime` and `_gameMove1Time`, this matches the time difference
    passed with the test data.
  prefs: []
  type: TYPE_NORMAL
- en: As the `GameMetrics` class tests successfully, let’s go to the .NET Aspire dashboard
    to see the custom metrics data.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing metrics data with the .NET Aspire dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We injected metrics and configured our custom `GamesMetrics` class with OpenTelemetry
    in the game APIs project. Now, we can use the .NET Aspire dashboard to see the
    games played!
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the services and starting the bot to run multiple games in parallel,
    we can see interesting outcomes. Sometimes, the bot doesn’t find an answer within
    12 moves because it lost the game, as shown in *Figure 11**.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Counter for games lost](img/B21217_11_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Counter for games lost
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.7* shows the number of games won by the bot is much higher. This
    figure also shows the filter for the game type that can be selected because of
    the tag specified:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Counter for games won](img/B21217_11_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Counter for games won
  prefs: []
  type: TYPE_NORMAL
- en: 'While games won and lost used simple counters, *Figure 11**.8* shows the up-down
    counter with the number of active games:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Up-down counter for active games](img/B21217_11_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Up-down counter for active games
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.9* shows a histogram that allows checking the duration of games:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Histogram showing the game duration](img/B21217_11_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – Histogram showing the game duration
  prefs: []
  type: TYPE_NORMAL
- en: 'A histogram graph shows **P50**, **P90**, and **P99** values. These names are
    marks for percentiles. 50% of the finished games are within the lowest values:
    over the complete time, 50% of the games were finished within 25 seconds. The
    next higher line marks 90% of the game runs. Over time, with some peaks, we can
    see that sometimes 90% of the games were finished within 25 seconds, but it also
    took up to 50 seconds. To get to a higher number of games, 99% of the games were
    finished within 50 to 75 seconds. At peak time, it took 250 seconds. If a user
    is playing the game, this can be expected. We need more time than the bot to solve
    this. But here, it was just the bot playing. With different games, the bot was
    configured to take different times between game moves. However, the bot was never
    configured to take that long. Thus, this needs to be another issue, probably too
    high a load on the service. To find the reason more easily for such behavior,
    the next section covering distributed tracing will help.'
  prefs: []
  type: TYPE_NORMAL
- en: Using distributed tracing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If errors happen on the service, where is this request coming from, and from
    where does it originate? With distributed tracing, we can see the interaction
    of services and resources and can easily follow information on how requests from
    a client flow to the different services and see when errors occur, going from
    the error up to the stack.
  prefs: []
  type: TYPE_NORMAL
- en: Using .NET, we use `ActivitySource` and `Activity` classes to specify information
    for distributed tracing.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an ActivitySource class with the DIC
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When writing trace information, you’ll usually have one `ActivitySource` class
    in a project that’s used by all classes that write trace information. With the
    games client library, an `ActivitySource` class is used as a static member. Using
    an `ActivitySource` class from an executable project such as the games API, we
    can register this in the DIC:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/ApplicationServices.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The ASP.NET Core initialization already registers an `ActivitySource` class
    with the name `Microsoft.AspNetCore` as a singleton for the `ActivitySource` type.
    We don’t want to overwrite this setting with our name. The ASP.NET Core features
    injecting this `ActivitySource` instance should still get this instance, but for
    our own trace messages, the `Codebreaker.GameAPIs` activity source should be used.
    With .NET 8 enhancements on the DIC, we can register a named service within the
    DIC by invoking the `AddKeyedSingleton` method and specifying the name and version
    strings. One instance is created using the factory defined with the lambda expression.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we can inject this singleton instance with the `GamesService` class.
  prefs: []
  type: TYPE_NORMAL
- en: Writing trace messages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With the constructor of the `GamesService` class, we can now inject the configured
    `ActivitySource` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using the `FromKeyedServices` attribute, we get the named instance from the
    DIC.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s update the creation of a new game by creating an `Activity` object:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Services/GamesService.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `Activity` object is created by invoking the `CreateActivity` method. The
    parameters used here are the name of the activity and the activity kind. The service
    specifies `ActivityKind.Server`, whereas the client library uses `ActivityKind.Client`.
    Other types available are `Producer` and `Consumer`.
  prefs: []
  type: TYPE_NORMAL
- en: The methods creating an `Activity` object might return `null`. If no one adds
    a listener to the `ActivitySource` class, the `CreateActivity` method returns
    `null`. This reduces the overhead but also means we always need to check for `null`
    values before using an `Activity` object. Using the `null` conditional operator,
    this is easy to do.
  prefs: []
  type: TYPE_NORMAL
- en: Using the `StartActivity` method instead of the `CreateActivity` method would
    immediately start the activity. Here, we want to add some data to the activity
    that is shown with the log output. The `AddTag` method is used to add the game
    type and the game ID. This method adds key-value pairs to the log entries, which
    allows filtering and searching. The `SetBaggage` method allows adding information
    not only to this activity output – this information is passed to the child activities.
    Baggage information is used across processes and thus needs to be serializable.
    Invoking the `Start` method starts the activity – this writes the first log record
    along with tag and baggage information.
  prefs: []
  type: TYPE_NORMAL
- en: An activity ends when the `Stop` method is invoked. Here, the `using` declaration
    is used to dispose of the activity when the `activity` variable goes out of scope.
    This stops the activity implicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Before the activity ends, the `SetStatus` method is invoked. This method specifies
    the outcome of the activity and is written when the activity ends. With a successful
    start of the game, `ActivityStatusCode.Ok` is the status of the activity. In case
    of errors, the status code is `ActivityStatusCode.Error` and an exception message
    is written.
  prefs: []
  type: TYPE_NORMAL
- en: Check the other source code repo for the other activities created with the `GamesService`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: With this implementation, we just need to configure the service defaults library
    to monitor the custom `ActivitySource` class.
  prefs: []
  type: TYPE_NORMAL
- en: Viewing distributed traces with the .NET Aspire dashboard
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'First, let’s add a custom `ActivitySource` class to the configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.ServiceDefaults/Extensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `WithTracing` method configures the distributed trace settings. The `AddSource`
    method of the `TracerProviderBuilder` class sets the sources that should be subscribed
    to. `Codebreaker.GameAPIs` is the activity source name that has been configured
    with the games API service. `Codebreaker.GameAPIs.Client` is the activity source
    name used from the client library, which is referenced by the bot service. The
    next methods invoked configure the built-in sources with ASP.NET Core, gRPC, and
    `HttpClient`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, running a few games using the bot, you can see *traces* in the .NET Aspire
    dashboard, as shown in *Figure 11**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Tracing](img/B21217_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Tracing
  prefs: []
  type: TYPE_NORMAL
- en: Sending a `POST` request to the bot to play multiple games, the request immediately
    returns (the one request in the figure lists 4,84 ms). The figure also shows activities
    started from this request from within a background task. This task is to play
    games. How this relates to multiple activities (or `bot POST bot/bots`, is an
    activity created from ASP.NET Core. The next activity, `bot StartGameAsync`, is
    a custom activity that was created from the games client library. `bot POST` is
    the next activity from `HttpClient`. From there, we switch over to the `gameapis`
    service. The custom activities created with the games API are `gameapis StartGame`
    and `gameapis SetMove`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With every one of these activities, you can dig deeper and get the data written,
    including the tags for the game ID and the game type, as shown in *Figure 11**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Trace data](img/B21217_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Trace data
  prefs: []
  type: TYPE_NORMAL
- en: While monitoring this data, also switch to **Structured Logs**. With these logs,
    you can see a **Trace** identifier. Clicking on this, you switch from the log
    to the trace information. It’s also working the other way around. While opening
    a trace, you can switch to the log information associated with the trace.
  prefs: []
  type: TYPE_NORMAL
- en: Using the .NET Aspire dashboard is now great in the development environment.
    For production environments, we have different needs. Let’s switch over to using
    .NET Azure services for monitoring.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring with Azure Application Insights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating an Azure Container Apps environment (starting with [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137))
    also creates an **Azure Log Analytics** resource. In this chapter, we add an **Azure
    Application Insights** resource, and add a Log Analytics respource explicitly
    to the app model. Log Analytics and Application Insights are both part of the
    **Azure** **Monitor** service.
  prefs: []
  type: TYPE_NORMAL
- en: Log Analytics is used to monitor the amount of log data created and the cost
    associated and gives reasons when there is a higher-than-expected usage. Application
    Insights has a focus on application telemetry data and user data.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the .NET Aspire host for Application Insights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To add Application Insights, add the NuGet package `Aspire.Hosting.Azure.ApplicationInsights`,
    and update the `Program.cs` file of the .NET Aspire `AppHost` project:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The Application Insights resource is added invoking the AddAzureApplicationInsights
    method. This method requires a name and a log analytics workspace resource which
    is created invoking the AddAzureLogAnalytics method. Both the games API and the
    bot services will use this resource, thus it is forwarded using Aspire orchestration
    by using the `WithReference` method.
  prefs: []
  type: TYPE_NORMAL
- en: With this, we can configure the services to use Application Insights.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the services to use Application Insights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use Application Insights, the common configuration project can be updated:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.ServiceDefaults/Extensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The `AddOpenTelemetryExporters` method is invoked from the `AddServiceDefaults`
    method in the same class. `AddServiceDefaults` is called with the `WebApplication`
    configuration of every service project. The `AddOpenTelemetry` method is part
    of the OpenTelementry SDK to configure services for logging, metrics, and distributed
    tracing. The `UseAzureMonitor` extension method configures providers to write
    this information to Azure Monitor.
  prefs: []
  type: TYPE_NORMAL
- en: This is all that we need to do. Let’s check the information we get from the
    application.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the solution with Application Insights
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As before, upon running the application when monitoring using the Aspire dashboard,
    use the bot to run multiple games. As Application Insights is configured, it’s
    not necessary to have the solution deployed to Azure; monitoring information will
    be available within Azure when running the application locally as well. After
    starting a few game runs using the bot, open the Azure Application Insights resource
    within the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: 'After playing a few games, check the Azure portal. With Application Insights,
    in the **Investigate** category on the left pane, select **Application map**.
    Here, you see how the different services communicate, as shown in *Figure 11**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Application map](img/B21217_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Application map
  prefs: []
  type: TYPE_NORMAL
- en: The previous figure shows the bot service invokes the game API service, and
    this communicates with the Azure Cosmos database. The count of messages, the time
    used, and errors can easily be seen from this information. Clicking on a connection,
    it’s possible to investigate performance by seeing the slowest calls and directly
    accessing log information.
  prefs: []
  type: TYPE_NORMAL
- en: With the **Investigate** category in the Azure portal, you can dig into other
    interesting information such as **Performance**, where you get insights into slow
    operations, and **Failures**, where you can dive into errors and exceptions. Smart
    detection can give you notifications (alerts) when services are not behaving with
    usual, expected values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the `codebreaker.active_games` and `codebreaker.game_moves-per-win`,
    where you can select the metric name and the aggregation type to calculate values
    and see graphical results, as shown in *Figure 11**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Metrics via Application Insights](img/B21217_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Metrics via Application Insights
  prefs: []
  type: TYPE_NORMAL
- en: With this figure, the first line shows the average duration of a game (seconds),
    the second line shows the average number of moves needed, and the third line shows
    the number of games currently active.
  prefs: []
  type: TYPE_NORMAL
- en: Clicking `customMetrics` table, you can query all the metrics data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Use this KQL query to get the average EF Core queries on a time chart:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'This query accesses the `customMetrics` table filtered by the `name` column
    to get the EF Core queries by second. This result (you can see every record fitting
    this query by clicking on **Results**) is then used to show the average values
    and a timestamp rendered on a time chart. Your result might look like the one
    shown in *Figure 11**.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – EF Core average queries using KQL](img/B21217_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – EF Core average queries using KQL
  prefs: []
  type: TYPE_NORMAL
- en: The Application Insights resource can be used no matter where your services
    are running if they have access to this resource on Microsoft Azure. In case the
    complete solution needs to run on-premises, you can use Prometheus and Grafana,
    as we’ll do next.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring with Prometheus and Grafana
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: For monitoring microservices solutions, Prometheus and Grafana are often used.
    **Prometheus** uses a pull model to collect data from services. Using this data,
    the **PromQL** query language analyzes this information. **Grafana** can access
    the data collected from Prometheus to show a graphical view.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll use Docker containers running Prometheus and Grafana. Microsoft Azure
    also offers managed services for Prometheus and Grafana that can be used as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s configure Docker containers for Prometheus and Grafana next.
  prefs: []
  type: TYPE_NORMAL
- en: Adding Docker containers for Prometheus and Grafana
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To use the solution with Prometheus and Grafana, you need to select the launch
    profile – using Visual Studio, select **OnPremises** in the toolbar after the
    project selection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the command line, use the `--``launch-profile` parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: To also use SQL Server within a Docker container, set the `DataStore` configuration
    to `SQLServer` (see [*Chapter 3*](B21217_03.xhtml#_idTextAnchor063) for details);
    you could also use in-memory or Cosmos instead with the same build configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'For using a Prometheus Docker container, we need to change the .NET Aspire
    `AppHost` implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The first Docker container we used was the container for SQL Server. For using
    the Docker image for SQL Server, the `AddSqlServerContainer` extension method
    was used. To use the Prometheus Docker image, we need to use the `AddContainer`
    generic method, which allows adding any Docker image. The Docker image for Prometheus
    can be pulled from Docker Hub using `prom/prometheus`. For the Prometheus configuration,
    we use the `prometheus` folder, which is stored outside of the container. Using
    `WithBindMount`, the `prometheus` host directory is mapped to the `/etc/prometheus`
    folder within the container. Prometheus used port `9090` to access its services.
    This port is mapped to the host port `9090` with the `WithHttpEndpoint` method
    to make Prometheus available.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a Docker container for Grafana with the same file:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.AppHost/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The Docker image for Grafana is pulled from Docker Hub with the name `grafana/grafana`.
    This container needs mounts within the `/etc/grafana` and `/var/lib/grafana/dashboards`
    Docker container directories for the Grafana configuration and dashboard configurations
    used. For both mounts, we’ll have a local `grafana` directory. The Grafana service
    will be available on port `3000`.
  prefs: []
  type: TYPE_NORMAL
- en: After configuring the Docker containers, let’s add the configuration for Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Prometheus
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Prometheus is configured with this YML file in the `prometheus` folder that’s
    referenced with the Docker container configuration specified previously:'
  prefs: []
  type: TYPE_NORMAL
- en: prometheus/prometheus.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Prometheus pulls telemetry data from services. How often this is done from Prometheus
    is defined by the `scrape_interval` parameter. To run tests and get fast information,
    here, 1 second is configured. On a production system, you might increase this
    value to, for example, 30 seconds to decrease the load on the services. The services
    that are accessed from Prometheus are the games API and the bot service. Make
    sure to configure the ports to the port numbers of your service projects. You
    can see these values with the `Properties/launchsettings.json` files.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add an API endpoint that’s accessed by Prometheus for scraping telemetry
    data, the `MapDefaultEndpoints` method of the `Extensions` class needs an update:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.ServiceDefaults/Extensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `MapPrometheusScrapingEndpoint` method configures an endpoint and maps the
    `PrometheusExporterMiddleware` middleware.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `AddOpenTelemetryExporters` method needs an update as well:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.ServiceDefaults/Extensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: With Azure Application Insights, we used the `UseAzureMonitor` method. For Prometheus,
    we use the `WithMetrics` method, and `AddPrometheusExporter` adds the exporter
    for Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: After the configuration of Prometheus, let’s configure Grafana.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring Grafana
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With this configuration of the Grafana Docker container, we defined using the
    `grafana` host folder. Here, we need to create a `grafana.ini` configuration file:'
  prefs: []
  type: TYPE_NORMAL
- en: grafana/grafana.ini
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: For simple tests locally, we allow anonymous authentication and specify that
    non-authenticated users have admin access to change settings and customize dashboards.
    The home dashboard that’s used is the ASP.NET Core dashboard.
  prefs: []
  type: TYPE_NORMAL
- en: 'To access Prometheus from Grafana, the data source needs to be specified with
    a YML file:'
  prefs: []
  type: TYPE_NORMAL
- en: grafana/config/provisioning/datasources/default.yaml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: The `datasources` folder contains the configuration file for the Prometheus
    data source. This uses port `9090` used by Prometheus.
  prefs: []
  type: TYPE_NORMAL
- en: 'The default dashboard is configured with a YML file as well:'
  prefs: []
  type: TYPE_NORMAL
- en: grafana/config/provisioning/dashbaords/default.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'The dashboards themselves are stored within the `grafana/dashboards` folder.
    You can get pre-built dashboards at [https://grafana.com/grafana/dashboards](https://grafana.com/grafana/dashboards).
    The ASP.NET Core team provides the dashboards for .NET 8 named *ASP.NET Core Endpoint*
    (ID: 19925) and *ASP.NET Core* (ID: 19924) to monitor request durations, error
    rates, current connections, total requests… for ASP.NET Core metrics. Both dashboards
    are copied to the final solution of this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: When this configuration is in place, we are ready to start the solution again
    – running all services on the local system.
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the solution with Prometheus and Grafana
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you run the application now, three Docker containers are running: SQL
    Server, Prometheus, and Grafana, and the bot and game APIs projects, as shown
    in *Figure 11**.15*. Grafana lists an endpoint that’s accessible from the host:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Aspire dashboard with Prometheus and Grafana](img/B21217_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Aspire dashboard with Prometheus and Grafana
  prefs: []
  type: TYPE_NORMAL
- en: 'By accessing the bot service again to let it play some games, we can access
    the configured dashboards from the Grafana Docker container, as shown in *Figure
    11**.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Grafana Dashboards](img/B21217_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – Grafana Dashboards
  prefs: []
  type: TYPE_NORMAL
- en: This page is opened by selecting **Dashboards** in the left pane. There, you
    can open both configured ASP.NET Core dashboards to see these metrics.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also see the custom metric counts written, as shown in *Figure 11**.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – Active games with Grafana](img/B21217_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – Active games with Grafana
  prefs: []
  type: TYPE_NORMAL
- en: The preceding figure shows the active game count (all started from the bot).
    To see this screen, open the **Explore** menu in the left pane. Then, select the
    value of the metric from a combobox and click the **Query** button. With the graph,
    you can select from different display types.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the previous section, you’ve seen Azure services to monitor the solution.
    With Prometheus and Grafana, you’ve seen services that can easily be used in an
    on-premises environment. In case you prefer Prometheus and Grafana while running
    within Microsoft Azure, one way of use is to run these services in Azure Container
    Apps. Azure-managed services are available as well: Azure offers Managed Grafana
    and Azure Monitor Managed Service for Prometheus. Using these services, the same
    service is available but with reduced management needs.'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, you learned about offering telemetry data from a microservice
    solution covering logging, metrics, and distributed tracing. With logging, you
    used high-performance, strongly typed logging to write information-level logs
    as well as errors. For metrics, you created custom metric data using the `Meter`
    class with instruments created. For distributed tracing, you used the `ActivitySource`
    and `Activity` classes.
  prefs: []
  type: TYPE_NORMAL
- en: To monitor all this telemetry data, you used the .NET Aspire dashboard, Azure
    Application Insights, and Prometheus with Grafana.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look into how to use metrics data to scale the services
    running with Azure Container Apps. We’ll find out about the memory and CPU usage
    of services using load tests we created in [*Chapter 10*](B21217_10.xhtml#_idTextAnchor239),
    combine this with metrics information from this chapter, learn about scaling services
    to be ready no matter how demand grows, and implement health checks to recover
    services when not healthy.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in this chapter, you can refer to
    the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: 'OpenTelemetry: [https://opentelemetry.io/](https://opentelemetry.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'High-performance logging in .NET: [https://learn.microsoft.com/en-us/dotnet/core/extensions/high-performance-logging](https://learn.microsoft.com/en-us/dotnet/core/extensions/high-performance-logging)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application Insights: [https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview](https://learn.microsoft.com/en-us/azure/azure-monitor/app/app-insights-overview)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'KQL repo: [https://github.com/microsoft/Kusto-Query-Language](https://github.com/microsoft/Kusto-Query-Language)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Prometheus: [https://prometheus.io/](https://prometheus.io/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grafana repo: [https://github.com/grafana/grafana](https://github.com/grafana/grafana)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Grafana Dashboards: [https://grafana.com/grafana/dashboards/](https://grafana.com/grafana/dashboards/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
