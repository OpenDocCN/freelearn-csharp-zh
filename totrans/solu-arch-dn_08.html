<html><head></head><body>
		<div id="_idContainer088">
			<h1 id="_idParaDest-93"><em class="italic"><a id="_idTextAnchor093"/>Chapter 6</em>: Architecture Considerations</h1>
			<p>In the previous chapter, we learned about a set of architectural patterns that you must know to design and build a successful solution. These patterns are essential as they set the path for the development team and address the client concerns related to solution agility, scalability, and performance. Later in the chapter, we had a quick overview of a set of architecture characteristics that affect how you choose the right pattern for your solution.</p>
			<p>In this chapter, we will dig deep into the quality factors that should be taken into account, such as reusability, usability, performance, security, development time, and similar quality requirements. Additionally, we will get to know best practices to plan for exception handling, tracing, and deploying.</p>
			<p>Here are the topics that we will cover in this chapter:</p>
			<ul>
				<li>Exploring the design and runtime quality attributes of the solution architecture</li>
				<li>Learning how to plan for exception handling, tracing, and deploying</li>
				<li>Caching in web applications</li>
			</ul>
			<p>By the end of this chapter, you will have learned what makes an architecture pattern the best fit for the product you are building by exploring design and runtime quality attributes. We will also enrich your knowledge by learning best practices to implement caching to improve performance and overall user experience, logging to track reported errors in a centralized location, and deployment techniques.</p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor094"/>Learning about quality attributes</h1>
			<p>An organized solution architecture sets the right path for your development team and makes it easy to maintain different quality characteristics, which will further enhance the quality of the product in many ways.</p>
			<p>Before we start exploring the various quality attributes, let's first understand what a quality attribute is. A <strong class="bold">quality attribute</strong> is a <a id="_idIndexMarker406"/>property that defines the quality of a system, it is a measurable or testable characteristic of a system that is used to indicate how well the architecture chosen for the system satisfies the requirements of the client. There are two types of <a id="_idIndexMarker407"/>quality attributes: qualities that can be measured at design time and others that can be measured at runtime or during execution. The following diagram shows us the various attributes that we will discuss in this chapter along with their respective types:</p>
			<div>
				<div id="_idContainer086" class="IMG---Figure">
					<img src="image/Figure_6.1_B17366.jpg" alt="Figure 6.1: Software architecture quality attributes"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.1: Software architecture quality attributes</p>
			<p>Let's explore these quality attributes in the following sections.</p>
			<h1 id="_idParaDest-95"><a id="_idTextAnchor095"/>Exploring design quality attributes</h1>
			<p>Business functionalities of the <a id="_idIndexMarker408"/>product take the front seat in terms of importance<a id="_idIndexMarker409"/> for the development team. We often focus on meeting the functional requirements of the client and later, after releasing the product, we notice some quality deficiency such as the product is difficult to maintain or to scale. Also, we may end up with performance issues or security breaches. In this section, we will explore the design quality attributes that should be addressed during the software architecture phase.</p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor096"/>Maintainability</h2>
			<p><strong class="bold">Maintainability</strong> is one<a id="_idIndexMarker410"/> of the key software quality attributes. It <a id="_idIndexMarker411"/>refers to the ability of the architecture to support future changes in the product behavior such as introducing a feature with new business requirements or modifying an existing one.</p>
			<p>Repair philosophy also affects the measurement of this attribute, which refers to the time needed to restore the system after a failure. The more our code is coupled and the components are developed with excessive dependencies, the more the product is difficult to maintain. With the existence of this attribute, software engineers started introducing the concept of separation of concerns into architectures, which is supported in microservices architecture, for example. </p>
			<p>Improving the maintainability of the product can greatly improve team productivity and lower the cost of adding new features. Here is a list of key techniques for better maintainability:</p>
			<ul>
				<li>Choose an architecture that allows us to separate the responsibilities of the components by having low coupling, which should create well-defined layers in the system and ease changes in the system.</li>
				<li>Use interfaces to maximize the use of plugin modules in the system, which will allow more flexibility and extensibility.</li>
				<li>Provide detailed documentation to explain the object-oriented structure in the system.</li>
			</ul>
			<h2 id="_idParaDest-97"><a id="_idTextAnchor097"/>Flexibility</h2>
			<p><strong class="bold">Flexibility</strong> refers to the <a id="_idIndexMarker412"/>ability of the architecture to adapt to <a id="_idIndexMarker413"/>varying environments and situations in response to different user and system requirements, which could be hardware changes, software changes, or even changes in the business rules. The less effort you put in to cope with changes, the more flexible it is; the easier it is to reconfigure and deploy the system, the more flexible it is.</p>
			<p>A flexible software architecture is able to adapt to changes, so let's check the following key techniques to improve flexibility:</p>
			<ul>
				<li>Consider using business layers to encapsulate the business rules. We can only modify these layers when business rules change.</li>
				<li>Consider using a configurable business workflow engine such as <strong class="bold">Microsoft Power Automate</strong>.</li>
				<li>Consider<a id="_idIndexMarker414"/> implementing layers in the system to separate<a id="_idIndexMarker415"/> the UI from the business logic and the data access functionality.</li>
				<li>Design layers to be consistent and loosely coupled to maximize flexibility and facilitate the replacement and reusability of the components.</li>
			</ul>
			<h2 id="_idParaDest-98"><a id="_idTextAnchor098"/>Reusability</h2>
			<p><strong class="bold">Reusability</strong> is also <a id="_idIndexMarker416"/>one of the key software quality attributes. It refers to the<a id="_idIndexMarker417"/> degree to which existing components, classes, and functions can be reused to develop new modules, new features, or even new applications. It eliminates the duplication of code and minimizes the time needed to implement new components.</p>
			<p>Reusability is an approach that should be applied with careful consideration of the benefits it brings to a system. Here are some key techniques to improve reusability:</p>
			<ul>
				<li>Identify the cross-cutting functionalities between components and implement the common classes and functions that we can reuse across different components to provide capabilities such as validation, logging, tracing, authorization, and authentication.</li>
				<li>Consider exposing the business logic through web services or Web APIs to provide this logic to different systems or platforms, such as web and mobile.</li>
				<li>Use data types and structures that can be accessed through different components.</li>
			</ul>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor099"/>Integrability</h2>
			<p><strong class="bold">Integrability</strong> outlines the<a id="_idIndexMarker418"/> way the components are designed to <a id="_idIndexMarker419"/>operate together by exchanging information as part of the overall system architecture. It also includes the coding standards and naming conventions in addition to other factors that affect the consistency of the components and makes it easy for the developers to understand the code and maintain it. It also measures the ability of the system to be integrated with other systems.</p>
			<p>There are numerous advantages of applying integrability to improve the harmony between the different components of a system. Here are some key techniques to maximize integrability:</p>
			<ul>
				<li>Enforce coding standards that should be predefined and available for the development team and provide detailed documentation for the entire system architecture.</li>
				<li>Consider using web services or gateway layers to integrate with legacy systems.</li>
				<li>Perform code review sessions to ensure guidelines are respected during the implementation.</li>
			</ul>
			<h2 id="_idParaDest-100"><a id="_idTextAnchor100"/>Testability</h2>
			<p><strong class="bold">Testability</strong> is a <a id="_idIndexMarker420"/>quality attribute that shows how well a system allows us to <a id="_idIndexMarker421"/>create test cases and execute test plans to determine whether the system is working as per the requirements. It allows us to identify faults in the system in an effective manner and based on predefined test cases.</p>
			<p>We should find defects, performance issues, and security vulnerabilities sooner as it is less expensive than having the customer find them when the product is released. Let's get to know some key techniques to improve testability:</p>
			<ul>
				<li>Create test cases in <strong class="bold">Visual Studio</strong>, then run test plans and check the test results. This is also applicable in <strong class="bold">Azure DevOps</strong>.</li>
				<li>Use mock objects in test cases to build different scenarios.</li>
				<li>Let our architecture support modular components to allow detailed testing.</li>
				<li>Create unit testing to test<a id="_idIndexMarker422"/> every single functionality in<a id="_idIndexMarker423"/> the system.</li>
			</ul>
			<p>It is recommended to consistently increase our learning curve and upgrade our skills to ensure that we are able to apply all these design attributes. This will lead to the creation of balanced and highly efficient software solutions and products. </p>
			<p>In the next section, we will explore runtime quality attributes.</p>
			<h1 id="_idParaDest-101"><a id="_idTextAnchor101"/>Understanding runtime quality attributes</h1>
			<p>Runtime quality attributes <a id="_idIndexMarker424"/>are a set of attributes that are measured during <a id="_idIndexMarker425"/>the execution of a system in real-life scenarios. They represent a set of features that facilitate the measurement of the performance and security of a software product in addition to other quality constraints.</p>
			<p>These quality attributes must be assessed to take actions proactively to ensure they are maintained properly to deliver great products to end users. What follows is an introduction to each runtime quality attribute with some key techniques diving into details that should be considered for improvements.</p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor102"/>Performance</h2>
			<p><strong class="bold">Performance</strong> is the most<a id="_idIndexMarker426"/> important quality attribute for every client. It<a id="_idIndexMarker427"/> refers to the responsiveness of the system to perform a specific function in given constraints such as time, accuracy, or memory usage. It includes two metrics, namely, <em class="italic">latency</em>, which is the time needed to respond to an event triggered in the system, and <em class="italic">throughput</em>, which is the number of events that can occur in a given time frame.</p>
			<p>We all know that there are some products out there that aren't being used because of their performance problems. So, let's get to know some key techniques for improving performance:</p>
			<ul>
				<li>Consider using asynchronous calls.</li>
				<li>Use <strong class="bold">Data Transfer Objects</strong> (<strong class="bold">DTOs</strong>) to minimize the size of data sent from the server to the frontend client.</li>
				<li>Avoid retrieving data more often than is necessary and use paging when returning data collection.</li>
				<li>Use performance profiling tools, such as <strong class="bold">Visual Studio Diagnostic Tools</strong> to identify code that has a large impact on performance.</li>
				<li>Minify frontend assets such as <strong class="bold">JavaScript</strong> and <strong class="bold">CSS</strong> files.</li>
				<li>Consider using <strong class="bold">Azure</strong> <strong class="bold">Functions</strong> to handle long-running requests, as out-of-process functions are<a id="_idIndexMarker428"/> beneficial to minimize CPU<a id="_idIndexMarker429"/> usage.</li>
				<li>Reduce the size of HTTP responses by using HTTP compression.</li>
				<li>Always use the latest release of ASP.NET Core as it includes many improvements.</li>
			</ul>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor103"/>Security</h2>
			<p><strong class="bold">Security</strong> is an essential<a id="_idIndexMarker430"/> part of the system. It refers to the fact that any system <a id="_idIndexMarker431"/>should be protected from disclosure and unauthorized attempts to access data. Securing a system starts with implementing proper authentication and authorization mechanisms. In addition, securing the system assets from unauthorized modification is a must. That's why we should always deploy the compiled assemblies and never upload the .NET classes as is.</p>
			<p>To secure our system, we must have an in-depth understanding of the environment where we want to deploy the product, what type of access we need to grant users, and what they can access. It is important to know that we need to apply various mechanisms to increase the protection level.</p>
			<p>The more we learn about potential threats and take action to avoid them, the more we protect the system. Having the product tested on a regular basis for security vulnerabilities is a must for protection against data breaches that may affect the client's reputation negatively and undermine their brand's integrity. Let's check the following key techniques that should help us improve the overall security of the product:</p>
			<ul>
				<li>Create a periodic task to back up the database and the system assets then store them in a secure location, which will make it possible to recover them quickly when needed.</li>
				<li>Test the restore process to make sure that the backups will work properly.</li>
				<li>Apply solid authentication and authorization processes.</li>
				<li>Never trust user input, always validate data input, and use stored procedures to prevent <strong class="bold">SQL injection</strong>.</li>
				<li>Never use string<a id="_idIndexMarker432"/> concatenation to create SQL statements.</li>
				<li>Encode passwords<a id="_idIndexMarker433"/> saved in the database.</li>
				<li>Do not store sensitive data in hidden fields.</li>
				<li>Implement audit logging functionality to log every single event in the system.</li>
				<li>Consider implementing a clustered server architecture if the system is considered mission-critical for the client.</li>
			</ul>
			<h2 id="_idParaDest-104"><a id="_idTextAnchor104"/>Reliability</h2>
			<p><strong class="bold">Reliability</strong> is the ability of <a id="_idIndexMarker434"/>a system to perform all tasks and events triggered <a id="_idIndexMarker435"/>by users over time without the need to conduct a repair or modification. The system has a probability of high reliability during the early stage of operation. This probability will start reducing over time. Improving the reliability of a system requires us to identify the most essential user journeys, then analyze them to detect the areas where we can improve. This methodology will allow us to create indicators about the services and functions that matter most to the users.</p>
			<p>This quality attribute is critical for the continuity of services delivered by the system. Here are some key techniques to improve the reliability of our system:</p>
			<ul>
				<li>Trace the performance of the most used services in our system to identify poor performance or failures. </li>
				<li>Audit calls to Web APIs and web services.</li>
				<li>Consider implementing a failover plan.</li>
				<li>Consider analyzing <a id="_idIndexMarker436"/>customer complaints to troubleshoot<a id="_idIndexMarker437"/> and identify the services that should be improved.</li>
			</ul>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>Usability</h2>
			<p><strong class="bold">Usability</strong> is a<a id="_idIndexMarker438"/> quality attribute that assesses the user interface of a system. It shows how easy it is to use the system. If users don't like the design or if they find it difficult to<a id="_idIndexMarker439"/> find what they are looking for, they might stop using the system. That's why usability is one of the main factors that will lead users to adopt a system. There are five key factors that constitute the usability attribute: </p>
			<ul>
				<li><strong class="bold">Learnability</strong>: This factor tells us how easy it is for users to perform their tasks the first time they see the system.</li>
				<li><strong class="bold">Efficiency</strong>: This factor specifies how quickly the users can perform their main tasks.</li>
				<li><strong class="bold">Memorability</strong>: This denotes how easy it is to remember the steps to perform main tasks after not using the system for a long time.</li>
				<li><strong class="bold">Errors</strong>: This stipulates how many errors they encounter while performing actions in the system and whether it's easy to report them or to recover and proceed to accomplish the task.</li>
				<li><strong class="bold">Satisfaction</strong>: This indicates how satisfied the users are with the overall design.</li>
			</ul>
			<p>Usability concerns should be carefully considered during the earliest design decisions of the system to avoid the disappointment and frustration of end users when the product is released. Here is a list of some key techniques to improve usability:</p>
			<ul>
				<li>Consider maximizing ease-of-use patterns by enforcing accepted UI design standards.</li>
				<li>Simplify user interaction and multi-step functionalities by applying workflows.</li>
				<li>Consider using asynchronous calls to increase user interactivity and to perform background tasks and avoid full post-back calls. </li>
			</ul>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>Interoperability</h2>
			<p><strong class="bold">Interoperability</strong> is a <a id="_idIndexMarker440"/>quality attribute that assesses the ability of the <a id="_idIndexMarker441"/>components in our system to cooperate at runtime to perform tasks successfully and efficiently exchange information.</p>
			<p>Moreover, interoperability is an attribute of the system that is responsible for its operation and interaction with other systems as well. It is an attribute that cannot be ignored. Let's get to know a few key techniques to increase interoperability:</p>
			<ul>
				<li>Consider using connectors and web services to connect to third-party systems and exchange data.</li>
				<li>Expose functionalities through standard web services or <strong class="bold">REST APIs</strong> to exchange data with legacy systems.</li>
				<li>Ensure that our architecture design allows low coupling between components to improve flexibility and reusability.</li>
			</ul>
			<p>In this section, we explored the runtime quality attributes that affect the quality of the software product. These attributes should be considered and solved during the implementation and execution of the system to ensure the delivery of great products for our clients. In the next section, we will explore the caching mechanism in ASP.NET Core.</p>
			<h1 id="_idParaDest-107"><a id="_idTextAnchor107"/>Caching in web applications</h1>
			<p><strong class="bold">Caching</strong> is a<a id="_idIndexMarker442"/> technique that allows us to store frequently used data in memory. Instead of querying the database multiple times to get the same content, we often use caching to store this content and then retrieve it from the memory the next time we request the same content.</p>
			<p>Caching is essential to<a id="_idIndexMarker443"/> improve performance in ASP.NET Core and the overall user experience of the product. In ASP.NET Core, there are different techniques to cache data. Here is an overview of these techniques:</p>
			<ul>
				<li><strong class="bold">In-memory caching</strong>: In this<a id="_idIndexMarker444"/> technique, the memory of the server is used to store the data.</li>
				<li><strong class="bold">Distributed caching</strong>: This <a id="_idIndexMarker445"/>technique is used when our app is deployed to Azure or when it is hosted on a farm environment. The cache is distributed across the servers contributing to this farm.</li>
			</ul>
			<p>Let's learn how to implement caching in ASP.NET Core.</p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/>Implementing caching in ASP.NET Core</h2>
			<p>In ASP.NET Core, there are two<a id="_idIndexMarker446"/> built-in main interfaces that you can use to <a id="_idIndexMarker447"/>start caching the content of mission-critical tasks: <strong class="source-inline">IMemoryCache</strong> and <strong class="source-inline">IDistributedCache</strong>:</p>
			<ul>
				<li><strong class="source-inline">IMemoryCache</strong>: This is an interface that allows us to apply a local in-memory cache.</li>
				<li><strong class="source-inline">IDistributedCache</strong>: This is an interface that provides us with a set of methods to manipulate the cache in a distributed environment.</li>
			</ul>
			<h4>IMemoryCache example</h4>
			<p>The following code <a id="_idIndexMarker448"/>demonstrates an example of using <strong class="source-inline">IMemoryCache</strong> to avoid querying the database multiple times to get the same content:</p>
			<p class="source-code">public class NewsService</p>
			<p class="source-code">{</p>
			<p class="source-code">    private const string NewsCacheKey = "news-cache-key";</p>
			<p class="source-code">    private readonly IMemoryCache _cache;</p>
			<p class="source-code">    private readonly IDatabase _db;</p>
			<p class="source-code">    public NewsService(IMemoryCache cache, IDatabase db)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _cache = cache;</p>
			<p class="source-code">        _db = db;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public async Task&lt;IEnumerable&lt;NewsItem&gt;&gt; GetNewsList()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        if (_cache.TryGet(NewsCacheKey,            out IEnumerable&lt;NewsItem&gt; news))</p>
			<p class="source-code">        {</p>
			<p class="source-code">            return news;</p>
			<p class="source-code">        }</p>
			<p class="source-code">        news = await _db.getLatestNews&lt;NewsItem&gt;(...);</p>
			<p class="source-code">        _cache.Set(NewsCacheKey, news,            new MemoryCacheEntryOptions</p>
			<p class="source-code">         {</p>
			<p class="source-code">    //sliding expiration force the cache to become         expired after 1 day.</p>
			<p class="source-code">         SlidingExpiration = TimeSpan.FromDays(1)</p>
			<p class="source-code">          });</p>
			<p class="source-code">        return news;</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this example, we have a <strong class="source-inline">NewsService</strong> class with a method to get all the updates from the database. Instead <a id="_idIndexMarker449"/>of querying the database every time, we want to display the new data. So, we decided to use the <strong class="source-inline">IMemoryCache</strong> interface to benefit from its caching mechanism. In the <strong class="source-inline">GetNewsList</strong> method, we are returning the cached version of the data if available; otherwise, we are querying the database then storing the content in the cache.</p>
			<h4>IDistributedCache example</h4>
			<p>This interface should be used when<a id="_idIndexMarker450"/> the application is hosted on a web farm or a cloud service. This interface doesn't use the local memory of the server. This cache is shared by multiple web servers. There are various options to implement the <strong class="source-inline">IDistributedCache</strong> interface:</p>
			<ul>
				<li>We can use the SQL Server distributed cache. This cache will be stored in a SQL table. For this option, we need to add the following <strong class="bold">NuGet</strong> package: <strong class="source-inline">Microsoft.Extensions.Caching.SqlServer</strong>.</li>
				<li>We can use the <strong class="bold">Redis</strong> distributed cache, which is an open source in-memory data store that is often used for a distributed cache. For this option, you need to add the following NuGet package: <strong class="source-inline">Microsoft.Extensions.Caching.StackExchangeRedis</strong>.</li>
			</ul>
			<p>Here is an example showing how to use the <strong class="source-inline">IDistributedCache</strong> interface for caching: </p>
			<p class="source-code">public class NewsModel : PageModel</p>
			<p class="source-code">{</p>
			<p class="source-code">    private readonly IDistributedCache _cache;</p>
			<p class="source-code">    public NewsModel(IDistributedCache cache)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        _cache = cache;</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public string CachedNewsTime { get; set; }</p>
			<p class="source-code">    public async Task OnGetAsync()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        CachedNewsTime = "Cached Time Expired";</p>
			<p class="source-code">        var encodedCachedNewsTime =            await _cache.GetAsync("cachedNewsTime");</p>
			<p class="source-code">        if (encodedCachedNewsTime != null)</p>
			<p class="source-code">        {</p>
			<p class="source-code">            CachedNewsTime = Encoding.UTF8.GetString                 (encodedCachedNewsTime);</p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p class="source-code">    public async Task&lt;IActionResult&gt; ResetCachedTime()</p>
			<p class="source-code">    {</p>
			<p class="source-code">        var currentTimeUTC = DateTime.UtcNow.ToString();</p>
			<p class="source-code">        byte[] encodedCurrentNewsTime = Encoding.UTF8             .GetBytes(currentNewsTime);</p>
			<p class="source-code">        var options = new DistributedCacheEntryOptions()           .SetSlidingExpiration(TimeSpan.FromSeconds(60));</p>
			<p class="source-code">        await _cache.SetAsync("cachedNewsTime",            encodedCurrentNewsTime, options);</p>
			<p class="source-code">        return RedirectToPage();</p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>In this example, we <a id="_idIndexMarker451"/>have created a <strong class="bold">Razor</strong> page to display the time and two asynchronous methods: one to get the cached time and the other one is to reset the cache.</p>
			<p>In the <strong class="source-inline">OnGetAsync</strong> method, we get the cached time if available. The <strong class="source-inline">ResetCachedTime</strong> method is used to set the cache object and define the sliding expiration for 60 seconds, which means the cache will be cleared if it is not used within 60 seconds. Otherwise, the time frame of the cache will be extended for another 60 seconds when it is consumed.</p>
			<p>In the preceding two <a id="_idIndexMarker452"/>examples, we tried to explain the difference between <strong class="source-inline">IMemoryCache</strong> and <strong class="source-inline">IDistributedCache</strong> and how to use them. You can find many Microsoft online forums that provide step-by-step examples on how to configure and implement caching in ASP.NET Core.</p>
			<p>In the next section, we will explore the logging and tracing mechanisms in ASP.NET Core.</p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor109"/>Unified solution for logging and tracing</h1>
			<p>.NET logging providers are used to log event messages to track the execution of the application and report all code errors or application exceptions in a centralized location. Tracing is used to track and view diagnostic information about a single flow in the system.</p>
			<p>Logging and <a id="_idIndexMarker453"/>tracing are essential for .NET teams as every time the application fails, we request information to<a id="_idIndexMarker454"/> troubleshoot the issue and resolve it. The unified solution for logging and tracing will give you answers to the following questions: </p>
			<ul>
				<li><em class="italic">Why did the system fail to complete the action?</em></li>
				<li><em class="italic">When did the error occur?</em></li>
				<li><em class="italic">Which function in the code caused the exception?</em></li>
				<li><em class="italic">What was the status of the data exchanged between the functions?</em></li>
			</ul>
			<p>For traditional solutions that are hosted on-premises, logging and tracing are performed by the same process that runs the executable of the application. As for modern cloud applications that are built with the microservices pattern, each service runs within a specific process. In this case, the logging and tracing are generated by each microservice process.</p>
			<p>The following diagram shows the architecture recommended by Microsoft to implement a unified logging and monitoring system using Azure services:</p>
			<div>
				<div id="_idContainer087" class="IMG---Figure">
					<img src="image/Figure_6.2_B17366.jpg" alt="Figure 6.2: Unified logging and monitoring system using Azure services"/>
				</div>
			</div>
			<p class="figure-caption">Figure 6.2: Unified logging and monitoring system using Azure services</p>
			<p>Let's get to know the main <a id="_idIndexMarker455"/>components from the preceding diagram:</p>
			<ul>
				<li><strong class="bold">Event Hubs</strong>: This<a id="_idIndexMarker456"/> is a real-time data ingestion service that is fully integrated with all other Azure services. It is used to log all types of events in one centralized hub.</li>
				<li><strong class="bold">Azure Monitor</strong>: This is<a id="_idIndexMarker457"/> used to create operational dashboards to help notify .NET teams about any issues and critical malfunctions.</li>
				<li><strong class="bold">Application Insights</strong>: This is <a id="_idIndexMarker458"/>part of Azure Monitor, which is used to monitor live Azure services, detect abnormalities in performance, and diagnose and trace malfunctions.</li>
				<li><strong class="bold">Logic Apps</strong>: This is a<a id="_idIndexMarker459"/> serverless cloud service that allows you to schedule and organize automated workflows using a user-friendly and easy-to-use visual designer.</li>
				<li><strong class="bold">Blob Storage</strong>: This is<a id="_idIndexMarker460"/> cloud storage used for cloud-native workloads to store unstructured data and binary files.</li>
				<li><strong class="bold">Azure Data Lake Storage</strong>: This is a<a id="_idIndexMarker461"/> cloud platform that provides secure storage for big data analytics. It provides a set of capabilities required for developers and data scientists to store and analyze big data.</li>
				<li><strong class="bold">Azure Sentinel</strong>: This is a <a id="_idIndexMarker462"/>cloud platform<a id="_idIndexMarker463"/> that uses built-in AI to log and analyze security information, then report any potential threat or anomalous behavior.</li>
				<li><strong class="bold">Azure Stream Analytics</strong>: This<a id="_idIndexMarker464"/> is a serverless cloud engine used to collect and log real-time analytics.</li>
			</ul>
			<p>So far, we have learned about the main components. Now let's get an understanding of the logging and tracing mechanism shown in <em class="italic">Figure 6.2</em>:</p>
			<ol>
				<li>First, our application hosted on Azure triggers events to <strong class="bold">Event Hubs</strong> and <strong class="bold">Application Insights</strong> from both a user interface action and a Web API call.</li>
				<li><strong class="bold">Application Insights</strong> queries log data, traces problems, and monitors the application performance.</li>
				<li>The <strong class="bold">Stream Analytics</strong> platform queries the data in <strong class="bold">Event Hubs</strong> to trigger <strong class="bold">Logic Apps</strong> workflows and process event messages that are flagged as critical indicators.</li>
				<li>Then, a <strong class="bold">Logic Apps</strong> scheduled process calls a REST endpoint and sends alerts to the .NET teams.</li>
				<li><strong class="bold">Azure Sentinel</strong> uses <strong class="bold">Playbooks</strong>, which are a set of procedures powered by <strong class="bold">Azure Logic Apps</strong> to log security alerts or incidents.</li>
				<li>All logs will then be stored in <strong class="bold">Blob Storage</strong> and <strong class="bold">Data Lake Storage</strong> for later analysis and troubleshooting.</li>
			</ol>
			<p>In the next section, we are going to talk about the high-level deployment steps in Azure.</p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Planning for deployment and monitoring</h1>
			<p>In this section, we are going to focus on deploying your ASP.NET application to <strong class="bold">Azure App Service</strong>. This doesn't <a id="_idIndexMarker465"/>mean that other traditional deployment options are not valid anymore, but we think the future is to host modern apps in the cloud for many reasons, including the capabilities<a id="_idIndexMarker466"/> offered by Azure that don't exist in traditional web hosting.</p>
			<p>To deploy the ASP.NET Core web app to Azure, we'll need to create a new Azure App Service web app. After the creation of the App Service, we'll be able to deploy our app using <strong class="bold">Git</strong> or Visual Studio. To create the App Service, we can use command-line scripts and <strong class="bold">Azure Cloud Shell</strong> or you can use the <strong class="bold">Azure portal</strong> to create and configure the App Service; both are easy to use.</p>
			<p class="callout-heading">Tip:</p>
			<p class="callout">You can refer to the Microsoft documentation for detailed steps on how to create an App Service. Refer to the <em class="italic">Deploy an app to App Service</em> section at <a href="https://docs.microsoft.com/en-us/dotnet/architecture/devops-for-aspnet-developers/deploying-to-app-service?view=aspnetcore-5.0">https://docs.microsoft.com/en-us/dotnet/architecture/devops-for-aspnet-developers/deploying-to-app-service?view=aspnetcore-5.0</a>.</p>
			<p>After creating the App Service, you can publish the application using Visual Studio. Just right-click the Visual Studio project and then publish it. By default, our app will be deployed to the production environment and we will be able to browse it on the internet.</p>
			<p><em class="italic">What if you want to have a staging environment so you can test and approve changes before moving them to production?</em> In this case, you can make use of Azure deployment slots. You can add a new deployment slot that will allow you to swap the app assets along with the configuration settings between the two deployment slots, usually staging and production. You can refer to the Microsoft documentation to create a staging deployment slot (similar steps can be applied to create a production slot): <a href="https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots">https://docs.microsoft.com/en-us/azure/app-service/deploy-staging-slots</a>.</p>
			<h1 id="_idParaDest-111"><a id="_idTextAnchor111"/>Summary</h1>
			<p>In this chapter, we explored the design and runtime quality attributes that affect the overall quality of our architecture and as a result, our product. It is important to understand and apply these quality attributes. This will give our product the ability to undergo repair and evolution.</p>
			<p>Next, we learned about the impact of caching on the performance of the application and how to enable it using ASP.NET Core interfaces. Later in this chapter, we discussed the logging and tracing mechanism in modern apps, then we explored the deployment capability of Azure App Service. </p>
			<p>Remember that our responsibility as solution architects is to get a satisfactory result from the big picture, which consists of the solution architecture as well as the implementation and deployment being done in the correct way – that's what we tried to cover in this chapter.</p>
			<p>In the next chapter, we will dig deep into security considerations and will highlight some key techniques to secure your ASP.NET web applications.</p>
		</div>
	</body></html>