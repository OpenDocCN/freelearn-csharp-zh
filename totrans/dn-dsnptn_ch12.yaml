- en: Chapter 12. Reactive Programming Using .NET Rx Extensions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how reactive programming shapes you up for scalability
    and responsiveness. We saw how these two attributes are supported in event-driven
    applications that enable it to readily respond to events, failures, and loads.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now in this chapter we will:'
  prefs: []
  type: TYPE_NORMAL
- en: Take a deep dive into the Reactive Extensions (Rx) library and see how we write
    asynchronous and event-driven programs using observable sequences and LINQ query
    operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also take a detailed look at some sample use cases and their implementations
    with Rx to clearly understand how Observables, LINQ, and Schedulers in the .NET
    Framework are leveraged to create concurrent and responsive applications that
    can work with asynchronous data streams
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will understand why Rx has been touted as the
    next big thing, and one that will become the de facto event-driven programming
    model, gaining traction and acceptance in various mainstream programming languages.
  prefs: []
  type: TYPE_NORMAL
- en: Streams as a way of life
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw in the previous chapter, the fundamental success to reactive programs
    is to convert events into immutable and observable streams. Program composition
    becomes very easy and intuitive with this format, and you can create a unifying
    interface using the .NET Rx extensions.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is really important to understand, as wielding a hammer like Rx doesn't
    make you Thor. You don't necessarily start seeing every single implementation
    as a nail and drive your hammer down on it. As Uncle Ben once advised Peter aka
    Spiderman - "With great power comes great responsibility".
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s understand this more by looking at the palette of options available,
    and making sound decisions on what can be done. Consider the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Streams as a way of life](img/image_12_001.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'As you can see in the preceding figure, in terms of unifying the worlds, Rx
    brings forth bridges that help you work seamlessly across these programming models.
    To quickly recap what we read in [Chapter 11](dn-dsnptn_ch11.html "Chapter 11. What
    is Reactive Programming?"), *What is Reactive Programming?*, take a look at the
    following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Factory methods** | **Unfold methods** | **Bridges** |'
  prefs: []
  type: TYPE_TB
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`Observable.Return`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Empty`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Never`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Throw`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Create`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`Observable.Range`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Interval`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Timer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.Generate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: '`Observable.Start`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.FromEventPattern`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task.ToObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Task<T>.ToObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IEnumerable<T>.ToObservable`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Observable.FromAsyncPattern`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '|'
  prefs: []
  type: TYPE_NORMAL
- en: As reiterated earlier, we don't replace existing asynchrony. The .NET events,
    async methods, tasks, and so on, have their use and are perfect in their own worlds.
  prefs: []
  type: TYPE_NORMAL
- en: Rx just becomes the glue to unify these worlds, provides compositionality, and
    helps build bridges.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get started on some examples that will help us understand how to
    put Rx to best use in our day-to-day programming. Only certain pragmatic aspects
    are highlighted leveraging key constructs in Rx, as complete coverage warrants
    another book in its own size.
  prefs: []
  type: TYPE_NORMAL
- en: Spell checker using events composition
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This first example is a Windows application that integrates the previously
    implemented spell checker (from [Chapter 9](dn-dsnptn_ch09.html "Chapter 9. Functional
    Programming Techniques for Better State Management"), *Functional Programming
    Techniques for Better State* *Management*) using Rx, and explores how this can
    be leveraged to suggest alternatives and corrections. Consider the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Initialize your input from here, with some basic controls that we will need,
    that is, a text box (used for keyword search) and a list box that provides suggestions/corrections
    for a given keyword. Take a look at the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we will need to create a `DispatcherScheduler` that schedules units of
    work on the dispatcher of the current UI thread. The delegate `onInputChange`
    is created to clear the suggestions in the list box whenever the input keyword
    changes. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We will define an observable stream/sequence on the input based by subscribing
    to the `TextChanged` event of the text box using the `FromEventPattern` bridge.
    We will further filter the input stream based on minimum characters (three, in
    this case) and distinct entries (helps us throttle the lookup frequency). A valid
    output from this input sequence will trigger the delegate that clears the list
    box contents and gets it ready to receive a new set of suggestions as and when
    they are available. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'This defines the second observable sequence that fetches suggestions based
    on the first sequence (keyword) we defined in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an important step where we declaratively specify to continue fetching
    suggestions until the keyword changes (the first observable sequence for us here).
    If you notice, this is done here using the `TakeUntil` operator:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'We will then define delegates (`onEachSuggest`, `onSuggestError`, and `onSuggestComplete`)
    for the `Subscribe` method to receive push-based notifications, as shown in the
    following piece of code (`onEachSuggest` tend to add received suggestions to the
    list box as and when they are received):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the final step where we will specify to observe on the dispatcher of
    the UI thread (it is absolutely critical for you to make the necessary UI updates)
    and subscribe on the default task scheduler instance (Rx will decide one for you
    based on the principle of least concurrency). Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s quickly see the supporting Model code (refactored the earlier `NorvigSpellChecker`
    code to make it a singleton and implement the `ISpellCheckerModel` interface)
    as well. This interface helps in returning the results as an enumerable list,
    which can further be converted to an observable sequence. Lets take a look at
    the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the old code from [Chapter 9](dn-dsnptn_ch09.html "Chapter 9. Functional
    Programming Techniques for Better State Management"), *Functional Programming
    Techniques for Better State Management*, based on Peter Norvig''s post: [http://norvig.com/spell-correct.html](http://norvig.com/spell-correct.html),
    modified to become a singleton. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Some key things to notice here are:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of the `FromEventPattern` bridge to subscribe to the `TextChanged` event
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classic use case for a Singleton (to prevent Training Model corpus creation
    repeatedly every time a word is looked up) to create and cache the dictionary
    for future use
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will be worthwhile to take a look at the Singleton implementation that has
    leveraged .NET 4's `Lazy<T>` type for thread safety, lazy instantiation, and not
    resorting to the conventional double-check locking idiom, where explicit locking
    is used
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The use of the `Where` and `DistinctUntilChanged` operators to restrict lookup
    for unique four letter words and beyond
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The screenshots of our spell checker in action are shown as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spell checker using events composition](img/image_12_002.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'The supporting console helps you understand the sequence of actions behind
    the scenes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Spell checker using events composition](img/image_12_003.jpg)'
  prefs: []
  type: TYPE_IMG
- en: MVVM on Rx
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, let's convert the preceding example to see how we can apply this for a
    classic MVVM implementation.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: MVVM is an important application development framework that has its roots with
    **Windows Presentation Framework** (**WPF**). It is best suited for event-driven
    programming where you achieve clear **Separation of Concerns**, thereby facilitating
    parallel development (Model, View, and View Model) and testability.
  prefs: []
  type: TYPE_NORMAL
- en: '![MVVM on Rx](img/image_12_004.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you observe (no pun intended) in the preceding solution model, the `TextChanged`
    event of the text box, where the word to be looked up is entered, will indicate
    to the `ISubject<T>` type here, one that implements both `IObservable<T>` and
    `IObserver<T>` interfaces, thereby enabling you to conveniently observe and publish
    items to subscribers.
  prefs: []
  type: TYPE_NORMAL
- en: 'Ensure that you have the appropriate dependencies/packages installed via the **NuGet**
    package manager and referenced properly. The ones under consideration here include
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Reactive.Core`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Reactive.Interfaces`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Reactive.Linq`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Reactive.PlatformServices`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`System.Reactive.Windows.Threading`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code for the View layer is shown as follows. Take note (highlighted) of
    the data binding with the corresponding view model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'As you can see, an instance of View Model is created and the Model (code in
    reference is the same one used for the earlier example) instance is specified.
    The text changes are routed to the subject in View Model through the `TextChanged`
    event. Synchronization, with respect to the data bindings, (against the suggestion
    list box), happens automatically through property change notifications from View
    Model, which happens to implement the `INotifyPropertyChanged` interface. The
    data source for the bindings is retained in the View Model. Let''s take a look
    at the View Model now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will use the `CallerMemberName` attribute to avoid specifying the
    member name as a string argument to the called method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, this final step provides the necessary magic in terms of:'
  prefs: []
  type: TYPE_NORMAL
- en: Providing the most recent changes in the sequence (the `Switch` operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up suggestions for only four letter words and above (the `Where` operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Looking up suggestions only if the new value entered is different from old (the
    `DistinctUntilChanged` operator)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'And, finally, looking up on a background thread using the schedulers task/thread
    pool and returning suggestions on the UI thread''s dispatcher. Take a look at
    the following code snippet:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: This View Model clearly shows how Observables, LINQ (`Where` and `DistinctUntilChanged`),
    and Schedulers are put to good practical use. As highlighted in the preceding
    code, the lookup, which is done on a background thread, lets the observer, in
    this case, the data source, that is, the `BindingList<string>`, know through property
    change notifications; thereby, triggering automatic content refresh in the `Suggestions`
    list box. Another thing to note is the adept usage of the `SubscribeOn`/`ObserveOn`
    pair to prevent blocking of UI thread and yet update UI objects on it.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are some key things to notice here:'
  prefs: []
  type: TYPE_NORMAL
- en: The use of `Switch` operator, in addition to the `Where` and `DistinctUntilChanged`
    operators, to ensure the liveliness in search in terms of showing the latest and
    relevant changes with respect to the sequence
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This will also serve as an example of the **Collection Pipeline** pattern, where
    your computation becomes a sequence of operations by taking a collection/sequence
    from one operation and feeding to another
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It leverages immutability, comprehensions (declarative query syntax in LINQ),
    laziness, and parallelism to achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: 'The screenshot of our spell checker in action is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![MVVM on Rx](img/image_12_005.jpg)'
  prefs: []
  type: TYPE_IMG
- en: An asynchronous logger
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Logging and Audit trail is an important cross-cutting or horizontal concern
    in the day-to-day application that we create. There are various third-party tools
    that we leverage; and we have seen how to write one ourselves in depth in [Chapter
    3](dn-dsnptn_ch03.html "Chapter 3. A Logging Library"), *A Logging Library*. Here,
    we will see how to impart reactive behavior to a custom-logging component.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the same spell checker example in the preceding section and see
    how to integrate logging capability into the existing code base.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will start off by initializing the log collection as a `BindingList`, the
    same way we got the corrections/suggestions initialized:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `AddToLog` method will be the generic logging method used to
    hand off the log text to the observer waiting on the `_logchanged` subject. You
    can see instrumentation code throughout the methods, shown as follows, for applicability
    and clarity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `DoLogging` method sets the observer, the `OnEachLog` method
    in our case, to listen for log text sequences/feeds from the observable `_logChanged`
    based on its `onNext` method invocations via the `AddToLog` method, thus, facilitating
    both publication and subscription using the `_logchanged` subject:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This binding list is bound to the `Listbox` specifically used in this example
    to view the logs. This change''s property is further routed to the UI thread that
    senses the change in the bounded data source list in our case against the list
    box and forces a refresh. If you observe carefully, the logging feature is purely
    asynchronous and is handled by a background thread-a worker thread from thread
    pool in this case. Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The logs can be further persisted using the store, such as file, database,
    and so on, of your choice. You can also use this to clearly understand the data
    flow from an observer and subscriber standpoint. The modified application will
    look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An asynchronous logger](img/image_12_006.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Near real-time visualizer/dashboard
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Dashboards are natural candidates for viewing real-time, or near real-time,
    data. Reactive constructs can be very effectively utilized in realizing utility
    dashboards from a reporting standpoint. Let''s look at an interesting scenario
    where election poll results are viewed on a real-time basis as and when the poll
    feeds come in from different states. Again, this has no resemblance to the actual
    polling process, but just conceptualized here in a fictitious manner that will
    enable learning and throw light on various interesting possibilities of leveraging
    reactive programming for such a reporting application. Consider the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the first stage in the prototype where we start building the simulation
    model for data sequences/streams, in our case, votes from multiple states. Here,
    we are initializing a certain number of votes per state. The `Take` query operator
    is utilized here, in case you noticed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the next stage in the prototype, where we will filter democratic and
    republican votes from the simulation model''s stream source, which is generated
    in the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we will initialize and create the data series for the X and Y axis needed
    by the chart component. This way the series are bound to the charting component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the stage where we kick-start simulation, that is, a generation of
    votes specified per state:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following two helper methods, `GetDemocraticVotes` and `GetRepublicanVotes`,
    used as a part of kick-starting simulation ensure that the observers (the following
    lambda function in this case) are bound and listening for changes as and when
    the votes start streaming in. The filtered votes are channeled to these respective
    helper methods and will continuously increment the respective vote counters on
    a near real-time basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following `GenerateVotes` method is the real vote generator (infinite,
    as you see) limited by the number specified using the Take operator, as indicated
    in the preceding code. This uses the generator function `CauchyDistribution` internally
    to generate the votes randomly and non-uniformly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This timer control helps in refreshing the chart control, which is based on
    the preset frequency, with values indicating votes scored by the two parties in
    the various states under consideration. Now, one important thing that you need
    to understand here is that as and when you traverse layers of subscribers and
    observers, you tend to introduce latency, again, based on the kind of schedulers
    you employ for concurrency, which makes the final output near real-time as opposed
    to real time not to introduce any interpretable subjectivity here. One should
    strive to reduce these layers and choose the right schedulers through multiple
    trials and calibrations to minimize these latencies and meet the required SLAs.
    Consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'As can you see, the program is divided into multiple stages, which are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Stage1**: A simulation model building block'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage2**: Filtering votes based on `Party`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage3**: Publish to subscribers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Stage4**: Dashboard renderer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The near real-time dashboard will look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Near real-time visualizer/dashboard](img/image_12_007.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you saw, we have gone through some interesting and pragmatic examples that
    illustrate the applicability of reactive programming principles. The idea is to
    make you aware of the possibilities and warm you up for some serious programming
    tasks ahead. We believe you are in a position to appreciate this paradigm now,
    and possibly able to relate to it as a natural way of expressing solution models
    in a declarative manner, which involved a lot of plumbing code earlier. The power
    of composability that you get in this model is quite evident. Now, in the next
    chapter, we will go on to explore RxJS, the reactive programming JavaScript library
    that helps you brace for web programming.
  prefs: []
  type: TYPE_NORMAL
