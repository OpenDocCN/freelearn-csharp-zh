<html><head></head><body><div id="sbo-rt-content"><div id="_idContainer035">
			<h1 id="_idParaDest-35"><em class="italic"><a id="_idTextAnchor037"/>Chapter 2</em>: Your First AR Scene</h1>
			<p>Creating a simple Augmented Reality (AR) scene is quite simple with Unity AR Foundation. The steps involved might only take a page or two. However, when we create a scene together in this chapter, each step will be explained in context so that you can gain a full understanding of what comprises an AR scene using AR Foundation. </p>
			<p>But before we do that, we'll take a look at some AR examples provided by Unity, including the AR Foundation Samples project, and build their example scenes for your device. And because that project contains some useful assets, we'll export those as an asset package for reuse in our own projects. </p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Building and running the AR Foundation Samples project</li>
				<li>Exporting and importing sample assets</li>
				<li>Constructing a new Unity AR scene</li>
				<li>Introduction to C# programming and the MonoBehaviour class</li>
				<li>Using AR raycast to place an object on a plane</li>
				<li>Instantiating a GameObject </li>
				<li>Creating and editing prefabs</li>
			</ul>
			<h1 id="_idParaDest-36"><a id="_idTextAnchor038"/>Technical requirements</h1>
			<p>To implement the project provided in this chapter, you will need Unity installed on your development computer, connected to a mobile device that supports augmented reality applications (see <a href="B15145_01_Final_SB_epub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a><em class="italic">, Setting Up for AR Development</em>, for instructions). The completed project can be found in this book's GitHub repository at <a href="https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation">https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation</a>.<strong class="bold"> </strong></p>
			<h1 id="_idParaDest-37"><a id="_idTextAnchor039"/>Exploring the AR Foundation example projects from Unity</h1>
			<p>A great way to <a id="_idIndexMarker129"/>learn about how to create AR projects with Unity AR Foundation is to explore the various example projects from Unity. These projects include example scenes, scripts, prefabs, and other assets. By cloning a project and opening an example scene, you can learn how to use AR Foundation, experiment with features, and see some best practices. In particular, consider these projects:</p>
			<ul>
				<li><em class="italic">AR Foundation Samples</em>: <a href="https://github.com/Unity-Technologies/arfoundation-samples">https://github.com/Unity-Technologies/arfoundation-samples</a>.</li>
				<li><em class="italic">AR Foundation Demos</em>: <a href="https://github.com/Unity-Technologies/arfoundation-demos">https://github.com/Unity-Technologies/arfoundation-demos</a>.</li>
				<li><em class="italic">XR Interaction Toolkit Examples</em>: <a href="https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/tree/master/AR">https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/tree/master/AR</a>.</li>
				<li>For more advanced work, I'm also a fan of several individual contributors, including Dan Miller, a senior XR developer at Unity. See <a href="https://github.com/DanMillerDev">https://github.com/DanMillerDev</a> for more information.</li>
			</ul>
			<p>Please look through the <strong class="bold">README</strong> file for each of these projects (found on the GitHub project's home page) to gain an understanding of what the project does, any dependencies it has, and other useful information about the project. </p>
			<p>Each of these repositories contains a full Unity project. That is, they are not simply Unity asset packages you can import into an existing project. Rather, you'll clone the entire repository and open it as its own project. This is typical for demo projects that may have other package dependencies and require preset settings to build and run properly. </p>
			<p>The <em class="italic">AR Foundation Samples</em> project is my <em class="italic">go-to project</em> for learning various AR Foundation features. It contains many example scenes demoing individual features, often in place of detailed documentation elsewhere (see <a href="https://github.com/Unity-Technologies/arfoundation-samples/tree/main/Assets/Scenes">https://github.com/Unity-Technologies/arfoundation-samples/tree/main/Assets/Scenes</a>).</p>
			<p>Each scene is extremely simple (almost to a fault) as it has the atomic purpose of illustrating a single feature. For example, there are separate scenes for plane detection, plane occlusion, and feathered planes. Notably, the project also contains a main menu scene (<strong class="source-inline">Assets/Scenes/ARFoundationMenu/Menu</strong>) that launches the other scenes when you build them all into a single executable. I recommend starting with the scene named <strong class="bold">SimpleAR</strong>, which we'll review in a moment. </p>
			<p>Another is the <em class="italic">AR Foundation Demos</em> project, which contains some more complex user scenarios and features <a id="_idIndexMarker130"/>not covered in the Samples project. For example, it demonstrates the Unity <strong class="bold">Onboarding UX</strong> assets, which we'll introduce you to in <a href="B15145_04_Final_SB_epub.xhtml#_idTextAnchor077"><em class="italic">Chapter 4</em></a><em class="italic">, Creating an AR User Framework</em>. It also covers image tracking, mesh placement, language localization, and some useful shaders (for example, wireframe, shadows, and fog).</p>
			<p>The <em class="italic">XR Interaction Toolkit Examples</em> repository contains two separate Unity projects: one for VR and another for AR. It is largely a placeholder (in my opinion) for things to come.</p>
			<p class="callout-heading">Information – XR Interaction Toolkit</p>
			<p class="callout">The XR Interaction Toolkit from Unity is not covered in this book. It provides components and other assets for developing interactive scenes using hand controllers and device-supported hand gestures. At the time of writing, XR Interaction Toolkit is focused <a id="_idIndexMarker131"/>on <strong class="bold">Virtual Reality</strong> (<strong class="bold">VR</strong>) applications (evidenced by its Examples project, which contains seven scenes for VR and just one for AR, which only supports mobile AR) but I believe it is a key part of Unity's XR strategy and architecture for the future. If you are interested in XR Interaction Toolkit for VR, check out my other book, <em class="italic">Unity 2020 Virtual Reality Projects – Third Edition</em>, from Packt Publishing.</p>
			<p>Let's get a copy of the AR Foundation Samples project and take a look at the <strong class="bold">SimpleAR</strong> scene.</p>
			<h2 id="_idParaDest-38"><a id="_idTextAnchor040"/>Building and running the Samples project</h2>
			<p>In this section, you are <a id="_idIndexMarker132"/>going to build the <em class="italic">AR Foundation Samples</em> project and run <a id="_idIndexMarker133"/>it on your device. First, please clone the project from its GitHub repository and open it in Unity, as follows: </p>
			<ol>
				<li>Clone a copy of the project from GitHub to your local machine. The project can be found at <a href="https://github.com/Unity-Technologies/arfoundation-samples">https://github.com/Unity-Technologies/arfoundation-samples</a>. Please use whatever cloning method you prefer; for example, GitHub Desktop (<a href="https://desktop.github.com/">https://desktop.github.com/</a>) or the command line (<a href="https://git-scm.com/download/">https://git-scm.com/download/</a>).</li>
				<li>Add the project to <strong class="bold">Unity Hub</strong> by selecting <strong class="bold">Projects | Add</strong>, navigating to the cloned project's root folder, and pressing <strong class="bold">Select Folder</strong>.</li>
				<li>Open the <a id="_idIndexMarker134"/>project in Unity. In the <strong class="bold">Unity Hub</strong> projects list, if <a id="_idIndexMarker135"/>you see a yellow warning icon, then the cloned project's Unity version is not currently installed on your system. Use the <strong class="bold">Unity Version</strong> selection to choose a newer version of the editor that you have, preferably of the same major release (for example, 20XX). </li>
				<li>Open the project by selecting it from the Unity Hub projects list.</li>
				<li>If your version of Unity is newer than the project from when it was last saved, you will see a prompt asking, "<strong class="bold">Do you want to upgrade your project to a newer version of Unity?</strong>." Press <strong class="bold">Confirm</strong>.</li>
			</ol>
			<p>One of the scenes, <strong class="bold">SimpleAR</strong>, is a basic AR example scene. When run, the user will scan their room with their device's camera and the app will detect any horizontal planes that are rendered on the screen. When your user taps on one of these planes, a small red cube will be placed in the environment. You can walk around the room and the cube will remain where it was placed. If you tap again on another location, the cube will be moved there. Let's briefly review this <strong class="bold">SimpleAR</strong> scene's GameObjects:</p>
			<ol>
				<li value="1">Open the <strong class="bold">SimpleAR</strong> scene from the <strong class="bold">Project</strong> window by navigating to the <strong class="source-inline">Scenes/SimpleAR/</strong> folder and double-clicking the <strong class="source-inline">SimpleAR</strong> scene file. </li>
				<li>In the <strong class="bold">Hierarchy</strong> window, you will find two GameObjects of particular interest: <strong class="bold">AR Session</strong> and <strong class="bold">AR Session Origin</strong>. </li>
				<li>Select the <strong class="bold">AR Session Origin</strong> object and examine its components in the <strong class="bold">Inspector</strong> window. These include <strong class="bold">AR Plane Manager</strong>, <strong class="bold">AR Point Cloud Manager</strong>, <strong class="bold">AR Raycast Manager</strong>, and a <strong class="bold">Place On Plane</strong> script. We'll explain all of this later in this chapter. </li>
			</ol>
			<p>Now, let's try to build and run the project:</p>
			<ol>
				<li value="1">Switch to your target platform if necessary. To do this, go to <strong class="bold">File | Build Settings</strong>, choose your device's platform from the <strong class="bold">Platform</strong> list (for example, Android or iOS), and click <strong class="bold">Switch Platform</strong>. </li>
				<li>Most likely, the <a id="_idIndexMarker136"/>cloned project's settings have <a id="_idIndexMarker137"/>already been configured, but let's make sure. From the <strong class="bold">Build Settings</strong> window, click the <strong class="bold">Player Settings</strong> button to open that window and confirm the necessary settings mentioned in <a href="B15145_01_Final_SB_epub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a><em class="italic">, Setting Up for AR Development</em>. For example, Android ARCore does not support Vulcan graphics and needs <strong class="bold">Nougat (API Level 24)</strong> as a minimum requirement.</li>
				<li>In the <strong class="bold">Build Settings</strong> window again, notice that the list of scenes in <strong class="bold">Scenes in Build</strong> starts with the <strong class="bold">Menu</strong> scene and contains all the demo scenes from this project (the first in the list will be the first scene to load when the app loads). You can leave these alone or just pick the one you want in the build. </li>
				<li>Ensure your mobile device is plugged into a USB port on your computer.</li>
				<li>Press the <strong class="bold">Build And Run</strong> button to build the project and install it on your device. It will prompt you for a file folder location; I like to create a folder in my project root, named <strong class="source-inline">Builds/</strong>. Give it a filename (if required) and press <strong class="bold">Save</strong>. It may take a while to complete this task.</li>
			</ol>
			<p>If all goes well, the project will build, be installed on your device, and launch. </p>
			<p>If you encounter errors while building the project, look at the <strong class="bold">Console</strong> window in the Unity Editor for messages (in the default layout, it's a tab behind the <strong class="bold">Project</strong> window). Read the messages carefully, generally starting from the top. If the fix is not obvious, do an internet search for the message's text, as you can be certain you're probably not the first person to have a similar question! </p>
			<p class="callout-heading">Tip – "Failed to generate ARCore reference image library" error</p>
			<p class="callout">If you receive an error when attempting to build the project that says something like <strong class="bold">Failed to generate ARCore reference image library</strong>, please make sure there are no spaces in the pathname of your project folder! See <a href="https://github.com/Unity-Technologies/arfoundation-samples/issues/119">https://github.com/Unity-Technologies/arfoundation-samples/issues/119</a> for more information.</p>
			<p>The <a id="_idIndexMarker138"/>main menu <a id="_idIndexMarker139"/>will be displayed, as shown in the following screen capture (left panel):</p>
			<div>
				<div id="_idContainer023" class="IMG---Figure">
					<img src="Images/Figure_2.01-arf-samples-screenshot-twin.jpg.jpg" alt="Figure 2.1 – Screenshot of my phone running the arfoundation-samples app and SimpleAR scene&#13;&#10;" width="1169" height="1032"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.1 – Screenshot of my phone running the arfoundation-samples app and SimpleAR scene</p>
			<p>A cool thing <a id="_idIndexMarker140"/>about AR Foundation (and this project) is that it <a id="_idIndexMarker141"/>can detect the capabilities of the device it is running on at runtime. This means that the buttons in the main menu will be disabled when AR Foundation detects that the features demoed in that scene are not supported on the device. (The device I'm using in the preceding screen capture is an Android phone, so some iOS-only feature scenes are disabled).</p>
			<p>Click the <strong class="bold">Simple AR</strong> button to open that scene. You should see a camera video feed on your device's screen. Move your phone slowly in different directions and closer/away. As it scans the environment, feature points and planes <a id="_idIndexMarker142"/>will be <a id="_idIndexMarker143"/>detected and rendered on the screen. Tap one of the planes to place a cube on the scene, as shown in the right-hand panel of the preceding screen capture.</p>
			<p>Some of the assets and scripts in the Samples project can be useful for building our own projects. I'll show you how to export them now.</p>
			<h2 id="_idParaDest-39"><a id="_idTextAnchor041"/>Exporting the sample assets for reuse</h2>
			<p>Unity offers the <a id="_idIndexMarker144"/>ability to share assets between projects using <strong class="source-inline">.unitypackage</strong> files. Let's export the assets from the AR Foundation Samples project for reuse. One trick I like to do is move all the sample folders into a root folder first. With the <em class="italic">arfoundation-samples</em> project open in Unity, please perform the following steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, create a new folder under <strong class="source-inline">Assets</strong> named <strong class="source-inline">ARF-samples</strong> by clicking the <strong class="bold">+</strong> icon (top left of the window) and selecting <strong class="bold">Folder</strong>.</li>
				<li>Drag the following folders into the <strong class="source-inline">ARF-samples</strong> one: <strong class="source-inline">Materials</strong>, <strong class="source-inline">Meshes</strong>, <strong class="source-inline">Prefabs</strong>, <strong class="source-inline">Scenes</strong>, <strong class="source-inline">Scripts</strong>, <strong class="source-inline">Shaders</strong>, and <strong class="source-inline">Textures</strong>. That is, move all of them but leave the <strong class="source-inline">XR</strong> folder at the root.</li>
				<li>Right-click on the <strong class="source-inline">ARF-samples</strong> folder and select <strong class="bold">Export Package</strong>.</li>
				<li>The <strong class="bold">Exporting Package</strong> window will open. Click <strong class="bold">Export</strong>.</li>
				<li>Choose a directory outside this project's root, name the file (for example, <strong class="source-inline">arf-samples</strong>), and click <strong class="bold">Save</strong>.</li>
			</ol>
			<p>The <strong class="source-inline">Assets/ARF-samples/</strong> folder in the <strong class="bold">Project</strong> window is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer024" class="IMG---Figure">
					<img src="Images/Figure_2.02-arf-samples-folders.jpg" alt="Figure 2.2 – The Samples assets folder being exported to a .unitypackage file&#13;&#10;" width="334" height="266"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.2 – The Samples assets folder being exported to a .unitypackage file</p>
			<p>You can <a id="_idIndexMarker145"/>close the <strong class="source-inline">arfoundation-samples</strong> project now if you want. You now have an asset package you can use in other projects. </p>
			<p class="callout-heading">Tip – Starting a New Project by Copying the Samples Project</p>
			<p class="callout">An alternative to starting a new Unity AR project from scratch is to duplicate the <em class="italic">arfoundation-samples</em> project as the starting point for new AR projects. To do that, from your Windows Explorer (or macOS Finder), duplicate the entire project folder and then add it to Unity Hub. This way, you get all the example assets and demo scenes in one place, and it's set up with reasonable default project settings. I often do this, especially for quick demos and small projects.</p>
			<p>Next, we are going to import the Samples assets into your Unity project and build the given SimpleAR scene.</p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor042"/>Building the SimpleAR scene in your own project</h1>
			<p>As you will see <a id="_idIndexMarker146"/>later in this chapter, the Samples project includes some assets we can use in your own projects, saving you time and effort, especially at the start. We will import <strong class="source-inline">unitypackage</strong>, which we just exported, and then build the given SimpleAR scene as another test to verify that you're set up to build and run AR applications. </p>
			<h2 id="_idParaDest-41"><a id="_idTextAnchor043"/>Creating a new project</h2>
			<p>If you already have a <a id="_idIndexMarker147"/>Unity project set up for AR development, as detailed in <a href="B15145_01_Final_SB_epub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a><em class="italic">, Setting Up for AR Development</em>, you can open it in Unity and skip this section. If not, perform the following steps, which have been streamlined for your convenience. If you require more details or explanations, please revisit <a href="B15145_01_Final_SB_epub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a><em class="italic">, Setting Up for AR Development</em>.<em class="italic"> </em></p>
			<p>To create and set up a new Unity project with AR Foundation, Universal Render Pipeline, and the new Input System, here are the abbreviated steps:</p>
			<ol>
				<li value="1"><em class="italic">Create a new project</em> by opening <strong class="bold">Unity Hub</strong>, selecting <strong class="bold">Projects | New</strong>, choosing <strong class="bold">Universal Render Pipeline</strong>, specifying a <strong class="bold">Project Name</strong>, such as <strong class="source-inline">MyARProject</strong>, and clicking <strong class="bold">Create</strong>.</li>
				<li><em class="italic">Open your project</em> in the Unity Editor by selecting it from Unity Hub's <strong class="bold">Projects</strong> list. </li>
				<li><em class="italic">Set your target platform</em> by going to <strong class="bold">File | Build Settings</strong>, choosing <strong class="bold">Android</strong> or <strong class="bold">iOS</strong> from the <strong class="bold">Platform</strong> list, and clicking <strong class="bold">Switch Platform</strong>.</li>
				<li><em class="italic">Set up the Player Settings</em> according to <a href="B15145_01_Final_SB_epub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a><em class="italic">, Setting Up for AR Development</em>, and/or your device's documentation by going to the <strong class="bold">Edit | Project Settings | Player</strong> window. For example, Android ARCore does not support Vulcan graphics and needs <strong class="bold">Nougat (API Level 24)</strong> as a minimum requirement. </li>
				<li><em class="italic">Install an XR plugin</em> by going to <strong class="bold">Edit | Project Settings | XR Plugins Manager | Install XR Plugin Management</strong>. Then, check the checkbox for your device's <strong class="bold">Plug-in Provider</strong>.</li>
				<li><em class="italic">Install AR Foundation</em> by going to <strong class="bold">Window | Package Manager</strong>, choosing <strong class="bold">Unity Registry</strong> from the filter list at the top left, searching for <strong class="source-inline">ar</strong> using the search input field, selecting the <strong class="bold">AR Foundation</strong> package, and clicking <strong class="bold">Install</strong>.</li>
				<li><em class="italic">Install the Input System package</em> by going to <strong class="bold">Window | Package Manager</strong>, choosing <strong class="bold">Unity Registry</strong> from the filter list at the top left, searching for <strong class="source-inline">input</strong> using the search input field, selecting the <strong class="bold">Input System</strong> package, and clicking <strong class="bold">Install</strong>.  <p>When prompted to <a id="_idIndexMarker148"/>enable the input backend, you can say <strong class="bold">Yes</strong>, but we'll actually change this setting to <strong class="bold">Both</strong> in the next topic when we import the Sample assets into the project. </p></li>
				<li><em class="italic">Add the AR Background Renderer</em> to the URP Forward renderer by locating the <strong class="bold">ForwardRenderer</strong> data asset, usually in the <strong class="source-inline">Assets/Settings/</strong> folder. In its <strong class="bold">Inspector</strong> window, click <strong class="bold">Add Renderer Feature</strong> and select <strong class="bold">AR Background Renderer Feature</strong>. <em class="italic"> </em></li>
			</ol>
			<p>You might want to bookmark these steps for future reference. Next, we'll import the Sample assets we exported from the AR Foundation Samples project.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor044"/>Importing the Sample assets into your own project</h2>
			<p>Now that you have a <a id="_idIndexMarker149"/>Unity project set up for AR development, you can import the sample assets into your project. With your project open in Unity, perform the following steps:</p>
			<ol>
				<li value="1">Import the package from the main menu by selecting <strong class="bold">Assets | Import Package | Custom Package</strong>.</li>
				<li>Locate the <strong class="source-inline">arf-samples.unitypackage</strong> file on your system and click <strong class="bold">Open</strong>.</li>
				<li>The <strong class="bold">Import Unity Package</strong> window will open. Click <strong class="bold">Import</strong>.</li>
				<li>If you created your project using the <em class="italic">Universal Render Pipeline</em> (or HDRP), rather than using the built-in render pipeline like we did, you need to convert the imported materials. Select <strong class="bold">Edit | Render Pipeline | URP | Upgrade Project Materials to URP Materials</strong>. Then, when prompted, click <strong class="bold">Proceed</strong>. </li>
				<li>Then, go to <strong class="bold">Player Settings</strong> using <strong class="bold">Edit | Project Settings | Player</strong>, select <strong class="bold">Configuration | Active Input Handling</strong>, and choose <strong class="bold">Both</strong>. Then, when prompted, click <strong class="bold">Apply</strong>. </li>
				<li>We will <a id="_idIndexMarker150"/>use the new Input System for projects in this book. However, some demo scenes in the Samples project use the old Input Manager. If you choose <strong class="bold">Input System Package (New)</strong> for <strong class="bold">Active Input Handling</strong>, then those demo scenes may not run.</li>
			</ol>
			<p>Hopefully, all the assets will import without any issues. However, there may be some errors while compiling the Samples scripts. This could happen if the Samples project is using a newer version of AR Foundation than your project and it is referencing API functions for features your project does not have installed. The simplest solution is to upgrade the version of AR Foundation to the same or later version as the Samples project. To do so, perform the following steps:</p>
			<ol>
				<li value="1">To see error messages, open the <strong class="bold">Console</strong> window using its tab or selecting <strong class="bold">Window | General | Console</strong>.</li>
				<li>Suppose that, in my project, I have additional errors because I have installed <em class="italic">AR Foundation 4.0.12</em> but the Samples project uses <em class="italic">version 4.1.3</em> features, which are not available in my version. Here, I'll go to <strong class="bold">Window | Package Manager</strong>, select the <strong class="bold">AR Foundation</strong> package, click <strong class="bold">See Other Versions</strong>, select the 4.1.3 version, and then click the <strong class="bold">Update to 4.1.3</strong> button.</li>
				<li>The project also might be using preview versions of packages. Enable preview packages by selecting <strong class="bold">Edit | Project Settings | Package Manager | Enable preview packages</strong>.</li>
				<li>Ensure the ARCore XR plugin and/or AR Kit XR plugin version matches the version of the AR Foundation package the project is using.</li>
				<li>Another message you might see is that some Samples scripts require that you enable "unsafe" code in the project. Go to <strong class="bold">Project Settings | Player | Script Compilation | Allow 'unsafe' code</strong> and check the checkbox.<p>This is <a id="_idIndexMarker151"/>not as threatening as it may sound. "Unsafe" code usually means that something you installed is calling C++ code from the project that is <em class="italic">potentially</em> unsafe from the compiler's point of view. Enabling unsafe code in Unity is usually not a problem unless, for example, you are publishing WebGL to a WebPlayer, which we are not.</p></li>
			</ol>
			<p>Finally, you can verify your setup by building and running the SimpleAR scene, this time from your own project. Perform the following steps:</p>
			<ol>
				<li value="1">Open the <strong class="bold">SimpleAR</strong> scene from the <strong class="bold">Project</strong> window by navigating to the <strong class="source-inline">ARF-samples/Scenes/SimpleAR/</strong> folder and double-clicking the <strong class="bold">SimpleAR</strong> scene file.</li>
				<li>Open the <strong class="bold">Build Settings</strong> window by going to <strong class="bold">File | Build Settings</strong>.</li>
				<li>For the <strong class="bold">Scenes in Build</strong> list, click the <strong class="bold">Add Open Scenes</strong> button and uncheck all the scenes in the list other than the SimpleAR one.</li>
				<li>Ensure your device is connected via USB.</li>
				<li>Press the <strong class="bold">Build And Run</strong> button to build the project and install it on your device. It will prompt you for a location; I like to create a folder in my project root named <strong class="source-inline">Builds/</strong>. Give it a filename (if required) and press <strong class="bold">Save</strong>. It may take a while to complete this task.</li>
			</ol>
			<p>The app should successfully build and run on your device. If you encounter any errors, please review each of the steps detailed in this chapter and <a href="B15145_01_Final_SB_epub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a><em class="italic">, Setting Up for AR Development</em>. </p>
			<p>When the app launches, as described earlier, you should see a camera video feed on your screen. Move <a id="_idIndexMarker152"/>your phone slowly in different directions and closer/away. As it scans the environment, feature points and planes will be detected and rendered on the screen. Tap one of these planes to place a cube on the scene.</p>
			<p>Your project is now ready for AR development! </p>
			<h1 id="_idParaDest-43"><a id="_idTextAnchor045"/>Starting a new, basic AR scene</h1>
			<p>In this section, we'll create a scene very similar to <strong class="source-inline">SimpleAR</strong> (actually, more like the Samples scene named <strong class="source-inline">InputSystem_PlaceOnPlane</strong>) but we will start with a new empty scene. We'll add AR Session and AR Session Origin objects provided by AR Foundation to the scene hierarchy, and then add trackable feature managers for planes and point clouds. In the subsequent sections of this chapter, we'll set up an Input System action controller, write a C# script to handle any user interaction, and create a prefab 3D graphic to place in the scene. </p>
			<p>So, start the <a id="_idIndexMarker153"/>new scene by performing the following steps:</p>
			<ol>
				<li value="1">Create a new scene by going to <strong class="bold">File | New Scene</strong>.</li>
				<li>If prompted, choose the <strong class="bold">Basic (Built-in)</strong> template. Then, click <strong class="bold">Create</strong>.<p>Unity allows you to use a Scene template when creating a new scene. The one named <strong class="bold">Basic (Built-in)</strong> is comparable to the default new scene in previous versions of Unity. </p></li>
				<li>Delete <strong class="bold">Main Camera</strong> from the <strong class="bold">Hierarchy</strong> window by using <em class="italic">right-click </em>| <strong class="bold">Delete</strong> (or the <em class="italic">Del</em> key on your keyboard). </li>
				<li>Add an AR Session by selecting <strong class="bold">GameObject</strong> from the main menu, then <strong class="bold">XR | AR Session</strong>.</li>
				<li>Add an AR Session Origin by selecting <strong class="bold">GameObject</strong> from the main menu, then <strong class="bold">XR | AR Session Origin</strong>.</li>
				<li>Unfold <strong class="bold">AR Session Origin</strong> and select its child; that is, <strong class="bold">AR Camera</strong>. In the <strong class="bold">Inspector</strong> window, use the <strong class="bold">Tag</strong> selector at the top left to set it as our <strong class="bold">MainCamera</strong>. (This is not required but it is a good practice to have one camera in the scene tagged as <strong class="bold">MainCamera</strong>.)</li>
				<li>Save the <a id="_idIndexMarker154"/>scene using <strong class="bold">File | Save As</strong>, navigate to the <strong class="source-inline">Assets/Scenes/</strong> folder, name it <strong class="source-inline">BasicARScene</strong>, and click <strong class="bold">Save</strong>.</li>
			</ol>
			<p>Your scene Hierarchy should now look as follows:</p>
			<div>
				<div id="_idContainer025" class="IMG---Figure">
					<img src="Images/Figure_2.03-starting-hierarchy.jpg" alt="Figure 2.3 – Starting a scene Hierarchy&#13;&#10;" width="257" height="137"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.3 – Starting a scene Hierarchy</p>
			<p>We can now take a closer look at the objects we just added, beginning with the AR Session object.</p>
			<h2 id="_idParaDest-44"><a id="_idTextAnchor046"/>Using AR Session</h2>
			<p>The <strong class="bold">AR Session</strong> object is <a id="_idIndexMarker155"/>responsible for enabling and disabling <a id="_idIndexMarker156"/>augmented reality features on the target platform. When you select the <strong class="bold">AR Session</strong> object in your scene <strong class="bold">Hierarchy</strong>, you can see its components in the <strong class="bold">Inspector</strong> window, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer026" class="IMG---Figure">
					<img src="Images/Figure_2.04-arsession-inspector.jpg" alt="Figure 2.4 – The AR Session object's Inspector window&#13;&#10;" width="552" height="398"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.4 – The AR Session object's Inspector window</p>
			<p>Each AR scene <a id="_idIndexMarker157"/>must include one (and only one) AR Session. It <a id="_idIndexMarker158"/>provides several options. Generally, you can leave these as their default values.</p>
			<p>The <strong class="bold">Attempt Update</strong> option instructs the AR Session to try and install the underlying AR support software on the device if it is missing. This is not required for all devices. iOS, for example, does not require any additional updates if the device supports AR. On the other hand, to run AR apps on Android, the device must have the ARCore services installed. Most AR apps will do this for you if they are missing, and that is what the <strong class="bold">Attempt Update</strong> feature of <strong class="bold">AR Session</strong> does. If necessary, when your app launches and support is missing or needs an update, AR Session will attempt to install <em class="italic">Google Play Services for AR</em> (see <a href="https://play.google.com/store/apps/details?id=com.google.ar.core">https://play.google.com/store/apps/details?id=com.google.ar.core</a>). If the required software is not installed, then AR will not be available on the device. You could choose to disable automatic updates and implement them yourself to customize the user onboarding experience.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">The <strong class="bold">Match Frame Rate</strong> option in the <strong class="bold">Inspector</strong> window is obsolete. Ordinarily, you would want the frame updates of your apps to match the frame rate of the physical device, and generally, there is no need to tinker with this. If you need to tune it, you should control it via scripting (see <a href="https://docs.unity3d.com/ScriptReference/Application-targetFrameRate.html">https://docs.unity3d.com/ScriptReference/Application-targetFrameRate.html</a>).</p>
			<p>Regarding <strong class="bold">Tracking Mode</strong>, you will generally leave it set to <strong class="bold">Position and Rotation</strong>, as this specifies that your VR device is tracking in the physical world 3D space using both its XYZ position and its <a id="_idIndexMarker159"/>rotation around each axis. This is <a id="_idIndexMarker160"/>referred to as <em class="italic">6DOF</em>, for six-degrees-of-freedom tracking, and is probably the behavior that you expect. But for face tracking, for example, we should set it to <strong class="bold">Rotation Only</strong>, as you'll see in <a href="B15145_09_Final_SB_epub.xhtml#_idTextAnchor224"><em class="italic">Chapter 9</em></a><em class="italic">, Selfies: Making Funny Faces</em>.</p>
			<p>The <strong class="bold">AR Session</strong> GameObject also has an <strong class="bold">AR Input Manager</strong> component that manages our <strong class="bold">XR Input Subsystem</strong> for tracking the device's pose in a physical 3D space. It reads input from the AR Camera's <strong class="bold">AR Pose Driver</strong> (discussed shortly). There are no options for the component, but this is required for device tracking.</p>
			<p>We also added an AR Session Origin GameObject to the Hierarchy. Let's look at that next.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor047"/>Using AR Session Origin</h2>
			<p>The <strong class="bold">AR Session Origin</strong> will be <a id="_idIndexMarker161"/>the root object <a id="_idIndexMarker162"/>of all trackable objects. Having a root origin keeps the Camera and any trackable objects in the same space and their positions relative to each other. This <em class="italic">session</em> (or <em class="italic">device) space</em> includes the AR Camera and any <em class="italic">trackable</em> features that have been detected in the real-world environment by the AR software. Otherwise, detected features, such as planes, won't appear in the correct place relative to the Camera. </p>
			<p class="callout-heading">Tip – Scaling Virtual Scenes in AR</p>
			<p class="callout">If you plan to scale your AR scene, place your game objects as children of AR Session Origin and then scale the parent AR Session Origin transform, rather than the child objects themselves. For example, consider a world-scale city map or game court resized to fit on a tabletop. Don't scale the individual objects in the scene; instead, scale everything by resizing the root session origin object. This will ensure the other Unity systems, especially physics and particles, retain their scale relative to the camera space. Otherwise, things such as gravity, calculated as meters per second, and particle rendering could mess up.</p>
			<p>When you <a id="_idIndexMarker163"/>select the <strong class="bold">AR Session Origin</strong> object in <a id="_idIndexMarker164"/>your scene <strong class="bold">Hierarchy</strong>, you can see its components in the <strong class="bold">Inspector</strong> window, as shown in the following screenshot:</p>
			<div>
				<div id="_idContainer027" class="IMG---Figure">
					<img src="Images/Figure_2.05-arsessionorigin-inspector.jpg" alt="Figure 2.5 – The AR Session object's Inspector window&#13;&#10;" width="558" height="310"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.5 – The AR Session object's Inspector window</p>
			<p>At the time of writing, the default AR Session Origin object simply has an <strong class="bold">AR Session Origin</strong> component. We'll want to build out its behavior by adding more components in a moment.</p>
			<p>The Session Origin's <strong class="bold">Camera</strong> property references its own child <strong class="bold">AR Camera</strong> GameObject, which we'll look at next. </p>
			<h2 id="_idParaDest-46"><a id="_idTextAnchor048"/>Using the AR Camera</h2>
			<p>The <strong class="bold">AR Camera</strong> object is a <a id="_idIndexMarker165"/>child of <a id="_idIndexMarker166"/>AR Session Origin. Its <strong class="bold">Inspector</strong> window is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer028" class="IMG---Figure">
					<img src="Images/Figure_2.06-arcamera-inspector.jpg" alt="Figure 2.6 – The AR Camera object's Inspector window&#13;&#10;" width="811" height="686"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.6 – The AR Camera object's Inspector window</p>
			<p>During setup, we tagged the AR Camera as our <strong class="bold">MainCamera</strong>. This is not required but it is a good practice to have one camera in the scene tagged as MainCamera, for example, for any code that may use <strong class="source-inline">Camera.main</strong>, which is a shortcut for the find by tag name.</p>
			<p>As its name implies, the AR Camera object includes a <strong class="bold">Camera</strong> component, required in all Unity scenes, which determines what objects to render on your screen. The AR one has mostly default values. The <strong class="bold">Near</strong> and <strong class="bold">Far Clipping</strong> planes have been adjusted for typical AR applications to (<strong class="source-inline">0.1, 20</strong>) meters. In AR apps, it's not unusual to place the device within inches of a virtual object, so we wouldn't want it to be clipped. Conversely, in an AR app, if you walk more than 20 meters away from an object that you've placed in the scene, you probably don't need it to be rendered at all. </p>
			<p>Importantly, rather <a id="_idIndexMarker167"/>than using a Skybox, as you'd expect in non-AR scenes, the <a id="_idIndexMarker168"/>camera's <strong class="bold">Background</strong> is set to a <strong class="bold">Solid</strong> black color. This means the background will be rendered using the camera's video feed. This is controlled using the <strong class="bold">AR Camera Background</strong> component of the AR Camera. In an advanced application, you can even customize how the video feed is rendered, using a custom video <em class="italic">material</em> (this topic is outside the scope of this book). Similarly, on a wearable AR device, a black camera background is required, but with no video feed, to mix your virtual 3D graphics atop the visual see-through view.</p>
			<p>The video feed source is controlled using the AR Camera Manager component. You can see, for example, that <strong class="bold">Facing Direction</strong> can be changed from <strong class="bold">World</strong> to <strong class="bold">User</strong> for a selfie face tracking app (see <a href="B15145_09_Final_SB_epub.xhtml#_idTextAnchor224"><em class="italic">Chapter 9</em></a><em class="italic">, Selfies: Making Funny Faces</em>). </p>
			<p>The <strong class="bold">Light Estimation</strong> options are used when you want to emulate real-world lighting when rendering your virtual objects. We'll make use of this feature later in this chapter. </p>
			<p>You also have the option to disable <strong class="bold">Auto Focus</strong> if you find that the camera feature is inappropriate for your AR application. </p>
			<p class="callout-heading">Tip – When to Disable Camera Auto Focus for AR</p>
			<p class="callout">Ordinarily, I disable Auto Focus for AR applications. When the software uses the video feed to help detect planes and other features in the environment, it needs a clear, consistent, and detailed video feed, not one that may be continually changing for Auto Focus. That would make it difficult to process AR-related algorithms accurately to decode their tracking. On the other hand, a selfie face tracking app may be fine with Auto Focus enabled and could improve the user experience when the area behind the user loses focus due to depth of field.</p>
			<p>The <strong class="bold">AR Pose Driver</strong> component is responsible for updating the AR Camera's transform as it tracks the device in the real world. (There are similar components for VR headsets and hand controllers, for instance.) This component relies on the XR plugin and the Input XR Subsystem to supply the positional tracking data (see <a href="https://docs.unity3d.com/Manual/XRPluginArchitecture.html">https://docs.unity3d.com/Manual/XRPluginArchitecture.html</a>). </p>
			<p>Our <a id="_idIndexMarker169"/>next step is to <a id="_idIndexMarker170"/>add Plane and Point Cloud visualizers to the scene.</p>
			<h2 id="_idParaDest-47"><a id="_idTextAnchor049"/>Adding Plane and Point Cloud managers</h2>
			<p>When your <a id="_idIndexMarker171"/>application runs, you'll ask the user to scan the <a id="_idIndexMarker172"/>room for the AR software to <a id="_idIndexMarker173"/>detect features in the environment, such as <a id="_idIndexMarker174"/>depth points and flat planes. Usually, you'll want to show these to the user as they're detected. We do this by adding the corresponding feature managers to the AR Session Origin game object. For example, to visualize planes, you'll add an <strong class="bold">AR Plane Manager</strong> to the AR Session Origin object, while to visualize point clouds, you'll add an <strong class="bold">AR Point Cloud Manager</strong>.</p>
			<p>AR Foundation supports detecting and tracking the following features:</p>
			<ul>
				<li><em class="italic">Anchor</em>: A fixed pose (consisting of location and rotation) in the physical environment (controlled by the AR Anchor Manager component). This is also known as a Reference Point.</li>
				<li><em class="italic">Reflection Probe</em>: Environment reflection probes for rendering shiny surface materials (controlled by the AR Environment Probe Manager component).</li>
				<li><em class="italic">Face</em>: A human face detected by the AR device (controlled by the AR Face Manager component).</li>
				<li><em class="italic">Human Body</em>: A trackable human body and the body's skeleton (controlled by the AR Human Body Manager component).</li>
				<li><em class="italic">Image</em>: A 2D image that has been detected and tracked in the environment's AR Tracked Image Manager component.</li>
				<li><em class="italic">Participant</em>: Another user (device) in a collaborative session.</li>
				<li><em class="italic">Plane</em>: A flat plane, usually horizontally or vertically inferred from the point cloud (controlled by the AR Plane Manager component).</li>
				<li><em class="italic">Point Cloud</em>: A set of depth points detected by the AR device (controlled by the AR Point Cloud Manager component).</li>
				<li><em class="italic">Object</em>: A 3D object detected and tracked in the environment (controlled by the AR Tracked Object Manager component).</li>
			</ul>
			<p>Not all of these are <a id="_idIndexMarker175"/>supported on every platform. See the <a id="_idIndexMarker176"/>documentation for your <a id="_idIndexMarker177"/>current version <a id="_idIndexMarker178"/>of AR Foundation (for example, visit <a href="mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/index.html#platform-support">https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/index.html#platform-support</a> and select your version at the top left). We will be using many of these in various projects throughout this book. Here, we will use the Plane and Point Cloud trackables. Please perform the following steps to add them:</p>
			<ol>
				<li value="1">Select the <strong class="bold">AR Session Origin</strong> object from the <strong class="bold">Hierarchy</strong> window.</li>
				<li>Add a Point Cloud Manager by selecting <strong class="bold">Add Component</strong>, searching for <strong class="source-inline">ar</strong> in the search input field, then clicking <strong class="bold">AR Point Cloud Manager</strong>.</li>
				<li>Add a Plane Manager by selecting <strong class="bold">Add Component</strong>, searching for <strong class="source-inline">ar</strong> in the search input field, and clicking <strong class="bold">AR Plane Manager</strong>.</li>
				<li>On the AR Plane Manager, change <strong class="bold">Detection Mode</strong> to only horizontal planes by selecting <strong class="bold">Nothing</strong> (to clear the list), then selecting <strong class="bold">Horizontal</strong>.</li>
			</ol>
			<p>You'll notice that the Point Cloud Manager has an empty slot for the Point Cloud Prefab visualizer and that the Plane Manager has an empty slot for the Plane Prefab visualizer. We'll use prefabs from the Samples project, as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Inspector</strong> window, go to <strong class="bold">AR Point Cloud Manager | Point Cloud Prefab</strong> and press the <em class="italic">doughnut</em> icon on the right-hand side of the field to open the <strong class="bold">Select GameObject</strong> dialog box.</li>
				<li>Click the <strong class="bold">Assets</strong> tab and double-click the <strong class="bold">AR Point Cloud Visualizer</strong> prefab.<p>There are alternative point cloud visualizer prefabs you might like to try out also, such as <strong class="bold">AR Point Cloud Debug Visualizer</strong> and <strong class="bold">AllPointCloudPointsPrefab</strong>.</p></li>
				<li>Likewise, for <strong class="bold">AR Plane Manager | Plane Prefab</strong>, press the <em class="italic">doughnut</em> icon on the right-hand side of the field to open the <strong class="bold">Select GameObject</strong> dialog box.</li>
				<li>Click the <strong class="bold">Assets</strong> tab and double-click <strong class="bold">AR Feathered Plane</strong>.<p>There are alternative plane visualizer prefabs to try out also, such as <strong class="bold">AR Plane Debug Visualizer</strong>, <strong class="bold">AR Feathered Plane Fade</strong>, and <strong class="bold">CheckeredPlane</strong>.</p></li>
				<li>Save the scene by going to <strong class="bold">File | Save</strong>.</li>
			</ol>
			<p>We're using the <a id="_idIndexMarker179"/>visualizer prefabs we got from the <a id="_idIndexMarker180"/>Samples project. Later in this chapter, we'll <a id="_idIndexMarker181"/>talk more about prefabs, take a <a id="_idIndexMarker182"/>closer look at the visualizer ones, and learn how to edit them to make our own custom visualizers. First, we'll add the AR Raycast Manager to the scene.</p>
			<h2 id="_idParaDest-48"><a id="_idTextAnchor050"/>Adding AR Raycast Manager</h2>
			<p>There's another <a id="_idIndexMarker183"/>component I know we're going to <a id="_idIndexMarker184"/>need soon, known as <strong class="bold">AR Raycast Manager</strong>. This will be used by our scripts to determine if a user's screen touch corresponds to a 3D trackable feature detected by the AR software. We're going to use it in our script to place an object on a plane. Perform the following steps to add it to the scene:</p>
			<ol>
				<li value="1">Select the <strong class="bold">AR Session Origin</strong> object from the <strong class="bold">Hierarchy</strong> window.</li>
				<li>Select <strong class="bold">Add Component |</strong> search for <strong class="source-inline">ar</strong> in the search input field, and click <strong class="bold">AR Raycast Manager</strong>.</li>
			</ol>
			<p>The <strong class="bold">AR Session Origin</strong> GameObject with the manager components we added now looks like this in the <strong class="bold">Inspector</strong> window:</p>
			<div>
				<div id="_idContainer029" class="IMG---Figure">
					<img src="Images/Figure_2.07-arorigin-withmanagers.jpg" alt="" width="870" height="498"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.7 – AR Session Origin with various manager components</p>
			<p>One more <a id="_idIndexMarker185"/>thing that's handy to include is <a id="_idIndexMarker186"/>light estimation, which helps with rendering your virtual objects more realistically.</p>
			<h2 id="_idParaDest-49"><a id="_idTextAnchor051"/>Adding Light Estimation</h2>
			<p>By adding a <a id="_idIndexMarker187"/>Light Estimation component to your <a id="_idIndexMarker188"/>Directional Light source, the AR camera can use this information when rendering your scene to try and match the scene's lighting more closely to the real-world environment.</p>
			<p>To add light estimation, perform the following steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">Directional Light</strong> object.</li>
				<li>In the <strong class="bold">Inspector</strong>, click <strong class="bold">Add Component</strong>, search for <strong class="source-inline">light estimation</strong>, and add the <strong class="bold">Basic Light Estimation</strong> component.</li>
				<li>In the <strong class="bold">Hierarchy</strong> window, find <strong class="bold">AR Camera</strong> (child of AR Session Origin), drag it into the <strong class="bold">Inspector</strong> window, and drop it onto the <strong class="bold">Light Estimation | Camera Manager</strong> slot.</li>
				<li>In the <strong class="bold">Hierarchy</strong> window, select <strong class="bold">AR Camera</strong>, then set <strong class="bold">AR Camera Manager | Light Estimation</strong> to <strong class="bold">Everything</strong>. Note that not all platforms support all light estimation capabilities, but using the <strong class="bold">Everything</strong> flags will have them use all of the ones that are available at runtime.</li>
				<li>Save your work by going to <strong class="bold">File | Save</strong>.</li>
			</ol>
			<p>Good! I think we <a id="_idIndexMarker189"/>should try to build and run what we <a id="_idIndexMarker190"/>have done so far and make sure it's working.</p>
			<h2 id="_idParaDest-50"><a id="_idTextAnchor052"/>Building and running the scene</h2>
			<p>Currently, the scene initializes an <a id="_idIndexMarker191"/>AR Session, enables the AR camera to <a id="_idIndexMarker192"/>scan the environment, detects points and horizontal planes, and renders these on the screen using visualizers. Let's build the scene and make sure it runs:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Build Settings</strong> window by going to <strong class="bold">File | Build Settings</strong>.</li>
				<li>For the <strong class="bold">Scenes in Build</strong> list, click the <strong class="bold">Add Open Scenes</strong> button and uncheck all the scenes in the list other than this current scene (mine is named <strong class="bold">BasicARScene</strong>).</li>
				<li>Ensure your device is connected to your computer via USB.</li>
				<li>Press the <strong class="bold">Build And Run</strong> button to build the project and install it on your device. It will prompt you for a location; I like to create a folder in my project root named <strong class="source-inline">Builds/</strong>. Give it a filename (if required) and press <strong class="bold">Save</strong>. It may take a while to complete this task.</li>
			</ol>
			<p>The app should successfully build and run on your device. If you encounter any errors, please read the error messages carefully in the <strong class="bold">Console</strong> window. Then, review each of the setup steps detailed in this chapter and <a href="B15145_01_Final_SB_epub.xhtml#_idTextAnchor013"><em class="italic">Chapter 1</em></a><em class="italic">, Setting Up for AR Development</em>. </p>
			<p>When the app launches, you should see a video feed on your screen. Move the device slowly in different directions and closer/away. As it scans the environment, feature points and planes will be <a id="_idIndexMarker193"/>detected and rendered on the screen using the <a id="_idIndexMarker194"/>visualizers you chose.</p>
			<p>Next, let's add the ability to tap on one of the planes to instantiate a 3D object there.</p>
			<h1 id="_idParaDest-51"><a id="_idTextAnchor053"/>Placing an object on a plane</h1>
			<p>We will now add the <a id="_idIndexMarker195"/>ability for the user to tap on a plane and place a 3D virtual object in the scene. There are several parts to implementing this:</p>
			<ul>
				<li>Setting up a Place Object input action when the user taps the screen. </li>
				<li>Writing a PlaceObjectOnPlane script that responds to the input action and places an object on the plane.</li>
				<li>Determining which plane and where to place the object using AR Raycast Manager.</li>
				<li>Importing a 3D model and making it a prefab for placing in this scene. </li>
			</ul>
			<p>Let's begin by creating an input action for a screen tap.</p>
			<h2 id="_idParaDest-52"><a id="_idTextAnchor054"/>Setting up a PlaceObject input action</h2>
			<p>We are going to <a id="_idIndexMarker196"/>use the <a id="_idIndexMarker197"/>Unity Input System package for user input. If the Input System is new to you, the steps in this section may seem complicated, but only because of its great versatility. </p>
			<p>The Input System lets you define <strong class="bold">Actions</strong> that separate the logical meaning of the input from the physical means of the input. Using named actions is more meaningful to the application and programmers. </p>
			<p class="callout-heading">Note – Input System Tutorial</p>
			<p class="callout">For a more complete tutorial on using the Input System package, see <a href="https://learn.unity.com/project/using-the-input-system-in-unity">https://learn.unity.com/project/using-the-input-system-in-unity</a>.</p>
			<p>Here, we will <a id="_idIndexMarker198"/>define a <strong class="bold">PlaceObject</strong> action that is bound to screen tap input data. We'll set this up now, and then <a id="_idIndexMarker199"/>use this input action in the next section to find the AR plane that was tapped and place a virtual object there. </p>
			<p>Before we begin, I will assume you have already imported the <strong class="bold">Input System</strong> package via <strong class="bold">Package Manager</strong> and set <strong class="bold">Active Input Handing</strong> to <strong class="bold">Input System Package</strong> (or <strong class="bold">Both</strong>) in <strong class="bold">Player Settings</strong>. Now, follow these steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, create a new folder named <strong class="source-inline">Inputs</strong> using <em class="italic">right-click</em> <strong class="bold">| Create | Folder</strong> (or use the <strong class="bold">+</strong> button at the top left of the window). I put mine under my <strong class="source-inline">_App/</strong> folder.</li>
				<li>Create an input action controller asset by <em class="italic">right-clicking</em> inside the <strong class="source-inline">Inputs</strong> folder, then selecting <strong class="bold">Create | Input Actions</strong> (or using the <strong class="bold">+</strong> button at the top left of the window). Rename it <strong class="source-inline">AR Input Actions</strong>.</li>
				<li>Click <strong class="bold">Edit Asset</strong> to open its editor window.</li>
				<li>In the leftmost <strong class="bold">Action Maps</strong> panel, click the <strong class="bold">+</strong> button and name the new map <strong class="source-inline">ARTouchActions</strong>.</li>
				<li>In the middle <strong class="bold">Actions</strong> panel, rename the default action to <strong class="source-inline">PlaceObject</strong> using <em class="italic">right-click</em> | <strong class="bold">Rename</strong>.</li>
				<li>In the right-hand side <strong class="bold">Properties</strong> panel, set <strong class="bold">Action Type</strong> to <strong class="bold">Value</strong>.</li>
				<li>Set its <strong class="bold">Control Type</strong> to <strong class="bold">Vector 2</strong>.</li>
				<li>In the middle <strong class="bold">Actions</strong> panel, click the child <strong class="bold">&lt;No Binding&gt;</strong> item to add a binding.</li>
				<li>In the right-hand side <strong class="bold">Properties</strong> panel, under <strong class="bold">Binding</strong>, using the <strong class="bold">Path</strong> select list, choose <strong class="bold">TouchScreen | Primary Touch | Position</strong>.</li>
				<li>At the top of the window, click <strong class="bold">Save Asset</strong> (unless the <strong class="bold">Auto-Save</strong> checkbox is checked).</li>
			</ol>
			<p>With that, we've <a id="_idIndexMarker200"/>created a data asset named <strong class="bold">AR Input Actions</strong> that contains an action map named <strong class="bold">ARTouchActions</strong>, which has one action, <strong class="bold">PlaceObject</strong>, that detects a screen touch. It returns <a id="_idIndexMarker201"/>the touch position as a 2D vector (<strong class="source-inline">Vector2</strong>) with the X, Y values in pixel coordinates. The input action asset is shown in the following screenshot:</p>
			<div>
				<div id="_idContainer030" class="IMG---Figure">
					<img src="Images/Figure_2.08-ar-input-action.jpg" alt="Figure 2.8 – Our AR Input Actions set up for screen taps&#13;&#10;" width="792" height="251"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.8 – Our AR Input Actions set up for screen taps</p>
			<p>Now, we can add the input actions to the scene. This can be done via a Player Input component. For our AR scene, we'll add a Player Input component to the AR Session Origin, as follows:</p>
			<ol>
				<li value="1">In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">AR Session Origin</strong> object.</li>
				<li>In its <strong class="bold">Inspector</strong> window, click <strong class="bold">Add Component | Input | Player Input</strong>.</li>
				<li>From the <strong class="bold">Project</strong> window, drag the <strong class="bold">AR Input Actions</strong> asset from your <strong class="source-inline">Inputs/</strong> folder into <a id="_idIndexMarker202"/>the <strong class="bold">Player Input | Actions</strong> slot in the <strong class="bold">Inspector</strong> window.</li>
				<li>Leave <strong class="bold">Behavior</strong> set <a id="_idIndexMarker203"/>to <strong class="bold">Send Messages</strong>.<p class="callout-heading">Information – Input System Behavior Types</p><p class="callout">Unity and C# provide different ways for objects to signal other objects. The Player Input component lets you choose how you want input actions to be communicated, via its <strong class="bold">Behavior</strong> setting. The options are as follows:</p><p class="callout"><em class="italic">Send Messages</em>: Will send action messages to any components on the <em class="italic">same</em> GameObject (<a href="https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html">https://docs.unity3d.com/ScriptReference/GameObject.SendMessage.html</a>). As we'll see, your message handler must be named with the "<strong class="source-inline">On</strong>" prefix (for example, <strong class="source-inline">OnPlaceObject</strong>) and receives an <strong class="source-inline">InputValue</strong> argument (<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputValue.html">https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputValue.html</a>).  </p><p class="callout"><em class="italic">Broadcast Messages</em>: Like Send Messages, Broadcast Messages will send messages to components on this GameObject <em class="italic">and all its children</em> (<a href="https://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html">https://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html</a>). </p><p class="callout"><em class="italic">Invoke Unity Events</em>: You can set event callback functions using the Inspector or in scripts (<a href="https://docs.unity3d.com/Manual/UnityEvents.html">https://docs.unity3d.com/Manual/UnityEvents.html</a>). The callback function receives an <strong class="source-inline">InputAction.CallbackContext</strong> argument (<a href="https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputAction.CallbackContext.html)">https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputAction.CallbackContext.html)</a>.</p><p class="callout"><em class="italic">Invoke C# Events</em>: You can set event listeners in scripts (<a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/">https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/</a>). </p><p class="callout">To learn more about the Player Input component, see <a href="mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/api/UnityEngine.InputSystem.PlayerInput.html">https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/api/UnityEngine.InputSystem.PlayerInput.html</a>. </p></li>
			</ol>
			<p>I've decided <a id="_idIndexMarker204"/>to use <strong class="bold">Send Messages</strong> here, so we'll <a id="_idIndexMarker205"/>need to write a script with an <strong class="source-inline">OnPlaceObject</strong> function, which we'll do next. But first, I'll provide a quick introduction to Unity C# programming.</p>
			<h2 id="_idParaDest-53"><a id="_idTextAnchor055"/>Introducing Unity C# programming and the MonoBehaviour class</h2>
			<p>Writing C# scripts is an <a id="_idIndexMarker206"/>essential skill for every Unity developer. You don't need to be an expert programmer, but you cannot avoid writing some code to make <a id="_idIndexMarker207"/>your projects work. If you are new to coding, you can simply follow the instructions provided here, and over time, you'll get more comfortable and proficient. I also encourage you to go through some of the great beginner tutorials provided by Unity (<a href="https://learn.unity.com/">https://learn.unity.com/</a>) and others, including the following:</p>
			<ul>
				<li><strong class="bold">Coding in C# in Unity for Beginners</strong>: https://unity3d.com/learning-c-sharp-in-unity-for-beginners</li>
				<li><strong class="bold">Working with Scripts</strong>: <a href="https://learn.unity.com/tutorial/working-with-scripts">https://learn.unity.com/tutorial/working-with-scripts</a></li>
				<li><strong class="bold">Beginner Scripting</strong>: https://learn.unity.com/project/beginner-gameplay-scripting</li>
			</ul>
			<p>Given that, I will offer some brief explanations as we work through this section. But I'll assume that you have at least a basic understanding of C# language syntax, common programming vocabulary (for example, <em class="italic">class</em>, <em class="italic">variable</em>, and <em class="italic">function</em>), using an editor such as Visual Studio, and how to read error messages that may appear in your <strong class="bold">Console</strong> window due to typos or other common coding mistakes. </p>
			<p>We're going to create a new script named <strong class="source-inline">PlaceObjectOnPlane</strong>. Then, we can attach this script as a component to a GameObject in the scene. It will then appear in the object's <strong class="bold">Inspector</strong> window. Let's begin by performing the following steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, locate your <strong class="source-inline">Scripts/</strong> folder (mine is <strong class="source-inline">Assets/_App/Scripts/</strong>), <em class="italic">right-click</em> it, and select <strong class="bold">Create | C# Script</strong>.</li>
				<li>Name the file <strong class="source-inline">PlaceObjectOnPlane</strong> (no spaces nor other special characters are allowed in the name, and it should start with a capital letter). <p>This creates a new C# script with the <strong class="source-inline">.cs</strong> file extension (although you don't see the extension in the <strong class="bold">Project</strong> window).</p></li>
				<li>Double-click the <strong class="bold">PlaceObjectOnPlane</strong> file to open it in your code editor. By default, my system uses Microsoft Visual Studio.</li>
			</ol>
			<p>As you can see in the <a id="_idIndexMarker208"/>following initial script content of the template, the <strong class="source-inline">PlaceObjectOnPlane.cs</strong> file declares a C# class, <strong class="source-inline">PlaceObjectsOnPlane</strong>, that <a id="_idIndexMarker209"/>has the same name as the <strong class="source-inline">.cs</strong> file (the names <em class="italic">must</em> match; otherwise, it will cause compile errors in Unity):</p>
			<p class="source-code">using System.Collections;</p>
			<p class="source-code">using System.Collections.Generic;</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code">public class PlaceObjectOnPlane : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    // Start is called before the first frame update</p>
			<p class="source-code">    void Start()</p>
			<p class="source-code">    { </p>
			<p class="source-code">    }</p>
			<p class="source-code">    // Update is called once per frame</p>
			<p class="source-code">    void Update()</p>
			<p class="source-code">    { </p>
			<p class="source-code">    }</p>
			<p class="source-code">}</p>
			<p>The first three lines in this script have a <strong class="source-inline">using</strong> directive, which declares an SDK library, or namespace, that will be used in the script. When a script references external symbols, the compiler needs to know where to find them. In this case, we're saying that we'll potentially be using standard .NET system libraries for managing sets of objects (<em class="italic">collections</em>). And here, we are using the UnityEngine API.</p>
			<p>One of the symbols defined by <em class="italic">UnityEngine</em> is the <strong class="bold">MonoBehaviour</strong> class. You can see that our <strong class="source-inline">PlaceObjectsOnPlane</strong> class is <a id="_idIndexMarker210"/>declared as a subclass of <strong class="source-inline">MonoBehaviour</strong>. (Beware its British spelling, "iour"). Scripts attached to a GameObject in your scene must be a subclass of <strong class="source-inline">MonoBehaviour</strong>, which provides a litany of features and services related to the GameObject where it is attached.</p>
			<p>For one, <strong class="source-inline">MonoBehaviour</strong> provides hooks into the GameObject life cycle and the Unity <strong class="bold">game loop</strong>. When a GameObject is created at runtime, for example, its <strong class="source-inline">Start()</strong> function will automatically be called. This is a good place to add some initialization code.</p>
			<p>The Unity game engine's <a id="_idIndexMarker211"/>main purpose is to render the current scene view every frame, perhaps 60 times per second or more. Each time the frame is updated, your <strong class="source-inline">Update()</strong> function will automatically be called. This is where you put any runtime code that needs to be run every frame. Try to keep the amount of work that's done in <strong class="source-inline">Update()</strong> to a minimum; otherwise, your app may feel slow and sluggish.</p>
			<p>You can learn more <a id="_idIndexMarker212"/>about the MonoBehaviour class here: <a href="https://docs.unity3d.com/ScriptReference/MonoBehaviour.html">https://docs.unity3d.com/ScriptReference/MonoBehaviour.html</a>. To get a complete picture of the GameObject and MonoBehaviour scripts' life cycles, take a look at this flowchart here: <a href="https://docs.unity3d.com/Manual/ExecutionOrder.html">https://docs.unity3d.com/Manual/ExecutionOrder.html</a>.    </p>
			<p>We can now write our script. Since this is the first script in this book, I'll present it slowly.</p>
			<h2 id="_idParaDest-54"><a id="_idTextAnchor056"/>Writing the PlaceObjectOnPlane script</h2>
			<p>The <a id="_idIndexMarker213"/>purpose of <a id="_idIndexMarker214"/>the <strong class="source-inline">PlaceObjectOnPlane</strong> script is to place a virtual object on the AR plane when and where the user taps. We'll <a id="_idIndexMarker215"/>outline the <a id="_idIndexMarker216"/>logic first (in C#, any text after <strong class="source-inline">//</strong> on the same line is a comment):</p>
			<p class="source-code">using System.Collections;</p>
			<p class="source-code">using System.Collections.Generic;</p>
			<p class="source-code">using UnityEngine;</p>
			<p class="source-code"><strong class="bold">using UnityEngine.InputSystem;</strong></p>
			<p class="source-code">public class PlaceObjectOnPlane : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">    void OnPlaceObject(InputValue value)</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        // get the screen touch position</strong></p>
			<p class="source-code"><strong class="bold">        // raycast from the touch position into the 3D scene            looking for a plane</strong></p>
			<p class="source-code"><strong class="bold">        // if the raycast hit a plane then</strong></p>
			<p class="source-code"><strong class="bold">        //      get the hit point (pose) on the plane</strong></p>
			<p class="source-code"><strong class="bold">        //      if this is the first time placing an object,</strong></p>
			<p class="source-code"><strong class="bold">        //          instantiate the prefab at the hit position                     and rotation</strong></p>
			<p class="source-code"><strong class="bold">        //      else</strong></p>
			<p class="source-code"><strong class="bold">        //          change the position of the previously                     instantiated object</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p class="source-code">}</p>
			<p>As it turns out, in this script, there is no need for an <strong class="source-inline">Update</strong> function as it is only used for frame updates, which this script can ignore. </p>
			<p>This script implements <strong class="source-inline">OnPlaceObject</strong>, which is called when the user taps the screen. As we mentioned previously, the Player Input component we added to the AR Session Origin uses the <strong class="bold">Send Messages</strong> behavior and thus expects our script to implement <strong class="source-inline">OnPlacedObject</strong> for the <strong class="bold">PlacedObject</strong> action. It receives an <strong class="source-inline">InputValue</strong>. Notice that I also added a line using <strong class="source-inline">UnityEngine.InputSystem;</strong>, which defines the <strong class="source-inline">InputValue</strong> class.</p>
			<p>First, we need to <a id="_idIndexMarker217"/>get the screen <a id="_idIndexMarker218"/>touch position from the input value we passed in. Add the following code, which declares and assigns it to the <strong class="source-inline">touchPosition</strong> local variable:</p>
			<p class="source-code">        // get the screen touch position</p>
			<p class="source-code">        Vector2 touchPosition = value.Get&lt;Vector2&gt;();</p>
			<p>The next step is to figure out if the screen touch corresponds to a plane that was detected in the AR scene. AR Foundation provides a solution by using the AR Raycast Manager component that we added to the AR Session Origin GameObject earlier. We'll use it in our script now. Add these lines to the top of your script:</p>
			<p class="source-code">using UnityEngine.XR.ARFoundation;</p>
			<p class="source-code">using UnityEngine.XR.ARSubsystems; </p>
			<p>Then, inside the <strong class="source-inline">OnPlaceObject</strong> function, add the following code:</p>
			<p class="source-code">        // raycast from the touch position into the 3D scene            looking for a plane</p>
			<p class="source-code">        // if the raycast hit a plane then  </p>
			<p class="source-code">        ARRaycastManager raycaster =            GetComponent&lt;ARRaycastManager&gt;();</p>
			<p class="source-code">        List&lt;ARRaycastHit&gt; hits = new List&lt;ARRaycastHit&gt;();</p>
			<p class="source-code">        if (raycaster.Raycast(touchPosition, hits,            TrackableType.PlaneWithinPolygon))</p>
			<p class="source-code">        {</p>
			<p class="source-code">            // </p>
			<p class="source-code">        }</p>
			<p>Firstly, we get a reference to the <strong class="bold">ARRaycastManager</strong> component, assigning it to <strong class="source-inline">raycaster</strong>. We declare and initialize a list of <strong class="source-inline">ARRaycastHit</strong>, which will be populated when the raycast finds something. Then, we call <strong class="source-inline">raycaster.Raycast()</strong>, passing in the <a id="_idIndexMarker219"/>screen's <strong class="source-inline">touchPosition</strong>, and a reference to the <strong class="source-inline">hits</strong> list. If it finds a plane, it'll return <strong class="source-inline">true</strong> and populate <a id="_idIndexMarker220"/>the <strong class="source-inline">hits</strong> list with details. The third argument instructs <strong class="source-inline">raycaster.Raycast</strong> on what kinds of trackables can be hit. In this case, <strong class="source-inline">PlaneWithinPolygon</strong> filters for 2D convex-shaped planes. </p>
			<p class="callout-heading">Information – For More Information on AR Raycasting</p>
			<p class="callout">For more information on using ARRaycastManager, see <a href="mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/raycast-manager.html">https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/raycast-manager.html</a>.</p>
			<p class="callout">For a list of trackable types you can pass in, see <a href="mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.1/api/UnityEngine.XR.ARSubsystems.TrackableType.html">https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.1/api/UnityEngine.XR.ARSubsystems.TrackableType.html</a>.</p>
			<p>The code inside the <strong class="source-inline">if</strong> statement will only be executed if <strong class="source-inline">raycaster.Raycast</strong> returns <strong class="source-inline">true</strong>; that is, if the user had tapped a location on the screen that casts to a trackable plane in the scene. In that case, we must create a 3D GameObject there. In Unity, creating a new GameObject is referred to as <strong class="bold">instantiating</strong> the object. You can read more about it here: <a href="https://docs.unity3d.com/Manual/InstantiatingPrefabs.html">https://docs.unity3d.com/Manual/InstantiatingPrefabs.html</a>. </p>
			<p>First, let's declare a variable, <strong class="source-inline">placedPrefab</strong>, to hold a reference to the prefab that we want to instantiate on the selected plane. Using the <strong class="source-inline">[SerializedField]</strong> directive permits the property to be visible and settable in the Unity Inspector. We'll also declare a <strong class="source-inline">private</strong> variable, <strong class="source-inline">spawnedObject</strong>, that holds a reference to the instantiated object. Add the following code to the top of the class:</p>
			<p class="source-code">public class PlaceObjectOnPlane : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code"><strong class="bold">    [SerializeField] GameObject placedPrefab;</strong></p>
			<p class="source-code"><strong class="bold">    GameObject spawnedObject;</strong></p>
			<p>Now, inside the <strong class="source-inline">if</strong> statement, we will instantiate a new object if this is the first time the user has tapped the screen, and then assign it to <strong class="source-inline">spawnedObject</strong>. If the object had already been <a id="_idIndexMarker221"/>spawned and the user <a id="_idIndexMarker222"/>taps the screen again, we'll move the object to the new location instead. Add the following highlighted code:</p>
			<p class="source-code">    public void OnPlaceObject(InputValue value)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // get the screen touch position</p>
			<p class="source-code">        Vector2 touchPosition = value.Get&lt;Vector2&gt;();</p>
			<p class="source-code">        // raycast from the touch position into the 3D scene            looking for a plane</p>
			<p class="source-code">        // if the raycast hit a plane then  </p>
			<p class="source-code">        ARRaycastManager raycaster =            GetComponent&lt;ARRaycastManager&gt;();</p>
			<p class="source-code">        List&lt;ARRaycastHit&gt; hits = new List&lt;ARRaycastHit&gt;();</p>
			<p class="source-code">        if (raycaster.Raycast(touchPosition, hits,            TrackableType.PlaneWithinPolygon))</p>
			<p class="source-code">        {</p>
			<p class="source-code"><strong class="bold">            // get the hit point (pose) on the plane</strong></p>
			<p class="source-code"><strong class="bold">            Pose hitPose = hits[0].pose;</strong></p>
			<p class="source-code"><strong class="bold">            // if this is the first time placing an object,</strong></p>
			<p class="source-code"><strong class="bold">            if (spawnedObject == null)</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">                // instantiate the prefab at the hit position                    and rotation</strong></p>
			<p class="source-code"><strong class="bold">                spawnedObject = Instantiate(placedPrefab,                    hitPose.position, hitPose.rotation);</strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code"><strong class="bold">            else</strong></p>
			<p class="source-code"><strong class="bold">            {</strong></p>
			<p class="source-code"><strong class="bold">                // change the position of the previously                    instantiated object</strong></p>
			<p class="source-code"><strong class="bold">                spawnedObject.transform.SetPositionAndRotation(                    hitPose.position, hitPose.rotation); </strong></p>
			<p class="source-code"><strong class="bold">            }</strong></p>
			<p class="source-code">        }</p>
			<p class="source-code">    }</p>
			<p><strong class="source-inline">Raycast</strong> populates a <a id="_idIndexMarker223"/>list of hit points, as there could be multiple trackable planes in line where the user has tapped the screen. They're sorted closest to furthest, so in our case, we're <a id="_idIndexMarker224"/>only interested in the first one, <strong class="source-inline">hits[0]</strong>. From there, we get the point's <strong class="source-inline">Pose</strong>, a simple structure that includes 3D position and rotation values. These, in turn, are used when placing the object.</p>
			<p>After that, save the script file. </p>
			<p>Now, back in Unity, we'll attach our script as a component to <strong class="bold">AR Session Origin</strong> by performing the following steps:</p>
			<ol>
				<li value="1">First, check the <strong class="bold">Console</strong> window (using the <strong class="bold">Console</strong> tab or <strong class="bold">Window | General | Console</strong>) and ensure there are no compile errors from the script. If there are, go back to your code editor and fix them.</li>
				<li>In the <strong class="bold">Hierarchy</strong> window, select the <strong class="bold">AR Session Origin</strong> object.</li>
				<li>In the <strong class="bold">Project</strong> window, drag the <strong class="bold">PlaceObjectOnPlane</strong> script into the <strong class="bold">Inspector</strong> window so that when you drop it, it is added as a new component.<p>You'll notice that there is a Placed Prefab property in the component's <strong class="bold">Inspector</strong> window. This is the <strong class="source-inline">placedPrefab</strong> variable we declared in the script. Let's populate it with the red cube prefab provided by the Samples assets.</p></li>
				<li>In the <strong class="bold">Project</strong> window, navigate to the <strong class="source-inline">ARF-samples/Prefabs/</strong> folder.</li>
				<li>Drag the <strong class="bold">AR Placed Cube</strong> prefab into the <strong class="bold">Inspector</strong> window, on the <strong class="bold">Place Object On Plane | Placed Prefab</strong> slot.</li>
				<li>Save the scene by going to <strong class="bold">File | Save</strong>.</li>
			</ol>
			<p>Our script, as a <a id="_idIndexMarker225"/>component <a id="_idIndexMarker226"/>on the AR Session Origin GameObject, should now look as follows:</p>
			<div>
				<div id="_idContainer031" class="IMG---Figure">
					<img src="Images/Figure_2.09-placeobjectonplane-inspector.jpg" alt="Figure 2.9 – PlaceObjectOnPlane as a component with its Placed Prefab slot populated &#13;&#10;" width="566" height="94"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.9 – PlaceObjectOnPlane as a component with its Placed Prefab slot populated </p>
			<p>Let's try it! We're now ready to build and run the scene.</p>
			<h2 id="_idParaDest-55"><a id="_idTextAnchor057"/>Building and running the scene</h2>
			<p>If you've built the <a id="_idIndexMarker227"/>scene before, in the <a id="_idIndexMarker228"/>previous section, you can go to <strong class="bold">File | Build And Run</strong> to start the process. Otherwise, perform the following steps to build and run the scene:</p>
			<ol>
				<li value="1">Open the <strong class="bold">Build Settings</strong> window by going to <strong class="bold">File | Build Settings</strong>.</li>
				<li>For the <strong class="bold">Scenes in Build</strong> list, click the <strong class="bold">Add Open Scenes</strong> button and uncheck all the scenes in the list other than this one (mine is named <strong class="bold">BasicARScene</strong>).</li>
				<li>Ensure your device is connected via USB.</li>
				<li>Press the <strong class="bold">Build And Run</strong> button to build the project and install it on your device. It will prompt you for a location; I like to create a folder in my project root named <strong class="source-inline">Builds/</strong>. Give it a filename (if required) and press <strong class="bold">Save</strong>. It may take a while to complete this task.<p>The app should <a id="_idIndexMarker229"/>successfully build and run on <a id="_idIndexMarker230"/>your device. As usual, if you encounter any errors, please read the error messages carefully in the <strong class="bold">Console</strong> window. When the app launches, you should see a video feed on your screen. Move your device slowly in different directions and closer/away. As it scans the environment, feature points and planes will be detected and rendered on the screen. If you tap the screen on a tracked plane, the red cube should be placed at that location.</p><h2 id="_idParaDest-56"><a id="_idTextAnchor058"/>Refactoring your script</h2><p><strong class="bold">Refactoring</strong> is reworking a <a id="_idIndexMarker231"/>script to <a id="_idIndexMarker232"/>make the code cleaner, more readable, more organized, more efficient, or otherwise improved without changing its behavior or adding new features. We can now refactor our little script to make the following improvements:</p><ul><li>Move initialization code that only needs to be done once out of <strong class="source-inline">Update()</strong> into <strong class="source-inline">Start()</strong> (for example, initialize the <strong class="source-inline">raycaster</strong> variable). </li><li>Avoid allocating new memory in <strong class="source-inline">Update()</strong> to avoid memory fragmentation and garbage collection (for example, initialize the <strong class="source-inline">hits</strong> list as a class variable).</li></ul></li>
			</ol>
			<p>The modified script is shown in the following code block. The changed code is highlighted, beginning with the top part, which contains the new class variables and the <strong class="source-inline">Start()</strong> function:</p>
			<p class="source-code">public class PlaceObjectOnPlane : MonoBehaviour</p>
			<p class="source-code">{</p>
			<p class="source-code">    [SerializeField] GameObject placedPrefab;</p>
			<p class="source-code">    GameObject spawnedObject;</p>
			<p class="source-code"><strong class="bold">    ARRaycastManager raycaster;</strong></p>
			<p class="source-code"><strong class="bold">    List&lt;ARRaycastHit&gt; hits = new List&lt;ARRaycastHit&gt;();</strong></p>
			<p class="source-code"><strong class="bold">    void Start()</strong></p>
			<p class="source-code"><strong class="bold">    {</strong></p>
			<p class="source-code"><strong class="bold">        raycaster = GetComponent&lt;ARRaycastManager&gt;();</strong></p>
			<p class="source-code"><strong class="bold">    }</strong></p>
			<p>Now, add <a id="_idIndexMarker233"/>the <strong class="source-inline">OnPlacedObject</strong> function, as follows:</p>
			<p class="source-code">    public void OnPlaceObject(InputValue value)</p>
			<p class="source-code">    {</p>
			<p class="source-code">        // get the screen touch position</p>
			<p class="source-code">        Vector2 touchPosition = value.Get&lt;Vector2&gt;();</p>
			<p class="source-code">        // raycast from the touch position into the 3D scene            looking for a plane</p>
			<p class="source-code">        // if the raycast hit a plane then  </p>
			<p class="source-code"><strong class="bold">        // REMOVE NEXT TWO LINES</strong></p>
			<p class="source-code"><strong class="bold">        // ARRaycastManager raycaster =               GetComponent&lt;ARRaycastManager&gt;();</strong></p>
			<p class="source-code"><strong class="bold">        //List&lt;ARRaycastHit&gt; hits = new List&lt;ARRaycastHit&gt;();</strong></p>
			<ol>
				<li value="5">        if (raycaster.Raycast(touchPosition, hits,            TrackableType.PlaneWithinPolygon))</li>
			</ol>
			<p class="source-code">        {</p>
			<p>Please save the script, then build and run it one more time to verify it still works.</p>
			<p class="callout-heading">Information – Public versus Private and Object Encapsulation</p>
			<p class="callout">One of the driving principles of <a id="_idIndexMarker234"/>object-oriented programming is <strong class="bold">encapsulation</strong>, where an object keeps its internal variables and functions private, and only exposes properties (public variables) and methods (public functions) to other objects when they're intended to be accessible. C# provides the <strong class="source-inline">private</strong> and <strong class="source-inline">public</strong> declarations for this purpose. And in C#, any symbol not declared public is assumed to be private. In Unity, any public variables are also visible (serialized) in the Inspector window when the script is attached to a GameObject as a component. Ordinarily, private variables are not visible. Using the <strong class="source-inline">[SerializeField]</strong> directive enables a private variable to also be visible and modifiable in the Inspector window.</p>
			<p>Congratulations! It's <a id="_idIndexMarker235"/>not necessarily a brilliant app, and it's modeled after the example scenes found in the Samples projects, but you started from <strong class="bold">File | New Scene</strong> and built it up all on your own.  Now, let's have a little fun with it and find a 3D model that's a little more interesting than a little red cube.</p>
			<h1 id="_idParaDest-57"><a id="_idTextAnchor059"/>Creating a prefab for placing</h1>
			<p>The prefab object <a id="_idIndexMarker236"/>we've been placing on the planes in this chapter is the one named <em class="italic">AR Placed Cube</em>, which we imported from the AR Foundation Samples project. Let's find a different, more interesting, model to use instead. In the process, we'll learn a bit more about GameObjects, Transforms, and prefabs.</p>
			<h2 id="_idParaDest-58"><a id="_idTextAnchor060"/>Understanding GameObjects and Transforms</h2>
			<p>I think a good place <a id="_idIndexMarker237"/>to start is by taking a closer look at the <em class="italic">AR Placed Cube</em> prefab we've been using. Let's <a id="_idIndexMarker238"/>open it in the Editor by performing the following steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, navigate to the <strong class="source-inline">ARF-samples/Prefabs/</strong> folder.</li>
				<li>Double-click the <strong class="bold">AR Placed Cube</strong> prefab.</li>
			</ol>
			<p>We are now editing the prefab, as shown in the following screenshot (I have rearranged my windows differently from the default layout):</p>
			<div>
				<div id="_idContainer032" class="IMG---Figure">
					<img src="Images/Figure_2.10-arplacedcube-edit.jpg" alt="Figure 2.10 – Editing the AR Placed Cube prefab&#13;&#10;" width="1538" height="616"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.10 – Editing the AR Placed Cube prefab</p>
			<p>The <strong class="bold">Scene</strong> window now shows the isolated prefab object, and the <strong class="bold">Hierarchy</strong> window is the hierarchy for just the prefab itself. At its root is an "empty" GameObject named <strong class="bold">AR Placed Cube</strong>; it has only one component – Transform, which is required of all GameObjects. Its Transform is reset to <strong class="bold">Position</strong> (<strong class="source-inline">0, 0, 0</strong>), <strong class="bold">Rotation</strong> (<strong class="source-inline">0, 0, 0</strong>), and <strong class="bold">Scale</strong> (<strong class="source-inline">1, 1, 1</strong>).</p>
			<p>Beneath the AR Placed Cube is a child <strong class="bold">Cube</strong> object, as depicted in the preceding screenshot. This cube is scaled to (<strong class="source-inline">0.05, 0.05, 0.05</strong>). These units are in meters (0.05 meters is about 2 inches per side). And that's its size when it's placed in the physical environment with our app.</p>
			<p>You'll also notice that the child Cube's X-Y-Z <strong class="bold">Position</strong> is (<strong class="source-inline">0, 0.025, 0</strong>), where Y in Unity is the up-axis. As 0.025 is half of 0.05, we've raised the cube half its height above the zero X-Z plane. </p>
			<p>The origin of a <a id="_idIndexMarker239"/>Cube is its center. So, the origin of the AR Placed Cube is the <a id="_idIndexMarker240"/>bottom of the child Cube. In other words, when we place this prefab in the scene, the cube's bottom side rests on the pose position, as determined by the <em class="italic">hit</em> raycast.</p>
			<p>Parenting a model with an empty GameObject to normalize its scale and adjust its origin is a common pattern in Unity development. </p>
			<p>Now, let's find a different model for our app and normalize its Transform as we make it a prefab.</p>
			<h2 id="_idParaDest-59"><a id="_idTextAnchor061"/>Finding a 3D model</h2>
			<p>To find a 3D model, feel free to <a id="_idIndexMarker241"/>search the internet for a 3D model you like. If you're a 3D artist, you may already have ones of your own. You will want a relatively simple, low-poly model (that is, with not many polygons). Look for files in <strong class="source-inline">.FBX</strong> or <strong class="source-inline">.OBJ</strong> format, as they will import into Unity without conversion. </p>
			<p>I found a model of a virus microbe on <strong class="source-inline">cgtrader.com</strong> here: <a href="https://www.cgtrader.com/free-3d-models/science/medical/microbe">https://www.cgtrader.com/free-3d-models/science/medical/microbe</a>. It is a free download and royalty-free, has 960 polygons, and is available in FBX format. My file is named <strong class="source-inline">uploads_files_745381_Microbe.fbx</strong>.</p>
			<p>Once you've found a file and downloaded it to your computer, perform the following steps to import it into Unity:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, create a folder named <strong class="source-inline">Models</strong> under your <strong class="source-inline">_App</strong> folder (this step is optional).</li>
				<li>Drag the model from your Windows File Explorer or macOS Finder into the <strong class="source-inline">Models</strong> folder to import it into the project. Alternatively, you can use the main menu by clicking <strong class="bold">Assets | Import New Asset</strong>.</li>
				<li>When you select the model in the <strong class="bold">Project</strong> window, you can review it in the <strong class="bold">Inspector</strong> window. While there, take a look at the many <strong class="bold">Import Settings</strong>. Generally, you can keep their default values.</li>
			</ol>
			<p>Now, we'll make a prefab of the model and make sure it's been scaled to a usable size. I like to use a temporary <a id="_idIndexMarker242"/>Cube object to measure it:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, create a folder named <strong class="source-inline">Prefabs</strong> under your <strong class="source-inline">_App</strong> folder (this step is optional).</li>
				<li>Right-click inside the <strong class="source-inline">Prefabs</strong> folder, select <strong class="bold">Create | Prefab</strong>, and give it a name (I named mine <strong class="source-inline">Virus</strong>).</li>
				<li>Double-click the new prefab, or click its <strong class="bold">Open Prefab</strong> button in the <strong class="bold">Inspector</strong> window.</li>
				<li>For measurement purposes, add a temporary Cube by selecting <strong class="bold">GameObject | 3D Object | Cube</strong> from the main menu (or use the <strong class="bold">+</strong> button at the top left, or right-click directly in the <strong class="bold">Hierarchy</strong> window).</li>
				<li>Assuming I want my model to appear in the scene as the same size as the red cube we had been using, set this measuring cube <strong class="bold">Scale</strong> to (<strong class="source-inline">0.05, 0.05, 0.05</strong>) and its <strong class="bold">Position</strong> to (<strong class="source-inline">0, 0.025, 0</strong>).</li>
				<li>Drag the 3D model you imported from your <strong class="bold">Project</strong> <strong class="source-inline">Models</strong> folder into the <strong class="bold">Hierarchy</strong> window as a child of the root object.</li>
				<li>Use the <strong class="bold">Scene</strong> edit toolbar and gizmos to scale and position your model so that it's about the same size and position as the Cube. I found this works: <strong class="bold">Scale</strong> (<strong class="source-inline">0.5, 0.05, 0.05</strong>), <strong class="bold">Position</strong> (<strong class="source-inline">0, 0.04, 0</strong>), <strong class="bold">Rotation</strong> (<strong class="source-inline">0, 0, 0</strong>).</li>
				<li>Delete or disable the Cube. With <strong class="bold">Cube</strong> selected, in its <strong class="bold">Inspector</strong> window, uncheck the <strong class="bold">Enable</strong> checkbox at the top left.</li>
				<li>Save the prefab by clicking the <strong class="bold">Save</strong> button at the top of the <strong class="bold">Scene</strong> window.</li>
			</ol>
			<p>The model I found did not come with a material, so let's create one for it now. With the prefab we're working on still open for editing, perform the following additional steps:</p>
			<ol>
				<li value="1">In the <strong class="bold">Project</strong> window, create a folder named <strong class="source-inline">Materials</strong> under your <strong class="source-inline">_App</strong> folder (this step is optional).</li>
				<li>Right-click inside the <strong class="source-inline">Materials</strong> folder, select <strong class="bold">Create | Material</strong>, and give it a name. I named mine <strong class="source-inline">Virus Material</strong>.</li>
				<li>Drag <strong class="bold">Virus Material</strong> onto the model object (<strong class="bold">uploads_files_745381_Microbe</strong>) in the <strong class="bold">Hierarchy</strong> window.</li>
				<li>With the <a id="_idIndexMarker243"/>microbe model selected in the <strong class="bold">Hierarchy</strong> window, you can modify its material in the <strong class="bold">Inspector</strong> window. For example, you can change its color by clicking the <strong class="bold">Base Map</strong> color chip and choosing a new one. I'll also make mine shinier by setting its <strong class="bold">Metallic Map</strong> value to <strong class="source-inline">0.5</strong>.</li>
				<li>Again, <strong class="bold">Save</strong> your prefab. </li>
				<li>Exit back to scene editing by clicking the <strong class="bold">&lt;</strong> button at the top left of the <strong class="bold">Hierarchy</strong> window.</li>
			</ol>
			<p>My prefab now looks like this while open for editing (I have rearranged my windows so that they're different from the default layout):</p>
			<div>
				<div id="_idContainer033" class="IMG---Figure">
					<img src="Images/Figure_2.11-virus-edit.jpg" alt="Figure 2.11 – Editing my Virus prefab&#13;&#10;" width="1423" height="794"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.11 – Editing my Virus prefab</p>
			<p>We're now ready to add this <a id="_idIndexMarker244"/>prefab to the scene. After, we will build and run the finished project.</p>
			<h2 id="_idParaDest-60"><a id="_idTextAnchor062"/>Completing the scene</h2>
			<p>We now have our <a id="_idIndexMarker245"/>own prefab to place in the AR scene. Let's add it to the <strong class="bold">Place Object On Plane</strong> component, as follows:</p>
			<ol>
				<li value="1">Ensure you've exited the prefab edit mode and are now editing BasicARScene.</li>
				<li>Select the <strong class="bold">AR Session Origin</strong> object in the <strong class="bold">Hierarchy</strong> window.</li>
				<li>From the <strong class="bold">Project</strong> window, drag your prefab (mine is <strong class="source-inline">_App/Prefabs/Virus</strong>) into the <strong class="bold">Inspector</strong> window, onto the <strong class="bold">Place Object On Plane | Placed Prefab</strong> slot.</li>
				<li>Save the scene with <strong class="bold">File | Save</strong>.</li>
				<li>Build and run the scene by going to <strong class="bold">File | Build And Run</strong>.</li>
			</ol>
			<p>As shown in the following screenshot, I have infected my desk with a virus! </p>
			<div>
				<div id="_idContainer034" class="IMG---Figure">
					<img src="Images/Figure_2.12-virus-keyboard.jpg" alt="Figure 2.12 – Running the project shows a virus on my keyboard&#13;&#10;" width="748" height="1330"/>
				</div>
			</div>
			<p class="figure-caption">Figure 2.12 – Running the project shows a virus on my keyboard</p>
			<p>There it is. You've <a id="_idIndexMarker246"/>successfully created an augmented reality scene that places a virtual 3D model in the real world. Perhaps you wouldn't have chosen a virus, but it's a sign of the times!</p>
			<p>You're now ready to proceed with creating your own AR projects in Unity.</p>
			<h1 id="_idParaDest-61"><a id="_idTextAnchor063"/>Summary</h1>
			<p>In this chapter, we examined the core structure of an augmented reality scene using AR Foundation. We started with the AR Foundation Samples project from Unity, building it to run on your device, and then exported its assets into an asset package for reuse. Then, we imported these sample assets into our own project, took a closer look at the <strong class="source-inline">SimpleAR</strong> scene, and built that to run on your device. </p>
			<p>Then, starting from a new empty scene, we built our own basic AR demo from scratch that lets the user place a virtual 3D object in the physical world environment. For this, we added <strong class="bold">AR Session</strong> and <strong class="bold">AR Session Origin</strong> game objects and added components for tracking and visualizing planes and point clouds. Next, we added user interaction, first by creating an <strong class="bold">Input Action</strong> controller that responds to screen touches, and then by writing a C# script to receive the <strong class="source-inline">OnPlaceObject</strong> action message. This function performs a raycast from the screen touch position to find a pose point on a trackable horizontal plane. It then instantiates an object on the plane at that location. We concluded this chapter by finding a 3D model on the internet, importing it into the project, creating a scaled prefab from the model, and using it as the virtual object placed into the scene. Several times along the way, we did a <strong class="bold">Build And Run</strong> of the project to verify that our work at that point runs as expected on the target device.</p>
			<p>In the next chapter, we will look at tools and practices to facilitate developing and troubleshooting AR projects, which will help improve the developer workflow, before moving on to creating more complete projects in subsequent chapters.</p>
		</div>
	</div></body></html>