- en: FTP and SMTP
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP 和 SMTP
- en: Having explored the heavy-hitter of application-layer protocols with a chapter
    on HTTP, it will serve us well to look at some of the other less common protocols.
    That's what we'll be looking at in this chapter. While HTTP is a general-purpose,
    workhorse protocol, there are a number of reasons why you might consider using
    **File Transfer Protocol** (**FTP**) or **Simple Mail Transfer Protocol** (**SMTP**)
    for specific tasks in your own software, or why those protocols might be leveraged
    by .NET Core under the hood of some of their more common abstractions. So, in
    this chapter, we'll see what those reasons might be and learn how to implement
    those protocols when the situation arises.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过关于 HTTP 的章节探讨了应用层协议的重磅内容，因此，审视一些不太常见的协议对我们来说将大有裨益。这正是本章我们将要探讨的内容。虽然
    HTTP 是一种通用的工作马协议，但有许多原因可能促使你考虑在自己的软件中针对特定任务使用**文件传输协议**（**FTP**）或**简单邮件传输协议**（**SMTP**），或者这些协议可能在
    .NET Core 的某些常见抽象之下被利用。因此，在本章中，我们将探讨这些原因，并学习在需要时如何实现这些协议。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: How the FTP standard is defined and how C# implements the protocol in .NET Core
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: FTP 标准是如何定义的，以及 C# 在 .NET Core 中如何实现该协议
- en: Understanding the processes for securing file transport
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解确保文件传输安全的过程
- en: Understanding the nature of SMTP and the role it fulfills
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 SMTP 的本质及其所扮演的角色
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we''ll be using sample applications available in the GitHub
    repository for the book here: [https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter
    10](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%2010).'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用本书 GitHub 仓库中提供的示例应用程序：[https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%2010](https://github.com/PacktPublishing/Hands-On-Network-Programming-with-CSharp-and-.NET-Core/tree/master/Chapter%2010)。
- en: We'll be working mostly with console applications, so you won't need any sort
    of REST or web client specifically for this chapter.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将主要使用控制台应用程序，因此您不需要为本章特别准备任何 REST 或 Web 客户端。
- en: Also, in this chapter, we'll be writing a client to engage with an FTP server.
    To that end, we'll need an FTP server we can administer ourselves. I will be using
    FileZilla for this and recommend you do the same. It's lightweight, stable, and
    open source. It can be found here: [https://filezilla-project.org/download.php?type=server](https://filezilla-project.org/download.php?type=server). If
    your development environment doesn't support FileZilla, don't worry. The goal
    is simply to have a server available and listening for our application to interact
    with. The demonstrations should be easy enough to follow along with using any
    FTP server with support for your OS.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，在本章中，我们将编写一个客户端来与 FTP 服务器交互。为此，我们需要一个我们可以自行管理的 FTP 服务器。我将使用 FileZilla，并建议你也这样做。它轻量级、稳定且开源。您可以在以下位置找到它：[https://filezilla-project.org/download.php?type=server](https://filezilla-project.org/download.php?type=server)。如果您的开发环境不支持
    FileZilla，请不要担心。目标仅仅是拥有一个可供应用程序交互的服务器。演示应该足够简单，以便使用支持您操作系统的任何 FTP 服务器进行跟随。
- en: Check out the following video to see the code in action: [http://bit.ly/2HYmsHj](http://bit.ly/2HYmsHj)
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频，了解代码的实际应用：[http://bit.ly/2HYmsHj](http://bit.ly/2HYmsHj)
- en: File transfer over the web
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过网络进行文件传输
- en: The first thing to note about FTP and file transfer is that, as an application-layer
    protocol on the **Open Systems Interconnection** (**OSI**) stack, the primary
    concern of its design is in optimizing a specific common business task for execution
    over a network. However, just because a task is optimally done over a given protocol,
    it doesn't mean it *must *be done over that protocol. Indeed, almost anything
    done at the application-layer could, in theory, be accomplished by any application-layer
    protocol. So, what is it that makes FTP useful for us as engineers?
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 FTP 和文件传输的第一件事要注意的是，作为 **开放系统互联**（**OSI**）堆栈上的应用层协议，其设计的主要关注点是优化特定常见业务任务在网络上的执行。然而，仅仅因为一项任务在某个协议上执行得最优化，并不意味着它必须通过该协议执行。实际上，理论上几乎任何在应用层执行的任务都可以通过任何应用层协议完成。那么，是什么使得
    FTP 对我们这些工程师来说有用呢？
- en: The intent of FTP
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP 的意图
- en: While FTP is optimized for a file transfer between hosts, I'd wager every dollar
    I have that there isn't a single reader of this book who hasn't transferred files
    over a network as an attachment of their email. The same task is accomplished,
    namely, a file was transferred from one host on a network to another, over that
    network, but it was accomplished using a different application-layer protocol
    (SMTP instead of FTP). Indeed, the versatility of the specification for HTTP has
    allowed it to grow well beyond the task for which it was optimized (transferring
    hypertext documents) and into a general-purpose workhorse of web communication.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然FTP针对主机之间的文件传输进行了优化，但我敢打赌，这本书的每一位读者都曾将文件作为电子邮件附件在网络中传输过。同样的任务完成了，也就是说，文件从一个网络主机传输到另一个网络主机，但这是通过不同的应用层协议（SMTP而不是FTP）完成的。确实，HTTP规范的多功能性使其能够远远超出其优化的任务（传输超文本文档）并成为网络通信的通用工作马。
- en: In fact, there are countless applications that transfer files directly over
    HTTP. There's even a well-known and broadly supported media type for precisely
    that kind of interaction with `multipart/form-data`. So, what advantages are there
    to be gained by using FTP for file transfer instead of other more general-purpose
    application-layer protocols?
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，有无数的应用程序直接通过HTTP传输文件。甚至有一个广为人知且广泛支持的媒体类型，专门用于与`multipart/form-data`进行此类交互。那么，使用FTP进行文件传输而不是其他更通用的应用层协议，我们能获得哪些优势呢？
- en: Built on a client-server model architecture, FTP is designed and implemented
    to leverage two separate connections for establishing the state of the target
    filesystem and transferring files. The first of these connections is what's called
    a control connection, and it is used to hold various details about the state of
    the remote host, such as the current working directory exposed to the FTP client.
    Meanwhile, for each transfer of data, a second data connection is established
    using information maintained by the control connection. When the data connection
    is engaged and transferring data, the control connection is idled.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 建立在客户端-服务器模型架构之上，FTP被设计和实现为利用两个独立的连接来建立目标文件系统的状态和传输文件。这些连接中的第一个被称为控制连接，它用于保存有关远程主机状态的详细信息，例如向FTP客户端公开的当前工作目录。同时，对于每次数据传输，使用控制连接维护的信息建立第二个数据连接。当数据连接建立并传输数据时，控制连接处于空闲状态。
- en: In most implementations, establishing a control connection can be a bit of a
    pain, and often slow-performing. This is because each connection requires multiple
    round trips, sending various commands to the remote host establishing the target
    directory, negotiating any authentication, and determining and storing the remote
    state for use by the data connection. This high performance cost, as well as the
    statefulness of the control connection, is what made FTP ill-suited for use in
    transferring simple, brief hypertext web pages, thus necessitating HTTP. However,
    that stateful connection and the information it provides a client regarding the
    current state of the directory is essential to some operations FTP is used to
    support (such as detecting the presence of a file on a remote host or bulk downloads
    of all files in a directory).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数实现中，建立控制连接可能有些麻烦，并且通常性能较慢。这是因为每个连接都需要多次往返，向远程主机发送各种命令以建立目标目录，协商任何身份验证，并确定和存储远程状态以供数据连接使用。这种高性能成本，以及控制连接的状态性，是使FTP不适合用于传输简单的、简短的超文本文档页面的原因，因此需要HTTP。然而，这种状态连接以及它提供给客户端有关目录当前状态的信息对于FTP所支持的一些操作是必不可少的（例如检测远程主机上的文件存在或目录中所有文件的批量下载）。
- en: Active and passive connections
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 激活和被动连接
- en: Once a control connection is established, the data connection can be made using
    one of two possible modes. The server can establish an active connection, which
    is the default state for most FTP servers, or a passive connection. These different
    types of connection refer specifically to how the dataconnection is established
    and handled. In either case, the client initiates a control connection with a
    message using the underlying transport protocol (usually **Transmission Control
    Protocol** (**TCP**)).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦建立了控制连接，数据连接可以使用两种可能的模式之一。服务器可以建立激活连接，这是大多数FTP服务器的默认状态，或者被动连接。这些不同类型的连接具体指的是数据连接的建立和处理方式。在任何情况下，客户端都使用底层传输协议（通常是**传输控制协议**（**TCP**））的消息来初始化控制连接。
- en: In an active connection, once the control connection is established and the
    data transfer can begin, it's the server that establishes a data connection to
    transmit the file over the wire. The client transmits information during the command
    connection phase, notifying the server about which port is actively listening
    for the data connection. Then the server attempts to establish a connection with
    the client on the designated port, which is used for the server to push out the
    file data. The server is said to be *actively transmitting* the data to the client.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在主动连接中，一旦控制连接建立并且可以开始数据传输，服务器将建立数据连接来通过线路传输文件。客户端在命令连接阶段传输信息，通知服务器哪个端口正在积极监听数据连接。然后服务器尝试在指定的端口上与客户端建立连接，该端口用于服务器推送文件数据。服务器被称为*主动传输*数据到客户端。
- en: In a passive connection, the client uses the control connection to notify the
    server that the connection should be passive. The server then responds with an
    IP address and port designation for the client to establish a connection with.
    At that point, it's the client that establishes the data connection to the server's
    designated IP address and port. Once this connection is established, the client
    can transmit the file data.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在被动连接中，客户端使用控制连接来通知服务器该连接应为被动模式。然后服务器响应一个IP地址和端口号，客户端可以据此建立连接。在那个时刻，客户端将建立数据连接到服务器的指定IP地址和端口。一旦这个连接建立，客户端就可以传输文件数据。
- en: Transfer modes and data representations
  id: totrans-22
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输模式和数据处理
- en: Once the actual data connection has been established as either active or passive,
    and the file transfer is ready, there are a number of ways to transmit the file
    in such a way as to have it readable on the target machine. Keep in mind that
    a text file written on a Unix system will have different character encodings or
    line terminals from a text file written on a Windows machine. If you've ever opened
    up a text editor or source control interface and been prompted to normalize the
    line endings of your files, this is why. It's a way of accounting for the subtle
    discrepancies between different native environments.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦实际数据连接被建立为主动或被动模式，并且文件传输准备就绪，就有多种方式来传输文件，使其在目标机器上可读。请记住，在Unix系统上编写的文本文件与在Windows机器上编写的文本文件将具有不同的字符编码或行终止符。如果你曾经打开过文本编辑器或源代码控制界面，并被提示规范化文件的行终止符，这就是原因。这是为了弥补不同原生环境之间细微差异的一种方式。
- en: 'Since FTP is a platform-agnostic network transmission protocol, it must account
    for the possible disparities between binary representations of a file''s content
    on different systems. To that end, FTP provides three different common data representation
    mechanisms for files being transferred over a connection:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 由于FTP是一种平台无关的网络传输协议，它必须考虑到不同系统上文件内容二进制表示可能存在的差异。为此，FTP为通过连接传输的文件提供了三种不同的常见数据表示机制：
- en: '**ASCII mode:** This should only ever be used for text files. The character
    and bytes are converted from the source machine''s native character representation
    to an 8-bit ASCII encoding prior to transmission, and then converted, again, to
    the target machine''s native character representation from that 8-bit ASCII encoding.
    Of course, if either machine''s native character encoding already is 8-bit ASCII,
    no conversion happens between that machine and the data connection.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ASCII模式**：这种模式仅应用于文本文件。字符和字节在传输之前从源机器的本地字符表示转换为8位ASCII编码，然后再次从该8位ASCII编码转换为目标机器的本地字符表示。当然，如果任一机器的本地字符编码已经是8位ASCII，那么在该机器和数据连接之间不需要进行转换。'
- en: '**Image (or binary) mode:** In this mode, the underlying binary data of the
    file on the source machine is sent over, unchanged, in a sequential byte stream.
    The target machine then stores that stream at the target file location on its
    local system, byte by byte, as it receives packets from the source.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图像（或二进制）模式**：在这种模式下，源机器上文件的底层二进制数据以未更改的状态，以顺序字节流的形式发送。目标机器随后在本地系统上的目标文件位置，逐字节存储该流，因为它从源接收数据包。'
- en: '**Local mode:** This is for two computers with a shared local configuration
    to transfer data in any proprietary representation without a need to convert it
    to ASCII. It''s not entirely dissimilar to the image mode, except that, where
    the proprietary format allows, data could be transferred non-sequentially.'
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**本地模式**：这是用于两台具有共享本地配置的计算机，以任何专有表示形式传输数据，而无需将其转换为ASCII。它与图像模式并不完全不同，只是在专有格式允许的情况下，数据可以非顺序地传输。'
- en: 'Once you''ve determined the best way to represent your data for transmission,
    though, FTP will also provide three mechanisms for actually executing that transmission.
    They are as follows:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，一旦你确定了表示数据传输的最佳方式，FTP还将提供三种执行该传输的机制。它们如下：
- en: '**Stream mode:** Datagrams are sent as a continuous stream. This has a number
    of performance advantages, as there''s no need to encapsulate discrete packets
    in any headers or metadata to enable the parsing. Bytes are simply sent out as
    they are read until the end of the file is reached on the source system.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流模式**：数据报以连续流的形式发送。这有几个性能优势，因为不需要在头部或元数据中封装离散的数据包来启用解析。字节简单地发送出去，直到源系统上的文件结束。'
- en: '**Block mode:** This mechanism will chunk the file data into discrete application-layer
    packets and transfer them one block at a time to the source system, which is then
    responsible for reconstructing the original file structure based on the information
    in the packet metadata.'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**块模式**：这种机制将文件数据分成离散的应用层数据包，并一次传输一个数据包到源系统，然后源系统根据数据包元数据中的信息重建原始文件结构。'
- en: '**Compressed mode:** This mode simply enables a simple data compression algorithm
    to minimize the total volume of data sent between hosts.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**压缩模式**：这种模式简单地启用了一种简单的数据压缩算法，以最小化主机之间发送的数据总量。'
- en: Exposing directories for FTP
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暴露目录以供FTP使用
- en: All of the features I've described in this section serve the specific purpose
    of negotiating the efficient transfer of files between two remote hosts. While
    the protocol obviously would not be well suited for a task such as transferring
    web pages to be rendered by a remote web browser, it does leverage a number of
    advantages over other application protocols such as HTTP. This includes giving
    engineers the flexibility to determine precisely how, and in what format, they
    can transfer large files.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我在本节中描述的所有功能都是为了在两个远程主机之间高效传输文件而服务的特定目的。虽然显然该协议不适合像将网页传输到远程浏览器渲染这样的任务，但它确实在HTTP等其他应用协议上具有许多优势。这包括给工程师提供灵活性，以确定他们如何以及以何种格式传输大文件。
- en: So, now that we understand how and why FTP is used, let's look at how we can
    use it in our own programs. We'll be writing a simple client using the .NET library
    classes. The end state will be a client that can upload and download files, as
    well as request directory information from the remote host.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，既然我们已经了解了FTP的使用方式和原因，让我们看看我们如何在自己的程序中使用它。我们将使用.NET库类编写一个简单的客户端。最终状态将是一个可以上传和下载文件，以及从远程主机请求目录信息的客户端。
- en: 'Our application will be a console application this time, so navigate via your
    terminal of choice to your working directory and create a new project:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这次我们的应用程序将是一个控制台应用程序，所以通过你选择的终端导航到你的工作目录，并创建一个新的项目：
- en: '[PRE0]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Next, you'll want to make sure your fileserver is up and running locally. When
    you install the software, you should have see a window prompting you to choose
    a port that the server will be listening on for administration connections.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你需要确保你的文件服务器在本地运行正常。当你安装软件时，你应该会看到一个窗口提示你选择一个端口，服务器将在这个端口上监听管理连接。
- en: Configuring your FTP server
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置你的FTP服务器
- en: If you read that prompt carefully, you will have noticed that it was very explicit
    that the port you were choosing was for administrative connections to your FTP
    server, and not active FTP connections. This is because (if you remember back
    to the *Reserved ports* section in [Chapter 8](a0c3481a-daca-484d-95f8-f08867c8c7b8.xhtml),
    *Sockets and Ports*) there is already a default port configured to listen for
    incoming FTP command connections. Just like how the `80` port is the default listening
    port for HTTP, the `21` port is the default port for FTP command connections.
    That means that, in general, connections sent to a URI with a schema of `ftp://...`
    and no port specification will automatically connect to the `21` port.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您仔细阅读那个提示，您会注意到它非常明确地指出您选择的端口是用于对FTP服务器的管理连接，而不是活动FTP连接。这是因为（如果您记得回想起第8章中的*保留端口*部分，*套接字和端口*），已经配置了一个默认端口来监听传入的FTP命令连接。就像`80`端口是HTTP的默认监听端口一样，`21`端口是FTP命令连接的默认端口。这意味着，通常情况下，发送到没有指定端口的`ftp://...`
    URI的连接将自动连接到`21`端口。
- en: This is why the port you configure on FileZilla is explicitly designated as
    being for administration only. You're not connecting to the FTP command connection.
    You're connecting to the FileZilla server that is managing that FTP command connection.
    So, with that in mind, start the server and configure it to point to the localhost
    and the port you specified at the time of installation.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是为什么您在FileZilla上配置的端口被明确指定为仅用于管理。您并不是连接到FTP命令连接。您是连接到管理该FTP命令连接的FileZilla服务器。因此，考虑到这一点，启动服务器并将其配置为指向安装时指定的localhost和端口。
- en: Once the application starts running, you'll see a notification that FTP over
    **Transport Layer Security** (**TLS**) is not enabled. Even though this message
    is written in alarming red text, you can ignore it for now. We'll look at it further
    when we explore TLS in a later chapter. For now, the lack of security keys will
    just make our lives a bit easier as we try to understand FTP, specifically. The
    fewer variables we introduce at once, the easier it is to understand new information
    as we receive it.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦应用程序开始运行，您将看到一个通知，表明**传输层安全性**（**TLS**）的FTP未启用。尽管这条消息是用令人警觉的红色文字写的，但现在您可以忽略它。当我们稍后在后续章节中探讨TLS时，我们会进一步研究它。目前，缺少安全密钥只会让我们在尝试理解FTP时生活变得稍微容易一些。我们引入的变量越少，在接收新信息时理解起来就越容易。
- en: 'Finally, we need to register a user for our application in the FTP Administration
    UI, and set a working directory for the user. To do so, click on Edit | Users
    in the menu on the FileZilla administrator console. Then navigate to the Shared
    folders configuration page to set which specific directory you want to allow for
    which specific user:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要在我们的应用程序中注册一个用户到FTP管理UI，并为该用户设置一个工作目录。为此，在FileZilla管理员控制台上的菜单中点击编辑 |
    用户。然后导航到共享文件夹配置页面，以设置您希望允许特定用户访问的特定目录：
- en: '![](img/9e88207c-72d6-4a40-88a0-c3a2d6b989ce.png)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e88207c-72d6-4a40-88a0-c3a2d6b989ce.png)'
- en: For the purposes of this demo, I'm going to create a new user named `s_burns`,
    and we'll give that user permissions to access the source code directory of [Chapter
    9](https://cdp.packtpub.com/hands_on_network_programming_with_c__and__net_core/wp-admin/post.php?post=33&action=edit#post_32), *HTTP
    in .NET*. Note that the user I created for the FTP server is distinct from my
    local machine username. When you're writing an FTP client to log in and access
    a remote directory, you need the credentials for a user that is registered with
    the FTP server software, not with the host machine. If I were to try to download
    a file from my local server using my operating system username, I would get an
    unauthorized exception in response, even with the correct password. The user credentials
    should always for a user as registered with the server itself, and in general,
    unless you've written an FTP server to allow open and anonymous connection, you
    should always be connecting with credentials.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示的目的，我将创建一个名为`s_burns`的新用户，并授予该用户访问第9章[《.NET中的HTTP》](https://cdp.packtpub.com/hands_on_network_programming_with_c__and__net_core/wp-admin/post.php?post=33&action=edit#post_32)源代码目录的权限。请注意，我为FTP服务器创建的用户与我的本地机器用户名不同。当您编写FTP客户端以登录并访问远程目录时，您需要的是注册在FTP服务器软件上的用户凭据，而不是主机机的凭据。如果我要尝试使用我的操作系统用户名从我的本地服务器下载文件，即使密码正确，我也会收到一个未经授权的异常。用户凭据应该是注册在服务器本身的用户，通常情况下，除非您编写了一个允许开放和匿名连接的FTP服务器，否则您应该始终使用凭据进行连接。
- en: The FTP server itself will have whatever permissions for a given directory are
    granted to it by the host machine. So, if you run the server in a process where
    the system identity has limited read-only permissions, that will be the extent
    of operations it can provide to a client. By default, however, FileZilla is installed
    with the same privileges granted to the user who initiated the installation. Since
    I'm a local admin, FileZilla was installed with local admin privileges for my
    system. However, just because those are the permissions granted to the FileZilla,
    that doesn't mean that any client connecting to the server with valid credentials
    will also have local admin privileges. That would be a huge security hole! Instead,
    when registering a new user for your server, the administrator (you, in this case)
    grants that new user individual permissions for writing, reading, and deleting
    files in the shared directory. For the purposes of this chapter, just create yourself
    a new user with full permissions.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: FTP服务器本身将拥有主机机器授予它的给定目录的权限。因此，如果你在一个系统身份有限制只读权限的进程中运行服务器，那么它能够提供给客户端的操作范围就是这些。然而，默认情况下，FileZilla是以授予安装用户的相同权限安装的。由于我是本地管理员，FileZilla在我的系统上安装时具有本地管理员权限。但是，仅仅因为授予了FileZilla这些权限，并不意味着任何使用有效凭据连接到服务器的客户端也会拥有本地管理员权限。这将是一个巨大的安全漏洞！相反，当为你的服务器注册新用户时，管理员（在这种情况下是你）为新用户授予在共享目录中写入、读取和删除文件的单独权限。为了本章的目的，只需为自己创建一个具有完全权限的新用户即可。
- en: Writing an FTP client
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写FTP客户端
- en: Now we'll want to set up our application for interacting with our running FTP
    server. Some of you may remember from [Chapter 5](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml),
    *Generating Network Requests in C#*, that I mentioned the `FtpWebRequest`/`FtpWebResponse`
    subclasses of the `WebRequest` utility class. If you do, you're already well ahead
    of me now. These are the primary mechanisms through which .NET Core apps interact
    with FTP servers, and they are what we'll be leveraging to satisfy the requirements
    for this program.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将设置我们的应用程序以与正在运行的FTP服务器进行交互。你们中的一些人可能还记得[第5章](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml)，*在C#中生成网络请求*，我提到了`WebRequest`实用类中的`FtpWebRequest`/`FtpWebResponse`子类。如果你们记得，那么现在你们已经比我领先了。这些是.NET
    Core应用程序与FTP服务器交互的主要机制，我们将利用它们来满足这个程序的需求。
- en: Fetching a directory listing
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 获取目录列表
- en: 'We''ll request an instance of the `FtpWebRequest` class and then use its methods
    to view directory information about our listening FTP server. The instance will
    be pointing to `ftp://localhost`, which, as I mentioned, defaults to port `21` without
    actually specifying it, thanks to the `ftp://` schema. Just as HTTP has methods
    for interacting with the server, FTP has its own methods for determining how it
    intends to interact with the server. In code, that is set with a series of static
    constant properties that are used by the `FtpWebRequest` class to determine how
    to initiate the desired behavior:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将请求`FtpWebRequest`类的实例，然后使用其方法来查看我们监听FTP服务器的目录信息。该实例将指向`ftp://localhost`，正如我提到的，由于`ftp://`方案的存在，默认端口为`21`，实际上不需要指定。就像HTTP有与服务器交互的方法一样，FTP也有它自己的方法来确定如何与服务器交互。在代码中，这是通过一系列静态常量属性来设置的，这些属性由`FtpWebRequest`类使用，以确定如何启动所需的行为：
- en: '[PRE1]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The difference between HTTP methods or verbs and the `.Method` property you
    can set for `FtpWebRequest` is how they operate under the hood. As we saw in [Chapter
    9](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml), *HTTP in .NET*, an HTTP method
    is specified as a header on the request itself. If the method is permitted for
    the address specified, then the rest of the request is simply parsed and processed
    right away, and a response generated. In an FTP connection, however, the `Method` property
    you set on the `FtpWebRequest` instance is actually an abstraction for a sequence
    of commands sent to the server over the FTP command connection. The `FtpWebRequest`
    client will actually send the appropriate commands over its underlying TCP connection,
    and only proceed if it gets the expected responses from the server throughout
    the entire exchange.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP方法或动词与可以为`FtpWebRequest`设置的`.Method`属性之间的区别在于它们在底层是如何操作的。正如我们在第9章[《.NET中的HTTP》](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml)中看到的，HTTP方法是在请求本身上指定为一个头部的。如果该方法对于指定的地址是允许的，那么请求的其余部分将立即解析和处理，并生成一个响应。然而，在FTP连接中，您在`FtpWebRequest`实例上设置的`Method`属性实际上是对通过FTP命令连接发送到服务器的命令序列的抽象。`FtpWebRequest`客户端实际上将通过其底层的TCP连接发送适当的命令，并且只有在整个交换过程中从服务器获得预期的响应时才会继续进行。
- en: 'Now, before we can request the information we asked for with the server, we
    need to authenticate our application as acting on behave of a registered user
    of the server. For that, we''ll use the helpful utility class, `NetworkCredential`.
    This class encapsulates the basic concept of a username and password, and maps
    it to the underlying representation necessary for an authenticated network request.
    So, instead of having to worry about whether your authentication mechanism is
    a basic authentication or digest authentication, this class just lets you think
    of it in terms of your login information. Simply instantiate a new instance of
    it with the login credentials of the FTP user you created in FileZilla''s administration
    application, and apply those credentials to your request:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在我们能够向服务器请求我们所需的信息之前，我们需要验证我们的应用程序作为服务器注册用户的代表在操作。为此，我们将使用有用的实用工具类`NetworkCredential`。这个类封装了用户名和密码的基本概念，并将其映射到进行认证网络请求所需的底层表示。因此，您无需担心您的认证机制是基本认证还是摘要认证，这个类只是让您从登录信息的角度来考虑它。只需使用在FileZilla管理应用程序中创建的FTP用户的登录凭证实例化一个新的实例，并将这些凭证应用到您的请求中：
- en: '[PRE2]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'And once we''re logged in, we can interact with the request object the same
    as we did back in [Chapter 5](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml), *Generating
    Network Requests in C#. *We''ll request the response for our request, and then
    read the response data stream with `StreamReader`, writing the results to our
    output to confirm our expected results:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们登录，我们可以像在第5章[《在C#中生成网络请求》](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml)中做的那样与请求对象进行交互。我们将请求我们的请求的响应，然后使用`StreamReader`读取响应数据流，并将结果写入我们的输出以确认我们的预期结果：
- en: '[PRE3]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now simply await a call to this method in your `Main` method, and observe the
    results. Since the user I registered in my FTP server only has permissions for
    the root of the source code directory of [Chapter 9](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml), *HTTP
    in .NET*, I see the following output in my console when I run my application:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 现在只需在您的`Main`方法中等待对这个方法的调用，并观察结果。由于我在FTP服务器上注册的用户只有对[第9章](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml)《.NET中的HTTP》源代码目录根部的权限，所以我运行应用程序时在我的控制台看到以下输出：
- en: '![](img/ed84409e-a37b-4943-bc91-42d54493fc62.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ed84409e-a37b-4943-bc91-42d54493fc62.png)'
- en: 'If you''ve never seen the string of characters at the start of each of those
    lines before, those are codes that define the permissions you have for each file
    in the directory listing. If there is a letter present, it means the permission
    or status is true for that folder. The structure is as follows:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您以前从未见过每行开头的字符序列，这些是定义您在目录列表中每个文件权限的代码。如果有字母存在，这意味着该文件夹的权限或状态为真。结构如下：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The directory flag indicates whether the entry listed is, itself, a directory
    that can be navigated to and have files pulled from it. If `d` is present at the
    start of the entry, it''s a folder containing files, not a file itself. Next is
    the permission sets for each kind of user that might want to interact with it.
    These are groupings of three characters indicating which permissions members of
    the set have for the file listed. In the order they are displayed, those characters
    are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 目录标志表示列出的条目本身是否是一个目录，可以导航到并且可以从它那里提取文件。如果条目开头有`d`，它是一个包含文件的文件夹，而不是文件本身。接下来是每种可能与之交互的用户类型的权限集。这些是三个字符的组合，表示该组中成员对列出的文件有哪些权限。按显示顺序，这些字符如下：
- en: '`r`: read'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`r`：读'
- en: '`w`: write'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`w`：写'
- en: '`x`: execute'
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`x`：执行'
- en: So, for each set, there are three characters that are either set or null (represented
    here as a `-` character) indicating whether that set has the permission.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每一组，有三个字符要么被设置要么为空（在这里用`-`字符表示），表示该组是否有权限。
- en: 'Using this, we can see that, for the files in our directory, `FitnessApp` and
    `FitnessDataStore` are both directories (they have `d` at the start of their permissions
    record), and both of them have the following permissions for each group:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个，我们可以看到，在我们的目录中，`FitnessApp`和`FitnessDataStore`都是目录（它们的权限记录以`d`开头），并且它们对每个组的权限如下：
- en: 'Owner: Read, write, and execute permissions'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有者：读、写和执行权限
- en: 'Group: Read and execute permissions'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：读和执行权限
- en: 'Other: Read and execute permissions'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他：读和执行权限
- en: 'Meanwhile, we can see that the `fitness_data.txt` file is not a directory,
    and the permissions for each group for that listing are as follows:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，我们可以看到`fitness_data.txt`文件不是一个目录，该列表中每个组的权限如下：
- en: 'Owner: Read and write permissions'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有者：读和写权限
- en: 'Group: Read-only access'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组：只读访问
- en: 'Other: Read-only access'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其他：只读访问
- en: After the permissions, you see the current owner and group for the file (in
    this case, FTP) then the file size in bytes (0 for a directory), the last modified
    date, and the name of the file or sub-directory. So, here we can see that our
    FTP server is listed as the owner of our files and thus the permissions `rwx`
    are available for it to grant to users.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在权限之后，您可以看到文件（在这种情况下，FTP）的当前所有者和组，然后是文件大小（对于目录为0），最后修改日期和文件或子目录的名称。因此，我们可以看到我们的FTP服务器被列为我们的文件的所有者，因此它有`rwx`权限可以授予用户。
- en: 'Now that we''re successfully connected to our FTP server and able to access
    the directory information for the directory we have access to with our credentials,
    let''s look back at how the server responded to that request. If you have your
    FileZilla server administration console open, you would have seen all of the interactions
    between our running application and the server show up in the server console:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经成功连接到我们的FTP服务器，并且能够访问我们凭据可以访问的目录信息，让我们回顾一下服务器对该请求的响应。如果您打开了FileZilla服务器管理控制台，您会看到我们的运行应用程序和服务器之间的所有交互都显示在服务器控制台中：
- en: '![](img/d05d00e4-787b-4a84-a035-1865d1833051.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/d05d00e4-787b-4a84-a035-1865d1833051.png)'
- en: Note that the first line indicates that the TCP connection was initiated on
    `21`, even though we never specified the port in our URI. That first line beginning
    with a timestamp is the initiation of the command connection. From there, every
    blue line in the console indicates a signal sent from our application to the server,
    and each green line represents the response from the server. The upper-case four-letter
    words and abbreviations sent from our application are all FTP commands from the
    FTP standard for interactions, and they were all sent by our application code
    without us even realizing it. This all happened under the hood of our application
    software just because we set our request method to `WebRequestMethods.Ftp.ListDirectoryDetails`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，第一行表明TCP连接是在`21`端口上发起的，尽管我们在URI中从未指定该端口。以时间戳开始的这一行是命令连接的发起。从那里，控制台中的每一行蓝色都表示从我们的应用程序发送给服务器的信号，每一行绿色代表服务器的响应。从我们的应用程序发送的所有的四个大写字母单词和缩写都是FTP标准中的FTP命令，它们都是我们的应用程序代码发送的，我们甚至都没有意识到。这一切都是在我们的应用程序软件的底层发生的，仅仅因为我们设置了我们的请求方法为`WebRequestMethods.Ftp.ListDirectoryDetails`。
- en: Transferring a file
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 文件传输
- en: So, now that we understand how the command connection to an FTP server is initiated
    under the hood, and how that allows us to open a data connection, let's use that
    to actually request a file. We'll use the same request processing structure we
    saw for building a request and then fetching the response back in [Chapter 5](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml),
    *Generating Network Requests in C#*. This should all feel pretty familiar at this
    point, but I will take advantage of a few of the `FtpWebRequest` class's specific
    properties to highlight some of the options at your disposal. So, let's write
    the method to download a file.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们了解了在底层如何通过命令连接到FTP服务器，以及它是如何允许我们打开数据连接的，让我们利用这一点来实际请求一个文件。我们将使用我们在[第5章](b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml)中看到的相同的请求处理结构，即[C#中生成网络请求]。到目前为止，这一切都应该感觉非常熟悉，但我将利用`FtpWebRequest`类的一些特定属性来突出一些你可以使用的选项。那么，让我们编写下载文件的函数。
- en: 'The first thing we''ll do differently will be specifying the sub-directory
    path for the file we want to look up. We''ll just use the `Startup.cs` file from
    FitnessApp, so it''s easy enough to confirm that we transferred it correctly.
    Then, we want to set the request `Method` property to the value of `WebRequestMethods.Ftp.DownloadFile`.
    Finally, we''ll explicitly notify our server to operate in passive mode, which
    means our application will, behind the scenes, establish its own connection to
    the remote server on `20` (the default connection port for data connections to
    an FTP server) and then request the file once the connection is open. So, the
    initialization code for our download method will look like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先要做的事情将是指定我们想要查找的文件的子目录路径。我们将使用FitnessApp中的`Startup.cs`文件，这样就可以很容易地确认我们已经正确地传输了它。然后，我们将请求的`Method`属性设置为`WebRequestMethods.Ftp.DownloadFile`的值。最后，我们将明确通知服务器以被动模式操作，这意味着我们的应用程序将在幕后在`20`（FTP服务器数据连接的默认连接端口）上建立自己的连接到远程服务器，然后一旦连接打开，就请求该文件。因此，我们的下载方法的初始化代码将看起来像这样：
- en: '[PRE5]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, to copy the file, we''ll be reading directly out of the response stream,
    and writing it into `StreamWriter` for our destination file. This will look complicated
    because of the nested scope, but all those tabs are only there to handle contexts
    for each disposable `Stream` object and its respective `Reader` or `Writer` helper
    class:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，为了复制文件，我们将直接从响应流中读取，并将其写入到我们的目标文件的`StreamWriter`中。由于嵌套的作用域，这看起来可能很复杂，但所有那些制表符只是为了处理每个可处置的`Stream`对象及其相应的`Reader`或`Writer`辅助类：
- en: '[PRE6]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now let''s add a call to this method to our `Main` method, which should look
    like this:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们在我们的`Main`方法中添加对这个方法的调用，它应该看起来像这样：
- en: '[PRE7]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: If you run this project from your terminal, your output should list the directory
    structure, and when navigating to the root of the project, we should find our
    `Copy_Startup.cs` file, looking exactly as we expect it to!
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你从终端运行此项目，你的输出应该列出目录结构，并且当导航到项目的根目录时，我们应该找到我们的`Copy_Startup.cs`文件，看起来正好如我们所期望的那样！
- en: Uploading a file via FTP
  id: totrans-86
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过FTP上传文件
- en: To complete this sample client, let's look at uploading to the server. Remember,
    it's the FTP, not the file download protocol. File transmission can go both ways.
    For this method, we'll be converting our file to a byte stream to upload to pass
    along with our request once the connection is established.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 为了完成这个客户端示例，让我们看看如何上传到服务器。记住，这是FTP，而不是文件下载协议。文件传输可以双向进行。对于这个方法，我们将把我们的文件转换为字节流，以便在建立连接后与我们的请求一起上传。
- en: 'We''ll also be pointing our `WebRequest` URI to the new yet-to-be-created file.
    We''ll just be copying the `Program.cs` file from our current project to the root
    of the remote directory. So, let''s see how the initialization code looks:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将把我们的`WebRequest` URI指向新创建的文件。我们只是将当前项目的`Program.cs`文件复制到远程目录的根目录。那么，让我们看看初始化代码看起来像什么：
- en: '[PRE8]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'So far, so good. Now we''ll need to create a byte array and write our `Program.cs`
    file to it. Then, write that byte array to the request stream. This should be
    pretty familiar territory for you after [Chapter 6](b5d28c0a-6e7c-4547-855d-e6c6d1842bd6.xhtml),
    *Streams, Threads, and Asynchronous Data Transfer*:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。现在我们需要创建一个字节数组并将我们的`Program.cs`文件写入其中。然后，将这个字节数组写入请求流。在你阅读了[第6章](b5d28c0a-6e7c-4547-855d-e6c6d1842bd6.xhtml)后，*流、线程和异步数据传输*，这应该对你来说应该很熟悉：
- en: '[PRE9]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Finally, to actually transmit the request to upload our file and the data stream
    with that file's contents, we just have to request a response from the server.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，为了实际传输上传我们的文件以及该文件内容的流，我们只需从服务器请求一个响应。
- en: '[PRE10]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: And with that, we're uploading a file to our remote FTP server. Simply add a
    line to our `Main` method, and run the application. If you've configured your
    server the same way I did, you should now see a copy of the program we just wrote
    sitting in the root directory for the [Chapter 9](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml), *HTTP
    in .NET*,  source code, right next to the `FitnessApp` and the `FitnessDataStore`
    project folders.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们正在将文件上传到我们的远程FTP服务器。只需在我们的`Main`方法中添加一行，然后运行应用程序。如果您以与我相同的方式配置了您的服务器，现在您应该在我们的[第9章](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml)的根目录中看到我们刚刚编写的程序的副本，即.NET中的*HTTP*源代码，紧挨着`FitnessApp`和`FitnessDataStore`项目文件夹。
- en: Securing FTP requests
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 保护FTP请求
- en: While you may suspect that the act of providing user credentials to our server
    meant there was some measure of security involved in our file access, we were
    actually interacting with our server in an entirely unsecure manner. Those credentials
    were only of value the moment they were received by the server and our command
    connection was established. After that though, they provided no more security
    of the data we were transmitting than if we had allowed entirely anonymous access
    to our directory. So, let's look at why that is, and how to fix it.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然您可能怀疑向我们的服务器提供用户凭证意味着在文件访问中涉及了一定程度的安全性，但实际上我们是以完全不安全的方式与我们的服务器交互的。这些凭证只有在服务器收到它们并且我们的命令连接建立的那一刻才有价值。然而，在那之后，它们为我们传输的数据提供的保护并不比我们允许完全匿名访问我们的目录更多。因此，让我们看看为什么是这样，以及如何解决这个问题。
- en: The risks of FTP
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP的风险
- en: With our example software, there isn't any real concern for security because
    our data is never transmitted over an actual network connection. Our requests
    are never making it past our `hosts` file, because we are always pointing to `localhost`.
    However, if that wasn't the case, and we needed to authenticate with a remote
    server, and we did so using the standard FTP connection we set up for this demo,
    we'd be in trouble. Those credentials we used to log in to the server were sent
    entirely in plain text. Furthermore, the data connection that was eventually established
    was also sent over the wire in an entirely unsecured fashion.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 使用我们的示例软件，我们无需对安全性有任何真正的担忧，因为我们的数据永远不会通过实际的网络连接进行传输。我们的请求永远不会越过我们的`hosts`文件，因为我们总是指向`localhost`。然而，如果情况不是这样，我们需要与远程服务器进行身份验证，并且我们使用为这个演示设置的FTP标准连接这样做，我们就会遇到麻烦。我们用来登录服务器的凭证完全以纯文本形式发送。此外，最终建立的数据连接也是以完全未加密的方式通过电线发送的。
- en: If we attempted to communicate with a remote server using only the server credentials
    we provided, we would have been at risk of falling prey to a variety of different
    malicious attacks. Imagine a simple man-in-the-middle attacker reading the byte
    stream for a file containing **Personally Identifiable Information** (**PII**),
    such as a social security number, medical information, or bank account details.
    The FTP standard isn't actually designed to account for that kind of risk. What's
    more, since the file transfer mechanisms are negotiated ahead of time via the
    command connection, the actual file data is usually sent as an uninterrupted stream
    of bytes, easily re-assembled and read by a malicious party. Simply accept the
    underlying packet stream in order, remove the standard transport layer headers,
    and concatenate the bytes as they are received. For this reason, it's generally
    pretty risky to use standard FTP connections outside of the context of a well-protected
    private network.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们仅使用我们提供的服务器凭证尝试与远程服务器进行通信，我们就会面临各种不同恶意攻击的风险。想象一下一个简单的中间人攻击者读取包含**个人身份信息**（**PII**）的文件的字节流，例如社会安全号码、医疗信息或银行账户详情。FTP标准实际上并没有设计来考虑这种风险。更重要的是，由于文件传输机制是在命令连接之前协商的，实际的文件数据通常以不间断的字节流的形式发送，容易被恶意方重新组装和读取。只需按顺序接受底层的包流，移除标准的传输层头部，并将接收到的字节拼接起来。因此，在受保护的私有网络之外使用标准FTP连接通常是非常危险的。
- en: Securing FTP with SFTP and FTPS
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用SFTP和FTPS保护FTP
- en: While there are security concerns inherent to FTP, there are, fortunately, a
    couple of approaches that you can take to mitigate your exposure to those risks.
    The two we'll be looking at both seek to make it substantially more difficult
    for a malicious actor to interfere with or read the content of your files in transit.
    So what are they?
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然FTP固有的存在一些安全风险，但幸运的是，你可以采取一些方法来减轻这些风险的影响。我们将探讨的两个方法都旨在使恶意行为者干扰或读取传输中的文件内容变得非常困难。那么，它们是什么呢？
- en: SFTP
  id: totrans-102
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SFTP
- en: Our old friends the **Internet Engineering Task Force** (**IETF**) designed
    a new standard for file transfer interactions that leveraged the **Secure Shell**
    (**SSH**) protocol for authentication and secure tunneling. Dubbed **SSH File
    Transfer Protocol**, or **Secure File Transfer Protocol** (**SFTP**), it was built
    as an extension to SSH that provisioned file transfer capabilities where they
    didn't previously exist.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的老朋友**互联网工程任务组**（**IETF**）为文件传输交互设计了一个新标准，该标准利用了**安全外壳协议**（**SSH**）进行身份验证和安全的隧道传输。被称为**SSH文件传输协议**，或**安全文件传输协议**（**SFTP**），它被构建为SSH的一个扩展，提供了之前不存在的文件传输能力。
- en: This application protocol provides security by establishing a secure tunnel
    between the two host machines. All data is sent that via tunnel once the client
    host has been authenticated by the server host machine (as opposed to the simple
    server-user authentication of our example in the previous section). This is not
    entirely dissimilar to simply transferring files over a VPN. It simply uses a
    different security protocol. This mechanism is less an implementation of FTP with
    security, though, and more an extension to SSH to also provide FTP functionality.
    As such, the out-of-the-box support for it in .NET Core is almost non-existent.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此应用协议通过在两个主机之间建立安全隧道来提供安全性。一旦客户端主机被服务器主机认证（与上一节中我们示例中的简单服务器用户认证不同），所有数据都通过该隧道发送。这与简单地通过VPN传输文件并没有太大的不同。它只是使用不同的安全协议。然而，这种机制与其说是FTP的安全实现，不如说是SSH的扩展，以提供FTP功能。因此，在.NET
    Core中，对它的支持几乎是默认的。
- en: FTPS
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTPS
- en: While SFTP exists as a file transfer subsystem added as an extension to SSH,
    the alternative approach for encrypting traffic sent over an open connection (one
    that hasn't established a secure tunnel between hosts) is to use what's called
    FTPS. An abbreviation of FTP over SSL, or FTP Secure, FTPS leverages the encryption
    mechanisms of the underlying transport layer to provide encryption for data transferred
    between hosts. This is almost exactly the same mechanism that underlies the HTTPS
    protocol we looked at in [Chapter 9](e93c024e-3366-46f3-b565-adc20317e6ec.xhtml),
    *HTTP in .NET*.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然SFTP作为一个文件传输子系统被添加到SSH中，但加密通过开放连接（尚未在主机之间建立安全隧道）发送的流量的替代方法是用所谓的FTPS。FTPS是FTP
    over SSL的缩写，或FTP Secure，FTPS利用底层传输层的加密机制为在主机之间传输的数据提供加密。这与我们在第9章中探讨的HTTPS协议几乎完全相同。
- en: In modern implementations, this will use the secure transport mechanism of whatever
    underlying transport-layer protocol is being used by the FTP client. Today, that
    means that it's often leveraging TLS, but historically the encryption mechanism
    of choice has been SSL. Thus, when you want to configure your FTP clients to leverage
    FTPS, you simply set the `EnableSsl` property on your `FtpWebRequest` object to
    true. Then, provided your server supports FTP over TLS (or SSL), you'll be taking
    advantage of it every time you connect.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代实现中，这将会使用FTP客户端正在使用的底层传输层协议的安全传输机制。今天，这意味着它通常利用TLS，但历史上选择的加密机制一直是SSL。因此，当你想要配置你的FTP客户端以利用FTPS时，你只需将你的`FtpWebRequest`对象的`EnableSsl`属性设置为true。然后，如果你的服务器支持通过TLS（或SSL）的FTP，你每次连接都会利用它。
- en: While there is a fair bit more to say on the subject of SSL and TLS and the
    security they provide, that's the subject of a later chapter. So, for now, just
    follow the simple rule of always using FTPS in your code where possible. The risks
    are just not worth it.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然关于SSL和TLS及其提供的安全性的话题还有很多可以说的，但这将是后续章节的主题。所以，现在，只需遵循一个简单的规则：在可能的情况下，始终在你的代码中使用FTPS。风险不值得。
- en: SMTP and MIME
  id: totrans-109
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SMTP和MIME
- en: Finally, we'll round out our exploration of the application-layer protocols
    with what is probably the second most common protocol (behind HTTP). And yet,
    as commonplace as it is, I would guess that a staggering number of people who
    benefit from SMTP don't even know it exists. So, what is it? How would we use
    it, and why would we use it?
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过探讨可能是第二常见的协议（仅次于HTTP）来结束我们对应用层协议的探索。尽管它如此普遍，但我猜受益于SMTP的令人震惊的人数甚至不知道它的存在。那么，它是什么呢？我们如何使用它，为什么我们要使用它？
- en: The email protocol
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 邮件协议
- en: 'First defined all the way back in 1982, the **Simple Mail Transfer Protocol**
    (**SMTP**) is the de-facto protocol for transmitting electronic messages. It''s
    a connection-oriented protocol using the client-server architecture we''ve become
    so familiar with over the course of this book. Similar to FTP, SMTP transactions
    happen over a sequence of commands and responses transmitted over a dedicated
    SMTP session. Those commands notify the server of what the addressing information
    is for a message (the To: and From: components of an email), transmit the message
    itself, and finally confirm receipt of the message.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**简单邮件传输协议**（**SMTP**）最早在1982年定义，是传输电子消息的事实上的协议。它是一个面向连接的协议，使用我们在本书中已经非常熟悉的客户端-服务器架构。与FTP类似，SMTP事务通过一系列命令和响应在专用的SMTP会话中传输。这些命令通知服务器消息的地址信息（电子邮件的“收件人”和“发件人”部分），传输消息本身，并最终确认消息的接收。'
- en: Unlike FTP, though, these interactions all happen over the same single connection
    to the server. Once a connection is established to the server (usually on the
    default SMTP port, `25`, for those who were curious), that connection constitutes
    a session*.* Once that session has begun, the commands sent by the server are
    received and responded to until all of the components of the message have been
    transmitted and the session is terminated.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 与FTP不同，这些交互都在与服务器相同的单一连接上发生。一旦与服务器建立连接（对于好奇的人来说，通常是在默认的SMTP端口`25`），该连接就构成了一个会话。一旦会话开始，就会接收并响应服务器发送的命令，直到消息的所有组件都已传输，会话结束。
- en: The important thing to note about SMTP is that it is entirely about the *outbound*
    transmission of a new message. There is no mechanism in the protocol itself to
    request messages back from a server. Applications that maintain a mailbox for
    users to access are doing so by leveraging entirely different messaging protocols,
    such as the **Internet Message Access Protocol** (**IMAP**) or the **Post Office
    Protocol** (**POP**). However, while those protocols are useful to update your
    phone's mail app, the application will still depend on SMTP to transmit any new
    messages you want to send to a remote address.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 关于SMTP的重要一点是，它完全是关于新消息的*出站*传输。该协议本身没有请求从服务器返回消息的机制。为用户提供邮箱以访问的应用程序是通过利用完全不同的消息协议来做到这一点的，例如**互联网消息访问协议**（**IMAP**）或**邮局协议**（**POP**）。然而，尽管这些协议对于更新手机邮件应用很有用，但应用程序仍然依赖于SMTP来传输您想要发送到远程地址的任何新消息。
- en: This outbound-only property and the need for software implementing various distinct
    protocols to meet the expectations of users of an email app means that the full
    process of managing the receipt and delivery of email can be a painful one. It
    typically involves multiple subsystems working in tandem to process every step
    of the transaction reliably.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这种仅限出站的属性以及软件实现各种不同协议以满足电子邮件应用用户期望的需要意味着，管理电子邮件接收和交付的整个过程可能是一个痛苦的过程。这通常涉及多个子系统协同工作，以确保可靠地处理交易的每一步。
- en: Extending SMTP with MIME
  id: totrans-116
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用MIME扩展SMTP
- en: Having been defined in 1982, there are a number of limitations to SMTP when
    implemented strictly according to the standard. This includes the range of valid
    character encodings and alternative representations of certain content, such as
    images or sounds, directly in the message body of an email. To that end, IETF
    extended the protocol with the **Multipurpose Internet Mail Extensions** (**MIME**).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在1982年就已经定义，严格按照标准实施时，SMTP存在一些局限性。这包括有效字符编码的范围以及某些内容（如图像或声音）的替代表示，这些内容直接在电子邮件的消息正文中。为此，IETF通过**多用途互联网邮件扩展**（**MIME**）扩展了该协议。
- en: 'MIME provides users with the following: non-ASCII character representation;
    audio, image, video, and application attachments; multipart message bodies; and
    additional context and metadata in the message headers. Interestingly, this is
    where SMTP overlaps the most with HTTP. Even though MIME was originally designed
    and implemented as an SMTP extension, the ability to specify the character encoding
    and data structure of an incoming message was quickly identified as a useful feature
    for other application protocols transmitting text content. Naturally, it was adopted
    into use by HTTP in no time. `MIME-type` is the name of the value of the `ContentType`
    header sent with HTTP messages that contain a message body, and this is exactly
    how the extension is used by SMTP.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: MIME为用户提供以下功能：非ASCII字符表示；音频、图像、视频和应用附件；多部分消息体；以及消息头中的附加上下文和元数据。有趣的是，这正是SMTP与HTTP重叠最多的地方。尽管MIME最初是作为SMTP扩展设计和实现的，但指定传入消息的字符编码和数据结构很快就被识别为其他传输文本内容的应用协议的有用功能。自然地，HTTP很快就采用了这一功能。"MIME-type"是包含消息体的HTTP消息中`ContentType`头部的值名称，这正是SMTP使用扩展的方式。
- en: Hopefully, these commonalities between SMTP, FTP, and HTTP highlight for you
    just how much of the core application-layer protocol implementations are similar
    to one another.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这些SMTP、FTP和HTTP之间的共性能向您突出显示核心应用层协议实现之间有多么相似。
- en: SMTP in .NET Core
  id: totrans-120
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core中的SMTP
- en: There are a lot of reasons why you might want to incorporate SMTP into your
    software. Maybe you want to give users a feedback mechanism for emailing the development
    team directly, and you want to do that with an SMTP client behind the scenes.
    Or maybe you want to wire up your error-handling infrastructure to send out emails
    to the support staff whenever exceptions of an unacceptable nature start getting
    thrown by your application. Whatever the case, you'll likely need a client for
    building those mail messages and sending them out to the target recipient.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能有很多理由想在软件中集成SMTP。也许您想为用户提供一种直接向开发团队发送电子邮件的反馈机制，并且您希望在幕后使用SMTP客户端来实现这一点。或者，也许您想将错误处理基础设施连接起来，以便在应用程序抛出不可接受的异常时向支持人员发送电子邮件。无论情况如何，您可能需要一个客户端来构建这些邮件消息并将它们发送到目标收件人。
- en: While there are solutions for just such a problem available to you, they are
    not currently provided by Microsoft or the .NET Core framework. While the .NET
    Framework contained a `SmtpClient` class which, along with a `MailMessage` class,
    and could be used to generate and send automated emails to a valid SMTP server,
    those classes didn't make it into the spec for the .NET Core 1.0 release. They
    did make it into the initial .NET Core 2.0 release, but almost as soon as they
    arrived, they were deprecated by Microsoft for insufficient support for modern
    features of the protocol. What's more, in their deprecation notes, they explicitly
    state that they deprecated the libraries because they were "poorly designed."
    I took this to mean "not designed well enough to grow with the protocol."
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管您可以使用针对此类问题的解决方案，但目前这些解决方案并非由微软或.NET Core框架提供。虽然.NET Framework中包含一个`SmtpClient`类，该类与`MailMessage`类一起使用，可以生成并发送自动电子邮件到有效的SMTP服务器，但这些类并未包含在.NET
    Core 1.0版本的规范中。它们确实包含在最初的.NET Core 2.0版本中，但几乎一出现，微软就因为对协议现代特性的支持不足而将其弃用。更甚者，在它们的弃用说明中，他们明确表示弃用这些库是因为它们“设计不佳”。我理解为“设计得不够好，无法随着协议的发展而成长。”
- en: So, now, instead of their internal libraries, Microsoft recommends using a third
    party called MailKit, the source control and documentation for which can be found
    here: [https://github.com/jstedfast/MailKit](https://github.com/jstedfast/MailKit).
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在，微软建议使用一个名为MailKit的第三方库，其源代码控制和文档可以在以下链接找到：[https://github.com/jstedfast/MailKit](https://github.com/jstedfast/MailKit)。
- en: So, while there is support for robust message generation for SMTP, the nature
    of the interactions is such that we won't be covering them here. Instead, I'll
    just allow this to serve as an example as to why you should always check on the
    status of any libraries you've used in the past before you incorporate them into
    a new project. Even if they were excellent when you last used them, the march
    of progress might have rendered them obsolete and deprecated before you managed
    to use them in a new project. And with that, we can move on from the application-layer
    protocols and start looking at the lower-level transport layer that makes it all
    possible.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，尽管SMTP支持强大的消息生成，但交互的性质是这样的，我们不会在这里涵盖它们。相反，我将仅允许这作为一个例子，说明为什么你总是在将过去使用的任何库纳入新项目之前检查其状态。即使它们在你上次使用时很出色，进步的步伐可能在你能够在新项目中使用它们之前使它们过时和弃用。有了这一点，我们可以从应用层协议转移到查看使其成为可能的所有可能的底层传输层。
- en: Summary
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered a lot of ground on some of the most common application-layer
    protocols still in use today. We looked at how different protocols were designed
    and optimized to perform different distinct tasks. Then we looked at exactly how
    FTP is optimized to perform its task of remote file transfer and directory lookup.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们覆盖了今天仍在使用的某些最常见应用层协议的很多内容。我们探讨了不同的协议是如何设计和优化的，以执行不同的特定任务。然后我们具体探讨了FTP是如何优化以执行其远程文件传输和目录查找任务的。
- en: We learned how FTP uses two separate connections to communicate between clients.
    We saw how the command connection is set up to initialize the transfer of files,
    negotiate authentication, and determine the mechanism for the subsequent data
    connection. We looked at the variety of ways FTP can format the file for data
    transmission, and the various transmission techniques an FTP connection can be
    configured for. We also leveraged our FTP server admin console to observe the
    under-the-hood interactions going on between our application and the remote server
    when we were leveraging the high-level abstractions of the .NET `FtpWebRequest`
    and `FtpWebResponse` classes.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 我们学习了FTP如何使用两个独立的连接在客户端之间进行通信。我们看到了命令连接是如何设置的，以初始化文件传输、协商身份验证以及确定后续数据连接的机制。我们探讨了FTP可以格式化文件进行数据传输的多种方式，以及FTP连接可以配置的各种传输技术。我们还利用FTP服务器管理控制台观察了当我们在使用.NET
    `FtpWebRequest`和`FtpWebResponse`类的高级抽象时，我们的应用程序和远程服务器之间正在进行的底层交互。
- en: Once we were able to programmatically interact with our server, we looked at
    what sort of security considerations need to be made for FTP and got a general
    sense for how that was accomplished.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们能够以编程方式与我们的服务器交互，我们就研究了FTP需要考虑的安全问题，并大致了解了这是如何完成的。
- en: We wrapped up this chapter by looking at another common application-layer protocol
    with SMTP. We compared and contrasted its implementation with that of FTP and
    HTTP to understand what it does well, and then looked at its future on the .NET
    Core platform with the deprecation of the .NET libraries and the endorsement of
    third-party open source solutions. With that topic rounding out our exploration
    of the application layer of the OSI stack, we're well positioned to finally take
    a deep dive into the lower-level software components that enable all of this.
    In the next chapter, we'll finally be looking at the transport-layer protocols
    that make HTTP, FTP, and SMTP possible in the first place.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过查看另一个常见的应用层协议SMTP来结束本章。我们将其实现与FTP和HTTP进行了比较和对比，以了解它做得好的地方，然后探讨了在.NET Core平台上随着.NET库的弃用和第三方开源解决方案的认可，其未来的情况。随着这个主题结束我们对OSI堆栈应用层的探索，我们终于可以深入探讨使这一切成为可能的底层软件组件。在下一章中，我们将最终探讨使HTTP、FTP和SMTP成为可能的第一层传输层协议。
- en: Questions
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What are the primary differences between FTP and HTTP?
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP和HTTP之间的主要区别是什么？
- en: What are the two phases of FTP connections? How do they work?
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP连接有两个阶段吗？它们是如何工作的？
- en: What are the two modes for data transfer in FTP and how are they different from
    one another? When should you use one over the other?
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP中的数据传输有两种模式，它们之间有什么不同？何时应该使用其中一种而不是另一种？
- en: What are the three modes of FTP data transfer?
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP数据传输有三种模式吗？
- en: What are the three ways to encode data in transit in FTP? When should they be
    used?
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: FTP中编码传输中数据的三种方式是什么？何时应该使用它们？
- en: What are the definitions of SMTP and MIME? How do they relate to one another?
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SMTP 和 MIME 的定义是什么？它们之间有何关联？
- en: How is SMTP distinct from HTTP or FTP?
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: SMTP 与 HTTP 或 FTP 有何区别？
- en: Further reading
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: If you're interested in some of the ways others have used FTP and SMTP libraries,
    you can check out *.NET Standard** 2.0 Cookbook,* by* Fiqri Ismai**l*. There's
    a chapter dedicated to networking applications that includes an SMTP implementation.
    You can find it here: [https://www.packtpub.com/application-development/net-standard-20-cookbook.](https://www.packtpub.com/application-development/net-standard-20-cookbook)
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你感兴趣于了解其他人如何使用 FTP 和 SMTP 库的一些方法，你可以查阅由 Fiqri Ismail* 编著的 *.NET Standard** 2.0 Cookbook,*。其中有一章专门介绍网络应用程序，包括
    SMTP 实现。你可以在这里找到它： [https://www.packtpub.com/application-development/net-standard-20-cookbook.](https://www.packtpub.com/application-development/net-standard-20-cookbook)
