<html><head></head><body>
		<div><h1 id="_idParaDest-135" class="chapter-number"><a id="_idTextAnchor135"/>6</h1>
			<h1 id="_idParaDest-136"><a id="_idTextAnchor136"/>Leveraging Data and Services</h1>
			<p>Managing data is central to the operation of most applications. Learning how to load, maintain, and save that data is an important aspect of WinUI development. Two of the most important aspects of data management <a id="_idIndexMarker425"/>are <strong class="bold">state management</strong> and <a id="_idIndexMarker426"/>the <strong class="bold">service locator pattern</strong>. We will be covering these concepts and putting some of them to use in our application.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Understanding the WinUI application lifecycle</li>
				<li>Learning to use <strong class="bold">SQLite</strong> to store application data</li>
				<li>Learning to use the <strong class="bold">object-relational mapper</strong> (<strong class="bold">ORM</strong>) <strong class="bold">Dapper</strong> to quickly map objects in a data service</li>
				<li>Continuing to explore the service locator pattern and implementing it with our data service</li>
			</ul>
			<p>By the end of this chapter, you will have a working understanding of the WinUI application lifecycle and will know how to manage data and state in your projects.</p>
			<h1 id="_idParaDest-137"><a id="_idTextAnchor137"/>Technical requirements</h1>
			<p>To follow along with the examples in this chapter, the following software is required:</p>
			<ul>
				<li>Windows 10 version 1803 (version 17134) or newer</li>
				<li>Visual Studio 2022 or newer, with the .NET desktop development workload configured for Windows App SDK development</li>
			</ul>
			<p>The source code for this chapter is available on GitHub at <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter06">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter06</a>.</p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor138"/>Managing application state with app lifecycle events</h1>
			<p>Before <a id="_idIndexMarker427"/>working with data in any application, it is important to understand the application lifecycle for the target application platform. We have touched on these concepts briefly, but now, it’s time to take a deeper dive into the Windows application<a id="_idIndexMarker428"/> lifecycle for <strong class="bold">WinUI on </strong><strong class="bold">Desktop</strong> applications.</p>
			<h2 id="_idParaDest-139"><a id="_idTextAnchor139"/>Exploring Windows application lifecycle events</h2>
			<p>WinUI on desktop applications<a id="_idIndexMarker429"/> has a slightly <a id="_idIndexMarker430"/>different set of lifecycle events than other desktop .NET applications. WPF and <strong class="bold">Windows Forms</strong> (<strong class="bold">WinForms</strong>) applications<a id="_idIndexMarker431"/> are either running or they’re not. There are several events that occur while launching and shutting down WPF and WinForms applications:</p>
			<div><div><img src="img/B20908_06_01.jpg" alt="Figure 6.1 – WPF and WinForms application life﻿cycle events"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.1 – WPF and WinForms application lifecycle events</p>
			<p class="callout-heading">Note</p>
			<p class="callout">We won’t go into the details here, as our primary focus is building WinUI 3 applications. However, for the two WPF events that fall outside of the launch and close, their sequences are as follows:</p>
			<p class="callout">1. <code>FrameworkElement.Unloaded</code>: This<a id="_idIndexMarker432"/> event fires when an element is removed from the WPF visual tree. It does not fire during application shutdown.</p>
			<p class="callout">2. <code>Application.SessionEnding</code>: This <a id="_idIndexMarker433"/>event fires when the current Windows user logs off or shuts down Windows. In the event handler, you can request that Windows cancels the process by setting the <code>SessionEndingCancelEventArgs.Cancel</code> property to <code>true</code>.</p>
			<h2 id="_idParaDest-140"><a id="_idTextAnchor140"/>Lifecycle events of WinUI applications</h2>
			<p>Let’s talk about<a id="_idIndexMarker434"/> the WinUI lifecycle. Lifecycle events give you a chance to initialize any data and state when your application starts execution, and this allows you to clean up or save the state when the application is closed. In UWP applications, you also had the ability to handle events when the application was suspended or resumed because of a user or operating system action. WinUI, like other .NET desktop applications, doesn’t have this ability.</p>
			<p>In the <code>Application</code> and <code>Window</code> classes, there are only a couple of events that can be handled. Every <code>Application</code> class overrides the <code>OnLaunched</code> method. This method will be invoked exactly once, when the application is launched either by a user or the operating system. We’ve already worked with the <code>OnLaunched</code> method in our sample application. It’s where <code>MainWindow</code> is created and where we added a call to the method to configure our IOC container. In a new WinUI application, the <code>OnLaunched</code> method will look like this:</p>
			<pre class="source-code">
protected override void OnLaunched(Microsoft.UI.Xaml.LaunchActivatedEventArgs args)
{
    m_window = new MainWindow();
    m_window.Activate();
}</pre>			<p>The <code>Application</code> and <code>Window</code> classes only inherit from the .NET <code>Object</code> class, so there are no inherited events to leverage either. This is not the case with the <code>Page</code> class, which we will discuss shortly. First, we’re going to discuss <code>Window</code>, which has a couple of events we can leverage when managing an app’s lifecycle.</p>
			<p>The <code>Window</code> class<a id="_idIndexMarker435"/> in WinUI does not have a <code>Loaded</code> event, which is used in a WPF <code>Window</code> class to indicate that the window and its contents are loaded and available for interaction. The <code>Window.Activated</code> event can be used in place of a <code>Loaded</code> event, but the <code>Activated</code> event fires every time the window receives focus. If this is your only option, you will need to add a flag to check whether it’s the first time that <code>Activated</code> has fired.</p>
			<p>The other lifecycle event in <code>Window</code> is the <code>Closed</code> event, which fires when the window has closed. If it is the last remaining window, usually <code>MainWindow</code>, the application will end after the window closes. This is where you should save any application data and state information.</p>
			<p>This is the extent of the application lifecycle events provided out of the box by the <code>Application</code> and <code>Window</code> classes. However, you can tap into some other events provided by <code>FrameworkElement</code>, which is a base class of <code>Page</code> and all the other controls in WinUI.</p>
			<h2 id="_idParaDest-141"><a id="_idTextAnchor141"/>Additional lifecycle events with FrameworkElement objects</h2>
			<p>Every control in WinUI inherits from <code>Control</code>, which inherits from <code>FrameworkElement</code>. Even <a id="_idIndexMarker436"/>the <code>Page</code> control, which we added to the <code>Control</code>, through its inheritance from <code>UserControl</code>.</p>
			<p>The <code>FrameworkElement</code> class provides<a id="_idIndexMarker437"/> three useful events that developers can leverage for the application lifecycle:</p>
			<ul>
				<li><code>Loading</code>: This<a id="_idIndexMarker438"/> event occurs when the loading process has started. This event can be leveraged to start fetching and processing data from services or other sources. You could also start loading data sooner, in the constructor of the current <code>Window</code> or <code>Page</code>, or even in <code>Application.OnLoaded</code>.</li>
				<li><code>Loaded</code>: The <code>Loaded</code> event<a id="_idIndexMarker439"/> is invoked when the current element and all its children are loaded and ready for interaction. Do not try to manipulate these elements before they are loaded, or the app will raise a runtime exception.</li>
				<li><code>Unloaded</code>: This <a id="_idIndexMarker440"/>event is fired when the current element has been unloaded and removed from<a id="_idIndexMarker441"/> the <code>Page</code>, you can use this to clean up resources or save any state for the page.</li>
			</ul>
			<p class="callout-heading">Note</p>
			<p class="callout">We haven’t discussed the WinUI visual tree up to this point. The concept of trees, physical and logical, in WinUI is the same as in other XAML frameworks. We will discuss the physical tree and logical tree in more detail when we discuss debugging WinUI applications in <a href="B20908_11.xhtml#_idTextAnchor330"><em class="italic">Chapter 11</em></a>, <em class="italic">Debugging WinUI Apps with Visual Studio</em>. To learn more now, Microsoft Learn has a great WPF article about trees: <a href="https://learn.microsoft.com/dotnet/desktop/wpf/advanced/trees-in-wpf">https://learn.microsoft.com/dotnet/desktop/wpf/advanced/trees-in-wpf</a>.</p>
			<p>You can handle the <code>Loaded</code> event<a id="_idIndexMarker442"/> for any control in your <a id="_idIndexMarker443"/>current view, whether it’s <code>Window</code> or <code>Page</code>, but always keep performance in mind. The <code>Loaded</code> event for the topmost <code>FrameworkElement</code> in the visual tree will not be fired until those of all its children have been completed. Network and filesystem operations can be expensive, so try to minimize and consolidate the calls to load the data needed to present your view whenever possible.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For more <a id="_idIndexMarker444"/>information about handling lifecycle events, read the following Microsoft Learn page: <a href="https://learn.microsoft.com/windows/apps/windows-app-sdk/applifecycle/applifecycle">https://learn.microsoft.com/windows/apps/windows-app-sdk/applifecycle/applifecycle</a>.</p>
			<p>Now that you have a solid understanding of WinUI’s lifecycle, let’s start working with some real data that will need to be persisted between user sessions.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor142"/>Creating a SQLite data store</h1>
			<p>Until this <a id="_idIndexMarker445"/>point, the <strong class="bold">My Media Collection</strong> project has only worked <a id="_idIndexMarker446"/>with data stored inside in-memory collections. This means that every time the application is closed, all the user’s data is lost. It has also meant calling a method to populate all the lists with hardcoded seed data each time the application is launched.</p>
			<p>In the previous chapter, we took the first step in creating a maintainable data service for the application. By creating a data service class that implements <code>IDataService</code>, no changes will be required in the <code>ViewModel</code> classes when we start loading data from a database. This section will focus on creating a new <code>SqliteDataService</code> class so that we can use <strong class="bold">SQLite</strong> for data access. The starting code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter06/Start">https://github.com/PacktPublishing/Learn-WinUI-3-Second-Edition/tree/master/Chapter06/Start</a>.</p>
			<h2 id="_idParaDest-143"><a id="_idTextAnchor143"/>What is SQLite?</h2>
			<p><strong class="bold">SQLite</strong> (found at <a href="https://sqlite.org/">https://sqlite.org/</a>) is a<a id="_idIndexMarker447"/> SQL-based database that is frequently <a id="_idIndexMarker448"/>used by mobile apps and simple desktop applications. It is a popular choice because it is small, fast, and self-contained in a single file. There are SQLite libraries available for virtually every platform. We <a id="_idIndexMarker449"/>will use Microsoft’s <strong class="bold">Microsoft.Data.Sqlite</strong> ADO.NET provider for SQLite.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">For <a id="_idIndexMarker450"/>more information about Microsoft’s SQLite provider, you can read <a href="https://learn.microsoft.com/dotnet/standard/data/sqlite/">https://learn.microsoft.com/dotnet/standard/data/sqlite/</a>. To learn more about using SQLite with WinUI projects, check <a id="_idIndexMarker451"/>out this Microsoft Learn article: <a href="https://learn.microsoft.com/windows/apps/develop/data-access/sqlite-data-access">https://learn.microsoft.com/windows/apps/develop/data-access/sqlite-data-access</a>.</p>
			<h2 id="_idParaDest-144"><a id="_idTextAnchor144"/>Adding SQLite as a data service</h2>
			<p>Follow<a id="_idIndexMarker452"/> these steps:</p>
			<ol>
				<li>Start by adding the <strong class="bold">Microsoft.Data.Sqlite</strong> NuGet package to the <strong class="bold">MyMediaCollection</strong> project by opening <strong class="bold">Package Manager Console</strong> from <strong class="bold">View</strong> | <strong class="bold">Other Windows</strong> | <strong class="bold">Package Manager Console</strong> and running the following command. Also, make sure the <strong class="bold">MyMediaCollection</strong> project is selected in the <strong class="bold">Package Manager Console</strong> window’s project dropdown before running this command:<pre class="source-code">
Install-Package Microsoft.Data.Sqlite</pre><p class="list-inset">Running this command is equivalent to finding and adding the package from the <code>SqliteDataService</code> in the <code>DataService</code> class into it as a starting point.</li>
				<li>Now, open <code>using</code> statements to the top of the file:<pre class="source-code">
using Microsoft.Data.Sqlite;
using System.IO;
using System.Threading.Tasks;
using Windows.Storage;</pre><p class="list-inset">The <code>System.IO</code> and <code>Windows.Storage</code> namespaces will be used when we initialize the SQLite database file, and we’ll need the <code>System.Threading.Tasks</code> namespace imported to work with some <code>async</code> tasks.</p></li>				<li>Next, add a new constant to the class to hold the database’s filename:<pre class="source-code">
private const string DbName = "mediaCollectionData.db";</pre></li>				<li>Now, let’s<a id="_idIndexMarker453"/> create a private method to create or open the database file, create a <code>SqliteConnection</code> class for the database, open it, and return it to the caller. This method can be used throughout the class whenever a new database connection is needed. The database file will be created in the user’s <code>LocalFolder</code>, which means the application’s data will be saved with the user’s local Windows profile data:<pre class="source-code">
private async Task&lt;SqliteConnection&gt; GetOpenConnectionAsync()
{
    await ApplicationData.Current.LocalFolder.CreateFileAsync(DbName, CreationCollisionOption.OpenIfExists).AsTask().ConfigureAwait(false);
    string dbPath = Path.Combine(ApplicationData.Current.LocalFolder.Path, DbName);
    var cn = new SqliteConnection($"Filename={dbPath}");
    cn.Open();
    return cn;
}</pre><p class="list-inset">Note that we have declared this method as <code>async</code> and that it uses the <code>await</code> keyword when opening or creating the file. It is a good practice to use async/await when using external resources such as files, network connections, or databases to keep your application responsive.</p></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">To find out more about <a id="_idIndexMarker454"/>async/await with C# and .NET, Microsoft Learn has a great article to get you started: <a href="https://learn.microsoft.com/dotnet/csharp/asynchronous-programming/">https://learn.microsoft.com/dotnet/csharp/asynchronous-programming/</a>.</p>
			<ol>
				<li value="6">Next, create <a id="_idIndexMarker455"/>two methods that will create the <code>MediaItems</code> and <code>Mediums</code> tables in the database. These will be called each time the app launches, but the SQL code only creates the tables if they do not exist. The <code>SqliteCommand</code> object accepts the <code>tableCommand</code> query string and <code>SqliteConnection</code>. It has several methods it can use to execute the command, depending on whether any data is expected to be returned by the query. In our case, no return values are expected, so <code>ExecuteNonQueryAsync</code> is the best of the async options for these two methods:<pre class="source-code">
private async Task CreateMediumTableAsync(SqliteConnection db)
{
    string tableCommand = @"CREATE TABLE IF NOT
        EXISTS Mediums (Id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
        Name NVARCHAR(30) NOT NULL,
        MediumType INTEGER NOT NULL)";
    using var createTable = new SqliteCommand(tableCommand, db);
    await createTable.ExecuteNonQueryAsync();
}
private async Task CreateMediaItemTableAsync(SqliteConnection db)
{
    string tableCommand = @"CREATE TABLE IF NOT
        EXISTS MediaItems (Id INTEGER PRIMARY KEY AUTOINCREMENT,
        Name NVARCHAR(1000) NOT NULL,
        ItemType INTEGER NOT NULL,
        MediumId INTEGER NOT NULL,
        LocationType INTEGER,
        CONSTRAINT fk_mediums
        FOREIGN KEY(MediumId)
        REFERENCES Mediums(Id))";
    using var createTable = new SqliteCommand(tableCommand, db);
    await createTable.ExecuteNonQueryAsync();
}</pre></li>				<li>Now, create<a id="_idIndexMarker456"/> a method for the <code>Mediums</code> table to insert a row into the table:<pre class="source-code">
private async Task InsertMediumAsync(SqliteConnection db, Medium medium)
{
    using var insertCommand = new SqliteCommand
    {
        Connection = db,
        CommandText = "INSERT INTO Mediums VALUES (NULL, @Name, @MediumType);"
    };
    insertCommand.Parameters.AddWithValue("@Name", medium.Name);
    insertCommand.Parameters.AddWithValue("@MediumType", (int)medium.MediaType);
    await insertCommand.ExecuteNonQueryAsync();
}</pre></li>				<li>Now, we <a id="_idIndexMarker457"/>need another method that will read all the rows from the <code>Mediums</code> table:<pre class="source-code">
private async Task&lt;IList&lt;Medium&gt;&gt; GetAllMediumsAsync(SqliteConnection db)
{
    IList&lt;Medium&gt; mediums = new List&lt;Medium&gt;();
    using var selectCommand = new SqliteCommand("SELECT Id, Name, MediumType FROM Mediums", db);
    using SqliteDataReader query = await selectCommand.ExecuteReaderAsync();
    while (query.Read())
    {
        var medium = new Medium
        {
            Id = query.GetInt32(0),
            Name = query.GetString(1),
            MediaType = (ItemType)query.GetInt32(2)
        };
        mediums.Add(medium);
    }
    return mediums;
}</pre></li>			</ol>
			<p>There’s a bit of code needed for these two simple operations. The insert method needs to add parameters for<a id="_idIndexMarker458"/> each property to be saved in the table, and the select method uses a <code>while</code> loop to add each table’s record to the collection. Let’s see whether we can simplify this in the next section.</p>
			<p>Before we implement the remaining methods for the <strong class="bold">Create, Read, Update, Delete </strong>(<strong class="bold">CRUD</strong>) operations, a <a id="_idIndexMarker459"/>new library must be added to the project to simplify the data access code we will write.</p>
			<h2 id="_idParaDest-145"><a id="_idTextAnchor145"/>Leveraging a Micro ORM to simplify data access</h2>
			<p>As you <a id="_idIndexMarker460"/>saw in the previous section, writing data access code for even the simplest application can take some time.</p>
			<p>ORMs, such <a id="_idIndexMarker461"/>as <strong class="bold">Entity Framework Core</strong> (<strong class="bold">EF Core</strong>), can greatly simplify and reduce the code required, but they can be overkill for a small app with just a handful of tables. In this chapter, we’ll look at a <strong class="bold">Micro ORM</strong>. Micro ORMs are lightweight frameworks that handle mapping data between objects and data queries.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">EF Core is a popular ORM for .NET developers. If you want to learn more about how to use EF Core with your projects, you can view the Packt video <em class="italic">Entity Framework Core – a Full Tour</em> at <a href="https://www.packtpub.com/product/entity-framework-core-a-full-tour-net-5-and-up-video/9781803242231">https://www.packtpub.com/product/entity-framework-core-a-full-tour-net-5-and-up-video/9781803242231</a>.</p>
			<p>The framework we will be using for data access in our project, Dapper, is an open source .NET Micro ORM that was created by the developers <a id="_idIndexMarker462"/>at <strong class="bold">Stack Overflow</strong>. You can learn more about <a id="_idIndexMarker463"/>Dapper at <a href="https://dapperlib.github.io/Dapper/">https://dapperlib.github.io/Dapper/</a> and get the package<a id="_idIndexMarker464"/> on NuGet: <a href="https://www.nuget.org/packages/Dapper">https://www.nuget.org/packages/Dapper</a>.</p>
			<p>Dapper is <a id="_idIndexMarker465"/>popular within the .NET community. While it doesn’t offer some of the features of EF Core, such as model generation or entity change tracking, it does make it very easy to write a fast, slim data layer. When you add the <code>Dapper.Contrib</code> library (<a href="https://www.nuget.org/packages/Dapper.Contrib">https://www.nuget.org/packages/Dapper.Contrib</a>) into the mix, it is <a id="_idIndexMarker466"/>even easier to write the CRUD methods needed for your applications.</p>
			<h2 id="_idParaDest-146"><a id="_idTextAnchor146"/>Adding Dapper to the project</h2>
			<p>Let’s dive right into it:</p>
			<ol>
				<li>Start <a id="_idIndexMarker467"/>by adding <code>Dapper</code> and <code>Dapper.Contrib</code> to the <strong class="bold">MyMediaCollection</strong> project. Open the <strong class="bold">Package Manager Console</strong> window <a id="_idIndexMarker468"/>again and add the two packages to your project:<pre class="source-code">
Install-Package Dapper
Install-Package Dapper.Contrib</pre></li>				<li>Now, revisit the <code>InsertMediaAsync</code> method. If we use the <code>QueryAsync</code> method provided by Dapper, we can reduce the code from our original method to this:<pre class="source-code">
private async Task InsertMediumAsync(SqliteConnection db, Medium medium)
{
    var newIds = await db.QueryAsync&lt;long&gt;(
        $@"INSERT INTO Mediums
            ({nameof(medium.Name)}, MediumType)
            VALUES
            (@{nameof(medium.Name)}, @{nameof(medium.MediaType)});
        SELECT last_insert_rowid()", medium);
    medium.Id = (int)newIds.First();
}</pre><p class="list-inset">The code we wrote to set the values of the query parameters is now gone. Dapper maps them for us from the <code>medium</code> object, which is passed into its <code>QueryAsync</code> method. You must ensure that the parameter names in the SQLite query match the property names on our object for Dapper’s automatic mapping to work.</p></li>				<li>As a bonus, we<a id="_idIndexMarker469"/> can also get the generated ID back from the <code>QueryAsync</code> call by adding the following SQLite code, which<a id="_idIndexMarker470"/> will return it after the <code>INSERT</code> operation completes:<pre class="source-code">
SELECT last_insert_rowid();</pre></li>				<li>Next, update the code for <code>GetAllMediumsAsync</code> to use Dapper:<pre class="source-code">
private async Task&lt;IList&lt;Medium&gt;&gt; GetAllMediumsAsync(SqliteConnection db)
{
    var mediums =
        await db.QueryAsync&lt;Medium&gt;(@"SELECT Id,
                                             Name,
                                             MediumType AS MediaType
                                      FROM Mediums");
    return mediums.ToList();
}</pre><p class="list-inset">We’ve gone from 14 lines of code to only 2. Note, in the highlighted part of the query, how we use an alias of <code>MediaType</code> for the <code>MediumType</code> field. This is an easy way to map data to an object property that doesn’t match the database field name, by simply renaming the field that’s returned as part of the SQL select statement. Dapper has also helped us by directly returning a list of our <code>Medium</code> objects, instead of us having to use a <code>while</code> loop to iterate over the result set.</p></li>				<li>Next, create a query that will get all the media items to populate the main <code>ListView</code> control. This query is a little more complex because we join two tables, <code>MediaItems</code> and <code>Mediums</code>, on <code>MediumId</code> and return the data to be mapped to two corresponding objects, <code>item</code> and <code>medium</code>. These types are indicated by the first two generic types provided to the <code>QueryAsync</code> method. To perform this mapping, we give Dapper a lambda expression that directs it to set <code>medium</code> as the <code>MediumInfo</code> property of the item for each row that’s returned from <a id="_idIndexMarker471"/>the query. The type of the returned object is defined by the third generic type provided to the <code>QueryAsync</code> method. The remaining parameters will be mapped automatically by <a id="_idIndexMarker472"/>Dapper based on their property names:<pre class="source-code">
private async Task&lt;List&lt;MediaItem&gt;&gt; GetAllMediaItemsAsync(SqliteConnection db)
{
    var itemsResult = await db.QueryAsync&lt;MediaItem, Medium, MediaItem&gt;
            (
                @"SELECT
                    [MediaItems].[Id],
                    [MediaItems].[Name],
                    [MediaItems].[ItemType] AS MediaType,
                    [MediaItems].[LocationType] AS Location,
                    [Mediums].[Id],
                    [Mediums].[Name],
                    [Mediums].[MediumType] AS MediaType
                FROM
                    [MediaItems]
                JOIN
                    [Mediums]
                ON
                    [Mediums].[Id] = [MediaItems].[MediumId]",
                (item, medium) =&gt;
                {
                    item.MediumInfo = medium;
                    return item;
                }
            );
    return itemsResult.ToList();
}</pre></li>				<li>Next, add the <a id="_idIndexMarker473"/>code to create the insert and<a id="_idIndexMarker474"/> update methods for our media items:<pre class="source-code">
private async Task&lt;int&gt; InsertMediaItemAsync(SqliteConnection db, MediaItem item)
{
    var newIds = await db.QueryAsync&lt;long&gt;(
        @"INSERT INTO MediaItems
            (Name, ItemType, MediumId, LocationType)
            VALUES
            (@Name, @MediaType, @MediumId, @Location);
        SELECT last_insert_rowid()", item);
    (int)newIds.First();
}
private async Task UpdateMediaItemAsync(SqliteConnection db, MediaItem item)
{
    await db.QueryAsync(
        @"UPDATE MediaItems
          SET Name = @Name,
              ItemType = @MediaType,
              MediumId = @MediumId,
              LocationType = @Location
          WHERE Id = @Id;", item);
}</pre><p class="list-inset">The code in <code>InsertMediaItemAsync</code> should look familiar. It’s very similar to what we<a id="_idIndexMarker475"/> did when we inserted data into the <code>Mediums</code> table. The code to update a row in <code>MediaItems</code> is <a id="_idIndexMarker476"/>technically only one line now, thanks to Dapper.</p></li>				<li>There’s one new read-only property that’s been added to the <code>MediaItem</code> object in our model. This property allows Dapper to map <code>MediumId</code> to the <code>MediaItems</code> table:<pre class="source-code">
public int MediumId =&gt; MediumInfo.Id;</pre></li>				<li>Now, add the <code>Computed</code> attribute to the <code>MediaItem.MediumInfo</code> property. This tells Dapper to ignore the property when we attempt to insert or update rows in the database. We only need to have <code>MediumId</code> saved. Users are unable to make changes to the rows in the <code>Mediums</code> table:<pre class="source-code">
<strong class="bold">[Computed]</strong>
public Medium MediumInfo { get; set; }</pre></li>				<li>Finally, let’s<a id="_idIndexMarker477"/> create a method that will delete items from the <code>MediaItems</code> table. This code is a little different, thanks to <code>Dapper.Contrib</code>. We don’t need to write any parameterized SQL in the code because <code>Dapper.Contrib</code> has a <code>DeleteAsync</code> method that generates the code to delete from <code>MediaItems</code>, based <a id="_idIndexMarker478"/>on the <code>Id</code> property of the <code>MediaItem</code> class provided:<pre class="source-code">
private async Task DeleteMediaItemAsync(SqliteConnection db, int id)
{
    await db.DeleteAsync&lt;MediaItem&gt;(new MediaItem { Id = id });
}</pre><p class="list-inset">To make this work, you must decorate the primary key properties of your model classes with <code>Key</code> attributes:</p><pre class="source-code">public class MediaItem
{
    [Key]
    public int Id { get; set; }
    ...
}</pre></li>			</ol>
			<p>Make sure that every model class that uses one of the <code>Dapper.Contrib</code> attributes adds a <code>using</code> statement for <code>Dapper.Contrib.Extensions</code>.</p>
			<p>Before we update all the public CRUD methods of the <code>SqliteDataService</code> class to call these private methods, we will complete the code that initializes the service when the application launches.</p>
			<h2 id="_idParaDest-147"><a id="_idTextAnchor147"/>Updating the data service’s initialization</h2>
			<p>Let’s get started:</p>
			<ol>
				<li>First, create a <a id="_idIndexMarker479"/>version of the <code>DataService.PopulateMediums</code> method in <code>Sqlite</code><code> DataService</code>, make it <code>async</code>, and rename it <code>PopulateMediumsAsync</code>. Update this method so that it fetches the data from SQLite. The method will also create any required data if this is the first time the application has been launched for the current user:<pre class="source-code">
private async Task PopulateMediumsAsync(SqliteConnection db)
{
    _mediums = await GetAllMediumsAsync(db);
    if (_mediums.Count == 0)
    {
        var cd = new Medium { Id = 1, MediaType = ItemType.Music, Name = "CD" };
        var vinyl = new Medium { Id = 2, MediaType = ItemType.Music, Name = "Vinyl" };
        var hardcover = new Medium { Id = 3, MediaType = ItemType.Book, Name = "Hardcover" };
        var paperback = new Medium { Id = 4, MediaType = ItemType.Book, Name = "Paperback" };
        var dvd = new Medium { Id = 5, MediaType = ItemType.Video, Name = "DVD" };
        var bluRay = new Medium { Id = 6, MediaType = ItemType.Video, Name = "Blu Ray" };
        var mediums = new List&lt;Medium&gt;
        {
            cd, vinyl, hardcover, paperback, dvd, bluRay
        };
        foreach (var medium in mediums)
        {
            await InsertMediumAsync(db, medium);
        }
        _mediums = await GetAllMediumsAsync(db);
    }
}</pre></li>				<li>Second, remove <code>PopulateItems</code> from <code>SqliteDataService</code>, <code>DataService</code>, and <code>IDataService</code>. It will not be needed because we now persist all data between sessions. You can also remove the <code>_items</code> private variable.</li>
				<li>Now, take the <a id="_idIndexMarker480"/>code from the <code>SqliteDataService</code> constructor, move it to a new public method named <code>InitializeDataAsync</code>, and update the code so that it uses the new private initialization methods. Don’t forget to remove the call to populate the items collection. The <code>SqliteConnection</code> object should always be part of a <code>using</code> block to ensure that the connection is closed and the object is disposed of:<pre class="source-code">
public async Task InitializeDataAsync()
{
    using (var db = await GetOpenConnectionAsync())
    {
        await CreateMediumTableAsync(db);
        await CreateMediaItemTableAsync(db);
        SelectedItemId = -1;
        PopulateItemTypes();
        await PopulateMediumsAsync(db);
        PopulateLocationTypes();
    }
}</pre></li>				<li>This new initialization method will need to be added to <code>IDataService</code> to make it available to objects that resolve the service through our DI container. If you keep the <a id="_idIndexMarker481"/>original <code>DataService</code> class in your project, you will need to add an implementation of <code>InitializeDataAsync</code> so that the project will compile:<pre class="source-code">
public interface IDataService
{
    Task InitializeDataAsync();
    ...
}</pre></li>				<li>After changing the location of the code that initializes <code>SqliteDataService</code>, the <code>RegisterComponents</code> method in <code>App.xaml.cs</code> will need to be updated to use the new <code>SqliteDataService</code> and call <code>InitializeDataAsync</code>. While we’re at it, rename the method to reflect its new async status:<pre class="source-code">
private <strong class="bold">async Task RegisterComponentsAsync</strong>(Frame rootFrame)
{
    var navigationService = new NavigationService(rootFrame);
    navigationService.Configure(nameof(MainPage), typeof(MainPage));
    navigationService.Configure(nameof(ItemDetailsPage), typeof(ItemDetailsPage));
<strong class="bold">    var dataService = new SqliteDataService();</strong>
<strong class="bold">    await dataService.InitializeDataAsync();</strong>
    HostContainer = Host.CreateDefaultBuilder()
        .ConfigureServices(services =&gt;
        {
            services.AddSingleton&lt;INavigationService&gt;(navigationService);
            <strong class="bold">services.AddSingleton&lt;IDataService&gt;(dataService);</strong>
            services.AddTransient&lt;MainViewModel&gt;();
            services.AddTransient&lt;ItemDetailsViewModel&gt;();
        }).Build();
}</pre></li>			</ol>
			<p>Don’t <a id="_idIndexMarker482"/>forget to update <code>OnLaunched</code> so that it’s <code>async</code> and await the call to the renamed <code>RegisterComponentsAsync</code>.</p>
			<p>Now that the application initializes the data service when it launches, it’s time to update the public CRUD methods so they use the async private methods we created to fetch data from SQLite.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor148"/>Retrieving data via services</h1>
			<p>Let’s start <a id="_idIndexMarker483"/>retrieving and saving SQLite data with our service methods. It will only be necessary to update the create, update, and delete operations. All the media items are stored in <code>List&lt;MediaItem&gt;</code> in <code>DataService</code>, so the public methods used to retrieve items can remain as they were in the previous chapter. Let’s get started:</p>
			<ol>
				<li>Start by updating the create, update, and delete methods for the media items in <code>SqliteDataService.cs</code>. Each of these will get an open connection to the database from <code>GetOpenConnectionAsync</code> and call its corresponding private method asynchronously:<pre class="source-code">
public async Task&lt;int&gt; AddItemAsync(MediaItem item)
{
    using var db = await GetOpenConnectionAsync();
    return await InsertMediaItemAsync(db, item);
}
public async Task UpdateItemAsync(MediaItem item)
{
    using var db = await GetOpenConnectionAsync();
    await UpdateMediaItemAsync(db, item);
}
public async Task DeleteItemAsync(MediaItem item)
{
    using var db = await GetOpenConnectionAsync();
    await DeleteMediaItemAsync(db, item.Id);
}</pre></li>				<li>Update the public methods that fetch items to be async:<pre class="source-code">
public async Task&lt;MediaItem&gt; GetItemAsync(int id)
{
    IList&lt;MediaItem&gt; mediaItems;
    using var db = await GetOpenConnectionAsync();
    mediaItems = await GetAllMediaItemsAsync(db);
    // Filter the list to get the item for our Id.
    return mediaItems.FirstOrDefault(i =&gt; i.Id == id);
}
public async Task&lt;IList&lt;MediaItem&gt;&gt; GetItemsAsync()
{
    using var db = await GetOpenConnectionAsync();
    return await GetAllMediaItemsAsync(db);
}</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">If you need to do a lot of filtering when querying data, Entity Framework is a more robust ORM that can provide more extensive options. SQLite is best suited for simpler applications. Note that, in the preceding code, <code>GetItemAsync</code> queries all the items and then filters to the item that matches the provided ID by using a lambda expression.</p>
			<ol>
				<li value="3">The<a id="_idIndexMarker484"/> method names have been updated to include <code>Async</code>, all uses of the <code>_items</code> collection have been removed, and each method has been changed to return <code>Task</code>. So, update the <code>IDataService</code> interface members to reflect the same changes. Also, either remove <code>DataService</code> from the project or update its methods to also be async. It’s best to try and anticipate that data access methods will need to be async when you set out, thus preventing breaking changes to your interfaces:<pre class="source-code">
<strong class="bold">Task&lt;int&gt;</strong> <strong class="bold">AddItemAsync</strong>(MediaItem item);
<strong class="bold">Task</strong> <strong class="bold">UpdateItemAsync</strong>(MediaItem item);
<strong class="bold">Task</strong> <strong class="bold">DeleteItemAsync</strong>(MediaItem item);
<strong class="bold">Task&lt;IList&lt;MediaItem&gt;&gt;</strong> <strong class="bold">GetItemsAsync</strong>();
<code>MainViewModel.cs</code>, the <code>Delete</code> method will be updated to use async/await with its data service call. Don’t forget to rename it <code>DeleteAsync</code> to follow best <a id="_idIndexMarker485"/>practices when naming async methods. You will also need to add a <code>using</code> statement to the file for the <code>System.Threading.Tasks</code> namespace:<pre class="source-code">
private <strong class="bold">async Task DeleteAsync</strong>()
{
    <strong class="bold">await _dataService.DeleteItemAsync(SelectedMediaItem);</strong>
    Items.Remove(SelectedMediaItem);
    allItems.Remove(SelectedMediaItem);
}</pre></li>				<li>Update the <code>PopulateData</code> method so that it’s named <code>PopulateDataAsync</code>, and use the async method of getting items:<pre class="source-code">
public <strong class="bold">async Task PopulateDataAsync</strong>()
{
    items.Clear();
    foreach(var item in <strong class="bold">await _dataService.GetItemsAsync()</strong>)
    {
        items.Add(item);
    }
    allItems = new ObservableCollection&lt;MediaItem&gt;(Items);
    mediums = new ObservableCollection&lt;string&gt;
    {
        AllMediums
    };
    foreach(var itemType in _dataService.GetItemTypes())
    {
        mediums.Add(itemType.ToString());
    }
    selectedMedium = Mediums[0];
}</pre></li>				<li>Now, you will <a id="_idIndexMarker486"/>have to update the <code>MainViewModel</code> constructor to call to <code>PopulateDataAsync</code> at the end of the constructor:<pre class="source-code">
public MainViewModel(INavigationService navigationService, IDataService dataService)
{
    _navigationService = navigationService;
    _dataService = dataService;
    <strong class="bold">PopulateDataAsync();</strong>
}</pre></li>				<li>Some similar changes will be needed in <code>ItemDetailsViewModel</code>. Update the <code>Save</code> method so that it’s async and awaits the data service calls to <code>AddItemAsync</code>, <code>GetItemAsync</code>, and <code>UpdateItemAsync</code>. Don’t forget to rename <code>Save</code> to <code>SaveAsync</code> and<a id="_idIndexMarker487"/> add a <code>using</code> statement for the <code>System.Threading.Tasks</code> namespace:<pre class="source-code">
private <strong class="bold">async Task SaveAsync</strong>()
{
    MediaItem item;
    if (_itemId &gt; 0)
    {
        item = <strong class="bold">await _dataService.GetItemAsync(_itemId)</strong>;
        item.Name = ItemName;
        item.Location = (LocationType)Enum.Parse(typeof(LocationType), SelectedLocation);
        item.MediaType = (ItemType)Enum.Parse(typeof(ItemType), SelectedItemType);
        item.MediumInfo = _dataService.GetMedium(SelectedMedium);
        <strong class="bold">await _dataService.UpdateItemAsync(item);</strong>
    }
    else
    {
        item = new MediaItem
        {
            Name = ItemName,
            Location = (LocationType)Enum.Parse(typeof(LocationType), SelectedLocation),
            MediaType = (ItemType)Enum.Parse(typeof(ItemType), SelectedItemType),
            MediumInfo = _dataService.GetMedium(SelectedMedium)
        };
        <strong class="bold">await _dataService.AddItemAsync(item);</strong>
    }
}</pre></li>				<li>Next, update<a id="_idIndexMarker488"/> the <code>SaveItemAndReturn</code> and <code>SaveAndContinue</code> methods so that they also use async/await:<pre class="source-code">
private <strong class="bold">async Task SaveItemAndReturnAsync</strong>()
{
    <strong class="bold">await SaveItemAsync();</strong>
    _navigationService.GoBack();
}
private <strong class="bold">async Task SaveItemAndContinueAsync</strong>()
{
    <strong class="bold">await SaveItemAsync();</strong>
    _dataService.SelectedItemId = 0;
    _itemId = 0;
    ItemName = "";
    SelectedMedium = null;
    SelectedLocation = null;
    SelectedItemType = null;
    IsDirty = false;
}</pre></li>				<li>Finally, update <code>ItemDetailsViewModel.xaml</code> so that the save buttons use the <a id="_idIndexMarker489"/>async methods when they bind their <code>Click</code> methods:<pre class="source-code">
&lt;SplitButton x:Name="SaveButton"
             Content="Save and Return"
             Margin="8,8,0,8"
             Click="{x:Bind ViewModel.<strong class="bold">SaveItemAndReturnAsync</strong>}"
             IsEnabled="{x:Bind ViewModel.IsDirty, Mode=OneWay}"&gt;
...
&lt;Button Content="Save and Create New"
    Click="{x:Bind ViewModel.<strong class="bold">SaveItemAndContinueAsync</strong>}"
    IsEnabled="{x:Bind ViewModel.IsDirty, Mode=OneWay}"
    Background="Transparent"/&gt;
&lt;Button Content="Save and Return"
    Click="{x:Bind ViewModel.<strong class="bold">SaveItemAndReturnAsync</strong>}"
    IsEnabled="{x:Bind ViewModel.IsDirty, Mode=OneWay}"
    Background="Transparent"/&gt;</pre></li>			</ol>
			<p class="callout-heading">Note</p>
			<p class="callout">If you have any issues<a id="_idIndexMarker490"/> with the <code>ComboBox</code> not populating on the main page after adding or editing a media item, update <code>Mode</code> of its <code>ItemsSource</code> data binding to <code>OneWay</code>. The completed source code in GitHub has been updated to reflect this change.</p>
			<p>That’s it. Run the application and see how it works. Since we’re no longer creating any dummy data for the <a id="_idIndexMarker491"/>media items list, the media collection in <code>ListView</code> will be empty when the app launches for the first time:</p>
			<div><div><img src="img/B20908_06_02.jpg" alt="Figure 6.2 – Launching with a database for the first time"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.2 – Launching with a database for the first time</p>
			<p>Try adding, updating, and removing some items. Then, close the application and run it again. You should see the same items on the list that were there when you closed it:</p>
			<div><div><img src="img/B20908_06_03.jpg" alt="Figure 6.3 – Relaunching with saved data"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 6.3 – Relaunching with saved data</p>
			<p>Users can <a id="_idIndexMarker492"/>now retain their saved data. If you would like to browse your SQLite data outside your app, there are tools you can use to connect to a local <code>db</code> and inspect it. One of them<a id="_idIndexMarker493"/> is <strong class="bold">DB Browser for SQLite</strong>. Covering this tool is beyond the scope of this book, but you can explore it for <a id="_idIndexMarker494"/>yourself at <a href="https://sqlitebrowser.org/">https://sqlitebrowser.org/</a>.</p>
			<p>Let’s wrap up and review what we’ve learned about working with data in a WinUI application.</p>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor149"/>Summary</h1>
			<p>We have covered a lot of important material in this chapter. You learned how to read and write data to a local SQLite database. Then, you learned how to simplify your data access code by leveraging Dapper, an ORM for .NET developers. Using an ORM will save you time creating boilerplate mapping code in your data access layers for WinUI projects (or any other .NET projects). All this data access code was made async to keep the UI responsive for the user.</p>
			<p>In the next chapter, we will learn how to create a beautiful <strong class="bold">Fluent UI</strong> with Microsoft’s Fluent UI design principles.</p>
			<h1 id="_idParaDest-150"><a id="_idTextAnchor150"/>Questions</h1>
			<ol>
				<li>When will Windows put a WinUI 3 app into a suspended state?</li>
				<li>When should you save the app state to ensure it is not lost if an application is closed?</li>
				<li>What is the event you can handle on a <code>Page</code> class to perform some logic when every element on a page has finished loading?</li>
				<li>What is a Micro ORM?</li>
				<li>What is the name of the Dapper package that adds CRUD helpers such as <code>Delete</code> and <code>DeleteAsync</code>?</li>
				<li>What is one of the powerful features of some more full-featured ORMs, such as Entity Framework?</li>
				<li>What is the name of a tool that can be used to inspect data in a SQLite database?</li>
			</ol>
		</div>
	

		<div><h1 id="_idParaDest-151" lang="en-US" xml:lang="en-US"><a id="_idTextAnchor151"/>Part 2:Extending WinUI and Modernizing Applications</h1>
			<p>In this part, you will build on what you have learned about WinUI application development and expand on it, with design concepts, platform options, and open source libraries. The Fluent design system that is native to WinUI controls provides Windows application users with a familiar look and feel. You will also learn how to integrate app notifications with the Windows App SDK. Then, you will explore the Windows Community Toolkit and .NET Community Toolkit, a set of open source packages that offer controls and helpers to WinUI developers. Finally, Template Studio will give WinUI developers a head-start with best practices when starting a new project.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B20908_07.xhtml#_idTextAnchor152"><em class="italic">Chapter 7</em></a>, <em class="italic">Fluent Design System for Windows Applications</em></li>
				<li><a href="B20908_08.xhtml#_idTextAnchor197"><em class="italic">Chapter 8</em></a>, <em class="italic">Adding Windows Notifications to WinUI Applications</em></li>
				<li><a href="B20908_09.xhtml#_idTextAnchor209"><em class="italic">Chapter 9</em></a>, <em class="italic">Enhancing Applications with </em><em class="italic">the Windows </em><em class="italic">Community Toolkits</em></li>
				<li><a href="B20908_10.xhtml#_idTextAnchor315"><em class="italic">Chapter 10</em></a>, <em class="italic">Accelerating App Development with Template Studio</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>