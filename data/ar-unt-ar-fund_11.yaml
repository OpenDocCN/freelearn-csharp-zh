- en: '*Chapter 8*: Planets: Tracking Images'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第8章*：行星：跟踪图像'
- en: In this chapter, we will be using augmented reality for data visualization and
    education. We're going to build a project where users can learn about the planets
    in our Solar System. Suppose you have a children's science book on the Solar System
    with a companion mobile app. On the page about planet Earth, for example, the
    reader can point their mobile device at the picture on the page and a 3D rendering
    of the Earth will pop out of the page.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将使用增强现实进行数据可视化和教育。我们将构建一个项目，用户可以了解我们太阳系中的行星。假设您有一本关于太阳系的儿童科学书籍及其配套移动应用程序。例如，在关于地球的页面，读者可以将他们的移动设备指向页面上的图片，地球的3D渲染就会从页面中弹出。
- en: The AR mechanism we'll be using is known as *image tracking*. With image tracking,
    you prepare a reference library of images that may be recognized and tracked in
    the real world at runtime. When the user's device's camera detects one of these
    images, a virtual object can be instantiated at the image location.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要使用的AR机制被称为*图像跟踪*。使用图像跟踪，您准备一个参考图像库，这些图像在运行时可以在真实世界中识别和跟踪。当用户的设备摄像头检测到这些图像之一时，可以在图像位置实例化一个虚拟对象。
- en: I have provided you with "planet cards," which have pictures and unique markers
    on them for each planet that I created from free resources available on the web,
    for you to print yourself and use with the app. For rendering the planets' spherical
    surface skins, we will be using free texture images of the actual planets.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经为您提供了“行星卡”，每张卡上都有图片和独特的标记，这些标记是我从网络上可用的免费资源中创建的，供您打印并用于应用程序。为了渲染行星的球形表面皮肤，我们将使用实际行星的免费纹理图像。
- en: 'We will cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将涵盖以下主题：
- en: Understanding AR image tracking
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解AR图像跟踪
- en: Specifying the Planets project and getting started
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 指定“行星”项目并开始
- en: Defining and tracking reference images
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义和跟踪参考图像
- en: Creating and instantiating a virtual Earth prefab
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建和实例化一个虚拟地球预制件
- en: Rotating a planet on its axis
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 绕其轴旋转行星
- en: Expanding the project with multiple planets
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过添加多个行星来扩展项目
- en: Making a responsive UI
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 制作响应式UI
- en: By the end of this chapter, you'll have a working app that detects images on
    the provided planet cards, renders a 3D model of the given planet, and offers
    additional information details about a planet.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将拥有一个可以检测提供的行星卡上的图像、渲染给定行星的3D模型并提供有关行星的附加信息详情的工作应用程序。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To implement the project in this chapter, you need Unity installed on your development
    computer, connected to a mobile device that supports augmented reality applications
    (see [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013), *Setting Up
    for AR Development*, for instructions). We also assume that you have the `ARFramework`
    template and all its prerequisites installed. See [*Chapter 5*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119)*,
    Using the AR User Framework*, for more details. The completed project can be found
    in this book's GitHub repository at [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation).
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现本章的项目，您需要在您的开发计算机上安装Unity，并将其连接到一个支持增强现实应用程序的移动设备（有关说明，请参阅[*第1章*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)，*为AR开发设置*）。我们还假设您已安装`ARFramework`模板及其所有先决条件。有关更多详细信息，请参阅[*第5章*](B15145_05_Final_SB_epub.xhtml#_idTextAnchor119)*，使用AR用户框架*。完成的项目可以在本书的GitHub仓库中找到，网址为[https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation)。
- en: Understanding AR image tracking
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解AR图像跟踪
- en: Before we start building our project, let's take a moment to learn how AR image
    tracking works. In this section, I'll introduce some of the basic principles behind
    image recognition and tracking, and what makes some images better than others
    for this purpose.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始构建项目之前，让我们花一点时间来了解AR图像跟踪是如何工作的。在本节中，我将介绍图像识别和跟踪背后的基本原理，以及为什么某些图像比其他图像更适合这个目的。
- en: As we know, the principles behind augmented reality involve using compute mechanisms
    to recognize features in the real world, determine their position and orientation
    in a 3D space, instantiate virtual objects relative to and anchored within this
    3D space, and track the user as they move within this space. Modern devices can
    accomplish this using their video cameras and other sensors built into the device
    to performing real-time spatial mapping of the environment. A different approach
    is for the device to track predetermined images. That is what we will use for
    the project in this chapter.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所知，增强现实背后的原理涉及使用计算机制来识别现实世界中的特征，确定它们在三维空间中的位置和方向，相对于并锚定在这个三维空间中实例化虚拟对象，并跟踪用户在空间中的移动。现代设备可以使用其视频摄像头和设备内置的其他传感器来执行环境的实时空间映射。另一种方法是设备跟踪预定的图像。这正是本章项目中我们将使用的方法。
- en: 'Augmented reality technology was born in the 1990s, where QR code-like marker
    images were used for tracking. An example is shown in the following image:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 增强现实技术诞生于20世纪90年代，当时使用类似二维码的标记图像进行跟踪。以下图像展示了示例：
- en: '![Figure 8.1 – A basic AR marker'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.1 – 基本AR标记符'
- en: '](img/Figure_8.01_B15145.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.01_B15145.jpg)'
- en: Figure 8.1 – A basic AR marker
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.1 – 基本AR标记符
- en: Marker images can be used for triggering and positioning virtual objects in
    the real world. These simplistic yet visually distinct markers are easily detected,
    even by low-end devices. Such markers are readily detectable because of their
    *distinctive details*, *high contrast edges*, and an *asymmetric shape* – that
    is, it's an easily recognizable image with unambiguous top, bottom, left, and
    right sides. In this way, the detection software can determine which marker image
    is in view and the orientation of the camera relative to the marker in 3D space.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 标记图像可用于在现实世界中触发和定位虚拟对象。这些简单但视觉上独特的标记易于检测，即使是低端设备也能轻松识别。这些标记易于检测，因为它们具有*独特的细节*、*高对比度边缘*和*不对称的形状*——也就是说，这是一个易于识别的图像，具有明确的顶部、底部、左侧和右侧。因此，检测软件可以确定哪个标记图像在视图中，以及相机相对于标记在三维空间中的方向。
- en: 'Taken to the next level, products such as Merge Cube ([https://mergeedu.com/cube](https://mergeedu.com/cube))
    have markers on each of its six faces, just like a physical cube that you can
    hold in your hand. Users can find companion apps with a wide gamut of games, learning,
    and exploration experiences. Merge offers a Unity package for developers so that
    you can build your own projects for it too. Merge Cube is depicted in the following
    image:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将这一概念提升到更高层次，例如Merge Cube ([https://mergeedu.com/cube](https://mergeedu.com/cube))这样的产品，在其六个面上都有标记，就像你可以用手拿的物理立方体一样。用户可以找到具有广泛游戏、学习和探索体验的配套应用程序。Merge为开发者提供Unity包，以便你也能为其构建自己的项目。以下图像展示了Merge
    Cube：
- en: '![Figure 8.2 – Merge Cube provides a 3D tracking cube with markers on each
    face'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.2 – Merge Cube在每个面上都有标记，提供3D跟踪立方体'
- en: '](img/Figure_8.02_B15145.jpg)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.02_B15145.jpg)'
- en: Figure 8.2 – Merge Cube provides a 3D tracking cube with markers on each face
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.2 – Merge Cube在每个面上都有标记，提供3D跟踪立方体
- en: Markers can be combined with natural images to provide pleasing and informative
    yet visually distinct images that also act as AR markers. You'll often see this
    in AR augmented storybooks or even cereal boxes. This is the approach I have taken
    in this chapter.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 标记符可以与自然图像结合，以提供令人愉悦且信息丰富的视觉上独特的图像，同时充当AR标记符。你经常在AR增强故事书中甚至谷物盒上看到这种做法。这正是我在本章中采用的方法。
- en: 'While markers provide the highest reliability, they are not necessarily required
    for image tracking. Ordinary photographic images can also be used. In AR lingo,
    these are referred to as *natural feature images*. Images for tracking must have
    the same characteristics that make markers reliable – distinctive details, high
    contrast edges, and an asymmetric shape. Much has been written about the best
    practices for selecting images. For instance, the AR Core developer guide ([https://developers.google.com/ar/develop/java/augmented-images/](https://developers.google.com/ar/develop/java/augmented-images/))
    contains additional tips about using reference images, including the following:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然标记提供了最高的可靠性，但它们对于图像跟踪并非必不可少。普通摄影图像也可以使用。在AR术语中，这些被称为*自然特征图像*。用于跟踪的图像必须具有使标记可靠的同种特征——独特的细节、高对比度边缘和不对称的形状。关于选择图像的最佳实践已经有很多讨论。例如，AR
    Core开发者指南([https://developers.google.com/ar/develop/java/augmented-images/](https://developers.google.com/ar/develop/java/augmented-images/))包含了关于使用参考图像的额外提示，包括以下内容：
- en: Use an image resolution of at least 300 x 300 pixels. However, a very high resolution
    does not help with recognition.
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用至少300 x 300像素的图像分辨率。然而，非常高的分辨率并不帮助识别。
- en: Color information is not used, so either color or grayscale images are just
    as good.
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 颜色信息没有被使用，所以彩色或灰度图像都一样好。
- en: Avoid images with a lot of geometric features, or too few.
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免具有很多几何特征的图像，或者太少的图像。
- en: Avoid repeating patterns.
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免重复的图案。
- en: The AR Core SDK comes with an **arcoreimg** tool that can evaluate images and
    returns a quality score between 0 and 100 for each image, where a score of at
    least 75 is recommended. Likewise, Unity uses a similar tool when compiling the
    Image Reference Library in your builds (we'll learn more about this later in this
    chapter).
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: AR Core SDK附带一个**arcoreimg**工具，可以评估图像，并为每个图像返回0到100之间的质量分数，其中至少75分的分数是推荐的。同样，Unity在编译您的构建中的图像参考库时使用类似的工具（我们将在本章后面了解更多关于这一点）。
- en: Given this general understanding of using image tracking in augmented reality
    applications, let's begin by defining a fun and interesting project – visualizing
    our Solar System's planets.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 基于对在增强现实应用中使用图像跟踪的一般理解，让我们首先定义一个有趣且有趣的项目——可视化我们的太阳系行星。
- en: Specifying the Planets project
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 指定行星项目
- en: We are going to build a planet information app that allows users to scan *planet
    cards* to visualize a 3D model of each planet in the Solar System. Imagine this
    being part of a trading card collection or a companion app to a children's science
    book. When the user points the device's camera at one of the planet cards, they
    can see a 3D rendering of the planet. Upon pressing an **Info** button, the user
    can get additional information about that planet. In this section, I will define
    the general user experience flow, give you instructions for preparing the planet
    cards for your own use, and help you collect assets that you'll use in this project.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将构建一个行星信息应用，允许用户扫描*行星卡*以可视化太阳系中每个行星的3D模型。想象一下，这将是交易卡收藏的一部分或儿童科学书的配套应用。当用户将设备的相机对准行星卡之一时，他们可以看到行星的3D渲染。按下**信息**按钮后，用户可以获取有关该行星的更多信息。在本节中，我将定义一般用户体验流程，为您提供准备行星卡以供自己使用的说明，并帮助您收集在本项目中使用的资产。
- en: User experience flow
  id: totrans-37
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 用户体验流程
- en: 'The general onboarding user workflow will play out as follows:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 通用用户入职工作流程将如下进行：
- en: '**Startup-mode**: The app will start, check the device for AR support, and
    ask for camera permissions (OS-dependent). Once read, the app will go into Scan-mode.'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**启动模式**：应用将启动，检查设备是否支持AR，并请求相机权限（取决于操作系统）。一旦读取，应用将进入扫描模式。'
- en: '**Scan-mode**: The user is prompted to aim the camera at an image for detection
    and tracking. When at least one image is being tracked, the app goes into Main-mode.'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**扫描模式**：用户被提示将相机对准图像进行检测和跟踪。当至少有一个图像正在跟踪时，应用进入主模式。'
- en: '**Main-mode**: This is where the app responds to new or updated tracked images
    and allows the user to interact with the planet. When an image is tracked, it
    determines which planet corresponds to the image and instantiates the planet''s
    game object. If tracking is lost, the app may go back to Scan-mode to prompt the
    user. If a different image is tracked, the current planet is replaced with the
    new image''s planet.'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**主模式**：这是应用对新或更新的跟踪图像做出响应并允许用户与行星交互的地方。当图像被跟踪时，它确定哪个行星与图像相对应，并实例化行星的游戏对象。如果丢失跟踪，应用可能会回到扫描模式以提示用户。如果跟踪不同的图像，当前行星将被新的图像的行星所取代。'
- en: This workflow is a bit simpler than the ones we implemented in the previous
    chapters. In that case, we needed the user to scan the environment for trackable
    planes before starting Main-mode. The user was then asked to deliberately tap
    the screen to place a virtual object in the scene. Furthermore, in the AR Gallery
    project, we added Edit-mode to modify pictures that had been added by the user.
    Much of that is unnecessary in this project; the process is more automated as
    we let the device detect an image and we instantiate a virtual object in response.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这个工作流程比我们在前几章中实现的工作流程要简单一些。在那个情况下，我们需要用户在进入主模式之前扫描环境以寻找可跟踪的平面。然后，用户被要求故意点击屏幕以在场景中放置一个虚拟对象。此外，在AR画廊项目中，我们添加了编辑模式来修改用户添加的图片。在这个项目中，许多这些都是不必要的；过程更加自动化，因为我们让设备检测图像，并相应地实例化一个虚拟对象。
- en: Preparing the planet cards
  id: totrans-43
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备行星卡
- en: 'For this project, we are using printed *planet cards* as marker images so that
    we can choose a planet to visualize. You can find a PDF file that contains the
    cards in the project files for this chapter (in the folder named `Printables/`).
    To prepare the cards for this project, follow these steps:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本项目，我们使用打印的 *行星卡片* 作为标记图像，以便我们可以选择一个行星进行可视化。您可以在本章的项目文件中找到一个包含这些卡片的 PDF 文件（在名为
    `Printables/` 的文件夹中）。为了准备这些卡片以供本项目使用，请按照以下步骤操作：
- en: Print out the `PlanetCards.pdf` file.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打印出 `PlanetCards.pdf` 文件。
- en: Then, cut the sheets into separate cards.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将纸张裁剪成单独的卡片。
- en: I suggest that you print on thick paper stock or mount the printouts on paperboard
    to avoid warping, which may affect the software's ability to recognize the images
    at runtime.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我建议您使用厚纸打印或把打印件粘贴到纸板上，以避免变形，这可能会影响软件在运行时识别图像的能力。
- en: 'The following photo shows getting these cards ready for use:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 以下照片显示了准备这些卡片以供使用的情况：
- en: '![Figure 8.3 – Cutting the printed planet cards for this project'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '![图 8.3 – 为本项目裁剪打印的行星卡片'
- en: '](img/Figure_8.03_B15145.jpg)'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '![图片](img/Figure_8.03_B15145.jpg)'
- en: Figure 8.3 – Cutting the printed planet cards for this project
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 图 8.3 – 为本项目裁剪打印的行星卡片
- en: These cards were created from a combination of resources that can be found for
    free on the web. I found the original flashcards on the *Kids Flashcards* website.
    Upon going to [https://kids-flashcards.com/en/free-printable/solar-system-flashcards-in-english](https://kids-flashcards.com/en/free-printable/solar-system-flashcards-in-english),
    I downloaded the *Solar System flashcards free* PDF file.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 这些卡片是由网络上可以免费找到的资源组合而成的。我在 *Kids Flashcards* 网站上找到了原始的闪卡。在访问 [https://kids-flashcards.com/en/free-printable/solar-system-flashcards-in-english](https://kids-flashcards.com/en/free-printable/solar-system-flashcards-in-english)
    后，我下载了 *Solar System flashcards free* PDF 文件。
- en: First, I attempted to use the flashcards as-is, but the pictures were not distinctive
    enough to be detected individually. So, I decided to add *ArUco* markers to each
    one. ArUco is a square marker with a wide black border and inner binary matrix
    that determines its ID based on OpenCV (the Open Source Computer Vision library,
    which was developed at the *University of Cordoba, Spain*; see [https://docs.opencv.org/3.2.0/d5/dae/tutorial_aruco_detection.html](https://docs.opencv.org/3.2.0/d5/dae/tutorial_aruco_detection.html)).
    I used the online ArUco marker generator at [https://chev.me/arucogen/](https://chev.me/arucogen/)
    to make separate markers for each planet.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我尝试直接使用这些闪卡，但图片不够独特，无法单独识别。因此，我决定为每一张卡片添加 *ArUco* 标记。ArUco 是一个带有宽黑色边框和内部二进制矩阵的方形标记，其
    ID 基于 OpenCV（开源计算机视觉库，由西班牙科尔多瓦大学开发；见 [https://docs.opencv.org/3.2.0/d5/dae/tutorial_aruco_detection.html](https://docs.opencv.org/3.2.0/d5/dae/tutorial_aruco_detection.html)）。我使用了在线
    ArUco 标记生成器 [https://chev.me/arucogen/](https://chev.me/arucogen/) 为每个行星制作单独的标记。
- en: Then, I used *Photoshop* to combine the markers with the planet flashcards to
    make our final planet cards for this project. (The Photoshop PSD file is also
    included with this chapter's files on GitHub.)
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我使用 *Photoshop* 将标记与行星闪卡结合，制作出本项目最终的行星卡片。（Photoshop PSD 文件也包含在本章的 GitHub
    文件中。）
- en: Each planet card is also a separate PNG image. These have been provided for
    you in the `Image Library/` folder. Later in this chapter, we will create an image
    reference library and add these images. The images are named with the pattern
    *[planetname]*`-MarkerCard.png`; for example, `Earth-MarkerCard.png`. We'll take
    advantage of this naming convention in our code.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每张行星卡片也是一个单独的 PNG 图像。这些图像已提供给您，位于 `Image Library/` 文件夹中。在本章的后面部分，我们将创建一个图像参考库并添加这些图像。图像的命名格式为
    `[planetname]`-MarkerCard.png；例如，`Earth-MarkerCard.png`。我们将在代码中利用这种命名约定。
- en: When the app detects a planet card, the application will instantiate a model
    of the planet. For this, we need texture images for the planet materials.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序检测到行星卡片时，应用程序将实例化一个行星模型。为此，我们需要行星材料的纹理图像。
- en: Collecting planet textures and data
  id: totrans-57
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 收集行星纹理和数据
- en: We need texture images to use as the planet skins of the spherical mesh for
    each planet. The ones we're using I found at the interesting *Solar System Scope*
    project site ([https://www.solarsystemscope.com/](https://www.solarsystemscope.com/)).
    These are included with the files for this chapter in this book's GitHub repository
    and can be downloaded from [https://www.solarsystemscope.com/textures/](https://www.solarsystemscope.com/textures/).
    That said, you can find alternative assets in the Unity Asset Store ([https://assetstore.unity.com/?q=solar%20system&orderBy=1](https://assetstore.unity.com/?q=solar%20system&orderBy=1)),
    including the classic *Planet Earth Free* package ([https://assetstore.unity.com/packages/3d/environments/sci-fi/planet-earth-free-23399](https://assetstore.unity.com/packages/3d/environments/sci-fi/planet-earth-free-23399))
    for Earth itself, which includes cloud cover.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要纹理图像来用作每个行星的球形网格的行星皮肤。我们使用的这些图像我是在有趣的 *太阳系范围* 项目网站上找到的 ([https://www.solarsystemscope.com/](https://www.solarsystemscope.com/))。这些文件包含在本书
    GitHub 存储库的该章节文件中，可以从 [https://www.solarsystemscope.com/textures/](https://www.solarsystemscope.com/textures/)
    下载。话虽如此，您可以在 Unity 资产商店 ([https://assetstore.unity.com/?q=solar%20system&orderBy=1](https://assetstore.unity.com/?q=solar%20system&orderBy=1))
    中找到替代资产，包括经典的 *地球免费* 包 ([https://assetstore.unity.com/packages/3d/environments/sci-fi/planet-earth-free-23399](https://assetstore.unity.com/packages/3d/environments/sci-fi/planet-earth-free-23399))，它包括云层。
- en: For additional metadata about the planets, I found the *Planetary Fact Sheet*
    on the NASA.gov website ([https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html](https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html))
    and more details at [https://nssdc.gsfc.nasa.gov/planetary/planetfact.html](https://nssdc.gsfc.nasa.gov/planetary/planetfact.html).
    We could use some of these details directly while rendering and animating our
    models, such as the planet diameter (km), rotation period (hours), and tilt (obliquity
    to orbit in degrees).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 关于行星的附加元数据，我在 NASA.gov 网站上找到了 *行星事实表* ([https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html](https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html))
    以及更多详细信息在 [https://nssdc.gsfc.nasa.gov/planetary/planetfact.html](https://nssdc.gsfc.nasa.gov/planetary/planetfact.html)。我们可以在渲染和动画我们的模型时直接使用其中的一些细节，例如行星直径（千米）、自转周期（小时）和倾斜（轨道倾角）。
- en: With our planet cards, planet skin textures, and other planetary details in
    hand, we're ready to start building the project.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有我们的行星卡、行星皮肤纹理和其他行星细节后，我们就可以开始构建项目了。
- en: Getting started
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'To begin, we''ll create a new scene named `PlanetsScene` using the `ARFramework`
    scene template. Follow these steps:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将使用 `ARFramework` 场景模板创建一个名为 `PlanetsScene` 的新场景。按照以下步骤操作：
- en: Select **File | New Scene**.
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **文件 | 新场景**。
- en: In the **New Scene** dialog box, select the **ARFramework** template.
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **新场景** 对话框中，选择 **ARFramework** 模板。
- en: Press **Create**.
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 **创建**。
- en: Select `Scenes/` folder in your `Assets` project, name it `PlanetsScene`, and
    click **Save**.
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 `Assets` 项目中选择 `Scenes/` 文件夹，将其命名为 `PlanetsScene`，然后点击 **保存**。
- en: 'The new AR scene already has the following set up:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 新的 AR 场景已经设置了以下内容：
- en: '**AR Session** game object.'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**AR 会话** 游戏对象。'
- en: '**AR Session Origin** rig with the raycast manager and plane manager components.'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配有射线投射管理器和平面管理器的 **AR 会话起源** 装配。
- en: '**UI Canvas** is a screen space canvas with child panels; that is, Startup
    UI, Scan UI, Main UI, and NonAR UI. It also contains the UI Controller component
    script that we wrote.'
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**UI Canvas** 是一个带有子面板的屏幕空间画布；即启动 UI、扫描 UI、主 UI 和非 AR UI。它还包含我们编写的 UI 控制器组件脚本。'
- en: '**Interaction Controller** is a game object that contains the Interaction Controller
    component script we wrote, which helps the app switch between interaction modes,
    including the Startup, Scan, Main, and NonAR modes. It also has a **Player Input**
    component that''s been configured with the **AR Input Actions** asset we created
    previously.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互控制器** 是一个包含我们编写的交互控制器组件脚本的游戏对象，它帮助应用在交互模式之间切换，包括启动、扫描、主和非 AR 模式。它还有一个配置了
    **AR 输入动作** 资产的 **玩家输入** 组件。'
- en: The **OnboardingUX** prefab from the AR Foundation Demos project, which provides
    AR session status and feature detection status messages, as well as animated onboarding
    graphics prompts.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 来自 AR Foundation Demos 项目的 **OnboardingUX** 预制件，它提供 AR 会话状态和功能检测状态消息，以及动画引导图形提示。
- en: 'We can set the app title now, as follows:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以设置应用标题，如下所示：
- en: In the **Hierarchy** window, unfold the **UI Canvas** object and unfold its
    child **App Title Panel**.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 窗口中，展开 **UI Canvas** 对象，然后展开其子 **应用标题面板**。
- en: Select the **Title Text** object.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **标题文本** 对象。
- en: In its `Planet Explorer`.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其 `行星探索器` 中。
- en: Using this scene as a basis, we will replace the AR trackable components with
    an AR Tracked Image Manager one.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 以这个场景为基础，我们将用AR跟踪图像管理器替换AR可跟踪组件。
- en: Tracking reference images
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跟踪参考图像
- en: Our starter scene includes an AR Session Origin with components for Player Input
    and AR Raycast Manager. It also has a component we do not need in this project,
    for detecting and tracking planes, which we'll replace with AR Tracked Image Manager
    instead. Documentation on **AR Tracked Image Manager** can be found at [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html).
    Then, we'll create an image reference library for our planet card images.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的开场景包括AR会话原点，以及用于玩家输入和AR射线管理器的组件。它还包括我们在这个项目中不需要的组件，用于检测和跟踪平面，我们将用AR跟踪图像管理器来替换它。有关**AR跟踪图像管理器**的文档可以在[https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html)找到。然后，我们将为我们的行星卡片图像创建一个图像参考库。
- en: Adding AR Tracked Image Manager
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加AR跟踪图像管理器
- en: 'To configure the AR Session to track images, perform the following steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要配置AR会话以跟踪图像，请执行以下步骤：
- en: In the **Hierarchy** window, select the **AR Session Origin** game object.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**AR会话原点**游戏对象。
- en: In the **Inspector** window, use the **3-dot** context menu (or *right-click*)
    on **AR Plane Manager** and select **Remove Component**.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，在**AR平面管理器**上使用**3点**上下文菜单（或*右键点击*）并选择**移除组件**。
- en: Using the `AR` and add an **AR Tracked Image Manager** component.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`AR`并添加一个**AR跟踪图像管理器**组件。
- en: You'll notice that there is a **Serialized Library** slot on the component for
    the reference image library. We'll create that next.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 你会注意到组件上有一个用于参考图像库的**序列化库**槽。我们将在下一步创建它。
- en: Creating a reference image library
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建参考图像库
- en: The reference image library contains records for each of the images that the
    application will be able to detect and track in the real world. In our case, we're
    going to add the planet card images. In the assets provided in the GitHub repository
    for this book, there is a folder named `Image Library/` that already contains
    the planet card images we'll be adding to the library. We will start with just
    the Earth card here; we will add the other planets later in this chapter.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图像库包含应用程序将在现实世界中检测和跟踪的每个图像的记录。在我们的情况下，我们将添加行星卡片图像。在GitHub存储库中提供的本书提供的资产中，有一个名为`Image
    Library/`的文件夹，其中已经包含了我们将添加到库中的行星卡片图像。我们在这里将仅从地球卡片开始；我们将在本章的后面添加其他行星。
- en: 'We can create the library by performing the following steps:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过执行以下步骤来创建库：
- en: In the `Image Library/`.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`图像库/`。
- en: '*Right-click* on the `Image Library/` folder and select **Create | XR | Reference
    Image Library**.'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`图像库/`文件夹上*右键点击*并选择**创建 | XR | 参考图像库**。
- en: With the **ReferenceImageLibrary** assets selected, in the **Inspector** window,
    click **Add Image**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**ReferenceImageLibrary**资产选中时，在**检查器**窗口中，点击**添加图像**。
- en: Drag the `Earth-MarkerCard` image from the **Project** window onto the square
    image texture slot.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`地球-MarkerCard`图像从**项目**窗口拖动到正方形图像纹理槽中。
- en: Check the **Specify Size** checkbox.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**指定大小**复选框。
- en: If you printed the planet cards from the PDF provided, at scale, the width will
    be about 8 cm, or 0.08 meters. Otherwise, use a ruler to measure the Earth planet
    card you printed.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你从提供的PDF中打印了行星卡片，按比例，宽度约为8厘米，或0.08米。否则，使用尺子测量你打印的地球行星卡片。
- en: Then, enter the width (`0.08`) in the **X** field. The **Y** value will be automatically
    updated based on the PNG image's pixel dimensions.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在**X**字段中输入宽度（`0.08`）。**Y**值将根据PNG图像的像素尺寸自动更新。
- en: Check the **Keep Texture At Runtime** checkbox.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**在运行时保留纹理**复选框。
- en: 'The resulting **Reference Image Library** settings are shown in the following
    screenshot:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图显示了生成的**参考图像库**设置：
- en: '![Figure 8.4 – Reference Image Library with the Earth added'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.4 – 添加了地球的参考图像库'
- en: '](img/Figure_8.04_B15145.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.04_B15145.jpg)'
- en: Figure 8.4 – Reference Image Library with the Earth added
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.4 – 添加了地球的参考图像库
- en: 'Now, we can update the **AR Tracked Image Manager** component, as follows:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新**AR跟踪图像管理器**组件，如下所示：
- en: In the **Hierarchy** window, select the **AR Session Origin** object.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**AR会话原点**对象。
- en: Drag the **ReferenceImageLibrary** asset from the **Project** window onto the
    **Serialized Library** slot of **AR Tracked Image Manager**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**参考图像库**资产从**项目**窗口拖放到**AR跟踪图像管理器**的**序列化库**槽位。
- en: Temporarily, while we get this project set up, we'll instantiate an existing
    prefab object when the image is detected.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们设置好这个项目的同时，当检测到图像时，我们将实例化现有的预制件对象。
- en: For example, drag the `ARF-samples/Prefabs/` folder onto the **Tracked Image
    Prefab** slot (or another similar object).
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 例如，将`ARF-samples/Prefabs/`文件夹拖放到**跟踪图像预制件**槽位（或另一个类似的对象）。
- en: 'The **AR Tracked Image Manager** component should now look as follows:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '**AR跟踪图像管理器**组件现在应如下所示：'
- en: '![Figure 8.5 – The AR Tracked Image Manager with the reference image library
    assigned'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.5 – The AR Tracked Image Manager with the reference image library
    assigned]'
- en: '](img/Figure_8.05_B15145.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.05_B15145.jpg]'
- en: Figure 8.5 – The AR Tracked Image Manager with the reference image library assigned
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.5 – 配置了参考图像库的AR跟踪图像管理器
- en: You now have an AR scene that recognizes and tracks images that have been defined
    in a reference library. Currently, the library only contains the Earth-MarkerCard
    image. When the image is recognized while running the app, a simple cube will
    be placed on the Earth planet card.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您现在有一个AR场景，可以识别和跟踪在参考库中定义的图像。目前，库中只包含地球标记卡图像。当在运行应用程序时识别到图像，将在地球行星卡上放置一个简单的立方体。
- en: We're almost ready to try this out. But first, let's configure the user framework's
    UI and modes.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎准备好尝试这个了。但首先，让我们配置用户框架的UI和模式。
- en: Configuring the user interaction modes and UI
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置用户交互模式和UI
- en: The scene template, `ARFramework`, where we started provides a simple framework
    for enabling user interaction modes and displaying the corresponding UI panels
    for a mode. This project will start in Startup-mode while the AR Session is initializing
    so that we can verify that the device supports AR. Then, it will transition to
    Scan-mode, where it will try to find one of the reference images. Once found,
    it will transition to Main-mode, where we can support additional user interactions
    with the app's content.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 场景模板`ARFramework`，我们从那里开始，提供了一个简单的框架，用于启用用户交互模式并显示对应模式的UI面板。此项目将在AR会话初始化时以启动模式开始，以便我们可以验证设备是否支持AR。然后，它将过渡到扫描模式，其中它将尝试找到其中一个参考图像。一旦找到，它将过渡到主模式，在那里我们可以支持与应用程序内容的附加用户交互。
- en: Scanning for reference images
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扫描参考图像
- en: 'In Scan-mode, we''ll display an instructional graphic prompting the user to
    point the camera at a planet card with a planet and marker image. Perform the
    following steps to configure this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在扫描模式中，我们将显示一个指导图形，提示用户将摄像头指向带有行星和标记图像的行星卡。执行以下步骤以配置此操作：
- en: In the **Hierarchy** window, unfold the **UI Canvas** game object and unfold
    its child **Scan UI**. Select the child **Animated Prompt** object.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，展开**UI Canvas**游戏对象及其子**扫描UI**。选择子**动画提示**对象。
- en: In the **Inspector** window set **Animated Prompt | Instruction to Find An Image**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中设置**动画提示 | 查找图像说明**。
- en: This will now play the Find Image Clip we defined on the **OnboardingUX** object,
    which is provided by the Unity Onboarding UX assets and is already present in
    our scene hierarchy. What you can expect is shown in the following screen capture.
    On the left is Startup-mode, where the AR Session is being initialized. On the
    right is Scan-mode, where the user is prompted to find an image (you can't see
    the video feed because I'm covering the camera to make the prompt more visible
    in the screen capture).
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 现在将在**OnboardingUX**对象上播放我们定义的查找图像剪辑，该对象由Unity Onboarding UX资产提供，并且已经存在于我们的场景层次结构中。以下屏幕截图显示了您可以期待的内容。左侧是启动模式，其中正在初始化AR会话。右侧是扫描模式，用户被提示查找图像（您看不到视频流，因为我覆盖了摄像头，以便在屏幕截图中使提示更加明显）。
- en: '![Figure 8.6 – Screen captures of Startup mode (left) and Scan mode (right)'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.6 – Screen captures of Startup mode (left) and Scan mode (right)]'
- en: '](img/Figure_8.06_B15145.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.06_B15145.jpg]'
- en: Figure 8.6 – Screen captures of Startup mode (left) and Scan mode (right)
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.6 – 启动模式（左）和扫描模式（右）的屏幕截图
- en: 'Now, we need to set up the Scan-mode''s script to know when an image has been
    found and transition to Main-mode. We''ll replace the default `ScanMode` script
    with a similar one that references `ARTrackedImageManager` instead of `ARTrackedPlaneManager`,
    as follows:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要设置扫描模式的脚本，以便知道何时找到图像并过渡到主模式。我们将用引用`ARTrackedImageManager`而不是`ARTrackedPlaneManager`的类似脚本替换默认的`ScanMode`脚本，如下所示：
- en: In the `Scripts/` folder by *right-clicking* and selecting`ImageScanMode`.
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts/`文件夹中，通过*右键单击*并选择`ImageScanMode`。
- en: 'Edit `ImageScanMode` and replace its content, as follows:'
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`ImageScanMode`并替换其内容，如下所示：
- en: '[PRE0]'
  id: totrans-125
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Save the script. Then, back in Unity, in the **Hierarchy** window, select the
    **Scan Mode** game object (under **Interaction Controller**).
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。然后，回到Unity中，在**层次结构**窗口中，选择**扫描模式**游戏对象（位于**交互控制器**下）。
- en: In the **Inspector** window, remove the original **Scan Mode** component using
    the *3-dot* context menu and selecting **Remove Component**.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，使用*3点*上下文菜单并选择**移除组件**来移除原始**扫描模式**组件。
- en: Drag the **ImageScanMode** script onto the **Scan Mode** object, adding it as
    a new component.
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**ImageScanMode**脚本拖动到**扫描模式**对象上，将其添加为新组件。
- en: From the **Hierarchy** window, drag the **AR Session Origin** object into the
    **Inspector** window and drop it onto the **Image Scan Mode | Image Manager**
    slot.
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中，将**AR会话原点**对象拖动到**检查器**窗口，并将其放置在**图像扫描模式 | 图像管理器**槽中。
- en: 'The component will now look as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件现在将如下所示：
- en: '![Figure 8.7 – The Image Scan Mode component'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.7 – 图像扫描模式组件'
- en: '](img/Figure_8.07_B15145.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.07_B15145.jpg)'
- en: Figure 8.7 – The Image Scan Mode component
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.7 – 图像扫描模式组件
- en: Currently, we have created a new scene using the `ARFramework` template and
    modified it to use **AR Tracked Image Manager** and prompt the user to scan for
    an image accordingly. When an image is detected (for example, the Earth-MarkerCard),
    a generic game object will be instantiated (for example, the AR Placed Cube prefab).
    Let's test what we have accomplished so far on the target device.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们已经使用`ARFramework`模板创建了一个新场景，并将其修改为使用**AR跟踪图像管理器**并提示用户扫描图像。当检测到图像（例如，地球标记卡片）时，将实例化一个通用游戏对象（例如，AR放置立方体预制件）。让我们在目标设备上测试我们迄今为止所完成的工作。
- en: Build and run
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 构建 和 运行
- en: 'To build and run the scene on your target device, perform the following steps:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 要在目标设备上构建和运行场景，请执行以下步骤：
- en: Ensure you've saved the work you've done on the current scene by going to **File
    | Save**.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过转到**文件 | 保存**确保您已保存当前场景上的工作。
- en: Select **File | Build Settings** to open the **Build Settings** window.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**文件 | 构建设置**以打开**构建设置**窗口。
- en: Click **Add Open Scenes** to add the current scene to the **Scenes In Build**
    list (if it's not already present).
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击**添加打开场景**将当前场景添加到**构建场景列表**中（如果尚未添加）。
- en: Uncheck all but the current scene, `PlanetsScene`, from the list.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从列表中取消选中除当前场景`PlanetsScene`之外的所有场景。
- en: Then, click **Build And Run** to build the project.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，点击**构建和运行**以构建项目。
- en: 'When the app launches, point your device''s camera at the printed Earth planet
    card. Your virtual cube should get instantiated at that location, as shown in
    the following screen capture from my phone:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用启动时，将您的设备相机对准打印的地球行星卡片。您的虚拟立方体应该在该位置实例化，如下面的手机屏幕截图所示：
- en: '![Figure 8.8 – The Earth card has been detected, and the cube has been instantiated'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.8 – 地球卡片已被检测到，立方体已被实例化'
- en: '](img/Figure_8.08_B15145.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.08_B15145.jpg)'
- en: Figure 8.8 – The Earth card has been detected, and the cube has been instantiated
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.8 – 地球卡片已被检测到，立方体已被实例化
- en: We now have a basic AR scene with image detection set up to recognize the Earth
    planet card and instantiate a sample prefab at that location. Now, let's make
    a planet Earth model that we can use instead of this silly cube.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经设置了一个基本的AR场景，其中图像检测已设置为识别地球行星卡片，并在该位置实例化一个样本预制件。现在，让我们制作一个地球模型，我们可以用它来代替这个愚蠢的立方体。
- en: Creating and instantiating a virtual Earth prefab
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建并实例化一个虚拟地球预制件
- en: In this section, we will create prefab game objects for each of the planets.
    Since each of the planets has similar behaviors (for example, they rotate), we'll
    first create a generic Planet Prefab, and then make each specific planet a variant
    of that one. In Unity, `Planet` script that animates the planet's rotation and
    handles other behavior. Each planet will have its own "skin" defined by a material,
    along with a base texture map, which we downloaded earlier from the web.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为每个行星创建预制件游戏对象。由于每个行星都有类似的行为（例如，它们会旋转），我们首先创建一个通用的行星预制件，然后使每个特定行星成为该预制件的变体。在Unity中，`Planet`脚本来动画行星的旋转并处理其他行为。每个行星将有自己的“皮肤”，由一个材质定义，以及一个基础纹理图，这是我们之前从网上下载的。
- en: In this section, we'll create a generic Planet Prefab object, create an Earth
    Prefab as a variant, add planet metadata by writing a `Planet` component script,
    and implement a planet rotation animation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建一个通用的星球预制体对象，创建一个地球预制体作为变体，通过编写“星球”组件脚本添加星球元数据，并实现星球旋转动画。
- en: Creating the generic Planet Prefab
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建通用星球预制体
- en: 'The Planet Prefab contains a 3D sphere that gets rendered with each planet''s
    texture image. Planets spin along their axes, so we''ll set up a hierarchy with
    an Incline transform that defines this incline axis. Follow these steps:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 星球预制体包含一个3D球体，每个星球都会使用其纹理图像进行渲染。星球沿着其轴线旋转，因此我们将设置一个具有倾斜变换的层次结构来定义这个倾斜轴线。按照以下步骤操作：
- en: In your `Planet Prefab`.
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的“星球预制体”。
- en: '*Double-click* (or select **Open Prefab** in the **Inspector** window) to open
    the prefab for editing.'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*双击*（或在**检查器**窗口中选择**打开预制体**）以打开预制体进行编辑。'
- en: From the main menu, select `Incline`.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从主菜单中选择“倾斜”。
- en: Right-click the `Planet`.
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击“星球”。
- en: It will be useful to have any planets we instantiate in the scene on a specific
    layer. I will name this layer `PlacedObjects`. (I introduced and discussed layers
    in a previous chapter). With its root `PlacedObjects`.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中实例化的任何星球都位于特定的层上会有用。我将把这个层命名为“放置对象”。（我在前一章中介绍了并讨论了层）。以它的根“放置对象”。
- en: If the `PlacedObjects` layer doesn't exist, select `PlacedObjects` to one of
    the empty slots. In the `PlacedObjects.`
  id: totrans-157
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果“放置对象”层不存在，请选择“放置对象”并将其放入一个空槽中。在“放置对象。”
- en: You will then be prompted with the question, **Do you want to set layer to PlacedObjects
    for all child objects as well?** Click **Yes, Change Children**.
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后你会被提示问题，**你想要将层设置为放置对象的所有子对象吗？** 点击**是，更改子对象**。
- en: '**Save** the prefab.'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存**预制体。'
- en: 'This is very simplistic right now (only a sphere child object is being parented
    by an Incline transform), but it will serve as a template for each planet prefab
    that we add. The Planet Prefab hierarchy is shown in the following screenshot:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 目前这非常简单（只有一个球形子对象被倾斜变换所包含），但它将作为我们添加的每个星球预制体的模板。星球预制体层次结构在以下屏幕截图中显示：
- en: '![Figure 8.9 – The Planet Prefab hierarchy'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.9 – 星球预制体层次结构'
- en: '](img/Figure_8.09_B15145.jpg)'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.09_B15145.jpg)'
- en: Figure 8.9 – The Planet Prefab hierarchy
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.9 – 星球预制体层次结构
- en: Each planet will be rendered with a skin representing an actual view of that
    planet. Before creating the Earth prefab, let's take a moment to understand render
    materials and the texture images we are going to use.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 每个星球都将使用代表该星球实际视图的皮肤进行渲染。在创建地球预制体之前，让我们花一点时间来了解渲染材质和我们将要使用的纹理图像。
- en: Understanding equirectangular images
  id: totrans-165
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解等距圆柱图像
- en: 'When Unity renders a 3D model, it starts with a 3D mesh that describes the
    geometry. Much like a fishing net, a mesh is a collection of vertices and vectors,
    with the vectors connecting these vertices, organized as triangles (or sometimes
    four-sided quads) that define the surface of the mesh. The following illustration
    shows a wireframe view of a sphere mesh on the left. On the right is a rendered
    view of the sphere, with a globe texture mapped onto its 3D surface:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 当Unity渲染3D模型时，它从一个描述几何形状的3D网格开始。就像渔网一样，网格是由顶点和向量组成的集合，向量将这些顶点连接起来，组织成三角形（有时是四边形的四边形），这些三角形定义了网格的表面。以下插图显示了左边的球体网格的线框视图。在右边是球体的渲染视图，地球纹理映射到其3D表面上：
- en: '![Figure 8.10 – Sphere mesh (left) and rendered sphere with texture (right)'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.10 – 球形网格（左）和带有纹理的渲染球形（右）'
- en: '](img/Figure_8.10_B15145.jpg)'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.10_B15145.jpg)'
- en: Figure 8.10 – Sphere mesh (left) and rendered sphere with texture (right)
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.10 – 球形网格（左）和带有纹理的渲染球形（右）
- en: 'A texture image is just a 2D image file (for example, a PNG file) that is computationally
    mapped onto the 3D mesh''s surface when it is rendered. Think of unraveling a
    globe as a 2D map, like cartographers have been doing for centuries. A common
    2D projection is known as **equirectangular**, where the center (equator) is at
    the correct scale and the image gets increasingly stretched as it approaches the
    top and bottom poles. The following image shows the equirectangular texture of
    the preceding globe (illustration by *Stefan Kuhn*):'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 纹理图像只是一个2D图像文件（例如，一个PNG文件），当它渲染时，在3D网格的表面上进行计算映射。想象一下将地球展开成一个2D地图，就像地图学家几个世纪以来所做的那样。一个常见的2D投影被称为**等距圆柱**，其中中心（赤道）处于正确的比例，并且当接近顶部和底部极点时，图像会越来越拉伸。以下图像显示了前面地球的等距圆柱纹理（由*Stefan
    Kuhn*绘制）：
- en: '![Figure 8.11 – Equirectangular texture that defines the skin of a sphere'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.11 – 定义球体皮肤的等经圆纹理'
- en: '](img/Figure_8.11_B15145.jpg)'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.11_B15145.jpg]'
- en: Figure 8.11 – Equirectangular texture that defines the skin of a sphere
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.11 – 定义球体皮肤的等经圆纹理
- en: Information – Equirectangular Images Are Also Used in 360-Degree Media and VR
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 信息 – 等经圆图像也用于360度媒体和VR
- en: Equirectangular images are also known as 360-degree images and used in virtual
    reality applications. In VR, the image is effectively mapped to the *inside* of
    a sphere, where you're viewing from the inside rather than the outside of a globe!
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 等经圆图像也被称为360度图像，并用于虚拟现实应用中。在VR中，图像被有效地映射到球体的**内部**，你从内部而不是地球仪的外部进行观看！
- en: 'For our project, we have texture images for each of the planets. The Mars one,
    for example, is as follows:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的项目，我们为每个行星都有纹理图像。例如，火星的一个如下所示：
- en: '![Figure 8.12 – Texture map image for Mars'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.12 – 火星纹理图'
- en: '](img/Figure_8.12_B15145.jpg)'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.12_B15145.jpg]'
- en: Figure 8.12 – Texture map image for Mars
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.12 – 火星纹理图
- en: To create a prefab for a specific planet, such as Earth, we'll need to create
    a material that uses the Earth texture image. We'll build that now.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 要为特定的行星（如地球）创建预制体，我们需要创建一个使用地球纹理图像的材质。我们现在将构建它。
- en: Creating the Earth prefab
  id: totrans-181
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建地球预制体
- en: 'The Earth prefab will be a variant of the Planet Prefab, with its own Earth
    Material. Create it by performing the following steps:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 地球预制体将是行星预制体的一个变体，具有自己的地球材质。通过以下步骤创建它：
- en: In the `Earth Prefab`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Earth Prefab`。
- en: '*Double-click* **Earth Prefab** (or select **Open Prefab** in the **Inspector**
    window).'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双击****地球预制体**（或在**检查器**窗口中选择**打开预制体**）。'
- en: In the `Materials/` folder (create one if necessary) and select `Earth Material`.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Materials/`文件夹中（如果需要则创建一个）并选择`Earth Material`。
- en: Drag **Earth Material** from the **Project** window and drop it onto the **Planet**
    game object.
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**地球材质**从**项目**窗口拖动并放置到**地球**游戏对象上。
- en: Locate the `Planet Textures/earth`) in the **Project** Assets and drag it onto
    the **Surface Inputs | Base Map** texture chip. The following screenshot shows
    **Earth Material** in the **Inspector** window:![Figure 8.13 – Earth Material
    with the Base Map texture defined
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**项目**资产中的`Planet Textures/earth`)中定位，并将其拖放到**表面输入 | 基础地图**纹理芯片上。以下屏幕截图显示了**地球材质**在**检查器**窗口中：![图8.13
    – 地球材质与基础地图纹理定义
- en: '](img/Figure_8.13_B15145.jpg)'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![img/Figure_8.13_B15145.jpg]'
- en: Figure 8.13 – Earth Material with the Base Map texture defined
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.13 – 定义了基础地图纹理的地球材质
- en: Let's pick a default size for our planet when added to the scene. Unless you
    want to place a 1-meter diameter planet into your scene (!), we need to set its
    **Scale**.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们在将地球添加到场景时选择一个默认大小。除非你想要将直径为1米的地球放置到你的场景中(!)，我们需要设置其**缩放**。
- en: Select the **Planet** child object in the **Hierarchy** window.
  id: totrans-191
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在**层次**窗口中选择**地球**子对象。
- en: In its `0.1, 0.1, 0.1`).
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其`0.1, 0.1, 0.1`）。
- en: Likewise, to rest the planet on the image's surface, we could set its Y position
    to `0.05`. But to let it hover a little above, we will set `0.075`.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样地，为了将地球放置在图像的表面上，我们可以将其Y位置设置为`0.05`。但为了让它稍微悬停在上方，我们将设置为`0.075`。
- en: '**Save** the prefab and exit back to the **Scene** hierarchy.'
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存**预制体并退出到**场景**层次。'
- en: 'Use this prefab instead of the AR Placed Cube prefab in the AR Tracked Image
    Manager component on the AR Session Origin object. Later, we''ll manage this more
    correctly using a script but for now, let''s just try it out:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此预制体而不是AR放置立方体预制体在AR跟踪图像管理器组件上的AR会话原点对象上。稍后，我们将使用脚本更正确地管理它，但现在让我们先试试：
- en: In the **Hierarchy** window, select the **AR Session Origin** game object.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**窗口中，选择**AR会话原点**游戏对象。
- en: Drag **Earth Prefab** from the **Project** window into the **Inspector** window
    and drop it into the **AR Tracked Image Manager | Tracked Image Prefab** slot.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**地球预制体**从**项目**窗口拖动到**检查器**窗口，并将其放入**AR跟踪图像管理器 | 跟踪图像预制体**槽中。
- en: '**Build and Run** the scene.'
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**构建并运行**场景。'
- en: 'This time, when you point the camera at the Earth planet card, the Earth prefab
    will appear, as shown in the following screen capture:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，当你将相机指向地球行星卡片时，地球预制体将出现，如下面的屏幕截图所示：
- en: '![Figure 8.14 – While tracking the Earth planet card, the app instantiates
    an Earth prefab'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.14 – 在跟踪地球行星卡片时，应用实例化了一个地球预制体'
- en: '](img/Figure_8.14_B15145.jpg)'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '![img/Figure_8.14_B15145.jpg]'
- en: Figure 8.14 – While tracking the Earth planet card, the app instantiates an
    Earth prefab
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.14 – 在跟踪地球行星卡片时，应用实例化了一个地球预制体
- en: This looks pretty nice. The prefab could also include other information about
    the planet. We'll look at how to do this next.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这看起来相当不错。预制件还可以包含有关行星的其他信息。我们将在下一节中查看如何做到这一点。
- en: Adding planet metadata
  id: totrans-204
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 添加行星元数据
- en: 'Each planet prefab can include additional information about that planet. We
    can capture this in the `Planet` script of the prefab, as follows:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 每个行星预制件都可以包含有关该行星的附加信息。我们可以在预制件的`Planet`脚本中捕获这些信息，如下所示：
- en: From the **Project** window, open **Planet Prefab** for editing.
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口中打开**星球预制件**进行编辑。
- en: In the `Scripts/` folder, create a new C# script named `Planet`.
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts/`文件夹中，创建一个名为`Planet`的新C#脚本。
- en: Drag the `Planet` script onto the root **Planet Prefab** game object, adding
    it as a component.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Planet`脚本拖放到根**星球预制件**游戏对象上，将其添加为组件。
- en: 'Open the `Planet` script in your code editor and write the following:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开`Planet`脚本并编写以下内容：
- en: '[PRE1]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Save the script. Then, in Unity, **Save** the prefab.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。然后，在Unity中，**保存**预制件。
- en: Although we have made all these changes to the Planet Prefab, the Earth Prefab
    inherits everything because it is a prefab variant.
  id: totrans-212
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 尽管我们对**星球预制件**做了所有这些更改，但由于它是预制件变体，地球预制件继承了所有内容。
- en: Now, open **Earth Prefab** for editing.
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开**地球预制件**进行编辑。
- en: In the `Earth`.
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Earth`。
- en: In the `Earth is the third planet from the Sun and the only astronomical object
    known to harbor and support life`.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`地球是距离太阳第三颗行星，也是已知能够孕育和维持生命的唯一天体`。
- en: '**Save** the prefab.'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存**预制件。'
- en: We also can ascribe behaviors to the planet prefab, such as rotation about its
    axis.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以将行为赋予行星预制件，例如绕其轴旋转。
- en: Animating the planet's rotation
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动画行星的旋转
- en: 'Planets spin. Some faster than others. Mercury just barely – it rotates once
    every 59 Earth days, while it orbits the Sun in 88 Earth days! And a planet''s
    axis of rotation is not perfectly vertical (relative to its orbit around the Sun).
    Earth, for example, is tilted by 23.4 degrees, while Venus rotates on its side
    at 177.4 degrees! OK, enough science trivia – let''s animate our Earth model.
    We''re going to add a `Planet` behavior script to the Planet Prefab that rotates
    the planet along its rotation axis. Follow these steps to do so:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 行星会自转。有的转得快，有的转得慢。水星几乎不转——它每59个地球日转一次，而它绕太阳公转需要88个地球日！而且行星的旋转轴并不完全垂直（相对于其绕太阳的轨道）。例如，地球倾斜了23.4度，而金星以177.4度的角度侧卧旋转！好了，足够了科学小知识——让我们来动画化我们的地球模型。我们将向行星预制件添加一个`Planet`行为脚本，使其沿旋转轴旋转。按照以下步骤进行操作：
- en: 'Open the `Planet` script in your code editor and add the following code:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的代码编辑器中打开`Planet`脚本并添加以下代码：
- en: '[PRE2]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: At the top of the class, we will declare variables for `inclineDegrees` (Earth
    is 23.4) and `rotationPeriodHours` (Earth is 24). We will also define references
    to the prefab's `incline` and `planet` child objects.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 在类的顶部，我们将声明`inclineDegrees`（地球为23.4）和`rotationPeriodHours`（地球为24）的变量。我们还将定义预制件的`incline`和`planet`子对象的引用。
- en: There's also a public `animationHoursPerSecond`, which sets the animation speed.
    I've initialized it to `1.0`, which means the Earth will complete one rotation
    in 24 seconds.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有一个公共的`animationHoursPerSecond`，它设置动画速度。我将其初始化为`1.0`，这意味着地球将在24秒内完成一次旋转。
- en: The `Start()` function sets up the **Incline** angle by rotating along the Z-axis.
    This only needs to be done once.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`Start()`函数通过沿Z轴旋转设置**倾斜**角度。这只需要做一次。'
- en: The `Update()` function rotates the planet about its local Y-axis. Since the
    planet is parented by the `Time.deltaTime` each `Update` is a common Unity idiom
    for calculating how an object's Transform changes from one frame to the next,
    where `deltaTime` is the fraction of a second since the previous `Update`.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()`函数使星球绕其局部Y轴旋转。由于星球是`Time.deltaTime`的父级，因此每个`Update`都是Unity中计算对象Transform从一个帧到下一个帧的变化的常用惯用语，其中`deltaTime`是自上次`Update`以来的一秒的分数。'
- en: 'After saving the script, back in Unity, do the following:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本后，回到Unity中，执行以下操作：
- en: From the **Project** window, open **Planet Prefab** for editing.
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**项目**窗口中打开**星球预制件**进行编辑。
- en: Ensure the root **Plane Prefab** game object is selected in the **Hierarchy**
    window.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在**层次结构**窗口中选中了根**平面预制件**游戏对象。
- en: Drag the **Incline** game object from the **Hierarchy** window into the **Inspector**
    window before dropping it onto the **Planet | Incline** slot.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将**斜面**游戏对象拖放到**星球 | 斜面**槽之前，先从**层次结构**窗口将其拖入**检查器**窗口。
- en: Drag the **Planet** object onto the **Planet | Planet** slot.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**星球**对象拖放到**星球 | 星球**槽中。
- en: 'The **Planet** component will now look like this in the **Inspector** window:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，**行星**组件现在将看起来像这样：
- en: '![Figure 8.15 – The Planet component on the Planet Prefab'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.15 – 行星预制体上的行星组件'
- en: '](img/Figure_8.15_B15145.jpg)'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.15_B15145.jpg)'
- en: Figure 8.15 – The Planet component on the Planet Prefab
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.15 – 行星预制体上的行星组件
- en: Please now **Build and Run** the project. When the Earth is instantiated, it
    will be tilted and rotating at the rate of one full rotation every 24 seconds.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 请现在**构建并运行**项目。当地球被实例化时，它将以每24秒一个完整旋转的速度倾斜和旋转。
- en: At this point, we have a basic AR scene with image tracking. It lets the AR
    Tracked Image Manager instantiate our Earth Prefab directly when an image is detected.
    Currently, it doesn't distinguish what image is detected (supposing you had multiple
    images in the reference library) and always instantiates an Earth Prefab. We need
    to make the app more robust, and we can do this from the Main-mode.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们有一个基本的AR场景，具有图像跟踪功能。它允许AR跟踪图像管理器在检测到图像时直接实例化我们的地球预制体。目前，它无法区分检测到的是哪种图像（假设你在参考库中有多个图像）并且始终实例化地球预制体。我们需要使应用更加健壮，并且我们可以从主模式中做到这一点。
- en: Building the app's Main-mode
  id: totrans-237
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建应用的主模式
- en: As you now know, `ARTrackedImageManager` has a "Tracked Image Prefab" field;
    however, this is not intended for content" ([https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/tracked-image-manager.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/tracked-image-manager.html)).
    Currently, when *any* reference image is recognized, the Earth Prefab will *always*
    be instantiated.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 正如你所知，`ARTrackedImageManager`有一个“跟踪图像预制体”字段；然而，这并不是用于内容" ([https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/tracked-image-manager.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.2/manual/tracked-image-manager.html))。目前，当**任何**参考图像被识别时，地球预制体将**始终**被实例化。
- en: 'Rather, when the app is in Main-mode, we should determine which planet card
    image is being tracked and instantiate the corresponding planet prefab for that
    card. So far, we only have one planet, Earth, in the image reference library.
    However, later in this chapter, we''ll expand the project for all the planets.
    We can start by removing the prefab from the **AR Tracked Image Manager** component,
    as follows:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当应用处于主模式时，我们应该确定正在跟踪哪个行星卡片图像，并为该卡片实例化相应的行星预制体。到目前为止，我们在图像参考库中只有一个行星，地球。然而，在本章的后面部分，我们将扩展项目以包含所有行星。我们可以从移除**AR跟踪图像管理器**组件中的预制体开始，如下所示：
- en: In the **Hierarchy** window, select the **AR Session Origin** game object.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，选择**AR会话原点**游戏对象。
- en: 'In the **Inspector** window, delete the contents of the **AR Tracked Image
    Manager | Tracked Image Prefab** slot, as shown in the following screenshot:'
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，删除**AR跟踪图像管理器 | 跟踪图像预制体**槽的内容，如下截图所示：
- en: '![Figure 8.16 – AR Tracked Image Manager with the default prefab field cleared'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.16 – 默认预制体字段已清除的AR跟踪图像管理器'
- en: '](img/Figure_8.16_B15145.jpg)'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '](img/Figure_8.16_B15145.jpg)'
- en: Figure 8.16 – AR Tracked Image Manager with the default prefab field cleared
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.16 – 默认预制体字段已清除的AR跟踪图像管理器
- en: When no prefab is specified in `ARTrackedImage` component on it. Now, we can
    instantiate the prefab as a child of that.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 当在它上面的`ARTrackedImage`组件中没有指定预制体时。现在，我们可以将其作为子对象实例化预制体。
- en: In our scene framework, the app starts in Startup-mode, then goes into Scan-mode
    once the AR Session is ready. When Scan-mode detects a reference image, it goes
    into Main-mode by enabling the **Main Mode** game object under **Interaction Controller**.
    This displays the **Main UI** panel. Let's build this panel now.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景框架中，应用以启动模式开始，一旦AR会话准备就绪，就进入扫描模式。当扫描模式检测到参考图像时，通过在**交互控制器**下启用**主模式**游戏对象，进入主模式。这会显示**主UI**面板。现在让我们构建这个面板。
- en: Writing the PlanetsMainMode script
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写PlanetsMainMode脚本
- en: In this section, we will write a new `PlanetsMainMode` script to replace the
    default `MainMode` one provided in the default scene template. Like other modes
    in our framework, it will display the appropriate UI panel when enabled. Then,
    when an image is tracked, it will find the corresponding planet prefab and instantiate
    it.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个新的`PlanetsMainMode`脚本，以替换默认场景模板中提供的默认`MainMode`脚本。像我们框架中的其他模式一样，当启用时，它将显示适当的UI面板。然后，当跟踪到图像时，它将找到相应的行星预制体并实例化它。
- en: The script needs to figure out which image the AR software found and decide
    which prefab to instantiate as a child of the tracked image. In our case, we'll
    use the name of the detected image file to determine which planet card is recognized
    (by design, each card image is prefixed with the planet's name; for example, `Earth-MarkerCard`).
    The script will implement a serializable dictionary we can use to look up the
    planet prefab for each planet name, using the *Serialized Dictionary Lite* Asset
    package (you already have this package installed because `ARFramework` also requires
    it. See [https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992](https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992)
    for more information).
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该脚本需要确定AR软件找到了哪个图像，并决定将哪个预制体实例化为跟踪图像的子对象。在我们的例子中，我们将使用检测到的图像文件名来确定哪个行星卡片被识别（按照设计，每个卡片图像都以行星的名称为前缀；例如，`Earth-MarkerCard`）。脚本将实现一个可序列化的字典，我们可以使用它来查找每个行星名称的行星预制体，使用*序列化字典轻量版*资产包（因为你已经安装了这个包，因为`ARFramework`也需要它。有关更多信息，请参阅[https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992](https://assetstore.unity.com/packages/tools/utilities/serialized-dictionary-lite-110992)）。
- en: 'Begin by performing the following steps:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 首先执行以下步骤：
- en: In your `Scripts/` folder, create a new C# script named `PlanetsMainMode`.
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的`Scripts/`文件夹中，创建一个名为`PlanetsMainMode`的新C#脚本。
- en: In the **Hierarchy** window, select the **Main Mode** game object (under **Interaction
    Controller**).
  id: totrans-252
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次**窗口中，选择**主模式**游戏对象（位于**交互控制器**下）。
- en: In its **Inspector** window, remove the default **Main Mode** component using
    the *3-dot* context menu and selecting **Remove Component**.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其**检查器**窗口中，使用**3点**上下文菜单选择**移除组件**来移除默认的**主模式**组件。
- en: Drag the `PlanetMainMode` script from the **Project** window onto the **Main
    Mode** object, adding it as a new component.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`PlanetMainMode`脚本从**项目**窗口拖动到**主模式**对象上，将其添加为新组件。
- en: '*Double-click* the `PlanetMainMode` script to open it for editing.'
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**双击**`PlanetMainMode`脚本以打开它进行编辑。'
- en: 'Begin by adding the following `using` assembly declarations at the top of the
    file:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先在文件顶部添加以下`using`程序集声明：
- en: '[PRE3]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'When an image is tracked, we need to find which planet prefab to instantiate.
    At the top of the file, define a `PlanetPrefabDictionary` as follows, and declare
    a `planetPrefab` variable for it:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当跟踪到图像时，我们需要找到要实例化的行星预制体。在文件顶部定义一个`PlanetPrefabDictionary`如下，并为它声明一个`planetPrefab`变量：
- en: '[PRE4]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'When this mode is enabled, similar to the original `MainMode` script, we''ll
    show the Main UI panel:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当此模式启用时，类似于原始的`MainMode`脚本，我们将显示主UI面板：
- en: '[PRE5]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Likewise, we''ll enter Main-mode after Scan-mode has determined it has started
    tracking an image. So, `OnEnable` should also instantiate planets for the tracked
    images. Add a reference to `imageManager` at the top of the class:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在扫描模式确定开始跟踪图像后，我们将进入主模式。因此，`OnEnable`也应该为跟踪的图像实例化行星。在类的顶部添加对`imageManager`的引用：
- en: '[PRE6]'
  id: totrans-263
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Then, update `OnEnable`:'
  id: totrans-264
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，更新`OnEnable`：
- en: '[PRE7]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Implement `InstantiatePlanet`, as follows:'
  id: totrans-266
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现以下`InstantiatePlanet`：
- en: '[PRE8]'
  id: totrans-267
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `InstantiatePlanet` function determines the planet's name from the tracked
    image filename (for example, `Earth-MarkerImage`) by assuming the images follow
    our naming convention. It makes sure we don't already have the planet object in
    the scene. If not, the planet prefab is instantiated and parented to the tracked
    image object. (We pass `false` as a second parameter so that the planet is positioned
    relative to the tracked image transform. See [https://docs.unity3d.com/ScriptReference/Transform.SetParent.html](https://docs.unity3d.com/ScriptReference/Transform.SetParent.html).)
  id: totrans-268
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`InstantiatePlanet`函数通过假设图像遵循我们的命名约定来确定跟踪图像文件名中的行星名称（例如，`Earth-MarkerImage`）。它确保场景中还没有行星对象。如果没有，则实例化行星预制体并将其作为跟踪图像对象的父对象。（我们传递`false`作为第二个参数，以便行星相对于跟踪图像变换进行定位。有关更多信息，请参阅[https://docs.unity3d.com/ScriptReference/Transform.SetParent.html](https://docs.unity3d.com/ScriptReference/Transform.SetParent.html)）。'
- en: Save the script.
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。
- en: Back in Unity, make sure you have the **Main Mode** game object selected in
    the **Hierarchy** window.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Unity中，确保你在**层次**窗口中选择了**主模式**游戏对象。
- en: Drag the **AR Session Origin** object from the **Hierarchy** window into the
    **Inspector** window, dropping it onto the **Image Manager** slot.
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**AR会话原点**对象从**层次**窗口拖动到**检查器**窗口中，将其放置在**图像管理器**槽中。
- en: In the **Inspector** window, click the **+** button at the bottom right of the
    **Planets Main Mode | Planet Prefabs** list.
  id: totrans-272
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，点击**行星主模式 | 行星预制体**列表右下角的**+**按钮。
- en: Type the word `Earth` into the `Id` slot.
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Id**槽中输入单词`Earth`。
- en: Unfold the item and, from the **Hierarchy** window, drag the **Earth Prefab**
    object on the **Value** slot in the **Inspector** window.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开项目，并从**层次结构**窗口中，将**地球预制件**对象拖放到**检查器**窗口中的**值**槽。
- en: Use **File | Save** to save your work.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**文件 | 保存**保存你的工作。
- en: If you `PlanetsMainMode` when it is enabled. Now, the code is ready to detect
    different planet card images and instantiate different corresponding planet prefabs.
    We will start by adding Mars.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 当它启用时，`PlanetsMainMode`。现在，代码已准备好检测不同的行星卡片图像并实例化相应的不同行星预制件。我们将从添加火星开始。
- en: Expanding the project with multiple planets
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个行星扩展项目
- en: To add another planet to the project, we need to add its planet card image to
    the Reference Image Library, create its planet prefab, including a material for
    rendering the planet skin, and add the reference to the `planetPrefabs` list in
    `PlanetsMainMode`. Then, we'll update the script to handle tracking multiple planets.
    Let's walk through the steps for adding Mars.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 要将另一个行星添加到项目中，我们需要将其行星卡片图像添加到参考图像库，创建其行星预制件，包括用于渲染行星皮肤的材质，并将引用添加到`PlanetsMainMode`中的`planetPrefabs`列表。然后，我们将更新脚本以处理跟踪多个行星。让我们一步步地添加火星。
- en: Adding the planet card image to the Reference Image Library
  id: totrans-279
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将行星卡片图像添加到参考图像库
- en: 'Perform the following steps to add Mars to our **Reference Image Library**:'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤将火星添加到我们的**参考图像库**：
- en: Locate and select your `Image Library/` folder.)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并选择你的`Image Library/`文件夹）。
- en: In its **Inspector** window, click **Add Image**.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在其**检查器**窗口中，点击**添加图像**。
- en: Locate and drag the `Mars-MarkerCard` image from the **Project** window and
    drop it onto the empty image **Texture** slot in the **Inspector** window.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位并拖动`Mars-MarkerCard`图像从**项目**窗口，并将其拖放到**检查器**窗口中空白的**纹理**槽。
- en: Check the `0.08` meters (8 cm).
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 检查`0.08`米（8厘米）。
- en: Also, check the **Keep Texture At Runtime** checkbox.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，勾选**在运行时保持纹理**复选框。
- en: 'The Reference Image Library should now look as follows:'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 参考图像库现在应该看起来如下：
- en: '![](img/Figure_8.17_B15145.jpg)'
  id: totrans-287
  prefs: []
  type: TYPE_IMG
  zh: '![](img/Figure_8.17_B15145.jpg)'
- en: Figure 8.17 – Reference Image Library with the Mars-MarkerCard image added
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.17 – 添加了火星-MarkerCard图像的参考图像库
- en: Next, we'll create the Mars Prefab and material.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将创建火星预制件和材质。
- en: Creating the planet prefab
  id: totrans-290
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建行星预制件
- en: 'To create the planet prefab, we''ll copy and modify the Earth Prefab assets.
    Perform the following steps:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建行星预制件，我们将复制并修改地球预制件资产。执行以下步骤：
- en: In the `Prefabs/` folder).
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Prefabs/`文件夹）。
- en: Select `Mars Prefab`.
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`Mars Prefab`。
- en: Open **Mars Prefab** for editing. Select the child **Planet** game object.
  id: totrans-294
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**火星预制件**进行编辑。选择子**行星**游戏对象。
- en: In the `Materials/` folder and select `Mars Material`.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Materials/`文件夹中，选择`Mars Material`。
- en: Drag **Mars Material** onto the **Planet** object.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**火星材质**拖放到**行星**对象上。
- en: In the `Planet Textures/` folder) and drag it onto the **Mars Material | Base
    Map** texture slot.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Planet Textures/`文件夹）并将它拖放到**火星材质 | 基图**纹理槽。
- en: 'The Mars Prefab Planet should now look as follows:'
  id: totrans-298
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 火星预制件的行星现在应该看起来如下：
- en: '![Figure 8.18 – Mars Prefab with its Planet set to the Mars Material'
  id: totrans-299
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '![图8.18 – 火星预制件及其行星设置为火星材质'
- en: '](img/Figure_8.18_B15145.jpg)'
  id: totrans-300
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '](img/Figure_8.18_B15145.jpg)'
- en: Figure 8.18 – Mars Prefab with its Planet set to the Mars Material
  id: totrans-301
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图8.18 – 火星预制件及其行星设置为火星材质
- en: Next, we'll set the Mars Planet metadata. In the **Hierarchy** window, select
    the root **Mars Prefab** game object.
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将设置火星行星元数据。在**层次结构**窗口中，选择根**火星预制件**游戏对象。
- en: In the `Mars`; `25.2`; `24.7`. For its `Mars is the fourth planet from the Sun
    and the second-smallest planet in the Solar System`.
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Mars`; `25.2`; `24.7`。因为**火星是太阳系中距离太阳第四颗行星，也是太阳系中第二小的行星**。
- en: '**Save** the prefab and return to the scene Hierarchy (using the **<** button
    at the top left of the **Hierarchy** window).'
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**保存**预制件并返回场景层次结构（使用**层次结构**窗口左上角的**<**按钮）。'
- en: 'Now, we can add the prefab to the Main-mode **Planet Prefabs** dictionary,
    as follows:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以将预制件添加到主模式的**行星预制件**字典中，如下所示：
- en: In the scene **Hierarchy**, select the **Main Mode** game object (under **Interaction
    Controller**).
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景**层次结构**中，选择**主模式**游戏对象（在**交互控制器**下）。
- en: In the **Inspector** window, click the **+** button at the bottom right of the
    **Planets Main Mode | Planet Prefabs** list.
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**窗口中，点击**行星主模式 | 行星预制件**列表右下角的**+**按钮。
- en: Type the word `Mars` into the `Id` slot.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Id**槽中输入单词`Mars`。
- en: Unfold the item and, from the **Hierarchy** window, drag the **Mars Prefab**
    object onto the **Value** slot in the **Inspector** window.
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开项目，从**层次结构**窗口中，将**火星预制体**对象拖放到**检查器**窗口中的**值**槽位。
- en: 'The **Planets Main Mode** component should now look as follows:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: '**行星主模式**组件现在应该如下所示：'
- en: '![Figure 8.19 – The Planets Main Mode component''s Planet Prefabs dictionary
    with Mars added'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.19 – The Planets Main Mode component''s Planet Prefabs dictionary
    with Mars added'
- en: '](img/Figure_8.19_B15145.jpg)'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.19_B15145.jpg](img/Figure_8.19_B15145.jpg)'
- en: Figure 8.19 – The Planets Main Mode component's Planet Prefabs dictionary with
    Mars added
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.19 – 添加火星后的行星主模式组件的行星预制体字典
- en: If you **Build and Run** now, when in Scan-mode, point the camera at your Mars
    planet card. The Mars 3D object will be added to the scene, rotating in all its
    glory!
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您现在**构建并运行**，在扫描模式下，将相机指向您的火星行星卡片。火星3D对象将被添加到场景中，旋转展示其全部荣耀！
- en: Unfortunately, after doing this, if you move the camera to scan the Earth planet
    card, nothing will happen. Let's fix that.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，执行此操作后，如果您将相机移动到扫描地球行星卡片，将不会发生任何操作。让我们修复这个问题。
- en: Responding to detected images
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对检测到的图像做出响应
- en: 'Your scripts can subscribe to events so that they''re notified when an image
    is being tracked, updated, or removed. Specifically, we can implement an `OnTrackedImageChanged`
    function to handle these events. We can use this in the `PlanetsMainMode` script,
    as follows:'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 您的脚本可以订阅事件，以便在图像被跟踪、更新或删除时得到通知。具体来说，我们可以实现一个`OnTrackedImageChanged`函数来处理这些事件。我们可以在`PlanetsMainMode`脚本中使用它，如下所示：
- en: 'Open the `PlanetsMainMode` script for editing again and add the following code:'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次打开`PlanetsMainMode`脚本进行编辑，并添加以下代码：
- en: '[PRE9]'
  id: totrans-319
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the following line to your `OnEnable` function, adding a listener to `imageManager`:'
  id: totrans-320
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下行添加到您的`OnEnable`函数中，为`imageManager`添加监听器：
- en: '[PRE10]'
  id: totrans-321
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Likewise, remove the listener in `OnDisable`:'
  id: totrans-322
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，在`OnDisable`中移除监听器：
- en: '[PRE11]'
  id: totrans-323
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: When `ARTrackedImageManager` detects a new image, the Main-mode script will
    kick in. It contains a listener for the events and will call `InstantiatePlanet`
    for any newly tracked images.
  id: totrans-324
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当`ARTrackedImageManager`检测到新图像时，主模式脚本将启动。它包含事件监听器，并将为任何新跟踪的图像调用`InstantiatePlanet`。
- en: 'If the app completely loses image tracking, we should go back to Scan-mode
    and display its instructional graphic, prompting the user to find a reference
    image. Add this check to `Update`, as follows:'
  id: totrans-325
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果应用程序完全丢失图像跟踪，我们应该回到扫描模式并显示其教学图形，提示用户找到参考图像。将此检查添加到`Update`中，如下所示：
- en: '[PRE12]'
  id: totrans-326
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Tip – Tracking the State of Individual Trackables
  id: totrans-327
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 小贴士——跟踪单个可追踪对象的状态
- en: AR Foundation also provides you with the current tracking state of each trackable
    image individually. Given a trackable image (`ARTRackedImage`), you can check
    its `trackingState` for `Tracking` – image is actively tracking, `Limited` – image
    is being tracked but not reliably, or `None` – the image is not being tracked.
    See [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html)`#tracking-state`.
    In this project, we will only go back to Scan mode when no images are being tracked,
    so we don't necessarily need this extra level of status monitoring.
  id: totrans-328
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: AR Foundation还为您提供了每个可追踪图像的当前跟踪状态。给定一个可追踪图像（`ARTRackedImage`），您可以检查其`trackingState`以确定是`Tracking`——图像正在积极跟踪，`Limited`——图像正在被跟踪但不可靠，或`None`——图像没有被跟踪。请参阅[https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/tracked-image-manager.html)`#tracking-state`。在本项目中，我们只有在没有图像被跟踪时才会回到扫描模式，因此我们不一定需要这一额外的状态监控级别。
- en: 'OK – this is getting pretty robust. **Build and Run** the project again, this
    time scanning either (or both) the Earth and Mars planet cards. We''ve got planets!
    The following screen capture shows the app running, with the addition of the information
    UI at the bottom of the screen, which we will add in the next section:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 好的——这已经相当稳健了。**构建并运行**项目，这次扫描地球和火星的行星卡片（或两者都扫描）。我们得到了行星！以下屏幕截图显示了应用程序正在运行，底部增加了信息UI，我们将在下一节中添加：
- en: '![Figure 8.20 – Earth and Mars rendered at runtime'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.20 – Earth and Mars rendered at runtime'
- en: '](img/Figure_8.20_B15145.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: '![Figure 8.20_B15145.jpg](img/Figure_8.20_B15145.jpg)'
- en: Figure 8.20 – Earth and Mars rendered at runtime
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.20 – 运行时渲染的地球和火星
- en: Go ahead and add the rest of the planets to your project by following these
    same steps. As we mentioned earlier in this chapter, referencing the NASA data
    provided at [https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html](https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html),
    use their *Length of Day* row for our `Planet` script already includes an animation
    speed scalar, `animationHoursPerSecond`, that you can use to modify the rotation
    rates that are visualized in the app.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 按照这些相同的步骤继续添加其余的行星到你的项目中。正如我们在本章前面提到的，参考[https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html](https://nssdc.gsfc.nasa.gov/planetary/factsheet/index.html)提供的NASA数据，他们的*日长*行对于我们的`Planet`脚本已经包含了一个动画速度标量`animationHoursPerSecond`，你可以用它来修改在应用程序中可视化的旋转速率。
- en: Now that our application supports multiple planets, you might want to tell the
    user more about the specific planet that they are looking at. Let's add this capability
    to Main-mode so that it responsively updates the UI.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应用程序支持多个行星，你可能想告诉用户更多关于他们正在查看的特定行星的信息。让我们将此功能添加到主模式中，以便它能够响应式地更新UI。
- en: Making a responsive UI
  id: totrans-335
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 制作响应式UI
- en: In this section, we'll add an info panel to the bottom of the screen (as shown
    in the preceding screen capture). When you point the camera at one planet or another,
    we'll show the planet's name, as well as an **Info** button, which will cause
    a text box to appear that contains more information about that planet.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向屏幕底部添加一个信息面板（如图8.20所示的屏幕截图）。当你将相机对准一个或另一个行星时，我们将显示行星的名称，以及一个**信息**按钮，点击该按钮将显示包含该行星更多信息的文本框。
- en: Creating the Main-mode UI
  id: totrans-337
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建主模式UI
- en: 'When the app is in Main-mode, the Main UI panel is displayed. On this panel,
    we''ll show the name of the current planet and an **Info** button for the user
    to press when they want more details about that planet. Perform the following
    steps:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序处于主模式时，主UI面板将显示。在此面板上，我们将显示当前行星的名称，并为用户提供一个**信息**按钮，以便在需要更多关于该行星的详细信息时按下。执行以下步骤：
- en: In the **Hierarchy** window, unfold the **UI Canvas** object and unfold its
    child **Main UI** object.
  id: totrans-339
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中，展开**UI画布**对象及其子**主UI**对象。
- en: The default child text in the panel is a temporary placeholder, so we can remove
    it. *Right-click* the child **Text** object and select *Delete*.
  id: totrans-340
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 面板中的默认子文本是一个临时占位符，因此我们可以将其删除。*右键单击*子**文本**对象并选择*删除*。
- en: Create a subpanel by *right-clicking* on `Info Panel`.
  id: totrans-341
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过*右键单击*`信息面板`创建一个子面板。
- en: Use `175`.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`175`。
- en: I set my background `255`.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我将背景设置为`255`。
- en: Create a text element for the planet name. *Right-click* `Planet Name Text`.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为行星名称创建一个文本元素。*右键单击*`行星名称文本`。
- en: On the Planet Name Text `[Planet name]`.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在行星名称文本 `[行星名称]`。
- en: Set the text properties; for example, `50`; `72`.
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置文本属性；例如，`50`; `72`。
- en: Create an `Info Button`.
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个`信息按钮`。
- en: Set the button properties; for example, `150, 150`; `-20`.
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 设置按钮属性；例如，`150, 150`; `-20`。
- en: Unfold `-50` and its text content to `Info`.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 展开并设置 `-50` 及其文本内容为 `信息`。
- en: '*Right-click* `?`, `72`, `-15`.'
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '*右键单击*`?`，`72`，`-15`。'
- en: We're going to use this button to toggle a details panel on and off. So, let's
    replace its **Button** component with a **Toggle** instead. With the **Info Button**
    object selected in the **Hierarchy** window, in the **Inspector** window, remove
    the **Button** component using the *3-dot* context menu and selecting **Remove
    Component**.
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将使用此按钮来切换详细信息的面板开/关。因此，让我们用**切换**组件替换其**按钮**组件。在**层次结构**窗口中选择**信息按钮**对象，在**检查器**窗口中，使用*3点*上下文菜单选择**移除组件**来移除**按钮**组件。
- en: Select `toggle`, and add a **Toggle** component.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择`切换`，并添加一个**切换**组件。
- en: 'My main **Info Panel** now looks as follows:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 我的主要**信息面板**现在看起来如下：
- en: '![Figure 8.21 – Main UI''s Info Panel with Planet Name Text and an Info Button'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 – 主UI的信息面板，包含行星名称文本和信息按钮'
- en: '](img/Figure_8.21_B15145.jpg)'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.21 – 主UI的信息面板，包含行星名称文本和信息按钮'
- en: Figure 8.21 – Main UI's Info Panel with Planet Name Text and an Info Button
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.21 – 主UI的信息面板，包含行星名称文本和信息按钮
- en: The Planet Name Text's content will be filled in at runtime. Let's add that
    code now.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 行星名称文本的内容将在运行时填充。让我们现在添加这段代码。
- en: Pointing the camera to show information
  id: totrans-358
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 指向相机以显示信息
- en: The plan is that with one or more virtual planets instantiated in the scene,
    the user can point the camera at a planet so that it displays the planet's name
    in the Info Panel. This can be implemented using a `Physics Raycast`. (Raycasts
    were introduced and explained in the previous chapters. See [https://docs.unity3d.com/ScriptReference/Physics.Raycast.html](https://docs.unity3d.com/ScriptReference/Physics.Raycast.html)).
    Recall that at the beginning of this chapter, we put the Planet Prefab on a layer
    named `PlacedObjects`. We'll make use of that here.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 计划是在场景中实例化一个或多个虚拟行星后，用户可以将相机指向一个行星，使其在信息面板中显示行星的名称。这可以通过使用`Physics Raycast`来实现。（射线投射在前面章节中已介绍并解释。见[https://docs.unity3d.com/ScriptReference/Physics.Raycast.html](https://docs.unity3d.com/ScriptReference/Physics.Raycast.html)）。回想一下，在本章开头，我们将行星预制件放置在一个名为`PlacedObjects`的层上。我们在这里将利用这一点。
- en: 'Make the following changes to the `PlanetsMainMode` script:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 对`PlanetsMainMode`脚本进行以下更改：
- en: 'Ensure the script file contains the following assembly references:'
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保脚本文件包含以下程序集引用：
- en: '[PRE13]'
  id: totrans-362
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'At the top of the class, declare and initialize references to the AR `camera`
    and `layerMask` variables, as follows:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部，声明并初始化对AR `camera`和`layerMask`变量的引用，如下所示：
- en: '[PRE14]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Also, add references to the `planetName` and `infoButton` UI elements in the
    Info Panel:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还在信息面板中添加对`planetName`和`infoButton` UI元素的引用：
- en: '[PRE15]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We can initialize the UI settings when the mode is enabled. Please add the
    following lines to the `OnEnable` function:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当模式启用时，我们可以初始化UI设置。请将以下行添加到`OnEnable`函数中：
- en: '[PRE16]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, add the following highlighted code to the `Update` function:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，将以下高亮代码添加到`Update`函数中：
- en: '[PRE17]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Save the script. Back in Unity, select the **Main Mode** object in the **Hierarchy**
    window.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存脚本。回到Unity中，在**层次结构**窗口中选择**主模式**对象。
- en: Drag the **Planet Name Text** game object from the **Hierarchy** window (under
    **UI Canvas / Main UI / Info Panel**) into the **Planets Main Mode | Planet Name**
    slot.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**行星名称文本**游戏对象从**层次结构**窗口（位于**UI Canvas / 主 UI / 信息面板**下）拖动到**行星主模式 | 行星名称**槽中。
- en: Drag the **Info Button** object onto the **Info Button** slot.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**信息按钮**对象拖动到**信息按钮**槽中。
- en: Go ahead and **Build and Run** the project one more time. While viewing one
    or more planets, as you point the device's camera at one of them, the planet's
    name will be shown in the Info Panel at the bottom of the screen.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 继续构建并运行项目。在查看一个或多个行星时，当你将设备的相机指向其中一个时，行星的名称将在屏幕底部的信息面板中显示。
- en: Lastly, let's set up the Info Button and description display.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们设置信息按钮和描述显示。
- en: Displaying information details
  id: totrans-376
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 显示信息详情
- en: 'When the user is pointing their camera at a virtual 3D planet in the scene,
    we show the name of the planet in the Info Panel. When the user clicks the **Info**
    button, we want to show more information about the planet, such as its description
    text. Let''s add a text panel for that now by performing the following steps:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户将相机指向场景中的虚拟3D行星时，我们在信息面板中显示行星的名称。当用户点击**信息**按钮时，我们希望显示有关行星的更多信息，例如其描述文本。现在让我们通过以下步骤添加一个文本面板：
- en: In the `Details Panel`.
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**详细信息面板**中。
- en: It has already been set to `30`, `30`, `150`, and `200`.
  id: totrans-379
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它已经设置为`30`、`30`、`150`和`200`。
- en: '*Right-click* `Details Text`.'
  id: totrans-380
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击**详细信息文本**。
- en: 'Format the text area; for example, set its `48`, its `30, 30, 30, 30`, and
    its **Alignment**: to **Center, Middle**.'
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 格式化文本区域；例如，设置其`48`、`30, 30, 30, 30`和其**对齐方式**：为**居中，中间**。
- en: 'Now, add control of this panel to the `PlanetsMainMode` script, as follows:'
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将此面板的控制权添加到`PlanetsMainMode`脚本中，如下所示：
- en: 'Add references to `detailsPanel` and `detailsText` at the top of the class:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的顶部添加对`detailsPanel`和`detailsText`的引用：
- en: '[PRE18]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Ensure the panel is hidden when the mode is enabled. Add the following line
    to the `OnEnable` function:'
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在模式启用时隐藏面板。将以下行添加到`OnEnable`函数中：
- en: '[PRE19]'
  id: totrans-386
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Initialize the panel''s content when a planet is being selected. That is, in
    `Update`, we must set `detailsText` at the same time we set `planetName`:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当选择行星时初始化面板的内容。也就是说，在`Update`中，我们必须同时设置`detailsText`和`planetName`：
- en: '[PRE20]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Save the script. Back in Unity, we'll wire up the **Info Button** toggle.
  id: totrans-389
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 保存脚本。回到Unity中，我们将连接**信息按钮**切换。
- en: With **Info Button** selected in the **Hierarchy** window, in the **Inspector**
    window, click the **+** button at the bottom right of the **Toggle | On Value
    Changed** action list.
  id: totrans-390
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**窗口中选择**信息按钮**，在**检查器**窗口中，点击**Toggle | On Value Changed**动作列表右下角的**+**按钮。
- en: From the **Hierarchy** window, drag the **Details Panel** game object onto the
    **On Value Changed | Object** slot.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**窗口中，将**详细信息面板**游戏对象拖放到**On Value Changed | Object**槽中。
- en: From the **Function** selection list, choose **GameObject | Dynamic Bool | SetActive**.
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**功能**选择列表中，选择**GameObject | Dynamic Bool | SetActive**。
- en: Save the scene.
  id: totrans-393
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 保存场景。
- en: 'Now, when you **Build and Run** the project and view a planet, then press the
    **Info** button, the Details Panel will be displayed alongside the planet''s description
    text, as shown in the following screen capture from my phone:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当你**构建并运行**项目并查看一个行星时，然后按下**信息**按钮，详细信息面板将显示在行星描述文本旁边，如下面的手机屏幕截图所示：
- en: '![Figure 8.22 – Displaying description text about Mars in the toggled Details
    Panel'
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 – 在切换的详细信息面板中显示关于火星的描述文本'
- en: '](img/Figure_8.22_B15145.jpg)'
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '![图8.22 – 在切换的详细信息面板中显示关于火星的描述文本'
- en: Figure 8.22 – Displaying description text about Mars in the toggled Details
    Panel
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 图8.22 – 在切换的详细信息面板中显示关于火星的描述文本
- en: In this section, we added a responsive UI to the scene. When the user points
    their device camera at a virtual planet that's been instantiated in the scene,
    the name of the planet is displayed in the Info Panel at the bottom of the screen.
    If the user taps the **Info** button, a text panel is toggled, showing additional
    details about that specific planet.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们向场景添加了一个响应式UI。当用户将他们的设备相机指向场景中实例化的虚拟行星时，行星的名称会显示在屏幕底部的信息面板中。如果用户点击**信息**按钮，一个文本面板会被切换，显示有关该特定行星的更多详细信息。
- en: Can you think of additional ways to improve this project?
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 你能想到其他改进这个项目的办法吗？
- en: Summary
  id: totrans-400
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you built an AR project that lets you visualize and learn about
    planets in our Solar System. The scene uses AR image detection and tracks the
    planet cards that you printed out from the PDF file provided with the files for
    this book. Each planet card image includes a distinct marker with unique details,
    high contrast edges, and asymmetric shapes, making them readily detectable and
    trackable by the AR system. You set up the AR Session to track images using the
    AR Trackable Image Manager component and built a Reference Image Library asset
    with the planet card images.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你构建了一个AR项目，让你能够可视化并学习我们太阳系中的行星。场景使用了AR图像检测，并跟踪了你从本书提供的PDF文件中打印出的行星卡片。每张行星卡片图像都包含一个独特的标记，具有独特的细节、高对比度的边缘和不对称的形状，这使得它们易于被AR系统检测和跟踪。你设置了AR会话，使用AR可追踪图像管理器组件来跟踪图像，并使用行星卡片图像构建了一个参考图像库资产。
- en: You then created a generic Planet Prefab with a Planet script that controls
    the rotation behavior and metadata for a planet. Then, you created separate prefab
    variants for each planet. You wrote a `PlanetsMainMode` script that instantiates
    the correct planet prefab when a specific planet card image is detected. This
    allows multiple tracked images and planets to be present in the scene. Then, you
    added a responsive UI where the user can point their device camera to an instantiated
    planet and get additional information about that virtual object.
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你创建了一个通用的行星预制件，其中包含控制行星旋转行为和元数据的行星脚本。然后，你为每个行星创建了单独的预制件变体。你编写了一个`PlanetsMainMode`脚本，当检测到特定的行星卡片图像时，它会实例化正确的行星预制件。这允许场景中存在多个跟踪图像和行星。然后，你添加了一个响应式UI，用户可以将他们的设备相机指向一个实例化的行星，并获取有关该虚拟对象的更多信息。
- en: 'In the next chapter, we''ll explore another kind of AR application: flipping
    the device camera so that it''s facing the user to make selfie face filters.'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探索另一种类型的AR应用：翻转设备相机，使其面向用户，制作自拍面部滤镜。
