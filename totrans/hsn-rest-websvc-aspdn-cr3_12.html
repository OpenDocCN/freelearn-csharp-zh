<html><head></head><body>
        

                            
                    <h1 class="header-title">Implementing the Domain Logic</h1>
                
            
            
                
<p class="mce-root">This chapter focuses on the logic layer of the catalog web service. As previously discussed, the logic will be encapsulated in the <kbd>Catalog.Domain</kbd> project. The chapter shows how to implement the application logic using the service classes approach. The aim of these classes is to perform the mapping logic between the requests and the effective entities used on the data source layer and to provide all the additional logic needed by our application. Moreover, we will also see how to test the implemented code in order to verify the behaviors.</p>
<p>This chapter will cover the following topics:</p>
<ul>
<li>How to implement the service classes for our application</li>
<li>How to implement request DTOs and the related validation system</li>
<li>How to apply tests to verify the implemented logic</li>
</ul>
<p>The code in the following chapter is available in the following GitHub repository: <a href="https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3">https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing service classes</h1>
                
            
            
                
<p>Let's proceed with the concrete part of the chapter by implementing the service classes. This layer of abstraction will define the methods that query the data layer, including the  <kbd>IItemRepository</kbd> interface, and map the resulting data. </p>
<p>As mentioned previously, our service implementation will use DTO classes in order to pass the data through the stack. First of all, let's define the request classes needed by our service. To do that, we can start by creating a new <kbd>Requests/Item</kbd> folder structure in the <kbd>Catalog.Domain</kbd> project, and by adding a new <kbd>AddItemRequest.cs</kbd> file in the folder:</p>
<pre>using System;<br/>using Catalog.Domain.Entities;<br/><br/>namespace Catalog.Domain.Requests.Item<br/>{<br/>    public class <strong>AddItemRequest <br/></strong>    {<br/>        public string Name { get; set; }<br/>        public string Description { get; set; }<br/>        public string LabelName { get; set; }<br/>        public Price Price { get; set; }<br/>        public string PictureUri { get; set; }<br/>        public DateTimeOffset ReleaseDate { get; set; }<br/>        public string Format { get; set; }<br/>        public int AvailableStock { get; set; }<br/>        public Guid GenreId { get; set; }<br/>        public Guid ArtistId { get; set; }<br/>    } <br/>}</pre>
<p>The preceding code defines the add item request. The class is very similar to the <kbd>Item</kbd> entity class, except that the <kbd>Id</kbd> field, the <kbd>Artist</kbd> field, and the <kbd>Genre</kbd> field are not present. Furthermore, the <kbd>Id</kbd> field will be generated by the EF Core implementation, and the <kbd>Artist</kbd> and <kbd>Genre</kbd> fields are handled by the ORM in order to represent the relationship between the entities.</p>
<p>In the same way, we can proceed by defining the <kbd>EditItemRequest</kbd> class in the same folder:</p>
<pre>using System;<br/>using Catalog.Domain.Entities;<br/><br/>namespace Catalog.Domain.Requests.Item<br/>{<br/>    public class EditItemRequest<br/>    {<br/>        public Guid Id { get; set; }<br/>        public string Name { get; set; }<br/>        public string Description { get; set; }<br/>        public string LabelName { get; set; }<br/>        public Price Price { get; set; }<br/>        public string PictureUri { get; set; }<br/>        public DateTimeOffset ReleaseDate { get; set; }<br/>        public string Format { get; set; }<br/>        public int AvailableStock { get; set; }<br/>        public Guid GenreId { get; set; }<br/>        public Guid ArtistId { get; set; }<br/>    }<br/>}</pre>
<p>Also in the preceding snippet, the class contains the same fields used by the <kbd>Item</kbd> entity, except for the <kbd>Artist</kbd> and <kbd>Genre</kbd> fields, for the same reason described earlier. As you can understand from the class name, it represents the update item operation. The same approach can be taken for the get item operation shown as follows:</p>
<pre>using System;<br/><br/>namespace Catalog.Domain.Requests.Item<br/>{<br/>    public class GetItemRequest<br/>    {<br/>        public Guid Id { get; set; }<br/>    }<br/>}<br/></pre>
<p>It may seem a little bit redundant, defining a request class for a single field. Despite that, we should consider that the HTTP requests received by our service may vary over time. Therefore, this approach guarantees us being able to evolve our requests without adding tons of parameters to the methods of the service class. On top of that, representing our incoming requests as classes provides an easy way to version the different request types evolving over time.</p>
<p class="mce-root">Let's continue by also defining the response classes used by our service classes. Also, in the case of the response classes, it is essential to understand that this approach guarantees us a way to avoid exposing all the fields to the client of our web service. As a first step, we need to define a new <kbd>Responses</kbd> folder in the <kbd>Catalog.Domain</kbd> project, and create the following classes:</p>
<pre><strong>// /Responses/Item/PriceResponse.cs</strong><br/>namespace Catalog.Domain.Responses<br/>{<br/>    public class PriceResponse<br/>    {<br/>        public decimal Amount { get; set; }<br/>        public string Currency { get; set; }<br/>    }<br/>}<br/><br/><strong>// /Response/Item/ArtistResponse.cs</strong><br/>using System;<br/><br/>namespace Catalog.Domain.Responses<br/>{<br/>    public class ArtistResponse<br/>    {<br/>        public Guid ArtistId { get; set; }<br/>        public string ArtistName { get; set; }<br/>    }<br/>}<br/><br/><strong>// /Response/Item/GenreResponse.cs</strong><br/>using System;<br/><br/>namespace Catalog.Domain.Responses<br/>{<br/>    public class GenreResponse<br/>    {<br/>        public Guid GenreId { get; set; }<br/>        public string GenreDescription { get; set; }<br/>    }<br/>}<br/></pre>
<p>For brevity, I've defined the implementation of the <kbd>PriceResponse</kbd>, <kbd>GenreResponse</kbd>, and <kbd>ArtistResponse</kbd> classes in a unique snippet of code. Those classes define the field used by the same entity classes we use on the database side. On top of that, we will also define an <kbd>ItemReposonse</kbd> class, which represents the response of our service:</p>
<pre>using System;<br/><br/>namespace Catalog.Domain.Responses<br/>{<br/>    public class ItemResponse<br/>    {<br/>        public Guid Id { get; set; }<br/>        public string Name { get; set; }<br/>        public string Description { get; set; }<br/>        public string LabelName { get; set; }<br/>        public PriceResponse Price { get; set; }<br/>        public string PictureUri { get; set; }<br/>        public DateTimeOffset ReleaseDate { get; set; }<br/>        public string Format { get; set; }<br/>        public int AvailableStock { get; set; }<br/>        public Guid GenreId { get; set; }<br/>        public GenreResponse Genre { get; set; }<br/>        public Guid ArtistId { get; set; }<br/>        public ArtistResponse Artist { get; set; }<br/>    }<br/>}</pre>
<p>The <kbd>ItemResponse</kbd> class refers to the other response classes in order to avoid a mismatch between the response data contained in the related entities. Furthermore, the <kbd>IItemRepository</kbd> implementation will load all the data of the related entities using the <kbd>Include</kbd> extension method we looked at in the previous chapter, and, as we will see later, the data will be mapped into the response types.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The service class interface</h1>
                
            
            
                
<p>Since we have defined all the requests and response types needed by our service, we are now able to proceed by defining the <kbd>IItemService</kbd> interface and its implementation. As a first step, we can create a new <kbd>Services</kbd> folder in the <kbd>Catalog.Domain</kbd> project and proceed by defining the following <kbd>IItemService</kbd> interface:</p>
<pre>using System.Collections.Generic;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Requests.Item;<br/>using Catalog.Domain.Responses;<br/><br/>namespace Catalog.Domain.Services<br/>{<br/>    public interface IItemService<br/>    {<br/>        Task&lt;IEnumerable&lt;ItemResponse&gt;&gt; GetItemsAsync();<br/>        Task&lt;ItemResponse&gt; GetItemAsync(GetItemRequest request);<br/>        Task&lt;ItemResponse&gt; AddItemAsync(AddItemRequest request);<br/>        Task&lt;ItemResponse&gt; EditItemAsync(EditItemRequest request);<br/>        Task&lt;ItemResponse&gt; DeleteItemAsync(DeleteItemRequest request);<br/>    }<br/>}</pre>
<p>The preceding definition exposes the methods needed by our application. First of all, we should notice that all the functions return a <kbd>Task&lt;T&gt;</kbd> generic type. We can also see that all the methods end with the <kbd>Async</kbd> prefix, which suggests that the implementation will be asynchronous. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the mapping layer</h1>
                
            
            
                
<p>This subsection and the following one describe the implementation of two mapping approaches we can use in our application: the <em>manual approach</em> and the <em>reflection approach</em>.</p>
<p>The <em>manual approach</em> involves the definition and implementation of our own mapper classes:</p>
<pre>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Requests.Item;<br/>using Catalog.Domain.Responses;<br/><br/>namespace Catalog.Domain.Mappers<br/>{<br/>    public interface IItemMapper<br/>    {<br/>        Item Map(AddItemRequest request);<br/>        Item Map(EditItemRequest request);<br/>        ItemResponse Map(Item item);<br/>    }<br/>}</pre>
<p>The preceding code defines an <kbd>IItemMapper</kbd> interface, which provides two methods to map <kbd>AddItemRequest</kbd> and <kbd>EditItemRequest</kbd> in the <kbd>Item</kbd> type.  In addition, it also defines the mapping method signature to convert an <kbd>Item</kbd> type into an <kbd>ItemResponse</kbd> instance. This strategy can be implemented with the following <kbd>ItemMapper</kbd> class:</p>
<pre>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Requests.Item;<br/><br/>namespace Catalog.Domain.Mappers<br/>{<br/>    public class ItemMapper : IItemMapper<br/>    {<br/>        public Item Map(AddItemRequest request)<br/>        {<br/>            if (request == null) return null;<br/><br/>            var item = new Item<br/>            {<br/>                Name = request.Name,<br/>                Description = request.Description,<br/>                LabelName = request.LabelName,<br/>                PictureUri = request.PictureUri,<br/>                ReleaseDate = request.ReleaseDate,<br/>                Format = request.Format,<br/>                AvailableStock = request.AvailableStock,<br/>                GenreId = request.GenreId,<br/>                ArtistId = request.ArtistId,<br/>            };<br/><br/>            if (request.Price != null)<br/>            {<br/>                item.Price = new Price { Currency = request.Price.Currency, <br/>                 Amount = request.Price.Amount };<br/>            }<br/><br/>            return item;<br/>        }<br/><br/>        public Item Map(EditItemRequest request)<br/>        {<br/>            if (request == null) return null;<br/><br/>            var item = new Item<br/>            {<br/>                Id = request.Id,<br/>                Name = request.Name,<br/>                ...<br/>                Format = request.Format,<br/>                AvailableStock = request.AvailableStock,<br/>                GenreId = request.GenreId,<br/>                ArtistId = request.ArtistId,<br/>            };<br/><br/>            if (request.Price != null)<br/>            {<br/>                item.Price = new Price { Currency = request.Price.Currency, <br/>                 Amount = request.Price.Amount };<br/>            }<br/><br/>            return item;<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p>Please notice that, for brevity, I've omitted all the fields of the entity defined in the mapping, you can find the full mapper class file in the following repository  <a href="https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3/tree/master/Chapter09/Catalog">https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3/tree/master/Chapter09/Catalog</a>. Both the <kbd>IItemMapper</kbd> interface and the <kbd>ItemMapper</kbd> class are located in a <kbd>Mappers</kbd> folder in the <kbd>Catalog.Domain</kbd> project. The <kbd>ItemMapper</kbd> implementation requires a bit of overhead in terms of development, but it performs exactly what you need without any runtime costs, such as reflection. On top of that, the logic is encapsulated in separate classes. The same approach can be applied to the <kbd>ItemResponse</kbd> mapping – in this case, we will also need to create some isolated mappers for the <kbd>Artist</kbd> and the <kbd>Genre</kbd> entities:</p>
<pre>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Responses;<br/><br/>namespace Catalog.Domain.Mappers<br/>{<br/>    public interface IArtistMapper<br/>    {<br/>        ArtistResponse Map(Artist artist);<br/>    }<br/><br/>    public class ArtistMapper : IArtistMapper<br/>    {<br/>       <strong> public ArtistResponse Map(Artist artist)</strong><br/><strong>        {<br/>           if (artist == null) return null;<br/><br/></strong><strong>           return new ArtistResponse<br/>            {</strong><br/><strong>                ArtistId = artist.ArtistId,</strong><br/><strong>                ArtistName = artist.ArtistName<br/>            };</strong><br/><strong>        }</strong><br/>    }<br/>}</pre>
<p>For brevity reasons, I've included the interface and the concrete implementation in a unique snippet of code. <kbd>IArtistMapper</kbd> exposes a method called <kbd>Map</kbd>, which initializes a new <kbd>ArtistResponse</kbd> given an <kbd>Artist</kbd> entity class. This approach will be the same for the <kbd>Genre</kbd> entity:</p>
<pre>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Responses;<br/><br/>namespace Catalog.Domain.Mappers<br/>{<br/>    public interface IGenreMapper<br/>    {<br/>        GenreResponse Map(Genre genre);<br/>    }<br/>    <br/>    public class GenreMapper : IGenreMapper<br/>    {<br/>       <strong> public GenreResponse Map(Genre genre)</strong><br/><strong>        {<br/>           if (genre == null) return null;<br/><br/></strong><strong>           return new GenreResponse<br/>            {</strong><br/><strong>                GenreId = genre.GenreId,</strong><br/><strong>                GenreDescription = genre.GenreDescription<br/>            };</strong><br/><strong>        }</strong><br/>    }<br/>}</pre>
<p>Also, in this case, we define <kbd>Genre</kbd> as <kbd>GenreResponse</kbd> mapping. Both these mapping classes can be used independently or referred by other mappers. Once we have implemented the <kbd>Artist</kbd> and <kbd>Genre</kbd> mapping logic, we can refer them into <kbd>IItemMapper</kbd> in order to define the implementation of the <kbd>ItemReponse Map(Item item)</kbd> mapping method:</p>
<pre>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Responses;<br/><br/>namespace Catalog.Domain.Mappers<br/>{<br/>    public class ItemMapper : IItemMapper<br/>    {<br/>       <strong> private readonly IArtistMapper _artistMapper;</strong><br/><strong>        private readonly IGenreMapper _genreMapper;<br/></strong><br/>        public ItemMapper(<strong>IArtistMapper artistMapper, IGenreMapper <br/>            genreMapper</strong>)<br/>        {<br/>            <strong>_artistMapper = artistMapper;</strong><br/><strong>            _genreMapper = genreMapper;</strong><br/>        }<br/>        <br/>        ...<br/><br/>      <strong> </strong><strong>public ItemResponse Map(Item item)</strong><br/><strong>        {</strong><br/>            if (request == null) return null;<br/>            var response = new ItemResponse<br/>            {<br/>                Id = request.Id,<br/>                Name = request.Name,<br/>                ...<br/>                GenreId = request.GenreId,<br/>                Genre = _genreMapper.Map(request.Genre),<br/>                ArtistId = request.ArtistId,<br/>                Artist = _artistMapper.Map(request.Artist),<br/>            };<br/><br/>            if (request.Price != null)<br/>            {<br/>                response.Price = new PriceResponse { Currency = <br/>                 request.Price.Currency, Amount = request.Price.Amount };<br/>            }<br/><br/>            return response;<br/>        }<br/>   }<br/>}</pre>
<p class="mce-root">We have changed the <kbd>ItemMapper</kbd> implementation class and we have combined the dependencies with the <kbd>IArtistMapper</kbd> and <kbd>IGenreMapper</kbd> interfaces. Furthermore, we can use the <kbd>Map</kbd> method we've just defined to create <kbd>ItemResponse</kbd> instances based on the <kbd>Item</kbd> entities. You may have noticed that I haven't implemented the mapping class for <kbd>PriceResponse</kbd>. This is because an entity such as <kbd>Price</kbd> is unlikely to change. Another crucial part to notice is that we are missing the initialization of the dependency injection between the mapper interfaces and their implementation; this part will be covered later in this chapter.</p>
<p> </p>
<p>Finally, I want to specify that this is not the only way to implement the mapping layer in our application. In fact, there are also other patterns, for example, using extension methods. Let's take as an example, <kbd>Artist</kbd> to <kbd>ArtistResponse</kbd> mapping:</p>
<pre>public static class MappingExtensions<br/>{<br/>    public static ArtistResponse MapToResponse(this Artist artist)<br/>    {<br/>        return new ArtistResponse<br/>        {<br/>            ArtistId = artist.ArtistId,<br/>            ArtistName = artist.ArtistName<br/>        };<br/>    }<br/>}<br/></pre>
<p class="mce-root"/>
<p>The preceding code defines a new <kbd>MappingExtensions</kbd> static class, which can be used as a container for all the extension methods we need for the mapping logic. Furthermore, it is possible to define a <kbd>MapToResponse</kbd> extension method that can be applied to the <kbd>Artist</kbd> entity in the following way:</p>
<pre>ArtistResponse artistResponse = artistEntity.MapToResponse();</pre>
<p>The extension methods approach can be applied to all the entities of the domain model. Although it seems a lot more immediate, it doesn't highlight the dependency between the services classes and the mapping logic. Therefore, I prefer implementing mapping through the use of separate classes because it provides a better way to understand the dependency flow of the application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mapping logic using Automapper</h1>
                
            
            
                
<p>An alternative way is to implement the mapping using the <kbd>Automapper</kbd> NuGet package. As mentioned in <a href="deede298-fc20-4523-afa6-02ed2c0592fd.xhtml"/><a href="deede298-fc20-4523-afa6-02ed2c0592fd.xhtml" target="_blank">Chapter 5</a>, <em>Web Service Stack in ASP.NET Core</em>, this approach uses the reflection system provided by .NET in order to match and to map the fields of our classes. It is possible to add the <kbd>Automapper</kbd> package to the <kbd>Catalog.Domain</kbd> project using the following CLI instruction:</p>
<pre><strong>dotnet add package Automapper</strong></pre>
<p>Automapper uses a profile-based structure in order to define the mapping behaviors of our classes. Let's proceed by defining a new <kbd>CatalogProfile</kbd> class in the <kbd>Mappers</kbd> folder:</p>
<pre>using AutoMapper;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Requests.Item;<br/>using Catalog.Domain.Responses.Item;<br/><br/>namespace Catalog.Domain.Mapper<br/>{<br/>    public class CatalogProfile : Profile<br/>    {<br/>        public CatalogProfile()<br/>        {<br/>            CreateMap&lt;ItemResponse, Item&gt;().ReverseMap();<br/>            CreateMap&lt;GenreResponse, Genre&gt;().ReverseMap();<br/>            CreateMap&lt;ArtistResponse, Artist&gt;().ReverseMap();<br/>            CreateMap&lt;Price, PriceResponse&gt;().ReverseMap();<br/>            CreateMap&lt;AddItemRequest, Item&gt;().ReverseMap();<br/>            CreateMap&lt;EditItemRequest, Item&gt;().ReverseMap();<br/>        }<br/>    }<br/>}</pre>
<p>The preceding profile will be used by the dependency injection engine to define the lists of mapping behaviors. The <kbd>CreateMap</kbd> method provided by the <kbd>Profile</kbd> base class matches two generic types: <kbd>TSource</kbd> and <kbd>TDestination</kbd>. It will be possible to also perform the reverse process by chaining the <kbd>ReverseMap()</kbd> extension method. This can be applied for every request and response type we define in the application. In order to use the mapping logic in our methods, it is necessary to inject the <kbd>IMapper</kbd> type into the target class and execute the <kbd>Map</kbd> method in the following way:</p>
<pre>_mapper.Map&lt;ItemResponse&gt;(new Item());</pre>
<p>It is important to notice that the <kbd>Map</kbd> method will throw a runtime exception in the following cases:</p>
<ul>
<li>The type of the source and the destination of the mapping don't correspond</li>
<li>The corresponding source and destination mapping is not explicitly defined in a profile</li>
<li>There are some unmapped members in the entities (this prevents accidental <kbd>null</kbd> fields in the destination of the mapping)</li>
</ul>
<p>Finally, Automapper also requires initialization using the dependency injection of .NET Core. We will see how to add <kbd>Automapper</kbd> in the DI engine later in this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The service class implementation</h1>
                
            
            
                
<p>Once the mapper layer is completed, we can proceed by implementing the service layer. Let's start by defining the <kbd>ItemService.cs</kbd> file in the <kbd>Services</kbd> folder of the <kbd>Catalog.Domain</kbd> project. The following code describes the implementation of the constructor method and the reading operations:</p>
<pre>using System;<br/>using System.Collections.Generic;<br/>using System.Linq;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Mappers;<br/>using Catalog.Domain.Repositories;<br/>using Catalog.Domain.Requests.Item;<br/>using Catalog.Domain.Responses;<br/><br/>namespace Catalog.Domain.Services<br/>{<br/>    public class ItemService : IItemService<br/>    {<br/>       <strong> private readonly IItemRepository _itemRepository;</strong><br/>        <strong>private readonly IItemMapper _itemMapper;</strong><br/><br/>        public ItemService(<strong>IItemRepository itemRepository,</strong> <br/><strong>         IItemMapper itemMapper</strong>)<br/>        {<br/><strong>            _itemRepository = itemRepository;</strong><br/><strong>            _itemMapper = itemMapper;</strong><br/>        }<br/><br/>        public async Task&lt;IEnumerable&lt;ItemResponse&gt;&gt; GetItemsAsync()<br/>        {<br/>            var result = await _itemRepository.GetAsync();<br/><br/>            return result.Select(x =&gt; _itemMapper.Map(x));<br/>        }<br/><br/>        public async Task&lt;ItemResponse&gt; GetItemAsync(GetItemRequest <br/>         request)<br/>        {<br/>            if (request?.Id == null) throw new ArgumentNullException();<br/><br/>            var entity = await _itemRepository.GetAsync(request.Id);<br/><br/>            return _itemMapper.Map(entity);<br/>        }<br/>    }<br/>}</pre>
<p>First of all, we can see that the class refers to both the <kbd>IItemRepository</kbd> and the <kbd>IItemMapper</kbd> interfaces, which are injected using the constructor injection technique. The snippet also describes the implementation of the <kbd>GetItemsAsync</kbd> and <kbd>GetItemAsync</kbd> functions. Both methods use the <kbd>IItemRepository</kbd> interface to retrieve data from the data source, and the <kbd>IItemMapper</kbd> interface to perform the mapping between the <kbd>Item</kbd> entity and <kbd>ItemResponse</kbd>. The same approach can be taken by the writing operations, which are implemented with the following:</p>
<pre><br/>namespace Catalog.Domain.Services<br/>{<br/>    public class ItemService : IItemService<br/>    {<br/>        ...<br/><br/>       <strong> public async Task&lt;ItemResponse&gt; AddItemAsync(AddItemRequest <br/></strong><strong>         request)</strong><br/>        {<br/>            var item = _itemMapper.Map(request);<br/>            var result = _itemRepository.Add(item);<br/><br/>            await _itemRepository.UnitOfWork.SaveChangesAsync();<br/><br/>            return _itemMapper.Map(result);<br/>        }<br/><br/>       <strong> public async Task&lt;ItemResponse&gt; EditItemAsync(EditItemRequest <br/></strong><strong>         request)</strong><br/>        {<br/>            var existingRecord = await <br/>             _itemRepository.GetAsync(request.Id);<br/><br/>            if (existingRecord == null)<br/>            {<br/>                throw new ArgumentException($"Entity with {request.Id} <br/>                 is not present");<br/>            }<br/><br/>            var entity = _itemMapper.Map(request);<br/>            var result = _itemRepository.Update(entity);<br/><br/>            await _itemRepository.UnitOfWork.SaveChangesAsync();<br/><br/>            return _itemMapper.Map(result);<br/>        }<br/>    }<br/>}</pre>
<p>Also, in the case of the writing operations, they use the <kbd>IItemMapper</kbd> instance to map the request's type with the <kbd>Item</kbd> entity type and to retrieve the <kbd>ItemResponse</kbd> type. In addition, they perform the operations by calling the <kbd>IItemRepository</kbd> instance, and subsequently, they call the <kbd>SaveChangesAsync</kbd> method to apply those changes to the database. Once we have implemented the service layer, we can proceed by testing the class and verifying the implementation. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing the service layer</h1>
                
            
            
                
<p>This section covers the testing of the service layer part implemented previously. As we did in <a href="84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml">Chapter 8</a>, <em>Building the Data Access Layer</em>, we need to set up a mock catalog context that provides the data necessary for testing the service classes. The <kbd>Catalog.Infrastructure</kbd> project already has its own implementation of the <kbd>TestCatalogContext</kbd> class and the <kbd>ModelBuilderExtensions</kbd> class. Furthermore, we can use the same two classes to implement the tests for the service layer. What we need is just a bit of refactoring and optimization on the <kbd>Catalog.Infrastructure</kbd> project.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Refactoring testing classes</h1>
                
            
            
                
<p>After implementing the <kbd>ItemsRepositoryTests</kbd> type, in <a href="84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml">Chapter 8</a>, <em>Building the Data Access Layer</em>, you might notice that we are using a recurring pattern in the <kbd>ItemRepositoryTests</kbd> class:</p>
<pre>... <br/>  var options = new DbContextOptionsBuilder&lt;CatalogContext&gt;()<br/>                .UseInMemoryDatabase(databaseName: "should_get_data")<br/>                .Options;<br/><br/>            await using var context = new TestCatalogContext(options);<br/>            context.Database.EnsureCreated();<br/><br/>            var sut = new ItemRepository(context);<br/><br/>...</pre>
<p>The preceding snippet has been replicated in every test method written up to now. It is possible to improve our test code by extracting the implementation in a different type. The <kbd>xunit</kbd> framework provides a way to share test contexts between test methods of the same test class by providing an interface called <kbd>IClassFixture</kbd>.</p>
<p><kbd>IClassFixture</kbd> is a generic type that constitutes a single test context and shares it among all the test methods in the class. Hence, the <kbd>xunit</kbd> framework cleans up the fixture after all the tests in the class have completed. The <kbd>IClassFixture</kbd> interface we are going to implement will be used by both the <kbd>Catalog.Infrastructure.Tests</kbd> project and the <kbd>Catalog.Domain.Tests</kbd> project. Therefore, we can commonize the implementation in a unique <kbd>Catalog.Fixtures</kbd> project.</p>
<p>Let's proceed by creating the new project in the <kbd>tests</kbd> folder:</p>
<pre><strong>dotnet new xunit -n Catalog.Fixtures -f netcoreapp3.1</strong><br/><br/><strong>dotnet sln ../Catalog.API.sln add  ./Catalog.Fixtures/Catalog.Fixtures.csproj</strong></pre>
<p>The preceding instructions create a new <kbd>Catalog.Fixtures</kbd> project and add it to the solution. After that, we can proceed by adding the dependencies:</p>
<pre><strong>dotnet add ./Catalog.Fixtures reference ../src/Catalog.Domain/ <br/><br/></strong><strong>dotnet add ./Catalog.Fixtures reference ../src/Catalog.Infrastructure/</strong><br/></pre>
<p>Finally, we can move all the classes previously implemented in the <kbd>Catalog.Infrastructure.Tests</kbd> project into the new <kbd>Catalog.Fixtures</kbd> project just created: <kbd>TestCatalogContext.cs</kbd>, <kbd>Extensions/ModelBuilderExtensions.cs</kbd>, and all <kbd>.json</kbd> files.</p>
<p>Let's continue by creating a new <kbd>CatalogContextFactory</kbd> class, which will be referred by the <kbd>IClassFixture</kbd> interface:</p>
<pre>using System;<br/>using Catalog.Domain.Mappers;<br/>using Catalog.Infrastructure;<br/>using Microsoft.EntityFrameworkCore;<br/><br/>namespace Catalog.Fixtures<br/>{<br/>    public class CatalogContextFactory<br/>    {<br/>        public readonly TestCatalogContext ContextInstance;<br/>        public readonly IGenreMapper GenreMapper;<br/>        public readonly IArtistMapper ArtistMapper;<br/>        public readonly IItemMapper ItemMapper;<br/><br/>        public CatalogContextFactory()<br/>        {<br/>            var contextOptions = new <br/>                DbContextOptionsBuilder&lt;CatalogContext&gt;()<br/>                .UseInMemoryDatabase(Guid.NewGuid().ToString())<br/>                .EnableSensitiveDataLogging()<br/>                .Options;<br/><br/>            EnsureCreation(contextOptions);<br/>            ContextInstance = new TestCatalogContext(contextOptions);<br/>            <br/>            GenreMapper = new GenreMapper();<br/>            ArtistMapper = new ArtistMapper();<br/>            ItemMapper = new ItemMapper(ArtistMapper, GenreMapper);<br/>        }<br/><br/>        private void EnsureCreation(DbContextOptions&lt;CatalogContext&gt; <br/>         contextOptions)<br/>        {<br/>            using var context = new TestCatalogContext(contextOptions);<br/>            context.Database.EnsureCreated();<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>CatalogContextFactory</kbd> class defines a new instance of <kbd>TestCatalogContext</kbd> using the previously assigned <kbd>contextOptions</kbd> object. It is necessary to notice that we are building <kbd>ContextOptions</kbd> using <kbd>Guid.NewGuid().ToString()</kbd> property as a database name in order to provide a new, clean in-memory instance for each test class. In addition, the class also initializes the three attributes of type <kbd>IGenreMapper</kbd>, <kbd>IArtistMapper</kbd>, and <kbd>IItemMapper</kbd> which will be used by the service layer tests in order to perform the mapping of the fields.</p>
<p class="mce-root">It is, therefore, possible to access the instance of the factory class in our tests by using the following constructor injection approach:</p>
<pre>using System;<br/>using System.Linq;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Fixtures;<br/>using Catalog.Infrastructure.Repositories;<br/>using Newtonsoft.Json;<br/>using Shouldly;<br/>using Xunit;<br/><br/>namespace Catalog.Infrastructure.Tests<br/>{<br/>    public class ItemRepositoryTests :<br/>        IClassFixture&lt;CatalogContextFactory&gt;<br/>    {<br/>        <strong>private readonly ItemRepository _sut;</strong><br/><strong>        private readonly TestCatalogContext _context;</strong><br/><br/>        public ItemRepositoryTests(CatalogContextFactory catalogContextFactory)<br/>        {<br/>           <strong> _context = catalogContextFactory.ContextInstance;</strong><br/><strong>            _sut = new ItemRepository(_context);</strong><br/>        }<br/>...</pre>
<p>The <kbd>IClassFixture</kbd> interface contains the reference to the factory class just created. The dependency will be resolved at runtime through the constructor of the test class. Note that the entire instance is shared between each unique test class. Therefore, each test method in the test class will share the same database snapshot with the other method.</p>
<p>Finally, we can refactor the <kbd>ItemRepositoryTests</kbd> class in order to use the new <kbd>CatalogContextFactory</kbd> implementation. For example, if we take as reference the <kbd>should_add_new_item</kbd> test method,  we can proceed in the following way:</p>
<pre><br/>    public class ItemRepositoryTests : <strong>IClassFixture&lt;CatalogContextFactory&gt;</strong><br/>    {<br/>       <strong> private readonly ItemRepository _sut;</strong><br/><strong>        private readonly TestCatalogContext _context;</strong><br/><br/><strong>        public ItemRepositoryTests(CatalogContextFactory <br/>            catalogContextFactory)</strong><br/><strong>        {</strong><br/><strong>            _context = catalogContextFactory.ContextInstance;</strong><br/><strong>            _sut = new ItemRepository(_context);</strong><br/><strong>        }</strong><br/><br/>        [Fact]<br/>        public async Task <strong>should_add_new_item</strong>()<br/>        {<br/>            var testItem = new Item<br/>            {<br/>                Name = "Test album",<br/>                Price = new Price { Amount = 13, Currency = "EUR" },<br/>                GenreId = new Guid("c04f05c0-f6ad-44d1-a400-<br/>                    3375bfb5dfd6"),<br/>                ArtistId = new Guid("f08a333d-30db-4dd1-b8ba-<br/>                    3b0473c7cdab"),<br/>                ...<br/>            };<br/><br/>           <strong> _sut.Add(testItem);</strong><br/>            await _sut.UnitOfWork.SaveEntitiesAsync();<br/><br/>            <strong>_context</strong>.Items<br/>                .FirstOrDefault(item =&gt; item.Id == testItem.Id)<br/>                .ShouldNotBeNull();<br/>        }<br/>    }</pre>
<p>The <kbd>_sut</kbd> class attribute is used to perform the actual operation we want to test. For example, in the test case above, we are verifying the <kbd>Add</kbd> method exposed by the <kbd>ItemRepository</kbd> class. The <kbd>_context</kbd> attribute is used to verify the result. This approach guarantees the reusability of our test code between the different test classes by providing the tests with better maintainability. All the data is provided by the <kbd>CatalogContextFactory</kbd> type, which uses the in-memory database technique provided by ASP.NET Core to store data in memory and simulates the data operation on a real database.</p>
<p>As we did for the <kbd>ItemRepositoryTests</kbd> class, we will also see how to use the <kbd>CatalogContextFactory</kbd> class in the service layer tests.</p>
<p>The code in this section is available in the following GitHub repository: <a href="https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3">https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing the ItemService tests</h1>
                
            
            
                
<p class="mce-root">Let's continue by implementing the <kbd>ItemService</kbd> test part. As a first step, we should proceed by creating a new <kbd>Catalog.Domain.Tests</kbd> project in the <kbd>tests</kbd> folder using the following CLI instruction:</p>
<div><div><div><pre><strong>dotnet new xunit -n Catalog.Domain.Tests </strong><strong>-f netcoreapp3.1</strong></pre>
<p>The preceding command creates a new <kbd>Catalog.Domain.Tests</kbd> project in the <kbd>tests</kbd> folder. Therefore, we can proceed by adding the new project to the solution using the following instruction:</p>
<pre><strong>dotnet sln ../Catalog.API.sln add Catalog.Domain.Tests
</strong></pre></div>
</div>
</div>
<p>Additionally, the test project has some dependencies. Furthermore, we can proceed by adding the reference using the following command to the <kbd>Catalog.Domain.Tests</kbd> folder:</p>
<div><div><div><pre><strong>dotnet add reference ../Catalog.Fixtures</strong><br/><strong>dotnet add reference ../../src/Catalog.Domain<br/>dotnet add package Shouldly</strong></pre></div>
</div>
</div>
<p>After that, we create a new <kbd>ItemServiceTests.cs</kbd> file with the following implementation:</p>
<pre>using System;<br/>using System.Threading;<br/>using System.Threading.Tasks;<br/>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Mappers;<br/>using Catalog.Domain.Requests.Item;<br/>using Catalog.Domain.Services;<br/>using Catalog.Fixtures;<br/>using Catalog.Infrastructure.Repositories;<br/>using Shouldly;<br/>using Xunit;<br/><br/>namespace Catalog.Domain.Tests.Services<br/>{<br/>    public class ItemServiceTests : <br/>        <strong>IClassFixture&lt;CatalogContextFactory&gt;</strong><br/>    {<br/><strong>        private readonly ItemRepository _itemRepository;</strong><br/><strong>        private readonly IItemMapper _mapper;</strong><br/><br/><strong>        public ItemServiceTests(CatalogContextFactory catalogContextFactory)</strong><br/><strong>        {</strong><br/><strong>            _itemRepository = new ItemRepository(catalogContextFactory.ContextInstance);</strong><br/><strong>            _mapper = catalogContextFactory.ItemMapper;</strong><br/><strong>        }</strong><br/><br/>        [Fact]<br/>        public async Task getitems_should_return_right_data()<br/>        {<br/>            ItemService sut = new ItemService(_itemRepository, _mapper);<br/><br/>            var result = await sut.GetItemsAsync();<br/>            result.ShouldNotBeNull();<br/>        }<br/><br/>        [Theory]<br/>        [InlineData("b5b05534-9263-448c-a69e-0bbd8b3eb90e")]<br/>        public async Task getitem_should_return_right_data(string guid)<br/>        {<br/>            ItemService sut = new ItemService(_itemRepository, _mapper);<br/><br/>            var result = await sut.GetItemAsync(new GetItemRequest { Id = new Guid(guid) });<br/><br/>            result.Id.ShouldBe(new Guid(guid));<br/>        }<br/><br/>        [Fact]<br/>        public void getitem_should_thrown_exception_with_null_id()<br/>        {<br/>            ItemService sut = new ItemService(_itemRepository, _mapper);<br/><br/>            sut.GetItemAsync(null).ShouldThrow&lt;ArgumentNullException&gt;();<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code tests the implementation of the reading operations of the <kbd>ItemService</kbd> class. The <kbd>ItemServiceTests</kbd> class uses the <kbd>CatalogContextFactory</kbd> type to initialize and get the base data used by the service. Each test method uses the <kbd>_itemRepository</kbd> class property and the <kbd>_mapper</kbd> instance to initialize a new <kbd>ItemService</kbd> and verify the <kbd>GetItemAsync</kbd> and the <kbd>GetItemsAsync</kbd> methods provided by the service class.</p>
<p>In the same way, we can use the same technique to implement the writing operation tests:</p>
<pre><br/>    public class ItemServiceTests : <br/>        IClassFixture&lt;CatalogContextFactory&gt;<br/>    {<br/>        private readonly ItemRepository _itemRepository;<br/>        private readonly IItemMapper _mapper;<br/><br/>        public ItemServiceTests(CatalogContextFactory catalogContextFactory)<br/>        {<br/>            _itemRepository = new ItemRepository(catalogContextFactory.ContextInstance);<br/>            _mapper = catalogContextFactory.ItemMapper;<br/>        }<br/><br/>        ...<br/><br/>        <strong>[Fact]</strong><br/><strong>        public async Task additem_should_add_right_entity()</strong><br/>        {<br/>            var testItem = new AddItemRequest<br/>            {<br/>                Name = "Test album",<br/>                GenreId = new Guid("c04f05c0-f6ad-44d1-a400-3375bfb5dfd6"),<br/>                ArtistId = new Guid("f08a333d-30db-4dd1-b8ba-3b0473c7cdab"),<br/>                Price = new Price { Amount = 13, Currency = "EUR" }<br/>                ...<br/>            };<br/><br/>            IItemService sut = new ItemService(_itemRepository, _mapper);<br/><br/>            var result = await sut.AddItemAsync(testItem);<br/><br/>            result.Name.ShouldBe(testItem.Name);<br/>            result.Description.ShouldBe(testItem.Description);<br/>            result.GenreId.ShouldBe(testItem.GenreId);<br/>            result.ArtistId.ShouldBe(testItem.ArtistId);<br/>            result.Price.Amount.ShouldBe(testItem.Price.Amount);<br/>            result.Price.Currency.ShouldBe(testItem.Price.Currency);<br/>        }<br/><br/>       <strong> [Fact]</strong><br/><strong>        public async Task edititem_should_add_right_entity()</strong><br/>        {<br/>            var testItem = new EditItemRequest<br/>            {<br/>                Id = new Guid("b5b05534-9263-448c-a69e-0bbd8b3eb90e"),<br/>                Name = "Test album",<br/>                GenreId = new Guid("c04f05c0-f6ad-44d1-a400-3375bfb5dfd6"),<br/>                ArtistId = new Guid("f08a333d-30db-4dd1-b8ba-3b0473c7cdab"),<br/>                Price = new Price { Amount = 13, Currency = "EUR" }<br/>                ...<br/>            };<br/><br/>            ItemService sut = new ItemService(_itemRepository, _mapper);<br/><br/>            var result = await sut.EditItemAsync(testItem);<br/><br/>            result.Name.ShouldBe(testItem.Name);<br/>            result.Description.ShouldBe(testItem.Description);<br/>            result.GenreId.ShouldBe(testItem.GenreId);<br/>            result.ArtistId.ShouldBe(testItem.ArtistId);<br/>            result.Price.Amount.ShouldBe(testItem.Price.Amount);<br/>            result.Price.Currency.ShouldBe(testItem.Price.Currency);<br/>        }<br/>    }<br/>}</pre>
<p>The <kbd>additem_should_add_the_entity</kbd> and <kbd>edititem_should_edit_the_entity</kbd> methods are verifying both the <kbd>IItemMapper</kbd> logic implementation and also the <kbd>IItemService</kbd> implementation. This approach can be used to test the logic of the service classes layer. In this case, the mapping logic is not so complex. Besides, I suggest also implementing separate tests in the case of a more complex mapping logic. </p>
<p>Finally, we can run the test cases we've just implemented by executing the <kbd>dotnet test</kbd> CLI instruction in the solution folder, or by using our preferred IDE test runner. The CLI result should be similar to this: </p>
<div><img src="img/43a9d778-e29d-47e7-92c4-d90d8836bdde.png"/></div>
<p>The preceding report lists all the tests executed by the <kbd>dotnet test</kbd> command, and it provides an overview of the successful and failed tests. Furthermore, it is also possible to specify the verbosity of the test by appending the <kbd>-v</kbd> option next to the <kbd>dotnet test -v &lt;q[uiet], m[inimal], n[ormal], d[etailed], and diag[nostic]&gt;</kbd> command.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Implementing request model validation</h1>
                
            
            
                
<p>The <kbd>Catalog.Domain</kbd> project also owns the validation logic of our request models<em>.</em> In this section, we will see how to implement the request validation logic part, which will be also used by our controllers in order to validate the incoming data. Here, I usually rely on the <kbd>FluentValidation</kbd> package, which provides a really readable way to perform validation checks on every type of object and data structure.</p>
<p>In order to add the <kbd>FluentValidation</kbd> package to our <kbd>Catalog.Domain</kbd> project, we can execute the following commands in the project folder:</p>
<pre><strong>dotnet add package FluentValidation</strong><br/><strong>dotnet add package FluentValidation.AspNetCore</strong><br/></pre>
<p class="mce-root">The <kbd>FluentValidation</kbd> package exposes the  <kbd>AbstractValidation</kbd> class, which can be extended to implement our custom validation criteria for a request model class:</p>
<pre><strong>//Requests/Item/Validators/AddItemRequestValidator.cs<br/><br/></strong>using FluentValidation;<br/><br/>namespace Catalog.Domain.Requests.Item.Validators<br/>{<br/>    public class AddItemRequestValidator : AbstractValidator&lt;AddItemRequest&gt;<br/>    {<br/>        public AddItemRequestValidator()<br/>        {<br/>            RuleFor(x =&gt; x.GenreId).NotEmpty();<br/>            RuleFor(x =&gt; x.ArtistId).NotEmpty();<br/>            RuleFor(x =&gt; x.Price).NotEmpty();<br/>            RuleFor(x =&gt; x.ReleaseDate).NotEmpty();<br/>            RuleFor(x =&gt; x.Name).NotEmpty();<br/>            RuleFor(x =&gt; x.Price).Must(x =&gt; x?.Amount &gt; 0);<br/>            RuleFor(x =&gt; x.AvailableStock).Must(x =&gt; x &gt; 0);<br/>        }<br/>    }<br/>}<br/><strong>//Requests/Item/Validators/EditItemRequestValidator.cs</strong><br/><br/>using FluentValidation;<br/><br/>namespace Catalog.Domain.Requests.Item.Validators<br/>{<br/>    public class EditItemRequestValidator : AbstractValidator&lt;EditItemRequest&gt;<br/>    {<br/>        public EditItemRequestValidator()<br/>        {<br/>            RuleFor(x =&gt; x.Id).NotEmpty();<br/>            RuleFor(x =&gt; x.GenreId).NotEmpty();<br/>            RuleFor(x =&gt; x.ArtistId).NotEmpty();<br/>            RuleFor(x =&gt; x.Price).NotEmpty();<br/>            RuleFor(x =&gt; x.Price).Must(x =&gt; x?.Amount &gt; 0);<br/>            RuleFor(x =&gt; x.ReleaseDate).NotEmpty();<br/>            RuleFor(x =&gt; x.Name).NotEmpty();<br/>        }<br/>    }<br/>}</pre>
<p class="mce-root">These validator classes are located in the <kbd>Requests/Item/Validators</kbd> path. Let's proceed by analyzing some of the validation criteria implemented in the  <kbd>AddItemRequestValidator</kbd> class:</p>
<ul>
<li>The <kbd>GenreId</kbd> and <kbd>ArtistId</kbd> fields are required because a vinyl always has this kind of information.</li>
<li>The class uses the same <kbd>NotEmpty</kbd> method on the  <kbd>Name</kbd>, <kbd>ReleaseDate</kbd>, and <kbd>Price</kbd> fields.</li>
</ul>
<p class="mce-root"/>
<ul>
<li>The <kbd>Amount</kbd> field of the <kbd>Price</kbd> class should always be greater than 0. The validator class uses the <kbd>Must</kbd> method to apply this rule.</li>
</ul>
<p>The same approach is taken for the <kbd>EditItemRequestValidator</kbd> class, except for the <kbd>Id</kbd> field, which is defined as required for the updated process of an entity. The fluent way of working is really useful for different reasons: it is ready to read, easy to maintain, and really helpful when we want to test logic.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Testing request model validation</h1>
                
            
            
                
<p>As mentioned, the <kbd>FluentValidation</kbd> package provides an excellent way to test our validation criteria.</p>
<p>The <kbd>AddItemRequestValidator</kbd> and <kbd>EditItemRequestValidator</kbd> classes implement elementary checks. Furthermore, it may be useful to cover them with some tests to document the logic implemented in these classes. <kbd>FluentValidation</kbd> provides a <kbd>TestHelper</kbd> class that provides the assertion conditions necessary to verify the behavior of our validation logic.</p>
<p class="mce-root">Let's see how to do some unit tests for the <kbd>AddItemRequestValidator</kbd> class:</p>
<pre>using Catalog.Domain.Entities;<br/>using Catalog.Domain.Requests.Item;<br/>using Catalog.Domain.Requests.Item.Validators;<br/>using FluentValidation.TestHelper;<br/>using Xunit;<br/><br/>namespace Catalog.Domain.Tests.Requests.Item.Validators<br/>{<br/>    public class AddItemRequestValidatorTests<br/>    {<br/>        private readonly AddItemRequestValidator _validator;<br/><br/>        public AddItemRequestValidatorTests()<br/>        {<br/>            _validator = new AddItemRequestValidator();<br/>        }<br/><br/>        [Fact]<br/>        public void should_have_error_when_ArtistId_is_null()<br/>        {<br/>            var addItemRequest = new AddItemRequest { Price = new Price() };<br/>            _validator.ShouldHaveValidationErrorFor(x =&gt; x.ArtistId, addItemRequest);<br/>        }<br/><br/>        [Fact]<br/>        public void should_have_error_when_GenreId_is_null()<br/>        {<br/>            var addItemRequest = new AddItemRequest { Price = new Price() };<br/>            _validator.ShouldHaveValidationErrorFor(x =&gt; x.GenreId, addItemRequest);<br/>        }<br/>    }<br/>}</pre>
<p>The test class defined in the preceding code verifies that <kbd>AddItemRequestValidator</kbd> triggers a validation error if the <kbd>GenreId</kbd> or <kbd>ArtistId</kbd> fields are null. It uses the <kbd>ShouldHaveValidationErrorFor</kbd> extension method exposed by the <kbd>TestHelper</kbd> class to verify the behavior. The <kbd>ShouldHaveValidationErrorFor</kbd> method also exposes an <kbd>IEnumerable</kbd> of <kbd>ValidationError</kbd>, which can be used to check the details of each message of type <kbd>ValidationError</kbd>. </p>


            

            
        
    

        

                            
                    <h1 class="header-title">Dependencies registration</h1>
                
            
            
                
<p>In this chapter, we have seen how to implement mapper classes, validators, and service classes. All these types work together using the dependency injection of .NET Core. Dependency registration usually happens through the use of extension methods that group the registered classes by following some criteria. In this case, I will group the registered classes in the following way:</p>
<ul>
<li>Services refer to all the service interfaces and classes defined in the <kbd>Catalog.Domain</kbd> project</li>
<li>Mappers refer to all the mapper classes defined in the <kbd>Catalog.Domain</kbd> project</li>
<li>Validations refer to all the fluent validation requirements and dependencies used by the application</li>
</ul>
<p>Now that we have defined the logic behind the separation of dependency registration, we can proceed by defining a new <kbd>DependencyRegistration</kbd> static class in the <kbd>Extensions</kbd> folder in the <kbd>Catalog.Domain</kbd> project:</p>
<pre>using System.Reflection;<br/>using Catalog.Domain.Mappers;<br/>using Catalog.Domain.Services;<br/>using FluentValidation.AspNetCore;<br/>using Microsoft.Extensions.DependencyInjection;<br/><br/>namespace Catalog.Domain.Extensions<br/>{<br/>    public static class DependenciesRegistration<br/>    {<br/>        <strong>public static IServiceCollection AddMappers(this IServiceCollection services)</strong><br/>        {<br/>            services<br/>                .AddSingleton&lt;IArtistMapper, ArtistMapper&gt;()<br/>                .AddSingleton&lt;IGenreMapper, GenreMapper&gt;()<br/>                .AddSingleton&lt;IItemMapper, ItemMapper&gt;();<br/>            <br/>            return services;<br/>        }<br/><br/>      <strong>  public static IServiceCollection AddServices(this IServiceCollection services)</strong><br/>        {<br/>            services<br/>                .AddScoped&lt;IItemService, ItemService&gt;();<br/>            <br/>            return services;<br/>        }<br/><br/>        <strong>public static IMvcBuilder AddValidation(this IMvcBuilder builder)</strong><br/>        {<br/>            builder<br/>                .AddFluentValidation(configuration =&gt;<br/>                    configuration.RegisterValidatorsFromAssembly<br/>                        (Assembly.GetExecutingAssembly()));<br/>            <br/>            return builder;<br/>        }<br/>    }<br/>}</pre>
<p>The preceding code defines three extension methods, one for each group: <kbd>AddMappers</kbd>, <kbd>AddServices</kbd>, and <kbd>AddValidation</kbd>.</p>
<p>The <kbd>AddMappers</kbd> extension method registers the mapper instances using a <em>singleton</em> life cycle, therefore, the mappers do not have any kind of dependency and they don't perform any request-related operation. On the other side, the <kbd>AddServices</kbd> extension method uses a scoped life cycle because the service classes depend on the repositories that perform I/O operations on the database. Finally, the <kbd>AddValidation</kbd> extension method is chained with <kbd>IMvcBuilder</kbd> and is strictly dependent on the MVC stack.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Furthermore, it uses the <kbd>AddFluentValidation</kbd> method provided by the <kbd>FluentValidation</kbd> package in order to register all the validation classes.</p>
<p>In conclusion, we can register the dependencies of our application in the following way:</p>
<pre>using Catalog.API.Extensions;<br/>...<br/><br/>namespace Catalog.API<br/>{<br/>    public class Startup<br/>    {<br/>        ...<br/>        public void ConfigureServices(IServiceCollection services)<br/>        {<br/>            services<br/>                .AddCatalogContext(Configuration.GetSection("DataSource:ConnectionString").Value)<br/>                .AddScoped&lt;IItemRepository, ItemRepository&gt;()<br/>               <strong> .AddMappers()</strong><br/><strong>                .AddServices()</strong><br/><strong>                .AddControllers()</strong><br/><strong>                .AddValidation();</strong><br/>        }<br/>...</pre>
<p>Lastly, we can now verify the implementations written during this chapter by again running a <kbd>dotnet test</kbd> command in the solution folder, or by executing the test runner of our preferred IDE.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>The <kbd>Catalog.Domain</kbd> project now contains the core logic of the entire application. Although the logic implemented in the <kbd>Domain</kbd> project is still quite simple, later on in this book, it will become more complex.</p>
<p>The topics covered in this chapter included some of the concepts related to the domain logic implementation of a web service: how to implement the service and the mapping classes, how to implement the request validation process using a fluent approach, and finally, how to test our code using some unit testing techniques. </p>
<p>The next chapter will look into all the HTTP parts of the application. Furthermore, we will focus on the <kbd>Catalog.API</kbd> project, and how to put together the data access, the service, and the API layers.</p>


            

            
        
    </body></html>