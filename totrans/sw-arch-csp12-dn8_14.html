<html><head></head><body>
<div class="Basic-Text-Frame" id="_idContainer247">
<h1 class="chapterNumber"><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 class="chapterTitle" id="_idParaDest-285"><span class="koboSpan" id="kobo.2.1">Implementing Microservices with .NET</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.3.1">In </span><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 11</span></em><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.7.1">, you learned the theory and basic concepts of microservices. </span><span class="koboSpan" id="kobo.7.2">In this chapter, you will learn how to put into practice those general concepts and tools to implement microservices in .NET. </span><span class="koboSpan" id="kobo.7.3">This way, you will have a practical understanding of how high-level architectural decisions translate into concrete .NET code.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.8.1">The focus of this chapter is on worker microservices; that is, microservices that are not part of the public interface of your application. </span><span class="koboSpan" id="kobo.8.2">Other kinds of microservices will be focused on in other chapters. </span><span class="koboSpan" id="kobo.8.3">Worker microservices process jobs that are not connected to a specific user. </span><span class="koboSpan" id="kobo.8.4">They somehow prepare the data that will be used by frontend microservices to satisfy all user requests. </span><span class="koboSpan" id="kobo.8.5">They are the assembly line of each application, so their design priorities are efficiency in both communication and local processing, together with protocols that ensure data coherence and fault tolerance. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.9.1">You will learn how to implement a frontend service in </span><em class="italic"><span class="koboSpan" id="kobo.10.1">Chapter 18</span></em><span class="koboSpan" id="kobo.11.1">, </span><em class="italic"><span class="koboSpan" id="kobo.12.1">Implementing Frontend Microservices with ASP.NET Core</span></em><span class="koboSpan" id="kobo.13.1">, after having learned about techniques for implementing a presentation layer in </span><em class="italic"><span class="koboSpan" id="kobo.14.1">Chapter 17</span></em><span class="koboSpan" id="kobo.15.1">, </span><em class="italic"><span class="koboSpan" id="kobo.16.1">Presenting ASP.NET Core</span></em><span class="koboSpan" id="kobo.17.1">. </span><span class="koboSpan" id="kobo.17.2">Other techniques for implementing presentation layers are described in</span><em class="italic"><span class="koboSpan" id="kobo.18.1"> Chapter 19, Client Frameworks: Blazor</span></em><span class="koboSpan" id="kobo.19.1">, while techniques for implementing public APIs will be discussed in </span><em class="italic"><span class="koboSpan" id="kobo.20.1">Chapter 15</span></em><span class="koboSpan" id="kobo.21.1">, </span><em class="italic"><span class="koboSpan" id="kobo.22.1">Applying Service-Oriented Architectures with .NET</span></em><span class="koboSpan" id="kobo.23.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.24.1">This chapter explains the structure of a .NET microservice and discusses the options for exchanging messages and serializing .NET data structures. </span><span class="koboSpan" id="kobo.24.2">In particular, we will put into practice a lot of concepts analyzed in </span><em class="italic"><span class="koboSpan" id="kobo.25.1">Chapter 11</span></em><span class="koboSpan" id="kobo.26.1">, </span><em class="italic"><span class="koboSpan" id="kobo.27.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.28.1">, such as the concept of Generic Host, the techniques for ensuring reliable communication (exponential retry, etc.), forward communication, and idempotency of messages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.29.1">More specifically, in this chapter, you will learn about the following subjects:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.30.1">Communication and data serialization</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.31.1">Implementing worker microservices with ASP.NET Core</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.32.1">Implementing microservices with .NET worker services and message brokers</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.33.1">Each point will be discussed in depth, and the reader can find further practical details in the section </span><em class="italic"><span class="koboSpan" id="kobo.34.1">A worker microservice with ASP</span></em> <em class="italic"><span class="koboSpan" id="kobo.35.1">.NET core </span></em><span class="koboSpan" id="kobo.36.1">of </span><em class="italic"><span class="koboSpan" id="kobo.37.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.38.1">, which describes in detail three complete implementations of worker microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.39.1">The first section of the chapter discusses the main coordination and queuing problems that arise in microservices communication and how to solve them with either message brokers or custom permanent queues. </span><span class="koboSpan" id="kobo.39.2">These topics are fundamental in the design of efficient and fault-tolerant communication, which, in turn, are essential requirements for ensuring coherent behavior and low response times of the overall application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.40.1">The remaining sections include examples of how to implement the same microservice with two different techniques. </span><span class="koboSpan" id="kobo.40.2">The techniques in the second section are based on the ASP.NET Core implementation of gRPC and an SQL Server-based permanent queue. </span><span class="koboSpan" id="kobo.40.3">It is worth pointing out that this technique requires HTTP/2. </span><span class="koboSpan" id="kobo.40.4">The example in the third section shows how to use message brokers and two serialization techniques. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.41.1">Message brokers are fundamental for three main reasons: </span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.42.1">They take care of most of the communication overhead.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.43.1">They support the publisher/subscriber pattern, which promotes the independence of communicating microservices.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.44.1">All main cloud providers offer message broker services. </span><span class="koboSpan" id="kobo.44.2">The </span><a id="_idIndexMarker976"/><span class="koboSpan" id="kobo.45.1">example uses </span><strong class="keyWord"><span class="koboSpan" id="kobo.46.1">RabbitMQ</span></strong><span class="koboSpan" id="kobo.47.1">, but RabbitMQ can be </span><a id="_idIndexMarker977"/><span class="koboSpan" id="kobo.48.1">replaced by </span><strong class="keyWord"><span class="koboSpan" id="kobo.49.1">Azure Service Bus</span></strong><span class="koboSpan" id="kobo.50.1">,</span><strong class="keyWord"> </strong><span class="koboSpan" id="kobo.51.1">the message broker offered by Azure. </span><span class="koboSpan" id="kobo.51.2">The chapter also explains the pros and cons of different serialization techniques.</span></li>
</ul>
<h1 class="heading-1" id="_idParaDest-286"><span class="koboSpan" id="kobo.52.1">Technical requirements</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.53.1">This chapter requires the free Visual Studio 2022 Community edition or better with all database tools installed. </span><span class="koboSpan" id="kobo.53.2">The code for this chapter is available at </span><a href="https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E"><span class="url"><span class="koboSpan" id="kobo.54.1">https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E</span></span></a><span class="koboSpan" id="kobo.55.1">. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.56.1">Experimenting with message brokers also requires the installation of the RabbitMQ message broker (version 3.9 or higher), which in turn requires the previous installation of a 64-bit version of Erlang. </span><span class="koboSpan" id="kobo.56.2">An adequate Erlang version for RabbitMQ 3.9 can be downloaded from </span><a href="https://github.com/erlang/otp/releases/download/OTP-24.0.6/otp_win64_24.0.6.exe"><span class="url"><span class="koboSpan" id="kobo.57.1">https://github.com/erlang/otp/releases/download/OTP-24.0.6/otp_win64_24.0.6.exe</span></span></a><span class="koboSpan" id="kobo.58.1">. </span><span class="koboSpan" id="kobo.58.2">The RabbitMQ Windows installer can be downloaded from </span><a href="https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.5/rabbitmq-server-3.9.5.exe"><span class="url"><span class="koboSpan" id="kobo.59.1">https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.5/rabbitmq-server-3.9.5.exe</span></span></a><span class="koboSpan" id="kobo.60.1">. </span><span class="koboSpan" id="kobo.60.2">We recommend you launch both installations from an administrative account.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.61.1">Three complete examples of worker microservices are in the </span><em class="italic"><span class="koboSpan" id="kobo.62.1">A worker microservice with ASP.NET core</span></em><span class="koboSpan" id="kobo.63.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.64.1">A worker microservice based on RabbitMQ</span></em><span class="koboSpan" id="kobo.65.1"> sections of </span><em class="italic"><span class="koboSpan" id="kobo.66.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.67.1">. </span><span class="koboSpan" id="kobo.67.2">Each of them exemplifies a technique described in this chapter and shows an alternative way of collecting travel statistics in the case study application.</span></p>
<h1 class="heading-1" id="_idParaDest-287"><span class="koboSpan" id="kobo.68.1">Communication and data serialization</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.69.1">As explained in the </span><em class="italic"><span class="koboSpan" id="kobo.70.1">Microservice design principles</span></em><span class="koboSpan" id="kobo.71.1"> subsection of </span><em class="italic"><span class="koboSpan" id="kobo.72.1">Chapter 11</span></em><span class="koboSpan" id="kobo.73.1">, </span><em class="italic"><span class="koboSpan" id="kobo.74.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.75.1">, requests to a microservices-based application can’t cause long chains of recursive microservices calls. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.76.1">In fact, each call adds both a </span><a id="_idIndexMarker978"/><span class="koboSpan" id="kobo.77.1">wait time and a communication time to the actual processing time, thus leading to unacceptable levels of overall response time, as shown in the following figure.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.78.1"><img alt="Shape, circle  Description automatically generated" src="../Images/B19820_14_01.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.79.1">Figure 14.1: Tree of blocking RPC calls</span></p>
<p class="normal"><span class="koboSpan" id="kobo.80.1">Messages </span><strong class="keyWord"><span class="koboSpan" id="kobo.81.1">1-6</span></strong><span class="koboSpan" id="kobo.82.1"> are triggered by a request to the </span><strong class="keyWord"><span class="koboSpan" id="kobo.83.1">A</span></strong><span class="koboSpan" id="kobo.84.1"> microservice and are sent in sequence, so their processing times sum up to the response time. </span><span class="koboSpan" id="kobo.84.2">Moreover, once sent, message </span><strong class="keyWord"><span class="koboSpan" id="kobo.85.1">1</span></strong><span class="koboSpan" id="kobo.86.1"> from microservice </span><strong class="keyWord"><span class="koboSpan" id="kobo.87.1">A</span></strong><span class="koboSpan" id="kobo.88.1"> remains blocked until it receives the last message (</span><strong class="keyWord"><span class="koboSpan" id="kobo.89.1">6</span></strong><span class="koboSpan" id="kobo.90.1">); that is, it remains blocked for the whole lifetime of the overall recursive communication process.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.91.1">Microservice </span><strong class="keyWord"><span class="koboSpan" id="kobo.92.1">B</span></strong><span class="koboSpan" id="kobo.93.1"> remains</span><a id="_idIndexMarker979"/><span class="koboSpan" id="kobo.94.1"> blocked twice, waiting for an answer to a request it issued. </span><span class="koboSpan" id="kobo.94.2">The first time is during the </span><strong class="keyWord"><span class="koboSpan" id="kobo.95.1">2-3</span></strong><span class="koboSpan" id="kobo.96.1"> communication and then the second is during the </span><strong class="keyWord"><span class="koboSpan" id="kobo.97.1">4-5</span></strong><span class="koboSpan" id="kobo.98.1"> communication. </span><span class="koboSpan" id="kobo.98.2">To sum</span><a id="_idIndexMarker980"/><span class="koboSpan" id="kobo.99.1"> up, </span><strong class="keyWord"><span class="koboSpan" id="kobo.100.1">Remote Procedure Calls</span></strong><span class="koboSpan" id="kobo.101.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.102.1">RPCs</span></strong><span class="koboSpan" id="kobo.103.1">) involve high response times and a waste of microservices computation time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.104.1">That’s why microservices avoid blocking recursive RPCs and prefer a data-driven approach that starts from the leaves of the procedure calls tree. </span><span class="koboSpan" id="kobo.104.2">Put simply, tree nodes, instead of waiting for requests from their parent nodes, send pre-processed data to all their possible callers each time their private data changes, as shown in the following figure.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.105.1"><img alt="Diagram  Description automatically generated" src="../Images/B19820_14_02.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.106.1">Figure 14.2: Data-driven asynchronous communication</span></p>
<p class="normal"><span class="koboSpan" id="kobo.107.1">Both communications labeled </span><strong class="keyWord"><span class="koboSpan" id="kobo.108.1">1</span></strong><span class="koboSpan" id="kobo.109.1"> are triggered when the data of the </span><strong class="keyWord"><span class="koboSpan" id="kobo.110.1">C</span></strong><span class="koboSpan" id="kobo.111.1">/</span><strong class="keyWord"><span class="koboSpan" id="kobo.112.1">D</span></strong><span class="koboSpan" id="kobo.113.1"> microservices changes, and they may occur in parallel. </span><span class="koboSpan" id="kobo.113.2">Moreover, once a communication is sent, each microservice can return to its job without waiting for a response. </span><span class="koboSpan" id="kobo.113.3">Finally, when a request arrives at microservice </span><strong class="keyWord"><span class="koboSpan" id="kobo.114.1">A</span></strong><span class="koboSpan" id="kobo.115.1">, </span><strong class="keyWord"><span class="koboSpan" id="kobo.116.1">A</span></strong><span class="koboSpan" id="kobo.117.1"> already has all the data it needs to build the response with no need to interact with other microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.118.1">In general, microservices </span><a id="_idIndexMarker981"/><span class="koboSpan" id="kobo.119.1">based on the data-driven approach pre-process data and send it to whichever other service might be interested. </span><span class="koboSpan" id="kobo.119.2">This way, each microservice already contains pre-computed data it can use to respond immediately to user requests with no need for further request-specific communications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.120.1">More specifically, as new data becomes available, each microservice does its job and then sends the results to all interested microservices with asynchronous communications; that is, a microservice doesn’t wait for any acknowledgment from its recipients. </span><span class="koboSpan" id="kobo.120.2">Asynchronous communication is a must since each communication act usually triggers other communication acts recursively for the recipient, so we can’t block the whole tree of microservices until the final acknowledgment arrives from all the tree leaves, as in the case of RPC.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.121.1">However, while being the only acceptable option for high-traffic microservices, the data-driven approach is more difficult to implement. </span><span class="koboSpan" id="kobo.121.2">In particular, the absence of acknowledgments creates complex coordination problems that increase the application development and testing time. </span><span class="koboSpan" id="kobo.121.3">We will discuss how to face coordination problems later on in the chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.122.1">Here it is just worth stating the following rule of thumb.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.123.1">Use the data-driven approach for all high-traffic worker microservices, but for services with shorter request-response cycles and experiencing low to moderate amounts of requests, use utilizing RPC (Remote Procedure Call).</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.124.1">Therefore, actual applications mix efficient short-path RPC calls with the data-driven approach.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.125.1">Another point that is worth mentioning is communication security. </span><span class="koboSpan" id="kobo.125.2">When security is needed, and communication relies on an underlying TCP/IP connection, we can simply use TLS/SSL (the same protocol used by HTTPS connections). </span><span class="koboSpan" id="kobo.125.3">However, in this case, since we are speaking of communications among servers, so there is no actual client, it is common that both communicating microservices authenticate each other with private key certificates, and then agree on a cryptographic protocol and key to secure their TLS/SS communication. </span><span class="koboSpan" id="kobo.125.4">.NET furnishes all tools for negotiating a TLS/SSL connection based on reciprocal authentication based on servers.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.126.1">However, when all microservices are part of the same private network, it is common to secure just the communication in/out of this private network and not secure all the intranet communications, both to simplify the design of the overall communication strategy and to save the performance cost of encryption.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.127.1">Another</span><a id="_idIndexMarker982"/><span class="koboSpan" id="kobo.128.1"> typical optimization of inter-application communications is the usage of binary serialization, which produces shorter messages and requires less bandwidth and less processing time. </span><span class="koboSpan" id="kobo.128.2">In fact, for instance, representing an integer within an object with a binary serialization costs about 4 bytes, that is, basically the same number of bytes needed to store it in the computer memory (there is a small overhead, for protocol-handling metadata), while representing the same integer as a text requires a byte for each digit, plus the bytes needed for the field name.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.129.1">Binary serialization is discussed in detail in the next subsection. </span><span class="koboSpan" id="kobo.129.2">Then, also, RPC- and data-driven asynchronous communication will be analyzed in dedicated subsections.</span></p>
<h2 class="heading-2" id="_idParaDest-288"><span class="koboSpan" id="kobo.130.1">Efficient and flexible binary serialization</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.131.1">Serialization</span><a id="_idIndexMarker983"/><span class="koboSpan" id="kobo.132.1"> is the process of transforming data in a way that they can be sent on a communication channel, or stored </span><a id="_idIndexMarker984"/><span class="koboSpan" id="kobo.133.1">in a file. </span><span class="koboSpan" id="kobo.133.2">Therefore, the way data are serialized has a strong impact on the quantity of data that will be sent.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.134.1">The .NET echo system contains several fast, platform-specific binary serializers, which are able to produce compact, short messages with very low computational costs. </span><span class="koboSpan" id="kobo.134.2">In the </span><em class="italic"><span class="koboSpan" id="kobo.135.1">Implementing microservices with .NET worker services and message brokers</span></em><span class="koboSpan" id="kobo.136.1"> section, we will test one of the fastest, the </span><em class="italic"><span class="koboSpan" id="kobo.137.1">Binaron</span></em><span class="koboSpan" id="kobo.138.1"> package.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.139.1">Unfortunately, efficient binary serializers suffer from a couple of well-known problems:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.140.1">Since the most performant binary serializers are tied to a specific platform, they are not interoperable. </span><span class="koboSpan" id="kobo.140.2">Thus, for instance, the Java binary format is not compatible with the .NET binary format. </span><span class="koboSpan" id="kobo.140.3">This constraint creates problems when your application microservices are heterogeneous and use different technologies.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.141.1">If one uses the same platform-specific, in-memory binary format, adding/removing properties to/from an object breaks compatibility. </span><span class="koboSpan" id="kobo.141.2">Thus, a microservice that uses an old version of a class is not able to de-serialize data created with a newer version of the same class. </span><span class="koboSpan" id="kobo.141.3">This constraint creates dependencies between the microservices’ CI/CD cycles because when a microservice changes to meet new requirements, it causes recursive changes in all other microservices that communicate with it.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.142.1">In </span><em class="italic"><span class="koboSpan" id="kobo.143.1">Chapter 15</span></em><span class="koboSpan" id="kobo.144.1">, </span><em class="italic"><span class="koboSpan" id="kobo.145.1">Applying Service-Oriented Architectures with .NET</span></em><span class="koboSpan" id="kobo.146.1">, we will see that the JSON format was widely</span><a id="_idIndexMarker985"/><span class="koboSpan" id="kobo.147.1"> adopted because it avoids these two problems since it is not tied to any </span><a id="_idIndexMarker986"/><span class="koboSpan" id="kobo.148.1">specific language/runtime, and added properties can simply be ignored, while removed properties are handled by assigning default values.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.149.1">The </span><strong class="keyWord"><span class="koboSpan" id="kobo.150.1">ProtoBuf</span></strong><span class="koboSpan" id="kobo.151.1"> binary format </span><a id="_idIndexMarker987"/><span class="koboSpan" id="kobo.152.1">was conceived to ensure the same JSON serialization/deserialization advantages for binary formats.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.153.1">ProtoBuf achieves interoperability by defining abstract elementary types and their binary representations. </span><span class="koboSpan" id="kobo.153.2">Then, each framework takes care of converting its native types to/from them. </span><span class="koboSpan" id="kobo.153.3">Elementary types are combined into complex structures called </span><strong class="keyWord"><span class="koboSpan" id="kobo.154.1">messages</span></strong><span class="koboSpan" id="kobo.155.1">, which represent classes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.156.1">Compatibility between different versions of the same message is ensured by assigning a unique integer number to each property. </span><span class="koboSpan" id="kobo.156.2">This way, when a message is de-serialized into an object, just the integers that mark the property of the given message version are searched in the serialized data and de-serialized. </span><span class="koboSpan" id="kobo.156.3">When a property number is not found in the serialized data, the default value is taken for the associate property. </span><span class="koboSpan" id="kobo.156.4">This way, ProtoBuf messages have the same serialization/deserialization advantages as JSON objects. </span><span class="koboSpan" id="kobo.156.5">In a few words compatibility among different versions is ensured if the developer doesn’t change the number associated with each property. </span><span class="koboSpan" id="kobo.156.6">The developer can also remove properties, but without assigning their numbers to new properties, because these numbers have the purpose of naming (with very short names) all fields. </span><span class="koboSpan" id="kobo.156.7">The receiver uses these integer names to restore the messages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.157.1">There are also other serialization proposals similar to ProtoBuf. </span><span class="koboSpan" id="kobo.157.2">Some of them also ensure better performance, but at the moment, ProtoBuf, which was created by Google, is the de facto standard for interoperable binary communication.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.158.1">ProtoBuf messages are defined in </span><code class="inlineCode"><span class="koboSpan" id="kobo.159.1">.proto</span></code><span class="koboSpan" id="kobo.160.1"> files and are then compiled into code in the target language by language-specific tools. </span><span class="koboSpan" id="kobo.160.2">The section that follows describes the ProtoBuf data description language.</span></p>
<h2 class="heading-2" id="_idParaDest-289"><span class="koboSpan" id="kobo.161.1">The ProtoBuf language</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.162.1">Each </span><code class="inlineCode"><span class="koboSpan" id="kobo.163.1">.proto</span></code><span class="koboSpan" id="kobo.164.1"> file starts with a declaration of the version of ProtoBuf. </span><span class="koboSpan" id="kobo.164.2">At the moment, the highest available</span><a id="_idIndexMarker988"/><span class="koboSpan" id="kobo.165.1"> version is </span><code class="inlineCode"><span class="koboSpan" id="kobo.166.1">proto3</span></code><span class="koboSpan" id="kobo.167.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.168.1">syntax = </span><span class="hljs-string"><span class="koboSpan" id="kobo.169.1">"proto3"</span></span><span class="koboSpan" id="kobo.170.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.171.1">Since .NET SDK will </span><a id="_idIndexMarker989"/><span class="koboSpan" id="kobo.172.1">generate classes out of ProtoBuf definitions, then, if the target language is .NET, you can specify the namespace where you generate all the .NET classes corresponding to the ProtoBuf types defined in the file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.173.1">option csharp_namespace = </span><span class="hljs-string"><span class="koboSpan" id="kobo.174.1">"FakeSource"</span></span><span class="koboSpan" id="kobo.175.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.176.1">Then, you can import definitions contained in other </span><code class="inlineCode"><span class="koboSpan" id="kobo.177.1">.proto</span></code><span class="koboSpan" id="kobo.178.1"> files, with one or more </span><code class="inlineCode"><span class="koboSpan" id="kobo.179.1">import</span></code><span class="koboSpan" id="kobo.180.1"> declarations:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.181.1">import </span><span class="hljs-string"><span class="koboSpan" id="kobo.182.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.183.1">google/protobuf/timestamp.proto"</span></span><span class="koboSpan" id="kobo.184.1">;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.185.1">The above definition imports the definition of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.186.1">TimeStamp</span></code><span class="koboSpan" id="kobo.187.1"> type, which encodes both the </span><code class="inlineCode"><span class="koboSpan" id="kobo.188.1">DateTime</span></code><span class="koboSpan" id="kobo.189.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.190.1">DateTimeOffset</span></code><span class="koboSpan" id="kobo.191.1"> .NET types. </span><code class="inlineCode"><span class="koboSpan" id="kobo.192.1">TimeStamp</span></code><span class="koboSpan" id="kobo.193.1"> is not a ProtoBuf simple type but is defined in a standard ProtoBuf types library.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.194.1">Finally, we can scope all message definitions to a </span><code class="inlineCode"><span class="koboSpan" id="kobo.195.1">package</span></code><span class="koboSpan" id="kobo.196.1"> to avoid name collisions. </span><span class="koboSpan" id="kobo.196.2">ProtoBuf packages have the same role as a .NET namespace but are not automatically converted into .NET namespaces during .NET code generation, since .NET namespaces are specified with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.197.1">option C#</span></code><span class="koboSpan" id="kobo.198.1"> declaration:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.199.1">package purchase;
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.200.1">Each </span><code class="inlineCode"><span class="koboSpan" id="kobo.201.1">.proto</span></code><span class="koboSpan" id="kobo.202.1"> file can contain several message definitions. </span><span class="koboSpan" id="kobo.202.2">Here is an example message:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.203.1">message PurchaseMessage </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.204.1">{</span></span><span class="koboSpan" id="kobo.205.1">
  string id = </span><span class="hljs-number"><span class="koboSpan" id="kobo.206.1">1</span></span><span class="koboSpan" id="kobo.207.1">;
  google.protobuf.Timestamp time = </span><span class="hljs-number"><span class="koboSpan" id="kobo.208.1">2</span></span><span class="koboSpan" id="kobo.209.1">;
  string location = </span><span class="hljs-number"><span class="koboSpan" id="kobo.210.1">3</span></span><span class="koboSpan" id="kobo.211.1">;
  int32 cost =</span><span class="hljs-number"><span class="koboSpan" id="kobo.212.1">4</span></span><span class="koboSpan" id="kobo.213.1">;
  google.protobuf.Timestamp purchaseTime = </span><span class="hljs-number"><span class="koboSpan" id="kobo.214.1">5</span></span><span class="koboSpan" id="kobo.215.1">;
</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.216.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.217.1">Each property is specified by the property type followed by the property name, and then by the unique integer associated with that property. </span><span class="koboSpan" id="kobo.217.2">Property names must be in camel case, but they are converted to Pascal case during .NET code generation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.218.1">If a new </span><a id="_idIndexMarker990"/><span class="koboSpan" id="kobo.219.1">version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.220.1">PurchaseMessage</span></code><span class="koboSpan" id="kobo.221.1"> is created, compatibility with the past version can be maintained by not reusing the integers assigned to the properties of the old version, and by removing just unused properties, as in the following example:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.222.1">message PurchaseMessage </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.223.1">{</span></span><span class="koboSpan" id="kobo.224.1">
  string id = </span><span class="hljs-number"><span class="koboSpan" id="kobo.225.1">1</span></span><span class="koboSpan" id="kobo.226.1">;
  int32 cost =</span><span class="hljs-number"><span class="koboSpan" id="kobo.227.1">4</span></span><span class="koboSpan" id="kobo.228.1">;
  google.protobuf.Timestamp purchaseTime = </span><span class="hljs-number"><span class="koboSpan" id="kobo.229.1">5</span></span><span class="koboSpan" id="kobo.230.1">;
  Reseller reseller = </span><span class="hljs-number"><span class="koboSpan" id="kobo.231.1">7</span></span><span class="koboSpan" id="kobo.232.1">;
</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.233.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.234.1">The </span><a id="_idIndexMarker991"/><span class="koboSpan" id="kobo.235.1">new version of </span><code class="inlineCode"><span class="koboSpan" id="kobo.236.1">PurchaseMessage</span></code><span class="koboSpan" id="kobo.237.1"> doesn’t contain properties </span><code class="inlineCode"><span class="koboSpan" id="kobo.238.1">2</span></code><span class="koboSpan" id="kobo.239.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.240.1">3</span></code><span class="koboSpan" id="kobo.241.1">, but it contains the new </span><code class="inlineCode"><span class="koboSpan" id="kobo.242.1">reseller</span></code><span class="koboSpan" id="kobo.243.1"> property, marked with the new </span><code class="inlineCode"><span class="koboSpan" id="kobo.244.1">7</span></code><span class="koboSpan" id="kobo.245.1"> integer. </span><span class="koboSpan" id="kobo.245.2">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.246.1">Reseller</span></code><span class="koboSpan" id="kobo.247.1"> type is defined by another message that can be contained either in the same </span><code class="inlineCode"><span class="koboSpan" id="kobo.248.1">.proto</span></code><span class="koboSpan" id="kobo.249.1"> file or an imported file.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.250.1">Clearly, compatibility is maintained just with clients that don’t use the removed properties, while clients directly affected by the changes must be updated.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.251.1">Collections are represented by prefixing the name of the collection element type with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.252.1">repeated</span></code><span class="koboSpan" id="kobo.253.1"> keyword:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.254.1">message PurchaseMessage </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.255.1">{</span></span><span class="koboSpan" id="kobo.256.1">
  ...
  </span><span class="koboSpan" id="kobo.256.2">repeated Product products = </span><span class="hljs-number"><span class="koboSpan" id="kobo.257.1">3</span></span><span class="koboSpan" id="kobo.258.1">;
  ...
</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.259.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.260.1">Repeated data are translated into the </span><code class="inlineCode"><span class="koboSpan" id="kobo.261.1">Google.Protobuf.Collections.RepeatedField&lt;T&gt;</span></code><span class="koboSpan" id="kobo.262.1"> .NET type, which implements </span><code class="inlineCode"><span class="koboSpan" id="kobo.263.1">IList&lt;T&gt;</span></code><span class="koboSpan" id="kobo.264.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.265.1">Dictionaries are represented with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.266.1">map&lt;T1, T2&gt;</span></code><span class="koboSpan" id="kobo.267.1"> type:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.268.1">message PurchaseMessage </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.269.1">{</span></span><span class="koboSpan" id="kobo.270.1">
  ...
  </span><span class="koboSpan" id="kobo.270.2">map&lt;string</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.271.1">,</span></span><span class="koboSpan" id="kobo.272.1"> int&gt; attributes = </span><span class="hljs-number"><span class="koboSpan" id="kobo.273.1">3</span></span><span class="koboSpan" id="kobo.274.1">;
  ...
</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.275.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.276.1">Messages can</span><a id="_idIndexMarker992"/><span class="koboSpan" id="kobo.277.1"> be nested in other messages, in which case they generate classes defined in other .NET classes during code generation:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.278.1">message PurchaseMessage </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.279.1">{</span></span><span class="koboSpan" id="kobo.280.1">
  message Product </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.281.1">{</span></span><span class="koboSpan" id="kobo.282.1">
    int32 id = </span><span class="hljs-number"><span class="koboSpan" id="kobo.283.1">1</span></span><span class="koboSpan" id="kobo.284.1">;
    string name = </span><span class="hljs-number"><span class="koboSpan" id="kobo.285.1">2</span></span><span class="koboSpan" id="kobo.286.1">;
    uint32 cost = </span><span class="hljs-number"><span class="koboSpan" id="kobo.287.1">3</span></span><span class="koboSpan" id="kobo.288.1">;
    uint32 quantity = </span><span class="hljs-number"><span class="koboSpan" id="kobo.289.1">4</span></span><span class="koboSpan" id="kobo.290.1">;
  </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.291.1">}</span></span><span class="koboSpan" id="kobo.292.1">
  ...
  </span><span class="koboSpan" id="kobo.292.2">repeated Product products = </span><span class="hljs-number"><span class="koboSpan" id="kobo.293.1">3</span></span><span class="koboSpan" id="kobo.294.1">;
  ...
</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.295.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.296.1">We can</span><a id="_idIndexMarker993"/><span class="koboSpan" id="kobo.297.1"> also define </span><code class="inlineCode"><span class="koboSpan" id="kobo.298.1">enum</span></code><span class="koboSpan" id="kobo.299.1"> types that translate directly to .NET </span><code class="inlineCode"><span class="koboSpan" id="kobo.300.1">enum</span></code><span class="koboSpan" id="kobo.301.1"> types:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.302.1">enum ColorType </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.303.1">{</span></span><span class="koboSpan" id="kobo.304.1">
    RED = </span><span class="hljs-number"><span class="koboSpan" id="kobo.305.1">0</span></span><span class="koboSpan" id="kobo.306.1">;
    GREEN = </span><span class="hljs-number"><span class="koboSpan" id="kobo.307.1">1</span></span><span class="koboSpan" id="kobo.308.1">;
    ...
  </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.309.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.310.1">It is also possible to define messages with conditional content. </span><span class="koboSpan" id="kobo.310.2">This is useful for sending either a response or error information:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.311.1">message Payload </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.312.1">{</span></span><span class="koboSpan" id="kobo.313.1">
    ...
</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.314.1">}</span></span><span class="koboSpan" id="kobo.315.1">
message Error </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.316.1">{</span></span><span class="koboSpan" id="kobo.317.1">
    ...
</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.318.1">}</span></span><span class="koboSpan" id="kobo.319.1">
message ResponseMessage </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.320.1">{</span></span><span class="koboSpan" id="kobo.321.1">
  one of result </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.322.1">{</span></span><span class="koboSpan" id="kobo.323.1">
    Error error = </span><span class="hljs-number"><span class="koboSpan" id="kobo.324.1">1</span></span><span class="koboSpan" id="kobo.325.1">;
    Person payload = </span><span class="hljs-number"><span class="koboSpan" id="kobo.326.1">2</span></span><span class="koboSpan" id="kobo.327.1">;
  </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.328.1">}</span></span>
<span class="hljs-punctuation"><span class="koboSpan" id="kobo.329.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.330.1">Once a microservice receives a .NET object of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.331.1">ResponseMessage</span></code><span class="koboSpan" id="kobo.332.1"> type, it can process it as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.333.1">ResponseMessage  response = ...;
switch (response.ResultCase)
</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.334.1">{</span></span><span class="koboSpan" id="kobo.335.1">
    case ResponseMessage.ResultOneofCase.Payload</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.336.1">:</span></span><span class="koboSpan" id="kobo.337.1">
        HandlePayload(response. </span><span class="koboSpan" id="kobo.337.2">Payload);
        break;
    case ResponseMessage.ResultOneofCase.Error</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.338.1">:</span></span><span class="koboSpan" id="kobo.339.1">
        HandleError(response.Error);
        break;
    default</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.340.1">:</span></span><span class="koboSpan" id="kobo.341.1">
        throw new ArgumentException();
</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.342.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.343.1">The</span><a id="_idIndexMarker994"/><span class="koboSpan" id="kobo.344.1"> table below summarizes </span><a id="_idIndexMarker995"/><span class="koboSpan" id="kobo.345.1">all the ProtoBuf simple types and their equivalent .NET types:</span></p>
<table class="table-container" id="table001-3">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.346.1">.NET types</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.347.1">Protobuf types</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.348.1">double</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.349.1">double</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.350.1">float</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.351.1">float</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.352.1">string</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.353.1">string</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.354.1">bool</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.355.1">bool</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.356.1">ByteString</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.357.1">bytes</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.358.1">int</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.359.1">int32, sint32, sfixed32</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.360.1">uint</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.361.1">uint32, fixed32</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.362.1">long</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.363.1">int64, sint64, sfixed64</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.364.1">ulong</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.365.1">uint64, fixed64</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.366.1">Table 14.1: Mapping Protobuf Simple Types to .NET Equivalents</span></p>
<p class="normal"><span class="koboSpan" id="kobo.367.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.368.1">ByteString</span></code><span class="koboSpan" id="kobo.369.1"> .NET type is defined in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.370.1">Google.Protobuf</span></code><span class="koboSpan" id="kobo.371.1"> namespace contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.372.1">Google.Protobuf</span></code><span class="koboSpan" id="kobo.373.1"> NuGet package. </span><span class="koboSpan" id="kobo.373.2">It can be converted to </span><code class="inlineCode"><span class="koboSpan" id="kobo.374.1">byte[]</span></code><span class="koboSpan" id="kobo.375.1"> with its </span><code class="inlineCode"><span class="koboSpan" id="kobo.376.1">.ToByteArray()</span></code><span class="koboSpan" id="kobo.377.1"> method. </span><span class="koboSpan" id="kobo.377.2">A </span><code class="inlineCode"><span class="koboSpan" id="kobo.378.1">byte[]</span></code><span class="koboSpan" id="kobo.379.1"> object can be converted into a </span><code class="inlineCode"><span class="koboSpan" id="kobo.380.1">ByteString</span></code><span class="koboSpan" id="kobo.381.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.382.1">ByteString.CopyFrom(byte[] data)</span></code><span class="koboSpan" id="kobo.383.1"> static method.</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.384.1">int32</span></code><span class="koboSpan" id="kobo.385.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.386.1">sint32</span></code><span class="koboSpan" id="kobo.387.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.388.1">sfixed32</span></code><span class="koboSpan" id="kobo.389.1"> encode .NET </span><code class="inlineCode"><span class="koboSpan" id="kobo.390.1">int</span></code><span class="koboSpan" id="kobo.391.1">. </span><span class="koboSpan" id="kobo.391.2">Now, </span><code class="inlineCode"><span class="koboSpan" id="kobo.392.1">sint32</span></code><span class="koboSpan" id="kobo.393.1"> is convenient when the integer is more</span><a id="_idIndexMarker996"/><span class="koboSpan" id="kobo.394.1"> likely to be negative, while the </span><code class="inlineCode"><span class="koboSpan" id="kobo.395.1">sfixed32</span></code><span class="koboSpan" id="kobo.396.1"> type is convenient when the integer is likely to contain more than 28 bits. </span><span class="koboSpan" id="kobo.396.2">Similar considerations apply to </span><code class="inlineCode"><span class="koboSpan" id="kobo.397.1">uint32</span></code><span class="koboSpan" id="kobo.398.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.399.1">fixed32</span></code><span class="koboSpan" id="kobo.400.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.401.1">The same criteria apply to 64-bit integers, but in this case, the threshold for the convenience of </span><code class="inlineCode"><span class="koboSpan" id="kobo.402.1">sfixed64</span></code><span class="koboSpan" id="kobo.403.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.404.1">fixed64</span></code><span class="koboSpan" id="kobo.405.1"> is 56 bits.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.406.1">ProtoBuf </span><a id="_idIndexMarker997"/><span class="koboSpan" id="kobo.407.1">simple types are not nullable. </span><span class="koboSpan" id="kobo.407.2">This means that they can’t have a null value, and if no value is assigned to them, they take a default value. </span><span class="koboSpan" id="kobo.407.3">The default value of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.408.1">string</span></code><span class="koboSpan" id="kobo.409.1"> is an empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.410.1">string</span></code><span class="koboSpan" id="kobo.411.1">, while the default value of a </span><code class="inlineCode"><span class="koboSpan" id="kobo.412.1">ByteString</span></code><span class="koboSpan" id="kobo.413.1"> is an empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.414.1">ByteString</span></code><span class="koboSpan" id="kobo.415.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.416.1">If you need nullable types, you must include a predefined </span><code class="inlineCode"><span class="koboSpan" id="kobo.417.1">.proto</span></code><span class="koboSpan" id="kobo.418.1"> file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.419.1">import </span><span class="hljs-string"><span class="koboSpan" id="kobo.420.1">"google/protobuf/wrappers.proto"</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.421.1">Here is a table that details the correspondence between .NET nullable simple types and ProtoBuf nullable wrappers:</span></p>
<table class="table-container" id="table002">
<tbody>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.422.1">.NET types</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.423.1">ProtoBuf types</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.424.1">double?</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.425.1">google.protobuf.DoubleValue</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.426.1">float?</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.427.1">google.protobuf.FloatValue</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.428.1">string?</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.429.1">google.protobuf.StringValue</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.430.1">bool?</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.431.1">google.protobuf.BoolValue</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.432.1">ByteString?</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.433.1">google.protobuf.BytesValue</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.434.1">int?</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.435.1">google.protobuf.Int32Value</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.436.1">uint?</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.437.1">google.protobuf.UInt32Value</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.438.1">long?</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.439.1">google.protobuf.Int64Value</span></code></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.440.1">ulong?</span></code></p>
</td>
<td class="table-cell">
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.441.1">google.protobuf.UInt64Value</span></code></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.442.1">Table 14.2</span></p>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.443.1">DateTime</span></code><span class="koboSpan" id="kobo.444.1">, </span><code class="inlineCode"><span class="koboSpan" id="kobo.445.1">DateTimeOffset</span></code><span class="koboSpan" id="kobo.446.1">, and </span><code class="inlineCode"><span class="koboSpan" id="kobo.447.1">TimeSpan</span></code><span class="koboSpan" id="kobo.448.1"> have no direct equivalent in ProtoBuf, but the </span><code class="inlineCode"><span class="koboSpan" id="kobo.449.1">Google.Protobuf.WellKnownTypes</span></code><span class="koboSpan" id="kobo.450.1"> namespace contained in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.451.1">Google.Protobuf</span></code><span class="koboSpan" id="kobo.452.1"> NuGet package contains the </span><code class="inlineCode"><span class="koboSpan" id="kobo.453.1">Timestamp</span></code><span class="koboSpan" id="kobo.454.1"> type, which maps from/to </span><code class="inlineCode"><span class="koboSpan" id="kobo.455.1">DateTime</span></code><span class="koboSpan" id="kobo.456.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.457.1">DateTimeOffset</span></code><span class="koboSpan" id="kobo.458.1">, and the </span><code class="inlineCode"><span class="koboSpan" id="kobo.459.1">Duration</span></code><span class="koboSpan" id="kobo.460.1"> type, which maps from/to </span><code class="inlineCode"><span class="koboSpan" id="kobo.461.1">TimeSpan</span></code><span class="koboSpan" id="kobo.462.1">. </span><span class="koboSpan" id="kobo.462.2">The mapping is completely </span><a id="_idIndexMarker998"/><span class="koboSpan" id="kobo.463.1">analogous to that of </span><code class="inlineCode"><span class="koboSpan" id="kobo.464.1">ByteString</span></code><span class="koboSpan" id="kobo.465.1">. </span><span class="koboSpan" id="kobo.465.2">Thus, for instance, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.466.1">Duration</span></code><span class="koboSpan" id="kobo.467.1"> is obtained from a </span><code class="inlineCode"><span class="koboSpan" id="kobo.468.1">TimeSpan</span></code><span class="koboSpan" id="kobo.469.1"> with the </span><code class="inlineCode"><span class="koboSpan" id="kobo.470.1">Duration.FromTimeSpan</span></code><span class="koboSpan" id="kobo.471.1"> static method, while a </span><code class="inlineCode"><span class="koboSpan" id="kobo.472.1">Duration</span></code><span class="koboSpan" id="kobo.473.1"> is transformed into a </span><code class="inlineCode"><span class="koboSpan" id="kobo.474.1">TimeSpan</span></code><span class="koboSpan" id="kobo.475.1"> by calling its </span><code class="inlineCode"><span class="koboSpan" id="kobo.476.1">.ToTimeSpan</span></code><span class="koboSpan" id="kobo.477.1"> instance method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.478.1">The </span><a id="_idIndexMarker999"/><span class="koboSpan" id="kobo.479.1">usage of </span><code class="inlineCode"><span class="koboSpan" id="kobo.480.1">Duration</span></code><span class="koboSpan" id="kobo.481.1"> and </span><code class="inlineCode"><span class="koboSpan" id="kobo.482.1">Timestamp</span></code><span class="koboSpan" id="kobo.483.1"> in </span><code class="inlineCode"><span class="koboSpan" id="kobo.484.1">.proto</span></code><span class="koboSpan" id="kobo.485.1"> files is shown in the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.486.1">syntax = </span><span class="hljs-string"><span class="koboSpan" id="kobo.487.1">"proto3"</span></span><span class="koboSpan" id="kobo.488.1">
import </span><span class="hljs-string"><span class="koboSpan" id="kobo.489.1">"google/protobuf/duration.proto"</span></span><span class="koboSpan" id="kobo.490.1">; 
import </span><span class="hljs-string"><span class="koboSpan" id="kobo.491.1">"google/protobuf/timestamp.proto"</span></span><span class="koboSpan" id="kobo.492.1">;
message PurchaseMessage {
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.493.1">string</span></span><span class="koboSpan" id="kobo.494.1"> id = </span><span class="hljs-number"><span class="koboSpan" id="kobo.495.1">1</span></span><span class="koboSpan" id="kobo.496.1">;
  google.protobuf.Timestamp time = </span><span class="hljs-number"><span class="koboSpan" id="kobo.497.1">2</span></span><span class="koboSpan" id="kobo.498.1">;
  </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.499.1">string</span></span><span class="koboSpan" id="kobo.500.1"> location = </span><span class="hljs-number"><span class="koboSpan" id="kobo.501.1">3</span></span><span class="koboSpan" id="kobo.502.1">;
  int32 cost =</span><span class="hljs-number"><span class="koboSpan" id="kobo.503.1">4</span></span><span class="koboSpan" id="kobo.504.1">;
  google.protobuf.Timestamp purchaseTime = </span><span class="hljs-number"><span class="koboSpan" id="kobo.505.1">5</span></span><span class="koboSpan" id="kobo.506.1">;
  google.protobuf.Duration travelDuration = </span><span class="hljs-number"><span class="koboSpan" id="kobo.507.1">6</span></span><span class="koboSpan" id="kobo.508.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.509.1">Please notice that usage needs the import of predefined </span><code class="inlineCode"><span class="koboSpan" id="kobo.510.1">.proto</span></code><span class="koboSpan" id="kobo.511.1"> files.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.512.1">At the moment, there is no equivalent to the .NET </span><code class="inlineCode"><span class="koboSpan" id="kobo.513.1">decimal</span></code><span class="koboSpan" id="kobo.514.1"> type, but it will probably be introduced in the next version. </span><span class="koboSpan" id="kobo.514.2">However, you can encode decimals with two integers, one for the integer part and the other for the decimal part, with a message like the one in the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.515.1">message ProtoDecimal </span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.516.1">{</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.517.1">// Whole units part of the decimal</span></span><span class="koboSpan" id="kobo.518.1">
    int64 units = </span><span class="hljs-number"><span class="koboSpan" id="kobo.519.1">1</span></span><span class="koboSpan" id="kobo.520.1">;
    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.521.1">// Nano units of the decimal (10^-9)</span></span>
<span class="hljs-comment"><span class="koboSpan" id="kobo.522.1">// Must be same sign as units</span></span><span class="koboSpan" id="kobo.523.1">
    sfixed32 nanos = </span><span class="hljs-number"><span class="koboSpan" id="kobo.524.1">2</span></span><span class="koboSpan" id="kobo.525.1">;
</span><span class="hljs-punctuation"><span class="koboSpan" id="kobo.526.1">}</span></span>
</code></pre>
<p class="normal"><span class="koboSpan" id="kobo.527.1">We can add implicit conversion to the .NET </span><code class="inlineCode"><span class="koboSpan" id="kobo.528.1">decimal</span></code><span class="koboSpan" id="kobo.529.1">, with a partial class that combines with another </span><a id="_idIndexMarker1000"/><span class="koboSpan" id="kobo.530.1">partial class, which is automatically generated from the </span><code class="inlineCode"><span class="koboSpan" id="kobo.531.1">.proto</span></code><span class="koboSpan" id="kobo.532.1"> file:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.533.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.534.1">partial</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.535.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.536.1">DecimalValue</span></span><span class="koboSpan" id="kobo.537.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.538.1">private</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.539.1">const</span></span> <span class="hljs-built_in"><span class="koboSpan" id="kobo.540.1">decimal</span></span><span class="koboSpan" id="kobo.541.1"> nanoFactor = </span><span class="hljs-number"><span class="koboSpan" id="kobo.542.1">1000000000</span></span><span class="koboSpan" id="kobo.543.1">m;
   
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.544.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.545.1">static</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.546.1">implicit</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.547.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.548.1">decimal</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.549.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.550.1">ProtoDecimal pDecimal</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.551.1">)</span></span><span class="koboSpan" id="kobo.552.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.553.1">return</span></span><span class="koboSpan" id="kobo.554.1"> pDecimal.Units + pDecimal.Nanos / nanoFactor;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.555.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.556.1">static</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.557.1">implicit</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.558.1">operator</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.559.1">ProtoDecimal</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.560.1"> (</span></span><span class="hljs-built_in"><span class="koboSpan" id="kobo.561.1">decimal</span></span><span class="hljs-params"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.562.1">value</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.563.1">)</span></span><span class="koboSpan" id="kobo.564.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.565.1">return</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.566.1">new</span></span><span class="koboSpan" id="kobo.567.1"> ProtoDecimal
          {
             Units = </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.568.1">decimal</span></span><span class="koboSpan" id="kobo.569.1">.ToInt32(</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.570.1">value</span></span><span class="koboSpan" id="kobo.571.1">),
             Nanos= </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.572.1">decimal</span></span><span class="koboSpan" id="kobo.573.1">.ToInt32((</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.574.1">value</span></span><span class="koboSpan" id="kobo.575.1"> - Units) * nanoFactor),
          };
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.576.1">We have </span><a id="_idIndexMarker1001"/><span class="koboSpan" id="kobo.577.1">described almost completely the ProtoBuf data description language. </span><span class="koboSpan" id="kobo.577.2">The only missing subject is the representation of variable/unknown types, which are rarely used. </span><span class="koboSpan" id="kobo.577.3">However, the </span><em class="italic"><span class="koboSpan" id="kobo.578.1">Further reading</span></em><span class="koboSpan" id="kobo.579.1"> section contains a link to the official documentation. </span><span class="koboSpan" id="kobo.579.2">The next section explains how to serialize and de-serialize messages.</span></p>
<h2 class="heading-2" id="_idParaDest-290"><span class="koboSpan" id="kobo.580.1">ProtoBuf serialization</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.581.1">An </span><a id="_idIndexMarker1002"/><span class="koboSpan" id="kobo.582.1">object tree can be</span><a id="_idIndexMarker1003"/><span class="koboSpan" id="kobo.583.1"> serialized as shown in the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.584.1">using</span></span><span class="koboSpan" id="kobo.585.1"> Google.Protobuf;
...
</span><span class="koboSpan" id="kobo.585.2">PurchaseMessage purchase = ....
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.586.1">byte</span></span><span class="koboSpan" id="kobo.587.1">[]? </span><span class="koboSpan" id="kobo.587.2">body = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.588.1">null</span></span><span class="koboSpan" id="kobo.589.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.590.1">using</span></span><span class="koboSpan" id="kobo.591.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.592.1">var</span></span><span class="koboSpan" id="kobo.593.1"> stream = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.594.1">new</span></span><span class="koboSpan" id="kobo.595.1"> MemoryStream())
{
    purchase.WriteTo(stream);
    stream.Flush();
    body = stream.ToArray();
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.596.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.597.1">WriteTo</span></code><span class="koboSpan" id="kobo.598.1"> method</span><a id="_idIndexMarker1004"/><span class="koboSpan" id="kobo.599.1"> needs a stream so create an in-memory stream. </span><span class="koboSpan" id="kobo.599.2">After, we create a byte array from the stream with </span><code class="inlineCode"><span class="koboSpan" id="kobo.600.1">ToArray</span></code><span class="koboSpan" id="kobo.601.1">, which ensures that the stream buffer is actually written into the stream before attempting the extraction of the byte array:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.602.1">Byte[] body = ...
</span><span class="koboSpan" id="kobo.602.2">PurchaseMessage? </span><span class="koboSpan" id="kobo.602.3">message = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.603.1">null</span></span><span class="koboSpan" id="kobo.604.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.605.1">using</span></span><span class="koboSpan" id="kobo.606.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.607.1">var</span></span><span class="koboSpan" id="kobo.608.1"> stream = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.609.1">new</span></span><span class="koboSpan" id="kobo.610.1"> MemoryStream(body))
{
    message = PurchaseMessage.Parser.ParseFrom(stream);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.611.1">Here, since </span><code class="inlineCode"><span class="koboSpan" id="kobo.612.1">ParseFrom</span></code><span class="koboSpan" id="kobo.613.1"> also needs a stream, we generate a stream from the message bytes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.614.1">The next subsection</span><a id="_idIndexMarker1005"/><span class="koboSpan" id="kobo.615.1"> describes the usage of RPC in microservices.</span></p>
<h2 class="heading-2" id="_idParaDest-291"><span class="koboSpan" id="kobo.616.1">Efficient and flexible RPC</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.617.1">The RPC approach </span><a id="_idIndexMarker1006"/><span class="koboSpan" id="kobo.618.1">can be adopted in </span><a id="_idIndexMarker1007"/><span class="koboSpan" id="kobo.619.1">some application microservices with good results if the following conditions are met:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.620.1">The chain of recursive calls is very short, usually just one call without recursive calls.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.621.1">Low communication latency and high channel bandwidth. </span><span class="koboSpan" id="kobo.621.2">This condition is met by intranet communications that take place on high-speed Ethernet within the same data center.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.622.1">Data is serialized quickly and in a very size-efficient format. </span><span class="koboSpan" id="kobo.622.2">This condition is met by any efficient binary serializer.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.623.1">Long chains of recursive calls are avoided whenever RPC is used just to queue a request and to receive confirmation that the request has been correctly queued, without waiting for any processing result. </span><span class="koboSpan" id="kobo.623.2">In this case, RPC is used to simulate an asynchronous communication with reception confirmation. </span><span class="koboSpan" id="kobo.623.3">If this is the case, all of these conditions are easily met whenever all communicating microservices are part of the same </span><strong class="keyWord"><span class="koboSpan" id="kobo.624.1">local area network</span></strong><span class="koboSpan" id="kobo.625.1"> (</span><strong class="keyWord"><span class="koboSpan" id="kobo.626.1">LAN</span></strong><span class="koboSpan" id="kobo.627.1">) where all computers are connected with high-speed physical connections.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.628.1">On the contrary, when </span><a id="_idIndexMarker1008"/><span class="koboSpan" id="kobo.629.1">the communicating microservices are geographically distributed and are part of a WAN instead of a LAN, waiting for confirmation of the reception of an RPC message might be unacceptable for high-traffic microservices. </span><span class="koboSpan" id="kobo.629.2">In this case, it is better to rely on message brokers that support completely asynchronous communications.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.630.1">The </span><a id="_idIndexMarker1009"/><span class="koboSpan" id="kobo.631.1">gRPC protocol brings all the advantages of ProtoBuf to RPC since, by default, it is based on ProtoBuf. </span><span class="koboSpan" id="kobo.631.2">gRPC/ProtoBuf is a binary protocol that works over an HTTP/2 connection. </span><span class="koboSpan" id="kobo.631.3">It is worth pointing out that gRPC can’t work with HTTP versions less than 2. </span><span class="koboSpan" id="kobo.631.4">In the remainder of the chapter, we will always assume that gRPC uses ProtoBuf.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.632.1">gRPC uses </span><code class="inlineCode"><span class="koboSpan" id="kobo.633.1">.proto</span></code><span class="koboSpan" id="kobo.634.1"> files, but </span><a id="_idIndexMarker1010"/><span class="koboSpan" id="kobo.635.1">together with data, gRPC </span><code class="inlineCode"><span class="koboSpan" id="kobo.636.1">.proto</span></code><span class="koboSpan" id="kobo.637.1"> files also define services with their RPC methods. </span><span class="koboSpan" id="kobo.637.2">Here is a service definition:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.638.1">service Counter {
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.639.1">// Accepts a counting request</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.640.1">rpc </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.641.1">Count</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.642.1"> (</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.643.1">CountingRequest</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.644.1">) </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.645.1">returns</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.646.1"> (</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.647.1">CountingReply</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.648.1">)</span></span><span class="koboSpan" id="kobo.649.1">;
 </span><span class="hljs-comment"><span class="koboSpan" id="kobo.650.1">//Get current count for a given time slot</span></span>
<span class="hljs-function"><span class="koboSpan" id="kobo.651.1">rpc </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.652.1">GetCount</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.653.1"> (</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.654.1">TimeSlotRequest</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.655.1">) </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.656.1">returns</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.657.1"> (</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.658.1">TimeSlotDataReply</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.659.1">)</span></span><span class="koboSpan" id="kobo.660.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.661.1">Each service is introduced by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.662.1">service</span></code><span class="koboSpan" id="kobo.663.1"> keyword, while each method is introduced by the </span><code class="inlineCode"><span class="koboSpan" id="kobo.664.1">rpc</span></code><span class="koboSpan" id="kobo.665.1"> keyword. </span><span class="koboSpan" id="kobo.665.2">Each service specifies an input message and an output message. </span><span class="koboSpan" id="kobo.665.3">If either of these two messages is empty, we can use the predefined </span><code class="inlineCode"><span class="koboSpan" id="kobo.666.1">google.protobuf.Empty</span></code><span class="koboSpan" id="kobo.667.1"> message, as shown in the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.668.1">...
</span><span class="koboSpan" id="kobo.668.2">import </span><span class="hljs-string"><span class="koboSpan" id="kobo.669.1">"google/protobuf/empty.proto"</span></span><span class="koboSpan" id="kobo.670.1">;
...
</span><span class="koboSpan" id="kobo.670.2">service Counter {
  ...
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.671.1">rpc </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.672.1">AllSlots</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.673.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.674.1">google.protobuf.Empty</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.675.1">) </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.676.1">return</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.677.1"> (</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.678.1">AllDataReply</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.679.1">)</span></span><span class="koboSpan" id="kobo.680.1">;
}
</span></code></pre>
<p class="normal"><code class="inlineCode"><span class="koboSpan" id="kobo.681.1">.proto</span></code><span class="koboSpan" id="kobo.682.1"> files can be used to generate both server code and client code. </span><span class="koboSpan" id="kobo.682.2">In client code, each service is translated into a proxy class with the same methods declared in the service. </span><span class="koboSpan" id="kobo.682.3">Each of the proxy methods automatically invokes the remote service method and returns its result.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.683.1">The server code, instead, translates each service into an abstract class, whose virtual methods correspond to methods declared in the service. </span><span class="koboSpan" id="kobo.683.2">The developer is responsible for inheriting from this abstract class and providing implementations for all service methods.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.684.1">Below is an example of how to inherit from a similar class:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.685.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.686.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.687.1">CounterService</span></span><span class="koboSpan" id="kobo.688.1">: </span><span class="hljs-title"><span class="koboSpan" id="kobo.689.1">Counter.CounterBase</span></span><span class="koboSpan" id="kobo.690.1">
{
    ...
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.691.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.692.1">override</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.693.1">async</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.694.1">  Task&lt;CountingReply&gt; </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.695.1">Count</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.696.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.697.1">          CountingRequest request, ServerCallContext context</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.698.1">)</span></span><span class="koboSpan" id="kobo.699.1">
    {
        CountingReply reply =...
          </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.700.1">return</span></span><span class="koboSpan" id="kobo.701.1"> reply;
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.702.1">Each method</span><a id="_idIndexMarker1011"/><span class="koboSpan" id="kobo.703.1"> receives both the input message and a context object. </span><span class="koboSpan" id="kobo.703.2">Since gRPC services use ASP.NET Core infrastructure, the context object furnishes access to the request </span><code class="inlineCode"><span class="koboSpan" id="kobo.704.1">HttpContext</span></code><span class="koboSpan" id="kobo.705.1"> through </span><code class="inlineCode"><span class="koboSpan" id="kobo.706.1">context.GetHttpContext()</span></code><span class="koboSpan" id="kobo.707.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.708.1">An ASP.NET Core application is enabled to gRPC with </span><code class="inlineCode"><span class="koboSpan" id="kobo.709.1">builder.Services.AddGrpc()</span></code><span class="koboSpan" id="kobo.710.1"> and by declaring each service with something like </span><code class="inlineCode"><span class="koboSpan" id="kobo.711.1">app.MapGrpcService&lt;CounterService&gt;();</span></code><span class="koboSpan" id="kobo.712.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.713.1">More </span><a id="_idIndexMarker1012"/><span class="koboSpan" id="kobo.714.1">details on both gRPC servers and clients will be given while discussing the example in the </span><em class="italic"><span class="koboSpan" id="kobo.715.1">A worker microservice with ASP.NET core</span></em><span class="koboSpan" id="kobo.716.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.717.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.718.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.719.1">Services can receive as input and return continuous streams of data, where a long-term connection between the client and server is established. </span><span class="koboSpan" id="kobo.719.2">However, the usage of streams in microservices is not common since microservices are ephemeral processes that are frequently shut down and moved from one processing node to another by orchestrators, so long-term connections are not easy to maintain.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.720.1">Here is a service that accepts and returns a stream:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.721.1">service StreamExample {
  </span><span class="hljs-function"><span class="koboSpan" id="kobo.722.1">rpc </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.723.1">Echo</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.724.1"> (</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.725.1">stream MyMessage</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.726.1">) </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.727.1">returns</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.728.1"> (</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.729.1">stream MyMessage</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.730.1">)</span></span><span class="koboSpan" id="kobo.731.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.732.1">Each input stream is passed as an argument to the .NET implementation of the method. </span><span class="koboSpan" id="kobo.732.2">If the method returns</span><a id="_idIndexMarker1013"/><span class="koboSpan" id="kobo.733.1"> a stream, the .NET implementation of the method must return a </span><code class="inlineCode"><span class="koboSpan" id="kobo.734.1">Task</span></code><span class="koboSpan" id="kobo.735.1">, and also the output stream is passed as an argument to the method:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.736.1">public</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.737.1">override</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.738.1">async</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.739.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.740.1">Echo</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.741.1">(</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.742.1">     IAsyncStreamReader&lt;MyMessage&gt; requestStream</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.743.1">      IServerStreamWriter&lt;MyMessage&gt; responseStream,</span></span>
<span class="hljs-params"><span class="koboSpan" id="kobo.744.1">      ServerCallContext context</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.745.1">)</span></span><span class="koboSpan" id="kobo.746.1">{
     ...
          </span><span class="koboSpan" id="kobo.746.2">While(...)
          {
             </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.747.1">bool</span></span><span class="koboSpan" id="kobo.748.1"> inputFinished =  !</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.749.1">await</span></span><span class="koboSpan" id="kobo.750.1"> requestStream.MoveNext();
             </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.751.1">var</span></span><span class="koboSpan" id="kobo.752.1"> current = requestStream.Current;
             ...
             </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.753.1">await</span></span><span class="koboSpan" id="kobo.754.1"> responseStream.WriteAsync(result);
          }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.755.1">On the </span><a id="_idIndexMarker1014"/><span class="koboSpan" id="kobo.756.1">client side, both input and output streams are available in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.757.1">call</span></code><span class="koboSpan" id="kobo.758.1"> object that is returned when the proxy method is called without awaiting it, as shown in the following:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.759.1">var</span></span><span class="koboSpan" id="kobo.760.1"> call = client.Echo();
...
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.761.1">await</span></span><span class="koboSpan" id="kobo.762.1"> call.RequestStream.WriteAsync(...);
...
</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.763.1">bool</span></span><span class="koboSpan" id="kobo.764.1"> inputFinished =  ! </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.765.1">await</span></span><span class="koboSpan" id="kobo.766.1"> call.ResponseStream.MoveNext();
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.767.1">var</span></span><span class="koboSpan" id="kobo.768.1"> current = call.ResponseS.Current;
...
</span><span class="koboSpan" id="kobo.768.2">call.RequestStream.CompleteAsync();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.769.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.770.1">CompleteAsync()</span></code><span class="koboSpan" id="kobo.771.1"> method closes the request stream, declaring that the input is finished.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.772.1">More practical details on the client usage are given in the example in the </span><em class="italic"><span class="koboSpan" id="kobo.773.1">A worker microservice with ASP.NET core</span></em><span class="koboSpan" id="kobo.774.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.775.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.776.1">, while the </span><em class="italic"><span class="koboSpan" id="kobo.777.1">Further reading</span></em><span class="koboSpan" id="kobo.778.1"> section contains a link to the .NET gRPC official documentation.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.779.1">The next subsection describes how to implement data-driven asynchronous communication.</span></p>
<h2 class="heading-2" id="_idParaDest-292"><span class="koboSpan" id="kobo.780.1">Reliable data-driven asynchronous communication</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.781.1">Non-blocking </span><a id="_idIndexMarker1015"/><span class="koboSpan" id="kobo.782.1">communication must necessarily rely on non-volatile queues to decouple the sender thread from the receiving thread. </span><span class="koboSpan" id="kobo.782.2">Decoupling can be achieved with just one queue on each communication path, but sometimes additional queues improve </span><a id="_idIndexMarker1016"/><span class="koboSpan" id="kobo.783.1">performance and increase CPU usage. </span><span class="koboSpan" id="kobo.783.2">Queues, can be placed in three places: within the microservice that sends the message, within the microservice that receives the message, or outside both microservices using dedicated services known as message brokers. </span><span class="koboSpan" id="kobo.783.3">by using dedicated queuing services </span><a id="_idIndexMarker1017"/><span class="koboSpan" id="kobo.784.1">called </span><strong class="keyWord"><span class="koboSpan" id="kobo.785.1">message brokers</span></strong><span class="koboSpan" id="kobo.786.1">.</span></p>
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.787.1">Azure Service Bus</span></strong><span class="koboSpan" id="kobo.788.1">, which</span><a id="_idIndexMarker1018"/><span class="koboSpan" id="kobo.789.1"> we described in the </span><em class="italic"><span class="koboSpan" id="kobo.790.1">.NET communication facilities</span></em><span class="koboSpan" id="kobo.791.1"> subsection of </span><em class="italic"><span class="koboSpan" id="kobo.792.1">Chapter 11</span></em><span class="koboSpan" id="kobo.793.1">, </span><em class="italic"><span class="koboSpan" id="kobo.794.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.795.1">, is a message broker that, like most message brokers, offers queuing services and publisher/subscriber communication. </span><span class="koboSpan" id="kobo.795.2">In this chapter, we will also describe </span><strong class="keyWord"><span class="koboSpan" id="kobo.796.1">RabbitMQ</span></strong><span class="koboSpan" id="kobo.797.1">, which </span><a id="_idIndexMarker1019"/><span class="koboSpan" id="kobo.798.1">offers queuing services and publisher/subscriber communication that is broadly similar to </span><strong class="keyWord"><span class="koboSpan" id="kobo.799.1">Azure Service Bus</span></strong> <strong class="keyWord"><span class="koboSpan" id="kobo.800.1">topics</span></strong><span class="koboSpan" id="kobo.801.1">. </span><span class="koboSpan" id="kobo.801.2">Since it is easier to debug code that uses a local instance of RabbitMQ, often it is convenient to use RabbitMQ during development and then move to Azure Service Bus.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.802.1">Queues </span><a id="_idIndexMarker1020"/><span class="koboSpan" id="kobo.803.1">decouple the sender and receiver but do not ensure that messages are not lost. </span><span class="koboSpan" id="kobo.803.2">In the </span><em class="italic"><span class="koboSpan" id="kobo.804.1">Resilient task execution</span></em><span class="koboSpan" id="kobo.805.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.806.1">Chapter 11,</span></em><span class="koboSpan" id="kobo.807.1"> we have already discussed strategies for achieving reliable communication. </span><span class="koboSpan" id="kobo.807.2">Here we give more practical details for preventing message losses with confirmations and timeouts:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.808.1">Queues must be stored on permanent storage; otherwise, their content can be lost if the processes controlling them either crash or are shut down.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.809.1">If a confirmation that the message was successfully inserted in the queue doesn’t arrive within a timeout time, the source assumes that the message was lost and retries the operation.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.810.1">When a message is extracted from a queue, it remains blocked and inaccessible to other consumers. </span><span class="koboSpan" id="kobo.810.2">If a confirmation that the message has been successfully processed arrives within a timeout time, the message is removed from the queue; otherwise, it is unblocked and becomes available again to other consumers.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.811.1">All confirmations </span><a id="_idIndexMarker1021"/><span class="koboSpan" id="kobo.812.1">can be handled asynchronously with the exception of the insertion in the first queue of a communication path. </span><span class="koboSpan" id="kobo.812.2">In fact, if the sending code doesn’t remain blocked waiting for the confirmation but moves to further processing and the message is lost, there is no way to resend the message, since the message cannot be taken from any other queue.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.813.1">For this reason, sometimes microservices that use a message broker also have an internal queue. </span><span class="koboSpan" id="kobo.813.2">More specifically, the main microservice thread produces all messages and stores them in a local queue that can be implemented with a database table. </span><span class="koboSpan" id="kobo.813.3">Another thread takes care of extracting messages from this queue and sending them to the message broker. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.814.1">Messages that are removed from the local queue are blocked and removed only when an asynchronous confirmation arrives from the message broker. </span><span class="koboSpan" id="kobo.814.2">This technique is used in the example of </span><em class="italic"><span class="koboSpan" id="kobo.815.1">Chapter 18</span></em><span class="koboSpan" id="kobo.816.1">, </span><em class="italic"><span class="koboSpan" id="kobo.817.1">Implementing Frontend Microservices with ASP.NET Core</span></em><span class="koboSpan" id="kobo.818.1">. </span><span class="koboSpan" id="kobo.818.2">The main advantage of the local queue is that confirmation from a local queue usually arrives faster because there is less concurrency with other threads/processes (don’t forget that each microservice should have a private database/permanent storage), so the blocking time is more acceptable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.819.1">Using a </span><a id="_idIndexMarker1022"/><span class="koboSpan" id="kobo.820.1">queue inside each receiver is a viable alternative to message brokers. </span><span class="koboSpan" id="kobo.820.2">The main advantage of private queues is that the process that handles the queue is not shared among several microservices, so all queue operations are faster. </span><span class="koboSpan" id="kobo.820.3">In particular, the confirmation of each insertion is immediate, so the sender can use a blocking RPC call to send the message. </span><span class="koboSpan" id="kobo.820.4">However, this simple solution has the following disadvantages:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.821.1">There is no way to implement the publisher/subscriber pattern.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.822.1">Just one microservice instance can extract messages from the queue. </span><span class="koboSpan" id="kobo.822.2">Therefore, microservices can’t be scaled horizontally. </span><span class="koboSpan" id="kobo.822.3">Limited vertical scaling can be achieved by increasing the number of processor cores and by processing queue messages with parallel threads.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.823.1">A similar approach can be efficiently implemented with gRPC and ASP.NET Core as follows:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.824.1">The sender sends the message to a gRPC method.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.825.1">The gRPC method just enqueues the message and immediately returns a confirmation to the sender.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.826.1">An ASP.NET Core hosted process takes care of extracting the messages from the queue and passing them to several parallel threads.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.827.1">When a message is passed to a thread, it remains blocked and inaccessible. </span><span class="koboSpan" id="kobo.827.2">It is removed only after the thread confirms that the message has been successfully processed. </span><span class="koboSpan" id="kobo.827.3">If, instead, a thread reports a failure, the corresponding message is unblocked so it can be passed to another thread.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.828.1">ASP.NET Core threads</span><a id="_idIndexMarker1023"/><span class="koboSpan" id="kobo.829.1"> take care of the necessary input parallelism. </span><span class="koboSpan" id="kobo.829.2">Some horizontal parallelism can be achieved by using load balancers and several web servers. </span><span class="koboSpan" id="kobo.829.3">However, in this case, either all the web servers use the same database, thus increasing the concurrency on the queue, or we use several sharded databases.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.830.1">This approach is described in more detail in the example in the </span><em class="italic"><span class="koboSpan" id="kobo.831.1">Implementing worker microservices with ASP.NET core </span></em><span class="koboSpan" id="kobo.832.1">section. </span><span class="koboSpan" id="kobo.832.2">As we will see, it is simple to implement and ensures good response time, but due to its limited scalability, it is adequate just for small or medium-sized applications with low to medium traffic.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.833.1">If, for </span><a id="_idIndexMarker1024"/><span class="koboSpan" id="kobo.834.1">some reason, either an insertion in a queue or the processing of a message extracted by a queue requires more time than the timeout time, the operation is repeated so that the same message is processed twice. </span><span class="koboSpan" id="kobo.834.2">Therefore, messages must be idempotent, meaning processing them once or several times must have the same effect. </span><span class="koboSpan" id="kobo.834.3">Record updates and deletions are intrinsically idempotent since repeating an update or a deletion several times doesn’t change the result, but record additions are not.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.835.1">Idempotency can always be forced by assigning a unique identifier to messages and then storing the identifiers of the already processed messages. </span><span class="koboSpan" id="kobo.835.2">This way, each incoming message can be discarded when its identifier is found among the identifiers of the already processed messages. </span><span class="koboSpan" id="kobo.835.3">We will use this technique in all examples in this chapter.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.836.1">Queues, confirmations, and message resends ensure that requests to a single microservice are safely processed, but how can we handle requests that involve several cooperating microservices? </span><span class="koboSpan" id="kobo.836.2">We will discover that in the next subsection. </span><span class="koboSpan" id="kobo.836.3">There, we will explain how distributed microservices can coordinate and reach agreements to yield coherent behavior with only the help of asynchronous communication.</span></p>
<h2 class="heading-2" id="_idParaDest-293"><span class="koboSpan" id="kobo.837.1">Distributed transactions</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.838.1">Everyone knows</span><a id="_idIndexMarker1025"/><span class="koboSpan" id="kobo.839.1"> what a database transaction is: several records are modified one after the other, but if a single action fails, all previous modifications are also undone before aborting the transaction. </span><span class="koboSpan" id="kobo.839.2">That is, either all operations succeed or they fail simultaneously.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.840.1">A distributed transaction</span><a id="_idIndexMarker1026"/><span class="koboSpan" id="kobo.841.1"> does the same job, but in this case, the records are not part of a single database but are distributed among the databases associated with several cooperating microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.842.1">The reliable data-driven communication techniques described so far are the building blocks for solving more complex cooperation problems.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.843.1">Let’s suppose that a user operation triggers processing and storage in several related microservices. </span><span class="koboSpan" id="kobo.843.2">The user operation can be considered successfully completed only if all involved processing/storage operations succeed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.844.1">Moreover, if a single processing/storage operation also fails for some fundamental reason, retrying the failed operation doesn’t help. </span><span class="koboSpan" id="kobo.844.2">Think, for instance, of a purchase that fails because the user has not got enough funds to complete the payment: the only way out is to undo all the operations that have already been performed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.845.1">In general, similar situations must be handled in a transactional way; either all operations are performed, or no operation is performed. </span><span class="koboSpan" id="kobo.845.2">Transactions that span several microservices are known as </span><strong class="keyWord"><span class="koboSpan" id="kobo.846.1">distributed transactions</span></strong><span class="koboSpan" id="kobo.847.1">. </span><span class="koboSpan" id="kobo.847.2">In theory, </span><strong class="keyWord"><span class="koboSpan" id="kobo.848.1">distributed transactions</span></strong><span class="koboSpan" id="kobo.849.1"> can be handled with the following two-stage protocol:</span></p>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.850.1">In the first stage, all operations are executed, each one in the scope of a local transaction (for instance, within the scope of each microservice database transaction). </span><span class="koboSpan" id="kobo.850.2">The success or failure of each operation is then returned to a transaction coordinator.</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.851.1">In the second stage, the transaction coordinator informs all microservices of the success or failure of the overall operation. </span><span class="koboSpan" id="kobo.851.2">In the case of failure, all local transactions are rolled back; otherwise, they are committed.</span></li>
</ol>
<p class="normal"><span class="koboSpan" id="kobo.852.1">When</span><a id="_idIndexMarker1027"/><span class="koboSpan" id="kobo.853.1"> using asynchronous messages, confirmations may arrive after quite a large amount of time and may interleave with other transactions performed on the same resources. </span><span class="koboSpan" id="kobo.853.2">Therefore, having all local resources blocked by a local transaction during a possibly time-consuming distributed transaction is not acceptable.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.854.1">For this reason, microservices transactions use the </span><strong class="keyWord"><span class="koboSpan" id="kobo.855.1">saga</span></strong><span class="koboSpan" id="kobo.856.1"> pattern: all local operations are performed without opening a local transaction, and in the case of failure, they are compensated by other operations that undo the initial operations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.857.1">Undoing a </span><a id="_idIndexMarker1028"/><span class="koboSpan" id="kobo.858.1">database insertion is quite easy since it is enough to remove the added item, but undoing modifications and deletes is quite difficult and requires the storage of additional information. </span><span class="koboSpan" id="kobo.858.2">The general solution to this problem is storing records that represent all database changes in a table. </span><span class="koboSpan" id="kobo.858.3">These records can be used to compute a compensation operation or to restore the previous database state starting from a reference database state. </span><span class="koboSpan" id="kobo.858.4">We already discussed this storage technique, which </span><a id="_idIndexMarker1029"/><span class="koboSpan" id="kobo.859.1">is called </span><strong class="keyWord"><span class="koboSpan" id="kobo.860.1">event sourcing</span></strong><span class="koboSpan" id="kobo.861.1">, in the </span><em class="italic"><span class="koboSpan" id="kobo.862.1">Event sourcing</span></em><span class="koboSpan" id="kobo.863.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.864.1">Chapter 7</span></em><span class="koboSpan" id="kobo.865.1">, </span><em class="italic"><span class="koboSpan" id="kobo.866.1">Understanding the Different Domains in Software Solutions</span></em><span class="koboSpan" id="kobo.867.1">. </span><span class="koboSpan" id="kobo.867.2">Just to recap, and in a few words, each database stores not only the actual state but also the history of all changes up to a certain previous time.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.868.1">When a saga transaction is undone, if other saga transactions depend on the undone changes, we must also undo them. </span><span class="koboSpan" id="kobo.868.2">For instance, suppose that an accepted purchase order depends on the funds uploaded by a user on an e-commerce platform. </span><span class="koboSpan" id="kobo.868.3">Then, if the funds upload transaction is undone, the purchase must also be undone.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.869.1">In order to </span><a id="_idIndexMarker1030"/><span class="koboSpan" id="kobo.870.1">avoid similar chain reactions when a</span><a id="_idIndexMarker1031"/><span class="koboSpan" id="kobo.871.1"> saga transaction is undone, often new transactions are accepted only if they depend on changes that took place before a certain safety interval. </span><span class="koboSpan" id="kobo.871.2">Thus, for instance, uploaded funds are made available only after, say, 5-10 minutes, because it is very unlikely that a transaction will be undone after more than 5-10 minutes.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.872.1">Saga transactions may use two fundamental techniques:</span></p>
<ul>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.873.1">Orchestration</span></strong><span class="koboSpan" id="kobo.874.1">: When </span><a id="_idIndexMarker1032"/><span class="koboSpan" id="kobo.875.1">the transaction starts, an orchestrator component is created that takes care of sending the necessary messages to all involved microservices and receiving their success/failure messages. </span><span class="koboSpan" id="kobo.875.2">This technique is easy to implement but creates dependencies between the software lifetimes of the involved microservices since the orchestrator must depend on the details of all microservices involved in the saga. </span><span class="koboSpan" id="kobo.875.3">Moreover, this technique may have poor performance since the orchestrator becomes a bottleneck.</span></li>
<li class="bulletList"><strong class="keyWord"><span class="koboSpan" id="kobo.876.1">Choreography</span></strong><span class="koboSpan" id="kobo.877.1">: There</span><a id="_idIndexMarker1033"/><span class="koboSpan" id="kobo.878.1"> is no centralized control of the transaction but each microservice is invoked by a different sending microservice and forwards the success/failure messages it receives to other communication neighbors. </span><span class="koboSpan" id="kobo.878.2">Choreography overcomes the disadvantages</span><a id="_idIndexMarker1034"/><span class="koboSpan" id="kobo.879.1"> of orchestration but it is more difficult to implement and test.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.880.1">The following table </span><a id="_idIndexMarker1035"/><span class="koboSpan" id="kobo.881.1">summarizes the pros and cons of the two techniques.</span></p>
<table class="table-container" id="table003">
<tbody>
<tr>
<td class="table-cell"/>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.882.1">Code maintainability</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.883.1">Difficulties in designing and debugging</span></strong></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.884.1">Choreography</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.885.1">Good</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.886.1">Quite high</span></p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal"><strong class="keyWord"><span class="koboSpan" id="kobo.887.1">Orchestration</span></strong></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.888.1">Low</span></p>
</td>
<td class="table-cell">
<p class="normal"><span class="koboSpan" id="kobo.889.1">No particular difficulty</span></p>
</td>
</tr>
</tbody>
</table>
<p class="packt_figref"><span class="koboSpan" id="kobo.890.1">Table 14.3: Pros and cons of choreography and orchestration</span></p>
<h1 class="heading-1" id="_idParaDest-294"><span class="koboSpan" id="kobo.891.1">Implementing worker microservices with ASP.NET Core</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.892.1">In order to</span><a id="_idIndexMarker1036"/><span class="koboSpan" id="kobo.893.1"> avoid blocking the caller’s synchronous request for too much time, an ASP.NET Core-based solution</span><a id="_idIndexMarker1037"/><span class="koboSpan" id="kobo.894.1"> requires the implementation of an internal queue where it can store all received messages. </span><span class="koboSpan" id="kobo.894.2">This way, when a message is received, it is immediately enqueued without processing it, so that a “received” response can be immediately returned.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.895.1">Therefore, the application level needs a repository interface that handles the queue. </span><span class="koboSpan" id="kobo.895.2">Here is a possible definition of this interface:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.896.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.897.1">interface</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.898.1">IMessageQueue</span></span><span class="koboSpan" id="kobo.899.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.900.1">public</span></span><span class="koboSpan" id="kobo.901.1"> Task&lt;IList&lt;QueueItem&gt;&gt; Top(</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.902.1">int</span></span><span class="koboSpan" id="kobo.903.1"> n);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.904.1">public</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.905.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.906.1">Dequeue</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.907.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.908.1">IEnumerable&lt;QueueItem&gt; items</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.909.1">)</span></span><span class="koboSpan" id="kobo.910.1">;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.911.1">public</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.912.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.913.1">Enqueue</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.914.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.915.1">QueueItem item</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.916.1">)</span></span><span class="koboSpan" id="kobo.917.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.918.1">Where:</span></p>
<ul>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.919.1">QueueItem</span></code><span class="koboSpan" id="kobo.920.1"> is a class that contains all request information</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.921.1">Enqueue</span></code><span class="koboSpan" id="kobo.922.1"> adds a new message to the queue</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.923.1">Top</span></code><span class="koboSpan" id="kobo.924.1"> returns the first </span><code class="inlineCode"><span class="koboSpan" id="kobo.925.1">n</span></code><span class="koboSpan" id="kobo.926.1"> queue items without removing them from the queue</span></li>
<li class="bulletList"><code class="inlineCode"><span class="koboSpan" id="kobo.927.1">Dequeue</span></code><span class="koboSpan" id="kobo.928.1"> removes the first </span><code class="inlineCode"><span class="koboSpan" id="kobo.929.1">n</span></code><span class="koboSpan" id="kobo.930.1"> messages from the queue</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.931.1">The actual implementation of the preceding interface can be based on a database table, or any other storage media.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.932.1">The </span><a id="_idIndexMarker1038"/><span class="koboSpan" id="kobo.933.1">application level can be </span><a id="_idIndexMarker1039"/><span class="koboSpan" id="kobo.934.1">implemented with an ASP.NET Core gRPC project that organizes all the gRPC stuff for you:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.935.1"><img alt="" role="presentation" src="../Images/B19820_14_03.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.936.1">Figure 14.3: Creating a gRPC Server project</span></p>
<p class="normal"><span class="koboSpan" id="kobo.937.1">The actual request processing is performed by a worker-hosted service that runs in parallel with the ASP.NET Core pipeline. </span><span class="koboSpan" id="kobo.937.2">It is implemented with the hosted services we discussed in the </span><em class="italic"><span class="koboSpan" id="kobo.938.1">Using generic hosts</span></em><span class="koboSpan" id="kobo.939.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.940.1">Chapter 11</span></em><span class="koboSpan" id="kobo.941.1">, </span><em class="italic"><span class="koboSpan" id="kobo.942.1">Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.943.1">. </span><span class="koboSpan" id="kobo.943.2">It is worth recalling that hosted services are implementations of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.944.1">IHostedService</span></code><span class="koboSpan" id="kobo.945.1"> interface defined in the dependency injection engine as follows:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="koboSpan" id="kobo.946.1">builder.Services.AddHostedService&lt;MyHostedService&gt;();
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.947.1">Being defined in the dependency injection engine, they are automatically injected services in their constructors. </span><span class="koboSpan" id="kobo.947.2">Hosted services are used to execute parallel threads that run independently of the remainder of the application. </span><span class="koboSpan" id="kobo.947.3">Usually, they are not defined by directly implementing the </span><code class="inlineCode"><span class="koboSpan" id="kobo.948.1">IHostedService</span></code><span class="koboSpan" id="kobo.949.1"> interface, but by inheriting from the abstract </span><code class="inlineCode"><span class="koboSpan" id="kobo.950.1">BackgroundService</span></code><span class="koboSpan" id="kobo.951.1"> class and overriding its </span><code class="inlineCode"><span class="koboSpan" id="kobo.952.1">Task ExecuteAsync(CancellationToken token)</span></code><span class="koboSpan" id="kobo.953.1"> abstract method.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.954.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.955.1">ExecuteAsync</span></code><span class="koboSpan" id="kobo.956.1"> method usually contains an endless loop that exits only when the application is shut down. </span><span class="koboSpan" id="kobo.956.2">This endless loop defines the behavior of a worker-hosted service that repeats a certain task. </span><span class="koboSpan" id="kobo.956.3">In our case, the task to repeat is the continuous extraction and processing of </span><code class="inlineCode"><span class="koboSpan" id="kobo.957.1">N</span></code><span class="koboSpan" id="kobo.958.1"> items from the queue.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.959.1">Here is a possible implementation of our hosted service:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.960.1">public</span></span> <span class="hljs-keyword"><span class="koboSpan" id="kobo.961.1">class</span></span> <span class="hljs-title"><span class="koboSpan" id="kobo.962.1">ProcessPurchases</span></span><span class="koboSpan" id="kobo.963.1"> : </span><span class="hljs-title"><span class="koboSpan" id="kobo.964.1">BackgroundService</span></span><span class="koboSpan" id="kobo.965.1">
{
    IServiceProvider services;
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.966.1">public</span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="koboSpan" id="kobo.967.1">ProcessPurchases</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.968.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.969.1">IServiceProvider services</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.970.1">)</span></span><span class="koboSpan" id="kobo.971.1">
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.972.1">this</span></span><span class="koboSpan" id="kobo.973.1">.services = services;
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.974.1">protected</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.975.1">override</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.976.1">async</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.977.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.978.1">ExecuteAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.979.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.980.1">CancellationToken stoppingToken</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.981.1">)</span></span><span class="koboSpan" id="kobo.982.1">
    {
        </span><span class="hljs-built_in"><span class="koboSpan" id="kobo.983.1">bool</span></span><span class="koboSpan" id="kobo.984.1"> queueEmpty = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.985.1">false</span></span><span class="koboSpan" id="kobo.986.1">;
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.987.1">while</span></span><span class="koboSpan" id="kobo.988.1"> (!stoppingToken.IsCancellationRequested)
        {
           </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.989.1">while</span></span><span class="koboSpan" id="kobo.990.1"> (!queueEmpty &amp;&amp; !stoppingToken.IsCancellationRequested)
           {
             ...
           </span><span class="koboSpan" id="kobo.990.2">}
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.991.1">await</span></span><span class="koboSpan" id="kobo.992.1"> Task.Delay(</span><span class="hljs-number"><span class="koboSpan" id="kobo.993.1">100</span></span><span class="koboSpan" id="kobo.994.1">, stoppingToken);
            queueEmpty = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.995.1">false</span></span><span class="koboSpan" id="kobo.996.1">;
        }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.997.1">The </span><a id="_idIndexMarker1040"/><span class="koboSpan" id="kobo.998.1">class constructor is not injected with the specific services it needs but instead has the </span><code class="inlineCode"><span class="koboSpan" id="kobo.999.1">IServiceProvider</span></code><span class="koboSpan" id="kobo.1000.1"> that can be </span><a id="_idIndexMarker1041"/><span class="koboSpan" id="kobo.1001.1">used to get any service defined in the dependency injection engine. </span><span class="koboSpan" id="kobo.1001.2">The reason for this choice is that it will launch several threads (one for each of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1002.1">N</span></code><span class="koboSpan" id="kobo.1003.1"> messages extracted from the queue), and, in general, different threads can’t share the same service instance.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1004.1">The problem is caused by services with a session scope. </span><span class="koboSpan" id="kobo.1004.2">Usually, these services are not designed to be thread-safe since the single session-scoped instance used throughout a whole ASP.NET Core request is never shared among parallel threads. </span><span class="koboSpan" id="kobo.1004.3">However, we are not going to use our services from within the usual ASP.NET Core pipeline but from within parallel threads launched by our hosted service. </span><span class="koboSpan" id="kobo.1004.4">Therefore, we need a different session scope for each parallel thread. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1005.1">Thus, the right way to process is to use </span><code class="inlineCode"><span class="koboSpan" id="kobo.1006.1">IServiceProvider</span></code><span class="koboSpan" id="kobo.1007.1"> to create each necessary scope and then use each scope to get a different instance for each parallel thread.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1008.1">The inner </span><code class="inlineCode"><span class="koboSpan" id="kobo.1009.1">while</span></code><span class="koboSpan" id="kobo.1010.1"> loop runs until the queue is empty, then the worker thread sleeps for 100 milliseconds and then tries the inner loop again to see if in the meantime some new message reached the queue.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1011.1">When the application is shut down, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1012.1">stoppingToken</span></code> <code class="inlineCode"><span class="koboSpan" id="kobo.1013.1">CancellationToken</span></code><span class="koboSpan" id="kobo.1014.1"> is signaled and both loops exit, so that the whole </span><code class="inlineCode"><span class="koboSpan" id="kobo.1015.1">ExecuteAsync</span></code><span class="koboSpan" id="kobo.1016.1"> method exits and the worker thread dies.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1017.1">Here is</span><a id="_idIndexMarker1042"/><span class="koboSpan" id="kobo.1018.1"> the content of the </span><a id="_idIndexMarker1043"/><span class="koboSpan" id="kobo.1019.1">inner loop:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1020.1">using</span></span><span class="koboSpan" id="kobo.1021.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1022.1">var</span></span><span class="koboSpan" id="kobo.1023.1"> scope = services.CreateScope())
{
    IMessageQueue queue = scope.ServiceProvider.GetRequiredService&lt;IMessageQueue&gt;();
                   
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1024.1">var</span></span><span class="koboSpan" id="kobo.1025.1"> toProcess = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1026.1">await</span></span><span class="koboSpan" id="kobo.1027.1"> queue.Top(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1028.1">10</span></span><span class="koboSpan" id="kobo.1029.1">);
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1030.1">if</span></span><span class="koboSpan" id="kobo.1031.1"> (toProcess.Count &gt; </span><span class="hljs-number"><span class="koboSpan" id="kobo.1032.1">0</span></span><span class="koboSpan" id="kobo.1033.1">)
    {
        Task&lt;QueueItem?&gt;[] tasks = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1034.1">new</span></span><span class="koboSpan" id="kobo.1035.1"> Task&lt;QueueItem?&gt;[toProcess.Count];
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1036.1">for</span></span><span class="koboSpan" id="kobo.1037.1"> (</span><span class="hljs-built_in"><span class="koboSpan" id="kobo.1038.1">int</span></span><span class="koboSpan" id="kobo.1039.1"> i = </span><span class="hljs-number"><span class="koboSpan" id="kobo.1040.1">0</span></span><span class="koboSpan" id="kobo.1041.1">; i &lt; tasks.Length; i++)
        {
            tasks[i] = toExecute();
        }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1042.1">await</span></span><span class="koboSpan" id="kobo.1043.1"> Task.WhenAll(tasks);
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1044.1">await</span></span><span class="koboSpan" id="kobo.1045.1"> queue.Dequeue(tasks.Select(m =&gt; m.Result)
           .Where(m =&gt; m != </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1046.1">null</span></span><span class="koboSpan" id="kobo.1047.1">).OfType&lt;QueueItem&gt;());
    }
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1048.1">else</span></span><span class="koboSpan" id="kobo.1049.1"> queueEmpty = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1050.1">true</span></span><span class="koboSpan" id="kobo.1051.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1052.1">A session scope surrounds the whole code since we need a unique instance of </span><code class="inlineCode"><span class="koboSpan" id="kobo.1053.1">IMessageQueue</span></code><span class="koboSpan" id="kobo.1054.1"> to manipulate the queue.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1055.1">The code tries to extract </span><code class="inlineCode"><span class="koboSpan" id="kobo.1056.1">N</span></code><span class="koboSpan" id="kobo.1057.1"> messages from the queue. </span><span class="koboSpan" id="kobo.1057.2">If no message is found, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1058.1">queueEmpty</span></code><span class="koboSpan" id="kobo.1059.1"> is set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1060.1">true</span></code><span class="koboSpan" id="kobo.1061.1">, so that the inner loop exits; otherwise, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1062.1">for</span></code><span class="koboSpan" id="kobo.1063.1"> loop creates a separate task for each extracted request and inserts it in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1064.1">tasks</span></code><span class="koboSpan" id="kobo.1065.1"> array.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1066.1">Then, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1067.1">Task.WhenAll</span></code><span class="koboSpan" id="kobo.1068.1"> awaits all tasks. </span><span class="koboSpan" id="kobo.1068.2">Finally, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1069.1">queue.Dequeue</span></code><span class="koboSpan" id="kobo.1070.1"> removes from the queue all not-null requests returned from the tasks. </span><span class="koboSpan" id="kobo.1070.2">Since a not-null request is returned only in the case of successful processing, </span><code class="inlineCode"><span class="koboSpan" id="kobo.1071.1">queue.Dequeue</span></code><span class="koboSpan" id="kobo.1072.1"> removes just the successfully processed requests.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1073.1">The </span><code class="inlineCode"><span class="koboSpan" id="kobo.1074.1">toExecute</span></code><span class="koboSpan" id="kobo.1075.1"> method performs the actual request processing that depends on the specific application.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1076.1">A complete example containing all details and a step-by-step guide to its practical implementation is described in the</span><em class="italic"><span class="koboSpan" id="kobo.1077.1"> A worker microservice with ASP.NET Core</span></em><span class="koboSpan" id="kobo.1078.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.1079.1">Chapter 21, Case Study</span></em><span class="koboSpan" id="kobo.1080.1">. </span><span class="koboSpan" id="kobo.1080.2">The complete source code of the example is contained in the folder</span><a id="_idIndexMarker1044"/><span class="koboSpan" id="kobo.1081.1"> associated with this chapter</span><a id="_idIndexMarker1045"/><span class="koboSpan" id="kobo.1082.1"> in the book’s GitHub repository.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1083.1">The next section shows you how to modify the code of this example to use queued communication based on the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1084.1">RabbitMQ</span></strong><span class="koboSpan" id="kobo.1085.1"> message broker.</span></p>
<h1 class="heading-1" id="_idParaDest-295"><span class="koboSpan" id="kobo.1086.1">Implementing microservices with .NET worker services and message brokers</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1087.1">This </span><a id="_idIndexMarker1046"/><span class="koboSpan" id="kobo.1088.1">section explains the modifications needed to use a message broker instead of gRPC communication with an internal queue. </span><span class="koboSpan" id="kobo.1088.2">This kind of solution is usually more difficult to test and design but allows for better horizontal scaling.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1089.1">The message broker used in the code</span><a id="_idIndexMarker1047"/><span class="koboSpan" id="kobo.1090.1"> is </span><strong class="keyWord"><span class="koboSpan" id="kobo.1091.1">RabbitMQ</span></strong><span class="koboSpan" id="kobo.1092.1">. </span><span class="koboSpan" id="kobo.1092.2">However, we could also replace it </span><a id="_idIndexMarker1048"/><span class="koboSpan" id="kobo.1093.1">with </span><strong class="keyWord"><span class="koboSpan" id="kobo.1094.1">Azure Service Bus </span></strong><span class="koboSpan" id="kobo.1095.1">using the code available in the GitHub repository associated with the book. </span><span class="koboSpan" id="kobo.1095.2">The next subsection explains how to install RabbitMQ on your development machine. </span><span class="koboSpan" id="kobo.1095.3">We used RabbitMQ to give the reader the opportunity to install and study it, since Azure Service Bus needs less configuration and is immediately ready to use. </span><span class="koboSpan" id="kobo.1095.4">In an actual production system, one might choose RabbitMQ, just so you are not tied to a specific cloud provider, because while Azure Service Bus is available just on Azure, RabbitMQ can be installed in any cloud or on-premises environment.</span></p>
<h2 class="heading-2" id="_idParaDest-296"><span class="koboSpan" id="kobo.1096.1">Installing RabbitMQ</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1097.1">Before</span><a id="_idIndexMarker1049"/><span class="koboSpan" id="kobo.1098.1"> installing </span><strong class="keyWord"><span class="koboSpan" id="kobo.1099.1">RabbitMQ,</span></strong><span class="koboSpan" id="kobo.1100.1"> you need to install </span><strong class="keyWord"><span class="koboSpan" id="kobo.1101.1">Erlang</span></strong><span class="koboSpan" id="kobo.1102.1"> from the link given in the </span><em class="italic"><span class="koboSpan" id="kobo.1103.1">Technical requirements</span></em><span class="koboSpan" id="kobo.1104.1"> section. </span><span class="koboSpan" id="kobo.1104.2">Just download and execute the installer from an administrative account. </span><span class="koboSpan" id="kobo.1104.3">After that, you can download and install RabbitMQ from the link in the </span><em class="italic"><span class="koboSpan" id="kobo.1105.1">Technical requirements</span></em><span class="koboSpan" id="kobo.1106.1"> section.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1107.1">If installation is successful, you should find a service called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1108.1">RabbitMQ</span></strong><span class="koboSpan" id="kobo.1109.1"> among your machine’s Windows services. </span><span class="koboSpan" id="kobo.1109.2">If either you don’t find it or it is not running, restart your computer.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1110.1">Administrative commands can be issued to RabbitMQ from the command prompt, which you can find in the </span><strong class="keyWord"><span class="koboSpan" id="kobo.1111.1">RabbitMQ Server</span></strong><span class="koboSpan" id="kobo.1112.1"> Windows menu folder.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1113.1">You can also enable a web-based administrative UI. </span><span class="koboSpan" id="kobo.1113.2">Let’s open the RabbitMQ command prompt and issue the following command:</span></p>
<pre class="programlisting con"><code class="hljs-con"><span class="koboSpan" id="kobo.1114.1">rabbitmq-plugins enable rabbitmq_management
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1115.1">Then, go to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1116.1">http://localhost:15672</span></code><span class="koboSpan" id="kobo.1117.1">. </span><span class="koboSpan" id="kobo.1117.2">You will be prompted for a username and password. </span><span class="koboSpan" id="kobo.1117.3">Initially, they are both set to </span><strong class="keyWord"><span class="koboSpan" id="kobo.1118.1">guest</span></strong><span class="koboSpan" id="kobo.1119.1">. </span><span class="koboSpan" id="kobo.1119.2">From there, you may inspect all active connections </span><a id="_idIndexMarker1050"/><span class="koboSpan" id="kobo.1120.1">and channels and all communication queues that have been created. </span><span class="koboSpan" id="kobo.1120.2">The queues page contains all queues that have been defined. </span><span class="koboSpan" id="kobo.1120.3">By clicking on each of them, you move to a queue-specific page where you can inspect the queue content and perform various operations on the specific queue.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1121.1">The next subsection contains a short survey of RabbitMQ features.</span></p>
<h2 class="heading-2" id="_idParaDest-297"><span class="koboSpan" id="kobo.1122.1">RabbitMQ basics</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1123.1">Natively, RabbitMQ </span><a id="_idIndexMarker1051"/><span class="koboSpan" id="kobo.1124.1">supports the AMQP asynchronous message protocol, which is one of the most used asynchronous protocols, the other being MQTT, which has a specific syntax for the publisher/subscriber pattern. </span></p>
<p class="normal"><span class="koboSpan" id="kobo.1125.1">Support for MQTT can be added with a plugin, but RabbitMQ has facilities for implementing easily a publisher/subscriber pattern on top of AMQP. </span><span class="koboSpan" id="kobo.1125.2">Moreover, RabbitMQ offers several tools to support scalability, disaster recovery, and redundancy, so it fulfills all requirements to be a first-class actor in cloud and microservices environments. </span><span class="koboSpan" id="kobo.1125.3">More specifically, it supports data replication like most SQL and NoSQL databases and also supports cooperation among several servers based on sophisticated and flexible techniques. </span><span class="koboSpan" id="kobo.1125.4">For lack of space, in this section, we will describe just RabbitMQ’s basic operations, but the reader can find more details in the tutorials and </span><a id="_idIndexMarker1052"/><span class="koboSpan" id="kobo.1126.1">documentation of RabbitMQ’s official website: </span><a href="https://www.rabbitmq.com/"><span class="url"><span class="koboSpan" id="kobo.1127.1">https://www.rabbitmq.com/</span></span></a><span class="koboSpan" id="kobo.1128.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1129.1">RabbitMQ messages must be prepared in binary format since RabbitMQ messages must be just an array of bytes. </span><span class="koboSpan" id="kobo.1129.2">Therefore, we need to serialize .NET objects with a binary formatter before sending them. </span><span class="koboSpan" id="kobo.1129.3">In the example in this section, we will test both the ProtoBuf serializer and a fast .NET-specific serializer called </span><em class="italic"><span class="koboSpan" id="kobo.1130.1">Binaron</span></em><span class="koboSpan" id="kobo.1131.1">. </span><span class="koboSpan" id="kobo.1131.2">It might also be possible to use a JSON serializer to ensure better compatibility if there are compatibility issues among microservices implemented with different frameworks by different teams, and/or if there are legacy microservices. </span><span class="koboSpan" id="kobo.1131.3">It is worth recalling that JSON is usually more compatible but less efficient, while binary formats are less compatible. </span><span class="koboSpan" id="kobo.1131.4">ProtoBuf tries to solve the binary compatibility issue by defining a universal binary language, but it is not an official standard but a de facto standard.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1132.1">Messages </span><a id="_idIndexMarker1053"/><span class="koboSpan" id="kobo.1133.1">are not sent directly to queues, but to other entities called </span><strong class="keyWord"><span class="koboSpan" id="kobo.1134.1">exchanges</span></strong><span class="koboSpan" id="kobo.1135.1"> that </span><a id="_idIndexMarker1054"/><span class="koboSpan" id="kobo.1136.1">route them to queues. </span><span class="koboSpan" id="kobo.1136.2">Exchanges are AMQP-specific concepts, and are RabbitMQ’s way of configuring complex communication protocols like the publisher/subscriber protocol.</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1137.1"><img alt="" role="presentation" src="../Images/B19820_14_04.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1138.1">Figure 14.4: RabbitMQ exchanges</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1139.1">To adequately define the exchange routing strategy, we can implement several patterns. </span><span class="koboSpan" id="kobo.1139.2">More specifically:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1140.1">When we use a default exchange, the message is sent to a single queue and we can implement asynchronous direct calls.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1141.1">When we use a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1142.1">fanout</span></code><span class="koboSpan" id="kobo.1143.1"> exchange, the exchange will send the message to all queues that subscribe to that exchange. </span><span class="koboSpan" id="kobo.1143.2">This way, we can implement the publisher/subscriber pattern. </span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1144.1">There is also a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1145.1">topic</span></code><span class="koboSpan" id="kobo.1146.1"> exchange that enhances the publisher/subscriber pattern by enabling the matching of several events with wildcard chars. </span><span class="koboSpan" id="kobo.1146.2">However, it is not usually needed in microservices for enterprise applications.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1147.1">Our examples </span><a id="_idIndexMarker1055"/><span class="koboSpan" id="kobo.1148.1">will describe just direct calls, but the </span><em class="italic"><span class="koboSpan" id="kobo.1149.1">Further reading</span></em><span class="koboSpan" id="kobo.1150.1"> section contains a link to RabbitMQ tutorials that show examples of publisher/subscriber implementations.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1151.1">The next section explains how to modify the code in the previous section to use RabbitMQ-based direct communication.</span></p>
<h2 class="heading-2" id="_idParaDest-298"><span class="koboSpan" id="kobo.1152.1">Replacing internal queues with RabbitMQ</span></h2>
<p class="normal"><span class="koboSpan" id="kobo.1153.1">As</span><a id="_idIndexMarker1056"/><span class="koboSpan" id="kobo.1154.1"> previously discussed, in high-traffic WAN networks also receiving a synchronous received-message acknowledgment has an unacceptable performance impact, so no RPC protocol can be used. </span><span class="koboSpan" id="kobo.1154.2">Moreover, often microservices use the publisher/subscriber pattern to achieve the best decoupling. </span><span class="koboSpan" id="kobo.1154.3">In these cases, using a message broker is a MUST. </span><span class="koboSpan" id="kobo.1154.4">Finally, having all queues handled by a unique scalable broker enables the independent and easy scaling of the communication resources. </span><span class="koboSpan" id="kobo.1154.5">This capability is fundamental for optimizing the performance of applications made of hundreds or thousands of microservices.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1155.1">Summing up, there are cases where message brokers are a MUST or are at least the best choice. </span><span class="koboSpan" id="kobo.1155.2">Therefore, in this section, we will show how to use them by transforming the previous project so that it uses RabbitMQ instead of gRPC and internal queues.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1156.1">Unluckily this transformation requires a complete restructuration of the microservice project. </span><span class="koboSpan" id="kobo.1156.2">We can save business and data layers but we need to move from an ASP.NET Core project to a different project template called </span><strong class="screenText"><span class="koboSpan" id="kobo.1157.1">Worker Service</span></strong><span class="koboSpan" id="kobo.1158.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1159.1">Therefore, let’s replace the ASP.NET Core project with a </span><strong class="screenText"><span class="koboSpan" id="kobo.1160.1">Worker Service</span></strong><span class="koboSpan" id="kobo.1161.1"> project:</span></p>
<figure class="mediaobject"><span class="koboSpan" id="kobo.1162.1"><img alt="" role="presentation" src="../Images/B19820_14_05.png"/></span></figure>
<p class="packt_figref"><span class="koboSpan" id="kobo.1163.1">Figure 14.5: Setup Process for a gRPC Server Project in ASP.NET Core</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1164.1">We don’t need the gRPC services anymore, but we need ProtoBuf because RabbitMQ works with binary messages.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1165.1">The </span><a id="_idIndexMarker1057"/><span class="koboSpan" id="kobo.1166.1">Worker Service project automatically scaffolds a hosted service (hosted services were discussed in detail in the </span><em class="italic"><span class="koboSpan" id="kobo.1167.1">Using generic hosts</span></em><span class="koboSpan" id="kobo.1168.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.1169.1">Chapter 11, Applying a Microservice Architecture to Your Enterprise Application</span></em><span class="koboSpan" id="kobo.1170.1">). </span><span class="koboSpan" id="kobo.1170.2">However, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1171.1">ExecuteAsync</span></code><span class="koboSpan" id="kobo.1172.1"> method of this hosted service must be a little bit different:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1173.1">protected</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1174.1">override</span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1175.1">async</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1176.1"> Task </span></span><span class="hljs-title"><span class="koboSpan" id="kobo.1177.1">ExecuteAsync</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1178.1">(</span></span><span class="hljs-params"><span class="koboSpan" id="kobo.1179.1">CancellationToken stoppingToken</span></span><span class="hljs-function"><span class="koboSpan" id="kobo.1180.1">)</span></span><span class="koboSpan" id="kobo.1181.1">
{
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1182.1">while</span></span><span class="koboSpan" id="kobo.1183.1"> (!stoppingToken.IsCancellationRequested)
    {
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1184.1">try</span></span><span class="koboSpan" id="kobo.1185.1">
        {
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1186.1">var</span></span><span class="koboSpan" id="kobo.1187.1"> factory = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1188.1">new</span></span><span class="koboSpan" id="kobo.1189.1"> ConnectionFactory() { HostName = </span><span class="hljs-string"><span class="koboSpan" id="kobo.1190.1">"</span></span><span class="hljs-string"><span class="koboSpan" id="kobo.1191.1">localhost"</span></span><span class="koboSpan" id="kobo.1192.1"> };
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1193.1">using</span></span><span class="koboSpan" id="kobo.1194.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1195.1">var</span></span><span class="koboSpan" id="kobo.1196.1"> connection = factory.CreateConnection())
            </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1197.1">using</span></span><span class="koboSpan" id="kobo.1198.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1199.1">var</span></span><span class="koboSpan" id="kobo.1200.1"> channel = connection.CreateModel())
            {
                channel.QueueDeclare(queue: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1201.1">"purchase_queue"</span></span><span class="koboSpan" id="kobo.1202.1">,
                                     durable: </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1203.1">true</span></span><span class="koboSpan" id="kobo.1204.1">,
                                     exclusive: </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1205.1">false</span></span><span class="koboSpan" id="kobo.1206.1">,
                                     autoDelete: </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1207.1">false</span></span><span class="koboSpan" id="kobo.1208.1">,
                                     arguments: </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1209.1">null</span></span><span class="koboSpan" id="kobo.1210.1">);
                channel.BasicQos(prefetchSize: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1211.1">0</span></span><span class="koboSpan" id="kobo.1212.1">, prefetchCount: </span><span class="hljs-number"><span class="koboSpan" id="kobo.1213.1">1</span></span><span class="koboSpan" id="kobo.1214.1">, </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1215.1">global</span></span><span class="koboSpan" id="kobo.1216.1">:                                </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1217.1">false</span></span><span class="koboSpan" id="kobo.1218.1">);
                </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1219.1">var</span></span><span class="koboSpan" id="kobo.1220.1"> consumer = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1221.1">new</span></span><span class="koboSpan" id="kobo.1222.1"> EventingBasicConsumer(channel);
                consumer.Received += </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1223.1">async</span></span><span class="koboSpan" id="kobo.1224.1"> (sender, ea) =&gt;
                {
                    </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1225.1">// Message received even handler</span></span><span class="koboSpan" id="kobo.1226.1">
                    ...
                </span><span class="koboSpan" id="kobo.1226.2">};
                channel.BasicConsume(queue: </span><span class="hljs-string"><span class="koboSpan" id="kobo.1227.1">"purchase_queue"</span></span><span class="koboSpan" id="kobo.1228.1">,
                            autoAck: </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1229.1">false</span></span><span class="koboSpan" id="kobo.1230.1">,
                            consumer: consumer);
                 </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1231.1">await</span></span><span class="koboSpan" id="kobo.1232.1"> Task.Delay(</span><span class="hljs-number"><span class="koboSpan" id="kobo.1233.1">1000</span></span><span class="koboSpan" id="kobo.1234.1">, stoppingToken);
            }
         }
        </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1235.1">catch</span></span><span class="koboSpan" id="kobo.1236.1"> { }
    }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1237.1">Inside the </span><a id="_idIndexMarker1058"/><span class="koboSpan" id="kobo.1238.1">main loop, if an exception is thrown, it is intercepted by the empty </span><code class="inlineCode"><span class="koboSpan" id="kobo.1239.1">catch</span></code><span class="koboSpan" id="kobo.1240.1">. </span><span class="koboSpan" id="kobo.1240.2">Since the two </span><code class="inlineCode"><span class="koboSpan" id="kobo.1241.1">using</span></code><span class="koboSpan" id="kobo.1242.1"> statements are left, both the connection and channel are disposed of. </span><span class="koboSpan" id="kobo.1242.2">Therefore, after the exception, a new loop is executed that creates a new fresh connection and a new channel.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1243.1">Intercepting exceptions is fundamental for several reasons:</span></p>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1244.1">First of all, it avoids the microservice crash.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1245.1">It enables a complete reset of all client objects involved in the communication with the RabbitMQ server that might be damaged by the error.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1246.1">It allows an error logging that, in the actual production environment, is the basic monitoring tool. </span><span class="koboSpan" id="kobo.1246.2">For simplicity, error logging is not shown in the code snippets.</span></li>
</ul>
<p class="normal"><span class="koboSpan" id="kobo.1247.1">In the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1248.1">using</span></code><span class="koboSpan" id="kobo.1249.1"> statement body, we ensure that our queue exists, and then set </span><code class="inlineCode"><span class="koboSpan" id="kobo.1250.1">prefetch</span></code><span class="koboSpan" id="kobo.1251.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1252.1">1</span></code><span class="koboSpan" id="kobo.1253.1">.</span></p>
<div class="note">
<p class="normal"><span class="koboSpan" id="kobo.1254.1">Ensuring queues exist and creating them if they don’t exist is better than relying on a single microservice for creating them since this approach avoids introducing complex dependencies and maintenance challenges related to the sequence in which microservices will run.</span></p>
</div>
<p class="normal"><span class="koboSpan" id="kobo.1255.1">Setting </span><code class="inlineCode"><span class="koboSpan" id="kobo.1256.1">prefetch</span></code><span class="koboSpan" id="kobo.1257.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1258.1">1</span></code><span class="koboSpan" id="kobo.1259.1"> causes each server to extract just one message at a time, which ensures a fair distribution of the load among all servers. </span><span class="koboSpan" id="kobo.1259.2">However, setting </span><code class="inlineCode"><span class="koboSpan" id="kobo.1260.1">prefetch</span></code><span class="koboSpan" id="kobo.1261.1"> to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1262.1">1</span></code><span class="koboSpan" id="kobo.1263.1"> might not be convenient when each server runs several equal parallel threads to process the incoming messages since it sacrifices thread usage optimization in favor of fair distribution of messages among servers. </span><span class="koboSpan" id="kobo.1263.2">As a consequence, threads that could successfully process further messages (after the first) might remain idle, thus possibly wasting processor cores available on each server machine.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1264.1">Then, we define a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1265.1">message received</span></code><span class="koboSpan" id="kobo.1266.1"> event handler. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1267.1">BasicConsume</span></code><span class="koboSpan" id="kobo.1268.1"> starts the actual message reception. </span><span class="koboSpan" id="kobo.1268.2">With </span><code class="inlineCode"><span class="koboSpan" id="kobo.1269.1">autoAck</span></code><span class="koboSpan" id="kobo.1270.1"> set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1271.1">false</span></code><span class="koboSpan" id="kobo.1272.1">, when a message is read from the queue, it is not removed but just blocked, so it is not available to other servers that read from the same queue. </span><span class="koboSpan" id="kobo.1272.2">The message is actually removed when a confirmation that it has been successfully processed is sent to RabbitMQ. </span><span class="koboSpan" id="kobo.1272.3">We can also send a failure confirmation, in which case the message is unblocked and becomes available for processing again.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1273.1">If no confirmation is received, the message remains blocked till the connection and channel are disposed of.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1274.1">Since </span><code class="inlineCode"><span class="koboSpan" id="kobo.1275.1">BasicConsume</span></code><span class="koboSpan" id="kobo.1276.1"> is non-blocking, the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1277.1">Task.Delay</span></code><span class="koboSpan" id="kobo.1278.1"> after it blocks until the cancellation token is signaled. </span><span class="koboSpan" id="kobo.1278.2">In any case, after 1 second </span><code class="inlineCode"><span class="koboSpan" id="kobo.1279.1">Task.Delay</span></code><span class="koboSpan" id="kobo.1280.1"> unblocks and both the connection and the channel are replaced with fresh ones. </span><span class="koboSpan" id="kobo.1280.2">This prevents non-confirmed messages from remaining blocked forever.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1281.1">Making </span><a id="_idIndexMarker1059"/><span class="koboSpan" id="kobo.1282.1">instructions like </span><code class="inlineCode"><span class="koboSpan" id="kobo.1283.1">BasicConsume</span></code><span class="koboSpan" id="kobo.1284.1"> non-blocking prevents a thread from wasting processor cores by remaining blocked while waiting for an event. </span><span class="koboSpan" id="kobo.1284.2">Instead, the thread is put in sleeping mode by instructions like </span><code class="inlineCode"><span class="koboSpan" id="kobo.1285.1">Task.Delay</span></code><span class="koboSpan" id="kobo.1286.1">, thus freeing up all its resources and its assigned processor core, which, this way, can be assigned to another parallel thread that was waiting for a free core for its execution.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1287.1">Let’s move on to the code inside the “message received” event. </span><span class="koboSpan" id="kobo.1287.2">This is the place where the actual message processing takes place.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1288.1">As a first step, the code verifies if the application is being shut down, in which case it disposes of the channel and connection and returns without performing any further operations:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1289.1">if</span></span><span class="koboSpan" id="kobo.1290.1"> (stoppingToken.IsCancellationRequested)
{
    channel.Close();
    connection.Close();
    </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1291.1">return</span></span><span class="koboSpan" id="kobo.1292.1">;
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1293.1">Then, a session scope is created to access all session-scoped dependency injection services:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1294.1">using</span></span><span class="koboSpan" id="kobo.1295.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1296.1">var</span></span><span class="koboSpan" id="kobo.1297.1"> scope = services.CreateScope())
{
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1298.1">try</span></span><span class="koboSpan" id="kobo.1299.1">
  {
  </span><span class="hljs-comment"><span class="koboSpan" id="kobo.1300.1">// actual application dependent message processing</span></span><span class="koboSpan" id="kobo.1301.1">
  ...
  </span><span class="koboSpan" id="kobo.1301.2">}
  </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1302.1">catch</span></span><span class="koboSpan" id="kobo.1303.1"> {
    ((EventingBasicConsumer)sender).Model.BasicNack(ea.DeliveryTag, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1304.1">false</span></span><span class="koboSpan" id="kobo.1305.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1306.1">true</span></span><span class="koboSpan" id="kobo.1307.1">);
  }
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1308.1">In the case </span><a id="_idIndexMarker1060"/><span class="koboSpan" id="kobo.1309.1">that an exception is thrown during the message processing, a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1310.1">Nack</span></code><span class="koboSpan" id="kobo.1311.1"> message is sent to RabbitMQ to inform it that the message processing failed. </span><code class="inlineCode"><span class="koboSpan" id="kobo.1312.1">ea.DeliveryTag</span></code><span class="koboSpan" id="kobo.1313.1"> is a tag that uniquely identifies the message. </span><span class="koboSpan" id="kobo.1313.2">The second argument set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1314.1">false</span></code><span class="koboSpan" id="kobo.1315.1"> informs RabbitMQ that the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1316.1">Nack</span></code><span class="koboSpan" id="kobo.1317.1"> is just for the message identified by </span><code class="inlineCode"><span class="koboSpan" id="kobo.1318.1">ea.DeliveryTag</span></code><span class="koboSpan" id="kobo.1319.1"> that doesn’t also involve all other messages waiting for confirmation from this server. </span><span class="koboSpan" id="kobo.1319.2">Finally, the last argument set to </span><code class="inlineCode"><span class="koboSpan" id="kobo.1320.1">true</span></code><span class="koboSpan" id="kobo.1321.1"> asks RabbitMQ to requeue the message whose processing failed.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1322.1">Inside the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1323.1">try</span></code><span class="koboSpan" id="kobo.1324.1"> block, there is the actual message processing. </span><span class="koboSpan" id="kobo.1324.2">Its first step is the message deserialization:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1325.1">var</span></span><span class="koboSpan" id="kobo.1326.1"> body = ea.Body.ToArray();
MyMessageClass? </span><span class="koboSpan" id="kobo.1326.2">message = </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1327.1">null</span></span><span class="koboSpan" id="kobo.1328.1">;
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1329.1">using</span></span><span class="koboSpan" id="kobo.1330.1"> (</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1331.1">var</span></span><span class="koboSpan" id="kobo.1332.1"> stream = </span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1333.1">new</span></span><span class="koboSpan" id="kobo.1334.1"> MemoryStream(body))
{
    message = PurchaseMessage.Parser.ParseFrom(stream);
}
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1335.1">After that, there is the actual application-dependent message processing. </span><span class="koboSpan" id="kobo.1335.2">If this processing fails, we must send a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1336.1">Nack</span></code><span class="koboSpan" id="kobo.1337.1">; otherwise, we must send an </span><code class="inlineCode"><span class="koboSpan" id="kobo.1338.1">Ack</span></code><span class="koboSpan" id="kobo.1339.1">:</span></p>
<pre class="programlisting code"><code class="hljs-code"><span class="hljs-keyword"><span class="koboSpan" id="kobo.1340.1">if</span></span><span class="koboSpan" id="kobo.1341.1">(success)
    ((EventingBasicConsumer)sender).Model
        .BasicAck(ea.DeliveryTag, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1342.1">false</span></span><span class="koboSpan" id="kobo.1343.1">);
</span><span class="hljs-keyword"><span class="koboSpan" id="kobo.1344.1">else</span></span><span class="koboSpan" id="kobo.1345.1">
    ((EventingBasicConsumer)sender).Model
        .BasicNack(ea.DeliveryTag, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1346.1">false</span></span><span class="koboSpan" id="kobo.1347.1">, </span><span class="hljs-literal"><span class="koboSpan" id="kobo.1348.1">true</span></span><span class="koboSpan" id="kobo.1349.1">);
</span></code></pre>
<p class="normal"><span class="koboSpan" id="kobo.1350.1">The full code of a complete example is in the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1351.1">GrpcMicroServiceRabbitProto</span></code><span class="koboSpan" id="kobo.1352.1"> subfolder of the </span><code class="inlineCode"><span class="koboSpan" id="kobo.1353.1">ch15</span></code><span class="koboSpan" id="kobo.1354.1"> folder in the GitHub repository of this book. </span><span class="koboSpan" id="kobo.1354.2">A detailed description of this example is in the </span><em class="italic"><span class="koboSpan" id="kobo.1355.1">A worker microservice based on RabbitMQ</span></em><span class="koboSpan" id="kobo.1356.1"> section of </span><em class="italic"><span class="koboSpan" id="kobo.1357.1">Chapter 21</span></em><span class="koboSpan" id="kobo.1358.1">, </span><em class="italic"><span class="koboSpan" id="kobo.1359.1">Case Study</span></em><span class="koboSpan" id="kobo.1360.1">.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1361.1">The next chapter describes service-oriented architecture and how to implement it with ASP.NET Core.</span></p>
<h1 class="heading-1" id="_idParaDest-299"><span class="koboSpan" id="kobo.1362.1">Summary</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1363.1">In this chapter, we analyzed various options for efficient internal microservices communication. </span><span class="koboSpan" id="kobo.1363.2">We explained the importance of a binary serialization that is interoperable and that ensures compatibility with previous message versions, and we described ProtoBuf in detail.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1364.1">We analyzed the limits of RPC communication and why data-driven communication must be preferred. </span><span class="koboSpan" id="kobo.1364.2">Then, we focused on how to achieve reliable asynchronous communication and efficient distributed transactions.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1365.1">After having described the conceptual problems and techniques of reliable asynchronous communication, we looked at two architectures. </span><span class="koboSpan" id="kobo.1365.2">The first one was based on gRPC, ASP.NET Core, and internal queues, and the second one was based on message brokers like RabbitMQ and .NET worker services.</span></p>
<p class="normal"><span class="koboSpan" id="kobo.1366.1">The chapter explained, using practical examples, how to implement all the communication protocols that have been discussed and the architectural options for implementing worker microservices that are available in .NET.</span></p>
<h1 class="heading-1" id="_idParaDest-300"><span class="koboSpan" id="kobo.1367.1">Questions</span></h1>
<ol class="numberedList" style="list-style-type: decimal;">
<li class="numberedList" value="1"><span class="koboSpan" id="kobo.1368.1">Why are queues so important in microservices communication?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1369.1">How do we recall another </span><code class="inlineCode"><span class="koboSpan" id="kobo.1370.1">.proto</span></code><span class="koboSpan" id="kobo.1371.1"> file?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1372.1">How can we represent a </span><code class="inlineCode"><span class="koboSpan" id="kobo.1373.1">TimeSpan</span></code><span class="koboSpan" id="kobo.1374.1"> in the ProtoBuf language?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1375.1">What are the advantages of ProtoBuf and gRPC over other binary options?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1376.1">What are the advantages of using message brokers instead of internal queues?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1377.1">Why is it acceptable to use a blocking gRPC call to enqueue a message in a recipient queue?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1378.1">How do we enable </span><code class="inlineCode"><span class="koboSpan" id="kobo.1379.1">.proto</span></code><span class="koboSpan" id="kobo.1380.1"> file code generation in a .NET project file?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1381.1">How do I send a message on a RabbitMQ channel with the official .NET client?</span></li>
<li class="numberedList"><span class="koboSpan" id="kobo.1382.1">How do you ensure that a message sent on a RabbitMQ channel is safely saved on disk using the official .NET client?</span></li>
</ol>
<h1 class="heading-1" id="_idParaDest-301"><span class="koboSpan" id="kobo.1383.1">Further reading</span></h1>
<ul>
<li class="bulletList"><span class="koboSpan" id="kobo.1384.1">The official .NET documentation on ProtoBuf can be found here: </span><a href="https://docs.microsoft.com/it-it/aspnet/core/grpc/protobuf?view=aspnetcore-6.0"><span class="url"><span class="koboSpan" id="kobo.1385.1">https://docs.microsoft.com/it-it/aspnet/core/grpc/protobuf?view=aspnetcore-6.0</span></span></a><span class="koboSpan" id="kobo.1386.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1387.1">The .NET documentation on gRPC is here: </span><a href="https://docs.microsoft.com/it-it/aspnet/core/grpc/?view=aspnetcore-6.0"><span class="url"><span class="koboSpan" id="kobo.1388.1">https://docs.microsoft.com/it-it/aspnet/core/grpc/?view=aspnetcore-6.0</span></span></a><span class="koboSpan" id="kobo.1389.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1390.1">The official Google documentation on the whole ProtoBuf language is here: </span><a href="https://developers.google.com/protocol-buffers/docs/proto3"><span class="url"><span class="koboSpan" id="kobo.1391.1">https://developers.google.com/protocol-buffers/docs/proto3</span></span></a><span class="koboSpan" id="kobo.1392.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1393.1">Complete tutorials on RabbitMQ can be found here: </span><a href="https://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html"><span class="url"><span class="koboSpan" id="kobo.1394.1">https://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html</span></span></a><span class="koboSpan" id="kobo.1395.1">.</span></li>
<li class="bulletList"><span class="koboSpan" id="kobo.1396.1">The complete documentation for RabbitMQ is here: </span><a href="https://www.rabbitmq.com/"><span class="url"><span class="koboSpan" id="kobo.1397.1">https://www.rabbitmq.com/</span></span></a><span class="koboSpan" id="kobo.1398.1">.</span></li>
</ul>
<h1 class="heading-1"><span class="koboSpan" id="kobo.1399.1">Learn more on Discord</span></h1>
<p class="normal"><span class="koboSpan" id="kobo.1400.1">To join the Discord community for this book – where you can share feedback, ask questions to the authors, and learn about new releases – follow the QR code below:</span></p>
<p class="normal"><a href="https://packt.link/SoftwareArchitectureCSharp12Dotnet8"><span class="url"><span class="koboSpan" id="kobo.1401.1">https://packt.link/SoftwareArchitectureCSharp12Dotnet8</span></span></a></p>
<p class="normal"><span class="koboSpan" id="kobo.1402.1"><img alt="" role="presentation" src="../Images/QR_Code175081751210902046.png"/></span></p>
</div>
</body></html>