- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The FIRSTHAND Guidelines of TDD
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD is more than a test-first unit testing or a Red-Green-Refactor approach.
    TDD includes best practices and guidelines that steer the way you work with unit
    testing.
  prefs: []
  type: TYPE_NORMAL
- en: 'I wanted to make a memorable list, from my experience, of the most useful guidelines
    on unit testing and TDD. So, here are nine proven best practices that I’ve abbreviated
    as **FIRSTHAND**. FIRSTHAND stands for:'
  prefs: []
  type: TYPE_NORMAL
- en: '*F*irst'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I*ntention'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*R*eadability'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*S*ingle-Behavior'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*T*horoughness'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*H*igh-Performance'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*A*utomation'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*N*o Interdependency'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*eterministic'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will go through each of these nine guidelines and support
    them with relevant practical examples. By the end of the chapter, you should have
    a fair understanding of the ecosystem of TDD and its guidelines.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found in the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch06](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch06)'
  prefs: []
  type: TYPE_NORMAL
- en: The First guideline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unit tests should be written first. This might seem odd or unintuitive at the
    beginning, but there are valid reasons for this choice.
  prefs: []
  type: TYPE_NORMAL
- en: Later means never
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: How many times have you heard, *we’ll test it later*? I have never seen a team
    finishing a project and releasing it to production and then allocating time to
    unit test their code.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, adding unit tests at the end will require code refactoring, which
    might break the product, and it is hard to justify to a non-technical person that
    a working system was broken because the team was adding unit tests. Actually,
    the statement *we broke production because we were adding unit tests* sounds ironic.
    Yes, you can refactor a working system while covered by other types of tests,
    such as Sintegration and acceptance tests, but it would be difficult to imagine
    that a team that didn’t have time to unit test previously had the time to build
    other tests that would fully cover the system.
  prefs: []
  type: TYPE_NORMAL
- en: '*Testing first ensures that unit tests and features are developed hand in hand
    and tests are not omitted.*'
  prefs: []
  type: TYPE_NORMAL
- en: Being dependency injection ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When you get used to the modern software development style of creating a service
    and then injecting it, you will never look back. Software frameworks have evolved
    to make DI a first-class citizen. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Angular Web Framework**: You can only obtain services in Angular via DI and
    you would struggle to do it in other ways.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Microsoft MAUI**: MAUI is a revamp of Xamarin.Forms and one of the major
    changes from Xamarin is having DI as a first-class citizen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**.NET Core Console**: classical .NET Framework console applications did not
    support DI, but this is now natively supported in Core, which paved the way to
    have other libraries, built on top of console applications, to support DI, for
    example ASP.NET Core.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**ASP.NET Core**: One major difference between classical ASP.NET and ASP.NET
    Core is having DI as a first-class citizen.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are all strong signals to tell you that there is no escape from using
    DI. Having your software implemented and then adding DI later is going to require
    a major refactoring and rethinking everything.
  prefs: []
  type: TYPE_NORMAL
- en: '*Starting with unit testing will enforce DI from the first moment.*'
  prefs: []
  type: TYPE_NORMAL
- en: Designing from the client’s perspective
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: TDD encourages you to think from the client’s (the caller) needs rather than
    getting bogged down with the implementation details. You are encouraged to think
    of the OOP design such as class name, abstractions, deciding the method signature
    and return type before thinking of the implementation details like the method
    body.
  prefs: []
  type: TYPE_NORMAL
- en: If you have a public interface (a combination of classes and methods) used by
    other systems or libraries, it is harder to change that interface as it is probably
    in-use by the other system, compared to changing the implementation of your code,
    say for optimization purposes.
  prefs: []
  type: TYPE_NORMAL
- en: '*TDD enforces designing the code from the client’s perspective.*'
  prefs: []
  type: TYPE_NORMAL
- en: Promoting behavior testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A unit test should care about *what* a **System Under Test** (**SUT**) does,
    *not how* it does it. In a unit test, you want to push a certain input, check
    how the dependencies are affected, and check the output. What you should not check
    is how the SUT worked internally to do all that.
  prefs: []
  type: TYPE_NORMAL
- en: If you decide to check the internals of the SUT, your unit tests will become
    tightly coupled to the implementation details. This means every change in the
    method will have a rippling effect on the associated unit tests. This will lead
    to more unit tests and brittle tests. It is worth iterating here that *tests are
    an asset and a liability*. Having more tests, which are often unnecessary, means
    more maintenance.
  prefs: []
  type: TYPE_NORMAL
- en: Testing first makes you naturally think about the inputs, outputs, and side
    effects, not about the details of the SUT implementation. Testing after implementation
    leads to what I refer to as *cheating*, where the developers look at the SUT implementation
    code and write their tests accordingly. This might inadvertently lead to testing
    implementation details.
  prefs: []
  type: TYPE_NORMAL
- en: '*TDD promotes the unit testing mantra: Test behavior, not implementation details.*'
  prefs: []
  type: TYPE_NORMAL
- en: Eliminating false positives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A false positive is when a test passes for the wrong reason. This doesn’t happen
    frequently, but when it does happen, it is hard to catch.
  prefs: []
  type: TYPE_NORMAL
- en: '*TDD uses the red-green approach to eliminate false positives.*'
  prefs: []
  type: TYPE_NORMAL
- en: Eradication of speculative code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have all written code thinking, *perhaps we will need it in the future*,
    or *let me leave it here as other* *colleagues will find it useful*. The drawback
    of this approach is this code may never be used but will be maintained. Even worse,
    if it is used in the future, it may give the illusion that it has been tested,
    while, in fact, it has been waiting for a future developer to test it.
  prefs: []
  type: TYPE_NORMAL
- en: '*TDD eradicates speculative code by writing production-only code.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Intention guideline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When your system grows, it drives more unit tests that will naturally cover
    system behavior and documentation. And with more tests comes greater responsibility:
    **readability** and **maintenance**.'
  prefs: []
  type: TYPE_NORMAL
- en: The tests will grow in quantity to an extent where the team will not remember
    the reason for writing them. You will be looking at a failing test and scratching
    your head for clues about the intention of the test.
  prefs: []
  type: TYPE_NORMAL
- en: Your unit tests should be understood with the least possible time and effort;
    otherwise, they will be more of a liability than an asset. An agile software team
    should be prepared in advance for such test failure scenarios. Intention can be
    demonstrated by having a clear method signature and a well-structured method body.
  prefs: []
  type: TYPE_NORMAL
- en: Starting with the method signature, here are two popular conventions that should
    clarify the unit test’s intention.
  prefs: []
  type: TYPE_NORMAL
- en: Method_Condition_Expectation
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I have been using this convention in naming the unit test methods across the
    book: `Method_``Condition_Expectation`. This is a succinct naming convention that
    doesn’t allow innovative method names and, in my opinion, spares innovation for
    other tasks. It results in a more boring but standard method name. The following
    is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginUser_UsernameDoesntExist_ThrowsInvalidOperationException`'
  prefs: []
  type: TYPE_NORMAL
- en: This is still not a precise convention, but it is good enough. For example,
    some developers may argue against using the word `Throws` as it is obvious because
    the word `Exception` is used.
  prefs: []
  type: TYPE_NORMAL
- en: What is important here is establishing, in a short amount of time, from the
    three parts seen in the preceding method name, the intention of this test.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: I have seen teams omitting the `Method` part and just using `Condition_Expectation`,
    especially if the whole unit test class targets one method only.
  prefs: []
  type: TYPE_NORMAL
- en: Method_Should_When
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Another popular convention that allows more natural language is using the `Method_Should_When`.
    This convention is more akin to fluent coding, where the code flows like an English
    sentence. The following is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginUser_Should_Throw_InvalidOperationException_When_UsernameDoesntExist`'
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, advocates of this convention like to also use **fluent assertions**
    for asserting:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As you might have noticed, the previous code is different from the xUnit style
    used in the book:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: If you are interested in using fluent assertions, you can have a look at a .NET
    library called **Shouldly** ([https://github.com/shouldly/shouldly](https://github.com/shouldly/shouldly)).
    In [*Appendix 1*](B18370_14.xhtml#_idTextAnchor315), *Commonly Used Libraries
    with Unit Tests*, we discuss a similar library called *Fluent Assertions*.
  prefs: []
  type: TYPE_NORMAL
- en: The next part for clarifying the intention is clarifying the method body.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The dominant method for structuring a unit test body is the popular **Arrange-Act-Assert**
    (**AAA**). Let’s shed more light on the intention of what each section should
    do.
  prefs: []
  type: TYPE_NORMAL
- en: Arrange
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Arrange` is meant to achieve two objectives:'
  prefs: []
  type: TYPE_NORMAL
- en: Initializing variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a SUT state
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Arrange` section might be shared with the constructor of the unit test
    class as the constructor might be doing some preparations to reduce the `Arrange`
    code across each unit test. In other words, there might be some *arrangements*
    happening outside this section. We will see examples of this in *Part 2*, *Building
    an Application with TDD*, of the book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Initializing the objects and initializing expectations happen in the `Arrange`
    section, and that is the obvious part. The not-so-obvious part is that this section
    sets a *state*. Here is an example to clarify what a state means:'
  prefs: []
  type: TYPE_NORMAL
- en: '`LoginUser_UsernameDoesntExist_ThrowsInvalidOperationException`'
  prefs: []
  type: TYPE_NORMAL
- en: '`Arrange` will create a state where the user doesn’t exist in the system, and
    in most cases, that code will be tightly related to the `Condition` in `Method_Condition_Expectation`.
    In this case, the arrangement should be linked to `UsernameDoesntExist`.'
  prefs: []
  type: TYPE_NORMAL
- en: Act
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Act` is mostly a single line of code that calls the same method specified
    in the first part of the method name. In the previous example, I expect the act
    to look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: This method reiterates the intention specified in the method’s signature and
    provides clean code.
  prefs: []
  type: TYPE_NORMAL
- en: Assert
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`Assert` is asserting the conditions in the last section of the method signature:
    `Expectation`.'
  prefs: []
  type: TYPE_NORMAL
- en: The signature convention and the body structure work together to provide clear
    intentions. Keep in mind that no matter what convention you’ve used, the key is
    consistency and clarity.
  prefs: []
  type: TYPE_NORMAL
- en: '*Clear-intention unit tests would promote easier maintenance and more accurate
    documentation.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Readability guideline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Is this method readable? Do you need to run it and start debugging to understand
    what it does? Does the `Arrange` section make your eyes bleed? This might be violating
    the readability principle.
  prefs: []
  type: TYPE_NORMAL
- en: Having the Intention guideline established is fabulous, but it is not enough.
    You will have at least 10x more lines of code in your unit tests compared to your
    production code. All this needs to be maintained and grow with the rest of your
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Tidying up the unit test for readability follows the same practices as the production
    code. However, there are some scenarios that are more dominant in unit tests,
    which we are going to address here.
  prefs: []
  type: TYPE_NORMAL
- en: SUT constructor initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Initializing your SUT will require that you prepare all the dependencies and
    pass them to the SUT, something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now we have done all the coding preparation, we can initialize the SUT (the
    controller, in our case) and pass to it the right parameters. This will be repeated
    in most of your same-SUT tests, which will make it a read nightmare. This code
    can easily go to the constructor of the unit test class and become something like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The beauty of the previous code is that it is reusable by all unit tests in
    the same class. The code in your unit test becomes something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Arrange` size in your unit tests in this class has gone down. Remember,
    you are looking here at one unit test method, but you might have several unit
    tests for the same SUT.
  prefs: []
  type: TYPE_NORMAL
- en: You might argue that while we have cleared some of the repeated code in our
    `Arrange`, it is still busy. Let’s get the builder design pattern to the rescue.
  prefs: []
  type: TYPE_NORMAL
- en: The builder pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For the same SUT, every unit test’s arrangement varies slightly from others.
    The **builder design pattern** is useful when creating an object with lots of
    possible configuration options, which comes in handy for this scenario.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This is different from the **Gang of Four** (**GoF**) Builder design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: 'The builder class, for the previous example, looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'What is notable in this class is that:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Every method returns the class instance. This helps to chain methods like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `Build()` method will combine all the configurations together to return
    a usable object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The refactored `Arrange` of the previous unit test looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code takes advantage of the builder class that we created earlier.
    You can see the code clearly setting the next day’s temperature as 3.3 degrees.
  prefs: []
  type: TYPE_NORMAL
- en: Using SUT constructor initialization and the builder pattern are just a few
    examples of making your unit tests readable.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the refactored class in `WeatherForecastTestsReadable.cs` and the
    original in `WeatherForecastTestsLessReadable.cs` in the companion source code.
  prefs: []
  type: TYPE_NORMAL
- en: '*Readability promotes the healthy growth of your unit test’s codebase. Keep
    it in check from day one.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Single-Behavior guideline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Every unit test should test one and only one behavior. Throughout this book,
    this concept has been enforced naturally by:'
  prefs: []
  type: TYPE_NORMAL
- en: The naming of the unit test method’s signature, which reflects one condition
    with one expectation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single AAA structure that enforced a single `Act`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Before digging further, I would like to define the word *behavior*.
  prefs: []
  type: TYPE_NORMAL
- en: What is behavior?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The definition of behavior varies in the industry, so it is important to set
    an accurate one for the context of this book. Each SUT is supposed to do something.
    A SUT does this *thing* by:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Communicating with dependencies**: Communication can be by calling a method
    on a dependency or setting a field or a property – this is referred to as *external
    behavior*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exception` or the return value (if a method is not a `void` or a `Task` method)
    – this is also referred to as *external behavior*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Plumbing all together**: Doing various commands in preparation to receive
    the input, in preparation for the output (the return value), or in preparation
    for communicating with a dependency – this is referred to as the *internals* of
    the SUT, or *internal behavior*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: External behavior propagates across the system, as it is touching other dependencies,
    while internal behavior is encapsulated in the SUT and not shown to the outside
    world.
  prefs: []
  type: TYPE_NORMAL
- en: When we use the word *behavior* on its own, we mean *external behavior*, so
    the Single-Behavior guideline refers to single external behavior. As usual, definitions
    seem more complicated than they are, so let’s fortify this definition with an
    example.
  prefs: []
  type: TYPE_NORMAL
- en: Example of behavior
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let’s take this code from the **Weather Forecasting App** (**WFA**) that was
    introduced in [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037), *Understanding
    Dependency Injection by Example*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, the external behaviors are all in the `_client.OneCallAsync`
    call and in the `return` statement. The rest of the code is all internal. You
    can think of the internal code’s role as preparing to trigger the `_client` dependency
    and to return a value.
  prefs: []
  type: TYPE_NORMAL
- en: The internal behaviors are no longer relevant once these two external behaviors
    are triggered; they are executed and forgotten, while the external behaviors propagate
    to other services.
  prefs: []
  type: TYPE_NORMAL
- en: Testing external behavior only
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If the role of internals is to prepare for external behavior only, then testing
    external behavior will cover testing the whole code. You can think of it as the
    internal code being tested is a by-product of testing the external behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some examples of unit testing the behavior (external behavior). These
    examples are fully implemented in the source code in [*Chapter 3*](B18370_03.xhtml#_idTextAnchor066),
    *Getting Started with Unit Testing* (**WF** stands for **Weather Forecasting**):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'After executing these tests that are targeting external behavior only, a code
    coverage tool will show that all the code that was demonstrated in the previous
    example is covered by our test. This includes the code in the `GetReal()` public
    method and the code in the `MapFeelToTemp()` private method. Let’s have a look
    at an example of code coverage:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Lines covered by behavior tests ](img/Figure_6.1_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.1 – Lines covered by behavior tests
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding figure, I have used a VS plugin called **Fine Code Coverage**
    (**FCC**) to show the lines that are covered by the selected tests to the right.
    It shows that all the code lines in the SUT were covered by these tests. We will
    discuss coverage and this plugin tool in more detail in *The Thoroughness guideline*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: Why not test internals?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One common mistake in unit testing is when developers try to test the internals
    of a SUT. Here are a few problems with testing internals:'
  prefs: []
  type: TYPE_NORMAL
- en: The SUT is already covered when testing external behavior, so there’s no need
    to increase the number of unit tests, which will increase maintenance (liability).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Testing the internals will create tight coupling between the SUT and the tests,
    which will create brittle tests that will have to change often.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Internals are usually hidden behind non-public methods; to test them, the code
    needs to change to public, which violates OOP’s encapsulation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A single behavior per test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the definition of behavior is clear, we can clarify what testing a
    single behavior means. Testing a single behavior works alongside the Intention
    guideline. If we are targeting a single behavior, our test will promote a better
    intention and more readability, and when it fails, we are supposed to pinpoint
    the reason promptly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Single-behavior testing is made up of a SUT, a single condition, a single expectation,
    and minimal assertions. The unit test signatures in the previous list (section:
    *Testing external behavior only*) are examples of targeting a single behavior.
    Also, all the examples in this book follow the same guidelines.'
  prefs: []
  type: TYPE_NORMAL
- en: '*A unit test method should test a single behavior and never test internals.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Thoroughness guideline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When unit testing some naturally occurring questions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: How many tests are enough?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Do we have a test coverage metric?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Should we test third-party components?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: What system components should we unit test and what should we leave?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Thoroughness guideline attempts to set the answers to these questions.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests for dependency testing
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When you encounter a dependency, whether this dependency is part of your system
    or a third-party dependency, you create a test double for it and isolate it in
    order to test your SUT.
  prefs: []
  type: TYPE_NORMAL
- en: 'In unit tests, you do not directly call a third-party dependency; otherwise,
    your code will be an integration test and with that, you lose all the benefits
    of unit tests. For example, in unit tests, you do not call this:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_someZipLibrary.Zip(fileSource, fileDestination);`'
  prefs: []
  type: TYPE_NORMAL
- en: For testing this, you create a test double for the `.zip` library to avoid calling
    the real thing.
  prefs: []
  type: TYPE_NORMAL
- en: This is an area that unit tests do not and should not cover, which leaves us
    with a coverage issue as some areas of the code are not unit-testable.
  prefs: []
  type: TYPE_NORMAL
- en: To test the interaction with dependencies and solve the previous problem of
    not being able to unit test some code, other types of tests can be employed, such
    as Sintegration, integration, and acceptance tests.
  prefs: []
  type: TYPE_NORMAL
- en: We started to speak about *coverage*; now we can dig deeper into the topic.
  prefs: []
  type: TYPE_NORMAL
- en: What is code coverage?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first step in understanding thoroughness is understanding code coverage.
    **Code coverage** is the percentage of the system code lines executed by your
    tests (unit, Sintegration, integration, and so on) from the total system lines.
    Let’s assume we have a method that returns if an integer is even:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have a unit test that tests if a number is even:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public void IsEven_EvenNumber_ReturnsTrue() {…}`'
  prefs: []
  type: TYPE_NORMAL
- en: This unit test would have covered the `if` line but it wouldn’t have executed
    the `else` line. This constitutes 50% code coverage. Obviously, having another
    test to test an odd number would have led to 100% coverage.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to realize that code coverage is not necessarily the unit test
    coverage only, but it might be a combination of unit tests, Sintegration tests,
    and integration tests. However, out of all tests, unit tests usually cover the
    biggest chunk of the code, as they are easier to write than other tests. Also,
    when using the TDD style, you get high coverage as soon as the feature is implemented,
    as all relevant unit tests are already supplied.
  prefs: []
  type: TYPE_NORMAL
- en: Coverage measurement tools
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To measure how much of your code is covered by your tests, usually, you measure
    it in the **Continuous Integration** (**CI**) pipeline (which will be discussed
    in [*Chapter 11*](B18370_11.xhtml#_idTextAnchor265), *Implementing Continuous
    Integration with GitHub Actions*, of the book) and/or on the development machine.
    There are plenty of commercial options for running test coverage and a limited
    number of free options. Here are a few examples:'
  prefs: []
  type: TYPE_NORMAL
- en: NCover – commercial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: dotCover – commercial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NCrunch – commercial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: VS Enterprise code coverage – commercial
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: SonarQube – commercial and community
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: AltCover – free
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: FCC – free plugin for VS
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you want to see how code coverage works, you can install FCC by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: From the menu, select **Extensions** | **Manage Extensions** and the **Manage
    Extensions** dialog will open.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Online** | **Visual Studio Marketplace**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Search for `Fine Code Coverage` and then select **Download**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Installing FCC dialog ](img/Figure_6.2_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.2 – Installing FCC dialog
  prefs: []
  type: TYPE_NORMAL
- en: Restart VS.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After installation, you can open the project from [*Chapter 3*](B18370_03.xhtml#_idTextAnchor066),
    *Getting Started with Unit Testing* and execute all your unit tests (**Test**
    | **Run All Tests**). This tool will be triggered automatically after several
    seconds of executing the tests. To see the results, a panel like the following
    one will appear at the bottom of VS to show you the results:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.3 – FCC analysis results ](img/Figure_6.3_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.3 – FCC analysis results
  prefs: []
  type: TYPE_NORMAL
- en: If you can’t see this panel, you might need to go, from the menu, to **View**
    | **Other Windows** | **Fine Code Coverage**.
  prefs: []
  type: TYPE_NORMAL
- en: I am only interested in the production code cover, which is `Uqs.Weather` in
    this example. I can see that my total coverage is 55.2%.
  prefs: []
  type: TYPE_NORMAL
- en: We will speak further about the previous code coverage results in the next few
    sections.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test coverage spectrum
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unit tests are excellent for testing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Business logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Validation logic
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Algorithms
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interaction between components (not to be confused with integration between
    components)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'On the other hand, unit tests are not optimal for testing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Integration between components – the call from component A passing through to
    component B, such as getting info from the database and analyzing the data
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Service booting components – such as `Program.cs`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Direct call to dependencies (dependency testing, as discussed earlier)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Wrappers wrapping real components – such as `RandomWrapper` in the following
    example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Unit tests should have no interest in testing anything in this class, as this
    is wrapping the real components directly.
  prefs: []
  type: TYPE_NORMAL
- en: Now, if we go back to the results of the code coverage, it is clear why we have
    0% coverage for `Program.cs`, `NowWrapper.cs`, and `RandomWrapper.cs`. It is best
    that the code in these files is not tested by unit tests and we haven’t done that.
  prefs: []
  type: TYPE_NORMAL
- en: '`WeatherForecastController` is 80% covered. You can open the file to see what
    FCC highlights.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Highlights from FCC ](img/Figure_6.4_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.4 – Highlights from FCC
  prefs: []
  type: TYPE_NORMAL
- en: It looks like not even a single line in `GetRandom` is tested as all are *red*.
    I might have not targeted this method in any of my tests. Obviously, having a
    complete method that is not tested would not have happened if I were using TDD;
    however, this is a method that comes with the VS sample code for the ASP.NET project.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand what code coverage is and what can be covered, we can
    describe what being *thorough* in testing is.
  prefs: []
  type: TYPE_NORMAL
- en: Being thorough
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Clearly, the best coverage level is 100%; or at least this should be the intention,
    but it is not easily achievable and sometimes, it isn’t worth the cost and effort
    to achieve it.
  prefs: []
  type: TYPE_NORMAL
- en: First, as discussed, unit tests are not meant to provide 100% coverage, so they
    need to be backed up by other categories of tests. If we want to achieve 100%
    coverage using unit tests, we will shoehorn unit tests to test things that are
    not best suited for unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Being thorough is doing a combination of unit testing, Sintegration testing,
    integration testing, and user acceptance testing.
  prefs: []
  type: TYPE_NORMAL
- en: The cost, time, and quality triangle
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This is probably not the first time you’ve heard of this concept. It is a project
    management one and is not specific to software engineering. Here is the popular
    triangle:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – The cost, time, and quality triangle ](img/Figure_6.5_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 5.5 – The cost, time, and quality triangle
  prefs: []
  type: TYPE_NORMAL
- en: '**Quality** in our triangle represents how thorough we want to be. It is clearly
    a function of **Time** and **Cost**.'
  prefs: []
  type: TYPE_NORMAL
- en: Testing, in general, is a time-consuming process and unit testing takes as much
    time, if not more, as writing production code. Unit tests are written by the same
    developers as the production code and they are not usually things that are done
    in parallel; they are done in series. The red-green-refactor process of TDD is
    done by the same individual or the team writing the code, not by a separate tester
    doing this in parallel.
  prefs: []
  type: TYPE_NORMAL
- en: How thorough?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Aiming for over 80% coverage is good. 95% coverage is the max you would be able
    to have with reasonable effort. This is only the case for the combination of unit
    testing with Sintegration or unit testing with integration. Acceptance testing
    does not usually count toward your coverage.
  prefs: []
  type: TYPE_NORMAL
- en: Being more thorough and aiming for higher coverage is a matter of more time
    and cost. So, the question of how much coverage is a question for project management
    and your team.
  prefs: []
  type: TYPE_NORMAL
- en: '*Being thorough is aiming for high coverage using a combination of unit tests
    with Sintegration tests or unit tests with integration tests. This is taking into
    consideration the time, money, and quality triangle.*'
  prefs: []
  type: TYPE_NORMAL
- en: The High-Performance guideline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Your unit tests should not take, in today’s hardware, over 5 seconds to run,
    ideally no more than a couple of seconds after the tests are loaded. But why all
    this fuss? Can’t we just let them take whatever time is needed to run without
    sweating over it?
  prefs: []
  type: TYPE_NORMAL
- en: First, your unit tests will have to run many times throughout the day. TDD is
    about running a chunk of your unit tests or all of them with every change; therefore,
    you don’t want to spend your time waiting and lose valuable time that could be
    spent more productively.
  prefs: []
  type: TYPE_NORMAL
- en: Second, your unit tests need to provide fast feedback to your CI pipeline. You
    want your source control branches to be green all the time, so that other developers
    are pulling green code at any given time and, of course, it is ready to ship to
    production. This is even more important for larger teams.
  prefs: []
  type: TYPE_NORMAL
- en: So, how do you keep your unit tests performing as fast as possible? We will
    attempt to answer this question in the next sections.
  prefs: []
  type: TYPE_NORMAL
- en: Integration as disguised units
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I have seen this in many projects, where developers call their integration tests
    unit tests just because they are executed by NUnit or xUnit.
  prefs: []
  type: TYPE_NORMAL
- en: Integration tests are slow by nature as they are doing IO operations, such as
    writing or reading from the disk, going to the database, and going over the network.
    These operations consume time and result in tests that take minutes or more to
    run.
  prefs: []
  type: TYPE_NORMAL
- en: Unit tests use test doubles and rely on memory and CPU to run. Running 10K unit
    tests should take seconds after project load, so *make sure you are not executing
    integration tests*.
  prefs: []
  type: TYPE_NORMAL
- en: CPU- and memory-intensive unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You might be doing unit tests that rely on math libraries that are not treated
    as test doubles or you might have code that involves sophisticated logic.
  prefs: []
  type: TYPE_NORMAL
- en: You can have multiple categories of unit tests that can be executed at different
    times. xUnit calls this feature a **trait**. You can have a trait to indicate
    slow tests.
  prefs: []
  type: TYPE_NORMAL
- en: '*You can execute faster tests during your TDD and all tests before pushing
    to* *the codebase (source control).*'
  prefs: []
  type: TYPE_NORMAL
- en: Having too many tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s assume that after becoming a TDD guru and reaching 100K tests, you start
    having tests that are taking over 5 seconds.
  prefs: []
  type: TYPE_NORMAL
- en: 'I would directly ask:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Do you have a bloated monolith type of project?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*What is your problem: slow tests or a project that should be divided into
    microservices?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A temporary solution for this issue is having multiple VS solutions and figuring
    out how to divide related projects into various solutions.
  prefs: []
  type: TYPE_NORMAL
- en: '*Having too many tests is a sign of weak architecture*. Employing an alternative
    architecture, such as microservices, can be considered and the unit tests problem
    may be sorted out automatically.'
  prefs: []
  type: TYPE_NORMAL
- en: '*High-performance unit tests are something you strive for from day one and
    keep in check while building your project.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Automation guideline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we say automation, we mean CI. CI has a dedicated chapter in this book,
    [*Chapter 11*](B18370_11.xhtml#_idTextAnchor265), *Implementing Continuous Integration
    with GitHub Actions*, so we won’t go into the details here.
  prefs: []
  type: TYPE_NORMAL
- en: This guideline is about realizing that the unit tests will run on other platforms
    than your local development machine. So, how do you make sure your unit tests
    are ready for automation?
  prefs: []
  type: TYPE_NORMAL
- en: CI automation from day 1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Agile teams dedicate the first sprint to setting up the environment, including
    the CI pipeline. This is usually called sprint or iteration zero. If CI is set
    up from day 1 to listen to source control, there is less chance it is omitted
    or a CI-incompatible test is introduced.
  prefs: []
  type: TYPE_NORMAL
- en: '*Implement CI from the start of the project.*'
  prefs: []
  type: TYPE_NORMAL
- en: Platform-independent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: .NET is multi-platform and the trend nowadays is to use Linux servers to run
    CI pipelines. Also, the developer dev machine can be Windows, macOS, or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: '*Make sure your code does not rely on any OS-specific features*, if not really
    needed, so that you can have a free choice of which OS to use for the CI pipeline.'
  prefs: []
  type: TYPE_NORMAL
- en: High performance on CI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CI pipelines, nowadays, are leased services from CI providers such as Azure
    DevOps or GitHub Actions. These leased services are low in resources (CPU and
    memory) and are shared between multiple projects.
  prefs: []
  type: TYPE_NORMAL
- en: It is fair to say that tests will take double the time, if not more, to run
    on a CI pipeline in comparison to your local machine, assuming that you have a
    decent dev machine and you are not paying a fortune for your CI resources.
  prefs: []
  type: TYPE_NORMAL
- en: This reiterates the fact that having high-performing tests is necessary.
  prefs: []
  type: TYPE_NORMAL
- en: '*Make sure whatever test you write on your dev machine is ready to run on CI*.'
  prefs: []
  type: TYPE_NORMAL
- en: The No Interdependency guideline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, I would like to elevate this from a guideline to a principle. This principle
    ensures that the unit test does not alter a state permanently; or, in other words,
    executing a unit test should not persist data. Based on this principle, we have
    the following rules:'
  prefs: []
  type: TYPE_NORMAL
- en: Test A shouldn’t affect test B.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn’t matter whether test A runs before test B.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It doesn’t matter whether we run test A and test B in parallel.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If you think about it, a unit test is creating test doubles and doing its operations
    in memory, and as soon as it finishes execution, all the changes are lost, except
    the test report. Nothing is saved in the database, in a file, or anywhere, because
    these dependencies were all provided as test doubles.
  prefs: []
  type: TYPE_NORMAL
- en: Having this principle in place also ensures that the test runner, such as Test
    Explorer, can run the tests in parallel and use multi-threading if needed.
  prefs: []
  type: TYPE_NORMAL
- en: Ensuring this principle is a shared responsibility between the unit testing
    framework and the developer.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing framework responsibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The unit testing framework should make sure that the unit test class is re-initialized
    after executing each unit test method. A unit test class should not maintain the
    state in the same way that a normal class maintains the state. Let me demonstrate
    with an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: When a unit testing framework runs `UnitTest1` and `UnitTest2`, it should not
    run them from the same object; it creates a new object for each method run. This
    means that they do not share instance fields. Otherwise, if `UnitTest1` runs before
    `UnitTest2`, then we should be asserting for `6`.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Modifying an instance field in a method, then asserting it in the same method,
    is not a good unit testing practice, but it has been done for demonstration purposes.
  prefs: []
  type: TYPE_NORMAL
- en: xUnit does follow this principle of making sure the state is not shared. However,
    it can be instructed otherwise by using a static member.
  prefs: []
  type: TYPE_NORMAL
- en: Developer’s responsibility
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As a developer, you know that you should not persist data during a unit test.
    Otherwise, this is, by definition, not a unit test.
  prefs: []
  type: TYPE_NORMAL
- en: 'If a developer is using test doubles to replace the database, the network,
    and other dependencies, they are respecting this rule by virtue. However, the
    problem arises if the developer decides to use static fields. Static fields will
    preserve the state between independent method calls. Let’s take this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The previous code fails this rule, as running `UnitTest2` before `UnitTest1`
    will fail the test. Actually, there is no guarantee that the second method will
    run after the first one based on their order in the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are instances where using static fields would promote better performance.
    Say we have an in-memory read-only database that we need to use in all tests.
    Also assume that this is taking a long time to initialize, such as 100 ms:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The field is read-only and the content of the class is also read-only, such
    as `readonly record`. Although, for this scenario, I argue if you need all the
    territories, or can you create a cutdown version suitable for unit testing? This
    might speed up loading and can remove the need for a static field.
  prefs: []
  type: TYPE_NORMAL
- en: As a developer, you should be careful not to create a state between multiple
    unit tests. This is easy to miss if you are new to the unit testing field.
  prefs: []
  type: TYPE_NORMAL
- en: '*No interdependency leads to easier-to-maintain code and reduces bugs in unit
    tests.*'
  prefs: []
  type: TYPE_NORMAL
- en: The Deterministic guideline
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A unit test should have a deterministic behavior and should lead to the same
    result. This should be the case regardless of the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Time**: This includes changes in time zone and testing at different times.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Environment**: Such as the local machine or CI/CD server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s discuss some cases where we risk making non-deterministic unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Non-deterministic cases
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are cases that can lead to non-deterministic unit tests. Here are a few
    of them:'
  prefs: []
  type: TYPE_NORMAL
- en: Having interdependent unit tests, such as a test that writes to a static field.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Loading a file with an absolute path as the file location on the development
    machine will not match that on the automation machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessing a resource that requires higher privileges. This can work, for example,
    when running VS as an admin but may fail when running from a CI pipeline.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using randomization methods without treating them as dependencies.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Depending on the system’s time without treating it as a dependency.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Next, we will see a case of not depending on varying time, to make our unit
    test deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: Example of freezing time
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If your test relies on time, you should be using a test double to freeze the
    time to ensure a deterministic test. Here is an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a wrapper to allow injecting the current time as a dependency. To register
    the wrapper in `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'Your service can look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The calculation in the preceding code is for demo purposes and does not take
    into account daylight saving. To inject the current time from the unit tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The previous unit test has frozen the current time to a specified value. This
    made the code independent from the OS’s clock and thus made it deterministic.
  prefs: []
  type: TYPE_NORMAL
- en: '*Running a unit test should always yield the same results, regardless of time
    or environmental factors.*'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: FIRSTHAND accumulates valuable guidelines and best practices in the industry.
    I trust this chapter topped up the learnings of the previous chapters to help
    you understand TDD and its ecosystem. I also hope that it made these guidelines
    memorable as TDD comes up often in developer discussions and it is certainly likely
    to be an interview topic.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter marks the end of this section, where we looked at dependency injection,
    unit testing, and TDD. This section was only an introduction to TDD, with scattered
    small and mid-size examples. If you’ve made it to this point, then hats off, you
    have covered the basics of TDD.
  prefs: []
  type: TYPE_NORMAL
- en: The next section will take all the basics and apply them to more lifelike scenarios.
    To make sure that you are ready for this application and to mimic a realistic
    application that uses TDD, our next chapter will be about **domain-driven design**
    (**DDD**) as you will be using the DDD concepts in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Building an Application with TDD'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: TDD is usually combined with a **Domain-Driven Design** (**DDD**) architecture.
    In this part, we will take what we’ve learned in *Part 1* and use it to build
    a complete application using TDD and DDD; in one instance, we will use a relational
    DB ([*Chapter 9*](B18370_09.xhtml#_idTextAnchor226)), and in another, a document
    DB ([*Chapter 10*](B18370_10.xhtml#_idTextAnchor245)) to show how this would affect
    our unit test implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'By the end of this part, you should be able to build an application using TDD
    and DDD from scratch. The following chapters are included in this part:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 7*](B18370_07.xhtml#_idTextAnchor183), *A Pragmatic View of Domain-Driven
    Desig*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209), *Designing an Appointment
    Booking App*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 9*](B18370_09.xhtml#_idTextAnchor226), *Building an Appointment Booking
    App with Entity Framework and Relational DB*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 10*](B18370_10.xhtml#_idTextAnchor245), *Building an App with Repositories
    and Document DB*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
