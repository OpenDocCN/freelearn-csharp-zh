<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. The Secret Ingredient Is a Dash of Physics</h1></div></div></div><div><blockquote class="blockquote"><p><em>"Sprinkles may seem soft, but they are an excellent sharp weapon against sweet-tooth pandas, who are trying to steal your delicious cake!"</em></p></blockquote></div><p>This chapter explains how Unity deals with 2D physics and provides descriptions for each of the components, along with useful examples of usages. Although we will use just a small portion of the Physics engine of Unity for our game, in this chapter you can find some foundations of physics to better face the topics covered, and a full insight of 2D physics in Unity.</p><p>In the first part of the chapter, we will acquire some basic notions about physics so as to better face the topics to come. We will learn about mass, forces, and torques, just enough to understand physics in Unity.</p><p>Then, most of the chapter will focus on explaining, bit by bit, the 2D Physics engine of Unity along with all its components and functionalities. Many examples will be provided in order to facilitate the learning.</p><p>Finally, in the last part of the chapter, we will use some of the notions learnt and apply them into our game. In fact, we will transform simple sprinkles into terrible weapons against the sweet-toothed pandas by enabling and handling collisions between the two.</p><p>Therefore, we are going to learn these topics:</p><div><ul class="itemizedlist"><li class="listitem">Basic notions of physics</li><li class="listitem">Understanding the Physics engine of Unity</li><li class="listitem">Physics settings, which are general properties for the whole project/game</li><li class="listitem">Rigidbody components with different body types and their usage</li><li class="listitem">Colliders and how to use them</li><li class="listitem">Joints to impose constraints on rigidbodies</li><li class="listitem">Effectors to change physics properties in particular region of the game world</li><li class="listitem">Physics materials to determine friction and bounciness on colliders</li><li class="listitem">Using the physics components in our game</li></ul></div><p>Like all other chapters in this book, you will find the <em>Homework</em> section at the end. It has a range of different exercises for you to do to improve your skills and implement a range of different functionalities into your game.</p><div><div><div><div><h1 class="title"><a id="ch05lvl1sec53"/>Getting ready</h1></div></div></div><p>This chapter does not need any particular prerequisite to learn about the Physics engine. However, at the end of this chapter we will continue our tower defense game from where we left it in <a class="link" title="Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike" href="part0056.xhtml#aid-1LCVG1">Chapter 4</a>, <em>No Longer Alone – Sweet-Toothed Pandas Strike</em>. Therefore, if you want to keep developing the <em>Tower Defense</em> game, you need to have done all the other steps in the previous chapters.</p><p>For those of you who are newcomers to physics, a great deal of patience is required, but once you master these concepts, a world of new possibilities for your own games will open. So don't give up!</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec54"/>Physics in video games</h1></div></div></div><p>From bullets flying at different speeds and trajectories to gravity playing a role between keeping you grounded and allowing you to float, physics in video games plays an essential part in making experiences realistic and definitely enjoyable (for the most part). Imagine if every weapon fired a bullet in the same way, regardless of the firepower. Then what would be the point between having a sniper rifle or a revolver? This is only one aspect of the role that physics plays in games. Physics in games does not just revolve around trajectories and force; it can include gravity, time travel, and fluid dynamics.</p><p>Some great examples of games that use physics include <em>World of Goo</em>, <em>Portal 1</em> and <em>2</em>, <em>Mario Galaxy</em>, and <em>Kerbal Space Program.</em></p><div><img src="img/image00512.jpeg" alt="Physics in video games"/><div><p>Image by Portal 2 - An orange liquid that reduces friction so much to give you a substantial boost</p></div></div><p style="clear:both; height: 1em;"> </p><p>Of course, at the other end of the spectrum, games don't always replicate physics in the most accurate way but rather exaggerate it or dismiss it altogether to allow for innovative and unique gameplay. An example of this would include taking a <em>Leap of Faith</em> from great heights in <em>Assassin's Creed</em>, into conveniently placed stacks of hay (and even water). Some people have even studied how much hay that you would actually need in order to survive such jumps, which you can find here: <a class="ulink" href="http://www.kotaku.com.au/2009/06/kotaku-bureau-of-weights-measures-studies-fallout-physics-also-beer/">http://www.kotaku.com.au/2009/06/kotaku-bureau-of-weights-measures-studies-fallout-physics-also-beer/</a></p><p>When it comes to adding physics to your own game, you must ask yourself to what extent you want your gaming experience to be real. If you want your game to be 100% identical to reality, then you must also consider things like death. If a character can be shot by a bullet, do they bleed out or can they heal themselves? In some cases, your game may end up more of a simulation than a game itself if the interaction is too real. An example is <strong>permadeath</strong> (where the player must restart the game from the beginning after they have died), which you may or may not want in your game/simulation. All of these factors need to be considered when adding physics into games because both the cause and effect will all contribute to how believable the game is and ultimately how enjoyable it will be.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec55"/>Physics – basics</h1></div></div></div><p>In this section, we will learn some basic notions of physics, to better understand the Physics engine of Unity later on, and overall become better game developers.</p><p>First of all, what is physics? Aristotle (the same guy from the previous chapter) wrote a treatise entitled <em>ta physika</em>, which literally means the natural things. From this treatise (although many before Aristotle have written about natural phenomena), physics has become a science. Nowadays, physics investigates matter, its motion both in time and space, through mathematical models. Ultimately, the goal of physics is to describe how the whole universe works. Physics is divided into four big branches:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Classical mechanics</strong>: This deals with the motion of objects</li><li class="listitem"><strong>Thermodynamics</strong>: This deals with the temperatures of bodies</li><li class="listitem"><strong>Electromagnetism</strong>: This deals with electromagnetic waves/particles</li><li class="listitem"><strong>Quantum mechanics</strong>: This deals with the study of subatomic particles</li></ul></div><p>You don't need to see these as separate entities but just faces of the same coin, which is the model of the world that physics over the centuries has tried to unravel. Therefore, many topics cross them all, and so the division in not univocal. But, it's a good way for newcomers to physics to get an overview.</p><p>In this chapter, we will deal only with classical mechanics, and in particular with the motion of rigid bodies. However, other branches and sub-branches of physics are also really useful in game development. For instance, we can use light equations, which are implemented in shader, or fluid dynamics to simulate oceans and waves. Even when the evil wizard casts his most terrible fireball, we need to calculate many different physics equations to have a realistic behaviour and look. Imagine just simulating the fire around the ball.</p><p>Most of the time, you don't want to go into that much detail, if you already have a game engine like Unity (or Unreal). In fact, their programmers will take care of this for you. However, sometimes you may have special needs, and you need to write your own shader or code some physics-based behaviours. As such, knowledge of physics is greatly and immensely helpful.</p><p>Of course, this is not a course in physics nor a book dedicated to physics programming (for example, algorithms that can simulate more or less approximately and efficiently some physical behaviours). However, in this chapter, we will consolidate the really basic concepts of physics so that we can have a rough idea of how it all works together. As such, this and the upcoming sections will be dedicated to building a foundational understanding of physics so that we can better grasp the Physics engine behind Unity.</p><div><h3 class="title"><a id="note55"/>Note</h3><p>I know that some of you might find physics somewhat boring. This may be the case if it awakes some bad memory (or memories) from high school. But my personal opinion is that knowing physics is really important to be a good game developer, especially when you need to program realistic behaviours. With this said, I promise that in this section, I'll try to be as clear as possible and use an informal language instead of the strict mathematical one so that these concepts can be understood by anyone.</p></div><p>Classical mechanics of rigidbodies can be divided into two sub-branches:</p><div><ul class="itemizedlist"><li class="listitem">Kinematics: Which deals with the study of the motion.</li><li class="listitem">Dynamics: Which deals with the causes of the motion.</li></ul></div><p>Of course, once again, they are faces of the same coin. In fact, dynamic equations need kinematic ones, so as to describe and predict the motion of rigidbodies. We will see them in a bit more detail soon, but first let's focus on some basic concepts.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec48"/>World coordinates and local coordinates</h2></div></div></div><p>As we have already seen in <a class="link" title="Chapter 2. Baking Cupcake Towers" href="part0028.xhtml#aid-QMFO1">Chapter 2</a>, <em>Baking Cupcake Towers,</em> there is a difference in using world coordinates and local coordinates. This is also an important concept in physics: which one is your reference frame (or coordinate system)? The question is key in determining also the values of the different physics quantities. Therefore, every time you have a physical quantity, you need to ask yourself in which reference frame are you working.</p><p>In any case, there isn't a frame that is privileged with respect to another (although some physical systems are easier to describe within a frame instead of another). So, by convention, a world frame is defined when we start the description of a physical system. For example, if you are driving your car, what is your velocity? Well, the answer depends on the coordinate system, or reference frame in which I'm describing the car moving. In the car itself, the speed of the car is zero, but rather the world is coming towards the car. Whereas for a pedestrian, the car is moving, and the world is not. An astronaut on the moon will see both the pedestrian moving really fast, along with the whole Earth, and also the car, at two different speeds. All of these descriptions are physically correct. Therefore, all quantities in physics depends on the reference frame.</p><p>In game engines such as Unity and/or Unreal, there is always a defined world frame (when you have the position with all zeros at the center of the world frame) as shown in the following diagram:</p><div><img src="img/image00513.jpeg" alt="World coordinates and local coordinates"/></div><p style="clear:both; height: 1em;"> </p><p>The preceding diagram shows how other frames are described in terms of linear and angular offset from the world frame. Moreover, you can describe a frame in terms of another, which is not the world frame (in the preceding diagram, look at the angular offset of frame <strong>#3</strong>). In Unity, you can consider the world frame as the global coordinates and the different frames as the local coordinates of game objects in the game. Children of game objects will be expressed in terms of the frame of the parent.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec49"/>Velocity</h2></div></div></div><p>Velocity in physics describes a relation between the space and the time of an object; in other words, how the object changes position with respect to a reference frame as a function of time. When the object is not accelerating, velocity is defined as distance covered in space divided by time.</p><div><h3 class="title"><a id="note56"/>Note</h3><p>For those of you who are curious, when an object changes its velocity in each instant, and we need to get the velocity in a specific instant, it is possible to retrieve it by using derivatives (this is a topic of calculus, and I won't adventure deeper in this book).</p></div><p>Velocity is a vector, and therefore it has two coordinates in the 2D world (three in the 3D world), which express a direction and an intensity. The intensity of a velocity is also called <strong>speed</strong>. So it's important to not get confused between the two. In fact, speed is a scalar, just a number, acting independently if we are dealing with 2D or 3D games; velocity, instead, does change (from two numbers to three numbers to express respectively the 2D or 3D vector).</p><p>Whenever we use the term velocity, we mean the velocity in the defined world frame (or coordinate). When we use the term relative velocity, we are taking the velocity with respect to another frame. For instance, imagine that there are two cars that are heading against each other, both at 50 Km/h (in the world frame, because when you look at your tachymeter, by convention, that is the velocity with respect to the Earth). For one of the two drivers, the car he is driving is not moving (in fact, when you drive, your steering wheel is not going 50 Km/h away from your hands, but it is always at the same distance from you). However, he will see the other car with the other driver coming at 100 Km/h towards him.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec50"/>Mass</h2></div></div></div><p>In classical mechanics, every rigid body has a mass, which you can imagine as the amount of matter that forms that body. Thus, it is considered a property of the physical body. Often in spoken language, mass is confused with weight. In fact, mass is measured in kg (kilograms) in the International System of Units, whereas weight is measured in N (newton) in the International System of Units. Therefore, a scale is not measuring your weight, but rather your mass. Weight is a force and depends on the location where you are. Your weight is different on the moon, but your mass is the same.</p><p>Sometimes, mass is also defined as the measure of an object's resistance to acceleration (a change in its state of motion) when a force is applied. In fact, you need much more force to move a truck than your laptop.</p><p>However, it is worthwhile paying attention that, for instance, both the laptop and the truck (in absence of other external forces) are attracted by the gravity of the Earth and that both will fall down and touch the ground at the same time. In fact, when the universal gravitation equation of Newton is applied, the forces applied are different but the resulting gravitational acceleration is the same for both objects (since the mass is simplified from the equations).</p><div><h3 class="title"><a id="note57"/>Note</h3><p>For the more curious of you, this was discovered by the famous Italian astronomer, physicist, engineer, philosopher, and mathematician Galileo Galilei, much before Newton formalized gravitation. There is an anecdote in which Galileo had dropped balls of the same material but different masses from the Leaning Tower of Pisa to demonstrate that their time of descent was independent of their mass. In this way, he proved that Aristotle's idea that heavy objects fall faster than lighter ones, in direct proportion to weight (at that time intended as mass) was wrong as shown in the following diagram:</p><div><img src="img/image00514.jpeg" alt="Mass"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec55"/>Centre of mass</h3></div></div></div><p>Imagine you need to calculate or predict the trajectory of an arrow. Taking into consideration the whole shape of the arrow and knowing that different forces come into play at each point ends up in a really tricky calculation (although possible). Therefore, the center of mass is an approximation that works pretty well for rigid bodies. It consists of concentrating the whole mass of an object into a single point (which is an abstraction to imagine all of the mass of that body in that single point). Where this point is depends on the shape of the object (since it is weighted among all the points the object is composed of), and this carries enough information about the shape to do really precise calculations. Especially in real-time applications, this becomes critical, since calculations of motion are greatly simplified. In fact, Unity will only do calculations using the center of mass.</p><div><img src="img/image00515.jpeg" alt="Centre of mass"/><div><p>The center of mass is the weight average of all the points in the system, where the weights are the different masses. From the diagram, we can see that center of mass is closer to m1 and m3, since they are bigger (have more mass) than m2.</p></div></div><p style="clear:both; height: 1em;"> </p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec51"/>Kinematics</h2></div></div></div><p>The term kinematics was used for the first time around 1840, as the translation of the French term <em>cinématique</em>, which was used by <em>André-Marie Ampère</em> (the famous French physicist and one of the founders of classical electromagnetism — so famous that the electric current unit in the International System of Units, the ampere, was named after him). However, the origin of the term derives from the Greek word <em>kinesis</em>, which means movement or motion.</p><p>To have a better understanding of what kinematics is in physics, let's refer to Wikipedia:</p><div><blockquote class="blockquote"><p><em>"Kinematics is the branch of classical mechanics which describes the motion of points (alternatively particles), bodies (objects), and systems of bodies without consideration of the masses of those objects nor the forces that may have caused the motion. Kinematics as a field of study is often referred to as the geometry of motion."</em></p></blockquote></div><p>Kinematics takes into consideration just the motion of an object and not the causes of the motion. This gives us some advantages when it comes to game development. First of all, it is cheaper from a computational point of view to take into consideration just the kinematics of an object. Then, we might not want to have a fully realistic object in our scene, and so we can just define its kinematic properties. We will see this in detail later when we will deal with kinematic bodies in Unity.</p><div><h3 class="title"><a id="note58"/>Note</h3><p>Of course, in our world, a pure kinematic body doesn't exist; all of them are dynamic. Yet, studying just the kinematics of an object gives us insights into its motion.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec52"/>Dynamics</h2></div></div></div><p>The term dynamic was used in the 19<sup>th</sup> century in the meaning of pertaining to the force producing motion, as opposite to static. Once again, it takes its origin from the French term <em>dynamique</em>, although it was introduced by the famous German mathematician and philosopher, Gottfried Wilhelm Leibnitz. However, the origin of this term is again from the Greek word <em>dynamikos</em>, which means powerful, and also from <em>dynamis</em> (power) and <em>dynasthai</em> (to be able to, to have power, and to be strong enough).</p><p>If not already explicitly suggested, every time we deal with something dynamic in physics, we are dealing with forces (which have a certain power to move objects). From Wikipedia we can read:</p><div><blockquote class="blockquote"><p><em>"Dynamics is a branch of applied mathematics (specifically classical mechanics) concerned with the study of forces and torques and their effect on motion, as opposed to kinematics, which studies the motion of objects without reference to its causes. Isaac Newton defined the fundamental physical laws which govern dynamics in physics, especially his second law of motion."</em></p></blockquote></div><p>Therefore, dynamics is built on top of kinematics and gives a better description/prediction of how the body will move. In fact, by taking forces into consideration, mass, gravity, drag, and many other things become really important and relevant.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec53"/>Force and torque</h2></div></div></div><div><blockquote class="blockquote"><p><em>
<em>"Forces are those things that allow motion; they are responsible for creating a motion</em>."</em></p></blockquote></div><p>Every force applies an acceleration to a body, which is calculated with Newton's second law. It is so simple and elegant that it's easy to understand. We can see this law as follows:</p><div><img src="img/image00516.jpeg" alt="Force and torque"/></div><p style="clear:both; height: 1em;"> </p><p>Where <em>F</em> represents the force, which is a vector (so the arrow above the formula), <em>m</em> is the mass, and <em>a</em> is the acceleration, which is another vector (so the arrow above its symbol in the formula).</p><p>This means that if you apply a force to an object with mass <em>m</em>, you know that the acceleration is <em>F/m</em>. So, just divide the force by the mass of an object and you can calculate how much it will be accelerated. Please note that if we have two objects on which we apply the same force but they have two different masses, the one with the higher mass will have a lower acceleration, because the force is divided by a greater number.</p><p>The concept of force is important because it is the cause of motion, and many Physics engines (including the one of Unity) allow you to specify forces.</p><p>Another important concept is torque, also called moment of force or just moment, which in some way expresses a force that makes an object rotate along an axis instead of moving it. If you think of force like a pull or push, you can imagine torque as a twist.</p><div><h3 class="title"><a id="note59"/>Note</h3><p>To those of you who know a bit more about the cross-product of vectors, torque is defined as the cross-product between the force vector and the distance vector from the application point of the force. As a result, it tends to produce rotational motion. Therefore, the formula is:
</p><div><img src="img/image00517.jpeg" alt="Force and torque"/></div><p style="clear:both; height: 1em;"> </p><p>Where <em>τ</em> (read tau) is the torque, <em>F</em> is the force vector, and <em>r</em> is the distance vector, also called offset.</p><p>In the the International System of Units, torque is measured in <em>N·m</em> (Newton meter).</p></div><p>The formula of torque is a bit more complicated since it involves the cross-product, and one who has just started to deal with physics in video games and uses a graphics engine like Unity doesn't need to know/understand the formula straightaway. However, it is important to understand that this quantity deals with rotations, and applying a torque on a rigid body means that it will rotate along an axis depending on where the torque is applied. Just remember that torque is not a force, although it might seem so due to the way we will deal with it within Unity.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec54"/>Collisions</h2></div></div></div><p>In classical mechanics, there are different kinds of collisions between rigid bodies that may happen. They are divided into two categories:</p><div><ul class="itemizedlist"><li class="listitem">Elastic collisions, in which all the kinetic energy is conserved.</li><li class="listitem">Inelastic collisions, in which part of the kinetic energy is transformed into another form of energy.</li></ul></div><p>To go through this chapter, it's not important to understand them well, but it is important to understand that the type of collision may change the behaviour of what happens after the collision. Imagine two balls: one rolling towards the second, which is not moving. At a certain point, the first one will collide with the second. Depending on which kind of collision happens, the result may differ. In one scenario, both the balls will roll in the same direction and they will be as if they were attached. In another scenario, the first one stops and the second one starts to roll. In a third scenario they roll at different velocities and directions after the collision.</p><div><img src="img/image00518.jpeg" alt="Collisions"/><div><p>The three possible after-collision scenarios</p></div></div><p style="clear:both; height: 1em;"> </p><p>If you want to learn more, a web page that explains the basic concepts of different collisions in a quite simple way is <a class="ulink" href="http://hyperphysics.phy-astr.gsu.edu/hbase/elacol.html">http://hyperphysics.phy-astr.gsu.edu/hbase/elacol.html</a>. However, it is intended for those who already have a clear knowledge of the basic concepts and formulae of physics.</p><div><h3 class="title"><a id="note60"/>Note</h3><p>The website itself, <a class="ulink" href="http://hyperphysics.phy-astr.gsu.edu">http://hyperphysics.phy-astr.gsu.edu</a>, is a good source for quick references to the main concepts of physics. However, a minimum of prerequisites are needed to fully understand what's on it. The best way to start is always with a physics book, which may be boring, but mastering those concepts is a great advantage.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec55"/>Rigid body</h2></div></div></div><p>A rigid body, as the name suggests, is a body that translates and rotates all together. So for instance, a Christmas ball, a television, or a flying disk are rigid bodies, because all their parts move together. A laptop is not, because its lid can rotate, as well as a door if you consider the frame too as a part of the whole. But, these kinds of objects can be described with two different rigid bodies, such as the door-frame and the door itself, which may constrain each other (in this case with a Hinge). Water, air, toothpaste, or a dress are not considered rigid bodies, because all their parts don't move together.</p><p>Most of the objects in your game will be rigidbodies (I'm writing it attached because this is the way Unity will refer to them), or they can be approximated to rigidbodies, so knowing them well is key to learning physics in Unity. In fact, most of the 2D Physics engine of unity is focused on rigid bodies (as we will see soon), and therefore this chapter is about them.</p><p>Simulating clothes, liquids, and other physical entities that are not rigidbodies is generally harder, although possible. But often they are used in 3D games, and we won't deal these aspects in this chapter.</p><div><h3 class="title"><a id="note61"/>Note</h3><p>For the most curious of you, here is a more precise definition:
 A <strong>rigid body</strong> is the idealization of a solid body, where deformation is neglected. Therefore, the distance between any two points within the rigid body remains constant over time, independently of the forces that will apply on the rigid body.</p><p>Of course, in our world such objects don't exist. In fact they are idealizations, but they approximate the behaviour of solid objects pretty well (unless the speed of an object is near the speed of light).</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec56"/>Friction – linear and angular drag</h2></div></div></div><p>If a kid were to ask me, "what is friction?" I would reply, "friction is the thing without which all things wouldn't stop moving". Even if this is not a formal definition, it helps to understand what friction is. It comes into play when you consider the dynamics of an object, because friction generates a force that opposes to the motion of the physical body. There are many types of frictions and they depend on different factors. For instance, air drag depends on the velocity of an object, whereas dry friction depends on the normal force (which depends on the surface, position of an object, its weight, and therefore also its mass).</p><p>In games, except for specific needs, you don't need all these kinds of frictions and drags. For instance, in Unity you can control just the linear and the angular drag. The first one opposes the motion of an object along a trajectory (or better, the trajectory of the center of mass of the object; otherwise it would be too complicated to do in real time) and the angular to the rotation of an object. So, in Unity, an object that has both nonzero values for linear and angular drag will eventually stop moving and rotating (in the absence of other forces).</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec56"/>The Unity Physics engine</h1></div></div></div><p>Unity has a Physics engine integrated into it, which is able to handle both kinematic and dynamic types of rigid bodies as well as other physical entities such as clothes. It is divided into two parts: 2D Physics and 3D Physics. It's important to understand that although they can coexist together in the same scene, they are two separate entities; they cannot communicate between themselves. Physical objects under 2D Physics will not interact with physical objects under 3D Physics.</p><p>In this section, we will explore most of the 2D Physics engine of Unity. Although we will not use all the components presented here, it's important to master them all to become a better Unity developer.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec57"/>Understanding Physics in Unity</h2></div></div></div><p>In Chapter 2, <em>Cooking Cupcake Towers, </em>we learnt about script ordering and how it is executed. The first question we may wonder is when does the Physics engine occur when a frame is rendered? The answer is not straightforward, because the Physics engine runs multiple times during a frame render. In any case, except particular cases (such as the application has paused or particular game objects are enabled/disabled in that frame), the Physics engine runs after the initialization (so all the <code class="literal">Awake()</code>, <code class="literal">Start()</code>, and <code class="literal">OnEnable()</code> functions) and before to gather inputs from the player and update the game logic.</p><p>As a result, when we do a physics calculation (we will see these later in the chapter), we need to use the <code class="literal">FixedUpdate()</code> function, which is called more than once per frame, and all the times just before the Physics engine performs its calculation. As such, if we need to retrieve the time, we cannot use <code class="literal">Time.deltaTime</code>; instead we need to use <code class="literal">Time.fixedDeltaTime</code>.</p><p>Another question we may wonder is when it is appropriate to use the Physics engine of Unity. In theory, you don't need to use it, because you can program from scratch all the collisions and/or physic behaviours. In practice, it solves many common problems with minimum coding and it is indeed useful. These problems are not necessarily physics problems. In fact, some of them include certain game mechanics that may enhance the quality of your game when using a physics approach (such as the movement of the character). Others include gathering information from the environment for scripting other behaviours (such as a script that needs to know how many targets there are within a zone).</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec58"/>Physics settings in Unity</h2></div></div></div><p>First of all, the Physics engine of Unity has some general settings, which should be taken into account. They define global physical properties of your game, such as the value of gravity, what will collide with what, and how accurate the Physics simulation should be.</p><p>You can have access to the Physics settings in Unity by navigating through <strong>Edit | Project Settings | Physics 2D</strong> as shown in the following screenshot:</p><div><img src="img/image00519.jpeg" alt="Physics settings in Unity"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note62"/>Note</h3><p>Similarly, you can have access to the 3D Physics setting by navigating through <strong>Edit | Project Settings | Physics</strong>.</p></div><p>The following screen will appear in the <strong>Inspector</strong> view (the most important parameters are highlighted, which we will see in detail in this section):</p><div><img src="img/image00520.jpeg" alt="Physics settings in Unity"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see, there are many options you can tweak. Most of the time, especially for simple games (like the one we are building), the default settings will be more than fine. But Unity offers you the chance to adapt them to your game.</p><p>Most of them deal with how accurate the Unity Physics engine is. Therefore, there is a trade-off between accuracy and efficiency, since more accurate means more expensive from a computational point of view.</p><p>Let's go through the main ones in detail (if you are interested in learning also about the others, see the optional, <em>Other things about Physics</em> section later in the chapter):</p><div><ul class="itemizedlist"><li class="listitem"><strong>Gravity</strong>: The vector that defines the gravity acceleration. By default, it is a negative value only along the <em>y-</em>axis. In particular, the absolute value of 9.81 corresponds to the one on the Earth, if we let the Unity units be meters.</li><li class="listitem"><strong>Default Material</strong>: The physical material used by all the colliders and rigidbodies that don't have one set (we will see more about physical materials later on).</li><li class="listitem"><strong>Time To Sleep</strong>: The time, expressed in seconds, that needs to pass before a Rigidbody 2D goes to sleep, which means that it is not updated anymore by the Physics engine (we will see more about rigidbodies and their sleeping later on).</li><li class="listitem"><strong>Linear Sleep Tolerance</strong>: This is the linear speed below which the rigidbody after <strong>Time to Sleep</strong> goes to sleep. Imagine you have many objects in your game that drag is slowing down, and now they are so slow that the player can barely perceive their motion. As such, it's a waste of computational resources to keep them updated in the Physics engine. Therefore, this variable puts a limit to the lowest velocity an object can have before it goes to sleep (no more updates from the Physics engine). The lower this value, the more accurate the simulation will be, but it will also be more expensive if many objects are moving at velocities above that one.</li><li class="listitem"><strong>Angular Sleep Tolerance</strong>: The angular speed below which the rigidbody after <strong>Time to Sleep</strong> goes to sleep. Imagine the same situation as before, but instead the body is rotating really slowly. The same reasoning applies: the lower the value, the more accurate the simulation, but usually it is more expensive.</li><li class="listitem"><strong>Layer Collision Matrix</strong>: This determines which kinds of objects collide with others. By default, everything is checked, but you may want to make two particular kinds of objects not collide among them. Objects are discriminated based on the physical layer they are in. If you remember, we talked about layers and tags in Chapter 1, <em>A Flat World in Unity</em>. So, through the layer menu, you can create new layers, and in the <strong>Inspector</strong>, you can assign a layer to a particular game object. To make things easier, the <strong>Layer Collision Matrix</strong> is presented in this screenshot:</li></ul></div><div><img src="img/image00521.jpeg" alt="Physics settings in Unity"/></div><p style="clear:both; height: 1em;"> </p><p>For our game, we can leave all the default values since they are more than fine for what we need.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec57"/>Physics components</h1></div></div></div><p>The Physics engine of Unity works by components. Some describe properties of the object itself, others with respect to each other, or some even within a certain region of the game world.</p><p>They can be divided as follows:</p><div><ul class="itemizedlist"><li class="listitem">Rigidbodies: Which define a rigidbody within the Physics engine</li><li class="listitem">Colliders: Which define a physical shape for the rigidbodies</li><li class="listitem">Joints: Which impose one or more constraints on the rigidbodies</li><li class="listitem">Effectors: Which change the physical property in some region of the game world, influencing all the rigidbodies within that region</li></ul></div><div><img src="img/image00522.jpeg" alt="Physics components"/><div><p>A summary diagram of the different components of the 2D Physics engine of Unity</p></div></div><p style="clear:both; height: 1em;"> </p><p>Now, let's see them in more detail.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec58"/>Rigidbodies</h1></div></div></div><p>Rigidbodies are, along with Colliders, the core of the Physics engine beneath Unity. When they are attached to a game object, they place it under the control of the Physics engine, which will take care to properly move its Transform. In fact, they should be moved with other functions, and scripts shouldn't touch the Transform. We will see this in detail later.</p><p>The exact name of the component is <strong>Rigidbody 2D</strong> (whereas <strong>Rigidbody</strong> is for the 3D Physics engine, but for brevity many times we will use the term rigidbody to specify a <strong>Rigidbody 2D</strong> component).</p><div><h3 class="title"><a id="note63"/>Note</h3><p>From Unity 5.4, and then again in Unity 5.5, the <strong>Rigidbody 2D</strong> component has slightly changed. In fact, many improvements have been made to the Physics engine of Unity.</p></div><p>Once the component is added to a game object, it looks like this:</p><div><img src="img/image00523.jpeg" alt="Rigidbodies"/></div><p style="clear:both; height: 1em;"> </p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec59"/>How a Rigidbody 2D works</h2></div></div></div><p>Every time we wanted to position an object (or its children) or move it, we changed its Transform, which defines where it is in the space as well as how it is rotated or scaled. However, the Physics engine will simulate how the object will interact in a world where physics is simulated. So, if the object has a collision with another one, it will change direction or speed. This means that the Physics engine has to change in some way the Transform of the object (that's why we shouldn't touch it with scripts for physical objects; we will see later how to deal with them by scripting). This way is the Rigidbody component, which is a sort of hub between the Physics engine and the properties of the object, including the Transform.</p><p>Therefore, after the Physics engine has made its calculation, it communicates with the rigidbody, which needs to be in its next position, and the Rigidbody component provides to change the Transform to match that new position.</p><p>The same applies to colliders (we will see them in detail soon). Each collider attached to the same object of the rigidbody (or to some of its children) will be linked to the rigidbody, and we shouldn't modify the collider or move it but instead move the whole rigidbody. These colliders, which are linked to the rigidbody, allow the rigidbody to actually collide with colliders of another rigidbody and give them a shape in the physics world.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec60"/>Body types</h2></div></div></div><p>The most important variable in a <strong>Rigidbody 2D</strong> is the <strong>Body Type</strong>, which is highlighted in the following screenshot:</p><div><img src="img/image00524.jpeg" alt="Body types"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note64"/>Note</h3><p>If you are using a previous version of Unity (older than 5.5), this variable won't be available. However, you can still get the kinematic mode by checking the <strong>Is Kinematic</strong> parameter, which is available in older versions (from 5.4 and below). You can see this highlighted in the following screenshot (Unity 5.4):</p><div><img src="img/image00525.jpeg" alt="Body types"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>And here in Unity 5.3:</p><div><img src="img/image00526.jpeg" alt="Body types"/></div><p style="clear:both; height: 1em;"> </p><p>
</p><p>Older versions, such as 5.2 and below, are similar to the 5.3.</p></div><p>In fact, depending on how the <strong>Body Type</strong> is set, it affects the other settings available on the component. Moreover, it's important to remember that any <strong>Collider 2D</strong> attached to a <strong>Rigidbody 2D</strong> inherits the <strong>Rigidbody 2D</strong> component's <strong>Body Type</strong>.</p><p>The <strong>Body Type</strong> determines how the object will move, how the colliders will interact, and therefore also how computationally expensive that rigidbody will be.</p><p>Changing the <strong>Body Type</strong> of a <strong>Rigidbody 2D</strong> at runtime can be complicated. There are a few things that you need to consider; for example, when a <strong>Body Type</strong> changes, various mass-related internal properties are recalculated immediately. In addition, all existing contacts for the Collider 2D components attached to the Rigidbody 2D need to be reevaluated during the GameObject's next <code class="literal">FixedUpdate</code>. As a result, depending on the number of contacts and Collider 2D components that are attached to the body, when you change the <strong>Body Type</strong> of the rigidbody, it can cause variations in performance.</p><div><h3 class="title"><a id="note65"/>Note</h3><p>It's worthwhile to mention that sometimes rigidbodies are described as colliding with each other. Although this is true when we talk about physics (so when we talk of rigid bodies), it is not true in the case of Rigidbody 2D<strong> </strong>(the component of Unity). In fact, in terms of the Physics engine of Unity, only colliders attached to rigidbodies will collide. However, saying that two rigidbodies have collided is a short way of saying that their colliders have hit each other.</p></div><p>The <strong>Body Type</strong> can be set to be of three types. Let's see them in detail:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Dynamic</strong>: This means that the rigidbody will follow all dynamic calculations, which means dealing with forces that cause motion. In fact, the rigidbody will have a mass and both linear and angular drag. Moreover, the body will be affected by gravity as well. In fact, this is the default body type, since it is the most used and collides with everything. But exactly for this reason, it is also the most computationally expensive body type.</li><li class="listitem"><strong>Kinematic</strong>: This means that the body is still able to move as a physical object, but there are no forces for its motion, and therefore it is not affected by gravity either. In fact, you need to script its motion with any formula (we will see this later), which may or may not be physically realistic (or maybe it is in your game world). However, it is still able to collide, which means the Physics engine will notify your script that the rigidbody has collided, and then it's up to us what happens next. In the case of a collision with a dynamic body type, the kinematic one is considered immovable, which means with an infinite mass. In fact, all dynamic properties, such as mass, are not available. From a computational point of view, the kinematic body type is faster than the dynamic one, since not calculating all the dynamic forces demands less resources from the Physics engine.</li><li class="listitem"><strong>Static</strong>: This means the rigidbody is not supposed to move at all under the Physics engine (or under simulation). This is intended for an object with infinite mass. Under a simulation, a static Rigidbody 2D is designed to not move. In the instance of something colliding with it, a static Rigidbody 2D behaves like an immovable object (as if it has infinite mass). It is also the least resource-intensive body type to use. A static body only collides with dynamic Rigidbody 2Ds. Having two static Rigidbody 2Ds collide is not supported. This is simply because they are not designed to move. As a result, there are a limited number of properties that are available for this body type.</li></ul></div><p>To better understand the differences between these body types, here is a table with the different features available for each one of them (we will see them in detail in the next section):</p><div><img src="img/image00527.jpeg" alt="Body types"/></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec61"/>Rigidbody properties</h2></div></div></div><p>In the previous table, we saw many properties; they may or may not be available for some body types. But what do they actually do and what do they determine for the rigidbody? Let's explore these properties in detail:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Material</strong>: A physics material that determines properties of collisions, such as friction and bounce (we will see more about physics materials later). This material will be applied to all the colliders under the control of the rigidbody (we will see more about colliders in the next section). This comes in handy when you need to have many colliders with the same physics material.</li><li class="listitem"><strong>Simulated</strong>: A checkbox that enables the rigidbody to interact with the Physics engine. If it is unchecked, then the rigidbody and so all the colliders referring to it will be disabled and transparent for the Physics engine as if they don't exist. This is useful to enable and disable many colliders at runtime (see the optional <em>More about physics</em> section to know more).</li><li class="listitem"><strong>Use Auto Mass</strong>: A checkbox that, if enabled, allows Unity to calculate the mass of the object by itself. These calculations are based on the dimension and density of each of the colliders that are referring to that specific rigidbody.</li><li class="listitem"><strong>Mass</strong>: If the previous checkbox is disabled, we can manually specify a mass for our rigidbody.</li><li class="listitem"><strong>Linear Drag</strong>: The value of the linear drag that affects the rigidbody. If it is different from zero, the object will eventually stop moving.</li><li class="listitem"><strong>Angular Drag</strong>: The value of the angular drag that affects the rigidbody. If it is different from zero, the object will eventually stop rotating.</li><li class="listitem"><strong>Gravity Scale</strong>: This is a multiplier to the gravity value for that specific rigidbody. This means that a value of <code class="literal">0.4</code> will reduce the gravity to 40% of its original value. This is useful when in your game you have objects that react to gravity in a different way. Imagine a fireball cast by your wizard; you may want it to have a rather straight trajectory (even if it is still a parabola, unless the trajectory is completely straight and the <strong>Gravity Scale</strong> is set to <code class="literal">0</code>, which means no gravity affects the rigidbody). Whereas you want the grenade of your soldier to have a clear parabolic trajectory, since it is affected by gravity. Values greater than <code class="literal">1</code> lead to a stronger gravity than for its original value as shown in the following diagram:<div><img src="img/image00528.jpeg" alt="Rigidbody properties"/></div><p style="clear:both; height: 1em;"> </p><p>On the left in the preceding diagram is a fireball, which is not affected by gravity when the gravity scale is set to zero, leading to a straight line trajectory. On the right is a grenade, which is affected by gravity (because the gravity scale is greater than zero; in this case, it is exactly <code class="literal">1</code>, which means normal gravity). Without other forces, rigidbodies with a linear velocity and affected by gravity have a parabolic trajectory.</p></li><li class="listitem"><strong>Use Full Kinematic Contacts</strong>: A checkbox available only for kinematic body types. If enabled, it allows the kinematic rigidbody to collide with other kinematic rigidbodies. By default, it is set to false, which means that the rigidbody will only collide with dynamic rigidbodies (with the exception of colliders set as triggers).</li><li class="listitem"><strong>Collision Detection</strong>: The way Unity detects collisions. It can be either <strong>Discrete</strong> or <strong>Continuous</strong>. In the first case, collision detection is calculated only on the position of the physical objects, and if they collide (which means that if the colliders overlap after the update of the positions of the objects, then Unity calculates the collision). On the contrary, continuous collision detection is calculated on the trajectory itself and not only on the positions of the objects. Imagine you have a really fast bullet, which is heading against a really thin wall. Since the game is discrete (the game renders frame by frame), when the bullet is near the wall, in the next update, it can be so fast that its new position is behind the wall. As such, with discrete collision detection, the bullet has crossed the wall without problems, because the Physics engine doesn't detect any collision. With continuous collision detection instead, the Physics engine is aware of the trajectory that the bullet has followed and does calculations on it. So, even if the the final position of the bullet is behind the wall, the collision is detected and it is properly handled by the Physics engine, which recalculates the new position of the bullet taking the collision into account as shown in the following diagram:<div><img src="img/image00529.jpeg" alt="Rigidbody properties"/></div><p style="clear:both; height: 1em;"> </p><p>On the left in the preceding diagram is the discrete method, in which only the different positions between frames are taken into consideration. Therefore, if the position of the bullet in the next frame is behind the wall, the discrete method won't detect the collision. On the right is the continuous method, in which the whole trajectory of the bullet is taken into consideration. Therefore, even if in the next frame the bullet is behind the wall, the collision is detected and a new position is calculated based on the collision. This second method is a bit more computationally expensive.</p></li><li class="listitem"><strong>Sleeping Mode</strong>: This is the way Unity deals with whether a rigidbody should be awake or sleeping at the beginning, or whether it has the possibility to sleep at all. The possible choices of this variable, with self-explanatory names, are: <strong>Never Sleep</strong>, <strong>Start Awake</strong>, and <strong>Start Asleep</strong>. A rigidbody is sleeping when it is not taken completely into consideration by the Physics engine (it differs from not being simulated, and now we see why). Imagine how many objects in your game could be potently moving but they don't at the moment. For example, imagine a ball pit with thousands of balls, but at the moment none of them are moving. In this scenario, it's useless to call each one of them in the Physics engine for void calculations. Another example: imagine a pendulum that is stopping, and its oscillation arc is too small to be perceived by the player. Calculating the exact position of the pendulum on this arc is a waste of computational resources. It's better to stop the pendulum or the balls (set them into sleeping mode) until an event, such as the player diving in the ball pit or pushing the pendulum. So, for performance reasons, not all rigidbodies are awake at any moment. However, they can be awoken by an event, which is usually automatic in the Physics engine. But it can also be controlled by you within a script (we will see more details about this in the next section).</li><li class="listitem"><strong>Interpolate</strong>: When a rigidbody is moving, maybe under a force, the Physics engine performs some calculations on which will be its next position. However, the Physics engine is not perfect and cannot replicate our physics. In fact, algorithms are subjected to numerical instability, which may result in a jerky motion in our case. Therefore, Unity offers you two ways to smooth the motion and make it less jerky, plus the option <strong>None</strong>, in which no smoothing is performed. The first way, called <strong>Interpolate</strong>, takes into consideration the previous position of the rigidbody. On the contrary, the second way, called <strong>Extrapolate</strong>, takes into consideration the prevision of the next position of the object. Both methods work well, and you can perceive the difference between them and <strong>None</strong>. However, the difference between the two could be tricky to understand, especially since their behaviour is really similar, and understanding which one is better for your game can sometimes be determined just by trial and error (unless you have really specific needs).<div><img src="img/image00530.jpeg" alt="Rigidbody properties"/><div><p>On the left, the trajectory is not interpolated; it leads to a fragmented trajectory. On the right, the trajectory is interpolated and its curve is smoothed.</p></div></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>Constraints</strong>: These prevent the rigid body from moving or rotating in a certain way, if not at all. In the case of 2D, you can freeze the motion along <em>x</em> or <em>y</em> or both axes and rotation along the <em>z-</em>axis. All of them are independent checkboxes, which can be selected in any combination. Of course, having all of them selected means that the rigidbody won't be able to move. Imagine you are developing a puzzle game and your main character game needs to move a box, maybe by pushing it. However, we don't want the box to start to rotate on itself if the player doesn't push the middle point of the box. As such, we can freeze the rotation of the box, still allowing the box to move and be pushed by the main character.</li></ul></div><div><img src="img/image00531.jpeg" alt="Rigidbody properties"/><div><p>On the left, there are no constraints, and therefore when the player pushes, the object might rotate. On the right, the rotation is frozen, and when the player pushes, the object won't rotate. Which behaviour to choose depends on the design of your game.</p></div></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note66"/>Note</h3><p><strong>Info</strong><strong>: </strong>A foldout showing all the other variables of the rigidbody, which is very useful in debugging.</p></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec62"/>Dealing with rigidbodies</h2></div></div></div><p>Now that we have explored the Rigidbody 2D component in detail, let's see how we can deal with it within scripts. As previously explained, scripts are not supposed to change the Transform of a rigidbody. So how we can move them? The answer is that some special functions exist.</p><p>These functions need to be called on the rigidbody; therefore probably you may want to have a reference to the Rigidbody 2D, like this fragment of script:</p><pre class="programlisting">
<em>//Reference to the RigidBody2D component </em> &#13;
public Rigidbody2D rb2D;&#13;
&#13;
void Start() { &#13;
 <em> //Get the reference to the Rigidbody2D component</em> &#13;
  rb2D = GetComponent&lt;Rigidbody2D&gt;(); &#13;
} &#13;
</pre><p>As a result, you can call the functions in this way:</p><pre class="programlisting">Rb2D.NameOfTheFunction() &#13;
</pre><p>Where of course, instead of <code class="literal">NameOfTheFunction</code> there will be one of the functions listed next. However, if you remember, the Physics engine might be called more than once per frame, and therefore all of these functions should be called within <code class="literal">FixedUpdate()</code>.</p><p>So how can we actually move a rigidbody? For dynamic body types, we can either just leave them at the mercy of the external forces such as gravity, collisions, and so on, or we can apply a specific force.</p><p>In order to apply a force to the rigidbody, there are the following useful functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">AddForce(Vector2 force, ForceMode2D mode = ForceMode2D.Force)</code>: Applies a force specified in the <code class="literal">force</code> parameter. Moreover, enum  <code class="literal">ForceMode2D</code> is an optional parameter that specifies whether the force should act as an impulse or not. By default, it is not an impulse.</li><li class="listitem"><code class="literal">AddForceAtPosition(Vector2 force, Vector2 position, ForceMode2D mode = ForceMode2D.Force)</code>: Behaves like the previous function, but you can also specify an application point for the force.</li><li class="listitem"><code class="literal">AddRelativeForce(Vector2 relativeForce, ForceMode2D mode = ForceMode2D.Force)</code>: Behaves like the first function, but the force is specified in local coordinates.</li><li class="listitem"><code class="literal">AddTorque(float torque, ForceMode2D mode = ForceMode2D.Force)</code>: This applies a torque to the rigidbody; likewise, the first function applies instead a force.</li></ul></div><p>For kinematic body types instead, we have two functions to explicitly move these kinds of body types and still allow the Physics engine to perform collision detection correctly. Inside these functions, we directly pass a position and a rotation, which can be calculated with any formula. Therefore they can follow any physics law you want (or one that is meaningful in your game):</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">public void MovePosition(Vector2 position)</code>: Moves the rigidbody to the specified position</li><li class="listitem"><code class="literal">public void MoveRotation(float angle)</code>: Rotates the rigidbody to the specified angle</li></ul></div><div><h3 class="title"><a id="note67"/>Note</h3><p>The easiest example is to apply the classical kinematic law for velocity to make the kinematic body move in a straight line indefinitely. For the most curious of you, the formula is the following:</p><div><img src="img/image00532.jpeg" alt="Dealing with rigidbodies"/></div><p style="clear:both; height: 1em;"> </p><p>The ∆ (read delta) in physics means the final minus the initialwhich can be rewritten (by explicitly separating the delta of the space) as:</p><div><img src="img/image00533.jpeg" alt="Dealing with rigidbodies"/></div><p style="clear:both; height: 1em;"> </p><p>We can translate this into Unity with the following fragment of code (instead of <code class="literal">Time.deltaTime</code>, we need to use <code class="literal">Time.deltaFixedTime</code>):</p><pre class="programlisting">public Vector2 velocity;
void FixedUpdate () {
  rb2D.MovePosition(rb2D.position + velocity * Time.fixedDeltaTime);
} 
</pre></div><p>Moreover, we have some or the other function for all kinds of body types:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">IsAwake()</code>: Returns true if the rigidbody is awake.</li><li class="listitem"><code class="literal">IsSleeping()</code>: Returns true if the rigidbody is sleeping.</li><li class="listitem"><code class="literal">IsTouching(Collider2D collider)</code>: Returns true if the collider is touching the rigidbody (which means any of the colliders attached to the rigidbody)</li><li class="listitem"><code class="literal">OverlapPoint(Vector2 point)</code>: Returns true if the point is overlapping the rigidbody (which means any of the colliders attached to the rigidbody)</li><li class="listitem"><code class="literal">Sleep()</code>: Makes the rigidbody sleep</li><li class="listitem"><code class="literal">WakeUp()</code>: Disables the sleeping mode of the rigidbody</li></ul></div><div><h3 class="title"><a id="note68"/>Note</h3><p>For the full list of functions and variables of a Rigidbody 2D component, you can consult the official documentation here: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Rigidbody2D.html">https://docs.unity3d.com/ScriptReference/Rigidbody2D.html</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec59"/>Colliders</h1></div></div></div><p>Imagine that you have the heroine of your game moving in a complex environment; by complex, I mean detailed, for instance, the kitchen of the king's castle. If the Physics engine is super realistic, it should take in consideration that the hand of the heroine can go over the table, as far as the body stays on its side. However, this is impossible (or at least out of reach for the current hardware of your players) to run in real time. So colliders provide an approximate shape for objects and characters that need to have some kind of physical interaction, such as a collision. For instance, characters are often approximated as a capsule-shaped collider and objects with a sphere-shaped or box-shaped collider. Of course, if a deeper level of detail is required, different colliders can act as a more complex one. And ultimately, all the polygons of the 3D model (or perimeter of the 2D Sprite) can be part of the collider, having a much better realism but at the cost of performance. Therefore, you'll want to be careful to always have the right level of detail for each situation.</p><p>In Unity, colliders can be of five types, which are:</p><div><table border="1"><colgroup><col/><col/><col/></colgroup><tbody><tr><td>
<p><strong>Name</strong></p>
</td><td>
<p><strong>Appearance in the <strong>Inspector</strong>
</strong></p>
</td><td>
<p><strong>Description</strong></p>
</td></tr><tr><td>
<p><strong>Circle Collider 2D</strong></p>
</td><td>
<div><img src="img/image00534.jpeg" alt="Colliders"/></div><p style="clear:both; height: 1em;"> </p>
</td><td>
<p>The collider's shape is a circle, which is defined by a position and a radius expressed in the local coordinate.</p>
</td></tr><tr><td>
<p><strong>Box Collider 2D</strong></p>
</td><td>
<div><img src="img/image00535.jpeg" alt="Colliders"/></div><p style="clear:both; height: 1em;"> </p>
</td><td>
<p>The collider's shape is a rectangle aligned to the world axis (<em>x</em> and <em>y</em>), and it is defined with a width and a height in the local coordinate.</p>
</td></tr><tr><td>
<p><strong>Polygon Collider 2D</strong></p>
</td><td>
<div><img src="img/image00536.jpeg" alt="Colliders"/></div><p style="clear:both; height: 1em;"> </p>
</td><td>
<p>The collider's shape is defined by a freeform edge made of line segments. In this way, you can adjust it to fit the shape of the Sprite graphic with great precision. Please note that this collider's edge must completely enclose an area (unlike <strong>Edge Collider 2D</strong>).</p>
</td></tr><tr><td>
<p><strong>Edge Collider 2D</strong></p>
</td><td>
<div><img src="img/image00537.jpeg" alt="Colliders"/></div><p style="clear:both; height: 1em;"> </p>
</td><td>
<p>The collider's shape is defined by a freeform edge made of line segments. In this way, you can adjust it to fit the shape of the Sprite graphic with great precision. Unlike the <strong>Polygon Collider 2D</strong>, its edge does not necessarily enclose an area. For instance, it's possible to create an <em>N</em> shape or just a straight line.</p>
</td></tr><tr><td>
<p><strong>Capsule Collider 2D</strong></p>
</td><td>
<div><img src="img/image00538.jpeg" alt="Colliders"/></div><p style="clear:both; height: 1em;"> </p>
</td><td>
<p>The collider's shape is a capsule without vertexes (so that it is hard it remains stuck between vertexes or corners of other colliders). Moreover, it's a solid collider, so if an object is completely inside this collider, it is pushed out and detected as colliding.</p>
</td></tr></tbody></table></div><p>All of them share the same core settings, and some additional ones to customize the shape of the collider. For instance, for <strong>Circle Collider 2D</strong>, we can decide the center and the radius. However, Unity automatically tries to enclose/envelop the Sprite or 3D model within the collider, though manual tweaking may be required (see further for editing the collider in a visual way).</p><div><h3 class="title"><a id="note69"/>Note</h3><p>Since this book focuses on the 2D world, for brevity we will refer to the colliders without the ending 2D, assuming we are always referring to the 2D component and not to the 3D one with the same name. For example, <strong>Box Collider 2D</strong> becomes <strong>Box Collider</strong>.</p></div><p>Let's explore the core options of each collider:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Density</strong>: This affects the mass of the rigidbody that it is referring to. A value of zero means that the collider will be completely ignored in the calculation of the mass of the rigidbody. The higher the value, the more the collider will contribute to the mass of the rigidbody.<div><h3 class="title"><a id="note70"/>Note</h3><p>If you don't see the <strong>Density</strong> option, it's normal. In fact, it will be visible only if the option <strong>Auto Mass</strong> is enabled on the rigidbody associated (so attached on the same game object of the collider or on some of its parents up in the hierarchy). In fact, when the rigidbody component automatically calculates the mass, it takes into consideration all the colliders linked to that rigidbody and their densities.</p></div></li><li class="listitem"><strong>Material</strong>: A physics material that determines properties of collisions, such as friction and bounce (we will see more about physics materials later).</li><li class="listitem"><strong>Is Trigger</strong>: Check this if you want the collider to behave as a trigger. This means that the collider won't be used to do collisions but rather to trigger something when another collider enters within this one (see the next section for more details).</li><li class="listitem"><strong>Used By Effector</strong>: Check this if you want the collider to be used by an attached effector (we will see more about effectors later).</li><li class="listitem"><strong>Offset</strong>: This is the offset of the collider geometry expressed in local coordinates; in other words, how far in terms of <em>x</em> and <em>y</em> the collider should be from the position of the game object on which it is attached.</li><li class="listitem"><strong>Info</strong>: A foldout showing all the other variables of the collider. It is very useful in debugging.</li></ul></div><p>Then, there are the specific ones for each collider:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Radius</strong>: Used only for the circle collider, and it determines the radius of the circle.</li><li class="listitem"><strong>Size</strong>: This is used only for the box and the capsule collider. In the first case, it determines the size of the box, and in the second the size of the box that the capsule fills up (and therefore indirectly the size of the capsule) as shown in the following diagram:<div><img src="img/image00539.jpeg" alt="Colliders"/></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>Points</strong>: This is non-editable information for the polygon or edge colliders about their complexity. It describes all the points of the collider and how they are connected in paths.</li><li class="listitem"><strong>Direction</strong>: This is used only for capsule colliders and it can be set to be either <strong>Vertical</strong> or <strong>Horizontal</strong>. This controls which way round the capsule sets; specifically, it defines the positioning of the semi-circular end-caps.</li></ul></div><p>Furthermore, it is possible to visually edit the colliders by clicking on the following icon, available in all the colliders:</p><div><img src="img/image00540.jpeg" alt="Colliders"/></div><p style="clear:both; height: 1em;"> </p><p>As a result, you will able to modify the collider directly into the <strong>Scene</strong> view. It is quite intuitive, so I'll let you explore this feature by yourself.</p><div><h3 class="title"><a id="tip71"/>Tip</h3><p>You can create a vertex for the edge or polygon colliders by clicking on one of their edges.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec63"/>Dealing with colliders</h2></div></div></div><p>Often, in video games, when colliders collide, we want to trigger some actions and run specific code. For instance, imagine a bullet that hits the surface of the wall, we may want to instantiate a particle effect in the point, and remove the bullet. The same applies for a fireball, but with a fire effect. Or imagine the player walks through a door and a cut-scene is triggered. In this case, there is a volume trigger (a collider with <strong>is Trigger</strong> set to true) so that when the player enters, the volume triggers the cut-scene. Another example, is an area full of toxic gasses, and the longer the player stays in that area, his health is gradually reducing.</p><p>All of this can be achieved by using some special functions. If you remember, in <a class="link" title="Chapter 2. Baking Cupcake Towers" href="part0028.xhtml#aid-QMFO1">Chapter 2</a>, <em>Baking Cupcake Tower</em>, we have seen that every script that derives from monobehaviour could have some functions, such as <code class="literal">Start()</code> and <code class="literal">Update()</code> that are automatically called by Unity. Among these functions there are some that are called by the Physics engine of Unity.</p><p>For trigger volumes, there are the following functions:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">OnTriggerEnter2D(Collider2D other)</code>: This is called on both the rigidbody and the volume trigger when the former enters in the latter. Information about the other collider is passed as a parameter in the <code class="literal">other</code> variable.</li><li class="listitem"><code class="literal">OnTriggerStay2D(Collider2D other)</code>: This is called on every frame on both the rigidbody and the volume trigger as long as the former is within the second one. Information about the other collider is passed as a parameter in the <code class="literal">other</code> variable.</li><li class="listitem"><code class="literal">OnTriggerExit2D(Collider2D other)</code>: This is called on both the rigidbody and the trigger volume when the former leaves/exits the second one. Information about the other collider is passed as a parameter in the <code class="literal">other</code> variable.</li></ul></div><p>For colliders not set to be triggers, there are similar functions. However, instead of having just information about the other collider, information about the whole collision is available through the class <code class="literal">Collision2D</code>, which stores — other than the colliders — the contact points, relative velocities, and so on. More information about this can be found here in the official documentation at: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Collision2D.html">https://docs.unity3d.com/ScriptReference/Collision2D.html</a></p><p>So, the functions for colliders are:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">OnCollisionEnter2D(Collision2D coll)</code>: This is called on both the rigidbodies/colliders that have just made contact (had a collision). Information about the collision can be found inside the <code class="literal">coll</code> variable.</li><li class="listitem"><code class="literal">OnCollisionStay2D(Collision2D coll)</code>: This is called on both rigidbodies/colliders every frame as long as they are touching each other. Information about the collision can be found inside the <code class="literal">coll</code> variable.</li><li class="listitem"><code class="literal">OnCollisionExit2D(Collision2D coll)</code>: This is called on both two rigidbodies/colliders when they stop making contact. Information about their collision can be found inside the <code class="literal">coll</code> variable.</li></ul></div><p>In our specific case, we will need these functions (the trigger ones) to detect when the sprinkles hit the enemies, to reduce their health, and eventually trigger the right animation. We will see this at the end of the chapter.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec60"/>Joints</h1></div></div></div><p>So far, we have talked about rigid bodies and colliders, but they were just single physical bodies. What about more complex mechanical systems? Imagine a rope that is holding a cage with a skeleton and a key inside. So, our protagonist decides to cut the rope to make the cage fall. Once the rope is broken, then the cage falls down. However, even before the rope is cut, the cage was under the effect of gravity. In fact, if our protagonist would have pushed the cage instead of cutting the rope, that would have started to oscillate. The reason is that the rope is giving a constraint to the cage — it is allowed to move only within a circle (or sphere if we are in 3D) that has per radius the length of the rope. Of course, when it oscillates, gravity makes the cage move on the border of this circle (or sphere). What if the rope were a rigid metal bar? Well, the cage would even have a harder constraint, because now it is forced to be only on the border of the circle (or sphere). And if the rope was a spring? Again, this is another kind of constraint as shown in the following diagram:</p><div><img src="img/image00541.jpeg" alt="Joints"/><div><p>Although the cage is under the force of the gravity, the rope imposes a reaction force. As a result, the cage doesn't fall. Therefore, the rope imposes a constraint on the cage. In particular, it limits the cage motion to be within a circle with a radius equal to the rope length.</p></div></div><p style="clear:both; height: 1em;"> </p><p>Now, imagine placing many of these constraints together. For instance, you tie up the cage to a pending spring, and from the bottom of the cage a rope is holding a metal sphere. The system would start to increase in complexity. But how does Unity handle all of this? The answer is, using Joints components.</p><div><h3 class="title"><a id="note72"/>Note</h3><p>Note that all the joints that finish with 2D belong to the 2D Physics engine; otherwise they belong to the 3D one. So be careful to not get confused or attach the wrong joint. However, from now on, we will always refer to it as Joint 2D, even without 2D, unless otherwise specified. This decision was made to make the chapter clear and more fluid to read.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec64"/>Main properties of Joints</h2></div></div></div><p>By using a joint component, you can attach a rigidbody to another one, in order to give them a specific constraint, and still leave some freedom for the motion. In particular, Unity provides nine Joint 2D components. But before we go through each one of them, let's explore some general properties of the joints in Unity.</p><div><div><div><div><h3 class="title"><a id="ch05lvl3sec56"/>The other rigidbody</h3></div></div></div><p>As we've already said, a joint involves two rigidbodies (with the exception of the <strong>Target Joint 2D</strong>). The first is attached to the same object of the joint. The other one can be chosen arbitrarily. Therefore, these two options are available inside the joint components:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Enable Collision</strong>: Both rigidbodies will have colliders. If this toggle is true, it means that the two rigidbodies will collide between them according to the Physics engine and what we have seen so far in the previous two sections. Most of the times, rigidbodies with a joint belong to the same big system, and you don't want it to collide with itself. As such, the default value is false.</li><li class="listitem"><strong>Connected Rigid body</strong>: This is the reference to the second rigidbody of the joint, as the name suggests.</li></ul></div><p>Then, most of the joints (with the exception for the <strong>Relative Joint 2D</strong> and the <strong>Target Joint 2D</strong>) needs the two points of the application of the joint. Imagine again the example of the cage pending from the rope. Where the rope is attached to the cage is an important factor, because if the rope is attached to one of the corners of the cage, this will be rotated, as shown in this diagram:</p><div><img src="img/image00542.jpeg" alt="The other rigidbody"/></div><p style="clear:both; height: 1em;"> </p><p>We attached the rope on the cage which is important, because it will affect how it will react to forces. However, it is interesting to note that wherever you append a rigidbody, the line along the rope will pass always through the barycenter (centroid) of the rigidbody.</p><p>Plus, you need to consider the possibility that there are other forces that may move the cage, and again where the rope is attached is an important piece of information. The same applies to the other rigidbody; in the case of the cage, the other rigid body is the ceiling.</p><p>Therefore, there are some options available to determine these two points of application, which are called <strong>anchors</strong> in Unity:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Auto Configure Connected Anchor</strong>: If this is checked, Unity will take care to determine where the two anchors are. Of course, turn it off if you have a specific point of application of the joint in mind and you want to place an anchor there.</li><li class="listitem"><strong>Anchor</strong>: The position in <em>x</em> and <em>y</em> (with respect to the rigidbody) of the anchor of the joint on the rigidbody where it is attached.</li><li class="listitem"><strong>Connected Anchor </strong>: This is the position in <em>x</em> and <em>y</em> (with respect to the rigidbody of the other object) of the anchor of the joint on the rigidbody specified in the <strong>Connected Rigidbody</strong> variable.</li></ul></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec57"/>Breaking joints</h3></div></div></div><p>Coming back to the example of the suspended cage, imagine that the hero decides that it is a good idea try to jump on top of the cage and then jump on another platform. However, he didn't consider that the rope was really old (in fact, there is a skeleton in the cage!), and once he landed on the cage, the rope breaks making both the cage and our hero fall. Therefore, it's true that joints impose a constraint, but they have limits too. For the same reason, if you pull both sides of a rubber with too much force, the rubber will eventually break.</p><p>Also in Unity, Joints can be broken. In particular, in their components there are two variables:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Break Force</strong>: This is present in all the joints, and it holds the numerical value of the force after which the joint will break. Breaking a joint in Unity means to erase the Joint component from the object. By default, it is set to be infinity, which means that the joint is indestructible. Otherwise, the lower the value, the easier it is to break the joint. In the example of the cage, if we choose to give a very low value for the joint that simulates the rope, it will be likely that the rope is really old and when our hero jumps on top of the cage, they both will fall in the dungeon of the castle.</li><li class="listitem"><strong>Break Torque</strong>: This is present in all the joints other than <strong>Distance Joint 2D</strong>, <strong>Spring Joint 2D</strong>, and <strong>Target Joint 2D</strong>. It holds the numerical value of the torque after which the joint will break. As we already have seen, rigidbodies can not only move but also rotate. By default, it is set to be infinity, which means the joint is indestructible. Otherwise, it can be brought to a finite value, allowing the joint to break with torques greater than the value specified.</li></ul></div><div><h3 class="title"><a id="note73"/>Note</h3><p>For an example of a joint that breaks under torque, you can just imagine something that is rotating but it's motion is blocked by something, such as when you use the screwdriver and keep going until the wood (which was the constraint) is broken. However, here is another example that is less intuitive but more common (even in video games). Imagine you append yourself on the boarder/edge of a shelf. Since there is an offset from the center of mass of the shelf and the point where you have appended yourself (they are likely to be perpendicular if the shelf is flat), a torque is applied on the shelf. Under the effect of the torque, the shelf should rotate around its center of mass, but it doesn't since the wall prevents it. If you are heavy enough, which means the force you apply on the shelf is greater (or also if in some way you are able to increase the offset), the torque increases, until it reaches a breaking point. Then the constraint will break, which may result either in a broken shelf or a broken wall depending which one has more resistance (most probably the shelf will break and the wall will still stand). The following diagram should help you to figure the example out:</p><p>
</p><div><img src="img/image00543.jpeg" alt="Breaking joints"/></div><p style="clear:both; height: 1em;"> </p></div></div></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec65"/>Specific joints</h2></div></div></div><p>So far, we have seen only general properties of the joints in Unity, but now we will take a closer look at all the nine joint 2D components available.</p><p>It's worthy to mention that joints are divided into two classes: spring joints and motor joints. The former uses a spring to impose a constraint, which may be completely stiff so as to simulate a rigid bar. Motor joints, instead, can actively apply forces onto the rigidbodies. Some joints are both, like a spring with a motor.</p><div><h3 class="title"><a id="tip74"/>Tip</h3><p>All the joints in Unity have an icon (visible when, for instance, you place the component in the <strong>Inspector</strong>). In this book, you can see the icon in the top-left corner of the images of the joints (in the next sections). This icon is really useful for remembering what the joint does and also how it works. So, when reading the next section, or programming your game, pay attention to this icon, which might help you to understand the joint better.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec58"/>Distance Joint 2D</h3></div></div></div><p>This joint keeps the two rigidbodies at a certain distance apart. The aim of this joint is to keep at a certain distance two rigidbodies, or a rigidbody and a fixed point in the game world. In fact, if you set the <strong>Connected Rigidbody</strong> variable to <code class="literal">None</code>, you can then specify the position of the fixed point in <strong>Connected Anchor</strong>.</p><p>It should appear like the following in the <strong>Inspector</strong>:</p><div><img src="img/image00544.jpeg" alt="Distance Joint 2D"/></div><p style="clear:both; height: 1em;"> </p><p>This joint applies a linear force to both the rigidbodies (or just to the rigidbody on which it is attached if using a fixed point) with a very stiff simulated spring (which is not configurable) to keep the distance. The joint doesn't apply any torque.</p><p>In addition to the parameters that we have seen in the last section, <strong>Distance Joint 2D</strong> also has the following options:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Auto Configure Distance</strong>: If set to true, Unity will calculate the current distance between the two rigidbodies (or the rigidbody and the fixed point) and place its value in the <strong>Distance</strong> variable.</li><li class="listitem">Distance: Specifies the distance beyond which the two rigidbodies (or the rigidbody and the fixed point) cannot go further.</li><li class="listitem"><strong>Max Distance Only</strong>: If enabled, the distance between the two rigidbodies (or the rigidbody and the fixed point) can be lower than the value specified in the Distance. If this option is disabled instead, the distance is fixed and the two points cannot be any further or closer than the Distance.</li></ul></div><div><h3 class="title"><a id="note75"/>Note</h3><p>Remember that if the <strong>Break Force</strong> of the joint is a finite value, it will eventually break, even if the <strong>Max Distance Only</strong> option is set to false.</p></div><p>When <strong>Max Distance Only</strong> is false, the constraint among the two points is rigid, so you can imagine them connected by a metal string/bar along with a hinge (since they can still rotate with respect to each other). An example of how this is used is when you need to connect two couches of a train together, because they cannot get any farther or closer than a specific distance. If <strong>Max Distance Only</strong> is true, instead, they can be closer than the <strong>Distance</strong>, but not further. This is the behaviour of our rope, which holds the cage. that potentially can get closer to where the rope is tied but not further. Another example is a dog with a leash.</p><p>However, it is important to keep in mind that both the rigidbodies are free to rotate with respect to each other. In fact, this joint imposes the constraint only on the relative position of the two rigid bodies.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec59"/>Fixed Joint 2D</h3></div></div></div><p>The aim of this joint is to keep a certain relative offset (both linear and angular) between two rigidbodies or a rigidbody and a fixed point in the game world (you can specify it by setting <strong>Connected Rigidbody</strong> to <code class="literal">None</code>).</p><p>It should appear like the following in the <strong>Inspector</strong>:</p><div><img src="img/image00545.jpeg" alt="Fixed Joint 2D"/></div><p style="clear:both; height: 1em;"> </p><p>This joints applies both a linear force to compensate the linear offset, and a torque to compensate the angular one. Like <strong>Distance Joint 2D</strong>, it uses a very stiff simulated spring, but you can tweak the spring values, such as the frequency.</p><p>Therefore, in addition to the parameters we have seen in the last section, <strong>Fixed Joint 2D</strong> has also the following options:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Damping Ratio</strong>: This defines the degree to which the oscillation of the spring is suppressed. Its value ranges from 0 to 1; the higher the value, the less motion. As you would expect from a spring, this joint will overshoot the desired distance and then rebound back, leading the spring to oscillate. The <strong>Damping Ratio</strong> determines how quickly the oscillation is damped (reduced) and thus how fast the spring comes back to its rest position</li><li class="listitem"><strong>Frequency</strong>: This defines the frequency at which the spring oscillates when the rigidbodies are reaching the separation distance. It is measured in cycles per second, and its value ranges from 1 to 1 million. The higher the value, the stiffer the spring, which means less motion. It's worthwhile to notice that a value of zero means that the spring is completely stiff.</li></ul></div><p>Another way to think of this joint is like parenting GameObjects within the <strong>Hierarchy</strong> so that the children are fixed with respect to their parents. However, the joint offers you more options than a simple parenting, including the possibility to break it.</p><p>An example of usage of this joint is when you have a chain of rigidbodies (such as a real chain that hangs from the ceiling, or you can imagine also a bridge made of sections), and you want to hold them rigidly together. The advantage is that you can allow a certain flexibility in the joint, so in the case of the bridge, it can still bend a little within the limits you impose.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec60"/>Friction Joint 2D</h3></div></div></div><p>The aim of this joint is to keep to zero both the linear and angular offset, by slowing down the movement between the two rigidbodies or a rigidbody and a fixed point in the game world (you can specify it by setting <strong>Connected Rigidbody</strong> to <code class="literal">None</code>).</p><p><strong>Friction Joint 2D</strong> should appear like this in the <strong>Inspector</strong>:</p><div><img src="img/image00546.jpeg" alt="Friction Joint 2D"/></div><p style="clear:both; height: 1em;"> </p><p>In addition to the parameters we have seen in the last section, <strong>Friction Joint 2D</strong> has the following options:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Max Force</strong>: This determines the linear resistance along the line that connects the two rigidbodies. A high value (the maximum is 1,000,000) creates a strong linear resistance; thus the two rigidbodies will not move along the line that connects them much. On the contrary, a low value allows more motion.</li><li class="listitem"><strong>Max Torque</strong>: This determines the angular resistance between the two rididbodies. A high value (the maximum is 1 million) creates a strong angular resistance; thus the two rigidbodies will not rotate much relatively. On the contrary, a low value allows more motion.</li></ul></div><p>An example of the use of this joint is when there are physical objects in the game that need friction to be believable. So, imagine a platform that is anchored to a big wheel in the background. Since the game is 2D, the wheel is only an aesthetic element; it doesn't actually affect the platform. As such, we need to simulate the friction between the platform and the wheel, and we can achieve that with a <strong>Friction Joint 2D</strong>. In this way, we can have an angular resistance on the platform; thus it can still be rotated, but not so easily. Maybe, the player may drop a heavy box on the border of the platform to make it rotate enough so that the player can pass.</p><div><img src="img/image00547.jpeg" alt="Friction Joint 2D"/><div><p>On the left is the representation of the system. On the right is what will happen when the box is dropped onto the platform, which will rotate slowly due its angular friction.</p></div></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec61"/>Hinge Joint 2D</h3></div></div></div><p>The aim of this joint is to constrain the rigidbody to rotate around another rigidbody or a fixed point in space (always specified by <strong>Connected Anchor</strong> if <strong>Connected Rigid Body</strong> is set to <code class="literal">None</code>). The rotation can either be left to happen passively (for example, in response to a collision, or under the effect of gravity) or be actively powered by a motor, which provides torque to the rigidbody. Furthermore, limits can be set to constrain the hinge just to rotate at certain angles, or to allow more than a one full rotation around its axis.</p><p>It appears like the following screenshot in the <strong>Inspector</strong>:</p><div><img src="img/image00548.jpeg" alt="Hinge Joint 2D"/></div><p style="clear:both; height: 1em;"> </p><p>In addition to the parameters that we have seen in the last section, <strong>Hinge Joint 2D</strong> has the following options:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Use Motor:</strong> If enabled, it allows the joint to actively apply a torque on the rigidbody, simulating a motor.</li><li class="listitem"><strong>Motor Speed:</strong> This specifies at which speed the simulated motor should rotate in degrees per second. So a value of 30 means that the motor will do a complete rotation in 12 seconds (<em>360/30=12</em>).</li><li class="listitem"><strong>Maximum Motor Force:</strong> This specifies the maximum force that the motor can apply to reach the <strong>Motor Speed</strong>. Imagine a very heavy object requires a stronger force to rotate and thus reach the <strong>Motor Speed</strong>. If the motor is not powerful enough, it won't make the rigidbody reach the <strong>Motor Speed</strong>. Moreover, if a <strong>Break Torque</strong> is specified, it may break the joint.</li><li class="listitem"><strong>Use Limits:</strong> If true, the joint limits the angles to which the rigidbody can rotate.</li><li class="listitem"><strong>Lower Angle:</strong> This sets the lower end of the rotation arc allowed by the limit.</li><li class="listitem"><strong>Upper Angle:</strong> This sets  the upper end of the rotation arc allowed by the limit.</li></ul></div><p>A clear example of the usage of this joint is with doors. They can rotate around their hinges, which connect the door with its frame. We can limit how the door can rotate, so for instance, you may want it to rotate only of 90 degrees. Moreover, if the door is automatic, we can simulate a motor, which actively makes the door rotate. In fact, the motor may be triggered by a script. Finally, if the player wants to push the door beyond its limit (90 degrees in the example), and a <strong>Break Torque</strong> is specified, the player may break the hinge with enough force.</p><div><img src="img/image00549.jpeg" alt="Hinge Joint 2D"/><div><p>Top view (birds-eye view). On the left is the representation of the system. On the right is what will happen when the player pushes the door beyond its limits.</p></div></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec62"/>Relative Joint 2D</h3></div></div></div><p>This joint makes two rigidbodies to keep a relative position based on each other's position. In fact, the aim of this joint is the same as that of the <strong>Fixed Joint 2D</strong>; the difference lies in how they do it. The <strong>Fixed Joint 2D</strong>, as we already have seen, is a spring kind of joint that will stop to oscillate only when the two rigidbodies are at the specified offset and rotation, and so the spring is in a rest position. Instead, the <strong>Relative Joint 2D</strong> is a motor kind of joint that applies a direct force and torque to rigidbodies so that they are at the same offset and rotation.</p><p>Like the <strong>Fixed Joint 2D</strong>, the <strong>Relative Joint 2D</strong> can also work with both of these:</p><div><ul class="itemizedlist"><li class="listitem">Two rigidbodies</li><li class="listitem">A rigidbody and a fixed point</li></ul></div><p>To use the second case, set <strong>Connected Rigidbody</strong> to <code class="literal">None</code> and then specify the coordinate of the fixed point in the <strong>Linear Offset</strong> variable.</p><p>It appears like this in the <strong>Inspector</strong>:</p><div><img src="img/image00550.jpeg" alt="Relative Joint 2D"/></div><p style="clear:both; height: 1em;"> </p><p>In addition to the parameters we saw in the last section, the <strong>Relative Joint 2D</strong> has the following options:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Max Force</strong>: This specifies the maximum force that the joint/motor can use to correct the offset between the two rigidbodies. The higher the value, the better the simulated motor will be able to correct the offset. By default, <strong>Max Force</strong> is set to <code class="literal">10000</code>, which means a really powerful motor.</li><li class="listitem"><strong>Max Torque</strong>: This specifies the maximum torque that the joint/motor can use to correct the angular offset between the two rigidbodies. The higher the value, the better the simulated motor will be able to correct the angular offset. By default, <strong>Max Torque</strong> is set to <code class="literal">10000</code>, which means a really powerful motor.</li><li class="listitem"><strong>Correction Scale</strong>: Tweaks the joint to make sure that it behaves as it is supposed to. This can be done by either increasing <strong>Max Force</strong> or <strong>Max Torque</strong>, which may affect behaviour (and as a result the joint may not reach its target). Therefore, you can use this setting to correct it. The default setting of <code class="literal">0.3</code> is usually appropriate (because on an average the joint behaves as you would expect; it's a value that has likely been found by trial and error). But it may need tweaking between the range of 0 and 1.</li><li class="listitem"><strong>Auto Configure Offset</strong>: When checked, this takes the current linear and angular offsets of the two rigidbodies, stores them in the <strong>Linear Offset</strong> and <strong>Angular Offset</strong> variables, and maintains them.</li><li class="listitem"><strong>Linear Offset</strong>: This specifies the linear offset that the two rigidbodies should have, expressed in local coordinates.</li><li class="listitem"><strong>Angular Offset</strong>: This specifies the angular offset that the two rigidbodies should have, expressed in local coordinates.</li></ul></div><p>An example of use of this joint is between the camera and the Avatar in the game. In this way, the camera can follow the Avatar with a slight delay (because if the camera is parented, it will move instantaneously with the Avatar). But it won't oscillate much as with the <strong>Fixed Joint 2D</strong>, since it is a spring kind, which may cause frustration to the player (of course, this also depends on how the <strong>Fixed Joint 2D</strong> is configured, maybe with a real stiff spring; but usually the <strong>Relative Joint 2D</strong> is used for this kind of situations).</p><p>Another typical example of the use of this joint is when something should follow the player, such as a life counter above her head or a friendly spirit behind her shoulders.</p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec63"/>Slider Joint 2D</h3></div></div></div><p>Imagine you want to constrain the motion of a rigidbody just along a line, so that it can only slide onto that line. This is what the <strong>Slider Joint 2D</strong> allows you to do. As for the other joints, the line can be between two rigidbodies or a rigidbody and a fixed point in the game world.</p><p>It appears like this in the <strong>Inspector</strong>:</p><div><img src="img/image00551.jpeg" alt="Slider Joint 2D"/></div><p style="clear:both; height: 1em;"> </p><p>In addition to the parameters we have seen in the last section, the <strong>Slider Joint 2D</strong> also has the following options:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Angle</strong>: This specifies the angle at which the rigidbody is constrained to remain. In the 2D world, an angle fully specifies a direction, and this angle specifies in which direction the motion is constrained.<div><h3 class="title"><a id="note76"/>Note</h3><p>In order to fully determine the line where motion is allowed by the joint, the current position the rigidbody is taken into consideration as well. Thus, a point (the current position of the rigidbody) and a direction (specified from the <strong>Angle</strong> variable) univocally determine a line where the motion is constrained, as shown in the following diagram:</p><p>
</p><div><img src="img/image00552.jpeg" alt="Slider Joint 2D"/></div><p style="clear:both; height: 1em;"> </p></div></li><li class="listitem"><strong>Use Motor</strong>: If true, the joint uses a simulated motor as well.</li><li class="listitem"><strong>Motor Speed</strong>: This specifies the speed of the rigidbody that the motor should achieve.</li><li class="listitem"><strong>Max Motor Force</strong>: This specifies the maximum force that the motor can use/apply in order to achieve a Motor Speed for the rigidbody.</li><li class="listitem"><strong>Use Limits</strong>: If true, this allows further constraints on the rigidbody along a segment of the line.</li><li class="listitem"><strong>Lower Limit</strong>: This specifies the minimum distance the rigidbody should be at from the <strong>Connected Anchor</strong> point.</li><li class="listitem"><strong>Upper Translation</strong>: This specifies the maximum distance the rigidbody should be at from the <strong>Connected Anchor</strong> point.</li></ul></div><p>Typical scenarios where you may want to use this joint are a sliding door, which goes up and down, and also a platform, which can go left and right, up, down, or even diagonally.</p><div><img src="img/image00553.jpeg" alt="Slider Joint 2D"/><div><p>The sliding door in the diagram is constrained along a segment</p></div></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec64"/>Spring Joint 2D</h3></div></div></div><p>As the name suggests, this is a pure spring joint 2D. It actually simulates a spring connected between the two rigidbodies, or a rigidbody and a fixed point. In fact, this joint gives you all the functionalities for a spring joint, and therefore you can simulate all the other pure (without a motor) spring-joints.</p><div><h3 class="title"><a id="note77"/>Note</h3><p>In fact, the <strong>Distance Joint 2D</strong> is simulated by using the <strong>Spring Joint 2D</strong> with <strong>Frequency</strong> set to <code class="literal">0</code> and <strong>Damping Ratio</strong> to <code class="literal">1</code>.</p></div><p>It appears like the following in the <strong>Inspector</strong>:</p><div><img src="img/image00554.jpeg" alt="Spring Joint 2D"/></div><p style="clear:both; height: 1em;"> </p><p>In addition to the parameters we have seen in the last section, the <strong>Spring Joint 2D</strong> has the following options:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Distance</strong>: This specifies the distance that the two rigidbodies (or the rigidbody and the fixed point) should keep. You can imagine it also like the length of the spring in its rest position, which means the length of the spring when no forces are applied on it.</li><li class="listitem"><strong>Damping Ratio</strong>: This specifies how much you want to suppress the motion of the spring. Its value ranges from 0 to 1. Lower values mean a movable spring, higher values mean a stiff spring. If it is set to 1, the spring is not movable.</li><li class="listitem"><strong>Frequency</strong>: This specifies the frequency at which the spring oscillates while the objects are approaching the separation distance (which is the length of the spring in the rest position) specified in the <strong>Distance</strong> variable (measured in cycles per second). It ranges from 0 to 1,000,000. The higher the value, the stiffer the spring will be.</li></ul></div><p>Whenever you need to place a spring in your game, this is the right joint. So, an example could be a physically realistic Launchpad, which you need to compress the spring, so as to let it have a boost in your jump. However, you don't need necessarily to think of this joint as a normal spring. In fact, you can bring this joint to the limits (such as a very stiff spring). As such, you are able to create other behaviours that in reality don't have a spring, but in the game they look nice when connected by a spring. Have you ever played <em>Rayman</em>? The character has its body parts separated, but they still move together in a coherent way in the game. If you are planning to create a similar character, the spring joint can be a valid solution to link the body parts in a realistic way. Here is an image of <em>Rayman</em>:</p><div><img src="img/image00555.jpeg" alt="Spring Joint 2D"/><div><p>Image of <em>Rayman</em>. As you can see, the character doesn't have legs or arms, but has hands and feet. In your game, you can attach them to the chest through a Spring Joint.</p></div></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec65"/>Target Joint 2D</h3></div></div></div><p>The <strong>Target Joint 2D</strong> is a particular spring-type joint that, instead of having a second rigidbody, has a target. The aim is to keep the rigidbody where the component is attached at a certain distance from the target. It only applies a linear force; thus no torque is given to the rigidbody.</p><p>It appears like this in the <strong>Inspector</strong>:</p><div><img src="img/image00556.jpeg" alt="Target Joint 2D"/></div><p style="clear:both; height: 1em;"> </p><p>Since this component doesn't have a second rigidbody, there are some variables that allow you to specify the target:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Anchor</strong>: Defined in local coordinates, with respect to the rigidbody, where the joint is attached on the rigidbody.</li><li class="listitem"><strong>Target</strong>: Defined in local coordinates, with respect to the rigidbody, where the other end of the joint tries to move.</li><li class="listitem"><strong>Auto Configure Target</strong>: When checked, it sets the <strong>Target</strong> to the current position of the rigidbody, which is useful when our rigidbody is moved around, maybe driven by other forces. Furthermore, when this option is selected, the <strong>Target</strong> changes as you move the rigidbody; on the contrary, it won't if the option is not selected.</li></ul></div><p>Moreover, it is possible to control the characteristic of the spring with the usual parameters:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Max Force</strong>: This specifies the maximum force that the joint can use on the rigidbody</li><li class="listitem"><strong>Damping Ratio</strong>: This specifies how much the motion of the spring is suppressed (refer to either the <em>Spring 2D Joint</em> or <em>Fixed 2D Joint</em> section for more details)</li><li class="listitem"><strong>Frequency</strong>: This specifies the frequency of the spring (refer to either the <em>Spring 2D Joint</em> or <em>Fixed 2D Joint</em> section for more details)</li></ul></div><p>An example of the use of this joint is when the player needs to drag objects with the mouse. In this scenario, you can set the target of the object dragged to the cursor, so it will follow the cursor, without having a rigid movement (as if we would set frame after frame the position of the object to the mouse coordinates). Moreover, you can use the <strong>Anchor</strong> to specify where the object should be attached. For instance, if the player started to drag from a corner of the object, you can set the <strong>Anchor</strong> to be there, and as a result, the object will hang from that point.</p><div><h3 class="title"><a id="note78"/>Note</h3><p>You can find this joint in one of the exercises of the last chapter to improve the look of your game.</p></div></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec66"/>Wheel Joint 2D</h3></div></div></div><p>The Wheel Joint 2D is a combination of a spring and motor kind of joint, and it has a very specific usage. As the name suggests, it simulates the constraint that a wheel can impose on a body. In particular, it can rotate the wheel with a motor (the wheel moves) and simulate suspensions with a spring.</p><p>More specifically, the joint applies a linear force to both connected rigid bodies to keep them on the line, an angular motor to rotate them on the line, and a spring to simulate the wheel suspension.</p><div><h3 class="title"><a id="note79"/>Note</h3><p>It is interesting to note that you can reconstruct a <strong>Wheel Joint 2D</strong> with the combination of a <strong>Slider Joint 2D</strong> (with both <strong>Use Motor</strong> and <strong>Use Limits</strong> off) and a <strong>Hinge Joint 2D</strong> (with <strong>Use Limits</strong> off).</p></div><p>It appears like the following in the <strong>Inspector</strong>:</p><div><img src="img/image00557.jpeg" alt="Wheel Joint 2D"/></div><p style="clear:both; height: 1em;"> </p><p>As you can see from the preceding screenshot, the parameters are divided into <strong>Suspension</strong>, which defines a spring, and a motor. Both use the same parameters we have already seen respectively for springs (with the exception of <strong>Angle</strong>) and motors.</p><p>The suspension is defined by the following:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Angle</strong>: This specifies the angle (in degrees in world coordinates) where the suspension happens. By default, it is set to <code class="literal">90</code> degrees, which means the suspension will happen upwards, as usually happens for a car (the body of the car is on top of the wheels, so the direction of the suspension is along the positive <em>y</em>-axis, which means 90 degrees) as shown in the following diagram:<div><img src="img/image00558.jpeg" alt="Wheel Joint 2D"/></div><p style="clear:both; height: 1em;"> </p><p>In this diagram, we can see the the angle of the suspension for the wheel of the car is at 90 degrees, which means upwards in the game world. This is the default value. Imagine you want to have a car that is able to run on the ceiling thanks to magnetic wheels; you may consider changing the angle of the suspension. In the case of the ceiling, it is the opposite of the normal situation, so the angle will be 270 degrees.</p></li><li class="listitem"><strong>Damping Ratio</strong>: This specifies how much the motion of the spring is suppressed (refer to either the <em>Spring 2D Joint</em> or <em>Fixed 2D Joint</em> section for more details).</li><li class="listitem"><strong>Frequency</strong>: This specifies the frequency of the spring (refer to either the <em>Spring 2D Joint</em> or <em>Fixed 2D Joint</em> section for more details).</li></ul></div><p>The motor is defined by:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Motor Speed</strong>: This specifies the speed that the motor should achieve on the wheel</li><li class="listitem"><strong>Max Motor Force</strong>: This specifies the maximum force that the motor can apply on the wheel in order to achieve <strong>Motor Speed</strong> on the wheel</li></ul></div><p>Needless to tell you which is the most common usage of this joint. Every time in your game you have a wheel and it needs to move in a realistic manner, this joint is the deal for you.</p><div><h3 class="title"><a id="tip80"/>Tip</h3><p>If you want to create a car controlled by the player, you can attach this joint to the wheels and set <strong>Motor Speed</strong> to <code class="literal">0</code> to control this variable through your script based on the player's input. Moreover, you can use <strong>Max Motor Force</strong> to simulate the different gears.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec61"/>Effectors</h1></div></div></div><p>Imagine our hero is crossing an enchanted room, so he starts to float due a powerful spell. In this case, while the hero is within this room, gravity should be contrasted by a (magical) force. As a result, we need to specify that in that room, there is a force that makes our hero levitate.</p><p>Similarly, imagine the hero drops a box in a lake. The box doesn't sink at the same velocity as it falls; moreover, it might float. Therefore, in our game, we need to specify that the region delimited by the lake has special physical properties.</p><div><img src="img/image00559.jpeg" alt="Effectors"/><div><p>There are some special regions of the game world where the physical laws could be different from the rest of the game world; in Unity, these regions can be specified with effectors</p></div></div><p style="clear:both; height: 1em;"> </p><p>In Unity, this can be achieved by using effectors. Effectors are some components that affect the behaviour of rigidbodies in certain region of the game world. They are really different from each other, because they do different things, although the core concept is the same: they affect one or more rigidbodies that come into the region that they control.</p><p>Effectors use collision detection to know which are the rigidbodies within their region, and therefore, as we already mentioned before, the rigidbodies need to have a collider. Otherwise, they won't be affected by the effector.</p><p>Moreover, the effectors themselves need their own collider to work. This, in order to be used by the effector they should have the <strong>Used By Effector</strong> property set to true. Otherwise, the effector will not affect any rigidbody. If the collider of the effector should be set to be the trigger or not depends both on the kind of effector and on what are you trying to achieve, although there is a default way to set it (in fact, Unity gives you a warning in case you are using the effector in an unusual way).</p><p>We will see this case by case, and here is a summary table with the effectors, saying whether the collider should use <strong>is Trigger</strong> or not:</p><div><table border="1"><colgroup><col/><col/></colgroup><tbody><tr><td>
<p><strong>Effector</strong></p>
</td><td>
<p><strong>Linked collider should be a trigger?</strong></p>
</td></tr><tr><td>
<p>Constant Force 2D</p>
</td><td>
<p>This component is attached to rigidbodies, not colliders</p>
</td></tr><tr><td>
<p>Area Effector 2D</p>
</td><td>
<p>True</p>
</td></tr><tr><td>
<p>Buoyancy Effector 2D</p>
</td><td>
<p>True</p>
</td></tr><tr><td>
<p>Point Effector 2D</p>
</td><td>
<p>True</p>
</td></tr><tr><td>
<p>Platform Effector 2D</p>
</td><td>
<p>False</p>
</td></tr><tr><td>
<p>Surface Effector 2D</p>
</td><td>
<p>False</p>
</td></tr></tbody></table></div><p>All of them (with the exception of Constant Force 2D) have a couple of variables to determine which rigidbodies are affected by the effector, and these variables are:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Use Collider Mask</strong>: If enabled, this allows you to discriminate the colliders that enter in the area through layers specified in the next variable.</li><li class="listitem"><strong>Collider Mask</strong>: This determines which layers are affected by the effector. Once again, remember that you can learn how to add layers in <a class="link" title="Chapter 2. Baking Cupcake Towers" href="part0028.xhtml#aid-QMFO1">Chapter 2</a>, <em>Baking Cupcake Towers
</em>. So, in this variable, you can specify one of them through the use of a drop-down menu.</li></ul></div><p>Let's see each one of them in detail to better understand how they work.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec66"/>Constant Force 2D</h2></div></div></div><p>This is not a proper effector, because instead of acting in an area or region, it is directly applied onto a rigidbody. So it needs to be attached to the same game object that has the rigidbody component.</p><p>Here is how it appears in the <strong>Inspector</strong>:</p><div><img src="img/image00560.jpeg" alt="Constant Force 2D"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note81"/>Note</h3><p>Out of curiosity, for this component, there is a 3D counterpart: <strong>Constant Force</strong>.</p></div><p>As the name suggests, it applies a constant force to the rigidbody. Usually this is used in testing to easily apply a force from the <strong>Inspector</strong>, but it can also be used in the normal gameplay if we need an object that is always under the control of a constant force (so that it will keep pushing). Of course, it's value can be changed through script to make it a non-constant force, but in that case it is preferable to apply the force directly with a function in the script. The component should be used only for constant forces or forces that don't change over time (the force can change, but for long periods of time it remains constant).</p><p>Moreover, this component also can be used to apply a torque on the rigidbody.</p><p>Here are the three variables:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Force</strong>: The constant force to apply to the rigidbody.</li><li class="listitem"><strong>Relative Force</strong>: The constant force to apply to the rigidbody expressed with respect to the rigidbody coordinates</li><li class="listitem"><strong>Torque</strong>: The constant torque to apply to the rigidbody</li></ul></div><p>Here is an example of usage that is not testing. Suppose you are doing a game where different objects are affected by different gravitational forces. So for instance, brown boxes will follow on the ground as usual, but green boxes will follow on the right because as per your game design they are supposed to do so. The reason could be an experimental serum invented to change gravity for things that are green. In this scenario, the green boxes cannot be affected by normal gravity, so you can place on them a rigidbody and set <strong>Gravity Scale</strong> to <code class="literal">0</code>. In this way, it won't be affected by normal gravity. Then, place on it the <strong>Constant 2D</strong> force component and set your gravity. Moreover, if all the objects have different <strong>Constant 2D</strong> forces, you can change their gravity force in real time, maybe after the invention of another serum, which changes the gravity on the left instead of the right.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec67"/>Area Effector 2D</h2></div></div></div><p>This component defines an area within which a force is applied to all the rigidbodies inside the area. You can configure the force at any angle with a specific magnitude and random variation on that magnitude. You can also apply both linear and angular drag forces to slow down rigidbody 2Ds.</p><p>This effector, in order to work, requires a collider with both <strong>Used By Effector</strong> and <strong>is Trigger</strong> set to true. In fact, rigidbodies should be able to enter in it.</p><p>The component has two foldouts (expandable menu options) for the relative options to set, <strong>Force</strong> and <strong>Damping</strong>, as we can see from this diagram, which shows the component in the <strong>Inspector</strong>:</p><div><img src="img/image00561.jpeg" alt="Area Effector 2D"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note82"/>Note</h3><p>The two foldouts appear only in recent versions of Unity. So if you are using an old version and you don't see them, don't worry; the options have just been reordered, but they still work as described here.</p></div><p>All the variables have intuitive names, but let's go through them quickly:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Use Global Angle</strong>: If checked, the next variable will be interpreted in the world coordinates, and local coordinates otherwise.</li><li class="listitem"><strong>Force Angle</strong>: This is the angle of the force to apply, and so it defines the direction.</li><li class="listitem"><strong>Force Magnitude</strong>: This is the magnitude, which means the intensity of the force.</li><li class="listitem"><strong>Force Variation</strong>: This is the variation of the magnitude of the force so as to not have always a constant force and improve realism. Be careful not to give too high value, which may quickly result in undesired behaviour.</li><li class="listitem"><strong>Force Target</strong>: This can be either the <strong>Rigidbody</strong> or <strong>Collider</strong>. In the first case, the force will always be applied to the center of the mass. In the second case, if the collider is not on the center of the mass, the force will also generate torque for the rigidbody.</li><li class="listitem"><strong>Drag</strong>: This is the linear drag to apply within the region.</li><li class="listitem"><strong>Angular Drag</strong>: This is the angular drag to apply within the region.</li></ul></div><p>Here is an example of the use of this component. Suppose that there is a special device which is able to push the magnetic shoes of the main character to contrast gravity. So, in the area just above this device, you can place an area effector, specifying a force that goes upwards. Please note that if the intensity of the force is less than the gravity, then your character will have a big jump, but eventually she will fall down. Whereas with a greater value, even without a jump she starts to levitate upwards until either an obstacle or the end of the area effector is met.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec68"/>Buoyancy Effector 2D</h2></div></div></div><p>This component is used to simulate a fluid, and so it can potentially make rigidbodies floating. It requires a collider with both <strong>Used By Effector</strong> and <strong>is Trigger</strong> set to true. In fact, rigidbodies should be able to enter it.</p><p>It appears like the following in the <strong>Inspector</strong>:</p><div><img src="img/image00562.jpeg" alt="Buoyancy Effector 2D"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note83"/>Note</h3><p>As we can see from this screenshot, there are two foldouts to help the logical order of the component. Don't worry if they aren't there. You may be using an older version of Unity.</p></div><p>The main variables are the following:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Density</strong>: This indicates the density of the fluid, and it affects how the different rigidbodies are affected by the effector depending on the rigidbody density as well. In fact, rigidbodies with a higher density will sink, those with a lower density will float, and those with the same density of the fluid will be suspended in the fluid.</li><li class="listitem"><strong>Surface Level</strong>: This indicates where the surface of the fluid is with respect to the Transform (the position) of the game object where the effector is attached. A value of zero means that the surface will lie on the center of the object, and it is placed in the middle of the collider (only if the collider doesn't have any offset). You can recognize it from the blue line in the <strong>Scene</strong> view.</li><li class="listitem"><strong>Drag</strong>: This is the linear drag to apply within the region below the surface.</li><li class="listitem"><strong>Angular Drag</strong>: This is the angular drag to apply within the region below the surface.</li><li class="listitem"><strong>Flow Angle</strong>: This specifies the angle, in world coordinates, where the flow force of the effector is applied. Therefore, it defines the direction of the force.</li><li class="listitem"><strong>Flow Magnitude</strong>: This specifies the intensity of the flow force, and therefore the level of buoyancy of the effector. It can assume negative values, and in this case, it's as if <strong>Flow Angle</strong> has been rotated by 180 degrees.</li><li class="listitem"><strong>Flow Variation</strong>: This indicates how much <strong>Flow Magnitude</strong> can vary, so as to not have it constant and therefore achieving a higher level of realism.</li></ul></div><p>The component appears like this in the <strong>Scene</strong> view, to actually show where the surface level is:</p><div><img src="img/image00563.jpeg" alt="Buoyancy Effector 2D"/></div><p style="clear:both; height: 1em;"> </p><p>Furthermore, here is an example of its usage. Suppose that in your 2D game there is the sea, and the main character has to jump on some platforms in the harbor. Placing this effector at the level of the sea will make its behaviour more realistic. For instance, the main character can push a wooden box down in the sea, which will float, and so she can jump on top of the floating box to cross.</p><div><img src="img/image00564.jpeg" alt="Buoyancy Effector 2D"/><div><p>An example of use of the Buoyancy Effector 2D, which is able to simulate the sea and make the wooden boxes float; as a result, the player can jump on top of the wooden box and cross the sea</p></div></div><p style="clear:both; height: 1em;"> </p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec69"/>Point Effector 2D</h2></div></div></div><p>You can imagine this component to be a magnet of rigidbodies, so it can push/repulse or attract them, which is concentrated at a single point, as the name of the effector suggests. The point can be determined by either the collider (most used) or the rigidbody attached to the same game object of the effector.</p><p>The component requires a collider with both <strong>Used By Effector</strong> and <strong>is Trigger</strong> set to true. In fact, rigidbodies should be able to enter in it.</p><p>It appears like this in the <strong>Inspector</strong>:</p><div><img src="img/image00565.jpeg" alt="Point Effector 2D"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note84"/>Note</h3><p>Once again, the foldouts are only in recent versions of Unity.</p></div><p>The main variables are the following:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Force Magnitude</strong>: The magnitude, which means the intensity of the force.</li><li class="listitem"><strong>Force Variation</strong>: The variation of the magnitude of the force in order not to always have a constant force and improve realism. Be careful not to give too high value, which may quickly result in undesired behaviours.</li><li class="listitem"><strong>Distance Scale</strong>: When the distance between the rigidbody and the attractive or repulsive point is calculated, it is scaled by (multiplied by) <strong>Distance Scale</strong>. As such, you are able to modify the behaviour of the effector (see <strong>Force Mode</strong> in this list).</li><li class="listitem"><strong>Force Source</strong>: This can be either a <strong>Rigidbody</strong> or <strong>Collider</strong>. In the first case, the point that attracts or repulses will be placed on the center of the rigidbody (which means at its center of the mass). In the second case, it will be placed in the middle of the collider.</li><li class="listitem"><strong>Force Target</strong>: This can be either a <strong>Rigidbody</strong> or <strong>Collider</strong>. In the first case, the force will always be applied to the center of the mass of the rigidbody entering in the effector. In the second case, if the collider is not centered on the center of the mass, the force will also generate torque for the rigidbody.</li><li class="listitem"><strong>Force Mode</strong>: This specifies how the force is calculated, and it can be of three types. <strong>Constant</strong> is the most intuitive. The force is always constant regardless of the distance between the rigidbody affected by the effector and the point that repulses or attracts. This means that only the relative positions between the rigidbody and the point are taken into consideration to determine the direction of the force, which lies on both. Instead, in <strong>Inverse Linear</strong>, the force changes its intensity based on the distance between the rigidbody and the point. For double the distance, half intensity of the force. Finally, <strong>Inverse Squared</strong>, which in most cases is the most physically realistic, takes the square of the distance into consideration. This means, for double the distance, a quarter the intensity of the force.<div><img src="img/image00566.jpeg" alt="Point Effector 2D"/><div><p>Differences between the different force modes</p></div></div><p style="clear:both; height: 1em;"> </p><p>In this diagram, on the left is a repulsive point effector. Below is a distance scale, all included within the range of the point effector. Suppose that at a distance of half alpha, three different rigidbodies have the same applied force from the point of effect. At a distance of alpha, the constant mode will keep its whole force applied on the rigidbody. The <strong>Inverse Linear</strong> mode will halve the force by doubling the distance. Finally, the <strong>Inversed Squared</strong> mode (which is the most physically realistic, since both the gravitation and the electromagnetic forces have this behaviour) will have a quarter of the force it would have half way closer to the point effector.</p></li><li class="listitem"><strong>Drag</strong>: This is the linear drag to apply within the region of the effector.</li><li class="listitem"><strong>Angular Drag</strong>: This is the angular drag to apply within the region of the effector.</li></ul></div><p>Here is an example of its usage. Suppose the main character has a special ring that, when active, attracts metal (when the ring is not, it will attract the main character's wife). Therefore, every time that the player activates the ring, the game activates a point effector on the main character, and through the <strong>Collision Mask</strong> variable, only metals can be selected.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec70"/>Platform Effector 2D</h2></div></div></div><p>This component gives the effect of a platform for 2D games. For instance, it implements the one-way collision. So if the character jumps from below the platform, he will cross it, but when he lands on top, the platform will give a collision, maintaining the character on top of the platform. Moreover, it can be used to remove side-friction/bounce.</p><div><img src="img/image00567.jpeg" alt="Platform Effector 2D"/><div><p>With this effector, the player is able to cross a collider in one direction but not the other way round. In some platform games, the player is able to jump on top of the platform by jumping underneath it, but he or she cannot fall back.</p></div></div><p style="clear:both; height: 1em;"> </p><p>In fact, this is the most used component to build platform games. Think about games like <em>Braid</em>, where the player is able to jump on top of a platform from a platform that is underneath.</p><p>The component requires a collider with <strong>Used By Effector</strong> set to true but not <strong>is Trigger</strong>. In fact, rigidbodies should be able to collide with it.</p><p>This is how it appears in the <strong>Inspector</strong>:</p><div><img src="img/image00568.jpeg" alt="Platform Effector 2D"/></div><p style="clear:both; height: 1em;"> </p><div><h3 class="title"><a id="note85"/>Note</h3><p>Once again, the foldouts are present only in recent versions of Unity. Moreover, the rotational offset is a parameter that has been added recently.</p></div><p>And here you can see one possible instance in the <strong>Scene</strong> view of this component. </p><div><img src="img/image00569.jpeg" alt="Platform Effector 2D"/><div><p>This is how the effector appears in the Scene view when its gizmos are active</p></div></div><p style="clear:both; height: 1em;"> </p><p>The big arc on top defines from which direction the platform/collider is not traversable, whereas the two small side arcs define which direction is considered the side of the platform.</p><p>The main variables are the following:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Rotational Offset</strong>: This indicates the angular offset in degrees of the whole platform effector. This has been added recently in Unity, and thanks to it, it is possible to rotate the platform effector so as to have platforms that are inclined, or walls that can be crossed one way. For instance, you can use it also for magical portals that can be crossed one way.</li><li class="listitem"><strong>Use One Way</strong>: If checked, the platform will collide only in one direction.</li><li class="listitem"><strong>Use One Way Grouping</strong>: This ensures that all contacts disabled by the one-way behaviour act on all colliders. This is useful when multiple colliders are used on the object passing through the platform and they all need to act together as a group.</li><li class="listitem"><strong>Surface Arc</strong>: This specifies in degrees how wide the arc on top of which the collision will be performed is. In all the other directions, if <strong>Use One Way</strong> is enabled, it won't allow any collision, allowing any rigidbody to pass through, such as your character.</li><li class="listitem"><strong>Use Side Friction</strong>: If true, friction is applied to the side of the platform effector.</li><li class="listitem"><strong>Use Side Bounce</strong>: If true, bounce is applied to the side of the platform effector.</li><li class="listitem"><strong>Side Arc</strong>: This specifies the degree for both the right and left side (if the <strong>Rotational Offset</strong> is set to <code class="literal">0</code>; otherwise it may indicate up and down) that are considered the sides of the platform effector. So, if <strong>Use Side Friction</strong><strong>or </strong>and<strong> Use Side Bounce</strong> is enabled, this will be applied along the arc specified here.</li></ul></div><p>Besides the classical use of this component to create platform games, let's see another example in which we may want to use it. Imagine a puzzle game where some portals can be crossed only in one direction. As such, we can place a platform effector and set its <strong>Rotational Offset</strong> so as to have the colliding part only on one side of the portal. As a result, the character will be able to cross the magical portal only in one direction, and not in the other way round as shown in the following diagram:</p><div><img src="img/image00570.jpeg" alt="Platform Effector 2D"/></div><p style="clear:both; height: 1em;"> </p><p>This is an example of how it is possible to use this effector in another way that is not the classical platform. By rotating the component through the <strong>Rotational Offset</strong>, it is possible to make a magical portal which is crossable in one way, but not in another. This could be an interesting game mechanic for a puzzle game.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec71"/>Surface Effector 2D</h2></div></div></div><p>This component applies a tangential force to the surface specified by the collider associated with this effector. In other words, you can imagine this as a conveyor belt, which transports rigidbodies along the direction of the force, as far as they are touching the surface.</p><p>This is how it appears in the <strong>Inspector</strong>:</p><div><img src="img/image00571.jpeg" alt="Surface Effector 2D"/></div><p style="clear:both; height: 1em;"> </p><p>It is possible to have access to the options of the <strong>Surface Effector 2D</strong> through two foldouts, and you can find the parameter that you can set here:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Speed</strong>: The speed that the tangential force should maintain. In other words, it's the speed of the conveyor belt.</li><li class="listitem"><strong>Speed Variation</strong>: The maximum variation of the speed, so as to not have always a constant speed, especially if you have many of these effectors. The random variation ranges from zero to the value in <strong>Speed Variation</strong>. Therefore, a positive value brings a random increment, whereas a negative value brings a random decrement.</li><li class="listitem"><strong>Speed Scale</strong>: This allows you to scale the tangential force that is applied when the effector tries to accelerate the contacting rigidbodies to the specified speed along the surface. If it is set to <code class="literal">0</code>, then no force is actually applied, and it is like that the component is disabled. On the other hand, if it is set to <code class="literal">1</code>, means that the full force is applied. A useful way to think of this parameter is to think about how fast the rigidbody, which is in contact with the surface, is then accelerated to meet the specified speed; lower values means it will require more time, whereas higher values means it will reach the speed much quicker. However, you should be careful to use the full force, since a rigidbody might face other forces, leading the rigidbody to an undesired motion.</li><li class="listitem"><strong>Use Contact Force</strong>: If true, a contact force will be used. Although it is more physically realistic, it may impress a torque to the rigidbody contacting the surface. As such, in video games where realism depends on the design, you can choose to enable it, since the default is disabled. An easy way to imagine this is that you are jumping on a real conveyor belt. The contact force along with the tangential force of the conveyor belt will make your legs move forward, but your chest will stay behind due to inertia, which may result in you falling. That means your body has started to rotate due a torque as shown in the following diagram:<div><img src="img/image00572.jpeg" alt="Surface Effector 2D"/></div><p style="clear:both; height: 1em;"> </p></li></ul></div><p>In this example, when you jump on the conveyor belt, your legs are brought forward by the tangential force of the belt. Your chest, instead, stays behind due to inertia, leading to an applied torque on your body, and therefore you will fall. In Unity, it is possible to disable the contact force, so as to ensure that a torque is not applied to rigidbodies that enter in contact with the conveyor belt.</p><div><ul class="itemizedlist"><li class="listitem"><strong>Use Friction</strong>: If true, there will be friction on the surface</li><li class="listitem"><strong>Use Bounce</strong>: If true, there will be bounce on the surface</li></ul></div><p>Of course, the natural example of usage is when in your game a conveyor belt is used. But let's try to find out another example. Suppose that the protagonist of your game has a special glove that when it touches a metal wall, it is able to contrast gravity by creating a magnetic field. You can place a surface effector vertically, and apply a force upwards as far as the player is touching that wall.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec62"/>Physics Material 2D</h1></div></div></div><p>Unity also offers the possibility to create physics materials so as to adjust the friction and bounciness of a physical object when it collides with another one. In the case of 2D, this is enabled by the <strong>Physics Material 2D</strong>.</p><p>You can create a <strong>Physics Material 2D</strong> by selecting <strong>Assets | Create | Physics Material 2D</strong> from the top-bar menu as shown in the following screenshot:</p><div><img src="img/image00573.jpeg" alt="Physics Material 2D"/></div><p style="clear:both; height: 1em;"> </p><p>Once selected in the project panel, we can tweak its two values in the <strong>Inspector</strong>, as shown here:</p><div><img src="img/image00574.jpeg" alt="Physics Material 2D"/></div><p style="clear:both; height: 1em;"> </p><p>It's worthwhile mentioning that we have seen many variables during this chapter to assign a <strong>Physics Material 2D</strong>, and they are structured in a simple hierarchy:</p><div><ol class="orderedlist arabic"><li class="listitem">If a <strong>Collider</strong> has a <strong>Physics Material 2D</strong>, this takes the priority and will be set to <strong>Collider</strong>.</li><li class="listitem">If a <strong>Collider</strong> doesn't have a <strong>Physics Material 2D</strong>, then it will be assigned the one in the <strong>Rigidbody2D</strong>.</li><li class="listitem">If even the <strong>Rigidbody2D</strong> doesn't have a <strong>Physics Material 2D</strong>, then the default <strong>Physics Material 2D </strong>will be assigned. The default <strong>Physics Material 2D</strong> can be set in <strong>Physics Settings</strong>.</li></ol><div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec63"/>Dealing with physics in Unity</h1></div></div></div><p>So far, everything went smooth and we learned about all the single components of the Physics engine of Unity. However, when it comes to building your own game, dealing with physics might be a little bit tricky. In fact, just some wrong values on some forces and the whole scene can quickly mess up. The best way to solve this is by trial and error. The more you experiment, the more you will become practical with the Physics engine, and you will develop an intuition on how to balance all the values in your game. As a result, you will be able to make your scene act as described in the game design document (or almost).</p><p>Dealing with physics isn't just about placing the different components, but also about how to program them. We have already seen some useful functions to apply on a rigidbody as well as some events when two colliders hit each other. But there is more. First of all, it's important to understand that all the variables we have seen of all the components (such as rigidbodies, colliders, joints, and effectors) can be assigned dynamically at runtime with a script. You just need to get a reference to that component, and then you will be able to change its internal parameters.</p><p>One more thing that can come in handy is the possibility to query the Physics engine through some functions in order to gather some information about the surroundings. These are static functions of the <code class="literal">Physics2D</code> class, and so they can be called with the following fragment of code:</p><pre class="programlisting">Physics2D.NameOfTheFunction(); &#13;
</pre><p>Of course, you need to substitute <code class="literal">NameOfTheFunction</code> with the function. The <code class="literal">Physics2D</code> class exposes many of these, but let's explore just the main ones:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">OverlapCircleAll(Vector2 point, float radius, [<em>optional parameters]</em>)</code>: This returns the arrays of <code class="literal">Collider2D</code> which are all within the circle specified by the <code class="literal">radius</code> and <code class="literal">point</code> (the center of the circle) variables. In other words, it detects all the colliders that are within the specified circle. From the collider, it is possible to retrieve the game object itself as well. Our cupcake towers will use this function to detect how many enemies there are around. Furthermore, other optional parameters of the function are available to specify a mask of layers and the min and max values for the depth (<em>z</em>-axis) in which the function should search.</li><li class="listitem"><code class="literal">OverlapCircle(Vector2 point, float radius, [<em>optional parameters]</em>)</code>: The same function as before, but instead of returning the full array, it returns the first occurrence. It is useful when you just need to detect whether something is present within the circle.</li><li class="listitem"><code class="literal">RaycastAll(Vector2 origin, Vector2 direction, [<em>optional parameters]</em>)</code>: This shoots a ray from an <code class="literal">origin</code> towards a <code class="literal">direction</code>, and returns all the different colliders that the ray hits within an array of <code class="literal">RayCastHit2D</code> (see later), which is a class that specifies all the details of the hit, including the collider. This function is useful when you need to verify if something is present somewhere in the space. Furthermore, other optional parameter can specify the maximum distance that the ray can reach, a mask of layers, and the min and max values for the depth (<em>z</em>-axis).</li><li class="listitem"><code class="literal">Raycast(Vector2 origin, Vector2 direction, [<em>optional parameters]</em>)</code>: The same function as the previous one, but instead of returning the full array, it returns only the first hit.</li></ul></div><div><h3 class="title"><a id="note86"/>Note</h3><p>You can find all the functions of the <code class="literal">Physics2D</code> class in the official documentation here: <a class="ulink" href="https://docs.unity3d.com/ScriptReference/Physics2D.html">https://docs.unity3d.com/ScriptReference/Physics2D.html</a>.</p></div><p>About the <code class="literal">RayCastHit2D</code> class, here is the list of information that we can retrieve:</p><div><ul class="itemizedlist"><li class="listitem"><code class="literal">centroid</code>: The centroid of the primitive used to perform the cast</li><li class="listitem"><code class="literal">collider</code>: The collider hit by the ray</li><li class="listitem"><code class="literal">distance</code>: The distance from the origin of the ray to the impact point</li><li class="listitem"><code class="literal">fraction</code>: The fraction of the distance along the ray that the hit occurred</li><li class="listitem"><code class="literal">normal</code>: The normal vector of the surface hit by the ray</li><li class="listitem"><code class="literal">point</code>: The point in the world space where the ray hit the collider's surface</li><li class="listitem"><code class="literal">rigidbody</code>: The <code class="literal">Rigidbody2D</code> attached to the object that was hit</li><li class="listitem"><code class="literal">transform</code>: The Transform of the object that was hit</li></ul></div><p>In conclusion, querying the Physics engine is a common practice to gather information, and we will do it with our <em>Tower </em>Defense game.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec64"/>Other things about Physics</h1></div></div></div><p>As with other chapters, this is an optional section with some deeper insights into the topic covered in the chapter. So, feel free to skip this section if you are not interested, and jump directly onto the next section. Otherwise, just grab some more coffee and keep reading.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec72"/>The Simulate setting on rigidbodies</h2></div></div></div><p>This aim of this section is to explain the difference between enabling and disabling physical components on a rigidbody and enabling and disabling the <strong>Simulate</strong> settings on top of the rigidbody component.</p><p>Every time that a physical component is either added, enabled, removed, or disabled, the internal memory of the Physics engine is updated (respectively to add or remove the component from the memory). When the <strong>Simulate</strong> setting is disabled, the Physics engine just stops to perform calculations on it - it doesn't erase the object from the memory. As a result, when <strong>Simulate</strong> is checked back, the Physics engine has already all the objects/components in the memory and it doesn't' need to create them from scratch, thus leading to a performance improvement.</p><p>Of course, if you need to remove a rigidbody permanently from the scene, then just erase the component, because if you just uncheck <strong>Simulate</strong>, the component will still be in memory, leading to a poor memory management.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec73"/>Physics Raycaster 2D component</h2></div></div></div><p>Back in Chapter 3, <em>Communicating with the Player – the User Interface</em>, we have seen the Unity UI system, and in the optional section there were the different components of a canvas. One of them was the <strong>Graphical Raycaster</strong>, which is able to detect the input of the user on the screen. This component checks if the player actually went over a slider or clicked a button, and then triggers events by exchanging messages with the event system.</p><p>If we have physics objects and we want to exchange events about them in a similar way the <strong>Graphical Raycaster</strong> does for the UI, we can use a Physics Raycaster 2D component on a camera to handle such events.</p><p>Once this component is added, you can implement different interfaces in the scripts of your physics objects. As a result, the functions that they will implement will be automatically called when the corresponding event is triggered.</p><p>For instance, an event could be that a joint breaks, and you may want to run some code when this happens. Moreover, some information will be provided to the functions; in the case of the joint, the amount of force that broke the joint is passed as a parameter.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec74"/>The other Physics settings</h2></div></div></div><p>Here you can find the other Physics settings:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Velocity Iterations</strong>: The number of iterations that are made to determine the velocity of a physical body during an update. The higher is the number, the more accurate the simulation will be. The drawback is computational cost. The default value is <code class="literal">8</code>.</li><li class="listitem"><strong>Position Iterations</strong>: The number of iteration made to determine the position of a physical body during an update. The higher is the number, the more accurate the simulation will be. The drawback is computational cost. The default value is <code class="literal">3</code>.</li><li class="listitem"><strong>Velocity Threshold</strong>: Collisions with a relative velocity lower than this value are treated as inelastic collisions, which means that the colliding bodies will not bounce off each other.</li><li class="listitem"><strong>Max Linear Correction</strong>: The maximum linear position correction used when solving constraints. It can have any value between <code class="literal">0.0001</code> to <code class="literal">1000000</code>. It helps to prevent overshooting.</li><li class="listitem"><strong>Max Angular Correction</strong>: The maximum angular correction used when solving constraints. It can have any value between <code class="literal">0.0001</code> to <code class="literal">1000000</code>. It helps to prevent overshooting.</li><li class="listitem"><strong>Max Translation Speed</strong>: This is the maximum (translation) speed that a body in your game could have. This value is the upper limit, which means that every object that tries to reach faster velocities, will be cap to this value.</li><li class="listitem"><strong>Max Rotation Speed</strong>: This is the maximum (rotation) speed that a body in your game could have. The same reasoning as before applies, just with rotations instead of translations.</li><li class="listitem"><strong>Min Penetration For Penalty</strong>: The minimum contact penetration radius allowed before any separation impulse force is applied.</li><li class="listitem"><strong>Baumgarte Scale</strong>: This is a scale factor that determines how fast collision overlaps are resolved (see the information box).</li><li class="listitem"><strong>Baumgarte Time Of Impact Scale</strong>: A scale factor that determines how fast time-of-impact overlaps are resolved (see the information box).</li></ul></div><div><h3 class="title"><a id="note87"/>Note</h3><p>Baumgarte's constraint stabilization method (sometimes just abbreviated to Baumgarte's method) is an algorithm for resolving certain collision constraints, such as with joints, invented by J. Baumgarte in 1972. It is fast enough so that it can be used in real-time applications such as video games or robotics. The trick consists of taking advantage of some derived analytic forms of differential equations that are solved numerically. This allows you to run the algorithm not only faster than its predecessors but also with a higher degree of accuracy.</p><p>The <strong>Baumgarte Scale</strong> is the important parameter for the algorithm, which represents the correction ratio to apply. A common value, which is often given as default, is <code class="literal">0.2</code> and it is also the default value that Unity uses.</p><p>The higher the value, the more your joints will go wild. On the other hand, the lower the value, the less your joints will do, and it can cause sponginess.</p></div><div><ul class="itemizedlist"><li class="listitem"><strong>Queries Hit Trigger</strong>: This is a toggle that if true allows raycasts to hit also trigger volumes. By default, it is true, but can be unchecked in case you don't want raycasting to hit trigger volumes, but just colliders. When to uncheck this box really depends on the design of your game, and what you have in mind to program it.<div><img src="img/image00575.jpeg" alt="The other Physics settings"/><div><p>When Queries Hit Trigger is set to false (upper part of diagram<em>)</em>, trigger volumes won't be detected by raycasting. On the contrary, when Queries Hit Trigger is set to true (lower part of diagram), also trigger volumes will be detected by raycasting and returned as a hit.</p></div></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>Queries Start In Collider</strong>: This is a toggle that, if true, allows raycasts that start within a collider to what hit that collider. By default, it is true, but can be unchecked if many of your raycasts start within a collider and you don't want them to be returned as hits. Again, when to uncheck this box really depends on the design of your game, and also you have in mind to program it.<div><img src="img/image00576.jpeg" alt="The other Physics settings"/><div><p>When Queries Start In Collider is set to false (upper part of diagram) and the the source of the raycast is within a collider, this one won't be returned as a hit. On the contrary, when Queries Start In Collider is set to true (lower part of diagram), also the collider in which there is the source of the raycast is returned as a hit.</p></div></div><p style="clear:both; height: 1em;"> </p></li><li class="listitem"><strong>Change Stops Playback</strong>: This is a toggle that, if true, stops reporting collision callbacks immediately if any of the GameObjects involved in the collision are deleted or moved. By default, it is false.</li><li class="listitem"><strong>Gizmos</strong>: (The description of this foldout is in the next section.)</li></ul></div><div><div><div><div><h3 class="title"><a id="ch05lvl3sec67"/>Gizmos for colliders</h3></div></div></div><p>This section describes the previous menu item, <strong>Gizmos</strong>, in the <strong>Physics 2D</strong> settings.</p><p><strong>Gizmos</strong> is a foldout that shows you extra options about the visualizations of colliders within the editor. These options are really useful in debugging. This is how it appears in the <strong>Inspector</strong>:</p><div><img src="img/image00577.jpeg" alt="Gizmos for colliders"/></div><p style="clear:both; height: 1em;"> </p><p>Here is an explanation of the options displayed and their usage:</p><div><ul class="itemizedlist"><li class="listitem"><strong>Always Show Colliders</strong>: By default, you are able to see a collider only when a game object (or one of its children) contains such a collider. If you enable this option, you will always be able to see colliders (whenever <strong>Gizmos</strong> are visible).</li><li class="listitem"><strong>Show Collider Sleep</strong>: When enabled, it allows you to see a collider even when it is in sleep mode within the Physics engine</li><li class="listitem"><strong>Collider Awake Color</strong>: This specifies the color that awake (no-sleeping) colliders should have when shown. By default, it is a light green with the alpha channel (opacity) set to <code class="literal">192</code>.</li><li class="listitem"><strong>Collider Sleep Color</strong>: This specifies the color that sleeping colliders should have when shown. By default, it is the same light green as when the collider is awake, but with the alpha channel (opacity) set to <code class="literal">92</code>.</li><li class="listitem"><strong>Show Collider Contacts</strong>: When enabled, this allows you to see the contacts point of the colliders when they collide. They are shown as arrows (as shown in the next diagram).</li><li class="listitem"><strong>Contact Arrow Scale</strong>: This value allows you to scale down the arrow showed by the contact points of the collider. By default, its value is <code class="literal">0.2</code> (as shown in the next diagram).</li><li class="listitem"><strong>Collider Contact Color</strong>: This specifies the color of such arrows representing the contact points of the collider. By default, it is set to light purple (as shown in the next diagram):<div><img src="img/image00578.jpeg" alt="Gizmos for colliders"/></div><p style="clear:both; height: 1em;"> </p><p>On the left there are two colliders that are overlapping with each other. In the middle, the colliders are updated by the Physics engine to simulate the collisions (since they cannot overlap). Also shown are the points of contact between the two arrows. On the right, there is the same diagram that is in the middle, but with the <strong>Contact Arrow Scale</strong> set to <code class="literal">0.6</code> instead of <code class="literal">0.2</code>, and as a result the arrows are bigger.</p></li><li class="listitem"><strong>Show Collider AABB</strong>: When enabled, this allows you to see the <strong>Axis-Aligned Bounding Box</strong> (<strong>AABB</strong>) of the collider. As the name suggests, it is a box that fully contains the collider, and it is aligned with the axis of the world frame. For example, the bounding box of a polygonal collider is the following (on the left):<div><img src="img/image00579.jpeg" alt="Gizmos for colliders"/></div><p style="clear:both; height: 1em;"> </p></li></ul></div><p>On the left is the polygonal collider with its AABB; on the right is the same diagram as the previous one, but showing its AABB.</p><div><ul class="itemizedlist"><li class="listitem"><strong>Collider AABB Color</strong>: This specifies the color of the AABB of the collider, when shown</li></ul></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec65"/>Physics for our game</h1></div></div></div><p>In this section we will apply some concepts of this chapter into our game. In particular, we will see how to detect when a sprinkle hits a panda and applies damage to it using the Physics engine.</p><div><div><div><div><h2 class="title"><a id="ch05lvl2sec75"/>Set up Pandas as a rigidbodies</h2></div></div></div><p>Since we will take advantage of the Physics engine, we need to proper set up the Panda as that to be a physical object in the scene. This means giving it a rigidbody component.</p><p>Therefore, we can start by adding a 
<strong>Rigidbody2D</strong> component to the Panda prefab, and set its 
<strong>Body Type</strong> as 
<strong>Kinematic</strong>, as shown in the following screenshot:</p><div><img src="img/image00580.jpeg" alt="Set up Pandas as a rigidbodies"/></div><p style="clear:both; height: 1em;"> </p><p>In theory, we should have done, since the Panda is considered a physical object now. However, in the previous chapter, we have written a function that allows the Panda to move by assigning its new position directly on its Transform. Since now the Panda has a <strong>Rigidbody2D</strong> component, we cannot do in this way anymore (as we already explained previously in the <em>Rigidbodies</em> section). Therefore, we need to slightly modify the <code class="literal">PandaScript</code>. In particular, we need to get a reference to the rigidbody of the Panda, then use the <code class="literal">MovePosition()</code> function for Kinematic rigidbodies. Basically, we are applying what we have learnt in the <em>Dealing with rigidbodies</em> section.</p><p>Hence, open the script, and add the following private variable:</p><pre class="programlisting">
<em>//Private variable to store the rigidbody2D</em>&#13;
private Rigidbody2D rb2D;</pre><p>Then, in the <code class="literal">Start()</code> function add this line at the end of the function:</p><pre class="programlisting">
<em>//Get the reference to the Rigidbody2d</em>&#13;
rb2D = GetComponent&lt;Rigidbody2D&gt;();</pre><p>In the <code class="literal">MoveTowards()</code> function, we need to use the <code class="literal">MovePosition()</code> function on the Panda's rigidbody to change its position. In addition, we shouldn't use <code class="literal">deltaTime</code> anymore, and substitute it with <code class="literal">fixedDeltaTime</code>. As such, here is highlighted what is changed from the previous chapter:</p><pre class="programlisting">
<em>//Function that based on the speed of the Panda makes it moving towards the destination point, specified as Vector3</em>&#13;
private void MoveTowards(Vector3 destination) {&#13;
<em>  //Create a step and then move in towards destination of one step</em>&#13;
  float step = speed * <strong>Time.fixedDeltaTime</strong>;&#13;
<strong>  rb2D.MovePosition(</strong>Vector3.MoveTowards(transform.position,&#13;
    destination, step)<strong>);&#13;
</strong>}</pre><div><h3 class="title"><a id="note88"/>Note</h3><p>We need to remember that the <code class="literal">MoveTowards()</code> function, now, should be called within a <code class="literal">FixedUpdate()</code> and not in the <code class="literal">Update()</code>. We will see this in <a class="ulink" href="https://cdp.packtpub.com/b03794gettingstartedwithunity2dgamedevelopmentsecondedition/wp-admin/post.php?post=220&amp;action=edit#post_247">Chapter 7</a>, <em>Trading Cupcakes and the Ultimate Battle for the Cake – Gameplay Programming</em>. But you can have an example in the next section.</p></div><p>Finally, we can save the script, and we have done with the Panda.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec76"/>Set up projectiles as rigidbodies</h2></div></div></div><p>Similar to what we did for the Pandas, we need to add a <strong>Rigidbody2D</strong> component to all the projectiles, and again set the <strong>Body Type</strong> to <strong>Kinematic</strong>.</p><p>If you remember, also projectiles used to move by changing directly their Transforms, and we need to fix this, since they have a <strong>Rigidbody2D</strong> component as well.</p><p>Open the script, and as we did for the Pandas, add the following private variable:</p><pre class="programlisting">
<em>//Private variable to store the rigidbody2D</em>&#13;
private Rigidbody2D rb2D;</pre><p>Then, in the <code class="literal">Start()</code> function, let’s get the reference to it:</p><pre class="programlisting">
<em>//Get the reference to the Rigidbody2d</em>&#13;
rb2D = GetComponent&lt;Rigidbody2D&gt;();</pre><p>Now, we need to replace the <code class="literal">Update()</code> function with the <code class="literal">FixedUpdate()</code> one, since we are dealing with the Physics engine. Moreover, we need to slightly change the code (note also the use of the <code class="literal">fixedDeltaTime</code>):</p><pre class="programlisting">
<em>// Update the position of the projectile according to time and speed</em>&#13;
void FixedUpdate() {&#13;
  rb2D.MovePosition(transform.position + direction *&#13;
    Time.fixedDeltaTime * speed);&#13;
}</pre><div><h3 class="title"><a id="note89"/>Note</h3><p>A careful reader would notice that we are applying the equation of motion explained in the information box within the <em>Dealing with rigidbodies</em> section. In particular, here we have split the velocity into a direction and a speed (which multiplied them together give back the velocity).</p></div><p>Save the script, and let’s see how we can detect when a sprinkle hits a panda in the next section.</p></div><div><div><div><div><h2 class="title"><a id="ch05lvl2sec77"/>Detect sprinkles</h2></div></div></div><p>In order to detect a collision between a sprinkle and a Panda, we need to add them both a <strong>Collider2D</strong>. You can choose the one that better suits your needs, I'll go for the <strong>Box2D</strong> collider. Then, you need to make one of them act as a Trigger, in our example we can take the Panda.</p><p>The next step is to implement the <code class="literal">OnTriggerEnter2D()</code> function, which is called from the Physics engine of Unity, on the <code class="literal">PandaScript</code>. As a result, we are able to detect when something hits the panda, and check if it is an actual sprinkle, so to apply damage to the panda with the <code class="literal">Hit()</code> function written in the previous chapter.</p><pre class="programlisting">
<em>//Function that detects projectiles</em>&#13;
void OnTriggerEnter2D(Collider2D other) {&#13;
  <em>//Check if the other object is a projectile</em>&#13;
  if(other.tag == "Projectile") {&#13;
  <em>  //Apply damage to this panda with the Hit function</em>&#13;
    Hit(other.GetComponent&lt;ProjectileScript&gt;().damage);&#13;
  }&#13;
}</pre><div><h3 class="title"><a id="note90"/>Note</h3><p>Of course, we need to be sure that every object with the Projectile tag have a <strong>ProjectileScript</strong> component attached. This check is left as an exercise.</p></div><p>Finally, save the script, and we have done with Physics for our game, at least in this chapter. In fact, in the next chapter, we will use again the Physics engine, but for other reasons.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec66"/>Homework</h1></div></div></div><p>As in every chapter, here are some exercises that you can use to practice your skills:</p><div><ol class="orderedlist arabic"><li class="listitem"><strong>The forgotten rigidbody</strong>: Sometimes components in the <strong>Inspector</strong> could be forgotten. However, we can facilitate the process by creating warnings in the code. For both our Panda and the sprinkles, create within their scripts a check, when the game object is initialized, to add a <strong>Rigidbody2D</strong> component, if missing, and set it to be <strong>Kinematic</strong>. Additionally, you can print a warning message (See <a class="link" title="Chapter 8. What Is beyond the Cake?" href="part0100.xhtml#aid-2VBO82">Chapter 8</a>, <em>What Is beyond the Cake?</em>, for more about debugging messages).</li><li class="listitem"><strong>Passion for acceleration</strong>: In the chapter, we saw how we could implement motion equations for our <strong>Kinematic</strong> rigidbodies. In particular, the chapter shown an implementation of the velocity equation. Now, try to implement the acceleration equation for a <strong>Kinematic</strong> rigidbody.</li><li class="listitem"><strong>Joint Master</strong>: For each one of the joints that Unity offers, think about a possible usage and example (possibly different from the ones already presented in the chapter). Then, sketch the physical system on paper, and determine which are the rigidbodies and where the anchor points are. Finally, reproduce what you have imagined within Unity, and tweak all the settings until it works as you have decided.</li><li class="listitem"><strong>Effector Master</strong>: For each one of the effectors that Unity offers, think about a possible usage and example (possibly different from the ones already presented in the chapter). Then, sketch how the effector should work on paper, and determine how the different rigidbodies would interact with it. Finally, reproduce what you have imagined within Unity, and tweak all the settings until it works as you have decided.</li><li class="listitem"><strong>A less dauntless Panda (Part III)</strong>: If you also completed the second part of this exercise back in <a class="link" title="Chapter 4. No Longer Alone – Sweet-Toothed Pandas Strike" href="part0056.xhtml#aid-1LCVG1">Chapter 4</a>, <em>No Longer Alone - Sweet-Toothed Pandas Strike</em>, some pandas will be stunned, others not, depending on the Boolean value. Instead of exposing this Boolean within the <strong>Inspector</strong>, add this property to the <code class="literal">Projectile</code> class, so that if the Panda is stunned or not depends on which kind of projectile the Panda was hit with (we will see this later in <a class="link" title="Chapter 6. Through a Sea of Sprinkles – Navigation in Artificial Intelligence" href="part0077.xhtml#aid-29DRA1">Chapter 6</a>, <em>Through a Sea of Sprinkles – Navigation in Artificial Intelligence</em>).</li><li class="listitem"><strong>A less dauntless Panda (Part IV)</strong>: After you have done part three of this exercise, if the poor panda is under attack with too many sprinkles, it might not move anymore because it is always in a stunned state. As a result, it won't able to avoid the sprinkles either. So as to avoid this, we need to modify the Panda script such that if another sprinkle hits the Panda while it is stunned, it detracts the health from the Panda; but doesn't trigger from the beginning the hit animation and/or the stun period.</li><li class="listitem"><strong>A less dauntless Panda (Part V)</strong>: Now that you have also completed the third part of this exercise, let's improve the whole system of stunning a Panda. Add to each projectile, a variable that indicates the chance of this projectile to stunning a Panda. Finally, trigger the stunning phase of the Panda probabilistically based on the previous variable.<p>Finally, if you are into challenges, here is one for you:</p></li><li class="listitem"><strong>The frozen conveyor belt (Part I)</strong>: Imagine a conveyor belt that is made of a big piece of ice and scrolls quite fast. Think and describe what would happen when a box is dropped onto it. Keep in mind that the friction on the ice is really low, and that there is inertia to consider. What if, instead of a box, there was a sphere? The solution is available at the end of the book.</li><li class="listitem"><strong>The frozen conveyor belt (Part II)</strong>: Once you have done Part I, reproduce the frozen conveyor belt within the Physics engine of Unity, and try it out with boxes and spheres.</li></ol><div></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec67"/>Summary</h1></div></div></div><p>In this chapter, we started by learning some basic notions of physics so as to better develop our games. Then, we went through the Physics engine of Unity, which is divided into some components. Rigidbodies and colliders describe the properties of physical objects in the game, whereas joints and effectors affect how they react with each other in the environment.</p><p>Finally, we saw how to deal with physics and took what we needed for our <em>Tower Defense</em> game, so as to implement the collision between a sprinkle and a Panda (and call the right functions to update the Panda's health and animations).</p></div></body></html>