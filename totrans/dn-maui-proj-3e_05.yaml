- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: A Matchmaking App with a Rich UX Using Animations
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用动画的丰富 UX 的匹配应用
- en: In this chapter, we will create the base functionality for a matchmaking app.
    We won’t be rating people, however, because of privacy issues. Instead, we will
    download images from a random source on the internet. This project is for anyone
    who wants an introduction to how to write reusable controls. We will also look
    at using animations to make our application feel nicer to use. This app will not
    be a **Model-View-ViewModel** (**MVVM**) application since we want to isolate
    the creation and usage of a control from the slight overhead of MVVM.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建匹配应用的基线功能。然而，由于隐私问题，我们不会对人员进行评分。相反，我们将从互联网上的随机来源下载图片。这个项目是为那些想要了解如何编写可重用控件的人准备的。我们还将探讨如何使用动画使我们的应用程序更易于使用。这个应用将不会是一个**模型-视图-视图模型**（**MVVM**）应用程序，因为我们想将控件创建和使用与
    MVVM 的轻微开销隔离开来。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Creating a custom control
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建自定义控件
- en: Styling the app to look like a photo, with descriptive text beneath it
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将应用程序样式设计成照片样式，并在其下方添加描述性文本
- en: Creating animations using .NET MAUI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 .NET MAUI 创建动画
- en: Subscribing to custom events
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 订阅自定义事件
- en: Reusing the custom control over and over again
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用自定义控件
- en: Handling pan gestures
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理平移手势
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To be able to complete this chapter’s project, you will need to have Visual
    Studio for Mac or Windows installed, as well as the necessary .NET MAUI workloads.
    See *Chapter 1*, *Introduction to .NET MAUI*, for more details on how to set up
    your environment.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够完成本章的项目，您需要安装 Visual Studio for Mac 或 Windows，以及必要的 .NET MAUI 工作负载。有关如何设置环境的更多详细信息，请参阅
    *第 1 章*，* .NET MAUI 简介*。
- en: You can find the full source for the code in this chapter at [https://github.com/PackPublishing/MAUI-Projects-3rd-Edition](https://github.com/PackPublishing/MAUI-Projects-3rd-Edition).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://github.com/PackPublishing/MAUI-Projects-3rd-Edition](https://github.com/PackPublishing/MAUI-Projects-3rd-Edition)找到本章代码的完整源代码。
- en: Project overview
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: 'Many of us have been there, faced with the conundrum of whether to swipe left
    or right. All of a sudden, you may find yourself wondering: *How does this work?
    How does the swipe magic happen?* Well, in this project, we’re going to learn
    all about it. We will start by defining a `MainPage` file in which the images
    of our application will reside. After that, we will implement the image control,
    and gradually add the **graphical user interface** (**GUI**) and functionality
    to it until we have nailed the perfect swiping experience.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人都曾面临过这样的困境：是滑动左键还是右键。突然间，你可能开始 wonder：*这是怎么工作的？滑动魔法是如何发生的？* 好吧，在这个项目中，我们将学习所有关于它的知识。我们将从定义一个`MainPage`文件开始，我们的应用程序图像将驻留在其中。之后，我们将实现图像控制，并逐渐添加**图形用户界面**（**GUI**）和功能，直到我们打造出完美的滑动体验。
- en: The build time for this project is about 90 minutes.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 该项目的构建时间大约为 90 分钟。
- en: Creating the matchmaking app
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建匹配应用
- en: In this project, we will learn more about creating reusable controls that can
    be added to an **Extensible Application Markup Language** (**XAML**) page. To
    keep things simple, we will not be using MVVM, but bare-metal .NET MAUI without
    any data binding. What we aim to create is an app that allows the user to swipe
    images, either to the right or the left, just as most popular matchmaking applications
    do.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个项目中，我们将学习更多关于创建可重用控件的知识，这些控件可以添加到**可扩展应用程序标记语言**（**XAML**）页面中。为了保持简单，我们不会使用
    MVVM，而是使用不带任何数据绑定的裸机 .NET MAUI。我们的目标是创建一个允许用户左右滑动图片的应用程序，就像大多数流行的匹配应用一样。
- en: Well, let’s get started by creating the project!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，让我们从创建项目开始吧！
- en: Setting up the project
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置项目
- en: This project, like all the rest, is a **File** | **New** | **Project...**-style
    project. This means that we will not be importing any code at all. So, this first
    section is all about creating the project and setting up the basic project structure.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目，就像所有其他项目一样，是一个**文件** | **新建** | **项目...**风格的程序。这意味着我们不会导入任何代码。因此，这个第一部分完全是关于创建项目和设置基本项目结构。
- en: Let’s get started!
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Creating the new project
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建新项目
- en: So, let’s begin.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们开始吧。
- en: 'The first step is to create a new .NET MAUI project:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个新的 .NET MAUI 项目：
- en: 'Open Visual Studio 2022 and select **Create a** **new project**:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 2022 并选择**创建一个** **新项目**：
- en: '![Figure 5.1 – Visual Studio 2022](img/B19214_05_1.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.1 – Visual Studio 2022](img/B19214_05_1.jpg)'
- en: Figure 5.1 – Visual Studio 2022
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.1 – Visual Studio 2022
- en: This will open the **Create a new** **project** wizard.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 **创建新项目** 向导。
- en: 'In the search field, type `maui` and select the **.NET MAUI App** item from
    the list:'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中，键入 `maui` 并从列表中选择 **.NET MAUI 应用** 项：
- en: '![Figure 5.2 – Create a new project](img/B19214_05_2.jpg)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.2 – 创建一个新项目](img/B19214_05_2.jpg)'
- en: Figure 5.2 – Create a new project
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.2 – 创建一个新项目
- en: Click **Next**.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步**。
- en: 'Complete the next step of the wizard by naming your project. We will be calling
    our application `Swiper` in this case. Move on to the next dialog box by clicking
    **Create**, as illustrated in the following screenshot:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过命名您的项目来完成向导的下一步。在这种情况下，我们将我们的应用程序命名为 `Swiper`。通过点击 **创建**，如图所示，继续到下一个对话框：
- en: '![Figure 5.3 – Configure your new project](img/B19214_05_3.jpg)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.3 – 配置您的全新项目](img/B19214_05_3.jpg)'
- en: Figure 5.3 – Configure your new project
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.3 – 配置您的全新项目
- en: Click **Next**.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **下一步**。
- en: 'The last step will prompt you for the version of .NET Core to support. At the
    time of writing, .NET 6 is available as **Long-Term Support** (**LTS**), and .NET
    7 is available as **Standard Term Support**. For this book, we will assume that
    you will be using .NET 7:'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步将提示您选择要支持的 .NET Core 版本。在撰写本文时，.NET 6 可用为 **长期支持**（**LTS**），.NET 7 可用为 **标准期限支持**。对于这本书，我们假设您将使用
    .NET 7：
- en: '![Figure 5.4 – Additional information](img/B19214_05_4.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.4 – 补充信息](img/B19214_05_4.jpg)'
- en: Figure 5.4 – Additional information
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.4 – 补充信息
- en: Finalize the setup by clicking **Create** and wait for Visual Studio to create
    the project.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过点击 **创建** 并等待 Visual Studio 创建项目来完成设置。
- en: Just like that, the app has been created. Let’s start by designing the `MainPage`
    file.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，应用程序已经创建。让我们先设计 `MainPage` 文件。
- en: Designing the MainPage file
  id: totrans-42
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 设计 MainPage 文件
- en: A brand new .NET MAUI Shell app named `Swiper` has been created, with a single
    page called `MainPage.xaml`. This is in the root of the project. We will need
    to replace the default XAML template with a new layout that will contain our `Swiper`
    control.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 已创建一个名为 `Swiper` 的新 .NET MAUI Shell 应用程序，包含一个名为 `MainPage.xaml` 的单页。这位于项目的根目录中。我们需要将默认的
    XAML 模板替换为包含我们的 `Swiper` 控件的新布局。
- en: 'Let’s edit the already existing `MainPage.xaml` file by replacing the default
    content with what we need:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过替换默认内容来编辑已存在的 `MainPage.xaml` 文件：
- en: Open the `MainPage.xaml` file.
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainPage.xaml` 文件。
- en: 'Replace the content of the page with the following highlighted XAML code:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将页面内容替换为以下突出显示的 XAML 代码：
- en: '[PRE0]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The XAML code within the `ContentPage` node defines two grids in the application.
    A grid is simply a container for other controls. It positions those controls based
    on rows and columns. The outer grid, in this case, defines two rows that will
    cover the entire available area of the screen. The first row is 400 units high
    and the second row, with `Height="*"`, uses the rest of the available space.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentPage` 节点内的 XAML 代码定义了应用程序中的两个网格。网格简单地是一个其他控件的容器。它根据行和列定位这些控件。在这种情况下，外部网格定义了两个将覆盖整个屏幕可用区域的行。第一行高
    400 个单位，第二行，使用 `Height="*"`，使用剩余的可用空间。'
- en: The inner grid, which is defined within the first grid, is assigned to the second
    row with the `Grid.Row="1"` attribute. The row and column indexes are zero-based,
    so `"1"` actually refers to the second row. We will add some content to this grid
    later in this chapter, but we’ll leave it empty for now.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在第一个网格内的内部网格，通过 `Grid.Row="1"` 属性分配给第二行。行和列索引是从零开始的，所以 `"1"` 实际上指的是第二行。我们将在本章的后面添加一些内容到这个网格中，但现在我们先让它保持为空。
- en: Both grids define their padding. You could enter a single number, meaning that
    all sides will have the same padding, or – as in this case – enter two numbers.
    We have entered `0,40`, which means that the left- and right-hand sides should
    have `0` units of padding and the top and bottom should have `40` units of padding.
    There is also a third option, with four digits, which sets the padding of the
    *left-hand* side, the *top*, the *right-hand* side, and the *bottom*, in that
    specific order.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 两个网格都定义了它们的填充。您可以输入一个数字，这意味着所有边都将有相同的填充，或者 – 如此案例中 – 输入两个数字。我们输入了 `0,40`，这意味着左侧和右侧应该有
    `0` 个单位的填充，顶部和底部应该有 `40` 个单位的填充。还有一个第三个选项，使用四个数字，它设置了 *左侧*、*顶部*、*右侧* 和 *底部* 的填充，按照特定的顺序。
- en: The last thing to notice is that we give the outer grid a name, `x:Name="MainGrid"`.
    This will make it directly accessible from the code-behind defined in the `MainPage.xaml.cs`
    file. Since we are not using MVVM in this example, we will need a way to access
    the grid without data binding.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 最后要注意的是，我们给外层网格起了一个名字，`x:Name="MainGrid"`。这将使得它可以直接从 `MainPage.xaml.cs` 文件中定义的后台代码中访问。由于在这个例子中我们没有使用
    MVVM，我们需要一种方法来访问网格而不使用数据绑定。
- en: Creating the Swiper control
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 Swiper 控件
- en: The main part of this project involves creating the `Swiper` control. A control,
    in a general sense, is a self-contained `ContentView`, as opposed to `ContentPage`,
    which is what XAML pages are. It can be added to any XAML page as an element,
    or in code in the code-behind file. We will be adding the control from code in
    this project.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 这个项目的核心部分是创建 `Swiper` 控件。在一般意义上，控件是一个自包含的 `ContentView`，与 `ContentPage` 相对，后者是
    XAML 页面。它可以作为一个元素添加到任何 XAML 页面中，或者在代码的后台文件中。在这个项目中，我们将从代码中添加控件。
- en: Creating the control
  id: totrans-54
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建控件
- en: 'Creating the `Swiper` control is a straightforward process. We just need to
    make sure that we select the correct item template, which is **Content View**,
    by doing the following:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 创建 `Swiper` 控件是一个简单的过程。我们只需要确保我们选择了正确的项目模板，即 **内容视图**，通过以下操作：
- en: In the `Swiper` project, create a folder called `Controls`.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Swiper` 项目中，创建一个名为 `Controls` 的文件夹。
- en: Right-click on the `Controls` folder, select **Add**, and then click **New item...**.
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Controls` 文件夹，选择 **添加**，然后点击 **新建项...**。
- en: Select **C# Items** and then **.NET MAUI** from the left pane of the **Add New
    Item** dialog box.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **添加新项** 对话框的左侧面板中选择 **C# 项**，然后选择 **.NET MAUI**。
- en: Select the **.NET MAUI ContentView (XAML)** item. Make sure you don’t select
    the **.NET MAUI ContentView (C#)** option; this only creates a C# file and not
    an XAML file.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 **.NET MAUI 内容视图 (XAML)** 项。确保您不要选择 **.NET MAUI 内容视图 (C#)** 选项；这只会创建一个 C#
    文件，而不是 XAML 文件。
- en: Name the control `SwiperControl.xaml`.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将控件命名为 `SwiperControl.xaml`。
- en: Click **Add**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加**。
- en: 'Refer to the following screenshot to view the preceding information:'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 参考以下截图查看上述信息：
- en: '![Figure 5.5 – Add New Item](img/B19214_05_5.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.5 – 添加新项](img/B19214_05_5.jpg)'
- en: Figure 5.5 – Add New Item
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.5 – 添加新项
- en: 'This adds an XAML file for the UI and a C# code-behind file. It should look
    as follows:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 这添加了一个用于 UI 的 XAML 文件和一个 C# 后台代码文件。它应该看起来如下：
- en: "![Fi\uFEFF\uFEFFgure 5.6 – Solution layout](img/B19214_05_6.jpg)"
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.6 – 解决方案布局](img/B19214_05_6.jpg)'
- en: Figure 5.6 – Solution layout
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.6 – 解决方案布局
- en: Defining the main grid
  id: totrans-68
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 定义主网格
- en: 'Let’s set the basic structure of the `Swiper` control:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们设置 `Swiper` 控件的基本结构：
- en: Open the `SwiperControl.xaml` file.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `SwiperControl.xaml` 文件。
- en: 'Replace the content with the highlighted code in the following code block:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码块中的内容替换为高亮的代码：
- en: '[PRE1]'
  id: totrans-72
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This defines a grid with three columns. The leftmost and rightmost columns will
    take up 100 units of space, and the center will occupy the rest of the available
    space. The spaces on the sides will be areas in which we will add labels to highlight
    the choice that the user has made. We’ve also added three comments that act as
    placeholders for the XAML code to come in.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 这定义了一个有三个列的网格。最左边的和最右边的列将占用 100 个单位的空间，中间将占用剩余的可供空间。两侧的空间将是添加标签以突出用户所做选择的地方。我们还添加了三个注释，作为即将到来的
    XAML 代码的占位符。
- en: We will continue by adding additional XAML to create the photo layout.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续添加额外的 XAML 来创建照片布局。
- en: Adding a content view for the photo
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加照片内容视图
- en: 'Now, we will extend the `SwiperControl.xaml` file by adding a definition of
    what we want the photo to look like. Our final result will look like *Figure 5**.7*.
    Since we are going to pull images off the internet, we’ll display a loading text
    to make sure that the user gets feedback on what’s going on. To make it look like
    an instantly printed photo, we added some handwritten text under the photo, as
    can be seen in the following figure:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将通过添加定义照片外观的定义来扩展 `SwiperControl.xaml` 文件。我们的最终结果将看起来像 *图 5.7*。由于我们将从互联网上拉取图片，我们将显示一个加载文本，以确保用户能够得到关于正在发生什么的反馈。为了使其看起来像即时打印的照片，我们在照片下方添加了一些手写的文本，如下面的图所示：
- en: '![Figure 5.7 – The photo UI design](img/B19214_05_7.jpg)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.7 – 照片 UI 设计](img/B19214_05_7.jpg)'
- en: Figure 5.7 – The photo UI design
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.7 – 照片 UI 设计
- en: 'The preceding figure shows what we would like the photo to look like. To make
    this a reality, we need to add some XAML code to the `SwiperControl` file by doing
    the following:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的图显示了我们希望照片看起来像什么。为了使这成为现实，我们需要通过以下方式向`SwiperControl`文件添加一些XAML代码：
- en: Open `SwiperControl.xaml`.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SwiperControl.xaml`。
- en: 'Add the highlighted XAML code following the `<!-- ContentView for photo here
    -->` comment. Make sure that you do not replace the entire `ContentView` control
    for the page; just add this under the comment, as illustrated in the following
    code block. The rest of the page should be untouched:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<!-- ContentView for photo here -->`注释之后添加高亮的XAML代码。确保不要替换页面的整个`ContentView`控件；只需在注释下添加此代码，如以下代码块所示。页面的其余部分应保持不变：
- en: '[PRE2]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: A `ContentView` control defines a new area where we can add other controls.
    One very important feature of a `ContentView` control is that it only takes one
    child control. Most of the time, we would add one of the available layout controls.
    In this case, we’ll use a `Grid` control to lay out the control, as shown in the
    preceding code.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentView`控件定义了一个新的区域，我们可以在这里添加其他控件。`ContentView`控件的一个非常重要的特性是它只接受一个子控件。大多数时候，我们会添加一个可用的布局控件。在这种情况下，我们将使用`Grid`控件来布局控件，如前述代码所示。'
- en: 'The grid defines two rows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 网格定义了两行：
- en: A row for the photo itself, which takes up all the available space when the
    other rows have been allocated space
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为照片本身添加一行，当其他行已经分配空间时，它将占据所有可用空间
- en: A row for the comment, which will be exactly 40 units in height
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为评论添加一行，其高度正好为40个单位
- en: The `Grid` control itself is set to use a black background and a padding of
    1\. This, in combination with a `BoxView` control, which has a white background,
    creates the frame that we see around the control. The `BoxView` control is also
    set to span both rows of the grid (`Grid.RowSpan="2"`), taking up the entire area
    of the grid, minus the padding.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`Grid`控件本身设置为使用黑色背景和1的填充。这与一个白色背景的`BoxView`控件结合使用，创建了我们在控件周围看到的框架。`BoxView`控件也被设置为跨越网格的两行（`Grid.RowSpan="2"`），占据网格的整个区域，减去填充。'
- en: The `Image` control comes next. It has a background color set to a nice gray
    tone (`#AAAAAA`) and a margin of 40, which will separate it a bit from the frame
    around it. It also has a hardcoded name (`x:Name="image"`), which will allow us
    to interact with it from the code-behind. The last attribute, called `Aspect`,
    determines what we should do if the image control isn’t of the same ratio as the
    source image. In this case, we want to fill the entire image area, but not show
    any blank areas. This effectively crops the image either in terms of height or
    width.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`Image`控件。它设置了一个背景颜色为漂亮的灰色调（`#AAAAAA`）和40的边距，这将使其与周围的框架稍微隔开。它还有一个硬编码的名称（`x:Name="image"`），这将允许我们从代码后端与之交互。最后一个属性，称为`Aspect`，决定了如果图像控件与源图像的比例不同时我们应该做什么。在这种情况下，我们希望填充整个图像区域，但不显示任何空白区域。这实际上在高度或宽度上裁剪了图像。
- en: We finish off by adding two labels, which also have hardcoded names for later
    reference.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过添加两个标签来完成，这些标签也有硬编码的名称供以后参考。
- en: That’s a wrap on the XAML for now; let’s move on to creating a description for
    the photo.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 现在XAML的部分就到这里了；让我们继续为这张照片创建一个描述。
- en: Creating the DescriptionGenerator class
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建`DescriptionGenerator`类
- en: 'At the bottom of the image, we can see a description. Since we don’t have any
    general descriptions of the images from our upcoming image source, we need to
    create a generator that makes up descriptions. Here’s a simple, yet fun, way to
    do it:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在图片底部，我们可以看到一个描述。由于我们来自即将到来的图片源没有任何通用的图片描述，我们需要创建一个生成描述的生成器。这里有一个简单而有趣的方法来做这件事：
- en: Create a folder called `Utils` in the `Swiper` project.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Swiper`项目中创建一个名为`Utils`的文件夹。
- en: Create a new class called `DescriptionGenerator` in that folder.
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个文件夹中创建一个名为`DescriptionGenerator`的新类。
- en: 'Add the following code to this class:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向这个类添加以下代码：
- en: '[PRE3]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This class only has one purpose: it takes one random word from the `_adjectives`
    array and combines it with a random word from the `_other` array. By calling the
    `Generate()` method, we get a fresh new combination. Feel free to enter your own
    words in the arrays. Note that the `Random` instance is a static field. This is
    because if we create new instances of the `Random` class that are too close to
    each other in time, they get seeded with the same value and return the same sequence
    of random numbers.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类只有一个目的：它从`_adjectives`数组中随机取一个词，并将其与`_other`数组中的一个随机词组合。通过调用`Generate()`方法，我们得到一个全新的组合。您可以在数组中自由添加自己的词。请注意，`Random`实例是一个静态字段。这是因为如果我们创建时间上过于接近的新实例的`Random`类，它们会被相同的值初始化，并返回相同的随机数序列。
- en: Now that we can create a fun description for the photo, we need a way to capture
    the image and description for the photo.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以为照片创建一个有趣的描述，我们需要一种方法来捕获照片和描述。
- en: Creating a Picture class
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建一个`Picture`类
- en: 'To abstract all the information about the image we want to display, we’ll create
    a class that encapsulates this information. There isn’t much information in our
    `Picture` class, but it is good coding practice to do this. Proceed as follows:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 为了抽象出我们想要显示的图片的所有信息，我们将创建一个封装这些信息的类。在我们的`Picture`类中信息不多，但这是一个好的编码实践。按照以下步骤进行：
- en: Create a new class called `Picture` in the `Utils` folder.
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Utils`文件夹中创建一个新的类，名为`Picture`。
- en: 'Add the following code to the class:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE4]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Picture` class has the following two public properties:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '`Picture`类有以下两个公共属性：'
- en: The `Uri` property, which points to its location on the internet
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Uri`属性，指向其在互联网上的位置'
- en: A description of that image, exposed as the `Description` property
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该图片的描述，作为`Description`属性公开
- en: In the constructor, we create a new URI, which points to a public source of
    test photos that we can use. The width and height are specified in the query string
    part of the URI. We also append a random timestamp to avoid the images being cached
    by .NET MAUI. This generates a unique URI each time we request an image.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们创建一个新的URI，它指向一个公共测试照片源，我们可以使用。宽度和高度在URI的查询字符串部分指定。我们还附加了一个随机时间戳，以避免.NET
    MAUI缓存图片。这为我们每次请求图片时生成一个唯一的URI。
- en: We then use the `DescriptionGenerator` class that we created previously to generate
    a random description for the image.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 我们随后使用之前创建的`DescriptionGenerator`类为图片生成一个随机描述。
- en: Note that the properties don’t define a `set` method, but instead use `init`.
    Since we never need to change the values of `URL` or `Description` after the object
    is created, the properties can be read-only. `init` only allows the value to be
    set before the constructor completes. If you try to set the value after the constructor
    has run, the compiler will generate an error.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，属性并不定义一个`set`方法，而是使用`init`。由于我们创建对象后永远不需要更改`URL`或`Description`的值，这些属性可以是只读的。`init`只允许在构造函数完成之前设置值。如果您在构造函数运行之后尝试设置值，编译器将生成一个错误。
- en: Now that we have all the pieces we need to start displaying images, let’s start
    pulling it all together.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经拥有了开始显示图片所需的所有组件，让我们开始把它们整合起来。
- en: Binding the picture to the control
  id: totrans-111
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将图片绑定到控件上
- en: Let’s begin to wire up the `Swiper` control so that it starts displaying images.
    We need to set the source of an image, and then control the visibility of the
    loading label based on the status of the image. Since we are using an image fetched
    from the internet, it might take a couple of seconds to download. A good UI will
    provide the user with proper feedback to help them avoid confusion regarding what
    is going on.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始连接`Swiper`控件，以便它开始显示图片。我们需要设置图片的来源，然后根据图片的状态控制加载标签的可见性。由于我们使用的是从互联网上获取的图片，可能需要几秒钟的时间来下载。一个好的用户界面将提供适当的反馈，帮助用户避免对正在发生的事情产生困惑。
- en: We will begin by setting the source for the image.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先设置图片的源。
- en: Setting the source
  id: totrans-114
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 设置源
- en: The `Image` control (referred to as `image` in the code) has a `source` property.
    This property is of the `ImageSource` abstract type. There are a few different
    types of image sources that you can use. The one we are interested in is the `UriImageSource`
    type, which takes a URI, downloads the image, and allows the image control to
    display it.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`Image`控件（在代码中称为`image`）有一个`source`属性。这个属性是`ImageSource`抽象类型。您可以使用几种不同类型的图像源。我们感兴趣的是`UriImageSource`类型，它接受一个URI，下载图片，并允许图像控件显示它。'
- en: 'Let’s extend the `Swiper` control so that we can set the source and description:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们扩展 `Swiper` 控件，以便我们可以设置源和描述：
- en: Open the `Controls/Swiper.Xaml.cs` file (the code-behind for the `Swiper` control).
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Controls/Swiper.Xaml.cs` 文件（`Swiper` 控件的代码隐藏文件）。
- en: Add a `using` statement for `Swiper.Utils` (`using Swiper.Utils;`) since we
    will be using the `Picture` class from that namespace.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Swiper.Utils` 添加一个 `using` 语句（`using Swiper.Utils;`），因为我们将会使用该命名空间中的 `Picture`
    类。
- en: 'Add the following highlighted code to the constructor:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下突出显示的代码添加到构造函数中：
- en: '[PRE5]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Here, we create a new instance of a `Picture` class and assign the description
    to the `descriptionLabel` control in the GUI by setting the text property of that
    control. Then, we set the source of the image to a new instance of the `UriImageSource`
    class, and assign the URI from the `picture` instance. This will cause the image
    to be downloaded from the internet, and display it as soon as it is downloaded.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们创建了一个 `Picture` 类的新实例，并通过设置该控制器的文本属性将描述分配给 GUI 中的 `descriptionLabel` 控制器。然后，我们将图像的源设置为
    `UriImageSource` 类的新实例，并将 `picture` 实例的 URI 分配给它。这将导致图像从互联网上下载，并在下载完成后立即显示。
- en: Next, we will change the visibility of the loading label for positive user feedback.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将更改加载标签的可见性以提供积极的用户反馈。
- en: Controlling the loading label
  id: totrans-123
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 控制加载标签
- en: While the image is downloading, we want to show a loading text centered over
    the image. This is already in the XAML file that we created earlier, so what we
    need to do is hide it once the image has been downloaded. We will do this by controlling
    the `IsVisibleProperty` property (yes, the property is actually named `IsVisibleProperty`)
    of the `loadingLabel` control by setting a binding to the `IsLoading` property
    of the image. Any time the `IsLoading` property is changed on the image, the binding
    changes the `IsVisible` property on the label. This is a nice fire-and-forget
    approach.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像正在下载时，我们想在图像上方显示一个居中的加载文本。这已经在之前创建的 XAML 文件中，所以我们需要做的是在图像下载后隐藏它。我们将通过控制 `loadingLabel`
    控件的 `IsVisibleProperty` 属性（是的，属性实际上命名为 `IsVisibleProperty`）来实现这一点，通过将绑定设置到图像的
    `IsLoading` 属性。每当图像上的 `IsLoading` 属性发生变化时，绑定就会更改标签上的 `IsVisible` 属性。这是一个很好的“点火并忘记”的方法。
- en: You might have noticed that we are using a binding when we said that we wouldn’t
    be using bindings at the beginning of this chapter. This is used as a shortcut,
    to avoid us having to write the code that would do essentially the same thing
    as this binding does. And to be fair, while we did say no MVVM and data binding,
    we are binding to ourselves, not between classes, so all the code is self-contained
    inside the `Swiper` control.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，当我们说我们不会使用绑定时，我们使用了绑定。这被用作一个快捷方式，以避免我们不得不编写与这个绑定本质上相同功能的代码。而且公平地说，虽然我们说过不要使用
    MVVM 和数据绑定，但我们是在绑定到自身，而不是在类之间绑定，所以所有代码都包含在 `Swiper` 控件内部。
- en: 'Let’s add the code needed to control the `loadingLabel` control, as follows:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加控制 `loadingLabel` 控件的代码，如下所示：
- en: Open the `Swiper.xaml.cs` code-behind file.
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Swiper.xaml.cs` 代码隐藏文件。
- en: 'Add the following code marked in bold to the constructor:'
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下加粗的代码添加到构造函数中：
- en: '[PRE6]'
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In the preceding code, the `loadingLabel` control sets a binding to the `IsVisibleProperty`
    property, which belongs to the `VisualElement` class that all controls inherit
    from. It tells `loadingLabel` to listen to changes in the `IsLoading` property
    of whichever object is assigned to the binding context. In this case, this is
    the image control.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`loadingLabel` 控制器将一个绑定设置到 `IsVisibleProperty` 属性，该属性属于所有控件继承的 `VisualElement`
    类。它告诉 `loadingLabel` 监听绑定上下文中任何对象的 `IsLoading` 属性的变化。在这种情况下，这是图像控件。
- en: Next, we will allow the user to “swipe right” or “swipe left.”
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将允许用户“向右滑动”或“向左滑动”。
- en: Handling pan gestures
  id: totrans-132
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 处理滑动手势
- en: A core feature of this app is the pan gesture. A pan gesture is when a user
    presses on the control and moves it around the screen. We will also add a random
    rotation to the `Swiper` control to make it look like there are photos in a stack
    when we add multiple images.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本应用的核心功能是滑动手势。滑动手势是指用户按下控件并在屏幕上移动它。我们还将向 `Swiper` 控件添加随机旋转，以便在添加多个图像时使其看起来像一堆照片。
- en: 'We will start by adding some fields to the `SwiperControl` class, as follows:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先向 `SwiperControl` 类添加一些字段，如下所示：
- en: Open the `SwiperControl.xaml.cs` file.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `SwiperControl.xaml.cs` 文件。
- en: 'Add the following fields in the code to the class:'
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在代码中将以下字段添加到类中：
- en: '[PRE7]'
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The first field, `_initialRotation`, stores the initial rotation of the image.
    We will set this in the constructor. The second field is a `static` field containing
    a `Random` object. As you might remember, it’s better to create one static random
    object to make sure multiple random objects don’t get created with the same seed.
    The seed is based on time, so if we create objects too close in time to each other,
    they get the same random sequence generated, so it wouldn’t be that random at
    all.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个字段`_initialRotation`存储图像的初始旋转。我们将在构造函数中设置这个值。第二个字段是一个包含`Random`对象的`static`字段。你可能记得，最好创建一个静态的随机对象，以确保不会创建具有相同种子的多个随机对象。种子基于时间，所以如果我们创建的对象在时间上太接近，它们将生成相同的随机序列，这根本不是随机的。
- en: 'The next thing we have to do is create an event handler for the `PanUpdated`
    event that we will bind to at the end of this section, as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须创建一个事件处理程序来处理`PanUpdated`事件，我们将在本节末尾将其绑定，如下所示：
- en: Open the `SwiperControl.xaml.cs` code-behind file.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SwiperControl.xaml.cs`代码隐藏文件。
- en: 'Add the `OnPanUpdated` method to the class, like this:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`OnPanUpdated`方法添加到类中，如下所示：
- en: '[PRE8]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code is straightforward. We handle an event that takes a `PanUpdatedEventArgs`
    object as the second argument. This is a standard method of handling events. We
    then have a `switch` clause that checks which status the event refers to.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码很简单。我们处理一个以`PanUpdatedEventArgs`对象作为第二个参数的事件。这是处理事件的标准方法。然后我们有一个`switch`子句来检查事件引用的是哪种状态。
- en: 'A pan gesture can have the following three states:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 平移手势可以有以下三种状态：
- en: '`GestureStatus.Started`: The event is raised once with this state when the
    panning begins'
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GestureStatus.Started`：当平移开始时，事件以这种状态触发一次'
- en: '`GestureStatus.Running`: The event is then raised multiple times, once for
    each time you move your finger'
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GestureStatus.Running`：事件被多次触发，每次你移动手指时触发一次'
- en: '`GestureStatus.Completed`: The event is raised one last time when you let go'
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GestureStatus.Completed`：当你放手时，事件最后一次被触发'
- en: 'For each of these states, we call specific methods that handle the different
    states. We’ll continue with adding those methods now:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这些状态中的每一个，我们调用特定的方法来处理不同的状态。我们现在将继续添加这些方法：
- en: Open the `SwiperControl.xaml.cs` code-behind file.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SwiperControl.xaml.cs`代码隐藏文件。
- en: 'Add the following three methods to the class, like this:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下三个方法添加到类中，如下所示：
- en: '[PRE9]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Let’s start by looking at `PanStarted()`. When the user starts dragging the
    image, we want to add the effect of it raising a little bit over the surface.
    This is done by scaling the image by 10%. .NET MAUI has a set of excellent functions
    to do this. In this case, we call the `ScaleTo()` method on the image control
    (named `Photo`) and tell it to scale to `1.1`, which corresponds to 10% of its
    original size. We also tell it to do this within a duration of `100` **milliseconds**
    (**ms**). This call is also awaitable, which means we can wait for the control
    to finish animating before executing the next call. In this case, we are going
    to use a fire-and-forget approach.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看`PanStarted()`。当用户开始拖动图像时，我们希望添加一点效果，使其稍微高出表面。这是通过将图像按10%的比例缩放来实现的。.NET
    MAUI有一套出色的函数来完成这个任务。在这种情况下，我们在图像控件（命名为`Photo`）上调用`ScaleTo()`方法，并告诉它缩放到`1.1`，这对应于其原始大小的10%。我们还告诉它在`100`毫秒（**ms**）内完成这个动作。这个调用也是可等待的，这意味着我们可以在执行下一个调用之前等待控件完成动画。在这种情况下，我们将使用一种触发即忘掉的方法。
- en: Next, we have `PanRunning()`, which is called multiple times during the pan
    operation. This takes an argument, called `PanUpdatedEventArgs`, from the event
    handler that `PanRunning()` is called from. We could also just pass in *X* and
    *Y* values as arguments to reduce the coupling of the code. This is something
    that you can experiment with. The method extracts the *X* and *Y* components from
    the `TotalX`/`TotalY` properties of the event and assigns them to the `TranslationX`/`TranslationY`
    properties of the image control. We also adjust the rotation slightly, based on
    how far the image has been moved.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是`PanRunning()`，它在平移操作期间多次被调用。这个方法从调用`PanRunning()`的事件处理程序中接收一个名为`PanUpdatedEventArgs`的参数。我们也可以只传递*X*和*Y*值作为参数来减少代码的耦合。这是一件你可以实验的事情。该方法从事件的`TotalX`/`TotalY`属性中提取*X*和*Y*分量，并将它们分配给图像控件的`TranslationX`/`TranslationY`属性。我们还根据图像移动的距离稍微调整了旋转。
- en: The last thing we need to do is restore everything to its initial state when
    the image is released. This can be done in `PanCompleted()`. First, we translate
    (or move) the image back to its original local coordinates (`0,0`) in `250` ms.
    We also added an easing function to make it overshoot the target a bit and then
    animate back. We can play around with the different predefined easing functions;
    these are useful for creating nice animations. We do the same to move the image
    back to its initial rotation. Finally, we scale it back to its original size in
    `250` ms.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 我们最后需要做的是在图像释放时将其恢复到初始状态。这可以在 `PanCompleted()` 中完成。首先，我们将图像（或移动）在 250 毫秒内翻译（或移动）回其原始局部坐标（`0,0`）。我们还添加了一个缓动函数，使其略微超出目标，然后动画回弹。我们可以尝试不同的预定义缓动函数；这些对于创建漂亮的动画很有用。我们同样将图像移动回其初始旋转。最后，我们在
    250 毫秒内将其缩放回原始大小。
- en: 'Now, it’s time to add the code in the constructor that will wire up the pan
    gesture and set some initial rotation values. Proceed as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候在构造函数中添加代码，以连接平移手势并设置一些初始旋转值。按照以下步骤进行：
- en: Open the `SwiperControl.xaml.cs` code-behind file.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `SwiperControl.xaml.cs` 代码隐藏文件。
- en: 'Add the highlighted code to the constructor. Note that there is more code in
    the constructor, so don’t overwrite the whole method; just add the bold text shown
    in the following code block:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下加粗代码添加到构造函数中。注意构造函数中还有更多代码，所以不要覆盖整个方法；只需添加以下代码块中显示的加粗文本：
- en: '[PRE10]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: All .NET MAUI controls have a property called `GestureRecognizers`. There are
    different types of gesture recognizers, such as `TapGestureRecognizer` or `SwipeGestureRecognizer`.
    In our case, we are interested in the `PanGestureRecognizer` type. We create a
    new `PanGestureRecognizer` instance and subscribe to the `PanUpdated` event by
    hooking it up to the `OnPanUpdated()` method we created earlier. Then, we add
    it to the `Swiper` controls `GestureRecognizers` collection.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 所有 .NET MAUI 控件都有一个名为 `GestureRecognizers` 的属性。有不同类型的手势识别器，例如 `TapGestureRecognizer`
    或 `SwipeGestureRecognizer`。在我们的情况下，我们感兴趣的是 `PanGestureRecognizer` 类型。我们创建一个新的
    `PanGestureRecognizer` 实例，并通过将其连接到我们之前创建的 `OnPanUpdated()` 方法来订阅 `PanUpdated`
    事件。然后，我们将它添加到 `Swiper` 控件的 `GestureRecognizers` 集合中。
- en: After this, we set an initial rotation of the image and make sure we store the
    current rotation value so that we can modify the rotation, and then rotate it
    back to the original state.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们设置图像的初始旋转，并确保我们存储当前的旋转值，以便我们可以修改旋转，然后将其旋转回原始状态。
- en: Next, we will wire up the control temporarily so that we can test it out.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将临时连接控件，以便我们可以对其进行测试。
- en: Testing the control
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试控件
- en: 'We now have all the code written to take the control for a test run. Proceed
    as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经编写了所有代码，可以对这个控件进行测试运行。按照以下步骤进行：
- en: Open `MainPage.xaml.cs`.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainPage.xaml.cs`。
- en: Add a `using` statement for the `Swiper.Controls` (`using Swiper.Controls;`).
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `Swiper.Controls` 添加一个 `using` 语句（`using Swiper.Controls;`）。
- en: 'Add the following code marked in bold to the constructor:'
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下加粗代码添加到构造函数中：
- en: '[PRE11]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'If all goes well with the build, we should end up with a photo like the one
    shown in the following figure:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果构建一切顺利，我们最终应该得到如图所示的照片：
- en: '![Figure 5.8 – Testing the app](img/B19214_05_8.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![图 5.8 – 测试应用](img/B19214_05_8.jpg)'
- en: Figure 5.8 – Testing the app
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图 5.8 – 测试应用
- en: We can also drag the photo around (pan it). Notice the slight lift effect when
    you begin dragging, and the rotation of the photo based on the amount of translation,
    which is the total movement. If you let go of the photo, it animates back into
    place.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以拖动照片（平移它）。注意当你开始拖动时会有轻微的抬起效果，以及根据平移量（即总移动量）的照片旋转。如果你放手，照片会动画回到原位。
- en: Now that we have the control displaying the photo and can swipe it left or right,
    we need to act on those swipes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了显示照片并可以左右滑动它的控件，我们需要对那些滑动做出反应。
- en: Creating decision zones
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建决策区域
- en: 'A matchmaking app is nothing without those special drop zones on each side
    of the screen. We want to do a few things here:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 一个配对应用如果没有屏幕两侧的特殊拖放区域，那就什么都不是。我们在这里想做一些事情：
- en: When a user drags an image to either side, text should appear that says `LIKE`
    or `DENY` (the decision zones)
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户将图像拖动到任一侧时，应显示 `LIKE` 或 `DENY`（决策区域）的文本
- en: When a user drops an image on a decision zone, the app should remove the image
    from the page
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当用户将图片拖放到决策区域时，应用应从页面上移除该图片
- en: We will create these zones by adding some XAML code to the `SwiperControl.xaml`
    file and then add the necessary code to make this happen. It is worth noting that
    the zones are not hotspots for dropping the image, but rather for displaying labels
    on top of the control surface. The actual drop zones are calculated and determined
    based on how far you drag the image.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过在`SwiperControl.xaml`文件中添加一些XAML代码来创建这些区域，然后添加必要的代码来实现这一功能。值得注意的是，这些区域不是放置图像的热点，而是用于在控制表面上方显示标签。实际的放置区域是根据你拖动图像的距离来计算和确定的。
- en: The first step is to add the UI for the left and right swipe actions.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是添加左右滑动动作的UI。
- en: Extending the grid
  id: totrans-179
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 扩展网格
- en: The `Swiper` control has three columns (left, right, and center) defined. We
    want to add some kind of visual feedback to the user if the image is dragged to
    either side of the page. We will do this by adding a `StackLayout` control with
    a `Label` control on each side.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`Swiper`控制有三个列（左侧、右侧和中间）定义。我们希望在图像被拖动到页面任一侧时，向用户添加某种视觉反馈。我们将通过添加一个带有每侧`Label`控制的`StackLayout`控制来实现这一点。'
- en: We will add the right-hand side first.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先添加右侧。
- en: Adding the StackLayout for liking photos
  id: totrans-182
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加用于喜欢照片的StackLayout
- en: 'The first thing we need to do is add the `StackLayout` control for liking photos
    on the right-hand side of the control:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在控制的右侧添加用于喜欢照片的`StackLayout`控制：
- en: Open `Controls/SwiperControl.xaml`.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml`。
- en: 'Add the following code under the `<!-- StackLayout for like here -->` comment:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<!-- StackLayout for like here -->`注释下添加以下代码：
- en: '[PRE12]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The `StackLayout` control is the container of child elements that we want to
    display. It has a name and is assigned to be rendered in the third column (it
    says `Grid.Column="2"` in the code due to the zero indexing). The `Opacity` property
    is set to `0`, making it completely invisible, and the `Padding` property is adjusted
    to make it move down a bit from the top.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: '`StackLayout`控制是我们想要显示的子元素的容器。它有一个名称，并分配为在第三列渲染（由于零索引，代码中显示为`Grid.Column="2"`）。`Opacity`属性设置为`0`，使其完全不可见，并且调整了`Padding`属性，使其从顶部向下移动一点。'
- en: Inside the `StackLayout` control, we’ll add the `Label` control.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 在`StackLayout`控制内部，我们将添加`Label`控制。
- en: Now that we have the right-hand side, let’s add the left.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了右侧，让我们添加左侧。
- en: Adding the StackLayout for denying photos
  id: totrans-190
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加用于拒绝照片的StackLayout
- en: 'The next step is to add the `StackLayout` control for denying photos on the
    left-hand side of the control:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是添加在控制的左侧用于拒绝照片的`StackLayout`控制：
- en: Open `Controls/SwiperControl.xaml`.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml`。
- en: 'Add the following code under the `<!-- StackLayout for deny here -->` comment:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`<!-- StackLayout for deny here -->`注释下添加以下代码：
- en: '[PRE13]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The setup for the left-hand side `StackLayout` is the same, except that it should
    be in the first column, which is the default, so there is no need to add a `Grid.Column`
    attribute. We have also specified `HorizontalOptions="End"`, which means that
    the content should be right-justified.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 左侧`StackLayout`的设置与右侧相同，只是它应该位于第一列，这是默认设置，因此不需要添加`Grid.Column`属性。我们还将`HorizontalOptions="End"`指定为`HorizontalOptions`，这意味着内容应该右对齐。
- en: With the UI all set, we can now work on the logic for providing the user visual
    feedback by adjusting the opacity of the `LIKE` or `DENIED` text controls as the
    photo is panned.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: UI设置完成后，我们现在可以着手实现逻辑，通过调整`LIKE`或`DENIED`文本控制的透明度，在照片平移时为用户提供视觉反馈。
- en: Determining the screen size
  id: totrans-197
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 确定屏幕大小
- en: To be able to calculate the percentage of how far the user has dragged the image,
    we need to know the size of the control. This is not determined until the control
    is laid out by .NET MAUI.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够计算用户拖动图像的距离百分比，我们需要知道控件的大小。这直到.NET MAUI布局控件后才确定。
- en: 'We will override the `OnSizeAllocated()` method and add a `_screenWidth` field
    in the class to keep track of the current width of the window:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将重写`OnSizeAllocated()`方法并在类中添加一个`_screenWidth`字段来跟踪窗口的当前宽度：
- en: Open `SwiperControl.xaml.cs`.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`SwiperControl.xaml.cs`。
- en: 'Add the following code to the file, putting the field at the beginning of the
    class and the `OnSizeAllocated()` method below the constructor:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到文件中，将字段放在类的开头，并在构造函数下方添加`OnSizeAllocated()`方法：
- en: '[PRE14]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `_screenWidth` field is used to store the width as soon as we have resolved
    it. We do this by overriding the `OnSizeAllocated()` method that is called by
    .NET MAUI when the size of the control is allocated. This is called multiple times.
    The first time it’s called is actually before the width and height have been set
    and before the `MainPage` property of the current app is set. At this time, the
    width and height are set to `-1`, and the `Application.Current.MainPage` property
    is `null`. We look for this state by null-checking `Application.Current.MainPage`
    and returning if it is `null`. We could also have checked for `-1` values on the
    width. Either method would work. If it does have a value, however, we want to
    store it in our `_screenWidth` field for later use.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`_screenWidth` 字段用于在解决后立即存储宽度。我们通过重写 .NET MAUI 调用的 `OnSizeAllocated()` 方法来实现这一点，当控制的大小被分配时调用。这会被多次调用。第一次调用实际上是在宽度和高度设置之前，以及当前应用程序的
    `MainPage` 属性设置之前。此时，宽度和高度被设置为 `-1`，`Application.Current.MainPage` 属性为 `null`。我们通过检查
    `Application.Current.MainPage` 是否为 `null` 来寻找此状态，如果是 `null`，则返回。我们也可以检查宽度上的 `-1`
    值。两种方法都可行。然而，如果它具有值，我们希望将其存储在我们的 `_screenWidth` 字段中供以后使用。'
- en: .NET MAUI will call the `OnSizeAllocated()` method any time the frame of the
    app changes. This is most relevant for **WinUI** apps since they are in a window
    that a user can easily change. Android and iOS apps are less likely to get a call
    to this method a second time since the app will take up the entire screen’s real
    estate.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 会在应用框架发生变化时调用 `OnSizeAllocated()` 方法。这对于 **WinUI** 应用程序尤其相关，因为它们位于用户可以轻松更改的窗口中。Android
    和 iOS 应用程序不太可能再次收到此方法的调用，因为应用程序将占据整个屏幕的空间。
- en: Adding code to calculate the state
  id: totrans-205
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加代码以计算状态
- en: To calculate the state of the image, we need to define what our zones are, and
    then create a function that takes the current amount of movement and updates the
    opacity of the GUI decision zones based on how far we panned the image.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算图像的状态，我们需要定义我们的区域，然后创建一个函数，该函数接受当前的移动量，并根据我们平移图像的距离更新 GUI 决策区域的不透明度。
- en: Deﬁning a method for calculating the state
  id: totrans-207
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 定义计算状态的函数
- en: 'Let’s add the `CalculatePanState()` method to calculate how far we have panned
    the image, and if it should start to affect the GUI, by following these few steps:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们按照以下几个步骤添加 `CalculatePanState()` 方法来计算平移图像的距离，并确定是否应该开始影响 GUI：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Controls/SwiperControl.xaml.cs`。
- en: 'Add the properties at the top and the `CalculatePanState()` method anywhere
    in the class, as shown in the following code block:'
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类中任何位置添加顶部属性和 `CalculatePanState()` 方法，如下面的代码块所示：
- en: '[PRE15]'
  id: totrans-211
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'We define the following two values as constants:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将以下两个值定义为常量：
- en: '`DeadZone`, which defines that 40% (`0.4`) of the available space on either
    side of the center point is a dead zone when panning an image. If we release the
    image in this zone, it simply returns to the center of the screen without any
    action being taken.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DeadZone` 定义了在平移图像时，中心点两侧的 40% (`0.4`) 可用空间为死区。如果我们在这个区域内释放图像，它将简单地返回到屏幕中心，不执行任何操作。'
- en: The next constant is `DecisionThreshold`, which defines another 40% (`0.4`)
    of the available space. This is used for interpolating the opacity of `StackLayout`
    on either side of the layout.
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 下一个常量是 `DecisionThreshold`，它定义了另外 40% (`0.4`) 的可用空间。这用于在布局两侧插值 `StackLayout`
    的不透明度。
- en: We then use these values to check the state of the panning action whenever the
    panning changes. If the absolute panning value of *X* (`panX`) is less than the
    dead zone, we return without any action being taken. If not, we calculate how
    far over the dead zone we have passed and how far into the decision zone we are.
    We calculate the opacity values based on this interpolation and clamp the value
    between `-1` and `1`.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，每当平移发生变化时，我们使用这些值来检查平移动作的状态。如果 *X* 的绝对平移值 (`panX`) 小于死区，则不执行任何操作并返回。如果不满足条件，我们计算超过死区的距离以及进入决策区的距离。我们根据这个插值计算不透明度值，并将值限制在
    `-1` 和 `1` 之间。
- en: Finally, we set the opacity to this value for both `likeStackLayout` and `denyStackLayout`.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将不透明度设置为 `likeStackLayout` 和 `denyStackLayout` 的此值。
- en: Wiring up the pan state check
  id: totrans-217
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接平移状态检查
- en: 'While the image is being panned, we want to update the state, as follows:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 当图像正在平移时，我们想要更新状态，如下所示：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Controls/SwiperControl.xaml.cs`。
- en: 'Add the following code in bold to the `PanRunning()` method:'
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `PanRunning()` 方法中添加以下加粗代码：
- en: '[PRE16]'
  id: totrans-221
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: This addition to the `PanRunning()` method passes the total amount of movement
    on the *x axis* to the `CalculatePanState()` method, to determine if we need to
    adjust the opacity of either `StackLayout` on the right or the left of the control.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 这个 `PanRunning()` 方法的添加将总移动量传递到 `CalculatePanState()` 方法，以确定是否需要调整控件右侧或左侧的 `StackLayout`
    的不透明度。
- en: Adding exit logic
  id: totrans-223
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加退出逻辑
- en: So far, all is well, except for the fact that if we drag an image to the edge
    and let go, the text stays. We need to determine when the user stops dragging
    the image, and, if so, whether or not the image is in a decision zone.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利，除了如果我们拖动图片到边缘并释放，文本会保留下来。我们需要确定用户何时停止拖动图片，以及，如果是这样，图片是否在决策区域。
- en: Let’s add the code needed to animate the photo back to its original position.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加将照片动画回原始位置的代码。
- en: Checking if the image should exit
  id: totrans-226
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 检查图片是否应该退出
- en: 'We want a simple function that determines if an image has panned far enough
    for it to count as an exit of that image. To create such a function, proceed as
    follows:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一个简单的函数来判断图片是否已经平移足够远，可以算作图片的退出。要创建这样的函数，请按照以下步骤操作：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-228
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Controls/SwiperControl.xaml.cs` 文件。
- en: 'Add the `CheckForExitCriteria()` method to the class, as shown in the following
    code snippet:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CheckForExitCriteria()` 方法添加到类中，如下代码片段所示：
- en: '[PRE17]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: This function calculates whether we have passed over the dead zone and into
    the decision zone. We need to use the `Math.Abs()` method to get the total absolute
    value to compare it against. We could have used `<` and `>` operators as well,
    but we are using this approach as it is more readable. This is a matter of code
    style and taste – feel free to do it your way.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这个函数计算我们是否已经越过了死区并进入了决策区。我们需要使用 `Math.Abs()` 方法来获取总绝对值以进行比较。我们也可以使用 `<` 和 `>`
    操作符，但我们使用这种方法因为它更易读。这是一个关于代码风格和品味的问题——请随意按照您的方式来做。
- en: Removing the image
  id: totrans-232
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 移除图片
- en: 'If we determine that an image has panned far enough for it to exit, we want
    to animate it off the screen and then remove the image from the page. To do this,
    proceed as follows:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确定图片已经平移足够远，可以算作退出，我们希望将其动画移出屏幕，然后从页面上移除图片。为此，请按照以下步骤操作：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Controls/SwiperControl.xaml.cs` 文件。
- en: 'Add the `Exit()` method to the class, as shown in the following code block:'
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Exit()` 方法添加到类中，如下代码块所示：
- en: '[PRE18]'
  id: totrans-236
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Let’s break down the preceding code block to understand what the `Exit()` method
    does:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解前面的代码块，了解 `Exit()` 方法的作用：
- en: We begin by making sure that this call is done on the UI thread, which is also
    known as the `MainThread` thread. This is because only the UI thread can do animations.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们首先确保这个调用是在 UI 线程上完成的，这也被称为 `MainThread` 线程。这是因为只有 UI 线程可以进行动画。
- en: We also need to run this thread asynchronously so that we can kill two birds
    with one stone. Since this method is all about animating the image to either side
    of the screen, we need to determine in which direction to animate it. We do this
    by determining if the total translation of the image is positive or negative.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们还需要异步运行这个线程，这样我们就可以一石二鸟。因为这个方法完全是关于将图片动画到屏幕的任一侧，我们需要确定动画的方向。我们通过确定图片的总平移量是正数还是负数来实现这一点。
- en: Then, we use this value to await a translation through the `photo.TranslateTo()`
    call.
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们使用这个值通过 `photo.TranslateTo()` 调用等待平移。
- en: We `await` this call since we don’t want the code execution to continue until
    it’s done. Once it has finished, we remove the control from the parent’s collection
    of children, causing it to disappear from existence forever.
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们使用 `await` 来等待这个调用，因为我们不希望代码执行继续直到它完成。一旦完成，我们就从父控件的子控件集合中移除该控件，使其永远消失。
- en: Updating PanCompleted
  id: totrans-242
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 更新 PanCompleted
- en: 'The decision regarding whether the image should disappear or simply return
    to its original state is triggered in the `PanCompleted()` method. Here, we will
    wire up the two methods that we created in the previous two sections. Proceed
    as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 关于图片是否应该消失或简单地返回到原始状态的决定是在 `PanCompleted()` 方法中触发的。在这里，我们将连接我们之前两个部分中创建的两个方法。请按照以下步骤操作：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Controls/SwiperControl.xaml.cs` 文件。
- en: 'Add the following code in bold to the `PanCompleted()` method:'
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码以粗体形式添加到 `PanCompleted()` 方法中：
- en: '[PRE19]'
  id: totrans-246
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The last step in this section is to use the `CheckForExitCriteria()` method,
    and the `Exit()` method if those criteria are met. If the exit criteria are not
    met, we need to reset the state and the opacity of `StackLayout` to make everything
    go back to normal.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的最后一步是使用`CheckForExitCriteria()`方法，如果满足这些条件，则使用`Exit()`方法。如果未满足退出条件，我们需要重置状态和`StackLayout`的不透明度，使一切恢复正常。
- en: Now that we can swipe left or swipe right, let’s add some events to raise when
    the user has swiped.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们可以左右滑动，让我们添加一些事件，当用户滑动时触发。
- en: Adding events to the control
  id: totrans-249
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加到控制器的事件
- en: The last thing we have left to do in the control itself is add some events that
    indicate whether the image has been *liked* or *denied*. We are going to use a
    clean interface, allowing for simple use of the control while hiding all the implementation
    details.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在控制器本身中，我们剩下要做的最后一件事是添加一些事件，以指示图片是否已被*喜欢*或*拒绝*。我们将使用一个干净的界面，允许简单使用控件，同时隐藏所有实现细节。
- en: Declaring two events
  id: totrans-251
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 声明两个事件
- en: 'To make the control easier to interact with from the application itself, we’ll
    need to add events for `Like` and `Deny`, as follows:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使控制器更容易从应用程序本身进行交互，我们需要添加`Like`和`Deny`事件，如下所示：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml.cs`。
- en: 'Add two event declarations at the beginning of the class, as shown in the following
    code snippet:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类开始处添加两个事件声明，如下代码片段所示：
- en: '[PRE20]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: These are two standard event declarations with out-of-the-box event handlers.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个是标准的事件声明，带有开箱即用的事件处理器。
- en: Raising the events
  id: totrans-257
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 触发事件
- en: 'We need to add code in the `Exit()` method to raise the events we created earlier,
    as follows:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在`Exit()`方法中添加代码来触发我们之前创建的事件，如下所示：
- en: Open `Controls/SwiperControl.xaml.cs`.
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Controls/SwiperControl.xaml.cs`。
- en: 'Add the following code in bold to the `Exit()` method:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Exit()`方法中添加以下加粗代码：
- en: '[PRE21]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, we inject the code to check whether we are liking or denying an image.
    We then raise the correct event based on this information.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们注入代码以检查我们是在喜欢还是拒绝图片。然后，根据这些信息触发正确的事件。
- en: We are now ready to finalize this app; the `Swiper` control is complete, so
    now, we need to add the right initialization code to finish it.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在准备好最终化这个应用；`Swiper`控制器已完成，因此现在我们需要添加正确的初始化代码来完成它。
- en: Wiring up the Swiper control
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接 Swiper 控制器
- en: We have now reached the final part of this chapter. In this section, we are
    going to wire up the images and make our app a closed-loop app that can be used
    forever. We will add 10 images that we will download from the internet when the
    app starts up. Each time an image is removed, we’ll simply add another one.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经到达了本章的最后一部分。在本节中，我们将连接图片，并使我们的应用成为一个闭环应用，可以永久使用。当应用启动时，我们将添加10张图片，这些图片将从互联网上下载。每次移除一张图片，我们就会简单地添加另一张。
- en: Adding images
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加图片
- en: Let’s start by creating some code that will add the images to the `MainView`
    class. First, we will add the initial images; then, we will create a logic model
    for adding a new image to the bottom of the stack each time an image is liked
    or denied.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先创建一些代码，这些代码将添加图片到`MainView`类。首先，我们将添加初始图片；然后，我们将为每次图片被喜欢或拒绝时在堆栈底部添加新图片创建一个逻辑模型。
- en: Adding initial photos
  id: totrans-268
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加初始图片
- en: 'To make the photos look like they are stacked, we need at least 10 of them.
    Proceed as follows:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 要使照片看起来像堆叠的，我们需要至少10张。按照以下步骤进行：
- en: Open `MainPage.xaml.cs`.
  id: totrans-270
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainPage.xaml.cs`。
- en: 'Add the `AddInitalPhotos()` method and `InsertPhotoMethod()` to the class,
    as illustrated in the following code block:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`AddInitalPhotos()`方法和`InsertPhotoMethod()`添加到类中，如下代码块所示：
- en: '[PRE22]'
  id: totrans-272
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: First, we create a method called `AddInitialPhotos()` that will be called upon
    startup. This method simply calls the `InsertPhoto()` method 10 times and adds
    a new `SwiperControl` to the `MainGrid` each time. It inserts the control at the
    first position in the stack, effectively putting it at the bottom of the pile
    since the collection of controls is rendered from the beginning to the end.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建一个名为`AddInitialPhotos()`的方法，该方法将在启动时被调用。此方法简单地调用`InsertPhoto()`方法10次，并在每次调用时向`MainGrid`添加一个新的`SwiperControl`。它将控件插入堆栈的第一个位置，由于控件集合是从开始到结束渲染的，因此这实际上将控件放置在堆栈底部。
- en: Making the call from the constructor
  id: totrans-274
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 在构造函数中发起调用
- en: 'We need to call this method for the magic to happen, so follow these steps
    to do so:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要调用此方法以实现魔法效果，因此请按照以下步骤进行操作：
- en: Open `MainPage.xaml.cs`.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainPage.xaml.cs`。
- en: 'Add the following code in bold to the constructor:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在构造函数中添加以下加粗代码：
- en: '[PRE23]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: There isn’t much to say here. Once the `MainPage` object has been initialized,
    we call the method to add 10 random photos that we will download from the internet.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有太多可说的。一旦`MainPage`对象被初始化，我们调用方法添加10张从互联网下载的随机照片。
- en: Adding count labels
  id: totrans-280
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加计数标签
- en: We want to add some values to the app as well. We can do this by adding two
    labels below the collection of `Swiper` controls. Each time a user rates an image,
    we will increment one of two counters and display the result.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还想在应用程序中添加一些值。我们可以通过在`Swiper`控件集合下方添加两个标签来实现。每次用户对图像进行评分时，我们将增加两个计数器之一，并显示结果。
- en: 'So, let’s add the XAML code needed to display the labels:'
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们添加显示标签所需的XAML代码：
- en: Open `MainPage.xaml`.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainPage.xaml`。
- en: 'Replace the `<!-- Placeholder for later -->` comment with the following code
    marked in bold:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`<!-- Placeholder for later -->`注释替换为以下加粗的代码：
- en: '[PRE24]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code adds a new `Grid` control with four auto-height rows. This means that
    we calculate the height of the content of each row and use this for the layout.
    It is the same thing as `StackLayout`, but we wanted to demonstrate a better way
    of doing this.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码添加了一个新的`Grid`控件，具有四个自动高度的行。这意味着我们计算每行内容的长度，并使用这个值进行布局。这与`StackLayout`相同，但我们想展示一种更好的实现方式。
- en: We add a `Label` control in each row and name two of them `likeLabel` and `denyLabel`.
    These two named labels will hold information about how many images have been liked
    and how many have been denied.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在每一行添加一个`Label`控件，并将其中两个命名为`likeLabel`和`denyLabel`。这两个命名标签将包含有关有多少图像被点赞和有多少被拒绝的信息。
- en: Subscribing to events
  id: totrans-288
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 订阅事件
- en: The last step is to wire up the `OnLike` and `OnDeny` events and display the
    total count to the user.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是连接`OnLike`和`OnDeny`事件，并将总计数显示给用户。
- en: Adding methods to update the GUI and respond to events
  id: totrans-290
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 添加方法以更新GUI和响应用件
- en: 'We need some code to update the GUI and keep track of the count. Proceed as
    follows:'
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要一些代码来更新GUI并跟踪计数。按照以下步骤进行：
- en: Open `MainPage.xaml.cs`.
  id: totrans-292
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainPage.xaml.cs`。
- en: 'Add the following code to the class:'
  id: totrans-293
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到类中：
- en: '[PRE25]'
  id: totrans-294
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The two fields at the top of the preceding code block keep track of the number
    of likes and denies. Since they are value-type variables, they default to zero.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码块顶部的两个字段跟踪点赞和拒绝的数量。由于它们是值类型变量，它们的默认值是零。
- en: To make the changes of these labels show up in the UI, we’ve created a method
    called `UpdateGui()`. This takes the value of the two aforementioned fields and
    assigns it to the `Text` properties of both labels.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这些标签的变化显示在UI中，我们创建了一个名为`UpdateGui()`的方法。这个方法将上述两个字段的值分配给两个标签的`Text`属性。
- en: The two methods that follow are the event handlers that will be handling the
    `OnLike` and `OnDeny` events. They increase the appropriate field, add a new photo,
    and then update the GUI to reflect the change.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的两个方法是处理`OnLike`和`OnDeny`事件的处理器。它们增加适当的字段，添加一张新照片，然后更新GUI以反映变化。
- en: Wiring up events
  id: totrans-298
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 连接事件
- en: 'Each time a new `SwiperControl` instance is created, we need to wire up the
    events, as follows:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 每次创建一个新的`SwiperControl`实例时，我们需要连接事件，如下所示：
- en: Open `MainPage.xaml.cs`.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`MainPage.xaml.cs`。
- en: 'Add the following code in bold to the `InsertPhoto()` method:'
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`InsertPhoto()`方法中，以下代码需要加粗：
- en: '[PRE26]'
  id: totrans-302
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The added code wires up the event handlers that we defined earlier. The events
    make it easy to interact with our new control. Try it for yourself and have a
    play around with the app that you have created.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 添加的代码连接了我们之前定义的事件处理程序。这些事件使得与我们的新控件交互变得容易。自己试一试，并玩一玩你创建的应用程序。
- en: Summary
  id: totrans-304
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Good job! In this chapter, we learned how to create a reusable, good-looking
    control that can be used in any .NET MAUI app. To enhance the **user experience**
    (**UX**) of the app, we used some animations that give the user more visual feedback.
    We also got creative with the use of XAML to define a GUI of the control that
    looks like a photo, with a hand-written description.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！在本章中，我们学习了如何创建一个可重用、外观良好的控件，可以在任何.NET MAUI应用程序中使用。为了增强应用程序的**用户体验**（**UX**），我们使用了一些动画，为用户提供更多的视觉反馈。我们还巧妙地使用了XAML来定义一个看起来像照片的控件GUI，并附有手写描述。
- en: After that, we used events to expose the behavior of the control back to the
    `MainPage` page to limit the contact surface between your app and the control.
    Most importantly of all, we touched on the subject of `GestureRecognizers`, which
    can make our life much easier when dealing with common gestures.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们使用事件将控制的行为暴露回`MainPage`页面，以限制您的应用和控制之间的接触面。最重要的是，我们触及了`GestureRecognizers`的主题，这在我们处理常见手势时可以使我们的生活变得更加轻松。
- en: 'Looking for ideas on how to make this app even better? Try this out: keep a
    history of the likes and dislikes and add a view to display each collection.'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 正在寻找如何使这个应用变得更好的想法？试试这个：保留点赞和踩不喜欢的记录，并添加一个视图来显示每个收藏。
- en: In the next chapter, we will create a photo gallery app using the `CollectionView`
    and `CarouselView` controls. The app will also allow you to favorite photos you
    like by using storage to keep the favorites list between app runs.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将使用`CollectionView`和`CarouselView`控件创建一个照片库应用。该应用还将允许您通过使用存储来保留在应用运行之间的收藏列表，来收藏您喜欢的照片。
