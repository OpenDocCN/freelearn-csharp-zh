- en: Understanding Object-Oriented Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When we are writing any program, apart from making sure that it serves the
    required purpose, we must make sure that we also take the following aspects into
    consideration:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Code reuse**: We must try to implement the program flow in such a way that
    common functionalities can be used across multiple modules.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code maintenance**: We must accept that any program code that''s written
    is bound to have a few bugs. However, we must ensure that the code that''s written
    is clear and structured enough that it''s understandable and easy to maintain.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Design patterns**: Design patterns allow us to write programs in such a manner
    that there is a common template/structure/functionality that can be used across
    multiple modules. This ensures that the performance of the application is not
    compromised, which is a key aspect of any program application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of these aspects are difficult to achieve in a procedural language. However,
    using object-oriented programming, which is the main essence of any high-level
    programming language, we can achieve the aforementioned objectives.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding object-oriented programming
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding encapsulation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding abstraction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding inheritance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding polymorphism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We will also go through code examples to understand how these features are implemented
    in a C# application.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Like in the previous chapters in this book, the programs that we will cover
    will be developed in Visual Studio 2017.
  prefs: []
  type: TYPE_NORMAL
- en: The sample code for this chapter can be found in this book's GitHub repository
    at [https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples](https://github.com/PacktPublishing/Programming-in-C-Exam-70-483-MCSD-Guide/tree/master/Book70483Samples).
  prefs: []
  type: TYPE_NORMAL
- en: Understanding object-oriented programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Object-oriented programming is a programming concept that is based on objects.
    An object is a collection of related data such as fields and procedures, that
    is, methods. For example, an object could be anything right from a very simple
    object such as a pencil to a very complex type such as a car. Each object will
    have its own set of attributes, that is, properties and functions or the methods
    that are implemented in that object. For example, for a car object, the possible
    attributes could be color, registration number, model, and so on. The possible
    functions could be start, stop, and accelerate.
  prefs: []
  type: TYPE_NORMAL
- en: Before object-oriented programming came into the picture, we did our programming
    under the principles of procedural programming. In a procedural language, an application
    was divided into a set of functions. The data that was used in the program was
    stored in a bunch of local variables that were used by the functions. It formed
    the basis of legacy programming languages such as COBOL and BASIC.
  prefs: []
  type: TYPE_NORMAL
- en: 'The main disadvantages of this programming concept were as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**No code reuse**: As the entire application was divided into a set of sequential
    functions, there was no code reuse in this programming concept.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Maintenance and scalability**: The following diagram is just an indicative
    flow of how a typical program written in a procedural language will run. In the
    program, the blocks indicate the different code functions, which are interlinked
    and interacting with each other to complete a task:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/1b84d311-0fdd-43df-b4df-6905b35c7bfd.png)'
  prefs: []
  type: TYPE_IMG
- en: Here, as in any typical program written on procedural language, there would
    be a bunch of functions, passing around parameters and executing them in a conceptual
    manner. So, any change or upgrade that's made to any one of these functions will
    have a good chance of causing issues in the execution of another function. Therefore,
    from both the standpoint of maintenance and scalability, an application that's
    written in a procedural language will have its challenges.
  prefs: []
  type: TYPE_NORMAL
- en: 'In object-oriented programming, each application can be divided into a bunch
    of objects that have their own properties and procedures. For example, let''s
    consider the same car scenario we explored in the previous chapter. A car can
    have the following properties and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/221913d4-2396-466f-94d7-4e171a6659fc.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, what we can do in an object-oriented programming language is directly declare
    a `car` object, set the values related to the properties, and call the corresponding
    properties, such as start.
  prefs: []
  type: TYPE_NORMAL
- en: Since the object is grouped with the corresponding properties, we don't need
    to pass any data for the respective properties. Instead, while executing the respective
    functions such as `start`, `stop`, or `accelerate`, we can then pass data against
    these properties as a function parameter list.
  prefs: []
  type: TYPE_NORMAL
- en: Thus, in this case, if, in the future, we change the `start()` function of the
    `car` class, we won't need to bother all the other places that it's getting called
    from.
  prefs: []
  type: TYPE_NORMAL
- en: This is a major upgrade in terms of the maintainability and scalability of the
    application compared to the standard way of doing things in a procedural language.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's deep dive into each of the four pillars of an object-oriented language
    and understand how we can use them in our C# applications.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding encapsulation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Encapsulation basically involves grouping all the related properties and methods
    that access them in an object. Whenever an application is being designed, we need
    to decide how many objects should be defined in it, along with the associated
    attributes and methods available in it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For instance, in the car example, we have the following associated attributes
    and methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '`car` is an object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `make`, `model`, and `color` are the different attributes that are present
    in the object.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`start`, `stop`, and `accelerate` are the different methods that are present
    in the object.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Encapsulation allows us to achieve the following functionality in any application:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Security**: Using encapsulation, we can define our attributes in such a way
    that not all of the attributes of an object are exposed to the entire application.
    In [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml), *Understanding Classes,
    Structures, and Interfaces,* we used access modifiers to control the security
    access of any property/method in the class/in the namespace/in the assembly, as
    well as in the entire application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Code maintenance**: From a maintenance perspective of a function, it''s always
    desirable that the function has as few attributes as possible.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using encapsulation, we can organize the required parameters of a function as
    an attribute of the class and thus we are not passing them explicitly in every
    call.
  prefs: []
  type: TYPE_NORMAL
- en: In the following code example, we will go through a code sample in C# and understand
    how this can be achieved.
  prefs: []
  type: TYPE_NORMAL
- en: Code example
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's consider an example of a banking application. In this banking application,
    we need to implement a scenario related to opening an account.
  prefs: []
  type: TYPE_NORMAL
- en: 'From a class implementation perspective, the following are the possible attributes
    that should be in the `Account` class. Please also note that there will be an
    additional class, `Customer`, to signify the person who is opening the account:'
  prefs: []
  type: TYPE_NORMAL
- en: '`openingDate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`customer`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`float currentBalance`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following are some of the methods that could be present in the `Account`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`bool OpenAccount();`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool depositMoney(float deposit);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`bool withdrawMoney(float withdrawalAmt);`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In regard to the `Customer` class, we will just go simple now and define the
    following attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '`string name`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`string customerId`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please refer to the following code for the declaration of the `Customer` class
    in a C# program. Here, we have created a `Customer` class and defined two attributes
    in it, that is, the name of the customer and a field of `CustomerID`, which will
    be a unique field for that customer.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following code, we will declare two variables and use them to showcase
    examples for the operators we mentioned previously:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Please refer to the following code for the declaration of the `Account` class
    in a C# program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are some of the key items in the implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Account` class, note that `currentBalance` is marked as private, as
    a customer may not want their balance to be exposed to the entire application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the `Account` class, in the methods of `OpenAccount`, `DepositMoney`, and
    `WithdrawMoney`, we are not passing all of the attributes related to the customer,
    current balance, or opening date. This is because the required attributes are
    already grouped together in the `Account` class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s look at how we will invoke these classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: If you look at the function calling part, you will understand that because the
    properties are linked to the `Account` class, we are not passing them explicitly
    to the functions. Therefore, if the implementation of the functions is changed,
    from a maintenance perspective, there will be minimal impact.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, it's always beneficial to use the principles of encapsulation and
    divide the application into chunks of classes with the related information.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding abstraction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Abstraction is also a concept in object-oriented programming and implies that,
    when we write code, we should hide the complexity and details of the implementation
    from the outside world.
  prefs: []
  type: TYPE_NORMAL
- en: In other words, when we write a program that, on receiving an input, does a
    bunch of complex operations and returns an output, we should hide the inner complexity
    of the operations that are done inside the program so that the outer applications
    can just focus on the input they are sending to the application and the output
    that they are getting from it.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, let''s consider the same example of `Account` that we worked on
    in the previous example. If we consider the example of the `OpenAccount` function,
    you will understand that opening an account for the customer will not be that
    simple. There will be several subtasks that need to be executed before we can
    finally open the account for the customer. For example, some of the steps could
    be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Verifying the identification documents of the customer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Linking and opening different bank accounts, which could be `Salary`, `Current`,
    and `Savings`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Fetching, that is, counting the initial amount deposit of the customer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Basically, in real life, the function that we have written above will look
    more similar to the following code snippet. In `OpenAccount`, we are passing a
    `Customer` object. Before creating the bank account of the customer, we are doing
    three distinct tasks:'
  prefs: []
  type: TYPE_NORMAL
- en: '`VerifyCustomerIdentity()`: In this function, the idea is to verify the identity
    of the customer, which is a common practice before an account is opened.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OpenAndLinkRelatedAccounts()`: In this function, the idea is to open different
    accounts for the same customer, that is, `Savings`, `Current`, and `Salaried`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`RetrieveAndCountDeposit()`: In this function, the idea is to retrieve the
    money the customer intends to save, count it, and finally deposit it in the customer''s
    account:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Please note the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The three functions, that is, `VerifyCustomerIdentity()`, `OpenAndLinkRelatedAccounts()`,
    and `RetrieveAndCountDeposit()`, all of which have `Private` as the access modifier.
    This will ensure that the complexities in these three functions are not exposed
    to the outside.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These three functions are being internally called in the `OpenAccount` function,
    so the calling application doesn't need to worry about calling these functions
    explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's say we discover some issues in the internal private function. In this
    case, we can easily make changes in these internal functions without needing to
    worry about the external implementation.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding inheritance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you went through [Chapter 2](7b49f1ac-89ac-4157-88b5-e6b8cd006733.xhtml),
    *Understanding Classes, Structures, and Interfaces*, you will already know how
    inheritance helps us in code reuse and reduced maintenance, and that it gives
    us more control of the entire application.
  prefs: []
  type: TYPE_NORMAL
- en: We also looked at a few code examples and saw how inheritance works and how
    it's implemented in C#. Now, we will look at some advanced features in inheritance,
    their use, and how they are implemented in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Method overriding
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Method overriding is a technique in C# that we can use to invoke the methods
    that are defined in the base class from the classes that are deriving from that
    base class. In method overriding, a derived class implements a function that''s
    declared in the base class with the same signature:'
  prefs: []
  type: TYPE_NORMAL
- en: The same name as the function that's declared in the base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same number and type of parameters in the function
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same return type as the function declared in the base class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In C#, method overriding is implemented using the following two methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Virtual methods**: A virtual method is a method in the base class that can
    also be defined or overridden in the derived class as well. Please note that,
    when a method is declared as virtual, it''s optional to define the implementation
    of the method in the base class. In case it''s defined, it becomes even more optional
    for the derived class to override it further. A method is declared as virtual
    using the *virtual* keyword.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Override**: Once a method has been declared as `virtual` or `abstract` in
    the base class, then by using the *override* keyword, the derived class can redefine
    the implementation of the method for its own use. In this section, we will be
    looking at *virtual methods*. In the next section, *Abstract and sealed classes*,
    we will do a deep dive into `abstract` methods.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s look at a code example to understand how method overriding is implemented
    in C#. Let''s assume that we have a base class, `Car`, and two classes, `Ferrari`
    and `Suzuki`, that are inheriting from the `Car` class. For the sake of explanation,
    we will keep things simple by just specifying a default constructor and a common
    `Accelerate` method across the three classes. The following would be the code
    implementation for the same:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create some objects for these classes by using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that in the preceding code, we have created a new object of the `Ferrari`
    class and have assigned it to a variable, `ferrari`, which is of the `Car` type.
    Similarly, we have also created a new object of the `Suzuki` class and have assigned
    it to a variable, `suzuki`, which is also of the `Car` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'When we execute the code, we get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f4182fda-7d40-4c9a-ba21-32094fa5784e.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that, even though we have the `Accelerate` method in both the parent `Car`
    class and the derived `Ferrari` and `Suzuki` classes, when we are calling the
    `Accelerate` method from the `ferrari` object, it's calling the `Accelerate` method
    that's present in the parent `Car` class. This is due to the fact that the type
    of the variable is `Car` and that, even though it's instantiated with the objects
    of the `Ferrari` and `Suzuki` child classes, the method in the base class has
    not been overridden.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now let''s make a slight change to the implementation and declare the method
    in the base class as `virtual` and the methods in the classes deriving from this
    class as `override`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, execute the same code again and review that we receive the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/614daa81-9315-476d-9b50-fbbca7659856.png)'
  prefs: []
  type: TYPE_IMG
- en: Note that now, the `Accelerate` method executes the code mentioned in the derived
    classes of `Ferrari` and `Suzuki` and not the code specified in the parent class
    of `Car`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Later in this chapter, we will also do a deep dive into polymorphism. There
    are two types of polymorphism: runtime polymorphism and compile-time polymorphism.
    Runtime polymorphism is implemented using method overriding.'
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at `abstract` classes and also explore the
    use of `virtual` methods in `abstract` classes.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: An `abstract` class in C# is a class that cannot be instantiated, that is, the
    program execution cannot create an object of this class. Instead, these classes
    can only act as base classes from which other classes can inherit.
  prefs: []
  type: TYPE_NORMAL
- en: 'We use the `abstract` class in scenarios where we specifically want all the
    deriving classes to implement the specific implementation of a particular function
    that''s declared in the base class. The following are some of the properties of
    an `abstract` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Just like all the other classes, an `abstract` class can have both functions
    and properties.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An `abstract` class can have both abstract and non-abstract functions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s take a look at a program to analyze how `abstract` classes work. We
    will define an `Animal` class using the `abstract` keyword. Now, let''s assume
    that each animal type, such as dog, speaks differently, so they must implement
    the function in their own way. To implement this, we will declare our base `Animal`
    class as `abstract` and have an `abstract` method `Speak` in it. Review that if
    we try to implement the `Speak` method, the compiler throws an error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d648af81-c47b-4e58-8504-52ba481fb632.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To remove this error, we can simply remove the declaration of the `abstract`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s create a `Dog` class that inherits from this base class of `Animal`.
    Note that the compiler will throw an error if the `Speak` method is not implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/33b389c9-5891-4cf7-86af-a23c5d1e2519.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We can get over this error by creating an implementation of the `Speak` function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Please note that we use the `override` keyword to let the compiler know that
    we are overriding the implementation of the `abstract` function called `Speak`
    in the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will look at the same example and understand how `abstract`
    methods differ from `virtual` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Abstract versus virtual methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the preceding example, we declared the `Speak` method as `abstract`. This
    forced our `Dog` class to provide an implementation of the method because, otherwise,
    we would get a compile-time error. Now, what if we don't want to have that particular
    restriction in our code?
  prefs: []
  type: TYPE_NORMAL
- en: 'We can do this by replacing the `abstract` method with the `virtual` method.
    The following is the changed implementation of the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note that when you compile the code, there are no errors. Also, just for the
    sake of experimenting, comment out the `Speak` method in the `Dog` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, compile the program. Note that, unlike the previous case, when we use
    `abstract` methods, no compile-time errors occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0f314e04-d673-4fd9-8045-82f76c321da4.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will look at `sealed` classes and how they are implemented
    in C# applications.
  prefs: []
  type: TYPE_NORMAL
- en: Sealed classes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A `sealed` class in C# is a class that we do not want to be inherited by any
    derived class. Once we insert the keyword `sealed`, a compiler will give a compile-time
    error if a derived class tries to inherit from the `sealed` class. The following
    is the screenshot of the same. For explanation purposes, we will use the same
    two classes we used in the preceding example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dc089c73-eadd-46f1-b15f-ba19c1353c83.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Note that `abstract` and `sealed` do not go hand in hand. `abstract` means
    that the class must never be instantiated, whereas the `sealed` class indicates
    that the class must never be inherited. Therefore, in hindsight, if we declare
    a `sealed` class as `abstract`, this will not make any sense. Thus, if we do try
    to declare an `abstract` class as `sealed`, we will get a compile-time error,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e6492e94-c777-4aa6-8993-c146065b80be.png)'
  prefs: []
  type: TYPE_IMG
- en: In the next section, we will look at another pillar of OOP programming, that
    is, *polymorphism*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Polymorphism is a Greek word whose literal translation to English is *many-shaped*.
    In programming terms, it''s referred to as one interface with multiple functions.
    Let''s try to understand polymorphism by looking at the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/539317c7-f54a-4233-9dec-c8b89f7cd982.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the preceding diagram, we have some program code that runs on **Input 1**
    and gives **Output 1**. Now, let''s say we make a mistake and send an incorrect
    input of **Input 2** instead. In this case, unfortunately, the program code may
    error out and send an error message. In such a scenario, we can use polymorphism.
    With polymorphism, the same example will be represented as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1f794080-5921-49d2-8dbe-d6a8ee4d55b9.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, by using polymorphism, we will maintain three copies of the code
    in memory and depending on the type of input received, the appropriate copy of
    the program code will be loaded and executed.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two types of polymorphism possible in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: Static/compile-time polymorphism, that is, method overloading or function overloading
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Execution time polymorphism, that is, method overriding or virtual functions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's go through each of these types and use code examples to understand how
    they work.
  prefs: []
  type: TYPE_NORMAL
- en: Static/compile-time polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Static polymorphism, also known as function overloading, involves creating functions
    with the same name but with different numbers or types of parameters.
  prefs: []
  type: TYPE_NORMAL
- en: 'The compiler loads the appropriate function based on the input that''s passed.
    Let''s go through the following code example to see how it works. Here, we will
    create two copies of a function called `ADD` that will differ in terms of the
    number of parameters accepted by the function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when the call is made to the function, based on the number of parameters
    passed, the respective function will be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'After the program is executed, we will get the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8f624dda-0863-4caf-acd1-4fb2fddcef50.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s consider another example. In the preceding example, we implemented
    polymorphism based on the number of parameters. In this example, we will implement
    polymorphism based on the type of parameter:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create two classes, one each for `Dog` and `Cat`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Create two functions with the same name but one accepting the input of a `Dog`
    object and another accepting the input of a `Cat` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, when a call is made to the function, based on the type of parameter, the
    appropriate function will be loaded:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'When the program is executed, it will show the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/c5be0bc9-f734-4255-bb9e-5a05a4fe6bb9.png)'
  prefs: []
  type: TYPE_IMG
- en: Runtime polymorphism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Runtime polymorphism in C# is executed via virtual methods. In this type of
    polymorphism, the compiler executes the code by identifying its form at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: In the *Method overriding* section, we learned about virtual methods and saw
    how they allow the derived class to override the implementation of a function
    in the base class. In runtime polymorphism, the object of the base class holds
    the reference to objects of the base and derived classes. Now, based on the object
    that the base object is pointing to, the appropriate function will be loaded.
  prefs: []
  type: TYPE_NORMAL
- en: To recap our understanding of this, let's go through another code example. In
    this example, we will create a base class called `Animal` that will be inherited
    by two classes, `Man` and `Dog`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the implementation in the `Animal` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the `Animal` class, we have declared two attributes to represent `numOfHands`
    and `numOfLegs` of the `Animal`. We have also declared a function called `Speak`
    and have marked it as `Virtual` so that any class that inherits from this class
    can give its own implementation of the `Speak` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: We have declared the `Speak` function as virtual, which means that this function
    can be overridden in the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the implementation in the `Dog` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: In this implementation, we have created a `Dog` class that is inheriting from
    the `Animal` class. The `Dog` class has an attribute called `Breed` and a constructor
    that takes three parameters of `breed`, `hands`, and `legs`, respectively. We
    also have a `Speak` function to provide an impression of how a dog object will
    implement the `Speak` functionality.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code is for another class, `Human`, which will also inherit from
    the base class of `Animal`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding code, we are doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: We are inheriting the `Dog` class from the base class of `Animal`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are overriding the `Speak` function in the derived class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We are also using the attributes that were declared in the base class.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let''s see how runtime polymorphism works. In the following code, we are
    declaring an object of the base `Animal` class and pointing it to an object of
    the derived class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we execute this code, we will notice that, based on the class object reference
    that the base object `animal` is pointing to, the appropriate implementation of
    the `Speak` method will be loaded. This loading is decided at runtime, which is
    why this is called **runtime polymorphism**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/cabfb529-154a-4e4d-9014-790e2f078430.png)'
  prefs: []
  type: TYPE_IMG
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about object-oriented programming, which is the
    main essence of any high-level programming language, including C#. We learned
    about the four pillars of OOP, that is, encapsulation, abstraction, polymorphism,
    and inheritance, and understood how they help us write applications that are easy
    to maintain, are scalable, and have a good amount of reuse.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how encapsulation helps us in keeping our code structured by grouping
    together all the related properties and methods in one class. Then, we learned
    how abstraction helps us reduce the complexity of a module that is exposed to
    the entire application. Using abstraction, we can make sure that all the complexities
    of a class are not exposed to outside classes, which also helps us maintain the
    application better. We also learned how we can use both runtime and static polymorphism
    to implement similar functionalities that can be reused across different inputs,
    thus helping us reuse our code throughout the application. Finally, we learned
    how inheritance helps us have more control over the application's implementation.
    Using inheritance, we can make sure that similar classes implement a set of properties
    and methods that are common across them.
  prefs: []
  type: TYPE_NORMAL
- en: While writing any program in C#, it's highly important that we keep these principles
    in mind. The biggest mistake that some C# programmers make these days is they
    don't utilize these core principles of OOP programming and, instead, the program
    that's written resembles more of a procedural language program. From a maintenance
    perspective, it helps us a lot as, to some extent, it ensures that the bug fixes
    in one module do not impact the complete application.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at the different operators that are used across
    C# programming. We will look at how we can manage program flow using operators
    and different conditional selection statements. We will also look at different
    iteration statements such as for and while loop, which help us control the program's
    flow.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which of the following best describes a program in which we have multiple functions
    with the same name but they differ in terms of the number of parameters and types
    of parameters accepted by them?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Method overloading
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Method overriding
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Encapsulation
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Abstraction
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword must be used when a derived class is defining the implementation
    of a function that's present in the base class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: New
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Virtual
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Override
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Which keyword can we use to prevent the inheritance of a particular class?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Abstract
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Private
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Sealed
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Protected
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: Answers
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Method overloading or function overloading is the concept in which different
    implementations of a function with same name is made. Depending upon the number
    of arguments or type of argument, appropriate implementation of the function is
    loaded.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The override keyword allows a derived class to implement the abstract method
    declared in the base class.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Sealed. If a class is declared as sealed, it will prevent the inheritance of
    the base class throughout the application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
