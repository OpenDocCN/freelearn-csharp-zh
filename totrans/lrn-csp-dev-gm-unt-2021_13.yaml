- en: '13'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '13'
- en: Exploring Generics, Delegates, and Beyond
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 探索泛型、委托以及更多
- en: The more time you spend programming, the more you start thinking about systems.
    Structuring how classes and objects interact, communicate, and exchange data are
    all examples of systems we've worked with so far; the question now is how to make
    them safer and more efficient.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 你编程的时间越长，你就越开始思考系统。如何结构化类和对象之间的交互、通信和数据交换是我们迄今为止所处理的一些系统；现在的问题是，如何使它们更安全、更高效。
- en: Since this will be the last practical chapter of the book, we'll be going over
    examples of generic programming concepts, delegation, event creation, and error
    handling. Each of these topics is a large area of study in its own right, so take
    what you learn here and expand on it in your projects. After we complete our practical
    coding, we'll finish up with a brief overview of design patterns and how they'll
    play a part in your programming journey going forward.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这将本书的最后一章，我们将讨论泛型编程概念、委托、事件创建和错误处理的例子。每个主题本身都是一个庞大的研究领域，所以请将这里学到的知识应用到你的项目中。完成我们的实际编码后，我们将简要概述设计模式及其在你未来编程旅程中的作用。
- en: 'We''ll cover the following topics in this chapter:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Generic programming
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型编程
- en: Using delegates
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用委托
- en: Creating events and subscriptions
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建事件和订阅
- en: Throwing and handling errors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 抛出和处理错误
- en: Understanding design patterns
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解设计模式
- en: Introducing generics
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍泛型
- en: All of our code so far has been very specific in terms of defining and using
    types. However, there will be cases where you need a class or method to treat
    its entities in the same way, regardless of its type, while still being type-safe.
    Generic programming allows us to create reusable classes, methods, and variables
    using a placeholder, rather than a concrete type.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 我们迄今为止的所有代码在定义和使用类型方面都非常具体。然而，会有一些情况，你需要一个类或方法以相同的方式处理其实体，而不管其类型如何，同时仍然保持类型安全。泛型编程允许我们使用占位符而不是具体类型来创建可重用的类、方法和变量。
- en: When a generic class instance is created at compile time or a method is used,
    a concrete type will be assigned, but the code itself treats it as a generic type.
    Being able to write generic code is a huge benefit when you need to work with
    different object types in the same way, for example, custom collection types that
    need to be able to perform the same operations on elements regardless of type,
    or classes that need the same underlying functionality. While you might be asking
    yourself why we don't just subclass or use interfaces, you'll see in our examples
    that generics help us in a different way.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 当在编译时创建泛型类实例或使用方法时，将分配一个具体类型，但代码本身将其视为泛型类型。当你需要以相同的方式处理不同的对象类型时，能够编写泛型代码是一个巨大的好处，例如，需要能够对元素执行相同操作的定制集合类型，或者需要相同底层功能的类。虽然你可能想知道为什么我们不直接使用子类或接口，但你将在我们的例子中看到泛型以不同的方式帮助我们。
- en: We've already seen this in action with the `List` type, which is a generic type.
    We can access all its addition, removal, and modification functions regardless
    of whether it's storing integers, strings, or individual characters.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过 `List` 类型看到了这一点，它是一个泛型类型。我们可以访问它的所有添加、删除和修改功能，无论它存储的是整数、字符串还是单个字符。
- en: Generic objects
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型对象
- en: 'Creating a generic class works the same as creating a non-generic class but
    with one important difference: its generic type parameter. Let''s take a look
    at an example of a generic collection class we might want to create to get a clearer
    picture of how this works:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 创建泛型类与创建非泛型类的工作方式相同，但有一个重要的区别：它的泛型类型参数。让我们看看一个我们可能想要创建的泛型集合类的例子，以更清楚地了解它是如何工作的：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We've declared a generic collection class named `SomeGenericCollection` and
    specified that its type parameter will be named `T`. Now, `T` will stand in for
    the element type that the generic list will store and can be used inside the generic
    class just like any other type.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经声明了一个名为 `SomeGenericCollection` 的泛型集合类，并指定其类型参数将被命名为 `T`。现在，`T` 将代表泛型列表将存储的元素类型，并且可以在泛型类内部像任何其他类型一样使用。
- en: 'Whenever we create an instance of `SomeGenericCollection`, we need to specify
    the type of values it can store:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 每当我们创建一个 `SomeGenericCollection` 的实例时，我们需要指定它可以存储的值的类型：
- en: '[PRE1]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this case, `highScores` stores integer values and `T` stands in for the `int`
    type, but the `SomeGenericCollection` class will treat any element type the same.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`highScores`存储整数值，而`T`代表`int`类型，但`SomeGenericCollection`类将对待任何元素类型相同。
- en: You have complete control over naming a generic type parameter, but the industry
    standard in many programming languages is a capital `T`. If you are going to name
    your type parameters differently, consider starting the name with a capital `T`
    for consistency and readability.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以完全控制泛型类型参数的命名，但在许多编程语言中，行业标准是使用大写`T`。如果你打算以不同的方式命名你的类型参数，请考虑以大写`T`开头，以保持一致性和可读性。
- en: 'Let''s create a more game-focused example next with a generic `Shop` class
    to store some fictional inventory items with the following steps:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们通过以下步骤创建一个更专注于游戏的示例，使用泛型`Shop`类来存储一些虚构的库存项目：
- en: 'Create a new C# script in the `Scripts` folder, name it `Shop`, and update
    its code to the following:'
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Scripts`文件夹中创建一个新的C#脚本，命名为`Shop`，并更新其代码如下：
- en: '[PRE2]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Create a new instance of `Shop` in `GameBehavior`:'
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameBehavior`中创建一个新的`Shop`实例：
- en: '[PRE3]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Let''s break down the code:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: Declares a new generic class named `IShop` with a `T` type parameter
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的名为`IShop`的泛型类，具有类型参数`T`
- en: Adds an inventory `List<T>` of type `T` to store whatever item types we initialize
    the generic class with
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个类型为`T`的库存`List<T>`来存储我们初始化泛型类时使用的任何项目类型
- en: Creates a new instance of `Shop<string>` in `GameBehavior` and specifies string
    values as the generic type
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`GameBehavior`中创建一个新的`Shop<string>`实例，并指定字符串值作为泛型类型
- en: Prints out a debug message with the inventory count:![](img/B17573_13_01.png)
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输出带有库存数量的调试信息：![img/B17573_13_01.png](img/B17573_13_01.png)
- en: 'Figure 13.1: Console output from a generic class'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.1：泛型类的控制台输出
- en: Nothing new has happened here yet in terms of functionality, but Visual Studio
    recognizes `Shop` as a generic class because of its generic type parameter, `T`.
    This sets us up to include additional generic operations like adding inventory
    items or finding how many of each item is available.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在功能方面，这里还没有发生任何新的事情，但Visual Studio由于泛型类型参数`T`，将`Shop`识别为泛型类。这使我们能够包含额外的泛型操作，如添加库存项目或查找每种项目的可用数量。
- en: It's worth noting here that generics aren't supported by the Unity Serializer
    by default. If you want to serialize generic classes, like we did with custom
    classes in the last chapter, you need to add the `Serializable` attribute to the
    top of class, like we did with our `Weapon` class. You can find more information
    at [https://docs.unity3d.com/ScriptReference/SerializeReference.html](https://docs.unity3d.com/ScriptReference/SerializeReference.html).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，Unity序列化器默认不支持泛型。如果你想要序列化泛型类，就像我们在上一章中自定义类那样，你需要在类顶部添加`Serializable`属性，就像我们在`Weapon`类中做的那样。更多信息可以在[https://docs.unity3d.com/ScriptReference/SerializeReference.html](https://docs.unity3d.com/ScriptReference/SerializeReference.html)找到。
- en: Generic methods
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型方法
- en: 'A standalone generic method can have a placeholder type parameter, just like
    a generic class, which allows it to be included inside either a generic or non-generic
    class as needed:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 一个独立的泛型方法可以有一个占位符类型参数，就像泛型类一样，这允许它根据需要包含在泛型或非泛型类中：
- en: '[PRE4]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `T` type can be used inside the method body and defined when the method
    is called:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '`T`类型可以在方法体中使用，并在调用方法时定义：'
- en: '[PRE5]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'If you want to declare a generic method inside a generic class, you don''t
    need to specify a new `T` type:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想在泛型类中声明一个泛型方法，你不需要指定一个新的`T`类型：
- en: '[PRE6]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'When you call a non-generic method that uses a generic type parameter, there''s
    no issue because the generic class has already taken care of assigning a concrete
    type:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当你调用一个使用泛型类型参数的非泛型方法时，没有问题，因为泛型类已经处理了分配具体类型：
- en: '[PRE7]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Generic methods can be overloaded and marked as static, just like non-generic
    methods. If you want the specific syntax for those situations, check out [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods).
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型方法可以重载并标记为静态，就像非泛型方法一样。如果你想知道那些情况下的特定语法，请查看[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/generic-methods)。
- en: Your next task is to create a method that adds new generic items to the inventory
    and use it in the `GameBehavior` script.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个任务是创建一个方法，用于向库存中添加新的泛型项目，并在`GameBehavior`脚本中使用它。
- en: 'Since we already have a generic class with a defined type parameter, let''s
    add a non-generic method to see them working together:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经有了一个具有定义类型参数的泛型类，让我们添加一个非泛型方法来看看它们是如何一起工作的：
- en: 'Open up `Shop` and update the code as follows:'
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Shop` 并按照以下方式更新代码：
- en: '[PRE8]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Go into `GameBehavior` and add an item to `itemShop`:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进入 `GameBehavior` 并向 `itemShop` 添加一个物品：
- en: '[PRE9]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s break down the code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: Declares a method for adding `newItems` of type `T` to the inventory
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个用于向库存添加 `newItems` 类型 `T` 的方法
- en: Adds two string items to `itemShop` using `AddItem()` and prints out a debug
    log:![](img/B17573_13_02.png)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `AddItem()` 向 `itemShop` 添加两个字符串项并打印出调试日志：![img/B17573_13_02.png](img/B17573_13_02.png)
- en: 'Figure 13.2: Console output after adding an item to a generic class'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.2：向泛型类添加物品后的控制台输出
- en: We wrote `AddItem()` to take in a parameter of the same type as our generic
    `Shop` instance. Since `itemShop` was created to hold string values, we add the
    `"Potion"` and `"Antidote"` string values without any issues.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们编写了 `AddItem()` 方法来接受与我们的泛型 `Shop` 实例相同类型的参数。由于 `itemShop` 是用来存储字符串值的，所以我们添加
    `"Potion"` 和 `"Antidote"` 字符串值时没有任何问题。
- en: 'However, if you try and add an integer, for example, you''ll get an error saying
    that the generic type of the `itemShop` doesn''t match:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果你尝试添加一个整数，例如，你会得到一个错误，说 `itemShop` 的泛型类型不匹配：
- en: '![](img/B17573_13_03.png)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![img/B17573_13_03.png](img/B17573_13_03.png)'
- en: 'Figure 13.3: Conversion error in a generic class'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.3：通用类中的转换错误
- en: Now that you've written a generic method, you need to know how to use multiple
    generic types in a single class. For example, what if we wanted to add a method
    to the `Shop` class that finds out how many of a given item are in stock? We can't
    use type `T` again because it's already been defined in the class definition.
    So what do we do?
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经编写了一个泛型方法，你需要知道如何在单个类中使用多个泛型类型。例如，如果我们想在 `Shop` 类中添加一个方法来找出给定物品在库存中有多少，我们不能再次使用类型
    `T`，因为它已经在类定义中定义了。那么我们该怎么办？
- en: 'Add the following method to the bottom of the `Shop` class:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 将以下方法添加到 `Shop` 类的底部：
- en: '[PRE10]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Let''s break down our new method:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解我们的新方法：
- en: Declares a method that returns an int value for how many matching items of type
    `U` we find in the inventory
  id: totrans-63
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个返回库存中找到的匹配类型 `U` 的物品数量的 int 值的方法
- en: Generic type parameter naming is completely up to you, just like naming variables.
    Conventionally, they start at `T` and continue in alphabetical order from there.
  id: totrans-64
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 泛型类型参数的命名完全取决于你，就像命名变量一样。传统上，它们从 `T` 开始，并从那里按字母顺序继续。
- en: Creates a variable to hold the number of matching stock items we find and eventually
    return from the inventory
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个变量来保存我们找到的匹配库存物品的数量，并最终从库存中返回
- en: Uses a `foreach` loop to go through the inventory list and increase the stock
    value every time a match is found
  id: totrans-66
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `foreach` 循环遍历库存列表，每次找到匹配项时增加库存值
- en: Returns the number of matching stock items
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回匹配库存物品的数量
- en: 'The problem here is that we''re storing string values in our shop, so if we
    try and look up how many string items we have, we''ll get the full inventory:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的问题是我们将字符串值存储在我们的商店中，如果我们尝试查找有多少字符串类型的物品，我们将得到完整的库存：
- en: '[PRE11]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This will print something like the following to the console:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台打印出类似以下内容：
- en: '![](img/B17573_13_04.png)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![img/B17573_13_04.png](img/B17573_13_04.png)'
- en: 'Figure 13.4: Console output from using multiple generic string types'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.4：使用多个泛型字符串类型的控制台输出
- en: 'On the other hand, if we tried to look up integer types in our inventory, we''d
    get no results because we''re only storing strings:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 另一方面，如果我们尝试在我们的库存中查找整数类型，我们将得到没有结果，因为我们只存储字符串：
- en: '[PRE12]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This will print something like the following to the console:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台打印出类似以下内容：
- en: '![](img/B17573_13_05.png)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![img/B17573_13_05.png](img/B17573_13_05.png)'
- en: 'Figure 13.5: Console output using multiple non-matching generic types'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.5：使用多个不匹配的泛型类型的控制台输出
- en: Neither of these scenarios is ideal since we can't make sure our shop inventory
    is storing AND can be searched for the same item type. But here's where generics
    really shine—we can add rules for our generic classes and methods to enforce the
    behavior we want, which we'll cover in the next section.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们无法确保我们的商店库存既能存储又能搜索相同类型的物品，因此这两种情况都不是理想的。但正是在这里，泛型真正发光——我们可以为我们的泛型类和方法添加规则，以强制执行我们想要的行为，这将在下一节中介绍。
- en: Constraint type parameters
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 约束类型参数
- en: One of the great things about generics is that their type parameters can be
    limited. This might contradict what we've learned about generics so far, but just
    because a class *can* contain any type, doesn't mean it should be allowed to.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型的一个优点是它们的类型参数可以被限制。这可能与到目前为止我们所学的泛型知识相矛盾，但仅仅因为一个类 *可以* 包含任何类型，并不意味着它应该被允许这样做。
- en: 'To constrain a generic type parameter, we need a new keyword and a syntax we
    haven''t seen before:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 要约束泛型类型参数，我们需要一个新的关键字和之前未见过语法：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The `where` keyword defines the rules that `T` must pass before it can be used
    as a generic type parameter. It essentially says `SomeGenericClass` can take in
    any `T` type as long as it conforms to the constraining type. The constraining
    rules aren''t anything mystical or scary; they''re concepts we''ve already covered:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`where` 关键字定义了 `T` 必须满足的规则，才能作为泛型类型参数使用。它本质上表示 `SomeGenericClass` 可以接受任何符合约束类型的
    `T` 类型。约束规则并不是什么神秘或可怕的东西；它们是我们已经讨论过的概念：'
- en: Adding the `class` keyword would constrain `T` to types that are classes
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `class` 关键字将限制 `T` 只能是类类型
- en: Adding the `struct` keyword would constrain `T` to types that are structs
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加 `struct` 关键字将限制 `T` 只能是结构体类型
- en: Adding an interface, such as `IManager`, as the type would limit `T` to types
    that adopt the interface
  id: totrans-86
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将接口，例如 `IManager`，作为类型添加将限制 `T` 只能是采用该接口的类型
- en: Adding a custom class, such as `Character`, would constrain `T` to only that
    class type
  id: totrans-87
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 添加一个自定义类，例如 `Character`，将限制 `T` 只能是该类类型
- en: 'If you need a more flexible approach to account for classes that have subclasses,
    you can use `where T : U`, which specifies that the generic `T` type must be of,
    or derive from, the `U` type. This is a little advanced for our needs, but you
    can find more details at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters).'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你需要一个更灵活的方法来处理具有子类的类，你可以使用 `where T : U`，这指定了泛型 `T` 类型必须是 `U` 类型或从 `U` 类型派生的。这对于我们的需求来说有点高级，但你可以在
    [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/generics/constraints-on-type-parameters)
    找到更多详细信息。'
- en: 'Just for fun, let''s constrain `Shop` to only accept a new type called `Collectable`:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 为了好玩，让我们将 `Shop` 限制为只能接受一个名为 `Collectable` 的新类型：
- en: 'Create a new script in the `Scripts` folder, name it `Collectable`, and add
    the following code:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scripts` 文件夹中创建一个新的脚本，命名为 `Collectable`，并添加以下代码：
- en: '[PRE14]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: All we've done here is declare a new class called `Collectable` with a name
    property, and created subclasses for potions and antidotes. With this structure,
    we can enforce our `Shop` to only accept `Collectable` types, and our stock finding
    method to only accept `Collectable` types as well so we can compare them and find
    matches.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们在这里所做的一切只是声明了一个名为 `Collectable` 的新类，具有一个名称属性，并为药水和解药创建了子类。有了这种结构，我们可以强制 `Shop`
    只接受 `Collectable` 类型，并且我们的库存查找方法也只接受 `Collectable` 类型，这样我们就可以进行比较并找到匹配项。
- en: 'Open up `Shop` and update the class declaration:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Shop` 并更新类声明：
- en: '[PRE15]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Update the `GetStockCount()` method to constrain `U` to equal whatever the
    initial generic `T` type is:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `GetStockCount()` 方法以约束 `U` 等于初始泛型 `T` 类型：
- en: '[PRE16]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In `GameBehavior`, update the `itemShop` instance to the following code:'
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `GameBehavior` 中，更新 `itemShop` 实例到以下代码：
- en: '[PRE17]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This will result in output like the following:'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这将导致以下输出：
- en: '![](img/B17573_13_12.png)'
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![图片](img/B17573_13_12.png)'
- en: 'Figure 13.6: Output from updated GameBehavior script'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.6：更新后的 GameBehavior 脚本输出
- en: In our example, we can ensure only collectable types are allowed in our shops.
    If we accidentally try and add non-collectable types in our code, Visual Studio
    will alert us about trying to break our own rules!
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的示例中，我们可以确保我们的商店中只允许收集类型。如果我们不小心在代码中尝试添加非收集类型，Visual Studio 将会提醒我们正在尝试破坏自己的规则！
- en: Adding generics to Unity objects
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将泛型添加到 Unity 对象中
- en: Generics also work with Unity scripts and GameObjects. For example, we can easily
    create a generic destroyable class to use on any `MonoBehaviour` or object `Component`
    we want to delete from the scene. If this sounds familiar, it's what our `BulletBehavior`
    does for us, but it's not applicable to anything other than that script. To make
    this more scalable, let's make any script that inherits from `MonoBehaviour` destroyable.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型也可以与 Unity 脚本和 GameObject 一起使用。例如，我们可以轻松地创建一个泛型可销毁类，用于从场景中删除我们想要删除的任何 `MonoBehaviour`
    或对象 `Component`。如果这听起来很熟悉，这就是我们的 `BulletBehavior` 为我们做的事情，但它不适用于除该脚本之外的任何东西。为了使这个功能更具可扩展性，让我们使任何从
    `MonoBehaviour` 继承的脚本都成为可销毁的。
- en: 'Create a new script in the `Scripts` folder, name it `Destroyable`, and add
    the following code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Scripts` 文件夹中创建一个新的脚本，命名为 `Destroyable`，并添加以下代码：
- en: '[PRE18]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Delete all the code inside `BulletBehavior` and inherit from the new generic
    class:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除 `BulletBehavior` 中的所有代码，并从新的泛型类继承：
- en: '[PRE19]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We've now turned our `BulletBehavior` script into a generic destroyable object.
    Nothing changes in the Bullet Prefab, but we can make any other object destroyable
    by inheriting from the generic `Destroyable` class. In our example, this would
    boost code efficiency and reusability if we created multiple projectile Prefabs
    and wanted them all to be destroyable, but at different times.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经将 `BulletBehavior` 脚本转换成了一个泛型可销毁对象。子弹预制体没有变化，但我们可以通过从泛型 `Destroyable`
    类继承来使任何其他对象可销毁。在我们的例子中，如果我们创建了多个弹道预制体并希望它们都能在特定时间被销毁，这将提高代码的效率和可重用性。
- en: Generic programming is a powerful tool in our toolbox, but with the basics covered
    it's time to talk about an equally important topic as you progress in your programming
    journey—delegation!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型编程是我们工具箱中的强大工具，但在掌握了基础知识之后，随着你在编程旅程中的进步，现在是时候讨论一个同样重要的主题了——委托！
- en: Delegating actions
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 委托动作
- en: There will be times when you need to pass off, or delegate, the execution of
    a method from one file to another. In C#, this can be accomplished through delegate
    types, which store references to methods and can be treated like any other variable.
    The only caveat is that the delegate itself and any assigned method need to have
    the same signature—just like integer variables can only hold whole numbers and
    strings can only hold text.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，你需要将方法从文件 A 传递到文件 B，或者委托执行。在 C# 中，这可以通过委托类型来实现，它存储对方法的引用，可以像任何其他变量一样处理。唯一的限制是，委托本身和任何分配的方法需要具有相同的签名——就像整数变量只能持有整数，字符串只能持有文本一样。
- en: 'Creating a delegate is a mix between writing a function and declaring a variable:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 创建委托是编写函数和声明变量之间的混合：
- en: '[PRE20]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'You start with an access modifier followed by the `delegate` keyword, which
    identifies it to the compiler as a `delegate` type. A `delegate` type can have
    a return type and name as a regular function, as well as parameters if needed.
    However, this syntax only declares the `delegate` type itself; to use it, you
    need to create an instance as we do with classes:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 你从一个访问修饰符开始，后面跟着 `delegate` 关键字，它将编译器识别为 `delegate` 类型。`delegate` 类型可以有一个返回类型和名称，就像常规函数一样，如果需要还可以有参数。然而，这个语法只声明了
    `delegate` 类型本身；要使用它，你需要创建一个实例，就像我们处理类一样：
- en: '[PRE21]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'With a `delegate` type variable declared, it''s easy to assign a method that
    matches the delegate signature:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 声明了一个 `delegate` 类型变量后，很容易分配一个与委托签名匹配的方法：
- en: '[PRE22]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Notice that you don''t include the parentheses when assigning `MatchingMethod`
    to the `someDelegate` variable, as it''s not calling the method at this point.
    What it''s doing is delegating the calling responsibility of `MatchingMethod`
    to `someDelegate`, which means we can call the function as follows:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在将 `MatchingMethod` 分配给 `someDelegate` 变量时，你不需要包括括号，因为此时并没有调用方法。它所做的只是将 `MatchingMethod`
    的调用责任委托给 `someDelegate`，这意味着我们可以像这样调用函数：
- en: '[PRE23]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: This might seem cumbersome at this point in your C# skill development, but I
    promise you that being able to store and execute methods as variables will come
    in handy down the road.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，你的 C# 技能发展可能觉得有些繁琐，但我向你保证，能够将方法和执行存储为变量将在以后派上用场。
- en: Creating a debug delegate
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建调试委托
- en: 'Let''s create a simple delegate type to define a method that takes in a string
    and eventually prints it out using an assigned method. Open up `GameBehavior`
    and add the following code:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个简单的委托类型来定义一个接受字符串的方法，并最终使用分配的方法将其打印出来。打开 `GameBehavior` 并添加以下代码：
- en: '[PRE24]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Let''s break down the code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: Declares a `public delegate` type named `DebugDelegate` to hold a method that
    takes in a `string` parameter and returns `void`
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个名为`DebugDelegate`的`public delegate`类型，用于存储接受一个`string`参数并返回`void`的方法
- en: Creates a new `DebugDelegate` instance named `debug` and assigns it a method
    with a matching signature named `Print()`
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的名为`debug`的`DebugDelegate`实例，并将其分配给一个具有匹配签名的名为`Print()`的方法
- en: Replaces the `Debug.Log(_state)` code inside `Initialize()` with a call to the
    `debug` delegate instance instead
  id: totrans-128
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Initialize()`中的`Debug.Log(_state)`代码替换为对`debug`委托实例的调用
- en: Declares `Print()` as a `static` method that takes in a `string` parameter and
    logs it to the console:![](img/B17573_13_06.png)
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Print()`声明为接受一个`string`参数并将其记录到控制台中的`static`方法：![img/B17573_13_06.png](img/B17573_13_06.png)
- en: 'Figure 13.7: Console output from a delegate action'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.7：委托动作的控制台输出
- en: Nothing in the console has changed, but instead of directly calling `Debug.Log()`
    inside `Initialize()`, that operation has been delegated to the `debug` delegate
    instance. While this is a simplistic example, delegation is a powerful tool when
    you need to store, pass, and execute methods as their types.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台中的内容没有变化，但在`Initialize()`中直接调用`Debug.Log()`的操作已经委托给了`debug`委托实例。虽然这是一个简单的例子，但在你需要存储、传递和执行方法时，委托是一个强大的工具。
- en: In Unity, we've already worked with examples of delegation by using the `OnCollisionEnter()`
    and `OnCollisionExit()` methods, which are methods that are called through delegation.
    In the real world, custom delegates are most useful when paired with events, which
    we'll see in a later section of this chapter.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，我们已经通过使用`OnCollisionEnter()`和`OnCollisionExit()`方法来处理委托的示例，这些方法是通过委托调用的。在现实世界中，自定义委托与事件结合使用时最为有用，我们将在本章的后续部分看到这一点。
- en: Delegates as parameter types
  id: totrans-133
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 作为参数类型的委托
- en: Since we've seen how to create delegate types for storing methods, it makes
    sense that a delegate type could also be used as a method parameter itself. This
    isn't that far removed from what we've already done, but it's a good idea to cover
    our bases.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经看到了如何创建用于存储方法的委托类型，因此一个委托类型也可以用作方法参数本身。这并不比我们之前所做的工作远，但了解这一点是个好主意。
- en: 'Let''s see how a delegate type can be used as a method parameter. Update `GameBehavior`
    with the following code:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将委托类型用作方法参数。用以下代码更新`GameBehavior`：
- en: '[PRE25]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Let''s break down the code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: Calls `LogWithDelegate()` and passes in our `debug` variable as its type parameter
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用`LogWithDelegate()`并传入我们的`debug`变量作为其类型参数
- en: Declares a new method that takes in a parameter of the `DebugDelegate` type
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的方法，它接受一个`DebugDelegate`类型的参数
- en: Calls the delegate parameter's function and passes in a string literal to be
    printed out:![](img/B17573_13_07.png)
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用委托参数的函数，并传入一个要打印的字符串字面量：![img/B17573_13_07.png](img/B17573_13_07.png)
- en: 'Figure 13.8: Console output of a delegate as a parameter type'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.8：作为参数类型的委托的控制台输出
- en: We've created a method that takes in a parameter of the `DebugDelegate` type,
    which means that the actual argument passed in will represent a method and can
    be treated as one. Think of this example as a delegation chain, where `LogWithDelegate()`
    is two steps removed from the actual method doing the debugging, which is `Print()`.
    Creating a delegation chain like this isn't always a common solution in a game
    or application scenario, but when you need to control levels of delegation it's
    important to understand the syntax involved. This is especially true in scenarios
    where your delegation chain is spread across multiple scripts or classes.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建了一个接受`DebugDelegate`类型参数的方法，这意味着实际传入的参数将代表一个方法，可以将其视为一个方法。将这个例子想象成一个委托链，其中`LogWithDelegate()`距离实际执行调试的方法`Print()`有两个步骤。在游戏或应用场景中，创建这样的委托链并不总是常见的解决方案，但当你需要控制委托级别时，了解相关的语法就很重要了。这在你的委托链分布在多个脚本或类中的场景中尤其如此。
- en: It's easy to get lost with delegation if you miss an important mental connection,
    so go back and review the code from the beginning of the section and check the
    docs at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 如果错过了一个重要的心理联系，委托就很容易迷失方向，所以请回顾本节开头的代码，并查看[https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/delegates/)上的文档。
- en: Now that you know how to work with basic delegates, it's time to talk about
    how events can be used to efficiently communicate information between multiple
    scripts. Honestly, the best use case for a delegate is being paired with events,
    which we'll dive into next.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了如何使用基本委托，是时候讨论如何使用事件在多个脚本之间高效地传递信息了。说实话，委托的最佳用途是与事件配对，我们将在下一节中深入探讨。
- en: Firing events
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 触发事件
- en: C# events allow you to essentially create a subscription system based on actions
    in your games or apps. For instance, if you wanted to send out an event whenever
    an item is collected, or when a player presses the spacebar, you could do that.
    However, when an event fires, it doesn't automatically have a subscriber, or receiver,
    to handle any code that needs to execute after the event action.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: C#事件允许你基于游戏或应用程序中的动作创建一个基于动作的订阅系统。例如，如果你想发送一个事件，每当收集到物品或玩家按下空格键时，你可以这样做。然而，当事件触发时，它不会自动有一个订阅者或接收者来处理事件动作之后需要执行的任何代码。
- en: Any class can subscribe or unsubscribe to an event through the calling class
    the event is fired from; just like signing up to receive notifications on your
    phone when a new post is shared on Facebook, events form a kind of distributed-information
    superhighway for sharing actions and data across your application.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 任何类都可以通过调用触发事件的类来订阅或取消订阅事件；就像在Facebook上分享新帖子时在手机上注册接收通知一样，事件形成了一种分布式信息高速公路，用于在应用程序中共享动作和数据。
- en: 'Declaring events is similar to declaring delegates in that an event has a specific
    method signature. We''ll use a delegate to specify the method signature we want
    the event to have, then create the event using the `delegate` type and the `event`
    keyword:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 声明事件与声明委托类似，因为事件具有特定的方法签名。我们将使用委托来指定事件应具有的方法签名，然后使用`delegate`类型和`event`关键字创建事件：
- en: '[PRE26]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'This setup allows us to treat `eventInstance` as a method because it''s a delegate
    type, which means we can send it out at any time by calling it:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 这种设置使我们能够将`eventInstance`视为一个方法，因为它是一个委托类型，这意味着我们可以通过调用它来在任何时候发送它：
- en: '[PRE27]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Your next task is to create an event of your own and fire it off in the appropriate
    place inside `PlayerBehavior`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个任务是创建一个自己的事件，并在`PlayerBehavior`内部适当的位置触发它。
- en: Creating and invoking events
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和调用事件
- en: 'Let''s create an event to fire off any time our player jumps. Open up `PlayerBehavior`
    and add the following changes:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个事件，每当我们的玩家跳跃时触发。打开`PlayerBehavior`并添加以下更改：
- en: '[PRE28]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Let''s break down the code:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: Declares a new `delegate` type that returns `void` and takes in no parameters
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的返回`void`且不接受任何参数的`delegate`类型
- en: Creates an event of the `JumpingEvent` type, named `playerJump`, that can be
    treated as a method that matches the preceding delegate's `void` return and no
    parameter signature
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`playerJump`的`JumpingEvent`类型事件，它可以被视为一个与前面委托的`void`返回值和没有参数签名匹配的方法
- en: Calls `playerJump` after the force is applied in `Update()`
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Update()`中应用力后调用`playerJump`
- en: We have successfully created a simple delegate type that takes in no parameters
    and returns nothing, as well as an event of that type to execute whenever the
    player jumps. Each time the player jumps, the `playerJump` event is sent out to
    all of its subscribers to notify them of the action.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经成功创建了一个不接受任何参数且不返回任何内容的简单委托类型，以及一个每当玩家跳跃时执行的事件类型。每次玩家跳跃时，`playerJump`事件都会发送给所有订阅者，以通知他们该动作。
- en: After the event fires, it's up to its subscribers to process it and do any additional
    operations, which we'll see in the *Handling event subscriptions* section, next.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 事件触发后，处理它并执行任何附加操作的责任就交给了其订阅者；我们将在下一节“处理事件订阅”中看到这一点。
- en: Handling event subscriptions
  id: totrans-162
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理事件订阅
- en: 'Right now, our `playerJump` event has no subscribers, but changing that is
    simple and very similar to how we assigned method references to delegate types
    in the last section:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的`playerJump`事件没有订阅者，但改变这一点很简单，并且与我们在上一节中为委托类型分配方法引用的方式非常相似：
- en: '[PRE29]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Since events are variables that belong to the class they''re declared in, and
    subscribers will be other classes, a reference to the event-containing class is
    necessary for subscriptions. The `+=` operator is used to assign a method that
    will fire when an event executes, just like setting up an out-of-office email.
    Like assigning delegates, the method signature of the event handler method must
    match the event''s type. In our previous syntax example, that means `EventHandler`
    needs to be the following:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件是它们声明的类中的变量，而订阅者是其他类，因此订阅需要事件包含类的引用。使用 `+=` 操作符分配一个在事件执行时触发的方法，就像设置自动回复邮件一样。像分配委托一样，事件处理方法的方法签名必须与事件类型匹配。在我们的先前的语法示例中，这意味着
    `EventHandler` 需要是以下形式：
- en: '[PRE30]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'In cases where you need to unsubscribe from an event, you simply do the reverse
    of the assignment by using the `-=` operator:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要取消订阅事件的情况下，你只需使用 `-=` 操作符执行赋值的逆操作：
- en: '[PRE31]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Event subscriptions are generally handled when a class is initialized or destroyed,
    making it easy to manage multiple events without messy code implementations.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 事件订阅通常在类初始化或销毁时处理，这使得管理多个事件而无需编写混乱的代码实现变得容易。
- en: Now that you know the syntax for subscribing and unsubscribing to events, it's
    your turn to put this into practice in the `GameBehavior` script.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经知道了订阅和取消订阅事件的语法，现在是时候在 `GameBehavior` 脚本中将这些应用到实践中了。
- en: 'Now that our event is firing every time the player jumps, we need a way to
    capture that action:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的事件在玩家跳跃时每次都会触发，我们需要一种方法来捕捉这个动作：
- en: 'Go back to `GameBehavior` and update the following code:'
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 返回到 `GameBehavior` 并更新以下代码：
- en: '[PRE32]'
  id: totrans-173
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Let''s break down the code:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: Creates a public variable of type `PlayerBehavior`
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个类型为 `PlayerBehavior` 的公共变量
- en: Declares the `OnEnable()` method, which is called whenever the object the script
    is attached to becomes active in the scene
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `OnEnable()` 方法，该方法在脚本附加的对象在场景中变为活动状态时被调用
- en: '`OnEnable` is a method in the `MonoBehaviour` class, so all Unity scripts have
    access to it. This is a great place to put event subscriptions instead of `Awake`
    because it only executes when the object is active, not just in the process of
    loading.'
  id: totrans-177
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`OnEnable` 是 `MonoBehaviour` 类中的一个方法，因此所有 Unity 脚本都可以访问它。这是一个放置事件订阅的好地方，而不是使用
    `Awake`，因为它只在对象活动时执行，而不是在加载过程中。'
- en: Finds the `Player` object in the scene and stores its `GameObject` in a local
    variable
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景中找到 `Player` 对象，并将它的 `GameObject` 存储在一个局部变量中
- en: Uses `GetComponent()` to retrieve a reference to the `PlayerBehavior` class
    attached to the `Player` and stores it in the `playerBehavior` variable
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `GetComponent()` 获取附加到 `Player` 的 `PlayerBehavior` 类的引用，并将其存储在 `playerBehavior`
    变量中
- en: Subscribes to the `playerJump` event declared in `PlayerBehavior` with a method
    named `HandlePlayerJump` using the `+=` operator
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 `+=` 操作符订阅 `PlayerBehavior` 中声明的 `playerJump` 事件，并使用名为 `HandlePlayerJump`
    的方法
- en: Declares the `HandlePlayerJump()` method with a signature that matches the event's
    type and logs a success message using the debug delegate each time the event is
    received:![](img/B17573_13_08.png)
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明 `HandlePlayerJump()` 方法，其签名与事件类型匹配，并在每次接收到事件时使用调试委托记录成功消息！:![img/B17573_13_08.png](img/B17573_13_08.png)
- en: 'Figure 13.9: Console output from a delegate event subscription'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图 13.9：委托事件订阅的控制台输出
- en: To correctly subscribe and receive events in `GameBehavior`, we had to grab
    a reference to the `PlayerBehavior` class attached to the player. We could have
    done this all in one line, but it's much more readable when it's split up. We
    then assigned a method to the `playerJump` event that will execute whenever the
    event is received, and complete the subscription process.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在 `GameBehavior` 中正确订阅并接收事件，我们必须获取附加到玩家上的 `PlayerBehavior` 类的引用。我们本可以一行完成这个操作，但将其拆分会使代码更易读。然后我们为
    `playerJump` 事件分配了一个方法，该方法在接收到事件时执行，并完成订阅过程。
- en: 'Now each time you jump, you''ll see a debug message with the event message:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 现在每次你跳跃时，你都会看到一个包含事件消息的调试信息：
- en: '![](img/B17573_13_09.png)'
  id: totrans-185
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B17573_13_09.png)'
- en: 'Figure 13.10: Console output from a delegate event firing'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 图 13.10：委托事件触发的控制台输出
- en: Since event subscriptions are configured in scripts, and scripts are attached
    to Unity objects, our job isn't done yet. We still need to handle how we clean
    up subscriptions when the object is destroyed or removed from the scene, which
    we'll cover in the next section.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 由于事件订阅是在脚本中配置的，而脚本附加到 Unity 对象上，我们的工作还没有完成。我们还需要处理当对象被销毁或从场景中移除时如何清理订阅，这将在下一节中介绍。
- en: Cleaning up event subscriptions
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 清理事件订阅
- en: Even though our player is never destroyed in our prototype, that's a common
    feature in games when you lose. It's always important to clean up event subscriptions
    because they take up allocated resources, as we discussed with streams in *Chapter
    12*, *Saving, Loading, and Serializing Data*.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管在我们的原型中玩家永远不会被销毁，但在游戏中失败时这是一个常见的功能。始终重要的是要清理事件订阅，因为它们会占用分配的资源，正如我们在*第12章*，*保存、加载和序列化数据*中讨论的那样。
- en: 'We don''t want any subscriptions hanging around after the subscribed object
    has been destroyed, so let''s clean up our jumping event. Add the following code
    to `GameBehavior` after the `OnEnable` method:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不希望订阅的对象被销毁后还有任何订阅存在，所以让我们清理我们的跳跃事件。在`OnEnable`方法之后向`GameBehavior`添加以下代码：
- en: '[PRE33]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'Let''s break down our new code addition:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下我们的新代码添加部分：
- en: Declares the `OnDisable()` method, which belongs to the `MonoBehavior` class
    and is the companion to the `OnEnable()` method we used earlier
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`OnDisable()`方法，它属于`MonoBehavior`类，是之前使用的`OnEnable()`方法的配套方法
- en: Any cleanup code you need to write should generally go in this method, as it
    executes when the object the script is attached to is inactive
  id: totrans-194
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你需要编写的任何清理代码通常都应该放在这个方法中，因为它在脚本附加的对象不活动时执行
- en: Unsubscribes the `playerJump` event from `HandlePlayerJump` using the `-=` operator
    and print out a console message
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用`-=`运算符从`HandlePlayerJump`取消订阅`playerJump`事件，并打印出控制台消息
- en: Now our script properly subscribes and unsubscribes to an event when the GameObject
    is enabled and disabled, leaving no unused resources in our game scene.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们的脚本在GameObject启用和禁用时正确地订阅和取消订阅事件，在我们的游戏场景中不留任何未使用的资源。
- en: That wraps up our discussion on events. Now you can broadcast them to every
    corner of your game from a single script and react to scenarios like a player
    losing life, collecting items, or updating the UI. However, we still have to discuss
    a very important topic that no program can succeed without, and that's error handling.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这就结束了我们对事件的讨论。现在你可以从单个脚本中广播事件到游戏的每个角落，并应对玩家生命值减少、收集物品或更新UI等场景。然而，我们仍然需要讨论一个非常重要的主题，没有这个主题任何程序都无法成功，那就是错误处理。
- en: Handling exceptions
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异常处理
- en: Efficiently incorporating errors and exceptions into your code is both a professional
    and personal benchmark in your programming journey. Before you start yelling "Why
    would I add errors when I've spent all this time trying to avoid them?!", you
    should know that I don't mean adding errors to break your existing code. It's
    quite the opposite—including errors or exceptions and handling them appropriately
    when pieces of functionality are used incorrectly makes your code base stronger
    and less prone to crashes, not weaker.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 高效地将错误和异常集成到你的代码中，是你编程旅程中专业和个人基准的一部分。在你开始大喊“我花了这么多时间试图避免错误，为什么要添加错误？！”之前，你应该知道，我的意思并不是添加错误来破坏你现有的代码。恰恰相反——包括错误或异常，并在功能部件使用不当时适当地处理它们，会使你的代码库更强大，更不容易崩溃，而不是更弱。
- en: Throwing exceptions
  id: totrans-200
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抛出异常
- en: When we talk about adding errors, we refer to the process as *exception throwing*,
    which is an apt visual analogy. Throwing exceptions is part of something called
    defensive programming, which essentially means that you actively and consciously
    guard against improper or unplanned operations in your code. To mark those situations,
    you throw out an exception from a method that is then handled by the calling code.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们谈论添加错误时，我们将其过程称为*异常抛出*，这是一个恰当的视觉类比。抛出异常是防御性编程的一部分，本质上意味着你积极地、有意识地保护你的代码免受不正确或不计划的操作。为了标记这些情况，你从一个方法中抛出一个异常，然后由调用代码处理。
- en: 'Let''s take an example: say we have an `if` statement that checks whether a
    player''s email address is valid before letting them sign up. If the email entered
    is not valid, we want our code to throw an exception:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们举一个例子：假设我们有一个`if`语句，在允许玩家注册之前检查玩家的电子邮件地址是否有效。如果输入的电子邮件地址无效，我们希望我们的代码抛出异常：
- en: '[PRE34]'
  id: totrans-203
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We use the `throw` keyword to send out the exception, which is created with
    the `new` keyword followed by the exception we specify. `System.ArgumentException()`
    will log the information about where and when the exception was executed by default,
    but can also accept a custom string if you want to be more specific.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用`throw`关键字来抛出异常，该异常是通过在`new`关键字后跟指定的异常来创建的。默认情况下，`System.ArgumentException()`会记录异常执行的位置和时间信息，但也可以接受一个自定义字符串，如果你想要更具体的话。
- en: '`ArgumentException` is a subclass of the `Exception` class and is accessed
    through the `System` class shown previously. C# comes with many built-in exception
    types, including subclasses for checking for null values, out or range collection
    values, and invalid operations. Exceptions are a prime example of using the right
    tool for the right job. Our example only needs the basic `ArgumentException`,
    but you can find the full descriptive list at [https://docs.microsoft.com/en-us/dotnet/api/system.exception#Standard](https://docs.microsoft.com/en-us/dotnet/api/system.exception#Standard).'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: '`ArgumentException`是`Exception`类的子类，并且可以通过之前显示的`System`类访问。C#提供了许多内置的异常类型，包括用于检查空值、出界或范围集合值以及无效操作的子类。异常是正确使用工具的绝佳例子。我们的例子只需要基本的`ArgumentException`，但你可以找到完整的描述性列表在[https://docs.microsoft.com/en-us/dotnet/api/system.exception#Standard](https://docs.microsoft.com/en-us/dotnet/api/system.exception#Standard)。'
- en: 'Let''s keep things simple on our first foray into exceptions and make sure
    that our level only restarts if we provide a positive scene index number:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们第一次尝试异常处理时，让我们保持简单，并确保只有当我们提供一个正的场景索引数字时，我们的级别才会重新启动：
- en: 'Open up `Utilities` and add the following code to the overloaded version of
    `RestartLevel(int)`:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Utilities`，并将以下代码添加到`RestartLevel(int)`的重载版本中：
- en: '[PRE35]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Change `RestartLevel()` in `GameBehavior` to take in a negative scene index
    and lose the game:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`GameBehavior`中的`RestartLevel()`修改为接受负的场景索引并输掉游戏：
- en: '[PRE36]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Let''s break down the code:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解一下代码：
- en: Declares an `if` statement to check that `sceneIndex` is not less than 0 or
    a negative number
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个`if`语句来检查`sceneIndex`是否不小于0或负数
- en: Throws an `ArgumentException` with a custom message if a negative scene index
    is passed in as an argument
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果传入的参数是负的场景索引，则抛出一个带有自定义信息的`ArgumentException`
- en: Calls `RestartLevel()` with a scene index of `-1`:![](img/B17573_13_10.png)
  id: totrans-214
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用场景索引`-1`调用`RestartLevel()`：![](img/B17573_13_10.png)
- en: 'Figure 13.11: Console output when an exception is thrown'
  id: totrans-215
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.11：抛出异常时的控制台输出
- en: When we lose the game now, `RestartLevel()` is called, but since we're using
    `-1` as the scene index argument, our exception is fired before any of the scene
    manager logic is executed. We don't have any other scenes configured in our game
    at the moment, but this defensive code acts as a safeguard and doesn't let us
    take an action that might crash the game (Unity doesn't support negative indexes
    when loading scenes).
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们输掉游戏时，会调用`RestartLevel()`，但由于我们使用`-1`作为场景索引参数，我们的异常在执行任何场景管理逻辑之前就被触发了。目前我们游戏中没有配置其他场景，但这段防御性代码充当了一个保护措施，防止我们执行可能导致游戏崩溃的操作（Unity不支持在加载场景时使用负索引）。
- en: Now that you've successfully thrown an error, you need to know how to handle
    the fallout from the error, which leads us to our next section and the `try-catch`
    statement.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经成功抛出了一个错误，你需要知道如何处理这个错误带来的后果，这引出了我们接下来的部分和`try-catch`语句。
- en: Using try-catch
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`try-catch`
- en: 'Now that we''ve thrown an error, it''s our job to safely handle the possible
    outcomes that calling `RestartLevel()` might have because at this point, this
    is not addressed properly. The way to do this is with a new kind of statement,
    called `try-catch`:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经抛出了一个错误，我们的任务是安全地处理调用`RestartLevel()`可能产生的可能结果，因为在这个点上，这还没有得到适当的处理。要做到这一点，我们需要使用一种新的语句，称为`try-catch`：
- en: '[PRE37]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: The `try-catch` statement is made up of consecutive code blocks that are executed
    on different conditions; it's like a specialized `if`/`else` statement. We call
    any methods that potentially throw exceptions in the `try` block—if no exceptions
    are thrown, the code keeps executing without interruption. If an exception is
    thrown, the code jumps to the `catch` statement that matches the thrown exception,
    just like `switch` statements do with their cases. `catch` statements need to
    define what exception they are accounting for and specify a local variable name
    that will represent it inside the `catch` block.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`try-catch`语句由连续的代码块组成，这些代码块在不同的条件下执行；它就像一个专门的`if`/`else`语句。我们在`try`块中调用可能抛出异常的方法——如果没有抛出异常，代码会继续执行而不会中断。如果抛出了异常，代码会跳转到匹配抛出异常的`catch`语句，就像`switch`语句与它们的case一样。`catch`语句需要定义它们所处理的异常，并指定一个在`catch`块内部代表它的局部变量名。'
- en: 'You can chain as many `catch` statements after the `try` block as you need
    to handle multiple exceptions thrown from a single method, provided they are catching
    different exceptions. For example:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在`try`块后面链式地添加任意多的`catch`语句，以处理单个方法抛出的多个异常，前提是它们捕获不同的异常。例如：
- en: '[PRE38]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'There''s also an optional `finally` block that can be declared after any `catch`
    statements that will execute at the very end of the `try-catch` statement, regardless
    of whether an exception was thrown:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个可选的`finally`块，可以在任何`catch`语句之后声明，它将在`try-catch`语句的末尾执行，无论是否抛出异常：
- en: '[PRE39]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'Your next task is to use a `try-catch` statement to handle any errors thrown
    from restarting the level unsuccessfully. Now that we have an exception that is
    thrown when we lose the game, let''s handle it safely. Update `GameBehavior` with
    the following code and lose the game again:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 你的下一个任务是使用`try-catch`语句来处理从重新启动关卡失败中抛出的任何错误。现在我们已经有一个在输掉游戏时抛出的异常，让我们安全地处理它。更新`GameBehavior`如下代码，并再次输掉游戏：
- en: '[PRE40]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: 'Let''s break down the code:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们分解代码：
- en: Declares the `try` block and moves the call to `RestartLevel()` inside with
    a `debug` command to print out if the restart is completed without any exceptions.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`try`块，并使用`debug`命令将`RestartLevel()`的调用移至其中，以打印出重启是否完成且没有任何异常。
- en: Declares the `catch` block and defines `System.ArgumentException` as the exception
    type it will handle and `exception` as the local variable name.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明`catch`块，并定义`System.ArgumentException`为它将处理的异常类型，并将`exception`作为局部变量名。
- en: 'Restarts the game at the default scene index if the exception is thrown:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果抛出异常，则在默认场景索引处重新启动游戏：
- en: Uses the `debug` delegate to print out a custom message, plus the exception
    information, which can be accessed from `exception` and converted into a string
    with the `ToString()` method
  id: totrans-232
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`debug`代理打印自定义消息，以及异常信息，这些信息可以通过`exception`访问，并使用`ToString()`方法转换为字符串。
- en: Since `exception` is of the `ArgumentException` type, there are several properties
    and methods associated with the `Exception` class that you can access. These are
    often useful when you need detailed information about a particular exception.
  id: totrans-233
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于`exception`是`ArgumentException`类型，与`Exception`类相关联的属性和方法有几个，你可以访问。这些在需要有关特定异常的详细信息时通常很有用。
- en: Adds a `finally` block with a debug message to signal the end of the exception-handling
    code:![](img/B17573_13_11.png)
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个带有调试信息的`finally`块，以表示异常处理代码的结束：![img/B17573_13_11.png](img/B17573_13_11.png)
- en: 'Figure 13.12: Console output of a complete try-catch statement'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 图13.12：完整的try-catch语句的控制台输出
- en: When `RestartLevel()` is called now, our `try` block safely allows it to execute,
    and if an error is thrown, it's caught inside the `catch` block. The `catch` block
    restarts the level at the default scene index and the code proceeds to the `finally`
    block, which simply logs a message for us.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 当现在调用`RestartLevel()`时，我们的`try`块安全地允许它执行，如果抛出错误，它将在`catch`块中被捕获。`catch`块在默认场景索引处重新启动关卡，然后代码继续到`finally`块，该块只是为我们记录一条消息。
- en: It's important to understand how to work with exceptions, but you shouldn't
    get into the habit of putting them everywhere in your code. This will lead to
    bloated classes and might affect the game's processing time. Instead, you want
    to use exceptions where they are most needed—invalidation or data processing,
    rather than game mechanics.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 理解如何处理异常很重要，但你不应养成在代码中到处放置异常的习惯。这会导致类膨胀，并可能影响游戏的处理时间。相反，你希望在使用它们最需要的地方使用异常——无效化或数据处理，而不是游戏机制。
- en: 'C# allows you the freedom to create your exception types to suit any specific
    needs your code might have, but that''s beyond the scope of this book. It''s just
    a good thing to remember for the future: [https://docs.microsoft.com/en-us/dotnet/standard/exceptions/how-to-create-user-defined-exceptions](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/how-to-create-user-defined-exceptions).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: C#允许你创建自己的异常类型以满足代码可能需要的任何特定需求，但这超出了本书的范围。记住这一点对将来是有好处的：[https://docs.microsoft.com/en-us/dotnet/standard/exceptions/how-to-create-user-defined-exceptions](https://docs.microsoft.com/en-us/dotnet/standard/exceptions/how-to-create-user-defined-exceptions)。
- en: Summary
  id: totrans-239
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: While this chapter brings us to the end of our practical adventure into C# and
    Unity 2020, I hope that your journey into game programming and software development
    has just begun. You've learned everything from creating variables, methods, and
    class objects to writing your game mechanics, enemy behavior, and more.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这一章将我们带入C#和Unity 2020的实践冒险之旅的终点，但我希望你的游戏编程和软件开发之旅才刚刚开始。你已经从创建变量、方法、类对象到编写游戏机制、敌人行为等一切知识。
- en: 'The topics we''ve covered in this chapter have been a level above what we dealt
    with for the majority of this book, and with good reason. You already know your
    programming brain is a muscle that you need to exercise before you can advance
    to the next plateau. That''s all generics, events, and design patterns are: just
    the next rung up the programming ladder.'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 本章所涉及的主题比本书大部分内容所涉及的内容要高一个层次，这是有充分理由的。你已经知道，你的编程大脑就像一块肌肉，在达到下一个平台之前，你需要先锻炼它。泛型、事件和设计模式就是这样：只是编程阶梯上的下一个台阶。
- en: In the next chapter, I will leave you with resources, further reading, and lots
    of other helpful (and, dare I say, cool) opportunities and information about the
    Unity community and the software development industry at large.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我将为你提供资源、进一步阅读以及大量关于 Unity 社区和整个软件开发行业的其他有用（甚至可以说酷）机会和信息。
- en: Happy coding!
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 开心编码！
- en: Pop quiz – intermediate C#
  id: totrans-244
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突击测验 - 中级 C#
- en: What is the difference between a generic and non-generic class?
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 泛型类和非泛型类之间的区别是什么？
- en: What needs to match when assigning a value to a delegate type?
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在将值赋给委托类型时，需要匹配什么？
- en: How would you unsubscribe from an event?
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会如何从事件中取消订阅？
- en: Which C# keyword would you use to send out an exception in your code?
  id: totrans-248
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你会使用哪个 C# 关键字在代码中抛出异常？
- en: JOIN us on Discord!
  id: totrans-249
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社群！
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他用户、Unity/C# 专家以及哈里森·费罗内一起阅读这本书。提问，为其他读者提供解决方案，通过“问我任何问题”的环节与作者聊天，以及更多。
- en: Join Now!
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 立即加入！
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
- en: '![](img/QR_Code_9781801813945.png)'
  id: totrans-253
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code_9781801813945.png)'
