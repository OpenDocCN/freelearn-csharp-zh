- en: Communication Protocols
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信协议
- en: We've spent the first two chapters of this book discussing what makes networks
    hard to program for open communication and device agnosticism. These aspects of
    networks demand standardization, and in this chapter, we'll examine how standards
    provide a common language that the network software can communicate through. First,
    we'll learn about the governing body that defines those standards. We'll learn
    a bit about who they are and what objectives they sought to achieve. Once we understand
    who defined the common architecture of networks, we'll take a deep dive into the
    way they've organized and categorized each tier of the hierarchy of network layers.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这本书的前两章中讨论了什么使得网络难以编程以实现开放通信和设备无关性。网络的这些方面需要标准化，在本章中，我们将探讨标准如何为网络软件提供一种共同的语言，通过网络软件进行通信。首先，我们将了解定义这些标准的监管机构。我们将简要了解他们是谁以及他们试图实现的目标。一旦我们了解了谁定义了网络的共同架构，我们将深入探讨他们是如何组织和分类网络层级的每一层的。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The origin of the current standard for network architecture and a brief history
    of it, as well as some background on the organization that is responsible for
    it.
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当前网络架构标准的起源及其简要历史，以及负责该标准的组织背景。
- en: How application code interacts with networked resources through the application
    layer and what communication standards are provided for that layer.
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用代码如何通过应用层与网络资源交互，以及为该层提供的通信标准。
- en: How data is communicated out to, or read from, the network on the transport
    layer of the network architecture standard.
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在网络架构标准中，数据如何在传输层上与网络进行通信或从网络中读取。
- en: Technical requirements
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'As with [Chapter 1](7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml), *Networks
    in a Nutshell,* this will be more of a conceptual examination of the standards
    defined for networks. There is no specific technology as such that is required
    for this book. We''ll be using the same technology for this chapter as we have
    in others: NET Core 2.1 SDK and either Visual Studio Code, or Visual Studio Community
    Edition to use as an IDE.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第一章](7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml)“网络概要”一样，这将是对于为网络定义的标准的一种概念性考察。本书不需要特定的技术。我们将使用与之前章节相同的技术：NET
    Core 2.1 SDK以及Visual Studio Code或Visual Studio Community Edition作为IDE。
- en: 'Check out the following video to see the code in action: [Placeholder link]'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际运行情况：[占位符链接]
- en: The Open Systems Interconnection network stack
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放系统互联（Open Systems Interconnection）网络栈
- en: There are several steps in the process of sending or receiving a resource from
    a remote source over a network, and each of those steps has been deeply considered
    by the network engineers tasked with executing them. In this section, we'll look
    at whothose network engineers were, and howthey defined a general pattern for
    implementing each step in that process. This section will be all about the OSI,
    and how that specification defines the network stack of a given network device.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在通过网络从远程源发送或接收资源的过程中，有几个步骤，每个步骤都由负责执行这些步骤的网络工程师进行了深入考虑。在本节中，我们将探讨这些网络工程师是谁，以及他们是如何定义实现该过程中每一步的一般模式的。本节将全部关于OSI，以及该规范如何定义特定网络设备的网络栈。
- en: What exactly is the Open Systems Interconnection?
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开放系统互联（Open Systems Interconnection）究竟是什么？
- en: In order to talk about communication protocols, we need to understand how each
    protocol fits into the larger picture of network connectivity, and to do that
    we need a common model for thinking about each step in the process. To that end,
    we have the OSI model for computer and telecommunication networks. This model
    seeks to organize the different steps of standardized communication to or from
    a given device into a tiered model of abstraction layers. Much like the logical
    topologies of a network, which we discussed in [Chapter 1](7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml), *Networks
    in a Nutshell, *the OSI model exists on a purely conceptual and abstract level.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 为了讨论通信协议，我们需要了解每个协议如何适应网络连接的更大图景，为此，我们需要一个共同模型来思考过程中的每一步。为此，我们有用于计算机和电信网络的OSI模型。该模型试图将标准化通信的不同步骤组织成一个抽象层级的分层模型。与我们在[第一章](7dd1ec0d-a43e-470e-ad8a-d86d69db2d9b.xhtml)“网络概要”中讨论的网络逻辑拓扑类似，OSI模型存在于纯粹的概念和抽象层面。
- en: As the name suggests, it was defined in such a way as to be useful as a referencewhile
    remaining entirely agnostic as to how any of the tiers defined in the model are
    ultimately implemented at the physical level. In fact, many implementations of
    communications protocols or standards do notcleanly map to the OSI network model.
    However, the model is broadly considered the gold standard, and has been since
    it was formalized in 1984\. So, let's take a look at how that came to be.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，它被定义为在保持对模型中定义的任何层级在物理层面上最终如何实现完全无知的条件下，作为一个参考是有用的。事实上，许多通信协议或标准的实现并没有干净地映射到
    OSI 网络模型上。然而，该模型被广泛认为是黄金标准，自从 1984 年正式化以来一直如此。因此，让我们看看它是如何成为这样的。
- en: The origins of the OSI
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OSI 的起源
- en: The need for a standardized model for network implementations became apparent
    almost as soon as networking became possible. To that end, back in the late 1970s,
    two different organizations for governing standardization in computing set out
    to define such a model. The first of these organizations was the **International
    Organization for Standardization** (**ISO**). The other organization that set
    out to solve the same problem, at roughly the same time, was the **International
    Telegraph and Telephone Consultative Committee** (**CCITT**, initialized from
    the French translation of the name).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于网络实现需要一个标准化模型的需求几乎在 networking 成为可能的同时就变得明显。为此，早在 1970 年代末，两个不同的组织开始着手定义这样一个模型，以实现这一目标。这些组织中的第一个是**国际标准化组织**（**ISO**）。另一个组织在几乎同一时间开始解决相同的问题，即**国际电报电话咨询委员会**（**CCITT**，该名称的法文翻译的首字母缩写）。
- en: Interestingly, the shortened name for the International Organization for Standardization,
    ISO, is notan initialism of the name of the organization. Instead, since the name
    of the organization would be initialized differently in each language that it
    is recognized, the members chose to shorten the name to ISO. This is in reference
    of the Greek isos, which means equal, and speaks to the goal of the organization
    to bring about equal understanding.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，国际标准化组织（ISO）的简称并不是该组织名称的缩写词。相反，由于该组织的名称在每种认可的语言中都会有所不同，成员们选择将名称缩短为 ISO。这是指希腊语的
    isos，意为相等，反映了该组织实现平等理解的宗旨。
- en: The fact that two organizations sought to define their own model at roughly
    the same time as one another isn't entirely surprising. The problem was faced
    by engineers across a wide array of disciplines, and the lack of standardization
    was quickly becoming a bottleneck to progress in those disciplines. What is surprising,
    however, is how similar the solutions were to one another. Like Leibniz and Newton
    independently inventing calculus, these organizations incidentally arrived at
    a common solution to their common problem. However, this happy coincidence helped
    to expedite the standardization process, since the similarity of their solutions
    served to validate both models as being highly likely to be correct.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 两个组织几乎在同一时间寻求定义自己的模型这一事实并不完全令人惊讶。这个问题被众多学科的工程师所面临，缺乏标准化很快成为这些学科进步的瓶颈。然而，令人惊讶的是，这些解决方案彼此之间是多么相似。就像莱布尼茨和牛顿独立发明微积分一样，这些组织意外地找到了一个共同的解决方案来解决他们共同的问题。然而，这个愉快的巧合有助于加快标准化过程，因为它们解决方案的相似性有助于验证这两个模型都极有可能正确。
- en: Given the success of both organization's efforts, it took only a handful of
    years before both models were merged into a single standard. Thus, in 1983, the Basic
    Reference Model for OSIwas born. Over time, the name has, of course, been shortened
    to the OSI model. By 1984, each organization had published this new shared model
    under their own official reference documents, canonizing the model, and its specific
    protocols, within the international community. So, let's take a look at what that
    model entails.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于两个组织的努力都取得了成功，因此仅用了几年时间，这两个模型就被合并为一个单一的标准。因此，在 1983 年，OSI 的基本参考模型诞生了。随着时间的推移，该名称当然被缩短为
    OSI 模型。到 1984 年，每个组织都在自己的官方参考文件中发布了这个新的共享模型，将模型及其特定的协议正式化，并在国际社会中确立。因此，让我们看看这个模型包含哪些内容。
- en: The Basic Reference Model
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基本参考模型
- en: The Basic Reference Model was formalized by ISO as standard ISO-7498 (and as
    standard X.200 by the ITU, the successor to the CCITT). The model could be cleanly
    broken into two parts. The first part is the abstract Basic Reference Model for
    networking. The second is the list of protocols the organizations saw fit to standardize
    for use by systems that implement the reference model.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 基本参考模型由ISO正式化为标准ISO-7498（以及由ITU正式化为标准X.200，CCITT的继任者）。该模型可以被干净地分为两部分。第一部分是网络的基本抽象参考模型。第二部分是组织认为适合标准化并用于实现参考模型的协议列表。
- en: The reference model defines network communication streams, as implemented by
    a compliant device on a network, in a hierarchy of seven distinct conceptual tiers,
    or layers, organized in a stack. This stack is defined as far down as the transmission
    of raw bits over physical media, and all the way up to the high-level application
    software that might use any resource distributed over a network.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: '参考模型定义了网络通信流，这是由网络上的合规设备实现的，以七个不同的概念层级或层的形式组织在堆栈中。这个堆栈被定义为从物理媒体上原始比特的传输开始，一直到可能使用网络上任何资源的低级应用软件。 '
- en: For our purposes, as we describe these layers, when we say a layer is higherin
    the stack, we mean farther away from the hardware-level transmission of bits across
    a physical medium.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的目的而言，当我们描述这些层级时，当我们说一个层在堆栈中更高时，我们指的是离物理介质上位传输的硬件层级更远。
- en: 'The model defines a strict mechanism of unidirectional interaction between
    layers. According to this communication standard, a given layer can only ever
    communicate with the layer directly beneath it through an abstract interface exposed
    by that lower layer. This interface is known as the **service definition **of
    a layer, and it defines the valid operations by which a higher layer can interact
    with any lower layers. The interaction model between layers of the OSI network
    stack shows the same:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 该模型定义了层之间单向交互的严格机制。根据这个通信标准，一个给定的层只能通过由该下层暴露的抽象接口与直接下方的层进行通信。这个接口被称为层的**服务定义**，它定义了高层可以通过哪些有效操作与任何低层进行交互。OSI网络堆栈层之间的交互模型显示了相同的情况：
- en: '![](img/7612d6ab-b762-4d3b-8ac6-e5b1fba0a536.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7612d6ab-b762-4d3b-8ac6-e5b1fba0a536.png)'
- en: As data moves through the layers of the stack, each lower layer wraps the packet
    in its own series of headers and footers to be parsed by the recipient device.
    This contains information about what layer in the stack the data originated from,
    as well as how to parse it. The data packet that gets passed down, layer-to-layer,
    through the network stack, is known as a **Protocol Data Unit** (**PDU**).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据通过堆栈的层级移动时，每一层都会用自己的一系列头部和尾部包装数据包，以便由接收设备解析。这包含了关于数据包起源于堆栈中哪一层的详细信息，以及如何解析它。在网络堆栈中，层与层之间传递的数据包被称为**协议数据单元**（**PDU**）。
- en: While service definitions provide an interface for interaction from one layer
    to the layer beneath it, **protocols **provide standardized interaction for an
    entity at a given level in the network stack to interact directly with a corresponding
    component at the samelevel on a remote host. These protocols assume smooth interaction
    down the stack of the originating host, and then back up the stack on the remote
    host. Once it has bubbled up the stack to the target layer of the remote host,
    the protocol determines how the receiving entity should process the data.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务定义提供从一层到其下一层交互的接口时，**协议**则为网络堆栈中给定层级的实体提供标准化的交互，以便直接与远程主机上同一层级的相应组件进行交互。这些协议假设原始主机堆栈中的交互顺畅，然后在远程主机上反向堆栈。一旦它冒泡到远程主机的目标层，协议就确定接收实体应该如何处理数据。
- en: 'So, we can describe the entire process of data transmission through the OSI
    stack, as follows:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以如下描述通过OSI堆栈的数据传输整个过程：
- en: An entity on the originating host creates a data packet, known as a PDU, at
    a given layer in the network stack, **N**.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始主机上的实体在网络的N层创建一个数据包，称为PDU。
- en: The originating layer passes it down the stack by leveraging the service definitionof
    the layer immediately beneath it.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 原始层通过利用其下一层的服务定义将其传递到堆栈中。
- en: Lower layers receive the PDU, each wrapping it in a set of headers and footers,
    to be parsed by the corresponding layer on the remote host.
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 低层接收PDU，每一层都会用一组头部和尾部包装它，以便由远程主机上的相应层解析。
- en: Once the PDU has been wrapped in headers and footers by the bottom most layer
    of the stack, it is transmitted to the remote host.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦 PDU 被堆栈最底层的层封装了头部和尾部，它就被传输到远程主机。
- en: Each layer of the stack on the remote host removes the headers and footers applied
    by the corresponding layer of the originating host, bubbling the PDU up through
    the stack.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 远程主机上的堆栈每一层都移除了由源主机相应层应用的头部和尾部，将 PDU 通过堆栈向上传递。
- en: The PDU is received by layer **N**on the remote host. The receiving layer then
    parses the data of the PDU according to the specifications of a protocolfor layer **N***, *as
    specified by the originating host.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: PDU 由远程主机上的第 **N** 层接收。接收层随后根据第 **N** 层协议的规范解析 PDU 的数据，*如源主机所指定。
- en: And just like that, our data is transmitted, reliably, over the network. That
    is the complete, if abstract, process of using protocols to transmit data units
    through the service definitions of each layer in the network stack. I know, it's
    a lot to take in at once, but it will become slightly more clear as we build up
    the picture more completely. So, with that, let's look at what the individual
    layers of the stack are, why they're ordered the way they are, and what they're
    ultimately responsible for.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样，我们的数据可靠地通过网络传输。这是使用协议通过网络堆栈中每一层的定义来传输数据单元的完整、如果说是抽象的过程。我知道，一次性吸收这么多信息可能有些困难，但随着我们更完整地构建这幅图景，它将变得稍微清晰一些。因此，让我们看看堆栈的各个单独层是什么，为什么它们以这种方式排序，以及它们最终负责什么。
- en: The layers of the network stack
  id: totrans-35
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络堆栈的层
- en: As we examine each layer of the network stack and what it is ultimately responsible
    for, there are some key things to bear in mind. First, remember that the model
    is abstract at its core, and is only meant to serve as a reference. For this reason,
    there may be times where it's not obvious which layer a given responsibility or
    task belongs to. Second, bear in mind that as we discuss the responsibilities
    of each layer in the stack, we're speaking specifically about the responsibilities
    of that layer with respect to the successful transmission of data over the network*.*
    So, the responsibilities of the session layer in the context of the network stack
    are completely independent of, say, the management of a user session in the context
    of a web application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们检查网络堆栈的每一层及其最终负责的内容时，有一些关键事项需要记住。首先，记住这个模型在本质上是非常抽象的，并且仅作为参考。因此，有时可能不清楚某个责任或任务属于哪一层。其次，记住，当我们讨论堆栈中每一层的责任时，我们是在具体讨论该层在数据通过网络成功传输方面的责任。*因此，在网络堆栈的上下文中，会话层的责任与在
    Web 应用程序上下文中管理用户会话的责任完全独立。
- en: Finally, it's useful to remember that the farther downthe stack we go, the closer
    we get to the physical transmission of data over a physical medium*. *We'll be
    numbering the layers in our stack in descending order, from top to bottom, so
    that the smaller the number, the closer we are to the signals on the wire. This
    will be helpful when considering why one layer is lower than another, and how
    its responsibilities are distinct from those of the layer above it. With all of
    this in mind, let's dive in, top to bottom, through the OSI network stack.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，记住，随着我们向下移动到堆栈的更深处，我们离通过物理介质传输数据就越近。*我们将按从上到下的顺序编号我们的层，这样数字越小，我们就越接近线上的信号。这将在考虑为什么某一层比另一层低，以及其责任如何与上层责任不同时有所帮助。考虑到所有这些，让我们从头到尾深入探讨
    OSI 网络堆栈。
- en: The Host/Media distinction
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 主机/媒体的区别
- en: The first thing to understand about the network stack is that there are different
    levels of abstraction that you can view. The higher up, conceptually, that you
    look at network interactions, the fewer layers there are, and the easier it is
    to distinguish between the responsibilities of those layers. Meanwhile, when you
    build a model closer to its concrete implementation, you see the distinctions
    between more subtle roles and responsibilities of each entity in that model. We're
    going to be looking at the full, lower-level model provided by the OSI reference
    model, but I want to take a moment to consider the higher-level distinction between
    entities on a network, which breaks down into two fundamental layers.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 关于网络堆栈的第一件事要理解的是，你可以看到不同级别的抽象。从概念上讲，你观察网络交互的位置越高，层就越少，区分这些层的责任也就越容易。同时，当你构建一个更接近其具体实现的模型时，你会看到模型中每个实体更微妙的角色和责任之间的区别。我们将要查看OSI参考模型提供的完整、低级模型，但我想要花一点时间来考虑网络实体之间的高级区分，这可以分为两个基本层。
- en: The first of these layers is the Host layer. This encapsulates the four higher
    levels of the OSI stack and describes entities or responsibilities specific to
    a given host trying to communicate on a network. In the most basic context of
    two-way communication between two hosts on a network, each host is responsible
    entirely for its own implementation of the OSI layers that aggregate up under
    the Host layer (hence the name). Bundling application data, specifying encoding
    and reliability expectations, and the methods for sending out a PDU to a given
    target all fits, loosely, under the Host layer.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这些层中的第一层是主机层。它封装了OSI堆栈的四个更高层，并描述了特定主机在网络上尝试通信的实体或特定责任。在两个网络主机之间双向通信的最基本背景下，每个主机完全负责其自身在主机层下聚合的OSI层的实现（因此得名）。将应用数据打包、指定编码和可靠性期望以及向特定目标发送PDU的方法都大致属于主机层。
- en: The second layer in the higher-level view of networks is the Media layer. These
    layers describe the physical implementation of the network components betweentwo
    hosts. This provides the expected functionality specified or requested by entities
    in the Host layers. Entities of this layer are typically implemented either on
    the hardware level, or in a low-level systems language such as C or C++. For this
    reason, entities of this layer will generally fall outside the scope of this book.
    However, C# provides abstractions that encapsulate and represent the functionality
    of entities in this layer, so it's important to understand how the layers that
    fall under the Media layer actually work on a basic level.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络的高级视图中，第二层是媒体层。这些层描述了两个主机之间网络组件的物理实现。这提供了主机层实体所指定或请求的预期功能。这个层的实体通常在硬件级别或C或C++等低级系统语言中实现。因此，这个层的实体通常超出了本书的范围。然而，C#提供了封装和表示该层实体功能的抽象，因此了解媒体层下层的层如何在基本层面上实际工作是很重要的。
- en: With that high-level distinction made, let's take a look at the full OSI model
    for networks, starting from the top.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在做出这一高级区分之后，让我们来看看网络的完整OSI模型，从最顶层开始。
- en: The application layer
  id: totrans-43
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用层
- en: The top most layer of the network stack is also the layer that most developers
    will interact with over the course of their careers. The application layer provides
    the highest-level interface for interaction with network communication. This is
    the layer that business application software uses to interact with the rest of
    the stack. There are a number of protocols leveraged by entities on the application
    layer, and we'll discuss them later in this chapter. For now though, it's only
    important to remember that the application layer serves as the access point between
    actual end user applications and the OSI network stack.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 网络堆栈的最顶层也是开发者在其职业生涯中会与之互动最多的层。应用层为与网络通信的交互提供了最高级别的接口。这是业务应用软件用来与堆栈其他部分交互的层。应用层上的实体使用了多种协议，我们将在本章后面讨论它们。不过，现在重要的是要记住，应用层是实际终端用户应用与OSI网络堆栈之间的接入点。
- en: The presentation layer
  id: totrans-45
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 表示层
- en: While it may sound like a way of visuallyrepresenting the data, the presentation
    layer is actually a way of defining how the data is to be interpreted by any consumer
    that wants to look at it. This layer provides context for application-layer entities
    from different hosts to mutually interact with a PDU. Entities in the presentation
    layer are responsible for describing how data passed from the application layer
    should be interpreted on the other side of a given data transaction. It does the
    work of abstracting away the encoding or serialization of PDUs from the higher-level
    business logic of application layer entities.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然听起来像是一种视觉表示数据的方式，但表示层实际上是一种定义数据如何被任何想要查看它的消费者解释的方式。这一层为来自不同主机的应用层实体提供了相互交互PDU的上下文。表示层上的实体负责描述从应用层传递的数据在给定数据事务的另一侧应该如何被解释。它完成了将PDUs的编码或序列化从应用层实体的更高层业务逻辑中抽象出来的工作。
- en: The session layer
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 会话层
- en: Entities on the session layer are responsible for establishing, maintaining,
    resuming, and terminating an active communication session between two hosts on
    a network. The entities at work on this layer provide communication mechanisms
    such as full-duplex interactions, half-duplex interactions, and simplex interactions,
    as specified by the constraints of the protocol used.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 会话层上的实体负责在网络上两个主机之间建立、维护、恢复和终止一个活跃的通信会话。在这个层上工作的实体提供如全双工交互、半双工交互和单工交互等通信机制，这些机制由所使用的协议约束指定。
- en: Full-duplex, half-duplex, and simplex communication
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 全双工、半双工和单工通信
- en: When a session is established between two hosts, there are a handful of ways
    that communication can happen over that session. The two most common are the full
    and half-duplex implementations. These simply describe a communication session
    that both connected parties can communicate over.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 当两个主机之间建立会话时，有几种方式可以在该会话上进行通信。最常见的是全双工和半双工实现。这些只是简单地描述了一个连接的双方都可以进行通信的会话。
- en: In a full-duplex session, both parties can communicate with one another simultaneously.
    The typical example for this kind of communication is a telephone call. On a phone
    call, both parties can talk and hear the other talking at the same time. The extent
    that someone can listen to what is being said to them while also speaking allows
    for much more efficient data transfer, and can facilitate reliable communication
    systems.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在全双工会话中，双方可以同时相互通信。这种通信的典型例子是电话通话。在电话通话中，双方可以同时说话并听到对方在说话。一个人在说话的同时还能听到别人对他说的话，这允许更高效的数据传输，并可以促进可靠的通信系统。
- en: A half-duplex system is one where both parties cancommunicate over the session,
    but only one party can communicate at a given time. A common example of this is
    a two-way radio or walkie-talkie. On these systems, engaging the microphone of
    one radio will lock the channel and prevent the other radio from transmitting
    until the first microphone has disengaged. This can allow more reliable communication
    over a limited bandwidth, since there is less opportunity for signal interference.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 半双工系统是一种双方可以在会话中通信，但一次只有一个参与者可以通信的系统。这种系统的常见例子是对讲机或步话机。在这些系统中，激活一个无线电的麦克风会锁定频道，防止另一个无线电传输，直到第一个麦克风被断开。这可以在有限的带宽上提供更可靠的通信，因为信号干扰的机会更少。
- en: Finally, a simplex communication session is one where only a single party can
    actually transmit data. That is, there is a sender and a receiver. A common example
    of this is network television; there is a single broadcast source, with multiple
    receivers actually accepting the transmitted signal. This is uncommon in most
    modern communication networks, since the additional cost of implementing a duplex
    communication session is often trivially small in relation to a simplex connection.
    However, it should be noted that a duplex communication system is simply a system
    of two simplex connections with one connection going in each direction between
    the hosts.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，单工通信会话是指只有一个参与者实际上可以传输数据的情况。也就是说，有一个发送者和一个接收者。这种通信的常见例子是网络电视；有一个单一的广播源，有多个接收器实际接收传输的信号。在大多数现代通信网络中，这种情况并不常见，因为实现双工通信会话的额外成本通常与单工连接相比微不足道。然而，应该注意的是，双工通信系统只是一个由两个单工连接组成的系统，每个主机之间有一个连接方向。
- en: The transport layer
  id: totrans-54
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输层
- en: Entities in the transport layer use protocols specifically designed for interacting
    with other hosts and the network entities in between. It might seem redundant
    given our description of the presentation and session layer; however, there's
    an important role to be played here. The presentation layer is concerned with
    character encoding, or the mapping from platform-specific data representations
    to platform-agnostic descriptions of that representation. The transport layer,
    though, looks at the full block of encoded data that was passed down by the presentation
    layer, and determines how to break it apart. It's responsible for cutting the
    data into segments of otherwise useless streams of binary. And, importantly, it
    breaks those segments up in such a way that they can be reassembled on the other
    side of the connection. The transport layer is also responsible for error detection
    and recovery, with different protocols providing different levels of reliability.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 传输层中的实体使用专门为与其他主机以及中间网络实体交互而设计的协议。鉴于我们对表示层和会话层的描述，这似乎是多余的；然而，这里有一个重要的角色要扮演。表示层关注字符编码，即从平台特定的数据表示到平台无关的描述的映射。然而，传输层查看由表示层传递下来的完整编码数据块，并确定如何将其拆分。它负责将数据切割成其他情况下无用的二进制流段。并且，重要的是，它以这种方式拆分这些段，以便它们可以在连接的另一侧重新组装。传输层还负责错误检测和恢复，不同的协议提供不同级别的可靠性。
- en: This layer is the lowest layer in the Host layers umbrella previously described.
    Determining what transport mechanism can and will be supported by a host remains
    the responsibility of that host. However, it is the lowest boundary of a given
    host's responsibility in successfully implementing network interaction. Everything
    below this layer falls into the Media layer, and is the responsibility of the
    engineers who support the network that the host has been deployed on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这一层是之前描述的主机层伞形结构中的最低层。确定主机可以和将支持哪种传输机制是主机的责任。然而，这是给定主机在成功实现网络交互中的最低边界。此层以下的所有内容都落入媒体层，这是支持主机部署的网络工程师的责任。
- en: The network layer
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 网络层
- en: Entities on the network layer manage interactions over the network topology.
    They're responsible for address resolution and routing data to target hosts once
    an address has been resolved. They also handle message delivery based on constraints
    or the resource availability of the physical network. So, while the transport
    layer determines the interactions between host-level tiers of the network stack
    on either side of a connection, the network layer is responsible for applying
    the transport protocol across the chain of devices that form the route between
    two hosts. The distinction between adjacent layers can be subtle, and we'll discuss
    some of the responsibilities specific to the network layer later in this chapter.
    So, if the distinction between transport and network layers is unclear, trust
    that we'll (at least, attempt to) clarify that distinction later.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 网络层中的实体管理网络拓扑结构上的交互。它们负责地址解析，并在地址解析后将数据路由到目标主机。它们还根据物理网络的约束或资源可用性处理消息传递。因此，虽然传输层确定连接两端的网络堆栈主机层之间的交互，但网络层负责在形成两个主机之间路由的设备链上应用传输协议。相邻层之间的区别可能很微妙，我们将在本章后面讨论一些特定于网络层的责任。所以，如果传输层和网络层之间的区别不清楚，请相信我们（至少，尝试）会在后面澄清这一区别。
- en: The data-link layer
  id: totrans-59
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据链路层
- en: 'The data-link layer falls very clearly into the Media layer''s grouping, as
    entities in this layer provide the actual transfer of data between nodes in a
    network. It''s responsible for error detection from the physical layer, and controls
    the flow of bits over physical media between nodes. So, for example, in a half-duplex
    communication setup, an entity in the data-link layer is responsible for restricting
    the transfer of data in one direction while data is being transferred in the other
    direction. Entities in this layer almost serve as the traffic lights directing
    traffic over the roads of a node-to-node connection. The data-link layer is broken
    down even further into two sub-layers by the **Institution of Electrical and Electronics
    Engineers** (**IEEE**) standard 802\. These two sub-layers are as follows:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 数据链路层非常明显地属于媒体层分组，因为这个层中的实体负责在网络中的节点之间实际传输数据。它负责从物理层检测错误，并控制节点之间通过物理媒体传输比特流的流量。例如，在半双工通信设置中，数据链路层中的实体负责在另一方向数据传输时限制一个方向的数据传输。这个层中的实体几乎充当了在节点到节点连接的道路上指挥交通的红绿灯。根据电气和电子工程师协会（**IEEE**）的标准802，数据链路层被进一步细分为两个子层。这两个子层如下：
- en: 'The **Medium Access-Control** (**MAC**) layer: This sub-layer controls who
    can transmit data throughthe data-layer entity, and how that data can be transmitted.'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**介质访问控制**（**MAC**）子层：这个子层控制哪些实体可以通过数据链路层传输数据，以及数据如何传输。'
- en: 'The **Logical Link Control** (**LLC**) layer: This sub-layer encapsulates the
    logical protocols of network interaction. It is essentially the interface that
    provides the entities links as a set of abstract protocol operations.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**逻辑链路控制**（**LLC**）子层：这个子层封装了网络交互的逻辑协议。它本质上是一个接口，提供实体链接作为一系列抽象协议操作。'
- en: Driving home how narrowly specific the data-link layer is in terms of its responsibilities
    on a network, its most common protocol is the **Point-to-Point Protocol** (**PPP**).
    This just highlights that entities of the data-link layer really are only concerned
    with facilitating the connection between two points.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明数据链路层在网络责任方面的具体性，它最常用的协议是**点对点协议**（**PPP**）。这仅仅突出了数据链路层的实体实际上只关注促进两点之间的连接。
- en: The physical layer
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理层
- en: Finally, we've arrived at the bottom of the stack, with the simplest layer to
    understand. The physical layer encapsulates the entities that are responsible
    for transmitting raw, unstructured data from one node in the network to another.
    This is the layer responsible for sending electrical signals that correspond to
    the strings of bits in a data packet. It encapsulates the devices responsible
    for modulating voltage, timing signals, and timing the frequency of wireless transmitters
    and receivers. Entities on this layer are explicitly outside of the scope of this
    book, but are an interesting concern regardless.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们到达了堆栈的底部，这是最容易理解的层。物理层封装了负责将原始、无结构数据从网络中的一个节点传输到另一个节点的实体。这是负责发送与数据包中比特串相对应的电气信号的层。它封装了负责调制电压、定时信号以及无线发射机和接收机频率的设备。这个层中的实体明确地超出了本书的范围，但无论如何都是一个有趣的问题。
- en: Putting it all together
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将所有这些放在一起
- en: Now, we've seen how the OSI model organizes the responsibilities of transmitting
    data. Hopefully, by this point, it should be clear how each layer in the stack
    is intended to provide a reliable abstraction for the layer above it. However,
    the process of communicating with a remote host, in its entirety, may still seem
    a bit vague. So, let's consider a concrete example and address each of the concepts
    that we talked about as they arise through the process of data transmission.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经看到了OSI模型是如何组织数据传输责任的。希望到这一点，你应该已经清楚每一层在堆栈中的意图是为它上面的层提供一个可靠的抽象。然而，与远程主机进行通信的整体过程可能仍然显得有些模糊。所以，让我们考虑一个具体的例子，并在数据传输过程中，针对我们讨论的每个概念进行说明。
- en: First, let's assume that an entity on layer 5 of our host (the session layer)
    wants to establish a session with an entity on **Layer 5** in a remote host. I
    haven't said so explicitly until now, but we can always assume that an entity
    on a given layer on one host only ever communicates directly with a corresponding
    entity on the samelayer in the remote host. So, for our example, an entity in
    layer 5 will communicate with a remote entity that also resides in layer 5.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们假设我们的主机（会话层）的第5层上的一个实体想要与远程主机上的**第5层**上的一个实体建立会话。我之前没有明确说明，但我们总是可以假设一个主机上给定层上的实体只与远程主机上同一层的相应实体直接通信。因此，在我们的例子中，第5层的实体将与也位于第5层的远程实体通信。
- en: Communicating with remote entities will always happen through a protocol*. *Given
    this, the first responsibility of any entity seeking to communicate with a remote
    host is to wrap the transmitted data in the headers and footers appropriate for
    that protocol. For our entity in the session layer, let's assume they are hoping
    to establish a session using the **Session Control Protocol** (**SCP**). This
    means that our local entity will produce the data necessary to establish a session,
    then wrap that data in SCP headers and footers, creating a well-formed PDU (hopefully,
    this makes it clear why the name describes this package). This ensures that the
    recipient host will be able to unwrap the data based on the information stored
    in the headers and footers of our PDU.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 与远程实体通信总是通过**协议**进行的。鉴于这一点，任何寻求与远程主机通信的实体的首要责任是将传输数据包裹在适当的协议头部和尾部中。对于我们的会话层实体，假设他们希望通过**会话控制协议**（SCP）建立会话。这意味着我们的本地实体将生成建立会话所需的数据，然后将这些数据包裹在SCP头部和尾部中，创建一个格式良好的PDU（希望这清楚地说明了为什么这个名字描述了这个包）。这确保了接收主机将能够根据我们PDU头部和尾部中存储的信息解包数据。
- en: Since entities that reside on any layer abovethe physical layer cannot communicate directly
    with one another, we have to pass our PDU down the stack. In our example, we can
    reliably pass the PDU down to **Layer 4** by taking advantage of its service definition
    and trusting that the logical operations exposed through that definition are accurately
    implemented by all of the responsible entities below **Layer 5**. So, we don't
    need to know how **Layer 4** implements transport mechanisms. Instead, we simply askit
    to use the appropriate transport mechanism for this particular instance and trust
    that it will do so appropriately.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 由于位于物理层之上的任何层中的实体不能直接相互通信，我们必须将我们的PDU向下传递到堆栈。在我们的例子中，我们可以通过利用其服务定义并相信通过该定义公开的逻辑操作被所有位于**第5层**以下的负责实体准确实现，来可靠地将PDU向下传递到**第4层**。因此，我们不需要知道**第4层**如何实现传输机制。相反，我们只需要求它使用适用于此特定实例的适当传输机制，并相信它会适当地这样做。
- en: This pattern of trusting that lower layers in the stack will correctly implement
    the operations being requested by higher layers in the stack continues all the
    way through to **Layer 1**. Over the course of this process, each layer in the
    stack will wrap the PDU in its own headers and footers. These standardized chunks
    of data give each intermediary layer on the receiving host enough information
    to know to pass the PDU up its own stack. By continuously wrapping the data in
    well-formed, well-understood chunks of binary data, each layer on the remote host
    can trust that the inner segment of data that is passed up the stack is exactly
    what should move up.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种相信堆栈中较低层将正确实现堆栈中较高层请求的操作的模式一直延续到**第1层**。在这个过程中，堆栈中的每一层都会在其PDU上添加自己的头部和尾部。这些标准化的数据块为接收主机上的每个中间层提供了足够的信息，以便知道将PDU向上传递到自己的堆栈。通过持续地将数据包裹在格式良好、易于理解的二进制数据块中，远程主机上的每一层都可以信任向上传递的数据段正是应该向上移动的内容。
- en: This process of wrapping the PDU in deeper and deeper layers of metadata continues
    down the stack until we reach **Layer 1**. **Layer 1** holds the physical connection
    from our host to the remote host. Once we've reached this level, we can step across
    the expanse of the network and start looking at how our PDU moves back upthe network
    stack until it reaches our target entity on **Layer 5**. Entities on each layer
    of the remote host will diligently remove and read the headers and footers applied
    by the corresponding layer of the originating host. The information in those wrappers
    will indicate that the PDU is destined for a layer abovethe current layer, and
    so entities will simply strip their headers and bubble the rest of the data upthe
    network stack.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这个将PDU包裹在越来越深的元数据层的过程一直持续到我们达到**第1层**。**第1层**承载着我们的主机与远程主机之间的物理连接。一旦达到这个级别，我们就可以跨越网络的广阔空间，开始观察我们的PDU如何沿着网络栈向上移动，直到它到达目标实体的**第5层**。远程主机每一层的实体都将勤奋地移除并读取由原始主机相应层应用的头部和尾部。这些包装器中的信息将表明PDU是发往当前层之上的一个层。因此，实体将简单地移除它们的头部，并将剩余的数据向上推送到网络栈。
- en: Once the data has reached layer 5 on the remote host, an entity on that layer
    will read the headers and footers of the PDU that were applied on **Layer 5**
    of the originating host. This metadata will indicate that layer 5 is, in fact,
    the target layer for this particular PDU. The metadata will also indicate what protocolshould
    be used to parse the data passed to the remote host. Using this information, the
    recipient host will have enough data to properly read the data in the PDU, and
    construct its own response PDU.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当数据达到远程主机的第5层时，该层的一个实体将读取在原始主机的**第5层**上应用的PDU头部和尾部。这些元数据将表明第5层实际上是这个特定PDU的目标层。元数据还将指示应该使用什么**协议**来解析传递给远程主机的数据。使用这些信息，接收主机将有足够的数据正确读取PDU中的数据，并构建它自己的响应PDU。
- en: 'Once that response is received by the originating host, a session will be established,
    and be open for use by any entities above the session layer in the originating
    or remote host. This whole process is captured in the following diagram of the
    full life cycle of data transmission through the OSI stack:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦原始主机收到响应，就会建立一个会话，并可供原始主机或远程主机会话层之上的任何实体使用。整个过程在以下OSI栈数据传输全生命周期的图中得到体现：
- en: '![](img/0b4db4a2-00f7-451e-bdc4-58d7b8966e8e.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0b4db4a2-00f7-451e-bdc4-58d7b8966e8e.png)'
- en: With this diagram in mind, is easy to see how the standardization provided by
    the OSI model makes it easier for engineers to program software for networks.
    The clean separation of concerns and the explicit pattern for passing data through
    the stack allows for well-formed contracts, against which all interested parties
    can design and develop. Engineers programming entities on the application layer
    can ignore the details of transporting data. They simply pass down a well-formed
    PDU through the stack.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑到这个图，很容易看出OSI模型提供的标准化如何使工程师更容易为网络编写软件。关注点的清晰分离和通过栈传递数据的明确模式允许形成良好的契约，所有相关方都可以据此设计和开发。在应用层编程实体的工程师可以忽略数据传输的细节。他们只需通过栈向下传递一个格式良好的PDU。
- en: Hopefully, this description clarifies how entities on specific layers expose
    their abstractions through a service definition, and how entities operating on
    the same layer of the network stack on different hosts reliably communicate through
    protocols. With this perspective in mind, let's take a closer look at the layers
    of this stack that we'll be programming for most frequently, as well as looking
    at some of the classes that C# provides to represent the entities of these layers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这个描述能够阐明特定层上的实体如何通过服务定义来暴露它们的抽象，以及处于不同主机上同一网络栈层的实体如何通过协议可靠地通信。带着这个观点，让我们更深入地看看我们将要频繁编程的这些栈层，以及C#提供的用于表示这些层实体的类。
- en: The application layer
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 应用层
- en: I mentioned it before, but it bears repeating,  application layer is where the vastmajority
    of day-to-day network programming will take place. This is especially true within
    the .NET Core framework, since the libraries provided by that framework deliver
    a wide array of clean, easy-to-use abstractions for entities or responsibilities
    that must be programmed lower in the stack. So, first, let's see why we should
    be so concerned with the responsibilities of the application layer. We'll look
    at the kinds of responsibilities that are typically delegated to entities in the
    layer, and see how frequently those responsibilities overlap with the requirements
    faced by everyday .NET Core developers. Then, given the extensive range of use
    cases for entities in the application layer, we'll take a look at some of the
    common protocols used by entities at that tier of the stack. We'll seek to understand
    them on a fundamental level. We'll look at what classes and libraries we have
    available to us for each of those layers; however, after this chapter, my hope
    is that you'll have a deep enough understanding to be able to reconstruct those
    classes yourself.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我之前提到过，但值得再次强调，应用层是日常网络编程的大部分工作将发生的地方。这在.NET Core框架中尤其如此，因为该框架提供的库为必须在栈的较低层编程的实体或责任提供了广泛清洁、易于使用的抽象。因此，首先，让我们看看为什么我们应该如此关注应用层的责任。我们将查看通常委托给该层实体的责任类型，并看看这些责任与日常.NET
    Core开发者面临的要求重叠的频率。然后，鉴于应用层实体的广泛用例，我们将查看该层实体使用的某些常见协议。我们将从基本层面理解它们。我们将查看我们为每一层可用的类和库；然而，在本书的这一章之后，我希望你将拥有足够的理解，能够自己重构这些类。
- en: The most common layer in the stack
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 栈中最常见的层
- en: This might feel redundant at this point, but it really is worth driving home
    that the application layer is where the vast majority of .NET developers are going
    to be doing their network programming. Since that accounts for most of you, we're
    going to keep talking about it. But *why *is the application layer so important?
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上可能感觉有些重复，但确实值得强调的是，应用层是绝大多数.NET开发者将要进行网络编程的地方。既然这占了你们中的大多数，我们将继续讨论它。但*为什么*应用层如此重要？
- en: The crux of it is that the application layer serves as the gateway to network
    activities for your business logic. This becomes very apparent as you explore
    how thoroughly .NET has hidden the implementation details of any of the responsibilities
    of lower levels of the network stack. Essentially, if there is something that
    you need to specify about how your application should behave anywhere below the
    stack, you'll be doing so througha .NET library class.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 其核心在于应用层充当了业务逻辑对网络活动的大门。当你深入探索.NET如何彻底隐藏了网络栈低层任何责任实现的细节时，这一点变得非常明显。本质上，如果你需要在栈的任何位置指定关于你的应用程序应该如何行为的内容，你将通过一个.NET库类来完成。
- en: I really can't stress enough how important it is to understand how the protocols
    behave under the hood. Knowing how the libraries are implemented will leave you
    better equipped to actually use them in the future. It's like learning to drive
    a stick shift. If you only ever learn the steps you have to perform to change
    gears, you'll likely get rusty without consistent practice. Over time, you'll
    have forgotten enough to not be able to drive a manual transmission anymore. However,
    if you learn *how *the steps you take serve to allow your car to drive, you'll
    never forget the steps themselves. Even if it's been years since you last drove
    a stick shift, you'll be able to reconstruct the steps you need to execute based
    on your understanding of what those steps actually accomplish. By this same measure,
    understanding exactly whatthe .NET core libraries are doing for you will enable
    you to use them more efficiently and correctly. You'll find yourself looking up
    the documentation less frequently and be better able to find the methods or properties
    you need through IntelliSense. That said, let's look closely at some of the most
    common protocols in the most common network layer.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 我真的无法强调理解协议底层行为的重要性。了解库是如何实现的将使你在未来使用它们时更加得心应手。这就像学习手动换挡一样。如果你只学会了换挡所需的步骤，没有持续的练习，你可能会变得生疏。随着时间的推移，你可能会忘记足够多的东西，以至于无法再驾驶手动变速器。然而，如果你学会了这些步骤是如何让你的汽车行驶的，你将永远不会忘记这些步骤本身。即使你已经很多年没有开过手动变速器，你也能根据对这些步骤实际完成的事情的理解来重建所需的步骤。按照同样的标准，理解.NET核心库为你做了什么将使你能够更高效、更正确地使用它们。你会发现你不需要经常查阅文档，并且能够通过IntelliSense更好地找到你需要的函数或属性。话虽如此，让我们仔细看看最常见的网络层协议中的一些最常见协议。
- en: HTTP – application to application communication
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP – 应用程序到应用程序的通信
- en: Welcome to the bread and butter of almost every .NET Core developer working
    today. HTTP is by far the most common and useful protocol for applications to
    interact over networks currently in use today. Why is that? Because HTTP is the
    protocol that almost every single web page on the internet is served up on by
    remote hosts, and requested by local clients. That alone is reason enough to call
    it the most common protocol in use. If you want more evidence, though, consider
    that most native mobile applications that serve up web-hosted data request this
    data from APIs that are exposed via HTTP. It almost feels ridiculous to have to
    make a case for the importance of understanding HTTP, since I'm certain there
    won't be a single person reading this book who *doesn't *have at least some experience
    with, or understanding of, HTTP.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到几乎所有当前正在工作的.NET Core开发者的基本功。HTTP是目前应用最普遍且最有用的网络交互协议。为什么这么说呢？因为HTTP是互联网上几乎每个网页都是由远程主机提供并由本地客户端请求的协议。仅此一点就足以称其为使用最普遍的协议。如果你还需要更多证据，那么考虑一下，大多数提供托管在Web上的数据的原生移动应用程序都是从通过HTTP公开的API请求这些数据的。几乎感觉没有必要为理解HTTP的重要性进行辩护，因为我确信阅读这本书的每个人至少都有一些与HTTP相关的经验或理解。
- en: So, why bother covering it so thoroughly if most of my readers are assumed to
    have some basic understanding of it? The answer to that is twofold. First, it's
    because it is so common as a communication protocol! HTTP is so prevalent that
    it would be criminally negligent not to give it due consideration in a book purporting
    to teach network programming fundamentals. And the second reason is because, at
    least in my own personal experience, most developers, and even engineers who work
    with it daily, only have a passing or surface-level understanding of what the
    specification provides. My hope is that by the end of this book, anyone who has
    read it, cover to cover, can and will go forth and program software that leverages
    every aspect of their target networks confidently and competently. It wouldn't
    be possible to do that without a deep, thorough understanding of what HTTP is,
    why it was defined, and how it is used by thousands of applications every second
    of every day. With that in mind, let's take a look at the protocol.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，为什么还要如此彻底地介绍它，如果大多数读者都被假设对它有一些基本了解呢？答案有两个方面。首先，这是因为它作为一种通信协议是多么普遍！HTTP如此普遍，如果不给予它应有的考虑，那就犯了刑事上的疏忽。第二个原因是，至少在我个人的经验中，大多数开发人员，甚至是每天与之打交道的工程师，对规范提供的了解只是肤浅的或表面的。我的希望是，到这本书的结尾，任何从头到尾读过这本书的人都能自信和熟练地编写利用目标网络每个方面的软件。没有对HTTP是什么、为什么被定义以及每天每秒都有数千个应用程序如何使用它的深入、全面的理解，这是不可能做到的。考虑到这一点，让我们来看看这个协议。
- en: What is HTTP?
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 什么是HTTP？
- en: As almost every reader of this book is likely to be shouting at its pages already,
    let's go on to HTTP**.** As should already be obvious, HTTP is a protocol implemented
    and leveraged by software that lives in the application layer of the OSI network
    stack. It's the primary mechanism of communication for applications exposed through
    the internet, and is designed for the transfer ofhypermediaover a network. Hypermedia
    typically refers to hypertext documentsthat contain multimedia information, as
    well as hyperlinksthat can be used to navigate to and load additional resources
    from other remote hosts.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎每一位这本书的读者可能都已经对着页面大喊，让我们继续到HTTP**。**正如已经显而易见的那样，HTTP是在OSI网络堆栈的应用层中实现并由软件利用的协议。它是通过互联网暴露的应用程序的主要通信机制，旨在在网络中传输超媒体。超媒体通常指的是包含多媒体信息的超文本文档，以及可以用来导航到并从其他远程主机加载额外资源的超链接。
- en: The transfercomponent of HTTP is, fundamentally, a request/response protocol
    that assumes a client-server relationship between hosts in an active HTTP session.
    To understand how this is done, let's start with the notion of a client-server
    relationship.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP的传输组件本质上是一种请求/响应协议，它假设在活跃的HTTP会话中，主机之间存在着客户端-服务器的关系。为了理解这是如何实现的，让我们从客户端-服务器关系的概念开始。
- en: The client - server model in HTTP
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP中的客户端-服务器模型
- en: Throughout this chapter, we've been referring to communication over a network
    as simply happening between originating and target hosts, as if the two were functionally
    identical, depending on which was sending a packet. In the client-server model,
    however, the two hosts actually perform distinct and specific duties, and so they
    are not conceptually interchangeable. A cliententity is one who requests, and
    is granted, use of the services or resources provided (or served) by the serverentity.
    Servers do not make active requests of clients, except when necessary to complete
    a service request already made by the client (for example, requesting additional
    login information from the client, when the client has initiated the transaction
    by requesting protected data). Likewise, clients are not expected to serve any
    specific resources to the server, except the information necessary for the server
    to sufficiently process and respond to a request.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们一直将网络上的通信简单地描述为发生在源主机和目标主机之间，好像这两个主机在功能上是相同的，这取决于哪个在发送数据包。然而，在客户端-服务器模型中，这两个主机实际上执行着不同的特定任务，因此它们在概念上不可互换。客户端实体是请求并得到使用由服务器实体（或称为服务端）提供的（或称为服务的）服务或资源的实体。服务器不会主动向客户端发出请求，除非这是完成客户端已经提出的某个服务请求所必需的（例如，当客户端通过请求受保护的数据来启动事务时，从客户端请求额外的登录信息）。同样，客户端也不需要向服务器提供任何特定的资源，除非这些信息对于服务器足够处理并响应请求是必要的。
- en: Today, it's not uncommon for two applications to use HTTP to interact with one
    another in such a way that, depending on the interaction, either application could
    be considered the client or the server. For example, a desktop finance application
    might be responsible for storing local user data, while also using a remote API
    to access live data feeds about current interest rates on different kinds of loans.
    Now suppose the authors of that desktop application want to periodically access
    information about users of their software. In the case of a user logging onto
    their application to look up market rates for mortgages, the desktop application
    will request information from the remote API; so the desktop application is the
    client, while the API is the server. However, when the remote software decides
    to query instances of its desktop application for user data, the roles are reversed.
    The remote software will request the data from known hosts of the desktop application;
    the remote software is the client, requesting information from computers running
    the desktop applications, which are the servers in this scenario.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，两个应用程序使用HTTP相互交互并不罕见，在这种情况下，根据交互方式，任一应用程序都可以被认为是客户端或服务器。例如，一个桌面财务应用程序可能负责存储本地用户数据，同时使用远程API来访问关于不同类型贷款的当前利率的实时数据流。现在假设该桌面应用程序的作者想要定期访问有关其软件用户的信息。在用户登录其应用程序以查找抵押贷款市场利率的情况下，桌面应用程序将从远程API请求信息；因此，桌面应用程序是客户端，而API是服务器。然而，当远程软件决定查询其桌面应用程序的实例以获取用户数据时，角色会颠倒。远程软件将从桌面应用程序的已知主机请求数据；在这种情况下，远程软件是客户端，从运行桌面应用程序的计算机请求信息，这些计算机是服务器。
- en: Alternatively, an application or host might be the clientof one remote host,
    while simultaneously operating as the serverfor a different remote host. Consider
    the case of an API that responds to requests by aggregating information from a
    number of other APIs. In the act of servicing requests by their downstream consumers,
    the application in question is very obviously a server. However, when the application
    requests information from other APIs upstream, it is acting as the client.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，一个应用程序或主机可能是一个远程主机的客户端，同时作为另一个远程主机的服务器运行。考虑这样一个API的例子，它通过聚合来自多个其他API的信息来响应请求。在为下游消费者提供服务请求的过程中，相关应用程序显然是一个服务器。然而，当应用程序从其他API上游请求信息时，它扮演的是客户端的角色。
- en: I bring these examples up to highlight the fact that the client-server relationship
    is mostly conceptual. The assignment of client or server roles to a given host
    is specific to a given interaction context. If that context changes, so too might
    the conceptual role of the hosts involved. It's important that we avoid confusion
    by only referring to clients and servers within the context of a specific interaction.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 我提出这些例子是为了强调客户端-服务器关系主要是概念性的。将客户端或服务器角色分配给特定主机是特定于特定交互上下文的。如果该上下文发生变化，那么涉及的宿主的观念角色也可能发生变化。我们只在与特定交互上下文相关的范围内提及客户端和服务器，以避免混淆是很重要的。
- en: Request/response
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求/响应
- en: In describing the nature of the client-server relationship, we've also touched
    on the nature of the HTTP request/response protocol. This protocol, as a way of
    serving up information, is fairly intuitive to understand. When a client makes
    a request of a server (the request part of request/response), the server, assuming
    it meets the specifications of the protocol, is expected to respond with meaningful
    information about the success or failure of that request, as well as by providing
    the specific data initially requested.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述客户端-服务器关系时，我们也触及了HTTP请求/响应协议的本质。作为提供信息的一种方式，该协议相当直观易懂。当客户端向服务器发出请求（请求/响应中的请求部分）时，如果服务器符合协议规范，它应预期以有意义的信息响应该请求的成功或失败，并提供最初请求的具体数据。
- en: Sometimes, the complete process of requesting information and receiving a meaningful
    response requires several intermediary round-trips between the client and server
    to establish initial connections, determine the ability of the server to service
    the request, and then submit the information necessary to initiate the request.
    This entire process, however, will be considered a single request/response session
    from the perspective of application-layer software. This leads us nicely onto
    the subject of just how those sessions are initially established in the first
    place.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，请求信息和接收有意义响应的完整过程需要客户端和服务器之间进行几次中间往返，以建立初始连接，确定服务器处理请求的能力，然后提交启动请求所需的信息。然而，从应用层软件的角度来看，整个过程将被视为一个单独的请求/响应会话。这很自然地引出了我们最初是如何建立这些会话的问题。
- en: HTTP sessions
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP会话
- en: So far, we've talked about the back and forth of the request/response communication
    patterns of HTTP, but we've neglected the context that allows that chatter to
    happen so seamlessly. This fluid interaction is facilitated by an underlying session
    established prior to satisfying the first request made by a client. Historically,
    this session has been provided by a **Transmission Control Protocol** (**TCP**)
    connection established against a specific port on the host server. This port can
    be specified in the URI when designating your target host, but typically will
    use default ports for HTTP, such as `80`, `8080`, or `443` (for HTTPS, which we'll
    cover later in this book). Once the connection is established, round trips of
    HTTP communication can proceed freely until the session is terminated.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了HTTP请求/响应通信模式的来回过程，但我们忽略了允许这种交流如此无缝发生的环境。这种流畅的交互是由客户端发出的第一个请求之前建立的底层会话所促进的。历史上，这种会话是由针对主机服务器上特定端口的**传输控制协议**（**TCP**）连接提供的。当指定目标主机时，可以在URI中指定此端口，但通常将使用HTTP的默认端口，例如`80`、`8080`或`443`（用于稍后本书中将要介绍的HTTPS）。一旦建立连接，HTTP通信的往返就可以自由进行，直到会话终止。
- en: You might have noticed that I specifically said that TCP is historicallyused
    for HTTP. This is because, for each of the current versions of HTTP (1.0, 1.1,
    and now HTTP/2), TCP has been the standard transport layer protocol supporting
    it. However, in the current proposed specification for HTTP/3, the protocol is
    being modified to take advantage of alternative transport protocols, including
    the **User Datagram Protocol** (**UDP**), or Google's experimental **Quick UDP
    Internet Connections** (**QUIC**) protocol. While there are trade-offs associated
    with these alternate transport protocols, the underlying sessions they provide
    are the same from our point of view. Each of these protocols serve to establish
    a connection with a listening host and facilitate the transmission of request
    and response messages. Next, let's take a look at some of the operations a client
    might request of a server, and how those operations are specified through the
    HTTP standard by way of request verbs.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，我特别提到TCP在历史上被用于HTTP。这是因为，对于HTTP的当前所有版本（1.0、1.1以及现在的HTTP/2），TCP一直是支持它的标准传输层协议。然而，在当前提出的HTTP/3规范中，该协议正在被修改以利用替代传输协议，包括**用户数据报协议**（**UDP**），或者谷歌的实验性**快速UDP互联网连接**（**QUIC**）协议。虽然这些替代传输协议有一些权衡，但它们提供的底层会话对我们来说是一样的。每种协议都旨在与监听主机建立连接，并促进请求和响应消息的传输。接下来，让我们看看客户端可能请求服务器执行的一些操作，以及这些操作是如何通过HTTP标准中的请求动词来指定的。
- en: Request methods
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求方法
- en: 'When a client wants to make a request of a server, it must specify the method
    by which the server will be expected to respond to the given request. These method
    specifications are typically called **HTTP verbs**, since most of them describe
    an actionto be taken by the server when processing a request sent by the client.
    The standard methods are as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 当客户端想要向服务器发送请求时，它必须指定服务器将如何响应该请求的方法。这些方法规范通常被称为**HTTP动词**，因为它们大多数描述了服务器在处理客户端发送的请求时将采取的动作。标准方法如下：
- en: '**OPTIONS**: This returns the list of other HTTP methods supported by the server
    at the given URL.'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**OPTIONS**：此操作返回服务器在给定URL上支持的其他HTTP方法列表。'
- en: '**TRACE**: This is a utility method that will simply echo the original request
    as received by the server. It is useful for identifying any modifications made
    to the request by entities on the network while the request is in transit.'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**TRACE**: 这是一个实用方法，它将简单地回显服务器接收到的原始请求。这对于识别在请求传输过程中网络实体对请求所做的任何修改非常有用。'
- en: '**CONNECT**: CONNECT requests establish a transparent TCP/IP tunnel between
    the originating host and the remote host.'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CONNECT**: CONNECT请求在源主机和远程主机之间建立一个透明的TCP/IP隧道。'
- en: '**GET**: This retrieves a copy of the resource specified by the URL to which
    the HTTP request was sent. By convention, GET requests will only ever retrieve
    the resource, with no side-effects on the state of the resources on the server
    (however, these conventions can be broken by poor programming practices, as we''ll
    see later in the book).'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GET**: 此操作检索由HTTP请求发送的URL指定的资源的副本。按照惯例，GET请求将仅检索资源，而不会对服务器上资源的状态产生任何副作用（然而，这些惯例可能会被书中稍后提到的糟糕的编程实践所破坏）。'
- en: '**HEAD**: This method requests the same response as a GET request to a given
    URL, but without the body of the response. What is returned is only the response
    headers.'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**HEAD**: 此方法请求与对给定URL的GET请求相同的响应，但不需要响应体。返回的内容只有响应头。'
- en: '**POST**: The POST method transmits data in the body of the request, and requests
    that the server store the content of the request body as a new resource hosted
    by the server.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**POST**: POST方法在请求体中传输数据，并请求服务器将请求体的内容作为由服务器托管的新资源存储。'
- en: '**PUT**: The PUT method is similar to the POST method in that the client is
    requesting that the server store the content of the request body. However, in
    the case of a PUT operation, if there is already content at the requested URL,
    this content is then modified and updated with the contents of the request body.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PUT**: PUT方法与POST方法类似，客户端请求服务器存储请求体的内容。然而，在PUT操作的情况下，如果请求URL上已经存在内容，则该内容将使用请求体的内容进行修改和更新。'
- en: '**PATCH**: The PATCH method will perform partialupdates of the resource at
    the requested URL, modifying it with the contents of the request body. A PATCH
    request will typically fail if there is no resource already on the server to be
    patched.'
  id: totrans-110
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**PATCH**: PATCH方法将对请求URL的资源执行部分更新，使用请求体的内容对其进行修改。如果没有在服务器上找到要修补的资源，则典型情况下PATCH请求将失败。'
- en: '**DELETE**: The DELETE method will permanently delete the resource at the specified
    URL.'
  id: totrans-111
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**DELETE**: DELETE方法将永久删除指定URL的资源。'
- en: A server will not respond to a request method invoked against a given location
    unless the server has been configured to do so. This is because some of the methods
    defined by the HTTP standard can permanently impact the state of resources on
    that server, and so should only be invoked and processed when it is safe to irrevocably
    update that state. There are, however, a number of methods designated as safe,
    by convention. This simply means that they can be processed by a server without
    having any side-effects on the state of the resources on that server. HEAD, GET,
    OPTIONS, and TRACE are all conventionally designated as safe.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 服务器不会对针对给定位置的请求方法做出响应，除非服务器已被配置为这样做。这是因为HTTP标准定义的一些方法可能会永久影响该服务器上资源的状态，因此只有在安全地不可撤销地更新该状态时才应调用和处理。然而，按照惯例，有许多方法被指定为安全的。这仅仅意味着它们可以被服务器处理，而不会对该服务器上资源的状态产生任何副作用。HEAD、GET、OPTIONS和TRACE都按惯例指定为安全。
- en: Status codes
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态码
- en: Even when an application has constructed a valid HTTP request object, and submits
    that request to a valid path on an active host, it's not uncommon for the server
    to fail to properly respond. For this reason, HTTP designates, as part of a response
    object, a status code to communicate the ability of the server to properly service
    the request. HTTP status codes are, by convention, 3-digit numeric codes returned
    as part of every response. The first digit indicates the general nature of the
    response, and the second and third digits will tell you the exact issue encountered.
    In this way, we can say that status codes are categorized by their first digits.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 即使应用程序已构造了一个有效的HTTP请求对象，并将其提交到活动主机上的有效路径，服务器无法正确响应的情况也并不少见。因此，HTTP将状态码指定为响应对象的一部分，以传达服务器正确处理请求的能力。按照惯例，HTTP状态码是作为每个响应的一部分返回的3位数数字码。第一位数字表示响应的一般性质，第二位和第三位数字将告诉您遇到的精确问题。这样，我们可以这样说，状态码是根据它们的第一位数字进行分类的。
- en: When you're writing software that responds to HTTP requests, it's important
    to send accurate status codes in response to different errors. HTTP is a standard
    that must be adhered to by developers in order to remain useful.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 当你编写响应HTTP请求的软件时，向不同的错误发送准确的状态码非常重要。HTTP是一个标准，开发者必须遵守才能保持其有用性。
- en: 'There are only five valid values for the first digit of an HTTP status code,
    and thus, five categories of responses; they are as follows:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP状态码的第一位数字只有五个有效值，因此有五个响应类别；它们如下所示：
- en: '**1XX:** Informational status code. This indicates that the request was in
    fact received, and the processing of that request is continuing.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1XX：信息状态码**。这表示请求确实已接收，并且该请求的处理正在继续。'
- en: '**2XX:** Success status code. This indicates that the request was successfully
    received and responded to.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2XX：成功状态码**。这表示请求已被成功接收并响应。'
- en: '**3XX:** Redirection. This indicates that the requesting host must send their
    request to a new location for it to be successfully processed.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3XX：重定向**。这表示请求的主机必须将它们的请求发送到新位置才能成功处理。'
- en: '**4XX:** Client Error. An error that is produced by the actions of the client,
    such as sending a malformed request or attempting to access resources from the
    wrong location.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**4XX：客户端错误**。这是一个由客户端操作产生的错误，例如发送格式不正确的请求或尝试从错误的位置访问资源。'
- en: '**5XX:** Server Error. There was a fault on the server preventing it from being
    able to fulfill a request. The client submitted the request correctly, but the
    server failed to satisfy it.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**5XX：服务器错误**。服务器出现故障，阻止其能够满足请求。客户端正确提交了请求，但服务器未能满足它。'
- en: Status codes are returned by servers for every HTTP request made against the
    server, and so can be very useful for building resiliency into your client software.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 状态码是服务器对每个针对服务器的HTTP请求返回的，因此对于构建客户端软件的弹性非常有用。
- en: The HTTP message format
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP消息格式
- en: 'Requests and responses in HTTP are always sent as plain text messages. Those
    plain text messages consist of a well-ordered, and well-structured, series of
    message segments that can be reliably parsed by the recipient. In requests, messages
    consist of three required message components and one optional component:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP中的请求和响应始终以纯文本消息发送。这些纯文本消息由一系列有序且结构良好的消息段组成，这些段可以被接收者可靠地解析。在请求中，消息由三个必需的消息组件和一个可选组件组成：
- en: The request line consists of the method, the path to the requested resource,
    and the specific protocol version that should be used to determine the validity
    of the rest of the message; for example, `GET /users/id/12 HTTP/1.1`.
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 请求行由方法、请求资源的路径以及用于确定消息其余部分有效性的特定协议版本组成；例如，`GET /users/id/12 HTTP/1.1`。
- en: 'A series of request headers and their values, for example, `Accept: application/json`.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '一系列请求头及其值，例如，`Accept: application/json`。'
- en: An empty line.
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个空行。
- en: (Optional) A request message body. This consists of content headers that provide
    metadata about the content type, as well as the content itself.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: （可选）请求消息体。这包括内容头，它提供了关于内容类型以及内容的元数据，以及内容本身。
- en: Each segment is delineated by a `<CR>` carriage return character and an `<LF>`
    line feed character; these are special white-space characters whose specific **American
    Standard Code for Information Interchange** (**ASCII**) values allow them to reliably
    be used to indicate the breaks between segments in a message stream.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 每个段由一个`<CR>`回车字符和一个`<LF>`换行字符分隔；这些是特殊的空白字符，它们的特定**美国信息交换标准代码**（**ASCII**）值允许它们可靠地用于在消息流中指示段之间的分隔。
- en: 'Meanwhile, an HTTP response consists of its own series of almost identically
    structured segments, each also delimited by the `<CR><LF>` characters. Just as
    with the request message, it contains three required segments and one optional
    message body segment, as follows:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，HTTP响应由其几乎具有相同结构的多个段组成，每个段也由`<CR><LF>`字符分隔。就像请求消息一样，它包含三个必需的段和一个可选的消息体段，如下所示：
- en: 'A status line consisting of the specific protocol, the HTTP status code, and
    the reason phrase associated with that status code:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由特定协议、HTTP状态码及其相关原因短语组成的状态行：
- en: '`HTTP/1.1 401 Bad Request`: A response containing the 401 client error status
    code (indicating that the client sent an improper request message for the resource
    that it was looking for).'
  id: totrans-132
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP/1.1 401 Bad Request`：包含401客户端错误状态码的响应（表示客户端发送了不正确的请求消息以查找其资源）。'
- en: '`HTTP/2.0 201 Created`: A response indicating the 201 success status code,
    meaning that the desired resource has been created on the server.'
  id: totrans-133
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`HTTP/2.0 201 Created`：表示 201 成功状态码的响应，意味着所需的资源已在服务器上创建。'
- en: Headers, as with the request message segment, providing metadata about how the
    response should be parsed.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与请求消息段一样，头提供了关于如何解析响应的元数据。
- en: An empty line.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一行空行。
- en: An optional message body.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 可选的消息体。
- en: Those simple segments fully define every valid HTTP message sent across the
    internet. This accounts for millions of requests per second, between millions
    or billions of devices. It's the simplicity of the message specification that
    makes that kind of scale possible.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 这些简单的段完全定义了互联网上发送的每个有效 HTTP 消息。这解释了每秒数百万次请求，涉及数百万或数十亿台设备。正是消息规范的简单性使得这种规模成为可能。
- en: HTTP in C#
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 中的 HTTP
- en: Remembering the proper character delimiters and order for segments in an HTTP
    message, anyone should be able to build a request from scratch. Thankfully though,
    you don't have to remember those details; .NET Core has you covered with the `System.Net.Http`
    namespace. We'll explore this namespace in much greater detail later in the book,
    but for now, just trust that any feature or detail you find yourself needing to
    leverage HTTP communication in your application is exposed through that namespace.
    This namespace exposes enum types for status codes and header values, and an `HttpMethod`
    class to specify your message verb. As a library, it's rich with out-of-the-box
    features while remaining flexible and extensible enough to be leveraged in any
    use case.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 记住 HTTP 消息中段的正确字符分隔符和顺序，任何人都可以从头开始构建一个请求。幸运的是，你不必记住这些细节；.NET Core 通过 `System.Net.Http`
    命名空间为你提供了支持。我们将在本书的后面部分更详细地探讨这个命名空间，但到目前为止，只需相信你在应用程序中需要利用 HTTP 通信的任何功能或细节都可以通过该命名空间暴露出来。这个命名空间提供了状态码和头值枚举类型，以及一个
    `HttpMethod` 类来指定你的消息动词。作为一个库，它具有丰富的开箱即用功能，同时足够灵活和可扩展，可以在任何用例中使用。
- en: FTP and SMTP – the rest of the application layer
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP 和 SMTP – 应用层的其余部分
- en: While we have developed a deep understanding of HTTP due to its prominence in
    the daily lives of network programmers, we must also take the time to mention
    and briefly look at some of the other common application-layer protocols in use
    today. In this section, we'll look at the **File Transfer Protocol** (**FTP**)
    and **SSH File Transfer Protocol** (**SFTP**), which allow for remote file copy
    operations and filesystem navigation; and the **Simple Mail Transfer Protocol**
    (**SMTP**), which is used for email transmission over networks.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管由于 HTTP 在网络程序员日常生活中的突出地位，我们已经对其有了深入的了解，但我们还必须花时间提及并简要地查看一些今天正在使用的其他常见应用层协议。在本节中，我们将探讨
    **文件传输协议**（**FTP**）和 **SSH 文件传输协议**（**SFTP**），它们允许远程文件复制操作和文件系统导航；以及 **简单邮件传输协议**（**SMTP**），它用于在网络上传输电子邮件。
- en: Interestingly, with each of these protocols operating on the application layer,
    it's not uncommon to see one protocol provide the functionality that has historically
    fallen under the domain of another protocol. For example, the data-agnostic nature
    of HTTP's plain-text message structure makes it trivially simple to use HTTP to
    transfer complete file data over an HTTP session. It's as simple as writing software
    on the server to transmit files through the message body of the response. For
    this reason, FTP, and to a lesser degree, SMTP, have fallen out of favor with
    network programmers in recent years, in favor of implementing their responsibilities
    in HTTP-aware software hosts. The protocols remain, however, and it will benefit
    us to consider what their flaws and advantages are.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，由于这些协议都在应用层运行，因此看到一种协议提供另一种协议历史上所提供的功能并不罕见。例如，HTTP 的纯文本消息结构的无数据感知特性使得通过
    HTTP 会话传输完整文件数据变得极其简单。这就像在服务器上编写软件通过响应的消息体传输文件一样简单。因此，FTP 和在某种程度上较小的 SMTP，近年来在网络程序员中已经不再受欢迎，他们更倾向于在支持
    HTTP 的软件宿主中实现其职责。然而，这些协议仍然存在，考虑它们的缺陷和优点将对我们有益。
- en: FTP and SFTP
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: FTP 和 SFTP
- en: FTP (and SFTP) leverages a client-server model similar to the one used by HTTP,
    but its connection specification is slightly more complicated than we saw before.
    Where HTTP sent messages over a single connection by way of a series of stateless
    request/response transactions, FTP maintains twoconnections between the client
    and server over the course of a stateful session. One connection establishes a
    stateful control pipeline that tracks the current state of the directory exposed
    by the FTP server and submits the commands necessary to execute the desired file
    transfers. The other connection is stateless, and facilitates the transfer of
    the raw file data between hosts. Establishing both of these connections for a
    single FTP session introduces the benefit of reliability at the cost of latency
    and complexity. Moreover, the limited nature of tasks that can be reliably executed
    through FTP as a communication protocol has only served to limit its popular use
    as time goes on. Thankfully though, as was the case with HTTP, much of the details
    of implementing an FTP server or client is taken care of by way of the `System.Net`
    namespace in .NET core, and we'll explore those tools later on in this book.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: FTP（以及SFTP）利用类似于HTTP所使用的客户端-服务器模型，但其连接规范比我们之前看到的要复杂一些。HTTP通过一系列无状态请求/响应事务在单个连接上发送消息，而FTP在状态会话期间维护客户端和服务器之间的两个连接。一个连接建立了一个状态控制管道，该管道跟踪FTP服务器暴露的目录的当前状态，并提交执行所需文件传输的必要命令。另一个连接是无状态的，它促进了主机之间原始文件数据的传输。为单个FTP会话建立这两个连接，在引入可靠性的同时，也带来了延迟和复杂性的代价。此外，随着时间推移，FTP作为通信协议能够可靠执行的任务性质有限，这仅仅限制了其流行的使用。幸运的是，正如HTTP的情况一样，在.NET核心中，实现FTP服务器或客户端的大部分细节都由`System.Net`命名空间处理，我们将在本书的后续部分探讨这些工具。
- en: SMTP
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: SMTP
- en: Similar to FTP, the feature set supported by the SMTP is quite limited and narrowly
    tailored to performing a few specific tasks. However, the need to implement email
    servers is actually fairly common, and understanding the complexity of sending
    or receiving messages through SMTP remains a relevant and useful skill; certainly
    more so than with FTP these days. SMTP is a connection-oriented protocol for sendingmail
    messages to remote servers that are configured to receive them. It leverages a
    client-server model leveraging reliable sessions, over which a series of commands
    and data-transfer processes transmit email, unilaterally, from the client to the
    server. The back-and-forth of an SMTP session is actually quite a bit more complicated
    than we saw with HTTP and FTP, and that complexity is beyond the scope of this
    chapter. For now though, it's sufficient to say that any network programmer worth
    their salt will have a sound understanding of HTTP, FTP, and SMTP.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 与FTP类似，SMTP所支持的功能集相当有限，且针对执行几个特定任务进行了精确定制。然而，实现电子邮件服务器的需求实际上相当普遍，理解通过SMTP发送或接收消息的复杂性仍然是一项相关且有用的技能；与FTP相比，这一点在当今更为重要。SMTP是一种面向连接的协议，用于向配置为接收它们的远程服务器发送邮件消息。它利用客户端-服务器模型，通过可靠的会话，一系列命令和数据传输过程将电子邮件单方面从客户端传输到服务器。SMTP会话的来回实际上比HTTP和FTP要复杂得多，这种复杂性超出了本章的范围。然而，目前来说，可以说任何有价值的网络程序员都应该对HTTP、FTP和SMTP有一个良好的理解。
- en: The Transport layer
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 传输层
- en: While the application layer is the layer of the OSI model that the vast majority
    of .NET developers work with in their daily lives, it would be useless without
    sound, reliable protocol implementations on the transport layer. It's on this
    layer that the connections are made and the data is streamed. It's the lowest
    layer in the stack that an individual host is directly responsible for, and in
    the transport layer, TCP and UDP reign supreme. Each provide their own mechanisms
    for delivering streams of data to their destination, and each present their own
    trade-offs, to be considered when choosing a transport protocol for your network
    services. As with all of these protocols, we'll take a closer look at them later
    in this book, but for now let's learn what they are and why they came to be.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然应用层是大多数.NET开发者在日常生活中与OSI模型打交道的层，但没有在传输层上的可靠、稳定的协议实现，它将毫无用处。正是在这一层上建立连接并传输数据。它是单个主机直接负责的堆栈中的最低层，在传输层，TCP和UDP占据主导地位。每个都提供自己的机制将数据流传输到目的地，并且每个都提供了自己的权衡，这些权衡在选择网络服务的传输协议时需要考虑。与所有这些协议一样，我们将在本书的后面更详细地探讨它们，但现在让我们了解它们是什么以及为什么会出现。
- en: TCP
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TCP
- en: Developed in 1974 by engineers in the IEEE, the TCP is defined as a connection-based
    communication protocol that provides the reliable delivery of ordered packets.
    It's used to facilitate communication between hosts of all kinds from the internet,
    to SMTP clients and servers, **Secure Shell** (**SSH**) connections, FTP clients
    and servers, and HTTP. It is ubiquitous as the transport layer protocol of choice
    for almost all modern applications.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由IEEE工程师于1974年开发，TCP被定义为一种基于连接的通信协议，它提供了有序数据包的可靠交付。它被用于促进各种主机之间的通信，从互联网到SMTP客户端和服务器，**Secure
    Shell** (**SSH**)连接，FTP客户端和服务器，以及HTTP。作为几乎所有现代应用的首选传输层协议，它无处不在。
- en: The broad adoption of TCP as the transport layer supporting most application-layer
    requests is primarily due to the reliability of a TCP connection. By convention,
    entities that implement TCP are written to detect packet loss and the out-of-order
    delivery of data streams, to re-request lost data, and to reorder the out-of-order
    streams. This error correction is resolved priorto returning that data back up
    the stack to the application layer entities making use of the TCP connection.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: TCP作为支持大多数应用层请求的传输层协议被广泛采用，这主要归功于TCP连接的可靠性。按照惯例，实现TCP的实体被编写来检测数据包丢失和数据流顺序错误，重新请求丢失的数据，并重新排序顺序错误的数据流。这种错误纠正是在将数据返回到使用TCP连接的应用层实体之前解决的。
- en: Of course, the obvious cost incurred by this error handling is latency and performance.
    Multiple round-trips to fetch, essentially, the same data two or three times can
    add substantial downtime to the client application. The reliability of TCP is
    ensured by leveraging a round-trip chain of request, acknowledgements of the receipt
    of a request, then another request, and so on. All the chatter incurred by this
    consistent back-and-forth makes TCP far from ideal for real-time applications,
    such as for gaming, video streaming, or video conferencing. Instead, where reliability
    or guaranteed ordering can be sacrificed in favor of performance, UDP or a similar
    protocol should be used as the transmission layer of choice.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这种错误处理显然产生的成本是延迟和性能。为了获取本质上相同的数据，多次往返可以给客户端应用增加大量的停机时间。TCP的可靠性是通过利用往返链请求、请求接收的确认、然后另一个请求，等等来保证的。这种持续的来回交流使得TCP对于实时应用，如游戏、视频流或视频会议，远非理想。相反，当可以牺牲可靠性或保证顺序以换取性能时，应使用UDP或类似协议作为传输层的选择。
- en: UDP
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UDP
- en: If the reliability of TCP is not strictly required for an application, then
    UDP begins to look like a very attractive option for its simplicity and performance.
    UDP is a simple, unreliable, and connectionless communication protocol for transmitting
    data over a network. Where TCP provided robust error handling through its pattern
    of repeated requests and acknowledgments, UDP has no handshaking or acknowledgment
    signals to indicate whether a packet was properly transmitted from host to host.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个应用不需要严格保证TCP的可靠性，那么UDP由于其简单性和性能开始看起来是一个非常吸引人的选择。UDP是一种简单、不可靠且无连接的通信协议，用于在网络中传输数据。TCP通过其重复请求和确认的模式提供了强大的错误处理，而UDP没有握手或确认信号来指示数据包是否正确地从主机传输到主机。
- en: While UDP does not provide robust error-handling in the case of lost or unordered
    packets, it does, at the very least, provide error-checking on the packet level.
    It does so by using a checksum value stored in the header of the packet. The difference
    being that when an error is detected in a packet, the packet is simply dropped
    by the UDP entity, and no request is sent out to try to retrieve the packet again
    in a valid state.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然UDP在数据包丢失或顺序错误的情况下不提供强大的错误处理，但它至少在数据包级别上提供了错误检查。它是通过使用存储在数据包头部的校验和值来实现的。区别在于，当检测到数据包中的错误时，UDP实体简单地丢弃该数据包，并且不会发送任何请求来尝试再次以有效状态检索该数据包。
- en: This packet-delivery-oriented model of sending out individual packets without
    regard for their successful delivery also means that UDP data requests can be
    sent without any prior establishment of a connection between hosts. This lack
    of an initial round-trip greatly reduces overhead in software systems that need
    to make frequent, real-time connections between many hosts. In fact, this lack
    of an initial handshake is one of the primary distinguishing factors between connection
    and connectionless communication protocols, and that is a distinction that warrants
    elaboration.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 这种以数据包投递为导向的模型，即发送单个数据包而不考虑其成功投递，也意味着UDP数据请求可以在主机之间没有建立任何先前连接的情况下发送。这种缺乏初始往返极大地减少了需要在大批主机之间频繁进行实时连接的软件系统中的开销。事实上，这种缺乏初始握手是连接和无连接通信协议之间主要的区别之一，这一点值得详细阐述。
- en: Connection versus connectionless communication
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 连接与无连接通信
- en: The idea of connectionless communication might seem like an oxymoron at first.
    How could two entities possibly communicate if they haven't connected first? How
    would one even know that the other exists to communicate with?
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 无连接通信的概念一开始可能看起来像是自相矛盾。如果两个实体在连接之前就无法通信，它们怎么可能进行交流？一个人甚至怎么知道另一个实体存在以便进行通信呢？
- en: The underlying principle is that in a connection-based communication protocol,
    both hosts must first establish a line of communication before thetransmission
    of any application-specific data can begin. The handshake sequence in TCP is the
    most obvious example of this. There is a complete round-trip of sent/received
    messages that must succeed before the connection is considered established, and
    data can be transmitted between hosts. That established line of communication
    is the 'connection' in this context. It consumes time and bandwidth, but provides
    reliability and error correction, and in almost all cases, the value of the reliability
    and error correction is worth far more than the costs incurred.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 基本原理是，在基于连接的通信协议中，两个主机必须首先建立一条通信线路，然后才能开始传输任何特定应用的数据。TCP中的握手序列是这一点的最明显例子。必须在成功建立连接之前，发送/接收消息完成一个完整的往返。在这个上下文中，建立的那条通信线路就是“连接”。它消耗时间和带宽，但提供可靠性和错误纠正，在几乎所有情况下，可靠性和错误纠正的价值远远超过所承受的成本。
- en: Meanwhile, in connectionless communication, data could be transmitted, and the
    communication terminated, without even a singlecomplete round-trip from the client
    to the server, and back to the client again. The packet has sufficient information
    in its own headers to be properly routed to a listening host. Provided that host
    has no follow-up to the initial request, that communication will stop with only
    a one-way packet delivery. The low-latency of this transmission pattern could
    be a major benefit in certain application contexts.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 同时，在无连接通信中，数据可以在没有从客户端到服务器，再从服务器返回客户端的单个完整往返的情况下进行传输和通信终止。数据包在其自己的头部中包含足够的信息，以便正确路由到监听主机。只要该主机没有对初始请求的后续操作，那么通信将仅通过单向数据包投递停止。这种传输模式的低延迟可能在某些应用场景中是一个主要优势。
- en: There's still so much more to explore with both of these protocols, going forward,
    but that is the concern of a later chapter in this book. For now though, I hope
    this makes it clear why the transport layer and its protocols serve such a major
    role in designing and implementing high-performance and highly-reliable network
    software.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这两个协议，还有很多东西需要进一步探索，但这将是本书后面章节的内容。然而，现在，我希望这能清楚地说明为什么传输层及其协议在设计和实现高性能和高可靠性网络软件中扮演着如此重要的角色。
- en: Summary
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned everything there is to know about the OSI network
    model. First, we learned about the governing bodies that defined the standard
    reference model, including when and why they set out to solve the problem of unified
    network modeling. Then, we took a close look at the model they defined, including
    looking at every layer in their stack, and what responsibilities entities in those
    layers assume. We learned about how protocolsdefine standardized communication
    patterns for entities operating on the same level in the network stack, but on
    separate hosts on a network. We saw how service definitionsallow entities to pass
    data through the network stack and deliver messages to remote entities.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了关于OSI网络模型的所有知识。首先，我们了解了定义标准参考模型的监管机构，包括他们何时以及为何着手解决统一网络建模的问题。然后，我们仔细研究了他们定义的模型，包括查看其堆栈中的每一层，以及那些层中的实体承担的责任。我们学习了协议如何为在同一网络堆栈层级但位于网络中不同主机上的实体定义标准化的通信模式。我们还看到了服务定义如何允许实体通过网络堆栈传递数据并将消息发送到远程实体。
- en: We also took a close look at some of the most common communication protocols,
    which we'll be interacting with in the rest of this book. We started with the
    king of all network protocols, HTTP. We looked at how HTTP sessions are established
    to allow communication between clients and servers. We saw how HTTP operates through
    a series of requests and responses using well-defined verbsto specify the operations
    to be performed in servicing those requests. We looked at TCP and UDP, and how
    the transport layer serves as the bus through which all application-layer network
    interactions must travel. Finally, we looked at how the network layer facilitates
    this communication through the IP addressing system, and discrete packet transmission.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还仔细研究了本书其余部分中我们将与之交互的一些最常用的通信协议。我们从所有网络协议之王HTTP开始。我们了解了HTTP会话是如何建立的，以便客户端和服务器之间进行通信。我们看到了HTTP如何通过一系列请求和响应以及定义良好的动词来操作，以指定在处理这些请求时需要执行的操作。我们还研究了TCP和UDP，以及传输层如何作为所有应用层网络交互必须通过的总线。最后，我们研究了网络层如何通过IP寻址系统和离散数据包传输来促进这种通信。
- en: With this foundation in place, we're well positioned to take a close look at
    how data is broken down into discrete packets and transmitted over the network
    through data streams in the next chapter.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个基础上，我们很好地定位了在下一章中深入探讨数据如何被分解成离散的数据包并通过数据流在网络中传输。
- en: Questions
  id: totrans-166
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What does OSI stand for, and what is the name of the organization that standardized
    it?
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OSI代表什么，哪个组织标准化了它？
- en: What is the abstraction layer via which layers of the OSI network stack communicate
    with layers beneath them?
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OSI网络堆栈的层通过哪个抽象层与下层的层进行通信？
- en: How many layers are in the OSI network stack, and what are they?
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: OSI网络堆栈有多少层，它们是什么？
- en: What is the name of the standardization mechanism by which entities on the same
    layer of the network stack on different hosts communicate?
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在不同主机上同一网络堆栈层级的实体之间通信的标准机制叫什么名字？
- en: What does HTTP stand for? For which network layer is HTTP used as a communication
    protocol?
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: HTTP代表什么？HTTP用作哪个网络层的通信协议？
- en: Name all of the HTTP verbs that a request can be sent from.
  id: totrans-172
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 列出所有可以从客户端发送的HTTP动词。
- en: What are some of the primary differences between the TCP and UDP transport protocols?
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: TCP和UDP传输协议之间有哪些主要区别？
- en: Further reading
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: For more information about the OSI Reference Model, see *Building Modern Networks*,
    by *Steven Noble, Packt Publishing*.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 更多关于OSI参考模型的信息，请参阅Steven Noble所著的《Building Modern Networks》，由Packt Publishing出版。
- en: 'Additionally, you can refer to *Computer Networking: Beginner''s Guide for
    Mastering Computer Networking* *and the OSI Model* by *Ramon Nastase''s,* and *The
    OSI Model for Network Engineers: Improve Your Network Troubleshooting,* by *Al
    Rivas*. Both are available in e-book form on [amazon.com](http://amazon.com),
    and will provide a much more thorough examination of the OSI stack than I had
    time or space to cover in the context of this chapter.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: '此外，您可以参考由Ramon Nastase编写的《Computer Networking: Beginner''s Guide for Mastering
    Computer Networking》和《The OSI Model》以及Al Rivas的《The OSI Model for Network Engineers:
    Improve Your Network Troubleshooting》。这两本书都可以在[amazon.com](http://amazon.com)以电子书形式获得，并将提供比我在这章的上下文中有时间或空间覆盖的更彻底的OSI堆栈的检查。'
