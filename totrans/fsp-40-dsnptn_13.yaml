- en: Chapter 13. Troubleshooting Functional Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第13章：函数代码的故障排除
- en: In this chapter, I touch on an important aspect of the functional-first programming
    approach that kicks in when the F# code is in the process of being developed.
    It so happens that the troubleshooting of the functional-first code differs from
    the troubleshooting of, say, imperative code. The goal of this chapter is to share
    with you some of my observations collected while authoring idiomatic F# code.
    It should leave you equipped with some considerations and a few techniques for
    effective bug squashing.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我简要介绍了函数优先编程方法的一个重要方面，该方法在F#代码开发过程中发挥作用。事实上，函数优先代码的故障排除与诸如命令式代码的故障排除不同。本章的目标是与你分享我在编写惯用F#代码时收集的一些观察结果。它应该使你具备一些考虑因素和一些有效的错误排除技巧。
- en: 'In this chapter, we will look into the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章我们将探讨以下主题：
- en: Understanding reasons for idiomatic F# having a low defect rate
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解为什么惯用F#具有低缺陷率
- en: Using REPL and explorative programming style
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用REPL和探索性编程风格
- en: Addressing some compile-time problems
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决一些编译时问题
- en: Addressing run-time problems
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 解决运行时问题
- en: Why idiomatic F# admits less defects
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么惯用F#允许更少的缺陷
- en: Without going back to the side-by-side comparison of functional-first and other
    paradigms available for F# programmer to employ, I will reiterate the (mostly
    anecdotal) point that an idiomatic F# code admits fewer defects than equivalent
    implementations based on object-oriented or imperative paradigms.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 不再回到函数优先和其他F#程序员可用的范式并行的比较，我将重申（主要是轶事性的）观点，即惯用F#代码允许的缺陷比基于面向对象或命令式范式的等效实现更少。
- en: 'The previous twelve chapters have contributed significantly to this judgment.
    But let me briefly revisit some considerations in order to conclude that:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 前十二章节对此判断做出了重大贡献。但让我简要回顾一些考虑因素，以便得出以下结论：
- en: This decrease in the defect rate is not something taken for granted. This artifact
    is what you gain in exchange for the pain of mind-bending while acquiring functional
    thinking habits and the following rigor in applying them
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这种缺陷率的降低并不是理所当然的。这是你在获得功能思维习惯和随后应用它们的严谨性时所付出的代价
- en: The use of F# by itself is not a remedy from the defects; there is still enough
    space for bugs to sneak into the code, although in significantly lower amounts
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 仅使用F#本身并不能解决缺陷；代码中仍有足够的空间让错误潜入，尽管数量显著减少
- en: Typical F# bugs are quite specific and often may be anticipated and avoided
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 典型的F#错误非常具体，通常可以预测并避免
- en: Reduced bug rate
  id: totrans-13
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 降低错误率
- en: 'This observation is very important and stems from a few factors:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 这个观察结果非常重要，并源于几个因素：
- en: 'The language''s succinctness contributes to the reduced bug rate literally:
    fewer lines of code carry fewer chances for bugs to sneak in and stay unnoticed'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 语言的简洁性直接导致错误率降低：更少的代码行意味着更少的错误潜入和未被注意到的机会
- en: Strict static typing and type inference simply do not allow oversights that
    are typical for dynamic languages, when the misplacement of types may lead to
    bugs that are hard to detect and eliminate later on
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 严格的静态类型和类型推断根本不允许动态语言中常见的疏忽，当类型放置不当可能导致难以检测和消除的bug
- en: Raised level of abstraction, library higher-order functions, and immutability.
    All of these contribute to eliminating many bugs that come from the unpredictable
    execution order of stateful code, more "moving parts" involved, and needless re-implementation
    of core library facilities
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提高抽象级别、库高阶函数和不可变性。所有这些都有助于消除许多来自状态代码不可预测执行顺序、更多“移动部件”参与以及不必要的核心库功能重实现的bug
- en: Prevalence of F# compile-time errors over run-time bugs
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: F#编译时错误比运行时错误更为普遍
- en: The syntactic correctness of a program written using a conventional programming
    language usually does not prompt any assumptions about the outcome of its execution.
    Generally speaking, these two factors are not correlated.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 使用传统编程语言编写的程序在语法上正确通常不会引起对其执行结果的任何假设。一般来说，这两个因素并不相关。
- en: It seems that this is not the case for the implementations following the F#
    functional-first approach. There is plenty of anecdotal evidence on the Internet
    in F# and non-F# functional programming context stating that
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，遵循F#函数优先方法的实现并非如此。在F#和基于F#的非函数编程环境中，互联网上有大量的轶事证据表明
- en: '*"if it compiles it works"*'
  id: totrans-21
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"如果编译成功，则运行正常"*'
- en: For example, this **Haskell wiki post** ([https://wiki.haskell.org/Why_Haskell_just_works](https://wiki.haskell.org/Why_Haskell_just_works)
    ) states a similar observation in relation to programs written in the allied Haskell
    programming language.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，这个**Haskell维基帖子**([https://wiki.haskell.org/Why_Haskell_just_works](https://wiki.haskell.org/Why_Haskell_just_works)
    )就与使用相关Haskell编程语言编写的程序提出了类似的观察。
- en: Actually, strict static typing and type inference may catch many random defects
    at compile-time, shielding programmers from the costly process of observing a
    problem at run-time and then often performing lengthy and skill-demanding activities
    known as *debugging* in order to nail down the genuine cause of the problem at
    the source code level.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，严格的静态类型和类型推断可以在编译时捕捉到许多随机缺陷，从而保护程序员免受在运行时观察问题并随后进行耗时且需要技能的活动——通常称为*调试*——以在源代码级别确定问题的真正原因所带来的高昂成本。
- en: 'Another extremely important factor is to implement the algorithm by sticking
    to a handful of idiomatic patterns supported by core libraries instead of manipulating
    lower-level language constructs. To give you a better idea of what I''m talking
    about here, try to answer this question: Which approach carries more chances for
    implementation mistakes, folding a sequence with `Seq.fold` or materializing the
    sequence into the array and traversing elements using indexing while aggregating
    the result in a mutable value? The right answer easily translates into what has
    been mentioned on many occasions throughout the book: the positive effect of "minimizing
    the amount of moving parts" in a functional paradigm.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个极其重要的因素是，通过坚持使用核心库支持的少量惯用模式来实现算法，而不是操作低级语言结构。为了更好地说明我这里所说的内容，试着回答这个问题：哪种方法更容易出现实现错误，使用`Seq.fold`折叠序列，还是将序列实体化为数组并使用索引遍历元素，同时在可变值中聚合结果？正确的答案很容易转化为本书多次提到的观点：在函数式范式中的“最小化移动部件”的积极影响。
- en: Still, your fold should be the rightly one for the overall correctness of the
    implementation from an algorithmic standpoint. And F# offers just another bug-squashing
    facility. This facility allows the developer to perform fast, easy, and frequent
    quick checks along the course of implementation with the help of so-called **REPL**
    covered in the next section.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你的折叠操作应该是正确的，这对于从算法角度来看实现的整体正确性至关重要。F#还提供了另一个除虫工具。这个工具允许开发者借助所谓的**REPL**（下一节将介绍）在实现过程中快速、轻松且频繁地进行快速检查。
- en: Using REPL and the explorative programming style
  id: totrans-26
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用REPL和探索式编程风格
- en: '**REPL** stands for **Read-Evaluate-Print Loop** ([https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop)
    ) and represents a manner of program development that quite deviates from what
    old-style C# programmers were used to, namely *edit source code - build the compiled
    program version - run and debug loop* . From its very early days, F# has introduced
    **interactive development manner** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/fsharp-interactive/index](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/fsharp-interactive/index)
    ). However, more broadly, it equips the F# developer with just another programming
    style collectively referred to as **exploratory programming** ([https://en.wikipedia.org/wiki/Exploratory_programming](https://en.wikipedia.org/wiki/Exploratory_programming)
    ). F# offers a tool known as **F# Interactive** (32-bit `fsi.exe` or 64-bit-capable
    `fsiAnyCPU.exe` ) both as a standalone, or as a part of Visual Studio reachable
    from any F# Project. It allows you to evaluate any F# expression presented in
    the form of a standalone F# script or just a selected F# program fragment in a
    dynamically built run-time environment.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**REPL**代表**读取-评估-打印循环**([https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop](https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop)
    )，它代表了一种与老式C#程序员习惯的方式截然不同的程序开发方式，即*编辑源代码 - 构建编译后的程序版本 - 运行和调试循环*。从它的早期开始，F#就引入了**交互式开发方式**([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/fsharp-interactive/index](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/tutorials/fsharp-interactive/index)
    )。然而，更广泛地说，它为F#开发者提供了一种被称为**探索式编程**([https://en.wikipedia.org/wiki/Exploratory_programming](https://en.wikipedia.org/wiki/Exploratory_programming)
    )的编程风格。F#提供了一个名为**F# Interactive**（32位`fsi.exe`或64位兼容的`fsiAnyCPU.exe`）的工具，它既可以作为独立工具，也可以作为Visual
    Studio的一部分，从任何F#项目访问。它允许你在动态构建的运行时环境中评估任何以独立F#脚本或选定的F#程序片段形式呈现的F#表达式。'
- en: F# Interactive is a tool of immense versatility. Its use cases span a quick
    check of just implemented one-liner function behavior to running F#-implemented
    microservices in the production environment. Yes, I'm not kidding; the quality
    of the F# Interactive compiler is pretty much the same as that of normal build
    compiler. At one time, the whole Jet.com microservices architecture was implemented
    as a set of F# scripts, each executed by a dedicated `fsi` process.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: F#交互式是一个功能极其强大的工具。它的使用场景涵盖了从快速检查刚刚实现的一行函数行为到在生产环境中运行F#实现的微服务。是的，我没有开玩笑；F#交互式编译器的质量几乎与正常构建编译器相同。曾经，整个Jet.com微服务架构都是通过一系列F#脚本实现的，每个脚本都由一个专门的`fsi`进程执行。
- en: The habit of doing quick checks while developing any F# code by evaluating this
    or that fragment in `fsi` may significantly help in achieving practically bug-free
    F# implementations. I highly recommend that you acquire and follow F# explorative
    programming style in your day after day practice.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在开发任何F#代码时，通过在`fsi`中评估这个或那个片段进行快速检查的习惯，可以显著帮助实现几乎无错误的F#实现。我强烈建议你在日常实践中获取并遵循F#探索式编程风格。
- en: Addressing some compile-time problems
  id: totrans-30
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决一些编译时问题
- en: Although REPL can help explore and tweak correct F# code, it keeps compiler
    errors intact, as evaluating a code snippet includes compilation by the F# compiler
    embedded into `fsi` . And I must admit that some compile-time errors may puzzle
    an inexperienced F# developer. Here, I will analyze several kinds of such errors
    and provide advice on how to get rid of them. Before I do this, you should keep
    in mind that because an initial defect usually gets ingested by type inference
    as correct code, the reported compilation error is in line with that convoluted
    type inference determination. That is, type inference often masks the authentic
    cause of an error. We will go over some occasions of this layout soon.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然REPL可以帮助探索和调整正确的F#代码，但它会保留编译器错误，因为评估代码片段包括`fsi`中嵌入的F#编译器的编译。而且我必须承认，一些编译时错误可能会让经验不足的F#开发者感到困惑。在这里，我将分析几种这样的错误，并提供如何摆脱它们的建议。在我这样做之前，你应该记住，由于初始缺陷通常被类型推断作为正确代码吸收，因此报告的编译错误与那种复杂的类型推断推断是一致的。也就是说，类型推断经常掩盖错误的真正原因。我们很快就会讨论一些这种情况的例子。
- en: The if-then return value
  id: totrans-32
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: if-then返回值
- en: One of the easiest-to-grasp occurrences of the similar convoluted determination
    takes place for the result type of F# `if...then...` expressions. Usually, it
    seems counterintuitive that this result cannot be anything but `unit` . Let's
    look at why this happens.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 对于F# `if...then...`表达式结果类型的类似复杂推断，其中一种最容易理解的情况发生在该结果类型不能是任何其他类型，只能是`unit`。通常，这似乎是反直觉的。让我们看看为什么会这样。
- en: 'In the following snippet, I chose the specific (`<` ) comparison operator within
    the implementation just to keep things simple (`Ch13_1.fsx` ):'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，我选择了实现中的特定（`<`）比较运算符，只是为了保持简单（`Ch13_1.fsx`）：
- en: '[PRE0]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Here, the inferred signature of function `f` representing the result of evaluating
    the F# expression `if-then-else` is `f: ''a -> ''a -> ''a` (requires comparison),
    which makes perfect sense (it should not take much effort to recognize a generic
    implementation of the `min` function in the preceding code).'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '在这里，函数`f`的推断签名表示评估F#表达式`if-then-else`的结果，为`f: ''a -> ''a -> ''a`（需要比较），这完全合理（应该不需要太多努力就能识别出前面代码中`min`函数的泛型实现）。'
- en: 'Now let''s look at what happens if I omit the `else` part (`Ch13_1.fsx` ):'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如果省略`else`部分会发生什么（`Ch13_1.fsx`）：
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now the inferred signature of `f''` is `f'': unit->unit->unit` ; in other words,
    both arguments and the result must be of type `unit` . What gives? The reasoning
    behind the seemingly counterintuitive type inference outcome is, in fact, to continue
    making perfect sense. Let''s think what value the function `f''` must return when
    the condition `a < b` is `false` ? The compiler, in the absence of explicit directions,
    decides that it must be `unit` . But wait a minute; shouldn''t both branches of
    the `if-then-else` expression be of the same type? This condition can be only
    fulfilled if argument `a` is of type `unit` , which means argument `b` must be
    of type `unit` as well.'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: '现在函数`f''`的推断签名是`f'': unit->unit->unit`；换句话说，两个参数和结果都必须是`unit`类型。那是什么意思？看似反直觉的类型推断结果背后的推理实际上是有道理的。让我们想想当条件`a
    < b`为`false`时，函数`f''`必须返回什么值？在没有明确指示的情况下，编译器决定它必须是`unit`。但是等等；`if-then-else`表达式的两个分支不应该是同一类型吗？只有当参数`a`是`unit`类型时，这个条件才能满足，这意味着参数`b`也必须是`unit`类型。'
- en: 'Fine; but what would happen if I try to push type inference into certain ways,
    for example, forcefully attempting `a` to be of generic type `''a (Ch13_1.fsx)`
    :'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧；但如果我尝试将类型推断推向某些方式，例如，强制尝试将`a`推断为泛型类型`'a (Ch13_1.fsx)`：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Or, what if we try pushing `a` in the direction of being less generic by forcing
    it to be of a concrete type, for example, `int (Ch13_1.fsx)` :'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，如果我们尝试将`a`推向更具体的方向，通过强制它成为具体类型，例如，`int (Ch13_1.fsx)`：
- en: '[PRE3]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Turns out both attempts are futile, as consideration about the `unit` return
    type of the omitted `else` branch is still valid. In the first case, the compiler
    will just make a nasty warning pointing that
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 结果发现，两次尝试都是徒劳的，因为关于省略的`else`分支的`unit`返回类型的考虑仍然是有效的。在第一种情况下，编译器将只是发出一个讨厌的警告，指出
- en: '*This construct causes code to be less generic than indicated by the type annotations.
    The type variable `''a` has been constrained to be type `''unit''` .*'
  id: totrans-45
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*此结构导致代码的泛型程度低于类型注解所指示的程度。类型变量`''a`已被约束为类型`''unit''`。*'
- en: In the second case, from a compiler standpoint, there's a plain and simple error
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二种情况下，从编译器的角度来看，这是一个简单而直接的错误
- en: '*This expression was expected to have type unit but here has type `int` .*'
  id: totrans-47
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*此表达式预期具有`unit`类型，但此处具有`int`类型。*'
- en: So, how should we handle the `if...then...` expressions? The moral is that this
    short form of conditional statement may be used only in cases where a side-effect
    is needed. Good examples would be logging some diagnostics or changing a mutable
    value. For cases where a genuine non-`unit` result has to be returned, the full-blown
    `if-then-else` expression must be evaluated with both branches returning values
    of the same type.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们应该如何处理`if...then...`表达式？教训是，这种条件语句的简短形式只能在需要副作用的情况下使用。好的例子包括记录一些诊断信息或更改可变值。对于必须返回真正的非`unit`结果的情况，必须评估完整的`if-then-else`表达式，并且两个分支都返回相同类型的值。
- en: Value restriction
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 值限制
- en: 'This compile problem usually makes intermediate level F# developers who have
    grasped and proudly put to use F# features such as *partial application* and *automatic
    generalization* stumble. Imagine that you came out with a powerful data processing
    algorithm and are implementing it, enjoying the power and beauty of idiomatic
    F# code in the process. At some moment, you realize that you need a function that
    takes a list of lists and finds out whether all element lists are empty or not.
    Not a problem for a seasoned functional programmer like you, right? So you coin
    something like this (`Ch13_2.fsx` ):'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这种编译问题通常会使已经掌握并自豪地使用F#特性（如*部分应用*和*自动泛化*）的中级F#开发者感到困惑。想象一下，您提出了一种强大的数据处理算法并正在实现它，在这个过程中享受了惯用F#代码的力量和美感。在某个时刻，您意识到需要一个函数，该函数接受一个列表的列表并找出所有元素列表是否为空。对于一个经验丰富的函数式程序员来说，这难道不是一个小问题吗？所以您想出了类似这样的事情（`Ch13_2.fsx`）：
- en: '[PRE4]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Surprise! It does not compile with the compiler warning:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 惊讶！它无法编译，编译器警告如下：
- en: '*Value restriction. The value `''allEmpty''` has been inferred to have generic
    type `val allEmpty : (''_a list list -> bool) when ''_a:equality` Either make
    the arguments to `''allEmpty''` explicit or, if you do not intend for it to be
    generic, add a type annotation.*'
  id: totrans-53
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*值限制。值`''allEmpty''`已被推断为具有泛型类型`val allEmpty : (''_a list list -> bool) when
    ''_a:equality`。要么使`''allEmpty''`的参数显式化，要么，如果您不希望它具有泛型，添加类型注解。*'
- en: 'And you (I should admit I did this on multiple occasions in the past) first
    stare at this mess in disbelief as the F# compiler has accurately inferred your
    intent but somehow dislikes it. Then you Google "f# value restriction" and get
    referred to **MSDN Automatic Generalization** ([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/automatic-generalization](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/automatic-generalization)
    ), where you are told that:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您（我应该承认我过去多次这样做）首先对这个混乱感到难以置信，因为F#编译器准确地推断出了您的意图，但不知何故不喜欢它。然后您在Google上搜索“f#值限制”，被引荐到**MSDN自动泛化**([https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/automatic-generalization](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/generics/automatic-generalization)
    )，在那里您被告知：
- en: '*The compiler performs automatic generalization only on complete function definitions
    that have explicit arguments, and on simple immutable values.*'
  id: totrans-55
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*编译器仅在具有显式参数的完整函数定义和简单的不可变值上执行自动泛化。*'
- en: This is followed by practical recipes of working around a sudden problem. You
    try this advice and get the problem fixed, but you are left with the aftertaste
    of some black magic.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 这之后是处理突发问题的实用技巧。你尝试这些建议并解决问题，但留下了一些黑魔法般的余味。
- en: 'For me, the eye-opener was reading through this excellent blog post: **Finer
    Points of F# Value Restriction** ([https://blogs.msdn.microsoft.com/mulambda/2010/05/01/finer-points-of-f-value-restriction/](https://blogs.msdn.microsoft.com/mulambda/2010/05/01/finer-points-of-f-value-restriction/)
    ). I will demonstrate the hidden dangers of generalization applied to mutable
    values that may create a motive for you to read this blog post and understand
    the rationale behind the F# compiler behavior.'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 对我来说，令人耳目一新的经历是阅读这篇优秀的博客文章：**F# 值限制的细微差别** ([https://blogs.msdn.microsoft.com/mulambda/2010/05/01/finer-points-of-f-value-restriction/](https://blogs.msdn.microsoft.com/mulambda/2010/05/01/finer-points-of-f-value-restriction/)）。我将展示应用于可变值的泛化所隐藏的危险，这可能会成为你阅读这篇博客文章并理解
    F# 编译器行为背后的理由的动力。
- en: 'Let''s look at a seemingly innocuous code fragment here (`Ch13_2.fsx` ):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个看似无害的代码片段（`Ch13_2.fsx`）：
- en: '[PRE5]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Guess what would be the printed `x` value upon this fragment execution? That
    would be `["a"]` , right?
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 猜猜在执行此片段后打印的 `x` 值会是什么？那会是 `["a"]`，对吧？
- en: 'Wrong; `[]` is what happens! The cause of this is that `gr` , despite appearing
    as a value of type `''a list ref` , is, in fact, a type function. Used on the
    left-hand side of the `:=` operator, it just brings a fresh unbound reference
    instance. Used on the right-hand side of operator `!` , it brings just another
    fresh reference instance that refers to an empty list, `[]` . In order to achieve
    the intuitively expected behavior, we need to bind `gr` applied to the type argument
    string to the concrete typed variable `cr` , and then the latter, being a normal
    reference, will behave as expected (`Ch13_2.fsx` ):'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 错误；`[]` 就是发生的情况！造成这种情况的原因是 `gr` ，尽管看起来像 `'a list ref` 类型的值，但实际上是一个类型函数。在 `:=`
    操作符的左侧使用时，它只是带来一个新的未绑定引用实例。在 `!` 操作符的右侧使用时，它只带来另一个新的引用实例，该实例指向一个空列表 `[]`。为了实现直观预期的行为，我们需要将
    `gr` 应用到类型参数字符串上绑定到具体的类型变量 `cr` ，然后后者，作为一个普通引用，将按预期行为（`Ch13_2.fsx`）：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now the printed value is `["a"]` indeed. Imposing a value restriction error
    in all cases where the situation deviates from the safest use case compiler protects
    developers from the surprise code behavior of the kind demonstrated earlier. Getting
    back to my initial sample, the possible remedial action can be any of the following
    (`Ch13_2.fsx` ):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，打印的值确实是 `["a"]`。在所有情况中强制执行值限制错误，当情况偏离最安全的使用情况时，编译器保护开发者免受先前演示的意外代码行为。回到我的初始示例，可能的补救措施可以是以下任何一种（`Ch13_2.fsx`）：
- en: '[PRE7]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Imperfect pattern matching
  id: totrans-65
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 不完美的模式匹配
- en: 'Many seemingly counterintuitive F# compile-time errors and warnings belong
    to the field of pattern matching. For example, take a look the following naive
    detection of the integer argument sign:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 许多看似反直觉的 F# 编译时错误和警告属于模式匹配领域。例如，看看以下对整数参数符号的简单检测：
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Despite seeming completeness, this produces the compiler''s warning:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管看似完整，但这会产生编译器的警告：
- en: '*incomplete pattern matches on this expression*'
  id: totrans-69
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*在此表达式中存在不完整的模式匹配*'
- en: 'Turns out that the F# compiler, if presented with the `when` guards, assumes
    that this construction designates an incomplete match case by definition. This
    is why regardless of the fact that the given set of cases is semantically complete,
    the compiler considers the function definition incomplete. Simply removing the
    excessive last `when` guard immediately fixes the problem (`Ch13_3.fsx` ):'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 结果表明，如果 F# 编译器遇到 `when` 守卫，它就会假设这种构造定义了一个不完整的匹配情况。这就是为什么，尽管给定的案例集在语义上是完整的，编译器仍然认为函数定义是不完整的。简单地移除过多的最后一个
    `when` 守卫立即解决了问题（`Ch13_3.fsx`）：
- en: '[PRE9]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Another common related problem is unreachable matching rules. Most of the time,
    unreachable matching rules get into play when the programmer mistakenly uses a
    variable instead of a literal in the sequence of rules, creating a premature catch-all
    case. In such cases, the compiler uses benign warnings, although almost always,
    the run-time results are messed-up. Therefore, perhaps denoting these occasions
    as errors would be a better design choice. A couple of years ago I wrote a **blog
    post** ([https://infsharpmajor.wordpress.com/2011/10/13/union-matching-challenge/](https://infsharpmajor.wordpress.com/2011/10/13/union-matching-challenge/)
    ) on this matter, which I reproduce here as the illustration of the problem in
    the following snippet (`Ch13_3.fsx` ):'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个常见的相关问题是不可达的匹配规则。大多数情况下，不可达的匹配规则会在程序员错误地在规则序列中使用变量而不是字面量时发挥作用，从而创建一个过早的通配符情况。在这种情况下，编译器使用良性警告，尽管几乎总是运行时结果混乱。因此，将这些场合标记为错误可能是一个更好的设计选择。几年前，我写了一篇关于这个问题的**博客文章**([https://infsharpmajor.wordpress.com/2011/10/13/union-matching-challenge/](https://infsharpmajor.wordpress.com/2011/10/13/union-matching-challenge/))，我在这里将其作为以下代码片段（`Ch13_3.fsx`）中问题的说明：
- en: '[PRE10]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This may trick you into expecting the `Tick` output followed by `Tack` , but
    in fact, the `Tick` output is to be followed by `Tock` !
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能会让你期待 `Tick` 输出后跟 `Tack`，但实际上，`Tick` 输出后应该跟 `Tock`！
- en: 'The F# compiler issues two warnings for the preceding fragment. The first warning
    prompts you that typo `Tock` is taken as a variable and not a literal, like literals
    of type `TickTack` in two other cases:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: F# 编译器对前面的片段发出两个警告。第一个警告提示你，打字错误 `Tock` 被视为变量而不是字面量，就像在另外两种情况下字面量 `TickTack`
    一样：
- en: '*Uppercase variable identifiers should not generally be used in patterns, and
    may indicate a misspelt pattern name*'
  id: totrans-76
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*通常不应在模式中使用大写变量标识符，这可能会表明模式名称拼写错误*'
- en: 'The second warning:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个警告：
- en: '*This rule will never be matched*'
  id: totrans-78
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*这条规则永远不会匹配*'
- en: directly indicates the outcome caused by the typo.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 直接指出了由打字错误引起的后果。
- en: The moral here is that the F# developer should be attentive to warnings. Treating
    rule unreachability by the compiler as an error would be more adequate perhaps.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的教训是，F# 开发者应该注意警告。将编译器处理的规则不可达视为错误可能更合适。
- en: Addressing run-time problems
  id: totrans-81
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决运行时问题
- en: The mantra " *if it compiles, it works* " helps followers score amazingly well
    in time-to-market ratings for enterprise software development.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: “如果编译成功，那么它就能工作” 的这句箴言帮助追随者们在企业软件开发的时间到市场评分中取得了惊人的成绩。
- en: Taking Jet.com as an example of building green field e-commerce platform implementation,
    it has really condensed the path from zero to **minimum viable product** ( **MVP**
    ) in less than a year. Release of the platform to the production mode took place
    in a bit more than a year from the reception.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 以 Jet.com 作为构建绿色田野电子商务平台实现的例子，它真的在不到一年的时间里将零到**最小可行产品**（**MVP**）的路径压缩了。平台的生产模式发布发生在接收后一年多一点的时间。
- en: Does this mean following a functional-first approach is a software development
    silver bullet? Surely not on an absolute scale, although on a relative scale,
    the improvements are just great.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这是否意味着遵循以函数式优先的方法是软件开发中的银弹？当然不是在绝对尺度上，尽管在相对尺度上，改进是巨大的。
- en: Why is the success not exhaustive? The thing is that the practice requires transition
    from gory ideas to mundane implementation issues. No matter how accurate our implementations
    are, there are always dark corners exist where unexpected problems may lurk.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 为什么成功不是详尽的？问题是，这种实践需要从血腥的想法过渡到平凡的实施问题。无论我们的实现多么准确，总有一些暗角可能潜伏着意外的问题。
- en: Let me demonstrate this with a sample taken from F# enterprise development practice
    at Jet.com. Jet represents an innovative e-commerce platform, bringing together
    many business areas, such as Internet ordering, retail selling, warehousing, finance,
    accounting, transportation, you name it. Each of these areas usually carries its
    own unique metadata classifications; so, in order to run them side by side, one
    of the most common operations within the implementation is mapping. And the generally
    accepted practice of using unique non-clashing identifications is based on GUIDs
    or **Global Unique Identifiers** ([https://en.wikipedia.org/wiki/Globally_unique_identifier](https://en.wikipedia.org/wiki/Globally_unique_identifier)
    ).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 让我用Jet.com F#企业开发实践中的一个示例来演示这一点。Jet代表一个创新的电子商务平台，汇集了许多业务领域，如互联网订购、零售销售、仓储、财务、会计、运输等。这些领域的每个通常都有自己的独特元数据分类；因此，为了并行运行它们，实现中最常见的操作之一是映射。而使用唯一非冲突标识符的普遍做法是基于GUID或**全局唯一标识符**
    ([https://en.wikipedia.org/wiki/Globally_unique_identifier](https://en.wikipedia.org/wiki/Globally_unique_identifier)
    )。
- en: Realistically assuming that quite frequently, enterprise software deals with
    dictionaries and caches using GUIDs as access keys, let's look at how good the
    core .NET library `System.Guid` implementation for the purpose would be.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，企业软件经常使用GUID作为访问键来处理字典和缓存，让我们看看.NET核心库`System.Guid`的实现是否适合这个目的。
- en: 'Here goes a quite simplistic explorative implementation using a dictionary
    that has instances of the `System.Guid` type as keys. I created a simple `dictionary`
    based on the standard F# core library implementation having type `IDictionary<Guid,int>`
    . I populated it with the size number of pairs (`Guid,int` ), just for the sake
    of simplicity. Now, I will imitate a big `trials` number of random accesses to
    the dictionary using array `keys` as a level of indirection and measuring the
    performance. The following snippet shows the composition of the required code
    pieces (`Ch13_4.fsx` ):'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个相当简单的探索性实现，使用具有`System.Guid`类型键的字典。我创建了一个基于标准F#核心库实现的简单`dictionary`，类型为`IDictionary<Guid,int>`。我仅为了简单起见，用大小数字对（`Guid,int`）填充它。现在，我将使用数组`keys`作为间接层来模拟对字典的大量随机访问，并测量性能。以下代码片段显示了所需代码片段的组成（`Ch13_4.fsx`）：
- en: '[PRE11]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Running this snippet through FSI with timing turned on yields the performance
    indicators shown in the following screenshot (only the valuable output is shown
    for brevity):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在开启计时的情况下运行此代码片段，以下屏幕截图显示了性能指标（为了简洁，仅显示有价值的输出）：
- en: '![Addressing run-time problems](img/Image00066.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![处理运行时问题](img/Image00066.jpg)'
- en: Using native System.Guid to access a dictionary
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 使用原生System.Guid访问字典
- en: '10 million accesses for 6.445 seconds translates into a bit higher than 1.5
    million accesses per second. Not too fast. Let''s take it for the baseline. Also,
    a worrying sign is a number of garbage collections that took place: 287 per 10000
    accesses is not light.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 1000万次访问在6.445秒内转换为每秒超过150万次访问。不算快。让我们把它作为基准。还有一个令人担忧的迹象是垃圾回收的数量：每10000次访问就有287次，这并不轻。
- en: 'Without digging dipper into the causes of the observed code behavior here,
    let me just show the results of the findings performed for Jet.com in an attempt
    to improve the watermark. I will introduce a simple change instead of using the
    genuine `System.Guid` type that is a quite complicated Windows system data structure
    as a dictionary key, I will use the representation of the GUID value as a hexadecimal
    string that is leftover when the canonical presentation is stripped of dashes.
    For example, the `f4d1734c-1e9e-4a25-b8d9-b7d96f48e0f` GUID will be represented
    as a `f4d1734c1e9e4a25b8d9b7d96f48e0f` string. This will require minimal changes
    to the previous snippet (`Ch13_4.fsx` ):'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入挖掘观察到的代码行为的原因之前，让我仅展示为Jet.com进行的调查结果，以尝试改进水印。我将引入一个简单的更改，而不是使用作为复杂Windows系统数据结构的字典键的真正`System.Guid`类型，我将使用当从规范表示中去除连字符后留下的GUID值的表示，即十六进制字符串。例如，GUID
    `f4d1734c-1e9e-4a25-b8d9-b7d96f48e0f`将被表示为字符串`f4d1734c1e9e4a25b8d9b7d96f48e0f`。这将需要对之前的代码片段（`Ch13_4.fsx`）进行最小的更改：
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here, I will just create a new `keys''` indirection layer made from corresponding
    parts of `keys` via a simple data conversion. Turning to FSI with this change
    brings a big surprise reflected in the following screenshot:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我将创建一个新的`keys'`间接层，通过简单的数据转换从`keys`的对应部分生成。使用这个更改转向FSI带来了一个巨大的惊喜，反映在下面的屏幕截图：
- en: '![Addressing run-time problems](img/Image00067.jpg)'
  id: totrans-97
  prefs: []
  type: TYPE_IMG
  zh: '![解决运行时问题](img/Image00067.jpg)'
- en: Switching from System.Guid to string in order to access a dictionary
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 从System.Guid切换到string以访问字典
- en: Compared to the baseline, the new access rate constitutes 16.4 millions accesses
    per second almost 11 times better! Also, garbage collection experiences a five-fold
    improvement.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 与基线相比，新的访问率构成了每秒16.4百万次访问，几乎提高了11倍！此外，垃圾回收也实现了五倍提升。
- en: Now remember that mappings based on `System.Guid` are ubiquitous for the platform
    and you can imagine the amount of impact from the above simple change to the overall
    platform performance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在记住，基于`System.Guid`的映射在平台上无处不在，你可以想象上述简单更改对整体平台性能的影响有多大。
- en: Summary
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter should leave you prepared for the defect type displacement taking
    place in the functional-first development in comparison to other development paradigms.
    A decreased rate of run-time errors typical to F# code shortens the time to market
    for developed systems and releases development resources for performance optimizations
    if they are deemed necessary.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本章应该使你为与其它开发范式相比，在以函数式编程为首要的开发中发生的缺陷类型位移做好准备。F#代码典型的运行时错误率降低缩短了开发系统的上市时间，并在必要时为性能优化释放了开发资源。
- en: We have reached the end of the book, where I equipped you with a whole slew
    of patterns of idiomatic F# use. The key assumption that the book makes is that
    such use requires from developers that come from other programming paradigms a
    certain shift in thinking habits, a distinct angle of seeing problems, and correspondent
    patterns and techniques populating the functional programmer tool belt. At this
    point you should be able to approach thinking through any problem by decomposing
    it into a handful of known building blocks and then composing the solution with
    appropriate functions and combinators. You also were shown the benefits of using
    standard F# algebraic data types over crafting custom .NET classes. Rely on patterns
    that you have acquired here in your functional designs; retain, recall, and reuse
    them in your day-to-day practices.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经到达了本书的结尾，我在这里为你装备了大量的惯用F#使用模式。本书的关键假设是，这种使用要求来自其他编程范式的开发者进行一定的思维习惯转变，独特的看问题角度，以及对应的功能程序员工具包中的模式和技巧。此时，你应该能够通过将问题分解为几个已知的构建块，然后使用适当的函数和组合子来构建解决方案来思考任何问题。你还被展示了使用标准F#代数数据类型而不是自定义.NET类的优势。在你的函数式设计中依赖你在这里获得的模式；保留、回忆并在日常实践中重用它们。
- en: I hope that this book may guide you onto a path to the field of idiomatic functional
    programming. Good luck getting there!
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我希望这本书能引导你进入惯用函数式编程领域的道路。祝你成功到达那里！
