<html><head></head><body>
  <div id="_idContainer1032" class="Basic-Text-Frame">
    <h1 class="chapterNumber">20</h1>
    <h1 id="_idParaDest-245" class="chapterTitle">Augmented Reality in Unity</h1>
    <p class="normal">Nowadays, new technologies expand the fields of the application of Unity, from gaming to all kinds of software, such as simulations, training, apps, and so on. In the latest versions of Unity, we saw lots of improvements in the field of augmented reality, which allows us to add a layer of virtuality on top of our reality, thereby augmenting what our device can perceive to create games that rely on real-world data, such as the camera’s image, our real-world position, and the current weather. This can also be applied to work environments, such as when viewing the building map or checking the electrical ducts inside a wall. Welcome to the extra section of this book, where we are going to discuss how to create <strong class="keyWord">Augmented Reality</strong> (<strong class="keyWord">AR</strong>) applications using Unity’s AR Foundation package.</p>
    <p class="normal">In this chapter, we will examine the following AR Foundation concepts: </p>
    <ul>
      <li class="bulletList">Using AR Foundation</li>
      <li class="bulletList">Building for mobile devices</li>
      <li class="bulletList">Creating a simple AR game</li>
    </ul>
    <p class="normal">By the end of this chapter, you will be able to create AR apps using AR Foundation and will have a fully functional game that uses its framework so that you can test the framework’s capabilities.</p>
    <p class="normal">Let’s start by exploring the AR Foundation framework.</p>
    <h1 id="_idParaDest-246" class="heading-1">Using AR Foundation</h1>
    <p class="normal">When it comes to AR, Unity <a id="_idIndexMarker1280"/>has two main tools to create applications: <strong class="keyWord">Vuforia</strong> and <strong class="keyWord">AR Foundation</strong>. Vuforia is an AR framework that can work in almost any mobile device and contains all the needed features for basic AR apps, but with a paid subscription, we get more advanced features. On the other hand, the completely free AR Foundation framework supports the latest AR native features of our devices but is supported only in newer ones. Picking between one or the other depends a lot on the type of project you’re going to build and the target audience. However, since this book aims to discuss the latest Unity features, we are going to explore how to use AR Foundation to create our first AR app for detecting the positions of images and surfaces in the real world. So, we’ll start by exploring its API. </p>
    <p class="normal">In this section, we will examine the following AR Foundation concepts:</p>
    <ul>
      <li class="bulletList">Creating an AR Foundation project</li>
      <li class="bulletList">Using tracking features</li>
    </ul>
    <p class="normal">Let’s start by <a id="_idIndexMarker1281"/>discussing how to prepare our project so that it can run AR Foundation apps.</p>
    <h2 id="_idParaDest-247" class="heading-2">Creating an AR Foundation project</h2>
    <p class="normal">Something to consider<a id="_idIndexMarker1282"/> when creating AR projects is that we will not only change the way we code our game, but also the game design aspect. AR apps have differences, especially in the way the user interacts, and also limitations, such as the user being in control of the camera all the time. We cannot simply port an existing game to AR without changing the very core experience of the game. That’s why, in this chapter, we are going to work on a brand-new project; it would be too difficult to change the game we’ve created so far so that it works well in AR.</p>
    <p class="normal">In our case, we are going to create a game where the user controls a player moving a “marker,” a physical image you can print that will allow our app to recognize where the player is in the real world. We will be able to move the player while moving that image, and this virtual player will automatically shoot at the nearest enemy. Those enemies will spawn from certain spawn points that the user will need to place in different parts of the home. As an example, we can put two spawn points on the walls and place our player marker on a table in the middle of the room so that the enemies will go toward them. In the following image, you can see a preview of what the game will look like:</p>
    <figure class="mediaobject"><img src="../Images/B18585_20_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.1: Finished game. The Cylinder is an enemy spawner, the Capsule is the enemy, and the Cube is the player. These are positioned in a marker image displayed by the cellphone</p>
    <p class="normal">We’ll start creating a new URP-based project in the same manner we created our first game. Something to consider is that AR Foundation works with other pipelines, including built-in ones, in case you want to use it in already existing projects. If you don’t remember how to create a project, please refer to <em class="chapterRef">Chapter 1</em>, <em class="italic">Creating a Unity Project</em>.</p>
    <p class="normal">Once you’re in your new blank project, install the AR Foundation package from the Package Manager, just like we’ve installed other packages previously—that is, from <strong class="screenText">Window</strong> | <strong class="screenText">Package Manager</strong>. Remember to set the Package Manager so that it shows all packages, not only the ones in the project (the <strong class="screenText">Packages</strong> button at the top-left part of the window needs to be set to <strong class="screenText">Unity Registry</strong>) and also the preview versions (click on the wheel icon, then <strong class="screenText">Project Settings</strong>, and check <strong class="screenText">Enable Pre-release Packages</strong> on the window that appears).</p>
    <p class="normal">At the time of<a id="_idIndexMarker1283"/> writing this book, the latest stable release is 4.2.3, but we are going to explore the 5.0.0 preview 13 version. Remember to open the package version list by clicking the triangle button at the left to see the preview versions. If you find a newer version than mine, you can try using that one, but as usual, if something works differently from what we want, please install 5.0.0-pre.13. As usual, if a warning prompting you to enable the new input system appears, click <strong class="screenText">Yes</strong>:</p>
    <figure class="mediaobject"><img src="../Images/B18585_20_02.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.2: Installing AR Foundation</p>
    <p class="normal">Before we install any other needed packages, now is a good moment to discuss some core ideas of the AR Foundation framework. This package, by itself, does nothing; it defines a series of AR features that mobile devices offer, such as image tracking, cloud points, and object tracking, but the actual implementation of how to do that is contained in the <strong class="screenText">Provider</strong> packages, such as <strong class="screenText">Apple ARKit XR Plugin</strong> and <strong class="screenText">Google ARCore XR plugin</strong> packages. This is designed like this because, depending on the target device you want to work with, the way those features are implemented changes. As an example, in iOS, Unity implements those features using AR Kit, while in Android, it uses AR Core; they are platform-specific frameworks. Remember to install the same version of these platform packages as the AR Foundation one (5.0.0 preview 13 in this case).</p>
    <p class="normal">Something to consider here is that not all iOS or Android devices support AR Foundation apps. You might find an updated list of supported devices when searching for AR Core- and AR Kit-supported devices on the internet. At the time of writing, the following links provide the supported devices lists:</p>
    <ul>
      <li class="bulletList"><strong class="keyWord">iOS</strong>: <a href="https://www.apple.com/lae/augmented-reality"><span class="url">https://www.apple.com/lae/augmented-reality</span></a> (at the <a id="_idIndexMarker1284"/>bottom of the page)</li>
      <li class="bulletList"><strong class="keyWord">Android</strong>: <a href="https://developers.google.com/ar/devices"><span class="url">https://developers.google.com/ar/devices</span></a></li>
    </ul>
    <p class="normal">Also, there isn’t a <a id="_idIndexMarker1285"/>PC Provider package, so the only way to test AR Foundation apps so far is directly on the device, but testing tools are going to be released soon. In my case, I will be creating an app for iOS, so aside from the <strong class="screenText">AR Foundation</strong> package, I need to install the <strong class="screenText">ARKit XR</strong> plugin.</p>
    <p class="normal">However, if you<a id="_idIndexMarker1286"/> want to develop for Android, install the <strong class="screenText">ARCore XR</strong> plugin instead (or both if you’re targeting both platforms). Also, I will be using the 4.1.7 version of these packages. Usually, the versions of the <strong class="screenText">AR Foundation</strong> and <strong class="screenText">Provider</strong> packages match but apply the same logic as when you picked the <strong class="screenText">AR Foundation</strong> version. In the following screenshot, you can see the <strong class="screenText">ARKit </strong>package in the <strong class="screenText">Package Manager</strong>:</p>
    <p class="normal">Now that we have the needed plugins, we need to prepare a scene for AR, as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a new Scene in <strong class="screenText">File | New Scene</strong> and select the <strong class="screenText">Basic (URP)</strong> template.</li>
      <li class="numberedList">Delete <strong class="screenText">Main Camera</strong>; we are going to use a different one.</li>
      <li class="numberedList">In the <strong class="screenText">GameObject | XR</strong> menu, create an <strong class="screenText">AR Session</strong> GameObject.</li>
      <li class="numberedList">In the same menu, create an <strong class="screenText">XR Origin (Mobile AR)</strong> object that has a <strong class="screenText">Camera</strong> inside it.</li>
      <li class="numberedList">Select the Main Camera inside <strong class="screenText">XR Origin</strong>.</li>
      <li class="numberedList">Set the <strong class="screenText">Render Mode</strong> property of the <strong class="screenText">AR Camera Manager</strong> component to <strong class="screenText">After Opaques</strong>. This is a workaround for a bug that prevents the camera from being rendered properly in another mode in the current versions.</li>
      <li class="numberedList">Your hierarchy should look as follows:<p class="packt_figref"><img src="../Images/B18585_20_03.png" alt=""/></p>
      </li>
    </ol>
    <p class="packt_figref">Figure 20.3: Starter AR Scene</p>
    <p class="normal">The <strong class="screenText">AR Session</strong> object will be responsible for initializing AR Framework and will handle all the update logic for the AR systems. The <strong class="screenText">XR Origin</strong> object will allow the framework to locate tracked objects such as images and point clouds in a relative position to the scene. The devices inform the positions of tracked objects relative to what the device considers “the origin.” This is usually the first area of your house you were pointing at when the app started detecting objects, so the <strong class="screenText">XR Origin</strong> object will represent that point in your physical <a id="_idIndexMarker1287"/>space. Finally, you can check the camera inside the origin, which contains some extra components, with the most important being <strong class="screenText">Tracked Pose Driver</strong>, which will make your <strong class="screenText">Camera</strong> object move along with your device. Since the device’s position is relative to the Session Origin object’s point, the camera needs to be inside the origin object.</p>
    <p class="normal">One extra step in case you are working on a URP project (our case) is that you need to set up the render pipeline so that it supports rendering the camera image in the app. To do that, go to the <code class="inlineCode">Settings</code> folder that was generated when we created the project, look for the <code class="inlineCode">URP-HighFidelity-Renderer</code> file, and select it. In the <strong class="screenText">Renderer Features</strong> list, click the <strong class="screenText">Add Renderer Feature</strong> button and select <strong class="screenText">AR Background Renderer Feature</strong>. In the following screenshot, you can see what the Forward Renderer asset should look like:</p>
    <figure class="mediaobject"><img src="../Images/B18585_20_04.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.4: Adding support for URP</p>
    <p class="normal">And that’s all! We <a id="_idIndexMarker1288"/>are ready to start exploring the AR Foundation components so that we can implement tracking features.</p>
    <h2 id="_idParaDest-248" class="heading-2">Using tracking features</h2>
    <p class="normal">For our project, we <a id="_idIndexMarker1289"/>are going to need two of the most common tracking features in AR (but not the only ones): image recognition and plane detection. The first one consists of detecting the position in the real world of a specific image so that we can place digital objects on top of it, such as the player. The second one, plane detection, consists of recognizing real-life surfaces, such as floors, tables, and walls, so that we have a reference of where we can put objects, such as the enemy’s spawn points. Only horizontal and vertical surfaces are recognized (just vertical surfaces on some devices).</p>
    <p class="normal">The first thing we need to do is tell our app which images it needs to detect, as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add an image to the project that you can print or display on a mobile device. Having a way to display the image in the real world is necessary to test this. In this case, I will use the following image:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_05.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.5: Image to track</p>
    <div class="note">
      <p class="normal">Try to get an image that contains as many features as you can. This means an image with lots of little details, such as contrasts, sharp corners, and so on. Those are what our AR systems use to detect it; the more detail, the better the recognition. If your device has trouble detecting our current image, try other images (the classic QR code might help).</p>
    </div>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Consider that some devices might have trouble with certain images, such as the image suggested in this book. If this generates issues when testing, please try using another one. You will be testing this on your device in the upcoming sections of this <a id="_idIndexMarker1290"/>chapter, so just keep this in mind.</li>
      <li class="numberedList">Create a <strong class="screenText">Reference Image Library</strong>, an asset containing all the images we wish our app to recognize, by clicking the <strong class="screenText">+</strong> button in <strong class="screenText">Project Panel</strong> and selecting <strong class="screenText">XR | Reference Image Library</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_06.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.6: Creating a Reference Image Library</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Select the <strong class="screenText">Reference Image Library</strong> asset we created and click the <strong class="screenText">Add Image</strong> button to add a new image to the library.</li>
      <li class="numberedList">Drag the texture to the texture slot (the one that says <strong class="screenText">None</strong>).</li>
      <li class="numberedList">Turn <strong class="screenText">Specify Size</strong> on and set <strong class="screenText">Physical Size</strong> to the size that your image will be printed in real life, in meters. Try to be accurate here; on some devices not having this value right might result in the image not being tracked:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_07.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.7: Adding an image to be recognized</p>
    <p class="normal">Now that we’ve specified the images to be detected, let’s test this by placing a cube on top of the real-life image:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a Prefab of a cube and add the <strong class="screenText">AR Tracked Image</strong> component to it.</li>
      <li class="numberedList">Remember to set a small scale, like 0.1, on each axis, given that the default cube will be 1 meter by 1 meter, which will be huge in AR.</li>
      <li class="numberedList">Add the <strong class="screenText">AR Tracked Image Manager</strong> component to the <strong class="screenText">XR Origin </strong>object. This will be<a id="_idIndexMarker1291"/> responsible for detecting images and creating objects in its position.</li>
      <li class="numberedList">Drag the <strong class="screenText">Image Library</strong> asset created in the previous steps to the <strong class="screenText">Serialized Library</strong> property of the component to specify the images to recognize.</li>
      <li class="numberedList">Drag the <strong class="screenText">Cube</strong> Prefab to the <strong class="screenText">Tracked Image Prefab</strong> property of the component:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_08.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.8: Setting up the Tracked Image Manager</p>
    <p class="normal">And that’s all! Later in the <em class="italic">Building for mobile</em> section in this chapter, when we will create an iOS or Android build, we will see a cube spawning in the same position that the image is located in the real world. Remember that you need to test this in the device, which we will do in the next section, so for now, let’s keep coding our test app:</p>
    <figure class="mediaobject"><img src="../Images/B18585_20_01.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.9: Cube located on top of the image being displayed by the cellphone</p>
    <p class="normal">Let’s also prepare our app so that it can detect and display the plane surfaces the camera has recognized. This is simply done by adding the <strong class="screenText">AR Plane Manager</strong> component to the <strong class="screenText">XR Origin </strong>object. </p>
    <figure class="mediaobject"><img src="../Images/B18585_20_10.png" alt="Graphical user interface, text, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.10: Adding the AR Plane Manager component</p>
    <p class="normal">This component will<a id="_idIndexMarker1292"/> detect surface planes over our house as we move the camera over it. It can take a while to detect them, so it’s important to visualize the detected areas to get feedback about this to ensure it’s working properly. We can manually get information about the plane from a component reference to the AR Plane Manager, but luckily, Unity allows us to visualize planes easily. Let’s take a look:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a Prefab of a plane, first by creating the plane in <strong class="screenText">GameObject | 3D Object | Plane</strong>.</li>
      <li class="numberedList">Add a <strong class="screenText">Line Renderer</strong> to it. This will allow us to draw a line over the edges of the detected areas.</li>
      <li class="numberedList">Set the <strong class="screenText">Width</strong> property of <strong class="screenText">Line Renderer</strong> to a small value such as <code class="inlineCode">0.01</code>, the <strong class="screenText">Color</strong> gradient property to black, and uncheck <strong class="screenText">Use World Space</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_11.png" alt="Graphical user interface  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.11: Setting the Line Renderer</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Remember to create a material with the proper shader (<strong class="screenText">Universal Render Pipeline/Unlit</strong>) and set it as the material of the <strong class="screenText">Line Renderer</strong> component under the <strong class="screenText">Materials</strong> list property:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_12.png" alt="Graphical user interface, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.12: Creating the Line Renderer material</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Also, create a<a id="_idIndexMarker1293"/> transparent material and use it in the <strong class="screenText">MeshRenderer</strong> plane. We want to see through it so that we can easily see the real surface beneath:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_13.png" alt="Graphical user interface, text, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.13: Material for the detected plane</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Add the <strong class="screenText">AR Plane</strong> and <strong class="screenText">AR Plane Mesh Visualizer</strong> components to the <strong class="screenText">Plane</strong> Prefab.</li>
      <li class="numberedList">Drag the Prefab to the <strong class="screenText">Plane Prefab</strong> property of the <strong class="screenText">AR Plane Manager</strong> component of the <strong class="screenText">XR Origin </strong>object:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_14.png" alt="Graphical user interface, text, application, chat or text message  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.14: Setting the plane visualization Prefab</p>
    <p class="normal">Now, we have a way to see the planes, but seeing them is not the only thing we can do (sometimes, we don’t even want them to be visible). The real power of planes resides in placing virtual objects on top of real-life surfaces, tapping into a specific plane area, and getting its real-life position. We can access the plane data using the <strong class="screenText">AR Plane Manager</strong> or by accessing the <strong class="screenText">AR Plane</strong> component of our visualization planes, but something easier is to use the <strong class="keyWord">AR Raycast Manager</strong> component.</p>
    <p class="normal">The <strong class="screenText">AR Raycast Manager</strong> component <a id="_idIndexMarker1294"/>provides us with the equivalent to the <code class="inlineCode">Physics.Raycast</code> function of the Unity Physics system, which, as you may recall, is used to create imaginary rays that start from one position and go toward a specified direction in order to make them hit surfaces and detect the exact hit point. The version provided by <strong class="screenText">AR Raycast Manager</strong>, instead of colliding with physics colliders, collides with tracked objects, mostly Point Clouds (we are not using them) and the “planes” we are tracking. We can test this feature by following these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Add the <strong class="screenText">AR Raycast Manager</strong> component to the <strong class="screenText">XR Origin </strong>object.</li>
      <li class="numberedList">Create a custom script called <code class="inlineCode">SpawnerPlacer</code> in the <strong class="screenText">XR Origin </strong>object.</li>
      <li class="numberedList">In the <strong class="screenText">Awake</strong> cache, add the reference to <code class="inlineCode">ARRaycastManager</code>. You will need to add the <code class="inlineCode">using UnityEngine.XR.ARFoundation;</code> line to the top of the script for this class to be usable in our script.</li>
      <li class="numberedList">Create a private field of the <code class="inlineCode">List&lt;ARRaycastHit&gt;</code> type and instantiate it; the Raycast function is going to detect every plane our ray hit, not just the first one:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_15.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.15: List to store hits</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Under <strong class="screenText">Update</strong>, check if the touch screen is pressed (<code class="inlineCode">Touchscreen.current.primaryTouch.press.isPressed</code>). You will need the <code class="inlineCode">using UnityEngine.InputSystem;</code> using at the top of the file to use the new input system.</li>
      <li class="numberedList">Inside the <code class="inlineCode">if</code> statement from the previous step, add another condition for calling the <code class="inlineCode">Raycast</code> function of <strong class="screenText">AR Raycast Manager</strong>, passing the position of the touch as the first parameter and the list of hits as the second (<code class="inlineCode">Touchscreen.current.primaryTouch.position.ReadValue()</code>).</li>
      <li class="numberedList">This will throw a Raycast toward the direction the player touches the screen and store the <a id="_idIndexMarker1295"/>hits inside the list we provided. This will return <code class="inlineCode">true</code> if something has been hit, and <code class="inlineCode">false</code> if not.</li>
      <li class="numberedList">Add a public field to specify the Prefab to instantiate in the place we touched. You can just create a Sphere Prefab and assign it to this field to test this; there’s no need to add any special component to the Prefab here. Remember to set a small scale.</li>
      <li class="numberedList">Instantiate the Prefab in the <strong class="screenText">Position</strong> and <strong class="screenText">Rotation</strong> fields of the <strong class="screenText">Pose</strong> property of the first hit stored in the list. The hits are sorted by distance, so the first hit is the closest one. Your final script should look as follows:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_16.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.16: Raycaster component</p>
    <p class="normal">In this section, we<a id="_idIndexMarker1296"/> learned how to create a new AR project using AR Foundation. We discussed how to install and set up the framework, as well as how to detect real-life image positions and surfaces, and then how to place objects on top of them.</p>
    <p class="normal">As you may have noticed, we never hit <strong class="screenText">Play</strong> to test this, and sadly at the time of writing this book, we cannot test this in the Editor. Instead, we need to test this directly on the device. Due to this, in the next section, we are going to learn how to do builds for mobile devices such as Android and iOS.</p>
    <h1 id="_idParaDest-249" class="heading-1">Building for mobile devices</h1>
    <p class="normal">Unity is a very powerful<a id="_idIndexMarker1297"/> tool that solves the most common problems in game development very easily, and one of them is building the game for several target platforms. Now, the Unity part of building our project for such devices is easy to do, but each device has its non-Unity-related nuances when installing development builds. In order to test our AR app, we need to test it directly on the device. So, let’s explore how we can make our app run on Android and iOS, the most common mobile platforms.</p>
    <p class="normal">Before diving into this topic, it is worth mentioning that the following procedures change a lot over time, so you will need to find the latest instructions on the internet. The Unity Learn portal site (<a href="https://learn.unity.com/tutorial/how-to-publish-to-android-2"><span class="url">https://learn.unity.com/tutorial/how-to-publish-to-android-2</span></a>) may be a good alternative in case the instructions in this book fail but try the steps here first.</p>
    <p class="normal">In this section, we will examine the following mobile building concepts:</p>
    <ul>
      <li class="bulletList">Building for Android</li>
      <li class="bulletList">Building for iOS</li>
    </ul>
    <p class="normal">Let’s start by discussing how to build our app so that it runs on Android phones.</p>
    <h2 id="_idParaDest-250" class="heading-2">Building for Android</h2>
    <p class="normal">Creating Android <a id="_idIndexMarker1298"/>builds is relatively easy compared to other<a id="_idIndexMarker1299"/> platforms, so we’ll start with Android. Remember that you will need an Android device capable of running AR Foundation apps, so please refer to the link regarding Android-supported devices we mentioned in the <em class="italic">Using AR Foundation </em>section of this chapter. The first thing we need to do is check if we have installed Unity’s Android support and configured our project to use that platform. To do that, follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Close Unity and open <strong class="screenText">Unity Hub</strong>.</li>
      <li class="numberedList">Go to the <strong class="screenText">Installs</strong> section and locate the Unity version you are working on.</li>
      <li class="numberedList">Click the wheel icon button at the top-right corner of the Unity version you are using and click <strong class="screenText">Add Modules</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_17.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.17: Adding modules to the Unity version</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Make sure <strong class="screenText">Android Build Support</strong> and the sub-options that are displayed when you click the arrow on its left are checked. If not, check them and click the <strong class="screenText">Continue </strong>button at the bottom-right to install them:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_18.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.18: Adding Android support to Unity</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Accept all the terms and conditions prompts by checking the <strong class="screenText">Accept Terms</strong> checkbox and clicking the <strong class="screenText">Continue</strong> button.</li>
      <li class="numberedList">Open <a id="_idIndexMarker1300"/>the AR <a id="_idIndexMarker1301"/>project we created in this chapter.</li>
      <li class="numberedList">Go to <strong class="screenText">Build Settings</strong> (<strong class="screenText">File | Build Settings</strong>).</li>
      <li class="numberedList">Select the <strong class="screenText">Android</strong> platform from the list and click the <strong class="screenText">Switch Platform</strong> button at the bottom-right part of the window:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_19.png" alt="Table  Description automatically generated with low confidence"/></figure>
    <p class="packt_figref">Figure 20.19: Switching to Android builds</p>
    <p class="normal">To build an app on Android, there are some requirements we need to meet, such as having the Java SDK (not the regular Java runtime) and Android SDK installed, but luckily, the new versions of Unity take care of that. Just to double-check that we have installed the needed dependencies, follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Go to <strong class="screenText">Unity Preferences</strong> (<strong class="screenText">Edit | Preferences</strong> on Windows or <strong class="screenText">Unity | Preferences</strong> on Mac).</li>
      <li class="numberedList">Click <strong class="screenText">External Tools</strong>.</li>
      <li class="numberedList">Check that all the options that say <strong class="screenText">…Installed with Unity</strong> on the Android section are checked. This means we will be using all the dependencies installed by Unity:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_20.png" alt="A picture containing text, newspaper, screenshot, document  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.20: Using installed dependencies</p>
    <p class="normal">There are <a id="_idIndexMarker1302"/>some<a id="_idIndexMarker1303"/> additional Android ARCore-specific related settings to check that you can find at <a href="https://developers.google.com/ar/develop/unity-arf/quickstart-android"><span class="url">https://developers.google.com/ar/develop/unity-arf/quickstart-android</span></a>. These can change if you are using newer versions of AR Core. You can apply them by following these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Go to <strong class="screenText">Player Settings</strong> (<strong class="screenText">Edit | Project Settings | Player</strong>).</li>
      <li class="numberedList">Uncheck <strong class="screenText">Multithreaded Rendering</strong> and <strong class="screenText">Auto Graphics API</strong> from the <strong class="screenText">Other Settings</strong> section.</li>
      <li class="numberedList">Remove <strong class="screenText">Vulkan</strong> from the <strong class="screenText">Graphics APIs</strong> list if it’s there.</li>
      <li class="numberedList">Set <strong class="screenText">Minimum API Level</strong> to <strong class="screenText">Android 7.0</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_21.png" alt="Graphical user interface, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.21: AR Core settings</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">Set the Scripting Backend to <strong class="screenText">IL2CPP</strong>.</li>
      <li class="numberedList">Check the <strong class="screenText">ARM64</strong> checkbox to give support to Android 64-bit devices.</li>
      <li class="numberedList">Check <strong class="screenText">Override Default Bundle Identifier</strong> and <a id="_idIndexMarker1304"/>set something<a id="_idIndexMarker1305"/> custom, like <code class="inlineCode">com.MyCompany.MyARApp</code>.</li>
      <li class="numberedList">Go to <strong class="screenText">Edit | Project Settings</strong> and select the <strong class="screenText">XR Plug-in Management</strong> option.</li>
      <li class="numberedList">Check <strong class="screenText">Google ARCore</strong> under <strong class="screenText">Plug-in Providers</strong> to make sure it will be enabled in our build; if not we won’t see anything:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_22.png" alt="Graphical user interface, text, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.22: ARCore plugin enabled</p>
    <p class="normal">Now, you can finally build the app from <strong class="screenText">File | Build Settings</strong> like usual, by using the <strong class="screenText">Build</strong> button. This time, the output will be a single APK file that you can install by copying the file to your device and opening it. Remember that in order to install APKs that weren’t downloaded from the Play Store, you need to set your device to allow <strong class="screenText">Install Unknown Apps</strong>. The location for that option varies a lot, depending on the Android version and the device you are using, but this option is usually located in the <strong class="screenText">Security</strong> settings. Some Android versions prompt you to view these settings when installing the APK.</p>
    <p class="normal">Now, we can copy and install the generated APK build file every time we want to create a build. However, we<a id="_idIndexMarker1306"/> can let Unity do that for us using the <strong class="screenText">Build and Run</strong> button. This option, after building the app, will look for the first Android device connected to your computer via USB and will automatically install the app. For this to work, we need to prepare our device and PC, as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">On your device, find the build number in the <strong class="screenText">Settings</strong> section of the device, whose location, again, can change depending on the device. On my device, it is located in the <strong class="screenText">About Phone | Software Information</strong> section:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_23.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.23: Locating the build number</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Tap it a few times<a id="_idIndexMarker1307"/> until the device says you are <a id="_idIndexMarker1308"/>now a programmer. This procedure enables the hidden developer option in the device, which you can now find in the settings.</li>
      <li class="numberedList">Open the developer options and turn on <strong class="screenText">USB Debugging</strong>, which allows your PC to have special permissions on your device. In this case, it allows you to install apps.</li>
      <li class="numberedList">Install the USB drivers from your phone manufacturer’s site onto your computer if using Windows. For example, if you have a Samsung device, search for <code class="inlineCode">Samsung USB Driver</code>. Also, if you can’t find that, you can look for <code class="inlineCode">Android USB Driver</code> to get the generic drivers, but that might not work if your device manufacturer has their own. On Mac, this step is usually not necessary.</li>
      <li class="numberedList">Connect your device (or reconnect it if it’s already connected). The option to <strong class="screenText">Allow USB Debugging</strong> for your computer will appear on the device. Check <strong class="screenText">Always Allow</strong> and click <strong class="screenText">OK</strong>:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_24.png" alt="Enabling USB Debugging on an Android Device"/></figure>
    <p class="packt_figref">Figure 20.24: Allowing USB debugging</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Accept the <strong class="screenText">Allow Data</strong> prompt that appears.</li>
      <li class="numberedList">If these options don’t appear, check that the <strong class="screenText">USB Mode</strong> of your device is set to <strong class="screenText">Debugging</strong> and not any other.</li>
      <li class="numberedList">In Unity, build with the <strong class="screenText">Build and Run</strong> button, and save the <code class="inlineCode">apk</code> into a folder. Be patient because this will take a while the first time.</li>
    </ol>
    <div class="note">
      <p class="normal">Please remember to try another image if you have trouble detecting the image where we instantiate the player (the Unity logo, in my case). This might vary a lot, according to your device’s capabilities.</p>
    </div>
    <p class="normal">And that’s all! Now <a id="_idIndexMarker1309"/>that you have your app running on your <a id="_idIndexMarker1310"/>device, let’s learn how to do the same for the iOS platform. </p>
    <h2 id="_idParaDest-251" class="heading-2">Building for iOS</h2>
    <p class="normal">When<a id="_idIndexMarker1311"/> developing <a id="_idIndexMarker1312"/>on iOS, you will need to spend some money. You will need to run XCode, a piece of software you can only run on macOS X. Due to this, you’ll need a device that can run it, such as a MacBook, a Mac mini, and so on. There may be ways to run macOS X on PCs, but you will need to find this out and try it for yourself. Besides spending on a Mac and an iOS device (iPhone, iPad, iPod, and so on), you’ll need to pay for an Apple Developer account, which costs 99 USD per year, but only if you are planning to release the game; for testing purposes, you can continue without it.</p>
    <p class="normal">To create an AR Foundation iOS build, you should do the following:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Get a Mac computer and an iOS device.</li>
      <li class="numberedList">Create an Apple Developer account (at the time of writing this book, you can create one at <a href="https://developer.apple.com/"><span class="url">https://developer.apple.com/</span></a>).</li>
      <li class="numberedList">Install the latest XCode from the App Store onto your Mac.</li>
      <li class="numberedList">Check if you have iOS build support in Unity Install on the Unity Hub. Please refer to the <em class="italic">Building for Android</em> section for more information about this step.</li>
      <li class="numberedList">Switch to the iOS<a id="_idIndexMarker1313"/> platform under <strong class="screenText">Build Settings</strong>, by<a id="_idIndexMarker1314"/> selecting iOS and clicking the <strong class="screenText">Switch Platform</strong> button:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_25.png" alt="Graphical user interface, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.25: Switching to iOS build</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Go to <strong class="screenText">Edit | Project Settings</strong> and select the <strong class="screenText">Player</strong> option.</li>
      <li class="numberedList">In <strong class="screenText">Other Settings</strong>, set the <strong class="screenText">Camera Usage Description</strong> property if not already. This will be a message shown to the user to tell them why we need access to their camera:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_26.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.26: Message regarding camera usage</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="8">Go to <strong class="screenText">Edit | Project Settings</strong> and select the <strong class="screenText">XR Plug-in Management</strong> option.</li>
      <li class="numberedList">Check <strong class="screenText">Apple ARKit</strong> under <strong class="screenText">Plug-in Providers</strong> to make sure it will be enabled in our build; if not, we won’t see anything:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_27.png" alt="Graphical user interface, text, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.27: ARKit plugin enabled</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="10">Click the <strong class="screenText">Build</strong> button in the <strong class="screenText">Build Settings</strong> window, create a folder for the build, and wait for the build to finish. A folder containing the generated files should open when finished.</li>
    </ol>
    <p class="normal">You will notice that the result of the build process will be a folder containing an XCode project. Unity cannot create the build directly, so it generates a project you can open with the XCode software we mentioned previously. The step you need to follow to create a build with<a id="_idIndexMarker1315"/> the XCode version being used in this book (13.4.1) are<a id="_idIndexMarker1316"/> as follows:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Double-click the <code class="inlineCode">.xcodeproj</code> file inside the generated folder:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_28.png" alt="Graphical user interface, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.28: XCode project file</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Go to <strong class="screenText">XCode | Preferences</strong>.</li>
      <li class="numberedList">In the <strong class="screenText">Accounts</strong> tab, hit the <strong class="screenText">+</strong> button at the bottom-left part of the window and log in with the Apple account you registered as an Apple developer:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_29.png" alt="Graphical user interface, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.29: Account settings</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Connect your device and select it from the top-left part of the window, which should now say <strong class="screenText">Any iOS device</strong>. You might need to unblock your device first, click on the <strong class="screenText">Trust</strong> button, and wait for XCode to finish setting up your device to see your device in the list:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_30.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.30: Selecting the device</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="5">XCode might<a id="_idIndexMarker1317"/> ask you to install certain updates to support<a id="_idIndexMarker1318"/> your device; please install them if needed.</li>
      <li class="numberedList">In the left panel, click the folder icon and then the <strong class="screenText">Unity-iPhone</strong> settings to display the project settings.</li>
      <li class="numberedList">From the <strong class="screenText">TARGETS</strong> list, select <strong class="screenText">Unity-iPhone</strong> and click on the <strong class="screenText">Signing &amp; Capabilities</strong> tab.</li>
      <li class="numberedList">Check <strong class="screenText">Automatically manage signing</strong> and click on the <strong class="screenText">Enable Automatic</strong> button on the prompt.</li>
      <li class="numberedList">In the <strong class="screenText">Team</strong> settings, select the option that says <strong class="screenText">Personal Team</strong>.</li>
      <li class="numberedList">If you see a <strong class="screenText">Failed to register bundle identifier</strong> error, just change the <strong class="screenText">Bundle Identifier</strong> setting for another one, always respecting the format (<code class="inlineCode">com.XXXX.XXXX</code>), and then click on <strong class="screenText">Try Again</strong> until it is solved. </li>
    </ol>
    <p class="numberedList">Once you find one that works, set it in Unity (<strong class="screenText">Bundle Identifier</strong> under <strong class="screenText">Player Settings</strong>) to avoid needing to change it in every build:</p>
    <figure class="mediaobject"><img src="../Images/B18585_20_31.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.31: Setting up your iOS project</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="11">Hit the <strong class="screenText">Play</strong> button at the top-left part of the window and wait for the build to complete. You might be prompted to enter your password a couple of times in the process, so please do so.</li>
      <li class="numberedList">When the build completes, remember to unlock the device. A prompt will ask you to do that. Note that the process won’t continue unless you unlock the phone. If that fails click <strong class="screenText">Cancel Running</strong> and try again, this time with the device <a id="_idIndexMarker1319"/>unlocked; remember to select your device <a id="_idIndexMarker1320"/>in the list again. Also, try to use the latest XCode available to support the latest iOS versions installed on your device.</li>
      <li class="numberedList">If you see a <strong class="screenText">Fetching Debug Symbols</strong> prompt that never ends, restart your device.</li>
      <li class="numberedList">After completion, you may see an error saying that the app couldn’t be launched but that it was installed anyway. If you try to open it, it will say you need to trust the developer of the app, which you can do by going to the settings of your device.</li>
      <li class="numberedList">From there, go to <strong class="screenText">General | VPN &amp; Device Management</strong> and select the first developer in the list.</li>
      <li class="numberedList">Click the blue <strong class="screenText">Trust…</strong> button and then <strong class="screenText">Trust</strong>.</li>
      <li class="numberedList">Try to open the app again.</li>
      <li class="numberedList">Please remember to try another image if you’re having trouble detecting the image where we instantiate the player (the pebbles image, in my case). This might vary a lot, depending on your device’s capabilities.</li>
    </ol>
    <p class="normal">In this section, we discussed how to build a Unity project that can run on iOS and Android, thus allowing us to create mobile apps—AR mobile apps, specifically. Like any build, there are methods we can follow to profile and debug, as we saw when we looked at PC builds, but we are not going to discuss that here. Now that we have created our first test project, we<a id="_idIndexMarker1321"/> will convert it into a real game by adding some <a id="_idIndexMarker1322"/>mechanics to it.</p>
    <h1 id="_idParaDest-252" class="heading-1">Creating a simple AR game</h1>
    <p class="normal">As we discussed <a id="_idIndexMarker1323"/>previously, the idea is to create a simple game where we can move our player while moving a real-life image, and also put in some enemy spawners by just tapping where we want them to be, such as a wall, the floor, a table, and so on. Our player will automatically shoot at the nearest enemy, and the enemies will shoot directly at the player, so our only task will be to move the player so that they avoid bullets. We are going to implement these game mechanics using scripts very similar to the ones we used in this book’s main project.</p>
    <p class="normal">In this section, we will develop the following AR game features:</p>
    <ul>
      <li class="bulletList">Spawning the player and enemies</li>
      <li class="bulletList">Coding the player and enemy behavior</li>
    </ul>
    <p class="normal">First, we are going to discuss how to make our player and enemies appear on the app, specifically in real-world positions, and then we will make them move and shoot each other to create the specified gameplay mechanics. Let’s start with <strong class="keyWord">spawning</strong>.</p>
    <h2 id="_idParaDest-253" class="heading-2">Spawning the player and enemies</h2>
    <p class="normal">The first thing we <a id="_idIndexMarker1324"/>need to do in order to implement our<a id="_idIndexMarker1325"/> game’s gameplay is to spawn objects to interact with. Let’s start with the player, since that’s the easiest one to deal with: we will create a Prefab with the graphics we want the player to have (in my case, just a cube), a <code class="inlineCode">Rigidbody</code> with <strong class="screenText">Is Kinematic</strong> checked (the player will move), and an <strong class="screenText">AR Tracked Image</strong> script. We will set that Prefab as them <strong class="screenText">Tracked Image Prefab</strong> of the <strong class="screenText">AR Tracked Image Manager</strong> component in the <strong class="screenText">XR Origin </strong>object. This will put the player on the tracked image. Remember to set the size of the player in terms of real-life sizes. In my case, I scaled the player to <code class="inlineCode">0.05</code>, <code class="inlineCode">0.05</code>, <code class="inlineCode">0.05</code>. Since the original cube is 1 meter in size, this means that my player will be <em class="italic">5x5x5</em> centimeters. </p>
    <p class="normal">Your <strong class="screenText">Player</strong> Prefab should look as follows:</p>
    <figure class="mediaobject"><img src="../Images/B18585_20_32.png" alt="Graphical user interface, application  Description automatically generated"/></figure>
    <p class="packt_figref">Figure 20.32: The starting “Player” Prefab</p>
    <p class="normal">The enemies will require <a id="_idIndexMarker1326"/>a little bit more work, as shown here:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a Prefab<a id="_idIndexMarker1327"/> called <code class="inlineCode">Spawner</code> with the graphic you want your spawner to have (in my case, a cylinder) and its real-life size (small scale).</li>
      <li class="numberedList">Add a custom script that spawns a Prefab every few seconds, such as the one shown in the following screenshot. </li>
      <li class="numberedList">You will notice the usage of <code class="inlineCode">Physics.IgnoreCollision</code> to prevent the <code class="inlineCode">Spawner</code> GameObject from colliding with the spawned GameObject, getting the colliders of both objects, and passing them to the function. You can also use the <strong class="keyWord">Layer Collision Matrix </strong>to prevent collisions, just like we did in this book’s main project, if you prefer to:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_33.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.33: Spawner script</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Create an <code class="inlineCode">Enemy</code> Prefab<a id="_idIndexMarker1328"/> with the desired graphic (a capsule, in my case) and a <code class="inlineCode">Rigidbody</code> component with the <strong class="screenText">Is Kinematic</strong> checkbox checked. This way, the enemy will move but not with physics. Remember to consider the real-life size of the enemy.</li>
      <li class="numberedList">Set the <strong class="screenText">Prefab</strong> property of the Spawner so that it spawns our enemy at our desired time frequency:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_34.png" alt="Graphical user interface, text, application  Description automatically generated"/> </figure>
    <p class="packt_figref">Figure 20.34: Configuring the Spawner</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Set the Prefab of <code class="inlineCode">SpawnerPlacer</code> in the XR Origin object so that it spawns the <strong class="screenText">Spawner</strong> Prefab we created earlier.</li>
    </ol>
    <p class="normal">And that’s all for the first part. If you test the game now, you will be able to tap on the detected planes in the app and see how the Spawner starts creating enemies. You can also look at the<a id="_idIndexMarker1329"/> target image and see our cube player appear. </p>
    <p class="normal">Now that we have the objects in the scene, let’s make them do something more interesting, starting with the enemies.</p>
    <h2 id="_idParaDest-254" class="heading-2">Coding the player and enemy behavior</h2>
    <p class="normal">The Enemy must <a id="_idIndexMarker1330"/>move toward the player in order to shoot at them, so it will need to have access to the player’s position. Since the enemy is instantiated, we cannot drag the player reference to the Prefab. However, the player has also been instantiated, so we can add a <code class="inlineCode">PlayerManager</code> script to the player that uses the <code class="inlineCode">Singleton</code> pattern (as we did in <em class="chapterRef">Chapter 8</em>, <em class="italic">Win and Lose Conditions</em>). </p>
    <p class="normal">To do that, follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a <code class="inlineCode">PlayerManager</code> script similar to the one shown in the following screenshot and add it to the player:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_35.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.35: Creating the PlayerManager script</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Now that the enemy has a reference to the player, let’s make them look at the player by adding a <code class="inlineCode">LookAtPlayer</code> script, as shown here:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_36.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.36: Creating the LookAtPlayer script</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">Also, add a simple <code class="inlineCode">MoveForward</code> script like the one shown in the following screenshot to <a id="_idIndexMarker1331"/>make the <strong class="keyWord">enemy</strong> not only look at the player but also move toward them. Since the <code class="inlineCode">LookAtPlayer</code> script is making the enemy face the player, this script moving along the <em class="italic">Z </em>axis is just enough:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_37.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.37: Creating the MoveForward script</p>
    <p class="normal">Now, we will take care of the player movement. Remember that our player is controlled by moving the image, so here, we are actually referring to the rotation, since the player will need to automatically look and shoot at the nearest enemy. To do this, follow these steps:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create an <code class="inlineCode">Enemy</code> script and add it to the <strong class="screenText">Enemy</strong> Prefab.</li>
      <li class="numberedList">Create an <code class="inlineCode">EnemyManager</code> script like the one shown in the following screenshot and add it to an empty <code class="inlineCode">EnemyManager</code> object in the scene:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_38.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.38: Creating the EnemyManager script</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="3">In the <code class="inlineCode">Enemy</code> script, make<a id="_idIndexMarker1332"/> sure to register the object in the <strong class="keyWord">all</strong> list of <code class="inlineCode">EnemyManager</code>, as we did previously with <code class="inlineCode">WavesManager</code> in this book’s main project:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_39.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.39: Creating the Enemy script</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="4">Create a <code class="inlineCode">LookAtNearestEnemy</code> script like the one shown in the following screenshot and add it to the <strong class="screenText">Player</strong> Prefab to make it look at the nearest enemy:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_40.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.40: Looking at the nearest Enemy</p>
    <p class="normal">Now that our objects<a id="_idIndexMarker1333"/> are rotating and moving as expected, the only thing missing is shooting and damaging:</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="1">Create a <code class="inlineCode">Life</code> script like the one shown in the following screenshot and add it to both the <strong class="screenText">Player</strong> and <strong class="screenText">Enemy</strong> components. Remember to set a value for the amount of life field. You will see this version of <code class="inlineCode">Life</code> instead of needing to check if the life reached zero every frame. We have created a <code class="inlineCode">Damage</code> function to check that damage is dealt (the <code class="inlineCode">Damage</code> function is executed), but the other version of this book’s project also works:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_41.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.41: Creating a Life component</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="2">Create a <code class="inlineCode">Bullet</code> Prefab with the desired graphics, the collider with the <strong class="screenText">Is Trigger</strong> checkbox on the collider checked, a <code class="inlineCode">Rigidbody</code> component with <strong class="screenText">Is Kinematic</strong> checked (a <a id="_idIndexMarker1334"/>kinematic trigger collider), and the proper real-life size.</li>
      <li class="numberedList">Add the <code class="inlineCode">MoveForward</code> script to the <strong class="screenText">Bullet</strong> Prefab to make it move. Remember to set the speed.</li>
      <li class="numberedList">Add a <code class="inlineCode">Spawner</code> script to both the <strong class="screenText">Player</strong> and the <strong class="screenText">Enemy</strong> components and set the <strong class="screenText">Bullet</strong> Prefab as the Prefab to spawn, as well as the desired spawn frequency.</li>
      <li class="numberedList">Add a <code class="inlineCode">Damager</code> script like the one shown in the following screenshot to the <strong class="screenText">Bullet</strong> Prefab to make bullets inflict damage on the objects they touch. Remember to set the damage:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_42.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.42: Creating a Damager script – part 1</p>
    <ol class="numberedList" style="list-style-type: decimal;">
      <li class="numberedList" value="6">Add an <code class="inlineCode">AutoDestroy</code> script like the one shown in the following screenshot to the <strong class="screenText">Bullet</strong> Prefab <a id="_idIndexMarker1335"/>to make it despawn after a while. Remember to set the destroy time:</li>
    </ol>
    <figure class="mediaobject"><img src="../Images/B18585_20_43.png" alt=""/></figure>
    <p class="packt_figref">Figure 20.43: Creating a Damager script – part 2</p>
    <p class="normal">And that’s all! As you can see, we basically created a new game using almost the same scripts we used<a id="_idIndexMarker1336"/> in the main game, mostly because we designed them to be generic (and the game genres are almost the same). Of course, this project can be improved a lot, but we have a nice base project to create amazing AR apps.</p>
    <h1 id="_idParaDest-255" class="heading-1">Summary</h1>
    <p class="normal">In this chapter, we introduced the AR Foundation Unity framework, explored how to set it up, and how to implement several tracking features so that we can position virtual objects on top of real-life objects. We also discussed how to build our project so that it can run on both iOS and Android platforms, which is the only way we can test our AR apps at the time of writing. Finally, we created a simple AR game based on the game we created in the main project but modified it so that it’s suitable for use in AR scenarios. </p>
    <p class="normal">With this new knowledge, you will be able to start your path as an AR app developer, creating apps that augment real objects with virtual objects by detecting the positions of the real objects. This can be applied to games, training apps, and simulations. You may even be able to find new fields of usage, so take advantage of this new technology and its new possibilities!</p>
    <p class="normal">Well, this is the end of this journey through Unity 2022. I’m really glad you reached this point in the book. I hope this knowledge will help you to improve or start your game development career with one of the most versatile and powerful tools on the market: Unity. I hope to see your creations someday! See you on the road!</p>
  </div>
</body></html>