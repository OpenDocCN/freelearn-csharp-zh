- en: Chapter 8. Customizing the Unity Editor
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The Unity Editor is a powerful, general purpose game development tool. Nevertheless,
    there are times during development when you probably wished the editor offered
    a specific feature that it doesn't have or behaved in a particular way, simply
    because it would be more convenient for you and your specific game. Maybe you'd
    like the path editing features, batch renaming functionality, or mesh creation
    tools, among others. In such cases, you can search the Asset Store for add-ons
    that meet your needs. But even then, you may still not find what you need. Consequently,
    the focus then turns to how the editor can be adapted or customized to achieve
    your purpose. Thankfully, there are many ways Unity can be changed as a tool,
    and this chapter focuses on particular case studies. First, it explores how to
    create a **Batch Rename** tool for renaming multiple selected objects in one operation.
    Second, it covers how to create a color range field in the Object Inspector to
    blend between two colors using a slider. Third, it explores how to expose public
    C# properties in the Object Inspector for both setting and getting values. Lastly,
    it covers how to use C# attributes to create a localization toolkit that allows
    you to automatically change all in-game strings to a chosen language (English,
    French, and so on) at the touch of a button.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: Batch renaming
  id: totrans-2
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating scenes with multiple enemies, power-ups, props, or other object
    instances, you'll typically use the duplicate feature to clone objects (*Ctrl*
    + *D*). This leads to many objects sharing the same name. Now, while there's nothing
    technically wrong in name duplication per se, it's both inconvenient and untidy.
    It results in a hierarchy panel of many identically named objects, and it's practically
    impossible to distinguish between specific objects by their name alone. Furthermore,
    object searches in script using the `GameObject.Find` function cannot be relied
    on to retrieve the specific object that you need, since it could return any one
    of the identically named objects. The solution, then, is to name each object uniquely
    and appropriately. But doing this can be tedious, especially if you're working
    with many objects. Thus, there's a need for a Batch Rename tool.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: 'This would, in theory, allow you to select multiple objects in the hierarchy
    panel and then to rename them automatically according to a numbered convention.
    The only technical problem with this is that Unity doesn''t natively support such
    a feature. But we can code it ourselves, as shown in the following screenshot:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
- en: '![Batch renaming](img/0655OT_08_01.jpg)'
  id: totrans-5
  prefs: []
  type: TYPE_IMG
- en: Creating a Batch Rename editor add-on
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin customizing the Unity Editor, first create a folder named `Editor`
    inside the project. This is important. `Editor` is a special folder recognized
    by Unity as a place to house all the editor customizing scripts. Thus, if you
    plan on changing the Unity Editor, be sure all customizing scripts are inside
    the `Editor` folder. It doesn''t matter whether your project features multiple
    folders named `Editor`; the only thing that matters is that there''s at least
    one `Editor` folder and an editor script inside it, as shown here:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
- en: '![Batch renaming](img/0655OT_08_02.jpg)'
  id: totrans-8
  prefs: []
  type: TYPE_IMG
- en: Create an Editor folder for all editor scripts
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
- en: Next, we'll create a Batch Rename utility from the `ScriptableWizard` class.
    This class is an ancestor from which we derive new classes. All derived classes
    will work much like a pop-up utility dialog that can be launched from the Unity
    main menu. Their purpose is to present a set of options from which the user can
    choose before pressing a confirmation button that performs a one-time process.
    In other words, classes derived from `ScriptableWizard` are ideal for performing
    automated, one-time operations on single or multiple objects.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-11
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the `ScriptableWizard` class can be found in the online
    Unity documentation at [http://docs.unity3d.com/ScriptReference/ScriptableWizard.html](http://docs.unity3d.com/ScriptReference/ScriptableWizard.html).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample 8-1 lists the complete source code for a Batch Rename
    utility:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The following are the comments for code sample 8-1:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 03**: The editor extensions should include the `UnityEditor` namespace
    that allows you to access editor classes and objects.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 06**: The `BatchRename` class derives not from `MonoBehaviour`, as with
    most script files, but from `ScriptableWizard`. Classes deriving from here will
    be treated by Unity like independent utilities that may be launched from the application
    menu.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 17-21**: The `MenuItem` attribute is prefixed to the `CreateWizard`
    function. This creates a menu entry in the application menu listed under **Edit/Batch
    Rename** and invokes the `CreateWizard` function when clicked on to display the
    **Batch Rename** window.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 8-16**: After `CreateWizard` is invoked, the `BatchRename` window shows.
    From here, all public class members (including **Base Name**, **Start Number**,
    and **Increment**) will automatically feature in the window as editable fields
    for the user.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 45-60**: The `OnWizardCreate` function is invoked as an event when
    the user presses the **Rename** button from the **Batch Rename** window. The button
    is called **Rename** in this case because of line 20\. The `OnWizardCreate` function
    iterates through all selected objects in the scene, if any, and renames them in
    sequence according to the **Base Name**, **Start Number**, and **Increment** fields,
    as shown here:![Batch renaming](img/0655OT_08_03.jpg)'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Batch Rename tool
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'To use the Batch Rename tool, just select a group of objects in the scene and
    then click on the **Batch Rename** option in **Edit** from the application menu.
    The **Base Name** field defines a string that needs to be prefixed to all object
    names, and the **Increment** field defines the amount by which an integer counter
    should increase that is prefixed to the base name. The **Start Number** value
    is the point from which all incrementing begins, as shown in the following screenshot:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: '![Batch renaming](img/0655OT_08_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
- en: Renamed objects using the Batch Rename tool
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: C# attributes and reflection
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'From this point forward in the chapter, all editor extensions will rely heavily
    on the concepts of attributes and reflection. These concepts are not specific
    to Unity but refer to more general ideas in computer science, programming, and
    to their application in languages such as C# as well as in the .NET framework.
    Before proceeding to the next editor extension, let''s consider attributes and
    the related concept of reflection using the example of the `Range` attribute,
    which is native to Unity. Consider the following line of code:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This public variable will be displayed in the Object Inspector with an edit
    field that allows the user to type in any valid floating point number thereby
    setting the value of `MyNumber`, as shown in the following screenshot:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
- en: '![C# attributes and reflection](img/0655OT_08_05.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
- en: Entering in floating point values from the Object Inspector
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
- en: 'This code works fine and is suitable in many cases, but there are times when
    it''s preferable to validate the numerical entry to within a range, clipping the
    numbers between a minimum and maximum. You can do this in the code using the `Mathf.Clamp`
    function but you can also validate the entry using an attribute. You can attach
    a `Range` attribute to the floating point variable (`MyNumber`) to display a slider
    instead of an edit box, as shown in the following code:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Tip
  id: totrans-33
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on attributes can be found in the online Unity documentation
    at [http://unity3d.com/learn/tutorials/modules/intermediate/scripting/attributes](http://unity3d.com/learn/tutorials/modules/intermediate/scripting/attributes).
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
- en: When this code is compiled, the `MyNumber` variable displays differently in
    the Object Inspector, honoring the numerical range between `0` and `1`, as shown
    in the following screenshot. Notice that all numbers provided to the `Range` attribute
    as arguments must be explicit values known at compile time and not expressions,
    which depend on variables that can vary at runtime. All attribute values must
    be known at compile time.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: '![C# attributes and reflection](img/0655OT_08_06.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
- en: Using attributes to customize inspector display
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
- en: 'So how do attributes work? In short, attributes are a form of metadata; they
    work like tags. Programmers can attach an attribute to a class, variable, or a
    method to associate data with it, which is known to the compiler. The attribute
    itself is entirely descriptive because it does nothing; it''s simply data. The
    importance of attributes arises because all the code based on .NET (or Mono) has
    the ability to step outside itself and become self-conscious, that is, the ability
    to look at all the classes and data types and instances contained inside the program.
    For each object in the program, its metadata (attributes) can be queried and examined.
    This ability of a program to "look at itself from the outside" is known as reflection
    as it''s like looking in a mirror. Of course, the program does not see itself
    in reverse or in distorted terms but rather as it truly is, including all its
    metadata. To give a quick example of reflection, try out the following code sample
    8-2\. This code will cycle through all the custom-made classes in your Unity application
    across all source files. Notice it doesn''t just list all the instances of classes
    in the scene but all classes themselves (that is, the blueprints, metaphorically
    speaking):'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'The following are the comments for code sample 8-2:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 03-04**: Both the namespaces `System` and `System.Reflection` should
    be included as they feature all classes and objects necessary for performing reflection
    in .NET.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 12**: This `foreach` loop cycles through all classes (types) in the
    active assembly (that is, the compiled code, including all your custom made script
    files).'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can take the concept of reflection even further. For example, having listed
    all types from code sample 8-2, you can even list the methods, properties, and
    variables (`Fields`) for a type. Refer to the following code sample 8-3 that,
    given a specific type as an argument, will list all its public member variables:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Tip
  id: totrans-45
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on bitwise operations, as used in this code sample, can be
    found online at [http://www.blackwasp.co.uk/CSharpLogicalBitwiseOps.aspx](http://www.blackwasp.co.uk/CSharpLogicalBitwiseOps.aspx).
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: 'Most crucially, however, you can list the attributes assigned to a type too.
    This lets you query a type for its metadata and examine its properties at runtime
    as shown in the following code sample 8-4:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code sample 8-4 demonstrates that all attribute data can be retrieved for
    a given data type in the code at runtime. This means data types and variables
    may have metadata associated with them, which can be retrieved and used to further
    influence how the objects should be handled. This is powerful for editor plugins
    because by creating our own custom-defined attributes that can be attached to
    data types and member variables, we can integrate our code with the Unity Editor
    without making its logical or runtime structure invalid. That is, we can tag variables
    in code with attributes to customize how they appear in the Unity Editor without
    invalidating or affecting it in terms of its logic or structure at runtime. Next,
    we'll see how to create custom attributes to customize the editor.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 代码示例 8-4 展示了在运行时可以从代码中检索给定数据类型的所有属性数据。这意味着数据类型和变量可能与其关联元数据，这些元数据可以被检索并用于进一步影响对象的处理方式。这对于编辑器插件来说非常强大，因为通过创建可以附加到数据类型和成员变量上的自定义定义属性，我们可以在不破坏其逻辑或运行时结构的情况下将我们的代码与
    Unity 编辑器集成。也就是说，我们可以通过在代码中使用属性标记变量来自定义它们在 Unity 编辑器中的显示方式，而不会在运行时逻辑或结构上无效化或影响它。接下来，我们将看到如何创建自定义属性来自定义编辑器。
- en: Color blending
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 颜色混合
- en: The `Range` attribute explored previously may be attached to integer and floating-point
    variables, by way of their declarations, to limit the accepted values for them
    between a minimum and maximum in the Unity Editor. In the Unity Editor, a slider
    control is substituted for an editable field that controls the accepted values
    for the variable. This does not, of course, affect the values assigned to the
    same variables in the code. In the code, at runtime, the `Range` attribute has
    no effect itself. Rather, the `Range` attribute simply controls how numerical
    public variables are presented in the Object Inspector, and how they are entered
    there via user input. Behind the scenes, an `Editor` class is querying object
    `Attribute` data through reflection to control how the data type is rendered in
    the Object Inspector.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 之前探索的 `Range` 属性可以通过其声明方式附加到整数和浮点变量上，以限制在 Unity 编辑器中它们的最小值和最大值之间的接受值。在 Unity
    编辑器中，一个滑动控件代替了可编辑字段，用于控制变量的接受值。当然，这不会影响代码中分配给相同变量的值。在代码中，在运行时，`Range` 属性本身没有效果。相反，`Range`
    属性仅控制数值公共变量在对象检查器中的显示方式以及用户输入时如何输入。在幕后，一个 `Editor` 类通过反射查询对象的 `Attribute` 数据，以控制数据类型在对象检查器中的渲染方式。
- en: The `Range` attribute works well for numbers. But it'd be great to deploy similar
    behavior for other data types besides just numbers. For example, it's common to
    fade between different colors, such as fading from black to transparency to create
    fade-in and fade-out effects for scene transitions. This is known as Color Lerping
    (linear interpolation). That is, an intermediary color is generated between two
    extremes using a normalized float (between `0` and `1`).
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: '`Range` 属性在处理数字时表现良好。但若能将其类似行为应用于除数字之外的其他数据类型，那就更完美了。例如，在场景过渡时，从黑色渐变到透明度以创建淡入和淡出效果是很常见的。这被称为颜色线性插值（Color
    Lerping）。也就是说，通过一个归一化的浮点数（介于 `0` 和 `1` 之间）在两个极端颜色之间生成一个中间颜色。'
- en: 'An appropriate `Inspector` property for this data type would be a slider control
    as with the `Range` attribute, which controls the interpolated color between `0`
    and `1`, as shown here:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于此类数据类型，合适的 `Inspector` 属性将是一个滑动控件，类似于 `Range` 属性，它控制 `0` 和 `1` 之间的插值颜色，如下所示：
- en: '![Color blending](img/0655OT_08_07.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![颜色混合](img/0655OT_08_07.jpg)'
- en: Lerping between two colors
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 在两种颜色之间进行线性插值
- en: 'In essence then, we need to customize the editor such that whenever an object
    is selected in the scene, which has a public member of a custom type we specify,
    we''ll want to customize how the member is rendered inside the Object Inspector.
    This lets us present custom controls and inputs in the Object Inspector, which
    validates data entry for that member as opposed to simply accepting its defaults.
    To begin this process, let''s create a custom class and define all data for a
    total color blend. A color blend requires four variables, namely the `SourceColor`
    and `DestColor` marking the limits of the blend. Next, the `BlendFactor` is a
    normalized float between `0` and `1` (start and end) which determines which intermediary
    color should be generated through Lerping. And then, finally, the output color
    itself (`BlendedColor`). The complete class definition for this process is included
    in the following code sample 8-5:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As the `ColorBlend` class uses the `[System.Serializable]` attribute, Unity
    will automatically render the class and its members inside the Object Inspector
    when it''s added as a public member of a class. By default, all public members
    of `ColorBlend` will be rendered, and the `BlendFactor` field will be rendered
    as an editable field inside which numbers can be directly entered, including numbers
    outside `0` and `1`, as shown here:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
- en: '![Color blending](img/0655OT_08_08.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
- en: Exposing the Color Adjuster class by its defaults and by changing its properties
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now start customizing how Unity should render this class inside the
    Object Inspector. Begin by creating a new attribute class called `ColorRangeAttribute`,
    as shown in the following code sample 8-6:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The following are the comments for code sample 8-6:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 01**: The `ColorRangeAttribute` class defines a metadata structure that
    we can tag to other data types. Notice that it derives from `PropertyAttribute`.
    This signifies, above everything else, that `ColorRangeAttribute` is an attribute
    and metadata structure but not a regular class. It''s not supposed to be instantiated
    as a standard class is.'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 07**: The attribute has a constructor function that accepts eight floating-point
    values defining the RGBA channels for the source and destination colors of the
    Lerp. These will be used soon when attaching the attribute to a variable.'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, we''ll write a class declaring an instance of `ColorBlend` with the `ColorRangeAttribute`
    attribute attached. Even now, however, the addition of `ColorRangeAttribute` will
    do nothing per se because no `Editor` class has yet been written to handle it.
    We can see this in the following code:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Creating an `Editor` class for rendering `ColorBlend` in the Object Inspector
    with a slider control involves handling the `ColorRangeAttribute` class. Specifically,
    Unity offers us the extension `PropertyDrawer` base class from which we can derive
    new classes to override the Object Inspector rendering for any specific attribute
    we add to our variables. In short, the `PropertyDrawer` class lets us customize
    inspector drawing for any and all variables tagged with a common attribute. Therefore,
    inside the `Editor` folder of your project, create a new `ColorRangeDrawer` class,
    as shown in the following code sample 8-7:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The following are the comments for code sample 8-7:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 01**: The `CustomPropertyDrawer` attribute is used here to associate
    the `PropertyDrawer` class with the `ColorRangeAttribute` attribute. The Unity
    Editor uses this metadata internally to determine which types require custom rendering
    in the Object Inspector. In this case, all members with `ColorRangeAttribute`
    will be drawn manually by the `OnGUI` function of the `PropertyDrawer` class.'
  id: totrans-71
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 11**: The `OnGUI` function is overridden from the base class to define
    how all fields with `ColorRangeAttribute` should be rendered in the Object Inspector.
    `EditorGUI` is a native Unity Editor utility class for drawing GUI elements, such
    as buttons, textboxes, and sliders. For more information on `EditorGUI`, see the
    online documentation at [http://docs.unity3d.com/ScriptReference/EditorGUI.html](http://docs.unity3d.com/ScriptReference/EditorGUI.html).'
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 14**: The `OnGUI` function is called once, perhaps many times per second,
    for each unique member to render manually in the Object Inspector. The attribute
    data for `ColorRangeAttribute` is retrieved here with typecasting, and this gives
    us access directly to all its members for the current object being rendered. To
    access the member variables of the object itself (for read/write access), as opposed
    to its attribute, the `SerializedProperty` argument should be used, such as the
    `FindPropertyRelative` method. For more information, see the online Unity documentation
    at [http://docs.unity3d.com/ScriptReference/SerializedProperty.html](http://docs.unity3d.com/ScriptReference/SerializedProperty.html).'
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 24**: From here onwards, the `FindPropertyRelative` function is called
    to retrieve public member variables, such as the `SourceColor`, `DestColor`, and
    `BlendedColor` in the selected object. This is where the values are actually set
    by moving the slider component.'
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  id: totrans-75
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the `PropertyDrawer` class can be found in the online Unity
    documentation at [http://docs.unity3d.com/Manual/editor-PropertyDrawers.html](http://docs.unity3d.com/Manual/editor-PropertyDrawers.html).
  id: totrans-76
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'The code sample 8-7 overrides the Object Inspector drawing for any `ColorBlend`
    instances when tagged with the `ColorRangeAttribute` attribute. This offers an
    accessible and easy-to-use way of creating blended colors. Remember, you can make
    your source and destination colors public, in order to be accessible from the
    **Inspector** tab, as shown here:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
- en: '![Color blending](img/0655OT_08_09.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
- en: Creating a ColorBlender display for the ColorBlend class
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
- en: Property exposing
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By default, the Object Inspector displays all public member variables of a
    class unless it''s in **Debug** mode or a private member is explicitly marked
    with the `SerializeField` attribute and in these cases private member variables
    will be shown too:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
- en: '![Property exposing](img/0655OT_08_10.jpg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
- en: Property accessing from the Object Inspector
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
- en: However, C# properties will never be displayed by default, either in **Release**
    or **Debug** mode. As discussed in [Chapter 1](ch01.html "Chapter 1. Unity C#
    Refresher"), *Unity C# Refresher*, C# properties act like accessor functions to
    a variable. They essentially permit validation on each `get` and `set` operation
    because every `get` and `set` operation entails an internal function call. However,
    regardless of Unity's limitation in the Object Inspector, it's possible to write
    an editor extension that will show all properties for a class in the Object Inspector,
    which allows you to get and set the values directly. This section considers how
    in more detail. Again, we'll have reason to rely heavily on reflection.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-85
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the `SerializeField` class can be found in the online Unity
    documentation at [http://docs.unity3d.com/ScriptReference/SerializeField.html](http://docs.unity3d.com/ScriptReference/SerializeField.html).
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following code sample 8-8 that features a few properties:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'This class will be used internally by a different class as a public member,
    as shown in the following code sample 8-9:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'By default, the public `MyPropClass` member (although tagged as `System.Serializable`)
    will not show its members in the Object Inspector. This is because C# properties
    are not natively supported:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
- en: '![Property exposing](img/0655OT_08_11.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
- en: By default, the Object Inspector will not render the C# properties
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
- en: 'To solve this issue, we can return to the `PropertyDrawer` class; this time
    associating the class with a specific class rather than an attribute, as shown
    in the following code sample 8-10:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following are the comments for code sample 8-10:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 08**: Notice that the `CustomPropertyDrawer` attribute is now associated
    with a regular class as opposed to an attribute. In this case, the rendering of
    a specific class is being customized for the Object Inspector as opposed to various
    properties of different types, which can share a common attribute.'
  id: totrans-97
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 12-18**: Some public members are declared, primarily to calculate the
    height (in pixels) of a single row in the Object Inspector. By default, the Object
    Inspector allocates one row (or line) for our custom rendering and all drawing
    is supposed to fit within that space. If the total height of our rendering exceeds
    the height of one line, all additional controls and data will overlap and mix
    with controls and widgets beneath. To address this problem, the `GetPropertyHeight`
    (at line 69) function can be used to return a pixel height allocated for our custom
    drawing.'
  id: totrans-98
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 26-27**: These lines are especially important. They use reflection
    to retrieve a type-correct object reference to the `ClassWithProperties` instance
    currently being drawn for this call to `OnGUI`. Specifically, a reference to `targetObject`
    is retrieved (the object selected), and then an instance to `ClassWithProperties`
    is retrieved from that. The result is that this code gives us direct and immediate
    access to the `ClassWithProperties` object.'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 37-58**: Each public property on the object is cycled in sequence,
    and for valid or supported data types, an inspector property is drawn that allows
    both read/write access to the property, provided the property itself supports
    both methods.'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the C# properties:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: '![Property exposing](img/0655OT_08_12.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
- en: Accessing C# properties
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
- en: Localization
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perhaps one of the most underappreciated and underdocumented aspect of game
    development is localization. This refers to the broad range of technical, economic,
    and logistical measures a developer takes to support multiple natural languages
    in their game, such as English, French, German, Spanish, Esperanto, and so on.
    The technical aim is not so much to support this or that specific language, but
    rather to establish an infrastructure that could support any arbitrary language
    chosen at any time, now or later. The entire scope and role of localization in
    development is beyond the scope of this book, but here we''ll examine one way
    in which the Unity Editor can be customized to facilitate a quick and easy localization
    workflow. For example, consider the following sample XML file, in which game text
    for the buttons in a main menu system is defined in both English and a "spoof
    language" called Yoda:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Tip
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Notice, the CDATA element encloses all custom text nodes to allow the use of
    any characters and symbols. More information on CDATA can be found online at [http://www.w3schools.com/xml/xml_cdata.asp](http://www.w3schools.com/xml/xml_cdata.asp).
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: 'The XML defined earlier creates four text elements, one for each button on
    a sample user interface menu. Each text element is assigned a unique ID: `text_01`,
    `text_02`, `text_03`, and `text_04`. These IDs uniquely identify each item of
    text in the game and will match across all specified languages. The purpose here
    is to import the text file into Unity that allows the developer to switch between
    languages at the touch of a button, and have all relevant text elements in the
    game change automatically to accommodate the language switch. Let''s see how this
    works.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: First import the localized text into a `Resources` folder in a Unity project.
    Create a folder named `Resources` and then import the localized text file into
    it, as shown in the following screenshot. In code, this means any object or class
    can load or open the text file using a `Resources.Load` call, as we'll see soon.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
- en: '![Localization](img/0655OT_08_13.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
- en: Importing localized text into a project
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  id: totrans-113
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on resources can be found online at the Unity documentation
    at [http://docs.unity3d.com/ScriptReference/Resources.html](http://docs.unity3d.com/ScriptReference/Resources.html).
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
- en: 'The imported text file simply contains all text data to be included in the
    game, where each element is associated with its ID. Thus, each string value is
    married to an ID, and the ID is consistent across language schemes that allow
    a seamless transition between languages. The ID is the one common denominator
    that makes an automated localization possible. To implement the localization system
    in code, we''ll first create an attribute that should be applied to all localized
    strings. The attribute defines only the ID to be attached to a specific string
    variable, as shown in the following code sample 8-11:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'With the `LocalizationTextAttribute` attribute now created, we can apply it
    to string members in code, which associates them with a specific ID, as shown
    in the following code sample 8-12:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The `SampleGameMenu` class appears as a regular class in the Object Inspector,
    as shown in the following screenshot. Later, through our `Editor` class, we'll
    develop the ability to automatically change all string members to the selected
    language.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
- en: '![Localization](img/0655OT_08_14.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
- en: A SampleGameMenu class features all texture required for a sample menu screen
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we''ll code an `Editor` class to switch between languages. This class
    will add menu entries on the application menu, which when clicked will change
    the active language, as shown in the following code sample 8-13\. This sample
    draws on a range of related concepts we''ve seen already, including new ones.
    Specifically, it uses the `Reflection`, `Linq`, and `Editor` classes as well as
    the Mono Framework XML handling classes:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The following are the comments for code sample 8-13:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 02-07**: Remember to include wide range of namespaces as shown here.
    Our code will rely on them all to some degree.'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 11-23**: For this sample application, the three languages: **English**,
    **French**, and **Yoda** are selectable from the application menu. For your own
    projects, your language list may be different. But crucially, based on the localization
    system given here, integration of additional languages, even at a much later time,
    is easy.'
  id: totrans-126
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 32**: The `Resources.Load` function is called here to open the XML text
    file from the `Resources` folder in the project that extracts its text contents
    into one single concatenated string variable.'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 35-36**: The XML string is loaded into an `XmlDocument` object, which
    is a Mono class encapsulating a complete XML file, either on disk or in memory.
    The class also validates the document on loading, which means an exception will
    be generated here if the file contains syntax errors.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 53**: Once a language is selected from the XML file, all child nodes
    of the language (each node a unique string) are cycled to find a matching ID.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 61**: For each string entry, all public string members for the text
    class are searched for an appropriate `LocalizationTextAttribute` and when found,
    the string ID is compared to check for a match. When a match is found, the string
    variable is assigned the corresponding localized string.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To use the localization framework given here, first add a `SampleGameMenu`
    object to the scene as shown here:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: '![Localization](img/0655OT_08_15.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
- en: Adding a Sample Game Menu object to the scene with localized text members
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, choose a language from the application main menu by selecting **English**
    or **Yoda** from the **Localization** tab, as shown here:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: '![Localization](img/0655OT_08_16.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
- en: Setting the active language for the game
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the active language is specified, all strings with the `LocalizationTextAttribute`
    attribute will be updated, as shown in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: '![Localization](img/0655OT_08_17.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
- en: Localized text is updated after selecting an active language
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter explored in depth the relationship between reflection, as a concept,
    and its practical use for creating `Editor` classes that extended the editor behavior
    beyond its defaults to accommodate custom intentions. The ability to do this is
    not always essential to building Unity games themselves but it can make your work
    easier. Furthermore, it can lead to making money via the Asset Store, should you
    wish to develop custom add-ons that can help other developers. Here, you saw how
    to create a Batch Rename tool with the `ScriptableWizard` class and then a color
    blending property for the Object Inspector. Next, we made extensive use of reflection
    to expose all public C# properties in the Object Inspector that allowed us direct
    access to the set and get property values as if we'd accessed them at runtime.
    Further, we moved on to see how a localization framework could be implemented
    from XML files via the `Editor` classes that allow string variables to be automatically
    changed to match a selected language. For more information, you can visit [http://catlikecoding.com/unity/tutorials/editor/custom-data/](http://catlikecoding.com/unity/tutorials/editor/custom-data/)
    and [http://catlikecoding.com/unity/tutorials/editor/custom-list/](http://catlikecoding.com/unity/tutorials/editor/custom-list/).
    In the next chapter, we'll move our conceptual and technical baggage to explore
    the world of 2D from more unconventional angles.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 本章深入探讨了作为概念的反射与其实际应用之间的关系，即创建扩展编辑器行为的`Editor`类，使其能够适应自定义意图，而不仅仅是默认行为。这种能力对于构建Unity游戏本身并非总是必需的，但它可以使你的工作更加轻松。此外，如果你希望开发能够帮助其他开发者的自定义插件，这也可以通过Asset
    Store带来盈利。在这里，你看到了如何使用`ScriptableWizard`类创建批量重命名工具，以及为对象检查器添加颜色混合属性。接下来，我们广泛使用了反射来暴露对象检查器中所有公共的C#属性，这使我们能够直接访问设置和获取属性值，就像我们在运行时访问它们一样。进一步地，我们探讨了如何通过`Editor`类从XML文件实现本地化框架，这些类允许字符串变量自动更改以匹配所选语言。更多信息，您可以访问[http://catlikecoding.com/unity/tutorials/editor/custom-data/](http://catlikecoding.com/unity/tutorials/editor/custom-data/)和[http://catlikecoding.com/unity/tutorials/editor/custom-list/](http://catlikecoding.com/unity/tutorials/editor/custom-list/)。在下一章中，我们将带着概念和技术上的负担，从更不寻常的角度探索2D世界。
