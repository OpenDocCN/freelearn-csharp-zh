<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Scaling RESTful Services (Performance of Web Services)</h1>
                </header>
            
            <article>
                
<p><span><span>I</span></span>n the world of the web, everyone is either writing or looking for a web application. As demand increases, every web application needs to be able to serve more requests—sometimes thousands of requests a day. Applications should therefore be written to handle this huge requests.</p>
<p>Say, as an example, that you are part of a development and support team that is responsible for developing the company's flagship product, FlixOne Store. This product is popular and gains traction, leading to your e-commerce website (FlixOne) being inundated with consumer traffic. The payment service in your system is slow, which has almost brought the whole thing down, causing you to lose customers. Although this is an imaginary scenario, it can happen in real life and can lead to a loss of business. To avoid such a scenario, you should think about the scalability of the FlixOne application.</p>
<div class="packt_infobox">
<p>Scalability is one of the most important non-functional requirements for a critical system. Serving a couple of users with hundreds of transactions is not the same as serving millions of users with several million transactions.</p>
</div>
<p>In this chapter, we will discuss scalability in general. We'll also discuss how to scale RESTful services, what to consider when we design them, and how to avoid cascading failures using different patterns including techniques, libraries, and tools that can also be helpful for our regular applications.</p>
<p>By the end of this chapter, you will have learned about:</p>
<ul>
<li>Clustering</li>
<li>Load balancing</li>
<li>An introduction to scalability</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Clustering</h1>
                </header>
            
            <article>
                
<p>Clustering is a way to provide the same service on more than one server. With the addition of more servers, you can avoid uncontrolled situations, such as failovers, system crashes, and so on. In the context of databases, clustering refers to the ability of several server instances to connect with a single server. Fault tolerance and load balancing are two of the main advantages of clustering.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Load balancing</h1>
                </header>
            
            <article>
                
<p>A load balancer is a useful tool when clustering. You can define a <strong>load balance</strong> as a device that helps to distribute network or application traffic within and across the cluster servers, and to improve the responsiveness of the application.</p>
<p>In implementation, a load balancer is placed between the client and the servers. It helps to balance multiple application requests across multiple servers. In the other words, a load balancer reduces individual server time and prevents application server failure.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">How does it work?</h1>
                </header>
            
            <article>
                
<p>A load balancer works to make sure that an application's server is available. If one application's server is unavailable, the load balancer redirects all new requests to the available servers, as illustrated in the following diagram:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/867aa115-47b5-4579-8b1b-e94c3e9f7bc8.png"/></div>
<p>In the preceding diagram, you can see a load balancer in its typical environment, where a system accepts multiple requests from different sources over the internet, which are then managed from multiple servers by the load balancer.</p>
<div class="mce-root packt_infobox">In .NET, this arrangement is also known as a web farm (<a href="https://www.codeproject.com/Articles/114910/What-is-the-difference-between-Web-Farm-and-Web-Ga">https://www.codeproject.com/Articles/114910/What-is-the-difference-between-Web-Farm-and-Web-Ga</a>).</div>
<p>A load balancer uses various algorithms, also known as load balancer methods: the least connection method, round-robin method, least response time method, least bandwidth method, least packets method, custom load method, and more.</p>
<p>A load balancer plays an important role in the scalability of an application as it makes sure that an application's server is available for server requests. Note that you will need to arrange your hardware infrastructure without a code change to cater for a load balancer (however, there will be some scenarios that call for a code change). There are a lot of load balancers on the market, such as Incapsula (<a href="https://www.incapsula.com/">https://www.incapsula.com/</a>), F5 (<a href="https://www.f5.com/">https://www.f5.com/</a>), Citrix Netscaler (<a href="https://www.citrix.com/">https://www.citrix.com/</a>), Dyn (<a href="https://dyn.com/">https://dyn.com/</a>), Amazon Elastic Load Balancing, and Amazon ELB (<a href="https://aws.amazon.com/">https://aws.amazon.com/</a>).</p>
<p>In the coming sections, we will look at the different ways you can scale systems.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Introduction to scalability</h1>
                </header>
            
            <article>
                
<p>Every application has its own ability to serve requests. An application’s ability refers to its performance and how it meets its objectives when load is increased.</p>
<div class="packt_infobox">
<p>Many web applications refer to this as a number of requests in a stipulated time.</p>
</div>
<p>It’s very important to make the right design decision when designing your web application; design decisions impact the scalability of your service. Be sure to strike the right balance so that your approach considers your services as well as their infrastructure, along with any need for scaling.</p>
<div class="packt_infobox">
<p>Performance and scalability are two different characteristics of a system. Performance deals with the throughput of the system, whereas scalability deals with serving the desired throughput for a larger number of users, or a larger number of transactions.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scaling in (vertical scaling)</h1>
                </header>
            
            <article>
                
<p><strong>Scaling in</strong> or <strong>scaling up</strong> (also called <strong>vertical scaling</strong>) is a way of achieving scalability through the addition of more resources, such as memory or faster processors, to the same machine. This is not always applicable to all applications, as costing is also a factor when considering vertical scaling.</p>
<p>You can also upgrade your resources or hardware instead of adding new resources to your machine. For example, if you have 8 GB of RAM, you can upgrade it to 16 GB, and the same thing would be applicable for processors and other resources. Unfortunately, with upgrades in hardware, there is a limit to how much you can scale the machine. This may lead to simply shifting the bottleneck, rather than solving the real problem of improving scalability.</p>
<p>You can also migrate your application to an entirely different machine, such as simply migrating your application to a more powerful MacOS, for example.</p>
<div class="packt_infobox">
<p>Scaling vertically does not involve any code changes so it is an easy task, but it does involve extra cost as it is quite an expensive technique. Stack Overflow is one of those rare examples of a .NET-based system that is scaled vertically.</p>
</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Scaling out (horizontal scaling)</h1>
                </header>
            
            <article>
                
<p>Scaling up, scaling out, or horizontal scaling adds more servers or nodes to service requests, rather than resources. If you do not want to scale up your application, there is always a way to scale it out.</p>
<p>Scaling out is a successful strategy when the application code does not depend on the server it is running on. However, if a request needs to be executed on a specific server, that is, if the application code has server affinity, it will be difficult to scale that out. In the case of stateless code, it is easier execute on any server. Hence, scalability is improved when stateless code is run on horizontally-scaled machines or clusters. <strong><br/>
<br/></strong> Due to the nature of horizontal scaling, it is a commonly used approach across the industry. There are  many examples of large scalable systems managed in this way, such as Google, Amazon, and Microsoft.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Linear scalability</h1>
                </header>
            
            <article>
                
<p>Linear scalability refers to scaling an application vertically with the application of Amdahl's law (<a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">https://en.wikipedia.org/wiki/Amdahl%27s_law</a>). Here, you can also think about parallel computing.</p>
<div class="packt_infobox">
<p>Parallel computing is a type of computing architecture that indicates simultaneous processing with the execution of several processors.</p>
</div>
<p>The benefits of linear scalability in your application include:</p>
<ul>
<li>No code changes are required</li>
<li>Extra resources can be easily added</li>
<li>There is physical availability</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Distributed caching</h1>
                </header>
            
            <article>
                
<p>With the help of distributed caching techniques, we can improve the scalability of our RESTful web services (web API). A distributed cache can be stored on multiple nodes of a cluster. A distributed cache enhances a web service's throughput, as the cache no longer requires an I/O trip to any external resource.</p>
<p>This approach has the following advantages:</p>
<ul>
<li>Clients get the same results</li>
<li>The distributed cache is backed up by a persistence store and runs as a different remote process; even if the app server restarts or has any problems, it in no way affects the cache</li>
<li>The source's data store has fewer requests made to it</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Caching persisted data (data-tier caching)</h1>
                </header>
            
            <article>
                
<p>Similar to application performance, you should also be considering database performance. By caching persisted data, you will get better performance after adding a caching layer to your database. This is also important when read requests are heavily used in an application. We will now take a look at EF Core’s levels of caching as an example.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">First-level caching</h1>
                </header>
            
            <article>
                
<p>This is an inbuilt session cache enabled by EF Core. From the first request from a service, an object is retrieved from the database and is stored in an EF Core session. In other words, EF Object Context and DbContext maintain state information about the entities they are managing. As soon as the context is no longer available, its state information is also gone.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Second-level caching</h1>
                </header>
            
            <article>
                
<p>Second-level caching is important for applications that have been developed in a mostly distributed manner or have-long running requests that need persisted data, such as web applications. Second-level caching exists outside the scope of a transaction or application, and these caches are available for any context or instance. You can use the caching mechanism available to your application instead of writing your own code, such as Memcached.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Application caching</h1>
                </header>
            
            <article>
                
<p>Application caching or application-tier caching helps to cache any object in an application. This further improves the scalability of an application. In the following section, we will discuss the various caching mechanisms available.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">CacheCow</h1>
                </header>
            
            <article>
                
<p>CacheCow comes into the picture when you want to implement HTTP caching on both the client and server. This is a lightweight library and ASP.NET web API support is currently available. CacheCow is open source and comes with an MIT license that is available on GitHub (<a href="https://github.com/aliostad/CacheCow">https://github.com/aliostad/CacheCow</a>).</p>
<p>To get started with CacheCow, you need to get ready for both the server and client by taking the following steps:</p>
<ol>
<li>Install the <kbd>Install-Package CacheCow.Server</kbd> NuGet package within your ASP.NET Web API project; this will be your server.</li>
<li>Install the <kbd>Install-Package CacheCow.Client</kbd> NuGet package within your client project; the client application will be WPF, Windows Form, Console, or any other web application.</li>
</ol>
<p> </p>
<ol start="3">
<li>
<p>Create a cache store. You need to create a cache</p>
store
<p>on the server side that requires a database for storing cache metadata (<a href="https://github.com/aliostad/CacheCow/wiki/Getting-started#cache-store">https://github.com/aliostad/CacheCow/wiki/Getting-started#cache-store</a>).</p>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Memcached</h1>
                </header>
            
            <article>
                
<p>Memcached is an open source project that is customizable; you can use the source code and add to and update it as per your requirements. Memcached is defined by its official page (<a href="https://memcached.org/">https://memcached.org/</a>) as:</p>
<div class="packt_quote">"An in-memory key-value store for small chunks of arbitrary data (strings, objects) from results of database calls, API calls, or page rendering."</div>
<div class="packt_quote packt_infobox">Refer to <a href="https://www.deanhume.com/memcached-for-c-a-walkthrough/">https://www.deanhume.com/memcached-for-c-a-walkthrough/</a> for a complete walkthrough.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Azure Redis Cache</h1>
                </header>
            
            <article>
                
<p>Azure Redis Cache is built on top of an open source store called Redis (<a href="https://github.com/antirez/redis">https://github.com/antirez/redis</a>), which is an in-memory database and persists on disk. As per Microsoft's description (<a href="https://azure.microsoft.com/en-in/services/cache/">https://azure.microsoft.com/en-in/services/cache/</a>):</p>
<div class="packt_quote">"Azure Redis Cache is based on the popular open source Redis cache. It gives you access to a secure, dedicated Redis cache, managed by Microsoft and accessible from any application within Azure."</div>
<p>Getting started with Azure Redis Cache is very simple if you take the following steps:</p>
<ol>
<li>Create a web API project. Refer to our code example in previous chapters.</li>
<li>Implement Redis. For a referral point, use <a href="https://github.com/StackExchange/StackExchange.Redis">https://github.com/StackExchange/StackExchange.Redis</a>. Also, install the <kbd>Install-Package StackExchange.Redis</kbd> NuGet package.</li>
</ol>
<p> </p>
<ol start="3">
<li>Update your config file for CacheConnection (<a href="https://docs.microsoft.com/en-us/azure/redis-cache/cache-dotnet-how-to-use-azure-redis-cache#NuGet">https://docs.microsoft.com/en-us/azure/redis-cache/cache-dotnet-how-to-use-azure-redis-cache#NuGet</a>).</li>
<li>Then, publish on Azure (<a href="https://docs.microsoft.com/en-us/azure/redis-cache/cache-web-app-howto#publish-and-run-in-azure">https://docs.microsoft.com/en-us/azure/redis-cache/cache-web-app-howto#publish-and-run-in-azure</a>).</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Communication (asynchronous)</h1>
                </header>
            
            <article>
                
<p>The term communication is self-explanatory; it is the act of interaction between services. Examples of this include the following:</p>
<ul>
<li>A service communicating with another service within the same application</li>
<li>A service communicating with another service outside of the application (external services)</li>
<li>A service communicating with a component (internal or external)</li>
</ul>
<p>This communication happens over the HTTP protocol as messages or data traverse over the wire.</p>
<div class="packt_tip">
<p>Your application's performance impacts how services communicate with each other.</p>
</div>
<p>Asynchronous communication is one of the methods that help to scale applications. In ASP.NET Core, we can achieve this by using asynchronous HTTP calls (asynchronous programming): <a href="https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/">https://docs.microsoft.com/en-us/dotnet/standard/asynchronous-programming-patterns/</a></p>
<p>You should be careful with operations while handling asynchronous communications, for example, when adding a new product with an image. A system is designed so that it creates a thumbnail of the images in different sizes. This is a time-consuming task that could lead to a performance hit if handled incorrectly. From a design perspective, an asynchronous operation would not work in this scenario. Here, you should implement something like a task with a callback that tells the system when a job is complete. Sometimes, you may also require middleware to handle requests.</p>
<div class="packt_infobox">
<p>The best way to implement asynchronous communication is with an asynchronous RESTful API.</p>
</div>
<p>When creating a scalable system, you must always think about asynchronous communication.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we discussed scalability, including the libraries available to help with it, tools, and so on. We then discussed how to scale RESTful services, what to consider when we design them, and how to avoid cascading failure using different patterns.</p>
<p>In the coming chapters, we will discuss and build a web client to call and consume RESTful services.</p>


            </article>

            
        </section>
    </body></html>