- en: Implementing Design Patterns - Basics Part 2
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现设计模式 - 基础部分 2
- en: In the previous chapter, we introduced FlixOne and the initial development of
    a new inventory management application. Several patterns were used by the development
    team, ranging from patterns designed to limit the scope of a deliverable such
    as a **Minimum Viable Product** (**MVP**) to patterns to assist in the development
    of the project such as **Test Driven Development** (**TDD**). Several patterns
    from the **Gang of Four** (**GoF**) were also applied as a solution to leverage
    how others have solved similar problems in the past so that we don't repeat common
    mistakes. Single responsibility principle, Open–closed principle, Liskov substitution
    principle, Interface Segregation principle, and Dependency inversion principle
    (SOLID principles) were applied to ensure we are creating a stable code base that
    will help in the management and future development of our application.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们介绍了 FlixOne 以及新库存管理应用程序的初始开发。开发团队使用了多种模式，从旨在限制可交付成果范围的模式，如 **最小可行产品**（**MVP**），到帮助项目开发的模式，如
    **测试驱动开发**（**TDD**）。还应用了 **四人帮**（**GoF**）的几个模式，作为利用过去他人解决类似问题的解决方案，以避免重复常见的错误。应用了单一职责原则、开闭原则、里氏替换原则、接口隔离原则和依赖倒置原则（SOLID
    原则），以确保我们创建一个稳定的代码库，这将有助于我们应用程序的管理和未来开发。
- en: This chapter will continue to explain the building of the FlixOne inventory
    management application by incorporating more patterns. More of the GoF patterns
    will be used, including the singleton and factory patterns. A singleton pattern
    will be used to illustrate the repository pattern that is used to maintain the
    FlixOne collection of books. The factory pattern will further the understanding
    of the **Dependency Injection** (**DI**). Finally, we will use the .NET Core framework
    to facilitate an **Inversion of Control** (**IoC**) container that will be used
    to complete the initial inventory management console application.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将继续通过结合更多模式来解释 FlixOne 库存管理应用程序的构建。将使用更多 GoF 模式，包括单例和工厂模式。将使用单例模式来展示用于维护 FlixOne
    书籍集合的存储库模式。工厂模式将进一步理解 **依赖注入**（**DI**）。最后，我们将使用 .NET Core 框架来简化一个 **控制反转**（**IoC**）容器的使用，该容器将用于完成初始的库存管理控制台应用程序。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The singleton pattern
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单例模式
- en: The factory pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 工厂模式
- en: Features of .NET Core
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core 的特性
- en: Console application
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制台应用程序
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter contains various code examples to explain these concepts. The code
    is kept simple and is just for demonstration purposes. Most of the examples involve
    a .NET Core console application written in C#.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 本章包含各种代码示例来解释这些概念。代码保持简单，仅用于演示目的。大多数示例涉及使用 C# 编写的 .NET Core 控制台应用程序。
- en: 'To run and execute the code, you will need the following:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行和执行代码，你需要以下内容：
- en: Visual Studio 2019 (you can also run the application using Visual Studio 2017
    version 3 or later)
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2019（你也可以使用 Visual Studio 2017 版本 3 或更高版本运行应用程序）
- en: .NET Core
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET Core
- en: SQL Server (the Express Edition is used in this chapter)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server（本章使用的是 Express 版本）
- en: Installing Visual Studio
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 安装 Visual Studio
- en: 'To run these code examples, you need to install Visual Studio or later. You
    can use your preferred IDE. To do this, follow these instructions:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行这些代码示例，你需要安装 Visual Studio 或更高版本。你可以使用你喜欢的 IDE。为此，请遵循以下说明：
- en: 'Download Visual Studio from the following link: [https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio).'
  id: totrans-16
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载 Visual Studio：[https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio](https://docs.microsoft.com/en-us/visualstudio/install/install-visual-studio)。
- en: Follow the installation instructions included. Multiple versions are available
    for the installation of Visual Studio; in this chapter, we are using Visual Studio
    for Windows.
  id: totrans-17
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照包含的安装说明进行操作。Visual Studio 提供了多种安装版本；在本章中，我们使用的是 Windows 版本的 Visual Studio。
- en: Setting up .NET Core
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置 .NET Core
- en: 'If you do not have .NET Core installed, you will need to follow these instructions:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尚未安装 .NET Core，你需要遵循以下说明：
- en: 'Download .NET Core from the following link: [https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows).'
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从以下链接下载 .NET Core：[https://www.microsoft.com/net/download/windows](https://www.microsoft.com/net/download/windows)。
- en: 'Follow the installation instructions for the related library: [https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2).'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照相关库的安装说明进行操作：[https://dotnet.microsoft.com/download/dotnet-core/2.2](https://dotnet.microsoft.com/download/dotnet-core/2.2)。
- en: The complete source code is available in GitHub. The source code that is shown
    in this chapter might not be complete, so it is recommended that you retrieve
    the source code in order to run the examples ([https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter4](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter4)).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 完整的源代码可在GitHub上找到。本章中展示的源代码可能不完整，因此建议您检索源代码以运行示例（[https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter4](https://github.com/PacktPublishing/Hands-On-Design-Patterns-with-C-and-.NET-Core/tree/master/Chapter4)）。
- en: The singleton pattern
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单例模式
- en: The singleton pattern is another GoF design pattern that is used to restrict
    the instantiation of a class to one object. It is used in situations where actions
    within a system need to be coordinated or access to data needs to be limited.
    For example, if access to a file needs to be restricted within an application
    to a single writer, then a singleton could be used to prevent multiple objects
    from trying to write to the file at the same time. In our scenario, we are going
    to use a singleton to maintain the collection of books and their inventory.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式是GoF设计模式之一，用于限制类的实例化只能有一个对象。它在需要协调系统内的操作或需要限制数据访问的情况下使用。例如，如果需要在应用程序中限制对文件的访问，只允许一个写者，那么可以使用单例来防止多个对象同时尝试写入文件。在我们的场景中，我们将使用单例来维护书籍及其库存的集合。
- en: The value of the singleton pattern is more apparent when it is illustrated using
    examples. This section will start with a basic class and then go on to identify
    the different issues that the singleton pattern addresses. These issues will be
    identified, and the class will be updated and then verified by unit tests.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用示例说明时，单例模式的值更为明显。本节将从基本类开始，然后继续识别单例模式解决的问题。这些问题将被识别，然后通过单元测试对类进行更新和验证。
- en: The singleton pattern should only be used when necessary as it can introduce
    a potential bottleneck for the application. Sometimes, the pattern is viewed as
    an anti-pattern as it introduces global state. With global state, unknown dependencies
    within an application are introduced and it then becomes unclear as to how many
    types might depend on the information. Additionally, many frameworks and repositories
    already limit access when required, so introducing an additional mechanism might
    limit the performance unnecessarily.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 单例模式仅在必要时使用，因为它可能会为应用程序引入潜在的瓶颈。有时，该模式被视为反模式，因为它引入了全局状态。随着全局状态的出现，应用程序中的未知依赖项被引入，并且不清楚有多少类型可能依赖于这些信息。此外，许多框架和存储库在需要时已经限制了访问，因此引入额外的机制可能会不必要地限制性能。
- en: .NET Core provides support for a number of the patterns discussed. In the next
    chapter, we will take advantage of the `ServiceCollection`class's support for
    both the factory method and the singleton pattern.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core对所讨论的许多模式提供支持。在下一章中，我们将利用`ServiceCollection`类的对工厂方法和单例模式的支持。
- en: In our scenario, the singleton pattern will be used to hold an in-memory repository
    containing a collection of books. The singleton will prevent the collection of
    books from being updated by more than one thread at a time. This will require
    us to *lock* a section of the code to prevent unpredictable updates.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的场景中，单例模式将用于保持包含书籍集合的内存存储库。单例将防止多个线程同时更新书籍集合。这需要我们将代码的一部分进行锁定，以防止不可预测的更新。
- en: 'The complexity of introducing a singleton into an application can be subtle;
    so, to gain a solid understanding of the pattern, we will cover the following
    topics:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序中引入单例的复杂性可能很微妙；因此，为了对模式有一个坚实的理解，我们将涵盖以下主题：
- en: .Net Framework's handling of processes and threads
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .Net Framework对进程和线程的处理
- en: The repository pattern
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 存储库模式
- en: Race conditions
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 竞态条件
- en: Unit testing to identify race conditions
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试以识别竞态条件
- en: Processes and threads
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进程和线程
- en: To understand the singleton pattern, we need to provide a little context. In
    the .Net Framework, an application will be composed of lightweight, managed subprocesses
    called application domains that can comprise one or more managed threads. For
    the purpose of understanding the singleton pattern, let's define this as a multithreaded
    application that contains one or more threads running simultaneously. Technically,
    the threads are actually not running simultaneously, but this is achieved by dividing
    the available processor time between the threads, so that each thread will execute
    for a small amount of time and then the thread will suspend activity, allowing
    for another thread to execute.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 要理解单例模式，我们需要提供一些背景信息。在 .Net 框架中，一个应用程序将由轻量级、受管理的子进程组成，称为应用程序域，这些子进程可以包含一个或多个受管理的线程。为了理解单例模式，让我们将其定义为一个包含一个或多个同时运行的线程的多线程应用程序。技术上，线程实际上并不是同时运行的，但这通过在线程之间分配可用的处理器时间来实现，这样每个线程将执行一小段时间，然后线程将暂停活动，允许另一个线程执行。
- en: Going back to the singleton pattern, in a multithreaded application, special
    care needs to be taken to ensure that access to the singleton is limited so that
    only one thread enters specific areas of logic at a time. Because of this synchronization
    of threads, it is possible for one thread to retrieve a value and update it, and,
    before it can be stored, another thread also updates the value.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 回到单例模式，在多线程应用程序中，需要特别注意确保对单例的访问受到限制，以便一次只有一个线程进入特定的逻辑区域。由于这种线程同步，一个线程可能检索一个值并更新它，而在它能够被存储之前，另一个线程也可能更新该值。
- en: The potential for more than one thread to access the same shared data and update
    it with unpredictable results can be referred to as a **race condition**.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 多个线程访问同一共享数据并可能产生不可预测结果的潜在情况可以被称为**竞态条件**。
- en: 'To avoid data being updated incorrectly, some restriction is required to prevent
    more than one thread from executing the same block of logic at the same time.
    There are several mechanisms supported in the .Net Framework and, in the singleton
    pattern, the `lock` keyword is used. In the following code, the `lock` keyword
    is illustrated to show that only one thread at a time can execute the highlighted
    code while all other threads will be blocked:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免数据被错误地更新，需要一些限制来防止多个线程同时执行相同的逻辑块。.Net 框架支持几种机制，在单例模式中，使用 `lock` 关键字。在下面的代码中，`lock`
    关键字被用来展示一次只有一个线程可以执行高亮显示的代码，而所有其他线程将被阻塞：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The lock is a simple way of restricting access to a section of code and can
    be applied to both object instances, as our previous example shows, and to the
    sections of code marked as static.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 锁是一种简单的方式来限制对代码段访问，并且可以应用于对象实例，正如我们之前的例子所示，也可以应用于标记为静态的代码段。
- en: The repository pattern
  id: totrans-41
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '**存储库模式**'
- en: The singleton pattern that is introduced to the project is applied to a class
    being used to maintain the inventory's collection of books. The singleton will
    prevent access from multiple threads being handled incorrectly, and, another pattern,
    the repository pattern, will be used to create a facade over the data that is
    being managed.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在项目中引入的单例模式应用于一个用于维护库存书籍集合的类。单例将防止多个线程错误地访问，并且，另一个模式，即存储库模式，将被用来创建对正在管理的数据的封装。
- en: The repository pattern provides an abstraction over a repository to provide
    a layer between the business logic of an application and the underlying data.
    This provides several advantages. By having a clean separation, our business logic
    can be maintained and unit tested independently of the underlying data. Often,
    the same repository pattern class can be reused by multiple business objects.
    An example of this could be `GetInventoryCommand`, `AddInventoryCommand`, and
    `UpdateInventoryCommand` objects; all of these objects use the same repository
    class. This allows us to test the logic in these commands in isolation from the
    repository. Another advantage of the pattern is that it enables centralized data-related
    policies to be more easily implemented, such as caching.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库模式在应用程序的业务逻辑和底层数据之间提供了一个抽象层。这提供了几个优点。通过清晰的分离，我们可以独立于底层数据维护和单元测试业务逻辑。通常，同一个存储库模式类可以被多个业务对象重用。这可以是一个例子`GetInventoryCommand`、`AddInventoryCommand`和`UpdateInventoryCommand`对象；所有这些对象都使用相同的存储库类。这允许我们独立于存储库测试这些命令中的逻辑。模式的另一个优点是它使得集中实现数据相关策略变得更加容易，例如缓存。
- en: 'To begin, let''s consider the following interface that describes the methods
    that the repository will implement; it contains a method for retrieving the books,
    adding a book, and updating the quantity of the book:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑以下接口，它描述了存储库将实现的方法；它包含一个用于检索书籍、添加书籍和更新书籍数量的方法：
- en: '[PRE1]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The initial version of the repository is as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库的初始版本如下：
- en: '[PRE2]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this chapter, the book collection is being maintained in the form of an in-memory
    cache, and, in later chapters, this will be moved to a repository providing persistent
    data. Of course, this implementation is not ideal, as, once the application ends,
    all the data will be lost. However, it serves to illustrate the singleton pattern.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，书籍集合以内存缓存的形式维护，在后面的章节中，这将被移动到一个提供持久数据的存储库。当然，这种实现并不理想，因为一旦应用程序结束，所有数据都将丢失。然而，它有助于说明单例模式。
- en: Unit tests
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: 'To illustrate the issues that the singleton pattern addresses, let''s start
    with a simple unit test that adds 30 books to the repository, updates the quantity
    of the different books, and then verifies the result. The following code shows
    the overall unit test, and we will explain each step individually:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 为了说明单例模式解决的问题，让我们从一个简单的单元测试开始，该测试向存储库中添加30本书，更新不同书籍的数量，然后验证结果。以下代码显示了整个单元测试，我们将逐个解释每个步骤：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To add 30 books, the `context` instance is used to add books from `Book_1`to
    `Book_30`:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 要添加30本书，使用`context`实例从`Book_1`到`Book_30`添加书籍：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The next section updates the book quantity by adding the numbers from `1` to
    `10` to the quantity of each book:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分通过将数字从`1`到`10`添加到每本书的数量来更新书籍数量：
- en: '[PRE5]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Then, in the next section, we will subtract the numbers from `1` to `10` from
    the quantity of each book:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在下一节中，我们将从每本书的数量中减去数字从`1`到`10`：
- en: '[PRE6]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As we have added and removed the same quantity for each book, the last part
    of our test will verify that the ending quantity is `0`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们为每本书添加和删除了相同的数量，我们的测试的最后部分将验证最终数量为`0`：
- en: '[PRE7]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'After running the test, we can see that the test passes:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 运行测试后，我们可以看到测试通过了：
- en: '![](img/9597d7f3-ef49-419f-b295-077228d9471e.png)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9597d7f3-ef49-419f-b295-077228d9471e.png)'
- en: So, when the test is run in a single process, the repository works as desired.
    However, what if the update requests are performed in separate threads? In order
    to test this, the unit test will be refactored to perform calls to the `InventoryContext`
    class in separate threads.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当测试在一个单独的进程中运行时，存储库按预期工作。然而，如果更新请求在单独的线程中执行呢？为了测试这一点，单元测试将被重构以在单独的线程中对`InventoryContext`类进行调用。
- en: 'The addition of the books is moved to a method that performs adding a book
    as a task (that is, in its own thread):'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 将书籍的添加移动到执行添加书籍作为任务的方法（即在它自己的线程中）：
- en: '[PRE8]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Additionally, the update quantity step is moved into another method with a
    similar approach:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，更新数量步骤被移动到另一个具有相似方法的方法中：
- en: '[PRE9]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: The unit test is then updated to call the new methods. It is worth noting that
    the unit test will wait until all books are added before updating the quantity.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 然后单元测试被更新为调用新方法。值得注意的是，单元测试将在所有书籍添加完毕后再更新数量。
- en: 'The `add thirty books` section now looks as follows:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 现在的`添加三十本书`部分如下所示：
- en: '[PRE10]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Similarly, the update quantity is changed to call both the `Add` and `subtract`
    method in the tasks:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，更新数量被改为在任务中调用`Add`和`subtract`方法：
- en: '[PRE11]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'After the refactor, the unit test no longer successfully completes, and, when
    the unit test runs now, an error is reported indicating that the book was not
    found in the collection. This will be reported as `"The given key was not present
    in the dictionary."`. This is because each time the context is instantiated, a
    new books collection is created. The first step is to restrict the creation of
    the context. This is done by changing the access of the constructor so that the
    class can no longer be instantiated directly. Instead, a new public `static` property
    that only supports a `get` operation is added. This property will return an underlying
    `static`instance of the `InventoryContext` class and, if the instance is missing,
    will create it:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 在重构之后，单元测试不再成功完成，并且当现在运行单元测试时，会报告一个错误，表明在收藏中没有找到书籍。这将被报告为`"给定的键不在字典中。"`。这是因为每次实例化上下文时，都会创建一个新的书籍收藏。第一步是限制上下文的创建。这是通过更改构造函数的访问权限来完成的，使得类不能再直接实例化。相反，添加了一个新的公共`static`属性，它只支持`get`操作。这个属性将返回`InventoryContext`类的底层`static`实例，如果实例不存在，将创建它：
- en: '[PRE12]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'This is still not enough to fix the broken unit test, but this is due to a
    different reason. To identify the issue, the unit test is run in debug mode with
    a breakpoint set in the `UpdateQuantity` method. The first time this is run, we
    can see that 28 books have been created and loaded in the book collection, as
    shown in the following screenshot:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这仍然不足以修复损坏的单元测试，但这是由于不同的原因。为了确定问题，以调试模式运行单元测试，并在`UpdateQuantity`方法中设置断点。第一次运行时，我们可以看到在书收藏中已创建并加载了28本书，如下面的截图所示：
- en: '![](img/c1515640-71e6-43e4-a1f1-d0d8f21d063c.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c1515640-71e6-43e4-a1f1-d0d8f21d063c.png)'
- en: 'At this point in the unit test, we would expect 30 books; however, before we
    start investigating, let''s run the unit test a second time. This time, we get
    an **Object reference not set to an instance of an object** error when we try
    to access the books collection for adding a new book, as shown in the following
    screenshot:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个单元测试的点，我们预计会有30本书；然而，在我们开始调查之前，让我们再次运行单元测试。这次，当我们尝试访问书籍收藏以添加新书时，会得到一个**对象引用未设置为对象实例**的错误，如下面的截图所示：
- en: '![](img/268b58d4-cbbe-4b12-9b77-df3b31df45db.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/268b58d4-cbbe-4b12-9b77-df3b31df45db.png)'
- en: 'Moreover, when the unit test is run a third time, the **Object reference not
    set to an instance of an object** error is not encountered, but there are only
    27 books in our collection, as shown in the following screenshot:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当单元测试第三次运行时，没有遇到**对象引用未设置为对象实例**的错误，但我们的收藏中只有27本书，如下面的截图所示：
- en: '![](img/46a4b8bc-48e9-4586-b1af-c64784920993.png)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/46a4b8bc-48e9-4586-b1af-c64784920993.png)'
- en: 'This type of unpredictable behavior is typical of race conditions and indicates
    that the shared resource, that is, the `InventoryContext` singleton, is being
    handled by multiple threads without synchronizing the access. The construction
    of the static object still allows more than one instance of the `InventoryContext`
    singleton to be created:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这种不可预测的行为是竞态条件的典型特征，表明共享资源，即`InventoryContext`单例，正在由多个线程处理，而没有同步访问。静态对象的构造仍然允许创建多个`InventoryContext`单例的实例：
- en: '[PRE13]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The race condition is where multiple threads evaluate the `if` statement as
    true and they all try to construct the `_context` object. All will succeed, but
    they will overwrite the previously constructed value by doing so. Of course, this
    is inefficient, especially when the constructor is a costly operation, but the
    issue discovered with the unit test is that the `_context` object is actually
    constructed by a thread after another thread or threads have updated the books
    collection. That is why the books collection, `_books`, has a different number
    of elements between runs.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 竞态条件是多个线程将`if`语句评估为真，并且它们都试图构造`_context`对象。所有尝试都会成功，但它们会通过这种方式覆盖之前构造的值。当然，这效率低下，尤其是在构造函数是一个昂贵的操作时，但单元测试中发现的问题实际上是由线程在另一个线程或多个线程更新书籍收藏之后构造的`_context`对象。这就是为什么在运行之间，书籍收藏`_books`的元素数量不同。
- en: 'To prevent this issue, the pattern uses a lock around the constructor as follows:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止这个问题，模式在构造函数周围使用锁，如下所示：
- en: '[PRE14]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Unfortunately, the unit tests still fail. This is because although one thread
    at a time can enter the lock, all blocked instances will still enter the lock
    once the blocking thread has completed. The pattern handles this situation by
    having an additional check inside the lock in case the construction has already
    been completed:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，单元测试仍然失败。这是因为尽管一次只有一个线程可以进入锁，但一旦阻塞的线程完成，所有阻塞的实例仍然会进入锁。该模式通过在锁内进行额外的检查来处理这种情况，以防构造已经完成：
- en: '[PRE15]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The preceding lock is essential as it prevents the static `InventoryContext`
    object from getting instantiated multiple times. Unfortunately, our test still
    does not consistently pass; with each change, the unit test becomes closer to
    passing. Some unit test runs will complete without error but, occasionally, the
    test completes with a failed result, as indicated in the following screenshot:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的锁是必不可少的，因为它防止了静态`InventoryContext`对象被多次实例化。不幸的是，我们的测试仍然没有一致地通过；每次更改，单元测试都更接近通过。一些单元测试运行将无错误完成，但偶尔，测试会以失败的结果完成，如下面的截图所示：
- en: '![](img/8cf03f40-50e7-4459-8209-60388b3b9a71.png)'
  id: totrans-88
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8cf03f40-50e7-4459-8209-60388b3b9a71.png)'
- en: 'Our instantiation of the static repository is now thread safe, but our access
    to the books collection is not. One thing to note is that the `Dictionary` class
    being used is not thread-safe. Fortunately, there are thread-safe collections
    available as part of the .Net Framework. These classes ensure that **adds and
    removals** from the collection are written for a multithreaded process. Note that
    only adds and removals are thread safe as this will become important a little
    bit later. The updated constructor is shown in the following code:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对静态仓库的实例化现在是线程安全的，但我们对书籍集合的访问不是。需要注意的是，正在使用的`Dictionary`类不是线程安全的。幸运的是，.Net
    Framework中提供了线程安全的集合。这些类确保集合的**添加和删除**操作是为多线程过程编写的。请注意，只有添加和删除是线程安全的，这将在稍后变得很重要。更新的构造函数如下所示：
- en: '[PRE16]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Microsoft recommends using the thread-safe collections in `System.Collections.Concurrent`
    over the corresponding collections in `System.Collections`, unless the application
    is targeting .Net Framework 1.1 or earlier.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 微软建议在`System.Collections.Concurrent`中使用线程安全的集合，而不是在`System.Collections`中使用相应的集合，除非应用程序针对的是.Net
    Framework 1.1或更早版本。
- en: After running the unit test again, introducing a `ConcurrentDictionary` class
    is still not enough to prevent incorrectly maintaining the books. The unit test
    is still failing. The concurrent dictionary protects from multiple threads being
    added and removed unpredictably, but does not offer any protection on the items
    in the collection themselves. This means that updates to the objects in the collection
    are not thread safe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 再次运行单元测试后，引入`ConcurrentDictionary`类仍然不足以防止错误地维护书籍。单元测试仍然失败。并发字典可以防止多个线程不可预测地添加和删除，但它不对集合中的项目本身提供任何保护。这意味着集合中对象的更新不是线程安全的。
- en: Let's take a closer look at race conditions in a multithreaded environment to
    understand why this is the case.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看多线程环境中的竞态条件，以了解为什么会出现这种情况。
- en: A race condition illustration
  id: totrans-94
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 竞态条件示例
- en: 'The following sequence of diagrams visualize what is happening conceptually
    between two threads: **ThreadA** and **ThreadB**. The first diagram shows both
    threads without any values from the collection:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的几个图示可视化了两线程之间在概念上发生的情况：**ThreadA**和**ThreadB**。第一个图显示两个线程没有任何来自集合的值：
- en: '![](img/fe27049f-ade1-485f-a255-bcd56290bbc6.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fe27049f-ade1-485f-a255-bcd56290bbc6.png)'
- en: 'The following diagram shows that both threads read from the collection of the
    book with the name of `Chester`:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示，两个线程都从名为`Chester`的书籍集合中读取：
- en: '![](img/b2b80704-df53-4c39-b3c5-e7176a6c2467.png)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b2b80704-df53-4c39-b3c5-e7176a6c2467.png)'
- en: 'The following diagram shows that **ThreadA** updates the book by increasing
    the quantity by `4`, while **ThreadB** updates the book by increasing the quantity
    by `3`:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 下图显示，**ThreadA**通过增加数量`4`来更新书籍，而**ThreadB**通过增加数量`3`来更新书籍：
- en: '![](img/b5a8650f-1f3d-4414-9109-f15046958d42.png)'
  id: totrans-100
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b5a8650f-1f3d-4414-9109-f15046958d42.png)'
- en: 'Then, when the updated book is persisted back to the collection, we have an
    unknown quantity as the result, as shown in the following diagram:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，当更新后的书籍被持久化回集合时，我们得到一个未知量作为结果，如下所示：
- en: '![](img/f4a99992-46d0-4eb7-a464-d82126476461.png)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4a99992-46d0-4eb7-a464-d82126476461.png)'
- en: 'To avoid this race condition, we need to block other threads while an update
    operation is taking place. In `InventoryContext`, blocking other threads takes
    the form of a lock around the update of the book quantity:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免这种竞争条件，我们需要在更新操作进行时阻塞其他线程。在`InventoryContext`中，阻塞其他线程的形式是对图书数量的更新操作进行锁定：
- en: '[PRE17]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The unit test now completes without error, as the additional locks prevent unpredictable
    race conditions.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试现在可以无错误地完成，因为额外的锁防止了不可预测的竞争条件。
- en: The `InventoryContext` class is still not complete as it has been completed
    just enough to illustrate the singleton and repository patterns. In later chapters,
    the `InventoryContext` class will be adapted to use Entity Framework, an **Object
    Relational Mapping** (**ORM**) framework. At this point, the `InventoryContext`
    class will be improved to support additional functionality.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryContext`类仍然不完整，因为它只是足够完整以说明单例和存储库模式。在后面的章节中，`InventoryContext`类将被修改以使用Entity
    Framework，一个**对象关系映射**（**ORM**）框架。在此阶段，`InventoryContext`类将被改进以支持额外的功能。'
- en: AddInventoryCommand
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AddInventoryCommand
- en: 'With our repository available, the three `InventoryCommand` classes can be
    completed. The first, `AddInventoryCommand`, is shown as follows:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的存储库可用，可以完成三个`InventoryCommand`类。第一个，`AddInventoryCommand`，如下所示：
- en: '[PRE18]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The first thing to note is that the repository, `IInventoryContext`, is injected
    in the constructor along with the `IUserInterface` interface described in the
    previous chapter. The command also requires a single parameter, `name`*,* to be
    supplied. This is retrieved in the `GetParameters` method that implements the
    `IParameterisedCommand` interface, which was also covered in the previous chapter.
    The command is then run in the `InternalCommand` method, which simply executes
    the `AddBook` method on the repository and returns a bool indicating whether the
    command has executed successfully.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 首先要注意的是，存储库`IInventoryContext`和前一章中描述的`IUserInterface`接口一起在构造函数中注入。命令还需要提供一个参数，`name`*，这将在实现`IParameterisedCommand`接口的`GetParameters`方法中检索，该接口也在前一章中介绍过。然后，命令在`InternalCommand`方法中运行，该方法简单地执行存储库上的`AddBook`方法并返回一个布尔值，指示命令是否成功执行。
- en: TestInventoryContext
  id: totrans-111
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: TestInventoryContext
- en: Similar to `TestUserInterface` used in the previous chapter, the `TestInventoryContext`
    class will be used to mock the behavior of our repository by implementing the
    `IInventoryContext` interface. This class will support the three methods of the
    interface, as well as supporting two additional methods for retrieving the books
    that have been added to the collection during the unit test and for retrieving
    the books that have been updated during the unit test.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一章中使用的`TestUserInterface`类似，`TestInventoryContext`类将通过实现`IInventoryContext`接口来模拟我们的存储库的行为。这个类将支持接口的三个方法，以及支持两个额外的用于在单元测试期间检索添加到集合中的图书和检索在单元测试期间更新的图书的方法。
- en: 'To support the `TestInventoryContext` class, two collections will be used:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 为了支持`TestInventoryContext`类，将使用两个集合：
- en: '[PRE19]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The first is used to store the starting collection of the books, while the
    second is used to store the final collection of the books. The constructor is
    shown in the following code; note how the dictionaries are copies of each other:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个用于存储图书的起始集合，而第二个用于存储图书的最终集合。构造函数如下所示；注意字典是如何相互复制的：
- en: '[PRE20]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The `IInventoryContext` methods are written to update and return just one of
    the collections, as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: '`IInventoryContext`方法被编写为仅更新并返回集合中的一个，如下所示：'
- en: '[PRE21]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'At the end of the unit test, the two remaining methods can be used to determine
    the difference between the starting and ending collections:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试结束时，可以使用剩下的两个方法来确定起始集合和结束集合之间的差异：
- en: '[PRE22]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: There is some confusion in the software industry around the differences between
    mocks, stubs, fakes, and other terms used to identify and/or categorize types
    or services used in testing that are not suitable for production but are necessary
    for the unit test. These dependencies may have functionality that is different,
    missing, and/or the same as their *real* counterparts.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在软件行业中，关于mocks、stubs、fakes以及其他用于识别和/或分类测试中使用的、不适合生产但对于单元测试是必要的类型或服务的术语之间存在一些混淆。这些依赖项可能具有与其实际对应物不同的、缺失的或相同的功能。
- en: For example, the `TestUserInterface` class could be referred to as a mock as
    it provides some expectation (for example, assert statements) of the unit test
    while the `TestInventoryContext` class would be a fake, as it provides a working
    implementation. In this book, we will not follow these classifications too strictly.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`TestUserInterface` 类可以被看作是一个模拟，因为它为单元测试提供了一些期望（例如断言语句），而 `TestInventoryContext`
    类则是一个伪造的类，因为它提供了一个工作实现。在这本书中，我们不会过于严格地遵循这些分类。
- en: AddInventoryCommandTest
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: AddInventoryCommandTest
- en: '`AddInventoryCommandTest` was updated by the team to verify the `AddInventoryCommand`
    functionality. This test will verify the adding of a single book to an existing
    inventory. The first part of the test is to define what is expected of the interface,
    which is only a single prompt to receive the new book name (remember that the
    `TestUserInterface` class takes three parameters: expected input, expected messages,
    and expected warnings):'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddInventoryCommandTest` 已由团队更新，以验证 `AddInventoryCommand` 功能。此测试将验证将单本书添加到现有库存。测试的第一部分是定义对接口的期望，即只接收新书籍名称的单一提示（记住，`TestUserInterface`
    类接受三个参数：预期输入、预期信息和预期警告）：'
- en: '[PRE23]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The `TestInventoryContext` class will be initialized with a single book simulating
    an existing book collection:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`TestInventoryContext` 类将初始化为包含单本书，模拟现有的书籍集合：'
- en: '[PRE24]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'The following code snippet shows the creation of `AddInventoryCommand`, the
    running of the command, and the assert statements used to validate that the command
    ran successfully:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段展示了 `AddInventoryCommand` 的创建、命令的执行以及用于验证命令成功执行的断言语句：
- en: '[PRE25]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: After the command is run, the result is verified to have run without error and
    that the command is not a terminating command. The rest of the `Assert` statements
    validate the expectation that only one book was added with the expected name.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 命令执行后，验证结果以确认没有错误发生，并且命令不是终止命令。其余的 `Assert` 语句验证了只有一个具有预期名称的书籍被添加的期望。
- en: UpdateQuantityCommand
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UpdateQuantityCommand
- en: '`UpdateQuantityCommand` is very similar to `AddInventoryCommand` and its source
    is as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateQuantityCommand` 与 `AddInventoryCommand` 非常相似，其源代码如下：'
- en: '[PRE26]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Like `AddInventoryCommand`, the `UpdateInventoryCommand` command is a non-terminating
    command with parameters. Therefore, it extends the `NonTerminatingCommand` base
    class and implements the `IParameterisedCommand` interface. Similarly, the dependencies
    for `IUserInterface` and `IInventoryContext` are injected in the constructor:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `AddInventoryCommand` 类似，`UpdateInventoryCommand` 命令也是一个带有参数的非终止命令。因此，它扩展了
    `NonTerminatingCommand` 基类并实现了 `IParameterisedCommand` 接口。同样，`IUserInterface`
    和 `IInventoryContext` 的依赖关系在构造函数中注入：
- en: '[PRE27]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The `UpdateQuantityCommand` class does have an additional parameter, *quantity*,
    which is determined as part of the `GetParameters` method.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateQuantityCommand` 类确实有一个额外的参数，*数量*，它是作为 `GetParameters` 方法的一部分确定的。'
- en: 'Finally, the quantity of a book is updated via the repository''s `UpdateQuantity`
    method in the `InternalCommand` override method:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，通过 `InternalCommand` 重写方法中的存储库的 `UpdateQuantity` 方法更新书籍的数量。
- en: '[PRE28]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Now that the `UpdateQuantityCommand` class has been defined, the following section
    will add a unit test to validate the command.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`UpdateQuantityCommand` 类已经定义，下一节将添加单元测试以验证该命令。
- en: UpdateQuantityCommandTest
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: UpdateQuantityCommandTest
- en: '`UpdateQuantityCommandTest` contains a test to validate a scenario where a
    book is updated in an existing collection. The creation of the expected interface
    and existing collection are shown in the following code (note that the test involves
    adding `6` to the quantity of an existing book):'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateQuantityCommandTest` 包含一个测试，用于验证在现有集合中更新书籍的场景。以下代码展示了预期接口和现有集合的创建（注意，该测试涉及将
    `6` 添加到现有书籍的数量）：'
- en: '[PRE29]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The following code block shows the running of the command and the initial validation
    of the successful run of the non-terminating command:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码块展示了命令的执行和非终止命令成功执行的初始验证：
- en: '[PRE30]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The expectation of the test is that no new books would be added and that the
    existing book''s quantity of 7 will be increased by 6, resulting in a new quantity
    of 13:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 测试的期望是不会有新书被添加，并且现有书籍的数量7将增加6，结果新的数量为13：
- en: '[PRE31]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: With the `UpdateQuantityCommand` class added, the ability to retrieve the inventory
    will be added in the next section.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 在添加了 `UpdateQuantityCommand` 类之后，下一节将添加检索库存的能力。
- en: GetInventoryCommand
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GetInventoryCommand
- en: 'The `GetInventoryCommand` command differs from the previous two commands because
    it does not require any parameters. It does use the `IUserInterface` dependency
    and the `IInventoryContext` dependency to write the content of the collection.
    This is shown as follows:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInventoryCommand` 命令与前两个命令不同，因为它不需要任何参数。它确实使用了 `IUserInterface` 依赖项和 `IInventoryContext`
    依赖项来写入集合的内容。如下所示：'
- en: '[PRE32]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: With the `GetInventoryCommand` command implemented, the next step is to add
    a new test.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现了 `GetInventoryCommand` 命令之后，下一步是添加一个新的测试。
- en: GetInventoryCommandTest
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: GetInventoryCommandTest
- en: '`GetInventoryCommandTest` covers a scenario when the `GetInventoryCommand`
    command is used to retrieve the collection of books. The test will define the
    expected messages (remember that the first parameter is for the parameters, the
    second parameter is for messages, and the third parameter is for warnings) that
    will occur when testing the user interface:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetInventoryCommandTest` 覆盖了当使用 `GetInventoryCommand` 命令检索书籍集合的场景。测试将定义在测试用户界面时可能发生的预期消息（记住，第一个参数用于参数，第二个参数用于消息，第三个参数用于警告）：'
- en: '[PRE33]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'These messages will correspond to the mock repository, as follows:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 这些消息将与模拟仓库对应，如下所示：
- en: '[PRE34]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'The unit test runs the command with the mock dependencies. It verifies that
    the command executed without error and that the command is not a terminating command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试运行带有模拟依赖项的命令。它验证命令执行无误，并且命令不是终止命令：
- en: '[PRE35]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The expected messages are validating in `TestUserInterface` and, hence, the
    only thing that remains for the unit test to do is to make sure that no books
    were mysteriously added or updated by the command:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 预期消息在 `TestUserInterface` 中进行验证，因此单元测试需要确保没有书籍被命令神秘地添加或更新：
- en: '[PRE36]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Now that suitable unit tests for the `GetInventoryCommand` class have been added,
    we'll introduce the factory pattern in order to manage the creation of specific
    commands.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在已经为 `GetInventoryCommand` 类添加了合适的单元测试，我们将引入工厂模式来管理特定命令的创建。
- en: The factory pattern
  id: totrans-162
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工厂模式
- en: The next pattern applied by the team is the GoF factory pattern. The pattern
    introduces a **creator** whose responsibility is the instantiation of implementations
    of a specific type. Its purpose is to encapsulate the complexity around constructing
    types. The factory pattern allows for more flexibility as the application changes,
    by limiting the amount of required change compared to whether the construction
    was in the calling class. This is because the complexity of the construction is
    in one location, instead of distributed in multiple locations across the application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 团队接下来应用的模式是 GoF 工厂模式。该模式引入了一个 **创建者**，其职责是实例化特定类型的实现。其目的是封装构建类型周围的复杂性。工厂模式允许在应用程序变化时提供更多灵活性，通过限制与在调用类中构建相比所需更改的数量来实现。这是因为构建的复杂性位于一个位置，而不是分散在应用程序的多个位置。
- en: In the FlixOne example, `InventoryCommandFactory` implements the pattern and
    shields the details of constructing each of the different `InventoryCommand` instances.
    In this scenario, the input received from the console application will be used
    to determine the concrete implementation of `InventoryCommand` to return. It is
    important to note that the return type is the `InventoryCommand` abstract class,
    thus shielding the calling class from the details of the concrete class.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在 FlixOne 示例中，`InventoryCommandFactory` 实现了该模式，并屏蔽了构建每个不同的 `InventoryCommand`
    实例的细节。在这种情况下，从控制台应用程序接收的输入将用于确定要返回的 `InventoryCommand` 的具体实现。需要注意的是，返回类型是 `InventoryCommand`
    抽象类，因此屏蔽了调用类对具体类的细节。
- en: '`InventoryCommandFactory` is shown in the following code block. But, for now,
    focus on the `GetCommand` method as this implements the factory pattern:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommandFactory` 在下面的代码块中展示。但，目前请关注 `GetCommand` 方法，因为它实现了工厂模式：'
- en: '[PRE37]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`GetCommand` uses a given string to determine the specific implementation of
    `InventoryCommand` to return:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetCommand` 使用给定的字符串来确定要返回的 `InventoryCommand` 的具体实现：'
- en: '[PRE38]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: All commands require `IUserInterface` to be supplied, but some also require
    access to the repository. These will be supplied with the singleton instance of
    `IInventoryContext`.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命令都需要提供 `IUserInterface`，但其中一些还需要访问仓库。这些将通过 `IInventoryContext` 的单例实例来提供。
- en: The factory pattern is often used with an Interface as the return type. It is
    illustrated here as the `InventoryCommand` base class.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 工厂模式通常与接口作为返回类型一起使用。这里以 `InventoryCommand` 基类为例进行说明。
- en: Unit tests
  id: totrans-171
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 单元测试
- en: At first glance, the idea of building unit tests for such a simple class seemed
    like a waste of the team's time. Two important issues were uncovered by constructing
    the unit tests that might have gone undetected.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 乍一看，为这样一个简单的类编写单元测试似乎是在浪费团队的时间。通过构建单元测试，发现了两个可能未被察觉的重要问题。
- en: Issue one – UnknownCommand
  id: totrans-173
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题一 – UnknownCommand
- en: 'The first issue was what to do when a command is received that does not match
    any of the defined `InventoryCommand` inputs. After reviewing the requirements,
    the team noticed they missed this requirement, as shown in the following screenshot:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个问题是在收到不匹配任何定义的 `InventoryCommand` 输入的命令时应该做什么。在审查需求后，团队注意到他们遗漏了这个要求，如下面的截图所示：
- en: '![](img/2609a169-37d7-4a74-8aac-65d25b8c1a77.png)'
  id: totrans-175
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2609a169-37d7-4a74-8aac-65d25b8c1a77.png)'
- en: 'The team decided to introduce a new `InventoryCommand` class, `UnknownCommand`,
    to handle this situation. The `UnknownCommand` class should print a warning message
    to the console (via the `IUserInterface` `WriteWarning` method), should not cause
    the application to end, and should return false to indicate that the command was
    not run successfully. The implementation details are shown in the following code:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 团队决定引入一个新的 `InventoryCommand` 类，`UnknownCommand`，来处理这种情况。`UnknownCommand` 类应该在控制台（通过
    `IUserInterface` 的 `WriteWarning` 方法）打印一条警告信息，不应该导致应用程序结束，并且应该返回 `false` 来指示命令没有成功执行。实现细节如下所示：
- en: '[PRE39]'
  id: totrans-177
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The unit test created for `UnknownCommand` will test for the warning message
    as well as the two Boolean values returned by the `InternalCommand` method:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为 `UnknownCommand` 创建的单元测试将测试警告信息以及 `InternalCommand` 方法返回的两个布尔值：
- en: '[PRE40]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`UnknownCommandTests` covers the commands that require testing. Next, tests
    around `InventoryCommandFactory` will be implemented.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '`UnknownCommandTests` 覆盖了需要测试的命令。接下来，将实现围绕 `InventoryCommandFactory` 的测试。'
- en: InventoryCommandFactoryTests
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: InventoryCommandFactoryTests
- en: '`InventoryCommandFactoryTests` contains unit tests related to `InventoryCommandFactory`.
    Because each test will have a similar pattern of constructing `InventoryCommandFactory`
    and its `IUserInterface` dependency and then running the `GetCommand` method,
    a shared method is created that will run when the test initializes:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommandFactoryTests` 包含与 `InventoryCommandFactory` 相关的单元测试。因为每个测试都将具有构建
    `InventoryCommandFactory` 及其 `IUserInterface` 依赖项并运行 `GetCommand` 方法的类似模式，因此创建了一个将在测试初始化时运行的方法：'
- en: '[PRE41]'
  id: totrans-183
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'The `Initialize` method constructs a stubbed `IUserInterface` and sets the
    `Factory` property. The individual unit tests then take a simple form of validating
    that the object returned is the correct type. First, an instance of the `QuitCommand`
    class should be returned when the user enters `"q"` or `"quit"`, as follows:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: '`Initialize` 方法构建了一个模拟的 `IUserInterface` 并设置了 `Factory` 属性。然后，各个单元测试以简单的形式验证返回的对象是否为正确的类型。首先，当用户输入
    `"q"` 或 `"quit"` 时，应该返回 `QuitCommand` 类的实例，如下所示：'
- en: '[PRE42]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'The `QuitCommand_Successful` test method validates that when the `InventoryCommandFactory`
    method, `GetCommand`, is run, the object returned is a specific instance of the
    `QuitCommand` type. `HelpCommand` is only available when `"?"` is submitted:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '`QuitCommand_Successful` 测试方法验证当运行 `InventoryCommandFactory` 的 `GetCommand`
    方法时，返回的对象是 `QuitCommand` 类的特定实例。`HelpCommand` 仅在提交 `"?"` 时可用：'
- en: '[PRE43]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'The team did add a test for `UnknownCommand` that validated how `InventoryCommand`
    would respond when given a value not matching an existing command:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 团队确实为 `UnknownCommand` 添加了一个测试，以验证当给 `InventoryCommand` 提供一个不匹配现有命令的值时，它会如何响应：
- en: '[PRE44]'
  id: totrans-189
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: With the test methods in place, we can now cover a scenario where a command
    is given that does not match a known command in the application.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 在测试方法就绪后，我们现在可以覆盖一个场景，即当给出一个不匹配应用程序中已知命令的命令时。
- en: Issue two – case-insensitive text commands
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题二 – 不区分大小写的文本命令
- en: 'The second issue was uncovered when the requirements were reviewed again, stating
    that the commands should not be case-sensitive:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个问题是在再次审查需求时发现的，指出命令不应该区分大小写：
- en: '![](img/10cf9ef0-f9f0-459d-969c-1ded9e9e093e.png)'
  id: totrans-193
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/10cf9ef0-f9f0-459d-969c-1ded9e9e093e.png)'
- en: 'With the test for `UpdateInventoryCommand`, `InventoryCommandFactory` was found
    to be case-sensitive using the following test:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `UpdateInventoryCommand` 的测试中，`InventoryCommandFactory` 被发现是区分大小写的，如下所示：
- en: '[PRE45]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'Fortunately, this test was easy to solve by applying a `ToLower()` method to
    the input before determining the command, as follows:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，通过在确定命令之前将输入应用 `ToLower()` 方法，这个测试很容易解决，如下所示：
- en: '[PRE46]'
  id: totrans-197
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This scenario highlights both the value of the `Factory` method and the value
    of leveraging unit tests to help validate requirements during development and
    not relying on user testing.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 这种情况突出了 `Factory` 方法的价值以及利用单元测试来帮助验证开发期间的需求的价值，而不是依赖于用户测试。
- en: Features in .NET Core
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET Core中的功能
- en: '[Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns – Basics Part 1,* and the first part of this chapter have illustrated
    the GoF patterns without using any frameworks. It is worth covering this as, sometimes,
    a framework is not available for a specific pattern or applicable in a particular
    scenario. Additionally, it is important to understand what functionality the framework
    is providing in order to know when a pattern should be used. The rest of this
    chapter will look at a couple of features that .NET Core provides that support
    some of the patterns we have covered so far.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)，*实现设计模式 - 基础部分1*，以及本章的第一部分展示了在不使用任何框架的情况下如何实现GoF模式。有时候，对于特定的模式或特定场景，可能没有可用的框架。此外，了解框架提供的功能也很重要，以便知道何时应该使用模式。本章的其余部分将探讨.NET
    Core提供的几个功能，这些功能支持我们迄今为止所讨论的一些模式。'
- en: IServiceCollection
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IServiceCollection
- en: .NET Core was designed with **Dependency Injection** (**DI**) built-in to the
    framework. Typically, the start of a .NET Core application contains the set up
    of the DI for an application that primarily contains the creation of a collection
    of services. The framework uses these services to supply the dependencies when
    the application requires them. The services provide the foundation of a robust
    **Inversion of Control** (**IoC**) framework and are arguably one of the coolest
    features of .NET Core. This section will complete the console application and
    demonstrate how .NET Core supports building a sophisticated IoC framework based
    on the `IServiceCollection` interface.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: .NET Core的设计中内置了 **依赖注入（Dependency Injection，DI**）。通常，.NET Core应用程序的开始包含为应用程序设置DI，这主要涉及创建服务集合。框架使用这些服务在应用程序需要时提供依赖项。服务提供了强大
    **控制反转（Inversion of Control，IoC**）框架的基础，并且可以说是.NET Core中最酷的功能之一。本节将完成控制台应用程序，并演示.NET
    Core如何支持基于 `IServiceCollection` 接口构建复杂的IoC框架。
- en: 'The `IServiceCollection` interface is used to define the services available
    to the container that implements `IServiceProvider` interface. The services themselves
    are types that will be injected at runtime when required by the application. For
    example, `ConsoleUserInterface` interface, which was defined previously, will
    be a service injected at runtime. This is shown in the following code:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`IServiceCollection` 接口用于定义容器中可用的服务，该容器实现了 `IServiceProvider` 接口。服务本身是类型，当应用程序需要时将在运行时注入。例如，之前定义的
    `ConsoleUserInterface` 接口将在运行时注入为一个服务。这如下面的代码所示：'
- en: '[PRE47]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the preceding code, `ConsoleUserInterface` interface is being added as a
    service that implements the `IUserInterface` interface. If the DI is providing
    another type that requires a `IUserInterface` interface dependency, then `ConsoleUserInterface`
    interface will be used. For example, `InventoryCommandFactory` is also added to
    the services, as shown in the following code:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`ConsoleUserInterface` 接口被添加为一个实现了 `IUserInterface` 接口的服务。如果依赖注入（DI）提供了另一个需要
    `IUserInterface` 接口依赖的类型，那么将使用 `ConsoleUserInterface` 接口。例如，`InventoryCommandFactory`
    也被添加到服务中，如下面的代码所示：
- en: '[PRE48]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '`InventoryCommandFactory` has a constructor that requires an implementation
    of the `IUserInterface` interface:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: '`InventoryCommandFactory` 有一个构造函数，它需要一个 `IUserInterface` 接口的实现：'
- en: '[PRE49]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: 'Later, an instance of `InventoryCommandFactory` is requested, as follows:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，请求了一个 `InventoryCommandFactory` 的实例，如下所示：
- en: '[PRE50]'
  id: totrans-210
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Then, an instance of `IUserInterface` (in this application it is the registered
    `ConsoleUserInterface`) is instantiated and supplied to the constructor of `InventoryCommandFactory`.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建了一个 `IUserInterface` 的实例（在这个应用程序中是已注册的 `ConsoleUserInterface`），并将其提供给 `InventoryCommandFactory`
    的构造函数。
- en: There are different types of service *lifetimes* that can be specified when
    registering a service. A lifetime governs how the types will be instantiated and
    include Transient, Scoped, and Singleton. Transient means the service is created
    each time it is requested. Scope will be covered later when we look at website-related
    patterns and in particular where services are created per web request. Singleton
    behaves like the singleton pattern we covered earlier, and will also be covered
    later in this chapter.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册服务时，可以指定不同类型的服务生命周期。生命周期决定了类型将被如何实例化，包括瞬态（Transient）、作用域（Scoped）和单例（Singleton）。瞬态意味着每次请求时都会创建服务。作用域将在我们查看与网站相关的模式时进行介绍，特别是当服务按每个Web请求创建时。单例的行为类似于我们之前讨论的单例模式，也将在本章后面进行介绍。
- en: CatalogService
  id: totrans-213
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: CatalogService
- en: 'The `CatalogService` interface represents the console application the team
    is building and is described as having a single `Run` method, as shown in the
    `ICatalogService` interface:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: '`CatalogService`接口代表了团队正在构建的控制台应用程序，并描述为具有单个`Run`方法，如`ICatalogService`接口所示：'
- en: '[PRE51]'
  id: totrans-215
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'The service has two dependencies, `IUserInterface` and `IInventoryCommandFactory`,
    and they will be injected into the constructor and stored as local variables:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 该服务有两个依赖项，`IUserInterface`和`IInventoryCommandFactory`，它们将被注入到构造函数中并作为局部变量存储：
- en: '[PRE52]'
  id: totrans-217
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'The `Run` method is based on the earlier design by the team shown in [Chapter
    3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design Patterns
    – Basics Part 1.* It prints a greeting and then loops until the quit inventory
    command is entered by the user. Each loop will perform the command and, if the
    command is not successful, it will print a help message:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`Run`方法基于团队在第3章[3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml]《实现设计模式 – 基础部分1》中之前的设计。它打印一个问候语，然后循环直到用户输入退出库存命令。每个循环将执行命令，如果命令未成功，它将打印一个帮助信息：'
- en: '[PRE53]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: Now that we have the `CatalogService` interface ready, the next step will be
    to put everything together. The next section will do this using .NET Core.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好了`CatalogService`接口，下一步将是将所有内容整合在一起。下一节将使用.NET Core来完成这项工作。
- en: IServiceProvider
  id: totrans-221
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: IServiceProvider
- en: 'With `CatalogService` defined, the team is finally able to put everything together
    in .NET Core. The start of all applications, that is, EXE programs, is the `Main`
    method, and .NET Core is no exception. The program is shown in the following code:'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了`CatalogService`之后，团队终于能够在.NET Core中将所有内容整合在一起。所有应用程序的开始，即EXE程序，是`Main`方法，.NET
    Core也不例外。程序如下所示：
- en: '[PRE54]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the `ConfigureServices` method, different types are added to the IoC container
    including `ConsoleUserInterface`, `CatalogService`, and `InventoryCommandFactory`
    classes. The `ConsoleUserInterface` and `InventoryCommandFactory` class will be
    injected as required and the `CatalogService` class will be explicitly retrieved
    from the `IServiceProvider` interface built from the `ServiceCollection` object
    containing the added types. The program *runs* until the `CatalogService` `Run`
    method completes.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 在`ConfigureServices`方法中，将不同类型添加到IoC容器中，包括`ConsoleUserInterface`、`CatalogService`和`InventoryCommandFactory`类。`ConsoleUserInterface`和`InventoryCommandFactory`类将按需注入，而`CatalogService`类将显式地从由包含已添加类型的`ServiceCollection`对象构建的`IServiceProvider`接口中检索。程序将一直运行，直到`CatalogService`的`Run`方法完成。
- en: In [Chapter 5](fd71001a-4673-4391-a10b-2490e07f135e.xhtml), *Implementing Design
    Patterns - .NET Core*, the singleton pattern will be revisited to use the .NET
    Core built-in capabilities by using the `IServiceCollection`, `AddSingleton` method
    to control the `InventoryContext` instance.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第5章](fd71001a-4673-4391-a10b-2490e07f135e.xhtml)《实现设计模式 - .NET Core》中，将重新审视单例模式，通过使用.NET
    Core内置的`IServiceCollection`和`AddSingleton`方法来控制`InventoryContext`实例，以利用.NET Core的内置功能。
- en: Console application
  id: totrans-226
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制台应用程序
- en: 'The console application, when running from the command line, is simple, but
    it is a foundation of well-designed code adhering to the SOLID principles discussed
    in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing Design
    Patterns – Basics Part 1*. When run, the application provides a simple greeting
    and displays a help message, including the command''s supports and examples:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 控制台应用程序在命令行中运行时很简单，但它是一个遵循第3章[3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml]《实现设计模式
    – 基础部分1》中讨论的SOLID原则的良好设计的代码的基础。运行时，应用程序会提供一个简单的问候语并显示帮助信息，包括命令的支持和示例：
- en: '![](img/2b227f12-9b64-4501-9190-7385cf1f6d34.png)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/2b227f12-9b64-4501-9190-7385cf1f6d34.png)'
- en: 'The application then loops through the commands until a quit command is received.
    The following screenshot illustrates its functionality:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序随后会循环遍历命令，直到接收到退出命令。以下截图说明了其功能：
- en: '![](img/23375dec-001c-4064-9278-19da5d745827.png)'
  id: totrans-230
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/23375dec-001c-4064-9278-19da5d745827.png)'
- en: This was not the most impressive of console applications, but it served to illustrated
    many principles and patterns.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个最令人印象深刻的控制台应用程序，但它有助于说明许多原理和模式。
- en: Summary
  id: totrans-232
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Similar to [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml), *Implementing
    Design Patterns – Basics Part 1,* this chapter continued the description of building
    an inventory management console application for FlixOne, in order to show practical
    examples of using **Object-Oriented Programming** (**OOP**) design patterns. In
    this chapter,the GoF's singleton and factory patterns were the focus. These two
    patterns have a particularly important role to play in .NET Core applications
    and will be used often in the following chapters. An introduction to using the
    built-in framework to provide an IoC container was also covered in this chapter.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 与[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)，“实现设计模式 - 基础部分1”类似，本章继续描述为FlixOne构建库存管理控制台应用程序，以展示使用**面向对象编程**（**OOP**）设计模式的实际示例。在本章中，GoF的单一模式和工厂模式是重点。这两个模式在.NET
    Core应用程序中扮演着特别重要的角色，将在接下来的章节中经常使用。本章还介绍了如何使用内置框架提供IoC容器。
- en: This chapter finished with a working inventory management console application
    based on the requirements determined in [Chapter 3](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml),
    *Implementing Design Patterns – Basics Part 1*. These requirements were the basis
    of the unit tests created in both chapters and were used to illustrate TDD. The
    team has a higher level of confidence that the application will pass the **User
    Acceptance Testing** (**UAT**) by having a suite of tests that verify the features
    required for this phase of development.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 本章以一个基于[第3章](3a038a92-9207-4232-9acd-d17cb24da6c5.xhtml)，“实现设计模式 - 基础部分1”中确定的要求的库存管理控制台应用程序结束。这些要求是两章中创建的单元测试的基础，并用于说明测试驱动开发（TDD）。通过拥有一套验证此开发阶段所需功能的测试，团队对应用程序通过**用户验收测试**（**UAT**）有更高的信心。
- en: In the next chapter, we will continue with the description of building the inventory
    management application. The focus will move from basic OOP patterns to using the
    .NET Core framework to implement different patterns. For example, the singleton
    pattern introduced in this chapter will be refactored to use the capability of
    `IServiceCollection` to create a singleton, and we will also take a closer look
    at its DI capabilities. Additionally, the application will be extended to support
    logging using a variety of logging providers.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续描述构建库存管理应用程序的过程。重点将从基本的OOP模式转移到使用.NET Core框架实现不同的模式。例如，本章中引入的单一模式将被重构以使用`IServiceCollection`的能力来创建单一实例，我们还将更详细地研究其依赖注入（DI）能力。此外，应用程序将扩展以支持使用各种日志提供程序进行日志记录。
- en: Questions
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'The following questions will allow you to consolidate the information contained
    in this chapter:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下问题将帮助您巩固本章包含的信息：
- en: Provide an example why using a singleton **would not** be a good mechanism for
    limiting access to a shared resource.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 提供一个示例，说明为什么使用单一模式**不是**限制对共享资源访问的好机制。
- en: Is the following statement true? Why or why not? `ConcurrentDictionary` prevents
    items in the collection from being updated by more than one thread at a time.
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下陈述是否正确？为什么或为什么不正确？`ConcurrentDictionary`防止集合中的项目同时被多个线程更新。
- en: What is a race condition and why should it be avoided?
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 什么是竞态条件，为什么应该避免它？
- en: How does the factory pattern help to simplify code?
  id: totrans-241
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 工厂模式如何帮助简化代码？
- en: Do .NET Core applications require third-party IoC containers?
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: .NET Core应用程序是否需要第三方IoC容器？
