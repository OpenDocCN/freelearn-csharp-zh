- en: Chapter 6. SQL Database Programming
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第6章 SQL数据库编程
- en: This chapter deals with access to databases built according to the principles
    of the relational model, which—generally speaking—we refer to as SQL databases
    due to the language used to manipulate their data. In the next chapter, we will
    take a look at the emerging noSQL database model.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章讨论根据关系模型原则构建的数据库的访问，通常我们将其称为SQL数据库，因为使用该语言来操作其数据。在下一章中，我们将探讨新兴的noSQL数据库模型。
- en: Note
  id: totrans-2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that we will not go in depth about data access here. This will just be
    a quick review of the most common possibilities you have in order to access database
    systems build according to the relational model.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们在这里不会深入探讨数据访问。这只是一个快速回顾，介绍您在根据关系模型构建的数据库系统中可以使用的最常见可能性。
- en: Here, we will quickly review the rules and foundations of the relational model
    (schemas, Normal Form Rules, and so on) before getting into SQL Server 2014, the
    **database management system** (**DBMS**) that I'll use in this chapter. Additionally,
    we'll go through the process of installing SQL Server 2014 Express Edition (totally
    free) along with some sample databases that will help us with the demos.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们将在介绍SQL Server 2014（我将在本章中使用）之前，快速回顾关系模型（模式、范式规则等）的规则和基础。此外，我们还将介绍安装SQL
    Server 2014 Express Edition（完全免费）的过程，以及一些示例数据库，这些数据库将帮助我们进行演示。
- en: In this section, we will also cover a not-so-common type of project that Visual
    Studio offers to deal with databases, the SQL Server Project Template, and explore
    how we can configure many aspects of the target database that our application
    uses straight from Visual Studio. We will even be able to save all this configuration
    in a `.dacpac` file, which can be later replicated in any other machine.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们还将介绍Visual Studio提供的一种不太常见的项目类型，用于处理数据库，即SQL Server项目模板，并探讨我们如何直接从Visual
    Studio配置目标数据库的许多方面。我们甚至可以将所有这些配置保存为`.dacpac`文件，该文件可以在任何其他机器上复制。
- en: Then, we'll cover the basic .NET Framework database engines recommended for
    data management. We'll start with a reminder of the initial engine that appeared
    with version 1.0 (ADO.NET), passing from there to the Entity Framework model (the
    most common and the one recommended by Microsoft), which is already in its version
    6.1 (although the new version aligns with the .NET Core wave, and it has been
    published under the name Entity Framework 1.1 recently).
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将介绍基本.NET Framework数据库引擎，这些引擎被推荐用于数据管理。我们将从版本1.0（ADO.NET）中出现的初始引擎开始提醒，然后过渡到实体框架模型（最常见且由微软推荐），该模型已经达到6.1版本（尽管新版本与.NET
    Core浪潮保持一致，并且最近以Entity Framework 1.1的名义发布）。
- en: We'll discover how to build an ORM data schema from one of the demo databases
    and how to query and manipulate data with EF and some of the new possibilities
    that these versions offer to the programmer.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将了解如何从一个演示数据库中构建ORM数据模式，以及如何使用EF查询和操作数据，以及这些版本为程序员提供的一些新可能性。
- en: 'Overall, we''ll cover the following topics in this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 总体而言，本章将涵盖以下主题：
- en: A refresher view of the Database Relational Model
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据库关系模型的复习
- en: The SQL Server 2014 Database system, installation, and features
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: SQL Server 2014数据库系统、安装和功能
- en: The SQL Server Project template in Visual Studio
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio中的SQL Server项目模板
- en: Basic data access from ADO.NET
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ADO.NET进行基本数据访问
- en: Basic data access with Entity Framework 6.0 using the Database-first *flavor*
    as used with an ASP.NET MVC application
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Database-first *flavor*进行Entity Framework 6.0的基本数据访问，类似于ASP.NET MVC应用程序
- en: The relational model
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关系模型
- en: Up until 1970, data access was diverse in nature and management. No standard
    or common approaches were available, and the term used to refer to what we now
    understand as databases was data banks, but their structures were quite different.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 直到1970年，数据访问在性质和管理上都是多样化的。没有标准或常见的途径可用，我们今天理解的数据库所使用的术语是数据银行，但它们的结构相当不同。
- en: Of course, there were other models, such as the hierarchical model and the network
    model, but their specifications were somewhat informal.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有其他模型，如层次模型和网络模型，但它们的规范有些非正式。
- en: In 1969 and the following years, an engineer at IBM (E.F. Codd) started publishing
    a series of papers in which he established the foundations of what we now understand
    as the relational model; especially, his paper, *The relational model for database
    management*, is now considered the RM manifesto. In this model, all data is represented
    in terms of tuples, and these tuples are grouped into relations. As a result,
    a database organized in terms of the relational model is called a relational database.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 在1969年和随后的几年里，IBM的一名工程师（E.F. Codd）开始发表一系列论文，其中他确立了我们现在理解的关系模型的基础；特别是，他的论文《数据库管理的关系模型》现在被认为是RM宣言。在这个模型中，所有数据都是用元组表示的，这些元组被分组到关系中。因此，按照关系模型组织的数据库被称为关系数据库。
- en: Properties of relational tables
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关系表属性
- en: 'The following are the properties of relational tables:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是关系表的属性：
- en: All data is offered in terms of collections of relations.
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有数据都是以关系集合的形式提供的。
- en: Each relation is described as a table. A table is composed of columns and rows.
  id: totrans-21
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个关系都描述为一个表。一个表由列和行组成。
- en: Columns are attributes of the entity, modeled by the table's definition (in
    a customer table, you could have `customerID`, `e-mail`, `account`, and so on).
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 列是实体的属性，由表的定义建模（在一个客户表中，你可能会有`customerID`、`e-mail`、`account`等等）。
- en: Each row (or tuple) represents a single entity (that is, in a customer table,
    `1234`, `thecustomer@site.com`, `1234`, `5678`, and so on, would denote a row
    with a single customer).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每一行（或元组）代表一个单一实体（也就是说，在一个客户表中，`1234`、`thecustomer@site.com`、`1234`、`5678`等等，将表示一个包含单个客户的行）。
- en: Every table has a set of attributes (one or more) that can be taken as a key,
    which uniquely identifies each entity (in the customer table, customer ID would
    specify only one customer, and this value should be unique in the table).
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个表都有一组属性（一个或多个），可以作为键使用，唯一地标识每个实体（在客户表中，客户ID将指定单个客户，并且这个值在表中应该是唯一的）。
- en: Many types of keys offer several possibilities, but the two most important are
    the primary key and the foreign key. While the former identifies tuples uniquely,
    the latter sits at another table, allowing the establishment of relations between
    tables. It is in this way that we can query data that relates to two or more tables
    based on a common field (this field does not have to be named as the other with
    which we will match; it only has to be of the same data type).
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 许多类型的键提供了多种可能性，但最重要的两种是主键和外键。前者唯一地标识元组，后者位于另一个表中，允许建立表之间的关系。正是通过这种方式，我们可以根据公共字段查询与两个或多个表相关的数据（这个字段不需要命名为我们将与之匹配的另一个字段；它只需要是相同的数据类型）。
- en: The relational model is based on Relational Algebra (also described by E.F.
    Codd, who proposed this algebra as a basis for database query languages, and thus
    the relation with set theory). This algebra uses a set union, set difference,
    and Cartesian product from a set theory and adds additional constraints to these
    operators, such as `select`, `project`, and `join`.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 关系模型基于关系代数（也被E.F. Codd描述，他提出这种代数作为数据库查询语言的基础，因此与集合论相关）。这种代数使用集合的并集、差集和笛卡尔积，并给这些操作符添加了额外的约束，例如`select`、`project`和`join`。
- en: 'These operations have a direct correspondence in the SQL Language, which is
    used to manipulate data, and basically, we find the following:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 这些操作在SQL语言中有直接的对应关系，SQL语言用于操作数据，基本上我们找到以下内容：
- en: '**Select**: It recovers values for rows in a table (optionally, with a given
    criteria)'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**选择**：它从表中恢复行值（可选地，根据给定的标准）'
- en: '**Project**: It reads values for select attributes'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**投影**：它读取选择的属性值'
- en: '**Join**: It combines information from two or more tables (or only one, taken
    as a second table)'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接**：它结合两个或多个表（或仅一个，作为第二个表）的信息'
- en: '**Intersect**: It shows rows present in two tables'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交集**：它显示两个表中都存在的行'
- en: '**Union**: It shows rows from multiple tables and removes the duplicate rows'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**并集**：它显示多个表中的行并删除重复的行'
- en: '**Difference**: It recovers rows in one table that are not found in another
    table'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**差集**：它恢复一个表中不存在于另一个表中的行'
- en: '**Product**: The cartesian product combines all rows from two or more tables
    and is normally used with filter clauses and foreign key relations'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**积**：笛卡尔积结合了两个或多个表中的所有行，通常与过滤子句和外部键关系一起使用'
- en: 'Another important aspect of the relational model is that ensures data integrity
    by means of a set of rules. Mainly, there are five rules that have to be considered:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 关系模型的一个重要方面是通过一系列规则确保数据完整性。主要的是，有五个规则必须考虑：
- en: 'The order of tuples and/or attributes doesn''t matter: If you have the ID before
    e-mail, it is the same as the e-mail before the ID).'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 元组和/或属性顺序不重要：如果你在电子邮件之前有ID，这与在ID之前有电子邮件是相同的。
- en: Every tuple is unique. For every tuple in a table, there is a combination of
    values that uniquely identifies it.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个元组都是唯一的。对于表中的每个元组，都有一个唯一标识它的值组合。
- en: Every field contains only single values. Or, if you want, each of the table's
    cells should only hold one value. This is derived from the First Normal Form;
    we'll come to that later.
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个字段只包含单个值。或者说，如果你愿意，每个表单元格应该只包含一个值。这是由第一范式推导出来的；我们稍后会讨论这一点。
- en: All values within an attribute (think of it as a column) are from the same domain.
    That is, only values allowed by the attribute's definition are allowed, either
    number, characters, dates, and so on. Their practical implementation will depend
    on the type definitions permitted by the database engine.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个属性（可以将其视为列）内的所有值来自同一个域。也就是说，只有允许由属性定义的值是允许的，无论是数字、字符、日期等等。它们的实际实现将取决于数据库引擎允许的类型定义。
- en: Identifiers of tables must be unique in a single database, and the same goes
    for columns in tables.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 表的标识符在单个数据库中必须是唯一的，表中的列也是如此。
- en: The principles and rules mentioned hereby are formalized by the Normal Form
    Rules (generally called **Normalization**). They establish a number of rules to
    reinforce data integrity. However, in practice, only the three first rules (1NF,
    2NF, and 3NF) are applied in everyday business and even the third one admits a
    *de-normalization* process in order to avoid unnecessary complexities in design
    on some occasions.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 本文中提到的原则和规则通过范式规则（通常称为**规范化**）形式化。它们建立了一系列规则来加强数据完整性。然而，在实践中，只有前三个规则（1NF、2NF和3NF）在日常业务中应用，甚至第三个规则在某些情况下也允许进行**反规范化**过程，以避免设计中的不必要复杂性。
- en: 'In a very succinct way, these are the requirements of the three normative Normal
    Forms:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，这些是三个规范性范式的要求：
- en: '**1NF**: It eliminates duplicative columns from the same table. That is, create
    separate tables for each group of related data and identify each row with a primary
    key.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**1NF**：它消除了同一表中重复的列。也就是说，为每组相关数据创建单独的表，并用主键标识每一行。'
- en: '**2NF**: It eliminates subsets of data that apply to more than one row of a
    table, and creates a new table with them. Later, you can create foreign keys to
    maintain relationships between the tables.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2NF**：它消除了适用于表的多行数据的子集，并创建了一个包含它们的新的表。之后，你可以创建外键来维护表之间的关系。'
- en: '**3NF**: It deletes all columns that are not dependent upon the primary key.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**3NF**：它删除了所有不依赖于主键的列。'
- en: With these normal forms, our data integrity is guaranteed in 99% of the cases,
    and we can exploit our bank of data using SQL in a very efficient way. Keep in
    mind that those keys that uniquely identify each table's rows allow the creation
    of indexes, which are additional files intended to speed up and ease data recovery.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这些范式，我们的数据完整性在99%的情况下得到保证，并且我们可以非常高效地利用我们的数据银行使用SQL。记住，那些唯一标识每个表行键允许创建索引，这些索引是额外的文件，旨在加快和简化数据恢复。
- en: 'In the case of SQL Server (and other DBMS), two types of indexes are allowed:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在SQL Server（和其他数据库管理系统）的情况下，允许两种类型的索引：
- en: '**Clustered indexes**: They can be only one per table. They are extremely fast
    data structures that should be based on a short-length field(s) and preferably
    over a field(s) that don''t change, such as customer ID in the example we mentioned
    earlier.'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**聚集索引**：每个表只能有一个。它们是极快的结构化数据，应该基于短字段长度，并且最好是基于那些不会改变的字段，例如我们之前提到的客户ID。'
- en: '**Non-clustered indexes**: We can define several per table and allow improvements
    in speed, especially in reading, joining, and filtering operations. It is recommended
    that the candidate fields be those that appear in `WHERE` and `JOIN` clauses,
    preferably.'
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**非聚集索引**：每个表可以定义多个，并允许在读取、连接和过滤操作中提高速度。建议候选字段是那些出现在`WHERE`和`JOIN`子句中的字段。'
- en: The tools – SQL Server 2014
  id: totrans-50
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工具 – SQL Server 2014
- en: In this chapter, I'm using SQL Server 2014 Express Edition, which is free to
    install and includes an optional installation of **SQL Server Management Studio**
    (**SSMS**), the visual tool that allows the user to manage all objects inside
    the DBMS, but you can also use the 2016 version, which holds identical (an extended)
    features.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我使用的是SQL Server 2014 Express Edition，它是免费安装的，包括可选安装**SQL Server Management
    Studio**（**SSMS**），这是一个可视化工具，允许用户管理DBMS内的所有对象，但您也可以使用2016版本，它具有相同（扩展）的功能。
- en: You can find them at [https://www.microsoft.com/en-us/download/details.aspx?id=42299](https://www.microsoft.com/en-us/download/details.aspx?id=42299),
    and once they're installed, you'll see a new entry in your system's menu, including
    several tools related to this product. With SSMS ready, you should download and
    install some sample databases. I recommend Adventure Works 2014, which includes
    enough data to go ahead with the majority of typical situations you need to test
    in everyday programming.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://www.microsoft.com/en-us/download/details.aspx?id=42299](https://www.microsoft.com/en-us/download/details.aspx?id=42299)找到它们，一旦安装完成，您将在系统菜单中看到一个新条目，包括与该产品相关的几个工具。有了SSMS准备就绪，您应该下载并安装一些示例数据库。我推荐Adventure
    Works 2014，它包含足够的数据，可以应对您在日常编程中需要测试的大多数典型情况。
- en: 'There''s a version available at [http://msftdbprodsamples.codeplex.com/Releases](http://msftdbprodsamples.codeplex.com/Releases).
    Once it''s installed, simply open SQL Server Management Studio, and you should
    end up with an available copy of this database, as shown in the following screenshot:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在[http://msftdbprodsamples.codeplex.com/Releases](http://msftdbprodsamples.codeplex.com/Releases)有一个可用的版本。一旦安装，只需打开SQL
    Server Management Studio，您应该会看到一个可用的数据库副本，如下面的截图所示：
- en: '![The tools – SQL Server 2014](img/image00535.jpeg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![工具 – SQL Server 2014](img/image00535.jpeg)'
- en: 'You will find a bunch of tables organized in schemas (prefixes that denote
    a common area of data management, such as **HumanResources**, **Person**, or **Production**).
    If you''re not new to SQL Server or you already know other DBMSes, you won''t
    find the usual utilities to create and edit queries or other SQL-related commands
    strange. They are available via contextual menus when selecting any member of
    the list presented in SQL Server Explorer. Refer to the following screenshot:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 您将找到一些组织在模式（表示数据管理公共区域的名称，如**HumanResources**、**Person**或**Production**）中的表。如果您不熟悉SQL
    Server或已经了解其他DBMS，您不会觉得创建和编辑查询或其他SQL相关命令的常规工具奇怪。它们可以通过在SQL Server资源管理器中选择列表中的任何成员时出现的上下文菜单获得。请参考以下截图：
- en: '![The tools – SQL Server 2014](img/image00536.jpeg)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![工具 – SQL Server 2014](img/image00536.jpeg)'
- en: All actions required for standard database management are available from SSMS,
    so we can always check for results, SQL commands, test execution plans, creating
    and designing existing or new databases, establishing security requirements, and
    creating any other object that your backend business logic needs, with the ability
    to test it immediately, as you can infer from the previous screenshot.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 所有标准数据库管理所需的操作都可通过SSMS获得，因此我们可以始终检查结果、SQL命令、测试执行计划、创建和设计现有或新数据库、建立安全要求，以及创建任何其他后端业务逻辑需要的对象，并且可以立即对其进行测试，如前一个截图所示。
- en: Other helpful possibilities are also found in the editors, since—just like happens
    with Visual Studio—they offer Intellisense on the objects available at any time,
    editing SQL Server commands, code hints, syntax error suggestions, and much more.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 编辑器中还有其他有用的可能性，因为——就像在Visual Studio中发生的那样——它们提供了在任何时间可用的对象的Intellisense，编辑SQL
    Server命令、代码提示、语法错误建议等等。
- en: 'The programmer''s experience is also enhanced with advanced debugging capabilities,
    which enable debugging within SSMS or even from Visual Studio itself, so you are
    allowed to enable the **Remote Debugging** options and use breakpoints and all
    the usual artifacts, as if you were in a C# code debugging session:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 程序员的经验也得到了增强，因为高级调试功能允许在SSMS内或甚至从Visual Studio本身进行调试，因此您可以启用**远程调试**选项并使用断点和所有常规工具，就像您在进行C#代码调试会话一样：
- en: '![The tools – SQL Server 2014](img/image00537.jpeg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![工具 – SQL Server 2014](img/image00537.jpeg)'
- en: 'Furthermore, you can switch on the **Activity Monitor** window, which will
    show you a dashboard with different usage-related statistics for any SQL command
    launched from the SSMS:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以打开**活动监视器**窗口，它将显示一个仪表板，其中包含从SSMS启动的任何SQL命令的不同使用相关统计信息：
- en: '![The tools – SQL Server 2014](img/image00538.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![工具 – SQL Server 2014](img/image00538.jpeg)'
- en: The SQL language
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL语言
- en: Fortunately, the well-established foundations of the Relational Model converged
    on the creation of a standard, first published by **American National Standards**
    **Institute** (**ANSI**) in 1986, and followed by **International Organization
    for Standardization** (**ISO**) in 1987.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，关系模型稳固的基础促成了标准的创建，该标准最早于 1986 年由 **美国国家标准协会**（**ANSI**）发布，并在 1987 年由 **国际标准化组织**（**ISO**）跟进。
- en: Since then, the standard has been revised periodically to enhance the language
    with new features. Thus, a revision in 2003 included the XML data types and auto
    generated values (including identity columns), and this XML support was extended
    in 2006 in order to cover the import/export of XML data and XQuery features.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 从那时起，该标准定期修订，以通过新功能增强语言。因此，2003 年的修订包括了 XML 数据类型和自动生成的值（包括标识列），并在 2006 年扩展了
    XML 支持，以涵盖 XML 数据的导入/导出和 XQuery 功能。
- en: 'However, as Wikipedia reminds us:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正如维基百科提醒我们：
- en: Despite the existence of such standards, most SQL code is not completely portable
    among different database systems without adjustments.
  id: totrans-67
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 尽管存在这些标准，但大多数 SQL 代码在不同数据库系统之间没有调整的情况下并不能完全移植。
- en: At least we have a common background that allows us—via these adjustments—to
    write portable code that executes in diverse RDBMS.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 至少我们有一个共同的背景，这使我们能够通过这些调整编写可移植的代码，在多种关系型数据库管理系统（RDBMS）中执行。
- en: 'The version of SQL implemented in SQL Server is named **T-SQL** (**Transact-SQL**).
    As Wikipedia reminds:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在 SQL Server 中实现的 SQL 版本被称为 **T-SQL**（**Transact-SQL**）。正如维基百科提醒：
- en: T-SQL expands on the SQL standard to include procedural programming, local variables,
    various support functions for string processing, date processing, mathematics,
    and so on.
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: T-SQL 在 SQL 标准的基础上扩展了过程编程、局部变量、各种字符串处理、日期处理、数学等方面的支持函数。
- en: Moreover, you can find changes in the `DELETE` and `UPDATE` statements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你还可以在 `DELETE` 和 `UPDATE` 语句中找到变化。
- en: With all these additional features Transact-SQL becomes a *Turing complete*
    language.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些附加功能使得 Transact-SQL 成为了一个 *图灵完备* 语言。
- en: Tip
  id: totrans-73
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: 'Note that in computability theory, a system of data-manipulation rules (such
    as a computer''s instruction set, a programming language, or a cellular automaton)
    is said to be Turing complete or computationally universal if it can be used to
    simulate any single-taped Turing machine. Most of the widely accepted programming
    languages today, such as .NET languages, Java, C, among others, are said to be
    Turing complete. (Wikipedia: [https://en.wikipedia.org/wiki/Turing_completeness](https://en.wikipedia.org/wiki/Turing_completeness)).'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在可计算理论中，如果一个数据处理规则系统（如计算机的指令集、编程语言或细胞自动机）能够模拟任何单带图灵机，那么它就被认为是图灵完备的或计算上通用的。今天广泛接受的编程语言，如
    .NET 语言、Java、C 等，都被认为是图灵完备的。（维基百科：[https://en.wikipedia.org/wiki/Turing_completeness](https://en.wikipedia.org/wiki/Turing_completeness)）。
- en: As we said, T-SQL is a very powerful language, allowing variable declarations,
    flow control, improvements to `DELETE` and `UPDATE` statements and `TRY/CATCH`
    exception handling, among many others. For a complete reference of the T-SQL language,
    go to *Transact-SQL Reference (Database Engine)* at [https://msdn.microsoft.com/en-us/library/bb510741.aspx](https://msdn.microsoft.com/en-us/library/bb510741.aspx),
    since the details of this languages deserve a book of its own.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们所说，T-SQL 是一种非常强大的语言，它允许变量声明、流程控制、改进 `DELETE` 和 `UPDATE` 语句以及 `TRY/CATCH`
    异常处理等功能。要获取 T-SQL 语言的完整参考，请访问 [https://msdn.microsoft.com/en-us/library/bb510741.aspx](https://msdn.microsoft.com/en-us/library/bb510741.aspx)，因为这种语言的细节值得一本专著。
- en: SQL Server from Visual Studio
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio 中的 SQL Server
- en: SQL Server is available in different forms for a Visual Studio programmer. First,
    we have a type of project, named `SQL Server Database Project`, which you can
    choose as if it were another common programmable template.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: SQL Server 以不同的形式提供给 Visual Studio 程序员。首先，我们有一种项目类型，名为 `SQL Server Database
    Project`，你可以选择它就像选择另一个常见的可编程模板一样。
- en: Just select **New Project** and scroll down to SQL Server. Usually (it might
    depend on other templates already installed on your machine), you'll find this
    type of project, and once it's selected, a solution structure will be created.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 只需选择 **新建项目** 并向下滚动到 SQL Server。通常（这可能取决于你机器上已安装的其他模板），你会找到这种类型的项目，一旦选择，就会创建一个解决方案结构。
- en: 'Initially, you will find the Solution Explorer pretty empty, and a look at
    the **Add New** menu will show you the large amount of options that this type
    of project offers for database manipulation (refer to the following screenshot):'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，你将发现解决方案资源管理器非常空，查看**添加新**菜单将显示这种类型的项目为数据库操作提供的众多选项（参见图表）：
- en: '![SQL Server from Visual Studio](img/image00539.jpeg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![从 Visual Studio 中的 SQL Server](img/image00539.jpeg)'
- en: As we can see, a large amount of different database objects are available in
    this manner, including most of the internal objects managed by SQL Server, external
    files, security aspects, CLR integration, and much more.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如我们所见，以这种方式提供了大量不同的数据库对象，包括 SQL Server 管理的大多数内部对象、外部文件、安全方面、CLR 集成等等。
- en: The first step would be to select the **Tools/Connect to Database** option in
    the menu in order to link our project to our already installed `AdventureWorks`
    database. You'll be offered the usual **Add Connection** dialog box, where you
    can select a database. At this point, a look at the Server Explorer will allow
    you to query data and other options.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是选择菜单中的**工具/连接到数据库**选项，以便将我们的项目链接到已安装的`AdventureWorks`数据库。你将看到一个常规的**添加连接**对话框，你可以选择一个数据库。此时，查看服务器资源管理器将允许你查询数据和其他选项。
- en: Note that although Visual Studio doesn't offer as many options as if you were
    inside SSMS, the most useful selections for data management appear, including
    data visualization, so we don't have to open SSMS in many usual scenarios of development.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，尽管 Visual Studio 提供的选项不如在 SSMS 内部那么多，但其中最实用的数据管理选项仍然会出现，包括数据可视化，因此我们不必在许多常规的开发场景中打开
    SSMS。
- en: 'You should find a user interface like the one shown in the next capture, when
    you open AdventureWorks2014 database in this manner (observe that the most important
    functionality for programmers is provided):'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 当你以这种方式打开 AdventureWorks2014 数据库时，你应该会找到一个类似于下一张截图的用户界面（注意，对于程序员来说，最重要的功能已经提供）：
- en: '![SQL Server from Visual Studio](img/image00540.jpeg)'
  id: totrans-85
  prefs: []
  type: TYPE_IMG
  zh: '![从 Visual Studio 中的 SQL Server](img/image00540.jpeg)'
- en: If you enable **Show all files** in the Solution Explorer, you'll discover that
    after compiling the applications, a number of files appear in the `bin` and `obj`
    directories, one of them with the `.dacpac` extension.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你启用了解决方案资源管理器中的**显示所有文件**，你将发现编译应用程序后，`bin`和`obj`目录中会出现许多文件，其中之一具有`.dacpac`扩展名。
- en: 'These files allow us a bunch of possibilities, as Jamie Thomson points out
    in the article *Dacpac braindump - What is a dacpac?*, available at the official
    SQL Blog ([http://sqlblog.com/blogs/jamie_thomson/archive/2014/01/18/dacpac-braindump.aspx](http://sqlblog.com/blogs/jamie_thomson/archive/2014/01/18/dacpac-braindump.aspx)):'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 这些文件为我们提供了许多可能性，正如 Jamie Thomson 在文章《Dacpac braindump - 什么是 dacpac？》中指出的，该文章可在官方
    SQL 博客上找到（[http://sqlblog.com/blogs/jamie_thomson/archive/2014/01/18/dacpac-braindump.aspx](http://sqlblog.com/blogs/jamie_thomson/archive/2014/01/18/dacpac-braindump.aspx)）：
- en: In that single file are a collection of definitions of objects that one could
    find in a SQL Server database such as tables, stored procedures, views plus some
    instance level objects such as logins too (the complete list of supported objects
    for SQL Server 2012 can be found at DAC Support For SQL Server Objects and Versions).
    The fact that a dacpac is a file means you can do anything you could do with any
    other file, store it, email it, share it on a file server etc… and this means
    that they are a great way of distributing the definition of many objects (perhaps
    even an entire database) in a single file. Or, as Microsoft puts it, a self-contained
    unit of SQL Server database deployment that enables data-tier developers and database
    administrators to package SQL Server objects into a portable artifact called a
    DAC package, also known as a DACPAC.
  id: totrans-88
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 在那个单一文件中，收集了可以在 SQL Server 数据库中找到的对象定义，例如表、存储过程、视图，以及一些实例级别的对象，如登录名等（SQL Server
    2012 支持的对象完整列表可以在 DAC 支持SQL Server 对象和版本中找到）。由于 dacpac 是一个文件，这意味着你可以像处理任何其他文件一样处理它，存储它、通过电子邮件发送它、在文件服务器上共享它等……这意味着它们是分发许多对象定义（也许甚至是一个完整的数据库）的绝佳方式。或者，正如微软所说，这是一个自包含的
    SQL Server 数据库部署单元，它使数据层开发人员和数据库管理员能够将 SQL Server 对象打包成一个可携带的工件，称为 DAC 包，也称为 DACPAC。
- en: 'Another interesting feature of these projects can be discovered by navigating
    to **Import** | **Database** in the project''s menu. If you choose this, you''ll
    be offered a dialog box in which you can select three different types of data
    origins: local, network, and Azure.'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这些项目的另一个有趣特性可以通过在项目菜单中导航到**导入** | **数据库**来发现。如果你选择这个选项，你将看到一个对话框，你可以从中选择三种不同的数据来源：本地、网络和Azure。
- en: 'In our case, if we select the local option, we''ll be shown a list of all the
    database instances available (it will depend on our machine''s configuration):'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，如果我们选择本地选项，我们将看到所有可用的数据库实例列表（这取决于我们机器的配置）：
- en: '![SQL Server from Visual Studio](img/image00541.jpeg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![SQL Server from Visual Studio](img/image00541.jpeg)'
- en: Once you're finished with this option, the process of importing data will take
    place—it might take some time depending on the size, the network speed (for network
    connections), or the Internet bandwidth (for Azure connections).
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 完成此选项后，导入数据的过程将开始——这可能需要一些时间，具体取决于数据的大小、网络速度（对于网络连接）或互联网带宽（对于Azure连接）。
- en: 'When the process ends, you''ll find a whole set of elements in your project,
    each of them representing the objects available in the database you connected
    with: tables, schemas, functions, stored procedures, users, logins, and so on.'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当过程结束时，你将在项目中找到一系列元素，每个元素都代表你连接的数据库中可用的对象：表、模式、函数、存储过程、用户、登录等。
- en: 'In other words, you''ll have a representation, element by element, of the whole
    database in your project. A look at the files shows you that their content depends
    on its nature: for stored procedure, you''ll be shown the SQL statements required
    to create and define it, but for a table, you''ll be shown the design editor and
    other editing options to change it from Visual Studio, as shown in the next screenshot:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，你将在项目中以元素为单位表示整个数据库。查看文件显示，其内容取决于其性质：对于存储过程，你会看到创建和定义它的SQL语句，但对于表，你会看到设计编辑器和从Visual
    Studio更改它的其他编辑选项，如下一张截图所示：
- en: '![SQL Server from Visual Studio](img/image00542.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![SQL Server from Visual Studio](img/image00542.jpeg)'
- en: Any modification you might make in the design or the definitions of any object
    in this project will be stored when compiling the project into the `.dacpac` file
    and can be easily restored or created in a destination DBMS of your choice.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这个项目中可能对设计或任何对象的定义所做的任何修改，在将项目编译成`.dacpac`文件时都会被存储，并且可以轻松地在你的选择的目标DBMS中恢复或创建。
- en: 'Note that a `.dacpac` file is just a ZIP file, so you can add that extension
    to the file and inspect its contents, expressed in the XML syntax, which are nothing
    but the contents of the project you have created. They''re only packaged in a
    special manner: they convey the Open Packaging Convention, a standard format created
    by Microsoft, to rally these files together in a much lighter fashion.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`.dacpac`文件只是一个ZIP文件，因此你可以将此扩展名添加到文件中并检查其内容，这些内容以XML语法表达，它们只是你创建的项目的内容。它们只是以特殊的方式打包：它们传达了Open
    Packaging Convention，这是由Microsoft创建的标准格式，以更轻便的方式将这些文件聚集在一起。
- en: 'This format is now used by a number of applications inside and outside the
    Microsoft world: AutoDesk, AutoCad, Siemens PLM, MathWorks, and so on.'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 这种格式现在被许多Microsoft世界内外应用程序使用：AutoDesk、AutoCad、Siemens PLM、MathWorks等。
- en: So, these types of projects are the perfect complement to a solution that manages
    databases, and you can include them as part of your deployment process. If you're
    done with your modifications, you can build the project like you would with any
    executable.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，这类项目是管理数据库解决方案的完美补充，你可以将它们作为部署过程的一部分。如果你完成了你的修改，你可以像处理任何可执行文件一样构建项目。
- en: Once you have your project built, you can publish the results in an existing
    DBMS. To do this, you'll select the **Publish** option, and you'll be required
    to get the initial data from the **Publish Configuration** dialog box, such as
    the connection string, database name, and so on.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你的项目构建完成，你可以在现有的数据库管理系统（DBMS）中发布结果。为此，你需要选择**发布**选项，并且你将需要在**发布配置**对话框中获取初始数据，例如连接字符串、数据库名称等。
- en: Also, this publishing configuration can be saved and stored for later use. The
    three buttons related to profiles allow you to load already existing profiles,
    creating a profile from the current configuration and saving the profile with
    a different name.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这种发布配置可以保存并存储以供以后使用。与配置文件相关的三个按钮允许你加载已存在的配置文件，从当前配置创建配置文件，以及以不同的名称保存配置文件。
- en: 'Other interesting options appear, such as editing the database connection string
    (for example, to replicate it in a different SQL Server instance), and even more
    detailed information can be established with the **Advanced** button:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 出现了一些其他有趣的选择，例如编辑数据库连接字符串（例如，在另一个 SQL Server 实例中复制它），还可以通过 **高级** 按钮获取更详细的信息：
- en: '![SQL Server from Visual Studio](img/image00543.jpeg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![SQL Server from Visual Studio](img/image00543.jpeg)'
- en: The **Advanced** button deserves a look, since every aspect of the final creation
    in the target will be covered in there. Many of the options relate to the way
    we want to convert our data in the target DBMS.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: '**高级** 按钮值得一看，因为目标中最终创建的每个方面都会在那里得到覆盖。许多选项都与我们希望在目标 DBMS 中转换数据的方式有关。'
- en: 'Observe that you have three tabs, allowing the configuration of general aspects
    of the process, and this includes elements you would like to delete (**Drop**)
    and that you would like to disregard (**Ignore**). The next screenshot shows this
    dialog box:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你有三个选项卡，允许配置过程的各个方面，包括你想要删除的元素（**删除**）和想要忽略的元素（**忽略**）。下一张截图显示了此对话框：
- en: '![SQL Server from Visual Studio](img/image00544.jpeg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![SQL Server from Visual Studio](img/image00544.jpeg)'
- en: When everything is fine, the process will start and you'll be able to see the
    destination of the objects created right from Visual Studio; or, you can open
    SSMS as usual and inspect the result directly.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 当一切正常时，过程将开始，你将能够从 Visual Studio 中直接看到创建的对象的目标；或者，你可以像往常一样打开 SSMS 并直接检查结果。
- en: Data access in Visual Studio
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Visual Studio 中的数据访问
- en: 'Using Visual Studio, you can create applications that connect to any kind of
    data, covering practically any database product or service in any format and anywhere:
    either from a local machine, LAN server, or located in the cloud.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Visual Studio，你可以创建连接到任何类型数据的应用程序，覆盖几乎所有格式和位置上的数据库产品或服务：无论是从本地机器、局域网服务器，还是位于云中的位置。
- en: 'The IDE enables you to explore data sources or create object models to store
    and manipulate data in the memory, and—of course—establish data-binding techniques
    in the user interface, no matter what type of UI you want: Console, Windows Forms,
    Windows Presentation Foundation, websites created with ASP.NET, and so on.'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: IDE 允许你探索数据源或创建对象模型以在内存中存储和操作数据，并且当然可以在用户界面中建立数据绑定技术，无论你想要哪种类型的 UI：控制台、Windows
    窗体、Windows 表现基金会、使用 ASP.NET 创建的网站等等。
- en: Besides, Microsoft Azure provides SDKs for .NET, Java, Node.js, PHP, Python,
    Ruby, mobile apps, and tools in Visual Studio in order to connect to Azure Storage.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Microsoft Azure 为 .NET、Java、Node.js、PHP、Python、Ruby、移动应用程序以及 Visual Studio
    中的工具提供了 SDK，以便连接到 Azure 存储。
- en: 'The following table shows you the variety of database connections available
    in recent versions of the IDE:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 下表显示了 IDE 中最近版本可用的数据库连接的多样性：
- en: '| Microsoft Azure (SQL and NoSQL) |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| Microsoft Azure (SQL 和 NoSQL) |'
- en: '| --- |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| --- |'
- en: '| SQL Database (Azure) | Azure Storage (Blobs, Tables, Queues, Files) | SQL
    Data Warehouse (Azure) |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| SQL Database (Azure) | Azure Storage (Blobs, Tables, Queues, Files) | SQL
    Data Warehouse (Azure) |'
- en: '| SQL Server Stretch Database (Azure) | StorSimple (Azure) | DocumentDB (Azure)
    |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| SQL Server Stretch Database (Azure) | StorSimple (Azure) | DocumentDB (Azure)
    |'
- en: '| Azure Redis Cache |   |   |'
  id: totrans-117
  prefs: []
  type: TYPE_TB
  zh: '| Azure Redis Cache |   |   |'
- en: '| SQL |'
  id: totrans-118
  prefs: []
  type: TYPE_TB
  zh: '| SQL |'
- en: '| SQL Server 2005* - 2016 | MySQL | Oracle |'
  id: totrans-119
  prefs: []
  type: TYPE_TB
  zh: '| SQL Server 2005* - 2016 | MySQL | Oracle |'
- en: '| Firebird | PostgreSQL | SQLite |'
  id: totrans-120
  prefs: []
  type: TYPE_TB
  zh: '| Firebird | PostgreSQL | SQLite |'
- en: '| NoSQL |'
  id: totrans-121
  prefs: []
  type: TYPE_TB
  zh: '| NoSQL |'
- en: '| MongoDB | Apache Cassandra | NDatabase |'
  id: totrans-122
  prefs: []
  type: TYPE_TB
  zh: '| MongoDB | Apache Cassandra | NDatabase |'
- en: '| OrientDB | RavenDB | VelocityDB |'
  id: totrans-123
  prefs: []
  type: TYPE_TB
  zh: '| OrientDB | RavenDB | VelocityDB |'
- en: You have more information about this topic at [https://msdn.microsoft.com/en-us/library/wzabh8c4(v=vs.140).aspx](https://msdn.microsoft.com/en-us/library/wzabh8c4(v=vs.140).aspx).
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://msdn.microsoft.com/en-us/library/wzabh8c4(v=vs.140).aspx](https://msdn.microsoft.com/en-us/library/wzabh8c4(v=vs.140).aspx)找到更多关于这个主题的信息。
- en: Apart from these direct possibilities, there are many other vendors that allow
    Visual Studio integration via NuGet packages. Some other options are at your disposal
    as well, when using the **Extensions and Updates**" option of the main **Tools**
    menu.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 除了这些直接的可能性之外，还有许多其他供应商允许通过 NuGet 包将 Visual Studio 集成。当使用主 **工具** 菜单中的 **扩展和更新**
    选项时，你还有其他一些选项可供选择。
- en: .NET data access
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 数据访问
- en: .NET data access—and that includes the new **.NET Core**—is based on **ADO.NET**,
    which is composed of a set of classes that define interfaces to access any kind
    of data source, both relational and non-relational. The IDE includes a customary
    number of tools in order to help connect to databases and create **ORMs** (**Object
    Relational Models**) that map the objects in the database to objects in a .NET
    language world.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: .NET数据访问——包括新的**.NET Core**——基于**ADO.NET**，它由一组定义接口以访问任何类型数据源的类组成，无论是关系型还是非关系型。IDE包含了一系列工具，旨在帮助连接到数据库并创建**ORMs**（**对象关系模型**），将数据库中的对象映射到.NET语言世界的对象。
- en: The IDE's options include data manipulation in the memory and presenting data
    to the user in several user interfaces and dialog boxes, both at development time
    and runtime.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: IDE的选项包括在内存中操作数据和在开发时间以及运行时通过多个用户界面和对话框向用户展示数据。
- en: Tip
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Note that in order to be consumable in ADO.NET, a database must have either
    a custom ADO.NET data provider, or it must expose an available ODBC or OLE DB
    interface. ADO.NET data providers for SQL Server as well as ODBC and OLE DB are
    offered by default. However, you can find an exhaustive list of providers at [https://msdn.microsoft.com/en-us/data/dd363565](https://msdn.microsoft.com/en-us/data/dd363565),
    which includes—but is not limited to—Oracle, MySQL, Sybase, IBM, SQLLite, and
    others.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，为了在ADO.NET中使用，数据库必须有一个自定义的ADO.NET数据提供程序，或者它必须公开一个可用的ODBC或OLE DB接口。默认情况下，提供了SQL
    Server的ADO.NET数据提供程序以及ODBC和OLE DB。然而，您可以在[https://msdn.microsoft.com/en-us/data/dd363565](https://msdn.microsoft.com/en-us/data/dd363565)找到提供程序的详尽列表，其中包括但不限于Oracle、MySQL、Sybase、IBM、SQLLite和其他。
- en: 'Visual Studio has several tools and designers that work with ADO.NET to help
    you connect to databases, manipulate the data in the memory, and present the data
    to the user. The official schema of the ADO.NET architecture is exposed in this
    image of MSDN:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio拥有多个工具和设计器，它们与ADO.NET一起工作，以帮助您连接到数据库，在内存中操作数据，并将数据展示给用户。ADO.NET的官方架构图在MSDN的这张图片中展示：
- en: '![.NET data access](img/image00545.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![.NET数据访问](img/image00545.jpeg)'
- en: 'As you can see, we have two sets of classes in this diagram: those of the .NET
    Framework data provider we use and those related to the DataSet object, which
    is an in-memory representation of part (or all) of the data tables, relations,
    and constraints included in the original database.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，在这个图中，我们有两套类：我们使用的.NET Framework数据提供程序的相关类和与DataSet对象相关的类，它是原始数据库中包含的部分（或全部）数据表、关系和约束的内存表示。
- en: Both sets of classes include data maintenance, although the dataset offers some
    extra functionalities, useful in many cases, such as batch updates and provider-agnostic
    data storage. With this functionality, some impossible things are available, such
    as linking two tables via relationships, independently of the possible diverse
    origin of those tables (say, an Oracle table, a SQL server table, and a Excel
    Spreadsheet). Reinforce these relations at execution time, establishing business
    logic that is quite complex to code otherwise.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这两套类都包括数据维护，尽管数据集提供了一些额外的功能，这在许多情况下非常有用，例如批量更新和提供程序无关的数据存储。有了这个功能，一些原本不可能的事情变得可行，例如通过关系将两个表链接起来，独立于这些表可能的多样来源（比如说，一个Oracle表，一个SQL服务器表和一个Excel电子表格）。在执行时强化这些关系，建立其他情况下难以编码的复杂业务逻辑。
- en: Using ADO.NET basic objects
  id: totrans-135
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用ADO.NET基本对象
- en: Let's create a new WPF project, which we will use to read some data from our
    database and present it in a data grid inside a WPF window.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建一个新的WPF项目，我们将使用它从我们的数据库中读取一些数据，并在WPF窗口内的数据网格中展示它。
- en: 'Once we''ve created the basic project, let''s add a new dataset. To do this,
    just select **Add New** in project''s options, and you''ll be presented with a
    blank design surface, in which you can drag and drop any table of the list of
    tables you''ll see in the Solution Explorer pointing to the `AdventureWorks` database.
    After choosing the **Person** table, you can add **Code Map**, selecting that
    option in the Solution Explorer''s top icons. You''ll have two windows as a result:
    one showing the data structure and another with the code schema, as shown in the
    following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们创建了基本项目，让我们添加一个新的数据集。为此，只需在项目选项中选择**添加新项**，您将看到一个空白的设计表面，您可以在其中拖放Solution
    Explorer中指向`AdventureWorks`数据库的任何表。选择**Person**表后，您可以通过在Solution Explorer的顶部图标中选择该选项来添加**代码映射**。结果您将有两个窗口：一个显示数据结构，另一个显示代码架构，如下面的截图所示：
- en: '![Using ADO.NET basic objects](img/image00546.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![使用ADO.NET基本对象](img/image00546.jpeg)'
- en: 'You can see that a new set of nested files has been created in your solution,
    showing several files that hold the class definitions related to the connection
    and the relational mapping I mentioned earlier:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以看到，在你的解决方案中创建了一个新的嵌套文件集，显示了几个包含与之前提到的连接和关系映射相关的类定义的文件：
- en: '![Using ADO.NET basic objects](img/image00547.jpeg)'
  id: totrans-140
  prefs: []
  type: TYPE_IMG
  zh: '![使用ADO.NET基本对象](img/image00547.jpeg)'
- en: A look at the contents of the C# files generated will show a large number of
    functionalities that provide the majority of resources we need for CRUD operations,
    Stored Procedures calls, connection management, searches, and much more.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 查看生成的C#文件的内容将显示大量功能，为我们提供了大多数CRUD操作、存储过程调用、连接管理、搜索等所需的大部分资源。
- en: Configuring the user interface
  id: totrans-142
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置用户界面
- en: We can add a new `DataGrid` object to our empty window, to be later populated
    with the data we read.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向我们的空窗口添加一个新的`DataGrid`对象，稍后用我们读取的数据填充。
- en: 'The first step to get the data directly when the window shows up is adding
    a `Loaded` event declared in the XAML editor at the end of the `<window>` declaration:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 当窗口显示时直接获取数据的第一个步骤是在XAML编辑器中在`<window>`声明末尾添加一个名为`Loaded`的事件：
- en: '[PRE0]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'This declaration, in the C# code, has created a `window_load` event handler.
    Next, we can use the `PersonTableAdapter` object created when defining our model
    in very simple way to load and bind data to our DataGrid object:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#代码中，这个声明创建了一个`window_load`事件处理程序。接下来，我们可以以非常简单的方式使用在定义我们的模型时创建的`PersonTableAdapter`对象来加载和绑定数据到我们的DataGrid对象：
- en: '[PRE1]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Here, the `PersonTableAdapter` code takes care of establishing a connection
    to the database, loading the data previously defined in its internal `SQLCommand`
    object and returning a `DataView` object suitable to be assigned to DataGrid for
    the automatic creation of columns (as many as the table has), as shown in the
    next screenshot:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`PersonTableAdapter`代码负责建立与数据库的连接，加载其内部`SQLCommand`对象中先前定义的数据，并返回一个适合分配给DataGrid的`DataView`对象，以便自动创建列（与表中的列数相同），如下一张截图所示：
- en: '![Configuring the user interface](img/image00548.jpeg)'
  id: totrans-149
  prefs: []
  type: TYPE_IMG
  zh: '![配置用户界面](img/image00548.jpeg)'
- en: By the way, the black toolbar on top of the data grid's header is a debugging
    option offered by Visual Studio that shows/hides layout adorners, enables/disables
    selection, and—optionally—takes you to a new window, Visual Tree, where you can
    inspect all elements in the XAML user interface and check their dependencies and
    values at runtime, as indicated in the arrow pointing to **LastName** `Miller`
    in the list.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 顺便说一句，数据网格标题上方的黑色工具栏是Visual Studio提供的调试选项，它显示/隐藏布局装饰器，启用/禁用选择，并且可选地可以带你到一个新窗口，Visual
    Tree，在那里你可以检查XAML用户界面中的所有元素，并在运行时检查它们的依赖关系和值，如指向列表中**LastName** `Miller`的箭头所示。
- en: If you take a look at the properties of the TableAdapter and DataSet objects,
    you'll discover a very rich set of objects prepared for all sorts of data manipulation.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你查看TableAdapter和DataSet对象的属性，你会发现一组非常丰富的对象，为各种数据操作做好了准备。
- en: This was just a simple demo to check how easy it is to read data using ADO.NET
    if you use the ORM objects created for us by Visual Studio. However, ADO.NET is
    not the technology most commonly used these days, since other options are preferred
    when accessing relational databases, especially Entity Framework.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个简单的演示，用来检查如果你使用Visual Studio为我们创建的ORM对象，使用ADO.NET读取数据有多容易。然而，由于其他选项在访问关系数据库时更受欢迎，尤其是Entity
    Framework，因此ADO.NET并不是现在最常用的技术。
- en: The Entity Framework data model
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Entity Framework数据模型
- en: 'Entity Framework, in the words of Microsoft, is as follows:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 按照微软的说法，Entity Framework 如下：
- en: '**Entity Framework** (**EF**) is an object-relational mapping technology that
    enables .NET developers to work with relational data using domain-specific objects.
    It eliminates the need for most of the data-access code that developers usually
    need to write. Entity Framework is the Microsoft''s recommended ORM modeling technology
    for new .NET applications.'
  id: totrans-155
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**Entity Framework**（**EF**）是一种对象关系映射技术，它使.NET开发者能够使用领域特定对象与关系数据一起工作。它消除了开发者通常需要编写的多数数据访问代码的需求。Entity
    Framework是微软为新的.NET应用程序推荐的对象关系映射建模技术。'
- en: Note
  id: totrans-156
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find a nice, although basic, introductory video about Entity Framework
    at [https://msdn.microsoft.com/en-us/data/ef.aspx](https://msdn.microsoft.com/en-us/data/ef.aspx).
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://msdn.microsoft.com/en-us/data/ef.aspx](https://msdn.microsoft.com/en-us/data/ef.aspx)找到一个关于Entity
    Framework的不错但基本的介绍视频。
- en: 'As mentioned earlier, the latest version is .NET Core 1.1, and it''s still
    in the adoption phase by the community, so we''re using version 6.0 here, which
    is totally stable and widely tested. In this version, you have three initial choices:
    starting with an existing database, starting with an empty model, or starting
    with already existing code.'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，最新版本是 .NET Core 1.1，它仍在社区的采用阶段，所以我们在这里使用的是 6.0 版本，该版本完全稳定且经过广泛测试。在这个版本中，你有三个初始选择：从一个现有的数据库开始，从一个空模型开始，或者从一个现有的代码开始。
- en: In the first case, called Database First, a connection is established to the
    DBMS to read metadata from the server and create a visual model of the selected
    objects. From that model, a set of classes is generated, which includes a wide
    range of CRUD and search operations by default.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一种情况下，称为数据库优先，会建立与数据库管理系统的连接，从服务器读取元数据并创建所选对象的视觉模型。从这个模型中，生成一组类，默认情况下包括广泛的CRUD和搜索操作。
- en: Similar to this is the behavior of the **Model First** option, in which you
    start from scratch, design a model in the graphical editor, and the classes' generations
    process follows. Optionally, you can generate the real database in the RDBMS depending
    on the connection string. In either case, you can automatically update your model
    when the underlying database changes, and the related code will be automatically
    generated as well. Both database generation and object-layer code generation are
    highly customizable.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 与此类似的是 **模型优先** 选项的行为，其中你从头开始，在图形编辑器中设计一个模型，类的生成过程随后进行。可选地，你可以根据连接字符串在关系数据库管理系统（RDBMS）中生成实际的数据库。在任何情况下，当底层数据库发生变化时，都可以自动更新你的模型，并且相关的代码也会自动生成。数据库生成和对象层代码生成都是高度可定制的。
- en: In the third option, **Code First**, you start from some existing code and a
    heuristic process takes place in order to infer the corresponding model from that
    code, the rest of the options being similar to the other two scenarios.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在第三种选项中，**代码优先**，你从一个现有的代码开始，并通过启发式过程从该代码中推断出相应的模型，其余的选项与其他两种场景类似。
- en: For a deeper approach at Entity Framework, I recommend *Mastering Entity Framework*,
    *Rahul Rajat Singh*, Packt Publishing ([https://www.packtpub.com/application-development/mastering-entity-framework](https://www.packtpub.com/application-development/mastering-entity-framework)).
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 对于对实体框架的更深入的了解，我推荐 *Mastering Entity Framework*，*Rahul Rajat Singh*，Packt Publishing
    ([https://www.packtpub.com/application-development/mastering-entity-framework](https://www.packtpub.com/application-development/mastering-entity-framework))。
- en: For the purpose of the next demo, I'm using the Database First approach in order
    to show the most common operations with Entity Framework but changing the project
    type to be an ASP.NET MVC application this time, where the code used for data
    access should be totally independent from the IU that consumes the data.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 为了演示下一个示例，我正在使用数据库优先的方法来展示使用实体框架最常见的操作，但这次将项目类型更改为ASP.NET MVC应用程序，其中用于数据访问的代码应完全独立于消耗数据的UI。
- en: 'So, let''s create a new ASP.NET application by selecting that option in the
    available projects. We will be offered several types of project variations depending
    on the version and project architecture:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们通过在可用的项目中选择该选项来创建一个新的ASP.NET应用程序。我们将根据版本和项目架构提供几种项目变体：
- en: '![The Entity Framework data model](img/image00549.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![实体框架数据模型](img/image00549.jpeg)'
- en: I selected the **No Authentication** feature in **Change Authentication** in
    order to avoid the automatic creation of a database. When clicking on **OK**,
    a new project will be generated (using the techniques we saw in previous chapter),
    and we'll end up with a basic, but functional, project with no data access.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我在 **更改身份验证** 中选择了 **无身份验证** 功能，以避免自动创建数据库。当点击 **确定** 时，将生成一个新的项目（使用我们在上一章中看到的技术），最终我们将得到一个基本但功能齐全的项目，没有数据访问。
- en: At this point, the `Models` folder should be empty. So, right-click on that
    folder, select **Add New**, and in the **Data** menu, choose **ADO.NET Entity
    Data Model**. I'll name mine `AWModel` and proceed. At this point, you have to
    select the type of designer to use, which determines the model's contents. I've
    selected **EF Designer from Database**.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，`Models` 文件夹应该是空的。因此，右键单击该文件夹，选择 **添加新项**，然后在 **数据** 菜单中选择 **ADO.NET 实体数据模型**。我将我的命名为
    `AWModel` 并继续。在此阶段，你必须选择要使用的设计器类型，它决定了模型的内容。我选择了 **从数据库的EF设计器**。
- en: Now, it's time to select the connection. The last one used will be presented
    by default, and the dialog box will generate a connection string in RichTextBox
    at the bottom. In case AdventureWorks doesn't show up, manually select the connection
    to be used.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，是时候选择连接了。默认情况下将显示最后使用的连接，对话框将在底部的 RichTextBox 中生成连接字符串。如果 AdventureWorks
    没有显示，请手动选择要使用的连接。
- en: Then, it's time to pick up which tables you want to work with, along with other
    objects, such as views and stored procedures. All of them will be used to generate
    the model.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，是时候选择你想要工作的表，以及其他对象，如视图和存储过程。所有这些都将用于生成模型。
- en: 'For this demo, I selected one table with a few columns to facilitate code reading,
    so I opted for `HumanResources.Department` with just four fields:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个演示，我选择了一个具有几个列的表以简化代码阅读，所以我选择了`HumanResources.Department`，只有四个字段：
- en: '![The Entity Framework data model](img/image00550.jpeg)'
  id: totrans-171
  prefs: []
  type: TYPE_IMG
  zh: '![The Entity Framework data model](img/image00550.jpeg)'
- en: A simple schema should appear in the **Design** window and its properties, detailed
    in a bottom window called **Mapping Details**, which specifies how the original
    data types and restrictions defined in the database are modeled into the C# language,
    to be managed by Entity Framework classes.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 一个简单的架构应该出现在**设计**窗口及其属性中，在底部窗口**映射详情**中详细说明，该窗口指定了如何在 C# 语言中将数据库中定义的原数据类型和限制建模，以便由
    Entity Framework 类管理。
- en: This is important, since it allows you to specify exactly how you want EF Generators
    to behave when creating the actual code.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这很重要，因为它允许你指定 EF 生成器在创建实际代码时的行为。
- en: There's another important feature to remember here. More often that not, changes
    happen in the original database, and that includes column reformatting or changing
    datatypes, adding (or deleting) tables, changing relations, and so on.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这里还有一个需要记住的重要功能。通常情况下，更改发生在原始数据库中，包括列格式化或更改数据类型，添加（或删除）表，更改关系等。
- en: 'In these cases, the contextual **Update Model from Database** option comes
    in handy. The entire model will be reread, and the corresponding changes will
    be updated, both in the **Mapping Details** section and the generated code, which
    will be regenerated:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在这些情况下，上下文相关的**从数据库更新模型**选项很有用。整个模型将被重新读取，相应的更改将在**映射详情**部分和生成的代码中更新，生成的代码将被重新生成：
- en: '![The Entity Framework data model](img/image00551.jpeg)'
  id: totrans-176
  prefs: []
  type: TYPE_IMG
  zh: '![The Entity Framework data model](img/image00551.jpeg)'
- en: Now, we need to understand how to modify code generation. This is done by means
    of the T4 templates, which are text files with the `.tt` extension, which you'll
    find within the files generated in the process, linked to the model's files.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要了解如何修改代码生成。这是通过 T4 模板完成的，这些是具有 `.tt` 扩展名的文本文件，你可以在生成的文件中找到它们，与模型的文件相关联。
- en: 'The reason to include these files is double: they allow the user to decide
    the way the code is generated, and they facilitate the creation itself (remember
    that Visual Studio uses CodeDOM internally among other techniques to generate
    code).'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 包含这些文件的原因有两个：它们允许用户决定代码的生成方式，并简化了生成过程（记住，Visual Studio 使用 CodeDOM 等技术内部生成代码）。
- en: Take a look at the classes generated and you'll learn how the `Department` class
    has been created, along with an `AdventureWorks2014Entities` class, which will
    be the starting point for data manipulation.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 查看生成的类，你会了解到`Department`类是如何创建的，以及一个`AdventureWorks2014Entities`类，它将是数据操作的开始点。
- en: Well, now we need controllers and views to present the user with the typical
    CRUD options for data manipulation. Once again, the IDE comes to help. Select
    **Add Controller**, and a dialog box will appear to select the type of controllers
    available.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧，现在我们需要控制器和视图来向用户提供数据操作的典型 CRUD 选项。再次，IDE 来帮忙。选择**添加控制器**，将出现一个对话框以选择可用的控制器类型。
- en: Note
  id: totrans-181
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that you'll need to compile the project first, since actual assemblies
    might be required for code generation.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你需要首先编译项目，因为可能需要实际的程序集来生成代码。
- en: 'Additionally, keep in mind that due to the natural integration with Entity
    Framework, an option covering all required controllers and views will be offered.
    So, in the **Add Scalffold** dialog box, select the **MVC 5 Controller with Views,
    using Entity Framework** option. This will generate all the required code to test
    the basic CRUD data options:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请记住，由于与 Entity Framework 的自然集成，将提供一个涵盖所有所需控制器和视图的选项。因此，在 **添加 Scalffold**
    对话框中，选择 **使用 Entity Framework 的 MVC 5 控制器与视图**选项。这将生成测试基本 CRUD 数据选项所需的所有代码：
- en: '![The Entity Framework data model](img/image00552.jpeg)'
  id: totrans-184
  prefs: []
  type: TYPE_IMG
  zh: '![实体框架数据模型](img/image00552.jpeg)'
- en: You will still be asked about the model to use (**Department**, in my case),
    and about the `DataContext` class (`AdventureWorks2014Entities`). When the assistant
    finishes, several new files will have been generated.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然会被问到要使用哪个模型（在我的情况下是 **Department**），以及关于 `DataContext` 类（`AdventureWorks2014Entities`）。当助手完成时，将生成几个新文件。
- en: First, we'll have a new `DepartmentsController` controller, which includes the
    CRUD operations I mentioned earlier. In addition, a new `Departments` folder appears,
    showing five new views, corresponding to **Create**, **Delete**, **Details** (to
    view only one department), **Edit**, and **Index**, which shows the whole list
    of departments, along with some links that will allow you to access the rest of
    options.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将有一个新的 `DepartmentsController` 控制器，其中包含我之前提到的 CRUD 操作。此外，一个新的 `Departments`
    文件夹出现，显示了五个新的视图，对应于 **创建**、**删除**、**详情**（仅查看一个部门）、**编辑** 和 **索引**，它显示了所有部门的整个列表，以及一些允许你访问其他选项的链接。
- en: 'The first lines of that controller class indicates the suggested way to operate:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 该控制器类的第一行指示了建议的操作方式：
- en: '[PRE2]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `DBContext` object will recover all the departments and convert them into
    `List<Department>`, which is the model the view expects (take a look at the `Index.cshtml`
    file in the **Views/Departments** area). When launching it, you'll need to reference
    the controller in the URL, since by default, the application is configured to
    present the Home controller and the `Index` action method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`DBContext` 对象将恢复所有部门并将它们转换为 `List<Department>`，这是视图期望的模型（查看 **Views/Departments**
    区域中的 `Index.cshtml` 文件）。当你启动它时，你需要在 URL 中引用控制器，因为默认情况下，应用程序配置为呈现 Home 控制器和 `Index`
    动作方法。'
- en: 'If you type `http://localhost:[portNumber]/Departments`, the routing pattern
    will take you to the `Index` method in the `Departments` controller, and the following
    list will show up (it doesn''t matter which browser you use, of course):'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你输入 `http://localhost:[端口号]/Departments`，路由模式将带你到 `Departments` 控制器中的 `Index`
    方法，以下列表将显示出来（当然，无论你使用哪个浏览器都无关紧要）：
- en: '![The Entity Framework data model](img/image00553.jpeg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![实体框架数据模型](img/image00553.jpeg)'
- en: If everything goes fine, you'll be able to change data using the **Edit** and
    **Delete** links that the view presents automatically, and a selection of the
    **Details** option will take you to a different view, showing just the selected
    element.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一切顺利，你将能够通过视图自动呈现的 **编辑** 和 **删除** 链接来更改数据，选择 **详情** 选项将带你到不同的视图，仅显示所选元素。
- en: Summary
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we reviewed the basics of data access in relational models.
    First, we examined the concepts behind the relational model itself, including
    its basic and fundamental principles, its architecture, and the properties of
    relational tables.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们回顾了关系模型中数据访问的基本知识。首先，我们检查了关系模型背后的概念，包括其基本和基本原理、其架构以及关系表的性质。
- en: Then, we went through the Microsoft tools offered to work with these models,
    such as SQL Server 2014 Express Edition, and **SQL Server Management Studio**
    (**SSMS**), revising their programmatic and operational offers in editing, debugging,
    analyzing execution, and so on.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们回顾了 Microsoft 提供的用于处理这些模型的工具，例如 SQL Server 2014 Express 版本和 **SQL Server
    Management Studio**（**SSMS**），并复习了它们在编辑、调试、分析执行等方面的程序性和操作提供。
- en: After a brief note on the T-SQL language, we covered a not-well-known type of
    project that Visual Studio proposed, SQL Server Projects, and saw how we can create
    and manage packages (`.dacpac` files) that help us manage and administer any database
    and reproduce its structure in another RDBMS.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 在简要介绍 T-SQL 语言后，我们介绍了 Visual Studio 提出的一个不太为人所知的项目类型，SQL Server 项目，并看到了我们如何创建和管理帮助我们在其他
    RDBMS 中管理和管理任何数据库并复制其结构的包（`.dacpac` 文件）。
- en: Finally, we reviewed some data access options from within Visual Studio, demonstrating
    how to access data using two technologies that are widely known and accepted,
    ADO.NET (using a Windows Presentation Foundation application) and Entity Framework,
    inside a ASP.NET MVC application.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们回顾了在 Visual Studio 内部的一些数据访问选项，展示了如何使用两种广为人知且被广泛接受的技术，即 ADO.NET（使用 Windows
    Presentation Foundation 应用程序）和 Entity Framework，在 ASP.NET MVC 应用程序中访问数据。
- en: 'In the next chapter, we will switch from the relational to the noSQL model,
    and we''ll study its advantages and disadvantages and work with the MongoDB noSQL
    database in both ways: from the tools offered by the product and also from Visual
    Studio.'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将从关系型数据库模型切换到 NoSQL 模型，并研究其优缺点，同时以两种方式与 MongoDB NoSQL 数据库进行交互：一种是利用产品提供的工具，另一种是从
    Visual Studio 进行操作。
