- en: Implementing Worker Services Using .NET Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The latest version of .NET Core includes a simple and convenient way to implement
    background processes. Moreover, starting from version 3.0, it is possible to create
    new projects using an out-of-the-box template for worker services. .NET worker
    services are suitable for multiple use cases. Furthermore, the increasing adoption
    of cloud technologies and distributed systems also involves event-driven communication
    between services, which requires the implementation of background processes. This
    chapter walks through some of the concepts and use cases of the worker services
    tools provided by ASP.NET Core. We will also have a look at how to integrate the
    worker service capabilities of ASP.NET Core to consume the `ItemSoldOut` event
    queue implemented in the previous chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to worker services
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementing a worker service using .NET Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying and running a worker on Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extending the background services class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to implement a worker service and
    deploy it using Docker container technology.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing worker services
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: .NET Core worker services can be really useful every time we need to perform
    a repetitive or background-running operation. In more detail, they can be used
    in the application layer to enable asynchronous operations and handle the events
    of an event-based architecture. If every time you need to publish or listen for
    a message, you need to refresh data based on a schedule, or your application needs
    to queue a background work item, then you should probably use a worker service.
    Furthermore, with worker services, it is possible to run multiple background tasks
    on the same server without consuming a lot of resources.
  prefs: []
  type: TYPE_NORMAL
- en: The foundation of worker services in .NET Core is the `IHostedService` interface.
    The out-of-the-box worker service template can be used as a guideline to start
    implementing our worker service project. More importantly, the `IHostedService`
    interface is implemented by a `BackgroundService` class, which is the base class
    we should extend to implement our worker service.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the worker services life cycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '.NET Core uses the definition of the `BackgroundService` class to identify
    a worker service. The `BackgroundService` class exposes three methods that represent
    the life cycle stages of the worker service:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is the abstract implementation of the `BackgroundService`
    class. The class implements both the `IHostedService` and `IDisposable` interfaces,
    and it exposes the following methods:'
  prefs: []
  type: TYPE_NORMAL
- en: The `StartAsync` method represents the first stage of the life cycle of the
    worker. This method is called when the host is ready to run the worker service.
    It accepts a `CancellationToken` type parameter, which can be used to cancel the
    running task.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `ExecuteAsync` method contains the core implementation of the `BackgroundService`
    class. This method is called once the `IHostedService` starts, and it returns
    a `Task` type that represents the status of the `Task`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `StopAsync` method is called when the hosted application is stopped gracefully.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This section provided an overview of the worker service life cycle methods.
    In the next section, we will see the hosting models available for the worker services
    in .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: Hosting models
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET Core worker template is nothing more than a common .NET Core app. Furthermore,
    we can run the worker template as a common console application. Besides, the worker
    template also provides the hosting APIs to run the worker as an always-running
    process. In the case of Windows, it is possible to run the worker using Windows
    services technology. In the case of Linux, the worker runs using `systemd`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, .NET Core provides two different NuGet packages to specify the
    host behavior of the worker: the `Microsoft.Extensions.Hosting.WindowsServices`
    package and the `Microsoft.Extensions.Hosting.Systemd` package, both available
    on NuGet.'
  prefs: []
  type: TYPE_NORMAL
- en: The `Microsoft.Extensions.Hosting.WindowsServices` package provides an extension
    method called `UseWindowsService()`, which can be applied after the initialization
    of the host in the `Main` method of the `Program` class. The `UseWindowsService()`
    method sets `WindowsServiceLifetime` and uses the *Windows event log* as the default
    logging output.
  prefs: []
  type: TYPE_NORMAL
- en: If we choose to host our worker as a `systemd` service, we need to use the `Microsoft.Extensions.Hosting.Systemd`
    NuGet package. This package provides the `UseSystemd()` method, which can be applied
    in the same way as `UseWindowsService()`; in this case, our worker service will
    use the `SystemdLifetime` class, and it configures the logging to be compliant
    with the `systemd` format.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that both the `UseWindowsService()` and `UseSystemd()`
    methods are executed only if the worker service is running respectively as a Windows
    service and a `systemd` service.
  prefs: []
  type: TYPE_NORMAL
- en: Once we have discovered the different ways to host the worker service, we can
    proceed by applying these concepts to the concrete of a health-check process.
    Besides, we will also see how to run the worker on a Docker container.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing a health-checking worker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The following section focuses on the implementation of a worker service. The
    use case we will cover is a health-checking worker of a generic web service. Furthermore,
    let's suppose that we want to check the health status of one of our web services
    regularly. This kind of check is usually performed at the end of the deployment
    pipeline, or once a service is deployed, to verify that the web service is up
    and running.
  prefs: []
  type: TYPE_NORMAL
- en: Project structure overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This section gives you an overview of the worker template project provided
    out of the box by the .NET Core templating system. We will use this type of project
    to implement a health-check worker. First of all, let''s start by creating a new
    project using the following CLI command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This command creates a new folder called `HealthCheckWorker` and it creates
    all of the files needed by a basic worker service project. Let's have a look at
    the files created by the template `dotnet new worker` command executed previously.
  prefs: []
  type: TYPE_NORMAL
- en: 'Secondly, we can run the `tree` CLI command (available both on macOS X and
    Windows), which shows the folder structure of the project previously created:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `Program.cs` file is the entry point of our worker service. As the `webapi`
    template, the worker template uses the `Program.cs` file to initialize and retrieve
    a new `IHostBuilder` instance by calling the `Host.CreateDefaultBuilder` and `ConfigureServices`
    methods. The `Main` static method in the `Program.cs` file initializes a list
    of workers using the `AddHostedService` extension method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As previously mentioned, the preceding snippet of code uses `AddHostedService`
    to initialize the `Worker` class created as a part of the default worker template.
    It is necessary to notice that, under the hood, `AddHostedService` initializes
    the class with a `Singleton` life cycle. Therefore, we will have one instance
    of the worker for the whole execution time of the worker service. In the next
    section, we will go deep into the life cycle execution of a worker.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another major characteristic that distinguishes a worker project from any other
    .NET Core project is the use of the `Microsoft.NET.Sdk.Worker` SDK. Furthermore,
    we should also notice that the `*.csproj` file refers to only one additional NuGet
    package that provides the hosting extension methods used by the `Program` class
    and the `Main` method: `Microsoft.Extensions.Hosting`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to create a new class that represents the configurations of
    the `HealthCheckWorker` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '`HealthCheckSettings` will contain two attributes: the `Url` and `IntervalMs`
    attributes. The first attribute contains the HTTP URL of the health check address,
    specified in `appsettings.json`*.* The `IntervalMs` attribute represents the frequency
    life cycle (in milliseconds) of the worker.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Furthermore, it is possible to use the configuration system of .NET Core to
    bind our configuration object at the execution of the `Main` method of the `Program.cs`
    file, using the following approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code uses `hostContext` to retrieve the `Configuration` instance
    provided by .NET Core. By default, `hostContext` will be populated with the settings
    structure written in the `appsettings.json` file. Moreover, it is possible to
    use the `GetSection` method to retrieve the specific configuration section from
    our `appsettings.json` file and bind it to the `HealthCheckSettings` type.
  prefs: []
  type: TYPE_NORMAL
- en: 'After that, we can proceed with the concrete implementation of the `Worker`
    class. Furthermore, we are now able to inject the `HealthCheckSettings` type instance
    using the built-in dependency injection of .NET Core. The settings are injected
    using the `IOption` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code defines the attributes of the `Worker` class. As mentioned,
    the class implements an `_settings` attribute of the `HealthCheckSettings` type
    initialized using the constructor injection technique. Moreover, we can also see
    an `HttpClient` attribute, which will be initialized by the `StartAsync` method
    exposed by the `BackgroundService` class, and it is used in the `ExecuteAsync`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: After the initialization of the client, the `ExecuteAsync` method implements
    a `while` loop that will continue until the `stoppingToken` requests the cancellation
    of the process. The core part of the loop uses the `GetAsync` method of `HttpClient`
    to check whether the health check route returns an HTTP status message. Finally,
    the code calls `Task.Delay` with the `IntervalMs` property populated with the
    `_settings` instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'As the last step, the `Worker` class overrides the `StopAsync` method exposed
    by the `BackgroundService` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `StopAsync` method executes the `HttpClient` instance disposition by calling
    the `Dispose()` method, and it calls `base.StopAsync(cancellationToken)` of the
    base `BackgroundService` class.
  prefs: []
  type: TYPE_NORMAL
- en: We should notice that the `StartAsync` and `StopAsync` methods always call the
    parent methods using the `base` keyword. Furthermore, in our case, we need to
    hold the behavior of the base `BackgroundService` class.
  prefs: []
  type: TYPE_NORMAL
- en: The next part of this chapter will be focused on the execution of the worker
    on a Docker container. We will see how to configure the `Dockerfile`, and deploy
    and run the application.
  prefs: []
  type: TYPE_NORMAL
- en: Running a worker service on Docker
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section is focused on the deployment step of the .NET worker template.
    We will proceed by running our service on a Docker Linux image. As we have already
    seen in [Chapter 12](d3fd0efc-cb05-42bb-8e06-4fd3a7ca9300.xhtml), *The Containerization
    of Services*, we will use Docker to run the application in a container.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s start by configuring the `Dockerfile` in the project folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code describes the container build and deployment process for
    our .NET Core worker application. The `Dockerfile` instructions can be grouped
    into five steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The first step executes the build of the project using the `dotnet/core/sdk`
    Docker image:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: First of all, it sets the working directory as `/src` and copies the files in
    the project folder.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: Secondly, it executes the `dotnet restore` and `dotnet build` commands.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The second step runs the `dotnet publish` command using the `Release` configuration
    in the `/app/publish` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The third step uses the `dotnet/core/runtime` Docker image to run the result
    of the previously executed `dotnet publish` using the `dotnet` CLI command.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'It is possible to build the Docker image using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can run the previously built image using the following command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The preceding command runs the Docker container and, consequently, the worker
    service process. The worker service will perform an HTTP `GET` request to the
    URL configured in the `appsettings.json` file of the project by applying throttling,
    also specified in the `appsettings.json` file.
  prefs: []
  type: TYPE_NORMAL
- en: The previously mentioned `Dockerfile` uses a multi-stage build approach and
    some other techniques to build the Docker image used to run the project. These
    concepts, and more, are described in detail in [Chapter 12](d3fd0efc-cb05-42bb-8e06-4fd3a7ca9300.xhtml),
    *The* *Containerization of Services*.
  prefs: []
  type: TYPE_NORMAL
- en: Consuming the sold-out event
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The sold-out event we implemented in [Chapter 13](8f70e186-50f1-4d55-99e6-026c73d5bb96.xhtml),
    *Service Ecosystem Patterns,* provides the information on the items that are not
    available in the catalog. Furthermore, we can consume this event through the use
    of the `BackgroundService` type capabilities we described in this chapter. The
    cart service will implement a sold-out handler that will handle and remove the
    item IDs that are not available from the Redis instance.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a sold-out handler
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s start by creating a handler that manages the sold-out condition of a
    product in the cart service. First of all, we should proceed by adding the `RabbitMQ.Client`
    package to the `Cart.Domain` project by executing the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'We can continue by defining a class that represents the sold-out event that''s
    used by the cart service in a new project that will contain all of the events.
    Therefore, we will proceed by creating a new `ItemSoldOutEvent` type, which represents
    a sold-out event:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ItemSoldOutEvent` type contains a reference to `Id` of the item that''s
    sold out. The type will be used to deserialize the content of the queue into a
    strongly typed instance and send a message through the MediatR instance. As we
    did for the configurations of the catalog service, we will also need an analog
    class that represents the RabbitMQ configurations in the `Cart.Infrastructure`
    project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'The `EventBusSettings` type defined previously describes `HostName` of the
    RabbitMQ instance, `User` and `Password` of the user, and the `EventQueue` name
    to use to push messages. Furthermore, we can proceed by defining the mediator
    handler for consuming the `ItemSoldOutEvent` events by defining a new class in
    the `Cart.Domain` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The previous `ItemSoldOutEventHandler` class implements the `IRequestHandler<T>`
    interface that's provided by the MediatR package. This interface contains the
    `Handle` method, which is the main entry point of the handler. A new `ItemSoldOutEventHandler`
    instance will be executed when an event of the `ItemSoldOutEvent` type is received
    by the cart service. `ItemSoldOutEventHandler` depends on `ICartRepository`. Furthermore,
    the `RemoveItemsInCart` method retrieves all of the carts stored in our repository,
    and it removes the sold-out items every time it receives a message of the `ItemSoldOutEvent`
    type.
  prefs: []
  type: TYPE_NORMAL
- en: Testing the sold-out process
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'It is possible to check the sold-out process by testing `ItemSoldOutHandler`.
    The handler will be tested with the same approach we saw for the other handlers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ItemSoldOutEventHandlerTests` class uses the `CartContextFactory` class
    to initialize a new repository in each test method using the `_contextFactory.GetCartRepository();`
    method. Furthermore, the `should_not_remove_records_when_soldout_message_contains_not_existing_id`
    test method checks that nothing breaks if the `ItemSoldOutEvent` instance has
    a non-existent ID. On the other hand, the `should_remove_records_when_soldout_messages_contains_existing_ids`
    test method checks that `ItemSoldOutEventHandler` deletes the item in the basket
    when the `ItemSoldOutEvent` instance contains an existing ID:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The second test method provides an existing item ID and verifies the handle
    method by checking whether the process has effectively removed the items. Now
    that we have verified the behavior of `ItemSoldOutHandler`, we can proceed by
    configuring and registering the event bus instance.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the background service
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now that we have defined the event bus abstraction, we can proceed by creating
    a new `BackgroundService` type that will use the `IMediator` interface to dispatch
    the sold-out messages. This book uses RabbitMQ because it is open source and easy
    to configure but keep in mind that there are tons of products and technologies
    related to this topic. Before continuing with the implementation of the background
    service, it is necessary to add some packages to the `Cart.Infrastructure` project:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'Furthermore, we can proceed by creating a new class that extends the `BackgroundService`
    type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding snippet defines the `ItemSoldOutBackgroundService` type. The
    class extends the `BackgroundService` base class exposed by the `Microsoft.Extensions.Hosting`
    namespace. The constructor injects the `IMediator` interface to dispatch the collected
    events to the `ItemSoldOutEventHandler` type. Furthermore, it also defines the
    attribute of the `IModel` type that will be populated by the `ConnectionFactory`
    type injected in the constructor. The `_channel` attribute will be used by the
    `ExecuteAsync` method provided by the `BackgroundService` class to dispatch the
    events. Let''s proceed by overriding the `ExecuteAsync` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The preceding snippet uses the `_channel` attribute to initialize a new `EventingBasicConsumer`
    instance. For each received message, it deserializes the `Body` attribute into
    an `ItemSoldOutEvent` type and it sends the event to the `IMediator` instance
    using the `Send` method. Finally, it activates the consuming process by using
    the `EventQueue` name provided by the `EventBusSettings` type. Also, in this case,
    the consumption process is wrapped using a try-catch to isolate the process in
    the event of failure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use RabbitMQ, it is necessary to configure the client so that
    we connect to the right event bus instance. Let''s start by creating a new extension
    method in the `Cart.Infrastructure` project, which can be found under the `Extensions`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: The previous definition implements an extension method bound with the `IServiceCollection`
    interface, which is provided by the dependency injection system of ASP.NET Core.
    It is used in the `Startup` class to connect to RabbitMQ.The `AddEventBus` method
    initializes the `ConnectionFactory` class by passing the parameter of RabbitMQ.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can proceed by activating the background service by adding the
    following extension methods to the `ConfigureServices` method of the `Startup`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddEventBus` method adds all of the dependencies needed by the consumption
    process of the sold-out events to the dependency injection. Also, the `AddHostedService`
    method registers `ItemSoldOutBackgroundService` as the `IHostedService` type.
    Finally, to use the event bus, we can proceed by defining the connection information
    in the `appsettings.json` file of the `Cart.API` project, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: The connection parameters point to the `catalog_esb` instance defined in the
    `docker-compose.yml` file defined in the catalog service. Furthermore, the `ItemSoldOutBackgroundService`
    class will process the message in the `ItemSoldOut` queue and trigger the removal
    of the items.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter described how you can use the .NET Core worker template to implement
    a continuously running task. .NET Core workers are really useful in distributed
    systems to perform all of the asynchronous and event-based computations without
    an increase in the load of the server.
  prefs: []
  type: TYPE_NORMAL
- en: The integration with Windows services and `systemd` also provides an efficient
    way to deploy and to run the worker. This chapter has given you an overview of
    the .NET Core worker service hosting models, and it showed how to set up and implement
    a worker service using .NET Core and how to run it on Docker. Finally, we saw
    how to integrate the `BackgroundService` class capabilities with the previously
    implemented item sold-out message integration.
  prefs: []
  type: TYPE_NORMAL
- en: The next chapter will cover some of the common security practices provided and
    implemented by .NET Core.
  prefs: []
  type: TYPE_NORMAL
