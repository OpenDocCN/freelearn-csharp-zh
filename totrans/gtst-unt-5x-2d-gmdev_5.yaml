- en: Chapter 5. The Secret Ingredient Is a Dash of Physics
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第5章。秘密成分是一点点物理
- en: '*"Sprinkles may seem soft, but they are an excellent sharp weapon against sweet-tooth
    pandas, who are trying to steal your delicious cake!"*'
  id: totrans-1
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “糖果可能看起来很柔软，但它们是对甜食熊猫的绝佳锐利武器，它们试图偷走你美味的蛋糕！”
- en: This chapter explains how Unity deals with 2D physics and provides descriptions
    for each of the components, along with useful examples of usages. Although we
    will use just a small portion of the Physics engine of Unity for our game, in
    this chapter you can find some foundations of physics to better face the topics
    covered, and a full insight of 2D physics in Unity.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了Unity如何处理2D物理，并为每个组件提供了描述，以及一些有用的使用示例。虽然我们只为我们的游戏使用Unity物理引擎的一小部分，但在本章中，你可以找到一些物理的基础知识，以更好地面对所涵盖的主题，以及Unity中2D物理的全面洞察。
- en: In the first part of the chapter, we will acquire some basic notions about physics
    so as to better face the topics to come. We will learn about mass, forces, and
    torques, just enough to understand physics in Unity.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的第一部分，我们将掌握一些关于物理的基本概念，以便更好地面对即将到来的主题。我们将学习质量、力和扭矩，仅足够理解Unity中的物理。
- en: Then, most of the chapter will focus on explaining, bit by bit, the 2D Physics
    engine of Unity along with all its components and functionalities. Many examples
    will be provided in order to facilitate the learning.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，本章的大部分内容将逐步解释Unity的2D物理引擎及其所有组件和功能。将提供许多示例，以方便学习。
- en: Finally, in the last part of the chapter, we will use some of the notions learnt
    and apply them into our game. In fact, we will transform simple sprinkles into
    terrible weapons against the sweet-toothed pandas by enabling and handling collisions
    between the two.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在本章的最后部分，我们将运用所学的概念并将它们应用到我们的游戏中。实际上，我们将通过启用和处理两个物体之间的碰撞，将简单的糖果变成对抗甜食熊猫的可怕武器。
- en: 'Therefore, we are going to learn these topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将学习以下这些主题：
- en: Basic notions of physics
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理学的基本概念
- en: Understanding the Physics engine of Unity
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解Unity的物理引擎
- en: Physics settings, which are general properties for the whole project/game
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 物理设置，这是整个项目/游戏的一般属性
- en: Rigidbody components with different body types and their usage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不同身体类型和它们的使用方式的刚体组件
- en: Colliders and how to use them
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞体及其使用方法
- en: Joints to impose constraints on rigidbodies
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于对刚体施加约束的关节
- en: Effectors to change physics properties in particular region of the game world
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在游戏世界的特定区域改变物理属性的效果器
- en: Physics materials to determine friction and bounciness on colliders
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 用于确定碰撞体摩擦和弹性的物理材料
- en: Using the physics components in our game
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的游戏中使用物理组件
- en: Like all other chapters in this book, you will find the *Homework* section at
    the end. It has a range of different exercises for you to do to improve your skills
    and implement a range of different functionalities into your game.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本书中的其他所有章节一样，你将在结尾找到“作业”部分。它包含了一系列不同的练习，帮助你提高技能并将各种不同的功能实现到你的游戏中。
- en: Getting ready
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This chapter does not need any particular prerequisite to learn about the Physics
    engine. However, at the end of this chapter we will continue our tower defense
    game from where we left it in [Chapter 4](part0056.xhtml#aid-1LCVG1 "Chapter 4. No
    Longer Alone – Sweet-Toothed Pandas Strike"), *No Longer Alone – Sweet-Toothed
    Pandas Strike*. Therefore, if you want to keep developing the *Tower Defense*
    game, you need to have done all the other steps in the previous chapters.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章学习关于物理引擎的内容不需要任何特定的先决条件。然而，在本章的结尾，我们将继续我们在[第4章](part0056.xhtml#aid-1LCVG1
    "第4章。不再孤单——甜食熊猫出击")中留下的塔防游戏，“不再孤单——甜食熊猫出击”。因此，如果你想继续开发“塔防”游戏，你需要完成前几章中的所有其他步骤。
- en: For those of you who are newcomers to physics, a great deal of patience is required,
    but once you master these concepts, a world of new possibilities for your own
    games will open. So don't give up!
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些刚开始学习物理的新手来说，需要大量的耐心，但一旦你掌握了这些概念，你自己的游戏将打开一个全新的可能性世界。所以不要放弃！
- en: Physics in video games
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏中的物理
- en: From bullets flying at different speeds and trajectories to gravity playing
    a role between keeping you grounded and allowing you to float, physics in video
    games plays an essential part in making experiences realistic and definitely enjoyable
    (for the most part). Imagine if every weapon fired a bullet in the same way, regardless
    of the firepower. Then what would be the point between having a sniper rifle or
    a revolver? This is only one aspect of the role that physics plays in games. Physics
    in games does not just revolve around trajectories and force; it can include gravity,
    time travel, and fluid dynamics.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 从不同速度和轨迹飞行的子弹到重力在让你保持在地面上和让你漂浮之间发挥作用，视频游戏中的物理学在使体验更加真实和绝对有趣（大部分情况下）中扮演着至关重要的角色。想象一下，如果每种武器发射的子弹都以相同的方式发射，无论火力如何，那么狙击步枪和左轮手枪之间的区别又在哪里呢？这仅仅是物理学在游戏中扮演角色的一个方面。游戏中的物理学不仅仅围绕轨迹和力；它还可以包括重力、时间旅行和流体动力学。
- en: Some great examples of games that use physics include *World of Goo*, *Portal
    1* and *2*, *Mario Galaxy*, and *Kerbal Space Program.*
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 一些使用物理学的优秀游戏例子包括 *World of Goo*，*Portal 1* 和 *2*，*Mario Galaxy*，以及 *Kerbal Space
    Program*。
- en: '![Physics in video games](img/image00512.jpeg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![视频游戏中的物理学](img/image00512.jpeg)'
- en: Image by Portal 2 - An orange liquid that reduces friction so much to give you
    a substantial boost
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图片来自 Portal 2 - 一种减少摩擦的橙色液体，可以给你提供很大的助推
- en: 'Of course, at the other end of the spectrum, games don''t always replicate
    physics in the most accurate way but rather exaggerate it or dismiss it altogether
    to allow for innovative and unique gameplay. An example of this would include
    taking a *Leap of Faith* from great heights in *Assassin''s Creed*, into conveniently
    placed stacks of hay (and even water). Some people have even studied how much
    hay that you would actually need in order to survive such jumps, which you can
    find here: [http://www.kotaku.com.au/2009/06/kotaku-bureau-of-weights-measures-studies-fallout-physics-also-beer/](http://www.kotaku.com.au/2009/06/kotaku-bureau-of-weights-measures-studies-fallout-physics-also-beer/)'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在光谱的另一端，游戏并不总是以最准确的方式复制物理学，而是夸张它或完全忽略它，以允许创新和独特的游戏玩法。一个例子就是在 *Assassin's
    Creed* 中从很高的地方跳下，跳进方便放置的干草堆（甚至水）。有些人甚至研究了为了生存这样的跳跃你需要多少干草，你可以在这里找到：[http://www.kotaku.com.au/2009/06/kotaku-bureau-of-weights-measures-studies-fallout-physics-also-beer/](http://www.kotaku.com.au/2009/06/kotaku-bureau-of-weights-measures-studies-fallout-physics-also-beer/)
- en: When it comes to adding physics to your own game, you must ask yourself to what
    extent you want your gaming experience to be real. If you want your game to be
    100% identical to reality, then you must also consider things like death. If a
    character can be shot by a bullet, do they bleed out or can they heal themselves?
    In some cases, your game may end up more of a simulation than a game itself if
    the interaction is too real. An example is **permadeath** (where the player must
    restart the game from the beginning after they have died), which you may or may
    not want in your game/simulation. All of these factors need to be considered when
    adding physics into games because both the cause and effect will all contribute
    to how believable the game is and ultimately how enjoyable it will be.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到在你的游戏中添加物理学时，你必须问自己你希望你的游戏体验有多真实。如果你想你的游戏与现实100%相同，那么你也必须考虑像死亡这样的事情。如果一个角色可以被子弹击中，他们会出血吗？或者他们可以自己治愈？在某些情况下，如果你的游戏互动过于真实，游戏本身可能最终更像是一个模拟而不是游戏。一个例子是**永久死亡**（玩家在死后必须从游戏开始重新开始），你可能或可能不在你的游戏/模拟中想要这个。在将物理学添加到游戏中时，所有这些因素都需要考虑，因为原因和结果都会对游戏的可信度和最终的可玩性产生影响。
- en: Physics – basics
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理学 – 基础
- en: In this section, we will learn some basic notions of physics, to better understand
    the Physics engine of Unity later on, and overall become better game developers.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习一些基本的物理学概念，以便更好地理解Unity的物理引擎，并总体上成为更好的游戏开发者。
- en: 'First of all, what is physics? Aristotle (the same guy from the previous chapter)
    wrote a treatise entitled *ta physika*, which literally means the natural things.
    From this treatise (although many before Aristotle have written about natural
    phenomena), physics has become a science. Nowadays, physics investigates matter,
    its motion both in time and space, through mathematical models. Ultimately, the
    goal of physics is to describe how the whole universe works. Physics is divided
    into four big branches:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，什么是物理学？亚里士多德（与上一章中提到的那个人同一个人）写了一篇题为 *ta physika* 的论文，字面意思是自然事物。从这篇论文（尽管在亚里士多德之前许多人已经写过关于自然现象的文章），物理学成为了一门科学。如今，物理学通过数学模型研究物质，它在时间和空间中的运动。最终，物理学的目标是描述整个宇宙是如何运作的。物理学分为四个主要分支：
- en: '**Classical mechanics**: This deals with the motion of objects'
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**经典力学**：这涉及物体的运动'
- en: '**Thermodynamics**: This deals with the temperatures of bodies'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**热力学**：这涉及物体的温度'
- en: '**Electromagnetism**: This deals with electromagnetic waves/particles'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电磁学**：这涉及电磁波/粒子'
- en: '**Quantum mechanics**: This deals with the study of subatomic particles'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**量子力学**：这涉及亚原子粒子的研究'
- en: You don't need to see these as separate entities but just faces of the same
    coin, which is the model of the world that physics over the centuries has tried
    to unravel. Therefore, many topics cross them all, and so the division in not
    univocal. But, it's a good way for newcomers to physics to get an overview.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 你不需要将这些看作是独立的实体，而只是同一枚硬币的不同面，这是物理学几个世纪以来试图揭示的世界模型。因此，许多主题跨越了所有这些分支，因此这种划分并不是绝对的。但是，这对于物理学的新手来说是一个很好的概述。
- en: In this chapter, we will deal only with classical mechanics, and in particular
    with the motion of rigid bodies. However, other branches and sub-branches of physics
    are also really useful in game development. For instance, we can use light equations,
    which are implemented in shader, or fluid dynamics to simulate oceans and waves.
    Even when the evil wizard casts his most terrible fireball, we need to calculate
    many different physics equations to have a realistic behaviour and look. Imagine
    just simulating the fire around the ball.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将只涉及经典力学，特别是刚体的运动。然而，物理学的其他分支和子分支在游戏开发中也非常有用。例如，我们可以使用在着色器中实现的灯光方程，或者流体动力学来模拟海洋和波浪。即使邪恶的巫师施放他最可怕的火球，我们也需要计算许多不同的物理方程，以实现逼真的行为和外观。想象一下只是模拟球体周围的火焰。
- en: Most of the time, you don't want to go into that much detail, if you already
    have a game engine like Unity (or Unreal). In fact, their programmers will take
    care of this for you. However, sometimes you may have special needs, and you need
    to write your own shader or code some physics-based behaviours. As such, knowledge
    of physics is greatly and immensely helpful.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数情况下，如果你已经有一个像Unity（或Unreal）这样的游戏引擎，你不需要深入了解细节。实际上，他们的程序员会为你处理这些。然而，有时你可能会有特殊的需求，需要编写自己的着色器或编写一些基于物理的行为代码。因此，对物理学的了解非常有帮助，并且极其重要。
- en: Of course, this is not a course in physics nor a book dedicated to physics programming
    (for example, algorithms that can simulate more or less approximately and efficiently
    some physical behaviours). However, in this chapter, we will consolidate the really
    basic concepts of physics so that we can have a rough idea of how it all works
    together. As such, this and the upcoming sections will be dedicated to building
    a foundational understanding of physics so that we can better grasp the Physics
    engine behind Unity.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这并不是一门物理学课程，也不是一本专门介绍物理学编程（例如，可以模拟更多或更少、更高效地模拟某些物理行为的算法）的书。然而，在本章中，我们将巩固物理学的基本概念，以便我们能够大致了解它们是如何共同工作的。因此，本章和接下来的部分将致力于建立对物理学的坚实基础，以便我们更好地理解Unity背后的物理引擎。
- en: Note
  id: totrans-38
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: I know that some of you might find physics somewhat boring. This may be the
    case if it awakes some bad memory (or memories) from high school. But my personal
    opinion is that knowing physics is really important to be a good game developer,
    especially when you need to program realistic behaviours. With this said, I promise
    that in this section, I'll try to be as clear as possible and use an informal
    language instead of the strict mathematical one so that these concepts can be
    understood by anyone.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道你们中的一些人可能会觉得物理有点无聊。如果它唤醒了高中的一些不良记忆（或记忆），可能会是这样。但我的个人观点是，了解物理对于成为一名优秀的游戏开发者来说非常重要，尤其是在你需要编写现实行为时。有了这个前提，我保证在本节中，我会尽可能地清晰，并使用非正式的语言而不是严格的数学语言，以便任何人都能理解这些概念。
- en: 'Classical mechanics of rigidbodies can be divided into two sub-branches:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 刚体经典力学可以分为两个子分支：
- en: 'Kinematics: Which deals with the study of the motion.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 运动学：它涉及对运动的研究。
- en: 'Dynamics: Which deals with the causes of the motion.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 动力学：它涉及运动的原因。
- en: Of course, once again, they are faces of the same coin. In fact, dynamic equations
    need kinematic ones, so as to describe and predict the motion of rigidbodies.
    We will see them in a bit more detail soon, but first let's focus on some basic
    concepts.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，再次强调，它们是同一枚硬币的两面。实际上，动态方程需要运动学方程，以便描述和预测刚体的运动。我们很快就会更详细地了解它们，但首先让我们关注一些基本概念。
- en: World coordinates and local coordinates
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 世界坐标系和局部坐标系
- en: 'As we have already seen in [Chapter 2](part0028.xhtml#aid-QMFO1 "Chapter 2. Baking
    Cupcake Towers"), *Baking Cupcake Towers,* there is a difference in using world
    coordinates and local coordinates. This is also an important concept in physics:
    which one is your reference frame (or coordinate system)? The question is key
    in determining also the values of the different physics quantities. Therefore,
    every time you have a physical quantity, you need to ask yourself in which reference
    frame are you working.'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在[第二章](part0028.xhtml#aid-QMFO1 "第二章。制作纸杯蛋糕塔")中已经看到的[*制作纸杯蛋糕塔*]，使用世界坐标系和局部坐标系之间存在差异。这也是物理学中的一个重要概念：你的参考系（或坐标系）是哪一个？这个问题是确定不同物理量值的关键。因此，每次你有一个物理量时，你都需要问自己你正在哪个参考系中工作。
- en: In any case, there isn't a frame that is privileged with respect to another
    (although some physical systems are easier to describe within a frame instead
    of another). So, by convention, a world frame is defined when we start the description
    of a physical system. For example, if you are driving your car, what is your velocity?
    Well, the answer depends on the coordinate system, or reference frame in which
    I'm describing the car moving. In the car itself, the speed of the car is zero,
    but rather the world is coming towards the car. Whereas for a pedestrian, the
    car is moving, and the world is not. An astronaut on the moon will see both the
    pedestrian moving really fast, along with the whole Earth, and also the car, at
    two different speeds. All of these descriptions are physically correct. Therefore,
    all quantities in physics depends on the reference frame.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，没有一个坐标系相对于另一个坐标系具有特权（尽管有些物理系统在某些坐标系中比在其他坐标系中更容易描述）。因此，按照惯例，当我们开始描述一个物理系统时，就定义了一个世界坐标系。例如，如果你在开车，你的速度是多少？嗯，答案取决于我描述汽车运动时所使用的坐标系或参考系。在汽车本身中，汽车的速度是零，而是世界正在向汽车靠近。而对于行人来说，汽车在移动，而世界没有移动。月球上的宇航员会看到行人以非常快的速度移动，包括整个地球，以及汽车，以不同的速度。所有这些描述都是物理上正确的。因此，物理学中的所有量都依赖于参考系。
- en: 'In game engines such as Unity and/or Unreal, there is always a defined world
    frame (when you have the position with all zeros at the center of the world frame)
    as shown in the following diagram:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity和/或Unreal等游戏引擎中，始终有一个定义好的世界坐标系（当你有以世界坐标系中心为零的位置时），如下面的图所示：
- en: '![World coordinates and local coordinates](img/image00513.jpeg)'
  id: totrans-48
  prefs: []
  type: TYPE_IMG
  zh: '![世界坐标系和局部坐标系](img/image00513.jpeg)'
- en: The preceding diagram shows how other frames are described in terms of linear
    and angular offset from the world frame. Moreover, you can describe a frame in
    terms of another, which is not the world frame (in the preceding diagram, look
    at the angular offset of frame **#3**). In Unity, you can consider the world frame
    as the global coordinates and the different frames as the local coordinates of
    game objects in the game. Children of game objects will be expressed in terms
    of the frame of the parent.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 上述图表显示了如何用线性偏移和角偏移来描述相对于世界坐标系的其它坐标系。此外，你还可以用另一个坐标系来描述一个坐标系，而这个坐标系不是世界坐标系（在上述图表中，看看框架**#3**的角偏移）。在Unity中，你可以将世界坐标系视为全局坐标，而不同的坐标系视为游戏中游戏对象的局部坐标。游戏对象的孩子将以父框架的形式表示。
- en: Velocity
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 速度
- en: Velocity in physics describes a relation between the space and the time of an
    object; in other words, how the object changes position with respect to a reference
    frame as a function of time. When the object is not accelerating, velocity is
    defined as distance covered in space divided by time.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 物理学中的速度描述了一个物体空间和时间之间的关系；换句话说，物体如何随时间变化相对于参考系的位置。当物体不加速时，速度被定义为空间内覆盖的距离除以时间。
- en: Note
  id: totrans-52
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: For those of you who are curious, when an object changes its velocity in each
    instant, and we need to get the velocity in a specific instant, it is possible
    to retrieve it by using derivatives (this is a topic of calculus, and I won't
    adventure deeper in this book).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些好奇的人，当一个物体在每个瞬间改变其速度，并且我们需要获取特定瞬间的速度时，可以通过使用导数来获取它（这是一个微积分的话题，我不会在这本书中深入探讨）。
- en: Velocity is a vector, and therefore it has two coordinates in the 2D world (three
    in the 3D world), which express a direction and an intensity. The intensity of
    a velocity is also called **speed**. So it's important to not get confused between
    the two. In fact, speed is a scalar, just a number, acting independently if we
    are dealing with 2D or 3D games; velocity, instead, does change (from two numbers
    to three numbers to express respectively the 2D or 3D vector).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 速度是一个矢量，因此它在2D世界中有两个坐标（在3D世界中是三个坐标），表示方向和强度。速度的强度也称为**速度**。所以不要混淆这两个概念。实际上，速度是一个标量，只是一个数字，如果我们处理的是2D或3D游戏，它独立起作用；相反，速度会变化（从两个数字变为三个数字，分别表示2D或3D矢量）。
- en: Whenever we use the term velocity, we mean the velocity in the defined world
    frame (or coordinate). When we use the term relative velocity, we are taking the
    velocity with respect to another frame. For instance, imagine that there are two
    cars that are heading against each other, both at 50 Km/h (in the world frame,
    because when you look at your tachymeter, by convention, that is the velocity
    with respect to the Earth). For one of the two drivers, the car he is driving
    is not moving (in fact, when you drive, your steering wheel is not going 50 Km/h
    away from your hands, but it is always at the same distance from you). However,
    he will see the other car with the other driver coming at 100 Km/h towards him.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时我们使用速度这个术语，我们指的是定义好的世界坐标系中的速度（或坐标）。当我们使用相对速度这个术语时，我们是指相对于另一个参考系的速度。例如，想象有两辆汽车朝相反方向行驶，速度都是50公里/小时（在世界坐标系中，因为当你看你的转速表时，按照惯例，这是相对于地球的速度）。对于两位驾驶员中的任何一位，他驾驶的汽车没有移动（实际上，当你开车时，你的方向盘并不是以50公里/小时的速度远离你的手，但它始终与你保持相同的距离）。然而，他会看到另一辆汽车和另一位驾驶员以100公里/小时的速度向他驶来。
- en: Mass
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 质量
- en: In classical mechanics, every rigid body has a mass, which you can imagine as
    the amount of matter that forms that body. Thus, it is considered a property of
    the physical body. Often in spoken language, mass is confused with weight. In
    fact, mass is measured in kg (kilograms) in the International System of Units,
    whereas weight is measured in N (newton) in the International System of Units.
    Therefore, a scale is not measuring your weight, but rather your mass. Weight
    is a force and depends on the location where you are. Your weight is different
    on the moon, but your mass is the same.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典力学中，每个刚体都有一个质量，你可以想象成构成该物体的物质的数量。因此，它被认为是物理体的一个属性。在口语中，质量经常与重量混淆。实际上，质量在国际单位制中以千克（kg）为单位测量，而重量在国际单位制中以牛顿（N）为单位测量。因此，秤不是测量你的重量，而是你的质量。重量是一种力，取决于你所在的位置。你在月球上的重量不同，但你的质量是相同的。
- en: Sometimes, mass is also defined as the measure of an object's resistance to
    acceleration (a change in its state of motion) when a force is applied. In fact,
    you need much more force to move a truck than your laptop.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，质量也被定义为物体对加速度（当施加力时其运动状态的变化）的抵抗程度的度量。实际上，你需要施加更多的力才能移动一辆卡车，而不是你的笔记本电脑。
- en: However, it is worthwhile paying attention that, for instance, both the laptop
    and the truck (in absence of other external forces) are attracted by the gravity
    of the Earth and that both will fall down and touch the ground at the same time.
    In fact, when the universal gravitation equation of Newton is applied, the forces
    applied are different but the resulting gravitational acceleration is the same
    for both objects (since the mass is simplified from the equations).
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，值得注意的是，例如，笔记本电脑和卡车（在没有其他外部力的情况下）都受到地球引力的吸引，并且它们都会同时落地接触地面。实际上，当应用牛顿的万有引力方程时，作用在两个物体上的力是不同的，但它们的重力加速度是相同的（因为质量在方程中被简化了）。
- en: Note
  id: totrans-60
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the more curious of you, this was discovered by the famous Italian astronomer,
    physicist, engineer, philosopher, and mathematician Galileo Galilei, much before
    Newton formalized gravitation. There is an anecdote in which Galileo had dropped
    balls of the same material but different masses from the Leaning Tower of Pisa
    to demonstrate that their time of descent was independent of their mass. In this
    way, he proved that Aristotle''s idea that heavy objects fall faster than lighter
    ones, in direct proportion to weight (at that time intended as mass) was wrong
    as shown in the following diagram:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 对于你们中更好奇的人，这个发现是由著名的意大利天文学家、物理学家、工程师、哲学家和数学家伽利略·伽利莱（Galileo Galilei）在牛顿正式化引力之前很久就发现的。有一个轶事说伽利略曾从比萨斜塔上扔下不同质量但材质相同的球体，以证明它们的下落时间与质量无关。通过这种方式，他证明了亚里士多德的观点——重的物体比轻的物体下落得快，与重量（当时指的是质量）成正比——是错误的，如下面的图所示：
- en: '![Mass](img/image00514.jpeg)'
  id: totrans-62
  prefs: []
  type: TYPE_IMG
  zh: '![质量](img/image00514.jpeg)'
- en: Centre of mass
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 质心
- en: Imagine you need to calculate or predict the trajectory of an arrow. Taking
    into consideration the whole shape of the arrow and knowing that different forces
    come into play at each point ends up in a really tricky calculation (although
    possible). Therefore, the center of mass is an approximation that works pretty
    well for rigid bodies. It consists of concentrating the whole mass of an object
    into a single point (which is an abstraction to imagine all of the mass of that
    body in that single point). Where this point is depends on the shape of the object
    (since it is weighted among all the points the object is composed of), and this
    carries enough information about the shape to do really precise calculations.
    Especially in real-time applications, this becomes critical, since calculations
    of motion are greatly simplified. In fact, Unity will only do calculations using
    the center of mass.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你需要计算或预测箭矢的轨迹。考虑到箭矢的整体形状，并知道在每一个点都有不同的力作用，最终会导致一个非常复杂的计算（尽管是可能的）。因此，质心是一个对刚体来说非常有效的近似。它包括将一个物体的全部质量集中到一个点上（这是一个抽象，想象这个物体的所有质量都集中在这个点上）。这个点的位置取决于物体的形状（因为它在物体组成的所有点中是加权的），并且这个点提供了足够的信息来进行非常精确的计算。特别是在实时应用中，这一点变得至关重要，因为运动计算大大简化了。实际上，Unity
    只会使用质心来计算。
- en: '![Centre of mass](img/image00515.jpeg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![质心](img/image00515.jpeg)'
- en: The center of mass is the weight average of all the points in the system, where
    the weights are the different masses. From the diagram, we can see that center
    of mass is closer to m1 and m3, since they are bigger (have more mass) than m2.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 质心是系统中所有点的重量平均值，其中权重是不同的质量。从图中我们可以看出，质心更靠近 m1 和 m3，因为它们更大（质量更大）于 m2。
- en: Kinematics
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 运动学
- en: The term kinematics was used for the first time around 1840, as the translation
    of the French term *cinématique*, which was used by *André-Marie Ampère* (the
    famous French physicist and one of the founders of classical electromagnetism
    — so famous that the electric current unit in the International System of Units,
    the ampere, was named after him). However, the origin of the term derives from
    the Greek word *kinesis*, which means movement or motion.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“运动学”首次在1840年左右被使用，作为法语术语*cinématique*的翻译，该术语由*安德烈-玛丽·安培*（著名的法国物理学家，经典电磁学的创始人之一——如此著名，以至于国际单位制中的电流单位安培是以他的名字命名的）。然而，这个术语的起源来自希腊语单词*kinesis*，意为运动或运动。
- en: 'To have a better understanding of what kinematics is in physics, let''s refer
    to Wikipedia:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解物理学中的运动学是什么，让我们参考维基百科：
- en: '*"Kinematics is the branch of classical mechanics which describes the motion
    of points (alternatively particles), bodies (objects), and systems of bodies without
    consideration of the masses of those objects nor the forces that may have caused
    the motion. Kinematics as a field of study is often referred to as the geometry
    of motion."*'
  id: totrans-70
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"运动学是经典力学的一个分支，它描述了点（或粒子）、物体（对象）和物体系统的运动，而不考虑这些物体的质量或可能引起运动的力。作为研究领域的运动学通常被称为运动几何。"*'
- en: Kinematics takes into consideration just the motion of an object and not the
    causes of the motion. This gives us some advantages when it comes to game development.
    First of all, it is cheaper from a computational point of view to take into consideration
    just the kinematics of an object. Then, we might not want to have a fully realistic
    object in our scene, and so we can just define its kinematic properties. We will
    see this in detail later when we will deal with kinematic bodies in Unity.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 运动学只考虑物体的运动，而不考虑运动的成因。这在游戏开发中带来了一些优势。首先，从计算的角度来看，只考虑物体的运动学要便宜得多。然后，我们可能不想在我们的场景中有一个完全逼真的物体，因此我们可以只定义其运动学属性。我们将在后面详细讨论在Unity中处理运动学物体时看到这一点。
- en: Note
  id: totrans-72
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, in our world, a pure kinematic body doesn't exist; all of them are
    dynamic. Yet, studying just the kinematics of an object gives us insights into
    its motion.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在我们的世界中，一个纯粹的动力学物体是不存在的；它们都是动态的。然而，仅仅研究一个物体的运动学，就能让我们对其运动有所了解。
- en: Dynamics
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 动力学
- en: The term dynamic was used in the 19^(th) century in the meaning of pertaining
    to the force producing motion, as opposite to static. Once again, it takes its
    origin from the French term *dynamique*, although it was introduced by the famous
    German mathematician and philosopher, Gottfried Wilhelm Leibnitz. However, the
    origin of this term is again from the Greek word *dynamikos*, which means powerful,
    and also from *dynamis* (power) and *dynasthai* (to be able to, to have power,
    and to be strong enough).
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 术语“动态”在19世纪被用来表示与产生运动的力量相关，与静态相对。再次强调，它起源于法语术语*dynamique*，尽管它是由著名的德国数学家和哲学家戈特弗里德·威廉·莱布尼茨引入的。然而，这个术语的起源再次来自希腊语单词*dynamikos*，意为强大的，以及来自*dynamis*（力量）和*dynasthai*（能够，拥有力量，足够强大）。
- en: 'If not already explicitly suggested, every time we deal with something dynamic
    in physics, we are dealing with forces (which have a certain power to move objects).
    From Wikipedia we can read:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有明确指出，每次我们处理物理学中的动态事物时，我们都在处理力（它们具有移动物体的某种能力）。从维基百科中我们可以读到：
- en: '*"Dynamics is a branch of applied mathematics (specifically classical mechanics)
    concerned with the study of forces and torques and their effect on motion, as
    opposed to kinematics, which studies the motion of objects without reference to
    its causes. Isaac Newton defined the fundamental physical laws which govern dynamics
    in physics, especially his second law of motion."*'
  id: totrans-77
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"动力学是应用数学的一个分支（特别是经典力学），它研究力和扭矩及其对运动的影响，与运动学相对，运动学研究物体运动而不考虑其成因。艾萨克·牛顿定义了支配物理中动力学的根本物理定律，特别是他的运动第二定律。"*'
- en: Therefore, dynamics is built on top of kinematics and gives a better description/prediction
    of how the body will move. In fact, by taking forces into consideration, mass,
    gravity, drag, and many other things become really important and relevant.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，动力学建立在运动学之上，并给出了对物体如何运动的更好描述/预测。实际上，通过考虑力、质量、重力、阻力等许多其他因素，它们变得非常重要和相关。
- en: Force and torque
  id: totrans-79
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 力和扭矩
- en: '**"Forces are those things that allow motion; they are responsible for creating
    a motion*."*'
  id: totrans-80
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**"力是那些允许运动的事物；它们负责产生运动*。"*'
- en: 'Every force applies an acceleration to a body, which is calculated with Newton''s
    second law. It is so simple and elegant that it''s easy to understand. We can
    see this law as follows:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 每个力都会对物体施加一个加速度，这是用牛顿第二定律计算的。它如此简单而优雅，以至于很容易理解。我们可以这样看待这条定律：
- en: '![Force and torque](img/image00516.jpeg)'
  id: totrans-82
  prefs: []
  type: TYPE_IMG
  zh: '![力和扭矩](img/image00516.jpeg)'
- en: Where *F* represents the force, which is a vector (so the arrow above the formula),
    *m* is the mass, and *a* is the acceleration, which is another vector (so the
    arrow above its symbol in the formula).
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *F* 代表力，它是一个矢量（因此公式上方的箭头），*m* 是质量，*a* 是加速度，它也是一个矢量（因此公式中其符号上方的箭头）。
- en: This means that if you apply a force to an object with mass *m*, you know that
    the acceleration is *F/m*. So, just divide the force by the mass of an object
    and you can calculate how much it will be accelerated. Please note that if we
    have two objects on which we apply the same force but they have two different
    masses, the one with the higher mass will have a lower acceleration, because the
    force is divided by a greater number.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你对一个质量为 *m* 的物体施加力，你知道加速度是 *F/m*。所以，只需将力除以物体的质量，你就可以计算出它将加速多少。请注意，如果我们对两个物体施加相同的力，但它们的质量不同，质量较大的物体将具有较低的加速度，因为力被除以一个更大的数字。
- en: The concept of force is important because it is the cause of motion, and many
    Physics engines (including the one of Unity) allow you to specify forces.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 力的概念很重要，因为它是运动的原因，许多物理引擎（包括Unity的引擎）允许你指定力。
- en: Another important concept is torque, also called moment of force or just moment,
    which in some way expresses a force that makes an object rotate along an axis
    instead of moving it. If you think of force like a pull or push, you can imagine
    torque as a twist.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的概念是扭矩，也称为力矩或简称矩，它在某种程度上表示一种使物体沿轴旋转而不是移动的力。如果你把力想象成拉或推，你可以把扭矩想象成扭转。
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'To those of you who know a bit more about the cross-product of vectors, torque
    is defined as the cross-product between the force vector and the distance vector
    from the application point of the force. As a result, it tends to produce rotational
    motion. Therefore, the formula is:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 对于那些对向量叉积有所了解的人来说，扭矩被定义为力向量和力作用点的距离向量之间的叉积。因此，它倾向于产生旋转运动。因此，公式是：
- en: '![Force and torque](img/image00517.jpeg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![力和扭矩](img/image00517.jpeg)'
- en: Where *τ* (read tau) is the torque, *F* is the force vector, and *r* is the
    distance vector, also called offset.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 其中 *τ*（读作tau）是扭矩，*F* 是力向量，*r* 是距离向量，也称为偏移量。
- en: In the the International System of Units, torque is measured in *N·m* (Newton
    meter).
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 在国际单位制中，扭矩以 *N·m*（牛顿米）为单位测量。
- en: The formula of torque is a bit more complicated since it involves the cross-product,
    and one who has just started to deal with physics in video games and uses a graphics
    engine like Unity doesn't need to know/understand the formula straightaway. However,
    it is important to understand that this quantity deals with rotations, and applying
    a torque on a rigid body means that it will rotate along an axis depending on
    where the torque is applied. Just remember that torque is not a force, although
    it might seem so due to the way we will deal with it within Unity.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 扭矩的公式稍微复杂一些，因为它涉及到叉积，对于那些刚开始在视频游戏中处理物理并使用Unity这样的图形引擎的人来说，不需要立即了解/理解这个公式。然而，重要的是要理解这个量与旋转有关，对刚体施加扭矩意味着它将根据扭矩施加的位置沿轴旋转。只需记住，扭矩不是力，尽管由于我们在Unity中处理它的方式，它可能看起来像力。
- en: Collisions
  id: totrans-93
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞
- en: 'In classical mechanics, there are different kinds of collisions between rigid
    bodies that may happen. They are divided into two categories:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典力学中，刚体之间可能发生不同类型的碰撞。它们被分为两类：
- en: Elastic collisions, in which all the kinetic energy is conserved.
  id: totrans-95
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 弹性碰撞，其中所有动能都得到保存。
- en: Inelastic collisions, in which part of the kinetic energy is transformed into
    another form of energy.
  id: totrans-96
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 非弹性碰撞，其中部分动能转化为其他形式的能量。
- en: 'To go through this chapter, it''s not important to understand them well, but
    it is important to understand that the type of collision may change the behaviour
    of what happens after the collision. Imagine two balls: one rolling towards the
    second, which is not moving. At a certain point, the first one will collide with
    the second. Depending on which kind of collision happens, the result may differ.
    In one scenario, both the balls will roll in the same direction and they will
    be as if they were attached. In another scenario, the first one stops and the
    second one starts to roll. In a third scenario they roll at different velocities
    and directions after the collision.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过这一章，并不需要很好地理解它们，但重要的是要理解碰撞的类型可能会改变碰撞后的行为。想象两个球：一个向第二个球滚动，而第二个球是静止的。在某个时刻，第一个球会与第二个球相撞。根据发生的是哪种碰撞，结果可能会有所不同。在一个场景中，两个球会向同一方向滚动，它们就像被连接在一起。在另一个场景中，第一个球停止，第二个球开始滚动。在第三个场景中，它们在碰撞后以不同的速度和方向滚动。
- en: '![Collisions](img/image00518.jpeg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞](img/image00518.jpeg)'
- en: The three possible after-collision scenarios
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 三种可能的碰撞后场景
- en: If you want to learn more, a web page that explains the basic concepts of different
    collisions in a quite simple way is [http://hyperphysics.phy-astr.gsu.edu/hbase/elacol.html](http://hyperphysics.phy-astr.gsu.edu/hbase/elacol.html).
    However, it is intended for those who already have a clear knowledge of the basic
    concepts and formulae of physics.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多，有一个网页以相当简单的方式解释了不同碰撞的基本概念，[http://hyperphysics.phy-astr.gsu.edu/hbase/elacol.html](http://hyperphysics.phy-astr.gsu.edu/hbase/elacol.html)。然而，它是为那些已经清楚了解物理学的基本概念和公式的读者准备的。
- en: Note
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: The website itself, [http://hyperphysics.phy-astr.gsu.edu](http://hyperphysics.phy-astr.gsu.edu),
    is a good source for quick references to the main concepts of physics. However,
    a minimum of prerequisites are needed to fully understand what's on it. The best
    way to start is always with a physics book, which may be boring, but mastering
    those concepts is a great advantage.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 本身，[http://hyperphysics.phy-astr.gsu.edu](http://hyperphysics.phy-astr.gsu.edu)
    网站是一个快速参考物理学主要概念的良好来源。然而，要完全理解其内容，需要一定的先决条件。最好的开始方式始终是阅读一本物理书，这可能很无聊，但掌握这些概念是一个巨大的优势。
- en: Rigid body
  id: totrans-103
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚体
- en: A rigid body, as the name suggests, is a body that translates and rotates all
    together. So for instance, a Christmas ball, a television, or a flying disk are
    rigid bodies, because all their parts move together. A laptop is not, because
    its lid can rotate, as well as a door if you consider the frame too as a part
    of the whole. But, these kinds of objects can be described with two different
    rigid bodies, such as the door-frame and the door itself, which may constrain
    each other (in this case with a Hinge). Water, air, toothpaste, or a dress are
    not considered rigid bodies, because all their parts don't move together.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 正如其名所示，刚体是一个整体平移和旋转的物体。例如，圣诞球、电视或飞盘都是刚体，因为它们的各个部分一起移动。笔记本电脑不是，因为其盖子可以旋转，如果你把框架也视为整体的一部分，门也是如此。但是，这类物体可以用两个不同的刚体来描述，例如门框和门本身，它们可能相互约束（在这种情况下是铰链）。水、空气、牙膏或连衣裙不被视为刚体，因为它们的各个部分不会一起移动。
- en: Most of the objects in your game will be rigidbodies (I'm writing it attached
    because this is the way Unity will refer to them), or they can be approximated
    to rigidbodies, so knowing them well is key to learning physics in Unity. In fact,
    most of the 2D Physics engine of unity is focused on rigid bodies (as we will
    see soon), and therefore this chapter is about them.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 你游戏中的大多数物体将是刚体（我这样写是因为这是Unity将引用它们的方式），或者它们可以被近似为刚体，因此了解它们对于学习Unity中的物理至关重要。实际上，Unity的2D物理引擎的大部分内容都集中在刚体上（我们很快就会看到），因此本章就是关于它们的。
- en: Simulating clothes, liquids, and other physical entities that are not rigidbodies
    is generally harder, although possible. But often they are used in 3D games, and
    we won't deal these aspects in this chapter.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 模拟衣服、液体和其他非刚体物理实体通常更困难，尽管是可能的。但它们通常用于3D游戏，我们不会在本章中处理这些方面。
- en: Note
  id: totrans-107
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: 'For the most curious of you, here is a more precise definition: A **rigid body**
    is the idealization of a solid body, where deformation is neglected. Therefore,
    the distance between any two points within the rigid body remains constant over
    time, independently of the forces that will apply on the rigid body.'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 对于最好奇的你们，这里有一个更精确的定义：**刚体**是对固体物体的理想化，其中忽略了变形。因此，刚体内部任意两点之间的距离在时间上保持恒定，独立于将作用于刚体的力。
- en: Of course, in our world such objects don't exist. In fact they are idealizations,
    but they approximate the behaviour of solid objects pretty well (unless the speed
    of an object is near the speed of light).
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在我们的世界中，这样的物体是不存在的。实际上，它们是理想化模型，但它们很好地近似了固体物体的行为（除非物体的速度接近光速）。
- en: Friction – linear and angular drag
  id: totrans-110
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摩擦——线性阻力和角阻力
- en: If a kid were to ask me, "what is friction?" I would reply, "friction is the
    thing without which all things wouldn't stop moving". Even if this is not a formal
    definition, it helps to understand what friction is. It comes into play when you
    consider the dynamics of an object, because friction generates a force that opposes
    to the motion of the physical body. There are many types of frictions and they
    depend on different factors. For instance, air drag depends on the velocity of
    an object, whereas dry friction depends on the normal force (which depends on
    the surface, position of an object, its weight, and therefore also its mass).
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个孩子问我，“什么是摩擦？”我会回答，“摩擦是那种没有它所有东西都不会停止运动的东西”。即使这不是一个正式的定义，但它有助于理解摩擦是什么。当你考虑物体的动力学时，它就会发挥作用，因为摩擦会产生一个与物理体运动相反的力。有许多种摩擦，它们取决于不同的因素。例如，空气阻力取决于物体的速度，而干摩擦取决于法向力（这取决于表面、物体的位置、其重量，因此也与其质量有关）。
- en: In games, except for specific needs, you don't need all these kinds of frictions
    and drags. For instance, in Unity you can control just the linear and the angular
    drag. The first one opposes the motion of an object along a trajectory (or better,
    the trajectory of the center of mass of the object; otherwise it would be too
    complicated to do in real time) and the angular to the rotation of an object.
    So, in Unity, an object that has both nonzero values for linear and angular drag
    will eventually stop moving and rotating (in the absence of other forces).
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏中，除非有特定需求，否则你不需要所有这些类型的摩擦和阻力。例如，在Unity中，你可以控制线性阻力和角阻力。第一个与物体沿轨迹（或者更好，物体的质心轨迹；否则在实时中做会很复杂）的运动相反，而角阻力与物体的旋转相反。因此，在Unity中，一个具有非零线性阻力和角阻力的物体最终会停止运动和旋转（在没有其他力的作用下）。
- en: The Unity Physics engine
  id: totrans-113
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Unity物理引擎
- en: 'Unity has a Physics engine integrated into it, which is able to handle both
    kinematic and dynamic types of rigid bodies as well as other physical entities
    such as clothes. It is divided into two parts: 2D Physics and 3D Physics. It''s
    important to understand that although they can coexist together in the same scene,
    they are two separate entities; they cannot communicate between themselves. Physical
    objects under 2D Physics will not interact with physical objects under 3D Physics.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: Unity集成了物理引擎，能够处理刚体动力学和动力学类型的刚体以及其他物理实体，如衣物。它分为两部分：2D物理和3D物理。重要的是要理解，尽管它们可以在同一场景中共存，但它们是两个独立的实体；它们之间不能相互通信。2D物理下的物理对象不会与3D物理下的物理对象相互作用。
- en: In this section, we will explore most of the 2D Physics engine of Unity. Although
    we will not use all the components presented here, it's important to master them
    all to become a better Unity developer.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将探讨Unity中大部分的2D物理引擎。虽然我们不会使用这里展示的所有组件，但掌握它们对于成为一名更好的Unity开发者来说非常重要。
- en: Understanding Physics in Unity
  id: totrans-116
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Unity中的物理
- en: In Chapter 2, *Cooking Cupcake Towers, *we learnt about script ordering and
    how it is executed. The first question we may wonder is when does the Physics
    engine occur when a frame is rendered? The answer is not straightforward, because
    the Physics engine runs multiple times during a frame render. In any case, except
    particular cases (such as the application has paused or particular game objects
    are enabled/disabled in that frame), the Physics engine runs after the initialization
    (so all the `Awake()`, `Start()`, and `OnEnable()` functions) and before to gather
    inputs from the player and update the game logic.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二章“制作纸杯蛋糕塔”中，我们学习了脚本排序及其执行方式。我们可能会问的第一个问题是，当渲染帧时物理引擎何时发生？答案是并不直接，因为物理引擎在帧渲染期间会运行多次。无论如何，除了特定情况（例如应用已暂停或在该帧中某些游戏对象被启用/禁用）之外，物理引擎在初始化（因此所有`Awake()`、`Start()`和`OnEnable()`函数）之后运行，并在从玩家那里收集输入和更新游戏逻辑之前。
- en: As a result, when we do a physics calculation (we will see these later in the
    chapter), we need to use the `FixedUpdate()` function, which is called more than
    once per frame, and all the times just before the Physics engine performs its
    calculation. As such, if we need to retrieve the time, we cannot use `Time.deltaTime`;
    instead we need to use `Time.fixedDeltaTime`.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当我们进行物理计算（我们将在本章后面看到这些）时，我们需要使用`FixedUpdate()`函数，该函数在每个帧中调用多次，并且所有调用都在物理引擎执行计算之前。因此，如果我们需要获取时间，我们不能使用`Time.deltaTime`；相反，我们需要使用`Time.fixedDeltaTime`。
- en: Another question we may wonder is when it is appropriate to use the Physics
    engine of Unity. In theory, you don't need to use it, because you can program
    from scratch all the collisions and/or physic behaviours. In practice, it solves
    many common problems with minimum coding and it is indeed useful. These problems
    are not necessarily physics problems. In fact, some of them include certain game
    mechanics that may enhance the quality of your game when using a physics approach
    (such as the movement of the character). Others include gathering information
    from the environment for scripting other behaviours (such as a script that needs
    to know how many targets there are within a zone).
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可能还会问的一个问题是何时应该使用Unity的物理引擎。从理论上讲，您不需要使用它，因为您可以从头开始编写所有碰撞和/或物理行为。在实践中，它以最少的编码解决了许多常见问题，确实很有用。这些问题不一定是物理问题。实际上，其中一些包括某些游戏机制，当使用物理方法时可能会提高您游戏的质量（例如角色的移动）。其他包括从环境中收集信息以编写其他行为（例如需要知道区域内有多少目标的脚本）。
- en: Physics settings in Unity
  id: totrans-120
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Unity中的物理设置
- en: First of all, the Physics engine of Unity has some general settings, which should
    be taken into account. They define global physical properties of your game, such
    as the value of gravity, what will collide with what, and how accurate the Physics
    simulation should be.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，Unity的物理引擎有一些通用设置，应该予以考虑。它们定义了您游戏的全局物理属性，例如重力值、什么会与什么相撞，以及物理模拟应该有多精确。
- en: 'You can have access to the Physics settings in Unity by navigating through
    **Edit | Project Settings | Physics 2D** as shown in the following screenshot:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过在Unity中导航到**编辑 | 项目设置 | 物理设置 2D**来访问物理设置，如下面的截图所示：
- en: '![Physics settings in Unity](img/image00519.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![Unity中的物理设置](img/image00519.jpeg)'
- en: Note
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Similarly, you can have access to the 3D Physics setting by navigating through
    **Edit | Project Settings | Physics**.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，您可以通过在Unity中导航到**编辑 | 项目设置 | 物理**来访问3D物理设置。
- en: 'The following screen will appear in the **Inspector** view (the most important
    parameters are highlighted, which we will see in detail in this section):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 以下屏幕将出现在**检查器**视图中（最重要的参数被突出显示，我们将在本节中详细说明）：
- en: '![Physics settings in Unity](img/image00520.jpeg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![Unity中的物理设置](img/image00520.jpeg)'
- en: As you can see, there are many options you can tweak. Most of the time, especially
    for simple games (like the one we are building), the default settings will be
    more than fine. But Unity offers you the chance to adapt them to your game.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，有许多可调整的选项。大多数情况下，特别是对于简单的游戏（如我们正在构建的游戏），默认设置将足够好。但Unity为您提供机会根据您的游戏调整它们。
- en: Most of them deal with how accurate the Unity Physics engine is. Therefore,
    there is a trade-off between accuracy and efficiency, since more accurate means
    more expensive from a computational point of view.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 其中大部分涉及Unity物理引擎的精确度。因此，在精确度和效率之间有一个权衡，因为更精确意味着从计算角度来看成本更高。
- en: 'Let''s go through the main ones in detail (if you are interested in learning
    also about the others, see the optional, *Other things about Physics* section
    later in the chapter):'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细说明主要的内容（如果您对其他内容也感兴趣，请参阅本章后面的可选部分“关于物理的其他事项”）：
- en: '**Gravity**: The vector that defines the gravity acceleration. By default,
    it is a negative value only along the *y-*axis. In particular, the absolute value
    of 9.81 corresponds to the one on the Earth, if we let the Unity units be meters.'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重力**：定义重力加速度的向量。默认情况下，它仅在 *y* 轴上具有负值。特别是，9.81的绝对值对应于地球上的重力，如果我们让Unity的单位是米。'
- en: '**Default Material**: The physical material used by all the colliders and rigidbodies
    that don''t have one set (we will see more about physical materials later on).'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**默认材质**：所有未设置物理材质的碰撞体和刚体所使用的物理材质（我们将在后面了解更多关于物理材质的内容）。'
- en: '**Time To Sleep**: The time, expressed in seconds, that needs to pass before
    a Rigidbody 2D goes to sleep, which means that it is not updated anymore by the
    Physics engine (we will see more about rigidbodies and their sleeping later on).'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**睡眠时间**：Rigidbody 2D进入睡眠状态之前需要经过的时间，这意味着它不再由物理引擎更新（我们将在后面了解更多关于刚体及其睡眠的内容）。'
- en: '**Linear Sleep Tolerance**: This is the linear speed below which the rigidbody
    after **Time to Sleep** goes to sleep. Imagine you have many objects in your game
    that drag is slowing down, and now they are so slow that the player can barely
    perceive their motion. As such, it''s a waste of computational resources to keep
    them updated in the Physics engine. Therefore, this variable puts a limit to the
    lowest velocity an object can have before it goes to sleep (no more updates from
    the Physics engine). The lower this value, the more accurate the simulation will
    be, but it will also be more expensive if many objects are moving at velocities
    above that one.'
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性睡眠容忍度**：这是在**睡眠时间**后刚体进入睡眠状态的线性速度。想象一下，你的游戏中有很多对象正在减速，现在它们的速度非常慢，以至于玩家几乎无法感知它们的运动。因此，在物理引擎中持续更新它们是浪费计算资源。因此，这个变量限制了对象在进入睡眠状态（不再从物理引擎接收更新）之前可以有的最低速度。这个值越低，模拟将越精确，但如果有很多对象以高于这个速度移动，成本也会更高。'
- en: '**Angular Sleep Tolerance**: The angular speed below which the rigidbody after
    **Time to Sleep** goes to sleep. Imagine the same situation as before, but instead
    the body is rotating really slowly. The same reasoning applies: the lower the
    value, the more accurate the simulation, but usually it is more expensive.'
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角速度睡眠容忍度**：在**睡眠时间**后，刚体进入睡眠状态的角速度。想象一下之前相同的情况，但这次身体旋转得非常慢。同样的推理适用：值越低，模拟越精确，但通常成本也更高。'
- en: '**Layer Collision Matrix**: This determines which kinds of objects collide
    with others. By default, everything is checked, but you may want to make two particular
    kinds of objects not collide among them. Objects are discriminated based on the
    physical layer they are in. If you remember, we talked about layers and tags in
    Chapter 1, *A Flat World in Unity*. So, through the layer menu, you can create
    new layers, and in the **Inspector**, you can assign a layer to a particular game
    object. To make things easier, the **Layer Collision Matrix** is presented in
    this screenshot:'
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**层碰撞矩阵**：这决定了哪些类型的对象会相互碰撞。默认情况下，所有选项都被选中，但你可能希望让两种特定的对象之间不发生碰撞。对象是根据它们所在的物理层来区分的。如果你还记得，我们在第一章“Unity中的二维世界”中讨论了层和标签。因此，通过层菜单，你可以创建新的层，在**检查器**中，你可以将层分配给特定的游戏对象。为了使事情更简单，**层碰撞矩阵**在下面的截图中有展示：'
- en: '![Physics settings in Unity](img/image00521.jpeg)'
  id: totrans-137
  prefs: []
  type: TYPE_IMG
  zh: '![Unity中的物理设置](img/image00521.jpeg)'
- en: For our game, we can leave all the default values since they are more than fine
    for what we need.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的游戏，我们可以保留所有默认值，因为它们对我们所需的功能来说已经足够好了。
- en: Physics components
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理组件
- en: The Physics engine of Unity works by components. Some describe properties of
    the object itself, others with respect to each other, or some even within a certain
    region of the game world.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的物理引擎通过组件工作。一些描述对象本身的属性，一些描述相互之间的关系，还有一些甚至在游戏世界的某个区域内。
- en: 'They can be divided as follows:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 它们可以按以下方式划分：
- en: 'Rigidbodies: Which define a rigidbody within the Physics engine'
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 刚体：在物理引擎中定义刚体的组件
- en: 'Colliders: Which define a physical shape for the rigidbodies'
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 碰撞体：为刚体定义物理形状
- en: 'Joints: Which impose one or more constraints on the rigidbodies'
  id: totrans-144
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 关节：对刚体施加一个或多个约束
- en: Effectors: Which change the physical property in some region of the game world,
    influencing all the rigidbodies within that region
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 效应器：在游戏世界的某个区域内改变物理属性，影响该区域内所有的刚体
- en: '![Physics components](img/image00522.jpeg)'
  id: totrans-146
  prefs: []
  type: TYPE_IMG
  zh: '![物理组件](img/image00522.jpeg)'
- en: A summary diagram of the different components of the 2D Physics engine of Unity
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 2D物理引擎不同组件的总结图
- en: Now, let's see them in more detail.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更详细地看看它们。
- en: Rigidbodies
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 刚体
- en: Rigidbodies are, along with Colliders, the core of the Physics engine beneath
    Unity. When they are attached to a game object, they place it under the control
    of the Physics engine, which will take care to properly move its Transform. In
    fact, they should be moved with other functions, and scripts shouldn't touch the
    Transform. We will see this in detail later.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 刚体，与碰撞体一起，是Unity物理引擎的核心。当它们附加到游戏对象上时，它们将游戏对象置于物理引擎的控制之下，物理引擎将负责正确地移动其变换。实际上，它们应该通过其他函数来移动，脚本不应该直接操作变换。我们将在稍后详细讨论这一点。
- en: The exact name of the component is **Rigidbody 2D** (whereas **Rigidbody** is
    for the 3D Physics engine, but for brevity many times we will use the term rigidbody
    to specify a **Rigidbody 2D** component).
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 组件的确切名称是**Rigidbody 2D**（而**Rigidbody**用于3D物理引擎，但为了简洁，我们经常使用术语刚体来指定**Rigidbody
    2D**组件）。
- en: Note
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: From Unity 5.4, and then again in Unity 5.5, the **Rigidbody 2D** component
    has slightly changed. In fact, many improvements have been made to the Physics
    engine of Unity.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 从Unity 5.4开始，然后在Unity 5.5中，**Rigidbody 2D**组件略有变化。实际上，Unity的物理引擎已经进行了许多改进。
- en: 'Once the component is added to a game object, it looks like this:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将组件添加到游戏对象中，它看起来就像这样：
- en: '![Rigidbodies](img/image00523.jpeg)'
  id: totrans-155
  prefs: []
  type: TYPE_IMG
  zh: '![刚体](img/image00523.jpeg)'
- en: How a Rigidbody 2D works
  id: totrans-156
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Rigidbody 2D的工作原理
- en: Every time we wanted to position an object (or its children) or move it, we
    changed its Transform, which defines where it is in the space as well as how it
    is rotated or scaled. However, the Physics engine will simulate how the object
    will interact in a world where physics is simulated. So, if the object has a collision
    with another one, it will change direction or speed. This means that the Physics
    engine has to change in some way the Transform of the object (that's why we shouldn't
    touch it with scripts for physical objects; we will see later how to deal with
    them by scripting). This way is the Rigidbody component, which is a sort of hub
    between the Physics engine and the properties of the object, including the Transform.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 每次我们想要定位一个对象（或其子对象）或移动它时，我们都会改变其变换，这定义了它在空间中的位置以及它是如何旋转或缩放的。然而，物理引擎将模拟对象在模拟物理的世界中的交互。因此，如果对象与另一个对象发生碰撞，它将改变方向或速度。这意味着物理引擎必须以某种方式改变对象的变换（这就是为什么我们不应该用脚本触摸物理对象；我们稍后会看到如何通过脚本处理它们）。这种方式是刚体组件，它是一种在物理引擎和对象的属性（包括变换）之间的枢纽。
- en: Therefore, after the Physics engine has made its calculation, it communicates
    with the rigidbody, which needs to be in its next position, and the Rigidbody
    component provides to change the Transform to match that new position.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在物理引擎完成计算后，它会与刚体通信，刚体需要处于其下一个位置，而刚体组件提供改变变换以匹配新位置。
- en: The same applies to colliders (we will see them in detail soon). Each collider
    attached to the same object of the rigidbody (or to some of its children) will
    be linked to the rigidbody, and we shouldn't modify the collider or move it but
    instead move the whole rigidbody. These colliders, which are linked to the rigidbody,
    allow the rigidbody to actually collide with colliders of another rigidbody and
    give them a shape in the physics world.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 同样的规则适用于碰撞体（我们很快会详细讨论）。每个连接到刚体相同对象（或其子对象之一）的碰撞体都将与刚体链接，我们不应该修改碰撞体或移动它，而应该移动整个刚体。这些与刚体链接的碰撞体实际上允许刚体与另一个刚体的碰撞体发生碰撞，并在物理世界中赋予它们形状。
- en: Body types
  id: totrans-160
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 身体类型
- en: 'The most important variable in a **Rigidbody 2D** is the **Body Type**, which
    is highlighted in the following screenshot:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Rigidbody 2D**中最重要的变量是**身体类型**，以下屏幕截图中已突出显示：
- en: '![Body types](img/image00524.jpeg)'
  id: totrans-162
  prefs: []
  type: TYPE_IMG
  zh: '![身体类型](img/image00524.jpeg)'
- en: Note
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'If you are using a previous version of Unity (older than 5.5), this variable
    won''t be available. However, you can still get the kinematic mode by checking
    the **Is Kinematic** parameter, which is available in older versions (from 5.4
    and below). You can see this highlighted in the following screenshot (Unity 5.4):'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是Unity的早期版本（低于5.5），这个变量将不可用。然而，你仍然可以通过检查**Is Kinematic**参数来获取运动学模式，该参数在旧版本中可用（从5.4及以下版本）。你可以在以下屏幕截图中看到这一点（Unity
    5.4）：
- en: '![Body types](img/image00525.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![身体类型](img/image00525.jpeg)'
- en: 'And here in Unity 5.3:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity 5.3中也是如此：
- en: '![Body types](img/image00526.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![身体类型](img/image00526.jpeg)'
- en: Older versions, such as 5.2 and below, are similar to the 5.3.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 旧版本，如5.2及以下版本，与5.3类似。
- en: In fact, depending on how the **Body Type** is set, it affects the other settings
    available on the component. Moreover, it's important to remember that any **Collider
    2D** attached to a **Rigidbody 2D** inherits the **Rigidbody 2D** component's **Body
    Type**.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，根据**身体类型**的设置，它会影响组件上可用的其他设置。此外，重要的是要记住，任何连接到**Rigidbody 2D**的**Collider
    2D**都会继承**Rigidbody 2D**组件的**身体类型**。
- en: The **Body Type** determines how the object will move, how the colliders will
    interact, and therefore also how computationally expensive that rigidbody will
    be.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '**身体类型**决定了对象将如何移动，碰撞体将如何交互，因此也决定了刚体将有多大的计算成本。'
- en: Changing the **Body Type** of a **Rigidbody 2D** at runtime can be complicated.
    There are a few things that you need to consider; for example, when a **Body Type**
    changes, various mass-related internal properties are recalculated immediately.
    In addition, all existing contacts for the Collider 2D components attached to
    the Rigidbody 2D need to be reevaluated during the GameObject's next `FixedUpdate`.
    As a result, depending on the number of contacts and Collider 2D components that
    are attached to the body, when you change the **Body Type** of the rigidbody,
    it can cause variations in performance.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时更改**Rigidbody 2D**的**Body Type**可能很复杂。你需要考虑一些事情；例如，当**Body Type**发生变化时，与质量相关的各种内部属性会立即重新计算。此外，附加到Rigidbody
    2D的Collider 2D组件的所有现有接触都需要在GameObject的下一个`FixedUpdate`期间重新评估。因此，根据附加到身体的接触和Collider
    2D组件的数量，当你更改刚体的**Body Type**时，可能会引起性能的变化。
- en: Note
  id: totrans-172
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It's worthwhile to mention that sometimes rigidbodies are described as colliding
    with each other. Although this is true when we talk about physics (so when we
    talk of rigid bodies), it is not true in the case of Rigidbody 2D(the component
    of Unity). In fact, in terms of the Physics engine of Unity, only colliders attached
    to rigidbodies will collide. However, saying that two rigidbodies have collided
    is a short way of saying that their colliders have hit each other.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，有时刚体被描述为相互碰撞。虽然当我们谈论物理时（因此当我们谈论刚体时）这是真的，但在Unity的Rigidbody 2D（组件）的情况下并不成立。实际上，在Unity的物理引擎中，只有附加到刚体上的碰撞体才会发生碰撞。然而，说两个刚体发生了碰撞，只是说它们的碰撞体相互碰撞的简短说法。
- en: 'The **Body Type** can be set to be of three types. Let''s see them in detail:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '**Body Type**可以设置为三种类型之一。让我们详细看看：'
- en: '**Dynamic**: This means that the rigidbody will follow all dynamic calculations,
    which means dealing with forces that cause motion. In fact, the rigidbody will
    have a mass and both linear and angular drag. Moreover, the body will be affected
    by gravity as well. In fact, this is the default body type, since it is the most
    used and collides with everything. But exactly for this reason, it is also the
    most computationally expensive body type.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**动态**: 这意味着刚体将遵循所有动态计算，这意味着处理导致运动的力。实际上，刚体将具有质量，以及线性和角动量阻力。此外，身体将受到重力的影响。实际上，这是默认的身体类型，因为它是最常用的，并且与所有东西发生碰撞。但正因为如此，它也是计算成本最高的身体类型。'
- en: '**Kinematic**: This means that the body is still able to move as a physical
    object, but there are no forces for its motion, and therefore it is not affected
    by gravity either. In fact, you need to script its motion with any formula (we
    will see this later), which may or may not be physically realistic (or maybe it
    is in your game world). However, it is still able to collide, which means the
    Physics engine will notify your script that the rigidbody has collided, and then
    it''s up to us what happens next. In the case of a collision with a dynamic body
    type, the kinematic one is considered immovable, which means with an infinite
    mass. In fact, all dynamic properties, such as mass, are not available. From a
    computational point of view, the kinematic body type is faster than the dynamic
    one, since not calculating all the dynamic forces demands less resources from
    the Physics engine.'
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运动学**: 这意味着物体仍然能够作为一个物理对象移动，但没有运动所需的力，因此也不受重力的影响。实际上，你需要用任何公式（我们稍后会看到）来编写它的运动脚本，这可能或可能不是物理上现实的（或者也许是在你的游戏世界中）。然而，它仍然能够发生碰撞，这意味着物理引擎将通知你的脚本刚体已经发生了碰撞，然后接下来发生什么就取决于我们了。在遇到动态类型的物体时，运动学类型的物体被认为是不可移动的，这意味着具有无限的质量。实际上，所有动态属性，如质量，都是不可用的。从计算的角度来看，运动学类型的物体比动态类型的物体更快，因为不需要计算所有动态力，这要求物理引擎的资源更少。'
- en: '**Static**: This means the rigidbody is not supposed to move at all under the
    Physics engine (or under simulation). This is intended for an object with infinite
    mass. Under a simulation, a static Rigidbody 2D is designed to not move. In the
    instance of something colliding with it, a static Rigidbody 2D behaves like an
    immovable object (as if it has infinite mass). It is also the least resource-intensive
    body type to use. A static body only collides with dynamic Rigidbody 2Ds. Having
    two static Rigidbody 2Ds collide is not supported. This is simply because they
    are not designed to move. As a result, there are a limited number of properties
    that are available for this body type.'
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**静态**: 这意味着刚体在物理引擎（或模拟）下不应该移动。这适用于具有无限质量的物体。在模拟下，静态刚体2D被设计为不移动。如果发生碰撞，静态刚体2D的行为就像一个不可移动的物体（好像它具有无限质量）。它也是使用最少的资源密集型身体类型。静态身体只与动态刚体2D发生碰撞。不支持两个静态刚体2D发生碰撞。这仅仅是因为它们不是设计来移动的。因此，对于这种身体类型，可用的属性数量有限。'
- en: 'To better understand the differences between these body types, here is a table
    with the different features available for each one of them (we will see them in
    detail in the next section):'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这些身体类型之间的差异，这里有一个表格，列出了每个身体类型可用的不同功能（我们将在下一节中详细了解它们）：
- en: '![Body types](img/image00527.jpeg)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![身体类型](img/image00527.jpeg)'
- en: Rigidbody properties
  id: totrans-180
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 刚体属性
- en: 'In the previous table, we saw many properties; they may or may not be available
    for some body types. But what do they actually do and what do they determine for
    the rigidbody? Let''s explore these properties in detail:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的表格中，我们看到了许多属性；它们可能对某些身体类型可用，也可能不可用。但它们实际上做什么，以及它们为刚体确定什么？让我们详细探讨这些属性：
- en: '**Material**: A physics material that determines properties of collisions,
    such as friction and bounce (we will see more about physics materials later).
    This material will be applied to all the colliders under the control of the rigidbody
    (we will see more about colliders in the next section). This comes in handy when
    you need to have many colliders with the same physics material.'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材料**: 一种物理材料，用于确定碰撞属性，例如摩擦和弹跳（我们将在后面了解更多关于物理材料的内容）。此材料将应用于受刚体控制的全部碰撞器（我们将在下一节中了解更多关于碰撞器的内容）。当你需要具有相同物理材料的许多碰撞器时，这很有用。'
- en: '**Simulated**: A checkbox that enables the rigidbody to interact with the Physics
    engine. If it is unchecked, then the rigidbody and so all the colliders referring
    to it will be disabled and transparent for the Physics engine as if they don''t
    exist. This is useful to enable and disable many colliders at runtime (see the
    optional *More about physics* section to know more).'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**模拟**: 一个复选框，用于启用刚体与物理引擎的交互。如果未勾选，则刚体以及所有引用它的碰撞器将禁用并透明，对物理引擎来说就像它们不存在一样。这在运行时启用和禁用许多碰撞器时很有用（请参阅可选的“更多关于物理”部分以了解更多信息）。'
- en: '**Use Auto Mass**: A checkbox that, if enabled, allows Unity to calculate the
    mass of the object by itself. These calculations are based on the dimension and
    density of each of the colliders that are referring to that specific rigidbody.'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用自动质量**: 一个复选框，如果启用，允许Unity自行计算物体的质量。这些计算基于每个引用该特定刚体的碰撞器的尺寸和密度。'
- en: '**Mass**: If the previous checkbox is disabled, we can manually specify a mass
    for our rigidbody.'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**质量**: 如果前面的复选框被禁用，我们可以手动为我们的刚体指定一个质量。'
- en: '**Linear Drag**: The value of the linear drag that affects the rigidbody. If
    it is different from zero, the object will eventually stop moving.'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性阻力**: 影响刚体的线性阻力值。如果它不为零，物体最终会停止移动。'
- en: '**Angular Drag**: The value of the angular drag that affects the rigidbody.
    If it is different from zero, the object will eventually stop rotating.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角阻力**: 影响刚体的角阻力值。如果它不为零，物体最终会停止旋转。'
- en: '**Gravity Scale**: This is a multiplier to the gravity value for that specific
    rigidbody. This means that a value of `0.4` will reduce the gravity to 40% of
    its original value. This is useful when in your game you have objects that react
    to gravity in a different way. Imagine a fireball cast by your wizard; you may
    want it to have a rather straight trajectory (even if it is still a parabola,
    unless the trajectory is completely straight and the **Gravity Scale** is set
    to `0`, which means no gravity affects the rigidbody). Whereas you want the grenade
    of your soldier to have a clear parabolic trajectory, since it is affected by
    gravity. Values greater than `1` lead to a stronger gravity than for its original
    value as shown in the following diagram:![Rigidbody properties](img/image00528.jpeg)'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**重力比例**：这是特定刚体的重力值的乘数。这意味着`0.4`的值将重力减少到原始值的40%。这在你的游戏中，当有对象以不同的方式对重力做出反应时很有用。想象一下你的法师发出的火球；你可能希望它有一个相当直的轨迹（即使它仍然是一个抛物线，除非轨迹完全直线且**重力比例**设置为`0`，这意味着没有重力影响刚体）。而你可能希望你的士兵的手榴弹有一个清晰的抛物线轨迹，因为它受到重力的影响。大于`1`的值会导致比原始值更强的重力，如以下图所示：![刚体属性](img/image00528.jpeg)'
- en: On the left in the preceding diagram is a fireball, which is not affected by
    gravity when the gravity scale is set to zero, leading to a straight line trajectory.
    On the right is a grenade, which is affected by gravity (because the gravity scale
    is greater than zero; in this case, it is exactly `1`, which means normal gravity).
    Without other forces, rigidbodies with a linear velocity and affected by gravity
    have a parabolic trajectory.
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的图中，左侧是一个火球，当重力比例设置为零时，它不受重力影响，导致直线轨迹。右侧是一个手榴弹，它受到重力的影响（因为重力比例大于零；在这种情况下，它正好是`1`，这意味着正常重力）。在没有其他力的作用下，具有线性速度并受到重力影响的刚体具有抛物线轨迹。
- en: '**Use Full Kinematic Contacts**: A checkbox available only for kinematic body
    types. If enabled, it allows the kinematic rigidbody to collide with other kinematic
    rigidbodies. By default, it is set to false, which means that the rigidbody will
    only collide with dynamic rigidbodies (with the exception of colliders set as
    triggers).'
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用完整运动学接触**：仅适用于运动学身体类型的复选框。如果启用，它允许运动学刚体与其他运动学刚体发生碰撞。默认情况下，它设置为false，这意味着刚体将仅与动态刚体（除了设置为触发器的碰撞器）发生碰撞。'
- en: '**Collision Detection**: The way Unity detects collisions. It can be either
    **Discrete** or **Continuous**. In the first case, collision detection is calculated
    only on the position of the physical objects, and if they collide (which means
    that if the colliders overlap after the update of the positions of the objects,
    then Unity calculates the collision). On the contrary, continuous collision detection
    is calculated on the trajectory itself and not only on the positions of the objects.
    Imagine you have a really fast bullet, which is heading against a really thin
    wall. Since the game is discrete (the game renders frame by frame), when the bullet
    is near the wall, in the next update, it can be so fast that its new position
    is behind the wall. As such, with discrete collision detection, the bullet has
    crossed the wall without problems, because the Physics engine doesn''t detect
    any collision. With continuous collision detection instead, the Physics engine
    is aware of the trajectory that the bullet has followed and does calculations
    on it. So, even if the the final position of the bullet is behind the wall, the
    collision is detected and it is properly handled by the Physics engine, which
    recalculates the new position of the bullet taking the collision into account
    as shown in the following diagram:![Rigidbody properties](img/image00529.jpeg)'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞检测**：Unity检测碰撞的方式。它可以是**离散**或**连续**的。在前一种情况下，碰撞检测仅基于物理对象的当前位置计算，如果它们发生碰撞（这意味着如果对象位置更新后碰撞器重叠，则Unity计算碰撞）。相反，连续碰撞检测是基于轨迹本身，而不仅仅是物体的位置。想象一下，你有一个非常快的子弹，它正对着一堵非常薄的墙。由于游戏是离散的（游戏逐帧渲染），当子弹靠近墙时，在下一个更新中，它可能移动得太快，以至于它的新位置在墙的后面。因此，使用离散碰撞检测时，子弹可以无问题地穿过墙，因为物理引擎没有检测到任何碰撞。相反，使用连续碰撞检测时，物理引擎知道子弹所跟随的轨迹，并对它进行计算。因此，即使子弹的最终位置在墙后面，碰撞也会被检测到，并且由物理引擎正确处理，如以下图所示：![刚体属性](img/image00529.jpeg)'
- en: On the left in the preceding diagram is the discrete method, in which only the
    different positions between frames are taken into consideration. Therefore, if
    the position of the bullet in the next frame is behind the wall, the discrete
    method won't detect the collision. On the right is the continuous method, in which
    the whole trajectory of the bullet is taken into consideration. Therefore, even
    if in the next frame the bullet is behind the wall, the collision is detected
    and a new position is calculated based on the collision. This second method is
    a bit more computationally expensive.
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在前面的图中，左侧是离散方法，其中只考虑帧之间的不同位置。因此，如果子弹在下一帧的位置在墙后面，离散方法将不会检测到碰撞。右侧是连续方法，其中考虑了子弹的整个轨迹。因此，即使子弹在下一帧的位置在墙后面，也会检测到碰撞，并基于碰撞计算一个新的位置。第二种方法在计算上稍微昂贵一些。
- en: '**Sleeping Mode**: This is the way Unity deals with whether a rigidbody should
    be awake or sleeping at the beginning, or whether it has the possibility to sleep
    at all. The possible choices of this variable, with self-explanatory names, are:
    **Never Sleep**, **Start Awake**, and **Start Asleep**. A rigidbody is sleeping
    when it is not taken completely into consideration by the Physics engine (it differs
    from not being simulated, and now we see why). Imagine how many objects in your
    game could be potently moving but they don''t at the moment. For example, imagine
    a ball pit with thousands of balls, but at the moment none of them are moving.
    In this scenario, it''s useless to call each one of them in the Physics engine
    for void calculations. Another example: imagine a pendulum that is stopping, and
    its oscillation arc is too small to be perceived by the player. Calculating the
    exact position of the pendulum on this arc is a waste of computational resources.
    It''s better to stop the pendulum or the balls (set them into sleeping mode) until
    an event, such as the player diving in the ball pit or pushing the pendulum. So,
    for performance reasons, not all rigidbodies are awake at any moment. However,
    they can be awoken by an event, which is usually automatic in the Physics engine.
    But it can also be controlled by you within a script (we will see more details
    about this in the next section).'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**睡眠模式**：这是Unity处理刚体在开始时应该处于唤醒状态还是睡眠状态，或者是否有睡眠可能性的方式。这个变量的可能选择，具有自解释的名称，包括：**永不睡眠**、**开始唤醒**和**开始睡眠**。当刚体没有被物理引擎完全考虑时，它处于睡眠状态（这与没有被模拟不同，现在我们知道了原因）。想象一下，你的游戏中可能有多少物体正在有力地移动，但此刻它们并没有移动。例如，想象一个有数千个球的水球池，但此刻没有任何一个球在移动。在这种情况下，在物理引擎中对每个球进行空计算是无用的。另一个例子：想象一个停止摆动的摆锤，其摆动弧线太小，玩家无法感知。计算摆锤在这个弧线上的确切位置是浪费计算资源。更好的做法是停止摆锤或球（将它们设置为睡眠模式），直到发生某个事件，例如玩家跳入水球池或推动摆锤。因此，出于性能考虑，并非所有刚体在任何时刻都是唤醒状态。然而，它们可以通过事件被唤醒，这在物理引擎中通常是自动的。但也可以通过脚本由你控制（我们将在下一节中看到更多关于这个的细节）。'
- en: '**Interpolate**: When a rigidbody is moving, maybe under a force, the Physics
    engine performs some calculations on which will be its next position. However,
    the Physics engine is not perfect and cannot replicate our physics. In fact, algorithms
    are subjected to numerical instability, which may result in a jerky motion in
    our case. Therefore, Unity offers you two ways to smooth the motion and make it
    less jerky, plus the option **None**, in which no smoothing is performed. The
    first way, called **Interpolate**, takes into consideration the previous position
    of the rigidbody. On the contrary, the second way, called **Extrapolate**, takes
    into consideration the prevision of the next position of the object. Both methods
    work well, and you can perceive the difference between them and **None**. However,
    the difference between the two could be tricky to understand, especially since
    their behaviour is really similar, and understanding which one is better for your
    game can sometimes be determined just by trial and error (unless you have really
    specific needs).![Rigidbody properties](img/image00530.jpeg)'
  id: totrans-194
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**插值**：当一个刚体在移动时，可能受到力的作用，物理引擎会对其下一个位置进行一些计算。然而，物理引擎并不完美，无法复制我们的物理。事实上，算法会受到数值不稳定性的影响，这可能导致我们案例中的运动出现颠簸。因此，Unity为你提供了两种平滑运动并使其不那么颠簸的方法，以及**无**选项，其中不执行任何平滑。第一种方法，称为**插值**，考虑了刚体的先前位置。相反，第二种方法，称为**外推**，考虑了对象的下一个位置的预测。两种方法都很好，你可以感知它们与**无**之间的区别。然而，两种方法之间的区别可能难以理解，特别是它们的行性行为非常相似，有时理解哪种更适合你的游戏可能只能通过试错（除非你有非常具体的需求）。![刚体属性](img/image00530.jpeg)'
- en: On the left, the trajectory is not interpolated; it leads to a fragmented trajectory.
    On the right, the trajectory is interpolated and its curve is smoothed.
  id: totrans-195
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在左侧，轨迹没有插值；这导致轨迹碎片化。在右侧，轨迹被插值，其曲线被平滑化。
- en: '**Constraints**: These prevent the rigid body from moving or rotating in a
    certain way, if not at all. In the case of 2D, you can freeze the motion along
    *x* or *y* or both axes and rotation along the *z-*axis. All of them are independent
    checkboxes, which can be selected in any combination. Of course, having all of
    them selected means that the rigidbody won''t be able to move. Imagine you are
    developing a puzzle game and your main character game needs to move a box, maybe
    by pushing it. However, we don''t want the box to start to rotate on itself if
    the player doesn''t push the middle point of the box. As such, we can freeze the
    rotation of the box, still allowing the box to move and be pushed by the main
    character.'
  id: totrans-196
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**约束**：这些可以防止刚体以某种方式（如果不是完全）移动或旋转。在2D的情况下，你可以冻结沿*x*或*y*或两个轴的运动，以及沿*z*轴的旋转。所有这些都是独立的复选框，可以以任何组合选择。当然，选择所有这些意味着刚体将无法移动。想象你正在开发一个益智游戏，你的主要角色需要移动一个盒子，可能通过推它。然而，我们不想让盒子在没有推到盒子的中间点时开始自身旋转。因此，我们可以冻结盒子的旋转，同时仍然允许盒子移动并被主要角色推挤。'
- en: '![Rigidbody properties](img/image00531.jpeg)'
  id: totrans-197
  prefs: []
  type: TYPE_IMG
  zh: '![刚体属性](img/image00531.jpeg)'
- en: On the left, there are no constraints, and therefore when the player pushes,
    the object might rotate. On the right, the rotation is frozen, and when the player
    pushes, the object won't rotate. Which behaviour to choose depends on the design
    of your game.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，没有约束，因此当玩家推挤时，物体可能会旋转。在右侧，旋转被冻结，当玩家推挤时，物体不会旋转。选择哪种行为取决于你游戏的设计。
- en: Note
  id: totrans-199
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: '**Info****:** A foldout showing all the other variables of the rigidbody, which
    is very useful in debugging.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: '**信息**：一个展开图，显示了刚体的所有其他变量，这在调试中非常有用。'
- en: Dealing with rigidbodies
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理刚体
- en: Now that we have explored the Rigidbody 2D component in detail, let's see how
    we can deal with it within scripts. As previously explained, scripts are not supposed
    to change the Transform of a rigidbody. So how we can move them? The answer is
    that some special functions exist.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经详细探讨了Rigidbody 2D组件，让我们看看我们如何在脚本中处理它。如前所述，脚本不应该改变刚体的Transform。那么我们如何移动它们呢？答案是存在一些特殊函数。
- en: 'These functions need to be called on the rigidbody; therefore probably you
    may want to have a reference to the Rigidbody 2D, like this fragment of script:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 这些函数需要在刚体上调用；因此，你可能想要有一个Rigidbody 2D的引用，如下面的脚本片段所示：
- en: '[PRE0]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'As a result, you can call the functions in this way:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你可以这样调用函数：
- en: '[PRE1]'
  id: totrans-206
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Where of course, instead of `NameOfTheFunction` there will be one of the functions
    listed next. However, if you remember, the Physics engine might be called more
    than once per frame, and therefore all of these functions should be called within
    `FixedUpdate()`.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这里 `NameOfTheFunction` 将被下面列出的函数之一所替代。然而，如果你记得，物理引擎可能会在每一帧被调用多次，因此所有这些函数都应该在
    `FixedUpdate()` 中调用。
- en: So how can we actually move a rigidbody? For dynamic body types, we can either
    just leave them at the mercy of the external forces such as gravity, collisions,
    and so on, or we can apply a specific force.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，我们实际上如何移动一个刚体呢？对于动态刚体类型，我们可以让它们在外部力（如重力、碰撞等）的 mercy 下自由移动，或者我们可以施加一个特定的力。
- en: 'In order to apply a force to the rigidbody, there are the following useful
    functions:'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 为了向刚体施加力，有以下有用的函数：
- en: '`AddForce(Vector2 force, ForceMode2D mode = ForceMode2D.Force)`: Applies a
    force specified in the `force` parameter. Moreover, enum  `ForceMode2D` is an
    optional parameter that specifies whether the force should act as an impulse or
    not. By default, it is not an impulse.'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddForce(Vector2 force, ForceMode2D mode = ForceMode2D.Force)`: 应用在 `force`
    参数中指定的力。此外，枚举 `ForceMode2D` 是一个可选参数，用于指定力是否应该作为冲量作用。默认情况下，它不是冲量。'
- en: '`AddForceAtPosition(Vector2 force, Vector2 position, ForceMode2D mode = ForceMode2D.Force)`:
    Behaves like the previous function, but you can also specify an application point
    for the force.'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddForceAtPosition(Vector2 force, Vector2 position, ForceMode2D mode = ForceMode2D.Force)`:
    与前面的函数行为类似，但你可以指定力的应用点。'
- en: '`AddRelativeForce(Vector2 relativeForce, ForceMode2D mode = ForceMode2D.Force)`:
    Behaves like the first function, but the force is specified in local coordinates.'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddRelativeForce(Vector2 relativeForce, ForceMode2D mode = ForceMode2D.Force)`:
    与第一个函数行为类似，但力是在局部坐标系中指定的。'
- en: '`AddTorque(float torque, ForceMode2D mode = ForceMode2D.Force)`: This applies
    a torque to the rigidbody; likewise, the first function applies instead a force.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddTorque(float torque, ForceMode2D mode = ForceMode2D.Force)`: 向刚体施加扭矩；同样，第一个函数施加的是力。'
- en: 'For kinematic body types instead, we have two functions to explicitly move
    these kinds of body types and still allow the Physics engine to perform collision
    detection correctly. Inside these functions, we directly pass a position and a
    rotation, which can be calculated with any formula. Therefore they can follow
    any physics law you want (or one that is meaningful in your game):'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于运动学刚体类型，我们有两个函数来明确移动这些类型的刚体，同时仍然允许物理引擎正确执行碰撞检测。在这些函数内部，我们直接传递一个位置和一个旋转，这些可以通过任何公式计算得出。因此，它们可以遵循你想要的任何物理定律（或游戏中有意义的定律）：
- en: '`public void MovePosition(Vector2 position)`: Moves the rigidbody to the specified
    position'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void MovePosition(Vector2 position)`: 将刚体移动到指定的位置'
- en: '`public void MoveRotation(float angle)`: Rotates the rigidbody to the specified
    angle'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`public void MoveRotation(float angle)`: 将刚体旋转到指定的角度'
- en: Note
  id: totrans-217
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'The easiest example is to apply the classical kinematic law for velocity to
    make the kinematic body move in a straight line indefinitely. For the most curious
    of you, the formula is the following:'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 最简单的例子是将经典运动学定律应用于速度，使运动学刚体无限期地沿直线移动。对于最好奇的你们，公式如下：
- en: '![Dealing with rigidbodies](img/image00532.jpeg)'
  id: totrans-219
  prefs: []
  type: TYPE_IMG
  zh: '![处理刚体](img/image00532.jpeg)'
- en: 'The ∆ (read delta) in physics means the final minus the initialwhich can be
    rewritten (by explicitly separating the delta of the space) as:'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 在物理学中，∆（读作 delta）表示最终值减去初始值，可以通过显式分离空间的变化来重写为：
- en: '![Dealing with rigidbodies](img/image00533.jpeg)'
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![处理刚体](img/image00533.jpeg)'
- en: 'We can translate this into Unity with the following fragment of code (instead
    of `Time.deltaTime`, we need to use `Time.deltaFixedTime`):'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以用以下代码片段将此翻译成 Unity（而不是 `Time.deltaTime`，我们需要使用 `Time.deltaFixedTime`）：
- en: '[PRE2]'
  id: totrans-223
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Moreover, we have some or the other function for all kinds of body types:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们为所有类型的刚体都有一些或另一些函数：
- en: '`IsAwake()`: Returns true if the rigidbody is awake.'
  id: totrans-225
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsAwake()`: 如果刚体处于唤醒状态，则返回 true。'
- en: '`IsSleeping()`: Returns true if the rigidbody is sleeping.'
  id: totrans-226
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsSleeping()`: 如果刚体处于休眠状态，则返回 true。'
- en: '`IsTouching(Collider2D collider)`: Returns true if the collider is touching
    the rigidbody (which means any of the colliders attached to the rigidbody)'
  id: totrans-227
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IsTouching(Collider2D collider)`: 如果碰撞体接触刚体（这意味着刚体上附加的任何碰撞体），则返回 true。'
- en: '`OverlapPoint(Vector2 point)`: Returns true if the point is overlapping the
    rigidbody (which means any of the colliders attached to the rigidbody)'
  id: totrans-228
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OverlapPoint(Vector2 point)`: 如果点与刚体重叠（这意味着刚体上附加的任何碰撞体），则返回 true。'
- en: '`Sleep()`: Makes the rigidbody sleep'
  id: totrans-229
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Sleep()`: 使刚体进入休眠状态'
- en: '`WakeUp()`: Disables the sleeping mode of the rigidbody'
  id: totrans-230
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`WakeUp()`: 禁用刚体的睡眠模式'
- en: Note
  id: totrans-231
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For the full list of functions and variables of a Rigidbody 2D component, you
    can consult the official documentation here: [https://docs.unity3d.com/ScriptReference/Rigidbody2D.html](https://docs.unity3d.com/ScriptReference/Rigidbody2D.html).'
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看Rigidbody 2D组件的完整函数和变量列表，您可以在此处查阅官方文档：[https://docs.unity3d.com/ScriptReference/Rigidbody2D.html](https://docs.unity3d.com/ScriptReference/Rigidbody2D.html)。
- en: Colliders
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 碰撞体
- en: Imagine that you have the heroine of your game moving in a complex environment;
    by complex, I mean detailed, for instance, the kitchen of the king's castle. If
    the Physics engine is super realistic, it should take in consideration that the
    hand of the heroine can go over the table, as far as the body stays on its side.
    However, this is impossible (or at least out of reach for the current hardware
    of your players) to run in real time. So colliders provide an approximate shape
    for objects and characters that need to have some kind of physical interaction,
    such as a collision. For instance, characters are often approximated as a capsule-shaped
    collider and objects with a sphere-shaped or box-shaped collider. Of course, if
    a deeper level of detail is required, different colliders can act as a more complex
    one. And ultimately, all the polygons of the 3D model (or perimeter of the 2D
    Sprite) can be part of the collider, having a much better realism but at the cost
    of performance. Therefore, you'll want to be careful to always have the right
    level of detail for each situation.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下，你的游戏中的女主角在一个复杂的环境中移动；这里的复杂是指详细的，例如，国王城堡的厨房。如果物理引擎非常逼真，它应该考虑女主角的手可以越过桌子，只要她的身体保持在侧面。然而，这在实时运行中是不可能的（或者至少对于玩家当前的硬件来说是不可能的）。因此，碰撞体为需要某种物理交互的对象和角色提供了一个近似的形状，例如碰撞。例如，角色通常被近似为胶囊形状的碰撞体，而具有球形或盒形碰撞体的物体。当然，如果需要更详细的级别，不同的碰撞体可以充当更复杂的碰撞体。最终，3D模型的全部多边形（或2D精灵的周界）都可以成为碰撞体的一部分，从而获得更高的真实感，但代价是性能。因此，你想要确保在每种情况下都保持正确的细节级别。
- en: 'In Unity, colliders can be of five types, which are:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，碰撞体可以是五种类型，它们是：
- en: '| **Name** | **Appearance in the **Inspector**** | **Description** |'
  id: totrans-236
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **在**检查器**中的显示** | **描述** |'
- en: '| **Circle Collider 2D** | ![Colliders](img/image00534.jpeg) | The collider''s
    shape is a circle, which is defined by a position and a radius expressed in the
    local coordinate. |'
  id: totrans-237
  prefs: []
  type: TYPE_TB
  zh: '| **二维圆形碰撞体** | ![碰撞体](img/image00534.jpeg) | 碰撞体的形状是一个圆形，由局部坐标系中的一个位置和一个半径定义。|'
- en: '| **Box Collider 2D** | ![Colliders](img/image00535.jpeg) | The collider''s
    shape is a rectangle aligned to the world axis (*x* and *y*), and it is defined
    with a width and a height in the local coordinate. |'
  id: totrans-238
  prefs: []
  type: TYPE_TB
  zh: '| **二维盒子碰撞体** | ![碰撞体](img/image00535.jpeg) | 碰撞体的形状是一个与世界轴（*x* 和 *y*）对齐的矩形，它在局部坐标系中由宽度和高度定义。|'
- en: '| **Polygon Collider 2D** | ![Colliders](img/image00536.jpeg) | The collider''s
    shape is defined by a freeform edge made of line segments. In this way, you can
    adjust it to fit the shape of the Sprite graphic with great precision. Please
    note that this collider''s edge must completely enclose an area (unlike **Edge
    Collider 2D**). |'
  id: totrans-239
  prefs: []
  type: TYPE_TB
  zh: '| **二维多边形碰撞体** | ![碰撞体](img/image00536.jpeg) | 碰撞体的形状由由线段组成的自由形状边缘定义。这样，你可以调整它以非常精确地适应Sprite图形的形状。请注意，此碰撞体的边缘必须完全包围一个区域（与**二维边缘碰撞体**不同）。|'
- en: '| **Edge Collider 2D** | ![Colliders](img/image00537.jpeg) | The collider''s
    shape is defined by a freeform edge made of line segments. In this way, you can
    adjust it to fit the shape of the Sprite graphic with great precision. Unlike
    the **Polygon Collider 2D**, its edge does not necessarily enclose an area. For
    instance, it''s possible to create an *N* shape or just a straight line. |'
  id: totrans-240
  prefs: []
  type: TYPE_TB
  zh: '| **二维边缘碰撞体** | ![碰撞体](img/image00537.jpeg) | 碰撞体的形状由由线段组成的自由形状边缘定义。这样，你可以调整它以非常精确地适应Sprite图形的形状。与**二维多边形碰撞体**不同，其边缘不一定包围一个区域。例如，可以创建一个*N*形状或只是一条直线。|'
- en: '| **Capsule Collider 2D** | ![Colliders](img/image00538.jpeg) | The collider''s
    shape is a capsule without vertexes (so that it is hard it remains stuck between
    vertexes or corners of other colliders). Moreover, it''s a solid collider, so
    if an object is completely inside this collider, it is pushed out and detected
    as colliding. |'
  id: totrans-241
  prefs: []
  type: TYPE_TB
  zh: '| **二维胶囊碰撞体** | ![碰撞体](img/image00538.jpeg) | 碰撞体的形状是一个无顶点的胶囊（因此它很难卡在顶点或其他碰撞体的角落之间）。此外，它是一个实体碰撞体，所以如果一个物体完全在这个碰撞体内部，它会被推出来并被检测为碰撞。|'
- en: All of them share the same core settings, and some additional ones to customize
    the shape of the collider. For instance, for **Circle Collider 2D**, we can decide
    the center and the radius. However, Unity automatically tries to enclose/envelop
    the Sprite or 3D model within the collider, though manual tweaking may be required
    (see further for editing the collider in a visual way).
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 它们都共享相同的核心设置，以及一些额外的设置来定制碰撞体的形状。例如，对于**二维圆形碰撞体**，我们可以决定中心点和半径。然而，Unity会自动尝试将精灵或3D模型包含在碰撞体内部，尽管可能需要手动调整（有关在视觉上编辑碰撞体的方法，请参阅以下内容）。
- en: Note
  id: totrans-243
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Since this book focuses on the 2D world, for brevity we will refer to the colliders
    without the ending 2D, assuming we are always referring to the 2D component and
    not to the 3D one with the same name. For example, **Box Collider 2D** becomes
    **Box Collider**.
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本书专注于2D世界，为了简洁起见，我们将省略碰撞体的2D后缀，假设我们总是指代2D组件，而不是具有相同名称的3D组件。例如，**二维盒形碰撞体**变为**盒形碰撞体**。
- en: 'Let''s explore the core options of each collider:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来探索每个碰撞体的核心选项：
- en: '**Density**: This affects the mass of the rigidbody that it is referring to.
    A value of zero means that the collider will be completely ignored in the calculation
    of the mass of the rigidbody. The higher the value, the more the collider will
    contribute to the mass of the rigidbody.'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密度**：这会影响所引用的刚体的质量。零值意味着碰撞体将在刚体质量计算中完全被忽略。值越高，碰撞体对刚体质量的贡献就越大。'
- en: Note
  id: totrans-247
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you don't see the **Density** option, it's normal. In fact, it will be visible
    only if the option **Auto Mass** is enabled on the rigidbody associated (so attached
    on the same game object of the collider or on some of its parents up in the hierarchy).
    In fact, when the rigidbody component automatically calculates the mass, it takes
    into consideration all the colliders linked to that rigidbody and their densities.
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 如果你没有看到**密度**选项，这是正常的。实际上，只有当关联的刚体（即附着在同一个游戏对象上的刚体或其层次结构中的某些父级）上的**自动质量**选项被启用时，它才会可见。实际上，当刚体组件自动计算质量时，它会考虑所有连接到该刚体的碰撞体及其密度。
- en: '**Material**: A physics material that determines properties of collisions,
    such as friction and bounce (we will see more about physics materials later).'
  id: totrans-249
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**材料**：一个物理材料，它决定了碰撞的性质，例如摩擦和反弹（我们将在后面了解更多关于物理材料的内容）。'
- en: '**Is Trigger**: Check this if you want the collider to behave as a trigger.
    This means that the collider won''t be used to do collisions but rather to trigger
    something when another collider enters within this one (see the next section for
    more details).'
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**是否触发**：如果您希望碰撞体作为触发器行为，请勾选此选项。这意味着碰撞体不会用于执行碰撞，而是当另一个碰撞体进入此碰撞体时触发某些操作（有关更多详细信息，请参阅下一节）。'
- en: '**Used By Effector**: Check this if you want the collider to be used by an
    attached effector (we will see more about effectors later).'
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**由效应器使用**：如果您希望碰撞体被附加的效应器使用，请勾选此选项（我们将在后面了解更多关于效应器的内容）。'
- en: '**Offset**: This is the offset of the collider geometry expressed in local
    coordinates; in other words, how far in terms of *x* and *y* the collider should
    be from the position of the game object on which it is attached.'
  id: totrans-252
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**偏移**：这是以局部坐标表示的碰撞体几何形状的偏移量；换句话说，碰撞体在附着游戏对象的位置上*x*和*y*方向上应该离多远。'
- en: '**Info**: A foldout showing all the other variables of the collider. It is
    very useful in debugging.'
  id: totrans-253
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**信息**：一个展开的窗口，显示碰撞体的所有其他变量。这在调试中非常有用。'
- en: 'Then, there are the specific ones for each collider:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，还有每个碰撞体的特定选项：
- en: '**Radius**: Used only for the circle collider, and it determines the radius
    of the circle.'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**半径**：仅用于圆形碰撞体，它决定了圆的半径。'
- en: '**Size**: This is used only for the box and the capsule collider. In the first
    case, it determines the size of the box, and in the second the size of the box
    that the capsule fills up (and therefore indirectly the size of the capsule) as
    shown in the following diagram:![Colliders](img/image00539.jpeg)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**大小**：这仅用于盒形和胶囊形碰撞体。在前者的情况下，它决定了盒子的大小，在后者的情况下，它决定了胶囊填充的盒子的大小（因此间接决定了胶囊的大小），如下面的图所示：![碰撞体](img/image00539.jpeg)'
- en: '**Points**: This is non-editable information for the polygon or edge colliders
    about their complexity. It describes all the points of the collider and how they
    are connected in paths.'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**点**：这是多边形或边缘碰撞体的不可编辑信息，关于它们的复杂性。它描述了碰撞体的所有点以及它们如何连接成路径。'
- en: '**Direction**: This is used only for capsule colliders and it can be set to
    be either **Vertical** or **Horizontal**. This controls which way round the capsule
    sets; specifically, it defines the positioning of the semi-circular end-caps.'
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**方向**：这仅用于胶囊碰撞器，可以设置为**垂直**或**水平**。这控制胶囊的方向；具体来说，它定义了半圆形端盖的位置。'
- en: 'Furthermore, it is possible to visually edit the colliders by clicking on the
    following icon, available in all the colliders:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以通过点击以下图标来直观地编辑碰撞器，该图标在所有碰撞器中都是可用的：
- en: '![Colliders](img/image00540.jpeg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞器](img/image00540.jpeg)'
- en: As a result, you will able to modify the collider directly into the **Scene**
    view. It is quite intuitive, so I'll let you explore this feature by yourself.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您可以直接在**场景**视图中修改碰撞器。这相当直观，所以我会让您自己探索这个功能。
- en: Tip
  id: totrans-262
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: You can create a vertex for the edge or polygon colliders by clicking on one
    of their edges.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过点击边缘之一为边缘或多边形碰撞器创建顶点。
- en: Dealing with colliders
  id: totrans-264
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 处理碰撞器
- en: Often, in video games, when colliders collide, we want to trigger some actions
    and run specific code. For instance, imagine a bullet that hits the surface of
    the wall, we may want to instantiate a particle effect in the point, and remove
    the bullet. The same applies for a fireball, but with a fire effect. Or imagine
    the player walks through a door and a cut-scene is triggered. In this case, there
    is a volume trigger (a collider with **is Trigger** set to true) so that when
    the player enters, the volume triggers the cut-scene. Another example, is an area
    full of toxic gasses, and the longer the player stays in that area, his health
    is gradually reducing.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在视频游戏中，当碰撞器碰撞时，我们希望触发一些动作并运行特定的代码。例如，想象一颗子弹击中墙壁的表面，我们可能想在那个点实例化一个粒子效果并移除子弹。同样的情况也适用于火球，但会有火效果。或者想象玩家穿过一扇门并触发一个场景。在这种情况下，有一个体积触发器（一个将**is
    Trigger**设置为true的碰撞器），当玩家进入时，体积触发器会触发场景。另一个例子是一个充满有毒气体的区域，玩家在该区域停留的时间越长，他的健康就会逐渐减少。
- en: All of this can be achieved by using some special functions. If you remember,
    in [Chapter 2](part0028.xhtml#aid-QMFO1 "Chapter 2. Baking Cupcake Towers"), *Baking Cupcake
    Tower*, we have seen that every script that derives from monobehaviour could have
    some functions, such as `Start()` and `Update()` that are automatically called
    by Unity. Among these functions there are some that are called by the Physics
    engine of Unity.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都可以通过使用一些特殊函数来实现。如果您还记得，在[第二章](part0028.xhtml#aid-QMFO1 "第二章. 烘焙纸杯蛋糕塔")中，*烘焙纸杯蛋糕塔*，我们看到了从monobehaviour派生的每个脚本都可以有一些函数，例如`Start()`和`Update()`，这些函数会被Unity自动调用。在这些函数中，有一些是由Unity的物理引擎调用的。
- en: 'For trigger volumes, there are the following functions:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 对于触发体积，有以下函数：
- en: '`OnTriggerEnter2D(Collider2D other)`: This is called on both the rigidbody
    and the volume trigger when the former enters in the latter. Information about
    the other collider is passed as a parameter in the `other` variable.'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTriggerEnter2D(Collider2D other)`: 当前者进入后者时，在刚体和体积触发器上都会调用此函数。其他碰撞器的信息作为参数通过`other`变量传递。'
- en: '`OnTriggerStay2D(Collider2D other)`: This is called on every frame on both
    the rigidbody and the volume trigger as long as the former is within the second
    one. Information about the other collider is passed as a parameter in the `other`
    variable.'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTriggerStay2D(Collider2D other)`: 这在刚体和体积触发器上每帧都会被调用，只要前者在后者内部。其他碰撞器的信息作为参数通过`other`变量传递。'
- en: '`OnTriggerExit2D(Collider2D other)`: This is called on both the rigidbody and
    the trigger volume when the former leaves/exits the second one. Information about
    the other collider is passed as a parameter in the `other` variable.'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnTriggerExit2D(Collider2D other)`: 当前者离开/退出后者时，在刚体和触发体积上都会调用此函数。其他碰撞器的信息作为参数通过`other`变量传递。'
- en: For colliders not set to be triggers, there are similar functions. However,
    instead of having just information about the other collider, information about
    the whole collision is available through the class `Collision2D`, which stores
    — other than the colliders — the contact points, relative velocities, and so on.
    More information about this can be found here in the official documentation at: [https://docs.unity3d.com/ScriptReference/Collision2D.html](https://docs.unity3d.com/ScriptReference/Collision2D.html)
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 对于未设置为触发器的碰撞体，有类似的功能。然而，不是只有关于另一个碰撞体的信息，通过`Collision2D`类可以获得关于整个碰撞的信息，该类除了碰撞体之外还存储了接触点、相对速度等信息。更多关于这方面的信息可以在官方文档中找到：[https://docs.unity3d.com/ScriptReference/Collision2D.html](https://docs.unity3d.com/ScriptReference/Collision2D.html)
- en: 'So, the functions for colliders are:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，碰撞体的函数是：
- en: '`OnCollisionEnter2D(Collision2D coll)`: This is called on both the rigidbodies/colliders
    that have just made contact (had a collision). Information about the collision
    can be found inside the `coll` variable.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCollisionEnter2D(Collision2D coll)`: 当刚体/碰撞体刚刚接触（发生碰撞）时，这个方法会被调用。关于碰撞的信息可以在`coll`变量中找到。'
- en: '`OnCollisionStay2D(Collision2D coll)`: This is called on both rigidbodies/colliders
    every frame as long as they are touching each other. Information about the collision
    can be found inside the `coll` variable.'
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCollisionStay2D(Collision2D coll)`: 当两个刚体/碰撞体持续接触时，每一帧都会调用这个方法。关于碰撞的信息可以在`coll`变量中找到。'
- en: '`OnCollisionExit2D(Collision2D coll)`: This is called on both two rigidbodies/colliders
    when they stop making contact. Information about their collision can be found
    inside the `coll` variable.'
  id: totrans-275
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OnCollisionExit2D(Collision2D coll)`: 当两个刚体/碰撞体停止接触时，这个方法会被调用。它们碰撞的信息可以在`coll`变量中找到。'
- en: In our specific case, we will need these functions (the trigger ones) to detect
    when the sprinkles hit the enemies, to reduce their health, and eventually trigger
    the right animation. We will see this at the end of the chapter.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的特定情况下，我们需要这些函数（触发器函数）来检测当糖果击中敌人时，减少他们的健康，并最终触发正确的动画。我们将在本章的末尾看到这一点。
- en: Joints
  id: totrans-277
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关节
- en: 'So far, we have talked about rigid bodies and colliders, but they were just
    single physical bodies. What about more complex mechanical systems? Imagine a
    rope that is holding a cage with a skeleton and a key inside. So, our protagonist
    decides to cut the rope to make the cage fall. Once the rope is broken, then the
    cage falls down. However, even before the rope is cut, the cage was under the
    effect of gravity. In fact, if our protagonist would have pushed the cage instead
    of cutting the rope, that would have started to oscillate. The reason is that
    the rope is giving a constraint to the cage — it is allowed to move only within
    a circle (or sphere if we are in 3D) that has per radius the length of the rope.
    Of course, when it oscillates, gravity makes the cage move on the border of this
    circle (or sphere). What if the rope were a rigid metal bar? Well, the cage would
    even have a harder constraint, because now it is forced to be only on the border
    of the circle (or sphere). And if the rope was a spring? Again, this is another
    kind of constraint as shown in the following diagram:'
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们讨论了刚体和碰撞体，但它们只是单个物理体。那么更复杂的机械系统呢？想象一下一根绳子，它正拉着装有骨架和钥匙的笼子。所以，我们的主人公决定切断绳子，让笼子掉落。一旦绳子被切断，笼子就会掉下来。然而，即使在绳子被切断之前，笼子就已经受到重力的作用。事实上，如果我们的主人公推笼子而不是切断绳子，那么笼子就会开始振荡。原因是绳子给笼子施加了一个约束——它只允许在半径等于绳子长度的圆（或如果我们在3D中，则是球）内移动。当然，当它振荡时，重力使得笼子在圆（或球）的边缘移动。如果绳子是一根刚性的金属棒呢？那么笼子会有更严格的约束，因为现在它被迫只位于圆（或球）的边缘。如果绳子是弹簧呢？这又是一种约束，如以下图所示：
- en: '![Joints](img/image00541.jpeg)'
  id: totrans-279
  prefs: []
  type: TYPE_IMG
  zh: '![关节](img/image00541.jpeg)'
- en: Although the cage is under the force of the gravity, the rope imposes a reaction
    force. As a result, the cage doesn't fall. Therefore, the rope imposes a constraint
    on the cage. In particular, it limits the cage motion to be within a circle with
    a radius equal to the rope length.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管笼子受到重力的作用，但绳子施加了一个反作用力。因此，笼子不会掉落。因此，绳子对笼子施加了一个约束。特别是，它限制了笼子的运动，使其保持在半径等于绳子长度的圆内。
- en: Now, imagine placing many of these constraints together. For instance, you tie
    up the cage to a pending spring, and from the bottom of the cage a rope is holding
    a metal sphere. The system would start to increase in complexity. But how does
    Unity handle all of this? The answer is, using Joints components.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，想象一下将这些约束放在一起。例如，你将笼子系在一个悬挂的弹簧上，从笼子的底部拉出一根绳索，绳索悬挂着一个金属球。系统将开始变得更加复杂。但Unity是如何处理所有这些的呢？答案是，使用关节组件。
- en: Note
  id: totrans-282
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Note that all the joints that finish with 2D belong to the 2D Physics engine;
    otherwise they belong to the 3D one. So be careful to not get confused or attach
    the wrong joint. However, from now on, we will always refer to it as Joint 2D,
    even without 2D, unless otherwise specified. This decision was made to make the
    chapter clear and more fluid to read.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，所有以2D结尾的关节都属于2D物理引擎；否则它们属于3D物理引擎。所以请小心，不要混淆或连接错误的关节。然而，从现在开始，我们将始终将其称为Joint
    2D，即使没有2D，除非另有说明。这个决定是为了使章节更清晰、更流畅地阅读。
- en: Main properties of Joints
  id: totrans-284
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 关节的主体属性
- en: By using a joint component, you can attach a rigidbody to another one, in order
    to give them a specific constraint, and still leave some freedom for the motion.
    In particular, Unity provides nine Joint 2D components. But before we go through
    each one of them, let's explore some general properties of the joints in Unity.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用关节组件，你可以将一个刚体连接到另一个刚体上，以便为它们提供特定的约束，同时仍然为运动留下一些自由度。特别是，Unity提供了九个Joint 2D组件。但在我们逐一介绍它们之前，让我们先探索一下Unity中关节的一些通用属性。
- en: The other rigidbody
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一个刚体
- en: 'As we''ve already said, a joint involves two rigidbodies (with the exception
    of the **Target Joint 2D**). The first is attached to the same object of the joint.
    The other one can be chosen arbitrarily. Therefore, these two options are available
    inside the joint components:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前所说的，一个关节涉及两个刚体（**目标关节2D**除外）。第一个是连接到关节相同物体的。另一个可以任意选择。因此，在关节组件内部有这两个选项：
- en: '**Enable Collision**: Both rigidbodies will have colliders. If this toggle
    is true, it means that the two rigidbodies will collide between them according
    to the Physics engine and what we have seen so far in the previous two sections.
    Most of the times, rigidbodies with a joint belong to the same big system, and
    you don''t want it to collide with itself. As such, the default value is false.'
  id: totrans-288
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**启用碰撞**：两个刚体都将有碰撞器。如果这个切换为真，这意味着两个刚体将根据物理引擎和我们在前两个部分中看到的进行碰撞。大多数情况下，具有关节的刚体属于同一个大系统，你不想它与自己碰撞。因此，默认值是false。'
- en: '**Connected Rigid body**: This is the reference to the second rigidbody of
    the joint, as the name suggests.'
  id: totrans-289
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接的刚体**：这是对关节第二个刚体的引用，正如其名所示。'
- en: 'Then, most of the joints (with the exception for the **Relative Joint 2D**
    and the **Target Joint 2D**) needs the two points of the application of the joint.
    Imagine again the example of the cage pending from the rope. Where the rope is
    attached to the cage is an important factor, because if the rope is attached to
    one of the corners of the cage, this will be rotated, as shown in this diagram:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，大多数的关节（除了**相对关节2D**和**目标关节2D**）需要两个应用关节的点。再次想象一下笼子悬挂在绳索上的例子。绳索连接到笼子的位置是一个重要因素，因为如果绳索连接到笼子的一个角落，这将导致旋转，如图所示：
- en: '![The other rigidbody](img/image00542.jpeg)'
  id: totrans-291
  prefs: []
  type: TYPE_IMG
  zh: '![另一个刚体](img/image00542.jpeg)'
- en: We attached the rope on the cage which is important, because it will affect
    how it will react to forces. However, it is interesting to note that wherever
    you append a rigidbody, the line along the rope will pass always through the barycenter
    (centroid) of the rigidbody.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将绳索系在了笼子上，这是很重要的，因为它将影响笼子对力的反应。然而，值得注意的是，无论你在哪里附加一个刚体，绳索的线始终会通过刚体的质心（重心）。
- en: Plus, you need to consider the possibility that there are other forces that
    may move the cage, and again where the rope is attached is an important piece
    of information. The same applies to the other rigidbody; in the case of the cage,
    the other rigid body is the ceiling.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你需要考虑可能存在其他可能移动笼子的力，而绳索连接的位置是一个重要的信息。同样适用于另一个刚体；在笼子的例子中，另一个刚体是天花板。
- en: 'Therefore, there are some options available to determine these two points of
    application, which are called **anchors** in Unity:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有一些选项可用于确定这两个应用点，在Unity中被称为**锚点**：
- en: '**Auto Configure Connected Anchor**: If this is checked, Unity will take care
    to determine where the two anchors are. Of course, turn it off if you have a specific
    point of application of the joint in mind and you want to place an anchor there.'
  id: totrans-295
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动配置连接锚点**：如果勾选了这个选项，Unity 将负责确定两个锚点的位置。当然，如果你已经有一个特定的关节应用点并且想要在那里放置锚点，请将其关闭。'
- en: '**Anchor**: The position in *x* and *y* (with respect to the rigidbody) of
    the anchor of the joint on the rigidbody where it is attached.'
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锚点**：相对于刚体，关节在连接的刚体上的锚点的 *x* 和 *y* 位置。'
- en: '**Connected Anchor **: This is the position in *x* and *y* (with respect to
    the rigidbody of the other object) of the anchor of the joint on the rigidbody
    specified in the **Connected Rigidbody** variable.'
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**连接锚点**：这是相对于另一个物体的刚体，在**连接刚体**变量指定的刚体上，关节锚点的 *x* 和 *y* 位置。'
- en: Breaking joints
  id: totrans-298
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 破坏关节
- en: Coming back to the example of the suspended cage, imagine that the hero decides
    that it is a good idea try to jump on top of the cage and then jump on another
    platform. However, he didn't consider that the rope was really old (in fact, there
    is a skeleton in the cage!), and once he landed on the cage, the rope breaks making
    both the cage and our hero fall. Therefore, it's true that joints impose a constraint,
    but they have limits too. For the same reason, if you pull both sides of a rubber
    with too much force, the rubber will eventually break.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 回到悬挂笼子的例子，想象一下，英雄决定尝试跳到笼子的顶部，然后再跳到另一个平台上。然而，他没有考虑到绳子真的很旧（实际上笼子里有一具骨架！），一旦他落在笼子上，绳子断裂，导致笼子和我们的英雄一起坠落。因此，确实，关节施加了约束，但它们也有局限性。出于同样的原因，如果你用太大的力拉扯橡皮筋，橡皮筋最终也会断裂。
- en: 'Also in Unity, Joints can be broken. In particular, in their components there
    are two variables:'
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 中，关节也可以被破坏。特别是，在它们的组件中，有两个变量：
- en: '**Break Force**: This is present in all the joints, and it holds the numerical
    value of the force after which the joint will break. Breaking a joint in Unity
    means to erase the Joint component from the object. By default, it is set to be
    infinity, which means that the joint is indestructible. Otherwise, the lower the
    value, the easier it is to break the joint. In the example of the cage, if we
    choose to give a very low value for the joint that simulates the rope, it will
    be likely that the rope is really old and when our hero jumps on top of the cage,
    they both will fall in the dungeon of the castle.'
  id: totrans-301
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断裂力**：所有关节都有这个属性，它表示关节断裂后的力数值。在 Unity 中破坏关节意味着从对象中删除关节组件。默认情况下，它被设置为无限大，这意味着关节是不可破坏的。否则，数值越低，关节越容易断裂。在笼子的例子中，如果我们选择为模拟绳子的关节设置一个非常低的值，那么绳子很可能真的很旧，当我们的英雄跳到笼子的顶部时，他们两人都会掉进城堡的地牢中。'
- en: '**Break Torque**: This is present in all the joints other than **Distance Joint
    2D**, **Spring Joint 2D**, and **Target Joint 2D**. It holds the numerical value
    of the torque after which the joint will break. As we already have seen, rigidbodies
    can not only move but also rotate. By default, it is set to be infinity, which
    means the joint is indestructible. Otherwise, it can be brought to a finite value,
    allowing the joint to break with torques greater than the value specified.'
  id: totrans-302
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断裂扭矩**：除了**二维距离关节**、**二维弹簧关节**和**二维目标关节**之外的所有关节都有这个属性。它表示关节断裂后的扭矩数值。正如我们之前所看到的，刚体不仅可以移动，还可以旋转。默认情况下，它被设置为无限大，这意味着关节是不可破坏的。否则，它可以被设置为有限值，允许关节在超过指定值的扭矩下断裂。'
- en: Note
  id: totrans-303
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'For an example of a joint that breaks under torque, you can just imagine something
    that is rotating but it''s motion is blocked by something, such as when you use
    the screwdriver and keep going until the wood (which was the constraint) is broken.
    However, here is another example that is less intuitive but more common (even
    in video games). Imagine you append yourself on the boarder/edge of a shelf. Since
    there is an offset from the center of mass of the shelf and the point where you
    have appended yourself (they are likely to be perpendicular if the shelf is flat),
    a torque is applied on the shelf. Under the effect of the torque, the shelf should
    rotate around its center of mass, but it doesn''t since the wall prevents it.
    If you are heavy enough, which means the force you apply on the shelf is greater
    (or also if in some way you are able to increase the offset), the torque increases,
    until it reaches a breaking point. Then the constraint will break, which may result
    either in a broken shelf or a broken wall depending which one has more resistance
    (most probably the shelf will break and the wall will still stand). The following
    diagram should help you to figure the example out:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个在扭矩作用下断裂的关节的例子，你可以想象一些正在旋转但运动被阻止的东西，比如当你使用螺丝刀并继续直到木头（作为约束）断裂时。然而，这里还有一个不那么直观但更常见的例子（甚至在视频游戏中）。想象你把自己附加在架子/边缘上。由于你的附加点与架子的质心之间有一个偏移（如果架子是平的，它们很可能是垂直的），架子上会施加一个扭矩。在扭矩的作用下，架子应该围绕其质心旋转，但由于墙壁阻止了它，它并没有旋转。如果你足够重，这意味着你施加在架子上的力更大（或者如果你以某种方式能够增加偏移），扭矩会增加，直到达到断裂点。然后约束将断裂，这可能导致架子或墙壁断裂，具体取决于哪一个有更大的阻力（最可能的是架子会断裂，而墙壁仍然站立）。以下图表应该有助于你理解这个例子：
- en: '![Breaking joints](img/image00543.jpeg)'
  id: totrans-305
  prefs: []
  type: TYPE_IMG
  zh: '![断裂关节](img/image00543.jpeg)'
- en: Specific joints
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 特定关节
- en: So far, we have seen only general properties of the joints in Unity, but now
    we will take a closer look at all the nine joint 2D components available.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只看到了 Unity 中关节的一般特性，但现在我们将更深入地了解所有九种 2D 关节组件。
- en: 'It''s worthy to mention that joints are divided into two classes: spring joints
    and motor joints. The former uses a spring to impose a constraint, which may be
    completely stiff so as to simulate a rigid bar. Motor joints, instead, can actively
    apply forces onto the rigidbodies. Some joints are both, like a spring with a
    motor.'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，关节分为两类：弹簧关节和电机关节。前者使用弹簧施加约束，可能完全刚硬，以模拟刚性杆。电机关节则可以主动对刚体施加力。一些关节既是弹簧又是电机，例如带有电机的弹簧。
- en: Tip
  id: totrans-309
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: All the joints in Unity have an icon (visible when, for instance, you place
    the component in the **Inspector**). In this book, you can see the icon in the
    top-left corner of the images of the joints (in the next sections). This icon
    is really useful for remembering what the joint does and also how it works. So,
    when reading the next section, or programming your game, pay attention to this
    icon, which might help you to understand the joint better.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 中的所有关节都有一个图标（例如，当你将组件放置在 **检查器** 中时可见）。在这本书中，你可以在关节图像的右上角看到这个图标（在下一节中）。这个图标非常有用，可以帮助你记住关节的作用以及它是如何工作的。因此，在阅读下一节或编写你的游戏时，请注意这个图标，它可能有助于你更好地理解关节。
- en: Distance Joint 2D
  id: totrans-311
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 距离关节 2D
- en: This joint keeps the two rigidbodies at a certain distance apart. The aim of
    this joint is to keep at a certain distance two rigidbodies, or a rigidbody and
    a fixed point in the game world. In fact, if you set the **Connected Rigidbody**
    variable to `None`, you can then specify the position of the fixed point in **Connected
    Anchor**.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 此关节保持两个刚体之间的特定距离。此关节的目的是在游戏世界中保持两个刚体或一个刚体与固定点之间的特定距离。实际上，如果你将 **连接刚体** 变量设置为
    `None`，你可以在 **连接锚点** 中指定固定点的位置。
- en: 'It should appear like the following in the **Inspector**:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 它应该看起来像以下这样在 **检查器** 中：
- en: '![Distance Joint 2D](img/image00544.jpeg)'
  id: totrans-314
  prefs: []
  type: TYPE_IMG
  zh: '![距离关节 2D](img/image00544.jpeg)'
- en: This joint applies a linear force to both the rigidbodies (or just to the rigidbody
    on which it is attached if using a fixed point) with a very stiff simulated spring
    (which is not configurable) to keep the distance. The joint doesn't apply any
    torque.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 此关节向两个刚体（或如果使用固定点，则仅向其附加的刚体）施加线性力，使用一个非常刚硬的模拟弹簧（不可配置）以保持距离。该关节不施加任何扭矩。
- en: 'In addition to the parameters that we have seen in the last section, **Distance
    Joint 2D** also has the following options:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在上一节中看到的参数之外，**二维距离关节**还有以下选项：
- en: '**Auto Configure Distance**: If set to true, Unity will calculate the current
    distance between the two rigidbodies (or the rigidbody and the fixed point) and
    place its value in the **Distance** variable.'
  id: totrans-317
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动配置距离**：如果设置为true，Unity将计算两个刚体（或刚体和固定点）之间的当前距离，并将其值放置在**距离**变量中。'
- en: 'Distance: Specifies the distance beyond which the two rigidbodies (or the rigidbody
    and the fixed point) cannot go further.'
  id: totrans-318
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 距离：指定两个刚体（或刚体和固定点）不能超过的距离。
- en: '**Max Distance Only**: If enabled, the distance between the two rigidbodies
    (or the rigidbody and the fixed point) can be lower than the value specified in
    the Distance. If this option is disabled instead, the distance is fixed and the
    two points cannot be any further or closer than the Distance.'
  id: totrans-319
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**仅最大距离**：如果启用，两个刚体（或刚体和固定点）之间的距离可以小于在距离中指定的值。如果此选项被禁用，则距离是固定的，两个点不能比距离更远或更近。'
- en: Note
  id: totrans-320
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 备注
- en: Remember that if the **Break Force** of the joint is a finite value, it will
    eventually break, even if the **Max Distance Only** option is set to false.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，如果关节的**断裂力**是一个有限值，即使将**仅最大距离**选项设置为false，它最终也会断裂。
- en: When **Max Distance Only** is false, the constraint among the two points is
    rigid, so you can imagine them connected by a metal string/bar along with a hinge
    (since they can still rotate with respect to each other). An example of how this
    is used is when you need to connect two couches of a train together, because they
    cannot get any farther or closer than a specific distance. If **Max Distance Only**
    is true, instead, they can be closer than the **Distance**, but not further. This
    is the behaviour of our rope, which holds the cage. that potentially can get closer
    to where the rope is tied but not further. Another example is a dog with a leash.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当**仅最大距离**为false时，两点之间的约束是刚性的，所以你可以想象它们通过一个金属绳索/杆和铰链连接在一起（因为它们仍然可以相对于彼此旋转）。这种用法的一个例子是当你需要将火车上的两个沙发连接在一起时，因为它们不能比特定的距离更远或更近。如果**仅最大距离**为true，那么它们可以比**距离**更近，但不能更远。这是我们的绳索的行为，它支撑着笼子，可以靠近绳索系的地方，但不能更远。另一个例子是拴着绳索的狗。
- en: However, it is important to keep in mind that both the rigidbodies are free
    to rotate with respect to each other. In fact, this joint imposes the constraint
    only on the relative position of the two rigid bodies.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，重要的是要记住，两个刚体都可以相对于彼此自由旋转。实际上，此关节仅对两个刚体的相对位置施加约束。
- en: Fixed Joint 2D
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 二维固定关节
- en: The aim of this joint is to keep a certain relative offset (both linear and
    angular) between two rigidbodies or a rigidbody and a fixed point in the game
    world (you can specify it by setting **Connected Rigidbody** to `None`).
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 此关节的目的是在游戏世界中保持两个刚体或刚体和固定点之间的一定相对偏移（线性和角偏移）（你可以通过将**连接刚体**设置为`None`来指定它）。
- en: 'It should appear like the following in the **Inspector**:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 它在**检查器**中应如下所示：
- en: '![Fixed Joint 2D](img/image00545.jpeg)'
  id: totrans-327
  prefs: []
  type: TYPE_IMG
  zh: '![二维固定关节](img/image00545.jpeg)'
- en: This joints applies both a linear force to compensate the linear offset, and
    a torque to compensate the angular one. Like **Distance Joint 2D**, it uses a
    very stiff simulated spring, but you can tweak the spring values, such as the
    frequency.
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 此关节同时施加一个线性力来补偿线性偏移，以及一个扭矩来补偿角偏移。与**二维距离关节**类似，它使用一个非常刚性的模拟弹簧，但你也可以调整弹簧的值，例如频率。
- en: 'Therefore, in addition to the parameters we have seen in the last section,
    **Fixed Joint 2D** has also the following options:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，除了我们在上一节中看到的参数之外，**二维固定关节**还有以下选项：
- en: '**Damping Ratio**: This defines the degree to which the oscillation of the
    spring is suppressed. Its value ranges from 0 to 1; the higher the value, the
    less motion. As you would expect from a spring, this joint will overshoot the
    desired distance and then rebound back, leading the spring to oscillate. The **Damping
    Ratio** determines how quickly the oscillation is damped (reduced) and thus how
    fast the spring comes back to its rest position'
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻尼比**：这定义了弹簧振荡被抑制的程度。其值范围从0到1；值越高，运动越少。正如你所期望的，弹簧会超过期望的距离然后反弹回来，导致弹簧振荡。**阻尼比**决定了振荡被阻尼（减少）的速度，从而决定了弹簧回到其静止位置的速度。'
- en: '**Frequency**: This defines the frequency at which the spring oscillates when
    the rigidbodies are reaching the separation distance. It is measured in cycles
    per second, and its value ranges from 1 to 1 million. The higher the value, the
    stiffer the spring, which means less motion. It''s worthwhile to notice that a
    value of zero means that the spring is completely stiff.'
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频率**：这定义了当刚体达到分离距离时弹簧振动的频率。它以每秒周期数来衡量，其值范围从1到100万。值越高，弹簧越硬，这意味着运动越少。值得注意的是，零值意味着弹簧完全僵硬。'
- en: Another way to think of this joint is like parenting GameObjects within the
    **Hierarchy** so that the children are fixed with respect to their parents. However,
    the joint offers you more options than a simple parenting, including the possibility
    to break it.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种思考这个关节的方法是将GameObject在**层次结构**中视为父级，这样子级就可以相对于父级固定。然而，这个关节为你提供了比简单父级更多的选项，包括打破它的可能性。
- en: An example of usage of this joint is when you have a chain of rigidbodies (such
    as a real chain that hangs from the ceiling, or you can imagine also a bridge
    made of sections), and you want to hold them rigidly together. The advantage is
    that you can allow a certain flexibility in the joint, so in the case of the bridge,
    it can still bend a little within the limits you impose.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关节的使用示例之一是当你有一系列刚体（例如从天花板悬挂的真实链条，或者你可以想象由部分组成的桥梁），并且你想要将它们刚性连接在一起。优点是你可以允许关节有一定的灵活性，因此，在桥梁的情况下，它仍然可以在你设定的限制内稍微弯曲。
- en: Friction Joint 2D
  id: totrans-334
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2D摩擦关节
- en: The aim of this joint is to keep to zero both the linear and angular offset,
    by slowing down the movement between the two rigidbodies or a rigidbody and a
    fixed point in the game world (you can specify it by setting **Connected Rigidbody**
    to `None`).
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关节的目的是通过减慢两个刚体之间或刚体与游戏世界中的固定点（你可以通过将**连接刚体**设置为`None`来指定）之间的运动来使线性偏移和角偏移都保持为零。
- en: '**Friction Joint 2D** should appear like this in the **Inspector**:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: '**2D摩擦关节**在**检查器**中应该看起来像这样：'
- en: '![Friction Joint 2D](img/image00546.jpeg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![2D摩擦关节](img/image00546.jpeg)'
- en: 'In addition to the parameters we have seen in the last section, **Friction
    Joint 2D** has the following options:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在上一节中看到的参数之外，**2D摩擦关节**还有以下选项：
- en: '**Max Force**: This determines the linear resistance along the line that connects
    the two rigidbodies. A high value (the maximum is 1,000,000) creates a strong
    linear resistance; thus the two rigidbodies will not move along the line that
    connects them much. On the contrary, a low value allows more motion.'
  id: totrans-339
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大力**：这决定了连接两个刚体的直线上的线性阻力。高值（最大值为1,000,000）会产生强烈的线性阻力；因此，两个刚体不会在它们连接的直线上移动很多。相反，低值允许更多的运动。'
- en: '**Max Torque**: This determines the angular resistance between the two rididbodies.
    A high value (the maximum is 1 million) creates a strong angular resistance; thus
    the two rigidbodies will not rotate much relatively. On the contrary, a low value
    allows more motion.'
  id: totrans-340
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大扭矩**：这决定了两个刚体之间的角阻力。高值（最大值为1百万）会产生强烈的角阻力；因此，两个刚体不会相对旋转很多。相反，低值允许更多的运动。'
- en: An example of the use of this joint is when there are physical objects in the
    game that need friction to be believable. So, imagine a platform that is anchored
    to a big wheel in the background. Since the game is 2D, the wheel is only an aesthetic
    element; it doesn't actually affect the platform. As such, we need to simulate
    the friction between the platform and the wheel, and we can achieve that with
    a **Friction Joint 2D**. In this way, we can have an angular resistance on the
    platform; thus it can still be rotated, but not so easily. Maybe, the player may
    drop a heavy box on the border of the platform to make it rotate enough so that
    the player can pass.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关节的使用示例之一是当游戏中存在需要摩擦力来显得逼真的物理对象时。想象一个平台，它固定在背景中的一个大轮子上。由于游戏是2D的，这个轮子只是一个美学元素；它实际上并不影响平台。因此，我们需要模拟平台和轮子之间的摩擦力，我们可以通过使用**2D摩擦关节**来实现这一点。这样，我们可以在平台上产生一个角阻力；因此，它仍然可以旋转，但不是那么容易。也许，玩家可能会在平台的边缘放下一个重箱子，使其旋转足够，以便玩家可以通过。
- en: '![Friction Joint 2D](img/image00547.jpeg)'
  id: totrans-342
  prefs: []
  type: TYPE_IMG
  zh: '![2D摩擦关节](img/image00547.jpeg)'
- en: On the left is the representation of the system. On the right is what will happen
    when the box is dropped onto the platform, which will rotate slowly due its angular
    friction.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 左边是系统的表示。右边是当箱子被扔到平台上时会发生的情况，由于角摩擦，平台会缓慢旋转。
- en: Hinge Joint 2D
  id: totrans-344
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2D铰链关节
- en: The aim of this joint is to constrain the rigidbody to rotate around another
    rigidbody or a fixed point in space (always specified by **Connected Anchor**
    if **Connected Rigid Body** is set to `None`). The rotation can either be left
    to happen passively (for example, in response to a collision, or under the effect
    of gravity) or be actively powered by a motor, which provides torque to the rigidbody.
    Furthermore, limits can be set to constrain the hinge just to rotate at certain
    angles, or to allow more than a one full rotation around its axis.
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 此关节的目的是将刚体约束在围绕另一个刚体或空间中的固定点（如果将**连接刚体**设置为`None`，则始终由**连接锚点**指定）旋转。旋转可以是被动发生的（例如，响应碰撞或在重力作用下）或由电机主动提供扭矩，该电机为刚体提供扭矩。此外，可以设置限制以仅允许铰链在特定角度旋转，或允许围绕其轴旋转超过一整圈。
- en: 'It appears like the following screenshot in the **Inspector**:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 在**检查器**中看起来如下截图所示：
- en: '![Hinge Joint 2D](img/image00548.jpeg)'
  id: totrans-347
  prefs: []
  type: TYPE_IMG
  zh: '![Hinge Joint 2D](img/image00548.jpeg)'
- en: 'In addition to the parameters that we have seen in the last section, **Hinge
    Joint 2D** has the following options:'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们在上一节中看到的参数之外，**Hinge Joint 2D**还有以下选项：
- en: '**Use Motor:** If enabled, it allows the joint to actively apply a torque on
    the rigidbody, simulating a motor.'
  id: totrans-349
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用电机:** 如果启用，它允许关节在刚体上主动施加扭矩，模拟电机。'
- en: '**Motor Speed:** This specifies at which speed the simulated motor should rotate
    in degrees per second. So a value of 30 means that the motor will do a complete
    rotation in 12 seconds (*360/30=12*).'
  id: totrans-350
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电机速度:** 这指定模拟电机应以每秒多少度旋转。因此，值为30表示电机将在12秒内完成一整圈旋转（*360/30=12*）。'
- en: '**Maximum Motor Force:** This specifies the maximum force that the motor can
    apply to reach the **Motor Speed**. Imagine a very heavy object requires a stronger
    force to rotate and thus reach the **Motor Speed**. If the motor is not powerful
    enough, it won''t make the rigidbody reach the **Motor Speed**. Moreover, if a
    **Break Torque** is specified, it may break the joint.'
  id: totrans-351
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大电机力:** 这指定电机可以达到**电机速度**的最大力。想象一个非常重的物体需要更大的力来旋转并达到**电机速度**。如果电机不够强大，它将无法使刚体达到**电机速度**。此外，如果指定了**断力矩**，它可能会破坏关节。'
- en: '**Use Limits:** If true, the joint limits the angles to which the rigidbody
    can rotate.'
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用限制:** 如果为真，则关节限制刚体可以旋转的角度。'
- en: '**Lower Angle:** This sets the lower end of the rotation arc allowed by the
    limit.'
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下角:** 这设置由限制允许的旋转弧的下端。'
- en: '**Upper Angle:** This sets the upper end of the rotation arc allowed by the
    limit.'
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上角:** 这设置由限制允许的旋转弧的上端。'
- en: A clear example of the usage of this joint is with doors. They can rotate around
    their hinges, which connect the door with its frame. We can limit how the door
    can rotate, so for instance, you may want it to rotate only of 90 degrees. Moreover,
    if the door is automatic, we can simulate a motor, which actively makes the door
    rotate. In fact, the motor may be triggered by a script. Finally, if the player
    wants to push the door beyond its limit (90 degrees in the example), and a **Break
    Torque** is specified, the player may break the hinge with enough force.
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 使用此关节的一个清晰的例子是与门一起使用。它们可以围绕铰链旋转，铰链将门与框架连接起来。我们可以限制门可以如何旋转，例如，你可能只想让它旋转90度。此外，如果门是自动的，我们可以模拟一个电机，该电机主动使门旋转。实际上，电机可能由脚本触发。最后，如果玩家想要将门推过其限制（例如，90度），并且指定了**断力矩**，玩家可能用足够的力破坏铰链。
- en: '![Hinge Joint 2D](img/image00549.jpeg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![Hinge Joint 2D](img/image00549.jpeg)'
- en: Top view (birds-eye view). On the left is the representation of the system.
    On the right is what will happen when the player pushes the door beyond its limits.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 俯视图（鸟瞰图）。在左侧是系统的表示。在右侧是玩家推门超过其限制时会发生的情况。
- en: Relative Joint 2D
  id: totrans-358
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 相对关节2D
- en: This joint makes two rigidbodies to keep a relative position based on each other's
    position. In fact, the aim of this joint is the same as that of the **Fixed Joint
    2D**; the difference lies in how they do it. The **Fixed Joint 2D**, as we already
    have seen, is a spring kind of joint that will stop to oscillate only when the
    two rigidbodies are at the specified offset and rotation, and so the spring is
    in a rest position. Instead, the **Relative Joint 2D** is a motor kind of joint
    that applies a direct force and torque to rigidbodies so that they are at the
    same offset and rotation.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 这个关节使两个刚体保持基于彼此位置的相对位置。实际上，这个关节的目标与**固定关节2D**相同；区别在于它们是如何实现的。**固定关节2D**，正如我们之前看到的，是一种弹簧式的关节，只有当两个刚体处于指定的偏移和旋转位置时，它才会停止振荡，弹簧处于静止位置。相反，**相对关节2D**是一种电机式的关节，它对刚体施加直接力和扭矩，使它们处于相同的偏移和旋转位置。
- en: 'Like the **Fixed Joint 2D**, the **Relative Joint 2D** can also work with both
    of these:'
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 与**固定关节2D**类似，**相对关节2D**也可以与这两个一起工作：
- en: Two rigidbodies
  id: totrans-361
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 两个刚体
- en: A rigidbody and a fixed point
  id: totrans-362
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个刚体和一个固定点
- en: To use the second case, set **Connected Rigidbody** to `None` and then specify
    the coordinate of the fixed point in the **Linear Offset** variable.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用第二种情况，将**连接刚体**设置为`None`，然后在**线性偏移**变量中指定固定点的坐标。
- en: 'It appears like this in the **Inspector**:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 它在**检查器**中显示如下：
- en: '![Relative Joint 2D](img/image00550.jpeg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![相对关节2D](img/image00550.jpeg)'
- en: 'In addition to the parameters we saw in the last section, the **Relative Joint
    2D** has the following options:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上一节中看到的参数外，**相对关节2D**还有以下选项：
- en: '**Max Force**: This specifies the maximum force that the joint/motor can use
    to correct the offset between the two rigidbodies. The higher the value, the better
    the simulated motor will be able to correct the offset. By default, **Max Force**
    is set to `10000`, which means a really powerful motor.'
  id: totrans-367
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大力**: 这指定了关节/电机可以用来校正两个刚体之间偏移的最大力。值越高，模拟的电机越能有效地校正偏移。默认情况下，**最大力**设置为`10000`，这意味着一个非常强大的电机。'
- en: '**Max Torque**: This specifies the maximum torque that the joint/motor can
    use to correct the angular offset between the two rigidbodies. The higher the
    value, the better the simulated motor will be able to correct the angular offset.
    By default, **Max Torque** is set to `10000`, which means a really powerful motor.'
  id: totrans-368
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大扭矩**: 这指定了关节/电机可以用来校正两个刚体之间角偏移的最大扭矩。值越高，模拟的电机越能有效地校正角偏移。默认情况下，**最大扭矩**设置为`10000`，这意味着一个非常强大的电机。'
- en: '**Correction Scale**: Tweaks the joint to make sure that it behaves as it is
    supposed to. This can be done by either increasing **Max Force** or **Max Torque**,
    which may affect behaviour (and as a result the joint may not reach its target).
    Therefore, you can use this setting to correct it. The default setting of `0.3`
    is usually appropriate (because on an average the joint behaves as you would expect;
    it''s a value that has likely been found by trial and error). But it may need
    tweaking between the range of 0 and 1.'
  id: totrans-369
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**校正比例**: 调整关节以确保其按预期行为。这可以通过增加**最大力**或**最大扭矩**来实现，这可能会影响行为（因此关节可能无法达到其目标）。因此，您可以使用此设置进行校正。默认设置`0.3`通常是合适的（因为平均而言，关节的行为符合您的预期；这是一个可能通过试错找到的值）。但可能需要在0到1的范围内进行调整。'
- en: '**Auto Configure Offset**: When checked, this takes the current linear and
    angular offsets of the two rigidbodies, stores them in the **Linear Offset** and
    **Angular Offset** variables, and maintains them.'
  id: totrans-370
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动配置偏移**: 当选中时，这将获取两个刚体的当前线性偏移和角偏移，将它们存储在**线性偏移**和**角偏移**变量中，并保持它们。'
- en: '**Linear Offset**: This specifies the linear offset that the two rigidbodies
    should have, expressed in local coordinates.'
  id: totrans-371
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**线性偏移**: 这指定了两个刚体应具有的线性偏移，以局部坐标表示。'
- en: '**Angular Offset**: This specifies the angular offset that the two rigidbodies
    should have, expressed in local coordinates.'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角偏移**: 这指定了两个刚体应具有的角偏移，以局部坐标表示。'
- en: An example of use of this joint is between the camera and the Avatar in the
    game. In this way, the camera can follow the Avatar with a slight delay (because
    if the camera is parented, it will move instantaneously with the Avatar). But
    it won't oscillate much as with the **Fixed Joint 2D**, since it is a spring kind,
    which may cause frustration to the player (of course, this also depends on how
    the **Fixed Joint 2D** is configured, maybe with a real stiff spring; but usually
    the **Relative Joint 2D** is used for this kind of situations).
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关节的一个使用示例是在游戏中的摄像机和Avatar之间。这样，摄像机可以稍微延迟地跟随Avatar（因为如果摄像机是父级，它将与Avatar瞬间移动）。但它的振荡不会像**固定关节
    2D**那样大，因为它是弹簧类型，可能会让玩家感到沮丧（当然，这也取决于**固定关节 2D**的配置，可能是一个真正的刚性弹簧；但通常在这种情况下使用**相对关节
    2D**）。
- en: Another typical example of the use of this joint is when something should follow
    the player, such as a life counter above her head or a friendly spirit behind
    her shoulders.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 这种关节的另一个典型使用示例是当某些东西应该跟随玩家时，例如她头上的生命计数器或她肩膀后面的友好精神。
- en: Slider Joint 2D
  id: totrans-375
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滑块关节 2D
- en: Imagine you want to constrain the motion of a rigidbody just along a line, so
    that it can only slide onto that line. This is what the **Slider Joint 2D** allows
    you to do. As for the other joints, the line can be between two rigidbodies or
    a rigidbody and a fixed point in the game world.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想要限制刚体的运动仅沿一条线，这样它只能滑动到那条线上。这就是**滑块关节 2D**允许你做到的。至于其他关节，这条线可以在两个刚体之间，或者是一个刚体和游戏世界中的一个固定点之间。
- en: 'It appears like this in the **Inspector**:'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: 它在**检查器**中看起来是这样的：
- en: '![Slider Joint 2D](img/image00551.jpeg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![滑块关节 2D](img/image00551.jpeg)'
- en: 'In addition to the parameters we have seen in the last section, the **Slider
    Joint 2D** also has the following options:'
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上一节中我们看到的参数之外，**滑块关节 2D**还有以下选项：
- en: '**Angle**: This specifies the angle at which the rigidbody is constrained to
    remain. In the 2D world, an angle fully specifies a direction, and this angle
    specifies in which direction the motion is constrained.'
  id: totrans-380
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角度**：这指定了刚体被约束保持的角度。在二维世界中，一个角度完全指定了一个方向，这个角度指定了运动受约束的方向。'
- en: Note
  id: totrans-381
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In order to fully determine the line where motion is allowed by the joint,
    the current position the rigidbody is taken into consideration as well. Thus,
    a point (the current position of the rigidbody) and a direction (specified from
    the **Angle** variable) univocally determine a line where the motion is constrained,
    as shown in the following diagram:'
  id: totrans-382
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了完全确定关节允许运动的那条线，还需要考虑刚体的当前位置。因此，一个点（刚体的当前位置）和一个方向（从**角度**变量指定）唯一地确定了一个运动受约束的线，如下面的图所示：
- en: '![Slider Joint 2D](img/image00552.jpeg)'
  id: totrans-383
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![滑块关节 2D](img/image00552.jpeg)'
- en: '**Use Motor**: If true, the joint uses a simulated motor as well.'
  id: totrans-384
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用电机**：如果为真，该关节还会使用模拟电机。'
- en: '**Motor Speed**: This specifies the speed of the rigidbody that the motor should
    achieve.'
  id: totrans-385
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电机速度**：这指定了电机应该达到的刚体速度。'
- en: '**Max Motor Force**: This specifies the maximum force that the motor can use/apply
    in order to achieve a Motor Speed for the rigidbody.'
  id: totrans-386
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大电机力**：这指定了电机为了达到刚体的电机速度所能使用/施加的最大力。'
- en: '**Use Limits**: If true, this allows further constraints on the rigidbody along
    a segment of the line.'
  id: totrans-387
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用限制**：如果为真，这允许对刚体沿线的某一段进行进一步的约束。'
- en: '**Lower Limit**: This specifies the minimum distance the rigidbody should be
    at from the **Connected Anchor** point.'
  id: totrans-388
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**下限**：这指定了刚体应从**连接锚点**处保持的最小距离。'
- en: '**Upper Translation**: This specifies the maximum distance the rigidbody should
    be at from the **Connected Anchor** point.'
  id: totrans-389
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**上平移**：这指定了刚体应从**连接锚点**处保持的最大距离。'
- en: Typical scenarios where you may want to use this joint are a sliding door, which
    goes up and down, and also a platform, which can go left and right, up, down,
    or even diagonally.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要使用这种关节的典型场景包括滑动门，它可以上下移动，以及平台，它可以左右、上下甚至对角移动。
- en: '![Slider Joint 2D](img/image00553.jpeg)'
  id: totrans-391
  prefs: []
  type: TYPE_IMG
  zh: '![滑块关节 2D](img/image00553.jpeg)'
- en: The sliding door in the diagram is constrained along a segment
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 图中的滑动门沿着一段被约束
- en: Spring Joint 2D
  id: totrans-393
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 2D 弹簧关节
- en: As the name suggests, this is a pure spring joint 2D. It actually simulates
    a spring connected between the two rigidbodies, or a rigidbody and a fixed point.
    In fact, this joint gives you all the functionalities for a spring joint, and
    therefore you can simulate all the other pure (without a motor) spring-joints.
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，这是一个纯二维弹簧关节。它实际上模拟了连接在两个刚体之间，或刚体和固定点之间的弹簧。实际上，这个关节为你提供了弹簧关节的所有功能，因此你可以模拟所有其他纯（不带电机）的弹簧关节。
- en: Note
  id: totrans-395
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: In fact, the **Distance Joint 2D** is simulated by using the **Spring Joint
    2D** with **Frequency** set to `0` and **Damping Ratio** to `1`.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，**二维距离关节**是通过使用**二维弹簧关节**来模拟的，其中**频率**设置为`0`，**阻尼比**设置为`1`。
- en: 'It appears like the following in the **Inspector**:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 它在**检查器**中看起来如下所示：
- en: '![Spring Joint 2D](img/image00554.jpeg)'
  id: totrans-398
  prefs: []
  type: TYPE_IMG
  zh: '![二维弹簧关节 2D](img/image00554.jpeg)'
- en: 'In addition to the parameters we have seen in the last section, the **Spring
    Joint 2D** has the following options:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 除了上一节中我们看到的参数外，**二维弹簧关节**还有以下选项：
- en: '**Distance**: This specifies the distance that the two rigidbodies (or the
    rigidbody and the fixed point) should keep. You can imagine it also like the length
    of the spring in its rest position, which means the length of the spring when
    no forces are applied on it.'
  id: totrans-400
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**距离**：这指定了两个刚体（或刚体和固定点）应保持的距离。你可以想象它也像弹簧在静止状态下的长度，这意味着没有施加力时弹簧的长度。'
- en: '**Damping Ratio**: This specifies how much you want to suppress the motion
    of the spring. Its value ranges from 0 to 1\. Lower values mean a movable spring,
    higher values mean a stiff spring. If it is set to 1, the spring is not movable.'
  id: totrans-401
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻尼比**：这指定了你想要抑制弹簧运动的程度。其值范围从0到1。较低的值意味着可移动的弹簧，较高的值意味着硬弹簧。如果设置为1，则弹簧不可移动。'
- en: '**Frequency**: This specifies the frequency at which the spring oscillates
    while the objects are approaching the separation distance (which is the length
    of the spring in the rest position) specified in the **Distance** variable (measured
    in cycles per second). It ranges from 0 to 1,000,000\. The higher the value, the
    stiffer the spring will be.'
  id: totrans-402
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频率**：这指定了当物体接近指定的分离距离（即弹簧在静止状态下的长度）时，弹簧振动的频率（以每秒周期数衡量）。其范围从0到1,000,000。数值越高，弹簧越硬。'
- en: 'Whenever you need to place a spring in your game, this is the right joint.
    So, an example could be a physically realistic Launchpad, which you need to compress
    the spring, so as to let it have a boost in your jump. However, you don''t need
    necessarily to think of this joint as a normal spring. In fact, you can bring
    this joint to the limits (such as a very stiff spring). As such, you are able
    to create other behaviours that in reality don''t have a spring, but in the game
    they look nice when connected by a spring. Have you ever played *Rayman*? The
    character has its body parts separated, but they still move together in a coherent
    way in the game. If you are planning to create a similar character, the spring
    joint can be a valid solution to link the body parts in a realistic way. Here
    is an image of *Rayman*:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 无论何时你需要在你的游戏中放置一个弹簧，这个关节就是正确的选择。所以，一个例子可能是一个物理上逼真的发射台，你需要压缩弹簧，以便在跳跃时给它一个助推。然而，你不必一定将这个关节视为一个普通的弹簧。事实上，你可以将这个关节推向极限（例如一个非常硬的弹簧）。这样，你就能创建出在现实中没有弹簧，但在游戏中通过弹簧连接看起来很棒的其他行为。你玩过**雷曼**吗？这个角色的身体部位是分开的，但在游戏中它们仍然以协调的方式移动。如果你计划创建一个类似的角色，弹簧关节可以是一个将身体部位以逼真方式连接起来的有效解决方案。以下是**雷曼**的图像：
- en: '![Spring Joint 2D](img/image00555.jpeg)'
  id: totrans-404
  prefs: []
  type: TYPE_IMG
  zh: '![二维弹簧关节 2D](img/image00555.jpeg)'
- en: Image of *Rayman*. As you can see, the character doesn't have legs or arms,
    but has hands and feet. In your game, you can attach them to the chest through
    a Spring Joint.
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: '**雷曼**的图像。正如你所见，这个角色没有腿或手臂，但有手和脚。在你的游戏中，你可以通过一个弹簧关节将它们附着在胸部。'
- en: Target Joint 2D
  id: totrans-406
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 目标关节2D
- en: The **Target Joint 2D** is a particular spring-type joint that, instead of having
    a second rigidbody, has a target. The aim is to keep the rigidbody where the component
    is attached at a certain distance from the target. It only applies a linear force;
    thus no torque is given to the rigidbody.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '**目标关节2D**是一种特殊的弹簧型关节，它没有第二个刚体，而是有一个目标。目标是保持组件附着在刚体上的距离一定距离。它只施加线性力；因此不会给刚体提供扭矩。'
- en: 'It appears like this in the **Inspector**:'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 它在**检查器**中看起来是这样的：
- en: '![Target Joint 2D](img/image00556.jpeg)'
  id: totrans-409
  prefs: []
  type: TYPE_IMG
  zh: '![目标关节 2D](img/image00556.jpeg)'
- en: 'Since this component doesn''t have a second rigidbody, there are some variables
    that allow you to specify the target:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 由于此组件没有第二个刚体，有一些变量允许你指定目标：
- en: '**Anchor**: Defined in local coordinates, with respect to the rigidbody, where
    the joint is attached on the rigidbody.'
  id: totrans-411
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**锚点**：在局部坐标系中定义，相对于刚体，关节附着在刚体上的位置。'
- en: '**Target**: Defined in local coordinates, with respect to the rigidbody, where
    the other end of the joint tries to move.'
  id: totrans-412
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**目标**：在局部坐标系中定义，相对于刚体，关节的另一端试图移动的位置。'
- en: '**Auto Configure Target**: When checked, it sets the **Target** to the current
    position of the rigidbody, which is useful when our rigidbody is moved around,
    maybe driven by other forces. Furthermore, when this option is selected, the **Target**
    changes as you move the rigidbody; on the contrary, it won''t if the option is
    not selected.'
  id: totrans-413
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动配置目标**：当勾选时，将**目标**设置为刚体的当前位置，这在我们的刚体被移动时很有用，可能是由其他力驱动的。此外，当选择此选项时，**目标**会随着刚体的移动而改变；相反，如果没有选择此选项，则不会改变。'
- en: 'Moreover, it is possible to control the characteristic of the spring with the
    usual parameters:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，可以使用常规参数来控制弹簧的特性：
- en: '**Max Force**: This specifies the maximum force that the joint can use on the
    rigidbody'
  id: totrans-415
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大力**：这指定了关节可以对刚体使用的最大力'
- en: '**Damping Ratio**: This specifies how much the motion of the spring is suppressed
    (refer to either the *Spring 2D Joint* or *Fixed 2D Joint* section for more details)'
  id: totrans-416
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻尼比**：这指定了弹簧运动被抑制的程度（有关更多详细信息，请参阅*弹簧 2D 关节*或*固定 2D 关节*部分）'
- en: '**Frequency**: This specifies the frequency of the spring (refer to either
    the *Spring 2D Joint* or *Fixed 2D Joint* section for more details)'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频率**：这指定了弹簧的频率（有关更多详细信息，请参阅*弹簧 2D 关节*或*固定 2D 关节*部分）'
- en: An example of the use of this joint is when the player needs to drag objects
    with the mouse. In this scenario, you can set the target of the object dragged
    to the cursor, so it will follow the cursor, without having a rigid movement (as
    if we would set frame after frame the position of the object to the mouse coordinates).
    Moreover, you can use the **Anchor** to specify where the object should be attached.
    For instance, if the player started to drag from a corner of the object, you can
    set the **Anchor** to be there, and as a result, the object will hang from that
    point.
  id: totrans-418
  prefs: []
  type: TYPE_NORMAL
  zh: 此关节的一个使用示例是在玩家需要用鼠标拖动对象时。在这种情况下，你可以将拖动的对象的目标设置为光标，这样它就会跟随光标，而不会有一个刚性的运动（就像我们会逐帧设置对象的位置到鼠标坐标一样）。此外，你可以使用**锚点**来指定对象应该连接的位置。例如，如果玩家从对象的角落开始拖动，你可以将**锚点**设置为那里，结果，对象将从那个点悬挂。
- en: Note
  id: totrans-419
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: You can find this joint in one of the exercises of the last chapter to improve
    the look of your game.
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在上一章的某个练习中找到这个关节，以改善你游戏的外观。
- en: Wheel Joint 2D
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 轮关节 2D
- en: The Wheel Joint 2D is a combination of a spring and motor kind of joint, and
    it has a very specific usage. As the name suggests, it simulates the constraint
    that a wheel can impose on a body. In particular, it can rotate the wheel with
    a motor (the wheel moves) and simulate suspensions with a spring.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 轮关节 2D 是一种弹簧和马达类型关节的组合，它有非常特定的用途。正如其名所示，它模拟了车轮对物体施加的约束。特别是，它可以使用马达（车轮移动）旋转车轮，并使用弹簧模拟悬挂。
- en: More specifically, the joint applies a linear force to both connected rigid
    bodies to keep them on the line, an angular motor to rotate them on the line,
    and a spring to simulate the wheel suspension.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，关节对两个连接的刚体施加线性力以保持它们在一条线上，一个角马达以在线旋转它们，以及一个弹簧来模拟车轮悬挂。
- en: Note
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: It is interesting to note that you can reconstruct a **Wheel Joint 2D** with
    the combination of a **Slider Joint 2D** (with both **Use Motor** and **Use Limits**
    off) and a **Hinge Joint 2D** (with **Use Limits** off).
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 有趣的是，你可以通过组合**滑块关节 2D**（两个**使用马达**和**使用限制**都关闭）和**铰链关节 2D**（**使用限制**关闭）来重建**轮关节
    2D**。
- en: 'It appears like the following in the **Inspector**:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 它在**检查器**中看起来如下：
- en: '![Wheel Joint 2D](img/image00557.jpeg)'
  id: totrans-427
  prefs: []
  type: TYPE_IMG
  zh: '![轮关节 2D](img/image00557.jpeg)'
- en: As you can see from the preceding screenshot, the parameters are divided into
    **Suspension**, which defines a spring, and a motor. Both use the same parameters
    we have already seen respectively for springs (with the exception of **Angle**)
    and motors.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从前面的截图中所见，参数分为**悬挂**，它定义了一个弹簧和一个马达。两者都使用我们之前已经看到的相同参数（除了**角度**）和马达。
- en: 'The suspension is defined by the following:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 悬挂由以下定义：
- en: '**Angle**: This specifies the angle (in degrees in world coordinates) where
    the suspension happens. By default, it is set to `90` degrees, which means the
    suspension will happen upwards, as usually happens for a car (the body of the
    car is on top of the wheels, so the direction of the suspension is along the positive
    *y*-axis, which means 90 degrees) as shown in the following diagram:![Wheel Joint
    2D](img/image00558.jpeg)'
  id: totrans-430
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角度**：这指定了悬挂发生的角度（以世界坐标中的度数表示）。默认情况下，它设置为`90`度，这意味着悬挂将向上发生，就像通常发生的那样（汽车的车身位于车轮之上，因此悬挂的方向沿着正*y*轴，这意味着90度），如下面的图所示：![轮轴2D](img/image00558.jpeg)'
- en: In this diagram, we can see the the angle of the suspension for the wheel of
    the car is at 90 degrees, which means upwards in the game world. This is the default
    value. Imagine you want to have a car that is able to run on the ceiling thanks
    to magnetic wheels; you may consider changing the angle of the suspension. In
    the case of the ceiling, it is the opposite of the normal situation, so the angle
    will be 270 degrees.
  id: totrans-431
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个图中，我们可以看到汽车的轮子悬挂角度为90度，这意味着在游戏世界中向上。这是默认值。想象一下，如果你想有一辆能够通过磁力轮在天花板上行驶的汽车；你可能需要考虑改变悬挂的角度。在这种情况下，它与正常情况相反，因此角度将是270度。
- en: '**Damping Ratio**: This specifies how much the motion of the spring is suppressed
    (refer to either the *Spring 2D Joint* or *Fixed 2D Joint* section for more details).'
  id: totrans-432
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻尼比**：这指定了弹簧运动被抑制的程度（有关更多详细信息，请参阅*2D弹簧关节*或*固定2D关节*部分）。'
- en: '**Frequency**: This specifies the frequency of the spring (refer to either
    the *Spring 2D Joint* or *Fixed 2D Joint* section for more details).'
  id: totrans-433
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**频率**：这指定了弹簧的频率（有关更多详细信息，请参阅*2D弹簧关节*或*固定2D关节*部分）。'
- en: 'The motor is defined by:'
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 电机由以下定义：
- en: '**Motor Speed**: This specifies the speed that the motor should achieve on
    the wheel'
  id: totrans-435
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**电机速度**：这指定了电机在轮子上应达到的速度'
- en: '**Max Motor Force**: This specifies the maximum force that the motor can apply
    on the wheel in order to achieve **Motor Speed** on the wheel'
  id: totrans-436
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大电机力**：这指定了电机在轮子上施加的最大力，以便在轮子上达到**电机速度**'
- en: Needless to tell you which is the most common usage of this joint. Every time
    in your game you have a wheel and it needs to move in a realistic manner, this
    joint is the deal for you.
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 无需告诉你这个关节最常用的用途。每次在你的游戏中有一个轮子并且需要以逼真的方式移动时，这个关节就是你的最佳选择。
- en: Tip
  id: totrans-438
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you want to create a car controlled by the player, you can attach this joint
    to the wheels and set **Motor Speed** to `0` to control this variable through
    your script based on the player's input. Moreover, you can use **Max Motor Force**
    to simulate the different gears.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想创建一个由玩家控制的汽车，你可以将这个关节连接到车轮上，并将**电机速度**设置为`0`，以便通过你的脚本根据玩家的输入来控制这个变量。此外，你可以使用**最大电机力**来模拟不同的档位。
- en: Effectors
  id: totrans-440
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 效果器
- en: Imagine our hero is crossing an enchanted room, so he starts to float due a
    powerful spell. In this case, while the hero is within this room, gravity should
    be contrasted by a (magical) force. As a result, we need to specify that in that
    room, there is a force that makes our hero levitate.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 想象一下我们的英雄正在穿越一个魔法房间，因此他开始因为一个强大的咒语而漂浮。在这种情况下，当英雄在这个房间里时，重力应该被一种（魔法）力量所抵消。因此，我们需要指定在那个房间里，有一种使我们的英雄悬浮的力。
- en: Similarly, imagine the hero drops a box in a lake. The box doesn't sink at the
    same velocity as it falls; moreover, it might float. Therefore, in our game, we
    need to specify that the region delimited by the lake has special physical properties.
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，想象一下英雄在湖中扔下一个箱子。箱子不会以与它下落相同的速度下沉；此外，它可能会漂浮。因此，在我们的游戏中，我们需要指定湖所界定的区域具有特殊的物理属性。
- en: '![Effectors](img/image00559.jpeg)'
  id: totrans-443
  prefs: []
  type: TYPE_IMG
  zh: '![效果器](img/image00559.jpeg)'
- en: There are some special regions of the game world where the physical laws could
    be different from the rest of the game world; in Unity, these regions can be specified
    with effectors
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏世界中有一些特殊的区域，那里的物理定律可能与其他游戏世界不同；在Unity中，这些区域可以通过效果器来指定
- en: 'In Unity, this can be achieved by using effectors. Effectors are some components
    that affect the behaviour of rigidbodies in certain region of the game world.
    They are really different from each other, because they do different things, although
    the core concept is the same: they affect one or more rigidbodies that come into
    the region that they control.'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，这可以通过使用作用力来实现。作用力是一些组件，它们会影响游戏世界中特定区域刚体的行为。它们之间真的很不同，因为它们做不同的事情，尽管核心概念是相同的：它们影响一个或多个进入它们控制区域的刚体。
- en: Effectors use collision detection to know which are the rigidbodies within their
    region, and therefore, as we already mentioned before, the rigidbodies need to
    have a collider. Otherwise, they won't be affected by the effector.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 作用力使用碰撞检测来知道它们区域内有哪些刚体，因此，正如我们之前提到的，刚体需要有一个碰撞器。否则，它们不会受到作用力的影响。
- en: Moreover, the effectors themselves need their own collider to work. This, in
    order to be used by the effector they should have the **Used By Effector** property
    set to true. Otherwise, the effector will not affect any rigidbody. If the collider
    of the effector should be set to be the trigger or not depends both on the kind
    of effector and on what are you trying to achieve, although there is a default
    way to set it (in fact, Unity gives you a warning in case you are using the effector
    in an unusual way).
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，作用力本身也需要它们自己的碰撞器才能工作。为了被作用力使用，它们应该将**由作用力使用**属性设置为true。否则，作用力将不会影响任何刚体。作用力的碰撞器是否应该设置为触发器取决于作用力的类型以及你试图实现的目标，尽管有一个默认的方式去设置它（实际上，Unity会在你以不寻常的方式使用作用力时给你一个警告）。
- en: 'We will see this case by case, and here is a summary table with the effectors,
    saying whether the collider should use **is Trigger** or not:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将逐个分析，这里有一个总结表，列出了作用力，说明了是否应该使用**is Trigger**：
- en: '| **Effector** | **Linked collider should be a trigger?** |'
  id: totrans-449
  prefs: []
  type: TYPE_TB
  zh: '| **作用力** | **链接的碰撞器应该是触发器吗？** |'
- en: '| Constant Force 2D | This component is attached to rigidbodies, not colliders
    |'
  id: totrans-450
  prefs: []
  type: TYPE_TB
  zh: '| 二维恒力 | 此组件连接到刚体，而不是碰撞器 |'
- en: '| Area Effector 2D | True |'
  id: totrans-451
  prefs: []
  type: TYPE_TB
  zh: '| 区域作用力2D | True |'
- en: '| Buoyancy Effector 2D | True |'
  id: totrans-452
  prefs: []
  type: TYPE_TB
  zh: '| 浮力作用力2D | True |'
- en: '| Point Effector 2D | True |'
  id: totrans-453
  prefs: []
  type: TYPE_TB
  zh: '| 点作用力2D | True |'
- en: '| Platform Effector 2D | False |'
  id: totrans-454
  prefs: []
  type: TYPE_TB
  zh: '| 平台作用力2D | False |'
- en: '| Surface Effector 2D | False |'
  id: totrans-455
  prefs: []
  type: TYPE_TB
  zh: '| 表面作用力2D | False |'
- en: 'All of them (with the exception of Constant Force 2D) have a couple of variables
    to determine which rigidbodies are affected by the effector, and these variables
    are:'
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些（除了二维恒力之外）都有几个变量来确定哪些刚体受到作用力的影响，这些变量是：
- en: '**Use Collider Mask**: If enabled, this allows you to discriminate the colliders
    that enter in the area through layers specified in the next variable.'
  id: totrans-457
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用碰撞器掩码**：如果启用，这允许你通过在下一个变量中指定的层来区分进入区域的碰撞器。'
- en: '**Collider Mask**: This determines which layers are affected by the effector.
    Once again, remember that you can learn how to add layers in [Chapter 2](part0028.xhtml#aid-QMFO1
    "Chapter 2. Baking Cupcake Towers"), *Baking Cupcake Towers* . So, in this variable,
    you can specify one of them through the use of a drop-down menu.'
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞器掩码**：这决定了哪些层会受到作用力的影响。再次提醒，你可以通过[第2章](part0028.xhtml#aid-QMFO1 "第2章。制作纸杯蛋糕塔")，*制作纸杯蛋糕塔*来学习如何添加层。因此，在这个变量中，你可以通过使用下拉菜单来指定其中一个。'
- en: Let's see each one of them in detail to better understand how they work.
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细看看每一个，以便更好地理解它们是如何工作的。
- en: Constant Force 2D
  id: totrans-460
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 二维恒力
- en: This is not a proper effector, because instead of acting in an area or region,
    it is directly applied onto a rigidbody. So it needs to be attached to the same
    game object that has the rigidbody component.
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是一个合适的作用力，因为它不是在区域或区域内起作用，而是直接作用于刚体。因此，它需要连接到具有刚体组件的同一游戏对象。
- en: 'Here is how it appears in the **Inspector**:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 在**检查器**中，它看起来是这样的：
- en: '![Constant Force 2D](img/image00560.jpeg)'
  id: totrans-463
  prefs: []
  type: TYPE_IMG
  zh: '![二维恒力](img/image00560.jpeg)'
- en: Note
  id: totrans-464
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Out of curiosity, for this component, there is a 3D counterpart: **Constant
    Force**.'
  id: totrans-465
  prefs: []
  type: TYPE_NORMAL
  zh: 出于好奇，对于这个组件，有一个3D对应物：**恒力**。
- en: As the name suggests, it applies a constant force to the rigidbody. Usually
    this is used in testing to easily apply a force from the **Inspector**, but it
    can also be used in the normal gameplay if we need an object that is always under
    the control of a constant force (so that it will keep pushing). Of course, it's
    value can be changed through script to make it a non-constant force, but in that
    case it is preferable to apply the force directly with a function in the script.
    The component should be used only for constant forces or forces that don't change
    over time (the force can change, but for long periods of time it remains constant).
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，它对刚体施加恒定力。通常这用于测试，以便容易地从 **检查器** 中施加力，但也可以在正常游戏玩法中使用，如果我们需要一个始终受到恒定力控制的物体（这样它就会持续推动）。当然，其值可以通过脚本更改以使其成为非恒定力，但在那种情况下，最好通过脚本中的函数直接施加力。该组件应仅用于恒定力或随时间不改变的力（力可以改变，但长时间内保持恒定）。
- en: Moreover, this component also can be used to apply a torque on the rigidbody.
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，此组件还可以用于对刚体施加扭矩。
- en: 'Here are the three variables:'
  id: totrans-468
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是三个变量的示例：
- en: '**Force**: The constant force to apply to the rigidbody.'
  id: totrans-469
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力**: 施加到刚体上的恒定力。'
- en: '**Relative Force**: The constant force to apply to the rigidbody expressed
    with respect to the rigidbody coordinates'
  id: totrans-470
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**相对力**: 以刚体坐标为基准施加到刚体上的恒定力'
- en: '**Torque**: The constant torque to apply to the rigidbody'
  id: totrans-471
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扭矩**: 施加到刚体上的恒定扭矩'
- en: Here is an example of usage that is not testing. Suppose you are doing a game
    where different objects are affected by different gravitational forces. So for
    instance, brown boxes will follow on the ground as usual, but green boxes will
    follow on the right because as per your game design they are supposed to do so.
    The reason could be an experimental serum invented to change gravity for things
    that are green. In this scenario, the green boxes cannot be affected by normal
    gravity, so you can place on them a rigidbody and set **Gravity Scale** to `0`.
    In this way, it won't be affected by normal gravity. Then, place on it the **Constant
    2D** force component and set your gravity. Moreover, if all the objects have different
    **Constant 2D** forces, you can change their gravity force in real time, maybe
    after the invention of another serum, which changes the gravity on the left instead
    of the right.
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个非测试用例的示例。假设你正在制作一个游戏，其中不同的物体受到不同的重力影响。例如，棕色箱子将像往常一样在地面上跟随，但绿色箱子将向右跟随，因为根据你的游戏设计，它们应该这样做。原因可能是一种实验性血清，用于改变绿色物体的重力。在这种情况下，绿色箱子不能受到正常重力的影响，因此你可以在它们上面放置一个刚体并将
    **重力缩放** 设置为 `0`。这样，它就不会受到正常重力的影响。然后，放置 **恒定 2D** 力组件并设置你的重力。此外，如果所有物体都有不同的 **恒定
    2D** 力，你可以在实时更改它们的重力力，也许是在发明另一种血清之后，这种血清改变了左边的重力而不是右边。
- en: Area Effector 2D
  id: totrans-473
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 面积效应器 2D
- en: This component defines an area within which a force is applied to all the rigidbodies
    inside the area. You can configure the force at any angle with a specific magnitude
    and random variation on that magnitude. You can also apply both linear and angular
    drag forces to slow down rigidbody 2Ds.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件定义了一个区域，在该区域内对区域内的所有刚体施加力。你可以配置以特定大小和在该大小上的随机变化的角度的力。你还可以施加线性拖动力和角拖动力来减慢刚体
    2D 的速度。
- en: This effector, in order to work, requires a collider with both **Used By Effector**
    and **is Trigger** set to true. In fact, rigidbodies should be able to enter in
    it.
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: 为了工作，此效应器需要一个具有 **Used By Effector** 和 **is Trigger** 都设置为 true 的碰撞器。实际上，刚体应该能够进入其中。
- en: 'The component has two foldouts (expandable menu options) for the relative options
    to set, **Force** and **Damping**, as we can see from this diagram, which shows
    the component in the **Inspector**:'
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件有两个折叠菜单（可展开的菜单选项）用于设置相对选项，**力** 和 **阻尼**，正如我们从这张图中可以看到的，它显示了 **检查器** 中的组件：
- en: '![Area Effector 2D](img/image00561.jpeg)'
  id: totrans-477
  prefs: []
  type: TYPE_IMG
  zh: '![面积效应器 2D](img/image00561.jpeg)'
- en: Note
  id: totrans-478
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The two foldouts appear only in recent versions of Unity. So if you are using
    an old version and you don't see them, don't worry; the options have just been
    reordered, but they still work as described here.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 这两个折叠菜单只出现在 Unity 的最新版本中。所以如果你使用的是旧版本并且没有看到它们，请不要担心；选项只是重新排序了，但它们仍然按此处描述的方式工作。
- en: 'All the variables have intuitive names, but let''s go through them quickly:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 所有变量都有直观的名称，但让我们快速浏览一下：
- en: '**Use Global Angle**: If checked, the next variable will be interpreted in
    the world coordinates, and local coordinates otherwise.'
  id: totrans-481
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用全局角度**：如果勾选，则下一个变量将在世界坐标中解释，否则在局部坐标中。'
- en: '**Force Angle**: This is the angle of the force to apply, and so it defines
    the direction.'
  id: totrans-482
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力角度**：这是要应用力的角度，因此它定义了方向。'
- en: '**Force Magnitude**: This is the magnitude, which means the intensity of the
    force.'
  id: totrans-483
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力大小**：这是大小，意味着力的强度。'
- en: '**Force Variation**: This is the variation of the magnitude of the force so
    as to not have always a constant force and improve realism. Be careful not to
    give too high value, which may quickly result in undesired behaviour.'
  id: totrans-484
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力变化**：这是力大小的变化，以便不是始终有恒定的力并提高现实感。请注意不要给出过高值，这可能会导致不希望的行为。'
- en: '**Force Target**: This can be either the **Rigidbody** or **Collider**. In
    the first case, the force will always be applied to the center of the mass. In
    the second case, if the collider is not on the center of the mass, the force will
    also generate torque for the rigidbody.'
  id: totrans-485
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力目标**：这可以是**刚体**或**碰撞器**。在第一种情况下，力将始终作用于质心。在第二种情况下，如果碰撞器不在质心上，力也会为刚体产生扭矩。'
- en: '**Drag**: This is the linear drag to apply within the region.'
  id: totrans-486
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻力**：这是在区域内部应用线性阻力。'
- en: '**Angular Drag**: This is the angular drag to apply within the region.'
  id: totrans-487
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角阻力**：这是在区域内部应用的角度阻力。'
- en: Here is an example of the use of this component. Suppose that there is a special
    device which is able to push the magnetic shoes of the main character to contrast
    gravity. So, in the area just above this device, you can place an area effector,
    specifying a force that goes upwards. Please note that if the intensity of the
    force is less than the gravity, then your character will have a big jump, but
    eventually she will fall down. Whereas with a greater value, even without a jump
    she starts to levitate upwards until either an obstacle or the end of the area
    effector is met.
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是一个使用此组件的例子。假设有一个特殊的设备，能够推动主角的磁性鞋子以对抗重力。因此，在这个设备正上方的区域，您可以放置一个区域效应用户指定向上的力。请注意，如果力的强度小于重力，那么您的角色将会有一个大跳跃，但最终她会掉下来。而如果力值更大，即使没有跳跃，她也会开始向上漂浮，直到遇到障碍物或区域效应用户指定结束。
- en: Buoyancy Effector 2D
  id: totrans-489
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Buoyancy Effector 2D
- en: This component is used to simulate a fluid, and so it can potentially make rigidbodies
    floating. It requires a collider with both **Used By Effector** and **is Trigger**
    set to true. In fact, rigidbodies should be able to enter it.
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件用于模拟流体，因此它可以使刚体漂浮。它需要一个同时设置了**由效应用户使用**和**是触发器**的碰撞器。实际上，刚体应该能够进入它。
- en: 'It appears like the following in the **Inspector**:'
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 它在**检查器**中看起来如下：
- en: '![Buoyancy Effector 2D](img/image00562.jpeg)'
  id: totrans-492
  prefs: []
  type: TYPE_IMG
  zh: '![Buoyancy Effector 2D](img/image00562.jpeg)'
- en: Note
  id: totrans-493
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As we can see from this screenshot, there are two foldouts to help the logical
    order of the component. Don't worry if they aren't there. You may be using an
    older version of Unity.
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 从这张截图我们可以看到，有两个折叠部分有助于组件的逻辑顺序。如果它们不在那里，请不要担心。您可能在使用Unity的较旧版本。
- en: 'The main variables are the following:'
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 主要变量如下：
- en: '**Density**: This indicates the density of the fluid, and it affects how the
    different rigidbodies are affected by the effector depending on the rigidbody
    density as well. In fact, rigidbodies with a higher density will sink, those with
    a lower density will float, and those with the same density of the fluid will
    be suspended in the fluid.'
  id: totrans-496
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**密度**：这表示流体的密度，并且它会影响不同刚体根据刚体密度受到效应对象的影响。实际上，密度较高的刚体会下沉，密度较低的刚体会漂浮，而与流体密度相同的刚体将在流体中悬浮。'
- en: '**Surface Level**: This indicates where the surface of the fluid is with respect
    to the Transform (the position) of the game object where the effector is attached.
    A value of zero means that the surface will lie on the center of the object, and
    it is placed in the middle of the collider (only if the collider doesn''t have
    any offset). You can recognize it from the blue line in the **Scene** view.'
  id: totrans-497
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表面水平**：这表示流体表面相对于附加效应对象的Transform（位置）的位置。零值表示表面将位于物体的中心，并且它位于碰撞器的中间（仅当碰撞器没有偏移时）。您可以从**场景**视图中的蓝色线条中识别它。'
- en: '**Drag**: This is the linear drag to apply within the region below the surface.'
  id: totrans-498
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻力**：这是在表面下方区域内部应用的线性阻力。'
- en: '**Angular Drag**: This is the angular drag to apply within the region below
    the surface.'
  id: totrans-499
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角阻力**：这是在表面下方区域应用的角度阻力。'
- en: '**Flow Angle**: This specifies the angle, in world coordinates, where the flow
    force of the effector is applied. Therefore, it defines the direction of the force.'
  id: totrans-500
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流动角度**：这指定了力场流动力应用的世界坐标角度。因此，它定义了力的方向。'
- en: '**Flow Magnitude**: This specifies the intensity of the flow force, and therefore
    the level of buoyancy of the effector. It can assume negative values, and in this
    case, it''s as if **Flow Angle** has been rotated by 180 degrees.'
  id: totrans-501
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流动大小**：这指定了流动力的强度，因此力场的浮力水平。它可以取负值，在这种情况下，就像**流动角度**旋转了180度一样。'
- en: '**Flow Variation**: This indicates how much **Flow Magnitude** can vary, so
    as to not have it constant and therefore achieving a higher level of realism.'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**流动变化**：这表示**流动大小**可以变化多少，以便不是恒定的，从而实现更高的现实感。'
- en: 'The component appears like this in the **Scene** view, to actually show where
    the surface level is:'
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: 在**场景**视图中，组件看起来是这样的，以实际显示表面层级：
- en: '![Buoyancy Effector 2D](img/image00563.jpeg)'
  id: totrans-504
  prefs: []
  type: TYPE_IMG
  zh: '![Buoyancy Effector 2D](img/image00563.jpeg)'
- en: Furthermore, here is an example of its usage. Suppose that in your 2D game there
    is the sea, and the main character has to jump on some platforms in the harbor.
    Placing this effector at the level of the sea will make its behaviour more realistic.
    For instance, the main character can push a wooden box down in the sea, which
    will float, and so she can jump on top of the floating box to cross.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这里是其使用的一个示例。假设在你的2D游戏中有一个海洋，主要角色必须跳到港口的一些平台上。将此力场放置在海洋水平将使其行为更加逼真。例如，主要角色可以将一个木箱推入海中，使其浮起，然后她可以跳到浮动的箱子上以穿越。
- en: '![Buoyancy Effector 2D](img/image00564.jpeg)'
  id: totrans-506
  prefs: []
  type: TYPE_IMG
  zh: '![Buoyancy Effector 2D](img/image00564.jpeg)'
- en: An example of use of the Buoyancy Effector 2D, which is able to simulate the
    sea and make the wooden boxes float; as a result, the player can jump on top of
    the wooden box and cross the sea
  id: totrans-507
  prefs: []
  type: TYPE_NORMAL
  zh: Buoyancy Effector 2D的一个使用示例，它可以模拟海洋并使木箱浮起；因此，玩家可以跳到木箱上并穿越海洋
- en: Point Effector 2D
  id: totrans-508
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 点力场2D
- en: You can imagine this component to be a magnet of rigidbodies, so it can push/repulse
    or attract them, which is concentrated at a single point, as the name of the effector
    suggests. The point can be determined by either the collider (most used) or the
    rigidbody attached to the same game object of the effector.
  id: totrans-509
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以将这个组件想象成一个刚体的磁铁，因此它可以推动/排斥或吸引它们，就像力场的名字所暗示的那样，集中在一个点上。这个点可以通过碰撞器（最常用）或附加到力场相同游戏对象的刚体来确定。
- en: The component requires a collider with both **Used By Effector** and **is Trigger**
    set to true. In fact, rigidbodies should be able to enter in it.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 组件需要一个具有**由力场使用**和**是触发器**设置为true的碰撞器。实际上，刚体应该能够进入其中。
- en: 'It appears like this in the **Inspector**:'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 它在**检查器**中看起来是这样的：
- en: '![Point Effector 2D](img/image00565.jpeg)'
  id: totrans-512
  prefs: []
  type: TYPE_IMG
  zh: '![Point Effector 2D](img/image00565.jpeg)'
- en: Note
  id: totrans-513
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once again, the foldouts are only in recent versions of Unity.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，展开图只存在于Unity的最近版本中。
- en: 'The main variables are the following:'
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 主要变量如下：
- en: '**Force Magnitude**: The magnitude, which means the intensity of the force.'
  id: totrans-516
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力的大小**：力的大小，即力的强度。'
- en: '**Force Variation**: The variation of the magnitude of the force in order not
    to always have a constant force and improve realism. Be careful not to give too
    high value, which may quickly result in undesired behaviours.'
  id: totrans-517
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力变化**：力的强度变化，以便不是始终有恒定的力并提高现实感。注意不要给出过高值，这可能会导致不希望的行为。'
- en: '**Distance Scale**: When the distance between the rigidbody and the attractive
    or repulsive point is calculated, it is scaled by (multiplied by) **Distance Scale**.
    As such, you are able to modify the behaviour of the effector (see **Force Mode**
    in this list).'
  id: totrans-518
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**距离缩放**：当计算刚体和吸引或排斥点之间的距离时，它会被**距离缩放**缩放（乘以）。这样，你可以修改力场的行为（参见此列表中的**力模式**）。'
- en: '**Force Source**: This can be either a **Rigidbody** or **Collider**. In the
    first case, the point that attracts or repulses will be placed on the center of
    the rigidbody (which means at its center of the mass). In the second case, it
    will be placed in the middle of the collider.'
  id: totrans-519
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力源**：这可以是**刚体**或**碰撞器**。在第一种情况下，吸引或排斥的点将放置在刚体的中心（这意味着在其质心）。在第二种情况下，它将放置在碰撞器的中间。'
- en: '**Force Target**: This can be either a **Rigidbody** or **Collider**. In the
    first case, the force will always be applied to the center of the mass of the
    rigidbody entering in the effector. In the second case, if the collider is not
    centered on the center of the mass, the force will also generate torque for the
    rigidbody.'
  id: totrans-520
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力目标**：这可以是**刚体**或**碰撞器**。在第一种情况下，力将始终应用于进入效应器的刚体的质心。在第二种情况下，如果碰撞器没有在质心中心，力也会为刚体产生扭矩。'
- en: '**Force Mode**: This specifies how the force is calculated, and it can be of
    three types. **Constant** is the most intuitive. The force is always constant
    regardless of the distance between the rigidbody affected by the effector and
    the point that repulses or attracts. This means that only the relative positions
    between the rigidbody and the point are taken into consideration to determine
    the direction of the force, which lies on both. Instead, in **Inverse Linear**,
    the force changes its intensity based on the distance between the rigidbody and
    the point. For double the distance, half intensity of the force. Finally, **Inverse
    Squared**, which in most cases is the most physically realistic, takes the square
    of the distance into consideration. This means, for double the distance, a quarter
    the intensity of the force.![Point Effector 2D](img/image00566.jpeg)'
  id: totrans-521
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**力模式**：这指定了力的计算方式，它可以是三种类型之一。**恒定**是最直观的。力始终是恒定的，无论受到效应器影响的刚体与排斥或吸引点之间的距离如何。这意味着只有刚体和点之间的相对位置被考虑来确定力的方向，该方向位于两者之间。相反，在**逆线性**中，力根据刚体和点之间的距离改变其强度。距离加倍，力强度减半。最后，**逆平方**，这在大多数情况下是最物理现实的，考虑了距离的平方。这意味着距离加倍，力强度减为四分之一。![点效应器
    2D](img/image00566.jpeg)'
- en: Differences between the different force modes
  id: totrans-522
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 不同力模式之间的差异
- en: In this diagram, on the left is a repulsive point effector. Below is a distance
    scale, all included within the range of the point effector. Suppose that at a
    distance of half alpha, three different rigidbodies have the same applied force
    from the point of effect. At a distance of alpha, the constant mode will keep
    its whole force applied on the rigidbody. The **Inverse Linear** mode will halve
    the force by doubling the distance. Finally, the **Inversed Squared** mode (which
    is the most physically realistic, since both the gravitation and the electromagnetic
    forces have this behaviour) will have a quarter of the force it would have half
    way closer to the point effector.
  id: totrans-523
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在这个图中，左边是一个排斥点效应器。下面是一个距离刻度，所有这些都包含在点效应器的范围内。假设在距离半alpha处，三个不同的刚体从效应点的位置受到相同的应用力。在alpha距离处，恒定模式将保持其全部力应用于刚体。**逆线性**模式将力减半，因为距离加倍。最后，**逆平方**模式（这是最物理现实的，因为重力和电磁力都有这种行为）将力强度减为距离一半处的四分之一。
- en: '**Drag**: This is the linear drag to apply within the region of the effector.'
  id: totrans-524
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阻力**：这是在效应器区域内要应用的线性阻力。'
- en: '**Angular Drag**: This is the angular drag to apply within the region of the
    effector.'
  id: totrans-525
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**角阻力**：这是在效应器区域内要应用的角阻力。'
- en: Here is an example of its usage. Suppose the main character has a special ring
    that, when active, attracts metal (when the ring is not, it will attract the main
    character's wife). Therefore, every time that the player activates the ring, the
    game activates a point effector on the main character, and through the **Collision
    Mask** variable, only metals can be selected.
  id: totrans-526
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是它用法的一个例子。假设主要角色有一个特殊的戒指，当激活时，会吸引金属（当戒指未激活时，它会吸引主要角色的妻子）。因此，每当玩家激活戒指时，游戏就会在主要角色上激活一个点效应器，并通过**碰撞掩码**变量，只可以选择金属。
- en: Platform Effector 2D
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 平台效应器 2D
- en: This component gives the effect of a platform for 2D games. For instance, it
    implements the one-way collision. So if the character jumps from below the platform,
    he will cross it, but when he lands on top, the platform will give a collision,
    maintaining the character on top of the platform. Moreover, it can be used to
    remove side-friction/bounce.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件为2D游戏提供了一个平台效果。例如，它实现了单向碰撞。所以如果角色从平台下方跳起，他将穿越平台，但当他落在平台上时，平台将产生碰撞，保持角色在平台上方。此外，它可以用来去除侧面摩擦/反弹。
- en: '![Platform Effector 2D](img/image00567.jpeg)'
  id: totrans-529
  prefs: []
  type: TYPE_IMG
  zh: '![平台效应器 2D](img/image00567.jpeg)'
- en: With this effector, the player is able to cross a collider in one direction
    but not the other way round. In some platform games, the player is able to jump
    on top of the platform by jumping underneath it, but he or she cannot fall back.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个效应器，玩家可以单向穿越碰撞器，但不能反向穿越。在一些平台游戏中，玩家可以从下面跳到平台上，但不能从上面跳下来。
- en: In fact, this is the most used component to build platform games. Think about
    games like *Braid*, where the player is able to jump on top of a platform from
    a platform that is underneath.
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，这是构建平台游戏最常用的组件。想想像《Braid》这样的游戏，玩家可以从下面的平台上跳到上面的平台上。
- en: The component requires a collider with **Used By Effector** set to true but
    not **is Trigger**. In fact, rigidbodies should be able to collide with it.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 该组件需要一个设置为**由效应器使用**但不是**是触发器**的碰撞器。实际上，刚体应该能够与之碰撞。
- en: 'This is how it appears in the **Inspector**:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它在**检查器**中的显示方式：
- en: '![Platform Effector 2D](img/image00568.jpeg)'
  id: totrans-534
  prefs: []
  type: TYPE_IMG
  zh: '![平台效应器 2D](img/image00568.jpeg)'
- en: Note
  id: totrans-535
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Once again, the foldouts are present only in recent versions of Unity. Moreover,
    the rotational offset is a parameter that has been added recently.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，展开项仅存在于 Unity 的最新版本中。此外，旋转偏移是一个最近添加的参数。
- en: And here you can see one possible instance in the **Scene** view of this component.
  id: totrans-537
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你可以看到这个组件在**场景视图**中的一个可能实例。
- en: '![Platform Effector 2D](img/image00569.jpeg)'
  id: totrans-538
  prefs: []
  type: TYPE_IMG
  zh: '![平台效应器 2D](img/image00569.jpeg)'
- en: This is how the effector appears in the Scene view when its gizmos are active
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 这是在其 Gizmo 激活时在场景视图中显示的效应器。
- en: The big arc on top defines from which direction the platform/collider is not
    traversable, whereas the two small side arcs define which direction is considered
    the side of the platform.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 顶部的较大弧线定义了平台/碰撞器不可穿越的方向，而两侧的两个小弧线定义了平台的一侧。
- en: 'The main variables are the following:'
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 主要变量如下：
- en: '**Rotational Offset**: This indicates the angular offset in degrees of the
    whole platform effector. This has been added recently in Unity, and thanks to
    it, it is possible to rotate the platform effector so as to have platforms that
    are inclined, or walls that can be crossed one way. For instance, you can use
    it also for magical portals that can be crossed one way.'
  id: totrans-542
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**旋转偏移**：这表示整个平台效应器的角度偏移（以度为单位）。这是最近在 Unity 中添加的，多亏了它，可以旋转平台效应器，使其平台倾斜，或者墙壁可以单向穿越。例如，你也可以用它来创建单向穿越的魔法传送门。'
- en: '**Use One Way**: If checked, the platform will collide only in one direction.'
  id: totrans-543
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用单向**：如果勾选，平台将只在单向发生碰撞。'
- en: '**Use One Way Grouping**: This ensures that all contacts disabled by the one-way
    behaviour act on all colliders. This is useful when multiple colliders are used
    on the object passing through the platform and they all need to act together as
    a group.'
  id: totrans-544
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用单向分组**：这确保了所有由单向行为禁用的接触都会作用于所有碰撞器。当在穿过平台的对象上使用多个碰撞器，并且它们都需要作为一个组一起作用时，这很有用。'
- en: '**Surface Arc**: This specifies in degrees how wide the arc on top of which
    the collision will be performed is. In all the other directions, if **Use One
    Way** is enabled, it won''t allow any collision, allowing any rigidbody to pass
    through, such as your character.'
  id: totrans-545
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**表面弧线**：这指定了在顶部进行碰撞的弧线的宽度（以度为单位）。在其他所有方向上，如果**使用单向**被启用，则不允许任何碰撞，允许任何刚体通过，例如你的角色。'
- en: '**Use Side Friction**: If true, friction is applied to the side of the platform
    effector.'
  id: totrans-546
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用侧面摩擦**：如果为真，则对平台效应器的侧面应用摩擦。'
- en: '**Use Side Bounce**: If true, bounce is applied to the side of the platform
    effector.'
  id: totrans-547
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用侧面弹跳**：如果为真，则对平台效应器的侧面应用弹跳。'
- en: '**Side Arc**: This specifies the degree for both the right and left side (if
    the **Rotational Offset** is set to `0`; otherwise it may indicate up and down)
    that are considered the sides of the platform effector. So, if **Use Side Friction****or**
    and **Use Side Bounce** is enabled, this will be applied along the arc specified
    here.'
  id: totrans-548
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**侧面弧线**：这指定了平台效应器两侧（如果**旋转偏移**设置为`0`；否则可能表示上下）的度数，这些被认为是平台效应器的一侧。因此，如果**使用侧面摩擦**或**使用侧面弹跳**被启用，这将应用于此处指定的弧线上。'
- en: 'Besides the classical use of this component to create platform games, let''s
    see another example in which we may want to use it. Imagine a puzzle game where
    some portals can be crossed only in one direction. As such, we can place a platform
    effector and set its **Rotational Offset** so as to have the colliding part only
    on one side of the portal. As a result, the character will be able to cross the
    magical portal only in one direction, and not in the other way round as shown
    in the following diagram:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 除了使用这个组件创建平台游戏的传统用途之外，让我们看看另一个可能需要使用它的例子。想象一个解谜游戏，其中一些传送门只能单向穿越。因此，我们可以放置一个平台效应器，并设置其**旋转偏移**，以便只有传送门的一侧发生碰撞。结果，角色只能单向穿越魔法传送门，而不能像以下图中所示的反方向穿越：
- en: '![Platform Effector 2D](img/image00570.jpeg)'
  id: totrans-550
  prefs: []
  type: TYPE_IMG
  zh: '![平台效应器 2D](img/image00570.jpeg)'
- en: This is an example of how it is possible to use this effector in another way
    that is not the classical platform. By rotating the component through the **Rotational
    Offset**, it is possible to make a magical portal which is crossable in one way,
    but not in another. This could be an interesting game mechanic for a puzzle game.
  id: totrans-551
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是如何以另一种方式使用这个效应器，而不是传统的平台方式的一个例子。通过旋转组件的**旋转偏移**，可以制作一个单向可穿越但另一方向不可穿越的魔法传送门。这可能是一个解谜游戏中的有趣游戏机制。
- en: Surface Effector 2D
  id: totrans-552
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 表面效应器 2D
- en: This component applies a tangential force to the surface specified by the collider
    associated with this effector. In other words, you can imagine this as a conveyor
    belt, which transports rigidbodies along the direction of the force, as far as
    they are touching the surface.
  id: totrans-553
  prefs: []
  type: TYPE_NORMAL
  zh: 此组件将切向力应用到由与该效应器关联的碰撞器指定的表面上。换句话说，您可以将其想象成一个传送带，它将刚体沿着力的方向运输，只要它们接触表面。
- en: 'This is how it appears in the **Inspector**:'
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是它在**检查器**中的样子：
- en: '![Surface Effector 2D](img/image00571.jpeg)'
  id: totrans-555
  prefs: []
  type: TYPE_IMG
  zh: '![表面效应器 2D](img/image00571.jpeg)'
- en: 'It is possible to have access to the options of the **Surface Effector 2D**
    through two foldouts, and you can find the parameter that you can set here:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过两个折叠菜单访问**表面效应器 2D**的选项，并且您可以找到这里可以设置的参数：
- en: '**Speed**: The speed that the tangential force should maintain. In other words,
    it''s the speed of the conveyor belt.'
  id: totrans-557
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度**：切向力应保持的速度。换句话说，它是传送带的速度。'
- en: '**Speed Variation**: The maximum variation of the speed, so as to not have
    always a constant speed, especially if you have many of these effectors. The random
    variation ranges from zero to the value in **Speed Variation**. Therefore, a positive
    value brings a random increment, whereas a negative value brings a random decrement.'
  id: totrans-558
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度变化**：速度的最大变化，以便不是始终有恒定的速度，尤其是如果您有很多这样的效应器。随机变化范围从零到**速度变化**中的值。因此，正值带来随机的增量，而负值带来随机的减量。'
- en: '**Speed Scale**: This allows you to scale the tangential force that is applied
    when the effector tries to accelerate the contacting rigidbodies to the specified
    speed along the surface. If it is set to `0`, then no force is actually applied,
    and it is like that the component is disabled. On the other hand, if it is set
    to `1`, means that the full force is applied. A useful way to think of this parameter
    is to think about how fast the rigidbody, which is in contact with the surface,
    is then accelerated to meet the specified speed; lower values means it will require
    more time, whereas higher values means it will reach the speed much quicker. However,
    you should be careful to use the full force, since a rigidbody might face other
    forces, leading the rigidbody to an undesired motion.'
  id: totrans-559
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度缩放**：这允许您缩放当效应器尝试将接触的刚体加速到沿表面的指定速度时施加的切向力。如果设置为`0`，则实际上不会应用任何力，这就像组件被禁用一样。另一方面，如果设置为`1`，则表示施加了全部力量。考虑这个参数的一个有用方法是考虑与表面接触的刚体加速到指定速度的速度有多快；较低的值意味着需要更多的时间，而较高的值意味着可以更快地达到速度。然而，您应该小心使用全部力量，因为刚体可能会遇到其他力，导致刚体产生不希望的运动。'
- en: '**Use Contact Force**: If true, a contact force will be used. Although it is
    more physically realistic, it may impress a torque to the rigidbody contacting
    the surface. As such, in video games where realism depends on the design, you
    can choose to enable it, since the default is disabled. An easy way to imagine
    this is that you are jumping on a real conveyor belt. The contact force along
    with the tangential force of the conveyor belt will make your legs move forward,
    but your chest will stay behind due to inertia, which may result in you falling.
    That means your body has started to rotate due a torque as shown in the following
    diagram:![Surface Effector 2D](img/image00572.jpeg)'
  id: totrans-560
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用接触力**：如果为真，将使用接触力。尽管这更符合物理现实，但它可能会对接触表面的刚体施加扭矩。因此，在现实感取决于设计的视频游戏中，你可以选择启用它，因为默认是禁用的。一个简单的想象方法是，你正在一个真正的传送带上跳跃。传送带的接触力和切向力会使你的腿向前移动，但由于惯性，你的胸部会保持在后面，这可能会导致你跌倒。这意味着你的身体已经开始因为扭矩而旋转，如下面的图所示：![表面感应器
    2D](img/image00572.jpeg)'
- en: In this example, when you jump on the conveyor belt, your legs are brought forward
    by the tangential force of the belt. Your chest, instead, stays behind due to
    inertia, leading to an applied torque on your body, and therefore you will fall.
    In Unity, it is possible to disable the contact force, so as to ensure that a
    torque is not applied to rigidbodies that enter in contact with the conveyor belt.
  id: totrans-561
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，当你跳上传送带时，你的腿会被传送带的切向力向前推。而你的胸部由于惯性而保持在后面，导致对你的身体施加了扭矩，因此你会跌倒。在 Unity
    中，可以禁用接触力，以确保进入与传送带接触的刚体不会受到扭矩。
- en: '**Use Friction**: If true, there will be friction on the surface'
  id: totrans-562
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用摩擦力**：如果为真，表面将有摩擦力'
- en: '**Use Bounce**: If true, there will be bounce on the surface'
  id: totrans-563
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**使用弹力**：如果为真，表面将有弹力'
- en: Of course, the natural example of usage is when in your game a conveyor belt
    is used. But let's try to find out another example. Suppose that the protagonist
    of your game has a special glove that when it touches a metal wall, it is able
    to contrast gravity by creating a magnetic field. You can place a surface effector
    vertically, and apply a force upwards as far as the player is touching that wall.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，自然的使用例子是在你的游戏中使用传送带。但让我们尝试找到另一个例子。假设你的游戏的主角有一个特殊的手套，当它接触金属墙时，能够通过产生磁场来对抗重力。你可以垂直放置一个表面感应器，并向上施加力，直到玩家触摸到那堵墙。
- en: Physics Material 2D
  id: totrans-565
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理材料 2D
- en: Unity also offers the possibility to create physics materials so as to adjust
    the friction and bounciness of a physical object when it collides with another
    one. In the case of 2D, this is enabled by the **Physics Material 2D**.
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 还提供了创建物理材料的功能，以便在物理对象与另一个对象碰撞时调整其摩擦力和弹性。在 2D 情况下，这是通过 **Physics Material
    2D** 实现的。
- en: 'You can create a **Physics Material 2D** by selecting **Assets | Create | Physics
    Material 2D** from the top-bar menu as shown in the following screenshot:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过从顶部菜单选择 **Assets | Create | Physics Material 2D** 来创建一个 **Physics Material
    2D**，如下面的截图所示：
- en: '![Physics Material 2D](img/image00573.jpeg)'
  id: totrans-568
  prefs: []
  type: TYPE_IMG
  zh: '![物理材料 2D](img/image00573.jpeg)'
- en: 'Once selected in the project panel, we can tweak its two values in the **Inspector**,
    as shown here:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦在项目面板中选中，我们可以在 **Inspector** 中调整其两个值，如下所示：
- en: '![Physics Material 2D](img/image00574.jpeg)'
  id: totrans-570
  prefs: []
  type: TYPE_IMG
  zh: '![物理材料 2D](img/image00574.jpeg)'
- en: 'It''s worthwhile mentioning that we have seen many variables during this chapter
    to assign a **Physics Material 2D**, and they are structured in a simple hierarchy:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们在本章中看到了许多变量来分配一个 **Physics Material 2D**，并且它们被组织在一个简单的层次结构中：
- en: If a **Collider** has a **Physics Material 2D**, this takes the priority and
    will be set to **Collider**.
  id: totrans-572
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个 **Collider** 有 **Physics Material 2D**，则它具有优先级，并将设置为 **Collider**。
- en: If a **Collider** doesn't have a **Physics Material 2D**, then it will be assigned
    the one in the **Rigidbody2D**.
  id: totrans-573
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果一个 **Collider** 没有分配 **Physics Material 2D**，则它将分配 **Rigidbody2D** 中的那个。
- en: If even the **Rigidbody2D** doesn't have a **Physics Material 2D**, then the
    default **Physics Material 2D** will be assigned. The default **Physics Material
    2D** can be set in **Physics Settings**.
  id: totrans-574
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 即使没有 **Rigidbody2D** 的 **Physics Material 2D**，也会分配默认的 **Physics Material 2D**。默认的
    **Physics Material 2D** 可以在 **Physics Settings** 中设置。
- en: Dealing with physics in Unity
  id: totrans-575
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理 Unity 中的物理
- en: So far, everything went smooth and we learned about all the single components
    of the Physics engine of Unity. However, when it comes to building your own game,
    dealing with physics might be a little bit tricky. In fact, just some wrong values
    on some forces and the whole scene can quickly mess up. The best way to solve
    this is by trial and error. The more you experiment, the more you will become
    practical with the Physics engine, and you will develop an intuition on how to
    balance all the values in your game. As a result, you will be able to make your
    scene act as described in the game design document (or almost).
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都很顺利，我们学习了Unity物理引擎的所有单个组件。然而，当涉及到构建自己的游戏时，处理物理可能有点棘手。实际上，只要在一些力上输入一些错误的值，整个场景就会很快变得混乱。解决这个问题的最佳方法是试错法。你实验得越多，你对物理引擎就越熟悉，你将发展出对如何在游戏中平衡所有值的直觉。结果，你将能够使你的场景按照游戏设计文档（或几乎）所描述的那样行动。
- en: Dealing with physics isn't just about placing the different components, but
    also about how to program them. We have already seen some useful functions to
    apply on a rigidbody as well as some events when two colliders hit each other.
    But there is more. First of all, it's important to understand that all the variables
    we have seen of all the components (such as rigidbodies, colliders, joints, and
    effectors) can be assigned dynamically at runtime with a script. You just need
    to get a reference to that component, and then you will be able to change its
    internal parameters.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 处理物理不仅仅是放置不同的组件，还包括如何编程它们。我们已经看到了一些有用的函数，可以应用于刚体以及当两个碰撞体相撞时的一些事件。但还有更多。首先，重要的是要理解，我们看到的所有组件的变量（如刚体、碰撞体、关节和效应器）都可以在运行时通过脚本动态分配。你只需要获取该组件的引用，然后你就可以更改其内部参数。
- en: 'One more thing that can come in handy is the possibility to query the Physics
    engine through some functions in order to gather some information about the surroundings.
    These are static functions of the `Physics2D` class, and so they can be called
    with the following fragment of code:'
  id: totrans-578
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件可能很有用的事情是，可以通过一些函数查询物理引擎，以收集有关周围环境的信息。这些是`Physics2D`类的静态函数，因此可以使用以下代码片段来调用：
- en: '[PRE3]'
  id: totrans-579
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Of course, you need to substitute `NameOfTheFunction` with the function. The `Physics2D`
    class exposes many of these, but let''s explore just the main ones:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你需要将`NameOfTheFunction`替换为函数。`Physics2D`类公开了许多这些函数，但让我们只探索主要的一些：
- en: '`OverlapCircleAll(Vector2 point, float radius, [*optional parameters]*)`: This
    returns the arrays of `Collider2D` which are all within the circle specified by
    the `radius` and `point` (the center of the circle) variables. In other words,
    it detects all the colliders that are within the specified circle. From the collider,
    it is possible to retrieve the game object itself as well. Our cupcake towers
    will use this function to detect how many enemies there are around. Furthermore,
    other optional parameters of the function are available to specify a mask of layers
    and the min and max values for the depth (*z*-axis) in which the function should
    search.'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OverlapCircleAll(Vector2 point, float radius, [*可选参数]*)`: 这个函数返回所有在由`radius`和`point`（圆的中心）变量指定的圆内的`Collider2D`数组。换句话说，它检测所有在指定圆内的碰撞体。从碰撞体中，还可以检索到游戏对象本身。我们的纸杯蛋糕塔将使用这个函数来检测周围有多少敌人。此外，该函数的其他可选参数还可以用来指定要搜索的层掩码以及深度（*z*轴）的最小和最大值。'
- en: '`OverlapCircle(Vector2 point, float radius, [*optional parameters]*)`: The
    same function as before, but instead of returning the full array, it returns the
    first occurrence. It is useful when you just need to detect whether something
    is present within the circle.'
  id: totrans-582
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`OverlapCircle(Vector2 point, float radius, [*可选参数]*)`: 与之前的函数相同，但它不是返回完整的数组，而是返回第一次出现的结果。这在只需要检测某个物体是否在圆内时非常有用。'
- en: '`RaycastAll(Vector2 origin, Vector2 direction, [*optional parameters]*)`: This
    shoots a ray from an `origin` towards a `direction`, and returns all the different
    colliders that the ray hits within an array of `RayCastHit2D` (see later), which
    is a class that specifies all the details of the hit, including the collider.
    This function is useful when you need to verify if something is present somewhere
    in the space. Furthermore, other optional parameter can specify the maximum distance
    that the ray can reach, a mask of layers, and the min and max values for the depth
    (*z*-axis).'
  id: totrans-583
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RaycastAll(Vector2 origin, Vector2 direction, [*可选参数]*)`: 从 `origin` 向 `direction`
    射出射线，并返回射线在 `RayCastHit2D` 数组（见后文）中击中的所有不同碰撞体，这是一个指定击中详细信息的类，包括碰撞体。此函数在您需要验证空间中是否存在某个物体时非常有用。此外，其他可选参数可以指定射线可以达到的最大距离、层掩码以及深度（*z*
    轴）的最小和最大值。'
- en: '`Raycast(Vector2 origin, Vector2 direction, [*optional parameters]*)`: The
    same function as the previous one, but instead of returning the full array, it
    returns only the first hit.'
  id: totrans-584
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Raycast(Vector2 origin, Vector2 direction, [*可选参数]*)`: 与上一个函数相同，但不是返回完整数组，而是只返回第一次击中的结果。'
- en: Note
  id: totrans-585
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can find all the functions of the `Physics2D` class in the official documentation
    here: [https://docs.unity3d.com/ScriptReference/Physics2D.html](https://docs.unity3d.com/ScriptReference/Physics2D.html).'
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在官方文档中找到 `Physics2D` 类的所有功能：[https://docs.unity3d.com/ScriptReference/Physics2D.html](https://docs.unity3d.com/ScriptReference/Physics2D.html)。
- en: 'About the `RayCastHit2D` class, here is the list of information that we can
    retrieve:'
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `RayCastHit2D` 类，以下是我们可以检索的信息列表：
- en: '`centroid`: The centroid of the primitive used to perform the cast'
  id: totrans-588
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`centroid`: 执行投射所使用的原初体的质心'
- en: '`collider`: The collider hit by the ray'
  id: totrans-589
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`collider`: 被射线击中的碰撞体'
- en: '`distance`: The distance from the origin of the ray to the impact point'
  id: totrans-590
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`distance`: 射线原点到击中点的距离'
- en: '`fraction`: The fraction of the distance along the ray that the hit occurred'
  id: totrans-591
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`fraction`: 击中发生沿射线的距离分数'
- en: '`normal`: The normal vector of the surface hit by the ray'
  id: totrans-592
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`normal`: 被射线击中的表面的法向量'
- en: '`point`: The point in the world space where the ray hit the collider''s surface'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`point`: 射线在全局空间中击中碰撞体表面的点'
- en: '`rigidbody`: The `Rigidbody2D` attached to the object that was hit'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`rigidbody`: 附着在击中对象的 `Rigidbody2D`'
- en: '`transform`: The Transform of the object that was hit'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`transform`: 被击中对象的变换'
- en: In conclusion, querying the Physics engine is a common practice to gather information,
    and we will do it with our *Tower *Defense game.
  id: totrans-596
  prefs: []
  type: TYPE_NORMAL
  zh: 总之，查询物理引擎是收集信息的一种常见做法，我们将在我们的 *塔防* 游戏中这样做。
- en: Other things about Physics
  id: totrans-597
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 物理学的其他事项
- en: As with other chapters, this is an optional section with some deeper insights
    into the topic covered in the chapter. So, feel free to skip this section if you
    are not interested, and jump directly onto the next section. Otherwise, just grab
    some more coffee and keep reading.
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 与其他章节一样，这是一个可选部分，其中包含对章节中主题的更深入见解。所以，如果您不感兴趣，请随意跳过本节，直接进入下一节。否则，就再喝点咖啡，继续阅读。
- en: The Simulate setting on rigidbodies
  id: totrans-599
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 碰撞体上的 Simulate 设置
- en: This aim of this section is to explain the difference between enabling and disabling
    physical components on a rigidbody and enabling and disabling the **Simulate**
    settings on top of the rigidbody component.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 本节的目标是解释在刚体上启用和禁用物理组件，以及在刚体组件上启用和禁用 **Simulate** 设置之间的区别。
- en: Every time that a physical component is either added, enabled, removed, or disabled,
    the internal memory of the Physics engine is updated (respectively to add or remove
    the component from the memory). When the **Simulate** setting is disabled, the
    Physics engine just stops to perform calculations on it - it doesn't erase the
    object from the memory. As a result, when **Simulate** is checked back, the Physics
    engine has already all the objects/components in the memory and it doesn't' need
    to create them from scratch, thus leading to a performance improvement.
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 每次物理组件被添加、启用、删除或禁用时，物理引擎的内部内存都会更新（分别将组件添加到或从内存中删除）。当 **Simulate** 设置被禁用时，物理引擎只是停止对其执行计算——它不会从内存中删除对象。因此，当
    **Simulate** 再次被选中时，物理引擎已经将所有对象/组件放入内存中，它不需要从头创建它们，从而提高了性能。
- en: Of course, if you need to remove a rigidbody permanently from the scene, then
    just erase the component, because if you just uncheck **Simulate**, the component
    will still be in memory, leading to a poor memory management.
  id: totrans-602
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，如果你需要永久地从场景中移除刚体，那么只需删除组件即可，因为如果你只是取消选择**模拟**，组件仍然会在内存中，导致内存管理不佳。
- en: Physics Raycaster 2D component
  id: totrans-603
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 2D 物理射线投射器组件
- en: Back in Chapter 3, *Communicating with the Player – the User Interface*, we
    have seen the Unity UI system, and in the optional section there were the different
    components of a canvas. One of them was the **Graphical Raycaster**, which is
    able to detect the input of the user on the screen. This component checks if the
    player actually went over a slider or clicked a button, and then triggers events
    by exchanging messages with the event system.
  id: totrans-604
  prefs: []
  type: TYPE_NORMAL
  zh: 回到第 3 章，“与玩家通信——用户界面”，我们看到了 Unity UI 系统，在可选部分有画布的不同组件。其中之一是**图形射线投射器**，它能够检测屏幕上的用户输入。此组件检查玩家是否真的滑过了滑块或点击了按钮，然后通过与事件系统交换消息来触发事件。
- en: If we have physics objects and we want to exchange events about them in a similar
    way the **Graphical Raycaster** does for the UI, we can use a Physics Raycaster
    2D component on a camera to handle such events.
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们有物理对象并且想要以类似于**图形射线投射器**为 UI 做的方式交换它们的事件，我们可以在相机上使用一个物理射线投射器 2D 组件来处理这些事件。
- en: Once this component is added, you can implement different interfaces in the
    scripts of your physics objects. As a result, the functions that they will implement
    will be automatically called when the corresponding event is triggered.
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了此组件，你就可以在物理对象的脚本中实现不同的接口。结果，当触发相应的事件时，它们将自动调用所实现的函数。
- en: For instance, an event could be that a joint breaks, and you may want to run
    some code when this happens. Moreover, some information will be provided to the
    functions; in the case of the joint, the amount of force that broke the joint
    is passed as a parameter.
  id: totrans-607
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一个事件可能是某个关节断裂，当这种情况发生时，你可能想要运行一些代码。此外，一些信息将被提供给函数；在关节的情况下，断裂关节的力的大小作为参数传递。
- en: The other Physics settings
  id: totrans-608
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 其他物理设置
- en: 'Here you can find the other Physics settings:'
  id: totrans-609
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里你可以找到其他物理设置：
- en: '**Velocity Iterations**: The number of iterations that are made to determine
    the velocity of a physical body during an update. The higher is the number, the
    more accurate the simulation will be. The drawback is computational cost. The
    default value is `8`.'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度迭代次数**：在更新期间确定物理体速度所进行的迭代次数。数字越高，模拟越精确。缺点是计算成本。默认值是 `8`。'
- en: '**Position Iterations**: The number of iteration made to determine the position
    of a physical body during an update. The higher is the number, the more accurate
    the simulation will be. The drawback is computational cost. The default value
    is `3`.'
  id: totrans-611
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**位置迭代次数**：在更新期间确定物理体位置所进行的迭代次数。数字越高，模拟越精确。缺点是计算成本。默认值是 `3`。'
- en: '**Velocity Threshold**: Collisions with a relative velocity lower than this
    value are treated as inelastic collisions, which means that the colliding bodies
    will not bounce off each other.'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**速度阈值**：与相对速度低于此值的碰撞被视为非弹性碰撞，这意味着碰撞的物体不会相互弹开。'
- en: '**Max Linear Correction**: The maximum linear position correction used when
    solving constraints. It can have any value between `0.0001` to `1000000`. It helps
    to prevent overshooting.'
  id: totrans-613
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大线性校正**：在解决约束时使用的最大线性位置校正。它可以是 `0.0001` 到 `1000000` 之间的任何值。它有助于防止超调。'
- en: '**Max Angular Correction**: The maximum angular correction used when solving
    constraints. It can have any value between `0.0001` to `1000000`. It helps to
    prevent overshooting.'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大角校正**：在解决约束时使用的最大角校正。它可以是 `0.0001` 到 `1000000` 之间的任何值。它有助于防止超调。'
- en: '**Max Translation Speed**: This is the maximum (translation) speed that a body
    in your game could have. This value is the upper limit, which means that every
    object that tries to reach faster velocities, will be cap to this value.'
  id: totrans-615
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大平移速度**：这是你的游戏中一个物体可能具有的最大（平移）速度。这个值是上限，这意味着任何试图达到更快速度的对象都将被限制在这个值。'
- en: '**Max Rotation Speed**: This is the maximum (rotation) speed that a body in
    your game could have. The same reasoning as before applies, just with rotations
    instead of translations.'
  id: totrans-616
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最大旋转速度**：这是你的游戏中一个物体可能具有的最大（旋转）速度。与之前相同的推理适用，只是用旋转代替平移。'
- en: '**Min Penetration For Penalty**: The minimum contact penetration radius allowed
    before any separation impulse force is applied.'
  id: totrans-617
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**最小穿透量以应用罚力**：在应用任何分离冲量力之前允许的最小接触穿透半径。'
- en: '**Baumgarte Scale**: This is a scale factor that determines how fast collision
    overlaps are resolved (see the information box).'
  id: totrans-618
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Baumgarte 比例尺**：这是一个比例因子，用于确定碰撞重叠解决的速度（见信息框）。'
- en: '**Baumgarte Time Of Impact Scale**: A scale factor that determines how fast
    time-of-impact overlaps are resolved (see the information box).'
  id: totrans-619
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Baumgarte 碰撞时间比例尺**：一个比例因子，用于确定碰撞时间重叠解决的速度（见信息框）。'
- en: Note
  id: totrans-620
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Baumgarte's constraint stabilization method (sometimes just abbreviated to Baumgarte's
    method) is an algorithm for resolving certain collision constraints, such as with
    joints, invented by J. Baumgarte in 1972\. It is fast enough so that it can be
    used in real-time applications such as video games or robotics. The trick consists
    of taking advantage of some derived analytic forms of differential equations that
    are solved numerically. This allows you to run the algorithm not only faster than
    its predecessors but also with a higher degree of accuracy.
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: Baumgarte 的约束稳定化方法（有时简称为 Baumgarte 方法）是由 J. Baumgarte 在 1972 年发明的一种用于解决某些碰撞约束的算法，例如与关节。它足够快，可以在实时应用中使用，如视频游戏或机器人技术。这个技巧在于利用一些导出的微分方程的解析形式，这些形式是数值解决的。这使得算法不仅比其前辈运行得更快，而且精度更高。
- en: The **Baumgarte Scale** is the important parameter for the algorithm, which
    represents the correction ratio to apply. A common value, which is often given
    as default, is `0.2` and it is also the default value that Unity uses.
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: '**Baumgarte 比例尺**是算法的重要参数，它表示要应用的校正比率。一个常见的值，通常作为默认值给出，是 `0.2`，也是 Unity 的默认值。'
- en: The higher the value, the more your joints will go wild. On the other hand,
    the lower the value, the less your joints will do, and it can cause sponginess.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 值越高，你的关节越容易失控。另一方面，值越低，你的关节动作越少，可能会导致弹簧感。
- en: '**Queries Hit Trigger**: This is a toggle that if true allows raycasts to hit
    also trigger volumes. By default, it is true, but can be unchecked in case you
    don''t want raycasting to hit trigger volumes, but just colliders. When to uncheck
    this box really depends on the design of your game, and what you have in mind
    to program it.![The other Physics settings](img/image00575.jpeg)'
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**查询击中触发器**：这是一个切换按钮，如果设置为真，允许射线投射物击中触发体积。默认情况下，它是真的，但如果不想射线投射物击中触发体积，只想击中碰撞器，则可以取消选中。何时取消选中此框实际上取决于你游戏的设计，以及你打算如何编程它。[其他物理设置](img/image00575.jpeg)'
- en: When Queries Hit Trigger is set to false (upper part of diagram*)*, trigger
    volumes won't be detected by raycasting. On the contrary, when Queries Hit Trigger
    is set to true (lower part of diagram), also trigger volumes will be detected
    by raycasting and returned as a hit.
  id: totrans-625
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当“查询击中触发器”设置为假（图的上半部分）时，触发体积不会被射线投射检测到。相反，当“查询击中触发器”设置为真（图的下半部分）时，触发体积也会被射线投射检测到，并作为碰撞返回。
- en: '**Queries Start In Collider**: This is a toggle that, if true, allows raycasts
    that start within a collider to what hit that collider. By default, it is true,
    but can be unchecked if many of your raycasts start within a collider and you
    don''t want them to be returned as hits. Again, when to uncheck this box really
    depends on the design of your game, and also you have in mind to program it.![The
    other Physics settings](img/image00576.jpeg)'
  id: totrans-626
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**碰撞器内查询开始**：这是一个切换按钮，如果设置为真，允许从碰撞器内开始的射线投射物检测到碰撞器。默认情况下，它是真的，但如果许多射线投射物在碰撞器内开始并且你不想它们被返回为碰撞，则可以取消选中。再次强调，何时取消选中此框实际上取决于你游戏的设计，以及你打算如何编程它。[其他物理设置](img/image00576.jpeg)'
- en: When Queries Start In Collider is set to false (upper part of diagram) and the
    the source of the raycast is within a collider, this one won't be returned as
    a hit. On the contrary, when Queries Start In Collider is set to true (lower part
    of diagram), also the collider in which there is the source of the raycast is
    returned as a hit.
  id: totrans-627
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 当“查询开始于碰撞器”设置为假（图的上半部分）且射线投射物的来源在碰撞器内时，这个碰撞不会返回。相反，当“查询开始于碰撞器”设置为真（图的下半部分）时，射线投射物的来源所在的碰撞器也会被返回为碰撞。
- en: '**Change Stops Playback**: This is a toggle that, if true, stops reporting
    collision callbacks immediately if any of the GameObjects involved in the collision
    are deleted or moved. By default, it is false.'
  id: totrans-628
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**停止播放更改**：这是一个切换按钮，如果设置为真，则如果任何参与碰撞的 GameObject 被删除或移动，则立即停止报告碰撞回调。默认情况下，它是假的。'
- en: '**Gizmos**: (The description of this foldout is in the next section.)'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Gizmos**: (本折叠图的描述将在下一节中介绍。)'
- en: Gizmos for colliders
  id: totrans-630
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 碰撞体的Gizmos
- en: This section describes the previous menu item, **Gizmos**, in the **Physics
    2D** settings.
  id: totrans-631
  prefs: []
  type: TYPE_NORMAL
  zh: 本节描述了**物理2D**设置中之前菜单项**Gizmos**。
- en: '**Gizmos** is a foldout that shows you extra options about the visualizations
    of colliders within the editor. These options are really useful in debugging.
    This is how it appears in the **Inspector**:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: '**Gizmos**是一个折叠图，显示你在编辑器内关于碰撞体可视化的额外选项。这些选项在调试中非常有用。这是它在**检查器**中的外观：'
- en: '![Gizmos for colliders](img/image00577.jpeg)'
  id: totrans-633
  prefs: []
  type: TYPE_IMG
  zh: '![碰撞体的Gizmos](img/image00577.jpeg)'
- en: 'Here is an explanation of the options displayed and their usage:'
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是对显示的选项及其用法的解释：
- en: '**Always Show Colliders**: By default, you are able to see a collider only
    when a game object (or one of its children) contains such a collider. If you enable
    this option, you will always be able to see colliders (whenever **Gizmos** are
    visible).'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Always Show Colliders**: 默认情况下，你只能在游戏对象（或其子对象之一）包含此类碰撞体时才能看到碰撞体。如果你启用此选项，你将始终能够看到碰撞体（无论何时**Gizmos**可见）。'
- en: '**Show Collider Sleep**: When enabled, it allows you to see a collider even
    when it is in sleep mode within the Physics engine'
  id: totrans-636
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Show Collider Sleep**: 当启用时，它允许你在物理引擎中的睡眠模式下看到碰撞体。'
- en: '**Collider Awake Color**: This specifies the color that awake (no-sleeping)
    colliders should have when shown. By default, it is a light green with the alpha
    channel (opacity) set to `192`.'
  id: totrans-637
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Collider Awake Color**: 这指定了当显示时唤醒（非睡眠）碰撞体应具有的颜色。默认情况下，它是一种浅绿色，其alpha通道（不透明度）设置为`192`。'
- en: '**Collider Sleep Color**: This specifies the color that sleeping colliders
    should have when shown. By default, it is the same light green as when the collider
    is awake, but with the alpha channel (opacity) set to `92`.'
  id: totrans-638
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Collider Sleep Color**: 这指定了当显示时睡眠碰撞体应具有的颜色。默认情况下，它与碰撞体唤醒时的相同浅绿色，但alpha通道（不透明度）设置为`92`。'
- en: '**Show Collider Contacts**: When enabled, this allows you to see the contacts
    point of the colliders when they collide. They are shown as arrows (as shown in
    the next diagram).'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Show Collider Contacts**: 当启用时，这允许你在碰撞体碰撞时看到接触点。它们显示为箭头（如下一图所示）。'
- en: '**Contact Arrow Scale**: This value allows you to scale down the arrow showed
    by the contact points of the collider. By default, its value is `0.2` (as shown
    in the next diagram).'
  id: totrans-640
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Contact Arrow Scale**: 此值允许你缩小由碰撞体的接触点显示的箭头。默认情况下，其值为`0.2`（如下一图所示）。'
- en: '**Collider Contact Color**: This specifies the color of such arrows representing
    the contact points of the collider. By default, it is set to light purple (as
    shown in the next diagram):![Gizmos for colliders](img/image00578.jpeg)'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Collider Contact Color**: 这指定了表示碰撞体接触点的此类箭头的颜色。默认情况下，它设置为浅紫色（如下一图所示）：![碰撞体的Gizmos](img/image00578.jpeg)'
- en: On the left there are two colliders that are overlapping with each other. In
    the middle, the colliders are updated by the Physics engine to simulate the collisions
    (since they cannot overlap). Also shown are the points of contact between the
    two arrows. On the right, there is the same diagram that is in the middle, but
    with the **Contact Arrow Scale** set to `0.6` instead of `0.2`, and as a result
    the arrows are bigger.
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 左边有两个相互重叠的碰撞体。在中间，物理引擎更新碰撞体以模拟碰撞（因为它们不能重叠）。同时显示两个箭头之间的接触点。在右侧，是中间的相同图，但**Contact
    Arrow Scale**设置为`0.6`而不是`0.2`，因此箭头更大。
- en: '**Show Collider AABB**: When enabled, this allows you to see the **Axis-Aligned
    Bounding Box** (**AABB**) of the collider. As the name suggests, it is a box that
    fully contains the collider, and it is aligned with the axis of the world frame.
    For example, the bounding box of a polygonal collider is the following (on the
    left):![Gizmos for colliders](img/image00579.jpeg)'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Show Collider AABB**: 当启用时，这允许你看到碰撞体的**轴对齐边界框**（**AABB**）。正如其名称所暗示的，它是一个完全包含碰撞体的盒子，并且它与世界坐标系的轴对齐。例如，多边形碰撞体的边界框如下（在左侧）：![碰撞体的Gizmos](img/image00579.jpeg)'
- en: On the left is the polygonal collider with its AABB; on the right is the same
    diagram as the previous one, but showing its AABB.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: 左边是具有其AABB的多边形碰撞体；右边是前一个图的相同图，但显示了其AABB。
- en: '**Collider AABB Color**: This specifies the color of the AABB of the collider,
    when shown'
  id: totrans-645
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Collider AABB Color**: 这指定了当显示时碰撞体AABB的颜色。'
- en: Physics for our game
  id: totrans-646
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 我们游戏中的物理
- en: In this section we will apply some concepts of this chapter into our game. In
    particular, we will see how to detect when a sprinkle hits a panda and applies
    damage to it using the Physics engine.
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将将本章的一些概念应用到我们的游戏中。特别是，我们将看到如何使用物理引擎检测当喷雾击中熊猫并对其造成伤害的情况。
- en: Set up Pandas as a rigidbodies
  id: totrans-648
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置 Pandas 为刚体
- en: Since we will take advantage of the Physics engine, we need to proper set up
    the Panda as that to be a physical object in the scene. This means giving it a
    rigidbody component.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将利用物理引擎，我们需要正确设置熊猫，使其在场景中成为一个物理对象。这意味着给它一个刚体组件。
- en: 'Therefore, we can start by adding a **Rigidbody2D** component to the Panda
    prefab, and set its **Body Type** as **Kinematic**, as shown in the following
    screenshot:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以先给 Panda 预制件添加一个 **Rigidbody2D** 组件，并将其 **Body Type** 设置为 **Kinematic**，如下截图所示：
- en: '![Set up Pandas as a rigidbodies](img/image00580.jpeg)'
  id: totrans-651
  prefs: []
  type: TYPE_IMG
  zh: '![设置 Pandas 为刚体](img/image00580.jpeg)'
- en: In theory, we should have done, since the Panda is considered a physical object
    now. However, in the previous chapter, we have written a function that allows
    the Panda to move by assigning its new position directly on its Transform. Since
    now the Panda has a **Rigidbody2D** component, we cannot do in this way anymore
    (as we already explained previously in the *Rigidbodies* section). Therefore,
    we need to slightly modify the `PandaScript`. In particular, we need to get a
    reference to the rigidbody of the Panda, then use the `MovePosition()` function
    for Kinematic rigidbodies. Basically, we are applying what we have learnt in the
    *Dealing with rigidbodies* section.
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 理论上，我们应该已经完成了，因为熊猫现在被视为一个物理对象。然而，在上一章中，我们编写了一个函数，允许熊猫通过直接在它的 Transform 上分配新位置来移动。由于现在熊猫有一个
    **Rigidbody2D** 组件，我们不能再这样做（就像我们之前在 *刚体* 部分中解释的那样）。因此，我们需要稍微修改 `PandaScript`。特别是，我们需要获取熊猫刚体的引用，然后使用
    `MovePosition()` 函数为 Kinematic 刚体。基本上，我们正在应用我们在 *处理刚体* 部分中学到的知识。
- en: 'Hence, open the script, and add the following private variable:'
  id: totrans-653
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，打开脚本，并添加以下私有变量：
- en: '[PRE4]'
  id: totrans-654
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then, in the `Start()` function add this line at the end of the function:'
  id: totrans-655
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `Start()` 函数的末尾添加以下行：
- en: '[PRE5]'
  id: totrans-656
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'In the `MoveTowards()` function, we need to use the `MovePosition()` function
    on the Panda''s rigidbody to change its position. In addition, we shouldn''t use
    `deltaTime` anymore, and substitute it with `fixedDeltaTime`. As such, here is
    highlighted what is changed from the previous chapter:'
  id: totrans-657
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MoveTowards()` 函数中，我们需要在熊猫的刚体上使用 `MovePosition()` 函数来改变其位置。此外，我们不再使用 `deltaTime`，而是用
    `fixedDeltaTime` 替换它。因此，这里突出显示了与上一章相比的变化：
- en: '[PRE6]'
  id: totrans-658
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Note
  id: totrans-659
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We need to remember that the `MoveTowards()` function, now, should be called
    within a `FixedUpdate()` and not in the `Update()`. We will see this in [Chapter
    7](https://cdp.packtpub.com/b03794gettingstartedwithunity2dgamedevelopmentsecondedition/wp-admin/post.php?post=220&action=edit#post_247),
    *Trading Cupcakes and the Ultimate Battle for the Cake – Gameplay Programming*.
    But you can have an example in the next section.
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要记住，现在应该调用 `MoveTowards()` 函数是在 `FixedUpdate()` 中，而不是在 `Update()` 中。我们将在
    [第 7 章](https://cdp.packtpub.com/b03794gettingstartedwithunity2dgamedevelopmentsecondedition/wp-admin/post.php?post=220&action=edit#post_247)
    中看到这一点，“交易纸杯蛋糕和终极蛋糕争夺战 – 游戏玩法编程”。但下一个部分可以有一个例子。
- en: Finally, we can save the script, and we have done with the Panda.
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以保存脚本，我们就完成了熊猫的设置。
- en: Set up projectiles as rigidbodies
  id: totrans-662
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置弹射体为刚体
- en: Similar to what we did for the Pandas, we need to add a **Rigidbody2D** component
    to all the projectiles, and again set the **Body Type** to **Kinematic**.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 与我们为 Pandas 做的类似，我们需要给所有弹射体添加一个 **Rigidbody2D** 组件，并将 **Body Type** 再次设置为 **Kinematic**。
- en: If you remember, also projectiles used to move by changing directly their Transforms,
    and we need to fix this, since they have a **Rigidbody2D** component as well.
  id: totrans-664
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你还记得，弹射体过去是通过直接改变它们的 Transforms 来移动的，我们需要修复这个问题，因为它们也有一个 **Rigidbody2D** 组件。
- en: 'Open the script, and as we did for the Pandas, add the following private variable:'
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 打开脚本，就像我们为 Pandas 做的那样，添加以下私有变量：
- en: '[PRE7]'
  id: totrans-666
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, in the `Start()` function, let’s get the reference to it:'
  id: totrans-667
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在 `Start()` 函数中，让我们获取它的引用：
- en: '[PRE8]'
  id: totrans-668
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, we need to replace the `Update()` function with the `FixedUpdate()` one,
    since we are dealing with the Physics engine. Moreover, we need to slightly change
    the code (note also the use of the `fixedDeltaTime`):'
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要将 `Update()` 函数替换为 `FixedUpdate()` 函数，因为我们正在处理物理引擎。此外，我们还需要稍微修改一下代码（注意也使用了
    `fixedDeltaTime`）：
- en: '[PRE9]'
  id: totrans-670
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Note
  id: totrans-671
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: A careful reader would notice that we are applying the equation of motion explained
    in the information box within the *Dealing with rigidbodies* section. In particular,
    here we have split the velocity into a direction and a speed (which multiplied
    them together give back the velocity).
  id: totrans-672
  prefs: []
  type: TYPE_NORMAL
  zh: 一个细心的读者会注意到，我们正在应用“处理刚体”部分信息框中解释的运动方程。特别是，这里我们将速度分解为方向和速度（将它们相乘后得到速度）。
- en: Save the script, and let’s see how we can detect when a sprinkle hits a panda
    in the next section.
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本，接下来让我们看看如何在下一节中检测到水滴击中熊猫。
- en: Detect sprinkles
  id: totrans-674
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检测水滴
- en: In order to detect a collision between a sprinkle and a Panda, we need to add
    them both a **Collider2D**. You can choose the one that better suits your needs,
    I'll go for the **Box2D** collider. Then, you need to make one of them act as
    a Trigger, in our example we can take the Panda.
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 为了检测水滴与熊猫之间的碰撞，我们需要给它们都添加一个**Collider2D**。你可以选择最适合你需求的，我会选择**Box2D**碰撞器。然后，你需要让其中一个对象充当触发器，在我们的例子中，我们可以选择熊猫。
- en: The next step is to implement the `OnTriggerEnter2D()` function, which is called
    from the Physics engine of Unity, on the `PandaScript`. As a result, we are able
    to detect when something hits the panda, and check if it is an actual sprinkle,
    so to apply damage to the panda with the `Hit()` function written in the previous
    chapter.
  id: totrans-676
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是实现`OnTriggerEnter2D()`函数，该函数由Unity的物理引擎在`PandaScript`中调用。结果，我们能够检测到有什么东西击中熊猫，并检查它是否是实际的水滴，以便使用上一章中编写的`Hit()`函数对熊猫造成伤害。
- en: '[PRE10]'
  id: totrans-677
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Note
  id: totrans-678
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Of course, we need to be sure that every object with the Projectile tag have
    a **ProjectileScript** component attached. This check is left as an exercise.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们需要确保带有“Projectile”标签的每个对象都附加了**ProjectileScript**组件。这个检查留作练习。
- en: Finally, save the script, and we have done with Physics for our game, at least
    in this chapter. In fact, in the next chapter, we will use again the Physics engine,
    but for other reasons.
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，保存脚本，我们至少在这一章中完成了游戏中的物理部分。实际上，在下一章中，我们还会再次使用物理引擎，但出于其他原因。
- en: Homework
  id: totrans-681
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: 'As in every chapter, here are some exercises that you can use to practice your
    skills:'
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 正如每一章一样，这里有一些练习可以帮助你练习你的技能：
- en: '**The forgotten rigidbody**: Sometimes components in the **Inspector** could
    be forgotten. However, we can facilitate the process by creating warnings in the
    code. For both our Panda and the sprinkles, create within their scripts a check,
    when the game object is initialized, to add a **Rigidbody2D** component, if missing,
    and set it to be **Kinematic**. Additionally, you can print a warning message
    (See [Chapter 8](part0100.xhtml#aid-2VBO82 "Chapter 8. What Is beyond the Cake?"),
    *What Is beyond the Cake?*, for more about debugging messages).'
  id: totrans-683
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**被遗忘的刚体**：有时在**检查器**中的组件可能会被遗忘。然而，我们可以通过在代码中创建警告来简化这个过程。对于我们的熊猫和水滴，在其脚本中创建一个检查，当游戏对象初始化时，如果缺少**Rigidbody2D**组件，则添加它，并将其设置为**Kinematic**。此外，你可以打印一条警告信息（参见[第8章](part0100.xhtml#aid-2VBO82
    "第8章。蛋糕之外是什么？")，“蛋糕之外是什么？”，了解更多关于调试信息）。'
- en: '**Passion for acceleration**: In the chapter, we saw how we could implement
    motion equations for our **Kinematic** rigidbodies. In particular, the chapter
    shown an implementation of the velocity equation. Now, try to implement the acceleration
    equation for a **Kinematic** rigidbody.'
  id: totrans-684
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**对加速度的热情**：在第8章中，我们看到了如何为我们的**Kinematic**刚体实现运动方程。特别是，本章展示了一个速度方程的实现。现在，尝试为**Kinematic**刚体实现加速度方程。'
- en: '**Joint Master**: For each one of the joints that Unity offers, think about
    a possible usage and example (possibly different from the ones already presented
    in the chapter). Then, sketch the physical system on paper, and determine which
    are the rigidbodies and where the anchor points are. Finally, reproduce what you
    have imagined within Unity, and tweak all the settings until it works as you have
    decided.'
  id: totrans-685
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**关节大师**：对于Unity提供的每一个关节，思考一个可能的用途和示例（可能不同于章节中已经展示的）。然后，在纸上绘制物理系统，确定哪些是刚体以及锚点在哪里。最后，在Unity中重现你所想象的内容，并调整所有设置，直到它按你决定的方式工作。'
- en: '**Effector Master**: For each one of the effectors that Unity offers, think
    about a possible usage and example (possibly different from the ones already presented
    in the chapter). Then, sketch how the effector should work on paper, and determine
    how the different rigidbodies would interact with it. Finally, reproduce what
    you have imagined within Unity, and tweak all the settings until it works as you
    have decided.'
  id: totrans-686
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**《效果器大师》**：对于Unity提供的每个效果器，思考可能的用途和示例（可能不同于章节中已经展示的）。然后，在纸上绘制效果器应该如何工作的草图，并确定不同的刚体如何与之交互。最后，在Unity中重现你的想象，并调整所有设置，直到它按你决定的方式工作。'
- en: '**A less dauntless Panda (Part III)**: If you also completed the second part
    of this exercise back in [Chapter 4](part0056.xhtml#aid-1LCVG1 "Chapter 4. No
    Longer Alone – Sweet-Toothed Pandas Strike"), *No Longer Alone - Sweet-Toothed
    Pandas Strike*, some pandas will be stunned, others not, depending on the Boolean
    value. Instead of exposing this Boolean within the **Inspector**, add this property
    to the `Projectile` class, so that if the Panda is stunned or not depends on which
    kind of projectile the Panda was hit with (we will see this later in [Chapter
    6](part0077.xhtml#aid-29DRA1 "Chapter 6. Through a Sea of Sprinkles – Navigation
    in Artificial Intelligence"), *Through a Sea of Sprinkles – Navigation in Artificial
    Intelligence*).'
  id: totrans-687
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**《不那么胆怯的大熊猫（第三部分）》**：如果你也完成了[第4章](part0056.xhtml#aid-1LCVG1 "第4章。不再孤单——甜食爱好者的大熊猫出击")中的这个练习的第二部分，*不再孤单——甜食爱好者的大熊猫出击*，一些大熊猫会被击晕，而另一些则不会，这取决于布尔值。不要在**检查器**中暴露这个布尔值，而是将这个属性添加到`Projectile`类中，这样大熊猫是否被击晕就取决于它被哪种投射物击中（我们将在[第6章](part0077.xhtml#aid-29DRA1
    "第6章。穿过糖果雨——人工智能中的导航")，*穿过糖果雨——人工智能中的导航*中看到这一点）。'
- en: '**A less dauntless Panda (Part IV)**: After you have done part three of this
    exercise, if the poor panda is under attack with too many sprinkles, it might
    not move anymore because it is always in a stunned state. As a result, it won''t
    able to avoid the sprinkles either. So as to avoid this, we need to modify the
    Panda script such that if another sprinkle hits the Panda while it is stunned,
    it detracts the health from the Panda; but doesn''t trigger from the beginning
    the hit animation and/or the stun period.'
  id: totrans-688
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**《不那么胆怯的大熊猫（第四部分）》**：在你完成了这个练习的第三部分之后，如果可怜的大熊猫被太多的糖果雨攻击，它可能不会再移动，因为它总是处于击晕状态。结果，它也无法避开糖果雨。为了避免这种情况，我们需要修改大熊猫脚本，使得如果另一个糖果雨在大熊猫被击晕时击中它，它会从大熊猫那里扣除健康值；但不会从开始就触发击中动画和/或击晕阶段。'
- en: '**A less dauntless Panda (Part V)**: Now that you have also completed the third
    part of this exercise, let''s improve the whole system of stunning a Panda. Add
    to each projectile, a variable that indicates the chance of this projectile to
    stunning a Panda. Finally, trigger the stunning phase of the Panda probabilistically
    based on the previous variable.'
  id: totrans-689
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**《不那么胆怯的大熊猫（第五部分）》**：既然你已经完成了这个练习的第三部分，让我们改进整个击晕大熊猫的系统。给每个投射物添加一个变量，表示这个投射物击晕大熊猫的概率。最后，根据前面的变量以概率触发大熊猫的击晕阶段。'
- en: 'Finally, if you are into challenges, here is one for you:'
  id: totrans-690
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 最后，如果你喜欢挑战，这里有一个挑战给你：
- en: '**The frozen conveyor belt (Part I)**: Imagine a conveyor belt that is made
    of a big piece of ice and scrolls quite fast. Think and describe what would happen
    when a box is dropped onto it. Keep in mind that the friction on the ice is really
    low, and that there is inertia to consider. What if, instead of a box, there was
    a sphere? The solution is available at the end of the book.'
  id: totrans-691
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**《冻结的传送带（第一部分）》**：想象一条由一大块冰制成的传送带，它滚动得相当快。思考并描述当一个箱子掉到上面时会发生什么。记住，冰上的摩擦力非常低，需要考虑惯性。如果掉下去的不是箱子，而是一个球体呢？解决方案在书的末尾。'
- en: '**The frozen conveyor belt (Part II)**: Once you have done Part I, reproduce
    the frozen conveyor belt within the Physics engine of Unity, and try it out with
    boxes and spheres.'
  id: totrans-692
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**《冻结的传送带（第二部分）》**：一旦你完成了第一部分，就在Unity的物理引擎中重现冻结的传送带，并用箱子和球体进行测试。'
- en: Summary
  id: totrans-693
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we started by learning some basic notions of physics so as
    to better develop our games. Then, we went through the Physics engine of Unity,
    which is divided into some components. Rigidbodies and colliders describe the
    properties of physical objects in the game, whereas joints and effectors affect
    how they react with each other in the environment.
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先学习了物理学的一些基本概念，以便更好地开发我们的游戏。然后，我们了解了 Unity 的物理引擎，它分为几个组件。刚体和碰撞体描述了游戏中物理对象的特点，而关节和效果器则影响它们在环境中的相互作用方式。
- en: Finally, we saw how to deal with physics and took what we needed for our *Tower
    Defense* game, so as to implement the collision between a sprinkle and a Panda
    (and call the right functions to update the Panda's health and animations).
  id: totrans-695
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们学习了如何处理物理问题，并从我们的 *塔防* 游戏中提取了所需内容，以便实现洒水器和熊猫之间的碰撞（并调用正确的函数来更新熊猫的健康状态和动画）。
