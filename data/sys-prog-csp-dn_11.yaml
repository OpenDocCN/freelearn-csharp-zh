- en: '11'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '11'
- en: The One with the Debugging Dances
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试舞蹈篇
- en: '*Debugging and Profiling* *System Applications*'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*调试与性能分析* *系统应用程序*'
- en: '**Debugging** is the art of finding errors in your code and ensuring you have
    all the knowledge to fix them. That sounds simple enough, doesn’t it? Well, think
    again. Debugging can get complicated quickly, and you need good strategies to
    recover. Luckily, I am here to help you! In this chapter, we’re going to cover
    the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试**是寻找代码中的错误并确保你拥有所有知识来修复它们的艺术。这听起来很简单，不是吗？好吧，再想想。调试可能会很快变得复杂，你需要良好的策略来恢复。幸运的是，我在这里帮助你！在本章中，我们将涵盖以下主要主题：'
- en: What is debugging? What is **profiling**?
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试是什么？什么是**性能分析**？
- en: How do we use **breakpoints**?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何使用**断点**？
- en: What other debugging tools do we have in Visual Studio?
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们在Visual Studio中还有哪些其他调试工具？
- en: How do we deal with multithreaded and asynchronous systems?
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何处理多线程和异步系统？
- en: How do we profile and benchmark our code to ensure it runs as fast as possible?
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们如何分析和基准测试我们的代码以确保它尽可能快地运行？
- en: Debugging can get quite time-intensive. So, let’s not waste any time and get
    started.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 调试可能会非常耗时。所以，我们不要浪费时间，开始吧。
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: As always, you can find the source code for all samples in this chapter in the
    GitHub repository at [https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter11](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter11).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 和往常一样，你可以在这个章节的GitHub仓库中找到所有示例的源代码，网址为[https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter11](https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter11)。
- en: I only use Visual Studio in this chapter; I am not referring to any of the third-party
    tools that might do the same job. However, I will provide you with a list of alternative
    tools at the end of this chapter.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我只使用Visual Studio；我并不是在提及任何可能做同样工作的第三方工具。然而，我将在本章末尾提供一系列替代工具的列表。
- en: Introducing debugging
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试介绍
- en: 'True story: I once worked for a manager who claimed he wanted to lay off the
    testers in my team. He said, “If your team performs better, they will not produce
    bugs, and therefore we can save on the testers.” Obviously, he was wrong. I left
    that company shortly after this happened.'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 真事：我曾经为一位声称想要裁减我团队测试人员的管理者工作。他说：“如果你的团队能够表现得更好，他们就不会产生错误，因此我们可以节省测试人员的开支。”显然，他是错的。在这件事发生后不久，我就离开了那家公司。
- en: Developing software is a creative job. People think software development is
    an exact science that is close to mathematics and physics, but it is not. Sure,
    the roots look mathematical, but what we, as software developers, do is something
    else. We take an idea, think of something that does not yet exist, and then turn
    those ideas into something that can help others. We create something out of thin
    air by our imagination and ingenuity.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 开发软件是一项创造性的工作。人们认为软件开发是一项接近数学和物理学的精确科学，但并非如此。当然，根源看起来像是数学的，但我们作为软件开发者所做的事情是不同的。我们有一个想法，想到一些还不存在的东西，然后把这些想法变成可以帮助他人的东西。我们通过想象和独创力从无到有地创造东西。
- en: 'However, the creative mind is sloppy. We cut corners when we are in the flow.
    We make mistakes trying to realize our vision. Testers and QA professionals are
    our safety net; they are there to catch the things we forget about. But having
    a safety net does not mean you can do whatever you want and wing it. Once you
    have the first outline of your code ready, it is time to switch from being the
    creative developer to the pensive, analytical developer – the one who looks at
    their code and notices areas of improvement; and still then you will miss things.
    So, you test yourself. That is when you find issues. Or, you see the system does
    not run as smoothly as you expected. Maybe you find the results are not what they
    are supposed to be. That is when the debugging dance starts: you run the system,
    you try to pinpoint the area where things go wrong, you fix things, and repeat
    the whole cycle.'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，创造性思维是随意的。我们在流畅的状态下会走捷径。我们在试图实现我们的愿景时犯错误。测试人员和QA专业人员是我们的安全网；他们在那里捕捉我们忘记的事情。但是，拥有安全网并不意味着你可以随心所欲地做任何事情。一旦你的代码初稿准备好，就是时候从创造性开发者转变为深思熟虑的分析性开发者——那个会查看他们的代码并注意到改进区域的人；即便如此，你仍然会错过一些东西。所以，你测试自己。那时你会发现问题。或者，你可能发现系统运行得不如你预期的流畅。也许你会发现结果不是预期的。那时调试舞会就开始了：你运行系统，尝试定位出错的地方，修复问题，然后重复整个循环。
- en: Tip
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Debugging can be a fun journey, or it can be an extremely frustrating experience.
    I am here to help you move your debugging experiences into a more fun one. If
    debugging means fixing bugs, then developing means creating bugs. There is nothing
    wrong with that, as long as you realize this is the case and you can resolve the
    issues before shipping. Let me help you with that!
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 调试可能是一次愉快的旅程，也可能是一次极其令人沮丧的经历。我在这里帮助你将调试体验转变为更加愉快的一种。如果调试意味着修复错误，那么开发意味着创建错误。这没有错，只要你意识到这一点，并且你可以在发货前解决这些问题。让我来帮助你吧！
- en: Debugging and profiling – an overview
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试和性能分析——概述
- en: I remember when they taught me how to write Cobol code on the university mainframe.
    It was a challenge, to be honest. The mainframe was a costly machine with many
    terminals attached. If you do not know what that means, imagine you have one computer
    with multiple keyboards and monitors connected to it, where each user can use
    their session to do their work, isolated from the others.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 我记得他们在大学主机的cobol代码编写教学。说实话，那是一个挑战。主机是一台昂贵的机器，连接了许多终端。如果你不知道那是什么意思，想象一下你有一台电脑，连接了多个键盘和显示器，每个用户都可以使用他们的会话来做自己的工作，与其他用户隔离。
- en: 'This worked fine when you had to do some simple stuff, such as working on a
    document or a spreadsheet; the mainframe could handle multiple sessions well.
    However, compiling code is something else: that takes a lot of CPU power. They
    fixed that by having the students submit their code to the compiler, which would
    then run sequentially at night. You could see what you did wrong when you returned
    the next day. Imagine forgetting a semicolon somewhere, meaning you have to wait
    another 24 hours before you can see the results of your fix. That way of working
    taught me to think about my code very thoroughly.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 当你需要做一些简单的事情时，比如处理文档或电子表格，这工作得很好；主机可以很好地处理多个会话。然而，编译代码是另一回事：那需要大量的CPU功率。他们通过让学生将代码提交给编译器来解决，编译器会在夜间依次运行。你可以在第二天回来时看到你做错了什么。想象一下在某个地方忘记了一个分号，这意味着你必须再等24小时才能看到你修复的结果。这种方式让我学会了非常仔细地思考我的代码。
- en: These days, when I enter C# code, I see the compiler working for me constantly.
    Visual Studio immediately tells me when I make a mistake.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，当我输入C#代码时，我可以看到编译器一直在为我工作。Visual Studio会立即告诉我我犯了错误。
- en: Debugging
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试
- en: '**Debugging** was out of the question. All we could do was stuff the code with
    logging messages, run the program, and see the output. Then, we could try to deduce
    the errors in our code from the log files.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: '**调试**是不可能的。我们所能做的就是往代码里填充日志消息，运行程序，然后查看输出。然后，我们可以尝试从日志文件中推断出我们代码中的错误。'
- en: 'Nowadays, it’s so much easier: you can step through your code, see the statements
    as they are executed, and inspect variables, memory, threads, and so on.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这要容易得多：你可以逐步执行你的代码，看到它们是如何执行的，并检查变量、内存、线程等等。
- en: Of course, the requirements of the software have also become much more complex,
    so writing software in itself hasn’t gotten any easier.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，软件的要求也变得更加复杂，所以编写软件本身并没有变得更容易。
- en: But modern debugging tools help – a lot.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 但现代调试工具帮助很大。
- en: '*Debugging is the process of identifying, isolating, and fixing problems or
    “bugs” in software. These bugs can be anywhere from simple syntax errors to more
    elusive logic errors that produce the wrong output* *or flow.*'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: '*调试是识别、隔离和修复软件中问题或“错误”的过程。这些错误可能从简单的语法错误到更难以捉摸的逻辑错误，这些错误会产生错误的输出或流程。*'
- en: 'The compiler helps us fix the most obvious mistakes: a typo in a statement
    is caught immediately. However, code that compiles does not result in a flawless
    program. Debugging can help remedy that.'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 编译器帮助我们修复最明显的错误：一个语句中的拼写错误会被立即捕捉到。然而，编译通过的代码并不意味着程序完美无瑕。调试可以帮助解决这个问题。
- en: Profiling
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析
- en: '**Profiling** is the twin of debugging. *While debugging aims to find logical
    errors, profiling is meant to help you find performance errors.* Performance errors
    can indicate that the system runs too slow, uses too much memory, or other things
    that stop the software from running as efficiently as possible.'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: '**性能分析**是调试的孪生兄弟。*虽然调试的目的是找到逻辑错误，但性能分析旨在帮助你找到性能错误。性能错误可能表明系统运行得太慢，使用太多的内存，或者其他阻止软件尽可能高效运行的事情。*'
- en: Profiling helps you improve the efficiency of your software. It shows you where
    the bottlenecks are. Profiling can help you pinpoint where your memory usage goes
    up and where your logic fails when encountering performance issues.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析可以帮助你提高软件的效率。它显示了瓶颈所在。性能分析可以帮助你确定内存使用增加的地方以及逻辑在遇到性能问题时失败的地方。
- en: Profiling can be as simple as logging some timing information or as complex
    as gathering 24 hours of activities of all your threads and performing a statistical
    analysis of that data. It all depends on your needs.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析可能只是记录一些时间信息，也可能像收集所有线程24小时的活动并对此数据进行统计分析那样复杂。这完全取决于你的需求。
- en: Debugging and profiling go hand in hand. With a profile session, you gather
    the evidence that something is not going as you want it to. You then use debugging
    techniques to find and fix the errors in your code.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 调试和性能分析是相辅相成的。在性能分析会话中，你收集了某些事情没有按预期进行的证据。然后，你使用调试技术来查找和修复代码中的错误。
- en: 'Of course, this process is more like a cycle. You debug, then you profile,
    then debug to find the issues, fix them, then debug the fixes, then profile the
    fixes, and so on. It’s a never-ending dance. However, it can be quite satisfying:
    in the end, you have much better code and a better-performing system, and that
    must make it all worth it!'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这个过程更像是一个循环。你调试，然后性能分析，然后调试以发现问题，修复它们，然后调试修复，然后性能分析修复，如此循环。这是一个永无止境的舞蹈。然而，这可以非常令人满意：最终，你有了更好的代码和性能更好的系统，这肯定使这一切都值得了！
- en: So, let’s investigate the tools we have to do all this magic!
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，让我们调查一下我们拥有的所有这些魔法工具！
- en: Debugging 101
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试101
- en: '**Visual Studio** is a great tool. It has many features that help you during
    development and the debugging process. So, it is natural to start by looking at
    Visual Studio first. I will not spend much time on debugging basics in Visual
    Studio. Still, I think revisiting the most apparent tools we have is immensely
    clarifying.'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: '**Visual Studio**是一个伟大的工具。它有许多在开发和调试过程中帮助你的功能。因此，首先查看Visual Studio是很自然的。我不会在Visual
    Studio中的调试基础知识上花费太多时间。然而，我认为回顾我们最明显的工具是非常有说明性的。'
- en: Debug builds versus Release builds
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试构建与发布构建
- en: Let’s talk about that dropdown at the top in Visual Studio, where you can choose
    between **Debug** and **Release**. I am sure you have a feeling about what this
    is all about. You pick **Debug** when you are still writing the code, and want
    to debug your software. You choose **Release** when you are ready to release your
    product.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈Visual Studio顶部那个下拉菜单，你可以在这里选择**调试**和**发布**。我确信你对这有什么感觉。当你还在编写代码并想要调试你的软件时，你选择**调试**。当你准备好发布你的产品时，你选择**发布**。
- en: However, there is a bit more you should know about those options. Let me start
    by saying that you can still debug your code if it is built in Release mode. It’s
    just a bit harder.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，还有一些关于这些选项的额外信息你应该知道。让我先说，即使代码是在发布模式下构建的，你仍然可以调试你的代码。只是稍微有点困难。
- en: 'Let me compare the results of a Debug setting and a Release setting. The following
    table shows the main differences:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我比较一下调试设置和发布设置的结果。以下表格显示了主要差异：
- en: '|  | **Debug** | **Release** |'
  id: totrans-43
  prefs: []
  type: TYPE_TB
  zh: '|  | **调试** | **发布** |'
- en: '| **Purpose** | Primarily for development. | Primarily for production. |'
  id: totrans-44
  prefs: []
  type: TYPE_TB
  zh: '| **目的** | 主要用于开发。 | 主要用于生产。 |'
- en: '| **Optimization** | Minimal or no optimization. | Highly optimized for performance
    and efficiency. The compiler removes unused code and applies various optimizations.
    |'
  id: totrans-45
  prefs: []
  type: TYPE_TB
  zh: '| **优化** | 最小或无优化。 | 高度优化以提升性能和效率。编译器会移除未使用的代码并应用各种优化。|'
- en: '| **Symbols** | Includes debugging symbols (`.pdb` files), which provide detailed
    information about the code (e.g., variable names, line numbers, and so on). |
    No or limited symbols. You can still get a `.pdb` file, but it will have much
    less information. |'
  id: totrans-46
  prefs: []
  type: TYPE_TB
  zh: '| **符号** | 包含调试符号（`.pdb` 文件），它们提供了有关代码的详细信息（例如，变量名、行号等）。 | 没有或有限的符号。你仍然可以得到一个
    `.pdb` 文件，但它将包含较少的信息。|'
- en: '| **Assertions** | Debug assertions are enabled. | Debug assertions are disabled.
    |'
  id: totrans-47
  prefs: []
  type: TYPE_TB
  zh: '| **断言** | 调试断言被启用。 | 调试断言被禁用。|'
- en: '| **Performance** | Generally slower because there is no optimization. | Generally
    faster and more efficient. |'
  id: totrans-48
  prefs: []
  type: TYPE_TB
  zh: '| **性能** | 通常较慢，因为没有优化。 | 通常更快且更高效。|'
- en: '| **Size** | Larger files due to extra debugging information. | Smaller because
    of optimizations and removal of debugging information. |'
  id: totrans-49
  prefs: []
  type: TYPE_TB
  zh: '| **大小** | 由于额外的调试信息，文件更大。 | 由于优化和调试信息的移除，文件更小。|'
- en: 'Table 11.1: Comparing Debug and Release builds'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.1：比较调试和发布构建
- en: I suggest you use Debug builds when debugging. That is what it is for.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我建议你在调试时使用调试构建。这就是它的用途。
- en: Breakpoints
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 断点
- en: The best tool Visual Studio offers is the mighty **breakpoint**. It is a straightforward
    construct, but it can help us a lot when trying to understand what is happening
    inside our application.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 提供的最佳工具是强大的 **断点**。这是一个简单的结构，但它在我们试图理解应用程序内部发生的事情时非常有帮助。
- en: In the simplest form, a breakpoint is a code point that stops the program when
    the application reaches the code statement to which the breakpoint is attached.
    You can add breakpoints to all sorts of things as long as they are statements.
    You cannot add a breakpoint to a code comment.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在最简单的情况下，断点是一个代码点，当应用程序到达与之关联的代码语句时，程序会停止。只要它们是语句，你就可以将断点添加到各种事物上。你不能在代码注释上添加断点。
- en: You cannot set a breakpoint on a method declaration, but you can set it on the
    first `{` that marks the beginning of the method.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能在方法声明上设置断点，但你可以在标记方法开始的第一个 `{` 上设置断点。
- en: Also, declarations of variables are not a valid target for a breakpoint unless
    you do an assignment simultaneously.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，变量的声明不是有效的断点目标，除非你同时进行赋值操作。
- en: 'For instance, look at the following two lines:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，看看以下两行：
- en: '[PRE0]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'We cannot add a breakpoint to the line where we declare `i`. We can add a breakpoint
    to the second line. Technically, that line consists of two parts: the declaration
    and the assignment; the breakpoint is set on the assignment part.'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能在声明 `i` 的行上设置断点。我们可以在第二行上设置断点。技术上，该行由两部分组成：声明和赋值；断点设置在赋值部分。
- en: Namespace declarations and `using` statements are also invalid targets. Interfaces
    cannot have breakpoints, just as attribute declarations are excluded.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 命名空间声明和 `using` 语句也是无效的目标。接口不能有断点，就像属性声明被排除一样。
- en: However, besides these obvious cases, you can place them wherever you want.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，除了这些明显的例子之外，你可以将它们放置在任何你想放置的地方。
- en: What happens when a breakpoint is hit?
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 当遇到断点时会发生什么？
- en: 'We have some software, placed a breakpoint, and ran the software. At one point,
    the execution point reaches our breakpoint. The question is: what happens then?'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有一些软件，放置了断点，并运行了软件。在某个时刻，执行点达到我们的断点。问题是：然后会发生什么？
- en: 'First, the execution stops. The program is frozen in time. In Visual Studio,
    some additional tools come to life:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，执行停止。程序被冻结在时间点上。在 Visual Studio 中，一些额外的工具开始活跃：
- en: '**Locals**: This window opens or updates, showing all variables reachable in
    the current scope'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**局部变量**：此窗口打开或更新，显示当前作用域中可访问的所有变量'
- en: '**Autos**: This window displays variables used in the current line and the
    surrounding context'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动监视**：此窗口显示当前行及其周围上下文中使用的变量'
- en: '**Watch**: This window shows any variables you might have added to the Watch'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**监视器**：此窗口显示你可能添加到监视器的任何变量'
- en: '**Call Stack**: This window displays a series of method calls that led up to
    the current breakpoint'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**调用堆栈**：此窗口显示一系列导致当前断点的方法调用'
- en: '**Immediate**: This window allows you to type commands, evaluate expressions,
    or change variable values on the fly'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**即时**：此窗口允许你即时输入命令、评估表达式或更改变量值'
- en: With the program paused, you can inspect or modify variable values if necessary.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当程序暂停时，如果需要，你可以检查或修改变量值。
- en: This helps you understand what happens in your program. However, it can lead
    to weird situations if you are not careful.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这有助于你理解程序中发生的情况。然而，如果你不小心，这可能会导致奇怪的情况。
- en: 'Let’s have a look at what I mean. Imagine you have this code somewhere:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我的意思。想象你在这段代码的某个地方：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'This code iterates over the `i` variable, increasing it and adding its value
    to the `sum` variable. If you run this, you get the result of `55`. Now, place
    a breakpoint inside the loop. Run the code again, but after the ninth iteration,
    you decide you want to see what happens in that loop one more time. So, you change
    the value of `i` from `9` back to `0`. The `sum` variable will not make any sense
    anymore: the outcome is a vastly different value.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码遍历`i`变量，增加它的值并将其添加到`sum`变量中。如果你运行这个，你会得到`55`的结果。现在，在循环内部放置一个断点。再次运行代码，但在第九次迭代后，你决定你想再次查看该循环中发生的情况。所以，你将`i`的值从`9`改回`0`。`sum`变量将不再有任何意义：结果是截然不同的值。
- en: This sample is simple, but these side effects can happen quite quickly. Changing
    variables might have unintended consequences. So, be aware of that.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例很简单，但这些副作用可能会很快发生。更改变量可能会有意外的后果。所以，要注意这一点。
- en: Threads and breakpoints
  id: totrans-76
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程和断点
- en: Later in this chapter, we will discuss debugging multithreaded applications,
    but I want to discuss one item here. I said that when the code hits a breakpoint,
    the debugger stops execution.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的后面部分，我们将讨论调试多线程应用程序，但我想在这里讨论一个项目。我说当代码遇到断点时，调试器会停止执行。
- en: 'Look at this code:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 看看这段代码：
- en: '[PRE2]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The code is straightforward enough. First, we get a `thread` from `ThreadPool`.
    An infinite loop logs a message in `thread`, increases a `counter`, and waits
    for 100 milliseconds.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 代码足够简单。首先，我们从`ThreadPool`获取一个`thread`。一个无限循环在`thread`中记录一条消息，增加一个`counter`，并等待100毫秒。
- en: In the main part of the code, we do something similar but at a different time.
    Running this program shows that we get two messages from the inner thread for
    each message from the outer thread. Now, place a breakpoint on the last `Task.Delay()`
    statement. Run the code, let the debugger hit the breakpoint, wait for a few seconds,
    and continue the run.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在代码的主要部分，我们做类似的事情，但时间不同。运行这个程序显示，对于外层线程的每条消息，我们都会从内层线程得到两条消息。现在，在最后一个`Task.Delay()`语句上放置一个断点。运行代码，让调试器遇到断点，等待几秒钟，然后继续运行。
- en: Suppose you do that a couple of times. In that case, you will notice that although
    the sequence of the messages to the console is slightly different, we still get
    twice as many messages from the inner thread. In other words, if we pause the
    outer thread, the inner thread is also paused.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你这样做几次。在这种情况下，你会注意到尽管发送到控制台的消息序列略有不同，但我们仍然从内层线程得到两倍多的消息。换句话说，如果我们暂停外层线程，内层线程也会暂停。
- en: 'That is good, of course. You do not want other threads to continue, wreaking
    havoc on the program flow. But let’s change things a bit: replace the code where
    we create the thread with the following:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，这是好的。你不想其他线程继续，破坏程序流程。但让我们稍微改变一下：将创建线程的代码替换为以下内容：
- en: '[PRE3]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Instead of having a `thread`, we now have a `timer`. This code achieves the
    same effect as our previous code: the `timer` works on a separate `thread` when
    the time has passed. If that happens, we will log the message and increase the
    counter.'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个`timer`而不是`thread`。这段代码实现了我们之前代码相同的效果：当时间过去时，`timer`在单独的`thread`上工作。如果发生这种情况，我们将记录消息并增加计数器。
- en: However, if we repeat the little trick we did with the breakpoint on the code
    in the last loop, you will notice a completely different behavior. The number
    of messages from the timer is no longer double the number we get from the main
    loop; it is much more than that.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，如果我们重复我们在上一个循环中对代码设置的断点的小技巧，你会注意到完全不同的行为。计时器发出的消息数量不再是来自主循环的两倍；它要多得多。
- en: A breakpoint does not stop timers. Neither does it stop classes such as `Stopwatch`.
    Time-based events still happen, so you have a different outcome than expected.
    Be mindful of that when you use timers!
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 断点不会停止计时器。它也不会停止像`Stopwatch`这样的类。基于时间的事件仍然会发生，所以你得到的结果与预期不同。使用计时器时要小心这一点！
- en: Features of breakpoints
  id: totrans-88
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断点的特性
- en: 'Breakpoints are more than just markers to show the debugger where to stop the
    execution. They have some properties that can be helpful if you use them correctly.
    Most of these settings are accessed by clicking the breakpoint in the **Breakpoints**
    window and selecting **Settings**. That window looks like this:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 断点不仅仅是向调试器显示停止执行位置的标记。它们有一些属性，如果您正确使用，可能会很有帮助。大多数这些设置都是通过在**断点**窗口中单击断点并选择**设置**来访问的。该窗口看起来像这样：
- en: "![Figure 1\uFEFF1.1: The Breakpoint Settings window in Visual Studio](img/B20924_12_01.jpg)"
  id: totrans-90
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.1：Visual Studio 中的断点设置窗口](img/B20924_12_01.jpg)'
- en: 'Figure 11.1: The Breakpoint Settings window in Visual Studio'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.1：Visual Studio 中的断点设置窗口
- en: You can also get this window by clicking on one of the settings you get when
    you right-click the breakpoint bullet in the code editor.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以通过在代码编辑器中右键单击断点项目并选择其中一个设置来获取此窗口。
- en: Active and inactive breakpoints
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 激活和未激活断点
- en: 'Breakpoints by default are active, meaning that if the debugger comes to the
    statement containing the breakpoint, the execution stops. But you can also disable
    the breakpoint: this means the breakpoint is still there, but it does not do anything.
    This option can be handy if you are debugging some code but want to skip a specific
    breakpoint at this time but do not want to delete it.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，断点是激活的，这意味着如果调试器到达包含断点的语句，则执行停止。但您也可以禁用断点：这意味着断点仍然存在，但它不会做任何事情。如果您正在调试某些代码但想跳过当前特定断点但又不想删除它，这个选项可能很有用。
- en: Conditional breakpoints
  id: totrans-95
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 条件断点
- en: A conditional breakpoint only breaks when a particular condition has been met.
    The condition can be a single condition or a set of conditions, all of which must
    be true. The condition can include variables from the code as well. Let’s imagine
    I want a breakpoint in the previous code sample. I want the breakpoint to be on
    the line with the `Task.Delay()`code. However, I only want that breakpoint to
    be active if the `outThreadCounter` variable is larger than `5` and only if that
    breakpoint has been hit 6 times. In our code, that should be the same (every time
    we go through that loop, `outThreadCounter` is increased), but if this doesn’t
    happen, you can verify it using this technique.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 条件断点仅在满足特定条件时才会中断。条件可以是一个条件或一组条件，所有这些条件都必须为真。条件还可以包括代码中的变量。让我们想象一下，我想在之前的代码示例中设置一个断点。我想断点在包含
    `Task.Delay()` 代码的行上。然而，我只希望当 `outThreadCounter` 变量大于 `5` 且该断点已被触发 6 次时，该断点才处于活动状态。在我们的代码中，这应该是相同的（每次我们通过该循环时，`outThreadCounter`
    都会增加），但如果这种情况没有发生，您可以使用此技术来验证。
- en: You can specify this by placing a breakpoint, right-clicking on it, and then
    choosing **Conditions**.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过放置断点、右键单击它，然后选择**条件**来指定此设置。
- en: Action breakpoints or tracepoints
  id: totrans-98
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 操作断点或跟踪点
- en: '**Action breakpoints** can be real breakpoints or breakpoints that do not break.
    But besides breaking (or not), you can also specify that the debugger should write
    something in the **Output** window. In other words, this is a very lightweight
    and temporary log system. You can output a static text or the contents of a variable.
    Underneath the option where you specify the output, you can place a checkmark
    in the box saying **Continue code execution**. If you check that box, the debugger
    does not stop at this breakpoint and only displays the required information in
    the Output window. When you do not stop executing the code and only display some
    information, we call these breakpoints **tracepoints**.'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: '**操作断点**可以是真正的断点或不会中断的断点。但除了中断（或不中断）之外，您还可以指定调试器应在**输出**窗口中写入某些内容。换句话说，这是一个非常轻量级且临时的日志系统。您可以输出静态文本或变量的内容。在指定输出的选项下方，您可以在表示**继续代码执行**的框中放置勾选标记。如果您勾选该框，调试器不会在此断点处停止，而只会在输出窗口中显示所需信息。当您不停止执行代码而只显示一些信息时，我们称这些断点为**跟踪点**。'
- en: One-time breakpoint
  id: totrans-100
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单次断点
- en: A **one-time breakpoint** only works once. It stops code execution when the
    breakpoint is hit and then disables itself. If you want to use it again, you must
    manually enable it. You create this breakpoint by selecting **Disable breakpoint**
    **once hit**.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '**单次断点**只工作一次。当断点被触发时，它会停止代码执行并禁用自己。如果您想再次使用它，必须手动启用它。您可以通过选择**一旦触发禁用断点**来创建此断点。'
- en: Dependent breakpoint
  id: totrans-102
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 依赖断点
- en: The **dependent breakpoint** is only enabled after another breakpoint has been
    hit. This is particularly useful if you have a method that is called from different
    places in your code. Still, you only want to debug a particular path. In that
    case, you create a breakpoint in the flow you are interested in (you might even
    make it non-breakable so that it only acts as a trigger) and then connect the
    breakpoint in the method you are interested in into that first breakpoint.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: '**依赖断点**只有在另一个断点被触发后才会启用。如果你有一个在代码中从不同地方调用的方法，这尤其有用。尽管如此，你可能只想调试特定的路径。在这种情况下，你可以在你感兴趣的流程中创建一个断点（你甚至可以将其设置为不可中断，使其仅作为触发器）然后，将你感兴趣的该方法中的断点连接到第一个断点。'
- en: The effect is that the breakpoint is disabled until that first breakpoint is
    hit.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是，断点在第一个断点被触发之前是禁用的。
- en: 'To see this in action, take our last example. Increase the time for the `1`
    second (1000 milliseconds). Then, add a breakpoint to the line where we write
    the message to the console. Tick the **Action** box in the properties of this
    breakpoint, but do not add anything to the **Message** dialog. However, make sure
    you tick the **Continue code execution** box. The settings should look like this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 要看到这个效果，请参考我们的最后一个示例。将 `1` 秒（1000 毫秒）的时间增加。然后，在写入消息到控制台的行上添加一个断点。勾选此断点的**操作**属性中的**动作**框，但不要在**消息**对话框中添加任何内容。然而，请确保勾选**继续代码执行**框。设置应该看起来像这样：
- en: "![Figure 1\uFEFF1.2: Trigger breakpoint](img/B20924_12_02.jpg)"
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.2：触发断点](img/B20924_12_02.jpg)'
- en: 'Figure 11.2: Trigger breakpoint'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.2：触发断点
- en: 'Then, add another breakpoint to the line where we write the console the value
    of `outThreadCounter`. This time, change the settings to enable the **Only enable
    when the following breakpoint is hit** option and select the other breakpoint
    in the corresponding drop-down menu. That should look like this:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，在写入 `outThreadCounter` 控制台值的行上添加另一个断点。这次，将设置更改为启用**仅在以下断点被触发时启用**选项，并在相应的下拉菜单中选择其他断点。它应该看起来像这样：
- en: "![Figure 1\uFEFF1.3: Depend\uFEFFent breakpoint](img/B20924_12_03.jpg)"
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.3：依赖断点](img/B20924_12_03.jpg)'
- en: 'Figure 11.3: Dependent breakpoint'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.3：依赖断点
- en: If you run the program, the debugger ignores the last breakpoint during the
    first second. Then, the execution stops since our first breakpoint has been hit.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行程序，调试器在前一秒钟会忽略最后一个断点。然后，由于我们的第一个断点被触发，执行停止。
- en: Of course, you can combine these settings at will.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，你可以随意组合这些设置。
- en: Adding other breakpoints quickly
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 快速添加其他断点
- en: You probably know that you can add breakpoints to your code by clicking in what
    is known as **the gutter** to the left of the source code. If you do that, a red
    bullet appears in that gutter to indicate you have added a breakpoint at that
    position. But did you know you can also right-click in that gutter? If you do
    that, you get a pop-up menu to quickly add the breakpoints that were previously
    mentioned. In the long run, this might save you some mouse clicks!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能知道，你可以通过点击源代码左侧的所谓**空白区域**来添加断点到你的代码。如果你这样做，空白区域会出现一个红色项目符号，表示你已在那个位置添加了断点。但你是否知道你还可以在空白区域右键点击？如果你这样做，你会得到一个弹出菜单，可以快速添加之前提到的断点。从长远来看，这可能会节省你一些鼠标点击！
- en: Some other features
  id: totrans-115
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 一些其他功能
- en: 'Breakpoints have some other nice features that might be helpful. You usually
    access these in the **Breakpoints** window in Visual Studio by right-clicking
    the chosen breakpoint. Here are some of them:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 断点还有一些其他可能很有用的功能。你通常通过在 Visual Studio 的**断点**窗口中右键点击选定的断点来访问这些功能。以下是一些例子：
- en: '**Breakpoints can have labels**: This way, you can give more meaningful names
    to the breakpoints.'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**断点可以有标签**：这样，你可以给断点起更有意义的名字。'
- en: '**You can group breakpoints**: If you create a breakpoint group, you can add
    breakpoints to them. This way, you can quickly turn a large group of breakpoints
    on or off instead of going through them individually.'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你可以分组断点**：如果你创建了一个断点组，你可以将断点添加到其中。这样，你可以快速打开或关闭大量断点，而无需逐个处理。'
- en: '**You can search for breakpoints**: In the breakpoints window, you can search
    for class names, line numbers, output, labels, and so on. This feature might be
    helpful if you have a large group of breakpoints.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你可以搜索断点**：在断点窗口中，你可以搜索类名、行号、输出、标签等。如果你有一大批断点，这个功能可能很有帮助。'
- en: '**You can sort breakpoints by name, condition, hit count, label, and more**:
    If you still can’t find what you need, you might want to reconsider your breakpoint
    strategy!'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**你可以按名称、条件、命中次数、标签等对断点进行排序**：如果你仍然找不到你需要的东西，你可能需要重新考虑你的断点策略！'
- en: 'Most developers I encounter never come near all these options: all they do
    is toggle a breakpoint on a line of code to stop execution. But I hope you begin
    to appreciate the power these tools can bring you.'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我遇到的大多数开发者从未接近所有这些选项：他们所做的只是在一行代码上切换断点以停止执行。但我希望你能开始欣赏这些工具能为你带来的力量。
- en: Debug windows
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试窗口
- en: Visual Studio has a lot of windows that can help you get a grip on what is happening
    when you debug. Most of these windows are useless when editing code but come to
    life once the debugger starts. Let’s see what we have!
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio有很多窗口可以帮助你在调试时了解发生了什么。当编辑代码时，这些窗口大多数都是无用的，但一旦开始调试，它们就会变得活跃。让我们看看我们有什么！
- en: Breakpoints
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 断点
- en: 'We already discussed breakpoints, but I want to point out the **Breakpoints**
    window. This window is where you see all the breakpoints in your application.
    It also shows additional information about those breakpoints. You can add columns
    to the window if you need more information. This is an example of what might look
    like:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经讨论了断点，但我想要指出**断点**窗口。这个窗口是你查看应用程序中所有断点的地方。它还显示了有关这些断点的附加信息。如果你需要更多信息，你可以向窗口添加列。以下是一个示例：
- en: "![Figure 1\uFEFF1.4: The Breakpoints window](img/B20924_12_04.jpg)"
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图11.4：断点窗口](img/B20924_12_04.jpg)'
- en: 'Figure 11.4: The Breakpoints window'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.4：断点窗口
- en: You can customize this window to fit your needs.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以自定义这个窗口以满足你的需求。
- en: Locals, autos, and watches
  id: totrans-129
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 局部变量、自动变量和监视
- en: When debugging, you probably want to see the values of the variables in your
    code. To see the value, you can hover the mouse over a variable in the code editor
    window. However, there are windows in Visual Studio dedicated to giving you access
    to that data. Let’s explore these.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 在调试时，你可能想看到代码中变量的值。要查看值，你可以在代码编辑器窗口中悬停鼠标在变量上。然而，Visual Studio中有一些窗口专门用于提供访问这些数据的方式。让我们来探索这些窗口。
- en: 'The **Locals** window shows all the variables in the current scope. That can
    be pretty useful: you see all variables in the current block without being distracted
    by other variables.'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: '**局部变量**窗口显示了当前作用域中的所有变量。这非常有用：你可以在不受到其他变量的干扰的情况下看到当前块中的所有变量。'
- en: 'The **Autos** window is even better: it tries to guess which variables interest
    you when you break in the code and show them and their values.'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '**自动变量**窗口甚至更好：它试图猜测当你中断代码时哪些变量对你感兴趣，并显示它们及其值。'
- en: 'Let’s have a look at this. We have the following class:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个。我们有以下类：
- en: '[PRE4]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'We use it in the following code (I added line numbers so I can refer to the
    lines later on):'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在以下代码中使用它（我添加了行号，这样我可以在以后引用这些行）：
- en: '[PRE5]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, add a breakpoint on *line 3*. Run the code and see whether your output
    matches mine. I will step through all lines from *3* up until *7* and show you
    what the **Autos** window tells me.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在*第3行*设置一个断点。运行代码，看看你的输出是否与我的匹配。我将逐步执行从*第3行*到*第7行*的所有行，并展示**自动变量**窗口告诉我什么。
- en: 'The first breakpoint is on *line 3*, so the debugger stops there. It breaks
    on *line 3*, with the following result in the **Autos** window:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个断点在第*3行*，所以调试器在那里停止。它在*第3行*中断，**自动变量**窗口中的以下结果是：
- en: '| **Name** | **Value** | **Type** |'
  id: totrans-139
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **值** | **类型** |'
- en: '| `myNumber` | `0` | Int |'
  id: totrans-140
  prefs: []
  type: TYPE_TB
  zh: '| `myNumber` | `0` | Int |'
- en: Table 11.2
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.2
- en: 'Now, step to the following line. Then we get, if we stop on *line 4*, we get
    the following results:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，转到下一行。如果我们停在*第4行*，我们会得到以下结果：
- en: '| **Name** | **Value** | **Type** |'
  id: totrans-143
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **值** | **类型** |'
- en: '|  |  |  |'
  id: totrans-144
  prefs: []
  type: TYPE_TB
  zh: '|  |  |  |'
- en: Table 11.3
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.3
- en: As you can see, we get no results. We stopped on `{`, and no variables can influence
    the path of the code now. So, there is nothing to show. Let’s continue and step
    to the following line, *line 5*.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，我们没有得到任何结果。我们停在`{`上，现在没有变量可以影响代码的路径。所以，没有东西可以显示。让我们继续并逐步到下一行，*第5行*。
- en: '| **Name** | **Value** | **Type** |'
  id: totrans-147
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **值** | **类型** |'
- en: '| `myClass` | `{``myClass}` | MyClass |'
  id: totrans-148
  prefs: []
  type: TYPE_TB
  zh: '| `myClass` | `{``myClass}` | MyClass |'
- en: '| `Counter` | `0` | Int |'
  id: totrans-149
  prefs: []
  type: TYPE_TB
  zh: '| `Counter` | `0` | Int |'
- en: '| `myClass.Counter` | `0` | int |'
  id: totrans-150
  prefs: []
  type: TYPE_TB
  zh: '| `myClass.Counter` | `0` | int |'
- en: Table 11.4
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 表11.4
- en: If you step to that line, you will see two items. The top one, `myClass`, can
    be expanded so you can see properties that might interest you. In our case, this
    is `myClass.Counter`. We also see the `myClass.Counter` variable separately since
    the compiler is smart enough to see this is significant in our code.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你单步执行到那一行，你会看到两个条目。上面的一个，`myClass`，可以展开，以便你可以看到可能对你感兴趣的性质。在我们的例子中，这是 `myClass.Counter`。我们还单独看到了
    `myClass.Counter` 变量，因为编译器足够聪明，能够看到这在我们的代码中很重要。
- en: Let’s move to the next line, *line 6*.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们转到下一行，*第 6 行*。
- en: '| **Name** | **Value** | **Type** |'
  id: totrans-154
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **值** | **类型** |'
- en: '| `MyClass.Counter.get returned` | `0` | int |'
  id: totrans-155
  prefs: []
  type: TYPE_TB
  zh: '| `MyClass.Counter.get returned` | `0` | int |'
- en: '| `myClass` | `{``myClass}` | MyClass |'
  id: totrans-156
  prefs: []
  type: TYPE_TB
  zh: '| `myClass` | `{``myClass}` | MyClass |'
- en: '| `Counter` | `1` | Int |'
  id: totrans-157
  prefs: []
  type: TYPE_TB
  zh: '| `Counter` | `1` | Int |'
- en: '| `myClass.Counter` | `1` | int |'
  id: totrans-158
  prefs: []
  type: TYPE_TB
  zh: '| `myClass.Counter` | `1` | int |'
- en: Table 11.5
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.5
- en: 'That is interesting: the `MyClass.Counter.get`) and got a result. There is
    also an icon to show you that this is indeed the return value. The “get” returned
    zero, but then we applied the `++` operator to change the value locally.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 这很有趣：我们调用了 `MyClass.Counter.get`) 并得到了一个结果。还有一个图标来显示这确实是一个返回值。`get` 返回了零，但随后我们应用了
    `++` 运算符来改变局部值。
- en: 'The next line, *line 7*, produces this:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个行，*第 7 行*，产生了这个：
- en: '| **Name** | **Value** | **Type** |'
  id: totrans-162
  prefs: []
  type: TYPE_TB
  zh: '| **名称** | **值** | **类型** |'
- en: '| `MyClass.Counter.get returned` | `1` | int |'
  id: totrans-163
  prefs: []
  type: TYPE_TB
  zh: '| `MyClass.Counter.get returned` | `1` | int |'
- en: '| `System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear
    returned` | `Counter 1` | string |'
  id: totrans-164
  prefs: []
  type: TYPE_TB
  zh: '| `System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear
    returned` | `Counter 1` | string |'
- en: Table 11.6
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.6
- en: We printed the line of text to the console and did that with the `$` interpolation
    command in front of the string. Now, you can see that doing that caused the `System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear()`
    method to be called, returning the resulting `Counter 1` string. Oh, and we lost
    `myClass` (well, it’s not lost; it’s just not shown any more since we will not
    use it in this scope anymore). As you can see, the **Locals** window is good at
    showing values of local variables and helping you figure out implicit method calls,
    such as the string interpolation and property getters!
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将文本行打印到控制台，并使用字符串前的 `$` 插值命令来完成。现在，你可以看到这样做触发了 `System.Runtime.CompilerServices.DefaultInterpolatedStringHandler.ToStringAndClear()`
    方法，返回了结果字符串 `Counter 1`。哦，而且我们失去了 `myClass`（嗯，它并没有丢失；只是由于我们在这个作用域内不再使用它，所以不再显示）。正如你所见，**局部变量**窗口擅长显示局部变量的值，并帮助你找出隐式方法调用，例如字符串插值和属性获取器！
- en: The **Locals** window is pretty clever at figuring out what you need to see.
    Of course, if you disagree, there is always the **Watch** window.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '**局部变量** 窗口非常擅长确定你需要看到什么。当然，如果你不同意，总有 **监视** 窗口。'
- en: 'The **Watch** window does the same as the previous two debug windows, but it
    only shows you what you ask it to show. Once the debugger stops the flow of your
    program, you can right-click on a variable and select **Add to Watch**. The variable
    will then pop up in the **Watch** window, where you can do the same things as
    you can do with **Locals** and **Autos**: inspect the variables and change the
    values if needed.'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: '**监视** 窗口与前面的两个调试窗口做的是同样的事情，但它只显示你要求它显示的内容。一旦调试器停止了程序的流程，你可以在一个变量上右键单击并选择 **添加到监视**。然后变量将出现在
    **监视** 窗口中，你可以像在 **局部变量** 和 **自动** 中一样执行相同的操作：检查变量并在需要时更改值。'
- en: 'However, this time, the variables stay there until you remove them. Suppose
    they go out of scope or are unreachable. In that case, you get an error in the
    **Watch** window telling you the variable does not exist in the current context.
    That doesn’t harm your experience, though: it will stay there as long as you need
    it, and if the variable comes back into context (in this or in a subsequent debugging
    session), it will be back again.'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这次，变量会一直保留，直到你将其移除。假设它们超出作用域或不可达。在这种情况下，你会在 **监视** 窗口中得到一个错误，告诉你变量在当前上下文中不存在。但这并不会损害你的体验：它会一直保留，直到你需要它，如果变量再次进入上下文（在这个或随后的调试会话中），它将再次出现。
- en: Diagnostic Tools
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 诊断工具
- en: The **Diagnostic Tools** window almost deserves its very own book. It does many
    things for us! Let’s dive into it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '**诊断工具** 窗口几乎值得拥有它自己的书籍。它为我们做了很多事情！让我们深入了解一下。'
- en: 'As with most other debugging tools in Visual Studio, you cannot use the **Diagnostic
    Tools** until you are at a breakpoint in your code while debugging. We will use
    a very silly program to show you some of **Diagnostic Tools**’ possibilities.
    It’s a **console application**, and the code looks like this:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 与Visual Studio中的大多数其他调试工具一样，你不能在调试代码时使用**诊断工具**。我们将使用一个非常愚蠢的程序来展示一些**诊断工具**的可能性。它是一个**控制台应用程序**，代码看起来像这样：
- en: '[PRE6]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'I also place a conditional breakpoint on the line with `passCounter++` (so,
    the first statement is in the while-loop). That condition looks like this:'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 我还在`passCounter++`的行上放置了一个条件断点（因此，第一个语句是在while循环中）。这个条件看起来是这样的：
- en: '[PRE7]'
  id: totrans-175
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: In other words, the breakpoint stops every 100 passes.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，断点每100次迭代就会停止。
- en: 'If we run this, the application will break on the first pass. That makes sense:
    0 % of 100 equals 0\. You can then open the **Diagnostic Tools** window (if it
    doesn’t show up automatically, you can open it by going to the **Debug** menu,
    then choosing **Windows**, followed by selecting **Show Diagnostic Tools**). I
    suggest you make the window bigger than usual so you can see all the goodies it
    gives us. Mine looks like this:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行这个，应用程序将在第一次迭代时中断。这是有道理的：100%的0等于0。然后，你可以打开**诊断工具**窗口（如果它没有自动显示，你可以通过转到**调试**菜单，然后选择**窗口**，接着选择**显示诊断工具**来打开它）。我建议你将窗口放大，以便可以看到它给我们提供的所有好东西。我的看起来像这样：
- en: "![Figure 1\uFEFF1.5: The Diagnostic Tools window](img/B20924_12_05.jpg)"
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.5：诊断工具窗口](img/B20924_12_05.jpg)'
- en: 'Figure 11.5: The Diagnostic Tools window'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.5：诊断工具窗口
- en: At the top of the window, there are some charts. Since nothing has happened
    yet in our program, these are not very interesting. But that will change! Below
    the charts, there are some tabs. Initially, you see the **Summary** tab, which
    summarizes the contents of the other tabs.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 在窗口顶部有一些图表。由于我们的程序还没有发生任何变化，这些图表并不很有趣。但那将会改变！在图表下方有一些标签页。最初，你看到的是**摘要**标签页，它总结了其他标签页的内容。
- en: In the **Summary** tab, click **Take Snapshot** under the **Memory Usage** title.
    You can also do that in the **Memory Usage** tab itself. Doing this saves the
    current memory usage and allows it to be compared to a later point in time. Since
    our application hasn’t done much, this could give us a baseline. So, click on
    **Take Snapshot**. Then, continue running the program.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在**摘要**标签页中，点击**内存使用**标题下的**捕获快照**。你也可以在**内存使用**标签页本身这样做。这样做会保存当前的内存使用情况，并允许它在未来的某个时间点进行比较。由于我们的应用程序没有做很多事情，这可以给我们提供一个基线。所以，点击**捕获快照**。然后，继续运行程序。
- en: 'If you click **Take Snapshot**, the window should show you the **Memory Usage**
    tab, which shows the snapshot. Since we continued the program, we are not on the
    100th iteration, so we can take another snapshot. Do that. That results in my
    system in this view:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你点击**捕获快照**，窗口应该显示**内存使用**标签页，它显示了快照。由于我们继续了程序，我们不在第100次迭代，所以我们可以再次捕获快照。这样做。这导致我的系统在这个视图下：
- en: "![Figure 1\uFEFF1.6: Second pass in the Diagnostic Tools window](img/B20924_12_06.jpg)"
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.6：诊断工具窗口的第二遍](img/B20924_12_06.jpg)'
- en: 'Figure 11.6: Second pass in the Diagnostic Tools window'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.6：诊断工具窗口的第二遍
- en: 'This is getting more interesting. We can see in the **Process Memory (MB)**
    chart that we have started to allocate a lot more memory. But the real exciting
    stuff happens in the **Memory Usage** tab below. You can see a lot here: in the
    second snapshot, we can see that we have allocated more objects and memory.'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 这变得越来越有趣。我们可以从**进程内存（MB）**图表中看到，我们已经开始分配更多的内存。但真正令人兴奋的事情发生在下面的**内存使用**标签页中。这里有很多内容：在第二个快照中，我们可以看到我们分配了更多的对象和内存。
- en: You can click on most values, such as `Count Diff.` column to sort on that.)
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击大多数值，例如`Count Diff.`列来按该列排序。)
- en: "![Figure 1\uFEFF1.7: Memory snapshot](img/B20924_12_07.jpg)"
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.7：内存快照](img/B20924_12_07.jpg)'
- en: 'Figure 11.7: Memory snapshot'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.7：内存快照
- en: We have 99 more `Byte[]` objects in memory, resulting in an increase of 104,858,955
    bytes of memory.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在内存中有99个更多的`Byte[]`对象，导致内存增加了104,858,955字节。
- en: You can do all sorts of things here. You can click on the line you want to learn
    more about and then drill down into the source code of that object. That way,
    you can probably discover why your memory usage is increasing.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在这里做各种事情。你可以点击你想了解更多信息的行，然后钻入该对象的源代码。这样，你可能会发现为什么你的内存使用在增加。
- en: A lot is going on in **Diagnostic Tools**. I suggest you play around with it
    and see what it can tell you about your system!
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在**诊断工具**中有很多事情在进行。我建议你尝试一下，看看它能告诉你关于你系统的一些什么信息！
- en: Debugging multithreaded and asynchronous code
  id: totrans-192
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 调试多线程和异步代码
- en: Let’s join the league of super debuggers. We are about to embark on a journey
    into the depths of multithreaded systems and where they go wrong.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们加入超级调试员的行列。我们即将开始一段探索多线程系统深处的旅程，以及它们出错的地方。
- en: 'Multithreaded code is notoriously hard to debug. Imagine you have two threads
    that interact with each other, and then things go wrong. However, if you step
    through the methods in Visual Studio, things work just fine, and that makes sense:
    some bugs appear only when certain timing conditions happen.'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 多线程代码调试起来特别困难。想象一下，你有两个相互交互的线程，然后出了问题。然而，如果你在Visual Studio中逐步执行方法，一切都会正常工作，这是有道理的：一些错误只有在特定的时机条件下才会出现。
- en: Parallel Watch
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 并行监视
- en: 'What about this: you have multiple threads, and something goes wrong. You want
    to inspect what happens in that thread. But if you set a breakpoint, how do you
    know you are in the correct thread?'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，如果你有多个线程，并且出了问题。你想要检查那个线程中发生的事情。但如果你设置了一个断点，你怎么知道你是在正确的线程中呢？
- en: 'Fear not: Visual Studio can help with this. Let’s start with the following
    code:'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 不要害怕：Visual Studio可以帮助你解决这个问题。让我们从以下代码开始：
- en: '[PRE8]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'This code creates 10 threads. Each thread has an infinite loop, displaying
    some text and counting up. However, each thread does this at a different speed:
    they all wait for a random time between each iteration.'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码创建了10个线程。每个线程都有一个无限循环，显示一些文本并计数。然而，每个线程以不同的速度执行这些操作：它们都在每次迭代之间等待随机的时间。
- en: 'Place a conditional breakpoint somewhere in that loop, with the condition saying
    it should break with this condition: `counter % 10 == 0`. Now, run the program.'
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个循环的某个地方放置一个条件断点，条件是它应该满足这个条件：`counter % 10 == 0`。现在，运行程序。
- en: You see the `counter` value in the **Autos** or **Locals** windows. That can
    be helpful; that variable is local to the thread you are currently in. Visual
    Studio did pause all other threads for us, but we have no idea what the state
    of the data is in those threads. How can we find out?
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在**Autos**或**Locals**窗口中看到`counter`值。这可能很有帮助；这个变量是你当前线程的局部变量。Visual Studio为我们暂停了所有其他线程，但我们不知道那些线程中数据的状态。我们该如何找出答案呢？
- en: 'The answer to that question is this: open the **Parallel Watch** window. Again,
    you can find this in the **Debug** | **Windows** menu. On my system, after breaking
    in my breakpoint, it looks like this:'
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案是：打开**并行监视**窗口。同样，你可以在**调试** | **窗口**菜单中找到它。在我的系统中，在断点中断后，它看起来像这样：
- en: "![Figure 1\uFEFF1.8: The Parallel Watch window](img/B20924_12_08.jpg)"
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![图1.8：并行监视窗口](img/B20924_12_08.jpg)'
- en: 'Figure 11.8: The Parallel Watch window'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.8：并行监视窗口
- en: In this particular case, I have apparently stopped execution in thread 14628\.
    That doesn’t tell me much.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的情况下，我显然是在线程14628处停止了执行。这并没有告诉我太多。
- en: Add a Parallel Watch
  id: totrans-206
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加一个并行监视
- en: 'But as you can see, on the top of the window, it says `counter` variable there.
    As soon as I do that, the **Watch** window shows me the value of that variable,
    but it does that for each thread:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 但正如你所见，在窗口的顶部，它写着`counter`变量。当我这样做的时候，**监视**窗口就显示了这个变量的值，但它为每个线程都这样做：
- en: "![Figure 1\uFEFF1.9: Parallel Watch with counter added](img/B20924_12_09.jpg)"
  id: totrans-208
  prefs: []
  type: TYPE_IMG
  zh: '![图1.9：添加了计数器的并行监视](img/B20924_12_09.jpg)'
- en: 'Figure 11.9: Parallel Watch with counter added'
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.9：添加了计数器的并行监视
- en: As you can see in the screenshot, all threads have their version of the `counter`,
    each with a different value. This is helpful!
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 如截图所示，所有线程都有自己的`counter`版本，每个都有不同的值。这很有帮助！
- en: Jumping to frames
  id: totrans-211
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 跳转到帧
- en: Although this window is primarily a **Watch** window, meaning it shows the variables
    you are interested in and their values, there are other things you can do here
    as well.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这个窗口主要是**监视**窗口，意味着它显示你感兴趣的变量及其值，但在这里你还可以做其他事情。
- en: Since we stopped somewhere in the loop, you can hover over the variables in
    your code to see the values. However, as we discovered, those values only apply
    to that thread. You can add all the variables you are interested in into the **Parallel
    Watch** window, but what if you just want to see a variable once? Well, the **Parallel
    Watch** window can help you. Select one of the other threads in that window and
    right-click on that line, and you will see a context menu. One of the options
    is **Switch To Frame**. If you do that, the debugger makes the chosen thread the
    current one, allowing you to investigate the values of all variables in scope
    for that particular thread.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在循环的某个地方停止了，你可以将鼠标悬停在代码中的变量上以查看其值。然而，正如我们所发现的，这些值仅适用于该线程。你可以将所有你感兴趣的变量添加到**并行监视**窗口中，但如果你只想查看一个变量一次怎么办？嗯，**并行监视**窗口可以帮助你。在窗口中选择其他线程，然后右键单击该行，你将看到一个上下文菜单。其中一个选项是**切换到帧**。如果你这样做，调试器将所选线程设置为当前线程，允许你调查该特定线程作用域内所有变量的值。
- en: This way, you can jump between all active threads and inspect all values of
    all variables in scope per thread.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这样，你可以在所有活动线程之间跳转，并检查每个线程作用域内所有变量的值。
- en: Freezing and thawing threads
  id: totrans-215
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 冻结和解冻线程
- en: The ability to inspect variables in different threads is a potent tool. You
    can probably imagine that certain variables affect other threads. Finding issues
    usually requires a lot of logging and inspections of those logs to determine the
    results of unwanted behavior. Being able to break the code and see what is happening
    saves you from a lot of that work.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 检查不同线程中变量的能力是一个强大的工具。你可能可以想象某些变量会影响其他线程。发现问题通常需要大量的日志记录和对这些日志的检查，以确定不希望的行为的结果。能够中断代码并查看正在发生的事情可以让你避免很多这样的工作。
- en: But sometimes, all those threads running simultaneously can get in the way.
    In those cases, you might want to focus on one or some threads in isolation. The
    **Freeze** and **Thaw** options can help in this situation.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 但有时，所有这些同时运行的线程可能会造成干扰。在这种情况下，你可能想要单独关注一个或一些线程。**冻结**和**解冻**选项可以帮助你处理这种情况。
- en: Freezing a thread is nothing more than pausing it during debugging. You temporarily
    halt the execution of one or more threads so you can focus on what is important
    to you. When you have all the information you need, you can thaw the frozen threads
    and let them resume their regular work. You can use the **Thread** window, but
    you can also do that in the **Parallel Watch** window. All you have to do is right-click
    on the thread you want to freeze and select **Freeze** from the context menu.
    If you resume the program, the thread you have chosen to freeze will not do anything
    anymore.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结线程不过是调试过程中暂停它。你暂时停止一个或多个线程的执行，以便你能专注于对你来说重要的事情。当你收集到所有需要的信息后，你可以解冻被冻结的线程，让它们恢复常规工作。你可以使用**线程**窗口，但也可以在**并行监视**窗口中这样做。你只需右键单击你想冻结的线程，并在上下文菜单中选择**冻结**即可。如果你继续程序，你选择的冻结线程将不再执行任何操作。
- en: 'To see that behavior in action, change the number of threads in our code to
    2 instead of 2\. Rerun the program and see which thread is active when the breakpoint
    hits. Obviously, one of the threads will cause the breakpoints condition (the
    `counter` variable in that thread must be a multiple of 10) to be satisfied. If
    you then resume the program, the other thread will likely be the following thread
    to stop: it is probably also close to satisfying the condition (I say “probably,”
    since the random behavior of the `Wait()` statement might, in theory, make it
    possible to act otherwise).'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看这种行为，将我们代码中的线程数从2改为2。重新运行程序，并查看断点触发时哪个线程是活动的。显然，其中一个线程将导致断点条件（该线程中的`counter`变量必须是10的倍数）得到满足。如果你然后继续程序，其他线程很可能是下一个停止的线程：它可能也接近满足条件（我说“可能”，因为`Wait()`语句的随机行为在理论上可能使其有可能采取其他行动）。
- en: Restart the program and wait for the first time the breakpoint becomes active.
    This time, right-click on the other thread and select **Freeze**. Resume the program.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 重新启动程序，等待断点第一次变为活动状态。这次，右键单击其他线程并选择**冻结**。继续程序。
- en: "![Figure 1\uFEFF1.10: Freezing threads in Parallel Watch](img/B20924_12_10.jpg)"
  id: totrans-221
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.10：在并行监视中冻结线程](img/B20924_12_10.jpg)'
- en: 'Figure 11.10: Freezing threads in Parallel Watch'
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.10：在并行监视中冻结线程
- en: 'A pause symbol should be in front of the chosen thread. Resume the program.
    When the program breaks again, it will be on the same thread as the first time
    it did this. If you resume, the third time will also be on that thread. That makes
    sense: the other thread is not doing anything and thus never satisfies the breakpoint
    conditions.'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 暂停符号应该位于所选线程之前。继续程序。当程序再次中断时，它将位于第一次执行此操作时的同一线程。如果你继续，第三次也将是在那个线程上。这很有道理：其他线程什么都没做，因此永远不会满足断点条件。
- en: 'Now, you can work on that one working thread to make sure you get what is going
    on. When you are ready to have the thread join the rest of the program, wait until
    the breakpoint happens again. Then, you can right-click the frozen thread and
    “thaw” it. Resume the program and see whether everything is back to normal: the
    debugger will break as soon as the condition is met in any of the threads.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以专注于那个正在运行的线程，以确保你了解发生了什么。当你准备好让线程加入程序的其他部分时，等待断点再次发生。然后，你可以右键单击冻结的线程并“解冻”它。继续程序，看看是否一切恢复正常：调试器将在任何线程满足条件时立即中断。
- en: 'Freeze and Thaw: a word of warning'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结和解冻：一句警告
- en: 'As you probably saw, the program continues after thawing the thread without
    adjusting anything. Typically, the `counter` variable values in both threads should
    be close to each other. However, after freezing one thread, it falls behind, and
    it doesn’t catch up on that lag anymore. Freezing and thawing threads can have
    an unpredictable side effect: if the rest of your code somehow relies on that
    thread running, you might have inadvertently changed the logic flow. So, be aware
    of that!'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，在解冻线程而没有调整任何东西之后，程序继续运行。通常，两个线程中的`counter`变量值应该相近。然而，在冻结一个线程后，它落后了，并且它无法弥补那个滞后。冻结和解冻线程可能会有不可预测的副作用：如果你的代码的其他部分以某种方式依赖于那个线程的运行，你可能会无意中改变了逻辑流程。所以，请注意这一点！
- en: Freezing and thawing can be a lovely addition to your tool belt. So, use them
    if needed, but use them wisely!
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 冻结和解冻可以成为你工具箱中的一项美好补充。所以，如果需要，请使用它们，但请明智地使用！
- en: Debugging deadlocks with Parallel Stacks and Thread windows
  id: totrans-228
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用并行堆栈和线程窗口调试死锁
- en: Deadlocks are pretty nasty. Simply put, a **deadlock** is when two threads wait
    for each other and thus cannot continue. It’s like driving your car on a narrow
    road and seeing someone coming from the other side. One of you will have to back
    off, or you will never leave that road. Deadlocks are like that, but your application
    freezes since neither of the involved threads is willing to drive back. I think
    it is obvious that you would not want that in your code.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 死锁相当讨厌。简单来说，**死锁**是两个线程相互等待，因此无法继续的情况。这就像你在狭窄的道路上开车，看到对面有人过来。你们其中一个人必须退后，否则你们将永远无法离开那条路。死锁就像这样，但你的应用程序因为涉及的线程都不愿意退后而冻结。我认为在代码中你肯定不希望这样。
- en: However, as simple as the issue sounds, it can be challenging to debug and fix.
    But Visual Studio is here to help!
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管问题听起来很简单，但调试和修复它可能具有挑战性。但Visual Studio在这里可以帮助你！
- en: 'Let’s begin with a simple program. This is the code:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从一个小程序开始。这是代码：
- en: '[PRE9]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'What do we do here? Simply put, we create two threads. They each use a `lock`
    statement. This means no other thread can enter that scope until the thread that
    owns the `lock` statement is done. That is not an issue in this code: both threads
    use a different `lock`. However, we also tried to use the other `lock` object
    in the thread. Because we have a `Thread.Sleep(1000)` in each thread, both threads
    have enough time to acquire the `lock` before accessing the other `lock`. But
    that never happens. No thread can release the `lock` since it waits for the other
    thread – and vice versa.'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里做什么？简单来说，我们创建了两个线程。它们各自使用一个`lock`语句。这意味着在没有拥有`lock`语句的线程完成之前，其他线程不能进入该作用域。在这段代码中这不是问题：两个线程使用不同的`lock`。然而，我们也试图在另一个线程中使用那个`lock`对象。因为我们每个线程都有一个`Thread.Sleep(1000)`，所以两个线程在访问另一个`lock`之前都有足够的时间获取`lock`。但这从未发生。没有线程可以释放`lock`，因为它在等待另一个线程——反之亦然。
- en: 'Run it. You will see that both threads print out their initial statements about
    acquiring their `lock`s. And then: nothing. The program is completely frozen.
    It doesn’t do anything anymore. We have a deadlock on our hands.'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 运行它。你会看到两个线程打印出它们关于获取它们的`lock`s的初始语句。然后：什么都没有。程序完全冻结了。它不再做任何事情。我们遇到了死锁。
- en: In this case, what is going on is obvious. Still, I am sure you can imagine
    these situations can be tricky to find in typical programs. The good news is that
    Visual Studio usually knows what is happening and can tell us.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，发生的事情很明显。尽管如此，我相信您可以想象在典型程序中找到这些情况可能会很棘手。好消息是 Visual Studio 通常知道发生了什么，并且可以告诉我们。
- en: Stop the program execution by going to the **Debug** menu, and then clicking
    on **Break All**. When Visual Studio has the focus, you can also press *Ctrl*
    + *Alt* + *Break*.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 通过转到 **调试** 菜单并单击 **全部中断** 来停止程序执行。当 Visual Studio 获得焦点时，您也可以按 *Ctrl* + *Alt*
    + *Break*。
- en: 'Breaking like this stops all threads as if the debugger has hit a breakpoint.
    Visual Studio stops at one of the three threads (the main thread or one of the
    bad-behaving ones), and you get a warning like this one:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以这种方式中断会停止所有线程，就像调试器遇到了断点一样。Visual Studio 停在三个线程之一（主线程或行为不良的线程），您会收到如下警告：
- en: "![Figure 1\uFEFF1.11: Deadlock detected by Visual Studio](img/B20924_12_11.jpg)"
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.11：Visual Studio 检测到的死锁](img/B20924_12_11.jpg)'
- en: 'Figure 11.11: Deadlock detected by Visual Studio'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.11：Visual Studio 检测到的死锁
- en: 'So, at least know what caused the freezing: we have a deadlock. It is time
    to find out what is going on.'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，至少要知道导致冻结的原因：我们遇到了死锁。现在是时候找出发生了什么。
- en: Parallel Stacks
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 并行堆栈
- en: 'In *Figure 11**.12*, you see the **Show Parallel Stacks** option in that dialog
    box. You can also get the **Parallel Stacks** window through the **Debug** | **Windows**
    menu option. Doing that gives you a nice visual representation of all currently
    known threads. On my machine, that looks like this:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 在 *图 11.12* 中，您可以看到该对话框中的 **显示并行堆栈** 选项。您也可以通过 **调试** | **窗口** 菜单选项获取 **并行堆栈**
    窗口。这样做会为您提供一个所有当前已知线程的直观表示。在我的机器上，它看起来像这样：
- en: "![Figure 1\uFEFF1.12: Parallel Stacks in action](img/B20924_12_12.jpg)"
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.12：并行堆栈在行动中](img/B20924_12_12.jpg)'
- en: 'Figure 11.12: Parallel Stacks in action'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.12：并行堆栈在行动中
- en: 'Since we have very few threads running, spotting the issue is straightforward.
    The offending threads are marked with a red circle with a white line: the symbol
    globally known as a stop sign. This symbol indicates the threads that are currently
    deadlocked. To make it even more apparent, the information box below says **[Deadlocked,
    double-click or press enter to view]**. You can double-click on the **Waiting
    on lock** line to jump to the source code for this thread.'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们运行的线程很少，找到问题很简单。有问题的线程用红色圆圈和白色线条标记：这是全球公认的停止标志符号。此符号表示当前处于死锁状态的线程。为了使其更加明显，下面的信息框中写着
    **[死锁，双击或按 Enter 查看详细信息]**。您可以双击 **等待锁** 行以跳转到该线程的源代码。
- en: This window helps you identify thread issues very quickly. You can see which
    threads are running, if there are any issues, and where those threads originated
    from.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 此窗口帮助您非常快速地识别线程问题。您可以看到哪些线程正在运行，是否存在任何问题，以及这些线程的来源。
- en: But if that is not enough, you can go deeper by looking at the **Threads** window.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 但如果这还不够，您可以通过查看 **线程** 窗口来深入了解。
- en: Threads window
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 线程窗口
- en: As you might have guessed from the name, the **Threads** window shows you all
    the threads you might be interested in. Let’s continue with our deadlock example.
    You have looked at **Parallel Stacks**, but you cannot find what is happening.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 如您从名称中猜测到的，**线程** 窗口显示了您可能感兴趣的线程。让我们继续我们的死锁示例。您已经查看了 **并行堆栈**，但找不到发生了什么。
- en: 'So, you open the **Threads** window. On my machine, it looks like this:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，您打开 **线程** 窗口。在我的机器上，它看起来像这样：
- en: "![Figure 1\uFEFF1.13: The Threads window](img/B20924_12_13.jpg)"
  id: totrans-251
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.13：线程窗口](img/B20924_12_13.jpg)'
- en: 'Figure 11.13: The Threads window'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.13：线程窗口
- en: 'These are all the threads currently known in my application. They are all up
    and running, and the current thread has an ID of `95264` (or managed thread ID
    `10`). It is a thread from the thread pool since the name is `.NET TP Worker`.
    You can also see the location: it is in my application.'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 这些都是我应用程序中目前已知的所有线程。它们都在运行，当前线程的 ID 为 `95264`（或托管线程 ID `10`）。这是一个线程池中的线程，因为其名称为
    `.NET TP Worker`。您还可以看到位置：它在我的应用程序中。
- en: 'If you click on the down arrow next to the name, you get more details:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您单击名称旁边的向下箭头，您会获得更多详细信息：
- en: "![Figure 1\uFEFF1.14: The Thread window with more details](img/B20924_12_14.jpg)"
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.14：带有更多详细信息的线程窗口](img/B20924_12_14.jpg)'
- en: 'Figure 11.14: The Thread window with more details'
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.14：带有更多详细信息的线程窗口
- en: As you can see in the screenshot, this gives me more information, including
    the text that this thread is deadlocked and is waiting on a lock owned by thread
    `14840`. The **Thread** window also shows information about that particular thread,
    so you can open that one if you want to. Double-clicking on the location brings
    you to the source code, where you can investigate what you were doing before the
    whole thing came crashing.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 如截图所示，这为我提供了更多信息，包括此线程已死锁并正在等待由线程 `14840` 拥有的锁。**线程**窗口也显示了有关该特定线程的信息，因此如果您想查看，可以打开它。双击位置将带您到源代码，在那里您可以调查在所有事情崩溃之前您做了什么。
- en: Debugging threading issues is not easy. But without these tools, they can be
    found more easily than ever before. Of course, the best course of action is not
    to make mistakes in the first place, but as I explained to my manager all those
    years ago, we do not live in that kind of world.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 调试线程问题并不容易。但如果没有这些工具，它们比以往任何时候都更容易被发现。当然，最好的做法是首先不犯错误，但正如我多年前向我的经理解释的那样，我们并不生活在一个那样的世界。
- en: Profiling application performance
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能分析应用程序性能
- en: By now, we have established that system programmers care about speed. Applications
    need to be as efficient and as fast as possible. But what if you think your application
    can go faster but do not know where or what to improve? That is where profiling
    and benchmarking can help.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们已经确定系统程序员关心速度。应用程序需要尽可能高效和快速。但如果你认为你的应用程序可以更快，但不知道在哪里或如何改进，那么性能分析和基准测试就可以帮助。
- en: 'Profiling is measuring and analyzing the performance of your application in
    terms of factors such as CPU usage, memory pressure, network performance, and
    so on. It’s like putting your app under a microscope. Things we look at during
    profiling are, amongst others, the following:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析是衡量和分析您应用程序的性能，包括CPU使用率、内存压力、网络性能等因素。这就像把您的应用程序放在显微镜下。在性能分析期间，我们关注的因素包括以下内容：
- en: '**CPU usage**: Identify which parts of your application are using the most
    processing power'
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**CPU使用率**：确定您的应用程序中哪些部分使用了最多的处理能力'
- en: '**Memory usage**: Track how much memory is used and finding memory leaks or
    excessive allocations'
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内存使用**：追踪使用了多少内存以及寻找内存泄漏或过度分配'
- en: '**Function call frequency**: See which methods are called the most and how
    long they take'
  id: totrans-264
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**函数调用频率**：查看哪些方法被调用得最多以及它们耗时多久'
- en: '**Performance hotspots**: Pinpoint areas of code that are slower than they
    should be'
  id: totrans-265
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**性能热点**：确定代码中比预期慢的区域'
- en: '**Benchmarking** is related, but it is different. Benchmarking is measuring
    the performance of your code under different circumstances or comparing different
    approaches. This process involves running predefined tests and capturing metrics.
    Some of the metrics are the following:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: '**基准测试**与之相关，但它不同。基准测试是在不同情况下衡量您的代码性能或比较不同方法。这个过程涉及运行预定义的测试并捕获指标。以下是一些指标：'
- en: '**Execution time**: Measuring how long it takes for a piece of code to run'
  id: totrans-267
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**执行时间**：测量一段代码运行所需的时间'
- en: '**Throughput**: Assessing how many operations or transactions can be processed
    in a given period'
  id: totrans-268
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**吞吐量**：评估在给定时间内可以处理多少操作或事务'
- en: '**Latency**: Determining the delay between the initiation and the execution
    of a task'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**延迟**：确定任务启动和执行之间的延迟'
- en: Profiling and benchmarking go hand in hand and are often used together to improve
    your application.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析和基准测试是相辅相成的，通常一起使用来改进您的应用程序。
- en: The prime application
  id: totrans-271
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '**主要应用程序**'
- en: 'To investigate how we might do this, let’s start with a program we want to
    improve performance. It is a simple program that calculates all the primes in
    the range 0 – 100,000 and sums them up. It’s nothing fancy or helpful, but it
    requires the CPU to do much work. We also want to see whether we can make things
    better. So, let’s start by looking at the code. First, we create a class called
    `PrimeCalculator`. That’s easy enough. The main method of this class is the `Run`
    method. It looks like this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 为了调查我们如何做到这一点，让我们从一个我们想要提高性能的程序开始。这是一个简单的程序，它计算0 – 100,000范围内的所有素数并将它们相加。它没有什么花哨的或有用的，但它需要CPU做很多工作。我们还想看看我们是否可以使事情变得更好。所以，让我们先看看代码。首先，我们创建一个名为
    `PrimeCalculator` 的类。这很简单。这个类的主要方法是 `Run` 方法。它看起来像这样：
- en: '[PRE10]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: There is nothing special going on here. We create a `Stopwatch` to time the
    duration, then call the `SumOfPrimes()` method that does all the actual work.
    Finally, we display the results and the duration.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别的事情发生。我们创建一个`Stopwatch`来计时持续时间，然后调用执行所有实际工作的`SumOfPrimes()`方法。最后，我们显示结果和持续时间。
- en: 'Let’s look at `SumOfPrimes()` next:'
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`SumOfPrimes()`：
- en: '[PRE11]'
  id: totrans-276
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'This code is also pretty basic. We loop for all values between `2` and the
    given limit (`2` since `1` is technically not a prime number) and check whether
    that number is a prime. If it is, we add it to the sum. Let’s move to `IsPrime()`:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码也很基础。我们循环遍历从`2`到给定限制（`2`，因为从技术上讲`1`不是一个质数）之间的所有值，并检查该数字是否为质数。如果是，我们就将其加到总和中。让我们转到`IsPrime()`：
- en: '[PRE12]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This method is a lousy implementation to see whether a number is a prime, but
    it is simple enough to follow. We do this by checking whether the number we give
    it is divisible by any number that is less than the square root of that number.
    If it is divisible, it is not a prime.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法是一个糟糕的实现，用于判断一个数字是否为质数，但它足够简单，易于理解。我们通过检查我们给出的数字是否可以被小于该数字平方根的任何数字整除来实现这一点。如果它可以被整除，那么它就不是质数。
- en: 'For example, if I run this on the machine I am writing this text on, I get
    the sum of 454, 396, 537 and a total duration of 21 milliseconds. I have no idea
    if that sum is correct; I have no intention of calculating it by hand on my calculator
    app on my phone. It doesn’t matter: we are here to see whether we can spot bottlenecks.'
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我在我写这段文字的机器上运行这个程序，我得到的结果是454,396,537，总耗时为21毫秒。我不知道这个总和是否正确；我无意在我的手机上的计算器应用程序中手动计算它。这无关紧要：我们在这里是为了看看我们是否可以找到瓶颈。
- en: 21 milliseconds sounds like a short amount of time, but in reality, it is pretty
    long. After all, computers are fast these days, so I am sure I can improve on
    it. We can use the profiling tools from Visual Studio to see where the bottlenecks
    are.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 21毫秒听起来像是一段很短的时间，但实际上相当长。毕竟，现在的计算机速度很快，所以我确信我可以改进它。我们可以使用Visual Studio的剖析工具来查看瓶颈在哪里。
- en: Profiling in Visual Studio
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Visual Studio中的分析
- en: In Visual Studio, under the main **Debug** menu, you find the **Performance
    Profile** option. The default shortcut key for that is *Alt* + *F2*, which might
    be helpful if you repeatedly run this (and you will!)
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 在Visual Studio中，在主**调试**菜单下，您会找到**性能分析**选项。该选项的默认快捷键是*Alt* + *F2*，如果您经常运行此操作（您会的！）可能会很有帮助。
- en: 'If you select that option, you see the following screen:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您选择该选项，您将看到以下屏幕：
- en: "![Figure 1\uFEFF1.15: Start of a profiling session](img/B20924_12_15.jpg)"
  id: totrans-285
  prefs: []
  type: TYPE_IMG
  zh: '![图11.15：分析会话的开始](img/B20924_12_15.jpg)'
- en: 'Figure 11.15: Start of a profiling session'
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.15：分析会话的开始
- en: 'Profiling can be done on many different levels. However, the most crucial choice
    is what you want to profile. By default, this tool chooses the current application.
    As you can see, in my case, that is the `11_Profiling` project. You can select
    other projects or running processes, browse for an application, and so on. Click
    that large **Change Target** button to change if necessary. There is also a warning
    underneath that button: we might want to switch from a Debug profile to a Release
    profile. Release is more closely related to what you run in production, so the
    figures you get are more like the ones you expect to see when you have deployed
    your application. However, Release mode optimizes your code, making it harder
    to find programming mistakes. So, I tend to leave it to Debug during development.'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 分析可以在许多不同的层面上进行。然而，最重要的选择是您想要分析的内容。默认情况下，这个工具选择当前的应用程序。正如您所看到的，在我的情况下，那就是`11_Profiling`项目。您可以选择其他项目或正在运行的过程，浏览应用程序，等等。如果需要，点击那个大型的**更改目标**按钮进行更改。按钮下面还有一个警告：我们可能想要从调试配置文件切换到发布配置文件。发布模式与您在生产环境中运行的内容更为紧密相关，因此您得到的数字更像是您在部署应用程序时预期看到的数字。然而，发布模式优化了您的代码，使得查找编程错误变得更加困难。所以，我倾向于在开发期间将其保留为调试模式。
- en: 'Then, you have to decide what you want to see. There are many options here:
    you might want to see async/awaits, or maybe you are interested in database communications.
    In my case, I want to know about **CPU Usage**. I also leave **.NET Counters**
    and **Memory Usage** checked; they might be helpful.'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，您必须决定您想查看什么。这里有许多选项：您可能想查看异步/等待，或者您可能对数据库通信感兴趣。在我的情况下，我想了解**CPU使用率**。我还勾选了**.NET计数器**和**内存使用率**；它们可能很有帮助。
- en: If you click the **Start** button, your program will build and run. In the background,
    Visual Studio starts collecting the information.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您点击**开始**按钮，您的程序将构建并运行。在后台，Visual Studio开始收集信息。
- en: In our case, the program runs and ends, signaling Visual Studio to stop collecting.
    If your application keeps running, you must stop the program manually or click
    the **stop collecting** button in Visual Studio.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，程序运行并结束，向Visual Studio发出停止收集的信号。如果你的应用程序继续运行，你必须手动停止程序或点击Visual Studio中的**停止收集**按钮。
- en: Once you have done that, Visual Studio shows you an overview of what it has
    collected.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你这样做，Visual Studio就会向你展示它收集的概览。
- en: "![Figure 1\uFEFF1.16: First results from a profiling session](img/B20924_12_16.jpg)"
  id: totrans-292
  prefs: []
  type: TYPE_IMG
  zh: '![图11.16：分析会话的第一批结果](img/B20924_12_16.jpg)'
- en: 'Figure 11.16: First results from a profiling session'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.16：分析会话的第一批结果
- en: 'The results are not that impressive since we have a straightforward program.
    However, you can see in the `_11_Profiling.PrimeCalculator.IsPrime(int)` method
    takes a lot of time: 10 microseconds, or 10.64% of the total time.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的程序很简单，所以结果并不那么令人印象深刻。然而，你可以看到在`_11_Profiling.PrimeCalculator.IsPrime(int)`方法中花费了很多时间：10微秒，占总时间的10.64%。
- en: 'That is good to know, but we want to see whether we can get more information.
    Click on that line, and you will get another view. You can select what you want
    to see at the top of that view. By default, you see all data grouped by **Functions**,
    but I want to see the call path. If you do that, you get this result:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 这很好，但我们想看看是否可以获得更多信息。点击那一行，你会得到另一个视图。你可以在视图的顶部选择你想看到的内容。默认情况下，你看到的是按**函数**分组的所有数据，但我想看到调用路径。如果你这样做，你会得到这个结果：
- en: "![Figure 1\uFEFF1.17: The hot path leading to the slowest function](img/B20924_12_17.jpg)"
  id: totrans-296
  prefs: []
  type: TYPE_IMG
  zh: '![图11.17：导致最慢函数的热路径](img/B20924_12_17.jpg)'
- en: 'Figure 11.17: The hot path leading to the slowest function'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.17：导致最慢函数的热路径
- en: You can click **Show Hot Path** and **Expand Hot Path** to see how the process
    came to the slowest function.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以点击**显示热路径**和**展开热路径**来查看过程是如何导致最慢函数的。
- en: 'Finally, you can double-click on a line to see the source code. So, if you
    double-click on the `IsPrime()` method, you get this:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你可以双击一行来查看源代码。所以，如果你双击`IsPrime()`方法，你会得到这个：
- en: "![Figure 1\uFEFF1.18: The slowest lines of code highlighted](img/B20924_12_18.jpg)"
  id: totrans-300
  prefs: []
  type: TYPE_IMG
  zh: '![图11.18：突出显示的代码慢行](img/B20924_12_18.jpg)'
- en: 'Figure 11.18: The slowest lines of code highlighted'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 图11.18：突出显示的代码慢行
- en: 'Now, it becomes clear that the loop is the slowest part of the `IsPrime()`
    function. That makes sense: to make this loop work, the CPU has to calculate `Math.Sqrt(number)`
    every time. That takes time. How to improve that is obvious: pre-calculate that
    square root and use that variable in the `for` statement. That should speed things
    up!'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，很明显，循环是`IsPrime()`函数中最慢的部分。这很有道理：为了让这个循环工作，CPU每次都必须计算`Math.Sqrt(number)`。这需要时间。如何改进这一点是显而易见的：预先计算这个平方根，并在`for`语句中使用这个变量。这应该能加快速度！
- en: 'As you can see, with the proper tooling, you can identify the bottlenecks in
    your application. Once you find them, you can restructure your code or replace
    parts with something faster. But how do you know which algorithm to use to speed
    things up? The answer to that is this: benchmark them!'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，有了适当的工具，你可以识别出应用程序中的瓶颈。一旦找到它们，你可以重构代码或用更快的部分替换。但你怎么知道该使用哪种算法来加速呢？答案是：基准测试它们！
- en: Benchmarking different solutions
  id: totrans-304
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对不同解决方案进行基准测试
- en: I know that the `number % i ==0` line is not the fastest way to see whether
    a number is divisible by another number. However, I am not really sure how much
    quicker other ways are. To find out, I can use some benchmarking to figure it
    out.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 我知道`number % i == 0`这一行不是查看一个数是否能被另一个数整除的最快方式。然而，我并不确定其他方法能快多少。为了找出答案，我可以使用一些基准测试来解决这个问题。
- en: There are several ways you can start with benchmarking, but in a case such as
    this, where I have several options for a specific algorithm, I like to use the
    `Benchmarkdotnet` NuGet package. This free package makes benchmarking simple.
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 你有几种方式可以从基准测试开始，但在像这种情况一样，我有几个特定算法的选项时，我喜欢使用`Benchmarkdotnet` NuGet包。这个免费包使基准测试变得简单。
- en: To do this, start a new console application. Add the `Benchmarkdotnet` package
    to the project. Then, create a new class. I call this class `ModuloTesters` since
    I want to test the performance of the `Module` operator and any alternatives I
    can find.
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，请启动一个新的控制台应用程序。将`Benchmarkdotnet`包添加到项目中。然后，创建一个新的类。我称这个类为`ModuloTesters`，因为我想要测试`Module`运算符的性能以及我能找到的任何替代方案。
- en: 'I added a method called `TestModulo`. That method looks like this:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 我添加了一个名为`TestModulo`的方法。这个方法看起来像这样：
- en: '[PRE13]'
  id: totrans-309
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: As you can see, it is pretty simple. I just go through several iterations (`numberOfLoopCount`
    is defined as a constant in my class, and I have set it to 100,000) and calculate
    the modulo (`testNumber` is again a constant; it doesn’t really matter what it
    is, but I have set it to 400). The only thing that makes this method stand out
    from a typical method is the `[Benchmark]` attribute. This tells the benchmark
    tool that this method needs to be measured.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，这很简单。我只是进行几次迭代（`numberOfLoopCount`在我的类中定义为常量，我将其设置为 100,000）并计算模数（`testNumber`再次是一个常量；它实际上并不重要，但我将其设置为
    400）。使这个方法区别于典型方法的唯一因素是`[Benchmark]`属性。这告诉基准测试工具需要测量这个方法。
- en: 'In the main program file, we need to kickstart the benchmarking. That is extremely
    easy: just add this line of code:'
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 在主程序文件中，我们需要启动基准测试。这非常简单：只需添加以下代码行：
- en: '[PRE14]'
  id: totrans-312
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Set the build mode to `Release`, and run without debugging. The `Benchmark`
    tool will run the methods marked with `Benchmark` a couple of times (well, more
    than just a couple) and present you with the results.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 将构建模式设置为`发布`，并运行不带调试。`Benchmark`工具将运行标记为`Benchmark`的方法几次（好吧，不止几次）并展示结果。
- en: 'But before we look at those results, we need to add something. Benchmarking
    is meant to compare solutions to a problem. Right now, we have one solution: the
    modulo operator. So, there is nothing to compare against. Let’s fix that. Add
    a new method to the `ModuloTesters` class that looks like this:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 但在我们查看这些结果之前，我们需要添加一些内容。基准测试的目的是比较解决问题的方案。目前，我们只有一个解决方案：取模运算符。所以，没有什么可以比较的。让我们来解决这个问题。向`ModuloTesters`类添加一个新方法，如下所示：
- en: '[PRE15]'
  id: totrans-315
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This is another way of calculating a module. But is it faster? There is only
    one way to find out: run the benchmark! If you do that, you see the results. On
    my machine, it looks like this:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一种计算模数的新方法。但它更快吗？唯一找到答案的方法是运行基准测试！如果您这样做，您会看到结果。在我的机器上，它看起来像这样：
- en: "![Figure 1\uFEFF1.19: Benchmark results](img/B20924_12_19.jpg)"
  id: totrans-317
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.19：基准测试结果](img/B20924_12_19.jpg)'
- en: 'Figure 11.19: Benchmark results'
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.19：基准测试结果
- en: 'So, the new algorithm is quicker: it takes 316.4 microseconds instead of 316.7
    microseconds. Ok, I admit it is not that much faster. Maybe we can do better.
    You know what? We can. Let’s add a third benchmark:'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，新的算法更快：它只需要 316.4 微秒，而不是 316.7 微秒。好吧，我承认这并没有快多少。也许我们可以做得更好。你知道吗？我们可以。让我们添加第三个基准测试：
- en: '[PRE16]'
  id: totrans-320
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Since all the calculations can be done independently, we can probably do them
    in parallel. So, that is what I am doing here: I use the `Parallel.For()` statement
    to divide the work into jobs that run simultaneously. I need a lock to update
    `numberOfMatches`, which might slow down the loop. But that is a guess: let’s
    test this. Run the benchmark. This is what I get:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 由于所有计算都可以独立完成，我们可能可以并行地完成它们。所以，这就是我在这里所做的事情：我使用`Parallel.For()`语句将工作分成同时运行的作业。我需要一个锁来更新`numberOfMatches`，这可能会减慢循环的速度。但这只是一个猜测：让我们来测试一下。运行基准测试。这是我得到的结果：
- en: "![Figure 1\uFEFF1.20: New benchmark results](img/B20924_12_20.jpg)"
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![图 11.20：新的基准测试结果](img/B20924_12_20.jpg)'
- en: 'Figure 11.20: New benchmark results'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 图 11.20：新的基准测试结果
- en: Now, that is interesting. The addition of `Parallel.For()` made a massive difference
    in the time spent on that method.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，这很有趣。添加了`Parallel.For()`之后，该方法所花费的时间有了巨大的变化。
- en: If you think that could benefit your code, you can apply the findings to the
    actual application you are working on. Of course, I would profile it first, make
    the changes, and then profile again to see whether you have not added new bottlenecks.
    But all in all, I think we have made our prime calculator a lot faster!
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您认为这可以改善您的代码，您可以将这些发现应用到您正在工作的实际应用程序中。当然，我会在进行更改之前先进行性能分析，然后再进行性能分析以查看是否没有添加新的瓶颈。但总的来说，我认为我们已经使我们的主要计算器变得更快了！
- en: Other tools
  id: totrans-326
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 其他工具
- en: Visual Studio is an excellent tool for debugging and profiling your system.
    However, it is not the only one. There are many other solutions out there that
    can help you debug and profile your code. Some of them are paid, others are free.
    Some are easy to use, some are pretty hard to get to know. I will not discuss
    the other tools, but I want to give you a small list so you can investigate them
    for yourself.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio 是一个用于调试和性能分析系统的优秀工具。然而，它并非唯一的选择。还有许多其他解决方案可以帮助您调试和性能分析代码。其中一些是付费的，其他是免费的。有些容易使用，有些则相当难以掌握。我不会讨论其他工具，但我想给您提供一个小的列表，以便您可以自己调查它们。
- en: Please look at what Visual Studio gives you first. Chances are, what you need
    is already there!
  id: totrans-328
  prefs: []
  type: TYPE_NORMAL
  zh: 请先看看 Visual Studio 给您提供了什么。很可能您需要的东西已经在那里了！
- en: Debugging tools
  id: totrans-329
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调试工具
- en: There are many debugging tools out there. This is just a sample of what you
    can try out.
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 现在有许多调试工具。这只是一个你可以尝试的样本。
- en: '| **Tool Name** | **Description** | **Company** |'
  id: totrans-331
  prefs: []
  type: TYPE_TB
  zh: '| **工具名称** | **描述** | **公司** |'
- en: '| --- | --- | --- |'
  id: totrans-332
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Visual** **Studio Debugger** | Integrated into Visual Studio, supports
    .NET, C++, and other languages with breakpoints, watch variables, and more. |
    Microsoft |'
  id: totrans-333
  prefs: []
  type: TYPE_TB
  zh: '| **Visual Studio 调试器** | 集成到 Visual Studio 中，支持 .NET、C++ 和其他语言，具有断点、监视变量等功能。
    | 微软 |'
- en: '| **WinDbg** | A multipurpose debugger for Windows, useful for debugging user-mode
    and kernel-mode code and analyzing crash dumps. | Microsoft |'
  id: totrans-334
  prefs: []
  type: TYPE_TB
  zh: '| **WinDbg** | Windows的多用途调试器，适用于调试用户模式和内核模式代码，以及分析崩溃转储。 | 微软 |'
- en: '| **Visual Studio** **Code Debugger** | Built into Visual Studio Code, supports
    various languages and platforms through extensions, with breakpoints and variable
    inspection. | Microsoft |'
  id: totrans-335
  prefs: []
  type: TYPE_TB
  zh: '| **Visual Studio Code 调试器** | 集成到 Visual Studio Code 中，通过扩展支持各种语言和平台，具有断点和变量检查功能。
    | 微软 |'
- en: '| **Managed** **Debugger (MDbg)** | A simple command-line debugger for .NET
    applications, offering basic debugging capabilities for managed code. | Microsoft
    |'
  id: totrans-336
  prefs: []
  type: TYPE_TB
  zh: '| **托管调试器 (MDbg)** | .NET 应用程序的简单命令行调试器，为托管代码提供基本的调试功能。 | 微软 |'
- en: '| **Debug Diagnostic** **Tool (DebugDiag)** | Assists in troubleshooting application
    crashes, hangs, memory leaks, and performance issues in user-mode processes. |
    Microsoft |'
  id: totrans-337
  prefs: []
  type: TYPE_TB
  zh: '| **调试诊断工具 (DebugDiag)** | 帮助诊断应用程序崩溃、挂起、内存泄漏和用户模式进程的性能问题。 | 微软 |'
- en: '| **ProcDump** | Command-line utility to monitor applications for CPU spikes
    and generate crash dumps for analysis. | Microsoft |'
  id: totrans-338
  prefs: []
  type: TYPE_TB
  zh: '| **ProcDump** | 命令行实用程序，用于监视应用程序的 CPU 峰值并生成用于分析的崩溃转储。 | 微软 |'
- en: '| **Microsoft Performance** **Tools (PerfView)** | Performance analysis tool
    for collecting and analyzing ETW data, valuable for .NET application performance
    and memory issues. | Microsoft |'
  id: totrans-339
  prefs: []
  type: TYPE_TB
  zh: '| **Microsoft 性能工具 (PerfView)** | 用于收集和分析 ETW 数据的性能分析工具，对于 .NET 应用程序的性能和内存问题非常有价值。
    | 微软 |'
- en: '| **Son of Strike (SOS) Debugging** **Extension** | An extension for WinDbg
    that provides insights into .NET runtime internals, aiding in-depth debugging
    of .NET applications. | Microsoft |'
  id: totrans-340
  prefs: []
  type: TYPE_TB
  zh: '| **Son of Strike (SOS) 调试扩展** | WinDbg 的扩展，提供对 .NET 运行时内部结构的洞察，有助于深入调试 .NET
    应用程序。 | 微软 |'
- en: '| **Windows Performance** **Recorder (WPR)** | Tools for recording and analyzing
    performance data on Windows systems, capturing detailed system and application
    behavior. | Microsoft |'
  id: totrans-341
  prefs: []
  type: TYPE_TB
  zh: '| **Windows 性能记录器 (WPR)** | 用于记录和分析 Windows 系统性能数据的工具，捕获详细的系统和应用程序行为。 | 微软
    |'
- en: '| **Remote** **Debugging Tools** | Tools for debugging applications running
    on different machines or environments, supporting both managed and native code.
    | Microsoft |'
  id: totrans-342
  prefs: []
  type: TYPE_TB
  zh: '| **远程调试工具** | 用于调试在不同机器或环境中运行的应用程序的工具，支持托管和本地代码。 | 微软 |'
- en: '| **GNU** **Debugger (GDB)** | A powerful debugger for various programming
    languages, especially C and C++, to see what is happening inside a program. |
    GNU Project |'
  id: totrans-343
  prefs: []
  type: TYPE_TB
  zh: '| **GNU 调试器 (GDB)** | 用于各种编程语言的强大调试器，特别是 C 和 C++，可以查看程序内部发生的情况。 | GNU 项目 |'
- en: '| **LLVM** **Debugger (LLDB)** | A modern, high-performance debugger part of
    the LLVM project, supporting languages such as C, C++, and Objective-C. | LLVM
    Project |'
  id: totrans-344
  prefs: []
  type: TYPE_TB
  zh: '| **LLVM 调试器 (LLDB)** | LLVM 项目的现代、高性能调试器，支持 C、C++ 和 Objective-C 等语言。 | LLVM
    项目 |'
- en: '| **Valgrind** | A programming tool for memory debugging, memory leak detection,
    and profiling, including tools such as Memcheck. | Valgrind Developers |'
  id: totrans-345
  prefs: []
  type: TYPE_TB
  zh: '| **Valgrind** | 内存调试、内存泄漏检测和性能分析编程工具，包括 Memcheck 等工具。 | Valgrind 开发者 |'
- en: '| **Strace** | A diagnostic, debugging, and instructional utility for Linux
    that traces system calls and signals. | Open Source |'
  id: totrans-346
  prefs: []
  type: TYPE_TB
  zh: '| **Strace** | Linux的诊断、调试和教学工具，用于跟踪系统调用和信号。 | 开源 |'
- en: 'Table 11.7: Debugging tools'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.7：调试工具
- en: I do not endorse any of these products; I have merely listed them here for your
    convenience.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 我不推荐任何这些产品；我仅仅在这里列出它们以供您方便参考。
- en: Profiling tools
  id: totrans-349
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 性能分析工具
- en: Profiling tools are also easy to find. A lot of companies next to Microsoft
    offer solutions for this. They each have their own strengths and weaknesses. So,
    please look at the following table as a guideline to help you find what is best
    for you.
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 性能分析工具也容易找到。许多公司都在微软旁边提供解决方案。它们各自都有其优势和劣势。因此，请参考以下表格作为指南，以帮助您找到最适合您的工具。
- en: '| **Tool Name** | **Description** | **Company** |'
  id: totrans-351
  prefs: []
  type: TYPE_TB
  zh: '| **工具名称** | **描述** | **公司** |'
- en: '| --- | --- | --- |'
  id: totrans-352
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- | --- |'
- en: '| **Visual** **Studio Profiler** | Integrated into Visual Studio, provides
    detailed performance and memory usage data for .NET and C++ applications. | Microsoft
    |'
  id: totrans-353
  prefs: []
  type: TYPE_TB
  zh: '| **Visual Studio 分析器** | 集成到 Visual Studio 中，为 .NET 和 C++ 应用程序提供详细的性能和内存使用数据。
    | 微软 |'
- en: '| **WPR** | Captures detailed performance data on Windows systems for in-depth
    analysis. | Microsoft |'
  id: totrans-354
  prefs: []
  type: TYPE_TB
  zh: '| **WPR** | 捕获 Windows 系统上的详细性能数据，以便进行深入分析。 | 微软公司 |'
- en: '| **Windows Performance** **Analyzer (WPA)** | Analyzes performance data collected
    by WPR, helping to identify performance issues. | Microsoft |'
  id: totrans-355
  prefs: []
  type: TYPE_TB
  zh: '| **Windows 性能分析器 (WPA)** | 分析 WPR 收集的性能数据，帮助识别性能问题。 | 微软 |'
- en: '| **PerfView** | Collects and analyzes ETW data, useful for investigating performance
    and memory issues in .NET applications. | Microsoft |'
  id: totrans-356
  prefs: []
  type: TYPE_TB
  zh: '| **PerfView** | 收集和分析 ETW 数据，对于调查 .NET 应用程序中的性能和内存问题很有用。 | 微软 |'
- en: '| **.NET** **Memory Profiler** | A powerful tool for finding memory leaks and
    optimizing memory usage in .NET applications. | SciTech Software |'
  id: totrans-357
  prefs: []
  type: TYPE_TB
  zh: '| **.NET 内存分析器** | 用于在 .NET 应用程序中查找内存泄漏和优化内存使用的强大工具。 | SciTech 软件 |'
- en: '| **ANTS Performance** **Profiler** | Provides .NET code profiling to find
    performance bottlenecks, including memory usage and execution time analysis. |
    Redgate |'
  id: totrans-358
  prefs: []
  type: TYPE_TB
  zh: '| **ANTS 性能分析器** | 提供 .NET 代码分析，以查找性能瓶颈，包括内存使用和执行时间分析。 | Redgate |'
- en: '| **JetBrains** **dotTrace** | A .NET profiler for performance, memory, and
    coverage analysis, integrated with Visual Studio. | JetBrains |'
  id: totrans-359
  prefs: []
  type: TYPE_TB
  zh: '| **JetBrains dotTrace** | 针对 .NET 的性能、内存和覆盖率分析分析器，与 Visual Studio 集成。 | JetBrains
    |'
- en: '| **VTune** **Profiler** | Performance analysis tool for C, C++, and Fortran
    applications, offering deep insights into CPU and GPU performance. | Intel |'
  id: totrans-360
  prefs: []
  type: TYPE_TB
  zh: '| **VTune 分析器** | 针对 C、C++ 和 Fortran 应用程序的性能分析工具，提供对 CPU 和 GPU 性能的深入洞察。 | 英特尔
    |'
- en: '| **Valgrind** | Includes a suite of tools such as Cachegrind for cache profiling
    and Massif for heap profiling, primarily for C and C++ programs. | Valgrind Developers
    |'
  id: totrans-361
  prefs: []
  type: TYPE_TB
  zh: '| **Valgrind** | 包含一系列工具，如 Cachegrind 用于缓存分析，Massif 用于堆分析，主要用于 C 和 C++ 程序。
    | Valgrind 开发者 |'
- en: '| **Google Performance** **Tools (gperftools)** | A suite of utilities for
    performance profiling and heap analysis, providing insights into CPU and memory
    usage. | Google |'
  id: totrans-362
  prefs: []
  type: TYPE_TB
  zh: '| **Google 性能工具 (gperftools)** | 一套用于性能分析和堆分析的实用程序，提供对 CPU 和内存使用的洞察。 | 谷歌 |'
- en: '| **YourKit** **Profiler** | A profiler for Java and .NET applications, offering
    comprehensive CPU and memory profiling features. | YourKit |'
  id: totrans-363
  prefs: []
  type: TYPE_TB
  zh: '| **YourKit 分析器** | 针对 Java 和 .NET 应用程序的分析器，提供全面的 CPU 和内存分析功能。 | YourKit |'
- en: '| **Perf** | A performance analyzing tool in Linux that provides detailed information
    on CPU performance, helping identify bottlenecks. | Linux Community |'
  id: totrans-364
  prefs: []
  type: TYPE_TB
  zh: '| **Perf** | Linux 中的性能分析工具，提供有关 CPU 性能的详细信息，有助于识别瓶颈。 | Linux 社区 |'
- en: '| **GlowCode** | A performance and memory profiler for Windows, focusing on
    C++ and .NET applications. | Electric Software Inc. |'
  id: totrans-365
  prefs: []
  type: TYPE_TB
  zh: '| **GlowCode** | 针对 Windows 的性能和内存分析器，专注于 C++ 和 .NET 应用程序。 | 电软公司 |'
- en: '| **AQtime** | An advanced performance and memory profiling tool for various
    programming languages, integrated with Visual Studio. | SmartBear |'
  id: totrans-366
  prefs: []
  type: TYPE_TB
  zh: '| **AQtime** | 针对各种编程语言的先进性能和内存分析工具，与 Visual Studio 集成。 | SmartBear |'
- en: '| **Perfino** | A Java profiler for production environments, focusing on performance
    monitoring and problem resolution. | EJ Technologies |'
  id: totrans-367
  prefs: []
  type: TYPE_TB
  zh: '| **Perfino** | 针对生产环境的 Java 分析器，专注于性能监控和问题解决。 | EJ 技术公司 |'
- en: 'Table 11.8: Profiling tools'
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 表 11.8：分析工具
- en: These tables do not contain all the tools available. New tools are added regularly,
    while others go away. I suggest you try some of them and stick to what works best
    for you. Maybe you prefer a CLI solution. Perhaps you want to work with a graphical
    tool. Whatever your preference is, there is always a tool that fits your needs.
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 这些表格并不包含所有可用的工具。新工具会定期添加，而其他工具则会被淘汰。我建议你尝试一些，并坚持使用最适合你的工具。也许你更喜欢 CLI 解决方案。也许你想要使用图形工具。无论你的偏好如何，总有适合你需求的工具。
- en: Next steps
  id: totrans-370
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 下一步
- en: Writing code inevitably means making mistakes. That is part of the fun of the
    job, I believe. Coming up with new ideas, making something out of nothing, and
    then making it work and improve is a great process. However, you can only do that
    when you have the right tools and know how to use them.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 编写代码不可避免地意味着会犯错误。我认为这是工作乐趣的一部分。提出新想法，从无到有，然后让它工作并改进是一个伟大的过程。然而，你只能在你拥有正确的工具并且知道如何使用它们的时候做到这一点。
- en: In this chapter, we have looked at the debugging tools that Visual Studio provides.
    We looked at what debugging and profiling actually are, discovered the possibilities
    with breakpoints, and looked at the other helpful debug windows.
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了 Visual Studio 提供的调试工具。我们了解了调试和性能分析究竟是什么，发现了断点的可能性，并查看了一些其他有用的调试窗口。
- en: We also investigated how to deal with multithreaded applications and the debug
    challenges they give us. We looked at the windows that could help us and investigated
    deadlocks.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还研究了如何处理多线程应用程序及其带来的调试挑战。我们查看了一些可以帮助我们的窗口，并研究了死锁问题。
- en: To top it off, we talked about profiling and benchmarking to uncover performance
    bottlenecks and how to solve them.
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 更重要的是，我们讨论了性能分析和基准测试，以揭示性能瓶颈及其解决方法。
- en: 'So, we now know how to tackle most of the issues in our code. However, we have
    one more important thing to discuss: how do we secure our code? What does that
    even mean? That is a big topic. It is so big that I have a complete chapter about
    it, and that is what is next. Please, follow along!'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在知道了如何应对代码中的大多数问题。然而，我们还有另一个重要的话题要讨论：我们如何确保代码的安全性？这究竟意味着什么？这是一个很大的话题。它如此之大，以至于我为此专门写了一整章，这就是接下来的内容。请继续关注！
