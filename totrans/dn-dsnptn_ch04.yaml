- en: Chapter 4. Targeting Multiple Databases
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章. 多数据库目标
- en: In this chapter, we will try to create a library which will help application
    developers target their applications against SQL Server, SQLite, MySQL, and Oracle.
    As a result of creating this library, we will be able to write the application
    code without worrying about the underlying persistence technology. Even though
    ADO.NET does a wonderful job of abstracting away the nitty-gritties of a **relational
    database management system** (**RDBMS**), we need more than what is available
    as a stock feature within ADO.NET to write a database-agnostic persistence layer.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将尝试创建一个库，帮助应用程序开发者针对SQL Server、SQLite、MySQL和Oracle等数据库。通过创建这个库，我们将能够编写应用程序代码，而无需担心底层持久化技术。尽管ADO.NET在抽象化关系数据库管理系统（**RDBMS**）的细节方面做得很好，但我们还需要比ADO.NET提供的标准功能更多的东西来编写数据库无关的持久化层。
- en: 'During the course of this chapter, as a reader, you will learn to leverage
    the abstract factory pattern, factory pattern, and the adapter pattern to be able
    to do the following:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的阅读过程中，作为读者，你将学会利用抽象工厂模式、工厂模式和适配器模式，以便能够做到以下几项：
- en: Interfacing with various ADO.NET providers
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 与各种ADO.NET提供者接口
- en: Writing persistence-store agnostic logic
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编写与数据库存储无关的逻辑
- en: Writing data to an SQLite database
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据写入SQLite数据库
- en: Writing data to an SQL Server database
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据写入SQL Server数据库
- en: Writing data to an ODBC data source
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将数据写入ODBC数据源
- en: Requirements for the library
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 库的要求
- en: 'Before we embark on writing the library, let us scribble down a preliminary
    requirement statement as follows:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始编写库之前，让我们草拟以下初步需求声明：
- en: Note
  id: totrans-10
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: When we write business applications, our application should be able to persist
    to relational database engines from different database vendors.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们编写商业应用程序时，我们的应用程序应该能够持久化到来自不同数据库供应商的关系数据库引擎。
- en: Note
  id: totrans-12
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We should be able to support SQL Server, SQLite, Oracle, or any database engine
    which supports ADO.net. Adding a new DB engine should be a breeze. Likewise, changing
    the database technology should be seamless for the application developer.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该能够支持SQL Server、SQLite、Oracle或任何支持ADO.net的数据库引擎。添加新的数据库引擎应该是一件轻而易举的事情。同样，对于应用程序开发者来说，更改数据库技术应该是一个无缝的过程。
- en: Solutions approach
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解决方案方法
- en: With the advent of ORM technologies like ADO.NET **Entity Framework** (**EF**)
    and **NHibernate**, writing an application which targets multiple database offerings
    has become easier. The authors believe that ADO.NET EF works in tandem with the
    Visual Studio environment and its tools, and would be difficult to deal with in
    a book meant for pattern oriented software development. For people from the Java
    world, who are accustomed to the Hibernate library, NHibernate flattens the learning
    curve. Despite its dwindling usage and popularity (reasons unknown) amidst .NET
    professionals, the authors feel that NHibernate is a viable option to write enterprise
    grade applications in. In this book, for the sake of simplicity, we will be using
    the ADO.NET programming model to isolate the database specificities.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 随着ORM技术如ADO.NET **Entity Framework**（**EF**）和**NHibernate**的出现，编写针对多个数据库提供者的应用程序变得更加容易。作者认为，ADO.NET
    EF与Visual Studio环境及其工具协同工作，在面向模式的软件开发书籍中处理起来可能会很困难。对于习惯了Hibernate库的Java世界的人来说，NHibernate简化了学习曲线。尽管在.NET专业人士中其使用率和受欢迎程度正在下降（原因不明），但作者认为NHibernate是编写企业级应用程序的一个可行的选择。为了简单起见，本书中将使用ADO.NET编程模型来隔离数据库特定性。
- en: 'The ADO.NET library is based on the following set of interfaces defined in
    the `System.Data` assembly from Microsoft:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: ADO.NET库基于Microsoft的`System.Data`程序集中定义的以下一组接口：
- en: '| **Interface** | **Definition** |'
  id: totrans-17
  prefs: []
  type: TYPE_TB
  zh: '| **接口** | **定义** |'
- en: '| `IDbConnection` | Interface for managing database connection specifics. |'
  id: totrans-18
  prefs: []
  type: TYPE_TB
  zh: '| `IDbConnection` | 用于管理数据库连接具体细节的接口。|'
- en: '| `IDbCommand` | Interface for issuing SQL commands and queries. |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| `IDbCommand` | 用于发出SQL命令和查询的接口。|'
- en: '| `IDbDataAdapter` | Interface for disconnected data access. |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| `IDbDataAdapter` | 用于断开连接的数据访问接口。|'
- en: '| `IDataReader` | Interface for cursor-based access to the database. |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| `IDataReader` | 用于基于游标的数据库访问接口。|'
- en: Note
  id: totrans-22
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: There are other interfaces which deal with the management of transactions, stored
    procedures, and associated parameter handling. We will ignore them in this book
    for the sake of shortening our code listings. Those can be incorporated into our
    library without much effort.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他接口用于处理事务管理、存储过程和相关的参数处理。为了缩短代码列表，我们将在此书中忽略它们。这些可以在不费太多力气的情况下纳入我们的库中。
- en: 'Each of the aforementioned Interfaces is implemented by a provider written
    by the respective database vendor. Microsoft encourages independent vendors to
    write ADO.NET providers. The SQL Server implementation (`System.Data.SqlClient`)
    of these interfaces are named as follows:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 所述接口均由各自数据库供应商编写的提供者实现。Microsoft 鼓励独立供应商编写 ADO.NET 提供者。这些接口的 SQL Server 实现 (`System.Data.SqlClient`)
    命名为以下：
- en: '| **Class** | **Definition** |'
  id: totrans-25
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **定义** |'
- en: '| `SqlConnection` | Implementation of `IDbConnection` interface. |'
  id: totrans-26
  prefs: []
  type: TYPE_TB
  zh: '| `SqlConnection` | 实现 `IDbConnection` 接口。 |'
- en: '| `SqlCommand` | Implementation of `IDbCommand` interface. |'
  id: totrans-27
  prefs: []
  type: TYPE_TB
  zh: '| `SqlCommand` | 实现 `IDbCommand` 接口。 |'
- en: '| `SqlDataAdapter` | Implementation of `IDbAdapter` interface. |'
  id: totrans-28
  prefs: []
  type: TYPE_TB
  zh: '| `SqlDataAdapter` | 实现 `IDbAdapter` 接口。 |'
- en: '| `SqlDataReader` | Implementation of `IDataReader` interface. |'
  id: totrans-29
  prefs: []
  type: TYPE_TB
  zh: '| `SqlDataReader` | 实现 `IDataReader` 接口。 |'
- en: 'In the case of `System.Data.SQLite`, the scheme is as follows:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `System.Data.SQLite` 的情况下，方案如下：
- en: '| **Class** | **Definition** |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| **类** | **定义** |'
- en: '| `SQLiteConnection` | Implementation of `IDbConnection` interface. |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| `SQLiteConnection` | 实现 `IDbConnection` 接口。 |'
- en: '| `SQLiteCommand` | Implementation of `IDbCommand` interface. |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| `SQLiteCommand` | 实现 `IDbCommand` 接口。 |'
- en: '| `SQLitelDataAdapter` | Implementation of `IDbAdapter` interface. |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| `SQLitelDataAdapter` | 实现 `IDbAdapter` 接口。 |'
- en: '| `SQLiteDataReader` | Implementation of `IDataReader` interface. |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| `SQLiteDataReader` | 实现 `IDataReader` 接口。 |'
- en: Similar provider classes are implemented by Oracle and MySQL.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 类似提供者类由 Oracle 和 MySQL 实现。
- en: Note
  id: totrans-37
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: We will be using the GoF catalog's abstract factory methods to instantiate standard
    ADO.NET-library-specific interfaces for connection, command, data adapter, and
    reader. The abstract factory pattern is a creational pattern which provides an
    interface for creating families of related or dependent objects without specifying
    their concrete classes.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用 GoF 目录中的抽象工厂方法来实例化针对连接、命令、数据适配器和读取器的标准 ADO.NET 库特定接口。抽象工厂模式是一种创建型模式，它提供了一个接口，用于在不指定具体类的情况下创建相关或依赖对象系列。
- en: A quick primer on ADO.net
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ADO.net 快速入门
- en: 'Since we are using ADO.net API for accessing databases, a couple of code snippets
    will be of help to comprehend the following sections. There are two ways to write
    code using the ADO.net API. We can directly use the concrete classes to access
    the database content. The following code snippet shows how one can write code
    against SQLite using `SQliteConnection`, `SQliteCommand` and `SQliteDataReader` and
    so on. Similar code can be written for SQL Server, MySQL and Oracle:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们使用 ADO.net API 访问数据库，以下代码片段将有助于理解以下部分。使用 ADO.net API 编写代码有两种方式。我们可以直接使用具体类来访问数据库内容。以下代码片段展示了如何使用
    `SQliteConnection`、`SQliteCommand` 和 `SQliteDataReader` 等编写针对 SQLite 的代码。类似的代码可以用于
    SQL Server、MySQL 和 Oracle：
- en: '[PRE0]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The above code snippet leverages the concrete classes provided. If we want
    to write code in a generic manner, we can program against the interfaces like
    `IDbConnection`, `IDbCommand` and `IDbDataReader` etc. The following code snippet
    demonstrates the technique:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码片段利用了提供的具体类。如果我们想以通用方式编写代码，我们可以针对接口如 `IDbConnection`、`IDbCommand` 和 `IDbDataReader`
    等进行编程。以下代码片段展示了该技术：
- en: '[PRE1]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The abstract factory pattern and object instantiation
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象工厂模式和对象实例化
- en: 'In our case, the abstract factory pattern is pertinent, as we are supposed
    to create a set of related classes based on the ADO.NET defined interfaces. For
    this very purpose, we will define an abstract class with the following signature:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的情况下，抽象工厂模式是相关的，因为我们应该基于 ADO.NET 定义的接口创建一组相关类。为此，我们将定义一个具有以下签名的抽象类：
- en: '[PRE2]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: '![The abstract factory pattern and object instantiation](img/B05691_04_01.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![抽象工厂模式和对象实例化](img/B05691_04_01.jpg)'
- en: In the preceding interface, we have methods to create connection object, command
    object, data adapter object, and data reader object. These classes are related,
    and concrete classes are for each of the database offerings. The concrete classes
    make calls to the corresponding ADO.NET driver.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一个界面中，我们有创建连接对象、命令对象、数据适配器对象和数据读取器对象的方法。这些类是相关的，具体类是为每个数据库提供的产品而设计的。具体类会调用相应的ADO.NET驱动程序。
- en: The SQL server implementation
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQL服务器实现
- en: 'The SQL Server implementation of abstract factory uses the default provider
    given by Microsoft Corporation. We need to include the `System.Data.SqlClient`
    namespace in our projects to utilize the objects in the provider namespace. Though
    the code given warrants more robust and defensive programming practices mandated
    for an industrial strength implementation, it provides clarity and is a good template
    for such an implementation:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象工厂的SQL Server实现使用了微软公司提供的默认提供程序。我们需要在我们的项目中包含`System.Data.SqlClient`命名空间，以利用提供程序命名空间中的对象。尽管给出的代码保证了更健壮和防御性编程实践，这对于工业强度实现是必需的，但它提供了清晰性，并且是此类实现的良好模板：
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The SQLite implementation
  id: totrans-52
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: SQLite的实现
- en: The SQLite implementation uses the ADO.NET provider maintained by the SQLite
    implementation team. To include that, we need to download assemblies from the
    [https://system.data.sqlite.org](https://system.data.sqlite.org/) site. We need
    to also include `sqlite3.dll` available on the SQLite site.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite的实现使用了SQLite实现团队维护的ADO.NET提供程序。为了包含它，我们需要从[https://system.data.sqlite.org](https://system.data.sqlite.org/)网站下载程序集。我们还需要包含SQLite网站上可用的`sqlite3.dll`。
- en: 'You could also use nuget to install it via the Package Manager Console as `PM>
    Install-Package System.Data.SQLite`:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用nuget通过包管理控制台安装它，命令为`PM> Install-Package System.Data.SQLite`：
- en: '[PRE4]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The Oracle and ODBC implementation
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Oracle和ODBC的实现
- en: Since Microsoft has deprecated the `System.Data.OracleClient` interface, we
    need to download ADO.NET providers from the Oracle Corporation site. Incorporating
    Oracle into the mix is similar to the way we did for SQL Server and SQLite. Since
    Oracle supports ODBC, we use an ODBC ADO.NET provider through the `System.Data.Oledb`
    namespace to interact with the other databases. The implementation is available
    as part of the source code downloads.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于微软已经弃用了`System.Data.OracleClient`接口，我们需要从Oracle公司网站下载ADO.NET提供程序。将Oracle整合到混合中与我们对SQL
    Server和SQLite所做的方式相似。由于Oracle支持ODBC，我们通过`System.Data.Oledb`命名空间使用ODBC ADO.NET提供程序与其他数据库交互。实现作为源代码下载的一部分提供。
- en: 'The following diagram illustrates the abstract factories in action (though
    only one has been labeled):'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示说明了抽象工厂的作用（尽管只有一个被标记）：
- en: '![The Oracle and ODBC implementation](img/B05691_04_02.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![Oracle和ODBC的实现](img/B05691_04_02.jpg)'
- en: The adapter pattern powered API
  id: totrans-60
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器模式驱动的API
- en: The GOF Adapter pattern is useful for us in this context to provide a unified
    programming model for the consumers of the sub system.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个上下文中，GOF适配器模式对我们很有用，可以为我们提供统一编程模型，供子系统消费者使用。
- en: Note
  id: totrans-62
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The Adapter pattern is a structural pattern which works as a bridge between
    different interfaces or different implementations of an interface. In our case,
    we will use the adapter pattern as a bridge between application developers and
    various implementations of `DbAstractFactory`.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 适配器模式是一种结构型模式，它作为不同接口或接口的不同实现之间的桥梁。在我们的情况下，我们将使用适配器模式作为应用程序开发者和`DbAstractFactory`各种实现之间的桥梁。
- en: 'We need to create an **Application Program Interface** (**API**) for the application
    software developer to leverage different implementations based on a configuration
    entry. We will create a C# interface, which an adapter class needs to implement,
    to act as an API. At this point in time, we have only one instance of the adapter
    class. In future, we can have adapters for different scenarios:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要为应用程序软件开发者创建一个**应用程序程序接口**（**API**），以便根据配置条目利用不同的实现。我们将创建一个C#接口，适配器类需要实现它，作为API。在这个时候，我们只有一个适配器类的实例。在未来，我们可以有不同的适配器用于不同的场景：
- en: '[PRE5]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The adapter class Implementation
  id: totrans-66
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器类实现
- en: 'We will implement an adapter class which will help us to seamlessly integrate
    multiple database engines with our application. For implementing the adapter class,
    we will leverage the object factory (`ObjectFactory`) implementation from the
    previous chapter:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将实现一个适配器类，它将帮助我们无缝地将多个数据库引擎与我们的应用程序集成。为了实现适配器类，我们将利用上一章中的对象工厂（`ObjectFactory`）实现：
- en: '[PRE6]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We leverage the factory method infrastructure created in [Chapter 3](dn-dsnptn_ch03.html
    "Chapter 3. A Logging Library"), *A Logging Library* to help instantiate the proper
    concrete implementation of `DbAstractFactory`. The `DbDrivers.xml` configuration
    file contains the necessary information to instantiate the concrete classes:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 我们利用在[第3章](dn-dsnptn_ch03.html "第3章。日志库")中创建的工厂方法基础设施，即《日志库》，以帮助实例化`DbAstractFactory`的正确具体实现。《DbDrivers.xml》配置文件包含实例化具体类所需的信息：
- en: '[PRE7]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'The constructor takes two parameters, that is, connection string and driver
    name. Using the driver name as the key, the appropriate implementation of ADO.NET
    will be instantiated:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数接受两个参数，即连接字符串和驱动程序名称。使用驱动程序名称作为键，将实例化适当的ADO.NET实现：
- en: '[PRE8]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'The `Open` method creates the connection object through the abstract factory
    concrete implementation. Once the connection object has been created, the ADO.NET
    connection is opened. The application developer should then make a call to `Open`
    method of the current class before calling any other method:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: '`Open` 方法通过抽象工厂的具体实现创建连接对象。一旦创建连接对象，ADO.NET连接就打开了。然后应用程序开发者应该在调用任何其他方法之前调用当前类的`Open`方法：'
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'The `Execute` method helps one to dispatch an SQL string to the selected database
    engine, and returns a dataset. This method is also used for disconnected access
    where an application wants to retrieve a small set of data to be populated in
    a user interface:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Execute` 方法帮助将SQL字符串发送到所选数据库引擎，并返回一个数据集。此方法还用于断开连接访问，其中应用程序想要检索一小批数据以填充用户界面：'
- en: '[PRE10]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `ExecuteQuery` method helps one to dispatch an SQL query to a database,
    and retrieve a data reader object which will help one to navigate one record at
    a time. This is called cursor-based access, and is suitable for queries which
    return a large dataset:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteQuery` 方法帮助将SQL查询发送到数据库，并检索一个数据读取器对象，该对象可以帮助逐条记录进行导航。这称为基于游标的访问，适用于返回大量数据集的查询：'
- en: '[PRE11]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The `ExecuteNonQuery` method is meant to insert, update, or delete records
    from the table. It does not return any value. In other words, the method is called
    for mutable operations on a relational database:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteNonQuery` 方法旨在向表中插入、更新或删除记录。它不返回任何值。换句话说，该方法用于对关系数据库上的可变操作进行调用：'
- en: '[PRE12]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `Close` method, as indicated, closes the database connection. The adapter
    class can be instantiated inside the application code using the following schema.
    All we need is a connection string and a driver name (`SQLITE`, `SQLSERVER`, and
    so on) to instantiate the object. Once we have instantiated the object, we can
    dispatch an arbitrary query against the chosen database engine as indicated in
    the following code:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如指示，`Close` 方法关闭数据库连接。适配器类可以使用以下模式在应用程序代码中实例化。我们需要的只是一个连接字符串和一个驱动程序名称（`SQLITE`、`SQLSERVER`等）来实例化对象。一旦实例化了对象，我们就可以像以下代码所示，对所选数据库引擎发送任意查询：
- en: '[PRE13]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The adapter configuration
  id: totrans-83
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 适配器配置
- en: 'The drivers for the respective database engines are configured via an XML file
    (`DbDrivers.xml`) as follows:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 各数据库引擎的驱动程序通过以下方式的XML文件（`DbDrivers.xml`）进行配置：
- en: '[PRE14]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: When we want to target a new database, we need to create a concrete class which
    implements the abstract factory interface, and add an entry to this configuration
    file.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要针对新的数据库时，我们需要创建一个实现抽象工厂接口的具体类，并将条目添加到此配置文件中。
- en: The client program
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 客户端程序
- en: 'We can write a client program to test this logic. The code for inserting an
    entry to a database of your choice is given next. We have chosen SQLite initially
    for the sake of simplicity. Since SQLite is a server-less database engine, we
    can embed an SQLite DB as part of our project:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以编写一个客户端程序来测试这个逻辑。以下给出将条目插入所选数据库的代码。我们最初选择SQLite是为了简化。由于SQLite是一个无服务器数据库引擎，我们可以将SQLite数据库嵌入到我们的项目中：
- en: '[PRE15]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'To retrieve data from a table, we can use either the disconnected recordset
    model or cursor model. When we are dealing with large datasets, especially for
    reports, using the cursor model is preferred. For scenarios where we need to edit
    a small set of data through some control, a disconnected set is preferred. The
    following code demonstrates how one can use the disconnected recordset for retrieving
    the data:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 要从表中检索数据，我们可以使用断开连接的记录集模型或游标模型。当我们处理大量数据集时，特别是对于报告，使用游标模型更合适。对于需要通过某些控件编辑一小批数据的场景，断开连接的集合更受欢迎。以下代码演示了如何使用断开连接的记录集来检索数据：
- en: '[PRE16]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `DataReader` interface of ADO.NET is meant for cursor-based access to the
    database. This helps one to iterate through the data which satisfies some criteria.
    Reporting applications are a typical use case for cursor-based access:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: ADO.NET 的 `DataReader` 接口旨在用于基于游标的数据库访问。这有助于遍历满足某些标准的数据。基于游标的访问是报告应用程序的典型用例：
- en: '[PRE17]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'The `Main` program which invokes these helper routines is given next. The initial
    code snippet shows how to use SQLite as a target database:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 下文给出了调用这些辅助例程的 `Main` 程序。初始代码片段展示了如何将 SQLite 作为目标数据库使用：
- en: '[PRE18]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'To use the SQL Server, one needs to make changes to the connection string.
    Since the connection string is specific to the SQL Server installation (which
    a reader will have), the general scheme of invoking the program is the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 SQL Server，需要修改连接字符串。由于连接字符串针对特定的 SQL Server 安装（读者将拥有），调用程序的通用方案如下：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The following UML diagram illustrates the key set of patterns in action for
    the **Database Access Library** (**DAL**) API that we have built:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 以下 UML 图展示了我们构建的 **数据库访问库（DAL**） API 中关键模式集的作用：
- en: '![The client program](img/B05691_04_03-1.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![客户端程序](img/B05691_04_03-1.jpg)'
- en: Summary
  id: totrans-100
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we created a reusable DAL to target different relational database
    offerings available for persistence. The library leverages the Microsoft ADO.NET
    programming model to implement database-agnostic persistence. In the process,
    you learned about the abstract factory pattern, adapter pattern, and revisited
    factory method pattern. You also understood the difference between the factory
    method and the abstract factory pattern. In the next chapter, we will write a
    document object library which will help one save data contents to different formats
    like PDF, SVG, and HTML. In that process, you will learn about the composite design
    pattern and visitor pattern.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们创建了一个可重用的 DAL，以针对不同的关系数据库产品实现持久化。该库利用 Microsoft ADO.NET 编程模型实现数据库无关的持久化。在这个过程中，你了解了抽象工厂模式、适配器模式和回顾了工厂方法模式。你还理解了工厂方法和抽象工厂模式之间的区别。在下一章中，我们将编写一个文档对象库，这将帮助用户将数据内容保存到不同的格式，如
    PDF、SVG 和 HTML。在这个过程中，你将学习到组合设计模式和访问者模式。
