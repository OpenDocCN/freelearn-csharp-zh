- en: '2'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '2'
- en: Building Our First .NET MAUI App
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建我们的第一个.NET MAUI应用
- en: In this chapter, we will create a to-do list app and, in doing so, explore all
    the bits and pieces of what makes up an app. We will look at creating pages, adding
    content to pages, navigating between pages, and creating a stunning layout. Well,
    *stunning* might be a bit of a stretch, but we will be sure to design the app
    so that you can tweak it to your needs once it is complete!
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将创建一个待办事项列表应用，并在创建过程中探索构成应用的所有组成部分。我们将查看创建页面、向页面添加内容、在页面之间导航以及创建令人惊叹的布局。好吧，*令人惊叹*可能有点夸张，但我们将确保设计出的应用在完成之后你可以根据自己的需求进行调整！
- en: 'The following topics will be covered in this chapter:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: Setting up the project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设置项目
- en: Persisting data locally on a device using the repository pattern
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用仓库模式在设备上本地持久化数据
- en: What MVVM is and why it’s a great fit for .NET MAUI
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MVVM是什么以及为什么它非常适合.NET MAUI
- en: Using .NET MAUI pages (as views) and navigating between them using .NET MAUI
    controls in XAML
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用.NET MAUI页面（作为视图）以及使用.NET MAUI控件在XAML中在它们之间导航
- en: Using data binding
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用数据绑定
- en: Using styling in .NET MAUI
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在.NET MAUI中使用样式
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: To complete this project, you need to have Visual Studio installed on your **Macintosh**
    (**Mac**) or PC, as well as the .NET mobile components. Refer to *Chapter 1*,
    *Introduction to .NET MAUI*, for more details on how to set up your environment.
    This chapter provides screenshots and instructions for Visual Studio on Windows.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成此项目，你需要在你的**Macintosh**（**Mac**）或PC上安装Visual Studio，以及.NET移动组件。有关如何设置环境的更多详细信息，请参阅*第1章*，*.NET
    MAUI简介*。本章提供了Windows上Visual Studio的截图和说明。
- en: This chapter will be a classic **File** | **New** | **Project** chapter, guiding
    you step by step through the process of creating your first to-do list app. No
    downloads will be required whatsoever, apart from a few NuGet packages.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将是一个经典的**文件** | **新建** | **项目**章节，逐步指导你创建你的第一个待办事项列表应用。除了几个NuGet包之外，无需任何下载。
- en: You can find the full source for the code in this chapter at [https://github.com/Packt
    Publishing/MAUI-Projects-3rd-Edition](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition)
    in the `Chapter02` folder.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://github.com/Packt Publishing/MAUI-Projects-3rd-Edition](https://github.com/PacktPublishing/MAUI-Projects-3rd-Edition)的`Chapter02`文件夹中找到本章代码的完整源代码。
- en: Project overview
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 项目概述
- en: Everyone needs a way of keeping track of things. To kick-start our .NET MAUI
    development learning curve, we’ve decided that a to-do list app is the best way
    to get started and to help you keep track of things. A simple, classic win-win
    scenario.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都需要一种跟踪事物的方法。为了启动我们的 .NET MAUI 开发学习曲线，我们决定制作一个待办事项列表应用是开始的最佳方式，并帮助你跟踪事物。这是一个简单、经典的双赢场景。
- en: We will start by creating a project and defining a repository to store the items
    of a to-do list. We will render these items in list form and allow the user to
    edit them using a detailed user interface. We will also look at how to store the
    to-do list items locally on a device through **SQLite.NET** so that they don’t
    get lost when we exit the app.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个项目并定义一个存储待办事项列表项的仓库。我们将以列表形式渲染这些项，并允许用户通过详细用户界面进行编辑。我们还将探讨如何通过**SQLite.NET**在设备上本地存储待办事项列表项，以便在退出应用时不会丢失。
- en: The build time for this project is about 2 hours.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本项目的构建时间大约为2小时。
- en: Setting up the project
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置项目
- en: .NET MAUI introduces a new code-sharing paradigm called single project. Previously,
    in Xamarin.Forms, you would have had a separate project for each platform your
    app would be deployed to. In .NET MAUI, all platforms are in a single project
    that is multi-targeted to all the supported platforms. By default, all code is
    considered shared, unless it is in one of the platform-specific subfolders. We
    will explore this further as we progress through this and future chapters.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI引入了一种新的代码共享范式，称为单一项目。在Xamarin.Forms中，你将为每个应用部署的平台创建一个单独的项目。在.NET MAUI中，所有平台都在一个项目中，该项目针对所有支持的平台进行多目标配置。默认情况下，所有代码都被视为共享的，除非它位于平台特定的子文件夹之一。随着我们继续本章和未来的章节，我们将进一步探讨这一点。
- en: Let’s get started!
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧！
- en: Creating the new project
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建新项目
- en: 'The first step is to create a new .NET MAUI project. Open Visual Studio 2022
    and select **Create a** **new project**:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 第一步是创建一个新的.NET MAUI项目。打开Visual Studio 2022并选择**创建一个** **新项目**：
- en: "![Figure 2.1 – Visual Studio 2\uFEFF022](img/Figure_2.1_B19214.jpg)"
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1 – Visual Studio 2022](img/Figure_2.1_B19214.jpg)'
- en: Figure 2.1 – Visual Studio 2022
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1 – Visual Studio 2022
- en: 'This will open the `maui` and select the **.NET MAUI App** item from the list:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开 `maui` 并从列表中选择 **.NET MAUI App** 项：
- en: "![Figure 2.2 – Create a new proje\uFEFFct](img/Figure_2.2_B19214.jpg)"
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.2 – 创建新项目](img/Figure_2.2_B19214.jpg)'
- en: Figure 2.2 – Create a new project
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.2 – 创建新项目
- en: 'Complete the next page of the wizard by naming your project `DoToo`, then click
    **Next**:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将项目命名为 `DoToo` 并点击 **下一步** 来完成向导的下一页：
- en: "![Figure 2.3 – Configure your new proj\uFEFFect](img/Figure_2.3_B19214.jpg)"
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.3 – 配置你的新项目](img/Figure_2.3_B19214.jpg)'
- en: Figure 2.3 – Configure your new project
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.3 – 配置你的新项目
- en: 'The next step will prompt you for the version of .NET Core to support. At the
    time of writing, .NET 6 is available as **Long-Term Support** (**LTS**), and .NET
    7 is available as **Standard Term Support**. For this book, we will assume that
    you will be using .NET 7:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步将提示你选择要支持的 .NET Core 版本。在撰写本文时，.NET 6 可用为 **长期支持**（**LTS**），.NET 7 可用为 **标准期限支持**。对于本书，我们假设你将使用
    .NET 7：
- en: '![Figure 2.4 – Additional information](img/Figure_2.4_B19214.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.4 – 其他信息](img/Figure_2.4_B19214.jpg)'
- en: Figure 2.4 – Additional information
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.4 – 其他信息
- en: Finalize the setup by clicking **Create** and wait for Visual Studio to create
    the project.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击 **创建** 并等待 Visual Studio 创建项目来最终完成设置。
- en: Congratulations! We’ve just created our first .NET MAUI app. Let’s take a look
    at what the template wizard generated for us.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！我们刚刚创建了我们第一个 .NET MAUI 应用。让我们看看模板向导为我们生成了什么。
- en: Examining the files
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查文件
- en: 'The selected template has now created a single project called `DoToo` as a
    .NET library that can target iOS, Mac Catalyst (macOS), Android, and Windows platforms.
    You can switch the target platform using the main toolbar in Visual Studio, as
    shown in *Figure 2**.5*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 选择的模板已创建一个名为 `DoToo` 的单个项目，作为一个可以针对 iOS、Mac Catalyst（macOS）、Android 和 Windows
    平台的目标 .NET 库。你可以使用 Visual Studio 中的主工具栏切换目标平台，如图 *图 2**.5* 所示：
- en: '![Figure 2.5 – The Debug Target drop-down menu](img/Figure_2.5_B19214.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.5 – 调试目标下拉菜单](img/Figure_2.5_B19214.jpg)'
- en: Figure 2.5 – The Debug Target drop-down menu
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.5 – 调试目标下拉菜单
- en: The Windows platform is selected by default, but you can easily switch to iOS
    or Android by using the **Debug Target** drop-down menu. In the dropdown under
    the **Framework** sub-menu, you will find all the supported target platforms.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下选择 Windows 平台，但你可以通过使用 **调试目标** 下拉菜单轻松切换到 iOS 或 Android。在 **框架** 子菜单下的下拉菜单中，你可以找到所有支持的目标平台。
- en: The target framework will also change appropriately when you choose a target
    device. If you select an emulator under the **Android Emulators** menu item, then
    the Android target framework will become the current framework, whereas if you
    select an iOS simulator or device from one of the iOS menu items, iOS will be
    the current framework.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 当你选择目标设备时，目标框架也将相应地更改。如果你在 **Android 模拟器** 菜单项下选择模拟器，那么 Android 目标框架将成为当前框架，而如果你从
    iOS 菜单项中选择 iOS 模拟器或设备，iOS 将成为当前框架。
- en: 'The project should now look as follows:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 项目现在应该如下所示：
- en: "![Figure 2.6 – .NET MAUI project str\uFEFFucture](img/Figure_2.6_B19214.jpg)"
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.6 – .NET MAUI 项目结构](img/Figure_2.6_B19214.jpg)'
- en: Figure 2.6 – .NET MAUI project structure
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.6 – .NET MAUI 项目结构
- en: We will highlight a few important files in the project so that we have a basic
    understanding of what they are. First, we will look at the shared code, after
    which we’ll look at the files/code specific to each platform (stored under the
    different platform folders).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将突出显示项目中的几个重要文件，以便我们对其有一个基本了解。首先，我们将查看共享代码，然后我们将查看每个平台特定的文件/代码（存储在不同的平台文件夹下）。
- en: Shared code
  id: totrans-46
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 共享代码
- en: Under `Dependencies`, we will find references to any external dependencies,
    such as each referenced .NET mobile framework. Under each framework, you will
    find the .NET MAUI dependency under the `packages` folder. We will update the
    .NET MAUI package version in the *Updating the .NET MAUI packages* section and
    add more dependencies as we progress through this chapter.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Dependencies` 下，我们将找到对任何外部依赖项的引用，例如每个引用的 .NET 移动框架。在每个框架下，你将在 `packages`
    文件夹下找到 .NET MAUI 依赖项。我们将在 *更新 .NET MAUI 包* 部分更新 .NET MAUI 包版本，并在本章的后续内容中添加更多依赖项。
- en: 'The `MauiProgram.cs` file is the starting point for the application. The initial
    template will generate a `MauiProgram` class that looks as follows:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`MauiProgram.cs` 文件是应用程序的起点。初始模板将生成一个如下所示的 `MauiProgram` 类：'
- en: '[PRE0]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The static `MauiProgram` class contains a single `CreateMauiApp` method that
    returns `MauiApp`. This instance is created by using `MauiAppBuilder`, which works
    in much the same way that the ASP.NET builders work; `MauiAppBuilder` uses a `Application`
    instance.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 静态的`MauiProgram`类包含一个`CreateMauiApp`方法，该方法返回`MauiApp`。这个实例是通过使用`MauiAppBuilder`创建的，它的工作方式与ASP.NET构建器非常相似；`MauiAppBuilder`使用一个`Application`实例。
- en: What is a Fluent API?
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是Fluent API？
- en: A Fluent API allows method chaining wherein each method of the API returns the
    same context. Fluent APIs form a distinct language in themselves by using terms
    specific to the topic of the API. This makes the API easier to grasp and use.
    C#’s **Language Integrated Query** (**LINQ**) is a good example of a Fluent API.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: Fluent API允许方法链式调用，其中API的每个方法都返回相同的上下文。Fluent API通过使用特定于API主题的术语形成了一种独特的语言。这使得API更容易理解和使用。C#的**语言集成查询**（**LINQ**）是Fluent
    API的一个很好的例子。
- en: Extension methods are used to add features and services to the `MauiApp` instance.
    The `UseMauiApp` extension method identifies the subclass of `Microsoft.Maui.Controls.Application`
    to use. By default, this class is defined in the `App.xaml` and `App.xaml.cs`
    files. Another extension method, `ConfigureFonts`, is used by the template to
    register custom font files in use by the application. Yet another example of an
    extension method that can be used is `ConfigureLifecycleEvents`, which is used
    to set up handlers for the cross-platform life cycle events available in .NET
    MAUI. We will discuss `ConfigureLifecycleEvents` more in *Chapter 3*, *Converting
    a Xamarin.Forms App into .**NET MAUI*.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法用于向`MauiApp`实例添加功能和服务。`UseMauiApp`扩展方法标识要使用的`Microsoft.Maui.Controls.Application`的子类。默认情况下，这个类定义在`App.xaml`和`App.xaml.cs`文件中。另一个扩展方法`ConfigureFonts`被模板用于注册应用程序使用的自定义字体文件。另一个可以使用的扩展方法示例是`ConfigureLifecycleEvents`，它用于设置.NET
    MAUI中可用的跨平台生命周期事件的处理器。我们将在*第3章*，*将Xamarin.Forms应用程序转换为.NET MAUI*中更详细地讨论`ConfigureLifecycleEvents`。
- en: The `App.xaml` file is a XAML file that represents the app. This is a good place
    to put application-wide resources, which we will do later. We can also see the
    `App.xaml.cs` file, which contains the startup code.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`App.xaml`文件是一个XAML文件，它表示应用程序。这是一个放置应用程序范围资源的好地方，我们稍后会这样做。我们还可以看到`App.xaml.cs`文件，它包含启动代码。'
- en: 'If we open `App.xaml.cs`, we can see the starting point for our .NET MAUI application:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们打开`App.xaml.cs`，我们可以看到我们的.NET MAUI应用程序的起点：
- en: '[PRE1]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The `MainPage` property is assigned to a page, which is particularly important
    as this determines which page is shown first to the user. In this template, this
    is the `DoToo.AppShell()`class.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainPage`属性被分配给一个页面，这尤其重要，因为它决定了哪个页面首先向用户显示。在这个模板中，这是`DoToo.AppShell()`类。'
- en: 'The `AppShell.xaml` and `AppShell.xaml.cs` files declare the first visible
    UI component in the .NET MAUI app. Shell provides a form of navigation between
    pages. When you open `AppShell.xaml`, it should look like this:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppShell.xaml`和`AppShell.xaml.cs`文件声明了.NET MAUI应用程序中第一个可见的UI组件。Shell提供了页面之间的导航形式。当你打开`AppShell.xaml`时，它应该看起来像这样：'
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `ShellContent` element identifies an individual page that is displayed within
    the shell. The `ContentTemplate` attribute is used to locate the class that implements
    the page – in this case, `MainPage` – while `Route` is the unique identifier for
    the page.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShellContent`元素标识了在shell中显示的单独页面。`ContentTemplate`属性用于定位实现页面的类——在本例中是`MainPage`——而`Route`是页面的唯一标识符。'
- en: The last two files are the `MainPage.xaml` file, which contains the first page
    of the application, and the code-behind file, which is called `MainPage.xaml.cs`.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后两个文件是`MainPage.xaml`文件，它包含应用程序的第一页，以及后置代码文件，称为`MainPage.xaml.cs`。
- en: Next, we will work through each platform’s files. Each platform has a unique
    folder under the `Platforms` folder. Android files are in the `Android` folder,
    iOS files are in the `iOS` folder, Mac Catalyst files are in the `MacCatalyst`
    folder, Tizen files are in the `Tizen` folder, and Windows files are in the `Windows`
    folder.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将逐个处理每个平台的文件。每个平台在`Platforms`文件夹下都有一个独特的文件夹。Android文件位于`Android`文件夹中，iOS文件位于`iOS`文件夹中，Mac
    Catalyst文件位于`MacCatalyst`文件夹中，Tizen文件位于`Tizen`文件夹中，Windows文件位于`Windows`文件夹中。
- en: Android
  id: totrans-63
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Android
- en: 'The Android-specific platform code lives under the `Platforms/Android` folder
    in the project:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: Android特定平台代码位于项目中的`Platforms/Android`文件夹下：
- en: '![Figure 2.7 – Android-specific files](img/Figure_2.7_B19214.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图2.7 – Android特定文件](img/Figure_2.7_B19214.jpg)'
- en: Figure 2.7 – Android-specific files
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.7 – Android特定文件
- en: The important files here are `MainActivity.cs` and `MainApplication.cs`. These
    two files contain the entry point for our application when we run the app on an
    Android device. A standard Android app will declare `MainLauncher` property of
    the `Activity` class attribute. `MauiAppCompatActivity` will search for a type
    decorated with `ApplicationAttribute` and instantiate it.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重要文件是 `MainActivity.cs` 和 `MainApplication.cs`。这两个文件包含我们在 Android 设备上运行应用程序时的应用程序入口点。标准的
    Android 应用会声明 `Activity` 类的 `MainLauncher` 属性。`MauiAppCompatActivity` 将搜索带有 `ApplicationAttribute`
    装饰的类型并实例化它。
- en: This attribute can be found in the `MainApplication` class in `MainApplication.cs`.
    During initialization, `MainApplication` will call the `CreateMauiApp` method,
    which, in turn, calls `MauiProgram.CreateMauiApp`, which we explored earlier in
    this chapter.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 此属性可以在 `MainApplication.cs` 文件中的 `MainApplication` 类中找到。在初始化期间，`MainApplication`
    将调用 `CreateMauiApp` 方法，该方法反过来调用我们在本章前面探索过的 `MauiProgram.CreateMauiApp`。
- en: You don’t need to understand these files in detail; just remember that they
    are important for initializing our app.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您不需要详细了解这些文件；只需记住，它们对于初始化我们的应用程序很重要。
- en: iOS and Mac Catalyst
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: iOS 和 Mac Catalyst
- en: 'The iOS and Mac Catalyst platform files are identical, but each has a folder
    for customizing the platform. Each platform’s files are contained in their respective
    named folder under the `Platform` folder:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: iOS 和 Mac Catalyst 平台文件相同，但每个平台都有一个用于自定义平台的文件夹。每个平台的文件都包含在 `Platform` 文件夹下各自命名的文件夹中：
- en: '![Figure 2.8 – iOS platform-specific files](img/Figure_2.8_B19214.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.8 – iOS 平台特定文件](img/Figure_2.8_B19214.jpg)'
- en: Figure 2.8 – iOS platform-specific files
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.8 – iOS 平台特定文件
- en: '`AppDelegate.cs` is the equivalent of the `MainApplication` class in the Android
    platform. It contains a single method called `CreateMauiApp` that has the same
    implementation as Android; it calls the `MauiProgram.CreateMauiApp` method.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`AppDelegate.cs` 是 Android 平台中 `MainApplication` 类的等价物。它包含一个名为 `CreateMauiApp`
    的单个方法，其实现与 Android 相同；它调用 `MauiProgram.CreateMauiApp` 方法。'
- en: The `Program.cs` file is the entry point for an iOS app. It contains the `Main`
    method, which calls `UIApplication.Main`, the launching point for an iOS application,
    and references the `AppDelegate` type to instantiate.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: '`Program.cs` 文件是 iOS 应用的入口点。它包含 `Main` 方法，该方法调用 `UIApplication.Main`，这是 iOS
    应用的启动点，并引用 `AppDelegate` 类型以实例化。'
- en: The code starts by initializing .NET MAUI and then loads the application. After
    that, it returns control to iOS. It must do this within 17 seconds; otherwise,
    the app is terminated by the OS.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 代码首先初始化 .NET MAUI，然后加载应用程序。之后，它将控制权返回给 iOS。它必须在 17 秒内完成此操作；否则，应用程序将被操作系统终止。
- en: The `info.plist` file is an iOS-specific file that contains information about
    the app, such as the bundle ID and its provisioning profiles. Visual Studio has
    a graphical editor for the `info.plist` file, but since it is a standard XML file,
    it can be edited in any text editor.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: '`info.plist` 文件是 iOS 特定的文件，其中包含有关应用程序的信息，例如包 ID 和其配置文件。Visual Studio 为 `info.plist`
    文件提供了一个图形编辑器，但由于它是一个标准的 XML 文件，因此可以使用任何文本编辑器进行编辑。'
- en: As with the Android app’s startup code, we don’t need to understand what is
    going on here in detail, other than that it’s important for initializing our app.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 与 Android 应用的启动代码一样，我们不需要详细了解这里发生的事情，只需知道这对于初始化我们的应用程序很重要。
- en: Tizen
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Tizen
- en: Tizen is Samsung’s custom distribution of Android. The `Main.cs` file is the
    launching point and, like the Android platform, the `Program` class has a `CreateMauiApp`
    method. Tizen is not enabled by default. To enable it, follow the instructions
    in the comments in the `DoToo.csproj` file. To develop applications for Tizen,
    you will need to install additional software distributed by Samsung.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: Tizen 是三星定制的 Android 发行版。`Main.cs` 文件是启动点，类似于 Android 平台，`Program` 类有一个 `CreateMauiApp`
    方法。Tizen 默认未启用。要启用它，请遵循 `DoToo.csproj` 文件中的注释说明。要为 Tizen 开发应用程序，您需要安装三星分发的附加软件。
- en: Windows
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Windows
- en: 'The last platform we will examine is the **WinUI** app. The file structure
    looks as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要检查的最后一个平台是 **WinUI** 应用。文件结构如下：
- en: '![Figure 2.9 – Windows-specific files](img/Figure_2.9_B19214.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.9 – Windows 特定文件](img/Figure_2.9_B19214.jpg)'
- en: Figure 2.9 – Windows-specific files
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.9 – Windows 特定文件
- en: It has an `App.xaml` file, which is like the one in the shared code, but specific
    to `App.xaml.cs`. This file is the Windows equivalent of Android’s `MauiApplication`,
    which contains the `CreateMauiApp` method.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 它有一个 `App.xaml` 文件，类似于共享代码中的文件，但特定于 `App.xaml.cs`。此文件是 Windows 的 Android 的 `MauiApplication`
    的等价物，它包含 `CreateMauiApp` 方法。
- en: That’s it for the platform project files. Next, we will look at how to keep
    .NET MAUI up to date.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 平台项目文件就到这里了。接下来，我们将探讨如何保持 .NET MAUI 的更新。
- en: Updating the .NET MAUI packages
  id: totrans-87
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更新 .NET MAUI 包
- en: Note – Windows users
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 – Windows用户
- en: Since .NET MAUI is distributed as part of Visual Studio, it is best to allow
    Visual Studio to update the packages when you update Visual Studio. If you follow
    these steps, you can probably get .NET MAUI into an unusable state.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 .NET MAUI 是作为 Visual Studio 的一部分分发的，因此最好让 Visual Studio 在您更新 Visual Studio
    时更新这些包。如果您遵循这些步骤，您可能将 .NET MAUI 更新到一个不可用的状态。
- en: .NET MAUI is distributed as a set of optional `dotnet workload` command. To
    see the currently installed workloads and their versions, you can use the `dotnet
    workload list` command. Visual Studio 2022 has a built-in developer PowerShell
    to execute commands. To access it, press *Ctrl* + *`* on both macOS and Windows.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 以一组可选的 `dotnet workload` 命令的形式分发。要查看当前安装的工作负载及其版本，您可以使用 `dotnet workload
    list` 命令。Visual Studio 2022 内置了开发者 PowerShell 来执行命令。要访问它，请在 macOS 和 Windows 上同时按
    *Ctrl* + *`*。
- en: 'Running the `dotnet workload list` should give you the following output. Note
    that your version numbers may be higher:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 运行 `dotnet workload list` 应该会给出以下输出。请注意，您的版本号可能更高：
- en: '[PRE3]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To update the packages in the MAUI workload, you can run `dotnet workload update`.
    This is a sample of the result from running that command:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 要更新 MAUI 工作负载中的包，您可以使用 `dotnet workload update`。这是运行该命令的结果示例：
- en: '[PRE4]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To see the result, just run the `dotnet workload list` command again:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看结果，只需再次运行 `dotnet workload list` 命令：
- en: '[PRE5]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now that we have a basic understanding of how .NET MAUI projects are structured,
    we can start building our first app!
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对 .NET MAUI 项目的结构有了基本的了解，我们可以开始构建我们的第一个应用程序了！
- en: Creating a repository and a TodoItem model
  id: totrans-98
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个存储库和一个 TodoItem 模型
- en: Any good architecture always involves abstraction. In this app, we need something
    to store and retrieve the items of our to-do list. Later, these will be stored
    in a SQLite database, but adding a reference to the database directly in the code
    that is responsible for the GUI is generally a bad idea as it tightly couples
    your data storage implementation to the UI layer, making it harder to test your
    UI code independently from the database.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 任何好的架构总是涉及抽象。在这个应用程序中，我们需要一个东西来存储和检索待办事项列表中的项目。稍后，这些项目将存储在 SQLite 数据库中，但将数据库直接添加到负责
    GUI 的代码中通常是一个坏主意，因为它将您的数据存储实现与 UI 层紧密耦合，这使得独立于数据库测试您的 UI 代码变得更加困难。
- en: So, what we need is something to abstract our database from the GUI. For this
    app, we’ve chosen to use a simple repository pattern. This repository is simply
    a class that sits between the SQLite database and our upcoming `ViewModel` class.
    This is the class that handles the interaction with the view, which, in turn,
    handles the GUI.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要一个东西来抽象我们的数据库与 GUI。对于这个应用程序，我们选择使用简单的存储库模式。这个存储库只是一个位于 SQLite 数据库和即将到来的
    `ViewModel` 类之间的类。这是处理与视图交互的类，反过来，它处理 GUI。
- en: The repository will expose methods for getting, adding, and updating items,
    as well as events that allow other parts of the app to react to changes in the
    repository. It will be hidden behind an interface so that we can replace the entire
    implementation later without modifying anything but a line of code in the initialization
    of the app. This is made possible by the **Microsoft.Extensions.DependencyInjection**
    NuGet package.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库将公开获取、添加和更新项目的方法，以及允许应用程序的其他部分对存储库中的更改做出反应的事件。它将隐藏在接口后面，这样我们就可以在不修改应用程序初始化中的任何代码的情况下替换整个实现。这是由
    **Microsoft.Extensions.DependencyInjection** NuGet 包实现的。
- en: Defining a to-do list item
  id: totrans-102
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义待办事项列表项
- en: 'We will start by creating a `TodoItem` class, which represents a single item
    on the list. This is a simple **Plain Old CLR Object** (**POCO**) class, where
    **CLR** stands for **Common Language Runtime**. In other words, this is a .NET
    class without any dependencies on third-party assemblies. To create the class,
    follow these steps:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先创建一个 `TodoItem` 类，它代表列表上的单个项目。这是一个简单的 **Plain Old CLR Object** (**POCO**)
    类，其中 **CLR** 代表 **Common Language Runtime**。换句话说，这是一个没有依赖第三方组件的 .NET 类。要创建该类，请按照以下步骤操作：
- en: In the `DoToo` project, create a folder called `Models`.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DoToo` 项目中，创建一个名为 `Models` 的文件夹。
- en: 'Add a class called `TodoItem.cs` to that folder and enter the following code:'
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在那个文件夹中添加一个名为 `TodoItem.cs` 的类，并输入以下代码：
- en: '[PRE6]'
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: This code is self-explanatory; it’s a simple POCO class that only contains properties
    and no logic. We have a `Title` property that describes what we want to be done,
    a flag named `Completed` that determines whether the to-do list item is completed,
    a `Due` date for when we expect it to be done, and a unique `Id` property that
    we will need later for the database.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码是自我解释的；它是一个简单的POCO（Plain Old CLR Object）类，只包含属性而没有逻辑。我们有一个`Title`属性，用于描述我们想要执行的操作，一个名为`Completed`的标志，用于确定待办事项列表项是否已完成，一个`Due`日期，表示我们期望完成的时间，以及一个唯一的`Id`属性，我们稍后会需要它在数据库中使用。
- en: Creating a repository and its interface
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建仓库及其接口
- en: 'Now that we have the `TodoItem` class, let’s define an interface that describes
    a repository that will store our to-do list items:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有了`TodoItem`类，让我们定义一个接口，描述一个将存储我们的待办事项列表项的仓库：
- en: In the `DoToo` project, create a folder called `Repositories`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DoToo`项目中创建一个名为`Repositories`的文件夹。
- en: 'Create an interface called `ITodoItemRepository.cs` in the `Repositories` folder
    and write the following code:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Repositories`文件夹中创建一个名为`ITodoItemRepository.cs`的接口，并编写以下代码：
- en: '[PRE7]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Wait, what? No Delete method?
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 等等，什么？没有删除方法？
- en: The eagle-eyed among you might have noticed that we are not defining a `Delete`
    method in this interface. This is something that should be in a real-world app.
    While the app that we are creating in this chapter does not support deleting items,
    we are quite sure that you could add this yourself if you want to!
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 眼尖的你们可能已经注意到，我们没有在这个接口中定义`Delete`方法。这在现实世界的应用中应该是必须的。虽然我们在本章创建的应用不支持删除项目，但我们非常确信，如果您想的话，您可以自己添加这个功能！
- en: This interface defines everything we need for our app. It is there to create
    logical insulation between your implementation of a repository and the user of
    that repository. If any other parts of your application want an instance of `ITodoItemRepository`,
    we can pass it an object that implements `ITodoItemRepository`, regardless of
    how it’s implemented.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 此接口定义了我们应用所需的一切。它的存在是为了在您的仓库实现和仓库使用者之间创建逻辑隔离。如果应用的其他部分需要`ITodoItemRepository`的一个实例，我们可以传递一个实现了`ITodoItemRepository`的对象，无论其实现方式如何。
- en: 'With that said, let’s implement `ITodoItemRepository`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，让我们来实现`ITodoItemRepository`：
- en: Create a class called `TodoItemRepository.cs` in the `Repositories` folder.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Repositories`文件夹中创建一个名为`TodoItemRepository.cs`的类。
- en: 'Enter the following code:'
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 输入以下代码：
- en: '[PRE8]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This code is the bare-bones implementation of the interface, except for the
    `AddOrUpdateAsync(...)` method. This handles a small piece of logic that states
    that if the `Id` value of an item is `0`, it’s a new item. Any item with an `Id`
    value greater than `0` is stored in the database. This is because the database
    assigns a value larger than `0` when we create rows in a table.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 此代码是接口的裸骨实现，除了`AddOrUpdateAsync(...)`方法。这个方法处理一小段逻辑，即如果一个项目的`Id`值为`0`，则它是一个新项目。任何`Id`值大于`0`的项目都存储在数据库中。这是因为当我们在表中创建行时，数据库会分配一个大于`0`的值。
- en: There are also two events defined in the preceding code. They will be used to
    notify subscribers of a list of items that have been updated or added.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码中还定义了两个事件。它们将被用来通知订阅者有关已更新或添加的项目列表。
- en: Connecting SQLite to persist data
  id: totrans-122
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将SQLite连接到持久化数据
- en: We now have an interface, as well as a skeleton to implement that interface.
    The last thing we need to do to finish this section is to connect SQLite in the
    implementation of the repository.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经有一个接口，以及实现该接口的框架。为了完成本节，我们需要在仓库的实现中连接SQLite。
- en: Adding the SQLite NuGet package
  id: totrans-124
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加SQLite NuGet包
- en: 'To access SQLite in this project, we need to add a NuGet package called `sqlite-net-pcl`
    to the `DoToo` project. To do this, right-click on the `DoToo` project node of
    the solution and click **Manage** **NuGet Packages...**:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 要在此项目中访问SQLite，我们需要将名为`sqlite-net-pcl`的NuGet包添加到`DoToo`项目中。为此，右键单击解决方案中的`DoToo`项目节点，然后单击**管理**
    **NuGet包...**：
- en: '![Figure 2.10 – Manage NuGet Packages...](img/Figure_2.10_B19214.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![图2.10 – 管理NuGet包...](img/Figure_2.10_B19214.jpg)'
- en: Figure 2.10 – Manage NuGet Packages...
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.10 – 管理NuGet包...
- en: Portable Class Library (PCL)
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 可移植类库 (PCL)
- en: You might have noticed that the NuGet package is suffixed with `-pcl`. This
    is an example of what happens when naming conventions go wrong. This package supports
    .NET Standard 1.0, even though the name says PCL, which was the predecessor of
    .NET Standard.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，NuGet包以`-pcl`结尾。这是命名规范出错时发生的一个例子。此包支持.NET Standard 1.0，尽管其名称表明它是PCL（Portable
    Class Library），它是.NET Standard的前身。
- en: 'This brings up the **NuGet Package** **Manager** window:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打开**NuGet包管理器**窗口：
- en: '![Figure 2.11 – NuGet Package Manager](img/Figure_2.11_B19214.jpg)'
  id: totrans-131
  prefs: []
  type: TYPE_IMG
  zh: '![图2.11 – NuGet包管理器](img/Figure_2.11_B19214.jpg)'
- en: Figure 2.11 – NuGet Package Manager
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.11 – NuGet包管理器
- en: 'To install the SQLite NuGet package, follow these steps:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装SQLite NuGet包，请按照以下步骤操作：
- en: Click `sqlite-net-pcl` in the search box.
  id: totrans-134
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在搜索框中点击`sqlite-net-pcl`。
- en: Select the package by **sQLite-net** and click **Install**.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过**sQLite-net**选择包并点击**安装**。
- en: A dialog will be displayed showing you all the packages that will be downloaded
    to your system; accept the changes to complete the installation.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将会显示一个对话框，显示所有将被下载到您系统中的包；接受更改以完成安装。
- en: Important
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 重要
- en: 'Version 1.8.116 of the `sqlite-net-pcl` package references versions of the
    native library that are not fully compatible with .NET 6+ on all platforms. To
    work around this, you need to add additional references to the following packages
    manually with a version of at least 2.1:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: '`sqlite-net-pcl`包的1.8.116版本引用了与.NET 6+在所有平台上不完全兼容的原生库版本。为了解决这个问题，您需要手动添加以下包的额外引用，版本至少为2.1：'
- en: '- `SQLitePCLRaw.core`'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: '- `SQLitePCLRaw.core`'
- en: '- `SQLitePCLRaw.provider.sqlite3`'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '- `SQLitePCLRaw.provider.sqlite3`'
- en: '- `SQLitePCLRaw.bundle_green`'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: '- `SQLitePCLRaw.bundle_green`'
- en: '- `SQLitePCLRaw.provider.dynamic_cdecl`'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '- `SQLitePCLRaw.provider.dynamic_cdecl`'
- en: See [https://github.com/praeclarum/sqlite-net/issues/1102](https://github.com/praeclarum/sqlite-net/issues/1102)
    for more details and a potential resolution.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多详细信息和一个可能的解决方案，请参阅[https://github.com/praeclarum/sqlite-net/issues/1102](https://github.com/praeclarum/sqlite-net/issues/1102)。
- en: Once the installation is complete, we can add some code to the `TodoItem` class
    to map the C# object to a table and create the connection to the database in the
    repository.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 安装完成后，我们可以在`TodoItem`类中添加一些代码，将C#对象映射到表，并在仓库中创建数据库连接。
- en: Updating the TodoItem class
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新TodoItem类
- en: 'Since SQLite is a relational database, it needs to know some basic information
    about how to create the tables that will store our objects. This is done using
    attributes, which are defined in the SQLite namespace:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 由于SQLite是一个关系型数据库，它需要了解一些关于如何创建存储我们对象的表的基本信息。这通过使用属性来完成，这些属性在SQLite命名空间中定义：
- en: Open `Models/TodoItem.cs`.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Models/TodoItem.cs`。
- en: 'Add a `using SQLite` statement at the start of the file right below the `namespace`
    statement, as shown in the following code:'
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件开头，紧接在`namespace`语句下方添加一个`using SQLite`语句，如下面的代码所示：
- en: '[PRE9]'
  id: totrans-149
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add the `PrimaryKey` and `AutoIncrement` attributes right before the `Id` property,
    as shown in the following code:'
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Id`属性之前添加`PrimaryKey`和`AutoIncrement`属性，如下面的代码所示：
- en: '[PRE10]'
  id: totrans-151
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: The `PrimaryKey` attribute instructs SQLite that the `Id` property is the primary
    key of the table. The `AutoIncrement` attribute makes sure that the value of `Id`
    is increased by 1 for each new `TodoItem` class that is added to the table.
  id: totrans-152
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`PrimaryKey`属性指示SQLite，`Id`属性是表的键。`AutoIncrement`属性确保每次向表中添加新的`TodoItem`类时，`Id`的值增加1。'
- en: With the data object classes properly configured, it is now time to create the
    connection to the database.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 在正确配置数据对象类之后，现在是时候创建数据库连接了。
- en: Creating a connection to the SQLite database
  id: totrans-154
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建与SQLite数据库的连接
- en: 'We will now add all the code needed to communicate with the database. The first
    thing we need to do is define a connection field that will hold the connection
    to the database:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们将添加所有与数据库通信所需的代码。首先，我们需要定义一个连接字段，它将保存对数据库的连接：
- en: Open the `Repositories/TodoItemRepository.cs` file.
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`Repositories/TodoItemRepository.cs`文件。
- en: 'Add a `using SQLite` statement right below the existing `using` statements,
    as shown in the following code:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在现有`using`语句下方添加一个`using SQLite`语句，如下面的代码所示：
- en: '[PRE11]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Add the following field right below the class declaration:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类声明下方添加以下字段：
- en: '[PRE12]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The connection needs to be initialized. Once it is initialized, it can be reused
    throughout the lifespan of the repository. Since the method is asynchronous, it
    cannot be called from the constructor without introducing a locking strategy.
    To keep things simple, we will simply call it from each of the methods that are
    defined by the interface. To do so, add the following code to the `TodoItemRepository`
    class:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 连接需要被初始化。一旦初始化，它就可以在整个仓库的生命周期中重复使用。由于该方法是非同步的，不能从构造函数中调用而不引入锁定策略。为了简化问题，我们将简单地从接口定义的每个方法中调用它。为此，将以下代码添加到`TodoItemRepository`类中：
- en: '[PRE13]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: The method begins by checking whether we already have a connection. If we do,
    we can simply `return`. If we don’t have a connection set up, we define a path
    on the disk to indicate where we want the database file to be located. In this
    case, we will choose the `MyDocuments` folder. .NET MAUI will find the closest
    match to this on each platform that we target.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 该方法首先检查我们是否已经有一个连接。如果有，我们可以简单地 `return`。如果没有设置连接，我们定义一个磁盘上的路径来指示我们希望数据库文件所在的位置。在这种情况下，我们将选择
    `MyDocuments` 文件夹。.NET MAUI 将在每个我们针对的平台找到最接近的匹配项。
- en: Then, we create the connection and store the reference to that connection in
    the `connection` field. We need to make sure that SQLite has created a table that
    mirrors the schema of the `TodoItem` table. To make developing the app easier,
    we add a default to-do list item if the `TodoItem` table is empty.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建连接并将该连接的引用存储在 `connection` 字段中。我们需要确保 SQLite 已经创建了一个与 `TodoItem` 表模式相对应的表。为了使开发应用程序更容易，如果
    `TodoItem` 表为空，我们将添加一个默认待办事项列表项。
- en: Next, we’ll add the implementation for the database operations.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将添加数据库操作的实现。
- en: Implementing the GetItemsAsync(), AddItemsAsync(), and UpdateItemsAsync() methods
  id: totrans-166
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现 GetItemsAsync(), AddItemsAsync(), 和 UpdateItemsAsync() 方法
- en: 'The only thing left to do in the repository is to implement the methods for
    getting, adding, and updating items:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在存储库中剩下的唯一事情是实现获取、添加和更新项目的相关方法：
- en: Locate the `GetItemsAsync()` method in the `TodoItemRepository` class.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TodoItemRepository` 类中定位 `GetItemsAsync()` 方法。
- en: 'Update the `GetItemsAsync()` method with the following code:'
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `GetItemsAsync()` 方法：
- en: '[PRE14]'
  id: totrans-170
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: To ensure that the connection to the database is valid, we call the `CreateConnectionAsync()`
    method we created in the previous section. When this method returns, we can ensure
    that it is initialized and that the `TodoItem` table has been created.
  id: totrans-171
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 为了确保数据库连接有效，我们调用上一节中创建的 `CreateConnectionAsync()` 方法。当此方法返回时，我们可以确保它已初始化，并且
    `TodoItem` 表已创建。
- en: Then, we use the connection to access the `TodoItem` table and return a `List<TodoItem>`
    item that contains all the to-do list items in the database.
  id: totrans-172
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，我们使用连接来访问 `TodoItem` 表，并返回一个包含数据库中所有待办事项列表项的 `List<TodoItem>` 项目。
- en: SQLite and LINQ
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 和 LINQ
- en: SQLite supports querying data using LINQ. You can play around with this after
    the project is complete to get a better understanding of how to work it with databases
    in your app.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: SQLite 支持使用 LINQ 查询数据。项目完成后，你可以尝试使用它来更好地理解如何在你的应用程序中与数据库一起工作。
- en: 'The code for adding items is even simpler:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 添加项目的代码甚至更简单：
- en: Locate the `AddItemAsync()` method in the `TodoItemRepository` class.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TodoItemRepository` 类中定位 `AddItemAsync()` 方法。
- en: 'Update the `AddItemAsync()` method with the following code:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `AddItemAsync()` 方法：
- en: '[PRE15]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The call to `CreateConnectionAsync()` makes sure that we have a connection in
    the same way as we did for the `GetItemsAsync()` method. After this, we insert
    it into the database using the `InsertAsyncAsync(...)` method on the `connection`
    object. After an item has been inserted into the table, we invoke the `OnItemAdded`
    event to notify any subscribers.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 对 `CreateConnectionAsync()` 的调用确保了我们有一个连接，就像我们对 `GetItemsAsync()` 方法所做的那样。之后，我们使用
    `connection` 对象上的 `InsertAsyncAsync(...)` 方法将其插入数据库。一个项目被插入到表中后，我们调用 `OnItemAdded`
    事件来通知任何订阅者。
- en: 'The code to update an item is the same as the `AddItemAsync()` method but also
    includes calls to `UpdateAsync` and `OnItemUpdated`. Let’s finish up by updating
    the `UpdateItemAsync()` method with the following code:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 更新项目的代码与 `AddItemAsync()` 方法相同，但还包括对 `UpdateAsync` 和 `OnItemUpdated` 的调用。让我们通过以下代码更新
    `UpdateItemAsync()` 方法来完成：
- en: Locate the `UpdateItemAsync()` method in the `TodoItemRepository` class.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `TodoItemRepository` 类中定位 `UpdateItemAsync()` 方法。
- en: 'Update the `UpdateItemAsync()` method with the following code:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下代码更新 `UpdateItemAsync()` 方法：
- en: '[PRE16]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the next section, we’ll get started with MVVM. Grab a cup of coffee and let’s
    get started!
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始学习 MVVM。拿一杯咖啡，让我们开始吧！
- en: Using MVVM – creating views and ViewModels
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 MVVM – 创建视图和视图模型
- en: '**Model-View-ViewModel**, or **MVVM** for short, is all about **separation
    of concerns**. It is an architectural pattern that defines three parts, each of
    which has a specific meaning:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: '**模型-视图-视图模型**，简称 **MVVM**，其核心是 **关注点分离**。它是一种定义了三个部分，每个部分都有特定意义的架构模式：'
- en: '`ViewModel`.'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ViewModel`。'
- en: '**View**: This is the visual component. In .NET MAUI, this is represented by
    a page.'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**视图**：这是视觉组件。在 .NET MAUI 中，这由一个页面表示。'
- en: '**ViewModel**: This is the class that acts as the glue between the model and
    the view.'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**ViewModel**：这是一个作为模型和视图之间粘合剂的类。'
- en: We are introducing MVVM here because the MVVM pattern was designed specifically
    around XAML-based GUIs. This app and the rest of the apps in this book will use
    XAML to define the GUI and we will use the MVVM pattern to separate the code into
    the three aforementioned parts.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里引入 MVVM，因为 MVVM 模式是专门针对基于 XAML 的 GUI 设计的。这个应用以及本书中的其他应用都将使用 XAML 来定义 GUI，我们将使用
    MVVM 模式来将代码分为前面提到的三个部分。
- en: In this app, we could say that the model is the repository and the to-do list
    items it returns. `ViewModel` refers to this repository and exposes properties
    that the view can bind to. The ground rule is that any logic should reside in
    `ViewModel` and no logic should reside in the view. The view should know how to
    present data, such as converting a Boolean value into `Yes` or `No`.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个应用中，我们可以认为模型是仓库以及它返回的任务列表项。`ViewModel` 指的是这个仓库，并公开了视图可以绑定的属性。基本规则是任何逻辑都应该位于
    `ViewModel` 中，而没有任何逻辑应该位于视图中。视图应该知道如何呈现数据，例如将布尔值转换为 `是` 或 `否`。
- en: MVVM can be implemented in many ways and there are quite a few frameworks that
    we can use to do so, such as **Prism**, **MVVMCross**, or even **TinyMvvm**. In
    this chapter, we have chosen to keep things simple and implement MVVM in a vanilla
    way first, and then use portions of the **CommunityToolkit.Mvvm** library. CommunityTookit.Mvvm
    is an open source library produced by the .NET Foundation. It is a replacement
    for the **MVVMLight** library.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: MVVM 可以以多种方式实现，并且有相当多的框架可以帮助我们实现，例如 **Prism**、**MVVMCross**，甚至是 **TinyMvvm**。在本章中，我们选择保持简单，首先以纯方式实现
    MVVM，然后使用 **CommunityToolkit.Mvvm** 库的部分功能。CommunityTookit.Mvvm 是由 .NET 基金会生产的开源库。它是
    **MVVMLight** 库的替代品。
- en: "The main benefits of using MVVM as an architectural pattern are a clear separation\
    \ of concerns, cleaner code, and great testability of `ViewModel`. If you are\
    \ interested in learning more about MVVM, and how to use it with .NET MAUI, visit\
    \ [https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm](https://learn.microsoft.com/en-us/dotnet/arch\uFEFF\
    \uFEFF\uFEFFitecture/maui/mvvm)."
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: "使用 MVVM 作为架构模式的主要好处是关注点的明确分离、代码更清晰，以及 `ViewModel` 的良好可测试性。如果您想了解更多关于 MVVM 的信息，以及如何与\
    \ .NET MAUI 一起使用它，请访问 [https://learn.microsoft.com/en-us/dotnet/architecture/maui/mvvm](https://learn.microsoft.com/en-us/dotnet/arch\uFEFF\
    \uFEFF\uFEFFitecture/maui/mvvm)。"
- en: Well, enough of that – let’s write some code instead!
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 好了，就说到这里吧——让我们来写一些代码吧！
- en: Defining a ViewModel base class
  id: totrans-195
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 定义 ViewModel 基类
- en: '`ViewModel` is the mediator between the view and the model. We can benefit
    from it greatly by creating a common base class for all our `ViewModel` classes
    to inherit from. To do this, follow these steps:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 是视图和模型之间的中介。通过为所有 `ViewModel` 类创建一个公共基类，我们可以从中受益匪浅。为此，请按照以下步骤操作：'
- en: Create a folder called `ViewModels` in the `DoToo` project.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DoToo` 项目中创建一个名为 `ViewModels` 的文件夹。
- en: Create a class called `ViewModel` in the `ViewModels` folder.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewModels` 文件夹中创建一个名为 `ViewModel` 的类。
- en: 'Add the following code:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE17]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The `ViewModel` class is a base class for all `ViewModel` objects. It is not
    meant to be instantiated on its own, so we mark it as `abstract`. It implements
    `INotifyPropertyChanged`, which is an interface defined in `System.ComponentModel`
    in the .NET base class libraries. This interface only defines one thing – the
    `PropertyChanged` event. Our `ViewModel` class must raise this event whenever
    we want the GUI to be aware of any changes to a property. This can be done manually
    by adding code to a setter in a property, as we did in the current implementation,
    or by using the **CommunityToolkit.Mvvm** library. We will talk about this in
    more detail in the next section.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: '`ViewModel` 类是所有 `ViewModel` 对象的基类。它不打算单独实例化，所以我们将其标记为 `abstract`。它实现了在 .NET
    基类库中定义的 `System.ComponentModel` 接口 `INotifyPropertyChanged`。该接口只定义了一件事——`PropertyChanged`
    事件。我们的 `ViewModel` 类必须在想要让 GUI 了解任何属性更改时引发此事件。这可以通过在属性的设置器中手动添加代码来实现，就像我们在当前实现中所做的那样，或者通过使用
    **CommunityToolkit.Mvvm** 库。我们将在下一节中详细介绍这一点。'
- en: We will also take a little shortcut here by adding an `INavigation` property
    to `ViewModel`. This will help us with navigation later on. This is also something
    that can (and should) be abstracted since we don’t want `ViewModel` to be dependent
    on .NET MAUI to be able to reuse the `ViewModel` classes on any platform.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还将在这里采取一个小捷径，通过向 `ViewModel` 添加一个 `INavigation` 属性。这将帮助我们进行后续的导航。这也是可以（并且应该）抽象化的东西，因为我们不希望
    `ViewModel` 依赖于 .NET MAUI，以便能够在任何平台上重用 `ViewModel` 类。
- en: Introducing the CommunityToolkit.Mvvm library’s ObservableObject and ObservableProperty
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 介绍CommunityToolkit.Mvvm库的ObservableObject和ObservableProperty
- en: 'The traditional way of implementing a `ViewModel` class is to inherit it from
    a base class (such as the `ViewModel` class that we defined previously) and then
    add code that might look as follows:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 实现ViewModel类传统的做法是从基类（例如我们之前定义的`ViewModel`类）继承，然后添加可能看起来如下所示的代码：
- en: '[PRE18]'
  id: totrans-205
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Each property that we want to add to a `ViewModel` class yields 13 lines of
    code. Not too bad, you might think. However, considering that a `ViewModel` class
    could potentially contain 10 to 20 properties, this rapidly turns into a lot of
    code. We can do better than this.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想要添加到`ViewModel`类的每个属性都会产生13行代码。你可能认为这还不错。然而，考虑到一个`ViewModel`类可能包含10到20个属性，这会迅速变成大量的代码。我们可以做得更好。
- en: 'In just a few simple steps, we can use the CommunityToolkit.Mvvm library to
    automatically inject almost all the code during the build process:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 只需几个简单的步骤，我们就可以使用CommunityToolkit.Mvvm库在构建过程中自动注入几乎所有代码：
- en: In the `DoToo` project, install the CommunityToolkit.Mvvm NuGet package.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`DoToo`项目中，安装CommunityToolkit.Mvvm NuGet包。
- en: 'Update the `ViewModel` class so that it looks like this:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新`ViewModel`类，使其看起来像这样：
- en: '[PRE19]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: We have changed the base class of our `ViewModel` class so that it has an `ObservableObject`
    attribute and added the `partial` modifier. This attribute will add the base implementation
    of `INotifyPropertyChanged` that was previously in our `ViewModel` base class
    automatically during the build process.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经更改了`ViewModel`类的基类，使其具有`ObservableObject`属性，并添加了`partial`修饰符。此属性将在构建过程中自动添加之前在`ViewModel`基类中存在的`INotifyPropertyChanged`的基实现。
- en: 'Once our base class has been modified, we can use the `ObservableProperty`
    attribute to automatically generate the property implementation. The result is
    that the test class we had previously is reduced to a single line of code per
    property. This makes the code base more readable because everything happens behind
    the scenes:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们的基类被修改，我们就可以使用`ObservableProperty`属性来自动生成属性实现。结果是，我们之前拥有的测试类每个属性都减少到一行代码。这使得代码库更易于阅读，因为所有操作都在幕后进行：
- en: '[PRE20]'
  id: totrans-213
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: There are a few things to note about the previous example. First, the class
    must be marked as `partial` for the `ObservableProperty` attribute to work, just
    like the `ObservableObject` attribute. Second, when using the `ObservableProperty`
    attribute, you place it on a private field, not a property. The CommunityToolkit.Mvvm
    library uses **Source Generators**, a feature added in .NET 5, to generate the
    actual property implementation.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 关于前面的示例，有几个需要注意的事项。首先，类必须被标记为`partial`，这样`ObservableProperty`属性才能正常工作，就像`ObservableObject`属性一样。其次，在使用`ObservableProperty`属性时，你应该将其放置在私有字段上，而不是属性上。CommunityToolkit.Mvvm库使用.NET
    5中添加的特性**Source Generators**来生成实际的属性实现。
- en: 'One of the great things about using Source Generators is that you can always
    view the generated source to see how things work. For example, to view the generated
    source for the `ViewModel` class, do the following:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 使用Source Generators的一个好处是，你可以始终查看生成的源代码来了解工作原理。例如，要查看`ViewModel`类的生成源代码，请执行以下操作：
- en: Open the `ViewModel.cs` file.
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ViewModel.cs`文件。
- en: Right-click the `ViewModel` type name.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击`ViewModel`类型名称。
- en: Select **Goto Implementation**.
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**转到实现**。
- en: 'Normally, this would do nothing, as you are in the implementation of `ViewModel`.
    However, since there is additional generated code, Visual Studio will show you
    a list of locations that contain implementations for `ViewModel`, similar to what’s
    shown here:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 通常情况下，这不会做任何事情，因为你正在`ViewModel`的实现中。然而，由于有额外的生成代码，Visual Studio会显示一个包含`ViewModel`实现位置列表，类似于这里所示：
- en: '![Figure 2.12 – Finding all implementations of ViewModel](img/Figure_2.12_B19214.jpg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![图2.12 – 查找ViewModel的所有实现](img/Figure_2.12_B19214.jpg)'
- en: Figure 2.12 – Finding all implementations of ViewModel
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.12 – 查找ViewModel的所有实现
- en: The first item in the list is what we added to the `ViewModel.cs` file, and
    the second item in the list is the generated code. By double-clicking the item,
    it will open the generated code in a new code window. In the *Creating TodoItemViewModel*
    section, you can follow the same steps to see what is generated for the property
    implementations.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 列表中的第一项是我们添加到`ViewModel.cs`文件中的内容，列表中的第二项是生成的代码。通过双击该项，它将在新的代码窗口中打开生成的代码。在*创建TodoItemViewModel*部分，你可以遵循相同的步骤来查看属性实现生成的代码。
- en: Now that we’ve seen how to implement properties using a sample `ViewModel`,
    it is time to create the concrete `ViewModel` classes.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经看到了如何使用示例 `ViewModel` 实现属性，现在是时候创建具体的 `ViewModel` 类了。
- en: Creating MainViewModel
  id: totrans-224
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 MainViewModel
- en: 'So far, we have mainly prepared to write the code that will make up the app
    itself. `MainViewModel` is the `ViewModel` class for the first view that is displayed
    to the user. It is responsible for providing data and logic to a list of to-do
    list items. We will create the bare-bones `ViewModel` classes and add code to
    them as we progress through this chapter:'
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们主要准备编写构成应用程序本身的代码。`MainViewModel` 是第一个显示给用户的视图的 `ViewModel` 类。它负责为待办事项列表项提供数据和逻辑。我们将创建基本的
    `ViewModel` 类，并在本章的进展中向它们添加代码：
- en: Create a class called `MainViewModel` in the `ViewModels` folder.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewModels` 文件夹中创建一个名为 `MainViewModel` 的类。
- en: 'Add the following template code and resolve the references:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下模板代码并解决引用：
- en: '[PRE21]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The structure of this class is something that we will reuse for all the `ViewModel`
    classes to come.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类的结构是我们将重用于所有即将到来的 `ViewModel` 类。
- en: 'Let’s summarize the important features we want the `ViewModel` class to have:'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们总结一下我们希望 `ViewModel` 类拥有的重要功能：
- en: We inherit from the `ViewModel` class to gain access to shared logic, such as
    the `INotifyPropertyChanged` interface and common navigation code.
  id: totrans-231
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过继承 `ViewModel` 类来访问共享逻辑，例如 `INotifyPropertyChanged` 接口和常见的导航代码。
- en: All dependencies to other classes, such as repositories and services, which
    are passed through the constructor of `ViewModel`. This is handled by the `Microsoft.Extensions.DependencyInjection`,
    which is the implementation of the dependency injection we are using. We will
    add support for automatic dependency injection in the *Wiring up dependency* *injection*
    section.
  id: totrans-232
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有对其他类的依赖，例如通过 `ViewModel` 构造函数传递的仓库和服务，都由 `Microsoft.Extensions.DependencyInjection`
    处理，这是我们所使用的依赖注入的实现。我们将在 *连接依赖注入* 部分添加对自动依赖注入的支持。
- en: We use an asynchronous call to `LoadDataAsync()` as an entry point to initialize
    the `ViewModel` class. Different MVVM libraries might do this in different ways,
    but the basic functionality is the same.
  id: totrans-233
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用异步调用 `LoadDataAsync()` 作为初始化 `ViewModel` 类的入口点。不同的 MVVM 库可能会以不同的方式做这件事，但基本功能是相同的。
- en: Creating TodoItemViewModel
  id: totrans-234
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 TodoItemViewModel
- en: '`TodoItemViewModel` is the `ViewModel` class that represents each item in the
    to-do list on `MainView`. It does not have an entire view of its own, although
    it could have. Instead, it is rendered by a template in `ListView`. We will get
    back to this when we create the controls for `MainView`.'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: '`TodoItemViewModel` 是代表 `MainView` 上待办事项列表中每个项目的 `ViewModel` 类。它没有自己的完整视图，尽管它可以有。相反，它通过
    `ListView` 中的模板进行渲染。我们将在创建 `MainView` 控件时回到这一点。'
- en: The important thing here is that this `ViewModel` object represents a single
    item, regardless of where we choose to render it.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 这里重要的是，这个 `ViewModel` 对象代表一个单独的项目，无论我们选择在哪里渲染它。
- en: 'Let’s create the `TodoItemViewModel` class:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建 `TodoItemViewModel` 类：
- en: Create a class called `TodoItemViewModel` in the `ViewModels` folder.
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewModels` 文件夹中创建一个名为 `TodoItemViewModel` 的类。
- en: 'Update the class so that it matches the following code:'
  id: totrans-239
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新类，使其与以下代码匹配：
- en: '[PRE22]'
  id: totrans-240
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As with any other `ViewModel` class, we inherit the `TodoItemViewModel` class
    from `ViewModel`. We conform to the pattern of injecting all the dependencies
    into the constructor. In this case, we pass an instance of the `TodoItem` class
    to the constructor that the `ViewModel` object will use to expose the view.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 与任何其他 `ViewModel` 类一样，我们从 `ViewModel` 继承 `TodoItemViewModel` 类。我们遵循将所有依赖项注入构造函数的模式。在这种情况下，我们向构造函数传递一个
    `TodoItem` 类的实例，该实例将被 `ViewModel` 对象用于公开视图。
- en: The `ItemStatusChanged` event handler will be used later when we want to signal
    to the view that the state of the `TodoItem` class has changed. The `Item` property
    allows us to access the item that we passed in.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们想要向视图发出信号，表示 `TodoItem` 类的状态已更改时，将使用 `ItemStatusChanged` 事件处理程序。`Item` 属性允许我们访问传递的项目。
- en: The `StatusText` property is used to make the status of the to-do item human-readable
    in the view.
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: '`StatusText` 属性用于在视图中使待办事项的状态对人类可读。'
- en: Creating the ItemViewModel class
  id: totrans-244
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 ItemViewModel 类
- en: '`ItemViewModel` represents the to-do list item in a view that can be used to
    create new items and edit existing ones:'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemViewModel` 代表一个视图中的待办事项列表项，可以用来创建新项和编辑现有项：'
- en: In the `ViewModels` folder, create a class called `ItemViewModel`.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ViewModels` 文件夹中创建一个名为 `ItemViewModel` 的类。
- en: 'Add the following code:'
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE23]'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The pattern is the same as for the previous two `ViewModel` classes:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式与之前的两个 `ViewModel` 类相同：
- en: We use dependency injection to pass the `TodoItemRepository` class to the `ViewModel`
    object
  id: totrans-250
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们使用依赖注入将 `TodoItemRepository` 类传递给 `ViewModel` 对象。
- en: We use inheritance from the `ViewModel` base class to add the common features
    defined by the base class
  id: totrans-251
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们通过从 `ViewModel` 基类继承来添加由基类定义的常见功能
- en: Creating the MainView view
  id: totrans-252
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 `MainView` 视图
- en: 'Now that we are done with the `ViewModel` classes, let’s create the skeleton
    code and the XAML required for the views. The template created a file named `MainPage.xml`.
    In MVVM, the convention is to use a `-View` suffix instead. We will also want
    to place all our views together in a subfolder, as we did with the `ViewModel`
    classes. Let’s deal with the `MainPage.xml` file first, which is the view that
    will be loaded first:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了 `ViewModel` 类，让我们创建视图所需的骨架代码和 XAML。模板创建了一个名为 `MainPage.xml` 的文件。在
    MVVM 中，惯例是使用 `-View` 后缀。我们还将希望将所有视图一起放在一个子文件夹中，就像我们对 `ViewModel` 类所做的那样。让我们首先处理
    `MainPage.xml` 文件，这是将被首先加载的视图：
- en: Delete the `MainPage.xml` file from the root of the project.
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从项目的根目录删除 `MainPage.xml` 文件。
- en: Create a folder called `Views` in the `DoToo` project.
  id: totrans-255
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DoToo` 项目中创建一个名为 `Views` 的文件夹。
- en: Right-click on the `Views` folder, select **Add**, and then click **New Item...**.
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击 `Views` 文件夹，选择 **添加**，然后点击 **新建项...**。
- en: Select **.NET MAUI** under the **C# Items** node on the left.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在左侧的 **C# 项** 节点下选择 **.NET MAUI**。
- en: Select `MainView`.
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择 `MainView`。
- en: 'Click **Add** to create the page:'
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击 **添加** 创建页面：
- en: '![Figure 2.13 – Adding a new XAML file](img/Figure_2.13_B19214.jpg)'
  id: totrans-260
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.13 – 添加新的 XAML 文件](img/Figure_2.13_B19214.jpg)'
- en: Figure 2.13 – Adding a new XAML file
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.13 – 添加新的 XAML 文件
- en: 'Let’s add some content to the newly created view:'
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在新创建的视图中添加一些内容：
- en: Open `MainView.xaml`.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainView.xaml`。
- en: 'Remove all the template code below the `ContentPage` root node and add the
    XAML code highlighted in the following code:'
  id: totrans-264
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `ContentPage` 根节点下方删除所有模板代码，并添加以下代码中突出显示的 XAML 代码：
- en: '[PRE24]'
  id: totrans-265
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: To be able to access custom converters, we need to add a reference to a local
    namespace. The `line defines this namespace for us. We will not use it directly
    in this case, but it’s a good idea to have a local namespace defined. If we create
    custom controls, we can access them by writing something such as **<**`**`local:MyControl
    />`.**
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够访问自定义转换器，我们需要添加对本地命名空间的引用。`line` 定义了这个命名空间。在这种情况下，我们不会直接使用它，但定义一个本地命名空间是一个好主意。如果我们创建自定义控件，我们可以通过编写类似
    **`<local:MyControl />`** 的方式来访问它们。**
- en: '**The `Title` property on the `ContentPage` page gives the page a title. Depending
    on the platform we are running on, the title is displayed differently. If we use
    a standard navigation bar, it will be displayed at the top, for example, in both
    iOS and Android. A page should always have a title.'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: '**`ContentPage` 页面上的 `Title` 属性为页面提供了标题。根据我们运行的平台，标题的显示方式不同。如果我们使用标准导航栏，它将在顶部显示，例如，在
    iOS 和 Android 上。页面应该始终有一个标题**。'
- en: The `ContentPage.ToolbarItems` node defines a toolbar item for adding new to-do
    items. It will also be rendered differently based on the platform, but it always
    follows the platform-specific UI guidelines.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: '`ContentPage.ToolbarItems` 节点定义了一个用于添加新待办事项的工具栏项。它根据平台的不同也会以不同的方式渲染，但始终遵循平台特定的
    UI 指南。'
- en: A page in .NET MAUI (and in an XML document, in general) can only have one root
    node. The root node in a .NET MAUI page populates the `Content` property of the
    page itself. Since we want our `MainView` view to contain a list of items and
    a button at the top to toggle a filter (to switch between all items and only active
    items), we need to add a `Layout` control to position them on the page. `Grid`
    is a control that allows you to split up the available space based on rows and
    columns.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 中的页面（以及在 XML 文档中通常情况下）只能有一个根节点。.NET MAUI 页面的根节点填充了页面本身的 `Content`
    属性。由于我们希望 `MainView` 视图包含一个项目列表和顶部的一个按钮来切换过滤器（在所有项目和仅活动项目之间切换），我们需要添加一个 `Layout`
    控件来在页面上定位它们。`Grid` 是一个允许您根据行和列分割可用空间的控件。
- en: For our `MainView` view, we want to add two rows. The first row is a space calculated
    by the height of the button (`Height="auto"`) and the second row takes up all
    the remaining space for `ListView` (`Height="*"`). Elements such as `ListView`
    are positioned in the grid using the `Grid.Row` and `Grid.Column` attributes.
    Both properties default to `0` if they are not specified, just like the button.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的 `MainView` 视图，我们想要添加两行。第一行是按钮高度计算出的空间（`Height="auto"`），第二行占据剩余的所有空间用于
    `ListView`（`Height="*"`）。像 `ListView` 这样的元素使用 `Grid.Row` 和 `Grid.Column` 属性在网格中定位。如果未指定这两个属性，它们默认为
    `0`，就像按钮一样。
- en: '`ListView` is a control that presents items in a list, which is coincidently
    exactly what our app will do. It’s worth noting that .NET MAUI does have a control
    called `CollectionView`, which can handle displaying collections of items better
    than `ListView`. Subsequent chapters will use this control, but we wanted to introduce
    you to the good old `ListView` control as well.'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView` 是一个以列表形式展示项的控件，这恰好是我们应用将要做的。值得注意的是，.NET MAUI 确实有一个名为 `CollectionView`
    的控件，它比 `ListView` 更好地处理显示项集合。后续章节将使用此控件，但我们还想介绍这个古老的 `ListView` 控件。'
- en: Tip
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are interested in how `Grid` works, you can search for more information
    about .NET MAUI grids on the internet or check out the official documentation
    at [https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/grid](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/grid).
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对 `Grid` 的工作原理感兴趣，你可以在互联网上搜索有关 .NET MAUI 网格的更多信息，或者查看官方文档[https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/grid](https://learn.microsoft.com/en-us/dotnet/maui/user-interface/layouts/grid)。
- en: 'We also need to wire up `ViewModel` to the view. This can be done by passing
    the `ViewModel` class in the constructor of the view:'
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要将 `ViewModel` 与视图连接起来。这可以通过在视图的构造函数中传递 `ViewModel` 类来实现：
- en: Open the code-behind file of `MainView` by expanding the `MainView.xaml` file
    in `MainView.xaml.cs`.
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过展开 `MainView.xaml` 文件在 `MainView.xaml.cs` 中打开 `MainView` 的代码隐藏文件。
- en: Add a `using DoToo.ViewModels` statement to the top of the file, adjacent to
    the existing `using` statements.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部添加 `using DoToo.ViewModels` 语句，紧邻现有的 `using` 语句。
- en: 'Modify the constructor of the class so that it looks as follows by adding the
    highlighted code:'
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类的构造函数，使其看起来如下，通过添加高亮代码：
- en: '[PRE25]'
  id: totrans-278
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We follow the same pattern as we did with the `ViewModel` classes by passing
    any dependencies through the constructor. A view is always dependent on a `ViewModel`
    class. To simplify the project, we also assign the `Navigation` property of the
    page directly to the `Navigation` property defined in the `ViewModel` base class.
    In a larger project, we might want to abstract this property as well to make sure
    that we separate the `ViewModel` classes from .NET MAUI. For the sake of this
    app, however, it is OK to reference it directly.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过构造函数传递任何依赖项，遵循与 `ViewModel` 类相同的模式。视图始终依赖于 `ViewModel` 类。为了简化项目，我们还直接将页面的
    `Navigation` 属性分配给在 `ViewModel` 基类中定义的 `Navigation` 属性。在一个更大的项目中，我们可能想要将此属性抽象出来，以确保将
    `ViewModel` 类与 .NET MAUI 分离。然而，对于这个应用来说，直接引用它是可以的。
- en: Lastly, we assign `ViewModel` to the `BindingContext` class of the page. This
    tells the .NET MAUI binding engine to use our `ViewModel` object for the bindings
    that we will create later.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将 `ViewModel` 分配给页面的 `BindingContext` 类。这告诉 .NET MAUI 绑定引擎使用我们稍后创建的绑定来使用我们的
    `ViewModel` 对象。
- en: At this point, since we have removed `MainPage`, the project will no longer
    run. We will fix this in the *Making the app run* section later.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一点上，由于我们已移除 `MainPage`，项目将无法运行。我们将在后面的 *使应用运行* 部分修复这个问题。
- en: Creating the ItemView view
  id: totrans-282
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建 ItemView 视图
- en: 'The second view we will add is `ItemView`. We will use this to add and edit
    the to-do list items:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要添加的第二个视图是 `ItemView`。我们将使用它来添加和编辑待办事项列表项：
- en: Create a new content page (in the same way that we created the `MainView` view)
    and name it `ItemView`.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的内容页面（与创建 `MainView` 视图的方式相同），并将其命名为 `ItemView`。
- en: 'Edit the XAML file so that it appears as in the following code. The changes
    are highlighted:'
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑 XAML 文件，使其看起来如下代码所示。更改已高亮显示：
- en: '[PRE26]'
  id: totrans-286
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As with `MainView`, we need a title. We will give it a default title of `New
    todo item` for now, but we will change this to `Edit todo item` when we reuse
    this view for editing later on. The user must be able to save a new or edited
    item, so we have added a toolbar `Save` button. The content of the page uses `StackLayout`
    to structure the controls. `StackLayout` adds an element vertically (the default
    option) or horizontally based on the space it calculates that the element takes
    up. This is a CPU-intensive process, so we should only use it on small portions
    of our layout. In `StackLayout`, we add a `Label` control, which is a line of
    text over the `Entry` control that comes underneath it. The `Entry` control is
    a text input control that contains the name of the to-do list item. Then, we have
    a section for `DatePicker`, where the user can select a due date for the to-do
    list item. The final control is a `Switch` control, which renders a toggle button
    to control when an item is complete, as well as a heading next to it. Since we
    want these to be displayed next to each other horizontally, we use a horizontal
    `StackLayout` control to do this.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `MainView` 一样，我们需要一个标题。现在我们将给它一个默认标题 `New todo item`，但稍后当我们重用此视图进行编辑时，我们将将其更改为
    `Edit todo item`。用户必须能够保存新的或编辑的项目，因此我们添加了一个工具栏 `Save` 按钮。页面内容使用 `StackLayout`
    来结构化控件。`StackLayout` 根据它计算出的元素所占用的空间垂直（默认选项）或水平地添加元素。这是一个 CPU 密集型过程，因此我们只应在布局的小部分上使用它。在
    `StackLayout` 中，我们添加了一个 `Label` 控件，它是一个在下面的 `Entry` 控件上方的文本行。`Entry` 控件是一个文本输入控件，包含待办事项列表项的名称。然后，我们有一个用于
    `DatePicker` 的部分，用户可以为此待办事项列表项选择一个截止日期。最后一个控件是一个 `Switch` 控件，它渲染一个切换按钮来控制项目是否完成，以及旁边的标题。由于我们希望这些控件水平显示，我们使用一个水平的
    `StackLayout` 控件来完成这个操作。
- en: 'The last step for the views is to wire up the `ItemViewModel` model to `ItemView`:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 视图的最后一步是将 `ItemViewModel` 模型连接到 `ItemView`：
- en: Open the code-behind file of `ItemView` by expanding the `ItemView.xaml` file
    in **Solution Explorer**.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在 **解决方案资源管理器** 中展开 `ItemView.xaml` 文件来打开 `ItemView` 的代码隐藏文件。
- en: Add a `using DoToo.ViewModels` statement to the top of the file, adjacent to
    the existing `using` statements.
  id: totrans-290
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在文件顶部添加一个 `using DoToo.ViewModels` 语句，紧邻现有的 `using` 语句。
- en: 'Modify the constructor of the class so that it looks as follows. Add the code
    that is marked in bold:'
  id: totrans-291
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改类的构造函数，使其看起来如下。添加以下加粗的代码：
- en: '[PRE27]'
  id: totrans-292
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This code is identical to the code that we added for `MainView`, except for
    the type of `ViewModel` class.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与我们为 `MainView` 添加的代码相同，只是 `ViewModel` 类的类型不同。
- en: Wiring up dependency injection
  id: totrans-294
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接依赖注入
- en: 'Earlier, we discussed the dependency injection pattern, which states that all
    dependencies, such as the repositories and view models, must be passed through
    the constructor of the class. This requirement has several benefits:'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，我们讨论了依赖注入模式，该模式指出所有依赖项，如存储库和 ViewModel，都必须通过类的构造函数传递。这个要求有几个好处：
- en: It increases the readability of the code since we can quickly determine all
    the external dependencies
  id: totrans-296
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它增加了代码的可读性，因为我们可以快速确定所有外部依赖项
- en: It makes dependency injection possible
  id: totrans-297
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使得依赖注入成为可能
- en: It makes unit testing possible by mocking classes
  id: totrans-298
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它通过模拟类使得单元测试成为可能
- en: We can control the lifetime of an object by specifying whether it should be
    a singleton or a new instance for each resolution
  id: totrans-299
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们可以通过指定对象应该是单例还是每次解析时的新实例来控制对象的生命周期
- en: Dependency injection is a pattern that lets us determine, at runtime, which
    instance of an object should be passed to a constructor when an object is created.
    We do this by defining a container where we register all the types of a class.
    We let the framework that we are using resolve any dependencies between them.
    Let’s say that we ask the container for a `MainView` class. The container takes
    care of resolving `MainViewModel` and any dependencies that the class has.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一种模式，它允许我们在运行时确定创建对象时应该传递给构造函数的对象的哪个实例。我们通过定义一个容器来实现这一点，我们在其中注册了类的所有类型。我们让使用的框架解决它们之间的任何依赖关系。假设我们要求容器提供一个
    `MainView` 类。容器负责解决 `MainViewModel` 以及该类所拥有的任何依赖关系。
- en: .NET MAUI uses the `Microsoft.Extensions.DependencyInjection` NuGet library
    internally and it is exposed for us to use in our applications. The first step
    is to register the classes we want to participate in dependency injection.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI 在内部使用 `Microsoft.Extensions.DependencyInjection` NuGet 库，并且它被暴露给我们用于我们的应用程序。第一步是注册我们想要参与依赖注入的类。
- en: Registering View, ViewModels, and Services
  id: totrans-302
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册视图、ViewModel 和服务
- en: For our classes to be available through dependency injection, they need to be
    registered with the dependency injection service. .NET MAUI exposes the dependency
    injection service using the `Services` property of the `MauiAppBuilder` class.
    The `Services` property will return an `IServiceCollection` object, also referred
    to as the container. `IServiceCollection` has two methods we are interested in,
    `AddSingleton`, and `AddTransient`. The “Transient” and “Singleton” in the method
    names refer to the lifetime of the objects. Transient objects are created every
    time they are requested from the container. Singleton objects are created only
    once, and that one instance is returned every time the class is requested from
    the container.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的类可以通过依赖注入使用，它们需要注册到依赖注入服务中。.NET MAUI 通过 `MauiAppBuilder` 类的 `Services`
    属性公开依赖注入服务。`Services` 属性将返回一个 `IServiceCollection` 对象，也称为容器。`IServiceCollection`
    有两个我们感兴趣的方法，`AddSingleton` 和 `AddTransient`。方法名称中的“Transient”和“Singleton”指的是对象的生存期。Transient
    对象每次从容器请求时都会创建。Singleton 对象只创建一次，并且每次从容器请求该类时都会返回那个实例。
- en: 'When registering classes with the container, it is recommended to use extension
    methods to group the types. For this app, there are three groups: `View`, `ViewModels`,
    and `Services`. The extension methods will take a single parameter and return
    a single value, the `MauiAppBuilder` instance. This is how the Builder pattern
    is implemented and allows us to chain the methods on the builder defined in the
    `CreateMauiApp` method.'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用容器注册类时，建议使用扩展方法来分组类型。对于此应用程序，有三个组：`View`、`ViewModels` 和 `Services`。扩展方法将接受一个参数并返回一个值，即
    `MauiAppBuilder` 实例。这就是实现 Builder 模式的方式，并允许我们在 `CreateMauiApp` 方法中定义的构建器上链式调用方法。
- en: 'To implement the methods, follow these steps:'
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现这些方法，请按照以下步骤操作：
- en: Open the `MauiProgram.cs` file.
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MauiProgram.cs` 文件。
- en: 'Make the following changes to the `MauiProgram` class. The changes are highlighted
    in bold:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对 `MauiProgram` 类进行以下更改。更改内容已加粗：
- en: '[PRE28]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Normally, registering a type is done by using the type name as the generic argument
    to the registration method, as in `mauiAppBuilder.Services.AddTransient<Views.MainView>();`.
    But that doesn’t work if you need to resolve an interface to an implementation,
    like what is happening in the `RegisterServices` method. There, the registration
    method doesn’t use the generic argument; instead, it passes in the type to register
    as the first argument, and the second argument is the type of the instance to
    return.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，通过将类型名称用作注册方法的泛型参数来注册类型，例如 `mauiAppBuilder.Services.AddTransient<Views.MainView>();`。但如果需要将接口解析为实现，如
    `RegisterServices` 方法中发生的情况，则这不起作用。在那里，注册方法不使用泛型参数；相反，它将注册的类型作为第一个参数传递，第二个参数是要返回的实例的类型。
- en: Info
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: To learn more about how `Microsoft.Extensions.DependencyInjection` works, visit
    [https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection)
    in your favorite browser.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于 `Microsoft.Extensions.DependencyInjection` 的工作原理，请访问您最喜欢的浏览器中的 [https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection)。
- en: Now that dependency injection is wired up, we can get the project running again.
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 现在依赖注入已经连接好，我们可以再次运行项目。
- en: Making the app run
  id: totrans-313
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使应用程序运行
- en: 'There are just a few more changes we need to make to enable the app to run:'
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要进行一些更改才能使应用程序运行：
- en: Open the `App.xaml.cs` file by expanding the `App.xaml` node in the `DoToo`
    project.
  id: totrans-315
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过展开 `DoToo` 项目中的 `App.xaml` 节点来打开 `App.xaml.cs` 文件。
- en: 'Modify the following lines in bold:'
  id: totrans-316
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下行需要加粗：
- en: '[PRE29]'
  id: totrans-317
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`AppShell.Xaml` and `AppShell.xaml.cs` are no longer used, so they can be deleted
    from the project.'
  id: totrans-318
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AppShell.Xaml` 和 `AppShell.xaml.cs` 已不再使用，因此可以从项目中删除。'
- en: When .NET MAUI initializes the `App` class via the builder, it does so by using
    the dependency injection container, so any arguments you add to the `App` constructor
    are resolved from the container as well, and their dependencies too. In this case,
    we are importing the `MainView` class (and all its dependencies, including `MainViewModel`
    and `TodoItemRepository`) and wrapping it in `NavigationPage`. `NavigationPage`
    is a page defined in .NET MAUI that adds a navigation bar and enables the user
    to navigate to other views.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 当.NET MAUI通过构建器初始化`App`类时，它是通过使用依赖注入容器来完成的，所以你添加到`App`构造函数中的任何参数都会从容器中解析出来，以及它们的依赖项。在这种情况下，我们正在导入`MainView`类（及其所有依赖项，包括`MainViewModel`和`TodoItemRepository`），并将其包装在`NavigationPage`中。`NavigationPage`是在.NET
    MAUI中定义的一个页面，它添加了一个导航栏，并使用户能够导航到其他视图。
- en: Information
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: .NET MAUI includes `Shell`, and we have a whole chapter about it in this book.
    However, to become a good .NET MAUI developer, you need to know the basics, and
    the basics of navigating in .NET MAUI uses the good old `NavigationPage` control.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI包括`Shell`，在这本书中我们有一整章关于它的内容。然而，要成为一名优秀的.NET MAUI开发者，你需要了解基础知识，而.NET
    MAUI中导航的基础知识使用的是古老的`NavigationPage`控件。
- en: 'That’s it! Now, your project should start. Depending on the platform you are
    using, it might look as follows:'
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 那就这样！现在，你的项目应该开始了。根据你使用的平台，它可能看起来如下所示：
- en: '![Figure 2.14 – The DoToo application in the Windows subsystem for Android](img/Figure_2.14_B19214.jpg)'
  id: totrans-323
  prefs: []
  type: TYPE_IMG
  zh: '![图2.14 – DoToo应用程序在Windows子系统中的Android](img/Figure_2.14_B19214.jpg)'
- en: Figure 2.14 – The DoToo application in the Windows subsystem for Android
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.14 – DoToo应用程序在Windows子系统中的Android
- en: Now that we have the app running with a basic UI, let’s add some functionality,
    starting with displaying data.
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经运行了一个具有基本UI的应用程序，让我们添加一些功能，从显示数据开始。
- en: Tip
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: If you are debugging the app using the Windows target framework and it isn’t
    working, and you aren’t getting any error messages, try using the Android target
    framework. Sometimes, you can get better error reporting from a different platform.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用Windows目标框架调试应用程序，但它不起作用，并且你没有收到任何错误消息，尝试使用Android目标框架。有时，你可以从不同的平台获得更好的错误报告。
- en: Adding data bindings
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 添加数据绑定
- en: 'Data binding is the heart and soul of MVVM. This is the way that the views
    and ViewModel communicate with each other. In .NET MAUI, we need two things to
    make data binding happen:'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定是MVVM的核心和灵魂。这是视图和ViewModel之间相互通信的方式。在.NET MAUI中，我们需要两样东西来使数据绑定发生：
- en: We need an object to implement `INotifyPropertyChanged`.
  id: totrans-330
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要一个对象来实现`INotifyPropertyChanged`。
- en: We need to set the `BindingContext` class of the page to that object. We already
    do this on both `ItemView` and `MainView`.
  id: totrans-331
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要将页面的`BindingContext`类设置为该对象。我们已经在`ItemView`和`MainView`上做了这件事。
- en: 'A useful feature of data binding is that it allows us to use two-way communication.
    For example, when data binding text to an `Entry` control, the property on the
    data-bound object is updated directly. Consider the following XAML:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 数据绑定的一个有用特性是它允许我们使用双向通信。例如，当将数据绑定到`Entry`控件上的文本时，数据绑定对象上的属性会直接更新。考虑以下XAML：
- en: '[PRE30]'
  id: totrans-333
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: To make this work, we need a property named `Title` on the string object. We
    have to look at the documentation, define an object, and let **IntelliSense**
    provide us with a hint to find out what type our property should be.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 要使这起作用，我们需要在字符串对象上有一个名为`Title`的属性。我们必须查看文档，定义一个对象，并让**IntelliSense**提供提示，以找出我们的属性应该是什么类型。
- en: Controls that perform an action, such as `Button`, usually expose a property
    called `Command`. This property is of the `ICommand` type, and we can either return
    `Microsoft.Maui.Controls.Command` or an implementation of our own. The `Command`
    property is explained in the next section, where we will use it to navigate to
    `ItemView`.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 执行动作的控件，如`Button`，通常公开一个名为`Command`的属性。这个属性是`ICommand`类型，我们可以返回`Microsoft.Maui.Controls.Command`或我们自己的实现。`Command`属性将在下一节中解释，我们将使用它来导航到`ItemView`。
- en: In the next few sections, we will be adding the data binding and command implementations
    to our views and ViewModels, starting with navigating from `MainView` to `ItemView`.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的几节中，我们将向我们的视图和ViewModel添加数据绑定和命令实现，从从`MainView`导航到`ItemView`开始。
- en: Information
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: It’s also worth noting that .NET MAUI supports one-way binding in addition to
    two-way data binding, which comes in handy when you want to display data in a
    view but not allow it to update the ViewModel. From a performance perspective,
    it’s a good idea to mark those bindings as one-way bindings.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，.NET MAUI 除了双向数据绑定外，还支持单向绑定，这在你想在视图中显示数据但不允许它更新 ViewModel 时非常有用。从性能的角度来看，将那些绑定标记为单向绑定是一个好主意。
- en: Navigating from MainView to ItemView to add a new item
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 从 MainView 导航到 ItemView 添加新项目
- en: We have an `Add` toolbar button in `MainView`. When the user taps this button,
    we want it to take them to `ItemView`. The MVVM way to do this is to define a
    command and then bind that command to the button.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainView` 中我们有一个 `Add` 工具栏按钮。当用户点击此按钮时，我们希望它将他们带到 `ItemView`。按照 MVVM 的方式来做这件事，就是定义一个命令，然后将该命令绑定到按钮上。
- en: 'In .NET MAUI, to navigate to a view, you need a reference to an instance of
    the destination. In this case, that would be `ItemView`. Since all our views have
    been registered with the dependency injection container, we will need a reference
    to the container to request a new instance of the view when we are ready to navigate.
    We will use constructor injection to have the container provide us with its instance,
    like this:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中，要导航到一个视图，你需要一个指向目标实例的引用。在这种情况下，那就是 `ItemView`。由于我们所有的视图都已经注册到依赖注入容器中，当我们准备导航时，我们需要一个指向容器的引用来请求视图的新实例。我们将使用构造函数注入来让容器提供其实例，如下所示：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-342
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewModels/MainViewModel.cs`。
- en: Add a `using` statement for `DoToo.Views`.
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为 `DoToo.Views` 添加一个 `using` 语句。
- en: 'Add the following field to the class:'
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加以下字段：
- en: '[PRE31]'
  id: totrans-345
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Modify the constructor as follows. The changes are highlighted:'
  id: totrans-346
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按照以下方式修改构造函数。变更部分已高亮：
- en: '[PRE32]'
  id: totrans-347
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: This will capture the instance of `ItemView` that was created by the dependency
    injection container in a class field. Now, let’s look at the command implementation.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 这将捕获由依赖注入容器创建的 `ItemView` 实例，并将其存储在类字段中。现在，让我们看看命令的实现。
- en: All commands should be exposed as a generic `ICommand` type. This abstracts
    the actual command implementation, which is good general practice to follow. The
    command must be a property; in our case, we are creating a new `Command` object
    that we assign to this property. The property is read-only, which is usually fine
    for a `Command` object. The action of the command (the code that we want to run
    when the command is executed) is passed to the constructor of the `Command` object.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 所有命令都应该以泛型 `ICommand` 类型公开。这抽象了实际的命令实现，这是遵循良好通用实践的好方法。命令必须是一个属性；在我们的例子中，我们正在创建一个新的
    `Command` 对象并将其分配给这个属性。这个属性是只读的，对于 `Command` 对象来说通常是可以接受的。命令的动作（当命令执行时我们想要运行的代码）被传递给
    `Command` 对象的构造函数。
- en: 'Following those requirements, you might end up writing something like the following:'
  id: totrans-350
  prefs: []
  type: TYPE_NORMAL
  zh: 按照那些要求，你可能会写出以下内容：
- en: '[PRE33]'
  id: totrans-351
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: There is a lot of boilerplate code in that implementation that you would have
    to repeat for each command. This boilerplate code can get in the way of what the
    command is doing. Like how we were able to eliminate boilerplate code with properties,
    we can do the same with `ICommand`, but instead, we can use the `RelayCommand`
    attribute. The `RelayCommand` attribute uses a source generator to wrap a method
    in a new `Command` instance and expose it through a property. The property name
    that’s generated is the method name with “Command” appended to it.
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个实现中有很多样板代码，你不得不为每个命令重复这些代码。这些样板代码可能会妨碍命令的实际操作。就像我们能够通过属性消除样板代码一样，我们也可以用 `ICommand`
    来做同样的事情，但在这里，我们可以使用 `RelayCommand` 属性。`RelayCommand` 属性使用源生成器将方法包装在一个新的 `Command`
    实例中，并通过属性暴露出来。生成的属性名是方法名加上“Command”。
- en: 'Now, we can add the `Command` object’s implementation:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以添加 `Command` 对象的实现：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewModels/MainViewModel.cs`。
- en: 'Add the following method to the class:'
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向类中添加以下方法：
- en: '[PRE34]'
  id: totrans-356
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Add `using CommunityToolkit.Mvvm.Input;` to the `usings` section of the file.
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `using CommunityToolkit.Mvvm.Input;` 添加到文件的 `usings` 部分。
- en: 'Update the class definition to allow the Source Generators to do their thing:'
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新类定义以允许源生成器执行其操作：
- en: '[PRE35]'
  id: totrans-359
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The action of the command is simply to use the `Navigation` service to push
    the `itemView` instance onto the stack for us.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 命令的动作仅仅是使用 `Navigation` 服务将 `itemView` 实例推入堆栈。
- en: 'After that, we just need to wire up the `AddItemAsync` command from `ViewModel`
    to the `Add` button in the view:'
  id: totrans-361
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，我们只需要将 `ViewModel` 中的 `AddItemAsync` 命令连接到视图中的 `Add` 按钮上：
- en: Open `Views/MainView.xaml`.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Views/MainView.xaml`。
- en: 'Update the `ContentPage` element:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 更新 `ContentPage` 元素：
- en: '[PRE36]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Add the `Command` attribute to `ToolbarItem`:'
  id: totrans-365
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向 `ToolbarItem` 添加 `Command` 属性：
- en: '[PRE37]'
  id: totrans-366
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Run the app and tap the `Add` button to navigate to the new `ItemView` view.
    Notice that the back button appears automatically.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
  zh: 运行应用并点击 `Add` 按钮导航到新的 `ItemView` 视图。注意，后退按钮会自动出现。
- en: Adding new items to the list
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 向列表添加新项目
- en: 'Now that we have finished adding navigation to a new item, let’s add the code
    to create a new item and save it to the database:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经完成了向新项目添加导航的添加，让我们添加创建新项目并将其保存到数据库的代码：
- en: Open `ViewModels/ItemViewModel.cs`.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewModels/ItemViewModel.cs`。
- en: 'Add the following code in bold:'
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下粗体标记的代码：
- en: '[PRE38]'
  id: totrans-372
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: The `Item` property holds a reference to the current item that we want to add
    or edit. A new item is created in the constructor and when we want to edit an
    item, we can simply assign our own item to this property. The new item is not
    added to the database unless we execute the `Save` command defined at the end.
    Once the item has been added or updated, we remove the view from the navigation
    stack and return to `MainView` again.
  id: totrans-373
  prefs: []
  type: TYPE_NORMAL
  zh: '`Item` 属性持有我们想要添加或编辑的当前项的引用。在构造函数中创建一个新项，当我们想要编辑一个项时，我们可以简单地将自己的项分配给这个属性。除非我们执行定义在末尾的
    `Save` 命令，否则新项不会被添加到数据库中。一旦项被添加或更新，我们就从导航堆栈中移除视图并返回到 `MainView`。 '
- en: Information
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 信息
- en: Since the navigation keeps pages in a stack, the framework declares methods
    that reflect operations that you can perform on a stack. The operation of removing
    the topmost item in a stack is known as *popping the stack*, so instead of `RemoveAsync()`,
    we have `PopAsync()`. To add a page to the navigation stack, we push it, so the
    method is called `PushAsync()`.
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: 由于导航将页面保存在一个堆栈中，框架声明了反映您可以在堆栈上执行的操作的方法。从堆栈中移除最顶层项的操作称为 *弹出堆栈*，因此我们使用 `PopAsync()`
    而不是 `RemoveAsync()`。要将页面添加到导航堆栈中，我们将其推入，所以该方法称为 `PushAsync()`。
- en: 'Now that we have extended `ItemViewModel` with the necessary commands and properties,
    it’s time to data-bind them in the XAML:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过必要的命令和属性扩展了 `ItemViewModel`，是时候在 XAML 中将它们数据绑定了：
- en: Open `Views/ItemView.xaml`.
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Views/ItemView.xaml`。
- en: 'Add the code marked in bold:'
  id: totrans-378
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下粗体标记的代码：
- en: '[PRE39]'
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: The binding to the `ToolbarItems` command attribute triggers the `SaveAsync`
    command exposed by `ItemViewModel` when a user taps the `Save` link. It’s worth
    noting again that any attribute called `Command` indicates that an action will
    take place and we must bind it to an instance of an object implementing the `ICommand`
    interface.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `ToolbarItems` 命令属性绑定触发 `ItemViewModel` 暴露的 `SaveAsync` 命令，当用户点击 `Save` 链接时。再次值得注意的是，任何名为
    `Command` 的属性都表示将发生动作，并且我们必须将其绑定到实现 `ICommand` 接口的对象的实例。
- en: The `Entry` control that represents the title is data-bound to the `Item.Title`
    property of `ItemViewModel`, and the `Datepicker` and `Switch` controls bind similarly
    to their respective properties.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 代表标题的 `Entry` 控件绑定到 `ItemViewModel` 的 `Item.Title` 属性，`Datepicker` 和 `Switch`
    控件以类似方式绑定到它们各自的属性。
- en: We could have exposed `Title`, `Due`, and `Complete` as properties directly
    on `ItemViewModel`, but instead, we chose to reuse the already-existing `TodoItem`
    object as a reference. This is fine, so long as the properties of the `TodoItem`
    object implement the `INotifyPropertyChange` interface.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以将 `Title`、`Due` 和 `Complete` 直接作为 `ItemViewModel` 的属性暴露，但相反，我们选择重用已经存在的
    `TodoItem` 对象作为引用。这是可以的，只要 `TodoItem` 对象的属性实现了 `INotifyPropertyChange` 接口。
- en: Binding ListView in MainView
  id: totrans-383
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在 `MainView` 中绑定 ListView
- en: 'A to-do list is not much use without a list of items. Let’s extend `MainViewModel`
    with a list of items:'
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 没有项目列表的待办事项列表没有什么用处。让我们通过项目列表扩展 `MainViewModel`：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewModels/MainViewModel.cs`。
- en: Add `using System.Collections.ObjectModel` in the `using` section of the class.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在类的 `using` 部分添加 `using System.Collections.ObjectModel`。
- en: 'Add a property for the to-do list items:'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为待办事项列表添加一个属性：
- en: '[PRE40]'
  id: totrans-388
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '`ObservableCollection` is like an ordinary collection, but it has a useful
    superpower: it can notify listeners about changes in the list, such as when items
    are added or deleted. The `ListView` control listens to changes in the list and
    updates itself automatically based on these. However, it’s important to be aware
    that a change to an item in the list will not trigger an update. Changing the
    title of an item will not cause the list to re-render. Let’s move on to implementing
    the rest of `MainViewModel`.'
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableCollection` 类似于一个普通集合，但它有一个有用的超能力：它可以在列表发生变化时通知监听器，例如当项目被添加或删除时。`ListView`
    控件会监听列表的变化，并基于这些变化自动更新自己。然而，重要的是要注意，列表中项目的更改不会触发更新。更改项目的标题不会导致列表重新渲染。让我们继续实现 `MainViewModel`
    的其余部分。'
- en: 'Now, we need some data:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一些数据：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-391
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewModels/MainViewModel.cs`。
- en: 'Replace (or complete) the `LoadDataAsync` method and create the `CreateTodo`
    **ItemViewModel** and `ItemStatusChanged` methods:'
  id: totrans-392
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 替换（或完成）`LoadDataAsync` 方法并创建 `CreateTodo ItemViewModel` 和 `ItemStatusChanged`
    方法：
- en: '[PRE41]'
  id: totrans-393
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Resolve all new references by adding the following `using` statements:'
  id: totrans-394
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过添加以下 `using` 语句解决所有新的引用：
- en: '[PRE42]'
  id: totrans-395
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: The `LoadData` method calls the repository to fetch all items. Then, we wrap
    each to-do list item in `TodoItemViewModel`. This contains more information that
    is specific to the view that we don’t want to add to the `TodoItem` class. It
    is good practice to wrap plain objects in `ViewModel`; this makes it simpler to
    add actions or extra properties to it. `ItemStatusChanged` is a stub that is called
    when we change the status of the to-do list item from `active` to `completed`,
    and vice versa.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: '`LoadData` 方法调用存储库以获取所有项目。然后，我们将每个待办事项列表项包装在 `TodoItemViewModel` 中。这包含了一些特定于视图的信息，我们不想将其添加到
    `TodoItem` 类中。将普通对象包装在 `ViewModel` 中是一种良好的实践；这使得向其中添加操作或额外属性变得更加简单。`ItemStatusChanged`
    是一个存根，当我们将待办事项列表项的状态从 `active` 更改为 `completed`，反之亦然时被调用。'
- en: 'We also need to hook up some events from the repository to know when data changes:'
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要连接存储库的一些事件，以便知道数据何时发生变化：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-398
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewModels/MainViewModel.cs`。
- en: 'Add the following code in bold:'
  id: totrans-399
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在粗体中添加以下代码：
- en: '[PRE43]'
  id: totrans-400
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: When an item is added to the repository, no matter who added it, `MainView`
    will add it to the `items` list. Since the items collection is an observable collection,
    the list updates. If an item is updated, we simply reload the list.
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 当项目被添加到存储库中时，无论谁添加了它，`MainView` 都会将它添加到 `items` 列表中。由于项目集合是一个可观察集合，列表会更新。如果项目被更新，我们只需重新加载列表。
- en: 'Let’s data-bind our items to `ListView`:'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们将项目数据绑定到 `ListView`：
- en: Open `MainView.xaml` and locate the `ListView` element.
  id: totrans-403
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `MainView.xaml` 并定位 `ListView` 元素。
- en: 'Modify it so that it reflects the following code:'
  id: totrans-404
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改它，使其反映以下代码：
- en: '[PRE44]'
  id: totrans-405
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `ItemsSource` binding tells `ListView` where to find the collection to iterate
    over and is local to `ViewModel`. Any bindings in the `ViewCell` node, however,
    are local to each item that we iterate in the list. In this case, we are binding
    to `TodoItemViewModel`, which contains a property named `Item`. This, in turn,
    has properties such as `Title`, `Due`, and `Completed`. We can navigate down the
    hierarchy of objects without any problem when defining a binding.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemsSource` 绑定告诉 `ListView` 去哪里找到要迭代的集合，并且是 `ViewModel` 本地化的。然而，`ViewCell`
    节点中的任何绑定都是针对列表中迭代的每个项目本地化的。在这种情况下，我们正在绑定到 `TodoItemViewModel`，它包含一个名为 `Item` 的属性。这个属性反过来又包含诸如
    `Title`、`Due` 和 `Completed` 等属性。在定义绑定时，我们可以毫无问题地导航到对象的层次结构。'
- en: The `DataTemplate` element defines what each row will look like. We use a grid
    to partition the space, just as we did earlier.
  id: totrans-407
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataTemplate` 元素定义了每一行将看起来是什么样子。我们使用网格来划分空间，就像我们之前做的那样。'
- en: You may have noticed that we didn’t discuss what `BoxView` was for, and it isn’t
    bound to any properties of `ViewModel`. The next two sections will cover how we
    can use the `Completed` property to color code our items with `BoxView`.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到我们没有讨论 `BoxView` 的用途，并且它没有绑定到 `ViewModel` 的任何属性。接下来的两个部分将介绍我们如何使用 `Completed`
    属性来使用 `BoxView` 为项目着色。
- en: Creating a ValueConverter object for the item’s status
  id: totrans-409
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为项目状态创建一个 `ValueConverter` 对象
- en: 'Sometimes, we want to bind to objects that are a representation of the original
    value. This could be a piece of text that is based on a Boolean value. Instead
    of `true` and `false`, for example, we might want to write `Yes` and `No` or return
    a color. This is where `ValueConverter` comes in handy. It can be used to convert
    a value to and from another value. We are going to write a `ValueConverter` object
    that converts the status of a to-do list item into a color:'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们想要绑定到表示原始值的对象。这可能是一段基于布尔值的文本。例如，我们可能想要写 `Yes` 和 `No`，或者返回一个颜色。这就是 `ValueConverter`
    发挥作用的地方。它可以用来将一个值转换为另一个值，或者从另一个值转换回来。我们将编写一个 `ValueConverter` 对象，将待办事项列表项的状态转换为颜色：
- en: In the root of the `DoToo` project, create a folder called `Converters`.
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `DoToo` 项目的根目录下创建一个名为 `Converters` 的文件夹。
- en: 'Create a class called `StatusColorConverter.cs` in the `Converters` folder
    and add the following code:'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Converters` 文件夹中创建一个名为 `StatusColorConverter.cs` 的类，并添加以下代码：
- en: '[PRE45]'
  id: totrans-413
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: A `ValueConverter` object is a class that implements `IValueConverter`. This,
    in turn, only has two methods defined. The `Convert` method is called when the
    view reads data from `ViewModel` and the `ConvertBack` method is used when `ViewModel`
    gets data from the view. The `ConvertBack` method is only used for controls that
    return data from plain text, such as the `Entry` control.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueConverter` 对象是一个实现了 `IValueConverter` 接口的类。这反过来又只定义了两个方法。当视图从 `ViewModel`
    读取数据时调用 `Convert` 方法，当 `ViewModel` 从视图中获取数据时使用 `ConvertBack` 方法。`ConvertBack`
    方法仅用于返回纯文本数据的控件，例如 `Entry` 控件。'
- en: 'If we look at the implementation of the `Convert` method, we’ll notice that
    any value passed to the method is of the `object` type. This is because we don’t
    know what type the user has bound to the property to which we are adding this
    `ValueConverter` class. We may also notice that we fetch colors from a resource
    file. We could have defined the colors in the code, but this is not recommended.
    So, instead, we went the extra mile and added them as a global resource to the
    `App.xaml` file. Resources are a good thing to take another look at once you have
    finished this chapter:'
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们查看 `Convert` 方法的实现，我们会注意到传递给该方法的所有值都是 `object` 类型。这是因为我们不知道用户将什么类型绑定到我们添加
    `ValueConverter` 类的属性上。我们可能还会注意到我们从资源文件中获取颜色。我们本来可以在代码中定义颜色，但这不是推荐的做法。因此，我们走得更远，将它们作为全局资源添加到
    `App.xaml` 文件中。完成本章学习后，资源是一个值得再次审视的好东西：
- en: Open `App.xaml` in the `DoToo` project.
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `DoToo` 项目的 `App.xaml` 文件。
- en: 'Add the following `ResourceDictionary` element:'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下 `ResourceDictionary` 元素：
- en: '[PRE46]'
  id: totrans-418
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '`ResourceDictionary` can define a wide range of different objects. We only
    need the two colors that we want to access from `ValueConverter`. Notice that
    these can be accessed by the key given to them and from any other XAML file using
    a static resource binding.'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResourceDictionary` 可以定义广泛的不同对象。我们只需要访问 `ValueConverter` 的两个颜色。请注意，这些可以通过给定的键访问，并且可以从任何其他
    XAML 文件使用静态资源绑定访问。'
- en: '`ValueConverter` itself is referenced as a static resource but from a local
    scope.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValueConverter` 本身作为一个静态资源被引用，但来自局部作用域。'
- en: Using ValueConverter
  id: totrans-421
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用 ValueConverter
- en: 'We want to use our brand-new `StatusColorConverter` object in `MainView`. Unfortunately,
    we have to jump through some hoops to make this happen. We need to do three things:'
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: 我们想在 `MainView` 中使用我们全新的 `StatusColorConverter` 对象。不幸的是，我们必须跳过一些步骤才能实现这一点。我们需要做三件事：
- en: Define a namespace in XAML
  id: totrans-423
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 XAML 中定义一个命名空间
- en: Define a local resource that represents an instance of the converter
  id: totrans-424
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义一个表示转换器实例的本地资源
- en: Declare that we want to use the converter in the binding
  id: totrans-425
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声明我们想要在绑定中使用转换器
- en: 'Let’s start with the namespace:'
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从命名空间开始：
- en: Open `Views/MainView.xaml`.
  id: totrans-427
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Views/MainView.xaml`。
- en: 'Add the following namespace to the page:'
  id: totrans-428
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下命名空间添加到页面中：
- en: '[PRE47]'
  id: totrans-429
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Add a `Resource` node to the `MainView.xaml` file:'
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `MainView.xaml` 文件中添加一个 `Resource` 节点：
- en: Open `Views/MainView.xaml`.
  id: totrans-431
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Views/MainView.xaml`。
- en: 'Add the following `ResourceDictionary` element, shown in bold under the root
    element of the XAML file:'
  id: totrans-432
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 XAML 文件的根元素下添加以下 `ResourceDictionary` 元素，如下所示（加粗）：
- en: '[PRE48]'
  id: totrans-433
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This has the same form as the global resource dictionary, but since this one
    is defined in `MainView`, it can only be accessed from there. We could have defined
    this in the global resource dictionary, but it’s usually more efficient to define
    objects that you only consume in one place as close to that place as possible.
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 这与全局资源字典具有相同的形式，但由于这个资源是在 `MainView` 中定义的，因此只能从那里访问。我们本来可以在全局资源字典中定义它，但通常将只在一个地方使用的对象尽可能靠近那个地方定义会更高效。
- en: 'The last step is to add the converter:'
  id: totrans-435
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是添加转换器：
- en: Locate the `BoxView` node in the XAML file.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 XAML 文件中找到 `BoxView` 节点。
- en: 'Add the `BackgroundColor` XAML, which is marked in bold:'
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加标记为粗体的 `BackgroundColor` XAML：
- en: '[PRE49]'
  id: totrans-438
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: What we have done here is bind a `bool` value to a property that takes a `Color`
    object. Right before the data binding takes place, however, `ValueConverter` converts
    the `bool` value into a color. This is just one of the many cases where `ValueConverter`
    comes in handy. Keep this in mind when you define the GUI.
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在这里所做的是将一个 `bool` 值绑定到一个接受 `Color` 对象的属性。然而，在数据绑定发生之前，`ValueConverter` 将 `bool`
    值转换为颜色。这只是 `ValueConverter` 有用的许多情况之一。在定义 GUI 时请记住这一点。
- en: Navigating to an item using a command
  id: totrans-440
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令导航到项
- en: We want to be able to see the details for a selected to-do list item. When we
    tap a row, we should navigate to the item in that row.
  id: totrans-441
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够看到所选待办事项列表项的详细信息。当我们点击一行时，我们应该导航到该行的项。
- en: 'To do this, we need to add the following code:'
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 要完成这个任务，我们需要添加以下代码：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-443
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewModels/MainViewModel.cs`。
- en: 'Add the `SelectedItem` property, the `OnSelectedItemChanging` event handler,
    and the `NavigateToItemAsync` method to the class:'
  id: totrans-444
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `SelectedItem` 属性、`OnSelectedItemChanging` 事件处理程序和 `NavigateToItemAsync` 方法添加到类中：
- en: '[PRE50]'
  id: totrans-445
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: The `SelectedItem` property is a property that we will data-bind to `ListView`.
    When we select a row in `ListView`, this property is set to the `TodoItemViewModel`
    object that represents that row. We are using the `ObservableProperty` attribute
    here to carry out its `PropertyChanged` magic. However, since the setter is being
    generated through the `ObservableProperty` attribute, there is no place to add
    additional code to the property. Luckily, the `ObservableProperty` source generator
    also adds two partial methods that can be implemented. We are using `OnSelectedItemChanging`
    to add additional functionality to the setter. The other partial method is `OnSelectedItemChanged`.
    `OnSelectedItemChanging` is called before the property value has changed and `OnSelectedItemChanged`
    is called after the value has changed. Remember that you can always view the generated
    source to learn more about how these attributes are extending your code.
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectedItem` 属性是我们将要数据绑定到 `ListView` 的属性。当我们选择 `ListView` 中的行时，此属性设置为表示该行的
    `TodoItemViewModel` 对象。在这里我们使用 `ObservableProperty` 属性来执行其 `PropertyChanged` 魔法。然而，由于设置器是通过
    `ObservableProperty` 属性生成的，因此没有地方可以添加额外的代码到该属性中。幸运的是，`ObservableProperty` 源生成器还添加了两个可以实现的局部方法。我们使用
    `OnSelectedItemChanging` 来向设置器添加额外的功能。另一个局部方法是 `OnSelectedItemChanged`。`OnSelectedItemChanging`
    在属性值改变之前被调用，而 `OnSelectedItemChanged` 在值改变后被调用。记住，你总是可以查看生成的源代码来了解这些属性是如何扩展你的代码的。'
- en: The `OnSelectedItemChanging` method then calls `NavigateToItem`, which creates
    a new `ItemView` view using the .NET MAUI dependency injection container. At this
    point, we change the `Title` of the view from `"Add todo item"` to `"Edit todo
    item"`. We extract `ViewModel` from the newly created `ItemView` view and assign
    the current `TodoItem` object that `TodoItemViewModel` contains. Confused? Remember
    that `TodoItemViewModel` wraps a `TodoItem` object, and it is that item that we
    want to pass to `ItemView`.
  id: totrans-447
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnSelectedItemChanging` 方法随后调用 `NavigateToItem`，它使用 .NET MAUI 依赖注入容器创建一个新的
    `ItemView` 视图。在这个时候，我们将视图的 `Title` 从 `"Add todo item"` 改为 `"Edit todo item"`。我们从新创建的
    `ItemView` 视图中提取 `ViewModel` 并将 `TodoItemViewModel` 包含的当前 `TodoItem` 对象分配给它。困惑了吗？记住，`TodoItemViewModel`
    包装了一个 `TodoItem` 对象，而我们想要传递给 `ItemView` 的就是那个对象。'
- en: 'We are not done yet. Now, we need to data-bind the new `SelectedItem` property
    to the right place in the view:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还没有完成。现在，我们需要将新的 `SelectedItem` 属性数据绑定到视图中的正确位置：
- en: Open `Views/MainView.xaml`.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Views/MainView.xaml`。
- en: 'Locate `ListView` and add the attributes in bold:'
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到 `ListView` 并添加粗体字中的属性：
- en: '[PRE51]'
  id: totrans-451
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: The `SelectedItem` attribute binds the `SelectedItem` property’s `ListView`
    view to the `ViewModel` property. When the selection of an item in `ListView`
    changes, the `ViewModel` property’s `SelectedItem` property is called and we navigate
    to the new and exciting views.
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: '`SelectedItem` 属性将 `ListView` 视图的 `SelectedItem` 属性绑定到 `ViewModel` 属性。当 `ListView`
    中项的选择改变时，`ViewModel` 属性的 `SelectedItem` 属性被调用，并且我们导航到新的和令人兴奋的视图。'
- en: 'The `x:Name` attribute is for naming `ListView` because we need to make a small
    and ugly hack to make this work. `ListView` stays selected after the navigation
    is done. When we navigate back, it cannot be selected again until we select another
    row. To mitigate this, we need to hook up to the `ItemSelected` event of `ListView`
    and reset the selected item directly on `ListView`. This is not recommended because
    we shouldn’t have any logic in our views, but sometimes, we have no other choice:'
  id: totrans-453
  prefs: []
  type: TYPE_NORMAL
  zh: '`x:Name` 属性用于命名 `ListView`，因为我们需要做一些小而丑陋的修改来使它工作。`ListView` 在导航完成后会保持选中状态。当我们返回导航时，它不能再次被选中，直到我们选择另一行。为了减轻这种情况，我们需要连接到
    `ListView` 的 `ItemSelected` 事件，并在 `ListView` 上直接重置选中项。这不被推荐，因为我们不应该在视图中有任何逻辑，但有时我们别无选择：'
- en: Open `Views/MainView.xaml.cs`.
  id: totrans-454
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Views/MainView.xaml.cs`。
- en: 'Add the following code in bold:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 请以粗体添加以下代码：
- en: '[PRE52]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: We should now be able to navigate to an item in the list. Next, we will mark
    it as complete.
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们应该能够导航到列表中的某个项目。接下来，我们将标记它为完成。
- en: Marking an item as complete using a command
  id: totrans-458
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令标记项目为完成
- en: 'We need to add a functionality that allows us to toggle items between `complete`
    and `active`. It is possible to navigate to the detailed view of the to-do list
    item, but this is too much work for a user. Instead, we’ll add a `ContextAction`
    item to `ListView`. In iOS, for example, this is accessed by swiping left on a
    row:'
  id: totrans-459
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加一个功能，允许我们在 `complete` 和 `active` 之间切换项目。虽然可以导航到待办事项列表项的详细视图，但这对于用户来说工作量太大。因此，我们将在
    `ListView` 中添加一个 `ContextAction` 项目。例如，在 iOS 中，这可以通过在行上向左滑动来访问：
- en: Open `ViewModel/TodoItemViewModel.cs`.
  id: totrans-460
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewModel/TodoItemViewModel.cs`。
- en: Add a `using` statement for `CommunityToolkit.Mvvm.Input`.
  id: totrans-461
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `using` 语句 `CommunityToolkit.Mvvm.Input`。
- en: 'Add a command to toggle the status of the item and a piece of text that describes
    the status:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个用于切换项目状态的命令和一段描述状态的文本：
- en: '[PRE53]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Here, we have added a command for toggling the state of an item. When executed,
    it inverses the current state and raises the `ItemStatusChanged` event so that
    subscribers are notified. To change the text of the context action button depending
    on the status, we added a `StatusText` property. This is not recommended practice
    because we are adding code that only exists because of a specific UI case to `ViewModel`.
    Ideally, this would be handled by the view, perhaps by using `ValueConverter`.
    To save us from having to implement these steps, however, we have left it as a
    string property:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们添加了一个用于切换项目状态的命令。当执行时，它会反转当前状态并引发 `ItemStatusChanged` 事件，以便订阅者得到通知。为了根据状态更改上下文操作按钮的文本，我们添加了一个
    `StatusText` 属性。这不是推荐的做法，因为我们正在向 `ViewModel` 添加仅因特定 UI 情况而存在的代码。理想情况下，这应该由视图处理，可能通过使用
    `ValueConverter`。然而，为了省去我们实现这些步骤的需要，我们将其保留为字符串属性：
- en: Open `Views/MainView.xaml`.
  id: totrans-465
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Views/MainView.xaml`。
- en: 'Locate the `ListView.ItemTemplate` node and add the following `ViewCell.ContextActions`
    node:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位到 `ListView.ItemTemplate` 节点，并添加以下 `ViewCell.ContextActions` 节点：
- en: '[PRE54]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Creating the filter toggle function using a command
  id: totrans-468
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用命令创建过滤切换功能
- en: We want to be able to toggle between viewing active items only and all the items.
    We will create a simple mechanism to do this.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 我们希望能够切换仅在查看活动项目或所有项目之间。我们将创建一个简单的机制来实现这一点。
- en: 'Hook up the changes in `MainViewModel` as follows:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式将 `MainViewModel` 中的更改连接起来：
- en: Open `ViewModels/MainViewModel.cs` and locate `ItemStatusChangeMethod`.
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewModels/MainViewModel.cs` 并定位 `ItemStatusChangeMethod`。
- en: 'Add the implementation to the `ItemStatusChanged` method and a property called
    `ShowAll` to control the filtering:'
  id: totrans-472
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将实现添加到 `ItemStatusChanged` 方法，并添加一个名为 `ShowAll` 的属性来控制过滤：
- en: '[PRE55]'
  id: totrans-473
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: The `ItemStatusChanged` event handler is triggered when we use the context action
    from the previous section. Since the sender is always an object, we try to cast
    it to `TodoItemViewModel`. If this is successful, we check whether we can remove
    it from the list if `ShowAll` is not `true`. This is a small optimization; we
    could have called `LoadData` and reloaded the entire list, but since the `Items`
    list is set to `ObservableCollection`, it communicates to `ListView` that one
    item has been removed from the list. We also call the repository to update the
    item to persist the change of status.
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们使用上一节中的上下文操作时，会触发 `ItemStatusChanged` 事件处理程序。由于发送者始终是一个对象，我们尝试将其转换为 `TodoItemViewModel`。如果成功，我们检查是否可以将其从列表中删除，如果
    `ShowAll` 不是 `true`。这是一个小的优化；我们本可以调用 `LoadData` 并重新加载整个列表，但由于 `Items` 列表被设置为 `ObservableCollection`，它会通知
    `ListView` 列表中已删除一个项目。我们还调用存储库来更新项目以持久化状态更改。
- en: 'The `ShowAll` property is what controls which state our filter is in. We need
    to adjust the `LoadData` method to reflect this:'
  id: totrans-475
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowAll` 属性控制我们的过滤器处于哪种状态。我们需要调整 `LoadData` 方法以反映这一点：'
- en: Locate the `Load` method in `MainViewModel`.
  id: totrans-476
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainViewModel` 中定位 `Load` 方法。
- en: 'Add the following lines of code marked in bold:'
  id: totrans-477
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下加粗的代码行：
- en: '[PRE56]'
  id: totrans-478
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE56]'
- en: If `ShowAll` is `false`, we limit the content of the list to the items that
    have not been completed. We can do this either by having two methods, `GetAllItems()`
    and `GetActiveItems()`, or by using a `filter` argument that can pass to `GetItemsAsync()`.
    Take a minute to think about how we could implement this.
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `ShowAll` 为 `false`，我们将限制列表的内容为未完成的项。我们可以通过有两个方法，`GetAllItems()` 和 `GetActiveItems()`，或者使用可以传递给
    `GetItemsAsync()` 的 `filter` 参数来实现这一点。花一分钟时间思考我们如何实现这一点。
- en: 'Let’s add the code that toggles the filter:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加切换过滤器的代码：
- en: Open `ViewModels/MainViewModel.cs`.
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `ViewModels/MainViewModel.cs`。
- en: 'Add the `FilterText` and `ToggleFilterAsync` properties:'
  id: totrans-482
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加 `FilterText` 和 `ToggleFilterAsync` 属性：
- en: '[PRE57]'
  id: totrans-483
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE57]'
- en: 'The `ShowAll` property is a Boolean value, and that does not display well in
    a human-readable form. We will use another `ValueConverter` to change the status
    into a human-readable form:'
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: '`ShowAll` 属性是一个布尔值，它以人类可读的形式显示得不好。我们将使用另一个 `ValueConverter` 将状态转换为人类可读的形式：'
- en: Create a new class in the `Converters` folder named `FilterTextConverter.cs`.
  id: totrans-485
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Converters` 文件夹中创建一个名为 `FilterTextConverter.cs` 的新类。
- en: 'Add the following code:'
  id: totrans-486
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码：
- en: '[PRE58]'
  id: totrans-487
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '`FilterTextConverter` is very similar to the previous converter we created.
    The difference is that in the `Convert` method, we convert a `bool` value into
    the `"All"` or `"Active"` string. This converter will be used in the view to change
    the value of `ShowAll` into a value more suitable for display in the user interface.'
  id: totrans-488
  prefs: []
  type: TYPE_NORMAL
  zh: '`FilterTextConverter` 与我们之前创建的转换器非常相似。区别在于在 `Convert` 方法中，我们将 `bool` 值转换为 `"All"`
    或 `"Active"` 字符串。此转换器将在视图中使用，将 `ShowAll` 的值转换为更适合在用户界面中显示的值。'
- en: The logic for the `ToggleFilterAsync` command is a simple inversion of the state
    and then a call to `LoadDataAsync`. This, in turn, causes the list to be reloaded.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToggleFilterAsync` 命令的逻辑是状态的简单反转然后调用 `LoadDataAsync`。这反过来又导致列表被重新加载。'
- en: 'Before we can filter the items, we need to hook up the filter button to `Command`
    and `Converter`:'
  id: totrans-490
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们可以过滤项目之前，我们需要将过滤按钮连接到 `Command` 和 `Converter`：
- en: Open `Views/MainView.xaml`.
  id: totrans-491
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Views/MainView.xaml`。
- en: 'Add the following highlighted entry to `ResourceDictionary`:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下突出显示的条目添加到 `ResourceDictionary`：
- en: '[PRE59]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Locate the button that controls the filter (the only button in the file).
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 定位控制过滤器的按钮（文件中的唯一按钮）。
- en: 'Adjust your code to reflect the following code:'
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调整您的代码以反映以下代码：
- en: '[PRE60]'
  id: totrans-496
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE60]'
- en: We have now finished with this feature! However, our app isn’t very attractive;
    we’ll deal with this in the following section.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经完成了这个功能！然而，我们的应用并不吸引人；我们将在下一节中处理这个问题。
- en: Laying out the contents
  id: totrans-498
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局内容
- en: This last section is about making the app look a bit nicer. We will just scratch
    the surface of the possibilities here, but this should give you some ideas about
    how styling works.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 这最后一部分是关于让应用看起来更美观。我们在这里只是触及了可能性的表面，但这应该会给你一些关于样式如何工作的想法。
- en: Setting an application-wide background color
  id: totrans-500
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置应用程序范围的背景颜色
- en: 'Styles are a great way of applying styling to elements. They can be applied
    either to all elements of a type or the elements referenced by a key if you add
    an `x:Key` attribute:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 样式是应用样式的绝佳方式。如果添加了 `x:Key` 属性，它们可以应用于类型的所有元素或通过键引用的元素：
- en: Open `App.xaml`.
  id: totrans-502
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `App.xaml`。
- en: 'Add the following XAML, which is in bold, to the file:'
  id: totrans-503
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下加粗的 XAML 添加到文件中：
- en: '[PRE61]'
  id: totrans-504
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE61]'
- en: The first style we will apply is a new background color and text color to the
    navigation bar. The second style will be applied to the filter button. We can
    define a style by setting `TargetType`, which tells .NET MAUI which type of object
    this style can be applied to. We can then add one or more properties that we want
    to set. The result will be the same as if we had added these properties directly
    to the element in the XAML code.
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将应用的第一种样式是导航栏的新背景颜色和文本颜色。第二种样式将应用于过滤按钮。我们可以通过设置 `TargetType` 来定义样式，这告诉 .NET
    MAUI 这种样式可以应用于哪种类型的对象。然后我们可以添加一个或多个我们想要设置的属性。结果将与我们在 XAML 代码中直接添加这些属性相同。
- en: Styles that lack the `x:Key` attribute are applied to all instances of the type
    defined in `TargetType`. Styles that have a key must be explicitly assigned in
    the XAML of the user interface. We will see examples of this when we define the
    filter button in the next section.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 缺少 `x:Key` 属性的样式应用于 `TargetType` 中定义的类型的所有实例。具有键的样式必须在用户界面的 XAML 中显式分配。我们将在定义下一节中的筛选按钮时看到这个例子。
- en: Laying out the MainView and ListView items
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局 MainView 和 ListView 项目
- en: In this section, we will improve the appearance of `MainView` and `ListView`.
    Open `Views/MainView.xaml` and apply the changes in bold in the XAML code in each
    of the following sections.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将改进 `MainView` 和 `ListView` 的外观。打开 `Views/MainView.xaml` 并在每个以下部分中应用
    XAML 代码中的粗体更改。
- en: The ﬁlter button
  id: totrans-509
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 筛选按钮
- en: 'The filter button allows us to toggle the state of the list to show only the
    active to-do items or all the to-do items. Let’s style it to make it stand out
    a bit in the layout:'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 筛选按钮允许我们切换列表的状态，以仅显示活动待办事项或所有待办事项。让我们将其样式化，使其在布局中更加突出：
- en: Find the filter button.
  id: totrans-511
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 找到筛选按钮。
- en: 'Make the following changes:'
  id: totrans-512
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 进行以下修改：
- en: '[PRE62]'
  id: totrans-513
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE62]'
- en: The style is applied using `DynamicResource`. Anything defined in a resource
    dictionary, either in the `App.xaml` file or in the local XAML file, is accessible
    through it. Then, we set `BackgroundColor`, again setting `DynamicResource` to
    `ActiveColor` and `TextColor` to `Black`.
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 样式是通过 `DynamicResource` 应用的。在资源字典中定义的任何内容，无论是 `App.xaml` 文件中还是本地 XAML 文件中，都可以通过它访问。然后，我们设置了
    `BackgroundColor`，再次将 `DynamicResource` 设置为 `ActiveColor` 并将 `TextColor` 设置为 `Black`。
- en: The `Button.Triggers` node is a useful feature. We can define several types
    of triggers that fire when certain criteria are met. In this case, we use a data
    trigger that checks whether the value of `ShowAll` changes to `true`. If it does,
    we set `TextColor` to white and `BackgroundColor` to `CompletedColor`. The coolest
    part is that when `ShowAll` becomes `false` again, it switches back to whichever
    value it was before.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: '`Button.Triggers` 节点是一个有用的功能。我们可以定义在满足某些条件时触发的几种类型的触发器。在这种情况下，我们使用了一个数据触发器，检查
    `ShowAll` 的值是否变为 `true`。如果是，我们将 `TextColor` 设置为白色，将 `BackgroundColor` 设置为 `CompletedColor`。最酷的部分是当
    `ShowAll` 再次变为 `false` 时，它会切换回之前的任何值。'
- en: Touching up ListView
  id: totrans-516
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 优化 ListView
- en: '`ListView` could use a couple of minor changes. The first change is formatting
    the due date string to a more human-readable format and the second is changing
    the color of the `Completed` label to a nice green tint:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: '`ListView` 可以进行一些小的修改。第一个修改是将到期日期字符串格式化为更易读的格式，第二个修改是将 `Completed` 标签的颜色改为漂亮的绿色：'
- en: Open `Views/MainView.xaml`.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 `Views/MainView.xaml`。
- en: 'Locate the labels that bind `Item.Due` and `Item.Completed` in `ListView`:'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ListView` 中定位绑定 `Item.Due` 和 `Item.Completed` 的标签：
- en: '[PRE63]'
  id: totrans-520
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE63]'
- en: Here, we added a formatting string to the binding to format the date using a
    specific format. In this case, we used the `0:MMMM d, yyyy` format, which will
    display the date as a string in the format of, for example, May 5, 2020.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们向绑定中添加了一个格式化字符串，用于使用特定格式格式化日期。在这种情况下，我们使用了 `0:MMMM d, yyyy` 格式，这将日期显示为字符串，例如，5
    月 5 日，2020 年。
- en: We also added a text color to the `Completed` label that is only visible if
    an item is completed. We did this by referencing our dictionary in `App.xaml`.
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还向 `Completed` 标签添加了文本颜色，仅在项目完成时可见。我们通过在 `App.xaml` 中引用我们的字典来实现这一点。
- en: 'Now that all the code changes are complete, run our application. Here is a
    small gallery of screenshots that should match your application:'
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有代码更改都已完成，运行我们的应用程序。以下是一组截图，应该与你的应用程序匹配：
- en: '![Figure 2.15 – DoToo on Android](img/Figure_2.15_B19214.jpg)'
  id: totrans-524
  prefs: []
  type: TYPE_IMG
  zh: '![图 2.15 – DoToo 在 Android 上](img/Figure_2.15_B19214.jpg)'
- en: Figure 2.15 – DoToo on Android
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: 图 2.15 – DoToo 在 Android 上
- en: Summary
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You should now have a good grasp of all the steps involved in creating a .NET
    MAUI app from scratch. In this chapter, we learned about the project structure
    and the important files in a newly created project. We talked about dependency
    injection and learned the basics of MVVM by creating all the views and the `ViewModel`
    classes needed. We also covered data storage in SQLite to persist data on our
    device in a fast and secure way. Using the knowledge you’ve gained from this chapter,
    you should now be able to create the backbone of any app you’d like.
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你应该已经很好地掌握了从头创建 .NET MAUI 应用所需的所有步骤。在本章中，我们了解了项目结构和新建项目中的重要文件。我们讨论了依赖注入，并通过创建所有视图和所需的
    `ViewModel` 类学习了 MVVM 的基础知识。我们还介绍了在 SQLite 中进行数据存储，以快速且安全的方式在我们的设备上持久化数据。利用本章中获得的知识，你现在应该能够创建任何你想要的任何应用的骨架。
- en: The next chapter will focus on upgrading an existing Xamarin.Forms application
    to .NET MAUI.**
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将专注于将现有的Xamarin.Forms应用程序升级到.NET MAUI。**
