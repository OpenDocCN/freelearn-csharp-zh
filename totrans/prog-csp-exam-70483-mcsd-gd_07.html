<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Implementing Exception Handling</h1>
                </header>
            
            <article>
                
<p class="mce-root">Exception handling helps developers structure their programs in a way that helps them handle both expected and unexpected scenarios. Often, application logic may throw some form of unhandled exception, for example, a code block trying to write to a file on a system that ends up with a file with a use exception. Such scenarios can be handled if proper exception handling is in place.</p>
<p>Exception handling uses the <kbd>try</kbd>, <kbd>catch</kbd>, and <kbd>finally</kbd> keywords to allow us to write code that may not succeed and can be handled when required, as well as to help us clean up resources once the <kbd>try</kbd> block has been executed. These exceptions can be thrown by CLR, .NET Framework, or by external libraries that are used in your code.</p>
<p>In this chapter, we will try to understand how we can use, create, and throw exceptions by looking at the following topics:</p>
<ul>
<li>Exceptions and handling exceptions in code</li>
<li>Compiler-generated exceptions</li>
<li>Custom exceptions</li>
</ul>
<p><span>After reading this chapter, you will be able to structure an application program and handle all sorts of exceptions that may be thrown from your application logic.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>The exercises in this chapter can be practiced using Visual Studio 2012 or above with .NET Framework 2.0 or newer. However, any new C# features from C# 7.0 and above require that you have Visual Studio 2017.</p>
<p class="mce-root"/>
<p>If you don't have a license for any of the aforementioned products, you can download the community version of Visual studio 2017 from <a href="https://visualstudio.microsoft.com/downloads/">https://visualstudio.microsoft.com/downloads/</a>.</p>
<p>The same code for this chapter can be found on GitHub at <a href="https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter07">https://github.com/PacktPublishing/Programming-in-C-sharp-Exam-70-483-MCSD-Guide/tree/master/Chapter07</a>.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exceptions and handling exceptions in code</h1>
                </header>
            
            <article>
                
<p>Exceptions are types that are derived from the <kbd>System.Exception</kbd> class. We use the <kbd>try</kbd> block around statements that may throw an exception. When an exception occurs, control jumps to the <kbd>catch</kbd> statement, where CLR collects all the required stack trace information before terminating the program and displaying a message to the user. If exception handling is not done, the program just terminates with an error. While handling exceptions, it is important to understand that if we cannot handle an exception, we should not catch it. This ensures that the application will be in a known state. When you define a <kbd>catch</kbd> block, you define an exception variable that can be used to obtain more information, such as the origin of the exception, which line in the code threw this exception, the type of exception, and so on.</p>
<p>A programmer can create and throw exceptions from the application logic using the throw keyword. Each <kbd>try</kbd> block may or may not define the <kbd>finally</kbd> block, which will be executed whether an exception is thrown or not. This block helps us release resources that have been used in the code block. Alternatively, if you want a piece of code to execute in all scenarios, it can be placed in the <kbd>finally</kbd> block.</p>
<p>In the upcoming sections, we will look at how we can use exceptions, the syntax of the <kbd>try</kbd>-<kbd>catch</kbd>-<kbd>finally</kbd> block, using the <kbd>finally</kbd> block, when we can dispose of unused objects, different types of system exceptions, and creating our own exceptions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Using exceptions</h1>
                </header>
            
            <article>
                
<p>As we mentioned previously, errors in C# programs are propagated at runtime using exceptions. When application code encounters an error, it throws an exception, which is then caught by another block of code that collects all the information about the exception and pushes it to the calling method, where the <kbd>catch</kbd> block was provided. A dialog box will be displayed by the system if you're using a generic exception handler for any uncaught exceptions.</p>
<p class="mce-root"/>
<p>In the following example, we are trying to parse an empty string into an <kbd>int</kbd> variable:</p>
<pre>public static void ExceptionTest1()<br/>{<br/>    string str = string.Empty;<br/>    int parseInt = int.Parse(str);<br/>}</pre>
<p><span>When executed, the runtime throws a format exception with a message stating</span> <span class="packt_screen">Input string was not in a correct format</span><span>. As this exception wasn't caught, we can see the generic handler displaying this error message in a dialog box:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/ba893895-c52d-4363-91ad-b06cd309b8ff.png"/></div>
<p>Here are the exception's details:</p>
<pre>System.FormatException occurred<br/>  HResult=0x80131537<br/>  Message=Input string was not in a correct format.<br/>  Source=&lt;Cannot evaluate the exception source&gt;<br/>  StackTrace:<br/>   at System.Number.StringToNumber(String str, NumberStyles options, NumberBuffer&amp; number, NumberFormatInfo info, Boolean parseDecimal)<br/>   at System.Number.ParseInt32(String s, NumberStyles style, NumberFormatInfo info)<br/>   at System.Int32.Parse(String s)<br/>   at Chapter7.ExceptionSamples.ExceptionTest1() in C:\Users\srini\source\repos\Programming-in-C-Exam-70-483-MCSD-Guide2\Book70483Samples\Chapter7\ExceptionSamples.cs:line 14<br/>   at Chapter7.Program.Main(String[] args) in C:\Users\srini\source\repos\Programming-in-C-Exam-70-483-MCSD-Guide2\Book70483Samples\Chapter7\Program.cs:line 13</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>Each <kbd>catch</kbd> block defines an exception variable that gives us more information about the exception that is being thrown. The <kbd>exception</kbd> class defines multiple properties, all of which hold the following extra information:</p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td style="width: 24.4766%"><strong><span><span>Property</span></span></strong></td>
<td style="width: 73.5234%"><strong>Description</strong></td>
</tr>
<tr>
<td style="width: 24.4766%"><kbd>Data</kbd></td>
<td style="width: 73.5234%"><span>Gets custom-defined details about the exception in a key/value pair collection.</span></td>
</tr>
<tr>
<td style="width: 24.4766%"><kbd>HelpLink</kbd></td>
<td style="width: 73.5234%"><span>Gets or sets a help link related to an exception.</span></td>
</tr>
<tr>
<td style="width: 24.4766%"><kbd>HResult</kbd></td>
<td style="width: 73.5234%"><span>Gets or sets <kbd>HRESULT</kbd>, a number value that is associated with the exception.</span></td>
</tr>
<tr>
<td style="width: 24.4766%"><kbd>InnerException</kbd></td>
<td style="width: 73.5234%"><span>Gets the instance of</span> the exception <span>that triggered the exception.</span></td>
</tr>
<tr>
<td style="width: 24.4766%"><kbd>Message</kbd></td>
<td style="width: 73.5234%"><span>Gets detailed information from the exception.</span></td>
</tr>
<tr>
<td style="width: 24.4766%"><kbd>Source</kbd></td>
<td style="width: 73.5234%"><span>Gets or sets the application/instance name or the object/variable that caused the error.</span></td>
</tr>
<tr>
<td style="width: 24.4766%"><kbd>StackTrace</kbd></td>
<td style="width: 73.5234%"><span>Gets a call stack in a string format.</span></td>
</tr>
<tr>
<td style="width: 24.4766%"><kbd>TargetSite</kbd></td>
<td style="width: 73.5234%"><span>Gets the method that triggered the exception.</span></td>
</tr>
</tbody>
</table>
<p> </p>
<p>Now, we will try to handle the format exception and see what each property will provide us with. In the following example, we have a <kbd>try</kbd> block where the string is being parsed into an integer and a <kbd>catch</kbd> block that is being used to catch the format exception. In the <kbd>catch</kbd> block, we are displaying all the properties of the exception that we've caught:</p>
<pre>public static void ExceptionTest2()<br/>{<br/>    string str = string.Empty;<br/>    try<br/>    {<br/>        int parseInt = int.Parse(str);<br/>    }<br/>    catch (FormatException e)<br/>    {<br/>        Console.WriteLine($"Exception Data: {e.Data}");<br/>        Console.WriteLine($"Exception HelpLink: {e.HelpLink}");<br/>        Console.WriteLine($"Exception HResult: {e.HResult}");<br/>        Console.WriteLine($"Exception InnerException: <br/>                          {e.InnerException}");<br/>        Console.WriteLine($"Exception Message: {e.Message}");<br/>        Console.WriteLine($"Exception Source: {e.Source}");<br/>        Console.WriteLine($"Exception TargetSite: {e.TargetSite}");<br/>        Console.WriteLine($"Exception StackTrace: {e.StackTrace}");<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p><span><span>We are trying to parse a string into an integer variable. However, this is not allowed, and so the system throws an exception. When we catch the exception, we are displaying each property of the exception to observe what it stores:</span></span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/aa6c6e08-4d29-47cc-8eb8-eea6dc13b351.png"/></div>
<p>Each exception is inherited from the <kbd>System.Exception</kbd> base case, which defines the type of exception and details all the properties that provide more information about the exception. When you need to throw an exception, you need to create an instance of the exception class, set all or some of these properties, and throw them using the <kbd>throw</kbd> keyword.</p>
<p>You can have more than one <kbd>catch</kbd> block for a <kbd>try</kbd> block. During execution, when an exception is thrown, a specific <kbd>catch</kbd> statement that handles the exception executes first and any other generic <kbd>catch</kbd> statements are ignored. Therefore, it is important to organize your <kbd>catch</kbd> blocks by placing them in order, that is, from the most specific to the least specific:</p>
<pre>public static void ExceptionTest3()<br/>{<br/>    string str = string.Empty;<br/>    try<br/>    {<br/>        int parseInt = int.Parse(str);<br/>    }<br/>    catch (ArgumentException ex)<br/>    {<br/>        Console.WriteLine("Argument Exception caught");<br/>    }<br/>    catch (FormatException e)<br/>    {<br/>        Console.WriteLine("Format Exception caught");<br/><br/>    }<br/>    catch (Exception ex1)<br/>    {<br/>        Console.WriteLine("Generic Exception caught");<br/>    }<br/>}</pre>
<p>When the program executes, although there are multiple <kbd>catch</kbd> blocks present, the system identifies an appropriate <kbd>catch</kbd> block and consumes the exception. Due to this, you will see a <kbd>Format Exception caught</kbd> message in the output:</p>
<pre><strong>Format Exception caught</strong><br/><strong>Press any key to exit.</strong></pre>
<p>The <kbd>finally</kbd> block is checked before invoking a <kbd>catch</kbd> block. When using resources in a <kbd>try</kbd>-<kbd>catch</kbd> block, there is a chance that these resources will move to an ambiguous state and aren't collected until the framework's garbage collector is invoked. Such resources can be cleaned up by the programmer via the use of <kbd>finally</kbd> blocks:</p>
<pre>public static void ExceptionTest4()<br/>{<br/>    string str = string.Empty;<br/>    try<br/>    {<br/>        int parseInt = int.Parse(str);<br/>    }<br/>    catch (ArgumentException ex)<br/>    {<br/>        Console.WriteLine("Argument Exception caught");<br/>    }<br/>    catch (FormatException e)<br/>    {<br/>        Console.WriteLine("Format Exception caught");<br/><br/>    }<br/>    catch (Exception ex1)<br/>    {<br/>        Console.WriteLine("Generic Exception caught");<br/>    }<br/>    finally<br/>    {<br/>        Console.WriteLine("Finally block executed");<br/>    }<br/>}</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p>As you can see, the <kbd>finally</kbd> block was executed, but not before an exception was raised and caught using the respective <kbd>catch</kbd> block:</p>
<pre><strong>Format Exception caught</strong><br/><strong>Finally block executed</strong><br/><strong>Press any key to exit.</strong></pre>
<p>Although we had three different <kbd>catch</kbd> blocks, the format exception was executed and the <kbd>finally</kbd> block was executed after.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exception handling</h1>
                </header>
            
            <article>
                
<p>Programmers partition application logic that may throw exceptions into a <kbd>try</kbd> block, followed by a <kbd>catch</kbd> block to handle these exceptions. An optional <kbd>finally</kbd> block, if present, is executed, regardless of whether an exception is thrown by a <kbd>try</kbd> block. You cannot just have a <kbd>try</kbd> block—<span>i</span>t has to be accompanied by either a <kbd>catch</kbd> block or a <kbd>finally</kbd> block. </p>
<p>In this section, we will look at different code blocks in order to understand the usage of the <kbd>try</kbd>-<kbd>catch</kbd> statement, the <kbd>try</kbd>-<kbd>finally</kbd> statement, and the <kbd>try</kbd>-<kbd>catch</kbd>-<kbd>finally</kbd> statement.</p>
<p>You can use a <kbd>try</kbd>-<kbd>catch</kbd> statement without a <kbd>finally</kbd> block like so:</p>
<pre>try<br/>{<br/>    //code block which might trigger exceptions<br/>}<br/>catch (SpecificException ex)<br/>{<br/>   //exception handling code block<br/>  <br/>}</pre>
<p>The system also allows you to use a <kbd>try</kbd> block with a <kbd>finally</kbd> block—<span>there's no</span> need for the <kbd>catch</kbd> exception. This is shown in the following code:</p>
<pre>try<br/>{<br/>    // <span>code block which might trigger exceptions</span><br/>}<br/>finally<br/>{<br/>    // Dispose resources here.<br/>    //Block you want to execute all times irrespective of try block is executed or not.<br/>}</pre>
<p>Last but not least, there's the <kbd>try</kbd>-<kbd>catch</kbd>-<kbd>finally</kbd> block:</p>
<pre>try<br/>{<br/>    // Code that you expect to throw exceptions goes here.<br/>}<br/>catch (SpecificException ex)<br/>{<br/>    // <span>exception handling code block</span><br/>}<br/>finally<br/>{<br/>    // code block that you want to run in all scenarios<br/>}</pre>
<p>A compile-time error is thrown if the runtime identifies incorrect syntax in a <kbd>try</kbd> block; for example, a <kbd>try</kbd> block without a <kbd>catch</kbd> or <kbd>finally</kbd> block during the compilation of the code. When you don't provide a <kbd>catch</kbd> or <kbd>finally</kbd> block, the compiler puts a red mark next to the closing bracket of <kbd>try</kbd> and an error is thrown, as shown in the error list window in the following screenshot:</p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/1bedb9a2-e322-45ac-aa37-b0072f16f25a.png"/></div>
<p class="mce-root"/>
<p>Exception filters are a type of exception that's used to catch in a <kbd>catch</kbd> block. <kbd>System.Exception</kbd> is the base class for any exception type class. As this is the base class, it can hold any exception in the code. We use this when we have code that handles every exception or when we are throwing an exception while calling <kbd>method()</kbd>.</p>
<p>We've already discussed that a <kbd>try</kbd> block can have multiple <kbd>catch</kbd> blocks with different exception filters. When the runtime evaluates the <kbd>catch</kbd> block, it takes a top-to-bottom approach and executes the most specific <kbd>catch</kbd> block that suits the exception that's been caught. If the <kbd>exception</kbd> filter in the <kbd>catch</kbd> block matches the exception that's been thrown or matches the base class of the exception that's been thrown, it's executed. As an exam tip, always remember to place the most specific <kbd>catch</kbd> statements on top and place the generic ones at the bottom.</p>
<p>Understanding the importance of exception handling helps you write proper code that handles every possible scenario and executes it without unexpected behavior occurring. For example, let's say your program is trying to open and write into a file and you receive an exception such as <kbd>File not found</kbd> or <span><kbd>File-in-Use</kbd>. Exception handling allows us to handle these scenarios. In the first case, the prompt asks the user to provide a correct filename, while in the second case, the prompt checks whether it is OK to create a new file.</span></p>
<p>In the following example, a <kbd>for</kbd> loop is throwing an index is out of range exception: </p>
<pre>public static void ExceptionTest5()<br/>{<br/>     string[] strNumbers = new string[] {"One","Two","Three","Four" };<br/>     try<br/>     {<br/>         for (int i = 0; i &lt;= strNumbers.Length; i++)<br/>         {<br/>             Console.WriteLine(strNumbers[i]);<br/>         }<br/>     }<br/>     catch (System.IndexOutOfRangeException e)<br/>     {<br/>         Console.WriteLine("Index is out of range.");<br/>         throw new System.ArgumentOutOfRangeException(<br/>                     "Index is out of range.", e);<br/>     }<br/> }</pre>
<p><span>The code handles it and displays a message on the screen before throwing it so that the invoking method can handle it, like so:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/3af8902a-b937-4084-8b0f-7993dbf386a7.png" style=""/></div>
<p><span>However, our main program doesn't handle the exception system. Instead, it uses the default and displays a dialog box:</span></p>
<div class="CDPAlignCenter CDPAlign"><img src="assets/691694c8-8895-4d6f-b177-50a9b4f6b3ad.png"/></div>
<p>The <kbd>finally</kbd> block releases any variables or objects that were created in the <kbd>try</kbd> block. This block executes last and always runs if present:</p>
<pre>public static void ExceptionTest6()<br/>{<br/>    FileStream inputfile= null;<br/>    FileInfo finfo = new FileInfo("Dummyfile.txt");<br/>    try<br/>    {<br/>        <span>inputfile</span> = <span>finfo </span>.OpenWrite();<br/>        <span>inputfile</span>.WriteByte(0xH);<br/>    }<br/>    finally<br/>    {<br/>        // Check for null because OpenWrite() method might return null.<br/>        if (<span>inputfile</span>!= null)<br/>        {<br/>            <span>inputfile</span>.Close();<br/>        }<br/>    }<br/>}</pre>
<p>In the preceding example, we created a file object in a <kbd>try</kbd> block and tried to write some bytes to it. When the runtime completes the execution of the <kbd>try</kbd> block, it executes a <kbd>finally</kbd> block and releases the <kbd>file</kbd> object that was created in the <kbd>try</kbd> block.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Compiler-generated exceptions</h1>
                </header>
            
            <article>
                
<p><span>Let's go over a few runtime-generated exceptions that .NET Framework supports. The framework uses these exceptions on valid statements that are being executed. Then, based on their type, an exception from the following table is thrown. For example, if the compiler tries to execute a division operation and if the denominator is zero, <kbd>DividebyZeroException</kbd> is thrown:</span></p>
<table border="1" style="border-collapse: collapse;width: 100%">
<tbody>
<tr>
<td>
<p><strong>Exception</strong></p>
</td>
<td>
<p><strong>Description</strong></p>
</td>
</tr>
<tr>
<td>
<p><kbd>ArithmeticException</kbd></p>
</td>
<td>
<p>An exception that's triggered while performing arithmetic operations can be caught.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>ArrayTypeMismatchException</kbd></p>
</td>
<td>
<p>When the value and type of the array don't match, this exception is thrown.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>DivideByZeroException</kbd></p>
</td>
<td>
<p>When an attempt to divide an integer value by zero is made, this exception is thrown.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>IndexOutOfRangeException</kbd></p>
</td>
<td>
<p>When an array is accessed with an index outside of its boundaries, this exception is thrown.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>InvalidCastException</kbd></p>
</td>
<td>
<p><span><span>Converting a base type into an interface or derived type will cause this exception at runtime.</span></span></p>
</td>
</tr>
<tr>
<td>
<p><kbd>NullReferenceException</kbd></p>
</td>
<td>
<p>When you try to access an object that is <kbd>null</kbd>, this exception is thrown.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>OutOfMemoryException</kbd></p>
</td>
<td>
<p>When the available memory for CLR is utilized, the new operator throws such exceptions.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>OverflowException</kbd></p>
</td>
<td>
<p>While performing a division operation, for example, if the output is long and you try to push it to <kbd>int</kbd>, this exception is thrown.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>StackOverflowException</kbd></p>
</td>
<td>
<p>Recursive calls usually cause such exceptions and indicate a very deep or infinite recursion.</p>
</td>
</tr>
<tr>
<td>
<p><kbd>TypeInitializationException</kbd></p>
</td>
<td>
<p>If you try to instantiate an abstract class, for example, this exception is thrown.</p>
</td>
</tr>
</tbody>
</table>
<p> </p>
<p>Now that we've looked at compiler-generated exceptions, let's take a look at custom exceptions.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Custom exceptions</h1>
                </header>
            
            <article>
                
<p>All exceptions are derived from the <kbd>System.Exception</kbd> class in .NET Framework. So, in a scenario where these predefined exceptions don't suit our requirements, the framework allows us to create our own exceptions by deriving our exception class from the <kbd>Exception</kbd> class.</p>
<p>In the following example, we are creating a custom exception and inheriting from the <kbd>Exception</kbd> class. We can use different constructors for this:</p>
<pre>public class MyCustomException : Exception<br/>{<br/>    public MyCustomException():base("This is my custom exception")<br/>    {<br/><br/>    }<br/><br/>    public MyCustomException(string message) <br/>           : base($"This is from the method : {message}")<br/>    {<br/><br/>    }<br/><br/>    public MyCustomException(string message, Exception innerException) <br/>       : base($"Message: {message}, InnerException: {innerException}")<br/>    {<br/>    } <br/>}</pre>
<p class="mce-root"/>
<p>When you create your own exception class, derive from the <kbd>System.Exception</kbd> class, and implement the base class, you get four constructors; implementing the three mentioned is the best practice. In the first instance, the base class message property is initialized by default and a message is displayed. However, in the second and third scenarios, the method that's throwing this custom exception needs to pass these values.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we looked at how we can use the exception class in a program, how we can create custom exceptions to meet our requirements, and different types of exceptions. We also learned about industry standards regarding how to plan and implement exceptions in an application.</p>
<p>In the next chapter, we will understand types and how to create and consume types.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>C# supports <kbd>try</kbd> blocks without<kbd>catch</kbd> and <kbd>finally</kbd> blocks.
<ol>
<li>True</li>
<li>False</li>
</ol>
</li>
<li><kbd>catch</kbd> blocks need to be used in a most-generic-to-least-generic pattern.
<ol>
<li>True</li>
<li>False</li>
</ol>
</li>
<li>If present, a <kbd>finally</kbd> block always executes.
<ol>
<li>True</li>
<li>False</li>
</ol>
</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Answers</h1>
                </header>
            
            <article>
                
<ol>
<li><strong>False</strong></li>
<li><strong>False</strong></li>
<li><strong>True</strong></li>
</ol>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p>While implementing exception handling in your application code, it is important to understand industry standards. Please take a look at the following link to understand these best practices: <a href="https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions">https://docs.microsoft.com/en-us/dotnet/standard/exceptions/best-practices-for-exceptions</a>.</p>


            </article>

            
        </section>
    </body></html>