<html><head></head><body>
		<div><h1 id="_idParaDest-146"><em class="italic"><a id="_idTextAnchor213"/>Chapter 7</em>: Exploring Cross-Cutting Concerns</h1>
			<p>Cross-cutting concerns such as authorization, validation, exception handling, and logging are fundamental parts of any serious system. They are essential to make your system secure and operate well.</p>
			<p>One problem with implementing cross-cutting concerns is that you should implement these concerns everywhere in your application, which leads to a repetitive code base. Also, one missing authorization or validation check may explode your entire system.</p>
			<p>One of ABP Framework's main goals is to help you apply the <strong class="bold">Don't Repeat Yourself</strong> (<strong class="bold">DRY</strong>) principle! ASP.NET Core already provides a good infrastructure for some cross-cutting concerns, but ABP takes it further to automate or make them much easier for you.</p>
			<p>This chapter explores ABP's infrastructure for the following cross-cutting concerns:</p>
			<ul>
				<li>Working with authorization and permission systems</li>
				<li>Validating user inputs</li>
				<li>Exception handling</li>
			</ul>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor214"/>Technical requirements</h1>
			<p>If you want to follow along and try the examples, you need to install an <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE</strong>)/editor (for example, Visual Studio) to build the ASP.NET Core projects.</p>
			<p>You can download the code examples from the following GitHub repository: <a href="https://github.com/PacktPublishing/Mastering-ABP-Framework">https://github.com/PacktPublishing/Mastering-ABP-Framework</a>.</p>
			<p>This chapter also references the <em class="italic">EventHub</em> project for some code examples. That project was introduced in <a href="B17287_04_Epub_AM.xhtml#_idTextAnchor130"><em class="italic">Chapter 4</em></a>, <em class="italic">Understanding the Reference Solution</em>, and you can access its source code from the following GitHub repository: <a href="https://github.com/volosoft/eventhub">https://github.com/volosoft/eventhub</a>.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor215"/>Working with authorization and permission systems</h1>
			<p><strong class="bold">Authentication</strong> and <strong class="bold">authorization</strong> are two major concepts in software security. Authentication is the process <a id="_idIndexMarker405"/>of identifying the current user. On the <a id="_idIndexMarker406"/>other hand, authorization is used to allow or prohibit a user <a id="_idIndexMarker407"/>from performing a specific action in the application.</p>
			<p>ASP.NET Core's authorization system provides an advanced and flexible way to authorize the current user. ABP Framework's authorization infrastructure is 100% compatible with ASP.NET Core's authorization system and extends it by introducing the permission system. ABP allows permissions to be easily granted to roles and users. It allows the same permissions to be checked on the client side too.</p>
			<p>I will explain the authorization system as a mix of ASP.NET Core's and ABP's infrastructure by indicating which part is added by ABP Framework. Let's begin with the simplest authorization check.</p>
			<h2 id="_idParaDest-149"><a id="_idTextAnchor216"/>Simple authorization</h2>
			<p>In the simplest case, you may want to <a id="_idIndexMarker408"/>allow a certain operation only for <a id="_idIndexMarker409"/>those logged in to the application. The <code>[Authorize]</code> attribute, without any parameters, only checks whether the current user has been authenticated (logged in).</p>
			<p>See the following <strong class="bold">model-view-controller</strong> (<strong class="bold">MVC</strong>) example:</p>
			<pre>public class ProductController : Controller
{
    public async Task&lt;List&lt;ProductDto&gt;&gt; GetListAsync()
    {
    }
    [Authorize]
    public async Task CreateAsync(ProductCreationDto input)
    {
    }    
    [Authorize]
    public async Task DeleteAsync(Guid id)
    {
    }
}</pre>
			<p>In this example, the <code>CreateAsync</code> and <code>DeleteAsync</code> actions are only usable by authenticated users. Suppose <a id="_idIndexMarker410"/>an anonymous user (a user that has not logged <a id="_idIndexMarker411"/>in to the application, so we couldn't identify them) tries to execute these actions. In that case, ASP.NET Core returns an authorization error response to the client. However, the <code>GetListAsync</code> method is available to everyone, even to anonymous users.</p>
			<p>The <code>[Authorize]</code> attribute can be used at the controller class level to authorize all the actions inside that controller. In that case, we can use the <code>[AllowAnonymous]</code> attribute to allow a specific action to anonymous users. So, we could rewrite the same example, as shown in the following code block:</p>
			<pre>[Authorize]
public class ProductController : Controller
{
    [AllowAnonymous]
    public async Task&lt;List&lt;ProductDto&gt;&gt; GetListAsync()
    {
    }
    public async Task CreateAsync(ProductCreationDto input)
    {
    }
    
    public async Task DeleteAsync(Guid id)
    {
    }
}</pre>
			<p>Here, I used the <code>[Authorize]</code> attribute on top of the class and added <code>[AllowAnonymous]</code> to the <code>GetListAsync</code> method. This makes it possible to also consume that particular action for users who haven't logged in to the application.</p>
			<p>While the <a id="_idIndexMarker412"/>parameterless <code>[Authorize]</code> attribute has some use cases, you <a id="_idIndexMarker413"/>generally want to define specific permissions (or policies) in your application so that all authenticated users don't have the same privileges.</p>
			<h2 id="_idParaDest-150"><a id="_idTextAnchor217"/>Using the permission system</h2>
			<p>The most important authorization extension of ABP Framework for ASP.NET Core is the permission system. A permission is a simple policy that is granted or prohibited for a particular user or role. It is <a id="_idIndexMarker414"/>then associated with a particular functionality of your application and is checked when users try to use that functionality. If the current user has the related permission granted, then the user can use the application functionality. Otherwise, the user cannot use that functionality.</p>
			<p>ABP provides all the functionality to define, grant, and check permissions in your application.</p>
			<h3>Defining permissions</h3>
			<p>We should define permissions before <a id="_idIndexMarker415"/>using them. To define permissions, create a class that inherits from the <code>PermissionDefinitionProvider</code> class. When you create a new ABP solution, an empty permission definition provider class comes in the <code>Application.Contracts</code> project of the solution. See the followin<a id="_idTextAnchor218"/>g example:</p>
			<pre>public class ProductManagementPermissionDefinitionProvider
    : PermissionDefinitionProvider
{
    public override void Define(
        IPermissionDefinitionContext context)
    {
        var myGroup = context.AddGroup(
            "ProductManagement");
        myGroup.AddPermission(
            "ProductManagement.ProductCreation");
        myGroup.AddPermission(
            "ProductManagement.ProductDeletion");
    }
}</pre>
			<p>ABP Framework calls the <code>Define</code> method on application startup. In this example, I've created a permission group, named <code>ProductManagement</code>, and defined two permissions inside it. Groups are <a id="_idIndexMarker416"/>used to group permissions on the <code>string</code> values (it is suggested to define <code>const</code> fields instead of using magic strings).</p>
			<p>That was a minimal configuration. You can also specify display names as localizable strings for the group, and permission names to show them in a user-friendly way on the UI. The following code block uses the localization system to specify the display names while defining the group and the p<a id="_idTextAnchor219"/>ermissions:</p>
			<pre>public class ProductManagementPermissionDefinitionProvider
    : PermissionDefinitionProvider
{
    public override void Define(
        IPermissionDefinitionContext context)
    {
        var myGroup = context.AddGroup(
            «ProductManagement»,
            L("ProductManagement"));
        myGroup.AddPermission(
            "ProductManagement.ProductCreation",
            L("ProductCreation"));
        myGroup.AddPermission(
            "ProductManagement.ProductDeletion",
            L("ProductDeletion"));
    }
    
    private static LocalizableString L(string name)
    {
        return LocalizableString
            .Create&lt;ProductManagementResource&gt;(name);
    }
}</pre>
			<p>I've defined an <code>L</code> method to <a id="_idIndexMarker417"/>simplify the localization. The localization system will be covered in <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<p class="callout-heading">Permission Definitions in Multi-Tenant Applications</p>
			<p class="callout">For multi-tenant applications, you can specify the <code>multiTenancySide</code> parameter for the <code>AddPermission</code> method, to define host-only or tenant-only permissions. We will return to this topic in <a href="B17287_16_Epub_AM.xhtml#_idTextAnchor457"><em class="italic">Chapter 16</em></a>, <em class="italic">Implementing Multi-Tenancy</em>.</p>
			<p>Once you define a permission, it becomes available on the permission management dialog after the next application startup.</p>
			<h3>Managing permissions</h3>
			<p>A permission can be granted for a user or role by default. For example, assume that you have created a manager <a id="_idIndexMarker418"/>role and want to grant the product permissions for that role. When you run the application, navigate to the <code>manager</code> role if you haven't created it before; to do so, click on the <strong class="bold">Actions</strong> button and select the <strong class="bold">Permissions</strong> action, as shown in <em class="italic">Figure 7.1</em>:</p>
			<div><div><img src="img/Figure_7.1_B17287.jpg" alt="Figure 7.1 – Selecting the Permissions action on the Role Management page&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1 – Selecting the Permissions action on the Role Management page</p>
			<p>Clicking on the <strong class="bold">Permissions</strong> action opens a modal dialog to manage the permissions of the selected role, as shown here:</p>
			<div><div><img src="img/Figure_7.2_B17287.jpg" alt="Figure 7.2 – Permission Management modal&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2 – Permission Management modal</p>
			<p>In <em class="italic">Figure 7.2</em>, you see the permission groups on the left-hand side, while the permissions in this group <a id="_idIndexMarker419"/>are available on the right-hand side. The permission group and the permissions we've defined are available in this dialog box without any additional effort.</p>
			<p>All users with the manager role inherit the permissions of that role. Users can have multiple roles, and they inherit a union of all permissions of all the assigned roles. You can also grant permissions directly to the users on the user management page for more flexibility.</p>
			<p>We've defined permissions and assigned them to roles. The next step is to check whether the current user has the requested permissions.</p>
			<h3>Checking permissions</h3>
			<p>You can check a permission <a id="_idIndexMarker420"/>either declaratively, using the <code>[Authorize]</code> attribute, or programmatically, using <code>IAuthorizationService</code>.</p>
			<p>We can rewrite the <code>ProductController</code> class (which was introduced in the <em class="italic">Simple authorization</em> section) to request the product creation and deletion permissions on specific actions, as follows:</p>
			<pre>public class ProductController : Controller
{
    public async Task&lt;List&lt;ProductDto&gt;&gt; GetListAsync()
    {
    }
    [Authorize("ProductManagement.ProductCreation")]
    public async Task CreateAsync(ProductCreationDto input)
    {
    }    
    [Authorize("ProductManagement.ProductDeletion")]
    public async Task DeleteAsync(Guid id)
    {
    }
}</pre>
			<p>The <code>[Authorize]</code> attribute, with <a id="_idIndexMarker421"/>this usage, takes a string parameter as a policy name. ABP defines permissions as automatic policies, so you can use a permission name wherever you need to specify a policy name.</p>
			<p>Declarative authorization is simple to use and recommended wherever possible. However, it is limited when you want to check permissions or perform logic for unauthorized cases conditionally. For such cases, you can inject and use <code>IAuthorizationService</code>, as shown in the foll<a id="_idTextAnchor220"/>owing example:</p>
			<pre>public class ProductController : Controller
{
    private readonly IAuthorizationService 
        _authorizationService;
    public ProductController(
        IAuthorizationService authorizationService)
    {
        _authorizationService = authorizationService;
    }
    
    public async Task CreateAsync(ProductCreationDto input)
    {
        if (await _authorizationService.IsGrantedAsync(  
            "ProductManagement.ProductCreation"))
        {
            // TODO: Create the product
        }
        else
        {
            // TODO: Handle unauthorized case
        }
    }
}</pre>
			<p>The <code>IsGrantedAsync</code> method checks the given permission and returns <code>true</code> if the current user (or a role of the user) has been granted the current permission. This is useful if you have custom <a id="_idIndexMarker422"/>logic for an unauthorized case. However, if you want to simply check the permission and throw an exception for unauthorized cases, the <code>CheckAsync</code> method is more practical:</p>
			<pre>public async Task CreateAsync(ProductCreationDto input)
{
    await _authorizationService
        .CheckAsync("ProductManagement.ProductCreation");
    //TODO: Create the product
}</pre>
			<p>The <code>CheckAsync</code> method throws an <code>AbpAuthorizationException</code> exception if the user doesn't have <a id="_idIndexMarker423"/>permission to carry out that operation, which is handled by ABP Framework to return a proper <code>IsGrantedAsync</code> and <code>CheckAsync</code> methods are useful extension methods defined by ABP Framework.</p>
			<p class="callout-heading">Tip: Inherit from AbpController</p>
			<p class="callout">It is suggested to derive your controller classes from the <code>AbpController</code> class instead of the standard <code>Controller</code> class. This extends the standard <code>Controller</code> class and defines some useful base properties. For example, it has the <code>AuthorizationService</code> property (of the <code>IAuthorizationService</code> type), which you can directly use instead of manually injecting the <code>IAuthorizationService</code> interface.</p>
			<p>Checking permissions on the server is a common approach. However, you may also need to check permissions on the client side.</p>
			<h3>Using permissions on the client side</h3>
			<p>ABP exposes a standard HTTP API with a URL of <code>/api/abp/application-configuration</code>, which <a id="_idIndexMarker424"/>returns JSON data containing localization <a id="_idIndexMarker425"/>texts, settings, permissions, and more. Then, the client application can consume that API to check permissions or perform localization on the client side.</p>
			<p>Different client types may provide different services to check permissions. For example, in an MVC/Razor Pages application, you can use the <code>abp.auth</code> JavaScript API to check a permission, as illustrated here:</p>
			<pre>abp.auth.isGranted('ProductManagement.ProductCreation');</pre>
			<p>This is a global <a id="_idIndexMarker426"/>function that returns <code>true</code> if the current user has <a id="_idIndexMarker427"/>the given permission. Otherwise, it returns <code>false</code>.</p>
			<p>In a Blazor application, you can reuse the same <code>[Authorize]</code> attribute and <code>IAuthorizationService</code>.</p>
			<p>We will return to client-side permission checking in <em class="italic">Part 4</em>, <em class="italic">User Interface and API Development</em>.</p>
			<h3>Child permissions</h3>
			<p>In a complex application, you <a id="_idIndexMarker428"/>may need to create some child permissions that depend <a id="_idIndexMarker429"/>on their parent permissions. The child <a id="_idIndexMarker430"/>permissions are meaningful only if the parent permission has been granted. See <em class="italic">Figure 7.3</em>:</p>
			<div><div><img src="img/Figure_7.3_B17287.jpg" alt="Figure 7.3 – Parent-child permissions&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3 – Parent-child permissions</p>
			<p>In <em class="italic">Figure 7.3</em>, the <strong class="bold">Role management</strong> permission <a id="_idIndexMarker431"/>has some child permissions such as <strong class="bold">Create</strong>, <strong class="bold">Edit</strong>, and <strong class="bold">Delete</strong>. The <strong class="bold">Role management</strong> permission <a id="_idIndexMarker432"/>is used to allow a user to enter the <strong class="bold">Role Management</strong> page. If the user cannot enter the page, then there is no point in granting the <a id="_idIndexMarker433"/>role creation permission, since it is practically impossible to create a new role without entering that page.</p>
			<p>In the permission definition class, the <code>AddPermission</code> method returns the created permission so that you can assign it to a variable and use the <code>AddChild</code> method to create a child permission, as shown in the following code block:</p>
			<pre>public override void Define(IpermissionDefinitionContext
                            context)
{
    var myGroup = context.AddGroup(
        "ProductManagement",
        L("ProductManagement"));
    var parent = myGroup.AddPermission(
        "MyParentPermission");
    parent.AddChild("MyChildPermission");
}</pre>
			<p>In this example, we've created a permission named <code>MyParentPermission</code>, then created another permission named <code>MyChildPermission</code> as a child permission.</p>
			<p>Child permissions can also <a id="_idIndexMarker434"/>have child permissions. You can assign the <a id="_idIndexMarker435"/>return value of the <code>parent.AddChild</code> method <a id="_idIndexMarker436"/>to a variable and call its <code>AddChild</code> method.</p>
			<p>Defining and using permissions is an easy yet powerful way to authorize an application via simple on/off-style policies. However, ASP.NET Core allows the creation of complete custom logic to define policies.</p>
			<h2 id="_idParaDest-151"><a id="_idTextAnchor221"/>Policy-based authorization</h2>
			<p>The ASP.NET Core <strong class="bold">policy-based authorization</strong> system allows you to authorize certain operations <a id="_idIndexMarker437"/>in your application, just as with permissions, but this <a id="_idIndexMarker438"/>time, with your custom logic expressed with code. Actually, a permission is a simplified and automated policy provided by ABP Framework.</p>
			<p>Assume that you want to authorize a <em class="italic">product creation</em> operation with your custom code. You first need to define a requirement that you will check later (we can define these classes in the application layer of the solution, while there is no strict rule). The code is illustr<a id="_idTextAnchor222"/>ated in the following snippet:</p>
			<pre>public class ProductCreationRequirement : 
    IAuthorizationRequirement
{ }</pre>
			<p><code>ProductCreationRequirement</code> is an empty class that just implements the <code>IAuthorizationRequirement</code> marker interface. Then, you should define an authorization handler for<a id="_idTextAnchor223"/> that requirement, as follows:</p>
			<pre>public class ProductCreationRequirementHandler 
    : AuthorizationHandler&lt;ProductCreationRequirement&gt;
{
    protected override Task HandleRequirementAsync(
        AuthorizationHandlerContext context,
        ProductCreationRequirement requirement)
    {
        if (context.User.HasClaim(c =&gt; c.Type == 
            "productManager"))
        {
            context.Succeed(requirement);
        }
        
        return Task.CompletedTask;
    }
}</pre>
			<p>The handler class must be derived from <code>AuthorizationHandler&lt;T&gt;</code>, where <code>T</code> is the type of your <a id="_idIndexMarker439"/>requirement class. In this example, I simply checked whether <a id="_idIndexMarker440"/>the current user has the <code>productManager</code> claim, which is my custom claim (a claim is a simple named value stored in the authentication ticket). You can build your custom logic. All you're going to do is call <code>context.Succeed</code> if you want to allow the current user to have the requirement.</p>
			<p>Once you define a requirement and handler, you need to register them in the <code>ConfigureServices</code> method of your module class, like this:</p>
			<pre>public override void ConfigureServices(
    ServiceCon<a id="_idTextAnchor224"/>figurationContext context)
{
    Configure&lt;AuthorizationOptions&gt;(options =&gt;
    {
        options.AddPolicy(
            "ProductManagement.ProductCreation",
            policy =&gt; policy.Requirements.Add(
                new ProductCreationRequirement()
            )
        );
    });
    context.Services.AddSingleton&lt;IAuthorizationHandler, 
        ProductCreationRequirementHandler&gt;();
}</pre>
			<p>I've used <code>AuthorizationOptions</code> to define a policy named <code>ProductManagement.ProductCreation</code> with the <code>ProductCreationRequirement</code> requirement. Then, I've registered <code>ProductCreationRequirementHandler</code> as a singl<a id="_idTextAnchor225"/>eton service.</p>
			<p>Now, suppose I use the <code>[Authorize("ProductManagement.ProductCreation")]</code> attribute on a controller or action <a id="_idIndexMarker441"/>or use <code>IAuthorizationService</code> to <a id="_idIndexMarker442"/>check the policy. In that case, my custom authorization handler logic works to allow me to take complete control of the policy-check logic.</p>
			<p class="callout-heading">Permissions versus Custom Policies</p>
			<p class="callout">Once you implement a <a id="_idIndexMarker443"/>custom policy, you cannot use the permission <a id="_idIndexMarker444"/>management dialog to grant permission to users and roles because it is not a simple on/off permission that you can enable/disable. However, a client-side policy check still works, since ABP is well integrated into ASP.NET Core's policy system.</p>
			<p>As you can see, ABP's permission system is much easier and more powerful if you just need on/off-style policies, while <a id="_idIndexMarker445"/>custom policies allow you to dynamically <a id="_idIndexMarker446"/>check policies with your custom logic.</p>
			<p class="callout-heading">Resource-Based Authorization</p>
			<p class="callout">ASP.NET Core's authorization system has more features than covered here. Resource-based authorization is one feature that allows you to control policies based on objects (such as entities). For example, you <a id="_idIndexMarker447"/>can control access to delete a specific product, rather than having a common deleting permission for all products. ABP is 100% compatible with the ASP.NET Core authorization system, so I suggest you check ASP.NET Core's documentation <a id="_idIndexMarker448"/>to learn more about authorization: <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization">https://docs.microsoft.com/en-us/aspnet/core/security/authorization</a>.</p>
			<p>Up to now, we've seen the usage of the <code>[Authorize]</code> attribute on MVC controllers. However, this attribute and <code>IAuthorizationService</code> are not limited to controllers.</p>
			<h2 id="_idParaDest-152"><a id="_idTextAnchor226"/>Authorizations outside of controllers</h2>
			<p>ASP.NET Core allows <a id="_idIndexMarker449"/>you to use the <code>[Authorize]</code> attribute and <code>IAuthorizationService</code> for Razor Pages, Razor components, and some other points in the web layer. You can refer to ASP.NET Core's documentation to learn about these standard usages: <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization">https://docs.microsoft.com/en-us/aspnet/core/security/authorization</a>.</p>
			<p>ABP Framework takes it one step further and allows using the <code>[Authorize]</code> attribute for the application service classes and methods without depending on the web layer, even in a non-web application. So, this usage is completely valid, as illustrated here:</p>
			<pre>public class ProductAppService
    : ApplicationService, IProductAppService
{
    [Authorize("ProductManagement.ProductCreation")]
    public Task CreateAsync(ProductCreationDto input)
    {
        // TODO
    }
}</pre>
			<p>The <code>CreateAsync</code> method can <a id="_idIndexMarker450"/>only be executed if the current user has the <code>ProductManagement.ProductCreation</code> permission/policy. Actually, <code>[Authorize]</code> is usable in any class that is registered for <strong class="bold">dependency injection</strong> (<strong class="bold">DI</strong>). However, since authorization is considered an application layer aspect, it is <a id="_idIndexMarker451"/>recommended that authorization be used at the application layer and not at the domain layer.</p>
			<p class="callout-heading">Dynamic Proxying/Interceptors</p>
			<p class="callout">ABP uses dynamic proxying using interceptors to accomplish the authorization check on method calls. If you inject a <a id="_idIndexMarker452"/>service via a class reference (rather than an interface reference), the dynamic proxying system uses the dynamic inheritance technique. In this case, your method must be defined with the <code>virtual</code> keyword to allow the dynamic proxying system to override it and perform the authorization check.</p>
			<p>The authorization system guarantees that only authorized users consume your services. It is one of the systems that you need to use to secure your application, while the other one is input validation.</p>
			<h1 id="_idParaDest-153"><a id="_idTextAnchor227"/>Validating user inputs</h1>
			<p>Validation ensures your data <a id="_idIndexMarker453"/>security and consistency and helps your application to operate properly. Validation is a wide topic, and there are some common levels of validation, as outlined here:</p>
			<ul>
				<li><strong class="bold">Client-side validation</strong> is used to <a id="_idIndexMarker454"/>pre-validate the user input before sending data to the server. It is important for the <strong class="bold">user experience</strong> (<strong class="bold">UX</strong>), and you should always implement it wherever possible. However, it cannot guarantee security—even an inexperienced hacker can bypass it. For example, checking whether a required textbox field is empty is a type of client-side validation. We will cover client-side validation in <em class="italic">Part 4</em>, <em class="italic">User Interface and API Development</em>.</li>
				<li><strong class="bold">Server-side validation</strong> is performed by the server to prevent incomplete, badly formatted, or <a id="_idIndexMarker455"/>malicious requests. It provides some level of security for your application and is generally performed when you first touch the data sent by the client. For example, checking a required input field is empty on the server side is an example of this type of validation.</li>
				<li><strong class="bold">Business validation</strong> is also performed in the server; it implements your business rules and keeps <a id="_idIndexMarker456"/>your business data consistent. It is done at every level of your business code. For example, checking a user's balance before a money transfer is a kind of business validation. We will cover business validation in <a href="B17287_10_Epub_AM.xhtml#_idTextAnchor316"><em class="italic">Chapter 10</em></a>, <em class="italic">DDD – The Domain Layer</em>.<p class="callout-heading">About the ASP.NET Core Validation System</p><p class="callout">ASP.NET Core provides many options for input validation. This book covers the basics by focusing on the features added by ABP Framework. See ASP.NET Core's <a id="_idIndexMarker457"/>documentation for all the validation possibilities: <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation">https://docs.microsoft.com/en-us/aspnet/core/mvc/models/validation</a>.</p></li>
			</ul>
			<p>This section focuses on server-side validation and shows how to perform input validation in different ways. It also explores ways to control the validation process and deal with validation exceptions.</p>
			<p>Let's start with the easiest way to perform validation—using data annotation attributes.</p>
			<h2 id="_idParaDest-154"><a id="_idTextAnchor228"/>Using data annotation attributes</h2>
			<p>Using data annotation <a id="_idIndexMarker458"/>attributes is the simplest way to perform a formal validation for the user input. See the following application service method:</p>
			<pre>public class ProductAppService
    : ApplicationService, IProductAppService
{
    public Task CreateAsync(ProductCreationDto input)
    {
        // TODO
    }
}</pre>
			<p><code>ProductAppService</code> is an application service, and the application service inputs are automatically validated in ABP Framework, just as with controllers in the ASP.NET Core MVC framework. The <code>ProductAppService</code> service takes an input parameter, as shown in the following code block:</p>
			<pre>public class ProductCreationDto
{
    [Required]
    [StringLength(100)]
    public string Name { get; set; }
    
    [Range(0, 999.99)]
    public decimal Price { get; set; }
    
    [Url]
    public string PictureUrl { get; set; }
    public bool IsDraft { get; set; }
}</pre>
			<p><code>ProductCreationDto</code> has <a id="_idIndexMarker459"/>three properties decorated with validation attributes. There are many built-in validation attributes of ASP.NET Core, including the following:</p>
			<ul>
				<li><code>[Required]</code>: Validates that the property is not null</li>
				<li><code>[StringLength]</code>: Validates a maximum (and optionally minimum) length for a string property</li>
				<li><code>[Range]</code>: Validates that the property value is in the specified range</li>
				<li><code>[Url]</code>: Validates that the property value has a proper URL format</li>
				<li><code>[RegularExpression]</code>: Allows the specifying of a custom <strong class="bold">regular expression</strong> (<strong class="bold">regex</strong>) to validate <a id="_idIndexMarker460"/>the property value</li>
				<li><code>[EmailAddress]</code>: Validates that the property has a properly formatted email address value</li>
			</ul>
			<p>ASP.NET Core also allows you to define custom validation attributes by inheriting them from the <code>ValidationAttribute</code> class and overriding the <code>IsValid</code> method.</p>
			<p>Data annotation attributes <a id="_idIndexMarker461"/>are very easy to use and are suggested to perform formal validation for your <strong class="bold">data transfer objects</strong> (<strong class="bold">DTOs</strong>) and models. However, they are limited when you need to perform custom code lo<a id="_idTextAnchor229"/>gic to validate the input.</p>
			<h2 id="_idParaDest-155"><a id="_idTextAnchor230"/>Custom validation with the IValidatableObject interface</h2>
			<p>A model or DTO <a id="_idIndexMarker462"/>object can implement <a id="_idIndexMarker463"/>the <code>IValidatableObject</code> interface to perform validation using a custom code block. See the following example:</p>
			<pre>public clas<a id="_idTextAnchor231"/>s ProductCreationDto : IValidatableObject
{
    ...
    [Url]
    public string PictureUrl { get; set; }    
    public bool IsDraft { get; set; }    
    public IEnumerable&lt;ValidationRes<a id="_idTextAnchor232"/>ult&gt; Validate(
        ValidationContext context)
    {
        if (IsDraft == false &amp;&amp;
            string.IsNullOrEmpty(PictureUrl))
        {
            yield return new ValidationResult(
                "Picture must be provided to publish a
                 product",
                new []{ nameof(PictureUrl) }
            );
        }
    }
}</pre>
			<p>In this example, <code>ProductCreationDto</code> has a custom rule: a profile picture is required if <code>IsDraft</code> is <code>false</code>. So, we are checking the condition and adding a validation error in this case.</p>
			<p>If you need to resolve <a id="_idIndexMarker464"/>a service from the <a id="_idIndexMarker465"/>DI system, you can use the <code>context.GetRequiredService</code> method. For example, if we want to localize the error message, we can rewrite the <code>Validate</code> method, as shown in the following code block:</p>
			<pre>public IEnumerable&lt;Val<a id="_idTextAnchor233"/>idationResult&gt; Validate(
    ValidationContext context)
{
    if (IsDraft == false &amp;&amp;
        string.IsNullOrEmpty(PictureUrl))
    {
        var localizer = context.GetRequiredService
            &lt;IStringLocalizer&lt;ProductManagementResource&gt;
            &gt;();
        
        yield return new ValidationResult(
            localizer["PictureIsMissingErrorMessage"],
            new []{ nameof(PictureUrl) }
        );
    }
}</pre>
			<p>Here, we resolve an <code>IStringLocalizer&lt;ProductManagementResource&gt;</code> instance from <a id="_idIndexMarker466"/>the DI and use it to return a localized <a id="_idIndexMarker467"/>error message to the client. We will cover the localization system in <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<p class="callout-heading">Formal Validation versus Business Validation</p>
			<p class="callout">As a best practice, implement only formal validation (such as if a DTO property was not filled or not formatted <a id="_idIndexMarker468"/>as expected) in the DTO/model classes <a id="_idIndexMarker469"/>and use only the data already available on the DTO/model class. Implement your business validation logic inside application or domain layer services. For example, if you want to check whether a given product name already exists in the database, do not try to implement this logic in the <code>Validate</code> method.</p>
			<p>Using either the validation <a id="_idIndexMarker470"/>attributes or <a id="_idIndexMarker471"/>custom validation logic, ABP Framework handles the validation result and throws an exception prior to the execution of your method.</p>
			<h2 id="_idParaDest-156"><a id="_idTextAnchor234"/>Understanding the validation exception</h2>
			<p>If the user input is not valid, ABP Framework <a id="_idIndexMarker472"/>automatically throws an exception of the <code>AbpValidationException</code> type. The exception is thrown in the following situations:</p>
			<ul>
				<li>The input object is <code>null</code>, so you don't need to check whether it is <code>null</code>.</li>
				<li>The input object is invalid in any way, so you don't have to check <code>Model.IsValid</code> in your API controllers.</li>
			</ul>
			<p>ABP doesn't call your service method (or controller action) in these cases. If your method is being executed, you can be sure that the input is not null and is valid.</p>
			<p>If you perform additional validation inside your services and want to throw a validation-related exception, you can also throw <code>AbpValidationException</code>, as illustrated in the following code sn<a id="_idTextAnchor235"/>ippet:</p>
			<pre>public async Task CreateAsync(ProductCreationDto input)
{
    if (await HasExistingProductAsync(input.Name))
    {
        throw new AbpValidationException(
            new List&lt;ValidationResult&gt;
            {
                new ValidationResult(
                    "Product name is already in use!",
                    new[] {nameof(input.Name)}
                )
            }
        );
    }
}</pre>
			<p>Here, we are assuming that <code>HasExistingProductAsync</code> returns <code>true</code> if there is a product with the given name. In this case, we are throwing <code>AbpValidationException</code> by specifying the validation error(s). <code>ValidationResult</code> represents <a id="_idIndexMarker473"/>a validation error; its first constructor parameter is the validation error message, and the second parameter (optional) is the name of the DTO properties that caused the validation error.</p>
			<p>Once you or the ABP validation system throws an <code>AbpValidationException</code> exception, the ABP exception-handling system catches and handles it properly, as we will see in the next section.</p>
			<p>The ABP validation system works just as you want most of the time, but <a id="_idTextAnchor236"/>sometimes, you may need to bypass it and apply your custom logic.</p>
			<h2 id="_idParaDest-157"><a id="_idTextAnchor237"/>Disabling the validation</h2>
			<p>It is possible to bypass the <a id="_idIndexMarker474"/>ABP validation system at a method or class level usi<a id="_idTextAnchor238"/>ng the <code>[DisableValidation]</code> attribute, as in the following example:</p>
			<pre>[DisableValidation]
public async Task CreateAsync(ProductCreationDto input)
{
}</pre>
			<p>In this example, the <code>CreateAsync</code> method is decorated with the <code>[DisableValidation]</code> attribute, so ABP doesn't perform any automatic validation for the <code>input</code> object.</p>
			<p>If you use the <code>[DisableValidation]</code> attribute for a class, then the validation is disabled for all the <a id="_idIndexMarker475"/>methods. In this case, you can use the <code>[EnableValidation]</code> attribute for a method to enable validation only for that particular method.</p>
			<p>When you disable auto-validation for a method, you can still perform your custom validation logic and throw <code>AbpValidationException</code>, as explained in the previous section.</p>
			<h2 id="_idParaDest-158"><a id="_idTextAnchor239"/>Validation in other types</h2>
			<p>ASP.NET Core performs validation for controller actions and Razor Page handlers. ABP, in addition to ASP.NET Core, performs validation for application service methods by default.</p>
			<p>Beyond the default <a id="_idIndexMarker476"/>behavior, ABP allows you to enable the auto-validation feature for any kind of class in your application. All you need to do is to implement the <code>IValidationEnabled</code> marker interface, as shown in the following example:</p>
			<pre>public class SomeServiceWithValidation
    : IValidationEnabled, ITransientDependency
{
    ...
}</pre>
			<p>Then, ABP auto-validates all the inputs for this class, using the validation system explained in this chapter.</p>
			<p class="callout-heading">Dynamic Proxying/Interceptors</p>
			<p class="callout">ABP uses dynamic proxying using interceptors to accomplish validation on method calls. If you inject a <a id="_idIndexMarker477"/>service via a class reference (rather than an interface reference), the dynamic <a id="_idIndexMarker478"/>proxying system uses the dynamic inheritance technique. In this case, your method must be defined with the <code>virtual</code> keyword to allow the dynamic proxying system to override it and perform the validation.</p>
			<p>Up to now, we've explained the ABP validation system that is directly compatible with ASP.NET Core's validation <a id="_idIndexMarker479"/>infrastructure. The next section introduces <code>FluentValidation</code> library integration, which allows you to separate the validation logic from the validated object.</p>
			<h2 id="_idParaDest-159"><a id="_idTextAnchor240"/>Integrating the FluentValidation library</h2>
			<p>The built-in validation system is enough for most cases, and it is easy to use to define formal validation rules. I personally <a id="_idIndexMarker480"/>don't see any problem with it and find it practical to embed the data validation logic inside DTO/model classes. However, some developers think that the validation logic inside DTO/model classes is a bad practice, even when it is only a formal validation. In this case, ABP provides an integration package with the popular <code>FluentValidation</code> library, which decouples the validation logic from the DTO/model class and provides more powerful features compared to the standard data annotation approach. </p>
			<p>If you want to use the <code>FluentValidation</code> library, you first need to install it into your project. You can <a id="_idIndexMarker481"/>use the <code>add-package</code> command of the <strong class="bold">ABP Command-Line Interface</strong> (<strong class="bold">ABP CLI</strong>) to install it for a project easily, as follows:</p>
			<pre>abp add-package Volo.Abp.FluentValidation</pre>
			<p>Once you install the package, you can create your validator cla<a id="_idTextAnchor241"/>sses and set your validation rules, as shown in the following code block:</p>
			<pre>public class ProductCreationDtoValidator
    : AbstractValidator&lt;ProductCreationDto&gt;
{
    public ProductCreationDtoValidator()
    {
        RuleFor(x =&gt; x.Name).NotEmpty().MaximumLength(100);
        RuleFor(x =&gt; x.Price).ExclusiveBetween(0, 1000);
        //...
    }
}</pre>
			<p>Please refer to <a id="_idIndexMarker482"/>the <code>FluentValidation</code> documentation to learn how to define advanced validation rules: <a href="https://fluentvalidation.net">https://fluentvalidation.net</a>.</p>
			<p>ABP automatically discovers the validator classes and integrates them into the validation process. That means you <a id="_idIndexMarker483"/>can even mix the standard validation logic with the <code>FluentValidation</code> validator classes.</p>
			<p>Authorization and validation exceptions are well-defined exception types, and ABP automatically handles them. The next section explores the ABP exception-handling system and explains how to deal with different kinds of exceptions.</p>
			<h1 id="_idParaDest-160"><a id="_idTextAnchor242"/>Exception handling</h1>
			<p>One of the most important quality indicators of an application is how it responds to errors and exceptional <a id="_idIndexMarker484"/>cases. A good application should handle errors, return a proper response to the client, and gracefully inform the user about the problem.</p>
			<p>In a typical web application, we should care about exceptions in every client request, which makes it a repetitive and tedious task for developers.</p>
			<p>ABP Framework completely automates error handling in every aspect of your application. Most of the time, you don't need to write any <code>try-catch</code> statement in your application code, as it does the following:</p>
			<ul>
				<li>Handles all exceptions, logs them, and returns a standard-formatted error response to the client for an API request or shows a standard error page for a server-rendered page</li>
				<li>Hides internal infrastructure errors while allowing you to return user-friendly, localized error messages when you need them</li>
				<li>Understands standard exceptions such as validation and authorization exceptions and sends a proper HTTP status code to the client</li>
				<li>Handles all errors on the client and shows a meaningful message to the end user</li>
			</ul>
			<p>While ABP takes care <a id="_idIndexMarker485"/>of exceptions, you can throw exceptions to return user-friendly messages or business-specific error codes to the client.</p>
			<h2 id="_idParaDest-161"><a id="_idTextAnchor243"/>User-friendly exceptions</h2>
			<p>ABP provides some <a id="_idIndexMarker486"/>predefined exception classes to customize the error-handling behavior. One of these is the <code>UserFriendlyException</code> class.</p>
			<p>First, to understand the need for the <code>UserFriendlyException</code> class, see what happens if an arbitrary exception is thrown from a server-side API. The following method throws an exception with a custom message:</p>
			<pre>Public async Task ExampleAsync()
{
    throw new Exception("my error message...");
}</pre>
			<p>Assume that a browser client calls that method via an AJAX request. It will show the following error message to the end user:</p>
			<div><div><img src="img/Figure_7.4_B17287.jpg" alt="Figure 7.4 – The default error message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4 – The default error message</p>
			<p>As you see in <em class="italic">Figure 7.4</em>, ABP shows a standard error message about an internal problem. The actual error message is written to the logging system. The server returns an HTTP 500 status code to the client for such generic errors.</p>
			<p>That is good behavior because it is not useful to show a raw exception message to an end user. It can even <a id="_idIndexMarker487"/>be dangerous, since it may include some sensitive information about your internal systems, such as database table names and fields.</p>
			<p>However, you may want to return a user-friendly, informative message to the end user for some specific cases. For such cases, you can throw a <code>UserFriendlyException</code> exception, as shown in the following code block:</p>
			<pre>public async Task ExampleAsync()
{
    throw new UserFriendlyException(
        "This message is available to the user!");
}</pre>
			<p>ABP, at this time, doesn't hide the error message, as we can see here:</p>
			<div><div><img src="img/Figure_7.5_B17287.jpg" alt="Figure 7.5 – Custom error message&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5 – Custom error message</p>
			<p>The <code>UserFriendlyException</code> class is not unique. Any exception class that inherits from the <code>UserFriendlyException</code> class or directly implements the <code>IUserFriendlyException</code> interface can be used to return user-friendly exception messages. ABP returns <a id="_idIndexMarker488"/>an HTTP 403 (forbidden) status code to the client when you throw a user-friendly exception. See the <em class="italic">Controlling the HTTP status code</em> section of this chapter for all HTTP status code mappings.</p>
			<p>In a multilingual application, you will probably want to return a localized message. Use the localization system in this case, which will be introduced in <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<p><code>UserFriendlyException</code> is a special type of business exception where you directly return a message to the user.</p>
			<h2 id="_idParaDest-162"><a id="_idTextAnchor244"/>Business exceptions</h2>
			<p>You will have some business rules in a business application, and you need to throw exceptions when the <a id="_idIndexMarker489"/>requested operation is not appropriate to execute in the current conditions based on these rules. Business exceptions in ABP are special kinds of exceptions recognized and handled by ABP Framework.</p>
			<p>In the simplest case, you can directly use the <code>BusinessException</code> class to t<a id="_idTextAnchor245"/>hrow a business exception. See the following example from the <em class="italic">EventHub</em> project:</p>
			<pre>public class EventRegistrationManager : DomainService
{
    public async Task RegisterAsync(
        Event @event,
        AppUser user)
    {
        if (Clock.Now &gt; @event.EndTime)
        {
            throw new BusinessException(EventHubErrorCodes
                .CantRegisterOrUnregisterForAPastEvent);
        }
        ...
    }
}</pre>
			<p><code>EventRegistrationManager</code> is a domain service that is used to perform business rules for event registrations. The <code>RegisterAsync</code> method checks the event time and prevents registering to events in the past by throwing a business exception in that case.</p>
			<p>The constructor of <code>BusinessException</code> takes a few parameters, and all are optional. These are listed here:</p>
			<ul>
				<li><code>code</code>: A string value that is used as a custom error code for the exception. Client applications can <a id="_idIndexMarker490"/>check it while handling the exception and track the error type easily. You typically use different error codes for different exceptions. The error code can also be used to localize the exception, as we will see in the <em class="italic">Localizing a business exception</em> section.</li>
				<li><code>message</code>: A string exception message, if needed.</li>
				<li><code>details</code>: A detailed explanation message string, if needed.</li>
				<li><code>innerException</code>: An inner exception, if available. You can pass here if you have cached an exception and throw a business exception based on that exception.</li>
				<li><code>logLevel</code>: The logging level for this exception. It is an enum of the <code>LogLevel</code> type, and the default value is <code>LogLevel.Warning</code>.</li>
			</ul>
			<p>You generally only pass <code>code</code>, which is easier to find in logs. It is also used for localizing the error message returned to the client.</p>
			<h3>Localizing a business exception</h3>
			<p>If you use <code>UserFriendlyException</code>, you have to localize the message yourself since the exception message is <a id="_idIndexMarker491"/>shown directly to the end user. If you throw <code>BusinessException</code>, ABP doesn't show the exception message to the end user unless you explicitly localize it. It uses error code namespaces for that purpose.</p>
			<p>Assume that you've used <code>EventHub:CantRegisterOrUnregisterForAPastEvent</code> as the error code. <code>EventHub</code>, here, becomes the error code namespace through the usage of the colon. We must map the error code namespace to a localization resource so that ABP can know which localization resource to use for these error messages. The code is illustrated in the following snippet:</p>
			<pre>Configure&lt;AbpExceptionLocalizationOptions&gt;(options =&gt;
{
    options.MapCodeNamespace(
        "EventHub", typeof(EventHubResource));
});</pre>
			<p>In this code snippet, we map the <code>EventHub</code> error code namespace to the <code>EventHubResource</code> localization resource. Now, you can define the error code as a key in your localization file, including the namespace, as follows:</p>
			<pre>{
  "culture": "en",
  "texts": {
    "EventHub:CantRegisterOrUnregisterForAPastEvent": 
        "You can not register to or unregister from an 
         event in the past, sorry!"
  }
}</pre>
			<p>After that configuration, ABP shows the localized message to the user whenever you throw a <code>BusinessException</code> exception with that error code.</p>
			<p>In some cases, you may want to include some additional data in the error message. See the following code snippet:</p>
			<pre>throw new BusinessException(
    EventHubErrorCodes.OrganizationNameAlreadyExists
).WithData("Name", name);</pre>
			<p>Here, we include the <a id="_idIndexMarker492"/>organization name in the error message, using the <code>WithData</code> extension method. Then, we can define the localization string, as shown in the following code snippet:</p>
			<pre>"EventHub:OrganizationNameAlreadyExists": "The organization {Name} already exists. Please use another name."</pre>
			<p>In this example, <code>{Name}</code> is a placeholder for the organization name. ABP automatically replaces it with the given name.</p>
			<p>We will cover the localization system in <a href="B17287_08_Epub_AM.xhtml#_idTextAnchor249"><em class="italic">Chapter 8</em></a>, <em class="italic">Using the Features and Services of ABP</em>.</p>
			<p>We've seen how to throw a <code>BusinessException</code> exception. What if you want to create specialized exception classes?</p>
			<h3>Custom business exception classes</h3>
			<p>It is also possible to create <a id="_idIndexMarker493"/>custom exception classes instead of directly throwing a <code>BusinessException</code> exception. In this case, you can create a new class inheriting from the <code>BusinessException</code> class, as shown in the following code block:</p>
			<pre>public class OrganizationNameAlreadyExistsException
    : BusinessException
{
    public string Name { get; private set; }
    public OrganizationNameAlreadyExistsException(
        string name) : base(EventHubErrorCodes
        .OrganizationNameAlreadyExists)
    {
        Name = name;
        WithData("Name", name);
    }
}</pre>
			<p>In this example, <code>OrganizationNameAlreadyExistsException</code> is a custom business exception class. It takes the organization's name in its constructor. It sets the <code>"Name"</code> data so that <a id="_idIndexMarker494"/>ABP can use the organization name in the localization process. Throwing this exception is pretty straightforward, as we can see here:</p>
			<pre>throw new OrganizationNameAlreadyExistsException(name);</pre>
			<p>This usage is simpler than throwing a <code>BusinessException</code> exception with custom data, which the developer can forget to set. It also reduces duplication when you throw the same exception in multiple places in your code base.</p>
			<h2 id="_idParaDest-163"><a id="_idTextAnchor246"/>Controlling exception logging</h2>
			<p>As mentioned at the <a id="_idIndexMarker495"/>beginning of the <em class="italic">Exception handling</em> section, ABP automatically logs all exceptions. Business exceptions, authorization, and validation exceptions are logged with the <code>Warning</code> level, while other errors are logged with the <code>Error</code> level by default.</p>
			<p>You can implement the <code>IHasLogLevel</code> interface to set a different log level for an exception class. See the following example:</p>
			<pre>public class MyException : Exception, IHasLogLevel
{
    public LogLevel LogLevel { get; set; } =
        LogLevel.Warning;
    //...
}</pre>
			<p>The <code>MyException</code> class implements the <code>IHasLogLevel</code> interface with the <code>Warning</code> level. ABP will write warning logs if you throw exceptions of the <code>MyException</code> type.</p>
			<p>It is also possible to write <a id="_idIndexMarker496"/>additional logs for an exception. You can implement the <code>IExceptionWithSelfLogging</code> interface to write additional logs, as shown in the following example:</p>
			<pre>public class MyException
    : Exception, IExceptionWithSelfLogging
{
    public void Log(ILogger logger)
    {
        //...log additional info
    }
}</pre>
			<p>In this example, the <code>MyException</code> class implements the <code>IExceptionWithSelfLogging</code> interface, which defines a <code>Log</code> method. ABP passes the logger here to allow you to write additional logs if you need them.</p>
			<h2 id="_idParaDest-164"><a id="_idTextAnchor247"/>Controlling the HTTP status code</h2>
			<p>ABP does its best to <a id="_idIndexMarker497"/>return a proper HTTP status code for known exception types, as follows:</p>
			<ul>
				<li>Returns <code>401</code> (unauthorized) if the user has not logged in, for <code>AbpAuthorizationException</code></li>
				<li>Returns <code>403</code> (forbidden) if the user has logged in, for <code>AbpAuthorizationException</code></li>
				<li>Returns <code>400</code> (bad request) for <code>AbpValidationException</code></li>
				<li>Returns <code>404</code> (not found) for <code>EntityNotFoundException</code></li>
				<li>Returns <code>403</code> (forbidden) for business and user-friendly exceptions</li>
				<li>Returns <code>501</code> (not implemented) for <code>NotImplementedException</code></li>
				<li>Returns <code>500</code> (internal server error) for other exceptions (those are assumed to be infrastructure errors)</li>
			</ul>
			<p>If you want to return another HTTP status code for your custom exceptions, you can map your error code to an HTTP status code, as shown in the following configuration:</p>
			<pre>services.Configure&lt;AbpExceptionHttpStatusCodeOptions&gt;(
    options =&gt;
{
    options.Map(
        EventHubErrorCodes.OrganizationNameAlreadyExists,
        HttpStatusCode.Conflict);
});</pre>
			<p>It is suggested to make that configuration in the web or HTTP API layer of your solution.</p>
			<h1 id="_idParaDest-165"><a id="_idTextAnchor248"/>Summary</h1>
			<p>In this chapter, we've explored three fundamental cross-cutting concerns that we should implement in every serious business application.</p>
			<p>Authorization is a key concern for system security. You should carefully control the authorization rules in every operation of your application. ABP simplifies the use of ASP.NET Core's authorization infrastructure and adds a flexible permission system that is a very common pattern for enterprise applications.</p>
			<p>Validation, on the other hand, supports system security and improves the UX by gracefully preventing badly formatted or malicious requests. ABP enhances the standard ASP.NET Core validation by allowing you to implement the validation in any service of your application and integrating it into the <code>FluentValidation</code> library for advanced usage.</p>
			<p>Finally, ABP's exception-handling system works seamlessly and automates exception handling on the server side and client side. It also allows you to decouple localizing error messages and map them to HTTP status codes from your code that throws an exception.</p>
			<p>The next chapter will continue to explore ABP Framework services by introducing some fancy ABP features such as automatic audit logging and data filtering.</p>
		</div>
	</body></html>