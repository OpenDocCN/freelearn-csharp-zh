- en: Caching Web Service Responses
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存网络服务响应
- en: In this chapter, we will explore the caching patterns of ASP.NET Core, as well
    as the caching strategies and the tools that are provided by the framework to
    help developers to implement them. The cache may become useful in order to avoid
    additional computation on the server, and consequently retrieve the fastest response
    to the client of a web service. Furthermore, we will look at a concrete cache
    implementation of the catalog web service.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨ASP.NET Core的缓存模式，以及框架提供的缓存策略和工具，以帮助开发者实现它们。缓存可能有助于避免在服务器上进行额外计算，并因此为网络服务的客户端检索最快的响应。此外，我们还将查看目录网络服务的具体缓存实现。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introduction to the HTTP caching system
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: HTTP缓存系统的介绍
- en: Implementing response caching in ASP.NET Core
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ASP.NET Core中实现响应缓存
- en: Implementing a distributed cache
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现分布式缓存
- en: By the end of this chapter, you will have a general understanding of caching
    mechanisms and the know-how needed in order to implement a distributed cache in
    ASP.NET Core using `Redis`.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，你将了解缓存机制，以及使用`Redis`在ASP.NET Core中实现分布式缓存所需的知识。
- en: Introduction to the HTTP caching system
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP缓存系统的介绍
- en: Caching is an essential part of web service development. The primary purpose
    of web service caching is to improve the performance of our system and reduce
    the overload of the webserver. Furthermore, fetching something over the network
    is slow and expensive, and so it is necessary to implement a caching system to
    improve the responsiveness of our web service and to avoid unnecessary additional
    computation. In this section, we will focus on some of the features that are defined
    in the HTTP 1.1 caching specification.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存是网络服务开发的一个关键部分。网络服务缓存的主要目的是提高我们系统的性能并减少服务器的负载。此外，通过网络获取数据速度慢且成本高，因此有必要实现一个缓存系统来提高我们网络服务的响应速度，并避免不必要的额外计算。在本节中，我们将关注HTTP
    1.1缓存规范中定义的一些特性。
- en: 'These caching specifications are sent by the webserver to the client. Whoever
    has ownership of the client needs to read the caching specifications and respond
    appropriately. In general, there are two common use cases for caching responses:
    the first one is when a web service exposes very *dynamic content*. In this case,
    the data changes a lot, and the *caching time* can be reduced or avoided at all.
    The second case is when our service may serve some *static content*. In that case,
    we can set a high caching time for the content that doesn''t change a lot.'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 这些缓存规范由网络服务器发送到客户端。任何拥有客户端的人都需要阅读缓存规范并做出相应的响应。通常，缓存响应有两个常见的用例：第一个是当网络服务公开非常*动态内容*时。在这种情况下，数据变化很大，*缓存时间*可以减少或完全避免。第二种情况是我们可能提供一些*静态内容*。在这种情况下，我们可以为不经常变化的内容设置较长的缓存时间。
- en: The HTTP caching specification
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: HTTP缓存规范
- en: 'The HTTP 1.1 caching specification ([https://tools.ietf.org/html/rfc7234](https://tools.ietf.org/html/rfc7234))
    describes how caches should behave over HTTP. The main header related to HTTP
    caching is the `Cache-Control` header. This header is used to specify directives
    in the request and response. It is also essential to note that the `Cache-Control`
    directives that are defined in the request and the response are independent. The
    following diagram shows a typical request-response workflow:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP 1.1缓存规范([https://tools.ietf.org/html/rfc7234](https://tools.ietf.org/html/rfc7234))描述了缓存如何在HTTP中表现。与HTTP缓存相关的主要头是`Cache-Control`头。此头用于指定请求和响应中的指令。还必须注意，请求和响应中定义的`Cache-Control`指令是独立的。以下图显示了典型的请求-响应工作流程：
- en: '![](img/b151bd77-6d75-42b3-b1da-f0ef2be74433.png)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b151bd77-6d75-42b3-b1da-f0ef2be74433.png)'
- en: The schema describes the interaction between a generic client and a server with
    a caching layer between them.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 该模式描述了通用客户端与它们之间带有缓存层的服务器之间的交互。
- en: First, the client requests a resource from the server, and the *caching layer*
    forwards it to the server. The server produces the data for the client and sends
    the response back; at this point, the caching server caches the response in the
    *caching layer*. Therefore, if the client performs another call to the same content,
    the request will not hit the server, but the cache system will provide the cached
    response.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，客户端从服务器请求一个资源，*缓存层*将其转发到服务器。服务器为客户端生成数据并发送响应；在这个时候，缓存服务器在*缓存层*中缓存了响应。因此，如果客户端再次调用相同的内容，请求将不会击中服务器，但缓存系统将提供缓存的响应。
- en: 'It is essential to note that the *cache layer* adds some headers to the response:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，*缓存层*会在响应中添加一些头：
- en: '[PRE0]'
  id: totrans-16
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Both of these are HTTP headers related to the caching directives. `Cache-Control`
    adds the `max-age` directive to indicate that the freshness lifetime of the content
    is equal to 100\. The `Age` header specifies the age of the cached content. When
    `Age` reaches the `Cache-Control: max-age` value, the *caching layer* will forward
    the request to the server in order to serve the fresh data. Both of the values
    of the headers are specified in *seconds*.'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: '这两个都是与缓存指令相关的HTTP头。`Cache-Control`添加了`max-age`指令来指示内容的 freshness lifetime 等于100。`Age`头指定了缓存内容的年龄。当`Age`达到`Cache-Control:
    max-age`值时，*缓存层*将请求转发到服务器以提供新鲜数据。这两个头的值都是以*秒*为单位的。'
- en: 'The `Cache-Control` header can be used to specify the caching mechanism. By
    default, it is possible to disable the cache by specifying the `no-cache` directive,
    that is, `Cache-Control: no-cache`. Another crucial aspect of the `Cache-Control`
    header is the public and private directives, such as `Cache-Control: public,max-age=100`.
    The `public` instruction means that the cached response can also be stored in
    a shared cache, and any other client can access that information. On the other
    hand, when a response is private, this means that it probably contains sensitive
    information and it cannot be shared with other clients.'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`Cache-Control`头可以用来指定缓存机制。默认情况下，可以通过指定`no-cache`指令来禁用缓存，即`Cache-Control: no-cache`。`Cache-Control`头的另一个关键方面是公共和私有指令，例如`Cache-Control:
    public,max-age=100`。`public`指令意味着缓存的响应也可以存储在共享缓存中，并且任何其他客户端都可以访问该信息。另一方面，当一个响应是私有的，这意味着它可能包含敏感信息，并且不能与其他客户端共享。'
- en: 'The caching specification also defines the `Vary` header. This kind of header
    is used to indicate which fields influence the cache variation. More specifically,
    it is used to decide whether a cached response can be used rather than requesting
    a fresh one from the original server:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 缓存规范还定义了`Vary`头。这种头用于指示哪些字段影响缓存变化。更具体地说，它用于决定是否可以使用缓存的响应而不是从原始服务器请求新鲜的一个：
- en: '[PRE1]'
  id: totrans-20
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In the first line of the preceding code, each variation in the request is treated
    as a single and uncacheable request. In the second line, the request is processed
    as uncacheable, but the `User-Agent` header is added.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在前述代码的第一行中，每个请求的变化都被视为一个单独且不可缓存的请求。在第二行中，请求被处理为不可缓存，但添加了`User-Agent`头。
- en: 'The `Expires` header has the same purpose as the `max-age` directive: to give
    the cache expiration time. The only reason they differ is that the `max-age` instruction
    focuses on a fixed date time. For example, we can set the following value:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: '`Expires`头与`max-age`指令具有相同的目的：提供缓存过期时间。它们之间唯一的不同之处在于`max-age`指令关注的是固定的日期时间。例如，我们可以设置以下值：'
- en: '[PRE2]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: It is essential to note that the `max-age` directive overrides the `Expires`
    header. Therefore, if both of them are present in the same response, the `Expires`
    header is ignored. In the next section, we will learn how to implement response
    caching using ASP.NET Core tools.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 必须注意，`max-age`指令覆盖了`Expires`头。因此，如果它们在同一个响应中都存在，则忽略`Expires`头。在下一节中，我们将学习如何使用ASP.NET
    Core工具实现响应缓存。
- en: Implementing response caching in ASP.NET Core
  id: totrans-25
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现ASP.NET Core中的响应缓存
- en: 'ASP.NET Core implements a declarative way to manage caching directives in the
    responses of our web service. Furthermore, it provides an attribute that can be
    used for caching purposes. The attribute implementation is also compatible with
    the HTTP 1.1 caching specification, therefore, it becomes easy to implement these
    caching standards using ASP.NET Core''s out-of-the-box implementations, and we
    don''t have to worry about the details of each request. We can specify the caching
    behavior using the `[ResponseCache]` attribute that''s exposed by ASP.NET Core:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core通过声明性方式管理我们Web服务的响应中的缓存指令。此外，它提供了一个可用于缓存目的的属性。属性实现也与HTTP 1.1缓存规范兼容，因此，使用ASP.NET
    Core的即用型实现来实现这些缓存标准变得很容易，我们不必担心每个请求的细节。我们可以使用ASP.NET Core公开的`[ResponseCache]`属性来指定缓存行为：
- en: '[PRE3]'
  id: totrans-27
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'For example, in this case, the code defines a caching directive on the `GetById`
    action method of the `ItemController` class. The `ResponseCache` attribute sets
    a `Duration` field and a `VaryByQueryKeys` field: the first one corresponds to
    the `max-age` instruction while the second one reflects the `Vary` HTTP header.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，在这种情况下，代码在`ItemController`类的`GetById`操作方法上定义了一个缓存指令。`ResponseCache`属性设置了一个`Duration`字段和一个`VaryByQueryKeys`字段：第一个对应于`max-age`指令，而第二个反映了`Vary`
    HTTP头。
- en: So far, we have only added the `Cache-Control` directive to the server responses.
    Therefore, we are *not* implementing any caching. The caching directives can be
    used by a third-party system or application, such as the client of our service,
    to cache information.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，我们只向服务器响应中添加了`Cache-Control`指令。因此，我们并没有实现任何缓存。缓存指令可以被第三方系统或应用程序使用，例如我们服务的客户端，以缓存信息。
- en: 'In addition to the `ResponseCache` attribute, it is necessary to put caching
    middleware in front of the web service. `ResponseCachingMiddleware` is the default
    middleware provided by ASP.NET Core. It is compliant with the HTTP 1.1 caching
    specification ([https://tools.ietf.org/html/rfc7234](https://tools.ietf.org/html/rfc7234)).
    Therefore, if we think about the `ResponseCachingMiddleware` type, it is possible
    to change the previous schema in the following way:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 除了`ResponseCache`属性之外，还需要在Web服务前放置缓存中间件。`ResponseCachingMiddleware`是ASP.NET
    Core提供的默认中间件。它符合HTTP 1.1缓存规范([https://tools.ietf.org/html/rfc7234](https://tools.ietf.org/html/rfc7234))。因此，如果我们考虑`ResponseCachingMiddleware`类型，可以按以下方式更改之前的架构：
- en: '![](img/8213c3cc-1f17-4636-8e25-0774296650a9.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8213c3cc-1f17-4636-8e25-0774296650a9.png)'
- en: 'The `ResponseCachingMiddleware` class can be initialized using the `AddResponseCaching`
    extension method provided by the `Microsoft.Extensions.DependencyInjection` package.
    In addition, we can add the `ResponseCachingMiddleware` middleware in the middleware
    pipeline by executing the `UseResponseCaching` extension method in the `Configure`
    method of the `Startup` class. The `ResponseCachingMiddleware` type checks whether
    a response is cacheable and stores responses and serves answers from the cache.
    We can add `ResponseCachingMiddleware` to the service pipeline by editing the
    `Startup` class in the `Catalog.API` project:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用`Microsoft.Extensions.DependencyInjection`包提供的`AddResponseCaching`扩展方法初始化`ResponseCachingMiddleware`类。此外，我们可以在`Startup`类的`Configure`方法中执行`UseResponseCaching`扩展方法，将`ResponseCachingMiddleware`中间件添加到中间件管道中。`ResponseCachingMiddleware`类型检查响应是否可缓存，并存储响应并从缓存中提供答案。我们可以通过编辑`Catalog.API`项目中的`Startup`类将`ResponseCachingMiddleware`添加到服务管道中：
- en: '[PRE4]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The preceding code adds the caching middleware, but it is not enough to initialize
    a caching mechanism. Therefore, if we try to call the route decorated with the
    `ResponseCache` attribute using the `curl` command, we will receive the following
    response:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码添加了缓存中间件，但仅此不足以初始化缓存机制。因此，如果我们尝试使用`curl`命令调用带有`ResponseCache`属性的路线，我们将收到以下响应：
- en: '[PRE5]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: As you can see, `Cache-Control` tells us that this information can be shared
    in the cache and that `max-age` is 100 seconds. Therefore, if we call the same
    route after *N (with N<100)* seconds, we can also see the `Age` header, which
    contains the time (in seconds) that the object has been in the cache for.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，`Cache-Control`告诉我们这些信息可以在缓存中共享，并且`max-age`为100秒。因此，如果我们调用相同的路线在*N（N<100）*秒后，我们也可以看到包含对象在缓存中存在时间的`Age`头。
- en: 'Moreover, if we call the same route after *N seconds* (with *N >= 100*), we
    will hit the server and cache a new response in the memory. It is also necessary
    to note that we can cancel the cache middleware by appending a query string parameter
    to the calling URL. This is because we specified the `Vary` header using the following
    field:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果我们调用相同的路由后 *N 秒*（其中 *N >= 100*），我们将访问服务器并在内存中缓存一个新的响应。还必须注意的是，我们可以通过在调用
    URL 中附加查询字符串参数来取消缓存中间件。这是因为我们指定了以下字段使用 `Vary` 头：
- en: '[PRE6]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'It may be the case that defining the `ResponseCache` attribute uses the `VaryByQueryKeys`
    field. In that case, the attribute will not be able to detect the query string
    variation. Furthermore, the routes that are covered by the `ResponseCache` attribute
    will retrieve the following exception:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 可能的情况是，定义 `ResponseCache` 属性时使用了 `VaryByQueryKeys` 字段。在这种情况下，该属性将无法检测查询字符串的变化。此外，受
    `ResponseCache` 属性覆盖的路线将检索以下异常：
- en: '`"ClassName":"System.InvalidOperationException","Message":"''VaryByQueryKeys''
    requires the response cache middleware."`'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`"ClassName":"System.InvalidOperationException","Message":"''VaryByQueryKeys''
    requires the response cache middleware."`'
- en: 'An important thing to note about the `ResponseCachingMiddleware` class is that
    it uses the `IMemoryCache` interface to store the content of the response. Hence,
    if you examine the definition of the class on GitHub ([https://github.com/aspnet/AspNetCore/.../ResponseCachingMiddleware.cs](https://github.com/aspnet/AspNetCore/blob/master/src/Middleware/ResponseCaching/src/ResponseCachingMiddleware.cs)),
    you will see the following constructor:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 `ResponseCachingMiddleware` 类的一个重要注意事项是它使用 `IMemoryCache` 接口来存储响应内容。因此，如果您在
    GitHub 上检查该类的定义（[https://github.com/aspnet/AspNetCore/.../ResponseCachingMiddleware.cs](https://github.com/aspnet/AspNetCore/blob/master/src/Middleware/ResponseCaching/src/ResponseCachingMiddleware.cs)），您将看到以下构造函数：
- en: '[PRE7]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The preceding method signature defines the constructor of the `ResposeCachingMiddleware`
    class. The constructor uses the `this` keyword to refer to another internal constructor
    overload that's used to initialize the properties of the class. As you can see,
    the `IResponseCache` interface is initialized using the `MemoryCache` type by
    default, which extends the `IMemoryCache` interface.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的方法签名定义了 `ResposeCachingMiddleware` 类的构造函数。构造函数使用 `this` 关键字引用另一个内部构造函数重载，该重载用于初始化类的属性。如您所见，`IResponseCache`
    接口默认使用 `MemoryCache` 类型初始化，该类型扩展了 `IMemoryCache` 接口。
- en: 'The `IMemoryCache` interface represents the cache stored in the webserver.
    Additionally, it is possible to use the `IMemoryCache` interface as a standalone
    component by adding the `AddMemoryCache()` extension method to the initialization
    of the services in the `Startup` class:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`IMemoryCache` 接口表示存储在 web 服务器中的缓存。此外，您还可以通过向 `Startup` 类中服务的初始化添加 `AddMemoryCache()`
    扩展方法，将 `IMemoryCache` 接口用作独立组件：'
- en: '[PRE8]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This approach allows you to use the `IMemoryCache` interface through the dependency
    injection engine, which means you can call the `GetOrCreate` and `GetOrCreateAsync`
    methods to set the cache values in the memory of the webserver. Although the in-memory
    cache provides a really good abstraction for us to cache data, it does not work
    in a distributed approach. Therefore, if you want to store and share caches between
    different web servers, ASP.NET Core provides the tools you'll need to implement
    a distributed cache. In the next section, we will learn a bit more about how to
    implement a distributed cache in ASP.NET Core.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法允许您通过依赖注入引擎使用 `IMemoryCache` 接口，这意味着您可以通过调用 `GetOrCreate` 和 `GetOrCreateAsync`
    方法在 web 服务器的内存中设置缓存值。尽管内存缓存为我们提供了很好的抽象来缓存数据，但它不适用于分布式方法。因此，如果您想在不同的 web 服务器之间存储和共享缓存，ASP.NET
    Core 提供了您实现分布式缓存所需的工具。在下一节中，我们将了解如何在 ASP.NET Core 中实现分布式缓存。
- en: Implementing a distributed cache
  id: totrans-47
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现分布式缓存
- en: 'As we mentioned previously, ASP.NET Core allows us to implement distributed
    caching. In this section, we will learn how to use `Redis` as a form of cache
    storage. It is possible to extend the behavior of the caching mechanism of ASP.NET
    Core by adding and executing the following CLI instruction in the `Catalog.API`
    project:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们之前提到的，ASP.NET Core 允许我们实现分布式缓存。在本节中，我们将学习如何将 `Redis` 作为缓存存储的形式使用。您可以通过在
    `Catalog.API` 项目的初始化中添加并执行以下 CLI 指令来扩展 ASP.NET Core 的缓存机制：
- en: '[PRE9]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'By doing this, we can connect the `Redis` server and use it by adding the following
    extension method to the `Startup` class:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这样做，我们可以连接 `Redis` 服务器，并通过向 `Startup` 类添加以下扩展方法来使用它：
- en: '[PRE10]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Microsoft provides the `AddDistributedRedisCache` extension method, which accepts
    the options that are used to define the instance of `Redis` so that it can be
    used as a cache as input. The `AddDistributedRedisCache` extension method is connected
    to the `catalog_cache` `Redis` instance. Furthermore, we need to declare the new
    instance in the `docker-compose.yml` file of the catalog service:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 微软提供了`AddDistributedRedisCache`扩展方法，该方法接受用于定义`Redis`实例的选项，以便它可以作为缓存输入使用。`AddDistributedRedisCache`扩展方法连接到`catalog_cache`的`Redis`实例。此外，我们还需要在目录服务的`docker-compose.yml`文件中声明新的实例。
- en: '[PRE11]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The preceding code defines the catalog cache''s `Redis` instance. Therefore,
    the application will be able to use this instance as part of `my_network`. Moreover,
    we can see what the primary purpose of the package is by having a look at the
    source of the `AddDistributedRedisCache` extension method:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码定义了目录缓存的`Redis`实例。因此，应用程序将能够将此实例作为`my_network`的一部分使用。此外，我们可以通过查看`AddDistributedRedisCache`扩展方法的源代码来了解该包的主要用途：
- en: '[PRE12]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'I''ve omitted some documentation comments for brevity purposes, but you can
    find the open-source code at the following GitHub link: [https://github.com/aspnet/Extensions/../StackExchangeRedisCacheServiceCollectionExtensions.cs](https://github.com/aspnet/Extensions/blob/master/src/Caching/StackExchangeRedis/src/StackExchangeRedisCacheServiceCollectionExtensions.cs).'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 为了简洁起见，我省略了一些文档注释，但您可以在以下GitHub链接中找到开源代码：[https://github.com/aspnet/Extensions/../StackExchangeRedisCacheServiceCollectionExtensions.cs](https://github.com/aspnet/Extensions/blob/master/src/Caching/StackExchangeRedis/src/StackExchangeRedisCacheServiceCollectionExtensions.cs)。
- en: As you can see from the preceding code, the extension methods configure and
    bind the `RedisCacheOptions` class. Secondly, the preceding snippet adds a new
    `IDistributedCache` interface to the built-in dependency injection of ASP.NET
    Core. This interface gives us some useful ways to interact with the `Redis` instance
    and store the caching information there. Furthermore, the instance is defined
    as a singleton, which means that all of the components inside the application
    will use the same instance.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 从前面的代码中可以看出，扩展方法配置并绑定`RedisCacheOptions`类。其次，前面的代码片段向ASP.NET Core的内置依赖注入中添加了一个新的`IDistributedCache`接口。这个接口为我们提供了一些与`Redis`实例交互和存储缓存信息的有用方式。此外，实例被定义为单例，这意味着应用程序中的所有组件都将使用相同的实例。
- en: 'Let''s have a look at the `IDistributedCache` interface:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`IDistributedCache`接口：
- en: '[PRE13]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: In this case, I've omitted the documentation comments for brevity purposes.
    You can find the complete version at [https://github.com/aspnet/Extensions/../IDistributedCache.cs](https://github.com/aspnet/Extensions/blob/master/src/Caching/Abstractions/src/IDistributedCache.cs).
    The interface provides a utility method that we can use to read and write information
    into the `Redis` instance.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，为了简洁起见，我省略了文档注释。您可以在[https://github.com/aspnet/Extensions/../IDistributedCache.cs](https://github.com/aspnet/Extensions/blob/master/src/Caching/Abstractions/src/IDistributedCache.cs)找到完整的版本。该接口提供了一个实用方法，我们可以使用它将信息读入和写入`Redis`实例。
- en: 'Furthermore, the interface exposes both synchronous and asynchronous methods
    to do this. Since the interface is part of the dependency injection engine, we
    can use it in any component, such as the `ItemController` class:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，该接口公开了同步和异步方法来完成这项工作。由于该接口是依赖注入引擎的一部分，我们可以在任何组件中使用它，例如`ItemController`类：
- en: '[PRE14]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `ItemController` class and any other components in the application can now
    be resolved and use the `IDistributedCache` singleton instance by including it
    in the constructor and action injection.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`ItemController`类和应用程序中的任何其他组件都可以通过将其包含在构造函数和操作注入中，通过包含`IDistributedCache`单例实例来解析和使用。
- en: 'ASP.NET Core also provides `AddDistributedMemoryCache()`, which is part of
    the `Microsoft.Extensions.DependencyInjection` namespace. Despite its name, it
    doesn''t initialize any distributed cache. Let''s have an in-depth look at its
    implementation:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core还提供了`AddDistributedMemoryCache()`方法，它是`Microsoft.Extensions.DependencyInjection`命名空间的一部分。尽管其名称如此，但它并不会初始化任何分布式缓存。让我们深入了解一下它的实现：
- en: '[PRE15]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: The extension method uses the memory of the webserver to store information.
    More specifically, the `AddDistributedMemoryCache` extension method is designed
    for development/testing environments, and it isn't a real distributed cache.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法使用网络服务器的内存来存储信息。更具体地说，`AddDistributedMemoryCache`扩展方法是为开发/测试环境设计的，它不是一个真正的分布式缓存。
- en: 'Finally, we can optimize and refactor the `Startup` class by creating a new
    configuration class dedicated to the cache. First of all, let''s create the following
    class in the `Configurations` folder of the catalog''s domain project:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以通过创建一个专门用于缓存的新的配置类来优化和重构 `Startup` 类。首先，让我们在目录的域项目的 `Configurations`
    文件夹中创建以下类：
- en: '[PRE16]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The class definition contains the `ConnectionString` field of the `Redis` instance.
    We can proceed by adding the `DistributedCacheExtensions` class to the `Catalog.Infrastructure`
    project, which can be found inside the `Extensions` folder:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 类定义包含 `Redis` 实例的 `ConnectionString` 字段。我们可以通过将 `DistributedCacheExtensions`
    类添加到 `Catalog.Infrastructure` 项目中继续操作，该项目位于 `Extensions` 文件夹内：
- en: '[PRE17]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code declares a new `AddDistributedCache` extension method. The
    method configures the `CacheSettings` node of the `appsettings.json` file by reading
    and registering the node to the dependency injection engine. Next, it calls the
    `AddDistributedCache` method to configure the distributed cache so that it can
    use the provided connection string.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码声明了一个新的 `AddDistributedCache` 扩展方法。该方法通过读取和注册节点到依赖注入引擎来配置 `appsettings.json`
    文件的 `CacheSettings` 节点。接下来，它调用 `AddDistributedCache` 方法来配置分布式缓存，使其可以使用提供的连接字符串。
- en: 'Let''s proceed by adding the new `CacheSettings` node to the `appsettings.json`
    file:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从向 `appsettings.json` 文件添加新的 `CacheSettings` 节点开始：
- en: '[PRE18]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Next, we need to call the `AddDistributedCache` extension method in the `Startup`
    class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在 `Startup` 类中调用 `AddDistributedCache` 扩展方法：
- en: '[PRE19]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Now, our application initializes a new `IDistributedCache` instance in the dependency
    injection engine using the connection string provided by the `appsettings.json`
    file. In the next section, we will examine an additional level of customization
    for distributed caches.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的应用程序使用 `appsettings.json` 文件提供的连接字符串在依赖注入引擎中初始化一个新的 `IDistributedCache`
    实例。在下一节中，我们将检查分布式缓存的额外定制级别。
- en: Implementing the IDistributedCache interface
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现 `IDistributedCache` 接口
- en: It is possible to extend the behavior of the `IDistributedCache` interface by
    overloading the extension methods. Furthermore, we need to store complex information
    and not bytes. For example, in the case of the `ItemController` class, we want
    to pass the `ItemResponse` type to the `Set` method of the `IDistributedCache`
    interface.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过重载扩展方法来扩展 `IDistributedCache` 接口的行为。此外，我们需要存储复杂信息而不是字节。例如，在 `ItemController`
    类的情况下，我们希望将 `ItemResponse` 类型传递给 `IDistributedCache` 接口的 `Set` 方法。
- en: 'Let''s proceed by modifying the `DistributedCacheExtensions` class in the `Catalog.API`
    project:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从修改 `Catalog.API` 项目中的 `DistributedCacheExtensions` 类开始：
- en: '[PRE20]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'The preceding class defines the generic extension methods to get and set a
    complex object in the `Redis` cache. It uses the `Newtonsoft.Json` methods to
    store objects in JSON format. The class also defines two `SetObject<T>` methods
    with different signatures. One provides a default configuration of `DistributedCacheEntryOptions`,
    while the other one allows us to override the options inside this configuration.
    Furthermore, it is possible to use these extension methods in the `ItemController`
    class, like so:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 上述类定义了获取和设置 `Redis` 缓存中复杂对象的泛型扩展方法。它使用 `Newtonsoft.Json` 方法以 JSON 格式存储对象。该类还定义了两个具有不同签名的
    `SetObject<T>` 方法。一个提供了 `DistributedCacheEntryOptions` 的默认配置，而另一个允许我们覆盖此配置中的选项。此外，我们可以在
    `ItemController` 类中使用这些扩展方法，如下所示：
- en: '[PRE21]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `GetById` action method uses the `IDistributedCache` interface to save
    information about `ItemResponse`: it defines a key that''s composed in the following
    way:'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetById` 动作方法使用 `IDistributedCache` 接口来保存 `ItemResponse` 的信息：它定义了一个以下方式组合的键：'
- en: '[PRE22]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: The action method tries to retrieve this information from the cache; if this
    information is not present, it performs the request by using the `IItemService`
    interface, and it stores the result using the `SetObjectAsync` method of the `IDistributedCache`
    interface.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 动作方法尝试从缓存中检索此信息；如果此信息不存在，它将使用 `IItemService` 接口执行请求，并使用 `IDistributedCache`
    接口的 `SetObjectAsync` 方法存储结果。
- en: 'Although this approach requires a discrete overhead in terms of implementation
    compared to the `ResponseCache` attribute, the `IDistributedCache` interface relies
    on an external caching system. Furthermore, it is possible to implement this kind
    of caching logic by using the filter pipeline stack. Therefore, it is possible
    to move the caching logic that''s implemented in the `ItemController` class into
    a custom action filter:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `ResponseCache` 属性相比，这种方法的实现开销更大，但 `IDistributedCache` 接口依赖于外部缓存系统。此外，可以使用过滤器管道堆栈实现这种类型的缓存逻辑。因此，可以将
    `ItemController` 类中实现的缓存逻辑移动到自定义动作过滤器中：
- en: '[PRE23]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`RedisCacheFilter` encapsulates the cache logic to avoid replicating it in
    every action method. It implements the following logic: before the action is executed,
    it tries to get `ItemResponse` from the cache by composing the key using the controller
    name, the action name, and the requested `id` value. If the cache key is not populated,
    it proceeds with the execution of the action method, and if the resulting `StatusCode`
    is `200`, it continues by storing the result in the `Redis` cache. The next request
    with the same `id` value will have the cache populated, and the action filter
    will return the cached object.'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`RedisCacheFilter` 封装了缓存逻辑，以避免在每个动作方法中重复实现。它实现了以下逻辑：在动作执行之前，它尝试通过组合控制器名称、动作名称和请求的
    `id` 值来从缓存中获取 `ItemResponse`。如果缓存键未填充，它将继续执行动作方法，如果结果 `StatusCode` 是 `200`，它将继续将结果存储在
    `Redis` 缓存中。下一个具有相同 `id` 值的请求将填充缓存，动作过滤器将返回缓存的对象。'
- en: 'It is possible to use the action filter in the following way:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 可以以下方式使用动作过滤器：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: The action method uses the `TypeFilter` attribute to resolve `RedisCacheFilter`,
    and it passes the number that represents the cache expiration in seconds as an
    argument. This implementation strategy is more readable and allows us to avoid
    code replication between different action methods.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 动作方法使用 `TypeFilter` 属性解析 `RedisCacheFilter`，并将表示缓存过期时间的秒数作为参数传递。这种实现策略更易于阅读，并允许我们避免在不同动作方法之间复制代码。
- en: Inject memory cache into the tests
  id: totrans-92
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 将内存缓存注入到测试中
- en: If we try to execute unit tests using `RedisCacheFilter`, we will notice that
    `get_by_id_should_return_right_data` will fail. This is because the Redis instance
    is not available in the development environment. Furthermore, we can use the `MemoryDistributedCache`
    implementation to perform our tests. The `MemoryDistributedCache` implementation
    is done in the same class that's used by the `AddDistributedMemoryCache` extension
    method. As we mentioned in the previous chapter, the class doesn't provide a real
    distributed cache, and it is used for testing purposes.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们尝试使用 `RedisCacheFilter` 执行单元测试，我们会注意到 `get_by_id_should_return_right_data`
    将会失败。这是因为 Redis 实例在开发环境中不可用。此外，我们可以使用 `MemoryDistributedCache` 实现来执行我们的测试。`MemoryDistributedCache`
    实现是在 `AddDistributedMemoryCache` 扩展方法所使用的同一类中完成的。正如我们在上一章中提到的，该类不提供真正的分布式缓存，它用于测试目的。
- en: 'For that reason, we can add the following line to the `InMemoryApplicationFactory<TStartup>`
    class, which is contained in the `Catalog.Fixtures` project:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以向包含在 `Catalog.Fixtures` 项目中的 `InMemoryApplicationFactory<TStartup>` 类添加以下行：
- en: '[PRE25]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The preceding code replaces the implementation of `IDistributedCache` with an
    instance of `MemoryDistributedCache`. Therefore, every time our implementation
    calls the `IDistributedCache` interface, the data is saved in the memory of the
    testing server.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码将 `IDistributedCache` 的实现替换为 `MemoryDistributedCache` 的一个实例。因此，每次我们的实现调用
    `IDistributedCache` 接口时，数据都会保存在测试服务器的内存中。
- en: Summary
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we covered some of the main caching scenarios in ASP.NET Core
    so that you know how the HTTP cache works and how it can be implemented. Furthermore,
    we learned how to implement a distributed cache using the `IDistributedCache`
    interface and how to connect the web service to a Redis instance. In the next
    chapter, we will look at how to deal with logging management and how to perform
    health checks on the dependencies of the catalog web service.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了 ASP.NET Core 中的一些主要缓存场景，以便您了解 HTTP 缓存的工作原理以及如何实现。此外，我们学习了如何使用 `IDistributedCache`
    接口实现分布式缓存以及如何将 Web 服务连接到 Redis 实例。在下一章中，我们将探讨如何处理日志管理以及如何对目录 Web 服务的依赖项进行健康检查。
