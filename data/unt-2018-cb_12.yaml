- en: Controlling and Choosing Positions
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制和选择位置
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Player control of a 2D GameObject (and limiting the movement within a rectangle)
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家控制2D游戏对象（并在矩形内限制移动）
- en: Player control of a 3D GameObject (and limiting the movement within a rectangle)
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 玩家控制3D游戏对象（并在矩形内限制移动）
- en: Choosing destinations – finding a random spawn point
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择目的地 – 寻找随机生成点
- en: Choosing destinations – finding the nearest spawn point
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择目的地 – 寻找最近的生成点
- en: Choosing destinations – respawning to the most recently passed checkpoint
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择目的地 – 回到最近通过的检查点重生
- en: Moving objects by clicking on them
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过点击移动对象
- en: Firing projectiles in the direction of movement
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 向运动方向发射弹体
- en: Introduction
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Many **GameObjects** in games move! Movement can be controlled by the player,
    by the (simulated) laws of physics in the environment, or by the **Non-Player
    Character** (**NPC**) logic; for example, objects that follow a path of a waypoint,
    or seek (move toward) or flee (away) from the current position of a character.
    Unity provides several controllers for first and third-person characters, and
    for vehicles such as cars and airplanes. **GameObject** movement can also be controlled
    through the state machines of the Unity **Mecanim** animation system.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏中的许多**游戏对象(GameObjects**)都在移动！移动可以由玩家控制，由环境中的（模拟的）物理定律控制，或者由**非玩家角色(NPC**)逻辑控制；例如，跟随路径的航点对象，或者寻找（朝向）或逃离（远离）角色的当前位置。Unity为第一人称和第三人称角色以及汽车和飞机等车辆提供了几个控制器。**游戏对象(GameObject**)的移动也可以通过Unity
    **Mecanim** 动画系统的状态机来控制。
- en: However, there may be times when you wish to tweak the Player character controllers
    from Unity, or write your own. You might wish to write directional logic—simple
    or sophisticated **Artificial Intelligence** (**AI**) to control the game's NPC
    and enemy characters. Such AI might involve your computer program making objects
    orient and move toward or away from characters or other game objects.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，可能会有时候你想调整Unity中的玩家角色控制器，或者编写自己的。你可能希望编写方向逻辑——简单或复杂的**人工智能(Artificial Intelligence**)来控制游戏中的NPC和敌人角色。这种AI可能涉及你的计算机程序使对象朝向或远离角色或其他游戏对象。
- en: This chapter (and the chapter that follows) presents a range of such directional
    recipes, from which many games can benefit in terms of a richer and more exciting
    user experience.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章（以及随后的章节）介绍了一系列这样的方向性食谱，许多游戏可以从更丰富和更令人兴奋的用户体验中受益。
- en: Unity provides sophisticated classes and components, including the `Vector3`
    class and rigid body physics for modeling realistic movements, forces, and collisions
    in games. We make use of these game engine features to implement some sophisticated
    NPC and enemy character movements in the recipes of this chapter.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: Unity提供了复杂的类和组件，包括`Vector3`类和刚体物理，用于在游戏中建模现实运动、力和碰撞。我们利用这些游戏引擎功能来实现本章食谱中的一些复杂的NPC和敌人角色移动。
- en: The big picture
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 整体概念
- en: For 3D games (and to some extent, 2D games as well), a fundamental class of
    object is the `Vector3` class objects that store and manipulate (x, y, z) values
    representing locations in a 3D space. If we draw an imaginary arrow from the origin
    (0, 0, 0) to a point on the space, then the direction and length of this arrow
    (vector) can represent a velocity or force (that is, a certain amount of magnitude
    in a certain direction).
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 对于3D游戏（以及在一定程度上，2D游戏），一个基本的对象类别是存储和操作表示3D空间中位置的(x, y, z)值的`Vector3`类对象。如果我们从一个原点(0,
    0, 0)到空间中的一个点画一个想象中的箭头，那么这个箭头的方向和长度（向量）可以表示速度或力（即，在某个方向上的一定量的量度）。
- en: If we ignore all the character controller components, colliders, and the physics
    system in Unity, we can write code that teleports objects directly to a particular
    (x,  y,  z) location in our scene. Sometimes, this is just what we want to do;
    for example, we may wish to spawn an object at a location. However, in most cases,
    if we want objects to move in more physically realistic ways, then we either apply
    a force to the object's **RigidBody**, or change its velocity component. Or, if
    it has a **Character Controller** component, then we can send it a `Move()` message.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们忽略Unity中的所有角色控制器组件、碰撞体和物理系统，我们可以编写代码将对象直接传送到场景中的特定(x, y, z)位置。有时，这正是我们想要的；例如，我们可能希望在一个位置生成一个对象。然而，在大多数情况下，如果我们想让对象以更物理现实的方式移动，那么我们要么对对象的**刚体(RigidBody**)施加力，要么改变其速度分量。或者，如果它有一个**角色控制器(Character
    Controller**)组件，那么我们可以发送一个`Move()`消息给它。
- en: 'Some important concepts in the NPC object movement and creation (instantiation)
    include the following:'
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: NPC对象移动和创建（实例化）的一些重要概念包括以下内容：
- en: '**Spawn points**: Specific locations in the scene where objects are to be created,
    or moved to'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**生成点**：场景中创建或移动对象的具体位置'
- en: '**Checkpoints**: Locations (or colliders) that, once passed through, change
    what happens later in the game (for example, extra time, or if a Player''s character
    gets killed, they respawn to the last crossed checkpoint, and so on)'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**检查点**：一旦通过，就会改变游戏后期发生的事情的位置（或碰撞体）（例如，额外时间，或者如果玩家的角色被杀死，他们将重生到最后一个通过的检查点，等等）'
- en: '**Waypoints**: A sequence of locations to define a path for NPCs or, perhaps,
    the Player''s character, to follow'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**航标点**：定义NPC或玩家角色跟随的路径的一系列位置'
- en: In this chapter, we will introduce a few recipes and demonstrate a selection
    of approaches to character control, spawn points, and checkpoints. In the next
    chapter, we'll look at waypoints for AI controlled characters.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍一些配方，并展示关于角色控制、生成点和检查点的几种方法。在下一章中，我们将探讨AI控制角色的航标点。
- en: You can learn more about the Unity 2D character controllers at [http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers](http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers).
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers](http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers)了解更多关于Unity
    2D角色控制器的信息。
- en: You can learn about the Unity 3D character component and control at [http://docs.unity3d.com/Manual/class-CharacterController.html](http://docs.unity3d.com/Manual/class-CharacterController.html)
    and [http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character](http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://docs.unity3d.com/Manual/class-CharacterController.html](http://docs.unity3d.com/Manual/class-CharacterController.html)和[http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character](http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character)了解Unity
    3D角色组件和控制。
- en: 'Every game needs textures. Here are some of the sources of free textures that
    are suitable for many games:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 每个游戏都需要纹理。以下是一些适合许多游戏的免费纹理来源：
- en: CG Textures are available at [http://www.cgtextures.com/](http://www.cgtextures.com/)
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: CG Textures可在[http://www.cgtextures.com/](http://www.cgtextures.com/)找到
- en: Naldz Graphics blog,  available at [http://naldzgraphics.net/textures/](http://naldzgraphics.net/textures/)
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Naldz Graphics博客，可在[http://naldzgraphics.net/textures/](http://naldzgraphics.net/textures/)找到
- en: Player control of a 2D GameObject (and limiting the movement within a rectangle)
  id: totrans-27
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 玩家对2D GameObject的控制（以及限制其在矩形内的移动）
- en: While the rest of the recipes in this chapter are demonstrated in 3D projects,
    basic character movement in 2D and also limiting the movement to a bounding rectangle,
    are core skills for many 2D games, and so this first recipe illustrates how to
    achieve these features for a 2D game.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然本章中的其余配方都是在3D项目中演示的，但基本的2D角色移动以及限制移动到边界矩形是许多2D游戏的核心技能，因此这个第一个配方说明了如何为2D游戏实现这些功能。
- en: 'Since in [Chapter 3](c6ad221f-b476-4471-8259-9ad448749a32.xhtml), *Inventory
    UIs*, we already created a basic 2D game, we''ll adapt this game to restrict the
    movement to a bounding rectangle:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于在[第3章](c6ad221f-b476-4471-8259-9ad448749a32.xhtml)，*库存UI*中，我们已经创建了一个基本的2D游戏，我们将适应这个游戏以限制移动到边界矩形内：
- en: '![](img/76b6b50a-1659-4d5c-8de2-db2777b28ce4.png)'
  id: totrans-30
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/76b6b50a-1659-4d5c-8de2-db2777b28ce4.png)'
- en: Getting ready
  id: totrans-31
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds on a simple 2D game called the Simple2DGame_SpaceGirl mini
    game from the first recipe of [Chapter 3](c6ad221f-b476-4471-8259-9ad448749a32.xhtml),
    *Inventory UIs*. Start with a copy of this game, or use the provided completed
    recipe project as the basis for this recipe. You can download the completed project
    from [https://github.com/dr-matt-smith/unity-cookbook-2018-ch03](https://github.com/dr-matt-smith/unity-cookbook-2018-ch03).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方基于第3章（c6ad221f-b476-4471-8259-9ad448749a32.xhtml）*库存UI*的第一个配方中的简单2D游戏Simple2DGame_SpaceGirl迷你游戏。从这个游戏的副本开始，或者使用提供的完成配方项目作为这个配方的基础。你可以从[https://github.com/dr-matt-smith/unity-cookbook-2018-ch03](https://github.com/dr-matt-smith/unity-cookbook-2018-ch03)下载完成的项目。
- en: How to do it...
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a 2D sprite controlled by the user with a movement that is limited
    to within a rectangle, follow these steps:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个用户控制的2D精灵，其移动限制在矩形内，请按照以下步骤操作：
- en: 'Create a new, empty **GameObject** named `corner_max`, and position it somewhere
    above and to the right of the **GameObject** called `player_spaceGirl`. With this
    **GameObject** selected in the Hierarchy view, choose the large yellow oblong
    icon, highlighted in the Inspector panel:'
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空 **游戏对象**，命名为 `corner_max`，并将其放置在名为 `player_spaceGirl` 的 **游戏对象**上方和右侧。在层次结构视图中选择此
    **游戏对象**后，选择检查器面板中突出显示的大黄色椭圆形图标：
- en: '![](img/accf458a-21c9-4fda-864c-145266b43739.png)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/accf458a-21c9-4fda-864c-145266b43739.png)'
- en: Duplicate the corner_max **GameObject** by naming the clone as `corner_min`,
    and position this clone somewhere below and to the left of the player-spaceGirl **GameObject**.
    The coordinates of these two **GameObjects** will determine the maximum and minimum
    bounds of movement, permitted for the player's character.
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 corner_max **游戏对象**，将副本命名为 `corner_min`，并将其放置在玩家-spaceGirl **游戏对象**下方和左侧。这两个
    **游戏对象**的坐标将确定玩家角色的最大和最小移动范围。
- en: 'Modify the C# Script called `PlayerMove` to declare some new variables at the
    beginning of the class:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为 `PlayerMove` 的 C# 脚本，在类开始处声明一些新的变量：
- en: '[PRE0]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Modify the C# Script called `PlayerMove` so that the `Awake()` method now gets
    a reference to the `SpriteRenderer`, and uses this object to help set up the maximum
    and minimum X and Y movement limits:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为 `PlayerMove` 的 C# 脚本，以便 `Awake()` 方法现在获取 `SpriteRenderer` 的引用，并使用此对象来帮助设置最大和最小
    X 和 Y 移动限制：
- en: '[PRE1]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Modify the C# Script called `PlayerMove` to declare a new method called `KeepWithinMinMaxRectangle()`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为 `PlayerMove` 的 C# 脚本，声明一个名为 `KeepWithinMinMaxRectangle()` 的新方法：
- en: '[PRE2]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Modify the C# Script called `PlayerMove` so that, after having updated the
    velocity in the `FixedUpdate()` method, a call will be made to the `KeepWithinMinMaxRectangle()`
    method:'
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修改名为 `PlayerMove` 的 C# 脚本，以便在 `FixedUpdate()` 方法更新速度后，调用 `KeepWithinMinMaxRectangle()`
    方法：
- en: '[PRE3]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: With the player-spaceGirl **GameObject** in the **Hierarchy** view, drag the
    corner_max and corner_min **GameObjects** over the public variables called corner_max
    and corner_min in the Inspector.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **层次结构** 视图中选择玩家-spaceGirl **游戏对象**，将 corner_max 和 corner_min **游戏对象**拖动到检查器中名为
    corner_max 和 corner_min 的公共变量上。
- en: Before running the scene in the **Scene** panel, try repositioning the corner_max
    and corner_min **GameObjects**. When you run the scene, the positions of these
    two **GameObjects** (max and min, and X and Y) will be used as the limits of movement
    for the Player's player-spaceGirl character.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **场景** 面板中运行场景之前，尝试重新定位 corner_max 和 corner_min **游戏对象**。当你运行场景时，这两个 **游戏对象**（最大和最小，以及
    X 和 Y）的位置将被用作玩家玩家空间女孩角色的移动限制。
- en: How it works...
  id: totrans-48
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You added the empty **GameObjects** called corner_max and corner_min to the
    scene. The X and Y coordinates of these **GameObjects** will be used to determine
    the bounds of movement that we will permit for the character called player-spaceGirl.
    Since these are the empty **GameObjects**, they will not be seen by the player
    when in play-mode. However, we can see and move them in the **Scene** panel, and
    having added the yellow oblong icons, we can see their positions and names very
    easily.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 您已将名为 corner_max 和 corner_min 的空 **游戏对象**添加到场景中。这些 **游戏对象**的 X 和 Y 坐标将用于确定我们允许名为
    player-spaceGirl 的角色进行的移动范围。由于这些是空 **游戏对象**，因此在游戏模式下玩家将看不到它们。然而，我们可以在 **场景** 面板中看到并移动它们，并且添加了黄色椭圆形图标后，我们可以很容易地看到它们的位置和名称。
- en: Upon using the `Awake()` method on the `PlayerMoveWithLimits` object, inside
    the player-spaceGirl **GameObject**, the maximum and minimum X and Y values of
    the **GameObjects** called corner_max and corner_min are recorded. Each time the
    physics system is called via the `FixedUpdate()` method, the velocity of the player-spaceGirl
    character is updated to the value set in the `Update()` method,which is based
    on the horizontal and vertical keyboard/joystick inputs. However, the final action
    of the `FixedUpdate()` method is to call the `KeepWithinMinMaxRectangle()` method,
    which uses the `Math.Clamp(...)` function to move the character back inside the
    X and Y limits. This happens so that the player's character is not permitted to
    move outside the area defined by the corner_max and corner_min **GameObjects**.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `PlayerMoveWithLimits` 对象上使用 `Awake()` 方法时，在玩家空间女孩 `GameObject` 内部，记录了名为 corner_max
    和 corner_min 的 `GameObjects` 的最大和最小 X 和 Y 值。每次通过 `FixedUpdate()` 方法调用物理系统时，玩家空间女孩角色的速度都会更新到
    `Update()` 方法中设置的值，该值基于水平和垂直键盘/摇杆输入。然而，`FixedUpdate()` 方法的最终操作是调用 `KeepWithinMinMaxRectangle()`
    方法，该方法使用 `Math.Clamp(...)` 函数将角色移动回 X 和 Y 限制内。这样，玩家的角色不允许移动到由 corner_max 和 corner_min
    `GameObjects` 定义的区域内。
- en: 'We have kept to a good rule of thumb:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 我们一直遵循一个很好的经验法则：
- en: '"Always listen for **input** in `Update()`.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: “始终在 `Update()` 中监听 **输入**。”
- en: Always apply **physics** in `FixedUpdate()`."
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 总是在 `FixedUpdate()` 中应用 **物理**。
- en: Learn more about why we should not check for inputs in `FixedUpdate()` in the
    Unity Answers thread (which is also the source for the preceding quote from user
    Tanoshimi) at [https://answers.unity.com/questions/1279847/getaxis-being-missed-in-fixedupdate-work-around.html](https://answers.unity.com/questions/1279847/getaxis-being-missed-in-fixedupdate-work-around.html).
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity Answers 线程中了解更多关于为什么我们不应该在 `FixedUpdate()` 中检查输入的原因（该线程也是用户 Tanoshimi
    之前引用的来源），请参阅 [https://answers.unity.com/questions/1279847/getaxis-being-missed-in-fixedupdate-work-around.html](https://answers.unity.com/questions/1279847/getaxis-being-missed-in-fixedupdate-work-around.html)。
- en: There's more...
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss out on.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 有些细节你不希望错过。
- en: Drawing a gizmo yellow rectangle to visually show bounding a rectangle
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制辅助黄色矩形以视觉上显示边界矩形
- en: 'As developers, it is useful to *see* elements like bounding rectangles when
    run-testing our game. Let''s make the rectangular bounds of the movement visually
    explicit in yellow lines in the Scene panel by having a yellow "gizmo" rectangle
    drawn. Add the following method to the C# script class called `PlayerMove`:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，在运行测试我们的游戏时，看到像边界矩形这样的元素是有用的。让我们通过在场景面板中绘制一个黄色的“辅助”矩形，使运动的矩形边界在黄色线条中视觉上明确。将以下方法添加到名为
    `PlayerMove` 的 C# 脚本类中：
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The `OnDrawGizmos()` method tests that the references to the corner_max and
    corner_min **GameObjects** are not null, and then sets the positions of the four
    **Vector3** objects, representing the four corners defined by the rectangle, with
    corner_max and corner_min at the opposite corners. It then sets the **Gizmo**
    color to yellow, and draws lines, connecting the four corners in the **Scene**
    panel.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDrawGizmos()` 方法检查对 corner_max 和 corner_min `GameObjects` 的引用是否不为空，然后设置代表由矩形定义的四个角的四个
    **Vector3** 对象的位置，其中 corner_max 和 corner_min 位于对角。然后设置 **Gizmo** 颜色为黄色，并在 **场景**
    面板中绘制线条，连接四个角。'
- en: See also
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the following recipe for more information about limiting Player controlled
    character movements.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 参考以下菜谱以获取有关限制玩家控制角色移动的更多信息。
- en: Player control of a 3D GameObject (and limiting the movement within a rectangle)
  id: totrans-63
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 3D GameObject 的玩家控制（并在矩形内限制移动）
- en: 'Many of the 3D recipes in this chapter are built on this basic project, which
    constructs a scene with a textured terrain, a **Main Camera**, and a red cube
    that can be moved around by the user with the four directional arrow keys. The
    bounds of movement of the cube are constrained using the same technique as in
    the previous 2D recipe:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中的许多 3D 菜单都是基于这个基本项目构建的，该项目构建了一个带有纹理地形、**主摄像机**和可以由用户使用四个方向箭头移动的红色立方体的场景。使用与上一个
    2D 菜单中相同的技术约束立方体的运动范围：
- en: '![](img/fbef8f32-06f6-4e98-9af4-6cbb47191e8b.png)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![](img/fbef8f32-06f6-4e98-9af4-6cbb47191e8b.png)'
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To create a basic 3D cube controlled game, follow these steps:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个基本的 3D 立方体控制游戏，请按照以下步骤操作：
- en: Create a new, empty 3D project.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空 3D 项目。
- en: 'Once the project has been created, import the single **Terrain Texture** named
    SandAlbedo by choosing menu: Assets | Import Package | Environments. Deselect
    everything, and then locate and tick the asset by going to `Assets/Environment/TerrainAssets/SurfaceTextures/
    SandAlbedo.psd`.'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦项目创建完成，通过选择菜单：资产 | 导入包 | 环境，导入名为SandAlbedo的单个**地形纹理**。取消选择所有内容，然后转到`Assets/Environment/TerrainAssets/SurfaceTextures/
    SandAlbedo.psd`找到并勾选该资产。
- en: You could have just added the Environment Asset Package when creating the project,
    but this would have imported hundreds of files, and we only needed this one. Starting
    a project in Unity and then selectively importing just what we need is the best
    approach to take if you want to keep the project's `Asset` folders to small sizes.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 你本可以在创建项目时添加环境资产包，但这会导入数百个文件，而我们只需要这一个。如果你想要保持项目`资产`文件夹的大小尽可能小，那么在Unity中开始一个项目然后只选择性地导入所需内容是最好的方法。
- en: 'Create a new terrain by choosing menu: Create | 3D Object | Terrain. With this
    new terrain **GameObject** selected in Hierarchy, in its Inspector properties,
    set the size to 30 x 20, and its position to (-15, 0, -10):'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：创建 | 3D 对象 | 地形来创建一个新的地形。在层次结构中选择这个新的地形**GameObject**，在其检查器属性中，将大小设置为30
    x 20，并将位置设置为(-15, 0, -10)：
- en: The transform position for the terrains relates to their corner and not their
    center.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 地形的变换位置与其角落相关，而不是与其中心相关。
- en: Since the **Transform** position of the terrains relates to the corner of the
    object, we center such objects at (0, 0, 0) by setting the X coordinate equal
    to ( *-1width/2*), and the Z-coordinate equal to (*-1length/2*). In other words,
    we slide the object by half its width and half its height to ensure that its center
    is just where we want it.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 由于地形的**变换**位置与对象的角落相关，我们通过将X坐标设置为(*-1width/2*)，Z坐标设置为(*-1length/2*)来将此类对象居中在(0,
    0, 0)。换句话说，我们通过对象宽度的一半和高度的一半滑动对象，以确保其中心正好在我们想要的位置。
- en: In this case, the width is 30 and the length is 20, hence we get -15 for X (*-1
    * 30/2*), and -10 for Z (*-1 * 20/2*).
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，宽度是30，长度是20，因此我们得到X坐标为-15(*-1 * 30/2*)，Z坐标为-10(*-1 * 20/2*)。
- en: '![](img/ece021ed-d3b8-40d2-8ac5-7edd13f44a9e.png)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ece021ed-d3b8-40d2-8ac5-7edd13f44a9e.png)'
- en: Texture paint this terrain with your texture called SandAlbedo.
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用你的纹理SandAlbedo绘制此地形。
- en: 'Make the following changes to the Main Camera:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对主摄像机进行以下更改：
- en: Position: (0, 20, -15)
  id: totrans-78
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置：(0, 20, -15)
- en: Rotation: (60, 0, 0)
  id: totrans-79
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转：(60, 0, 0)
- en: Change the Aspect Ratio of the **Game Panel** from Free Aspect to 4:3\. You
    will now see the whole of the Terrain in the **Game Panel**.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**游戏面板**的纵横比从自由纵横比更改为4:3。现在你将在**游戏面板**中看到整个地形。
- en: Create a new empty **GameObject** named corner_max, and position it at (14,
    0, 9). With this **GameObject** selected in the Hierarchy, choose the large, yellow
    oblong icon, highlighted in the Inspector panel.
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的空**GameObject**，命名为corner_max，并将其定位在(14, 0, 9)。在层次结构中选择此**GameObject**，选择检查器面板中突出显示的大、黄色椭圆形图标。
- en: Duplicate the corner_max **GameObject**, naming the clone as corner_min, and
    position this clone at (-14, 0, -9). The coordinates of these two **GameObjects**
    will determine the maximum and minimum bounds of the movement permitted for the
    player's character.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制角落最大值 **GameObject**，将副本命名为corner_min，并将此副本定位在(-14, 0, -9)。这两个**GameObject**的坐标将决定玩家角色允许移动的最大和最小边界。
- en: 'Create a new cube called **GameObject **by choosing menu: Create | 3D Object
    | Cube. Name this `Cube-player`, and set its position to (0, 0.5, 0), and size
    as (1, 1, 1).'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过选择菜单：创建 | 3D 对象 | 立方体创建一个新的立方体**GameObject**。将其命名为`Cube-player`，并将位置设置为(0,
    0.5, 0)，大小为(1, 1, 1)。
- en: Add a rigid body component to the Cube-player **GameObject** (Physics | RigidBody),
    and uncheck the **RigidBody** property Use Gravity.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向Cube-player **GameObject**添加刚体组件（物理 | 刚体），并取消勾选**刚体**属性使用重力。
- en: Create a red **Material** named `m_red`, and apply this Material to Cube-player.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`m_red`的红色**材质**，并将其应用到Cube-player上。
- en: 'Create a C# Script class called `PlayerControl`, and add an instance object
    as a component to **GameObject **Cube-player:'
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`PlayerControl`的C#脚本类，并将实例对象作为组件添加到**GameObject** Cube-player：
- en: '[PRE5]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: With the Cube-player **GameObject** selected in Hierarchy, drag the **GameObjects**
    called corner_max and corner_min over the public variables called corner_max and
    corner_min in the Inspector panel.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层次结构中选择Cube-player **GameObject**，将名为corner_max和corner_min的**GameObject**拖到检查器面板中的公共变量corner_max和corner_min上。
- en: When you run the scene, the positions of the corner_max and corner_min **GameObjects**
    will define the bounds of movement for the Player's Cube-player character.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行场景时，corner_max 和 corner_min **GameObjects** 的位置将定义玩家立方体-玩家角色的移动范围。
- en: How it works...
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The scene contains a positioned terrain so that its center is (0, 0, 0). The
    red cube is controlled by the user's arrow keys through the `PlayerControl` script.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 场景包含一个定位的地形，使其中心位于 (0, 0, 0)。红色立方体通过 `PlayerControl` 脚本由用户的箭头键控制。
- en: Just as with the previous 2D recipe, a reference to the (3D) RigidBody component
    is stored when the `Awake()` method executes, and the maximum and minimum X and
    Z values are retrieved from the two corner **GameObjects**, and are stored in
    the `x_min`, `x_max`, `z_min`, and `z_max` variables. Note that for this basic
    3D game, we won't allow any Y-movement, although such movement (and bounding limits
    by adding a third max-height corner **GameObject**) can be easily added by extending
    the code in this recipe.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前的 2D 配方一样，当 `Awake()` 方法执行时，会存储对 (3D) RigidBody 组件的引用，并从两个角 **GameObjects**
    中检索最大和最小 X 和 Z 值，并将它们存储在 `x_min`、`x_max`、`z_min` 和 `z_max` 变量中。请注意，对于这个基本的 3D
    游戏，我们不会允许任何 Y 方向的运动，尽管可以通过扩展此配方中的代码轻松添加此类运动（以及通过添加第三个最大高度角 **GameObject** 的边界限制）。
- en: The `KeyboardMovement()` method reads the horizontal and vertical input values
    (which the Unity default settings read from the four directional arrow keys).
    Based on these left-right and up-down values, the velocity of the cube is updated.
    The amount it will move depends on the speed variable.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeyboardMovement()` 方法读取水平和垂直输入值（Unity 默认设置从四个方向箭头键读取）。根据这些左右和上下值，更新立方体的速度。它将移动的量取决于速度变量。'
- en: The `KeepWithinMinMaxRectangle()` method uses the `Math.Clamp(...)` function
    to move the character back inside the X and Z limits so that the player's character
    is not permitted to move outside the area defined by the corner_max and corner_min **GameObjects**.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`KeepWithinMinMaxRectangle()` 方法使用 `Math.Clamp(...)` 函数将角色移动回 X 和 Z 的限制范围内，以便玩家的角色不允许移动到由
    corner_max 和 corner_min **GameObjects** 定义的区域内。'
- en: There's more...
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: There are some details that you don't want to miss out on.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节您不想错过。
- en: Drawing a gizmo yellow rectangle to visually show bounding a rectangle
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 绘制一个黄色的 gizmo 矩形以直观地显示边界矩形
- en: 'As developers, it is useful to *see* elements like bounding rectangles when
    test-running our game. Let''s make the rectangular bounds of the movement visually
    explicit in yellow lines in the **Scene** panel by having a yellow "gizmo" rectangle
    drawn. Add the following method to the C# Script class called `PlayerMove`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 作为开发者，在测试运行我们的游戏时，看到像边界矩形这样的元素是有用的。让我们通过在 **场景** 面板中绘制一个黄色的“gizmo”矩形，使移动的矩形边界在黄色线条中直观地显示出来。将以下方法添加到名为
    `PlayerMove` 的 C# 脚本类中：
- en: '[PRE6]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: The `OnDrawGizmos()` method tests that the references to the corner_max and
    corner_min **GameObjects** are not null, and then sets the positions of the four
    Vector3 objects, representing the four corners defined by the rectangle, with
    the corner_max and corner_min **GameObjects** at the opposite corners. It then
    sets the **Gizmo** color to yellow, and draws lines, connecting the four corners
    in the **Scene** panel.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnDrawGizmos()` 方法检查对 corner_max 和 corner_min **GameObjects** 的引用是否不为空，然后设置代表矩形四个角的四个
    Vector3 对象的位置，这些对象位于相对的角上。然后，它将 **Gizmo** 颜色设置为黄色，并在 **场景** 面板中绘制线条，连接四个角。'
- en: Choosing destinations – finding a random spawn point
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择目的地 – 寻找一个随机出生点
- en: Many games make use of spawn points and waypoints. This recipe demonstrates
    choosing a random spawn point, and then the instantiation of an object at that
    chosen point.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 许多游戏都使用出生点和航点。此配方演示了选择一个随机出生点，然后在所选点实例化一个对象。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds upon the previous recipe. So, make a copy of this project,
    open it, and then follow the steps in the next section.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于之前的配方。因此，复制此项目，打开它，然后按照下一节中的步骤进行操作。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To find a random spawn point, follow these steps:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到一个随机出生点，请按照以下步骤操作：
- en: In the Scene panel, create a sphere (by navigating to Create | 3D Object | Sphere)
    sized as (1, 1, 1) at (2, 2, 2) position, and apply the m_red **Material**.
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景面板中，创建一个大小为 (1, 1, 1) 的球体（通过导航到 Create | 3D Object | Sphere），位置在 (2, 2, 2)，并应用
    m_red **材质**。
- en: In the Project panel, create a new **Prefab** (by going to Create | Prefab)
    named `Prefab-ball`, and drag your sphere into it (and then delete the sphere
    from the Hierarchy panel).
  id: totrans-108
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个新的 **Prefab**（通过转到 Create | Prefab），命名为 `Prefab-ball`，并将你的球体拖入其中（然后从层次结构面板中删除球体）。
- en: 'In the Scene panel, create a new capsule (by navigating to Create | 3D Object
    | Capsule) named `Capsule-spawnPoint` at (3, 0.5, 3), and give it a tag of Respawn
    (this is one of the default tags that Unity provides):'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在场景面板中，创建一个新的胶囊（通过导航到 Create | 3D Object | Capsule），命名为 `Capsule-spawnPoint`，位置在
    (3, 0.5, 3)，并给它一个标记为 Respawn（这是 Unity 提供的默认标记之一）：
- en: For testing, we'll leave these Respawn points visible. For the final game, we'll
    then uncheck the Mesh Rendered of each Respawn **GameObject** so that they are
    not visible to the Player.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 为了测试，我们将保留这些重生点的可见性。在最终游戏中，我们将取消选中每个重生 **GameObject** 的“网格渲染”选项，以便它们对玩家不可见。
- en: '![](img/9e33a140-8ca0-4924-8995-611f9309024a.png)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/9e33a140-8ca0-4924-8995-611f9309024a.png)'
- en: Make several copies of your Capsule-spawnPoint by moving them to different locations
    on the terrain.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作几个你的胶囊重生点的副本，将它们移动到地形上的不同位置。
- en: 'Create a C# Script class called SpawnBall, and add an instance object as a
    component to the Cube-player **GameObject**:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 SpawnBall 的 C# 脚本类，并将其作为组件添加到 Cube-player **GameObject**：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a C# Script class called `SpawnPointManager` and add an instance object
    as a component to the Cube-player **GameObject**:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `SpawnPointManager` 的 C# 脚本类，并将其作为组件添加到 Cube-player **GameObject**：
- en: '[PRE8]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Ensure that Cube-player is selected in the Inspector for the SpawnBall scripted
    component. Then, drag Prefab-ball over the public variable projectile called Prefab
    Ball.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保在检查器中选择 Cube-player 以用于 SpawnBall 脚本组件。然后，将 Prefab-ball 拖动到名为 public variable
    projectile 的公共变量“Prefab Ball”上。
- en: Now, run your game. Every second, a red ball should be spawned and disappear
    after half a second. The location each ball is spawned at should be random.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行你的游戏。每秒应该生成一个红色球体，并在半秒后消失。每个球体生成的位置应该是随机的。
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `Capsule-spawnPoint` objects represent candidate locations, where we might
    wish to create an instance of our ball **Prefab**. When our `SpawnPointManager`
    object, inside the Cube-player **GameObject**, receives the `Start()` message,
    the respawned **GameObject** array is set to the array, which is returned from
    the call to `FindGameObjectsWithTag("Respawn")`. This creates an array of all
    the objects in the scene with the Respawn tag—that is, all our `Capsule-spawnPoint`
    objects.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Capsule-spawnPoint` 对象代表可能创建我们的球体 **Prefab** 实例的候选位置。当我们的 `SpawnPointManager`
    对象在 Cube-player **GameObject** 内接收到 `Start()` 消息时，重生后的 **GameObject** 数组被设置为从
    `FindGameObjectsWithTag("Respawn")` 调用返回的数组。这创建了一个具有 Respawn 标记的所有场景对象的数组，即我们的所有
    `Capsule-spawnPoint` 对象。'
- en: When our `SpawnBall` object GameObject Cube-player receives the `Start()` message,
    it sets the `spawnPointManager` variable to be a reference to its sibling `SpawnPointManager`
    script component. Next, we use the `InvokeRepeating(...)` method to schedule the `CreateSphere()` method
    to be called every 1 second.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们的 `SpawnBall` 对象 GameObject Cube-player 接收到 `Start()` 消息时，它将 `spawnPointManager`
    变量设置为对其兄弟 `SpawnPointManager` 脚本组件的引用。接下来，我们使用 `InvokeRepeating(...)` 方法安排每秒调用一次
    `CreateSphere()` 方法。
- en: The `SpawnBall` method `CreateSphere()` assigns the `spawnPoint` variable to
    the **GameObject** returned by a call to the `RandomSpawnpoint(...)` method of
    our `spawnPointManager`. Then, it creates a new instance of `prefab_ball` (via
    the public variable) at the same position as the spawnPoint **GameObject**.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`SpawnBall` 方法 `CreateSphere()` 将 `spawnPoint` 变量赋值给由我们 `spawnPointManager`
    的 `RandomSpawnpoint(...)` 方法返回的 **GameObject**。然后，它通过公共变量在与 `spawnPoint` **GameObject**
    相同的位置创建一个新的 `prefab_ball` 实例。'
- en: See also
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 参见
- en: The same techniques and code can be used for selecting spawn points or waypoints.
    Refer to the *NPC NavMeshAgent control to follow waypoints in sequence* recipe
    in the next chapter ([Navigation Meshes and Agents](https://cdp.packtpub.com/unity_2017_cookbook/wp-admin/post.php?post=604&action=edit))
    for more information about waypoints.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的技术和代码可以用于选择重生点或航点。有关航点的更多信息，请参考下一章中的“*NPC NavMeshAgent 控制以顺序跟随航点*”配方（[导航网格和代理](https://cdp.packtpub.com/unity_2017_cookbook/wp-admin/post.php?post=604&action=edit)）。
- en: Choosing destinations – finding the nearest spawn point
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择目的地 – 寻找最近的重生点
- en: Rather than just choosing a random spawn point or waypoint, sometimes, we want
    to select the one closest to some object (such as the player's **GameObject**).
    In this recipe, we will modify the previous one to find the nearest spawn point
    to the player's cube, and use that location to spawn a new red ball prefab.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是仅仅选择一个随机的出生点或航点，有时我们希望选择离某个对象（如玩家的 **GameObject**）最近的那个。在这个配方中，我们将修改之前的配方以找到离玩家立方体最近的出生点，并使用该位置生成一个新的红色球体预制体。
- en: Getting ready
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备就绪
- en: This recipe builds upon the previous recipe. So, make a copy of this project,
    open it, and then follow the steps in the next section.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 此配方基于之前的配方。因此，复制此项目，打开它，然后按照下一节中的步骤操作。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To find the nearest spawn point, follow these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要找到最近的出生点，请按照以下步骤操作：
- en: 'Add the following method to the C# Script class called `SpawnPointManager`:'
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下方法添加到名为 `SpawnPointManager` 的 C# 脚本类中：
- en: '[PRE9]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'We now need to change the first line in the C# class called `SpawnBall` so
    that the `spawnPoint` variable is set by a call to our new method called `NearestSpawnpoint(...)`:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要更改名为 `SpawnBall` 的 C# 类中的第一行，以便通过调用我们新方法 `NearestSpawnpoint(...)` 来设置
    `spawnPoint` 变量：
- en: '[PRE10]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Now, run your game. Every second, a red ball should be spawned, and disappear
    after half a second. Use the arrow keys to move the player's red cube around the
    terrain. Each time a new ball is spawned, it should be at the spawn point closest
    to the player.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行你的游戏。每秒应该生成一个红色球体，半秒后消失。使用箭头键移动玩家的红色立方体在场景中。每次生成新的球体时，它应该位于离玩家最近的出生点。
- en: How it works...
  id: totrans-136
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In the `NearestSpawnpoint(...)` method, we set nearestSpawnpoint to the first
    (array index `0`) **GameObject** in the array as our default. We then loop through
    the rest of the array (array index `1` up to `spawnPoints.Length`). For each **GameObject**
    in the array, we test to see if its distance is less than the shortest distance
    so far, and if it is, then we update the shortest distance, and also set `nearestSpawnpoint`
    to the current element. When the array has been searched, we return the **GameObject**
    that the `nearestSpawnpoint` variable refers to.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `NearestSpawnpoint(...)` 方法中，我们将 nearestSpawnpoint 设置为数组中的第一个（数组索引 `0`）**GameObject**
    作为默认值。然后我们遍历数组的其余部分（数组索引 `1` 到 `spawnPoints.Length`）。对于数组中的每个 **GameObject**，我们测试其距离是否小于迄今为止的最短距离，如果是，则更新最短距离，并将
    `nearestSpawnpoint` 设置为当前元素。当数组搜索完毕后，我们返回 `nearestSpawnpoint` 变量所引用的 **GameObject**。
- en: There's more...
  id: totrans-138
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更多内容...
- en: There are some details that you don't want to miss out on.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些细节你不希望错过。
- en: Avoiding errors due to an empty array
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 避免因数组为空而导致的错误
- en: Let's make our code a little more robust so that it can cope with the issue
    of an empty `spawnPoints` array, that is, when there are no objects tagged as `Respawn`
    in the scene.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们使我们的代码更加健壮，以便它可以处理空 `spawnPoints` 数组的问题，即场景中没有标记为 `Respawn` 的对象。
- en: 'To cope with the no objects tagged as `Respawn`, we need to do the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 为了处理没有标记为 `Respawn` 的对象，我们需要执行以下操作：
- en: 'Improve our `Start()` method in the C# Script class called `SpawnPointManager` so
    that an *error* is logged if the array of the objects tagged as `Respawn` is empty:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改进名为 `SpawnPointManager` 的 C# 脚本类中的 `Start()` 方法，以便如果标记为 `Respawn` 的对象数组为空，则记录一个
    *错误*：
- en: '[PRE11]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Improve the `RandomSpawnPoint()` and `NearestSpawnpoint()` methods in the C#
    Script class called `SpawnPointManager` so that they still return a **GameObject**,
    even if the array is empty:'
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改进名为 `SpawnPointManager` 的 C# 脚本类中的 `RandomSpawnPoint()` 和 `NearestSpawnpoint()`
    方法，以确保即使数组为空，它们仍然返回一个 **GameObject**：
- en: '[PRE12]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Improve the `CreateSphere()` method in the C# class called `SpawnBall` so that
    we only attempt to instantiate a new **GameObject** if the `RandomSpawnPoint()`
    and `NearestSpawnpoint()` methods have returned a non-null object reference:'
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 改进名为 `SpawnBall` 的 C# 类中的 `CreateSphere()` 方法，以便只有在 `RandomSpawnPoint()` 和 `NearestSpawnpoint()`
    方法返回非空对象引用时，才尝试实例化新的 **GameObject**：
- en: '[PRE13]'
  id: totrans-148
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: See also
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 相关内容
- en: The same techniques and code can be used for selecting spawn points or waypoints.
    Refer to the *NPC* *NavMeshAgent control to follow waypoints in sequence* recipe
    in the next chapter ([Navigation Meshes and Agents](https://cdp.packtpub.com/unity_2017_cookbook/wp-admin/post.php?post=604&action=edit))
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样的技术和代码可以用于选择出生点或航点。请参考下一章中关于 *NPC* *NavMeshAgent 控制按顺序跟随航点* 的配方（[导航网格和代理](https://cdp.packtpub.com/unity_2017_cookbook/wp-admin/post.php?post=604&action=edit))。
- en: Choosing destinations – respawning to the most recently passed checkpoint
  id: totrans-151
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 选择目的地 – 回到最近通过的检查点
- en: A checkpoint usually represents a certain distance through the game (or perhaps
    a track) in which an agent (user or NPC) has succeeded reaching. Reaching (or
    passing) checkpoints often results in bonus awards, such as extra time, points,
    ammo, and so on. Also, if a player has multiple lives, then often a player will
    only be respawned back as far as the most recently passed checkpoint, rather than
    right to the beginning of the level.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 检查点通常表示游戏中（或可能是一条赛道）的某个距离，其中代理（用户或 NPC）成功到达。达到（或通过）检查点通常会导致奖励，例如额外时间、分数、弹药等。此外，如果玩家有多个生命，那么玩家通常只会被重生到最近通过的检查点，而不是直接回到关卡开始处。
- en: 'This recipe demonstrates a simple approach to the checkpoints, whereby once
    the player''s character has passed a checkpoint, if they die, they are moved back
    to the most recently passed checkpoint:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱演示了检查点的简单方法，即一旦玩家的角色通过检查点，如果他们死亡，他们将被移回最近通过的检查点：
- en: '![](img/c7e329b9-214a-46bd-9088-ad03fec4a8fb.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/c7e329b9-214a-46bd-9088-ad03fec4a8fb.png)'
- en: Getting ready
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds upon the player-controlled 3D cube Unity project that you
    created at the beginning of this chapter. So, make a copy of this project, open
    it, and then follow the steps for this recipe.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱基于您在本章开头创建的玩家控制的 3D 立方体 Unity 项目。因此，复制此项目，打开它，然后按照本食谱的步骤进行操作。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To have the respawn position change upon losing a life depending on the checkpoints
    passed, follow these steps:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 要根据通过的检查点在失去生命时更改重生位置，请按照以下步骤操作：
- en: Move the Cube-player **GameObject** to the (12, 0.5, 0) position.
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 Cube-player **GameObject** 移动到 (12, 0.5, 0) 位置。
- en: Select Cube-player in the Inspector panel and add a **Character Controller**
    component by clicking on Add Component | Physics | Character Controller (this
    is to enable the **OnTriggerEnter** collision messages to be received).
  id: totrans-160
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器面板中选择 Cube-player，通过点击添加组件 | 物理 | Character Controller 添加一个 **Character
    Controller** 组件（这是为了接收 **OnTriggerEnter** 碰撞消息）。
- en: Create a cube named Cube-checkpoint-1 at (5, 0, 0), scaled to (1, 1, 20).
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 (5, 0, 0) 位置创建一个名为 Cube-checkpoint-1 的立方体，缩放比例为 (1, 1, 20)。
- en: With Cube-checkpoint-1 selected, check the Is Trigger property of its Box Collider
    component in the Inspector panel.
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择 Cube-checkpoint-1 时，检查其 Box Collider 组件在检查器面板中的 Is Trigger 属性。
- en: Create a CheckPoint tag, and assign this tag to Cube-checkpoint-1.
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 CheckPoint 标签，并将此标签分配给 Cube-checkpoint-1。
- en: Duplicate Cube-checkpoint-1 and name the clone `Cube-checkpoint-2`, and position
    it at (-5, 0, 0).
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 Cube-checkpoint-1 并将其副本命名为 `Cube-checkpoint-2`，并将其放置在 (-5, 0, 0) 位置。
- en: Create a sphere named `Sphere-Death` at (7, 0.5, 0). Assign the m_red material
    to this sphere to make it red.
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 (7, 0.5, 0) 位置创建一个名为 `Sphere-Death` 的球体。将 m_red 材质分配给此球体以使其变红。
- en: With Sphere-Death selected, check the Is Trigger property of its Sphere Collider
    component in the Inspector panel.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在选择 Sphere-Death 时，检查其 Sphere Collider 组件在检查器面板中的 Is Trigger 属性。
- en: Create a `Death` tag, and assign this tag to Sphere-Death.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Death` 标签，并将此标签分配给 Sphere-Death。
- en: Duplicate Sphere-Death, and position this clone at (0, 0.5, 0).
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制 Sphere-Death，并将这个副本放置在 (0, 0.5, 0) 位置。
- en: Duplicate Sphere-Death a second time, and position this second clone at (-10,
    0.5, 0).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次复制 Sphere-Death，并将这个第二个副本放置在 (-10, 0.5, 0) 位置。
- en: 'Add an instance of the following C# Script class called `CheckPoints` to the
    Cube-player **GameObject**:'
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `CheckPoints` 的以下 C# 脚本类实例添加到 Cube-player **GameObject** 中：
- en: '[PRE14]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Run the scene. If the cube runs into a red sphere before crossing a checkpoint,
    it will be respawned back to its starting position. Once the red cube has passed
    a checkpoint, if a red sphere is hit, then the cube will be moved back to the
    location of the most recent checkpoint that it passed through.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 运行场景。如果立方体在通过检查点之前撞到红色球体，它将被重新生成到其起始位置。一旦红色立方体通过检查点，如果撞到红色球体，则立方体将被移回到它最近通过的检查点位置。
- en: How it works...
  id: totrans-174
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The C# script class called `CheckPoint` has one variable called `respawnPosition`,
    which is a **Vector3** that refers to the position the player's cube is to be
    moved to (respawned) if it collides with a `Death` tagged object. The default
    setting for this is the position of the player's cube when the scene begins, so
    in the `Start()` method, we set it to the player's position.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckPoint` C# 脚本类有一个名为 `respawnPosition` 的变量，它是一个 **Vector3**，指代玩家立方体将被移动到（重新生成）的位置，如果它与一个带有
    `Death` 标签的对象发生碰撞。此默认设置是场景开始时玩家立方体的位置，因此我们在 `Start()` 方法中将其设置为玩家的位置。'
- en: Each time an object tagged called `Checkpoint` is collided with, the value of
    `respawnPosition` is updated to the current position of the player's red cube
    at this point in time (that is, where it is when it touches the stretched cube
    tagged object called CheckPoint). The next time the object tagged `Death` is hit,
    the cube will be respawned back to where it last touched the object tagged called
    CheckPoint.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 每当与标记为`Checkpoint`的对象发生碰撞时，`respawnPosition`的值将更新为玩家红色立方体在此时此刻的位置（即它接触标记为CheckPoint的拉伸对象时的位置）。下一次当标记为`Death`的对象被击中时，立方体将重新生成到它上次接触标记为CheckPoint的对象的位置。
- en: Moving objects by clicking on them
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过点击移动对象
- en: Sometimes, we want to allow the user to interact with objects through mouse
    pointer clicks. In this recipe, we will allow the user to move an object in a
    random direction by clicking on it.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们希望允许用户通过鼠标指针点击与对象交互。在本食谱中，我们将允许用户通过点击来使对象向随机方向移动。
- en: Getting ready
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: 'This recipe builds upon the player-controlled 3D cube Unity project that you
    created at the beginning of this chapter. So, make a copy of this project, open
    it, and then follow the steps for this recipe. The result of following this recipe
    should look as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱基于你在本章开头创建的玩家控制的3D立方体Unity项目。因此，请复制此项目，打开它，然后按照本食谱的步骤进行操作。按照此食谱操作的结果应如下所示：
- en: '![](img/4b8fb3a4-1972-4e56-8bfb-ff6d1c820c6e.png)'
  id: totrans-181
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4b8fb3a4-1972-4e56-8bfb-ff6d1c820c6e.png)'
- en: How to do it...
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To move objects by clicking on them, follow these steps:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 通过点击来移动对象，请按照以下步骤操作：
- en: Delete the Cube-player **GameObject**.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除**立方体-玩家（Cube-player**）**游戏对象**。
- en: Set the Main Camera position to (0, 3, -5), and its rotation to (25, 0, 0).
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将主相机的位置设置为（0，3，-5），并将它的旋转设置为（25，0，0）。
- en: 'Create a C# Script class called `ClickMove`:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`ClickMove`的C#脚本类：
- en: '[PRE16]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Create a Cube **GameObject** and add an instance object of the script class
    `ClickMove` as a component.
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个**立方体（Cube**）**游戏对象（GameObject**），并将脚本类`ClickMove`的实例对象作为组件添加。
- en: You should see that a **RigidBody** component is automatically added to the
    new cube, since the script class has the directive `RequireComponent(typeof(Rigidbody))`.
    This only works if the directive is in the code before the script class is added
    to a **GameObject**.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 你应该会看到，由于脚本类中包含了指令 `RequireComponent(typeof(Rigidbody))`，新创建的立方体自动添加了一个**刚体（RigidBody**）组件。这仅在指令位于将脚本类添加到**游戏对象（GameObject**）之前时才有效。
- en: 'Make four more duplicates of the cube, and arrange the six objects into a pyramid
    by setting their positions to be the following:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 制作四个更多立方体的副本，并将六个对象按照以下位置排列成一个金字塔：
- en: '[PRE17]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Run the scene. Each time you use the mouse pointer to click on a cube, the clicked
    cube will have a random directional force applied to it. So, with a few clicks,
    you can knock down the pyramid!
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。每次使用鼠标指针点击立方体时，点击的立方体将受到一个随机方向上的力。因此，通过几次点击，你可以将金字塔推倒！
- en: How it works...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The public float variable multiplier allows you to change the maximum magnitude
    of the force by changing the value in the `ClickMove` scripted component of each
    cube.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 公共的`float`变量`multiplier`允许你通过更改每个立方体的`ClickMove`脚本组件中的值来改变力的最大大小。
- en: The `ClickMove` script class has a private variable called `rigidBody` set as
    a reference to the RigidBody component in the `Awake()` method.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: '`ClickMove`脚本类中有一个名为`rigidBody`的私有变量，在`Awake()`方法中将它设置为对RigidBody组件的引用。'
- en: Each time the cube receives a `MouseDown()` message (such as when it has been
    clicked with the user's mouse pointer), this method creates a random directional
    **Vector3**, and applies this as a force to the object's `rigidBody` reference.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 每次立方体接收到`MouseDown()`消息（例如，当用户用鼠标指针点击它时），此方法创建一个随机的方向**Vector3**，并将其作为力应用到对象的`rigidBody`引用上。
- en: The `RandomDirectionComponent()` method returns a random value between `-multiplier`
    and `+multiplier`.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: '`RandomDirectionComponent()`方法返回一个介于`-multiplier`和`+multiplier`之间的随机值。'
- en: Firing projectiles in the direction of movement
  id: totrans-198
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向移动方向发射弹丸
- en: 'Another common use of force is to apply a force to a newly instantiated object,
    making it a projectile travelling in the direction the Player''s **GameObject**
    is facing. That''s what we''ll create in this recipe. The result of following
    this recipe should look as follows:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 力的另一种常见用途是将力应用到新实例化的对象上，使其成为朝向玩家**游戏对象（GameObject**）面向的方向移动的弹丸。这就是本食谱中我们将要创建的内容。按照此食谱操作的结果应如下所示：
- en: '![](img/b1129371-8dba-467f-9351-7130a8e38c2b.png)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b1129371-8dba-467f-9351-7130a8e38c2b.png)'
- en: Getting ready
  id: totrans-201
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds upon the player-controlled 3D cube Unity project that you
    created at the beginning of this chapter. So, make a copy of this project, open
    it, and then follow the steps for this recipe.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方基于你在本章开头创建的玩家控制的3D立方体Unity项目。因此，复制此项目，打开它，然后按照此配方的步骤进行操作。
- en: How to do it...
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To fire projectiles in the direction of movement, follow these steps:'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 要在移动方向上发射弹体，请按照以下步骤操作：
- en: Create a new Sphere **GameObject** (by navigating to Create | 3D Object | Sphere).
    Set its size as (0.5, 0.5, 0.5).
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的球体 **GameObject**（通过导航到 创建 | 3D 对象 | 球体）。将其大小设置为 (0.5, 0.5, 0.5)。
- en: Add a RigidBody component to the Sphere (go to Physics | RigidBody).
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 RigidBody 组件添加到球体上（转到 物理 | RigidBody）。
- en: In the Project panel, create a new blue **Material** named `m_blue` (go to Create
    | Material).
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个新的蓝色 **材质** 命名为 `m_blue`（转到 创建 | 材质）。
- en: Apply the `m_blue` **Material** to your sphere.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `m_blue` **材质** 应用到你的球体上。
- en: In the Project panel, create a new **Prefab** named `prefab_projectile`.
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目面板中，创建一个新的 **Prefab** 命名为 `prefab_projectile`。
- en: Drag the sphere from the Hierarchy panel over your prefab_projectile (it should
    turn blue).
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将球体从层级面板拖动到你的 prefab_projectile 上（它应该变成蓝色）。
- en: You can now delete the Sphere from the Hierarchy.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你可以从层级中删除球体。
- en: Ensure that Cube-player is located at (0, 0.5, 0).
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保Cube-player位于 (0, 0.5, 0)。
- en: 'Create a new cube named `Cube-launcher`. Disable its Box Collider component,
    and set its transform as follows:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的立方体名为 `Cube-launcher`。禁用其 Box Collider 组件，并设置其变换如下：
- en: Position (0, 1, 0.3)
  id: totrans-214
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 位置 (0, 1, 0.3)
- en: Rotation (330, 0, 0)
  id: totrans-215
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 旋转 (330, 0, 0)
- en: Scale (0.1, 0.1, 0.5)
  id: totrans-216
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缩放 (0.1, 0.1, 0.5)
- en: In the Hierarchy, make Cube-launcher a child of Cube-player by dragging Cube-launcher
    onto Cube-player. This means that both objects will move together when the user
    presses the arrow keys.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在层级中，通过将 Cube-launcher 拖动到 Cube-player 上，使 Cube-launcher 成为 Cube-player 的子对象。这意味着当用户按下箭头键时，两个对象将一起移动。
- en: 'Create a C# Script class called `FireProjectile` and add an instance object
    as a component to Cube-launcher:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `FireProjectile` 的 C# 脚本类，并将其作为组件添加到 Cube-launcher 实例对象中：
- en: '[PRE18]'
  id: totrans-219
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: With Cube-launcher selected in the Inspector, from the Project panel, drag prefab_projectile
    into the public variable Projectile Prefab in the Fire Projectile (Script) component
    in the Inspector.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在检查器中选择 Cube-launcher，从项目面板中，将 prefab_projectile 拖动到检查器中 Fire Projectile（脚本）组件的公共变量
    Projectile Prefab。
- en: Run the scene. You can move around the terrain with the arrow keys, and each
    time you click the mouse button, you should see a blue sphere projectile launched
    in the direction that the player's cube is facing.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行场景。你可以使用箭头键在场景中移动，每次点击鼠标按钮，你应该看到从玩家立方体面向的方向发射出一个蓝色的球体弹体。
- en: How it works...
  id: totrans-222
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: You created a blue sphere as a **Prefab** (containing a RigidBody). You then
    created a scaled and rotated cube for the projectile launcher Cube-launcher, and
    childed this object to Cube-player.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 你创建了一个蓝色的球体作为 **Prefab**（包含 RigidBody）。然后你创建了一个缩放和旋转的立方体作为弹体发射器 Cube-launcher，并将此对象作为子对象添加到
    Cube-player 中。
- en: The `FireProjectile` script class contains a constant `FIRE_DELAY`—this is the
    minimum time between the firing of new projectiles, set to `0.25` seconds. There
    is also a second constant called `PROJECTILE_LIFE`—this is how long each projectile
    will "live" until it is automatically destroyed, otherwise, the scene and memory
    would fill up quickly with lots of old projectiles!
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`FireProjectile` 脚本类包含一个常量 `FIRE_DELAY`——这是发射新弹体之间的最小时间，设置为 `0.25` 秒。还有一个名为
    `PROJECTILE_LIFE` 的第二个常量——这是每个弹体“存活”的时间，直到它被自动销毁，否则，场景和内存会很快被大量旧弹体填满！'
- en: There are also two public variables. One is for the reference to the sphere
    prefab, and the second is for the initial speed of newly instantiated prefabs.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还有两个公共变量。一个是球体预制件的引用，另一个是新实例化的预制件的初始速度。
- en: There is also a private variable called `nextFireTime`—this is used to decide
    whether or not enough time has passed to allow a new projectile to be fired.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个名为 `nextFireTime` 的私有变量——这个变量用于判断是否已经过去了足够的时间，以便可以发射新的弹体。
- en: The `Update()` method tests the current time against the value of `nextFireTime`.
    If enough time has passed, then it will invoke the `CheckFireKey()` method.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: '`Update()` 方法将当前时间与 `nextFireTime` 的值进行比较。如果已经过去了足够的时间，那么它将调用 `CheckFireKey()`
    方法。'
- en: The `CheckFireKey()` method tests to see if the Fire1 button has been clicked.
    This is usually mapped to the left mouse button, but can be mapped to other input
    events through the Project Settings (navingate to Edit | Project Settings | Input).
    If the `Fire1` event is detected, then the next fire time is reset to be `FIRE_DELAY`
    seconds in the future, and a new projectile is created by invoking the `CreateProjectile()` method.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckFireKey()` 方法用于检测是否点击了 Fire1 按钮。这通常映射到左鼠标按钮，但可以通过项目设置（导航到 Edit | 项目设置
    | 输入）映射到其他输入事件。如果检测到 `Fire1` 事件，则下一次射击时间将被重置为未来的 `FIRE_DELAY` 秒，并通过调用 `CreateProjectile()`
    方法创建一个新的弹体。'
- en: The `CreateProjectile()` method gets the current position and rotation of the
    parent **GameObject**. Remember that the instance object of this class has been
    added to Cube-launcher, so our scripted object can use the position and rotation
    of this launcher as the initial settings for each new projectile. A new instance
    of `projectilePrefab` is created with these position and rotation settings.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateProjectile()` 方法获取父 **GameObject** 的当前位置和旋转。请记住，这个类的实例对象已经被添加到 Cube-launcher
    中，因此我们的脚本对象可以使用这个发射器的位置和旋转作为每个新弹体的初始设置。使用这些位置和旋转设置创建 `projectilePrefab` 的新实例。'
- en: Next, a Vector3 called `projectileVelocity` is created by multiplying the `projectileSpeed`
    variable with the standard forward vector (0, 0, 1). In Unity, for 3D objects,
    the Z-axis is generally the direction in which the object is facing.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，通过将 `projectileSpeed` 变量与标准前进向量（0, 0, 1）相乘，创建了一个名为 `projectileVelocity`
    的 Vector3。在 Unity 中，对于 3D 对象，Z 轴通常是对象面向的方向。
- en: The special method `TransformDirection(...)` is used to turn the local-space
    forward direction into a world-space direction so that we have a Vector representing
    a forward motion relative to the Cube-launcher object.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 使用特殊的 `TransformDirection(...)` 方法将局部空间的前进方向转换为世界空间方向，这样我们就有一个表示相对于 Cube-launcher
    对象的前进运动的 Vector。
- en: This world-space directional vector is then used to add a force to the projectile's
    RigidBody.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，使用这个世界空间方向向量给弹体的 RigidBody 添加力。
- en: Finally, a reference is made to the parent **GameObject** of the projectile,
    and the `Destroy(...)` method is used so that the projectile will be destroyed
    after `1.5` seconds—the value of `PROJECTILE_LIFE`.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，引用了弹体的父 **GameObject**，并使用 `Destroy(...)` 方法，以便弹体在 `1.5` 秒后——即 `PROJECTILE_LIFE`
    的值——被销毁。
- en: You can learn more about `Transform.TransformDirection()` at [https://docs.unity3d.com/ScriptReference/Transform.TransformDirection.html](https://docs.unity3d.com/ScriptReference/Transform.TransformDirection.html).
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://docs.unity3d.com/ScriptReference/Transform.TransformDirection.html](https://docs.unity3d.com/ScriptReference/Transform.TransformDirection.html)
    了解更多关于 `Transform.TransformDirection()` 的信息。
