<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-140"><a id="_idTextAnchor272"/>7</h1>
<h1 id="_idParaDest-141"><a id="_idTextAnchor273"/>Data Access in ASP.NET Core (Part 3: Tips)</h1>
<p>In <a href="B18971_06.xhtml#_idTextAnchor245"><em class="italic">Chapter 6</em></a>, we learned how to manage relationships between entities using the EF Core Fluent API. We introduced three types of relationships: one-to-one, one-to-many, and many-to-many. We also learned how to perform <strong class="bold">CRUD</strong> operations on related entities. With the knowledge we gained from <a href="B18971_06.xhtml#_idTextAnchor245"><em class="italic">Chapter 6</em></a>, we can now build a simple data access layer for most web API applications. However, there are still some scenarios that we need to handle properly. For example, how do we improve the performance of data access? And what should we do if there are concurrency conflicts?</p>
<p>In this chapter, we will cover some advanced topics related to data access in ASP.NET Core, including <code>DbContext</code> pooling, performance optimization, raw SQL queries, and concurrency conflicts. We will also discuss some tips and tricks that can help you write better code.</p>
<p>We will cover the following topics:</p>
<ul>
<li><code>DbContext</code> pooling</li>
<li>Tracking versus no-tracking queries</li>
<li>IQueryable versus IEnumerable</li>
<li>Client versus server evaluation</li>
<li>Raw SQL queries</li>
<li>Bulk operations</li>
<li>Concurrency conflicts</li>
<li>Reverse engineering</li>
<li>Other ORM frameworks</li>
</ul>
<p>After reading this chapter, you will have gained a deeper understanding of EF Core and be able to use it more effectively in your applications. You will have learned how to use no-tracking queries to improve query performance, as well as how to use raw SQL queries to execute complex queries. Additionally, you will understand how to use bulk operations to improve the performance of bulk data operations. Furthermore, you will be able to handle concurrency conflicts for large-scale applications and use reverse engineering to generate the entity classes and the <code>DbContext</code> class from an existing database.</p>
<h1 id="_idParaDest-142"><a id="_idTextAnchor274"/>Technical requirements</h1>
<p>The code examples in this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8</a>. You can use VS 2022 or VS Code to open the solutions.</p>
<h1 id="_idParaDest-143"><a id="_idTextAnchor275"/>Understanding DbContext pooling</h1>
<p>In the <a id="_idIndexMarker612"/>previous chapter, we learned how to register the <code>DbContext</code> instance as a scoped service in the DI container using the <code>AddDbContext()</code> extension method. By default, a new <code>DbContext</code> instance is created for each request, which is generally not a problem since it is a lightweight object that does not consume many resources. However, in a high-throughput application, the cost of setting up various internal services and objects for each <code>DbContext</code> instance can add up. To address this, EF Core provides a feature called <code>DbContext</code> instance to be reused across multiple requests.</p>
<p>To <a id="_idIndexMarker613"/>enable <code>DbContext</code> pooling, you can replace the <code>AddDbContext()</code> method with the <code>AddDbContextPool()</code> method. This resets the state of the <code>DbContext</code> instance when it is disposed of, stores it in a pool, and reuses it when a new request comes in. By reducing the cost of setting up the <code>DbContext</code> instance, <code>DbContext</code> pooling can significantly improve the performance of your application for high-throughput scenarios.</p>
<p>You can find the sample code for this section from the <code>/samples/chapter7/EfCoreDemo</code> folder in this chapter's GitHub repository.</p>
<p>Open the <code>Program.cs</code> file in the <code>EfCoreDemo</code> project. The following code shows how to enable <code>DbContext</code> pooling:</p>
<pre class="source-code">
services.AddDbContextPool&lt;InvoiceDbContext&gt;(options =&gt;{
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection"));
});</pre>
<p>The <code>AddDbContextPool()</code> method takes a <code>poolSize</code> parameter, which specifies the maximum number of <code>DbContext</code> instances that can be stored in the pool. The default value is <code>1024</code>, which is usually sufficient for most applications. If the pool is full, EF Core will start creating new <code>DbContext</code> instances as needed.</p>
<p>To validate<a id="_idIndexMarker614"/> whether <code>DbContext</code> pooling can improve the performance of the application, we can run a performance test. <strong class="bold">Grafana k6</strong> is an open-source<a id="_idIndexMarker615"/> load-testing tool that can be used to test the performance of web APIs. To use k6, you need to install NodeJS here: <a href="https://nodejs.org/">https://nodejs.org/</a>. Then you can download it from <a href="https://k6.io/docs/get-started/installation/">https://k6.io/docs/get-started/installation/</a>. k6 has packages for various platforms, including Windows, Linux, and macOS. Install k6 on your machine.</p>
<p>You can find a <code>script.js</code> file in the <code>k6</code> folder in the project. The <code>script.js</code> file is a k6 script that contains the test scenarios. The following code shows the content of the <code>script.js</code> file:</p>
<pre class="source-code">
import http from 'k6/http';import { sleep } from 'k6';
export const options = {
    vus: 500,
    duration: '30s',
  };
export default function () {
  http.get('http://localhost:5249/api/Invoices?page=1&amp;pageSize=10');
  sleep(1);
}</pre>
<p>This is a basic k6 test script that runs a 30-second, 500-VU load test. <code>GET</code> requests to the <code>/api/Invoices?page=1&amp;pageSize=10</code> endpoint for 30 seconds.</p>
<p>First, use <a id="_idIndexMarker617"/>the <code>AddDbContext()</code> method to register the <code>DbContext</code>, and run the application using the <code>dotnet run</code> command. Then, open a new terminal and run the following command to start the k6 test:</p>
<pre class="source-code">
k6 run script.js</pre> <p>Next, use the <code>AddDbContextPool()</code> method to register the <code>DbContext</code>, and test the application again using the same k6 script. You can compare the results of the two tests to see whether <code>DbContext</code> pooling improves the performance of the application. For example, one test result of using the <code>AddDbContext()</code> method is as follows:</p>
<div><div><img alt="Figure 7.1 – The test result of using the AddDbContext() method" src="img/B18971_07_1.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1 – The test result of using the AddDbContext() method</p>
<p>The following is the result of using the <code>AddDbContextPool</code> method:</p>
<div><div><img alt="Figure 7.2 – The test result of using the AddDbContextPool() method" src="img/B18971_07_2.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2 – The test result of using the AddDbContextPool() method</p>
<p>When <a id="_idIndexMarker618"/>using <code>AddDbContext()</code>, the average request duration is 1.07 s and 7,145 requests are completed, while when using <code>AddDbContextPool()</code>, the average request duration is 782.36 ms and 8,530 requests are completed. The results show that <code>DbContext</code> pooling can improve the performance of the application. Note that your results may vary depending on your machine’s configuration. Also, the <code>dotnet run</code> command is used to run the application in development mode, which is not optimized for performance. So, this test is just for demonstration purposes and cannot reflect the real performance of the application. However, it can give you an idea of how <code>DbContext</code> pooling works.</p>
<p class="callout-heading">Important note</p>
<p class="callout">For most applications, <code>DbContext</code> pooling is not necessary. You should enable <code>DbContext</code> pooling only if you have a high-throughput application. Therefore, before enabling <code>DbContext</code> pooling, it is important to test your application’s performance with and without it to see whether there’s any noticeable improvement.</p>
<p>In summary, while <code>DbContext</code> pooling can improve the performance of high-throughput applications, it’s not a one-size-fits-all solution. Be sure to evaluate your application’s specific needs before deciding whether to enable <code>DbContext</code> pooling or <a id="_idTextAnchor276"/>not.</p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor277"/>Understanding the difference between tracking versus no-tracking queries</h1>
<p>In this section, we will discuss the difference between tracking and no-tracking queries. What<a id="_idIndexMarker619"/> are tracking queries and no-tracking queries? Let us start from the beginning!</p>
<p>In the early days of .NET, the term <strong class="bold">SqlHelper</strong> was <a id="_idIndexMarker620"/>popular to refer to a static class that provided a set of methods to execute SQL queries. While SqlHelper simplified the process of executing SQL queries, developers still had to manage connection and transaction objects, write boilerplate code to map results to model objects, and work directly with the database.</p>
<p><strong class="bold">ORM</strong> frameworks such as EF Core were created to solve these problems. They not only simplify the process of executing SQL queries and mapping the results to model objects but also provide the ability to track changes made to the entities returned by queries. When changes are saved, EF Core generates the appropriate SQL queries to update the database. This is called tracking and is a significant benefit of using an ORM framework such as EF Core.</p>
<p>However, tracking comes at a cost. This can add overhead and memory usage, especially when dealing with a large number of entities.</p>
<p>We introduced a little bit about tracking in <a href="B18971_05.xhtml#_idTextAnchor198"><em class="italic">Chapter 5</em></a>. Let's see an example of tracking. You can find the sample code for this section from the <code>/samples/chapter7/EfCoreDemo</code> folder in this chapter's GitHub repository.</p>
<p>In the sample <code>EfCoreDemo</code> project, you can find the <code>GetInvoice</code> action in the <code>InvoicesController</code> class. The following code shows how the tracking works:</p>
<pre class="source-code">
[HttpGet("{id}")]public async Task&lt;ActionResult&lt;Invoice&gt;&gt; GetInvoice(Guid id)
{
    if (context.Invoices == null)
    {
        return NotFound();
    }
    logger.LogInformation($"Invoice {id} is loading from the database.");
    var invoice = await context.Invoices.FindAsync(id);
    logger.LogInformation($"Invoice {invoice?.Id} is loaded from the database."
    logger.LogInformation($"Invoice {id} is loading from the context.");
    invoice = await context.Invoices.FindAsync(id);
    logger.LogInformation($"Invoice {invoice?.Id} is loaded from the context.")
    if (invoice == null)
    {
        return NotFound();
    }
    return invoice;
}</pre>
<p>In the<a id="_idIndexMarker621"/> preceding code, we added some logging statements to see how EF Core calls the database. Run the application and call the <code>GetInvoice</code> action. You will see an output in the console like this:</p>
<pre class="console">
info: BasicEfCoreDemo.Controllers.InvoicesController[0]      Invoice e61436dd-0dac-4e8b-7d61-08dae88bb288 is loading from the database.
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (30ms) [Parameters=[@__get_Item_0='?' (DbType = Guid)], CommandType='Text', CommandTimeout='30']
      SELECT TOP(1) [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE [i].[Id] = @__get_Item_0
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Invoice e61436dd-0dac-4e8b-7d61-08dae88bb288 is loaded from the database.
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Invoice e61436dd-0dac-4e8b-7d61-08dae88bb288 is loading from the context.
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Invoice e61436dd-0dac-4e8b-7d61-08dae88bb288 is loaded from the context.</pre>
<p>When we<a id="_idIndexMarker622"/> call the <code>context.Invoices.FindAsync(id)</code> method for the first time, EF Core will query the database and return the <code>Invoice</code> entity. The second time, EF Core will return the <code>Invoice</code> entity from the context because the <code>Invoice</code> entity is already in the context.</p>
<p class="callout-heading">Find() versus Single()</p>
<p class="callout">When we get an entity from the database by its primary key, we can use the <code>Find()</code> or <code>FindAsync()</code> methods. Also, we can use the <code>Single()</code> or <code>SingleOrDefault()</code> methods. They are similar, but they are not the same. The <code>Find()</code> and <code>FindAsync()</code> methods are methods of the <code>DbSet</code> class. If an entity with the given primary key values is being tracked by the context, the <code>Find()</code> or <code>FindAsync()</code> methods will return the tracked entity without making a request to the database. Otherwise, EF Core will make a query to the database to get the entity, attach it to the context, and return it. But if you use the <code>Single()</code> or <code>SingleOrDefault()</code> methods, EF Core will always make a query to the database to get the entity. The same is true for the <code>First()</code> and <code>FirstOrDefault()</code> methods. So, the <code>Find()</code> and <code>FindAsync()</code> methods are more efficient for getting an entity by its primary key. But in rare cases, <code>Find()</code> and <code>FindAsync()</code> may return outdated data if the entity is updated in the database after it is loaded into the context. For example, if you use the bulk-update <code>ExecuteUpdateAsync()</code> method, the update will not be tracked by <code>DbContext</code>. Then, if you use <code>Find()</code> or <code>FindAsync()</code> to get the entity from <code>DbContext</code>, you will get the outdated data. In this case, you should use <code>Single()</code> or <code>SingleOrDefault()</code> to get the entity from the database again. In most cases, you can use the <code>Find()</code> or <code>FindAsync()</code> methods to get an entity by its primary key when you are sure the entity is always tracked by the <code>DbContext</code>.</p>
<p>An entity has<a id="_idIndexMarker623"/> one of the following <code>EntityState</code> values: <code>Detached</code>, <code>Added</code>, <code>Unchanged</code>, <code>Modified</code>, or <code>Deleted</code>. We introduced the <code>EntityState</code> enum in <a href="B18971_05.xhtml#_idTextAnchor198"><em class="italic">Chapter 5</em></a>. The following is how the states change:</p>
<ul>
<li>All the entities that are returned by the query (such as <code>Find()</code>, <code>Single()</code>, <code>First()</code>, <code>ToList()</code>, and their <code>async</code> overloads) are in the <code>Unchanged</code> state</li>
<li>If you update the properties of the entity, EF Core will change the state to <code>Modified</code></li>
<li>If you call the <code>Remove()</code> method on the entity, EF Core will change the state to <code>Deleted</code></li>
<li>If you call the <code>Add()</code> method on the entity, EF Core will change the state to <code>Added</code></li>
<li>If you call the <code>Attach()</code> method on the untracked entity, EF Core will track the entity and set the state to <code>Unchanged</code></li>
<li>If you call the <code>Detach()</code> method on the tracked entity, EF Core will not track the entity and will change the state to <code>Detached</code></li>
</ul>
<p>Note that EF Core can track the changes at the property level, meaning that if you update a property of an entity, EF Core will only update the property when you call the <code>SaveChanges</code> method.</p>
<p>To retrieve the <code>EntityEntry</code> object for an entity, we can use the <code>Entry()</code> method, which contains the state of the entity and the changed properties. Use the sample <code>EfCoreDemo</code> project in the <code>/samples/chapter7/EfCoreDemo</code> folder. You can find the <code>PutInvoice</code> action within the <code>InvoicesController</code> class:</p>
<pre class="source-code">
context.Entry(invoice).State = EntityState.Modified;await context.SaveChangesAsync();</pre>
<p>In the <a id="_idIndexMarker624"/>preceding code snippet, we obtained the <code>EntityEntry</code> object for the <code>Invoice</code> entity using the <code>Entry()</code> method and set its state to <code>Modified</code>. When <code>SaveChanges()</code> is called, EF Core persists the changes to the database.</p>
<p>By default, tracking is enabled in EF Core. However, there may be scenarios where you do not want EF Core to track changes to entities. For instance, in read-only queries within <code>Get</code> actions, where the <code>DbContext</code> only exists for the duration of the request, tracking is not necessary. Disabling tracking can enhance performance and save memory. If you don’t intend to modify entities, you should disable tracking by calling the <code>AsNoTracking()</code> method on the query. Here’s an example:</p>
<pre class="source-code">
// To get the invoice without trackingvar invoice = await context.Invoices.AsNoTracking().FirstOrDefaultAsync(x =&gt; x.Id == id);
// To return a list of invoices without tracking
var invoices = await context.Invoices.AsNoTracking().ToListAsync();</pre>
<p>If you have lots of read-only queries and you feel it is tedious to call the <code>AsNoTracking()</code> method every time, you can disable tracking globally when you configure the <code>DbContext</code>. The following code shows how to do this:</p>
<pre class="source-code">
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder){
    base.OnConfiguring(optionsBuilder);
    optionsBuilder.UseQueryTrackingBehavior(QueryTrackingBehavior.NoTracking);
}</pre>
<p>For any other queries that you want to track, you can call the <code>AsTracking()</code> method on the query, as shown in the following code:</p>
<pre class="source-code">
// To get the invoice with trackingvar invoice = await context.Invoices.AsTracking().FirstOrDefaultAsync(x =&gt; x.Id == id);
// To return a list of invoices with tracking
var invoices = await context.Invoices.AsTracking().ToListAsync();</pre>
<p>In the <a id="_idIndexMarker625"/>preceding code, we explicitly call the <code>AsTracking()</code> method to enable tracking for the query, so that we can update the entity and save the changes to the database.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If an entity is a keyless entity, EF Core will never track it. Keyless entity types do not have keys defined on them. They are configured by a <code>[Keyless]</code> data annotation or a Fluent API <code>HasNoKey()</code> method. The keyless entity is often used for read-only queries or views. We will not discuss keyless entities in detail in this book. You can refer to the official documentation at <a href="https://learn.microsoft.com/en-us/ef/core/modeling/keyless-entity-types">https://learn.microsoft.com/en-us/ef/core/modeling/keyless-entity-types</a> for more information.</p>
<p>Using no-tracking queries is a good way to improve performance for read-only scenarios. However, keep in mind that if you disable tracking, you will not be able to update the entities when you call the <code>SaveChanges()</code> method because EF Core cannot detect changes to untracked entities. So, it is important to consider the implications of using no-tracking queries before implementing them.</p>
<p>In addition to non-tracking queries, there are other factors that can affect the performance of data queries in EF Core. We will explore the differences between <code>IQueryable</code> and <code>IEnumerable</code> and how they impact query performance in the ne<a id="_idTextAnchor278"/>xt section.</p>
<h1 id="_idParaDest-145"><a id="_idTextAnchor279"/>Understanding the difference between IQueryable and IEnumerable</h1>
<p>When <a id="_idIndexMarker626"/>working with EF Core, you have two interfaces available to query the database: <code>IQueryable</code> and <code>IEnumerable</code>. Although these interfaces may seem similar at first glance, they have important differences that can affect your application’s performance. In this section, we will discuss the differences between <code>IQueryable</code> and <code>IEnumerable</code>, how they work, and when to use each of them.</p>
<p>You might be familiar with the <code>IEnumerable</code> interface. The <code>IEnumerable</code> interface is a standard .NET interface that is used to represent a collection of objects. It is used to iterate through the collection. Many .NET collections implement the <code>IEnumerable</code> interface, such as <code>List</code>, <code>Array</code>, <code>Dictionary</code>, and so on. The <code>IEnumerable</code> interface has a single method called <code>GetEnumerator</code>, which returns an <code>IEnumerator</code> object. The <code>IEnumerator</code> object is used to iterate through the collection.</p>
<p>The first difference between <code>IQueryable</code> and <code>IEnumerable</code> is that <code>IQueryable</code> is in the <code>System.Linq</code> namespace, while <code>IEnumerable</code> is in the <code>System.Collections</code> namespace. The <code>IQueryable</code> interface inherits from the <code>IEnumerable</code> interface, so <code>IQueryable</code> can do everything that <code>IEnumerable</code> does. But why do we need the <code>IQueryable</code> interface?</p>
<p>One of the key differences between <code>IQueryable</code> and <code>IEnumerable</code> is that <code>IQueryable</code> is used to query data from a specific data source, such as a database. <code>IEnumerable</code> is used to iterate through a collection in memory. When we use <code>IQueryable</code>, the query will be translated into a specific query language, such as SQL, and executed against the data source to get the results when we call the <code>ToList()</code> (or <code>ToAway()</code>) method or iterate the items in the collection.</p>
<p>Download the sample code from the <code>/samples/chapter7/EfCoreDemo</code> folder in the chapter's GitHub repository. You can find a <code>GetInvoices</code> action in the <code>InvoicesController</code> class.</p>
<p>First, let's use the <code>IQueryable</code> interface to query the database:</p>
<pre class="source-code">
// Use IQueryablelogger.LogInformation($"Creating the IQueryable...");
var list1 = context.Invoices.Where(x =&gt; status == null || x.Status == status);
logger.LogInformation($"IQueryable created");
logger.LogInformation($"Query the result using IQueryable...");
var query1 = list1.OrderByDescending(x =&gt; x.InvoiceDate)
    .Skip((page - 1) * pageSize)
    .Take(pageSize);
logger.LogInformation($"Execute the query using IQueryable");
var result1 = await query1.ToListAsync();
logger.LogInformation($"Result created using IQueryable");</pre>
<p>In the <a id="_idIndexMarker627"/>preceding code, <code>context.Invoices</code> is a <code>DbSet&lt;TEntity&gt;</code> object, which implements the <code>IQueryable</code> interface. The <code>Where()</code> method is used to filter the invoices by status, and returns an <code>IQueryable</code> object. Then, we use some other methods to sort and paginate the invoices. When we call the <code>ToListAsync()</code> method, the query will be translated into a SQL query and executed against the database to get the results. The logs show the execution order of the code:</p>
<pre class="source-code">
info: BasicEfCoreDemo.Controllers.InvoicesController[0]      Creating the IQueryable...
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      IQueryable created
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Query the result using IQueryable...
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Execute the query using IQueryable
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (49ms) [Parameters=[@__p_0='?' (DbType = Int32), @__p_1='?' (DbType = Int32)], CommandType='Text', CommandTimeout='30']
      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      ORDER BY [i].[InvoiceDate] DESC
      OFFSET @__p_0 ROWS FETCH NEXT @__p_1 ROWS ONLY
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Result created using IQueryable</pre>
<p>From the logs, we<a id="_idIndexMarker628"/> can see that the query is executed against the database when we call the <code>ToListAsync()</code> method. The query contains the <code>ORDER BY</code>, <code>OFFSET</code>, and <code>FETCH NEXT</code> clauses, which means the query is executed on the database server.</p>
<p>Next, let us use the <code>IEnumerable</code> interface to query the database:</p>
<pre class="source-code">
// Use IEnumerablelogger.LogInformation($"Creating the IEnumerable...");
var list2 = context.Invoices.Where(x =&gt; status == null || x.Status == status).AsEnumerable();
logger.LogInformation($"IEnumerable created");
logger.LogInformation($"Query the result using IEnumerable...");
var query2 = list2.OrderByDescending(x =&gt; x.InvoiceDate)
    .Skip((page - 1) * pageSize)
    .Take(pageSize);
logger.LogInformation($"Execute the query using IEnumerable");
var result2 = query2.ToList();
logger.LogInformation($"Result created using IEnumerable");</pre>
<p>In the <a id="_idIndexMarker629"/>preceding code, we use the <code>AsEnumerable()</code> method to convert the <code>IQueryable</code> object to an <code>IEnumerable</code> object. Then, we sort and paginate the invoices and call the <code>ToList()</code> method to get the results. The logs show the execution order of the code:</p>
<pre class="source-code">
info: BasicEfCoreDemo.Controllers.InvoicesController[0]      Creating the IEnumerable...
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      IEnumerable created
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Query the result  using IEnumerable...
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Execute the query using IEnumerable
info: Microsoft.EntityFrameworkCore.Database.Command[20101]
      Executed DbCommand (5ms) [Parameters=[], CommandType='Text', CommandTimeout='30']
      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
info: BasicEfCoreDemo.Controllers.InvoicesController[0]
      Result created using IEnumerable</pre>
<p>Look at the logs. The generated SQL query does not contain the <code>ORDER BY</code>, <code>OFFSET</code>, and <code>FETCH NEXT</code> clauses, which means the query fetched all the invoices from the database and then filtered, sorted, and paged the invoices in memory. If we have a large number of entities in the database, the second query will be very slow and inefficient.</p>
<p>Now, we can see the difference between the two interfaces. The <code>IQueryable</code> interface is a deferred execution query, which means the query is not executed when we add <a id="_idIndexMarker630"/>more conditions to the query. The query will be executed against the database when we call the <code>ToList()</code> or <code>ToArray()</code> methods or iterate the items in the collection. So, in complex and heavy queries, we should always use the <code>IQueryable</code> interface to avoid fetching all the data from the database. Be careful when you call the <code>ToList()</code> or <code>ToArray()</code> methods because <code>ToList()</code> or <code>ToArray()</code> (and their <code>async</code> overloads) will execute the query immediately.</p>
<p class="callout-heading">What LINQ methods can cause the query to be executed immediately?</p>
<p class="callout">There are a couple of operations that result in the query being executed immediately:</p>
<ul>
<li class="callout">Use the <code>for</code> or <code>foreach</code> loop to iterate the items in the collection</li>
<li class="callout">Use the <code>ToList()</code>, <code>ToArray()</code>, <code>Single()</code>, <code>SingleOrDefault()</code>, <code>First()</code>, <code>FirstOrDefault()</code>, or <code>Count()</code> methods, or the <code>async</code> overloads of these methods</li>
</ul>
<p>In this section, we explored the differences between <code>IQueryable</code> and <code>IEnumerable</code>. It is important to understand why we should use <code>IQueryable</code> instead of <code>IEnumerable</code> when querying the database for complex and heavy queries. Loading all the data from the database can cause performance issues if there are a large number of entities in the database.</p>
<p>Moving on, we will discuss another factor that can affect performance: c<a id="_idTextAnchor280"/>lient evaluation.</p>
<h1 id="_idParaDest-146"><a id="_idTextAnchor281"/>Client evaluation versus server evaluation</h1>
<p>In this section, we<a id="_idIndexMarker631"/> will discuss the difference between client evaluation and server evaluation. In the old versions of EF Core (earlier than EF Core 3.0), the wrong usage of LINQ queries that have client evaluation can cause significant performance issues. Let's see what client evaluation and server evaluation are.</p>
<p>When we use EF Core to query data from the database, we can just write LINQ queries, and EF Core will translate the LINQ queries into SQL queries and execute them against the database. However, sometimes, the LINQ operation must be executed<a id="_idIndexMarker632"/> on the client side. Check the following code in the <code>SearchInvoices</code> action method in the <code>InvoicesController</code> class:</p>
<pre class="source-code">
var list = await context.Invoices    .Where(x =&gt; x.ContactName.Contains(search) || x.InvoiceNumber.Contains(search))
    .ToListAsync();</pre>
<p>When we use the <code>Contains()</code> method, EF Core can translate the LINQ query into the following SQL query:</p>
<pre class="source-code">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (4ms) [Parameters=[@__search_0='?' (Size = 32), @__search_0_1='?' (Size = 32) (DbType = AnsiString)], CommandType='Text', CommandTimeout='30']
      SELECT [i].[Id], [i].[Amount], [i].[ContactName], [i].[Description], [i].[DueDate], [i].[InvoiceDate], [i].[InvoiceNumber], [i].[Status]
      FROM [Invoices] AS [i]
      WHERE (@__search_0 LIKE N'') OR CHARINDEX(@__search_0, [i].[ContactName]) &gt; 0 OR (@__search_0_1 LIKE '') OR CHARINDEX(@__search_0, [i].[InvoiceNumber]) &gt; 0</pre>
<p>You can see that the SQL query uses some native SQL functions to filter the data, which means that the SQL query is executed on the database server.  This is called <strong class="bold">server evaluation</strong>. EF Core tries to run server evaluation as much as possible.</p>
<p>Now, let's say we want to return the GST tax amount for each invoice. We can transfer the entity to a new object with the GST tax amount. Of course, the better way is to add a property for the tax in the <code>Invoice</code> entity. The following is a demonstration of how to do this.</p>
<p>Add a <code>static</code> method to calculate the GST tax amount:</p>
<pre class="source-code">
private static decimal CalculateTax(decimal amount){
    return amount * 0.15m;
}</pre>
<p>Update<a id="_idIndexMarker633"/> the code as follows:</p>
<pre class="source-code">
var list = await context.Invoices    .Where(x =&gt; x.ContactName.Contains(search) || x.InvoiceNumber.Contains(search))
    .Select(x =&gt; new Invoice
    {
        Id = x.Id,
        InvoiceNumber = x.InvoiceNumber,
        ContactName = x.ContactName,
        Description = $"Tax: ${CalculateTax(x.Amount)}. {x.Description}",
        Amount = x.Amount,
        InvoiceDate = x.InvoiceDate,
        DueDate = x.DueDate,
        Status = x.Status
    })
    .ToListAsync();</pre>
<p>We updated the <code>Description</code> property by adding the GST tax calculation. When we run the application and call the endpoint, we will see the generated SQL query is the same as the previous query. But the <code>Description</code> property has been updated in the result. This means the conversion is done on the client side. This is called <strong class="bold">client evaluation</strong>.</p>
<p>This kind of client evaluation is acceptable because the query does need to fetch the data from the database. The cost is very low. However, it might cause problems for some queries. For example, we want to query the invoices that have a GST tax amount greater than $10. Update the code as follows:</p>
<pre class="source-code">
var list = await context.Invoices    .Where(x =&gt; (x.ContactName.Contains(search) || x.InvoiceNumber.Contains(search)) &amp;&amp; CalculateTax(x.Amount) &gt; 10)
    .ToListAsync();</pre>
<p>When <a id="_idIndexMarker634"/>we call the endpoint, we will see the following error:</p>
<pre class="source-code">
fail: Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware[1]      An unhandled exception has occurred while executing the request.
      System.InvalidOperationException: The LINQ expression 'DbSet&lt;Invoice&gt;()
          .Where(i =&gt; i.ContactName.Contains(__search_0) || i.InvoiceNumber.Contains(__search_0) &amp;&amp; InvoicesController.CalculateTax(i.Amount) &gt; 10)' could not be translated. Additional information: Translation of method 'BasicEfCoreDemo.Controllers.InvoicesController.CalculateTax' failed. If this method can be mapped to your custom function, see https://go.microsoft.com/fwlink/?linkid=2132413 for more information. Either rewrite the query in a form that can be translated, or switch to client evaluation explicitly by inserting a call to 'AsEnumerable', 'AsAsyncEnumerable', 'ToList', or 'ToListAsync'. See https://go.microsoft.com/fwlink/?linkid=2101038 for more information.</pre>
<p>The error message is very clear. This is because the <code>CalculateTax()</code> method is not supported by EF Core. In old versions of EF Core (earlier than EF Core 3.0), EF Core will fetch all the data from the database and then filter the data in memory. It could cause performance issues. After EF Core 3.0, EF Core will throw an exception if the query cannot be translated correctly, to avoid potential performance issues.</p>
<p>But if you<a id="_idIndexMarker635"/> are sure the client evaluation is safe, such as when dealing with a small data size, you can explicitly use the <code>AsEnumerable()</code> method (or <code>AsAsyncEnumerable()</code>, <code>ToList()</code>, or <code>ToListAsync()</code>) to force EF Core to fetch all the data and then execute the query on the client side. Make sure you know what you are doing.</p>
<p class="callout-heading">Why must the CalculateTax() method be static?</p>
<p class="callout">EF Core caches the compiled query due to the expensive nature of compiling the query. If the <code>CalculateTax()</code> method is not static, EF Core will need to maintain a reference to a constant expression of the <code>InvoicesController</code> through the <code>CalculateTax()</code> instance method, which could potentially lead to memory leaks. To prevent this, EF Core throws an exception if the <code>CalculateTax()</code> method is not static. Making the method static will ensure that EF Core does not capture constant in the instance.</p>
<p>The latest version of EF Core offers the benefit of preventing potential performance issues caused by client evaluation. If you encounter an exception similar to a previous one, you can review the query to ensure it is being translated correctly.</p>
<p>Next, we will discuss how to use raw SQL queries in EF Core. For some scenarios, we need to write raw SQL queries to execute complex queries.</p>
<h1 id="_idParaDest-147"><a id="_idTextAnchor282"/>Using raw SQL queries</h1>
<p>Although<a id="_idIndexMarker636"/> EF Core can translate most LINQ queries into SQL queries, which is very convenient, sometimes we need to write raw SQL queries if the required query cannot be written in LINQ, or the generated SQL query is not efficient. In this section, we will explore how to use raw SQL queries in EF Core.</p>
<p>EF Core provides several methods to execute raw SQL queries:</p>
<ul>
<li><code>FromSql()</code></li>
<li><code>FromSqlRaw()</code></li>
<li><code>SqlQuery()</code></li>
<li><code>SqlQueryRaw()</code></li>
<li><code>ExecuteSql()</code></li>
<li><code>ExecuteSqlRaw()</code></li>
</ul>
<p>When we<a id="_idIndexMarker637"/> execute raw SQL queries, we must be careful to avoid SQL injection attacks. Let's see when we should use raw SQL queries and how to use them properly. You can download the sample code from the <code>/samples/chapter7/EfCoreDemo</code> folder in the chapter's GitHub repository.</p>
<h2 id="_idParaDest-148"><a id="_idTextAnchor283"/>FromSql() and FromSqlRaw()</h2>
<p>We can<a id="_idIndexMarker638"/> use the <code>FromSql()</code> method to create a LINQ query based on an interpolated string. The <code>FromSql()</code> method is available in EF Core 7.0 and later versions. There is a similar method called <code>FromSqlInterpolated()</code> in older versions.</p>
<p>To execute the raw SQL query, we<a id="_idIndexMarker639"/> just need to pass the interpolated string to the <code>FromSql()</code> method, as follows:</p>
<pre class="source-code">
var list = await context.Invoices    .FromSql($"SELECT * FROM Invoices WHERE Status = 2")
    .ToListAsync();</pre>
<p>We can also pass parameters to the raw SQL query. For example, we want to query the invoices that have a specific status:</p>
<pre class="source-code">
[HttpGet][Route("status")]
public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(string status)
{
    // Omitted for brevity
    var list = await context.Invoices
        .FromSql($"SELECT * FROM Invoices WHERE Status = {status}")
        .ToListAsync();
    return list;
}</pre>
<p>Wait, is it<a id="_idIndexMarker640"/> safe to insert a string into the SQL query directly? What if the <code>status</code> parameter is <code>'; DROP TABLE Invoices; --</code>? Will it cause a SQL injection attack?</p>
<p>That is a<a id="_idIndexMarker641"/> good question. Let us see how EF Core handles the parameters. Run the application and call the <code>/api/invoices/status?status=AwaitPayment</code> endpoint. We will see the generated SQL query is as follows:</p>
<pre class="source-code">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (41ms) [Parameters=[p0='?' (Size = 4000)], CommandType='Text', CommandTimeout='30']
      SELECT * FROM Invoices WHERE Status = @p0</pre>
<p>The parameter is not inserted into the SQL query directly. Instead, EF Core uses the <code>@p0</code> parameter placeholder and passes the parameter value to the SQL query. This is called a parameterized query. It is safe to use the parameterized query to avoid SQL injection attacks. So, we do not need to worry about the safety of the <code>FromSql</code> method.</p>
<p class="callout-heading">Why FromSql() is safe to use</p>
<p class="callout">The <code>FromSql()</code> method expects a parameter as the <code>FormattableString</code> type. So, it is required to use the interpolated string syntax by using the <code>$</code> prefix. The syntax looks like regular C# string interpolation, but it is not the same thing. A <code>FormattableString</code> type can include interpolated parameter placeholders. The interpolated parameter values will be automatically converted to the <code>DbParameter</code> type. So, it is safe to use the <code>FromSql()</code> method to avoid SQL injection attacks.</p>
<p>For some scenarios, we might need to build dynamic SQL queries. For example, we want to query the invoices according to user input, which specifies the property name and property value. For this case, we cannot use <code>FromSql</code> because it is not allowed to <a id="_idIndexMarker642"/>parameterize the column names. We need to <a id="_idIndexMarker643"/>use <code>FromSqlRaw</code> instead. However, we must be careful to avoid SQL injection attacks. It is the developer’s responsibility to make sure the SQL query is safe. Here is an example:</p>
<pre class="source-code">
[HttpGet][Route("free-search")]
public async Task&lt;ActionResult&lt;IEnumerable&lt;Invoice&gt;&gt;&gt; GetInvoices(string propertyName, string propertyValue)
{
    if (context.Invoices == null)
    {
        return NotFound();
    }
    // Do something to sanitize the propertyName value
    var value = new SqlParameter("value", propertyValue);
    var list = await context.Invoices
        .FromSqlRaw($"SELECT * FROM Invoices WHERE {propertyName} = @value", value)
        .ToListAsync();
    return list;
}</pre>
<p>In the preceding example, the column name is not parameterized. Therefore, we must be careful to avoid SQL injection attacks. It is required to sanitize the <code>propertyName</code> value to make sure it is safe. Maybe you can check whether the value contains any special characters, such as <code>;</code>, <code>--</code>, and so on. If the value contains any special characters, you can throw an exception or remove the special characters before executing the SQL query. Also, if you allow the user to specify the column name, it will increase the effort to validate the column name because you need to check whether the column <a id="_idIndexMarker644"/>name exists in the database or whether the column has the correct index. Make sure you know what you are doing.</p>
<p>The <code>propertyValue</code> is parameterized, so it is safe to use.</p>
<p>After you <a id="_idIndexMarker645"/>build the SQL query using <code>FromSql()</code>, you can then apply the LINQ query operators to filter the data as you want. Remember that it is better to use <code>FromSql()</code> than <code>FromSqlRaw()</code>.</p>
<p>When we use the <code>FromSql()</code> or <code>FromSqlRaw()</code> methods, keep in mind that there are some limitations:</p>
<ul>
<li>The data returned from the SQL query must contain all the properties of the entity, otherwise, EF Core cannot map the data to the entity.</li>
<li>The column names returned from the SQL query must match the column names that the entity properties are mapped to.</li>
<li>The SQL query can only query one table. If you need to query multiple tables, you can build the raw query first and then use the <code>Include()</code> method t<a id="_idTextAnchor284"/>o include the related entities.</li>
</ul>
<h2 id="_idParaDest-149"><a id="_idTextAnchor285"/>SqlQuery() and SqlQueryRaw()</h2>
<p>The <code>FromSql()</code> method is<a id="_idIndexMarker646"/> useful when we want to <a id="_idIndexMarker647"/>query entities from the database using a raw SQL query. For some cases, we want to execute the raw SQL query and return a scalar value or non-entity type. For example, we want to query the IDs of invoices that have a specific status. We can use the <code>SqlQuery()</code> method to execute the raw SQL query and return a list of IDs. Here is an example:</p>
<pre class="source-code">
[HttpGet][Route("ids")]
public ActionResult&lt;IEnumerable&lt;Guid&gt;&gt; GetInvoicesIds(string status)
{
    var result = context.Database
        .SqlQuery&lt;Guid&gt;($"SELECT Id FROM Invoices WHERE Status = {status}")
        .ToList();
    return result;
}</pre>
<p>The <a id="_idIndexMarker648"/>translated SQL <a id="_idIndexMarker649"/>query is as follows:</p>
<pre class="source-code">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (22ms) [Parameters=[p0='?' (Size = 4000)], CommandType='Text', CommandTimeout='30']
      SELECT Id FROM Invoices WHERE Status = @p0</pre>
<p>Note that the <code>SqlQuery()</code> method is used on the <code>Database</code> property of the <code>DbContext</code> object. It is not available on the <code>DbSet</code> object.</p>
<p>The <code>SqlQueryRaw()</code> method<a id="_idIndexMarker650"/> is similar to the <code>SqlQuery()</code> method, but <a id="_idIndexMarker651"/>it allows us to build dynamic SQL queries like the <code>FromSqlRaw()</code> method. Similarly, you must take responsib<a id="_idTextAnchor286"/>ility to avoid SQL injection attacks.</p>
<h2 id="_idParaDest-150"><a id="_idTextAnchor287"/>ExecuteSql() and ExecuteSqlRaw()</h2>
<p>For some <a id="_idIndexMarker652"/>scenarios, where<a id="_idIndexMarker653"/> we do not need return values, we can use the <code>ExecuteSql</code> method to execute a raw SQL query. Normally, it is used to update or delete data or call<a id="_idIndexMarker654"/> a <code>ExecuteSql()</code> method to execute the raw SQL query. Here is an example:</p>
<pre class="source-code">
[HttpDelete][Route("status")]
public async Task&lt;ActionResult&gt; DeleteInvoices(string status)
{
    var result = await context.Database
        .ExecuteSqlAsync($"DELETE FROM Invoices WHERE Status = {status}");
    return Ok();
}</pre>
<p>In this way, we <a id="_idIndexMarker655"/>do not need to load the entities <a id="_idIndexMarker656"/>from the database and then delete them one by one. It is much more efficient to use the <code>ExecuteSql()</code> method to execute the raw SQL query.</p>
<p>The <code>ExecuteSqlRaw()</code> method is<a id="_idIndexMarker657"/> similar to the <code>ExecuteSql()</code> method, but<a id="_idIndexMarker658"/> it allows us to build dynamic SQL queries like the <code>FromSqlRaw()</code> method. Similarly, you must be very careful to sanitize the SQL query to avoid SQL injection attacks.</p>
<p>In this section, we introduced how to use raw SQL queries in EF Core. We discussed the differences between <code>FromSql()</code> and <code>FromSqlRaw()</code>, <code>SqlQuery()</code> and <code>SqlQueryRaw()</code>, and <code>ExecuteSql()</code> and <code>ExecuteSqlRaw()</code>. We also discussed the limitations of these methods. Again, we must be very careful to avoid SQL injection attacks when we use raw SQL queries.</p>
<p>In one of the examples in this section, we showed you how to run a raw SQL query to delete a set of entities. EF Core 7.0 introduces a bulk operations feature that can make this easier. There are two new methods available for bulk operations, <code>ExecuteUpdate()</code> and <code>ExecuteDelete()</code>, which provide a more efficient way to update or delete data. In the following section, <a id="_idTextAnchor288"/>we will discuss this feature in more detail.</p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor289"/>Using bulk operations</h1>
<p>In this <a id="_idIndexMarker659"/>section, we will explore how to effectively update/delete data using EF Core. EF Core 7.0 or later offers the ability of bulk operations, which are easy to use and can improve the performance of update/delete operations. To take advantage of this feature, ensure you are using the most recent version of EF Core.</p>
<p>As we mentioned in the previous section, EF Core tracks the changes in entities. To update an entity, normally, we need to load the entity from the database, update the entity properties, and then call the <code>SaveChanges()</code> method to save the changes to the database. This is a very common scenario. Deleting an entity is similar. However, if we want to update or delete a large number of entities, it is not efficient to load the entities one by one and then update or delete them. For these scenarios, it is not required to track the changes in the entities. So, it would be better to use the bulk operations feature to update or delete data.</p>
<p>We can use a raw SQL query to update or delete data using the <code>ExecuteSql()</code> method. However, it lacks strong type support. Hardcoding the column names in the SQL query is not a good practice. From EF Core 7.0, we can use the <code>ExecuteUpdate()</code> and <code>ExecuteDelete()</code> methods to update or delete data. Note that these two methods do not involve the entity tracking feature. So, once you call these two methods, the changes will be executed immediately. There is no need to call the <code>SaveChanges()</code> method.</p>
<p>Next, let us see how to use these two methods. We will show you how to use the <code>ExecuteUpdate()</code> method and what SQL query is generated. The <code>ExecuteDelete()</code> method is similar. The sample code is located at the <code>/samples/chapter7/EfCoreDemo</code> folder in the chapter's GitHub repository.</p>
<h2 id="_idParaDest-152"><a id="_idTextAnchor290"/>ExecuteUpdate()</h2>
<p>The <code>ExecuteUpdate()</code> method <a id="_idIndexMarker660"/>is used to update data without loading the entities from the database. You can use it to update one or more entities by adding the <code>Where()</code> clause.</p>
<p>For example, we want to update the status of the invoices that were created before a specific date. The code is as follows:</p>
<pre class="source-code">
[HttpPut][Route("status/overdue")]
public async Task&lt;ActionResult&gt; UpdateInvoicesStatusAsOverdue(DateTime date)
{
    var result = await context.Invoices
        .Where(i =&gt; i.InvoiceDate &lt; date &amp;&amp; i.Status == InvoiceStatus.AwaitPayment)
        .ExecuteUpdateAsync(s =&gt; s.SetProperty(x =&gt; x.Status, InvoiceStatus.Overdue));
    return Ok();
}</pre>
<p>The generated SQL query is as follows:</p>
<pre class="source-code">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (46ms) [Parameters=[@__p_0='?' (DbType = DateTimeOffset)], CommandType='Text', CommandTimeout='30']
      UPDATE [i]
      SET [i].[Status] = 'Overdue'
      FROM [Invoices] AS [i]
      WHERE [i].[InvoiceDate] &lt; @__p_0 AND [i].[Status] = 'AwaitPayment'</pre>
<p>This query can update multiple invoices at the same time. It does benefit from the strong type support but has the same efficiency as the raw SQL query. If you need to update more <a id="_idIndexMarker661"/>than one property, you can use the <code>SetProperty()</code> method multiple times, as seen in the following code:</p>
<pre class="source-code">
var result = await context.Invoices        .Where(i =&gt; i.InvoiceDate &lt; date &amp;&amp; i.Status == InvoiceStatus.AwaitPayment)
        .ExecuteUpdateAsync(s =&gt;
            s.SetProperty(x =&gt; x.Status, InvoiceStatus.Overdue)
            .SetProperty(x =&gt; x.LastUpdatedDate, DateTime.Now));</pre>
<p>In addition, the <code>Where()</code> clause can reference the other entities. So, the <code>ExecuteUpdate()</code> method is always recommended to update multipl<a id="_idTextAnchor291"/>e entities, instead of using the raw SQL query.</p>
<h2 id="_idParaDest-153"><a id="_idTextAnchor292"/>ExecuteDelete()</h2>
<p>Similarly, we <a id="_idIndexMarker662"/>can use the <code>ExecuteDelete()</code> method to delete data without loading the entities from the database. This method can be used to delete one or more entities by adding the <code>Where</code> clause. For example, we want to delete the invoices that were created before a specific date. The code is as follows:</p>
<pre class="source-code">
await context.Invoices.Where(x =&gt; x.InvoiceDate &lt; date).ExecuteDeleteAsync();</pre> <p>Again, these bulk operations do not track the changes in the entities. If a <code>DbContext</code> instance already loaded the entities, after the bulk update or delete, the entities in the context will still keep the old values. So, be careful when using these bulk operations.</p>
<p>In this section, we discussed how to use the bulk operations feature in EF Core. We introduced the <code>ExecuteUpdate()</code> and <code>ExecuteDelete()</code> methods, which can be used to update or delete data without loading the entities from the database. Compared to a raw SQL query, these two methods have strong type support. It is recommended to use these two methods to update or delete multiple entities.</p>
<p>Next, we will learn how to <a id="_idTextAnchor293"/>manage concurrency conflicts when updating data.</p>
<h1 id="_idParaDest-154"><a id="_idTextAnchor294"/>Understanding concurrency conflicts</h1>
<p>An API endpoint <a id="_idIndexMarker663"/>can be called by multiple clients at the same time. If the endpoint updates data, the data may be updated by another client before the current client completes the update. When the same entity is updated by multiple clients, it can cause a concurrency conflict, which may result in data loss or inconsistency, or even cause data corruption. In this section, we will discuss how to handle concurrency conflicts in EF Core. You can download the sample project <code>ConcurrencyConflictDemo</code> from  the <code>/samples/chapter7/ConcurrencyConflictDemo</code> folder in the chapter's GitHub repository.</p>
<p>There are two ways to <a id="_idIndexMarker664"/>handle concurrency conflicts:</p>
<ul>
<li><strong class="bold">Pessimistic concurrency control</strong>: This uses database locks to prevent multiple <a id="_idIndexMarker665"/>clients from updating the same entity at the same time. When a client tries to update an entity, it will first acquire a lock on the entity. If the lock is acquired successfully, only this client can update the entity, and all other clients will be blocked from updating the entity until the lock is released. However, this approach may result in performance issues when the number of concurrent clients is large because managing locks is expensive. EF Core does not have built-in support for pessimistic concurrency control.</li>
<li><strong class="bold">Optimistic concurrency control</strong>: This way does not involve locks; instead, a version<a id="_idIndexMarker666"/> column is used to detect concurrency conflicts. When a client tries to update an entity, it will first get the value of the version column, and then compare this value with the old value when updating the entity. If the value of the version column is the same, it means that no other client has updated the entity. In this case, the client can update the entity. But if the value of the version column is different from the old value, it means that another client has updated <a id="_idIndexMarker667"/>the entity. In this case, EF Core will throw an exception to indicate the concurrency conflict. The client can then handle the exception and retry the update operation.</li>
</ul>
<p>Let's see an example <a id="_idIndexMarker668"/>of concurrency conflicts. In the <code>ConcurrencyConflictDemo</code> project, we have a <code>Product</code> entity with an <code>Inventory</code> property, which is used to store the number of products in stock. We want to create an API endpoint to sell a product. When a client calls this endpoint, it will pass the product ID and the number of products to sell. The endpoint will then update the <code>Inventory</code> property by subtracting the number of products to sell. The logic is as follows:</p>
<ul>
<li>The client calls the API endpoint to sell a product.</li>
<li>The application gets the product from the database.</li>
<li>The application checks the <code>Inventory</code> property to make sure that the number of products in stock is enough for the sale:<ul><li>If the number of products in stock is enough, the application subtracts the number of products being sold from the <code>Inventory</code> property and then calls the <code>SaveChanges()</code> method to save the changes to the database</li><li>If the number of products in stock is not enough, the application returns an error message to the client</li></ul></li>
</ul>
<p class="callout-heading">Important note</p>
<p class="callout">The example project uses the following code to reset the database in the <code>Program.cs</code> file when the application starts:</p>
<p class="callout"><code>dbContext.Database.EnsureDeleted();</code></p>
<p class="callout"><code>dbContext.Database.EnsureCreated();</code></p>
<p class="callout">So, when you run the application, the database will be reset, and the <code>Inventory</code> property of product 1 will be set to <code>15</code>.</p>
<p>The following code<a id="_idIndexMarker669"/> shows the first version of the implementation of the API endpoint:</p>
<pre class="source-code">
[HttpPost("{id}/sell/{quantity}")]public async Task&lt;ActionResult&lt;Product&gt;&gt; SellProduct(int id, int quantity)
{
    if (context.Products == null)
    {
        return Problem("Entity set 'SampleDbContext.Products' is null.");
    }
    var product = await context.Products.FindAsync(id);
    if (product == null)
    {
        return NotFound();
    }
    if (product.Inventory &lt; quantity)
    {
        return Problem("Not enough inventory.");
    }
    product.Inventory -= quantity;
    await context.SaveChangesAsync();
    return product;
}</pre>
<p>There should be some other logic that handles the order creation and payment, and so on. We will not discuss that here; instead, we will focus on the concurrency conflicts caused by <a id="_idIndexMarker670"/>the product inventory update:</p>
<ol>
<li>To simulate this concurrent scenario, we can pass a <code>delay</code> parameter to add a delay before saving the changes to the database. The following code shows how to add a delay:<pre class="source-code">
[HttpPost("{id}/sell/{quantity}")]public async Task&lt;ActionResult&lt;Product&gt;&gt; SellProduct(int id, int quantity, int delay = 0){    // Omitted code for brevity    await Task.Delay(TimeSpan.FromSeconds(delay));    product.Inventory -= quantity;    await context.SaveChangesAsync();    return product;}</pre></li> <li>Now, let us try to call the API endpoint twice in a short time. The first <code>POST</code> request will pass a <code>delay</code> parameter with a value of <code>2</code> seconds:<pre class="source-code">
http://localhost:5273/api/Products/1/sell/10?delay=2</pre><p class="list-inset">The second <code>POST</code> request will pass the <code>delay</code> parameter with a value of <code>3</code> seconds:</p><pre class="source-code">http://localhost:5273/api/Products/1/sell/10?delay=3</pre></li> <li>Send the first request and then send the second request in <code>2</code> seconds. The expected result should be that the first request will succeed and the second request will fail. But actually, both requests will succeed. The responses show that the <code>Inventory</code> property of the product is updated to <code>5</code>, which is incorrect. The initial value of the <code>Inventory</code> property is <code>15</code>, and we sold 20 products, so how can the <code>Inventory</code> property be updated to <code>5</code>?</li>
</ol>
<p>Let us see what <a id="_idIndexMarker671"/>happens in the application:</p>
<ol>
<li>Client A calls the API endpoint to sell a product and wants to sell 10 products.</li>
<li>Client A checks the <code>Inventory</code> property and finds that the number of products in stock is 15, which is enough to sell.</li>
<li>Almost at the same time, client B calls the API endpoint to sell a product and wants to sell 10 products.</li>
<li>Client B checks the <code>Inventory</code> property and finds that the number of products in stock is 15 because client A has not updated the <code>Inventory</code> property yet.</li>
<li>Client A subtracts 10 from the <code>Inventory</code> property, which results in a value of <code>5</code>, and saves the changes to the database. Now, the number of products in stock is <code>5</code>.</li>
<li>Client B also subtracts 10 from the <code>Inventory</code> property and saves the changes to the database. The problem is that the number of products in stock has been updated to <code>5</code> by client A, but client B does not know this. So, client B also updates the <code>Inventory</code> property to <code>5</code>, which is incorrect.</li>
</ol>
<p>This is an example of concurrency conflict. Multiple clients try to update the same entity at the same time, and the result is not what we expected. In this case, client B should not be able to update the <code>Inventory</code> property because the number of products in stock is not enough. However, if the application does not handle concurrency conflicts, we may end up with incorrect data in the database.</p>
<p>To solve this problem, EF Core provides optimistic concurrency control. There are two ways to use optimistic concurrency control:</p>
<ul>
<li>Native database-generate<a id="_idTextAnchor295"/>d concurrency token</li>
<li>Application-managed concurrency token</li>
</ul>
<p>Let us see how to use these two ways to handle concurrency conflicts.</p>
<h2 id="_idParaDest-155"><a id="_idTextAnchor296"/>Native database-generated concurrency token</h2>
<p>Some<a id="_idIndexMarker672"/> databases, such as SQL Server, provide a native mechanism to handle concurrency conflicts. To use the native database-generated concurrency token in SQL Server, we need to create a new property for the <code>Product</code> class and add a <code>[Timestamp]</code> attribute to it. The following code shows the updated <code>Product</code> class:</p>
<pre class="source-code">
public class Product{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Inventory { get; set; }
    // Add a new property as the concurrency token
    public byte[] RowVersion { get; set; }
}</pre>
<p>In the Fluent API configuration, we need to add the following code to map the <code>RowVersion</code> property to the <code>rowversion</code> column in the database:</p>
<pre class="source-code">
modelBuilder.Entity&lt;Product&gt;()    .Property(p =&gt; p.RowVersion)
    .IsRowVersion();</pre>
<p>If you prefer to use the data annotation configuration, you can add the <code>[Timestamp]</code> attribute to the <code>RowVersion</code> property, and EF Core will automatically map it to the <code>rowversion</code> column in the database, as shown in the following code:</p>
<pre class="source-code">
public class Product{
    public int Id { get; set; }
    public string Name { get; set; }
    public int Inventory { get; set; }
    // Add a new property as the concurrency token
    [Timestamp]
    public byte[] RowVersion { get; set; }
}</pre>
<p>Do not <a id="_idIndexMarker673"/>forget to run the <code>dotnet ef migrations add AddConcurrencyControl</code> command to create a new migration. There is no need to run the <code>dotnet ef database update</code> command this time because we have the code to reset the database when the application starts.</p>
<p class="callout-heading">Important note</p>
<p class="callout">If you want to configure the mapping in Fluent API, you can use the following code:</p>
<p class="callout"><code>modelBuilder.Entity&lt;Product&gt;()</code></p>
<p class="callout"><code> .Property(p =&gt; </code><code>p.RowVersion)</code></p>
<p class="callout"><code> .</code><code>IsRowVersion();</code></p>
<p class="callout">This will generate the following migration:</p>
<p class="callout"><code>migrationBuilder.AddColumn&lt;byte[]&gt;(</code></p>
<p class="callout"><code>name: "RowVersion",</code></p>
<p class="callout"><code>table: "Products",</code></p>
<p class="callout"><code>type: "rowversion",</code></p>
<p class="callout"><code>rowVersion: true,</code></p>
<p class="callout"><code>nullable: false,</code></p>
<p class="callout"><code>defaultValue: </code><code>new byte[0]);</code></p>
<p>Now, let's try to call the API endpoint again. Use the same requests as before, one with a <code>delay</code> parameter of <code>2</code> seconds, and the other with a <code>delay</code> parameter of <code>3</code> seconds. This time, we should see that the first request will succeed, but the second request <a id="_idIndexMarker674"/>will fail with a <code>DbUpdateConcurrencyException</code> exception:</p>
<pre class="console">
fail: Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware[1]      An unhandled exception has occurred while executing the request.
      Microsoft.EntityFrameworkCore.DbUpdateConcurrencyException: The database operation was expected to affect 1 row(s), but actually affected 0 row(s); data may have been modified or deleted since entities were loaded. See http://go.microsoft.com/fwlink/?LinkId=527962 for information on understanding and handling optimistic concurrency exceptions.</pre>
<p>Check the database. The <code>Inventory</code> column of product 1 has been updated to <code>5</code>, which is correct.</p>
<p>If you check the SQL statement generated by EF Core, you will find that the <code>rowversion</code> column is included in the <code>WHERE</code> clause of the <code>UPDATE</code> statement:</p>
<pre class="source-code">
info: Microsoft.EntityFrameworkCore.Database.Command[20101]      Executed DbCommand (1ms) [Parameters=[@p1='?' (DbType = Int32), @p0='?' (DbType = Int32), @p2='?' (Size = 8) (DbType = Binary)], CommandType='Text', CommandTimeout='30']
      SET IMPLICIT_TRANSACTIONS OFF;
      SET NOCOUNT ON;
      UPDATE [Products] SET [Inventory] = @p0
      OUTPUT INSERTED.[RowVersion]
      WHERE [Id] = @p1 AND [RowVersion] = @p2;</pre>
<p>By using concurrency control, EF Core not only checks the ID of the entity but also checks the value of the <code>rowversion</code> column. If the value of the <code>rowversion</code> column is <a id="_idIndexMarker675"/>not the same as the value in the database, it means that the entity has been updated by another client, and the current update operation should be aborted.</p>
<p>Note that the <code>rowversion</code> column type is available for SQL Server, but not for other databases, such as SQLite. Different databases may have different types of concurrency tokens, or may not support the concurrency token at all. Please check the documentation of the database you are using to see whether it supports the built-in concurrency token. If not, you need to use the applica<a id="_idTextAnchor297"/>tion-managed concurrency token, as shown in the next section.</p>
<h2 id="_idParaDest-156"><a id="_idTextAnchor298"/>Application-managed concurrency token</h2>
<p>If the <a id="_idIndexMarker676"/>database does not support the built-in concurrency token, we can manually manage the concurrency token in the application. Instead of using the <code>rowversion</code> column, which can be automatically updated by the database, we can use a property in the entity class to manage the concurrency token and assign a new value to it every time the entity is updated.</p>
<p>Here is an example of using the application-managed concurrency token:</p>
<ol>
<li>First, we need to add a new property to the <code>Product</code> class, as shown in the following code:<pre class="source-code">
public class Product{    public int Id { get; set; }    public string Name { get; set; }    public int Inventory { get; set; }    // Add a new property as the concurrency token    public Guid Version { get; set; }}</pre></li> <li>Update the Fluent API configuration to specify the <code>Version</code> property as the concurrency token:<pre class="source-code">
modelBuilder.Entity&lt;Product&gt;()    .Property(p =&gt; p.Version)    .IsConcurrencyToken();</pre></li> <li>The <a id="_idIndexMarker677"/>corresponding data annotation configuration is as follows:<pre class="source-code">
public class Product{    public int Id { get; set; }    public string Name { get; set; }    public int Inventory { get; set; }    // Add a new property as the concurrency token    [ConcurrencyCheck]    public Guid Version { get; set; }}</pre></li> <li>Because this <code>Version</code> property is not managed by the database, we need to manually assign a new value whenever the entity is updated.</li>
</ol>
<p>The following code shows how to update the <code>Version</code> property when the entity is updated:</p>
<pre class="source-code">
[HttpPost("{id}/sell/{quantity}")]public async Task&lt;ActionResult&lt;Product&gt;&gt; SellProduct(int id, int quantity)
{
    // Omitted for brevity.
    product.Inventory -= quantity;
    // Manually assign a new value to the Version property.
    product.Version = Guid.NewGuid();
    await context.SaveChangesAsync();
    return product;
}</pre>
<p>You can <a id="_idIndexMarker678"/>use the application-managed concurrency token in SQL Server as well. The only difference is that you need to manually assign a new value to the concurrency token property every time the entity is updated. But if you use the built-in concurrency token in SQL Server, you do not need to do that.</p>
<p>In the event of a concurrency conflict, it is essential to take the necessary steps to res<a id="_idTextAnchor299"/>olve the issue. This will be addressed in the following section.</p>
<h2 id="_idParaDest-157"><a id="_idTextAnchor300"/>Handling concurrency conflicts</h2>
<p>When a <a id="_idIndexMarker679"/>concurrency conflict occurs, EF Core will throw a <code>DbUpdateConcurrencyException</code> exception. We can catch this exception and handle it in the application. For example, we can return a <code>409 Conflict</code> status code to the client, and let the client decide what to do next:</p>
<pre class="source-code">
[HttpPost("{id}/sell/{quantity}")]public async Task&lt;ActionResult&lt;Product&gt;&gt; SellProduct(int id, int quantity)
{
    // Omitted for brevity.
    product.Inventory -= quantity;
    try
    {
        await context.SaveChangesAsync();
    }
    catch (DbUpdateConcurrencyException)
    {
        // Do not forget to log the error
        return Conflict($"Concurrency conflict for Product {product.Id}.");
    }
    return product;
}</pre>
<p>The <a id="_idIndexMarker680"/>preceding code returns a <code>409 Conflict</code> status code to the client when a concurrency conflict occurs. The client can then handle the exception and retry the update operation.</p>
<p class="callout-heading">Important note</p>
<p class="callout">Some databases provide different isolation levels to handle concurrency conflicts. For example, SQL Server provides four isolation levels: <code>ReadUncommitted</code>, <code>ReadCommitted</code>, <code>RepeatableRead</code>, and <code>Serializable</code>. The default isolation level is <code>ReadCommitted</code>. Each isolation level has different behaviors when a concurrency conflict occurs and has its own pros and cons. Higher levels of isolation provide more consistency but also reduce concurrency. For more information, see <em class="italic">Isolation Levels</em> at <a href="https://learn.microsoft.com/en-gb/sql/t-sql/statements/set-transaction-isolation-level-transact-sql">https://learn.microsoft.com/en-gb/sql/t-sql/statements/set-transaction-isolation-level-transact-sql</a>.</p>
<p>In this section, we discussed how to handle concurrency conflicts in EF Core. We introduced two ways to handle concurrency conflicts: native database-generated concurrency tokens and application-managed concurrency tokens. We also discussed how to handle exceptions when concurrency conflicts occur. Concurrency conflicts are a common issue in a highly concurrent environment. It is impo<a id="_idTextAnchor301"/>rtant to handle them properly to avoid data loss or inconsistency.</p>
<h1 id="_idParaDest-158"><a id="_idTextAnchor302"/>Reverse engineering</h1>
<p>So far, we<a id="_idIndexMarker681"/> have learned how to use EF Core to create a database schema from the entity classes. This <a id="_idIndexMarker682"/>is called <em class="italic">code-first</em>. However, sometimes we need to work with an existing database. In this case, we need to create the entity classes and <code>DbContext</code> from the existing database schema. This is called <em class="italic">database-first</em> or <em class="italic">reverse engineering</em>. In this section, we will discuss how to use EF Core to reverse engineer the entity classes and <code>DbContext</code> from an existing database schema. This<a id="_idIndexMarker683"/> is useful when we want to migrate an existing application to EF Core.</p>
<p>Let's use the <code>EfCoreRelationshipsDemoDb</code> database as an example. If you have not created this database, please follow the steps in <a href="B18971_06.xhtml#_idTextAnchor245"><em class="italic">Chapter 6</em></a> to create it. The sample code is located at the <code>/samples/chapter7/EfCoreReverseEngineeringDemo</code> folder in the chapter's GitHub repository.</p>
<ol>
<li>First, let us create a new web API project. Run the following command in the terminal:<pre class="source-code">
<code>Microsoft.EntityFrameworkCore.Design</code> NuGet package. Navigate to the <code>EfCoreReverseEngineeringDemo</code> folder, and run the following command in the terminal to install it:<pre class="source-code">
<code>Microsoft.EntityFrameworkCore.SqlServer</code> NuGet package to the project:<pre class="source-code">
<code>Microsoft.EntityFrameworkCore.Sqlite</code> NuGet package. You can find the list of supported database providers at <a href="https://learn.microsoft.com/en-us/ef/core/providers/">https://learn.microsoft.com/en-us/ef/core/providers/</a>.</p></li> <li>Next, we will use the <code>dbcontext scaffold</code> command to generate the entity classes and <code>DbContext</code> from the database schema. This command needs the connection string of the database and the name of the database provider. We can run the following command in the terminal:<pre class="source-code">
<code>DbContext</code> class will be the same as the database name, such as <code>EfCoreRelationshipsDemoDbContext</code>.cs. We can also change the name of the <code>DbContext</code> class by using the <code>--context</code> option. For example, we can run the following command to change the name of the <code>DbContext</code> class to <code>AppDbContext</code>:</pre><pre class="source-code"><code>Data</code> and <code>Models</code> folders.</p></li> <li>Open the <code>AppDbContext.cs</code> file, and we will see a warning in the following code:<pre class="source-code">
protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)#warning To protect potentially sensitive information in your connection string, you should move it out of source code. You can avoid scaffolding the connection string by using the Name= syntax to read it from configuration - see https://go.microsoft.com/fwlink/?linkid=2131148. For more guidance on storing connection strings, see http://go.microsoft.com/fwlink/?LinkId=723263.        =&gt; optionsBuilder.UseSqlServer("Server=(localdb)\\mssqllocaldb;Initial Catalog=EfCoreRelationshipsDemoDb;Trusted_Connection=True;");</pre><p class="list-inset">This warning tells us that we should not store the connection string in the source code. Instead, we should store it in a configuration file, such as <code>appsettings.json</code>.</p></li> </ol>
<p>In the <code>OnModelCreating</code> method, we<a id="_idIndexMarker685"/> can see the entity classes and their relationships have been configured in Fluent API style. If you prefer to use data annotations, you can use the <code>--data-annotations</code> option when you run the <code>dbcontext scaffold</code> command. But as we mentioned in <a href="B18971_05.xhtml#_idTextAnchor198"><em class="italic">Chapter 5</em></a>, Fluent API is more powerful than data annotations, and it is recommended to use Fluent API.</p>
<p>EF Core is smart enough to detect the relationships between the entity classes if your database schema follows the conventions. However, if this is not the case, you may get unexpected results. Please review the generated code carefully to make sure the relationships are configured correctly.</p>
<p>Keep in mind that the generated code is just a starting point. Some models or properties may not be represented correctly in the database. For example, if your models have inheritance, the generated code will not include the base class because the base class is not represented in the database. Also, some column types may not be able to be mapped to the corresponding CLR types. For example, the <code>Status</code> column in the <code>Invoice</code> table is of the <code>nvarchar(16)</code> type, which will be mapped to the <code>string</code> type in the generated code, instead of the <code>Status</code> enum type.</p>
<p>You can update the generated code to suit your needs, but be aware that the next time you run the <code>dbcontext scaffold</code> command, the changes will be overwritten. You<a id="_idIndexMarker686"/> can use partial classes to add your own code to the generated classes, as the generated classes are declared as <code>partial</code>.</p>
<p>In this section, we discussed how to use EF Core to reverse engineer the entity classes and <code>DbContext</code> from an existing database schema. It should be noted that EF Core strongly prefers the code-first approach. Unless you are working with an existing database, it is recommended to use the <a id="_idTextAnchor303"/>code-first approach to take advantage of the EF Core migrations feature.</p>
<h1 id="_idParaDest-159"><a id="_idTextAnchor304"/>Other ORM frameworks</h1>
<p>In addition to EF Core, there are numerous other ORM frameworks available for .NET. Some of the most popular include the following:</p>
<ul>
<li><strong class="bold">Dapper</strong> (<a href="https://dapperlib.github.io/Dapper/">https://dapperlib.github.io/Dapper/</a>): Dapper is a micro-ORM framework that is designed <a id="_idIndexMarker687"/>to <a id="_idIndexMarker688"/>be fast and lightweight. Dapper does not support change tracking, but it is easy to use, and it is very fast. As the official documentation says, “<em class="italic">Dapper’s simplicity means that many features that ORMs ship with are stripped out. It worries about the 95% scenario and gives you the tools you need most of the time. It doesn’t attempt to solve every problem.</em>” The performance is one of the most important features of Dapper. Maybe it is not fair to compare Dapper’s performance with EF Core, because EF Core provides many more features than Dapper. If you are looking for a simple ORM framework that is fast and easy to use, Dapper is a good choice. In some projects, Dapper is used with EF Core to provide the best of both worlds. Dapper is open-source and originally developed by Stack Overflow.</li>
<li><strong class="bold">NHibernate</strong> (<a href="https://nhibernate.info/">https://nhibernate.info/</a>): Like NUnit, NHibernate is a .NET implementation <a id="_idIndexMarker689"/>of the Hibernate ORM framework in Java. It is a<a id="_idIndexMarker690"/> mature, open-source ORM framework that has been around for a long time. It is very powerful and flexible. NHibernate is maintained by a community of developers.</li>
<li><strong class="bold">PetaPoco</strong> (<a href="https://github.com/CollaboratingPlatypus/PetaPoco">https://github.com/CollaboratingPlatypus/PetaPoco</a>): PetaPoco is a tiny, fast, easy-to-use micro-ORM framework, which only had 1,000+ lines of code in the original <a id="_idIndexMarker691"/>version. PetaPoco has a similar performance <a id="_idIndexMarker692"/>to Dapper because it uses dynamic method generation (MSIL) to assign column values to properties. PetaPoco now supports SQL Server, SQL Server CE, MS Access, SQLite, MySQL, MariaDB, PostgreSQL, Firebird DB, and Oracle. It uses T4 templates to generate the code. PetaPoco is open-source and currently maintained by a few core developers.</li>
</ul>
<p>It is hard to say which one is the best. It depends on your needs. Dapper is known for its speed and performance, while EF Core is more feature-rich and provides better support for complex queries and relationships. When deciding which framework to use for a particular task, consider the performance implications of each approach, <a id="_idTextAnchor305"/>and also the trade-offs between the features and flexibility of the framework.</p>
<h1 id="_idParaDest-160"><a id="_idTextAnchor306"/>Summary</h1>
<p>In this chapter, we delved into some advanced topics of Entity Framework. We started by exploring how to improve the performance of our application by using <code>DbContext</code> pooling and no-tracking queries. We then learned how to execute raw SQL queries safely and efficiently using parameterized queries, and how to leverage the new bulk operations feature in EF Core for faster data manipulation.</p>
<p>Next, we looked at how to handle concurrency scenarios using optimistic concurrency control, which allows multiple users to access and modify the same data simultaneously without conflicts. We also covered reverse engineering, a technique for generating entity classes and <code>DbContext</code> classes from an existing database schema, which can save time and effort in creating a data access layer.</p>
<p>To broaden our horizons beyond EF Core, we briefly introduced some other popular ORM frameworks, such as Dapper, NHibernate, and PetaPoco, and discussed their strengths and weaknesses. By the end of this chapter, you should have a solid understanding of how to leverage EF Core in a web API project to efficiently access and manipulate data, as well as some insights into other ORM options available to you.</p>
<p>However, EF Core is a very large topic, and we cannot cover everything in this book. For more information about EF Core, please refer to the official documentation at <a href="https://learn.microsoft.com/en-us/ef/">https://learn.microsoft.com/en-us/ef/</a>.</p>
<p>In the next chapter, we will learn how to secure our web API project using authentication and authorization.</p>
</div>
</body></html>