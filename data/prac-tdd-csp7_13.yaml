- en: Unraveling a Mess
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解开混乱
- en: Not all applications were written with testing in mind. Few were originally
    developed using TDD. Often, the original developers are long gone, and documentation
    is incorrect, incomplete, or missing entirely.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 并非所有应用程序都是考虑到测试而编写的。其中很少是最初使用TDD开发的。通常，原始的开发者已经离开，文档不正确、不完整或完全缺失。
- en: 'In this chapter, we will gain an understanding of:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将了解：
- en: Dealing with inherited code
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理继承的代码
- en: Characterization tests
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 特征测试
- en: Refactoring with tests
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带着测试进行重构
- en: Inheriting code
  id: totrans-6
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 继承代码
- en: This chapter is a case study of legacy code that needs (what should be) a minor
    change. We will quickly find out that the change is not so minor. To begin, let's
    look at what the legacy application does.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 本章是关于需要（应该是）微小更改的遗留代码的案例研究。我们将很快发现，这个更改并不那么微小。首先，让我们看看遗留应用程序做了什么。
- en: 'Here is some sample output from a run of this code:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是这段代码运行的一些示例输出：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[PRE1]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Looking at the interactions, this program doesn't look that bad. In speaking
    with the business analyst, the application was explained as a game.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 看起来，这个程序并不那么糟糕。在与业务分析师交谈中，应用程序被解释为是一款游戏。
- en: The game
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 游戏
- en: This particular game is called *Mastermind* and is a code breaking puzzle. According
    to the business analyst, the code consists of the letters A through F and contains
    four of the letters chosen at random. It is the goal of the player to determine
    the passcode.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这款特定的游戏被称为 *Mastermind*，是一种解码谜题。根据业务分析师的说法，密码由字母A到F组成，包含随机选择的四个字母。玩家的目标是确定通行码。
- en: The player is given hints along the way. For a correctly placed letter, the
    player receives a plus symbol. For a correct letter in the wrong position, the
    player receives a minus symbol. If the letter is incorrect, the player receives
    no symbol.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 玩家在游戏中会收到提示。对于放置正确的字母，玩家会收到一个加号符号。对于位置错误但正确的字母，玩家会收到一个减号符号。如果字母不正确，玩家则不会收到任何符号。
- en: A change is requested
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 请求进行更改
- en: During play testing, it was determined that players were discovering the passcodes
    too quickly. As a result, the game wasn't as much fun as it could be. The suggested
    solution was to make the passcode more complex by allowing more than six letters
    to be used. It is our job to extend the character range to A through Z.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏测试过程中，发现玩家发现通行码的速度太快。因此，游戏并没有像预期的那样有趣。建议的解决方案是通过允许使用超过六个字母来使密码更复杂。我们的任务是扩展字符范围到A到Z。
- en: We can start by looking at the existing code to determine where we might have
    to make the change. That is where we discover this!
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以先查看现有代码，以确定我们可能需要做出更改的地方。那就是我们发现这个地方的地方！
- en: 'In the file `Program.cs`:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Program.cs` 中：
- en: '[PRE2]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We now have several problems. Firstly, it's not exactly clear where the letters
    are coming from. Secondly, there is no way this code is tested. Lastly, even if
    making the change were straight forward, making sure we didn't break something
    would not be. We have to do a full manual regression test to verify that any of
    this is working, and trying to verify that all letters, A through Z, are possible
    may take a very long time.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有几个问题。首先，并不完全清楚字母是从哪里来的。其次，这段代码显然没有经过测试。最后，即使更改是直接的，确保我们没有破坏任何东西也不是那么简单。我们必须进行完整的手动回归测试来验证这些是否正常工作，而尝试验证所有字母，从A到Z，可能需要非常长的时间。
- en: Life sometimes hands you lemons
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生活有时会给你柠檬
- en: While I hope you never receive code this bad, we are going to walk through what
    is needed to turn even this into readable, maintainable, and fully tested code.
    The best part, the part you aren't going to believe, is that transforming this
    code is actually safe and fairly easy.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我希望你永远不会收到这么糟糕的代码，但我们将一步步讲解如何将即使是这样的代码也转变为可读、可维护和完全测试的代码。最好的部分，你可能会不相信的部分，是转换这段代码实际上是安全且相对容易的。
- en: Getting started
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 开始
- en: In any code situation like this, the first thing we must do is remove the code
    in question from the environment where we have no control. In this case, we can't
    test the code if it is sitting in `Program.main`. So, let's grab the whole thing
    and put it into a class named `Mastermind`. We will have a single function named
    `Play` that will run the game. This is considered a safe refactoring, because
    we are not changing any of the existing code, simply moving it somewhere else.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何这样的代码情况下，我们首先必须做的是将问题代码从我们没有控制的环境中移除。在这种情况下，如果代码位于 `Program.main` 中，我们就无法测试它。所以，让我们把整个代码块抓取出来，放入一个名为
    `Mastermind` 的类中。我们将有一个名为 `Play` 的单个函数来运行游戏。这被认为是一种安全的重构，因为我们没有改变任何现有的代码，只是将其移动到其他地方。
- en: 'In the file `Program.cs`:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Program.cs` 中：
- en: '[PRE3]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the file `Mastermind.cs`:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Mastermind.cs` 中：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Running the code again at this point shows that everything still works. The
    next step is a cosmetic one; let's spread the `Play` method out into sections.
    This should help us determine what private methods exist inside the large public
    method.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个点上再次运行代码显示，一切仍然正常工作。下一步是一个外观上的改进；让我们将 `Play` 方法扩展到几个部分。这应该有助于我们确定大型公共方法内部存在哪些私有方法。
- en: 'In the file `Mastermind.cs`:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Mastermind.cs` 中：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We have now used whitespace to split the program into several pieces and added
    comments explaining what we think each piece is doing. At this point, we are almost
    ready to begin testing. We have just a couple things in the way, the worst of
    which is the `Console` class.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在已经使用空白将程序分成几个部分，并添加了注释来解释我们认为每个部分在做什么。到目前为止，我们几乎准备好开始测试了。我们只是有几件事情需要处理，其中最糟糕的是
    `Console` 类。
- en: Abstracting a third-party class
  id: totrans-33
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 抽象第三方类
- en: If we tried to test right now, the application would hit the first `ReadLine`
    call and the test would time out. Console has the ability to redirect the input
    and output, but we are not going to use this feature, because it is specific to
    Console and we want to demonstrate a more generic solution that you can apply
    anywhere.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们现在尝试测试，应用程序会调用第一个 `ReadLine` 调用，并且测试会超时。控制台具有重定向输入和输出的能力，但我们不会使用这个特性，因为它特定于控制台，我们想要展示一个更通用的解决方案，你可以在任何地方应用。
- en: What we need is a class that gives us a similar interface to Console. Then we
    can dependency inject our class for the tests and a thin wrapper for the production
    code. Let's test drive that interface now.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要的是一个提供与控制台类似接口的类。然后我们可以为测试注入我们的类，并为生产代码提供一个薄薄的包装器。现在让我们测试这个接口。
- en: 'In the file `InputOutputTests.cs`:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `InputOutputTests.cs` 中：
- en: '[PRE6]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'In the file `ReadLineTests.cs`:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `ReadLineTests.cs` 中：
- en: '[PRE7]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the file `ReadTests.cs`:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `ReadTests.cs` 中：
- en: '[PRE8]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'In the file `WriteTests.cs`:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `WriteTests.cs` 中：
- en: '[PRE9]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'In the file `WriteLineTests.cs`:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `WriteLineTests.cs` 中：
- en: '[PRE10]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'In the file `IInputOutput.cs`:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `IInputOutput.cs` 中：
- en: '[PRE11]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'In the file `MockInputOutput.cs`:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `MockInputOutput.cs` 中：
- en: '[PRE12]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: That handles our mock input and output, but we need to create the production
    wrapper class for Console, and we need to use `Program.cs` to inject that class
    into the `Mastermind` class.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 这处理了我们的模拟输入和输出，但我们需要创建控制台的生产包装器类，并需要使用 `Program.cs` 将该类注入到 `Mastermind` 类中。
- en: Unexpected Input
  id: totrans-51
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 非预期的输入
- en: 'While replacing calls to Console with calls to our injected class, we found
    two use cases that we did not plan for. The first use case is fairly involved
    and has a couple parameters we need to handle:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在将控制台的调用替换为对我们注入的类的调用时，我们发现了一些我们没有计划到的用例。第一个用例相当复杂，有几个参数我们需要处理：
- en: '[PRE13]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'The second use case is more simple and doesn''t take any parameters:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个用例更简单，不需要任何参数：
- en: '[PRE14]'
  id: totrans-55
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The second use case is the easiest to deal with, so let us write a quick test
    for that now.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个用例处理起来最简单，所以现在让我们为它编写一个快速测试。
- en: 'In the file `WriteLineTests.cs`:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `WriteLineTests.cs` 中：
- en: '[PRE15]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'In the file `IInputOutput.cs`:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `IInputOutput.cs` 中：
- en: '[PRE16]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'In the file `MockInputOutput.cs`:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `MockInputOutput.cs` 中：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The next issue is slightly more complicated. If we want to handle it accurately,
    we will need to do quite a bit of regular expression and string manipulation.
    However, we don't need it to be "correct"; we only need it to work as expected
    by the application. In the singular case where this is being used, the value that
    should be placed into the string being written, isn't. The original developer
    abused the functionality of `Console.Write` to reduce the number of lines in the
    if statement so they could avoid brackets. So, all we need to do for the code
    to continue to work is allow for the input to take place. A simple interface extension
    should provide that for us.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个问题稍微复杂一些。如果我们想准确处理它，我们需要进行相当多的正则表达式和字符串操作。然而，我们不需要它“正确”；我们只需要它按照应用程序的预期工作。在唯一使用这个功能的情况下，应该放入正在写入的字符串中的值并没有放入。原始的开发者滥用了
    `Console.Write` 的功能来减少 if 语句中的行数，从而避免使用括号。因此，为了让代码继续工作，我们只需要允许输入即可。一个简单的接口扩展应该能为我们提供这个功能。
- en: 'In the file `IInputOutput.cs`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `IInputOutput.cs` 中：
- en: '[PRE18]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'In the file `MockInputOutput.cs`:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `MockInputOutput.cs` 中：
- en: '[PRE19]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Back in the application code, we can finish making our changes. Here is the
    updated application.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在应用程序代码中，我们可以完成我们的更改。以下是更新后的应用程序。
- en: 'In the file `ConsoleInputOutput.cs`:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `ConsoleInputOutput.cs` 中：
- en: '[PRE20]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'In the file `Program.cs`:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Program.cs` 中：
- en: '[PRE21]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'In the file `Mastermind.cs`:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Mastermind.cs` 中：
- en: '[PRE22]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'A quick test run confirms that the application is working correctly:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 快速运行测试确认应用程序正在正确工作：
- en: '[PRE23]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Now, we can write a gold standard or characterization test that will verify
    all the parts of the code are working correctly. The only piece of the code this
    test will not cover is the random password generation:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以编写一个黄金标准或特性测试，以验证代码的所有部分是否正常工作。这个测试不会覆盖的唯一代码部分是随机密码生成：
- en: '[PRE24]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This is an extremely long test, and it has an out of the ordinary structure,
    but this single test runs through almost all the logic in the application. You
    may not always be able to do this with a single test, but before beginning any
    heavy refactoring, these tests must exist.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个极其长的测试，它具有非常规的结构，但这个单独的测试几乎涵盖了应用中的所有逻辑。你可能无法总是用一个单独的测试来完成这项工作，但在开始任何重大重构之前，这些测试必须存在。
- en: Making sense of the madness
  id: totrans-80
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弄清楚混乱
- en: Now that we have the gold standard test written, we can begin to safely refactor
    the code. Any changes that we try to make that break the gold standard test will
    have to be undone and a new approach will have to be taken.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了黄金标准测试，我们可以开始安全地重构代码。任何试图做出的更改，如果破坏了黄金标准测试，都必须撤销，并采取新的方法。
- en: 'Looking at the `Mastermind` class, all those variables at the top of the `Play`
    method can be moved out to be class level fields. This will make them available to
    all the code within the class and help to both figure out what they are for and
    how often they are used in the app:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 看一下 `Mastermind` 类，`Play` 方法顶部所有这些变量都可以移动到类级别字段中。这将使它们对类内的所有代码都可用，并有助于弄清楚它们的作用以及它们在应用中使用的频率：
- en: '[PRE25]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Next, we will just work our way down the `Play` method, extracting all that
    we can into tiny private methods. We are only able to do some tiny refactoring
    before we need to switch gears and start fixing some of the antiquated logic in
    this application:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将逐步向下工作到 `Play` 方法，将所有可以提取的内容提取到微小的私有方法中。在我们需要切换到修复这个应用程序中一些过时的逻辑之前，我们只能进行一些微小的重构：
- en: '[PRE26]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We were able to break out a password generation method. We were also able to
    simplify the structure of the success code. We cannot, however, proceed without
    addressing the complexity of the chosen looping structures. The developer that
    wrote this did not use general looping structures, such as while and for loops.
    We need to fix that in order to better understand and work with this code:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 我们能够提取出一个密码生成方法。我们还能够简化成功代码的结构。然而，如果不解决所选循环结构的复杂性，我们无法继续前进。编写这个代码的开发者没有使用通用的循环结构，如
    while 和 for 循环。我们需要修复这个问题，以便更好地理解和处理这段代码：
- en: '[PRE27]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'We now have a structure that we can begin to work with. Let''s start by making
    some sense of these variable names:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在有一个可以开始工作的结构。让我们先弄清楚这些变量名：
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'We will want to make updates to the `Play` method that reflect our determinations
    for what the variables mean. Following we have replaced the single letter variable
    names with names that more appropriately represent what the variables are used
    for:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将想要更新 `Play` 方法，使其反映我们对变量含义的确定。以下我们将单个字母变量名替换为更恰当地表示变量用途的名称：
- en: '[PRE29]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Next, it would be nice if we could update the interface now that we understand
    the application a little better. Two things that we would like to change are the
    input and the very end of the game. It would be nice if the input was a simple
    string instead of a character array. The `Play` method could take a string and
    the program could figure out how to get the password string from the arguments.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，如果我们现在能更新接口，那会很好，因为我们对应用程序有了更好的理解。我们想要改变的两件事是输入和游戏的最后阶段。如果输入是一个简单的字符串而不是字符数组，那就更好了。`Play`
    方法可以接受一个字符串，程序可以确定如何从参数中获取密码字符串。
- en: Along those same lines, we could reduce the overall number of writes and turn
    the consecutive plus and minus `Write` commands into a single `WriteLine` command.
    This would break our gold standard test, but wouldn't actually change the functionality
    of the code. It would still print the pluses and minuses on a single line.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着同样的思路，我们可以减少总的写入次数，并将连续的加号和减号 `Write` 命令转换成一个单独的 `WriteLine` 命令。这将破坏我们的黄金标准测试，但实际上不会改变代码的功能。它仍然会在一行上打印加号和减号。
- en: 'To convert the guess from a character array to a string, we must first understand
    what is happening on this line:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要将猜测从字符数组转换为字符串，我们首先必须理解这一行正在发生什么：
- en: '[PRE30]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Analyzing the line, we see the numbers `65`, `26`, and `32`. If you are familiar
    with ASCII codes, then these lines might make sense to you. The number `65` is
    the starting point of the alphabet characters on the ASCII tables. There are 26
    letters in the English alphabet. And, there are 32 values between "a" and "A".
    So, it is to be assumed that this code is either uppercasing or lowercasing the
    character at the specified index. We can approximate this in C# using the `String.ToUpper()`
    method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 分析这一行，我们看到数字 `65`、`26` 和 `32`。如果你熟悉 ASCII 码，那么这些行可能对你来说是有意义的。数字 `65` 是字母字符在
    ASCII 表中的起始点。英语字母表中共有 26 个字母。并且，在 "a" 和 "A" 之间有 32 个值。因此，可以假设这段代码是在对指定索引处的字符进行大写或小写转换。我们可以使用
    C# 中的 `String.ToUpper()` 方法来近似实现这一点。
- en: While we are doing a small bit of gold standard changes, we should also remove
    the last two lines of the `Play` method and move them to `Program.cs`, as they
    are more related to a Console application than anything else.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在进行一些小的黄金标准更改时，我们还应该将 `Play` 方法的最后两行移到 `Program.cs` 中，因为它们与控制台应用程序更相关。
- en: 'In the file `Program.cs`:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Program.cs` 中：
- en: '[PRE31]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In the file `Mastermind.cs`:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Mastermind.cs` 中：
- en: '[PRE32]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'In the file `GoldStandardTests.cs`:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `GoldStandardTests.cs` 中：
- en: '[PRE33]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Final beautification
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 最终美化
- en: Now that everything else is done and the code is working correctly, it is time
    for the last refactoring before we start our enhancement. We want our methods
    to be as small as possible. In this case, that means that the `Play` function
    should have practically no logic outside the main game loop.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 现在所有其他工作都已完成，代码也运行正确，是时候在我们开始增强之前进行最后的重构了。我们希望方法尽可能小。在这种情况下，这意味着 `Play` 函数应该几乎没有任何逻辑在主游戏循环之外。
- en: In general, if a method has any kind of block in it (for example, if, while,
    for, and so on), we want that block to be the only thing in the method. Often,
    there are also guard statements checking input, but that should be it. Let's refactor
    to follow that convention and see what the code looks like afterwards.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，如果一个方法中包含任何类型的块（例如，if、while、for 等），我们希望该块是方法中唯一的内容。通常，还有检查输入的守卫语句，但应该仅此而已。让我们重构以遵循该约定，并看看重构后的代码是什么样子。
- en: 'In the file `Mastermind.cs`:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Mastermind.cs` 中：
- en: '[PRE34]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: There are many ways that this code could have been refactored; this is just
    one. Now that the code is refactored, we are ready to move on and begin working
    on enhancements.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码可以有多种重构方式；这只是其中一种。现在代码已经重构，我们准备继续前进并开始进行增强。
- en: Ready for enhancements
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备进行增强
- en: We are now to a point where the code makes enough sense that we can begin to
    work on our change requests. We have broken the random password generation portion
    of the code into its own method, so now we can work on it independently.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在到达了一个点，代码已经足够清晰，我们可以开始处理我们的变更请求了。我们已经将随机密码生成部分的代码拆分成了它自己的方法，因此现在我们可以独立地工作在这个方法上。
- en: One of the first things we need to do is to stop using `Random`. `Random` is,
    by nature, unpredictable and outside of our control. We need a way to feed the
    number generation to verify that we can get the expected outputs when `Random`
    provides specific inputs.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是停止使用 `Random`。`Random` 本质上是不可预测的，并且不受我们的控制。我们需要一种方法来提供数字生成，以验证当 `Random`
    提供特定输入时，我们能否得到预期的输出。
- en: We will extract an interface and mock class similar to what we did for Console.
    Here is the first round of tests, the mock class, and the interface that were
    created.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将提取一个接口和模拟类，类似于我们为 Console 所做的。以下是创建的第一轮测试、模拟类和接口。
- en: 'In the file `RandomNumberTests.cs`:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `RandomNumberTests.cs` 中：
- en: '[PRE35]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In the file `IRandomGenerator.cs`:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `IRandomGenerator.cs` 中：
- en: '[PRE36]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'In the file `MockRandomGenerator.cs`:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `MockRandomGenerator.cs` 中：
- en: '[PRE37]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now, to create the production `RandomGenerator` class and inject it into our
    application.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，创建生产 `RandomGenerator` 类并将其注入到我们的应用程序中。
- en: 'In the file `RandomGenerator.cs`:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `RandomGenerator.cs` 中：
- en: '[PRE38]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'In the file `Program.cs`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Program.cs` 中：
- en: '[PRE39]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'In the file `Mastermind.cs`:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Mastermind.cs` 中：
- en: '[PRE40]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: And lastly, let's modify the gold standard test to use random password generation.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，让我们修改黄金标准测试以使用随机密码生成。
- en: 'In the file `GoldStandardTests.cs`:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `GoldStandardTests.cs` 中：
- en: '[PRE41]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'Now we are ready to refactor the password generation method and extend it to
    provide us with the requested change. First, there is a looping structure that
    is not core to the language. Let''s focus in on the `CreateRandomPassword` method
    and fix the looping structure:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们准备重构密码生成方法，并扩展它以提供所需的变化。首先，有一个不是语言核心的循环结构。让我们专注于 `CreateRandomPassword`
    方法并修复循环结构：
- en: '[PRE42]'
  id: totrans-131
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Next, for fun, let''s see if we can generalize and compress this loop, since
    we have a very similar loop in the `Check` method. While not necessary, this is
    fun example of reducing duplication of code. Here is what that refactoring looks
    like:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，为了好玩，让我们看看我们能否泛化和压缩这个循环，因为我们 `Check` 方法中有一个非常相似的循环。虽然这不是必要的，但这是一个减少代码重复的好例子。以下是重构的样子：
- en: '[PRE43]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Now let's do one more refactoring before we extend the application. Looking
    at how the characters are generated, it is not very obvious what is going on.
    Instead, we would like the code to be as straightforward as possible. There is
    no reason that the random generator class can't just directly return letters,
    so let's add that functionality.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们扩展应用程序之前，让我们再进行一次重构。观察字符的生成方式，并不明显。相反，我们希望代码尽可能简单直接。没有理由随机生成器类不能直接返回字母，所以让我们添加这个功能。
- en: 'In the file `RandomLetterTests.cs`:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `RandomLetterTests.cs` 中：
- en: '[PRE44]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: 'In the file `MockRandomGenerator.cs`:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `MockRandomGenerator.cs` 中：
- en: '[PRE45]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: 'In the file `IRandomGenerator.cs`:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `IRandomGenerator.cs` 中：
- en: '[PRE46]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'In the file `RandomGenerator.cs`:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `RandomGenerator.cs` 中：
- en: '[PRE47]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'In the file `Mastermind.cs`:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Mastermind.cs` 中：
- en: '[PRE48]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'In the file `GoldStandardTests.cs`:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `GoldStandardTests.cs` 中：
- en: '[PRE49]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: That is the final refactoring for this exercise. We only have one thing to do,
    and that is to extend the application to generate passwords using the full range
    of the English alphabet. Because of the effort we put into testing and refactoring,
    this is now a trivial matter, and, in fact, only requires the removal of three
    characters in the `Mastermind` class.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 那就是这个练习的最终重构。我们只有一件事要做，那就是扩展应用程序以使用整个英语字母表的范围生成密码。由于我们在测试和重构上付出的努力，这现在是一件微不足道的事情，实际上只需要在
    `Mastermind` 类中删除三个字符。
- en: 'In the file `Mastermind.cs`:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在文件 `Mastermind.cs` 中：
- en: '[PRE50]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: 'Now a more complicated password, consisting of the full range of the alphabet,
    is created. This causes a much more difficult password, and a game with output
    similar to the following:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 现在创建一个更复杂的密码，包含整个字母表的范围。这导致了一个更难的密码，并且一个输出类似于以下的游戏：
- en: '[PRE51]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Summary
  id: totrans-152
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: You now have a well-written example, covered by tests. The effort involved can
    be daunting, but for anything more than a trivial application, it can be well
    worth the effort.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在有一个编写良好的示例，由测试覆盖。所涉及的努力可能令人畏惧，但对于任何非平凡的应用程序来说，这可能非常值得。
- en: In [Chapter 14](part0430.html#CQ2HS0-d186949d2da74f5c95dd1712efae1195), *A Better
    Foot Forward*, we'll summarize what we've learned as well as give you some pointers
    on how to rejoin the world as a TDD expert.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [第 14 章](part0430.html#CQ2HS0-d186949d2da74f5c95dd1712efae1195)，《更好的起点》，我们将总结我们所学的知识，并给你一些如何作为
    TDD 专家重新融入世界的建议。
