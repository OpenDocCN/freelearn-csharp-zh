<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-273">
    <a id="_idTextAnchor273">
    </a>
    
     8
    
   </h1>
   <h1 id="_idParaDest-274">
    <a id="_idTextAnchor274">
    </a>
    
     Keeping the Application Secure
    
   </h1>
   <p>
    
     In this chapter, we focus on essential security practices for Blazor applications, as protecting user data and maintaining trust is crucial for any
    
    
     
      commercial success.
     
    
   </p>
   <p>
    
     We will start by scaffolding identity – setting up the necessary infrastructure for user authentication and management by leveraging the template provided by the .NET team.
    
    
     We will look at strategies to prevent unauthorized access and protect your component from unwanted actors.
    
    
     Additionally, we will cover a more granular approach and secure markup areas to customize the component behavior and ensure that sensitive information is only accessible to authorized users.
    
    
     We will explore how to define and enforce
    
    <strong class="bold">
     
      roles
     
    </strong>
    
     and
    
    <strong class="bold">
     
      policies
     
    </strong>
    
     to centralize and encapsulate access levels that align with your security requirements.
    
    
     Next, we will learn how to determine users’
    
    <strong class="bold">
     
      authentication state
     
    </strong>
    
     and their current
    
    <a id="_idIndexMarker389">
    </a>
    
     access context, allowing us to secure and enhance backend logic.
    
    
     We will also discuss how to update user identity safely
    
    
     
      and securely.
     
    
   </p>
   <p>
    
     By the end of this chapter, you will understand various security mechanisms in Blazor and have the best security practices in
    
    
     
      your skillset.
     
    
   </p>
   <p>
    
     Here’s a list of the recipes we
    
    
     
      will cover:
     
    
   </p>
   <ul>
    <li>
     
      
       Scaffolding identity
      
     
    </li>
    <li>
     
      
       Securing pages
      
     
    </li>
    <li>
     
      Securing
     
     
      
       markup areas
      
     
    </li>
    <li>
     
      
       Creating roles
      
     
    </li>
    <li>
     
      Modifying a
     
     
      
       user’s identity
      
     
    </li>
    <li>
     
      Supporting roles’ and
     
     
      
       policies’ authorization
      
     
    </li>
    <li>
     
      Resolving authentication state in
     
     
      
       procedural logic
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-275">
    <a id="_idTextAnchor275">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     In this chapter, recipes build on one another, resulting in a guide through the most often required identity features.
    
    
     For clarity, at the beginning of each recipe, you will find instructions on how to set up a working directory and where to get the sample objects from.
    
    
     On top of that, this chapter requires that you have a working
    
    <strong class="bold">
     
      Structured Query Language
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SQL
     
    </strong>
    
     ) database, a connection string to the database instance, and a SQL IDE as you will need to run a few custom migrations.
    
    
     Most of the tables will be scaffolded for you, so don’t stress if you don’t have much experience with
    
    
     
      SQL itself.
     
    
   </p>
   <p>
    
     All the code samples are available on GitHub
    
    
     
      at:
     
    
    <a href="https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/Chapter08/BlazorCookbook.Auth">
     
      
       https://github.com/PacktPublishing/Blazor-Web-Development-Cookbook/tree/main/Chapter08/BlazorCookbook.Auth
      
     
    </a>
   </p>
   <h1 id="_idParaDest-276">
    <a id="_idTextAnchor276">
    </a>
    
     Scaffolding identity
    
   </h1>
   <p>
    
     The .NET team provides a template that enables adding authentication to your Blazor application rapidly.
    
    
     This template is not only quick to set up but also highly customizable.
    
    
     You can streamline the implementation of user authentication, registration, and profile management, ensuring that your application is secure from the get-go.
    
    
     You get essential features such as login and logout functionality, password recovery, and user data management – all crucial for any
    
    
     
      authentication system.
     
    
   </p>
   <p>
    
     Let’s scaffold a new Blazor project with authentication enabled and explore the features it offers out of the box.
    
    
     By the
    
    <a id="_idIndexMarker390">
    </a>
    
     end of this recipe, you will have a solid foundation and understanding of the identity system.
    
    
     Whether you’re building a simple app or a complex enterprise solution, this approach will save you time and effort while ensuring your application meets modern
    
    
     
      security standards.
     
    
   </p>
   <h2 id="_idParaDest-277">
    <a id="_idTextAnchor277">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     We will showcase initializing the project with identity, leveraging the GUI provided as part of Visual Studio, so the only pre-requirement in this recipe is that you start your IDE.
    
    
     Let’s
    
    
     
      dive in.
     
    
   </p>
   <p>
    
     If you’re using the .NET CLI in your environment, you can refer to the
    
    <em class="italic">
     
      There’s more…
     
    </em>
    
     section at the end of the recipe, where I’ll provide
    
    
     
      equivalent commands.
     
    
   </p>
   <h2 id="_idParaDest-278">
    <a id="_idTextAnchor278">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to
    
    <a id="_idIndexMarker391">
    </a>
    
     scaffold a new Blazor project
    
    
     
      with identity:
     
    
   </p>
   <ol>
    <li>
     
      Select
     
     <strong class="bold">
      
       Create a new project
      
     </strong>
     
      from the
     
     
      
       welcome window:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.1: Starting the creation of a new project from the welcome window" src="img/Figure_8.1_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.1: Starting the creation of a new project from the welcome window
    
   </p>
   <ol>
    <li value="2">
     
      Use the search bar at the top of the panel to find the
     
     <strong class="bold">
      
       Blazor Web App
      
     </strong>
     
      position and confirm by clicking the
     
     
      <strong class="bold">
       
        Next
       
      </strong>
     
     
      
       button:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.2: Selecting Blazor Web App from available project templates" src="img/Figure_8.2_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.2: Selecting Blazor Web App from available project templates
    
   </p>
   <ol>
    <li value="3">
     
      Define a project
     
     <a id="_idIndexMarker392">
     </a>
     
      location and name and confirm by clicking the
     
     
      <strong class="bold">
       
        Next
       
      </strong>
     
     
      
       button:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.3: Setting a project location and name" src="img/Figure_8.3_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.3: Setting a project location and name
    
   </p>
   <ol>
    <li value="4">
     
      Choose
     
     <strong class="bold">
      
       .NET 9.0 (Standard Term Support)
      
     </strong>
     
      as the target framework, and in the
     
     <strong class="bold">
      
       Authentication type
      
     </strong>
     
      section, select
     
     <strong class="bold">
      
       Individual Accounts
      
     </strong>
     
      .
     
     
      Make sure to check the
     
     <strong class="bold">
      
       Configure for HTTPS
      
     </strong>
     
      and
     
     <strong class="bold">
      
       Include sample pages
      
     </strong>
     
      checkboxes, and select
     
     <strong class="bold">
      
       Auto (Server and WebAssembly)
      
     </strong>
     
      and
     
     <strong class="bold">
      
       Per page/component
      
     </strong>
     
      from the
     
     <a id="_idIndexMarker393">
     </a>
     
      interactivity configuration dropdowns.
     
     
      Confirm by clicking the
     
     
      <strong class="bold">
       
        Create
       
      </strong>
     
     
      
       button:
      
     
    </li>
   </ol>
   <div><div><img alt="Figure 8.4: Configuring the project’s framework, interactivity, and authentication" src="img/Figure_8.4_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.4: Configuring the project’s framework, interactivity, and authentication
    
   </p>
   <p class="list-inset">
    
     You will arrive at
    
    <a id="_idIndexMarker394">
    </a>
    
     a similar project setup, which may vary depending on the name of
    
    
     
      your project:
     
    
   </p>
   <div><div><img alt="Figure 8.5: Initial solution structure" src="img/Figure_8.5_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.5: Initial solution structure
    
   </p>
   <h2 id="_idParaDest-279">
    <a id="_idTextAnchor279">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     The entire process is almost the same as we explored in the
    
    <em class="italic">
     
      Initializing a project
     
    </em>
    
     recipe in
    
    <a href="B22020_01.xhtml#_idTextAnchor020">
     
      <em class="italic">
       
        Chapter 1
       
      </em>
     
    </a>
    
     .
    
    
     Navigate there for the first three steps.
    
    
     Here, we focus on
    
    
     <em class="italic">
      
       step 4
      
     </em>
    
    
     
      .
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we land on the project configuration panel.
    
    
     First, we select
    
    <strong class="bold">
     
      .NET 9 (Standard Term Support)
     
    </strong>
    
     as our target framework.
    
    
     Then, we have an
    
    <strong class="bold">
     
      Authentication type
     
    </strong>
    
     section.
    
    
     Here, we opt for the
    
    <strong class="bold">
     
      Individual Accounts
     
    </strong>
    
     option, instructing Visual Studio to scaffold the code supporting identity in our application.
    
    
     We also enable HTTPS and generate sample pages by checking the respective checkboxes.
    
    
     Lastly, to complete the configuration setup, we define the interactivity of our application – we will
    
    
     
      use a
     
    
    
     per-page/component interactivity location and a mix of Server and WebAssembly rendering.
    
    
     Next, we see the result of the scaffolding – a solution with two projects for the server and
    
    <a id="_idIndexMarker395">
    </a>
    
     client side, respectively.
    
    
     It looks nothing different from the standard Blazor template scaffold, so let’s dive into each project to understand how it
    
    
     
      supports identity.
     
    
   </p>
   <p>
    
     Here’s what the scaffolded projects’ structures
    
    
     
      look like:
     
    
   </p>
   <div><div><img alt="Figure 8.6: Scaffolded server- and client-side projects, with enabled authentication" src="img/Figure_8.6_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.6: Scaffolded server- and client-side projects, with enabled authentication
    
   </p>
   <p>
    
     Let’s first unpack the client-side project (on the right side in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    <em class="italic">
     
      .6
     
    </em>
    
     ), as it’s significantly smaller.
    
    
     On the components’ side, we’re getting just one relevant to manage identity –
    
    <strong class="source-inline">
     
      RedirectToLogin
     
    </strong>
    
     .
    
    
     As the name implies,
    
    <strong class="source-inline">
     
      RedirectToLogin
     
    </strong>
    
     safely redirects a user to the login page, persisting the initial URL so that Blazor can return there.
    
    
     We’re also getting a
    
    <strong class="source-inline">
     
      UserInfo
     
    </strong>
    
     class – a model containing the user identity details we want to share between server- and client-side communication, and one we can easily extend.
    
    
     The backbone of sharing the authentication state across render mode boundaries is the
    
    <strong class="source-inline">
     
      PersistentAuthenticationStateProvider
     
    </strong>
    
     service, which we will explore in the
    
    <em class="italic">
     
      Supporting roles’ and policies’ authorization
     
    </em>
    
     recipe.
    
    
     Lastly, we’re getting a minimal setup in the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file.
    
    
     The
    
    <strong class="source-inline">
     
      PersistentAuthenticationStateProvider
     
    </strong>
    
     service is registered as a singleton in the
    
    <strong class="bold">
     
      dependency injection container
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DI
     
    </strong>
    
     ), and with the
    
    <strong class="source-inline">
     
      AddAuthorizationCore()
     
    </strong>
    
     extension method, all services required to enable authorization in our app are registered for us.
    
    
     We also get an invocation of the
    
    <strong class="source-inline">
     
      AddCascadingAuthenticationState()
     
    </strong>
    
     extension method to add an authentication state as a root-level cascading value and make it interceptable in the entire
    
    
     
      WebAssembly application.
     
    
   </p>
   <p>
    
     The server-side project (on the left side in
    
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    <em class="italic">
     
      .6
     
    </em>
    
     ) contains the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     directory, with an
    
    <strong class="source-inline">
     
      ApplicationDbContext
     
    </strong>
    
     class, an
    
    <strong class="source-inline">
     
      ApplicationUser
     
    </strong>
    
     class, and a
    
    <strong class="source-inline">
     
      Migrations
     
    </strong>
    
     subdirectory, indicating that the server-side project is responsible for persisting and managing users
    
    <a id="_idIndexMarker396">
    </a>
    
     and their identities.
    
    
     That means you must provide a valid connection string to the database where you want to store identity data.
    
    
     You’ll find a placeholder
    
    <strong class="source-inline">
     
      DefaultConnection
     
    </strong>
    
     node generated in the
    
    <strong class="source-inline">
     
      appSettings.json
     
    </strong>
    
     file, which you must replace with the connection details of your database resource.
    
    
     Next to the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     directory, we get a chunk of generated components, including an
    
    <strong class="source-inline">
     
      Account
     
    </strong>
    
     area, with pages and UI, handling all actions required to manage identity in our application.
    
    
     There are components for logging in, logging out, managing accounts, and even enabling
    
    <strong class="bold">
     
      two-factor authentication
     
    </strong>
    
     (
    
    <strong class="bold">
     
      2FA
     
    </strong>
    
     ), and they’re all Razor-native components.
    
    
     You’ll notice that regardless of the interactivity declared when configuring, all the identity components are rendered in
    
    <strong class="bold">
     
      server-side rendering
     
    </strong>
    
     (
    
    <strong class="bold">
     
      SSR
     
    </strong>
    
     ) mode by default.
    
    
     As is currently an industry standard for applications with a server-side to leverage cookies for identity management, we’re also getting a custom
    
    <strong class="source-inline">
     
      IdentityRedirectManager
     
    </strong>
    
     wrapper, which leverages the default Blazor
    
    <strong class="source-inline">
     
      NavigationManager
     
    </strong>
    
     class, extending it with identity status cookies and a few redirection resolvers.
    
    
     The
    
    <strong class="source-inline">
     
      IdentityRedirectManager
     
    </strong>
    
     class is also designed to throw an
    
    <strong class="source-inline">
     
      InvalidOperationException
     
    </strong>
    
     exception when used outside of the static SSR.
    
    
     In SSR, contrary to other rendering modes, we can access an
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     instance of each request.
    
    
     The
    
    <strong class="source-inline">
     
      IdentityUserAccessor
     
    </strong>
    
     class is another wrapper class, allowing us to resolve the current user identity from the
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     instance.
    
    
     In the
    
    <strong class="source-inline">
     
      IdentityComponentsEndpointRouteBuilderExtensions
     
    </strong>
    
     class, we get a mapping for three additional identity endpoints for logging in with an external
    
    <strong class="bold">
     
      identity provider
     
    </strong>
    
     (
    
    <strong class="bold">
     
      IdP
     
    </strong>
    
     ), downloading personal user data, and logging out.
    
    
     These are missing in the default identity API implementation, as they’re native for applications with a UI.
    
    
     The
    
    <strong class="source-inline">
     
      IdentityNoOpEmailSender
     
    </strong>
    
     class is a placeholder service for sending identity-related emails: confirming user email or resetting passwords.
    
    
     You have to implement your own
    
    <strong class="source-inline">
     
      IEmailSender
     
    </strong>
    
     client before going live.
    
    
     We also get a
    
    <strong class="source-inline">
     
      PersistingRevalidatingAuthenticationStateProvider
     
    </strong>
    
     class that Blazor uses to share the authentication state across render boundaries between server and client code – we will explore that in the
    
    <em class="italic">
     
      Supporting roles’ and policies’ authorization
     
    </em>
    
     recipe too.
    
    
     The
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file gets a bit more complex.
    
    
     We will find here the default setup of interactive
    
    <a id="_idIndexMarker397">
    </a>
    
     server and WebAssembly components and a default middleware pipeline.
    
    
     However, on top of that, we’re setting up the server-side identity features.
    
    
     We register the custom identity services (discussed earlier in this section) and invoke the
    
    <strong class="source-inline">
     
      AddCascadingAuthenticationState()
     
    </strong>
    
     extension method to enable the cascading of the authentication state at a root level.
    
    
     We configure the authentication leveraging the
    
    <strong class="source-inline">
     
      AddAuthentication()
     
    </strong>
    
     extension method.
    
    
     Here’s also where we inform Blazor to use cookies for identity persistence with the help of the
    
    <strong class="source-inline">
     
      AddIdentityCookies()
     
    </strong>
    
     extension method.
    
    
     In
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     , we also configure the database access for our
    
    <strong class="source-inline">
     
      ApplicationDbContext
     
    </strong>
    
     class.
    
    
     Lastly, and most importantly, we leverage the
    
    <strong class="source-inline">
     
      AddIdentityCore()
     
    </strong>
    
     method and the
    
    <strong class="source-inline">
     
      IdentityBuilder
     
    </strong>
    
     API to configure the required
    
    
     
      identity services.
     
    
   </p>
   <p>
    
     Now that you understand the structure of each of the projects, let’s visualize how the authentication
    
    
     
      workflow works:
     
    
   </p>
   <div><div><img alt="Figure 8.7: Authentication workflow between server and client sides of the Blazor web app" src="img/Figure_8.7_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.7: Authentication workflow between server and client sides of the Blazor web app
    
   </p>
   <p>
    
     When a user tries to access the application, their identity is checked.
    
    
     The authentication state provider service validates the available authentication cookie or lack thereof.
    
    
     If validation is successful, the user gets redirected to the page they intended to visit; otherwise, the user lands on the login page.
    
    
     After submitting the login form and receiving a successful
    
    <a id="_idIndexMarker398">
    </a>
    
     authentication response from the IdP, Blazor persists the user’s identity in the authentication cookie.
    
    
     That cookie gets attached to every request between the server and client side, allowing
    
    <strong class="source-inline">
     
      PersistingRevalidatingAuthenticationStateProvider
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      PersistentAuthenticationStateProvider
     
    </strong>
    
     to effectively monitor and recognize the current user and
    
    
     
      their permissions.
     
    
   </p>
   <p>
    
     When you run the application for the first time and try to create an account, your application will fail.
    
    
     But in a developer-friendly way, you will see an exception page, informing you that you didn’t run the initial migration yet, so your backing database can’t support
    
    
     
      identity features:
     
    
   </p>
   <div><div><img alt="Figure 8.8: Exception page when you try to create an account without the initial migration" src="img/Figure_8.8_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.8: Exception page when you try to create an account without the initial migration
    
   </p>
   <p>
    
     You will also get a simple
    
    <strong class="bold">
     
      Apply Migrations
     
    </strong>
    
     button allowing you to apply the
    
    
     
      migrations immediately!
     
    
   </p>
   <p>
    
     All that code and functionality are ready to use, and you haven’t written a single line of your own code yet.
    
    
     Leveraging
    
    <a id="_idIndexMarker399">
    </a>
    
     solution templates and scaffolding increases the velocity of the delivery of
    
    
     
      your application.
     
    
   </p>
   <h2 id="_idParaDest-280">
    <a id="_idTextAnchor280">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     In case you’re not using a GUI or Visual Studio, you can leverage the cross-platform .NET CLI and scaffold the same template with a single command line.
    
    
     Navigate to your working directory and run the
    
    
     
      following command:
     
    
   </p>
   <pre class="console">
dotnet new blazor -o BlazorCookbook.Auth -int Auto --framework net9.0 -au Individual</pre>
   <p>
    
     You will get the same format of a project that we did through the Visual Studio walk-through, with one difference.
    
    
     The project scaffolded with the .NET CLI utilizes the SQLite database rather than SQL Server.
    
    
     You can quickly adjust that by navigating to the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file of the server-side project and updating the
    
    <strong class="source-inline">
     
      ApplicationDbContext
     
    </strong>
    
     registration options to use
    
    
     
      SQL Server:
     
    
   </p>
   <pre class="source-code">
builder.Services.AddDbContext&lt;ApplicationDbContext&gt;(
    options =&gt; options.UseSqlServer(connectionString));</pre>
   <h1 id="_idParaDest-281">
    <a id="_idTextAnchor281">
    </a>
    
     Securing pages
    
   </h1>
   <p>
    
     Protecting unauthorized routing is crucial as malicious actors can attempt to scrape your application, bypassing the navigation paths enforced by your UI.
    
    
     Ensuring that only authorized users can access specific routes helps safeguard sensitive data and functionality.
    
    
     Blazor
    
    <a id="_idIndexMarker400">
    </a>
    
     comes with a built-in
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     attribute to check access permissions when a user navigates to
    
    
     
      a page.
     
    
   </p>
   <p>
    
     Let’s add a routable component that only an authenticated user can navigate to by applying the
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     attribute in the
    
    
     
      right place.
     
    
   </p>
   <h2 id="_idParaDest-282">
    <a id="_idTextAnchor282">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we add a secure component to the server-side project, create a
    
    <strong class="source-inline">
     
      Components
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      Recipes
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      Recipe02
     
    </strong>
    
     directory – this will be your
    
    
     
      working directory.
     
    
   </p>
   <h2 id="_idParaDest-283">
    <a id="_idTextAnchor283">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these instructions to protect
    
    
     
      a component:
     
    
   </p>
   <ol>
    <li>
     
      Create a routable
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component with a
     
     <strong class="source-inline">
      
       /
      
     </strong>
     
      <strong class="source-inline">
       
        ch08r02
       
      </strong>
     
     
      
       path:
      
     
     <pre class="source-code">
@page "/ch08r02"</pre>
    </li>
    <li>
     
      Reference the
     
     <strong class="source-inline">
      
       Microsoft.AspNetCore.Authorization
      
     </strong>
     
      assembly and attach an
     
     <strong class="source-inline">
      
       Authorize
      
     </strong>
     
      attribute to the
     
     
      <strong class="source-inline">
       
        Settings
       
      </strong>
     
     
      
       component:
      
     
     <pre class="source-code">
@using Microsoft.AspNetCore.Authorization
@attribute [Authorize]</pre>
    </li>
    <li>
     
      Add placeholder markup to the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component, informing the user that they are authorized to see
     
     
      
       this content:
      
     
     <pre class="source-code">
&lt;h3&gt;Settings&lt;/h3&gt;
&lt;p&gt;You're authorized to see settings.&lt;/p&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-284">
    <a id="_idTextAnchor284">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we execute a routine step and create a new routable
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component, leveraging
    
    <strong class="source-inline">
     
      @page
     
    </strong>
    
     .
    
    
     Next, in
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we reference the
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.Authorization
     
    </strong>
    
     assembly with the help of the
    
    <strong class="source-inline">
     
      @using
     
    </strong>
    
     directive right below the
    
    <strong class="source-inline">
     
      @page
     
    </strong>
    
     declaration.
    
    
     Then, we use
    
    <strong class="source-inline">
     
      @attribute
     
    </strong>
    
     to attach the
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     attribute.
    
    
     Now, only authenticated users can access the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     page.
    
    
     However, it’s important to note that Blazor performs a verification of the
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     attribute only as part of the routing process and does not apply it to child components’ rendering flow.
    
    
     Lastly, in
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we add some placeholder content to inform users that they
    
    <a id="_idIndexMarker401">
    </a>
    
     are authorized to view this page.
    
    
     In the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     markup, we render the page header and a
    
    <strong class="bold">
     
      You’re authorized to see
     
    </strong>
    
     <strong class="bold">
      
       settings.
      
     </strong>
    
    
     
      message.
     
    
   </p>
   <h2 id="_idParaDest-285">
    <a id="_idTextAnchor285">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     If you’re building a markup-less component or simply working in a code-behind fashion, you can still leverage the
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     attribute.
    
    
     Here’s how we would implement a markup-less
    
    <a id="_idIndexMarker402">
    </a>
    
     version of the
    
    
     <strong class="source-inline">
      
       Settings
      
     </strong>
    
    
     
      component:
     
    
   </p>
   <pre class="source-code">
[Route("/ch08r02")]
[Authorize]
public class Settings : ComponentBase
{
    // ...
}</pre>
   <p>
    
     As we’re no longer in a Razor file, we’re using the syntax of C# attributes.
    
    
     By decorating the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     class with a
    
    <strong class="source-inline">
     
      [Route]
     
    </strong>
    
     attribute, we enable navigation to the
    
    <strong class="source-inline">
     
      /ch08r02
     
    </strong>
    
     path.
    
    
     Additionally, by adding the
    
    <strong class="source-inline">
     
      [Authorize]
     
    </strong>
    
     attribute, we ensure that Blazor only allows routing to this component for authenticated users.
    
    
     We effectively achieve the same logical behavior as in the initial implementation.
    
    
     As a side note, when you’re working in Razor files, the Razor compiler translates all the dedicated
    
    <strong class="source-inline">
     
      @directive
     
    </strong>
    
     declarations to attributes – similar to what we did with the
    
    
     
      markup-less component.
     
    
   </p>
   <h1 id="_idParaDest-286">
    <a id="_idTextAnchor286">
    </a>
    
     Securing markup areas
    
   </h1>
   <p>
    
     Sometimes, restricting access to an entire page can be too limiting.
    
    
     You might want to expose your landing page to everyone while fine-tuning the elements users see in the navigation menu.
    
    
     For example, authenticated
    
    <a id="_idIndexMarker403">
    </a>
    
     users might have access to a back office feature that standard users cannot see despite viewing the same page.
    
    
     Blazor supports protecting specific markup areas with an
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     component.
    
    
     The
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     component allows you to control the visibility of content based on the user’s authentication state.
    
    
     It supports various states and works seamlessly with
    
    <strong class="source-inline">
     
      RenderFragment
     
    </strong>
    
     objects, making it highly flexible
    
    
     
      and versatile.
     
    
   </p>
   <p>
    
     Let’s leverage the
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     component and add a status message visible only to
    
    
     
      authenticated users.
     
    
   </p>
   <h2 id="_idParaDest-287">
    <a id="_idTextAnchor287">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we add a protected status message to a component, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      In the server-side project, create a
     
     <strong class="source-inline">
      
       Components
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipes
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Securing pages
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Components
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipes
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe02
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-288">
    <a id="_idTextAnchor288">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to add a protected markup area in
    
    
     
      a component:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component and remove the
     
     <strong class="source-inline">
      
       Authorize
      
     </strong>
     
      attribute and the existing
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        using
       
      </strong>
     
     
      
       directive.
      
     
    </li>
    <li>
     
      Locate the authorization status message in the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      markup and wrap it in
     
     <strong class="source-inline">
      
       AuthorizeView
      
     </strong>
     
      
       component tags:
      
     
     <pre class="source-code">
&lt;h3&gt;Settings&lt;/h3&gt;
&lt;AuthorizeView&gt;
    &lt;p&gt;You're authorized to see settings.&lt;/p&gt;
&lt;/AuthorizeView&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-289">
    <a id="_idTextAnchor289">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we remove the existing
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     attribute and the
    
    <strong class="source-inline">
     
      @using
     
    </strong>
    
     directive, required to reference the attribute, from the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component, allowing all users to access
    
    
     
      the page.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we locate the
    
    <strong class="bold">
     
      You’re authorized to see settings.
     
    </strong>
    
     authorization status message in the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     markup.
    
    
     We then wrap this message inside
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     component tags.
    
    
     The
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     component manages content visibility based on
    
    <a id="_idIndexMarker404">
    </a>
    
     the user authentication state and accepts
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     , meaning Blazor will render the status message only for authenticated users.
    
    
     This approach ensures that only users with the proper credentials see certain content, enhancing the security and user experience of your application.
    
    
     You can find more details on the
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     pattern in the
    
    <em class="italic">
     
      Creating components with customizable content
     
    </em>
    
     recipe of
    
    <a href="B22020_01.xhtml#_idTextAnchor020">
     
      <em class="italic">
       
        Chapter 1
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     Blazor will effectively obscure everything inside the
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     component from unauthorized users.
    
    
     That means markup, as well as any event handlers or method calls.
    
    
     Consequently, you can secure your UI and entire features and functionalities, preventing unauthorized users from even knowing
    
    
     
      they exist.
     
    
   </p>
   <h2 id="_idParaDest-290">
    <a id="_idTextAnchor290">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     Apart from
    
    <strong class="source-inline">
     
      ChildContent
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     supports providing the
    
    <strong class="source-inline">
     
      Authorized
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Authorizing
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      NotAuthorized
     
    </strong>
    
     fragments explicitly.
    
    
     With that, you can define distinct content for authenticated and unauthenticated users within the same component.
    
    
     You would leverage the
    
    <strong class="source-inline">
     
      Authorizing
     
    </strong>
    
     fragment to display a temporary message indicating that resolving of user’s identity is in progress, as you might need to execute some asynchronous and long-running logic.
    
    
     In our case, we could opt for the following markup in the
    
    
     <strong class="source-inline">
      
       Settings
      
     </strong>
    
    
     
      component:
     
    
   </p>
   <pre class="source-code">
&lt;h3&gt;Settings&lt;/h3&gt;
&lt;AuthorizeView&gt;
    &lt;Authorized&gt;
        &lt;p&gt;You're authorized to see settings.&lt;/p&gt;
    &lt;/Authorized&gt;
    &lt;Authorizing&gt;
        &lt;p&gt;Give us a few moments...&lt;/p&gt;
    &lt;/Authorizing&gt;
    &lt;NotAuthorized&gt;
        &lt;p&gt;You can't be here, sorry.&lt;/p&gt;
    &lt;/NotAuthorized&gt;
&lt;/AuthorizeView&gt;</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     component will evaluate the user’s authentication state normally, but this time give the user a feeling of each stage of the process.
    
    
     When authenticating the user, Blazor will render the content in
    
    <strong class="source-inline">
     
      Authorizing
     
    </strong>
    
     tags – a
    
    <strong class="bold">
     
      Give us a few moments…
     
    </strong>
    
     message.
    
    
     When
    
    <a id="_idIndexMarker405">
    </a>
    
     authentication is complete, for the authenticated user, Blazor will render the markup in the
    
    <strong class="source-inline">
     
      Authorized
     
    </strong>
    
     section and display the expected
    
    <strong class="bold">
     
      You’re authorized to see settings.
     
    </strong>
    
     message.
    
    
     However, contrary to the
    
    <strong class="source-inline">
     
      Authorized
     
    </strong>
    
     attribute, an anonymous user will also see some content – one within
    
    <strong class="source-inline">
     
      NotAuthorized
     
    </strong>
    
     tags, saying
    
    <strong class="bold">
     
      You can’t be here, sorry.
     
    </strong>
    
     , offering meaningful feedback to
    
    
     
      unauthenticated users.
     
    
   </p>
   <h1 id="_idParaDest-291">
    <a id="_idTextAnchor291">
    </a>
    
     Creating roles
    
   </h1>
   <p>
    
     Roles in web applications are predefined categories assigned to users that determine their access permissions and functionalities within the application.
    
    
     By categorizing users into roles, you can manage
    
    <a id="_idIndexMarker406">
    </a>
    
     and control what each user can view and do, enhancing security and user experience.
    
    
     Roles provide a clear and structured way to enforce access control.
    
    
     Instead of managing permissions for each user, you can assign roles and define access rules based on these roles.
    
    
     This approach simplifies the administration of user permissions and ensures consistent security policies across
    
    
     
      the application.
     
    
   </p>
   <p>
    
     Let’s add a small form where authenticated users can create new roles in
    
    
     
      the application.
     
    
   </p>
   <h2 id="_idParaDest-292">
    <a id="_idTextAnchor292">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we implement the role creation form, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      In the server-side
     
     <a id="_idIndexMarker407">
     </a>
     
      project, create a
     
     <strong class="source-inline">
      
       Components
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipes
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe04
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Securing markup areas
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Components
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipes
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      If you haven’t scaffolded your project, copy the
     
     <strong class="source-inline">
      
       StatusMessage
      
     </strong>
     
      component from the
     
     <strong class="source-inline">
      
       Components
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Account
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Shared
      
     </strong>
     
      directory of the GitHub repository to the same path in your
     
     
      
       server-side project
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-293">
    <a id="_idTextAnchor293">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these instructions to set up roles’ support
    
    
     
      and management:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the server-side project’s
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      file.
     
     
      Find the section where we register identity services, starting with the
     
     
      <strong class="source-inline">
       
        AddIdentityCore()
       
      </strong>
     
     
      
       method.
      
     
    </li>
    <li>
     
      After the
     
     <strong class="source-inline">
      
       AddIdentityCore()
      
     </strong>
     
      method, invoke the
     
     <strong class="source-inline">
      
       AddRoles()
      
     </strong>
     
      method and leverage the default
     
     <strong class="source-inline">
      
       IdentityRole
      
     </strong>
     
      model to declare the application role model.
     
     
      Below the
     
     <strong class="source-inline">
      
       AddEntityFrameworkStores()
      
     </strong>
     
      method, register a role manager with the help of an
     
     <strong class="source-inline">
      
       AddRoleManager()
      
     </strong>
     
      builder method with the default
     
     <strong class="source-inline">
      
       RoleManager
      
     </strong>
     
      service for the
     
     
      <strong class="source-inline">
       
        IdentityRole
       
      </strong>
     
     
      
       model:
      
     
     <pre class="source-code">
builder.Services.AddIdentityCore&lt;ApplicationUser&gt;()
    .AddRoles&lt;IdentityRole&gt;()
    .AddEntityFrameworkStores&lt;ApplicationDbContext&gt;()
    .AddRoleManager&lt;RoleManager&lt;IdentityRole&gt;&gt;()
    .AddSignInManager()
    .AddDefaultTokenProviders();</pre>
    </li>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component, and below the
     
     <strong class="source-inline">
      
       @page
      
     </strong>
     
      directive, add a set of
     
     <strong class="source-inline">
      
       @using
      
     </strong>
     
      directives referencing the
     
     
      
       necessary assemblies:
      
     
     <pre class="source-code">
@using BlazorCookbook.Auth.Components.Account
@using BlazorCookbook.Auth.Components.Account.Shared
@using Microsoft.AspNetCore.Identity</pre>
    </li>
    <li>
     
      Below the section
     
     <a id="_idIndexMarker408">
     </a>
     
      with
     
     <strong class="source-inline">
      
       @using
      
     </strong>
     
      , inject
     
     <strong class="source-inline">
      
       RoleManager
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        Navigation
       
      </strong>
     
     
      
       services:
      
     
     <pre class="source-code">
@inject RoleManager&lt;IdentityRole&gt; RoleManager
@inject IdentityRedirectManager Navigation</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component, initialize the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block and construct an
     
     <strong class="source-inline">
      
       InputModel
      
     </strong>
     
      class with a single
     
     
      <strong class="source-inline">
       
        RoleName
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
@code {
    private sealed class InputModel
    {
        public string RoleName { get; set; }
    }
}</pre>
    </li>
    <li>
     
      Below the service injections, intercept a cascading value
     
     
      
       of
      
     
     
      <strong class="source-inline">
       
        HttpContext
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
[CascadingParameter]
private HttpContext HttpContext { get; set; }</pre>
    </li>
    <li>
     
      Below
     
     <strong class="source-inline">
      
       HttpContext
      
     </strong>
     
      , declare an
     
     <strong class="source-inline">
      
       Input
      
     </strong>
     
      parameter supplied from a form and override the
     
     <strong class="source-inline">
      
       OnInitialized()
      
     </strong>
     
      lifecycle method to complete the form
     
     
      
       initialization pattern:
      
     
     <pre class="source-code">
[SupplyParameterFromForm]
private InputModel Input { get; set; } = new();
protected override void OnInitialized()
    =&gt; Input ??= new();</pre>
    </li>
    <li>
     
      Complete the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block with the implementation of a
     
     <strong class="source-inline">
      
       SaveAsync()
      
     </strong>
     
      method, where you initialize a new
     
     <strong class="source-inline">
      
       IdentityRole
      
     </strong>
     
      object and leverage the
     
     <strong class="source-inline">
      
       RoleManager
      
     </strong>
     
      service to
     
     <a id="_idIndexMarker409">
     </a>
     
      save the new role.
     
     
      Use the
     
     <strong class="source-inline">
      
       Navigation
      
     </strong>
     
      service to perform a self-redirect and display the
     
     
      
       operation status:
      
     
     <pre class="source-code">
private async Task SaveAsync()
{
    var role = new IdentityRole(Input.RoleName);
    await RoleManager.CreateAsync(role);
    Navigation.RedirectToCurrentPageWithStatus(
        $"'{role.Name}' role has been created",
        HttpContext);
}</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component markup, locate the
     
     <strong class="source-inline">
      
       AuthorizeView
      
     </strong>
     
      tags and declare a custom name for the
     
     <strong class="source-inline">
      
       Context
      
     </strong>
     
      parameter.
     
     
      Also, replace the authentication status message with a
     
     
      <strong class="source-inline">
       
        StatusMessage
       
      </strong>
     
     
      
       component:
      
     
     <pre class="source-code">
&lt;AuthorizeView Context="auth"&gt;
    &lt;StatusMessage /&gt;
&lt;/AuthorizeView&gt;</pre>
    </li>
    <li>
     
      Below
     
     <strong class="source-inline">
      
       StatusMessage
      
     </strong>
     
      , initialize an
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      component, attaching the
     
     <strong class="source-inline">
      
       Input
      
     </strong>
     
      model and the
     
     <strong class="source-inline">
      
       SaveAsync()
      
     </strong>
     
      method to the
     
     <strong class="source-inline">
      
       Model
      
     </strong>
     
      and
     
     <strong class="source-inline">
      
       OnValidSubmit
      
     </strong>
     
      parameters.
     
     
      Remember to declare a unique
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      name
     
     
      
       as well:
      
     
     <pre class="source-code">
&lt;EditForm FormName="creator"
          OnValidSubmit="@SaveAsync"
          Model="@Input"&gt;
&lt;/EditForm&gt;</pre>
    </li>
    <li>
     
      Within the
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      component, add a paragraph with an editable input box binding to the
     
     
      <strong class="source-inline">
       
        Input.RoleName
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
&lt;p&gt;Role name
  &lt;InputText @bind-Value="@Input.RoleName" /&gt;
&lt;/p&gt;</pre>
    </li>
    <li>
     
      Complete the
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      component
     
     <a id="_idIndexMarker410">
     </a>
     
      by adding a form submit button below the role
     
     
      
       name input:
      
     
     <pre class="source-code">
&lt;p&gt;&lt;button type="submit"&gt;Save&lt;/button&gt;&lt;/p&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-294">
    <a id="_idTextAnchor294">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file of the server-side project and locate the section where we register identity services.
    
    
     It’s a section starting with an
    
    <strong class="source-inline">
     
      AddIdentityCore()
     
    </strong>
    
     method and producing an
    
    <strong class="source-inline">
     
      IdentityBuilder
     
    </strong>
    
     object.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we invoke the
    
    <strong class="source-inline">
     
      AddRoles()
     
    </strong>
    
     method to add role management capabilities to the identity system.
    
    
     The
    
    <strong class="source-inline">
     
      AddRoles()
     
    </strong>
    
     method is a generic method requiring an identity role model class.
    
    
     We leverage the default
    
    <strong class="source-inline">
     
      IdentityRole
     
    </strong>
    
     model, provided with an identity package.
    
    
     The
    
    <strong class="source-inline">
     
      IdentityRole
     
    </strong>
    
     model is enough for our needs.
    
    
     Next, below the
    
    <strong class="source-inline">
     
      AddEntityFrameworkStores()
     
    </strong>
    
     method, we register the role manager using the
    
    <strong class="source-inline">
     
      AddRoleManager()
     
    </strong>
    
     builder method with the default
    
    <strong class="source-inline">
     
      RoleManager
     
    </strong>
    
     service for the
    
    <strong class="source-inline">
     
      IdentityRole
     
    </strong>
    
     model.
    
    
     We’ve effectively enabled roles’ support and roles’ management in
    
    
     
      the app.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we move to the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component.
    
    
     First, we add a set of
    
    <strong class="source-inline">
     
      @using
     
    </strong>
    
     directives below
    
    <strong class="source-inline">
     
      @page
     
    </strong>
    
     to reference the necessary assemblies, allowing access to the scaffolded
    
    <strong class="source-inline">
     
      Account
     
    </strong>
    
     area and built-in identity services.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we inject the
    
    <strong class="source-inline">
     
      RoleManager
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Navigation
     
    </strong>
    
     services, handling role management and navigation, respectively.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we initialize the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block in the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component.
    
    
     Within the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block, we construct an
    
    <strong class="source-inline">
     
      InputModel
     
    </strong>
    
     class with a single
    
    <strong class="source-inline">
     
      RoleName
     
    </strong>
    
     property.
    
    
     The
    
    <strong class="source-inline">
     
      InputModel
     
    </strong>
    
     class will hold the details of the new role when a user fills out the form.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we intercept a cascading value of
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     to access the current HTTP context  –  necessary for communicating role creation status later.
    
    
     The
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     object didn’t appear magically – when Blazor renders in SSR mode, it exposes the
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     instance cascadingly by default.
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , below
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     , we declare an
    
    <strong class="source-inline">
     
      Input
     
    </strong>
    
     parameter supplied from a form and override the
    
    <strong class="source-inline">
     
      OnInitialized()
     
    </strong>
    
     lifecycle method to complete the form initialization pattern.
    
    
     You can learn more about building forms in
    
    <a href="B22020_06.xhtml#_idTextAnchor203">
     
      <em class="italic">
       
        Chapter 6
       
      </em>
     
    </a>
    
     .
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we complete the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block by implementing a
    
    <strong class="source-inline">
     
      SaveAsync()
     
    </strong>
    
     method.
    
    
     In
    
    <strong class="source-inline">
     
      SaveAsync()
     
    </strong>
    
     , we initialize a new
    
    <strong class="source-inline">
     
      IdentityRole
     
    </strong>
    
     object and leverage
    
    <strong class="source-inline">
     
      RoleManager
     
    </strong>
    
     to save the new role to a database.
    
    
     We
    
    <a id="_idIndexMarker411">
    </a>
    
     use the
    
    <strong class="source-inline">
     
      Navigation
     
    </strong>
    
     service and
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     to perform a self-redirect and send an operation status back to
    
    
     
      the user.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we switch to the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     markup.
    
    
     First, we locate the
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     tags.
    
    
     The
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     component is a generic component, so it exposes a
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     property.
    
    
     Likewise,
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     , which we will use for our form, is also a generic component having a
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     property.
    
    
     We will have a conflict, and the app will not compile!
    
    
     To resolve that issue, we give a custom name to the
    
    <strong class="source-inline">
     
      Context
     
    </strong>
    
     property of
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     .
    
    
     We also replace the existing authentication status message with a
    
    <strong class="source-inline">
     
      StatusMessage
     
    </strong>
    
     component.
    
    
     The
    
    <strong class="source-inline">
     
      StatusMessage
     
    </strong>
    
     component intercepts
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     and resolves the status message from a designated cookie.
    
    
     That’s why we needed
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     in the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block – to attach that status cookie correctly.
    
    
     In
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , we initialize an
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component below
    
    <strong class="source-inline">
     
      StatusMessage
     
    </strong>
    
     , attaching the
    
    <strong class="source-inline">
     
      Input
     
    </strong>
    
     model and the
    
    <strong class="source-inline">
     
      SaveAsync()
     
    </strong>
    
     method to the
    
    <strong class="source-inline">
     
      Model
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      OnValidSubmit
     
    </strong>
    
     parameters, respectively.
    
    
     We also declare a unique
    
    <strong class="source-inline">
     
      FormName
     
    </strong>
    
     class for
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     .
    
    
     Within
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     , in
    
    <em class="italic">
     
      step 11
     
    </em>
    
     , we add a paragraph with an editable input box binding to the
    
    <strong class="source-inline">
     
      Input.RoleName
     
    </strong>
    
     property, allowing the user to enter the new role name.
    
    
     Finally, in
    
    <em class="italic">
     
      step 12
     
    </em>
    
     , we complete the
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component by adding a form submit button below the role
    
    
     
      name input.
     
    
   </p>
   <h1 id="_idParaDest-295">
    <a id="_idTextAnchor295">
    </a>
    
     Modifying a user’s identity
    
   </h1>
   <p>
    
     Modifying a user’s identity
    
    <a id="_idIndexMarker412">
    </a>
    
     can be crucial for tailoring your application’s functionality and improving user experience.
    
    
     Having additional identity properties, you can enable more personalized interactions and better manage user-specific information.
    
    
     In many applications, a username is equivalent to a user’s email, and that’s not enough details for displaying personalized greetings, sending customized notifications, or generating reports.
    
    
     But worry not.
    
    
     In Blazor, identity is
    
    
     
      highly flexible.
     
    
   </p>
   <p>
    
     Let’s allow a user to
    
    <a id="_idIndexMarker413">
    </a>
    
     fill in their first and
    
    
     
      last name.
     
    
   </p>
   <h2 id="_idParaDest-296">
    <a id="_idTextAnchor296">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before extending the user’s identity, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      In the server-side project, create a
     
     <strong class="source-inline">
      
       Components
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipes
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Creating roles
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Components
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipes
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe03
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      Find the
     
     <strong class="source-inline">
      
       seed-work.sql
      
     </strong>
     
      script in the
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      directory of the server-side project in the GitHub repository and run it on
     
     
      
       your database
      
     
    </li>
    <li>
     
      If you haven’t scaffolded your project, copy the
     
     <strong class="source-inline">
      
       StatusMessage
      
     </strong>
     
      component from the
     
     <strong class="source-inline">
      
       Components
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Account
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Shared
      
     </strong>
     
      directory of the GitHub repository to the same path in your
     
     
      
       server-side project
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-297">
    <a id="_idTextAnchor297">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     Follow these steps to extend the default user
    
    
     
      identity model:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       ApplicationUser
      
     </strong>
     
      class in the
     
     <strong class="source-inline">
      
       Data
      
     </strong>
     
      directory of the server-side project and extend it with
     
     <strong class="source-inline">
      
       FirstName
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        LastName
       
      </strong>
     
     
      
       properties:
      
     
     <pre class="source-code">
public class ApplicationUser : IdentityUser
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}</pre>
    </li>
    <li>
     
      Using the
     
     <strong class="bold">
      
       Package Manager Console
      
     </strong>
     
      , call an Entity Framework command to generate a new
     
     <strong class="source-inline">
      
       AddedUserFullName
      
     </strong>
     
      
       database migration:
      
     
     <pre class="source-code">
<strong class="bold">add-migration AddedUserFullName</strong></pre>
     <p class="list-inset">
      
       Alternatively, if you’re using the .NET CLI, generate the same migration using the
      
      
       
        following command:
       
      
     </p>
     <pre class="source-code"><strong class="bold">dotnet ef migrations add AddedUserFullName</strong></pre>
     <p class="list-inset">
      
       You will get a few
      
      <a id="_idIndexMarker414">
      </a>
      
       new files in the
      
      
       <strong class="source-inline">
        
         Data
        
       </strong>
      
      
       
        /
       
      
      
       <strong class="source-inline">
        
         Migrations
        
       </strong>
      
      
       
        directory:
       
      
     </p>
    </li>
   </ol>
   <div><div><img alt="Figure 8.9: Migration files adding FirstName and LastName properties to ApplicationUser in database" src="img/Figure_8.9_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.9: Migration files adding FirstName and LastName properties to ApplicationUser in database
    
   </p>
   <ol>
    <li value="3">
     
      Apply the
     
     <strong class="source-inline">
      
       AddedUserFullName
      
     </strong>
     
      migration to the database by calling another command in the
     
     <strong class="bold">
      
       Package
      
     </strong>
     
      <strong class="bold">
       
        Manager Console
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
<strong class="bold">update-database</strong></pre>
     <p class="list-inset">
      
       Alternatively, if you’re using the .NET CLI, update the database using the
      
      
       
        following command:
       
      
     </p>
     <pre class="source-code"><strong class="bold">dotnet ef database update</strong></pre>
    </li>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component and add one more
     
     <strong class="source-inline">
      
       @using
      
     </strong>
     
      directive, next to the
     
     
      
       existing ones:
      
     
     <pre class="source-code">
@using BlazorCookbook.Auth.Data</pre>
    </li>
    <li>
     
      Below, in the section with injections, replace the
     
     <strong class="source-inline">
      
       RoleManager
      
     </strong>
     
      service with
     
     <strong class="source-inline">
      
       IdentityUserAccessor
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       UserManager
      
     </strong>
     
      , and
     
     <strong class="source-inline">
      
       SignInManager
      
     </strong>
     
      services.
     
     
      Keep the already available
     
     
      <strong class="source-inline">
       
        Navigation
       
      </strong>
     
     
      
       service:
      
     
     <pre class="source-code">
@inject IdentityUserAccessor UserAccessor
@inject UserManager&lt;ApplicationUser&gt; UserManager
@inject SignInManager&lt;ApplicationUser&gt; SignInManager
@inject IdentityRedirectManager Navigation</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, update
     
     <a id="_idIndexMarker415">
     </a>
     
      the
     
     <strong class="source-inline">
      
       InputModel
      
     </strong>
     
      class by replacing the existing properties with
     
     <strong class="source-inline">
      
       FirstName
      
     </strong>
     
      
       and
      
     
     
      <strong class="source-inline">
       
        LastName
       
      </strong>
     
     
      
       :
      
     
     <pre class="source-code">
private sealed class InputModel
{
    public string FirstName { get; set; }
    public string LastName { get; set; }
}</pre>
    </li>
    <li>
     
      Above the existing
     
     <strong class="source-inline">
      
       SaveAsync()
      
     </strong>
     
      method, declare a private
     
     
      <strong class="source-inline">
       
        ApplicationUser
       
      </strong>
     
     
      
       field:
      
     
     <pre class="source-code">
private ApplicationUser _user;</pre>
    </li>
    <li>
     
      Below the
     
     <strong class="source-inline">
      
       _user
      
     </strong>
     
      declaration, override the
     
     <strong class="source-inline">
      
       OnInitializedAsync()
      
     </strong>
     
      lifecycle method.
     
     
      Leverage the
     
     <strong class="source-inline">
      
       UserAccessor
      
     </strong>
     
      instance to get the user details from the database and hydrate the
     
     
      <strong class="source-inline">
       
        Input
       
      </strong>
     
     
      
       model:
      
     
     <pre class="source-code">
protected override async Task OnInitializedAsync()
{
    _user = await UserAccessor
        .GetRequiredUserAsync(HttpContext);
    Input.FirstName ??= _user.FirstName;
    Input.LastName ??= _user.LastName;
}</pre>
    </li>
    <li>
     
      To complete the
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block, update the
     
     <strong class="source-inline">
      
       SaveAsync()
      
     </strong>
     
      method so that it updates
     
     <strong class="source-inline">
      
       _user
      
     </strong>
     
      details from the filled
     
     <strong class="source-inline">
      
       Input
      
     </strong>
     
      model, persist changes with the help of
     
     <strong class="source-inline">
      
       UserManager
      
     </strong>
     
      , and refresh the user context using
     
     <strong class="source-inline">
      
       SignInManager
      
     </strong>
     
      .
     
     
      Lastly, update the status
     
     <a id="_idIndexMarker416">
     </a>
     
      message returned to
     
     
      
       the user:
      
     
     <pre class="source-code">
private async Task SaveAsync()
{
    _user.FirstName = Input.FirstName;
    _user.LastName = Input.LastName;
    await UserManager.UpdateAsync(_user);
    await SignInManager.RefreshSignInAsync(_user);
    Navigation.RedirectToCurrentPageWithStatus(
        "Your profile has been updated",
        HttpContext);
}</pre>
    </li>
    <li>
     
      Jump to the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      markup area and locate the content area of the existing
     
     
      <strong class="source-inline">
       
        EditForm
       
      </strong>
     
     
      
       component.
      
     
    </li>
    <li>
     
      Update the existing input label to
     
     <strong class="source-inline">
      
       First Name
      
     </strong>
     
      and fix the binding to the
     
     
      <strong class="source-inline">
       
        Input.FirstName
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
&lt;p&gt;First Name
  &lt;InputText @bind-Value="@Input.FirstName" /&gt;
&lt;/p&gt;</pre>
    </li>
    <li>
     
      Below the first name, add a paragraph displaying another editable input binding to the
     
     
      <strong class="source-inline">
       
        Input.LastName
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
&lt;p&gt;Last Name
  &lt;InputText @bind-Value="@Input.LastName" /&gt;
&lt;/p&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-298">
    <a id="_idTextAnchor298">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      ApplicationUser
     
    </strong>
    
     class in the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     directory of the server-side project.
    
    
     The
    
    <strong class="source-inline">
     
      ApplicationUser
     
    </strong>
    
     class represents the user of our application and currently inherits from the default
    
    <strong class="source-inline">
     
      IdentityUser
     
    </strong>
    
     class to be compatible with the identity schema.
    
    
     Now, we extend our user identity details with
    
    <strong class="source-inline">
     
      FirstName
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      LastName
     
    </strong>
    
     properties.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we extend the identity database using a database migration.
    
    
     Database migrations are a way to manage and apply incremental changes to the database schema over time.
    
    
     They allow developers to define changes to the database
    
    <a id="_idIndexMarker417">
    </a>
    
     structure, such as adding or modifying tables and columns, in code, ensuring that the database is in sync with the application.
    
    
     We open the
    
    <strong class="bold">
     
      Package Manager Console
     
    </strong>
    
     , available in Visual Studio, and generate a new
    
    <strong class="source-inline">
     
      AddedUserFullName
     
    </strong>
    
     database migration.
    
    
     The Entity Framework tool will generate two new files in the
    
    <strong class="source-inline">
     
      Data
     
    </strong>
    
     /
    
    <strong class="source-inline">
     
      Migrations
     
    </strong>
    
     directory.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we apply the
    
    <strong class="source-inline">
     
      AddedUserFullName
     
    </strong>
    
     migration to the database using the
    
    <strong class="bold">
     
      Package Manager Console
     
    </strong>
    
     again.
    
    
     We will not explore generated migrations or migration commands as they’re not in the scope of this book, but you can find additional resources in the
    
    <em class="italic">
     
      See also
     
    </em>
    
     section at the end of
    
    
     
      the recipe.
     
    
   </p>
   <p>
    
     Next, in
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we open the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component and extend the set of already existing
    
    <strong class="source-inline">
     
      @using
     
    </strong>
    
     directives with a reference to a
    
    <strong class="source-inline">
     
      BlazorCookbook.Auth.Data
     
    </strong>
    
     assembly, where we have the
    
    <strong class="source-inline">
     
      ApplicationUser
     
    </strong>
    
     class.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we remove the
    
    <strong class="source-inline">
     
      RoleManager
     
    </strong>
    
     service injection, as we won’t work with roles.
    
    
     Instead, we’re adding a few other identity services.
    
    
     We need
    
    <strong class="source-inline">
     
      IdentityUserAccessor
     
    </strong>
    
     to resolve the user context from the application
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     instance.
    
    
     With the help of
    
    <strong class="source-inline">
     
      UserManager
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      SignInManager
     
    </strong>
    
     , we can safely manipulate and refresh user details.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we update the
    
    <strong class="source-inline">
     
      InputModel
     
    </strong>
    
     class to support our new requirements and replace all existing properties with
    
    <strong class="source-inline">
     
      FirstName
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      LastName
     
    </strong>
    
     properties, matching the details we want to see on the new form later.
    
    
     At this point, you will see some IDE errors, as the existing form is no longer compatible with the updated
    
    <strong class="source-inline">
     
      InputModel
     
    </strong>
    
     class.
    
    
     We will fix that shortly.
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we declare a backing field – a private
    
    <strong class="source-inline">
     
      ApplicationUser
     
    </strong>
    
     variable to store a reference to the database object representing the currently logged-in user.
    
    
     We will use it to persist the first and last name the user provides.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we override the
    
    <strong class="source-inline">
     
      OnInitializedAsync()
     
    </strong>
    
     lifecycle method.
    
    
     We leverage the injected
    
    <strong class="source-inline">
     
      UserAccessor
     
    </strong>
    
     service to resolve the
    
    <strong class="source-inline">
     
      ApplicationUser
     
    </strong>
    
     object from
    
    <strong class="source-inline">
     
      HttpContext
     
    </strong>
    
     into the
    
    <strong class="source-inline">
     
      _user
     
    </strong>
    
     instance and hydrate the
    
    <strong class="source-inline">
     
      Input
     
    </strong>
    
     model with the found details.
    
    
     That way, we ensure the form is pre-populated with the current user’s details before the UI renders.
    
    
     To complete the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block, in
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we update the
    
    <strong class="source-inline">
     
      SaveAsync()
     
    </strong>
    
     method so that it supports the updated
    
    <strong class="source-inline">
     
      Input
     
    </strong>
    
     model and saves user identity details.
    
    
     We update the persisted
    
    <strong class="source-inline">
     
      _user
     
    </strong>
    
     object with data coming from the form, filled by the user, and save those changes to the database with the help of
    
    <strong class="source-inline">
     
      UserManager
     
    </strong>
    
     .
    
    
     After
    
    <a id="_idIndexMarker418">
    </a>
    
     updating, we refresh the user context using
    
    <strong class="source-inline">
     
      SignInManager
     
    </strong>
    
     and perform a self-redirect to display a
    
    <strong class="bold">
     
      Your profile has been updated
     
    </strong>
    
     message on
    
    
     
      the UI.
     
    
   </p>
   <p>
    
     Next, in
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , we jump to the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     markup area and locate the existing
    
    <strong class="source-inline">
     
      EditForm
     
    </strong>
    
     component.
    
    
     We will adjust the form to support filling in the user’s first and last names.
    
    
     In
    
    <em class="italic">
     
      step 11
     
    </em>
    
     , we fix the no longer compatible input box by binding it to the
    
    <strong class="source-inline">
     
      Input.FirstName
     
    </strong>
    
     property.
    
    
     We also update the label to
    
    <strong class="source-inline">
     
      First name
     
    </strong>
    
     , to make it clear which field the user is updating.
    
    
     Similarly, in
    
    <em class="italic">
     
      step 12
     
    </em>
    
     , we add a paragraph with another editable input box with a
    
    <strong class="source-inline">
     
      Last name
     
    </strong>
    
     label and binding to the
    
    
     <strong class="source-inline">
      
       Input.LastName
      
     </strong>
    
    
     
      property.
     
    
   </p>
   <p>
    
     With the form in place, you can run the app and update the first and last name of the account you’ll be using.
    
    
     When you fill the inputs and save the changes, you’ll receive a friendly
    
    
     
      confirmation message:
     
    
   </p>
   <div><div><img alt="Figure 8.10: Status message confirming that changes were successfully applied" src="img/Figure_8.10_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.10: Status message confirming that changes were successfully applied
    
   </p>
   <p>
    
     You can also check changes in the database by displaying the records in the
    
    
     <strong class="source-inline">
      
       AspNetUsers
      
     </strong>
    
    
     
      table:
     
    
   </p>
   <div><div><img alt="Figure 8.11: Reviewing first and last name updates in the database" src="img/Figure_8.11_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.11: Reviewing first and last name updates in the database
    
   </p>
   <h2 id="_idParaDest-299">
    <a id="_idTextAnchor299">
    </a>
    
     See also
    
   </h2>
   <p>
    
     In this recipe, we’ve
    
    <a id="_idIndexMarker419">
    </a>
    
     touched on the concept of database migrations.
    
    
     It’s a topic deserving a book of its own, but if you’d like to learn more, go to the learning resources prepared by the Microsoft
    
    
     
      team:
     
    
    <a href="https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations">
     
      
       https://learn.microsoft.com/en-us/ef/core/managing-schemas/migrations
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-300">
    <a id="_idTextAnchor300">
    </a>
    
     Supporting roles’ and policies’ authorization
    
   </h1>
   <p>
    
     Securing your application might not be just about having an authenticated user; it often requires more granular control.
    
    
     You may need to grant access to specific features or pages based on the user’s role.
    
    
     Blazor’s native authorization APIs – the
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     attribute and the
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     component – support both roles and policies that you will find familiar from MVC applications or
    
    
     
      REST APIs.
     
    
   </p>
   <p>
    
     Let’s implement roles and policies, fine-tuning a settings page to display different content for administrators and
    
    
     
      standard users.
     
    
   </p>
   <h2 id="_idParaDest-301">
    <a id="_idTextAnchor301">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we put policies and
    
    <a id="_idIndexMarker420">
    </a>
    
     roles in place, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      In the server-side project, create a
     
     <strong class="source-inline">
      
       Components
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipes
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe06
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory.
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component from the
     
     <em class="italic">
      
       Modifying a user’s identity
      
     </em>
     
      recipe or from the
     
     <strong class="source-inline">
      
       Components
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipes
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe05
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository.
      
     
    </li>
    <li>
     
      If you haven’t run migrations yet, find the
     
     <strong class="source-inline">
      
       seed-work.sql
      
     </strong>
     
      script in the
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      directory of the server-side project and run it on
     
     
      
       your database.
      
     
    </li>
    <li>
     
      If you’re not following along, make sure you have roles’ support enabled in your server-side project; you must leverage the
     
     <strong class="source-inline">
      
       AddRoles()
      
     </strong>
     
      builder API method, which we discussed in the
     
     <em class="italic">
      
       Creating
      
     </em>
     
      <em class="italic">
       
        roles
       
      </em>
     
     
      
       recipe.
      
     
    </li>
   </ul>
   <h2 id="_idParaDest-302">
    <a id="_idTextAnchor302">
    </a>
    
     How to do it…
    
   </h2>
   <p>
    
     To add roles’ and policies’ support, both
    
    <a id="_idIndexMarker421">
    </a>
    
     on the server and client side, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Navigate to the
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      file in the
     
     <strong class="source-inline">
      
       BlazorCookbook.Auth.Client
      
     </strong>
     
      project – the
     
     
      
       client-side application.
      
     
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      file, find the
     
     <strong class="source-inline">
      
       AddAuthorizationCore()
      
     </strong>
     
      method call and overload it with
     
     <strong class="source-inline">
      
       options
      
     </strong>
     
      to configure the
     
     <strong class="source-inline">
      
       InternalEmployee
      
     </strong>
     
      policy that checks if a user’s email belongs to the
     
     <strong class="source-inline">
      
       @
      
     </strong>
     
      <strong class="source-inline">
       
        packt.com
       
      </strong>
     
     
      
       domain:
      
     
     <pre class="source-code">
builder.Services.AddAuthorizationCore(options =&gt;
{
    options.AddPolicy("InternalEmployee", policy =&gt;
        policy.RequireAssertion(context =&gt;
            context.User?.Identity?.Name?
                .EndsWith("@packt.com") ?? false));
});</pre>
    </li>
    <li>
     
      Still on the client side, open the
     
     <strong class="source-inline">
      
       UserInfo
      
     </strong>
     
      class and extend it with a
     
     
      <strong class="source-inline">
       
        Role
       
      </strong>
     
     
      
       property:
      
     
     <pre class="source-code">
public class UserInfo
{
    //... existing properties ...
    public required string Role { get; set; }
}</pre>
    </li>
    <li>
     
      Next, navigate to the
     
     <strong class="source-inline">
      
       PersistentAuthenticationStateProvider
      
     </strong>
     
      class, and in the
     
     <a id="_idIndexMarker422">
     </a>
     
      constructor, extend the
     
     <strong class="source-inline">
      
       claims
      
     </strong>
     
      array to include the newly added
     
     
      <strong class="source-inline">
       
        Role
       
      </strong>
     
     
      
       value:
      
     
     <pre class="source-code">
Claim[] claims = [
    // ... existing properties ...
    new Claim(ClaimTypes.Email, userInfo.Email),
    new Claim(ClaimTypes.Role, userInfo.Role),
];</pre>
    </li>
    <li>
     
      Switch to the server-side application and open the
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      file of the
     
     
      <strong class="source-inline">
       
        BlazorCookbook.Auth
       
      </strong>
     
     
      
       project.
      
     
    </li>
    <li>
     
      Locate where the app is built, and just before that, use the authorization builder to add the same
     
     <strong class="source-inline">
      
       InternalEmployee
      
     </strong>
     
      policy as on the
     
     
      
       client side:
      
     
     <pre class="source-code">
builder.Services
    .AddAuthorizationBuilder()
    .AddPolicy("InternalEmployee",
        policy =&gt; policy.RequireAssertion(context =&gt;
            context.User?.Identity?.Name?
                .EndsWith("@packt.com") ?? false));
var app = builder.Build();</pre>
    </li>
    <li>
     
      Navigate to an
     
     <strong class="source-inline">
      
       OnPersistingAsync
      
     </strong>
     
      method of a
     
     <strong class="source-inline">
      
       PersistingRevalidatingAuthenticationStateProvider
      
     </strong>
     
      class and extend the logic executed for the authenticated user to append the role to the
     
     <strong class="source-inline">
      
       UserInfo
      
     </strong>
     
      class that Blazor will send over to the
     
     
      
       client side:
      
     
     <pre class="source-code">
var userId = principal.FindFirst(
    options.ClaimsIdentity.UserIdClaimType)?.Value;
var email = principal.FindFirst(
    options.ClaimsIdentity.EmailClaimType)?.Value;
var role = principal.FindFirst(
    options.ClaimsIdentity.RoleClaimType)?.Value;
state.PersistAsJson(nameof(UserInfo), new UserInfo
{
    UserId = userId,
    Email = email,
    Role = role
});</pre>
    </li>
    <li>
     
      Open the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component, and below the
     
     <strong class="source-inline">
      
       @page
      
     </strong>
     
      directive, add the
     
     <strong class="source-inline">
      
       Authorize
      
     </strong>
     
      attribute
     
     <a id="_idIndexMarker423">
     </a>
     
      overloaded with the
     
     
      <strong class="source-inline">
       
        InternalEmployee
       
      </strong>
     
     
      
       policy:
      
     
     <pre class="source-code">
@using Microsoft.AspNetCore.Authorization
@attribute [Authorize(Policy = "InternalEmployee")]</pre>
    </li>
    <li>
     
      In the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      markup, find the existing
     
     <strong class="source-inline">
      
       AuthorizeView
      
     </strong>
     
      opening tag and set the
     
     <strong class="source-inline">
      
       Roles
      
     </strong>
     
      parameter to allow
     
     <strong class="source-inline">
      
       Support
      
     </strong>
     
      and
     
     
      <strong class="source-inline">
       
        Admin
       
      </strong>
     
     
      
       roles:
      
     
     <pre class="source-code">
&lt;AuthorizeView Context="user" Roles="Support,Admin"&gt;
    @* here's still the existing EditForm *@
&lt;/AuthorizeView&gt;</pre>
    </li>
    <li>
     
      Below the
     
     <strong class="source-inline">
      
       EditForm
      
     </strong>
     
      protected area, construct another
     
     <strong class="source-inline">
      
       AuthorizeView
      
     </strong>
     
      section, protecting a
     
     <strong class="bold">
      
       Shut down the app
      
     </strong>
     
      button and rendering the content only for users in the
     
     
      <strong class="source-inline">
       
        Admin
       
      </strong>
     
     
      
       role:
      
     
     <pre class="source-code">
&lt;AuthorizeView Roles="Admin"&gt;
    &lt;p&gt;&lt;button&gt;Shut down the app&lt;/button&gt;&lt;/p&gt;
&lt;/AuthorizeView&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-303">
    <a id="_idTextAnchor303">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     We’re starting with the client-side application, so in
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we navigate to the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file in the
    
    <strong class="source-inline">
     
      BlazorCookbook.Auth.Client
     
    </strong>
    
     project.
    
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we extend the authorization registration by finding the
    
    <strong class="source-inline">
     
      AddAuthorizationCore()
     
    </strong>
    
     method call and overloading it with options to configure the
    
    <strong class="source-inline">
     
      InternalEmployee
     
    </strong>
    
     policy.
    
    
     We leverage the
    
    <strong class="source-inline">
     
      AuthorizationPolicyBuilder
     
    </strong>
    
     class, which we call
    
    <strong class="source-inline">
     
      policy
     
    </strong>
    
     , to check if a currently logged-in user’s email belongs to the
    
    <strong class="source-inline">
     
      @packt.com
     
    </strong>
    
     domain.
    
    
     The
    
    <strong class="source-inline">
     
      AuthorizationPolicyBuilder
     
    </strong>
    
     class supports custom assertions (which we used) as well as checking claims, usernames, or .NET native
    
    <strong class="source-inline">
     
      IAuthorizationRequirement
     
    </strong>
    
     objects.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we open the
    
    <strong class="source-inline">
     
      UserInfo
     
    </strong>
    
     class and extend it with a
    
    <strong class="source-inline">
     
      Role
     
    </strong>
    
     property.
    
    
     The
    
    <strong class="source-inline">
     
      UserInfo
     
    </strong>
    
     class is a model that Blazor uses to share user identity details across render mode boundaries.
    
    
     As we need the WebAssembly side to resolve
    
    <a id="_idIndexMarker424">
    </a>
    
     user roles correctly, we must pass them there explicitly.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we complete the client-side configuration by extending the constructor of the
    
    <strong class="source-inline">
     
      PersistentAuthenticationStateProvider
     
    </strong>
    
     class.
    
    
     Blazor uses
    
    <strong class="source-inline">
     
      PersistentAuthenticationStateProvider
     
    </strong>
    
     to determine the user’s authentication state that arrives from the server side.
    
    
     In the constructor, we deserialize the state into a
    
    <strong class="source-inline">
     
      UserInfo
     
    </strong>
    
     object and extend the
    
    <strong class="source-inline">
     
      claims
     
    </strong>
    
     array to include the value of the newly added
    
    <strong class="source-inline">
     
      Role
     
    </strong>
    
     property.
    
    
     Now, whenever our application runs locally in the browser, the user’s role will still be available to
    
    
     
      verify against.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we switch to the server-side application and open the
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     file of the
    
    <strong class="source-inline">
     
      BlazorCookbook.Auth
     
    </strong>
    
     project.
    
    
     In
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we locate where we invoke the
    
    <strong class="source-inline">
     
      builder.Build()
     
    </strong>
    
     method to build the app.
    
    
     Right before that, we add the same
    
    <strong class="source-inline">
     
      InternalEmployee
     
    </strong>
    
     policy as on the client side with the help of the authorization builder.
    
    
     As the policy assertion is indeed the same, the server API for configuring authorization is slightly different.
    
    
     We invoke the
    
    <strong class="source-inline">
     
      AddAuthorizationBuilder()
     
    </strong>
    
     method to access the
    
    <strong class="source-inline">
     
      AuthorizationBuilder
     
    </strong>
    
     instance as it exposes the
    
    <strong class="source-inline">
     
      AddPolicy()
     
    </strong>
    
     builder method.
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , we complete the server-side implementation by navigating to the
    
    <strong class="source-inline">
     
      OnPersistingAsync
     
    </strong>
    
     method of the
    
    <strong class="source-inline">
     
      PersistingRevalidatingAuthenticationStateProvider
     
    </strong>
    
     class.
    
    
     That’s the service Blazor uses when passing the user’s identity to the browser.
    
    
     We locate the logic for the authenticated user.
    
    
     It already contains the sharing of the user’s ID and email.
    
    
     We follow the same implementation pattern by grabbing the value of
    
    <strong class="source-inline">
     
      RoleClaimType
     
    </strong>
    
     from the current
    
    <strong class="source-inline">
     
      principal
     
    </strong>
    
     value and passing it on to the
    
    <strong class="source-inline">
     
      UserRole
     
    </strong>
    
     object that Blazor will persist as JSON inside the
    
    
     
      outgoing response.
     
    
   </p>
   <p>
    
     Now, we put all that authorization implementation to the test.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we open the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component
    
    <a id="_idIndexMarker425">
    </a>
    
     and add the
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     attribute.
    
    
     It requires a reference to the
    
    <strong class="source-inline">
     
      Microsoft.AspNetCore.Authorization
     
    </strong>
    
     assembly, so we grant that with the
    
    <strong class="source-inline">
     
      @using
     
    </strong>
    
     directive.
    
    
     Then, we leverage the overloading of the
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     attribute.
    
    
     We can set the
    
    <strong class="source-inline">
     
      Policy
     
    </strong>
    
     property so that the user must meet it to access the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     page.
    
    
     That’s where we finally use the
    
    <strong class="source-inline">
     
      InternalEmployee
     
    </strong>
    
     policy.
    
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we continue to the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     markup.
    
    
     We find the existing
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     opening tag, wrapping the form where users can fill in their first and last names.
    
    
     We set the
    
    <strong class="source-inline">
     
      Roles
     
    </strong>
    
     parameter to
    
    <strong class="source-inline">
     
      Support
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Admin
     
    </strong>
    
     values, ensuring that the form renders only when the current user is in any of the expected roles.
    
    
     The
    
    <strong class="source-inline">
     
      Roles
     
    </strong>
    
     parameter accepts a
    
    <strong class="source-inline">
     
      string
     
    </strong>
    
     object, so you can provide one or multiple comma-separated roles.
    
    
     You can also have as many protected markup areas as you need within the same component.
    
    
     In
    
    <em class="italic">
     
      step 10
     
    </em>
    
     , we construct another
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     area below the one already existing.
    
    
     Inside, we construct an idle
    
    <strong class="bold">
     
      Shut down the app
     
    </strong>
    
     button, but we ensure it renders only for users in the
    
    
     <strong class="source-inline">
      
       Admin
      
     </strong>
    
    
     
      role.
     
    
   </p>
   <p>
    
     We arrive at a fully functional, secure view that adjusts dynamically to whoever is
    
    
     
      viewing it.
     
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    <em class="italic">
     
      .12
     
    </em>
    
     shows the store settings to the user with the
    
    
     <strong class="source-inline">
      
       Admin
      
     </strong>
    
    
     
      role:
     
    
   </p>
   <div><div><img alt="Figure 8.12: Store settings that an admin@packt.com user sees" src="img/Figure_8.12_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.12: Store settings that an admin@packt.com user sees
    
   </p>
   <p>
    
     <em class="italic">
      
       Figure 8
      
     </em>
    
    <em class="italic">
     
      .13
     
    </em>
    
     shows the store settings to the user with the
    
    
     <strong class="source-inline">
      
       Support
      
     </strong>
    
    
     
      role:
     
    
   </p>
   <div><div><img alt="Figure 8.13: Store settings that a support@packt.com user sees" src="img/Figure_8.13_B22020.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 8.13: Store settings that a support@packt.com user sees
    
   </p>
   <p>
    
     As you can see, when I log in as
    
    <strong class="source-inline">
     
      admin@packt.com
     
    </strong>
    
     , which has the
    
    <strong class="source-inline">
     
      Admin
     
    </strong>
    
     role, I can see both the edit form and the most restricted
    
    <strong class="bold">
     
      Shut down the app
     
    </strong>
    
     button.
    
    
     But the moment I change to
    
    <strong class="source-inline">
     
      support@packt.com
     
    </strong>
    
     , the
    
    <strong class="bold">
     
      Shut down the app
     
    </strong>
    
     button is gone!
    
    
     I encourage you to
    
    <a id="_idIndexMarker426">
    </a>
    
     check how the UI changes when you log in
    
    
     
      as
     
    
    
     <strong class="source-inline">
      
       user@packt.com
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-304">
    <a id="_idTextAnchor304">
    </a>
    
     There’s more…
    
   </h2>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     attribute supports the same authorization APIs that
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     does.
    
    
     Both can use
    
    <strong class="source-inline">
     
      Roles
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Policy
     
    </strong>
    
     to verify the user’s identity against specific criteria.
    
    
     You can even use both
    
    <strong class="source-inline">
     
      Roles
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Policy
     
    </strong>
    
     at the
    
    
     
      same time!
     
    
   </p>
   <pre class="source-code">
@attribute [Authorize(Roles = "User,Support,Admin")]
&lt;h3&gt;Settings&lt;/h3&gt;
&lt;AuthorizeView Context="user" Policy="InternalEmployee"&gt;
    @* here's still the existing EditForm *@
&lt;/AuthorizeView&gt;
&lt;AuthorizeView Policy="InternalEmployee" Roles="Admin"&gt;
    &lt;p&gt;&lt;button&gt;Shutdown the app&lt;/button&gt;&lt;/p&gt;
&lt;/AuthorizeView&gt;</pre>
   <p>
    
     With the
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     attribute, we now verify whether the logged-in user has any of the three allowed roles:
    
    <strong class="source-inline">
     
      User
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Support
     
    </strong>
    
     , or
    
    <strong class="source-inline">
     
      Admin
     
    </strong>
    
     .
    
    
     Additionally, we’ve updated the rendering of the user details edit form.
    
    
     Now,
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     displays the form to anyone meeting the
    
    <strong class="source-inline">
     
      InternalEmployee
     
    </strong>
    
     policy and having any of the available roles.
    
    
     We’ve also updated the restrictions on the
    
    <strong class="bold">
     
      Shut down the app
     
    </strong>
    
     button – the user has to have the
    
    <strong class="source-inline">
     
      Admin
     
    </strong>
    
     role and belong to the
    
    <strong class="source-inline">
     
      @packt.com
     
    </strong>
    
     domain, enforced by the
    
    
     <strong class="source-inline">
      
       InternalEmployee
      
     </strong>
    
    
     
      policy.
     
    
   </p>
   <p>
    
     The parameters of
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     work similarly but are applied at different levels.
    
    
     The question remains when to use the attribute and when the component suits best.
    
    
     Use
    
    <strong class="source-inline">
     
      Authorize
     
    </strong>
    
     when protecting navigation to a given resource or page, ensuring that only authorized users can access it.
    
    
     On the other hand, use
    
    <strong class="source-inline">
     
      AuthorizeView
     
    </strong>
    
     when you need to restrict access to certain areas of the markup without affecting the overall routing.
    
    
     This approach provides a comprehensive way to secure your Blazor
    
    <a id="_idIndexMarker427">
    </a>
    
     application, ensuring that only authorized users can access specific features
    
    
     
      and content.
     
    
   </p>
   <h1 id="_idParaDest-305">
    <a id="_idTextAnchor305">
    </a>
    
     Resolving authentication state in procedural logic
    
   </h1>
   <p>
    
     Incorporating authentication and authorization into the procedural logic of your application is often necessary.
    
    
     Simply manipulating markup visibility may not suffice in these scenarios; you need to
    
    <a id="_idIndexMarker428">
    </a>
    
     resolve the current
    
    <a id="_idIndexMarker429">
    </a>
    
     authentication state to make informed decisions within your code.
    
    
     That’s where a cascading
    
    <strong class="source-inline">
     
      AuthenticationState
     
    </strong>
    
     class comes in.
    
    
     The
    
    <strong class="source-inline">
     
      AuthenticationState
     
    </strong>
    
     class is a built-in Blazor feature that provides information about the user’s authentication status
    
    
     
      and claims.
     
    
   </p>
   <p>
    
     Let’s add a button that redirects internal employees to different areas of a ticketing system based on
    
    
     
      their roles.
     
    
   </p>
   <h2 id="_idParaDest-306">
    <a id="_idTextAnchor306">
    </a>
    
     Getting ready
    
   </h2>
   <p>
    
     Before we leverage authentication state in procedural logic, do
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      In the server-side project, create a
     
     <strong class="source-inline">
      
       Components
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipes
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe07
      
     </strong>
     
      directory – this will be your
     
     
      
       working directory
      
     
    </li>
    <li>
     
      Copy the
     
     <strong class="source-inline">
      
       FakePages
      
     </strong>
     
      directory from the
     
     <strong class="source-inline">
      
       Components
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipes
      
     </strong>
     
      /
     
     <strong class="source-inline">
      
       Recipe07
      
     </strong>
     
      directory in the
     
     
      
       GitHub repository
      
     
    </li>
    <li>
     
      If you haven’t run migrations yet, find the
     
     <strong class="source-inline">
      
       seed-work.sql
      
     </strong>
     
      script in the
     
     <strong class="source-inline">
      
       Samples
      
     </strong>
     
      directory of the server-side project and run it on
     
     
      
       your database
      
     
    </li>
    <li>
     
      As we will need to enable interactivity, we can’t use any of the existing
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      components
     
     <a id="_idIndexMarker430">
     </a>
     
      anymore, so we will create a totally
     
     
      
       new one
      
     
    </li>
   </ul>
   <p>
    
     How to do it…
    
   </p>
   <p>
    
     Follow these instructions
    
    <a id="_idIndexMarker431">
    </a>
    
     to leverage authentication state in
    
    
     
      procedural logic:
     
    
   </p>
   <ol>
    <li>
     
      Create a new routable
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component with server-side interactivity and an injected
     
     
      <strong class="source-inline">
       
        Navigation
       
      </strong>
     
     
      
       service:
      
     
     <pre class="source-code">
@page "/ch08r07"
@rendermode InteractiveServer
@inject NavigationManager Navigation</pre>
    </li>
    <li>
     
      Add a
     
     <strong class="source-inline">
      
       @code
      
     </strong>
     
      block to intercept the cascading
     
     
      
       authentication state:
      
     
     <pre class="source-code">
@code {
    [CascadingParameter]
    private Task&lt;AuthenticationState&gt; AuthState
    {
        get; set;
    }
}</pre>
    </li>
    <li>
     
      Below the
     
     <strong class="source-inline">
      
       AuthState
      
     </strong>
     
      parameter, initialize a
     
     <strong class="source-inline">
      
       GoToTicketsAsync()
      
     </strong>
     
      method and resolve the
     
     
      <strong class="source-inline">
       
        user
       
      </strong>
     
     
      
       context:
      
     
     <pre class="source-code">
private async Task GoToTicketsAsync()
{
    var user = (await AuthState).User;
    //we will continue building logic here
}</pre>
    </li>
    <li>
     
      Below the
     
     <strong class="source-inline">
      
       user
      
     </strong>
     
      context, check
     
     <a id="_idIndexMarker432">
     </a>
     
      if the user’s
     
     <strong class="source-inline">
      
       Identity
      
     </strong>
     
      property has a value and redirect to
     
     <a id="_idIndexMarker433">
     </a>
     
      the login page if
     
     
      
       it’s missing:
      
     
     <pre class="source-code">
if (user.Identity is null)
{
    Navigation.NavigateTo("/Account/Login");
    return;
}</pre>
    </li>
    <li>
     
      Below the
     
     <strong class="source-inline">
      
       Identity
      
     </strong>
     
      verification, check if the user is correctly authenticated and redirect to the login page
     
     
      
       if not:
      
     
     <pre class="source-code">
if (!user.Identity.IsAuthenticated)
{
    Navigation.NavigateTo("/Account/Login");
    return;
}</pre>
    </li>
    <li>
     
      After authentication verification, check if the value of the user’s
     
     <strong class="source-inline">
      
       Name
      
     </strong>
     
      property belongs to the
     
     <strong class="source-inline">
      
       @packt.com
      
     </strong>
     
      domain and, if not, redirect them to the landing page of the
     
     
      
       ticketing system:
      
     
     <pre class="source-code">
if (!user.Identity.Name.EndsWith("@packt.com"))
{
    Navigation.NavigateTo("/tickets");
    return;
}</pre>
    </li>
    <li>
     
      After the user’s domain
     
     <a id="_idIndexMarker434">
     </a>
     
      check, check if the user is in the
     
     <strong class="source-inline">
      
       Support
      
     </strong>
     
      or
     
     <strong class="source-inline">
      
       Admin
      
     </strong>
     
      role and redirect
     
     <a id="_idIndexMarker435">
     </a>
     
      them to the admin panel of the
     
     
      
       ticketing system:
      
     
     <pre class="source-code">
if (user.IsInRole("Support") ||
    user.IsInRole("Admin"))
{
    Navigation.NavigateTo("/tickets/admin");
    return;
}</pre>
    </li>
    <li>
     
      Lastly, if the user’s identity doesn’t fit any of the handled cases, redirect them to the access
     
     
      
       denied page:
      
     
     <pre class="source-code">
Navigation.NavigateTo("/tickets/denied");</pre>
    </li>
    <li>
     
      Jump to the markup of the
     
     <strong class="source-inline">
      
       Settings
      
     </strong>
     
      component and add a button to navigate to the
     
     
      
       ticketing system:
      
     
     <pre class="source-code">
&lt;p&gt;
    &lt;button @onclick=@GoToTicketsAsync&gt;
        Support tickets
    &lt;/button&gt;
&lt;/p&gt;</pre>
    </li>
   </ol>
   <h2 id="_idParaDest-307">
    <a id="_idTextAnchor307">
    </a>
    
     How it works…
    
   </h2>
   <p>
    
     In
    
    <em class="italic">
     
      step 1
     
    </em>
    
     , we create a new routable
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component, rendering in an
    
    <strong class="source-inline">
     
      InteractiveServer
     
    </strong>
    
     mode as we want our users to navigate to the ticketing system with a
    
    
     
      button click.
     
    
   </p>
   <p>
    
     If you follow along the entire chapter
    
    <a id="_idIndexMarker436">
    </a>
    
     or have scaffolded your project, you will already have a cascading
    
    <a id="_idIndexMarker437">
    </a>
    
     authentication state registered.
    
    
     But to give you a comprehensive overview, in both server- and client-side projects, in their
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     files, you will find (or add, if it’s missing) the
    
    <strong class="source-inline">
     
      builder.Services.AddCascadingAuthenticationState()
     
    </strong>
    
     command that explicitly enables cascading authentication state in
    
    
     
      your application.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 2
     
    </em>
    
     , we initialize the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block in the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component.
    
    
     Firstly, we intercept the authentication state.
    
    
     Blazor shares
    
    <strong class="source-inline">
     
      AuthenticationState
     
    </strong>
    
     as a
    
    <strong class="source-inline">
     
      Task
     
    </strong>
    
     parameter – in line with modern web development, where all operations are inherently asynchronous and as the
    
    <strong class="source-inline">
     
      AuthenticationStateProvider
     
    </strong>
    
     implementation might contain asynchronous logic constructing the authentication state.
    
    
     We also inject a
    
    <strong class="source-inline">
     
      NavigationManager
     
    </strong>
    
     service to help us redirect the user to the intended destination.
    
    
     For the next couple of steps, still inside the
    
    <strong class="source-inline">
     
      @code
     
    </strong>
    
     block, we implement a
    
    <strong class="source-inline">
     
      GoToTicketsAsync()
     
    </strong>
    
     method to resolve the redirection destination based on the user’s identity context.
    
    
     In
    
    <em class="italic">
     
      step 3
     
    </em>
    
     , we resolve the
    
    <strong class="source-inline">
     
      user
     
    </strong>
    
     object by awaiting
    
    <strong class="source-inline">
     
      AuthState
     
    </strong>
    
     and grabbing the
    
    <strong class="source-inline">
     
      User
     
    </strong>
    
     property from the result.
    
    
     In
    
    <em class="italic">
     
      step 4
     
    </em>
    
     , we check if the current user has an
    
    <strong class="source-inline">
     
      Identity
     
    </strong>
    
     value set, which can be
    
    <strong class="source-inline">
     
      null
     
    </strong>
    
     if the user hasn’t logged in yet.
    
    
     If the
    
    <strong class="source-inline">
     
      Identity
     
    </strong>
    
     value is missing, we immediately redirect the user to the login page.
    
    
     In
    
    <em class="italic">
     
      step 5
     
    </em>
    
     , we perform an additional check on the
    
    <strong class="source-inline">
     
      Identity
     
    </strong>
    
     value using the
    
    <strong class="source-inline">
     
      IsAuthenticated
     
    </strong>
    
     property to verify if the user is logged in and correctly authenticated.
    
    
     If that check fails, we redirect the user to the login page to revalidate their authentication state.
    
    
     Now that we are sure the current user has a valid identity, in
    
    <em class="italic">
     
      step 6
     
    </em>
    
     , we check if the user is actually an internal employee.
    
    
     We leverage the
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     property of the
    
    <strong class="source-inline">
     
      user
     
    </strong>
    
     object, representing the user’s login in the application.
    
    
     As, in our case, the
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     property is equivalent to the user’s email, we verify if the user account of the current user we check belongs to the
    
    <strong class="source-inline">
     
      @packt.com
     
    </strong>
    
     domain.
    
    
     If that check fails, we redirect the user to the
    
    <strong class="source-inline">
     
      /tickets
     
    </strong>
    
     page, where they can create new support tickets as standard application users.
    
    
     In
    
    <em class="italic">
     
      step 7
     
    </em>
    
     , knowing that an internal employee is using the application, we check if they have an
    
    <strong class="source-inline">
     
      Admin
     
    </strong>
    
     or
    
    <strong class="source-inline">
     
      Support
     
    </strong>
    
     role.
    
    
     If they do, we redirect them to the
    
    <strong class="source-inline">
     
      /tickets/admin
     
    </strong>
    
     page, where they can access the admin panel of the ticketing system.
    
    
     In
    
    <em class="italic">
     
      step 8
     
    </em>
    
     , we close the implementation of the
    
    <strong class="source-inline">
     
      GoToTicketsAsync()
     
    </strong>
    
     method.
    
    
     When all the previous authentication and authorization checks fail, we assume the user’s account is incomplete and redirect them to the
    
    <strong class="source-inline">
     
      /tickets/denied
     
    </strong>
    
     page, indicating they can’t access the
    
    
     
      ticketing system.
     
    
   </p>
   <p>
    
     In
    
    <em class="italic">
     
      step 9
     
    </em>
    
     , we extend the
    
    <strong class="source-inline">
     
      Settings
     
    </strong>
    
     component
    
    <a id="_idIndexMarker438">
    </a>
    
     markup.
    
    
     Below the existing
    
    <strong class="source-inline">
     
      h3
     
    </strong>
    
     header, we add a paragraph
    
    <a id="_idIndexMarker439">
    </a>
    
     with a
    
    <strong class="source-inline">
     
      button
     
    </strong>
    
     property that invokes the
    
    <strong class="source-inline">
     
      GoToTicketsAsync()
     
    </strong>
    
     method upon click, allowing the user to navigate to the ticketing system.
    
    
     Effective redirection depends on the result of the procedural logic we added and the
    
    
     
      user’s identity.
     
    
   </p>
  </div>
 </body></html>