- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Performance Optimization and Tuning
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化和调整
- en: Performance separates applications that are used and loved from those that are
    uninstalled and forever forgotten.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 性能将使那些被使用和喜爱的应用程序与那些被卸载并被永远遗忘的应用程序区分开来。
- en: It is not enough to have an application that responds to users’ needs. To be
    used frequently (and likely daily), an application needs to bootstrap and perform
    tasks quickly.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 仅有一个能够响应用户需求的应用程序是不够的。为了被频繁使用（并且很可能是每天使用），一个应用程序需要快速启动并执行任务。
- en: This speed and responsiveness directly impact user satisfaction, as people have
    increasingly high expectations for digital experiences. Studies have shown that
    even small delays in load times or task completion can significantly reduce user
    engagement and overall satisfaction.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 这种速度和响应性直接影响到用户满意度，因为人们对数字体验的期望越来越高。研究表明，即使是加载时间或任务完成的小幅延迟也会显著降低用户参与度和整体满意度。
- en: 'In this chapter, we will discuss different areas where performance can be improved
    and what techniques we can use to achieve this. More specifically, we will cover
    the following:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将讨论可以提升性能的不同领域以及我们可以使用哪些技术来实现这一点。更具体地说，我们将涵盖以下内容：
- en: The different areas to be considered to improve application performance
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 需要考虑的不同领域以提升应用程序性能
- en: How to instrument an application to identify performance problems
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何对应用程序进行仪表化以识别性能问题
- en: How to improve your application performance
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何提升你的应用程序性能
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: The code for this chapter can be found in the GitHub repository accompanying
    this book, [https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter12](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter12).
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在本书附带的GitHub仓库中找到，[https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter12](https://github.com/PacktPublishing/Building-CLI-Applications-with-C-Sharp-and-.NET/tree/main/Chapter12)。
- en: Performance optimization areas
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 性能优化领域
- en: The performance of an application is not only a matter of code. It is a series
    of fine tuning, at different levels, that helps achieve performance efficiency.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序的性能并不仅仅是代码的问题。它是一系列在不同层面上进行的精细调整，有助于实现性能效率。
- en: 'Performance optimization therefore occurs in areas such as the following:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，性能优化发生在以下领域：
- en: '**Application design and architecture**: The longer the path you must walk,
    the longer it takes you to get to your destination. As I always tell my customers,
    you may run twice as fast as me, but if your path is twice as long as mine, we
    will arrive at our destination at the same time. The idea here is that using performant
    frameworks and libraries is of little use if your architecture is not efficient.
    Too often, I see architectures that are over-decoupled, with too many hops and
    context switching, leading to applications that are not performant and slow. The
    key is to build an architecture that balances performance with the optimal level
    of decoupling. From a design perspective, I often see designs that can be improved
    (leading to more efficient and performant applications) by finding a shorter path
    to achieve a goal. Of course, you won’t do that for every piece of code, but you
    will want to focus your attention on hot paths, namely paths that are often used
    by your users. There may be no point in optimizing the performance of a functionality
    that is used by one user once a year. You must find a balance between the cost
    of the optimization effort (it takes time, so it has a cost) and the benefit you
    are expecting from it.'
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**应用程序设计和架构**：你必须走的路越长，到达目的地所需的时间就越长。正如我总是告诉我的客户，你可能跑得比我快两倍，但如果你的路是我路的两倍长，我们将在同一时间到达目的地。这里的观点是，如果你架构不够高效，那么使用高性能的框架和库是没有什么用的。我经常看到过度解耦的架构，有太多的跳跃和上下文切换，导致应用程序性能不佳且速度慢。关键是构建一个在性能和最佳解耦水平之间取得平衡的架构。从设计角度来看，我经常看到可以通过找到更短的路径来实现目标（从而产生更高效和性能更好的应用程序）的设计。当然，你不会对每一行代码都这样做，但你将希望将注意力集中在热点路径上，即用户经常使用的路径。对于一年只被一个用户使用一次的功能，优化其性能可能没有意义。你必须找到优化努力的成本（它需要时间，因此有成本）和从它期望得到的收益之间的平衡。'
- en: '**Infrastructure**: If we host the application on an infrastructure, we must
    ensure that this infrastructure is efficient and has been optimized to maximize
    the throughput of the application while minimizing its latency. However, in the
    context of CLI applications, the application runs on the user’s computer, so we
    might be tempted to say that there is nothing to do here, but we would be wrong!
    There are tuning tasks we can perform that will positively impact performance.
    For example, we can reduce resource utilization so that running the application
    on the user’s computer will consume the least amount of resources and therefore
    will be executed efficiently, even if the computer is running other applications
    side by side or has little horsepower.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**基础设施**：如果我们托管应用程序在基础设施上，我们必须确保这个基础设施是高效的，并且已经优化以最大化应用程序的吞吐量同时最小化其延迟。然而，在CLI应用程序的上下文中，应用程序在用户的计算机上运行，所以我们可能会认为这里没有什么可做的，但我们会犯错误！我们可以执行一些调整任务，这将积极影响性能。例如，我们可以减少资源利用率，这样在用户的计算机上运行应用程序将消耗最少的资源，因此即使计算机同时运行其他应用程序或性能较弱，应用程序的执行也将是高效的。'
- en: '**Frameworks and libraries**: Of course, using efficient and performant frameworks
    and libraries helps to improve the application’s performance. For example, every
    new release of .NET promises better performance. Hence, upgrading the .NET version
    can be an easy way to improve the performance of our application. The same goes
    for the libraries that we use: some are known to have better performance than
    others.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**框架和库**：当然，使用高效且性能良好的框架和库有助于提高应用程序的性能。例如，.NET的每个新版本都承诺更好的性能。因此，升级.NET版本可以是我们提高应用程序性能的一种简单方法。同样适用于我们使用的库：一些库的性能比其他库更好。'
- en: '**Coding practices**: The last piece of the puzzle is the coding practices.
    We have already mentioned hot spots and hot paths, but coding practices also include
    using the most appropriate data structures.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编码实践**：拼图的最后一块是编码实践。我们已经提到了热点和热点路径，但编码实践还包括使用最合适的数据结构。'
- en: Before we start optimizing our application’s performance, we need to instrument
    it and identify its hot spots and hot paths.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们开始优化应用程序的性能之前，我们需要对其进行仪器化并识别其热点和热点路径。
- en: Instrumenting .NET applications
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 仪器化.NET应用程序
- en: Multiple tools exist to help us instrument.NET applications. The main difference
    between these tools is their scope of action.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 存在多个工具可以帮助我们为.NET应用程序进行仪器化。这些工具之间的主要区别在于它们的作用范围。
- en: Nevertheless, a key benefit of instrumentation is the ability to detect memory
    leaks and identify slow code paths.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，仪器化的一个关键好处是能够检测内存泄漏并识别缓慢的代码路径。
- en: Instrumentation can be achieved both during the development phase and continuously,
    while the application is running in production.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 仪器化可以在开发阶段实现，也可以在应用程序在生产环境中运行时持续进行。
- en: '| **Development-time profiling** | Visual Studio Diagnostic Tools, `BenchmarkDotNet`,
    `dotTrace`, `dotMemory`, and `PerfView` are great for profiling CPU, memory leaks
    and allocation, and application performance. |'
  id: totrans-23
  prefs: []
  type: TYPE_TB
  zh: '| **开发时性能分析** | Visual Studio诊断工具、`BenchmarkDotNet`、`dotTrace`、`dotMemory`和`PerfView`非常适合进行CPU、内存泄漏和分配以及应用程序性能的性能分析。
    |'
- en: '| **Production-time monitoring** | Azure Application Insights, AppDynamics,
    and New Relic help monitor and diagnose performance issues in real time in production
    environments. |'
  id: totrans-24
  prefs: []
  type: TYPE_TB
  zh: '| **生产时监控** | Azure Application Insights、AppDynamics和New Relic有助于在生产环境中实时监控和诊断性能问题。
    |'
- en: Table 12.1 – Some popular instrumentation tools
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.1 – 一些流行的仪器化工具
- en: 'You may have noticed the terms *“profiling”* and *“monitoring.”* There are
    some key differences between them:'
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到了术语*“性能分析”*和*“监控”*。它们之间存在一些关键区别：
- en: Profiling provides a detailed, granular view of an application’s performance,
    often focusing on specific code sections or methods. This includes CPU usage per
    functionality or method, memory allocation, execution time, and method call frequency
    and duration.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 性能分析提供了对应用程序性能的详细、细粒度视图，通常关注特定的代码部分或方法。这包括每个功能或方法的CPU使用情况、内存分配、执行时间和方法调用频率及持续时间。
- en: Monitoring is usually done in production and provides an overview of the application’s
    health, looking at broader performance trends and operational data over time rather
    than focusing on individual code paths. This includes CPU and memory usage across
    the entire application, error rates (exceptions, failures), response times and
    throughput (e.g., how long requests take, how many requests per second), and the
    application’s resource usage (disk I/O, network usage, etc.).
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 监控通常在生产环境中进行，提供了应用程序健康状况的概述，随着时间的推移查看更广泛的性能趋势和运营数据，而不是专注于单个代码路径。这包括整个应用程序的CPU和内存使用情况，错误率（异常、失败），响应时间和吞吐量（例如，请求需要多长时间，每秒多少个请求），以及应用程序的资源使用情况（磁盘I/O、网络使用等）。
- en: Because a CLI application runs on the user’s computer, it may be harder to monitor
    it. It requires permission from the user to collect the necessary data, usually
    at frequent intervals. We may then expect the user to refuse to share telemetry
    data, and therefore monitoring may not be possible.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于CLI应用程序在用户的计算机上运行，可能更难对其进行监控。它需要用户授权以收集必要的数据，通常在频繁的时间间隔内进行。我们可能预期用户会拒绝共享遥测数据，因此监控可能无法进行。
- en: While it is important to know the tools that help us instrument our applications,
    it is equally important to understand where to use them, in other words, how to
    identify these areas that may be good candidates for performance optimization.
    In that regard, it is important to be able to identify hot spots and hot paths.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然了解帮助我们进行应用程序度量的工具很重要，但同样重要的是要了解在哪里使用它们，换句话说，如何识别这些可能适合性能优化的区域。在这方面，能够识别热点和热路径非常重要。
- en: Hot spots versus hot paths
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 热点与热路径
- en: This is not the first time in this chapter that I have mentioned hot spots and
    hot paths. However, I haven’t taken the time to explain them. Let’s fix this right
    away!
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我并不是第一次提到热点和热路径。然而，我还没有花时间解释它们。让我们立即解决这个问题！
- en: A **hot spot** is an area of intense activity in the code, typically referring
    to frequently executed methods that consume a significant amount of execution
    time. Therefore, a hot spot represents a potential optimization target for improving
    the overall performance of the application.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**热点**是指代码中活动密集的区域，通常指的是频繁执行且消耗大量执行时间的方法。因此，热点代表了提高应用程序整体性能的潜在优化目标。'
- en: A **hot path** refers to an execution path through the code that is frequently
    taken and therefore contributes *significantly* to the application’s runtime.
    Hot paths can help locate inefficiently used resources, such as memory usage and
    allocation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '**热路径**指的是代码中频繁执行的执行路径，因此对应用程序的运行时间有**显著**的贡献。热路径可以帮助定位使用不充分的资源，例如内存使用和分配。'
- en: The question that may arise here is *“what process can we follow to identify
    the application’s hot spots and* *hot paths?”*
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 可能会出现的疑问是*“我们可以遵循什么流程来识别应用程序的热点和热路径？”*
- en: Identifying the application’s hot spots and hot paths
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 识别应用程序的热点和热路径
- en: 'Fortunately, identifying an application’s hot spots and hot paths does not
    have to be done by shots in the dark. Instead, we can follow a structured process
    that consists of three steps: profiling, analysis, and optimization. If monitoring
    is implemented, it will serve as an input for that process, since this process
    should be performed periodically to ensure optimal performance of the application.'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 幸运的是，识别应用程序的热点和热路径不必盲目进行。相反，我们可以遵循一个由三个步骤组成的结构化流程：分析、分析和优化。如果实现了监控，它将作为该过程的输入，因为此过程应定期执行，以确保应用程序的最佳性能。
- en: 'The process is described in the following table:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 以下表格描述了该过程：
- en: '| **Step** | **What** **to do** |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '| **步骤** | **要做什么** |'
- en: '| --- | --- |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '| --- | --- |'
- en: '|'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Profiling and data collection
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析和数据收集
- en: '|'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Use performance profilers to gather data about your application’s execution.
    A library such as `BenchmarkDotNet` can collect detailed information about CPU
    usage, memory consumption, and execution times.
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用性能分析器来收集应用程序执行的数据。例如，`BenchmarkDotNet`库可以收集关于CPU使用、内存消耗和执行时间的详细信息。
- en: Collect metrics on method execution times, resource usage, and frequency of
    calls to identify performance bottlenecks.
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 收集方法执行时间、资源使用和调用频率的指标，以识别性能瓶颈。
- en: '|'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Analysis and identification
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 分析和识别
- en: '|'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: 'Analyze the profiler output and find:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 分析分析器输出并找到：
- en: Methods with high execution times
  id: totrans-51
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行时间长的方法
- en: Frequently called methods
  id: totrans-52
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常调用的方法
- en: Areas of high CPU or memory usage
  id: totrans-53
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 高CPU或内存使用区域
- en: Long-running database queries or I/O operations
  id: totrans-54
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 长时间运行的数据库查询或I/O操作
- en: 'Look for patterns in the data that indicate potential hot spots or hot paths:'
  id: totrans-55
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 寻找数据中的模式，这些模式表明潜在的热点或热路径：
- en: Methods that consume a disproportionate amount of resources
  id: totrans-56
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消耗过多资源的函数
- en: Execution paths that are frequently taken and contribute significantly to the
    overall runtime
  id: totrans-57
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 经常执行且对总体运行时间贡献显著的执行路径
- en: '|'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: '|'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Optimization
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 优化
- en: '|'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Once hot spots and hot paths are identified, implement optimizations targeting
    these areas.
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦确定了热点和热路径，就针对这些区域实施优化。
- en: Use benchmarking tools such as `BenchmarkDotNet` to measure and compare the
    performance of the code before and after optimization to assess the gain in performance.
    You may also measure and compare different implementations to identify the most
    optimal one.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用基准测试工具，如`BenchmarkDotNet`，来测量和比较优化前后的代码性能，以评估性能提升。您还可以测量和比较不同的实现，以确定最优的实现。
- en: '|'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: '|'
- en: Table 12.2 – Identifying hot spots and hot paths
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 表12.2 – 识别热点和热路径
- en: We mentioned that `BenchmarkDotNet` can help us profile our application. Then,
    it is time to learn how to use it.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们提到`BenchmarkDotNet`可以帮助我们分析应用程序。那么，现在是时候学习如何使用它了。
- en: Profiling Bookmarkr with BenchmarkDotNet
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用BenchmarkDotNet分析Bookmarkr
- en: Although `BenchmarkDotNet` is considered to be a benchmarking library (that
    is, it is used to compare different implementation alternatives against a baseline
    to identify which one is the most performant), when used strategically, it can
    also identify hot spots and hot paths in our code.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`BenchmarkDotNet`被认为是一个基准测试库（即，它用于将不同的实现方案与基线进行比较，以确定哪个是最高效的），但如果我们有策略地使用它，它也可以识别我们代码中的热点和热路径。
- en: Let’s see how we can leverage this library to profile our CLI application.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何利用这个库来分析我们的CLI应用程序。
- en: 'The first thing we need to do is to reference the `BenchmarkDotNet` library.
    This can be achieved by executing the following command:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是引用`BenchmarkDotNet`库。这可以通过执行以下命令来实现：
- en: '[PRE0]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'The next step is to configure benchmark collection and reporting. For that
    matter, let’s add the following block of code at the very beginning of the `Main`
    method:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是配置基准测试收集和报告。为此，让我们在`Main`方法的非常开始处添加以下代码块：
- en: '[PRE1]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This allows us to run the benchmarks if we execute the application and pass
    `benchmark` as a parameter.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许我们在执行应用程序并传递`benchmark`作为参数时运行基准测试。
- en: What this block of code does is ask `BenchmarkDotNet` (via the `BenchmarkRunner`
    class) to run all the benchmarks that will be found in the `Benchmarks` class.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码所做的就是请求`BenchmarkDotNet`（通过`BenchmarkRunner`类）运行在`Benchmarks`类中找到的所有基准测试。
- en: Let’s create that `Benchmarks` class!
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们创建那个`Benchmarks`类！
- en: Following the folder structure convention that we defined in previous chapters,
    we will create a `Benchmarks` folder within which we will create a `Benchmarks.cs`
    file.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 按照我们在前几章中定义的文件夹结构约定，我们将在其中创建一个`Benchmarks`文件夹，并在其中创建一个`Benchmarks.cs`文件。
- en: We can either have a single class where all benchmarks are located, or we can
    create one benchmark class for every command or service to be benchmarked. We
    will take the first approach in this chapter as we will only benchmark the `export`
    command.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以选择将所有基准测试都放在一个单独的类中，或者为每个要基准测试的命令或服务创建一个基准测试类。在本章中，我们将采用第一种方法，因为我们只对`export`命令进行基准测试。
- en: 'Let’s add our first benchmark method. Its code looks like this:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加我们的第一个基准测试方法。其代码如下所示：
- en: '[PRE2]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: This method creates an instance of the `ExportCommand` class and executes it
    by calling its `InvokeAsync` method, passing in the required parameters for the
    command.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法创建`ExportCommand`类的实例，并通过调用其`InvokeAsync`方法来执行它，传递命令所需的参数。
- en: Right now, this method is not yet considered as a benchmark by the `BenchmarkRunner`
    class. The reason is that for a method to be considered as a benchmark, it needs
    to be decorated with the `[Benchmark]` attribute. Let’s fix this!
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个方法还没有被`BenchmarkRunner`类视为基准测试。原因是，要使一个方法被视为基准测试，它需要用`[Benchmark]`属性进行装饰。让我们来修复这个问题！
- en: '[PRE3]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Awesome! But we are not ready to run it yet…
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！但我们还没有准备好运行它…
- en: See what’s missing?
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 看看还缺少什么？
- en: You got it! The `ExportCommand` class takes an instance of type `IBookmarkService`
    as a parameter, but we haven’t so far provided such an instance of an object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 你明白了！`ExportCommand`类接受一个类型为`IBookmarkService`的实例作为参数，但我们迄今为止还没有提供这样一个对象的实例。
- en: Since we already have such an instance defined in the `Program` class, you may
    expect that we can pass it to the `Benchmarks` class through its constructor,
    and this would be a perfectly reasonable assumption. However, the `BenchmarkRunner`
    class does not allow us to do so (at least with the current version of `BenchmarkDotNet`).
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经在 `Program` 类中定义了这样一个实例，您可能期望我们可以通过其构造函数将其传递给 `Benchmarks` 类，这将会是一个完全合理的假设。然而，`BenchmarkRunner`
    类不允许我们这样做（至少在当前版本的 `BenchmarkDotNet` 中不允许）。
- en: 'What we will do instead is to instantiate this object in the `Benchmarks` class
    directly. The code will then look like this:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将采取的做法是直接在 `Benchmarks` 类中实例化此对象。然后代码将看起来像这样：
- en: '[PRE4]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Notice that the instantiation of the service is not performed in the class constructor
    but rather in a method decorated with the `[GlobalSetup]` attribute. This special
    attribute instructs `BenchmarkDotNet` to call this method once before executing
    each benchmark method. This is to have a clean instance of the service for each
    benchmark method, hence preventing side effects from previous benchmarks.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，服务的实例化不是在类构造函数中进行的，而是在一个带有 `[GlobalSetup]` 属性的函数中进行的。这个特殊属性指示 `BenchmarkDotNet`
    在执行每个基准方法之前调用此方法一次。这是为了确保每个基准方法都有一个干净的服务实例，从而防止之前基准测试的副作用。
- en: GlobalSetup versus class constructor
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 全局设置与类构造函数
- en: The execution time of the `[GlobalSetup]` method is not taken into account in
    calculating the benchmarked method execution time, as opposed to the execution
    time of the constructor. While this might seem negligible, it will not be if the
    method is meant to be executed a significant number of times.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算基准测试方法执行时间时，不考虑 `[GlobalSetup]` 方法的执行时间，这与构造函数的执行时间不同。虽然这看起来可能微不足道，但如果该方法需要执行很多次，那么它就不会微不足道了。
- en: We are now ready to execute our benchmark.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在可以执行基准测试了。
- en: To do this, we first need to build the application, but this time we need to
    build it in `Release` mode. Otherwise, `BenchmarkDotNet` will generate an error.
    The reason is that running a program in `Debug` mode is not optimal and has a
    significant performance cost compared to running the program in `Release` mode,
    which is the mode the application should be run on in production. Therefore, when
    benchmarking our application, we should do it in its optimal performance mode.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，我们首先需要构建应用程序，但这次我们需要在 `Release` 模式下构建它。否则，`BenchmarkDotNet` 将生成错误。原因是与在
    `Release` 模式下运行程序相比，在 `Debug` 模式下运行程序不是最优的，并且与在 `Release` 模式下运行程序相比，性能成本显著。因此，在生产环境中运行应用程序时，应该以最佳性能模式运行应用程序。因此，在基准测试我们的应用程序时，我们应该在它的最佳性能模式下进行。
- en: Debug vs Release modes
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: Debug 与 Release 模式
- en: Building the code in `Debug` mode produces unoptimized code with full symbolic
    `debug` information, enabling easier debugging and breakpoint setting. In contrast,
    `Release` mode generates optimized code for better performance and smaller file
    sizes. `Release` builds typically omit `debug` symbols, inline methods, and apply
    various optimizations that can make debugging more challenging but result in faster
    execution. While `Debug` builds are ideal for development and troubleshooting,
    `Release` builds are used when deploying to production.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Debug` 模式下构建代码会产生未优化的代码，带有完整的符号 `debug` 信息，这使得调试和设置断点更加容易。相比之下，`Release`
    模式生成优化后的代码，以获得更好的性能和更小的文件大小。`Release` 构建通常省略 `debug` 符号、内联方法和应用各种优化，这些优化可能会使调试更具挑战性，但会导致更快的执行速度。虽然
    `Debug` 构建非常适合开发和故障排除，但在部署到生产环境时通常使用 `Release` 构建。
- en: 'Building the application in `Release` mode can be achieved by typing the following:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 `Release` 模式下构建应用程序，可以输入以下命令：
- en: '[PRE5]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'We then run the benchmarks by typing the following:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后通过输入以下命令来运行基准测试：
- en: '[PRE6]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`C:\code\Chap12\bookmarkr\bin\Release\net8.0` is the location of the generated
    DLL of the Bookmarkr application.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '`C:\code\Chap12\bookmarkr\bin\Release\net8.0` 是 Bookmarkr 应用程序生成的 DLL 文件的位置。'
- en: 'The result is as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Figure 12.1 – Benchmarking the export command](img/B22400_12_01.jpg)'
  id: totrans-103
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.1 – 导出命令的基准测试](img/B22400_12_01.jpg)'
- en: Figure 12.1 – Benchmarking the export command
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.1 – 导出命令的基准测试
- en: The benchmark method has run 98 times and, on average, it takes 6.356 milliseconds
    to run the `export` command, which is not bad at all, is it?
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试方法已运行 98 次，平均每次运行 `export` 命令需要 6.356 毫秒，这并不算坏，对吧？
- en: 'You can see the table in the middle of the screen. This table compiles the
    metrics per benchmark method. Let’s explain what each of its columns represents:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在屏幕中间看到表格。该表格按基准方法编译指标。让我们解释一下每一列代表什么：
- en: '`Mean`: This represents the average duration of the benchmarked method over
    all its executions (98 in our example).'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Mean`：这代表基准测试方法在其所有执行中的平均持续时间（在我们的例子中是98）。'
- en: '`Error`: Simply stated, this value represents the precision of the mean value’s
    measurement. The smaller the error, the more precise the measurement of the mean
    value. As an example, since our mean value is 6.356 ms and the error is 0.7840
    ms, all measurements fall within the range of 6.356 ms ± 0.7840 ms, which means
    between 5.572 ms and 7.140 ms.'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Error`：简单来说，这个值代表测量平均值精度的值。误差越小，平均值的测量越精确。例如，由于我们的平均值是6.356毫秒，误差是0.7840毫秒，所有测量值都在6.356毫秒
    ± 0.7840毫秒的范围内，这意味着在5.572毫秒和7.140毫秒之间。'
- en: '`StdDev`: This value represents the standard deviation of all measurements.
    It quantifies the amount of variation or dispersion in the execution times. In
    other words, a lower value of `StdDev` indicates that the execution times are
    clustered closely around the mean.'
  id: totrans-109
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`StdDev`：这个值代表所有测量的标准差。它量化了执行时间的变化或分散程度。换句话说，`StdDev`的值越低，表示执行时间越接近平均值。'
- en: Benchmarking is not only for commands!
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 基准测试不仅适用于命令！
- en: Although we are benchmarking a command here, it is important to note that benchmarking
    does not only apply to commands but rather to all code artifacts that may have
    an impact on the application’s performance, which also includes services. Therefore,
    by benchmarking commands *and* the services they use, we can determine the percentage
    of the execution time and memory consumption that is attributable to the service
    and the command.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然我们在这里对命令进行基准测试，但重要的是要注意，基准测试不仅适用于命令，而且适用于所有可能影响应用程序性能的代码工件，这包括服务。因此，通过基准测试命令*以及*它们使用的服务，我们可以确定执行时间和内存消耗中有多少可以归因于服务本身和命令。
- en: Great! There is, however, one measurement that we haven’t seen here, which is
    the measurement of memory consumption. Let’s fix that!
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 太好了！然而，这里还有一个我们没有看到的测量值，那就是内存消耗的测量。让我们来解决这个问题！
- en: 'To collect data about memory consumption, we simply need to add the `[MemoryDiagnoser]`
    tag on top of the `Benchmarks` class, as follows:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 要收集关于内存消耗的数据，我们只需在`Benchmarks`类顶部添加`[MemoryDiagnoser]`标签，如下所示：
- en: '[PRE7]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, if we run the code in exactly the same way as before, we get the following
    results:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果我们以完全相同的方式运行代码，我们会得到以下结果：
- en: '![Figure 12.2 – Benchmarking memory consumption](img/B22400_12_02.jpg)'
  id: totrans-116
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 基准测试内存消耗](img/B22400_12_02.jpg)'
- en: Figure 12.2 – Benchmarking memory consumption
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 基准测试内存消耗
- en: 'Notice that now we have a new column called `Allocated`, which represents the
    amount of allocated memory for every execution of the benchmarked method, in kilobytes.
    This column is interesting for two reasons:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，现在我们有一个新的列叫做`Allocated`，它代表基准测试方法每次执行分配的内存量，以千字节为单位。这个列有两个有趣的原因：
- en: It allows us to see if the benchmarked method is using way too much memory than
    it should (or way more than it is expected to use). This can indicate memory leaks
    in our code that require deeper investigation.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这允许我们看到基准测试的方法是否使用了比预期多得多的内存。这可以表明我们的代码中存在需要进一步调查的内存泄漏。
- en: When we optimize our code, we can see if the new implementation has an impact
    on memory consumption. For example, we could come up with an implementation that
    speeds up the execution time at the expense of significant memory consumption.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们优化代码时，我们可以看到新的实现是否对内存消耗有影响。例如，我们可以提出一种实现，以牺牲显著的内存消耗为代价来加快执行时间。
- en: Execution time versus memory consumption optimization
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 执行时间与内存消耗优化
- en: You may be wondering whether we should concentrate on optimizing memory consumption
    or execution time. The decision about where to focus our attention and energy
    depends on what we value the most, memory consumption or execution time. It is
    interesting to note that, in some situations, we may even be able to optimize
    both at the same time! To do that, we have to come up with a creative implementation
    that addresses both concerns by leveraging advanced features of the frameworks
    and libraries that we use, combined with advanced and creative algorithms.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道我们是否应该专注于优化内存消耗或执行时间。关于在哪里集中我们的注意力和精力，取决于我们最重视的是什么，内存消耗还是执行时间。值得注意的是，在某些情况下，我们甚至可能同时优化两者！为了做到这一点，我们必须提出一个创造性的实现，通过利用我们使用的框架和库的高级功能，结合高级和创造性的算法来解决这两个问题。
- en: While `BenchmarkDotNet` helps us identify optimization opportunities during
    the development phase, it is important to implement monitoring so that we can
    continuously check the application’s performance while it is being used in production.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `BenchmarkDotNet` 帮助我们在开发阶段识别优化机会，但实施监控同样重要，这样我们才能在生产使用过程中持续检查应用程序的性能。
- en: Monitoring BookmarkrSyncr with Azure Application Insights
  id: totrans-124
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用 Azure Application Insights 监控 BookmarkrSyncr
- en: We mentioned earlier that a CLI application runs locally on the user’s computer
    and that the user may refuse to allow us to collect telemetry data that is absolutely
    essential for monitoring. That is why we won’t implement monitoring in Bookmarkr
    but rather in **BookmarkrSyncr**, the external web service invoked by Bookmarkr.
    Since this is a web service hosted and managed by us, we can implement monitoring
    and ensure that telemetry data will be collected, therefore ensuring that monitoring
    can take place.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前提到，命令行界面（CLI）应用程序在用户的计算机上本地运行，用户可能会拒绝我们收集对监控至关重要的遥测数据。这就是为什么我们不会在 Bookmarkr
    中实现监控，而是在由 Bookmarkr 调用的外部网络服务 **BookmarkrSyncr** 中实现监控。由于这是一个由我们托管和管理的网络服务，我们可以实现监控并确保收集遥测数据，从而确保监控可以实施。
- en: Since this web service is deployed to the **Microsoft Azure** cloud platform,
    we will rely on Azure Application Insights, the **application performance monitoring**
    (**APM**) solution provided natively by the Microsoft Azure cloud platform.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个网络服务部署到了 **Microsoft Azure** 云平台，我们将依赖 Azure Application Insights，这是 Microsoft
    Azure 云平台提供的原生 **应用程序性能监控**（**APM**）解决方案。
- en: When we deployed BookmarkrSyncr to Microsoft Azure, we created an infrastructure
    for hosting it. More specifically, we created an **Azure App Service** instance.
    As part of the process of creating this service, we are offered the opportunity
    to create an instance of the **Azure Application Insights** service. This service
    is a monitoring solution that is provided and managed for us by Microsoft.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们将 BookmarkrSyncr 部署到 Microsoft Azure 时，我们创建了一个托管它的基础设施。更具体地说，我们创建了一个 **Azure
    App Service** 实例。在创建此服务的过程中，我们有机会创建 **Azure Application Insights** 服务的实例。这项服务是由
    Microsoft 提供和管理的监控解决方案。
- en: Azure Application Insights is a fantastic service that allows us to monitor
    performance, availability, failed requests, exceptions, page views, traces, browser
    timings, usage (including **user flows**, which allow us to identify hot paths
    in the application), and even access live metrics so we can monitor in real time.
    Another great feature of **Azure Application Insights** is the ability to configure
    alerts to be triggered if a certain metric reaches a certain threshold, for example,
    if the server response time (which measures the duration between receiving the
    HTTP request and sending the response to the client) is above the maximum allowed
    value as defined by our organization’s standards. When an alert is raised, we
    can then trigger an automated processing or a notification (such as an email to
    a specific group of people).
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: Azure Application Insights 是一项出色的服务，它允许我们监控性能、可用性、失败的请求、异常、页面浏览量、跟踪、浏览器时间、使用情况（包括
    **用户流程**，这使我们能够识别应用程序中的热点路径），甚至可以实时访问实时指标。**Azure Application Insights** 的另一个出色功能是能够配置警报，当某个指标达到某个阈值时触发，例如，如果服务器响应时间（衡量从接收
    HTTP 请求到向客户端发送响应之间的持续时间）超过了我们组织标准定义的最大允许值。当警报被触发时，我们可以触发自动处理或通知（例如，向特定人群发送电子邮件）。
- en: To seewhat monitoring with **Azure Application Insights** may look like, check
    out (this article on Microsoft Learn, which can be found at [https://learn.microsoft.com/en-us/azure/azure-monitor/app/overview-dashboard](https://learn.microsoft.com/en-us/azure/azure-monitor/app/overview-dashboard).
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解使用 **Azure Application Insights** 的监控可能是什么样子，请查看（Microsoft Learn 上的这篇文章，可在
    [https://learn.microsoft.com/en-us/azure/azure-monitor/app/overview-dashboard](https://learn.microsoft.com/en-us/azure/azure-monitor/app/overview-dashboard)
    找到）。
- en: Okay. Now that we know how to identify the areas of our application that require
    performance tuning (using profiling and monitoring), let’s discuss the most common
    techniques that we can use to enhance the performance of our application.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 好的。现在我们知道了如何识别应用程序中需要性能调优的区域（使用分析器和监控），让我们讨论一下我们可以用来提高应用程序性能的最常见技术。
- en: Common performance optimization techniques
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 常见的性能优化技术
- en: It is worth mentioning that the techniques we will be discussing here do not
    only apply to CLI applications but can rather be applied to any kind of application.
    Let’s break these techniques down according to the categories we presented earlier.
    For every category, I will give you a list of techniques commonly used for it.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，我们在这里讨论的技术不仅适用于CLI应用程序，而且可以应用于任何类型的应用程序。让我们根据我们之前提出的类别来分解这些技术。对于每个类别，我将为您提供一个常见技术的列表。
- en: '**Application design** **and architecture**:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: '**应用程序设计和架构**：'
- en: Establish the shortest path to achieve a goal, removing all unnecessary intermediaries.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 建立实现目标的最短路径，移除所有不必要的中间环节。
- en: This can be achieved by using efficient algorithms.
  id: totrans-135
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这可以通过使用高效的算法来实现。
- en: Find the optimal balance between decoupling and low latency.
  id: totrans-136
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在解耦和低延迟之间找到最佳平衡。
- en: Use lazy loading for resources that aren't immediately needed.
  id: totrans-137
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 对于不需要立即使用的资源，使用懒加载。
- en: Implement efficient error handling and logging mechanisms.
  id: totrans-138
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现高效的错误处理和日志记录机制。
- en: Design for scalability from the start.
  id: totrans-139
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从一开始就设计可扩展性。
- en: '**Infrastructure**:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '**基础设施**：'
- en: When packaging and distributing your application, compile it in `Release` mode.
    While `Debug` mode is great during the development phase, it may add a significant
    performance overhead.
  id: totrans-141
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在打包和分发您的应用程序时，请以`Release`模式编译。虽然`Debug`模式在开发阶段很棒，但它可能会增加显著的性能开销。
- en: Also, when packaging and distributing your application, compile it as platform-specific
    if the target platform is known ahead of time or if the packaging and distribution
    mechanism is not cross-platform. For example, distributing our application as
    a **Winget** package means that it will exclusively be used on the Windows platform.
    The same goes with an apt-get package (where the application will run exclusively
    on **Linux**) and with **Homebrew** (where the application will run exclusively
    on **macOS**). It is therefore easy to know what platform-specific compilation
    should be used and will make .NET apply all the possible optimizations, which
    is something it wouldn’t do if the target platform is not known ahead of time
    (an example of that is file handling, which is different on Windows, Linux, and
    macOS). This will result in a version of the application that runs in the most
    efficient manner on that target platform.
  id: totrans-142
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，当打包和分发您的应用程序时，如果目标平台在事先已知或打包和分发机制不是跨平台的情况下，请将其编译为特定平台。例如，将我们的应用程序作为**Winget**包分发意味着它将仅用于Windows平台。同样，apt-get包（其中应用程序将仅运行在**Linux**上）和**Homebrew**（其中应用程序将仅运行在**macOS**上）也是如此。因此，很容易知道应该使用哪种平台特定编译，这将使.NET应用所有可能的优化，这是它如果目标平台事先未知（例如文件处理，它在Windows、Linux和macOS上有所不同）不会做的事情。这将导致一个在目标平台上以最有效方式运行的应用程序版本。
- en: You might also choose to use **AOT** (**Ahead-Of-Time**) compilation to precompile
    your code to native code (instead of relying on **JIT**) for faster startup times
    or to reduce the dependency on runtime compilation. This could be particularly
    useful if you're targeting environments like mobile (iOS/Android) or WebAssembly,
    where JIT might not be feasible. Note that platform targeting and AOT can be combined
    for even better performance optimization.
  id: totrans-143
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 您还可以选择使用**AOT**（**提前编译**）来预编译您的代码为本地代码（而不是依赖于**JIT**），以实现更快的启动时间或减少对运行时编译的依赖。如果您针对的是移动（iOS/Android）或WebAssembly等环境，其中JIT可能不可行，这可能特别有用。请注意，平台目标化和AOT可以结合使用，以实现更好的性能优化。
- en: '**Frameworks** **and libraries:**'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '**框架** **和库**：'
- en: Avoid using libraries that rely on reflection, unless absolutely necessary.
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 除非绝对必要，否则避免使用依赖反射的库。
- en: Choose lightweight frameworks and libraries that align with your specific needs.
    Beware of libraries that pull off tenth of other libraries when you reference
    them.
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择与您特定需求相匹配的轻量级框架和库。当您引用它们时，要警惕那些拉入大量其他库的库。
- en: Keep dependencies up to date to benefit from performance improvements.
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持依赖项更新，以从性能改进中受益。
- en: Consider using micro-frameworks for smaller, focused tasks.
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 考虑使用适用于较小、专注任务的微框架。
- en: '**Coding practices:**'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '**编码实践**：'
- en: Rely on asynchronous operations whenever possible. This will avoid blocking
    the main thread and increases the feeling of responsiveness of the application.
  id: totrans-150
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，依赖异步操作。这将避免阻塞主线程，并增加应用程序的响应感。
- en: Choose the most optimized data types or data structures for the pursued purpose.
    This will ensure we have the minimal footprint on the computer’s resources.
  id: totrans-151
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 选择最适合追求目的的数据类型或数据结构。这将确保我们在计算机资源上占用最小的空间。
- en: Whenever possible, try to achieve a task with as little memory allocation as
    possible. For example, at the time of this writing, .NET 9 was released and introduces
    split operations with no memory allocation by calling `AsSpan().Split(…)`.
  id: totrans-152
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，尽量以尽可能少的内存分配来完成一项任务。例如，在撰写本文时，.NET 9 已发布，并引入了通过调用 `AsSpan().Split(…)`
    而不进行内存分配的分割操作。
- en: Implement a caching mechanism to avoid unnecessary calls to external dependencies
    (such as web services or databases).
  id: totrans-153
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现缓存机制以避免对外部依赖（如 Web 服务或数据库）进行不必要的调用。
- en: Optimize database queries and implement proper indexing.
  id: totrans-154
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 优化数据库查询并实现适当的索引。
- en: Speaking about databases, if you are using an `AsNoTracking()` to significantly
    improve query performance and reduce memory usage, especially when dealing with
    large datasets or read-only operations. This method tells the ORM not to track
    changes to the retrieved entities, bypassing the change tracking mechanism and
    resulting in faster queries with lower memory overhead.
  id: totrans-155
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 说到数据库，如果你使用 `AsNoTracking()` 显著提高查询性能并减少内存使用，尤其是在处理大数据集或只读操作时。此方法告诉 ORM 不要跟踪检索到的实体的更改，绕过更改跟踪机制，从而实现更快查询和更低的内存开销。
- en: Use connection pooling, which consists in reusing established database connections
    instead of creating a new one for every request. This is because it can be expensive
    to establish a connection to a database, therefore connection pooling reduces
    connection latency and enables high database throughput (transactions per second)
    on the server.
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用连接池，它涉及重用已建立的数据库连接，而不是为每个请求创建一个新的连接。这是因为建立数据库连接可能很昂贵，因此连接池减少了连接延迟，并允许服务器实现高数据库吞吐量（每秒事务数）。
- en: Implement proper memory management and dispose of unused resources.
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现适当的内存管理并释放未使用的资源。
- en: We have seen a bunch of techniques that are commonly used for optimizing the
    performance of any kind of application that is built with any technology stacks,
    including CLI applications built with .NET.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了许多常用的技术，这些技术可以用于优化任何使用任何技术栈构建的应用程序的性能，包括使用 .NET 构建的 CLI 应用程序。
- en: Let’s now apply some of these techniques to enhance Bookmarkr’s performance.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们应用一些这些技术来增强 Bookmarkr 的性能。
- en: Optimizing Bookmarkr’s performance
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 优化 Bookmarkr 的性能
- en: We cannot optimize what is already perfect, can we?
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能优化已经完美的事物，对吧？
- en: Just kidding. Of course we can! There is always room for improvement.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 开个玩笑。当然我们可以！总有改进的空间。
- en: Let’s see some of the quick wins that we can apply to enhance the performance
    of our beloved CLI application.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们可以应用的一些快速胜利，以增强我们心爱的 CLI 应用程序的性能。
- en: Looking at the handler method of the `ExportCommand` class (namely, `OnExportCommand`),
    we can see that it already leverages async operations. This is a great start and
    is actually one of the techniques we described earlier.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 查看处理 `ExportCommand` 类的方法（即 `OnExportCommand`），我们可以看到它已经利用了异步操作。这是一个很好的开始，实际上也是我们之前描述的技术之一。
- en: However, the handler method can be optimized. To illustrate this, let’s create
    a copy of the `ExportCommand` class and name it `ExportCommandOptimized`. Let’s
    copy the code from the `ExportCommand` as is, and we will optimize it in a moment.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，处理方法可以进行优化。为了说明这一点，让我们创建 `ExportCommand` 类的副本并将其命名为 `ExportCommandOptimized`。让我们直接复制
    `ExportCommand` 中的代码，我们将在稍后对其进行优化。
- en: The reason we are creating a copy of the original class rather than directly
    optimizing it is so that we can add a benchmark method for the optimized version
    and compare it with the original one.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建原始类的副本而不是直接优化它的原因是为了能够为优化版本添加基准方法，并与原始版本进行比较。
- en: 'In the handler method of the `ExportCommandOptimized` class, let’s change these
    two lines of code:'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `ExportCommandOptimized` 类的处理方法中，让我们更改这两行代码：
- en: '[PRE8]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Replace them with the following two lines:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 将它们替换为以下两行：
- en: '[PRE9]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let’s see what we have done:'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们做了什么：
- en: Using `JsonSerializer.SerializeAsync` is more efficient for large datasets as
    it streams the JSON directly to the file without keeping the entire serialized
    string in memory
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `JsonSerializer.SerializeAsync` 对于大数据集来说更高效，因为它直接将 JSON 流式传输到文件中，而不需要在内存中保留整个序列化字符串。
- en: Using `FileStream` with async operations allows better control over file I/O
    operations and can improve performance, especially for large files
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`FileStream`和异步操作可以更好地控制文件I/O操作，并可以提高性能，特别是对于大文件。
- en: Okay. Let’s compare this new implementation with the original one.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 好吧。让我们比较这个新实现和原始实现。
- en: 'To do this, let’s add the following benchmark method to the `Benchmarks` class:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 要做到这一点，让我们向`Benchmarks`类添加以下基准方法：
- en: '[PRE10]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This `benchmark` method is identical to the previous one. Well, almost identical…
    The only difference is that we are instantiating (and invoking) the `ExportCommandOptimized`
    class rather than the `ExportCommand` class.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`benchmark`方法与上一个方法完全相同。嗯，几乎相同……唯一的区别是我们实例化（并调用）的是`ExportCommandOptimized`类，而不是`ExportCommand`类。
- en: Since we want to compare the new, optimized, implementation against the original
    one, we will modify the `[``Benchmark]` attribute of the original method to look
    like this.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们想要将新的、优化的实现与原始实现进行比较，我们将修改原始方法的`[Benchmark]`属性，使其看起来像这样。
- en: 'This instructs `BenchmarkDotNet` to use this method as a baseline for the comparison:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 这指示`BenchmarkDotNet`使用此方法作为比较的基线：
- en: '[PRE11]'
  id: totrans-180
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Let’s rebuild the application (in `Release` mode, of course) and execute the
    benchmarks.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们重新构建应用程序（当然是在`Release`模式下）并执行基准测试。
- en: 'The results are the following:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 结果如下：
- en: '![Figure 12.3 – Benchmarking the new implementation against the original one](img/B22400_12_03.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.3 – 将新实现与原始实现进行基准测试](img/B22400_12_03.jpg)'
- en: Figure 12.3 – Benchmarking the new implementation against the original one
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – 将新实现与原始实现进行基准测试
- en: 'Notice the appearance of two new columns:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 注意出现了两个新的列：
- en: '`Ratio`: This indicates the average measure of the performance relative to
    the baseline benchmark method'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ratio`: 这表示相对于基线基准方法的性能的平均度量'
- en: '`RatioSD`: This indicates the average standard deviation relative to the standard
    deviation of the baseline benchmark method'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RatioSD`: 这表示相对于基线基准方法的标准偏差的平均标准偏差'
- en: The value of `0.91` in the `Ratio` column indicates that the optimized implementation
    (`ExportCommandOptimized`) is on average 9% faster than the baseline implementation
    (`ExportCommand`). We mentioned earlier that the implementation we made in `ExportCommandOptimized`
    is especially more performant when dealing with large files. Therefore, we can
    expect it to be even faster than the baseline implementation as the output file
    becomes larger.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: '`Ratio`列中的`0.91`值表示优化后的实现（`ExportCommandOptimized`）平均比基线实现（`ExportCommand`）快9%。我们之前提到，我们在`ExportCommandOptimized`中做出的实现特别适用于处理大文件。因此，我们可以预期，随着输出文件变大，它甚至会比基线实现更快。'
- en: Awesome! We now know how to improve the performance of our beloved CLI application
    and we have made our users happy.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在知道如何提高我们心爱的CLI应用程序的性能，并且让我们的用户感到满意。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the various areas of performance optimization,
    we learned techniques to identify performance hot spots and hot paths, and we
    saw how to improve their performance, with the ultimate goal of offering our users
    a great and efficient application that they will love to use.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了性能优化的各个领域，我们学习了识别性能热点和热点路径的技术，并看到了如何提高它们的性能，最终目标是向我们的用户提供一个他们喜欢使用的出色且高效的应用程序。
- en: Hopefully, you have understood that there is not one single area or action that
    leads to better performance, but rather a series of fine-tuning here and there
    that do the trick.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 希望你已经理解了，没有单一的区域或行动会导致更好的性能，而是一系列在此处和彼处的微调才能达到效果。
- en: Awesome! So, we have an application that efficiently provides great functionality.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！所以我们有一个高效提供出色功能的应用程序。
- en: There is, however, one key area that we have not yet covered when it comes to
    building CLI applications (and, for that matter, any kind of application). That
    key area is **security**, and this is the topic of the next chapter.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们谈到构建CLI应用程序时（以及任何类型的应用程序），有一个关键领域我们还没有涉及。这个关键领域是**安全性**，这也是下一章的主题。
- en: Your turn!
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你的回合！
- en: Following along with the provided code is a great way to learn through practice.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 跟随提供的代码是一种通过实践学习的好方法。
- en: A better way is by challenging yourself to achieve tasks. Hence, I challenge
    you to improve the Bookmarkr application by adding the following features.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 一个更好的方法是挑战自己完成任务。因此，我挑战你通过添加以下功能来改进Bookmarkr应用程序。
- en: 'Task #1 – Write more benchmarks'
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #1 – 编写更多基准测试'
- en: In this chapter, we have illustrated writing benchmark methods by only writing
    a benchmark for the `export` command. However, as we mentioned earlier, benchmarks
    do not only apply to commands, but they can also apply to services.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们通过仅编写`export`命令的基准来展示了编写基准方法。然而，正如我们之前提到的，基准不仅适用于命令，它们也可以适用于服务。
- en: That’s why you are tasked with writing additional benchmark methods for each
    command and for the services used by the Bookmarkr application.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，你被分配了为每个命令以及由Bookmarkr应用程序使用的服务编写额外的基准方法。
- en: 'Task #2 – Fine-tune Bookmarkr for optimal performance'
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '任务 #2 – 优化Bookmarkr以获得最佳性能'
- en: Throughout this chapter, we haven’t implemented every performance optimization
    opportunity, and we have probably missed some (was that intentional? *wink wink*).
    Therefore, you are tasked with identifying other potential performance optimizations
    in Bookmarkr and implementing them.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们并没有实现每一个性能优化的机会，我们可能也错过了一些（这是故意的吗？*眨眼*）。因此，你被分配了在Bookmarkr中识别其他潜在的性能优化并实施它们。
