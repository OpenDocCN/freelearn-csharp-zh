<html><head></head><body>
<div><h1 class="chapterNumber"><a id="_idTextAnchor122"/>5</h1>
<h1 class="chapterTitle" id="_idParaDest-87"><a id="_idTextAnchor123"/>Background Functions in Practice</h1>
<p class="normal">When you start working with cloud computing, especially while working with <strong class="keyWord">Platform as a Service</strong> (<strong class="keyWord">PaaS</strong>), one of the challenges you may encounter is how to enable background work if your solution is based on instances that require a request before processing. One of the answers to this problem is the use of serverless to process this background job. In Azure, you will find Azure Functions triggers that can help you with this.</p>
<p class="normal">In this chapter, we will discuss three of them: the timer trigger, Blob storage trigger, and queue storage trigger. It is important to mention that we covered their basics in <a href="Chapter_1.xhtml#_idTextAnchor022"><em class="italic">Chapter 1</em></a><em class="italic">, Demystifying Serverless Applications</em>, but we will start to implement them now.</p>
<p class="normal">Together with their implementation, we will present an alternative to the publication of Azure Functions inside Visual Studio. We will also check how to monitor these functions. Understanding the advantages and disadvantages and when these functions are a good approach to be used will be discussed in the chapter. We will also see them working using the car-sharing example as a basis for understanding the purpose of each trigger better. Let’s go!</p>
<h1 class="heading-1" id="_idParaDest-88"><a id="_idTextAnchor124"/>Technical requirements</h1>
<p class="normal">This chapter requires the Visual Studio 2022 free <em class="italic">Community edition </em>or Visual Studio Code. You will also need an Azure account to create the sample environment. You can find the sample code for this chapter at <a href="https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp">https://github.com/PacktPublishing/Practical-Serverless-and-Microservices-with-Csharp</a>.</p>
<h1 class="heading-1" id="_idParaDest-89"><a id="_idTextAnchor125"/>Timer trigger</h1>
<p class="normal">It is not uncommon to need to<a id="_idIndexMarker276"/> process a task from time to time, at a specific moment of the day. A timer trigger will certainly help you with this. This function is based on the <code class="codeHighlighted" style="font-weight: bold;">NCRONTAB</code> expression, which is like a <code class="codeHighlighted" style="font-weight: bold;">CRON</code> expression:</p>
<p class="normal"><code class="inlineCode">{second} {minute} {hour} {day} {month} {day-of-week}</code></p>
<p class="normal">If you consider this expression, you will be able to schedule different moments to trigger the function. Let’s check the following table to understand it better: </p>
<table class="table-container" id="table001">
<tbody>
<tr>
<th class="table-head">
<p class="normal"><strong class="keyWord">Second</strong></p>
</th>
<th class="table-head">
<p class="normal"><strong class="keyWord">Minute</strong></p>
</th>
<th class="table-head">
<p class="normal"><strong class="keyWord">Hour</strong></p>
</th>
<th class="table-head">
<p class="normal"><strong class="keyWord">Day</strong></p>
</th>
<th class="table-head">
<p class="normal"><strong class="keyWord">Month</strong></p>
</th>
<th class="table-head">
<p class="normal"><strong class="keyWord">Day of the Week</strong></p>
</th>
<th class="table-head">
<p class="normal"><strong class="keyWord">Result</strong></p>
</th>
<th class="table-head">
<p class="normal"><strong class="keyWord">Meaning</strong></p>
</th>
</tr>
<tr>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">* * * * * *</p>
</td>
<td class="table-cell">
<p class="normal">Every second</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">0</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">0 * * * * *</p>
</td>
<td class="table-cell">
<p class="normal">Every minute</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">*/5</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*/5 * * * * *</p>
</td>
<td class="table-cell">
<p class="normal">Every five seconds</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">0</p>
</td>
<td class="table-cell">
<p class="normal">0</p>
</td>
<td class="table-cell">
<p class="normal">1</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">1-5</p>
</td>
<td class="table-cell">
<p class="normal">0 0 1 * * 1-5</p>
</td>
<td class="table-cell">
<p class="normal">At 1:00 AM, from Monday to Friday</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">5,10,20 </p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">*</p>
</td>
<td class="table-cell">
<p class="normal">5,10,20 * * * * *</p>
</td>
<td class="table-cell">
<p class="normal">At 5, 10, and 20 seconds past the minute</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">There are some important tips related to the <code class="codeHighlighted" style="font-weight: bold;">NCRONTAB</code> expression. First, you may consider days of the week from Sunday (<code class="codeHighlighted" style="font-weight: bold;">0</code>) to Saturday (<code class="codeHighlighted" style="font-weight: bold;">6</code>). The <code class="codeHighlighted" style="font-weight: bold;">*</code> operator represents all values at the moment defined, while <code class="codeHighlighted" style="font-weight: bold;">-</code> is the range operator. If you want to express an interval, you may use the <code class="codeHighlighted" style="font-weight: bold;">/</code> operator, and if you want to <a id="_idIndexMarker277"/>define a set of values, the <code class="codeHighlighted" style="font-weight: bold;">,</code> operator must be used.</p>
<p class="normal">The following code is an example of a timer trigger and the way you define its schedule:</p>
<pre class="programlisting code"><code class="hljs-code">public class SampleFunction
{
  private readonly ILogger _logger;
  public SampleFunction(ILoggerFactory loggerFactory)
  {
    _logger = loggerFactory.CreateLogger&lt;SampleFunction&gt;();
  }
  [Function(“SampleFunction”)]
  public void Run([TimerTrigger(“*/5 * * * * *”)] TimerInfo myTimer)
  {
    _logger.LogInformation($”C# Timer trigger function executed at:
                             {DateTime.Now}”);
   
    if (myTimer.ScheduleStatus is not null)
    {
      _logger.LogInformation($”Next timer schedule at:
                              {myTimer.ScheduleStatus.Next}”);
    }
  }
}
</code></pre>
<p class="normal">There are some websites where you can interpret the <code class="codeHighlighted" style="font-weight: bold;">NCRONTAB</code> expression you have designed. You can check this out at https://crontab.cronhub.io/.</p>
<p class="normal">The following figure shows the result of the preceding timer trigger code.</p>
<figure class="mediaobject"><img alt="Figure 5.1: Timer trigger function in execution" src="img/B31916_05_01.png"/></figure>
<p class="packt_figref">Figure 5.1: Timer trigger function in execution</p>
<p class="normal">This flexibility enables you to define a solid structure of jobs to run your microservices. On the other hand, if you want to debug <a id="_idIndexMarker278"/>a specific function, you may use the <code class="codeHighlighted" style="font-weight: bold;">RunOnStartup</code> parameter set to <code class="codeHighlighted" style="font-weight: bold;">true</code>. It is important to mention, though, that this parameter must not be used in production</p>
<div><p class="normal">There is a possibility to manually trigger non-HTTP functions. Please check this link to do so: <a href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-manually-run-non-http">https://learn.microsoft.com/en-us/azure/azure-functions/functions-manually-run-non-http</a>.</p>
</div>
<p class="normal">Now you understand how timer trigger functions work, let’s check a way you can publish them using Visual Studio.</p>
<h1 class="heading-1" id="_idParaDest-90"><a id="_idTextAnchor126"/>Publishing your functions</h1>
<p class="normal">As you are developing your Azure functions in Visual Studio, it is useful to know that the IDE enables you to publish your<a id="_idIndexMarker279"/> code to Azure in small steps. Let’s check how to do so.</p>
<p class="normal">The first step is to right-click the project you want to publish. As soon as you do this, you will find the <strong class="keyWord">Publish…</strong> action to start the process.</p>
<figure class="mediaobject"><img alt="Figure 5.2: Publishing an Azure function project" src="img/B31916_05_02.png"/></figure>
<p class="packt_figref">Figure 5.2: Publishing an Azure function project</p>
<p class="normal">Once you decide to publish, you will be prompted to decide where to publish the function. Besides Azure, you might want to publish the function in a Docker container registry or a folder. You may also want to use a pre-made <a id="_idIndexMarker280"/>profile, so there is also an option to import the profile. For this demo, the <strong class="keyWord">Azure</strong> option will be selected.</p>
<figure class="mediaobject"><img alt="Figure 5.3: Publishing on Azure" src="img/B31916_05_03.png"/></figure>
<p class="packt_figref">Figure 5.3: Publishing on Azure</p>
<p class="normal">After the selection of <strong class="keyWord">Azure</strong>, you need to decide where in Azure you will have your function running. As we saw in <a href="Chapter_1.xhtml#_idTextAnchor022"><em class="italic">Chapter 1</em></a><em class="italic">, Demystifying Serverless Applications</em>, Azure functions can run in different operating systems and different container solutions. For this demo, we will select the Windows operating system.</p>
<figure class="mediaobject"><img alt="Figure 5.4: Selecting Azure Function App for Windows" src="img/B31916_05_04.png"/></figure>
<p class="packt_figref">Figure 5.4: Selecting Azure Function App for Windows</p>
<p class="normal">After connecting Visual Studio<a id="_idIndexMarker281"/> to your Azure account, all the function instances available for deployment will be presented to you. However, if you don’t have any instances, you will also be given the opportunity to create a new instance, by selecting the <strong class="keyWord">Create new</strong> button.</p>
<figure class="mediaobject"><img alt="Figure 5.5: Creating the Azure Function App on the Visual Studio interface" src="img/B31916_05_05.png"/></figure>
<p class="packt_figref">Figure 5.5: Creating the Azure Function App on the Visual Studio interface</p>
<p class="normal">The creation will take a few minutes, but then your Azure function can be published on Azure.</p>
<figure class="mediaobject"><img alt="Figure 5.6: Azure Function App ready" src="img/B31916_05_06.png"/></figure>
<p class="packt_figref">Figure 5.6: Azure Function App ready</p>
<p class="normal">The current wizard <a id="_idIndexMarker282"/>available in Visual Studio is very useful. It not only helps you publish in a single step but also creates a YML file for you, to be used together with GitHub Actions. For this demo, we will use the basic option that generates a <code class="codeHighlighted" style="font-weight: bold;">.pubxml</code> file, but you may consider GitHub Actions as the best opportunity for real-life scenarios.</p>
<figure class="mediaobject"><img alt="Figure 5.7: Methods available for publishing" src="img/B31916_05_07.png"/></figure>
<p class="packt_figref">Figure 5.7: Methods available for publishing</p>
<p class="normal">Once you finish the <a id="_idIndexMarker283"/>wizard, you will have the publishing profile ready to start publishing the application.</p>
<figure class="mediaobject"><img alt="Figure 5.8: Publishing profiler" src="img/B31916_05_08.png"/></figure>
<p class="packt_figref">Figure 5.8: Publishing profiler</p>
<p class="normal">By clicking the <strong class="keyWord">Publish</strong> button, the <a id="_idIndexMarker284"/>process will start running and, after a few moments, your Azure Function App will be published.</p>
<figure class="mediaobject"><img alt="Figure 5.9: Function App published" src="img/B31916_05_09.png"/></figure>
<p class="packt_figref">Figure 5.9: Function App published</p>
<p class="normal">It is important to mention that <a id="_idIndexMarker285"/>you will need to do this complete process only once. After that, the new deployments needed will be a lot easier.</p>
<h1 class="heading-1" id="_idParaDest-91"><a id="_idTextAnchor127"/>Monitoring your functions</h1>
<p class="normal">The process for deploying<a id="_idIndexMarker286"/> functions presented in the last section is not exclusive to timer trigger functions. The same happens when it comes to monitoring your functions. In Azure, there are some alternative ways to check whether your Azure function is running properly. Let’s explore them.</p>
<p class="normal">The easiest way to monitor whether a function is running properly is by checking the number of invocations made by it. The <strong class="keyWord">Invocations</strong> tab is available in the Function App, and it will give you basic details about the execution.</p>
<figure class="mediaobject"><img alt="Figure 5.10: Function invocations" src="img/B31916_05_10.png"/></figure>
<p class="packt_figref">Figure 5.10: Function invocations</p>
<p class="normal">However, you may want<a id="_idIndexMarker287"/> to obtain detailed information about each execution. In this case, the best option to get this kind of information is by accessing the logs retained by Azure Monitor.</p>
<figure class="mediaobject"><img alt="Figure 5.11: Azure Monitor logs" src="img/B31916_05_11.png"/></figure>
<p class="packt_figref">Figure 5.11: Azure Monitor logs</p>
<p class="normal">Using Azure Monitor logs<a id="_idIndexMarker288"/> will result in a cost increase. Please check the best alternative for storing logs at <a href="https://docs.azure.cn/en-us/azure-monitor/logs/cost-logs">https://docs.azure.cn/en-us/azure-monitor/logs/cost-logs</a>.</p>
<p class="normal">The logs stored by Azure Monitor will also give you two other views. The Application Insights <strong class="keyWord">Performance</strong> view helps you analyze performance and errors that may happen in the Azure functions you develop.</p>
<figure class="mediaobject"><img alt="Figure 5.12: Application Insights Performance view" src="img/B31916_05_12.png"/></figure>
<p class="packt_figref">Figure 5.12: Application Insights Performance view</p>
<p class="normal">There is also a <strong class="keyWord">Live metrics</strong> view <a id="_idIndexMarker289"/>of the function running, which may be useful for debugging or understanding behaviors in production.</p>
<figure class="mediaobject"> <img alt="Figure 5.13: Application Insights Live metrics view" src="img/B31916_05_13.png"/></figure>
<p class="packt_figref">Figure 5.13: Application Insights Live metrics view</p>
<p class="normal">These options make Azure Functions an excellent alternative for processing your background work, as the observability<a id="_idIndexMarker290"/> provided is very good.</p>
<h2 class="heading-2" id="_idParaDest-92"><a id="_idTextAnchor128"/>Advantages, disadvantages, and when to use Azure timer triggers</h2>
<p class="normal">As we saw before, Azure timer triggers provide a great way to execute functions at regular intervals without the need for manual intervention. Their simplicity in setup and configuration helps you create functions that will run regularly, such as data synchronization, cleanup operations, and scheduled reports.</p>
<p class="normal">However, since the function will run<a id="_idIndexMarker291"/> exactly when you schedule it, if there is no job to be done at that moment, this execution will result in resource wastage, which basically means <a id="_idIndexMarker292"/>spending money unnecessarily. So, you must properly define the execution of the timer trigger function.</p>
<p class="normal">Based on the preceding information, scheduled actions that cannot depend on human manual intervention, such as backups, routine maintenance tasks, and periodic data processing, are great use cases for this kind of function. Even though it is important to define a way to monitor and report these executions, you can still make the most of this option.</p>
<h2 class="heading-2" id="_idParaDest-93"><a id="_idTextAnchor129"/>Car-sharing timer trigger example</h2>
<p class="normal">The car-sharing solution is an event-driven application. This means that there is no need for a timer trigger for this application <a id="_idIndexMarker293"/>when it comes to its basic flow of work. However, let’s imagine a routine for processing billing. Considering the business rules of this company, there is no way to process bills on Sundays, and considering the cash flow on the other days, the billing can be processed once an hour.</p>
<p class="normal">Based on this scenario, a timer trigger function can be a great choice to solve this problem, as follows:</p>
<pre class="programlisting code"><code class="hljs-code">public class ProcessBilling
{
  private readonly ILogger _logger;
  public ProcessBilling(ILoggerFactory loggerFactory)
  {
    _logger = loggerFactory.CreateLogger&lt;ProcessBilling&gt;();
  }
  /// &lt;summary&gt;
/// Every hour, between 08:00 AM and 05:59 PM, Monday through Saturday
/// &lt;/summary&gt;
/// &lt;param name=”myTimer”&gt;&lt;/param&gt;
  [Function(“ProcessBilling”)]
  public void Run([TimerTrigger(“0 0 8-17 * * 1-6”)] TimerInfo myTimer)
  {
    _logger.LogInformation($”Time to process billing!”);
    _logger.LogInformation($”Execution started at: {DateTime.Now}.”);
    // TODO - Code for processing billing
    _logger.LogInformation($”Process billing done: {DateTime.Now}.”);
  }
}
</code></pre>
<p class="normal">Notice that no matter whether you have billing to process or not, the execution of the function will happen every single hour, between <a id="_idIndexMarker294"/>8:00 AM and 5:59 PM, from Monday through Saturday. It is important to mention that Azure Functions will respect UTC time, so you should consider your location when defining the correct <code class="codeHighlighted" style="font-weight: bold;">CRON</code> expression to be used.</p>
<h1 class="heading-1" id="_idParaDest-94"><a id="_idTextAnchor130"/>Blob trigger</h1>
<p class="normal">Azure Blob Storage is a service provided <a id="_idIndexMarker295"/>by Microsoft Azure for storing large amounts of unstructured data, such as images, videos, logs, and backups. It is optimized for storing binary data in a highly scalable and cost-effective <a id="_idIndexMarker296"/>way. <strong class="keyWord">Blob</strong> stands for <strong class="keyWord">Binary Large Object</strong>, highlighting its ability to handle massive volumes of data efficiently, making it an ideal solution for applications that require durable, scalable storage.</p>
<p class="normal">The great thing about this service is that it is highly scalable, secure, and accessible from anywhere in the world via HTTP or HTTPS. Also, it enables integration with other Azure services, such as Azure Functions. This connector enables a variety of possible solutions for automating processes since it is possible to execute a function for each change made in a specific blob storage.</p>
<p class="normal">The focus of this book is not to <a id="_idIndexMarker297"/>go further into Blob Storage options, but it is useful to know that the service provides different access tiers, such as hot, cool, and archive, which vary according to access needs, each with its own pricing.</p>
<p class="normal">When you start creating a Blob storage trigger function, one of the things that you will be asked to define is where the storage will run. For debugging, you will have the possibility to use <strong class="keyWord">Storage Azurite emulator</strong>, which is a<a id="_idIndexMarker298"/> local emulator for Azure Storage. Azurite is available with Visual Studio. Based on your edition of Vision Studio, it will be placed in a specific folder. After you find the executable, you may run it using Admin access.</p>
<figure class="mediaobject"><img alt="Figure 5.14: Azurite execution" src="img/B31916_05_14.png"/></figure>
<p class="packt_figref">Figure 5.14: Azurite execution</p>
<p class="normal">Another important tool to be used while creating Blob storage trigger functions is Microsoft Azure Storage Explorer. With these two tools, the process of creating Blob storage trigger functions will be very easy. The following figure shows how Visual Studio enables you to select Azurite as the default emulator for your project.</p>
<figure class="mediaobject"><img alt="Figure 5.15: Connecting a Blob storage trigger to Azure" src="img/B31916_05_15.png"/></figure>
<p class="packt_figref">Figure 5.15: Connecting a Blob storage trigger to Azure</p>
<h2 class="heading-2" id="_idParaDest-95"><a id="_idTextAnchor131"/>Advantages, disadvantages, and when to use Blob storage triggers</h2>
<p class="normal">When it comes to advantages<a id="_idIndexMarker299"/> regarding the usage of Blob storage triggers, the possibility of handling large volumes of data<a id="_idIndexMarker300"/> efficiently can surely be mentioned. Besides that, the possibility to scale the processing no matter the number of incoming triggers is also a good reason why you should consider this kind of trigger to process data.</p>
<p class="normal">On the other hand, pricing can be a problem since, in some cases, the pricing model is based on the number of executions and the amount of data processed, so do not forget to analyze the best way to allocate this kind of Azure function.</p>
<p class="normal">It is also important to mention that, depending on the app plan you have defined for the Azure function, you may experience some delay between the uploading or updating of the file and the function processing. To avoid it, you may<a id="_idIndexMarker301"/> consider an App Service plan with Always On enabled, although this will obviously<a id="_idIndexMarker302"/> increase the cost of the solution. </p>
<p class="normal">To finish, it is important to mention that the initial Blob storage trigger function implementation was based on pooling. Pooling refers to a periodic scan of the entire container, typically processing up to 10,000 blobs per batch. In this approach, each file has up to five retry attempts by default. If all retries fail, the function creates a poison message and moves it to the <code class="codeHighlighted" style="font-weight: bold;">webjobs-blobtrigger-poison</code> queue. To avoid such scenarios and improve reliability, you can implement a Blob storage trigger using Event Grid instead. We will cover this in the next section.</p>
<p class="normal">Based on this information, you can use a Blob storage trigger in applications where you have software requirements such as image processing, data analysis, and real-time or batch processing. In this kind of application, you generally need to react quickly and automatically to new or updated blobs. In these cases, the scalability and adaptability of Azure Functions will help you meet your demands.</p>
<h1 class="heading-1" id="_idParaDest-96"><a id="_idTextAnchor132"/>Blob trigger implementation using Event Grid</h1>
<p class="normal">The idea behind using <a id="_idIndexMarker303"/>Event Grid to implement Blob trigger events is to reduce latency. Besides, if you decide to define your functions using the Flex Consumption plan, this is the only option you will have.</p>
<p class="normal">To do so, while creating the function, select the <strong class="keyWord">Blob Trigger (using Event Grid)</strong> option. With this option, Visual Studio will create a different code for the Azure function.</p>
<figure class="mediaobject"><img alt="Figure 5.16: Creating a Blob trigger function using Event Grid" src="img/B31916_05_16.png"/></figure>
<p class="packt_figref">Figure 5.16: Creating a Blob trigger function using Event Grid</p>
<p class="normal">It is important to mention that this <a id="_idIndexMarker304"/>function will run better on Azure than locally. For this, you need to create a <strong class="keyWord">general-purpose v2 </strong>storage account, which is mandatory for the event subscription.</p>
<figure class="mediaobject"><img alt="Figure 5.17: Review of the creation of the storage account" src="img/B31916_05_17.png"/></figure>
<p class="packt_figref">Figure 5.17: Review of the creation of the storage account</p>
<p class="normal">In the same way that we have the prerequisite for Azure Storage, the function app for running this kind of trigger should<a id="_idIndexMarker305"/> consider using the Flex Consumption plan, as we can see in the following figure. The advantage of this Consumption plan, according to Microsoft, is that it reduces cold starts with always-ready instances, supports VNets, and scales automatically, even in high load periods. On the other hand, at the time of writing this book, this option was not available in all regions.</p>
<figure class="mediaobject"><img alt="Figure 5.18: Flex Consumption plan" src="img/B31916_05_18.png"/></figure>
<p class="packt_figref">Figure 5.18: Flex Consumption plan</p>
<p class="normal">After the creation of the Azure function app, you may use the steps presented previously to publish the function. The name used for the function app in this example was <code class="codeHighlighted" style="font-weight: bold;">flexfunction</code>. It is worth noting that Flex <a id="_idIndexMarker306"/>Consumption plans are for Linux-based operating systems.</p>
<p class="normal">The following code shows the published function. Notice that the <code class="codeHighlighted" style="font-weight: bold;">Connection</code> parameter is <code class="codeHighlighted" style="font-weight: bold;">"ConnectionStringName"</code> in this example. Also, notice that the name of the function is <code class="codeHighlighted" style="font-weight: bold;">SampleFunction</code>:</p>
<pre class="programlisting code"><code class="hljs-code">public class SampleFunction
{
  private readonly ILogger&lt;SampleFunction&gt; _logger;
  public SampleFunction(ILogger&lt;SampleFunction&gt; logger)
  {
    _logger = logger;
  }
  [Function(nameof(SampleFunction))]
  public async Task Run([BlobTrigger(“event-grid-samples/{name}”,
    Source = BlobTriggerSource.EventGrid,
    Connection = “ConnectionStringName”)] Stream stream, string name)
  {
    using var blobStreamReader = new StreamReader(stream);
    var content = await blobStreamReader.ReadToEndAsync();
    _logger.LogInformation($”C# Blob Trigger (using Event Grid) processed
                             blob\n Name: {name} \n Data: {content}”);
  }
}
</code></pre>
<p class="normal">You will need this information <a id="_idIndexMarker307"/>to set the Azure function. <code class="codeHighlighted" style="font-weight: bold;">"ConnectionStringName"</code> needs to be defined in the settings of the function app as an environment variable, as you can see in the following figure. The content of this configuration is the connection string of the created storage account.</p>
<figure class="mediaobject"><img alt="Figure 5.19: Defining the connection between the function app and the storage account" src="img/B31916_05_19.png"/></figure>
<p class="packt_figref">Figure 5.19: Defining the connection between the function app and the storage account</p>
<p class="normal">After that, you will have all the information needed to define the event that will be triggered in the function app. Notice<a id="_idIndexMarker308"/> that the event happens in the storage account and Event Grid triggers the function. To do this, a webhook is created. The definition of the URL of the webhook can be seen here:</p>
<table class="table-container" id="table002">
<thead>
<tr>
<th class="table-head">
<p class="normal"><strong class="keyWord">Part</strong></p>
</th>
<th class="table-head">
<p class="normal"><strong class="keyWord">Template</strong></p>
</th>
</tr>
</thead>
<tbody>
<tr>
<td class="table-cell">
<p class="normal">Base function app URL</p>
</td>
<td class="table-cell">
<p class="normal">https://&lt;FUNCTION_APP_NAME&gt;.azurewebsites.net</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Blob-specific path</p>
</td>
<td class="table-cell">
<p class="normal">/runtime/webhooks/blobs</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Function query string</p>
</td>
<td class="table-cell">
<p class="normal">?functionName=Host.Functions.&lt;FUNCTION_NAME&gt;</p>
</td>
</tr>
<tr>
<td class="table-cell">
<p class="normal">Blob extension access key</p>
</td>
<td class="table-cell">
<p class="normal">&amp;code=&lt;BLOB_EXTENSION_KEY&gt;</p>
</td>
</tr>
</tbody>
</table>
<p class="normal">The blob extension access key can be found in the <strong class="keyWord">App Keys</strong> section of the function app. There is a specific system key for <code class="codeHighlighted" style="font-weight: bold;">blobs_extension</code>. Once you have the key, you can use it to create a new event in Azure Storage, as you can see in the next figure.</p>
<figure class="mediaobject"><img alt="Figure 5.20: Subscribing to an event in Blob Storage" src="img/B31916_05_20.png"/></figure>
<p class="packt_figref">Figure 5.20: Subscribing to an event in Blob Storage</p>
<p class="normal">It is important to mention <a id="_idIndexMarker309"/>that your Azure subscription may not have enabled the resource provider for Event Grid and an error may occur with this disabled while creating the subscription. To enable the resource provider, you need to go to your subscription account and register it.</p>
<figure class="mediaobject"><img alt="Figure 5.21: Registering the Microsoft.EventGrid resource provider" src="img/B31916_05_21.png"/></figure>
<p class="packt_figref">Figure 5.21: Registering the Microsoft.EventGrid resource provider</p>
<p class="normal">After this configuration, by simply <a id="_idIndexMarker310"/>uploading files to the defined container, the function will be triggered for each file uploaded, in a low-latency model. You can monitor each trigger using the function’s <strong class="keyWord">Invocations</strong> panel. Notice, in the figure, that the function was triggered four times in the same second in the last calls, showing the capacity of the trigger function to handle a greater number of files at the same time.</p>
<figure class="mediaobject"><img alt="Figure 5.22: Monitoring triggers" src="img/B31916_05_22.png"/></figure>
<p class="packt_figref">Figure 5.22: Monitoring triggers</p>
<p class="normal">It is worth noting that this example requires different components that may create additional costs. So, you must pay attention not to let this demo run in your Azure account if you are just trying this option. On the <a id="_idIndexMarker311"/>other hand, this will decrease the latency between the arrival of a file and its processing, so you may consider it a good approach for real-life applications.</p>
<h2 class="heading-2" id="_idParaDest-97"><a id="_idTextAnchor133"/>Car-sharing Blob storage trigger example</h2>
<p class="normal">Considering the car-sharing use<a id="_idIndexMarker312"/> case that we are presenting in this book, it is worth mentioning that one of the services that may be included in this solution is to analyze the driver’s license. To do so, in the frontend application, there will be a user interface to upload this important document to the business logic of the application. However, as this file is important, storing information like this needs to be well designed. A good option is to only extract the information needed with the uploaded image and then create a hash of this information, so you can delete the file uploaded by the user.</p>
<p class="normal">To do so, you may create a function dedicated to processing driver’s license photos. Using a Blob storage trigger to do so may be a good idea.</p>
<p class="normal">It is important to mention that this example needs to update the <code class="codeHighlighted" style="font-weight: bold;">Program.cs</code> file. Instead of directly using the <code class="codeHighlighted" style="font-weight: bold;">FunctionsApplication</code> class, we will use <code class="codeHighlighted" style="font-weight: bold;">HostBuilder</code> here, configuring the Azure Functions application<a id="_idIndexMarker313"/> with the <code class="codeHighlighted" style="font-weight: bold;">ConfigureFunctionsWebApplication</code> method. It is worth mentioning that in Azure Functions with .NET 8, <code class="codeHighlighted" style="font-weight: bold;">ConfigureFunctionsWebApplication()</code> enables ASP.NET Core integration, while the default <code class="codeHighlighted" style="font-weight: bold;">ConfigureFunctionsWorkerDefaults()</code> is used for the isolated worker model, offering greater flexibility and control over .NET versions and dependencies:</p>
<pre class="programlisting code"><code class="hljs-code">using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Configuration;
using CarShareBackground;
var host = new HostBuilder()
  .ConfigureFunctionsWebApplication()
  .ConfigureAppConfiguration(config =&gt;
  {
    config.AddUserSecrets&lt;ProcessDriversLicensePhoto&gt;(optional: true,
      reloadOnChange: false);
  })
  .Build();
host.Run();
</code></pre>
<p class="normal">The <code class="codeHighlighted" style="font-weight: bold;">AddUserSecrets</code> method adds user secrets to the configuration, which is useful for storing sensitive information such as API keys or connection strings. In this case, we are storing the connection with Blob Storage. The <code class="codeHighlighted" style="font-weight: bold;">ProcessDriversLicensePhoto</code> type is used to identify the assembly containing the user secrets. The <code class="codeHighlighted" style="font-weight: bold;">optional: true</code> parameter means that the application will not fail if the user secrets file is not found, and <code class="codeHighlighted" style="font-weight: bold;">reloadOnChange: false</code> indicates that the configuration <a id="_idIndexMarker314"/>will not automatically reload if the user secrets file changes.</p>
<p class="normal">Once you have defined <code class="codeHighlighted" style="font-weight: bold;">Program.cs</code>, you may create the Azure function to process Blob Storage. The function itself is quite simple to define, as you can see in the following code:</p>
<pre class="programlisting code"><code class="hljs-code">[Function(nameof(ProcessDriversLicensePhoto))]
public async Task Run([BlobTrigger(“drivers-license/{name}”,
    Connection = “CarShareStorage”)] Stream myBlob, string name)
{
  StreamReader reader = new StreamReader(myBlob);
  var message = reader.ReadToEnd();
  _logger.LogInformation(“File detected”);
}
</code></pre>
<p class="normal">The <code class="codeHighlighted" style="font-weight: bold;">BlobTrigger</code> attribute defines where in Blob Storage the files will be uploaded, in this case, in the <code class="codeHighlighted" style="font-weight: bold;">drivers-license</code> folder, where <code class="codeHighlighted" style="font-weight: bold;">{name} </code>is a placeholder for the blob’s name, which will be passed as a string in the <code class="codeHighlighted" style="font-weight: bold;">name</code> parameter. The stream of the file will be obtained by the <code class="codeHighlighted" style="font-weight: bold;">myBlob</code> parameter.</p>
<h1 class="heading-1" id="_idParaDest-98"><a id="_idTextAnchor134"/>Queue storage trigger</h1>
<p class="normal">The principle of a<a id="_idIndexMarker315"/> queue is fairly well known since this is a data structure where you want to control the data so that first in will be first out. When we talk about the queue storage trigger in Azure Functions, we have the possibility to manage queues asynchronously and totally decoupled, making its usage extremely powerful.</p>
<p class="normal">The great power that we have in this scenario is the ability to handle large amounts of messages efficiently. Azure Functions has the capability to scale automatically, and it guarantees that each task will be processed properly with reliability and fault tolerance.</p>
<p class="normal">Considering this approach, it is worth noting that serverless applications will always focus the development on what is<a id="_idIndexMarker316"/> essentially needed – the business logic to make that service work. That is why serverless applications are a great way to implement microservices since the necessity of handling infrastructure will be less needed.</p>
<h2 class="heading-2" id="_idParaDest-99"><a id="_idTextAnchor135"/>Advantages, disadvantages, and when to use queue storage triggers</h2>
<p class="normal">If you have a use case where you must control a queue of data, a queue storage trigger function will be one of the good options to select. The fact that this approach can handle large volumes of messages efficiently is truly an advantage. In this case, you only need to focus on the business logic for the service that will be implemented.</p>
<p class="normal">However, the pricing model is based on the number of executions and the amount of data processed, so you must be aware <a id="_idIndexMarker317"/>of it and not be surprised by the costs related to the solution. It is also worth noting that high load or transient errors may occur and, as a developer, you <a id="_idIndexMarker318"/>must implement retries and error-handling mechanisms to ensure your solution is well implemented.</p>
<p class="normal">Queue storage triggers may be a good solution when you must deliver a reliable and efficient solution for processing queued tasks, considering all we have discussed. For instance, if you need order processing, background job scheduling, or event event-driven notifications, this kind of solution can be a good approach. Now, let’s check a scenario in the car-sharing example where a queue storage trigger could be a good solution.</p>
<h2 class="heading-2" id="_idParaDest-100"><a id="_idTextAnchor136"/>Car-sharing queue storage trigger example</h2>
<p class="normal">Considering the car-sharing<a id="_idIndexMarker319"/> use case, one of the services that may be created using a queue storage trigger is the <code class="codeHighlighted" style="font-weight: bold;">My_Best_Matches</code> microservice. According to the car-sharing example specification described in <a href="Chapter_2.xhtml#_idTextAnchor038"><em class="italic">Chapter 2</em></a>, <em class="italic">Demystifying Microservices Applications</em>, all routes’ changes are sent to both the <code class="codeHighlighted" style="font-weight: bold;">My_Best_Matches</code> and <code class="codeHighlighted" style="font-weight: bold;">Route-Choosing</code> microservices.</p>
<p class="normal">Considering this scenario, let’s suppose that the routes’ changes are queued as JSON components in an Azure Storage <a id="_idIndexMarker320"/>queue. This JSON will indicate that there is a new match to be processed by <code class="codeHighlighted" style="font-weight: bold;">My_Best_Matches</code> microservice:</p>
<pre class="programlisting code"><code class="hljs-code">using Azure.Storage.Queues.Models;
using Microsoft.Azure.Functions.Worker;
using Microsoft.Extensions.Logging;
namespace My_Best_Matches
{
  public class NewMatchTrigger
  {
    private readonly ILogger&lt;NewMatchTrigger&gt; _logger;
    public NewMatchTrigger(ILogger&lt;NewMatchTrigger&gt; logger)
    {
      _logger = logger;
    }
    [Function(nameof(NewMatchTrigger))]
    public void Run([QueueTrigger(“new-match”,
      Connection = “CarSharingStorage”)] QueueMessage message)
    {
      _logger.LogInformation($”C# Queue trigger function processed:
        {message.MessageText}”);
    }
  }
}
</code></pre>
<p class="normal">Once you have this code running, using the local storage emulator, you can place a message in the <code class="codeHighlighted" style="font-weight: bold;">new-match</code> queue.</p>
<figure class="mediaobject"><img alt="Figure 5.23: Placing a message in the queue" src="img/B31916_05_23.png"/></figure>
<p class="packt_figref">Figure 5.23: Placing a message in the queue</p>
<p class="normal">The message placed in the <a id="_idIndexMarker321"/>queue will be automatically processed by the function and then deleted from the storage.</p>
<figure class="mediaobject"><img alt="Figure 5.24: Azure function output" src="img/B31916_05_24.png"/></figure>
<p class="packt_figref">Figure 5.24: Azure function output</p>
<p class="normal">Considering this scenario, this <a id="_idIndexMarker322"/>message could be used to send an email to both the car holder and car seeker, indicating that there is a new match for them and that they can interact with the system to define whether or not they will accept the proposed route.</p>
<h1 class="heading-1" id="_idParaDest-101"><a id="_idTextAnchor137"/>Summary</h1>
<p class="normal">This chapter discussed the implementation of three important Azure trigger functions to implement background services – timer triggers, Blob storage triggers, and queue storage triggers. Tasks such as processing routines, images, data, and orders can be easily implemented using this serverless technology.</p>
<p class="normal">While presenting these kinds of functions, the chapter explained how to publish and monitor functions. It also presented a more efficient way to implement blob trigger functions, using Event Grid as a basis, and reducing the latency between the file upload and the start of the processing.</p>
<p class="normal">The chapter also explained how Azure Functions can be a great approach to implementing microservices. To do so, it presented three examples related to the car-sharing use case where the usage of this kind of solution will let developers focus on what really matters when it comes to software development – coding the business logic of the solution that is being developed.</p>
<p class="normal">Now, let’s move on to the next chapter, which will discuss how to enable IoT solutions using Azure Functions as a basis.</p>
<h1 class="heading-1" id="_idParaDest-102"><a id="_idTextAnchor138"/>Questions</h1>
<ol>
<li class="numberedList" value="1">What is the purpose of the timer trigger function?</li>
</ol>
<p class="normal-one">The timer trigger function is designed to execute code on a schedule, defined using <code class="codeHighlighted" style="font-weight: bold;">NCRONTAB</code> expressions. It allows developers to run background jobs at regular intervals without requiring manual initiation or HTTP requests.</p>
<p class="normal-one">This is useful for scenarios such as data synchronization, cleanup operations, report generation, and periodic billing. It helps automate repetitive tasks, especially those that shouldn’t depend on human interaction to be performed.</p>
<ol>
<li class="numberedList" value="2">What is the purpose of the blob trigger function?</li>
</ol>
<p class="normal-one">The blob trigger function responds automatically whenever a file is added or modified in a specific Azure Blob Storage container. It enables event-driven processing for unstructured data such as images, logs, or documents.</p>
<p class="normal-one">This trigger is ideal for automating workflows involving data ingestion, file processing, image analysis, or document transformation. It supports scalability and integration with Event Grid to reduce latency in high-performance scenarios.</p>
<ol>
<li class="numberedList" value="3">What is the purpose of the queue trigger function?</li>
</ol>
<p class="normal-one">The queue trigger function executes when a new message is added to Azure Queue Storage. It enables the asynchronous processing of tasks, decoupling producers from consumers in distributed systems.</p>
<p class="normal-one">This approach ensures reliable and scalable handling of queued tasks such as background processing, order handling, or notifications, allowing developers to focus on business logic while Azure Functions handles infrastructure concerns.</p>
<ol>
<li class="numberedList" value="4">What is the difference between the blob and queue trigger functions?</li>
</ol>
<p class="normal-one">The blob trigger function reacts to file changes in Azure Blob Storage, typically processing binary or unstructured data. It is event-driven and suited for scenarios such as file uploads, media processing, or document handling.</p>
<p class="normal-one">In contrast, the queue trigger function is designed to process text-based messages from Azure Queue Storage. It is better suited for managing workflows, job scheduling, and message-driven integrations, where you need explicit control over task order and execution.</p>
<ol>
<li class="numberedList" value="5">How can we reduce the latency between the file upload and the start of processing in a blob trigger function?</li>
</ol>
<p class="normal-one">To reduce latency in a blob trigger function, it’s recommended to use Event Grid-based blob triggers instead of polling-based triggers. Event Grid enables near-real-time processing by pushing events as they occur.</p>
<p class="normal-one">Additionally, using the Flex Consumption plan or an App Service plan with Always On enabled helps minimize cold start times. However, these approaches may increase cost, so they should be evaluated based on application requirements.</p>
<ol>
<li class="numberedList" value="6">List different ways to monitor an Azure function.</li>
</ol>
<p class="normal-one">Azure functions can be monitored using several built-in tools. The <strong class="keyWord">Invocation</strong> tab in the Azure portal provides basic metrics, such as the number of executions and execution status.</p>
<p class="normal-one">For deeper insights, Azure Monitor logs and Application Insights (<strong class="keyWord">Performance</strong> and <strong class="keyWord">Live Metrics</strong> views) offer advanced telemetry, performance tracking, and real-time diagnostics. These tools help identify errors, analyze trends, and debug runtime behavior effectively.</p>
<h1 class="heading-1" id="_idParaDest-103"><a id="_idTextAnchor139"/>Further reading</h1>
<ul>
<li class="bulletList">Azure Functions timer trigger: <a href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer">https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-timer</a></li>
<li class="bulletList">Azurite: <a href="https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite">https://learn.microsoft.com/en-us/azure/storage/common/storage-use-azurite</a></li>
<li class="bulletList">Microsoft Azure Storage Explorer: <a href="https://learn.microsoft.com/en-us/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer">https://learn.microsoft.com/en-us/azure/storage/storage-explorer/vs-azure-tools-storage-manage-with-storage-explorer</a></li>
<li class="bulletList">Azure Functions blob trigger: <a href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-blob-trigger">https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-blob-trigger</a></li>
<li class="bulletList">Azure Functions blob trigger with Event-Grid: <a href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-event-grid-blob-trigger">https://learn.microsoft.com/en-us/azure/azure-functions/functions-event-grid-blob-trigger</a></li>
<li class="bulletList">Azure Queue storage trigger: <a href="https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue">https://learn.microsoft.com/en-us/azure/azure-functions/functions-bindings-storage-queue</a></li>
<li class="bulletList">Azure storage considerations: <a href="https://learn.microsoft.com/en-us/azure/azure-functions/storage-considerations">https://learn.microsoft.com/en-us/azure/azure-functions/storage-considerations</a></li>
</ul>
<h1 class="heading-1" id="_idParaDest-104"><a id="_idTextAnchor140"/>Join our community on Discord</h1>
<p class="normal">Join our community’s Discord space for discussions with the author and other readers:</p>
<p class="normal"><a href="https://packt.link/PSMCSharp">https://packt.link/PSMCSharp</a></p>
<p class="normal"><img alt="A qr code with black squares  AI-generated content may be incorrect." src="img/B31916_Discord-QR-Code.png"/></p>
</div>
</body></html>