- en: '10'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '10'
- en: JavaScript Interop
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript 互操作
- en: In this chapter, we will take a look at JavaScript. In specific scenarios, we
    still need to use JavaScript, or we will want to use an existing library that
    relies on JavaScript. Blazor uses JavaScript to update the **Document Object Model**
    (**DOM**), download files, and access local storage on the client.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨 JavaScript。在特定场景中，我们仍然需要使用 JavaScript，或者我们可能想使用依赖于 JavaScript 的现有库。Blazor
    使用 JavaScript 来更新 **文档对象模型**（**DOM**），下载文件，并访问客户端上的本地存储。
- en: So, there are, and always will be, cases when we need to communicate with JavaScript
    or have JavaScript communicate with us. Don’t worry, the Blazor community is an
    amazing one, so chances are someone has already built the interop we need.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，总会有，并且始终会有，我们需要与 JavaScript 通信或让 JavaScript 与我们通信的情况。别担心，Blazor 社区是一个了不起的社区，所以很可能有人已经构建了我们需要的互操作。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Why do we need JavaScript?
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为什么我们需要 JavaScript？
- en: .NET to JavaScript
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 到 JavaScript
- en: JavaScript to .NET
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 到 .NET
- en: Implementing an existing JavaScript library
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现现有的 JavaScript 库
- en: JavaScript interop in WebAssembly
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: WebAssembly 中的 JavaScript 互操作
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Ensure you have followed the previous chapters or use the `Chapter09` folder
    as a starting point.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 确保你已经遵循了前面的章节或使用 `Chapter09` 文件夹作为起点。
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter10).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter10](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter10)
    找到本章结果的源代码。
- en: If you are jumping into this chapter using the code from GitHub, make sure you
    have added the `Auth0` account information in the settings files. You can find
    the instructions in *Chapter 8*, *Authentication and Authorization*.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你正在使用 GitHub 上的代码跳入这一章，请确保你已经在设置文件中添加了 `Auth0` 账户信息。你可以在 *第 8 章*，*身份验证和授权*
    中找到说明。
- en: Why do we need JavaScript?
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为什么我们需要 JavaScript？
- en: Many say Blazor is the JavaScript killer, but the truth is that Blazor needs
    JavaScript to work. Some events only get triggered in JavaScript, and if we want
    to use those events, we need to make an interop.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 许多人说 Blazor 是 JavaScript 杀手，但事实是 Blazor 需要 JavaScript 来工作。某些事件仅在 JavaScript
    中触发，如果我们想使用这些事件，我们需要进行互操作。
- en: I jokingly say that I have never written so much JavaScript as when I started
    developing with Blazor. it’s not that bad.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 我开玩笑地说，我在开始使用 Blazor 进行开发时从未写过这么多 JavaScript。这并不糟糕。
- en: I have written a couple of libraries that require JavaScript to work. They are
    called `Blazm.Components` and `Blazm.Bluetooth`.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经编写了几个需要 JavaScript 才能工作的库。它们被称为 `Blazm.Components` 和 `Blazm.Bluetooth`。
- en: The first one is a grid component that uses JavaScript interop to trigger C#
    code (JavaScript to .NET) when the window is resized, to remove columns if they
    can’t fit inside the window.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个是一个网格组件，它使用 JavaScript 互操作在窗口大小调整时触发 C# 代码（JavaScript 到 .NET），以移除无法适应窗口的列。
- en: When that is triggered, the C# code calls JavaScript to get the size of the
    columns based on the client width, which only the web browser knows, and based
    on that answer, it removes columns if needed.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当触发时，C# 代码会调用 JavaScript 来获取列的大小，这是只有网络浏览器才知道的，然后根据这个答案，如果需要的话，它会移除列。
- en: The second one, `Blazm.Bluetooth`, makes it possible to interact with Bluetooth
    devices using Web Bluetooth, which is a web standard accessible through JavaScript.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个，`Blazm.Bluetooth`，使得使用 Web Bluetooth 与蓝牙设备交互成为可能，这是一个通过 JavaScript 可访问的
    Web 标准。
- en: 'It uses two-way communication; Bluetooth events can trigger C# code, and C#
    code can iterate over devices and send data to them. They are both open source,
    so if you are interested in looking at a real-world project, you can check them
    out on my GitHub: [https://github.com/EngstromJimmy](https://github.com/EngstromJimmy).'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 它使用双向通信；蓝牙事件可以触发 C# 代码，而 C# 代码可以遍历设备并向它们发送数据。它们都是开源的，所以如果你对查看一个真实世界的项目感兴趣，你可以在我的
    GitHub 上查看它们：[https://github.com/EngstromJimmy](https://github.com/EngstromJimmy)。
- en: As mentioned earlier, in most cases, I would argue that we won’t need to write
    JavaScript ourselves. The Blazor community is very big, so chances are that someone
    has already written what we need. But we don’t need to be afraid of using JavaScript
    either. Next, we will look at different ways to add JavaScript calls to our Blazor
    project.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在大多数情况下，我会说我们不需要自己编写 JavaScript。Blazor 社区非常大，所以很可能有人已经编写了我们需要的代码。但我们也不必害怕使用
    JavaScript。接下来，我们将探讨向我们的 Blazor 项目添加 JavaScript 调用的不同方法。
- en: .NET to JavaScript
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: .NET 到 JavaScript
- en: 'Calling JavaScript from .NET is pretty simple. There are two ways of doing
    this:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 从 .NET 调用 JavaScript 非常简单。有两种这样做的方法：
- en: Global JavaScript
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 全局 JavaScript
- en: JavaScript isolation
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: JavaScript 隔离
- en: We will go through both ways to see what the difference is.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将探讨这两种方法，看看它们有什么区别。
- en: Global JavaScript (the old way)
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 全局 JavaScript（旧方法）
- en: To access the JavaScript method, we need to make it accessible. One way is to
    define it globally through the JavaScript window object. This is a bad practice
    since it is accessible by all scripts and could replace the functionality in other
    scripts (if we accidentally use the same names).
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要访问 JavaScript 方法，我们需要使其可访问。一种方法是通过 JavaScript 窗口对象全局定义它。这是一种不好的做法，因为它对所有脚本都是可访问的，并且可能会替换其他脚本中的功能（如果我们不小心使用了相同的名称）。
- en: What we can do, for example, is use scopes, create an object in global space,
    and put our variables and methods on that object so that we lower the risk a bit,
    at least.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，我们可以使用作用域，在全局空间中创建一个对象，并将我们的变量和方法放在该对象上，这样我们就能降低一点风险，至少。
- en: 'Using a scope could look something like this:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 使用作用域可能看起来像这样：
- en: '[PRE0]'
  id: totrans-32
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: We create an object with the name `myscope`. Then, we declare a method on that
    object called `methodName`. In this example, there is no code in the method; this
    only demonstrates how it could be done.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个名为 `myscope` 的对象。然后，我们在该对象上声明一个名为 `methodName` 的方法。在这个例子中，方法中没有代码；这只是为了演示如何实现。
- en: 'Then, to call the method from C#, we would call it using `JSRuntime` like this:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，要从 C# 调用该方法，我们将使用 `JSRuntime` 如此调用：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'There are two different methods we can use to call JavaScript:'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以使用两种不同的方法来调用 JavaScript：
- en: '`InvokeVoidAsync`, which calls JavaScript but doesn’t expect a return value'
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvokeVoidAsync`，它调用 JavaScript 但不期望返回值'
- en: '`InvokeAsync<T>`, which calls JavaScript and expects a return value of type
    `T`'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`InvokeAsync<T>`，它调用 JavaScript 并期望返回类型为 `T` 的值'
- en: We can also send in parameters to our JavaScript method if we want. We also
    need to refer to JavaScript, and JavaScript must be stored in the `wwwroot` folder.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想的话，我们也可以向我们的 JavaScript 方法发送参数。我们还需要引用 JavaScript，并且 JavaScript 必须存储在 `wwwroot`
    文件夹中。
- en: The other way is JavaScript isolation, which uses the methods described here,
    but with modules.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种方法是 JavaScript 隔离，它使用这里描述的方法，但使用模块。
- en: JavaScript Isolation
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 隔离
- en: In .NET 5, we got a new way to add JavaScript using JavaScript Isolation, which
    is a much nicer way to call JavaScript. It doesn’t use global methods, and it
    doesn’t require us to refer to the JavaScript file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 5 中，我们得到了一种使用 JavaScript 隔离添加 JavaScript 的新方法，这是一种调用 JavaScript 的更好方式。它不使用全局方法，也不需要我们引用
    JavaScript 文件。
- en: This is awesome for component vendors and end users because JavaScript will
    be loaded when needed. It will only be loaded once (Blazor handles that for us),
    and we don’t need to add a reference to the JavaScript file, which makes it easier
    to start and use a library.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 这对于组件供应商和最终用户来说都很棒，因为 JavaScript 只在需要时加载。它只会加载一次（Blazor 为我们处理这一点），我们不需要添加对 JavaScript
    文件的引用，这使得开始和使用库变得更容易。
- en: So, let’s implement that instead.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 所以，让我们来实现它。
- en: Isolated JavaScript can be stored in the `wwwroot` folder, but since an update
    in .NET 6, we can add them in the same way we add isolated CSS. Add them to your
    component’s folder and name it, adding `.js` to the end (`mycomponent.razor.js`).
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 隔离的 JavaScript 可以存储在 `wwwroot` 文件夹中，但自从 .NET 6 更新以来，我们可以像添加隔离 CSS 一样添加它们。将它们添加到组件的文件夹中，并命名为，在末尾添加
    `.js`（`mycomponent.razor.js`）。
- en: Let’s do just that!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们就这样做！
- en: 'In our project, we can delete categories and components. Let’s implement a
    simple JavaScript call to reveal a prompt to make sure that the user wants to
    delete the category or tag. But we have talked about doing things in a reusable
    way, so let’s do that:'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的项目中，我们可以删除类别和组件。让我们实现一个简单的 JavaScript 调用来显示一个提示，以确保用户想要删除类别或标签。但我们已经讨论了以可重用方式做事，所以让我们这样做：
- en: In the `SharedComponents` project, select the `ReusableComponents/BlogButton.razor`
    file, create a new JavaScript file, and name the file `BlogButton.razor.js`.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`SharedComponents`项目中，选择`ReusableComponents/BlogButton.razor`文件，创建一个新的JavaScript文件，并将文件命名为`BlogButton.razor.js`。
- en: 'Open the new file (it is located under `BlogButton.razor` in the solution explorer)
    and add the following code:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开新文件（位于解决方案资源管理器中的`BlogButton.razor`下）并添加以下代码：
- en: '[PRE2]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: JavaScript Isolation uses the standard **EcmaScript** (**ES**) modules and can
    be loaded on demand. The methods it exposes are only accessible through that object
    and not globally, as with the *old* way.
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: JavaScript Isolation使用标准的**EcmaScript**（**ES**）模块，并且可以按需加载。它公开的方法只能通过该对象访问，而不是像*旧方法*那样全局访问。
- en: 'Open `BlogButton.razor` and inject `IJSRuntime` at the top of the file:'
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`BlogButton.razor`并在文件顶部注入`IJSRuntime`：
- en: '[PRE3]'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'In the `code` section, let’s add a method that will call JavaScript:'
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`code`部分，让我们添加一个将调用JavaScript的方法：
- en: '[PRE4]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`IJSObjectReference` is a reference to the specific script that we will import
    further down. It has access to the exported methods in our JavaScript, and nothing
    else.'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`IJSObjectReference`是对我们将进一步导入的特定脚本的引用。它有权访问我们的JavaScript中导出的方法，而其他什么都没有。'
- en: We run the `Import` command and send the filename as a parameter. This will
    run the `let mymodule = import("/_content/SharedComponents/ReusableComponents/BlogButton.razor.js")`
    JavaScript command and return the module. We also add a `ConfirmMessage` parameter
    so we know that if we have a `ConfirmMessage` we should show a confirm message.
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们运行`Import`命令并将文件名作为参数发送。这将运行`let mymodule = import("/_content/SharedComponents/ReusableComponents/BlogButton.razor.js")`
    JavaScript命令并返回模块。我们还添加了一个`ConfirmMessage`参数，这样我们知道如果有`ConfirmMessage`，我们应该显示确认消息。
- en: 'Then, in our `OnButtonClick` method, we first check whether we `shoudExecute`
    the method or not. Change it to the following:'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 然后，在我们的`OnButtonClick`方法中，我们首先检查是否应该执行该方法。将其更改为以下内容：
- en: '[PRE5]'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Now, we can use our button to confirm whether we want to delete the `Category`
    or `Tag`.
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 现在，我们可以使用我们的按钮来确认我们是否想要删除`Category`或`Tag`。
- en: 'Open `ItemList.razor`, and let’s add our `BlogButton` to the component. Inside
    the `Virtualize` component, change the content to the following:'
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开`ItemList.razor`，并将我们的`BlogButton`添加到组件中。在`Virtualize`组件内部，将内容更改为以下内容：
- en: '[PRE6]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Instead of just calling our `Delete` event callback, we first call our new method.
    Let JavaScript confirm that you really want to delete it, and if so, then run
    the `Delete` event callback.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 而不是仅仅调用我们的`Delete`事件回调，我们首先调用我们的新方法。让JavaScript确认你确实想要删除它，如果是的话，然后运行`Delete`事件回调。
- en: This is a simple implementation of JavaScript.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的JavaScript实现。
- en: JavaScript to .NET
  id: totrans-65
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: JavaScript到.NET
- en: What about the other way around? I would argue that calling .NET code from JavaScript
    isn’t a very common scenario, and if we find ourselves in that scenario, we might
    want to think about what we are doing.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 反过来呢？我认为从JavaScript调用.NET代码并不是一个非常常见的场景，如果我们发现自己处于那种场景，我们可能需要考虑我们在做什么。
- en: As Blazor developers, we should avoid using JavaScript as much as possible.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 作为Blazor开发者，我们应该尽可能避免使用JavaScript。
- en: I am not bashing JavaScript in any way, but I see this often happen where developers
    kind of shoehorn what they’ve used before into their Blazor projects.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我并不是在以任何方式批评JavaScript，但我看到开发者经常将他们之前使用过的东西强行塞入Blazor项目中。
- en: They are solving things with JavaScript that are easy to do with an `if` statement
    in Blazor. So, that’s why I think it’s essential to think about when to use JavaScript
    and when not to use JavaScript.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 他们用JavaScript解决的是用Blazor中的`if`语句容易解决的问题。这就是为什么我认为考虑何时使用JavaScript以及何时不使用JavaScript是至关重要的。
- en: There are, of course, times when JavaScript is the only option, and as I mentioned
    earlier, `Blazm` uses communication both ways.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，有时JavaScript是唯一的选择，如我之前提到的，`Blazm`使用双向通信。
- en: 'There are three ways of doing a callback from JavaScript to .NET code:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 从JavaScript到.NET代码的回调有三种方式：
- en: A static .NET method call
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 静态.NET方法调用
- en: An instance method call
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实例方法调用
- en: A component instance method call
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 组件实例方法调用
- en: Let’s take a closer look at them.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更仔细地看看它们。
- en: Static .NET method call
  id: totrans-76
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态.NET方法调用
- en: To call a .NET function from JavaScript, we can make the function static, and
    we also need to add the `JSInvokable` attribute to the method.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 要从JavaScript调用.NET函数，我们可以使函数静态，并且还需要将`JSInvokable`属性添加到方法上。
- en: 'We can add a function such as this in the `code` section of a Razor component,
    or inside a class:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以在Razor组件的`code`部分或类内部添加一个这样的函数：
- en: '[PRE7]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the JavaScript file, we can call that function using the following code:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在JavaScript文件中，我们可以使用以下代码调用该函数：
- en: '[PRE8]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The `DotNet` object comes from the `Blazor.js` or `blazor.server.js` file.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: '`DotNet`对象来自`Blazor.js`或`blazor.server.js`文件。'
- en: '`BlazorWebAssemblySample` is the name of the assembly, and `ReturnArrayAsync`
    is the name of the static .NET function.'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`BlazorWebAssemblySample`是程序集的名称，`ReturnArrayAsync`是静态.NET函数的名称。'
- en: 'It is also possible to specify the name of the function in the `JSInvokeable`
    attribute if we don’t want it to be the same as the method name like this:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们不想让函数名与方法名相同，我们也可以在`JSInvokeable`属性中指定函数名，如下所示：
- en: '[PRE9]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In this sample, JavaScript calls back to .NET code, which returns an `int` array.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例中，JavaScript回调到.NET代码，该代码返回一个`int`数组。
- en: It is returned as a promise in the JavaScript file that we are waiting for,
    and then (using the `then` operator) we continue with the execution, adding a
    `4` to the array and then outputting the values in the console.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 它在JavaScript文件中以promise的形式返回，我们等待它，然后（使用`then`运算符）继续执行，将`4`添加到数组中，然后在控制台输出值。
- en: Instance method call
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实例方法调用
- en: This method is a bit tricky; we need to pass an instance of the .NET object
    to call it (this is the method that `Blazm.Bluetooth` is using).
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 这个方法有点棘手；我们需要传递.NET对象的实例来调用它（这是`Blazm.Bluetooth`使用的方法）。
- en: 'First, we need a class that will handle the method call:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要一个类来处理方法调用：
- en: '[PRE10]'
  id: totrans-91
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This class takes a string (a name) in the constructor and a method called `SayHello`
    that returns a string containing `"Hello,"` and the name we supplied when we created
    the instance.
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类在构造函数中接受一个字符串（一个名字）和一个名为`SayHello`的方法，该方法返回一个包含`"Hello,"`和我们在创建实例时提供的名字的字符串。
- en: So, we need to create an instance of that class, supply a name, and create `DotNetObjectReference<T>`,
    which will give JavaScript access to the instance.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们需要创建这个类的实例，提供一个名字，并创建`DotNetObjectReference<T>`，这将使JavaScript能够访问这个实例。
- en: 'But first, we need JavaScript that can call the .NET function:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 但首先，我们需要能够调用.NET函数的JavaScript：
- en: '[PRE11]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: In this case, we are using the export syntax, and we export a function called
    `sayHello`, which takes an instance of `DotNetObjectReference` called `dotnetHelper`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用导出语法，并导出一个名为`sayHello`的函数，它接受一个名为`dotnetHelper`的`DotNetObjectReference`实例。
- en: In that instance, we invoke the `SayHello` method, which is the `SayHello` method
    on the .NET object. In this case, it will reference an instance of the `HelloHelper`
    class.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在该实例中，我们调用`SayHello`方法，这是.NET对象上的`SayHello`方法。在这种情况下，它将引用`HelloHelper`类的一个实例。
- en: 'We also need to call the JavaScript method, and we can do that from a class
    or, in this case, from a component:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要调用JavaScript方法，我们可以从一个类或，在这种情况下，从一个组件中这样做：
- en: '[PRE12]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Let’s go through the class. We inject `IJSRuntime` because we need one to call
    the JavaScript function. To avoid any memory leaks, we also have to make sure
    to implement `IDisposable` interface, and toward the bottom of the file, we make
    sure to dispose of the `DotNetObjectReference` instance.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看这个类。我们注入`IJSRuntime`，因为我们需要它来调用JavaScript函数。为了避免任何内存泄漏，我们还需要确保实现`IDisposable`接口，并在文件的底部确保销毁`DotNetObjectReference`实例。
- en: We create a private variable of the `DotNetObjectReference<HelloHelper>` type,
    which is going to contain our reference to our `HelloHelper` instance. We create
    `IJSObjectReference` so that we can load our JavaScript function.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们创建一个`DotNetObjectReference<HelloHelper>`类型的私有变量，它将包含我们对`HelloHelper`实例的引用。我们创建`IJSObjectReference`以便我们可以加载我们的JavaScript函数。
- en: Then, we create an instance of `DotNetObjectReference.Create(new HelloHelper("Bruce
    Wayne"))` of our reference to a new instance of the `HelloHelper` class, which
    we supply with the name `"Bruce Wayne"`.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`DotNetObjectReference.Create(new HelloHelper("Bruce Wayne"))`的新实例，它是我们对`HelloHelper`类的新实例的引用，我们向其提供名字`"Bruce
    Wayne"`。
- en: Now, we have `objRef`, which we will send to the JavaScript method, but first,
    we load the JavaScript module, and then we call `JavaScriptMethod` and pass in
    the reference to our `HelloHelper` instance. Now, the JavaScript `sayHello` method
    will run `hellohelperref.invokeMethodAsync('SayHello')`, which will make a call
    to `SayHelloHelper` and get back a string with `"Hello, Bruce Wayne"`.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们有`objRef`，我们将将其发送到JavaScript方法，但首先，我们加载JavaScript模块，然后调用`JavaScriptMethod`并传入我们的`HelloHelper`实例的引用。现在，JavaScript的`sayHello`方法将运行`hellohelperref.invokeMethodAsync('SayHello')`，这将调用`SayHelloHelper`并返回一个包含`"Hello,
    Bruce Wayne"`的字符串。
- en: There are two more ways that we can use to call .NET functions from JavaScript.
    We can call a method on a component instance where we can trigger an action, but
    it is not a recommended approach for Blazor Server. We can also call a method
    on a component instance by using a `helper` class.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以使用两种其他方法从 JavaScript 调用 .NET 函数。我们可以在组件实例上调用一个方法来触发一个动作，但这不是 Blazor Server
    的推荐方法。我们还可以通过使用 `helper` 类在组件实例上调用一个方法。
- en: Since calling .NET from JavaScript is rare, we won’t go into the two examples.
    Instead, we’ll dive into things to think about when implementing an existing JavaScript
    library.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 由于从 JavaScript 调用 .NET 很少见，我们不会深入探讨两个示例。相反，我们将深入了解实现现有 JavaScript 库时需要考虑的事项。
- en: Implementing an existing JavaScript library
  id: totrans-106
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现现有的 JavaScript 库
- en: The best approach, in my opinion, is to avoid porting JavaScript libraries.
    Blazor needs to keep the DOM and the render tree in sync, and having JavaScript
    manipulate the DOM can jeopardize that.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 在我看来，最好的方法是不移植 JavaScript 库。Blazor 需要保持 DOM 和渲染树的同步，而让 JavaScript 操作 DOM 可能会危及这一点。
- en: Most component vendors, such as Telerik, Synfusion, Radzen, and, of course,
    `Blazm`, have native components. They don’t just wrap JavaScript but are explicitly
    written for Blazor in C#. Even though the components use JavaScript in some capacity,
    the goal is to keep that to a minimum.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数组件供应商，如 Telerik、Synfusion、Radzen，当然还有 `Blazm`，都有原生组件。它们不仅仅是包装 JavaScript，而是用
    C# 明确为 Blazor 编写的。即使这些组件在某种程度上使用 JavaScript，目标也是将其保持在最低限度。
- en: So, if you are a library maintainer, my recommendation would be to write a native
    Blazor version of the library, keep JavaScript to a minimum, and, most importantly,
    not force Blazor developers to write JavaScript to use your components.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果您是库维护者，我的建议是编写一个本地的 Blazor 版本的库，尽量减少 JavaScript 的使用，最重要的是，不要强迫 Blazor 开发者编写
    JavaScript 来使用您的组件。
- en: Some components will be unable to use JavaScript implementations since they
    need to manipulate the DOM.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 一些组件将无法使用 JavaScript 实现，因为它们需要操作 DOM。
- en: Blazor is pretty smart when syncing the DOM and render tree, but try to avoid
    manipulating the DOM. If you need to use JavaScript for something, make sure to
    put an HTML tag outside the manipulation area, and Blazor will then keep track
    of that tag and not think about what is inside the tag.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: Blazor 在同步 DOM 和渲染树方面相当智能，但尽量避免操作 DOM。如果您需要使用 JavaScript 做某事，请确保将 HTML 标签放在操作区域之外，然后
    Blazor 将跟踪该标签，而不会考虑标签内部的内容。
- en: Since we started using Blazor at my workplace very early, many vendors had not
    yet come out with Blazor components. We needed a graph component fast. On our
    previous website (before Blazor), we used a component called **Highcharts**.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们在工作场所很早就开始使用 Blazor，许多供应商还没有推出 Blazor 组件。我们需要一个图表组件，而且要快。在我们的上一个网站（Blazor
    之前），我们使用了一个名为 **Highcharts** 的组件。
- en: '`Highcharts` is free to use for non-commercial projects. When building our
    wrapper, we had a couple of things we wanted to ensure. We wanted the component
    to work in a similar way to the existing one, and we wanted it to be as simple
    to use as possible.'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: '`Highcharts` 可以免费用于非商业项目。在构建我们的包装器时，我们有一些想要确保的事情。我们希望组件的工作方式与现有的类似，并且我们希望它尽可能简单易用。'
- en: Let’s walk through what we did.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下我们做了什么。
- en: 'First, we added a reference to the `Highcharts` JavaScript:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们添加了对 `Highcharts` JavaScript 的引用：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, we added a JavaScript file as follows:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们添加了一个 JavaScript 文件，如下所示：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `loadHighchart` method takes `id` of the `div` tag, which should be converted
    into a chart, and the JSON for configuration.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`loadHighchart` 方法接受要转换为图表的 `div` 标签的 `id` 和配置的 JSON。'
- en: There is also a method that converts the JSON into a JSON object so that it
    can be passed into the `chart` method.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 也有一种方法可以将 JSON 转换为 JSON 对象，以便它可以传递给 `chart` 方法。
- en: 'The `Highchart` Razor component looks like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: '`Highchart` Razor 组件看起来是这样的：'
- en: '[PRE15]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'The important thing to notice here is that we have two nested `div` tags: one
    on the outside that we want Blazor to track and one on the inside that Highcharts
    will add things to.'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的重要事情是我们有两个嵌套的 `div` 标签：一个在外面，我们希望 Blazor 跟踪；一个在里面，Highcharts 将添加内容。
- en: We pass a JSON parameter in the JSON for the configuration and then call our
    JavaScript function. We run our JavaScript interop in the `OnAfterRenderAsync`
    method because, otherwise, it would throw an exception, as you may recall from
    *Chapter 4*, *Understanding Basic Blazor Components*.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在配置的 JSON 中传递一个 JSON 参数，然后调用我们的 JavaScript 函数。我们在 `OnAfterRenderAsync` 方法中运行我们的
    JavaScript 互操作，因为否则它可能会抛出异常，正如您可能从第 4 章*理解基本 Blazor 组件*中回忆的那样。
- en: 'Now, the only thing left to do is to use the component, and that looks like
    this:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，唯一剩下的事情就是使用组件，它看起来像这样：
- en: '[PRE16]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This test code will show a pie chart that looks like *Figure 10.1*:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试代码将显示一个看起来像*图 10.1*的饼图：
- en: '![A yellow and black pie chart  Description automatically generated](img/B21849_10_01.png)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![一个黄色和黑色的饼图 描述自动生成](img/B21849_10_01.png)'
- en: 'Figure 10.1: Chart example'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 图 10.1：图表示例
- en: We have now gone through how we got a JavaScript library to work with Blazor,
    so this is an option if there is something we need.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经了解了如何使 JavaScript 库与 Blazor 一起工作，所以如果需要，这是一个选项。
- en: As mentioned, component vendors are investing in Blazor, so chances are that
    they have what we need, so we might not need to invest time in creating our own
    component library.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 正如之前提到的，组件供应商正在投资 Blazor，因此他们可能已经拥有了我们所需要的，所以我们可能不需要在创建自己的组件库上投入时间。
- en: JavaScript interop in WebAssembly
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: WebAssembly 中的 JavaScript 互操作
- en: All the things mentioned so far in this chapter will work great for Blazor Server
    and Blazor WebAssembly.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提到的所有内容都将非常适合 Blazor Server 和 Blazor WebAssembly。
- en: But with Blazor WebAssembly, we have direct access to the `JSRuntime` (since
    all the code is running inside the browser). Direct access will give us a really
    big performance boost. For most applications, we are doing one or two JavaScript
    calls. Performance is not really going to be a problem. Some applications are
    more JavaScript-heavy though and would benefit from using the `JSRuntime` directly.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 但在 Blazor WebAssembly 中，我们直接访问 `JSRuntime`（因为所有代码都在浏览器内部运行）。直接访问将给我们带来巨大的性能提升。对于大多数应用程序，我们只进行一到两次
    JavaScript 调用。性能实际上不会成为问题。但是，有些应用程序更侧重于 JavaScript，因此直接使用 `JSRuntime` 会更有益。
- en: We have had direct access to the `JSRuntime` using the `IJSInProcessRuntime`
    and `IJSUnmarshalledRuntime`. But with .NET 7, both are now obsolete, and we have
    gotten a nicer syntax.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经通过使用 `IJSInProcessRuntime` 和 `IJSUnmarshalledRuntime` 直接访问了 `JSRuntime`。但是，从
    .NET 7 开始，这两个都已成为过时，我们现在有了更简洁的语法。
- en: In the GitHub repository, I have added a couple of files to the `SharedComponents`
    project if you want to try the code.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 在 GitHub 仓库中，我向 `SharedComponents` 项目添加了一些文件，如果您想尝试代码。
- en: We will start by looking at calling JavaScript from .NET. Please note that since
    our project is prerendering on the server, these code samples will not work (since
    they don’t work when running on the server). These samples must run in a WebAssembly-only
    project or disable the prerendering. They are included in the source code on GitHub
    for reference.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先探讨如何在 .NET 中调用 JavaScript。请注意，由于我们的项目在服务器端进行预渲染，这些代码示例将无法工作（因为它们在服务器上运行时不会工作）。这些示例必须在仅使用
    WebAssembly 的项目中运行或禁用预渲染。它们包含在 GitHub 上的源代码中供参考。
- en: 'To be able to use these features, we need to enable them in the project file
    by enabling `AllowUnsafeBlocks`:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 为了能够使用这些功能，我们需要在项目文件中启用它们，通过启用 `AllowUnsafeBlocks`：
- en: '[PRE17]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: .NET to JavaScript
  id: totrans-140
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: .NET 到 JavaScript
- en: To show the difference, the following sample is the same `ShowAlert` function
    as earlier in the chapter.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 为了展示差异，以下示例是本章前面提到的相同的 `ShowAlert` 函数。
- en: 'The Razor file looks like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 文件看起来像这样：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'We are using `JSHost` to import the JavaScript and give it the name `"nettojs"`.
    A source generator generates the implementation for calling the JavaScript, and
    to be sure that it can pick up what it should do, we need to add some code in
    a code-behind. We will go into more depth on source generators in *Chapter 17*,
    *Examining Source Generators*. The code-behind looks like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `JSHost` 来导入 JavaScript 并将其命名为 `"nettojs"`。源生成器生成调用 JavaScript 的实现，并且为了确保它能识别出它应该做什么，我们需要在代码后添加一些代码。我们将在第
    17 章*检查源生成器*中更深入地探讨源生成器。代码后看起来像这样：
- en: '[PRE19]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The JavaScript file looks like this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: JavaScript 文件看起来像这样：
- en: '[PRE20]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We add a `JSImport` attribute to a method, which will automatically be mapped
    to the JavaScript call.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在方法上添加一个 `JSImport` 属性，它将自动映射到 JavaScript 调用。
- en: This is a much nicer implementation, I think, and a lot faster.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 我认为这是一个更优雅的实现，并且速度更快。
- en: Next, we will look at calling .NET from JavaScript.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将探讨如何从 JavaScript 调用 .NET。
- en: JavaScript to .NET
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: JavaScript 到 .NET
- en: When calling a .NET method from JavaScript, a new attribute makes that possible
    called `JSExport`.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 当从 JavaScript 调用一个 .NET 方法时，有一个新的属性可以实现这一功能，称为 `JSExport`。
- en: 'The Razor file implementation looks like this:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: Razor 文件实现如下：
- en: '[PRE21]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Calling `JSHost.ImportAsync` is not necessary for the `JSExport` part of the
    demo, but we need it to call JavaScript so that we can make the .NET call from
    JavaScript.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在演示的 `JSExport` 部分中，调用 `JSHost.ImportAsync` 不是必需的，但我们需要它来调用 JavaScript，以便我们可以从
    JavaScript 中进行 .NET 调用。
- en: 'Similarly, here we need to have the methods in a code-behind class that looks
    like this:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，这里我们需要在代码背后的类中有类似这样的方法：
- en: '[PRE22]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Here, we are using the `SupportedOSPlatform` attribute to ensure that this code
    can only run on a browser.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用 `SupportedOSPlatform` 属性来确保此代码只能在浏览器上运行。
- en: 'The JavaScript portion of this demo looks like this:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 此演示的 JavaScript 部分看起来像这样：
- en: '[PRE23]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: We call the `showMessage` JavaScript function from .NET, and it will then call
    the `setMessage` function.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从 .NET 调用 `showMessage` JavaScript 函数，然后它将调用 `setMessage` 函数。
- en: The `setMessage` function uses the `globalThis` object to access the .NET runtime
    and get access to the `getAssemblyExports` method.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: '`setMessage` 函数使用 `globalThis` 对象来访问 .NET 运行时并获取对 `getAssemblyExports` 方法的访问权限。'
- en: It will retrieve all the exports for our assembly and then run the method. The
    .NET method will return the `"This is a message from .NET"` string and show the
    string in an alert box.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 它将检索我们程序集的所有导出，然后运行该方法。.NET 方法将返回 `"This is a message from .NET"` 字符串，并在一个警告框中显示该字符串。
- en: Even though I prefer not to make any JavaScript calls in my Blazor applications,
    I love having the power to bridge between .NET code and JavaScript code with ease.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我更喜欢不在我的 Blazor 应用程序中调用任何 JavaScript 代码，但我非常喜欢能够轻松地在 .NET 代码和 JavaScript 代码之间建立桥梁的能力。
- en: Summary
  id: totrans-165
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter taught us about calling JavaScript from .NET and calling .NET from
    JavaScript. In most cases, we won’t need to do JavaScript calls, and chances are
    that the Blazor community or component vendors have solved the problem for us.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 本章向我们介绍了从 .NET 调用 JavaScript 以及从 JavaScript 调用 .NET 的方法。在大多数情况下，我们不需要进行 JavaScript
    调用，而且可能性很大，Blazor 社区或组件供应商已经为我们解决了这个问题。
- en: We also looked at how we can port an existing library if needed.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还探讨了如果需要，如何移植现有的库。
- en: In the next chapter, we will continue to look at state management.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将继续探讨状态管理。
- en: Join our community on Discord
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 社区
- en: 'Join our community’s Discord space for discussions with the author and other
    readers:'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 加入我们的 Discord 空间，与作者和其他读者进行讨论：
- en: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/WebDevBlazor3e](https://packt.link/WebDevBlazor3e)'
- en: '![](img/QR_Code2668029180838459906.png)'
  id: totrans-172
  prefs: []
  type: TYPE_IMG
  zh: '![二维码](img/QR_Code2668029180838459906.png)'
