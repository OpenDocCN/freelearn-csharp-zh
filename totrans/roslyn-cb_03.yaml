- en: Writing IDE Code Fixes, Refactorings, and Intellisense Completion Providers
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编写 IDE 代码修复、重构和智能感知完成提供者
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下食谱：
- en: Creating, debugging, and executing a `CodeFixProvider` to fix a compiler warning
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建、调试和执行 `CodeFixProvider` 以修复编译器警告
- en: 'Applying batch code fixes (FixAll) across different scopes: document, project,
    and solution'
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在不同的作用域（文档、项目、解决方案）中应用批量代码修复（FixAll）
- en: Creating a custom `FixAllProvider` to fix all occurrences of an issue across
    a scope
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个自定义的 `FixAllProvider` 来修复作用域内所有问题的所有出现
- en: Creating a `CodeRefactoringProvider` to refactor source code to recommend using
    C# 7.0 tuples
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `CodeRefactoringProvider` 来重构源代码，推荐使用 C# 7.0 的元组
- en: Creating a `CompletionProvider` to provide additional intellisense items while
    editing code
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建一个 `CompletionProvider` 以在编辑代码时提供额外的智能感知项
- en: Writing unit tests for a `` `CodeFixProvider` ``
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为 `` `CodeFixProvider` `` 编写单元测试
- en: Introduction
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Code fix providers and code refactoring providers are extensions to the Visual
    Studio IDE to edit the user source code to fix issues and refactor it without
    introducing functional changes respectively. Users see a light bulb in the code
    editor to invoke the code action (fix/refactoring) to automatically edit their
    code. Additionally, code fixes can provide FixAll support, which allows fixing
    multiple similar issues across a document, project, or solution with a single
    code action.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 代码修复提供者和代码重构提供者是 Visual Studio IDE 的扩展，用于编辑用户源代码以修复问题并重构它，同时不引入功能更改。用户在代码编辑器中看到灯泡图标，可以调用代码操作（修复/重构）以自动编辑他们的代码。此外，代码修复还可以提供
    FixAll 支持，允许通过单个代码操作修复文档、项目或解决方案中多个类似的问题。
- en: Completion providers are extensions to the Visual Studio IDE to show additional
    completion items in the intellisense completion list when a user is editing source
    code, and to auto-generate code when a user commits a specific completion item.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 完成提供者是 Visual Studio IDE 的扩展，用于在用户编辑源代码时在智能感知完成列表中显示额外的完成项，并在用户提交特定完成项时自动生成代码。
- en: This chapter enables C# developers to write, debug, execute, and test these
    IDE extensions.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使 C# 开发者能够编写、调试、执行和测试这些 IDE 扩展。
- en: Creating, debugging, and executing a CodeFixProvider to fix a compiler warning
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建、调试和执行 `CodeFixProvider` 以修复编译器警告
- en: Code fix providers are IDE extensions to fix diagnostics in source code, which
    are reported by compilers and/or analyzers. These are built on top of Roslyn's
    Workspaces layer and operate on the current document being edited. When the user
    invokes a command such as *Ctrl* + dot in Visual Studio editor, the IDE code fix
    engine computes all the diagnostics in the current line span and identifies all
    the code fix providers that have registered to fix one or more of the reported
    diagnostics. Each of these code fix providers are then invoked with a code fix
    context containing the current document, diagnostics, and span. Fixers operate
    on the underlying syntax tree associated with the document by adding, removing,
    or editing the syntax nodes within the tree, and returning the new document with
    the fixed code. They might also alter the contents of the containing project or
    solution to fix the diagnostic. When the user commits the fix by pressing the
    *Enter* key, the code fix engine applies this code fix to the user code.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 代码修复提供者是 IDE 扩展，用于修复源代码中的诊断，这些诊断由编译器和分析器报告。这些是在 Roslyn 的 Workspaces 层之上构建的，并操作于正在编辑的当前文档。当用户在
    Visual Studio 编辑器中调用如 *Ctrl* + 点的命令时，IDE 代码修复引擎计算当前行跨度中的所有诊断，并识别所有已注册修复一个或多个报告的诊断的代码修复提供者。然后，每个代码修复提供者都会使用包含当前文档、诊断和跨度的代码修复上下文被调用。修复器通过在树中添加、删除或编辑语法节点来操作与文档关联的底层语法树，并返回带有修复代码的新文档。它们还可能更改包含的项目或解决方案的内容以修复诊断。当用户通过按
    *Enter* 键提交修复时，代码修复引擎将此代码修复应用于用户代码。
- en: 'In this section, we will write a `CodeFixProvider` to fix the compiler warning
    *CS0219* ([https://docs.microsoft.com/en-us/dotnet/csharp/misc/cs0219](https://docs.microsoft.com/en-us/dotnet/csharp/misc/cs0219))
    (the variable `variable` is assigned but its value is never used). For example,
    the following code sample contains two unused variables `a` and `b` and the code
    fix will remove the local declaration statement with unused variable `a` and remove
    the declaration `b = 1` in the next declaration statement:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: '在本节中，我们将编写一个`CodeFixProvider`来修复编译器警告*CS0219* ([https://docs.microsoft.com/en-us/dotnet/csharp/misc/cs0219](https://docs.microsoft.com/en-us/dotnet/csharp/misc/cs0219))（变量`variable`被赋值但从未使用过）。例如，以下代码示例包含两个未使用的变量`a`和`b`，代码修复将删除带有未使用变量`a`的局部声明语句，并在下一个声明语句中删除声明`b
    = 1`:'
- en: '[PRE0]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Getting ready
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have Visual Studio 2017 installed on your machine to execute
    the recipes in this chapter. You can install a free community version of Visual
    Studio 2017 from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的机器上安装Visual Studio 2017才能执行本章中的食谱。你可以从[https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)安装免费的Visual
    Studio 2017社区版。
- en: Additionally, you can refer to the recipe, *Creating, debugging, and executing
    an analyzer project in Visual Studio,* from [Chapter 1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml),
    *Writing Diagnostic Analyzers,* to install the analyzer + code fix project templates
    and create a default project from the template, say `CSharpAnalyzers`.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以参考[第1章](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml)中的食谱，*在Visual Studio中创建、调试和执行分析器项目*，来安装分析器+代码修复项目模板，并从模板创建一个默认项目，例如`CSharpAnalyzers`。
- en: How to do it...
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open `CSharpAnalyzers.sln` in Visual Studio and open source file `CodeFixProvider.cs`
    in the project `CSharpAnalyzers`.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`CSharpAnalyzers.sln`解决方案，并打开项目`CSharpAnalyzers`中的源文件`CodeFixProvider.cs`。
- en: 'Change the `title` of the code fix provider from `"Make Uppercase"` to `"Remove
    unused local"` and change `FixableDiagnosticIds` property to return `"CS0219"`
    instead of `CSharpAnalyzersAnalyzer.DiagnosticId`:'
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '将代码修复提供者的`title`从`"Make Uppercase"`更改为`"Remove unused local"`，并将`FixableDiagnosticIds`属性更改为返回`"CS0219"`而不是`CSharpAnalyzersAnalyzer.DiagnosticId`:'
- en: '![](img/b14ad973-4d84-4f17-ba87-3c8d3ed90745.png)'
  id: totrans-22
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b14ad973-4d84-4f17-ba87-3c8d3ed90745.png)'
- en: Replace the implementation of the `RegisterCodeFixesAsync` method with the code
    from `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CodeFixProvider.cs/` method
    named `RegisterCodeFixesAsync`***.***
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`RegisterCodeFixesAsync`方法的实现替换为来自`CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CodeFixProvider.cs/`中名为`RegisterCodeFixesAsync`***.***的代码。
- en: Add the helper methods `GetSyntaxNodeToRemoveAsync` and `RemoveDeclarationAsync`
    to the source file with the code from `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CodeFixProvider.cs`.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将辅助方法`GetSyntaxNodeToRemoveAsync`和`RemoveDeclarationAsync`添加到源文件中，文件内容来自`CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CodeFixProvider.cs`。
- en: Set breakpoints at the first line of the newly added methods `RegisterCodeFixesAsync`
    and `RemoveDeclarationAsync`.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新添加的方法`RegisterCodeFixesAsync`和`RemoveDeclarationAsync`的第一行设置断点。
- en: Set `CSharpAnalyzers.Vsix` as the startup project and press *F5* to start a
    new VS instance with the code fix provider enabled.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CSharpAnalyzers.Vsix`设置为启动项目，并按*F5*启动一个新的带有代码修复提供者启用的VS实例。
- en: 'In the new VS instance, create a new C# class library project, say `ClassLibrary`,
    and replace the existing code with the following:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的VS实例中，创建一个新的C#类库项目，例如`ClassLibrary`，并用以下代码替换现有代码：
- en: '[PRE1]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Put the cursor on the line `int a = 0;` and verify the breakpoint in `RegisterCodeFixesAsync`
    is hit. Remove this breakpoint and then you can either step through the method
    with *F10* or hit *F5* to continue execution.
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标放在`int a = 0;`这一行上，并验证`RegisterCodeFixesAsync`中的断点是否被触发。移除此断点后，你可以使用*F10*单步执行方法，或者按*F5*继续执行。
- en: 'Verify that the light bulb shows up with a hyperlink to `Show potential fixes`
    under the source line:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证在源行下方是否出现灯泡图标，并带有指向`显示潜在修复`的超链接：
- en: '![](img/928633a8-24e6-4b64-93d8-7c20f4b70d45.png)'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![](img/928633a8-24e6-4b64-93d8-7c20f4b70d45.png)'
- en: Click on the light bulb and verify the breakpoint in `RemoveDeclarationAsync`
    is hit. Remove this breakpoint and then you can either step through the method
    with *F10* or hit *F5* to continue execution.
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击灯泡图标，并验证`RemoveDeclarationAsync`中的断点是否被触发。移除此断点后，你可以使用*F10*单步执行方法，或者按*F5*继续执行。
- en: 'Click on the light bulb again and verify the Remove unused local code fix is
    offered with a preview of code change by the fix:'
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次单击灯泡并验证是否提供了移除未使用局部代码的修复，并提供修复的代码更改预览：
- en: '![](img/bbfa27ab-026c-4464-b5f7-76ce55936776.png)'
  id: totrans-34
  prefs: []
  type: TYPE_IMG
  zh: '![](img/bbfa27ab-026c-4464-b5f7-76ce55936776.png)'
- en: Hit enter to apply the code fix and verify that the unused local declaration
    statement is removed.
  id: totrans-35
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按下回车键应用代码修复并验证未使用的局部声明语句已被删除。
- en: 'Move the cursor to unused local `b` and press keys *Ctrl* + dot and verify
    the same code fix is offered, and applying the fix removes the declaration `b
    = 1`*,* but retains the local declaration for `c`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标移至未使用的局部变量 `b` 并按 *Ctrl* + 点键，验证是否提供了相同的代码修复，并应用修复删除声明 `b = 1`，但保留 `c` 的局部声明：
- en: '![](img/8c2aa0d1-a42b-4644-95ef-24269c67e304.png)'
  id: totrans-37
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8c2aa0d1-a42b-4644-95ef-24269c67e304.png)'
- en: Verify that no code fixes are offered for a local `d` with a non-constant initializer
    and local `e` with a different compiler error.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证对于具有非常量初始化器的局部 `d` 和具有不同编译器错误的局部 `e`，没有提供代码修复。
- en: How it works...
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Code fix providers are VS IDE extensions that can register code actions for
    fixing compiler or analyzer diagnostics of specified diagnostic IDs. The primary
    APIs on `CodeFixProvider` are:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 代码修复提供者是 VS IDE 扩展，可以注册用于修复指定诊断 ID 的编译器或分析器诊断的代码操作。`CodeFixProvider` 上的主要 API
    是：
- en: '`FixableDiagnosticIds` property (abstract): An immutable array of diagnostics
    IDs that the code fix provider can fix. Any compiler or analyzer diagnostic that
    is reported with one of the specified diagnostic IDs is a candidate for a code
    fix from the provider, and `RegisterCodeFixesAsync` is called with each such diagnostic.'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FixableDiagnosticIds` 属性（抽象）：一个不可变的诊断 ID 数组，代码修复提供者可以修复。任何报告了指定诊断 ID 之一的编译器或分析器诊断都是提供者的代码修复的候选者，并且对于每个此类诊断都会调用
    `RegisterCodeFixesAsync`。'
- en: '`RegisterCodeFixesAsync` method (abstract): This is the method to register
    code actions for fixable diagnostics. This method is invoked by the code fix engine
    whenever it needs to compute the code actions for diagnostics reported on a current
    source line in the VS IDE. This method takes a `CodeFixContext` argument, which
    contains a set of one or more diagnostics to be fixed for a given diagnostic span
    and document. All the diagnostics in the context have a fixable diagnostic ID.
    The `CodeFixProvider` can map the diagnostic span to the syntax node in the document
    and analyze it to register one or more code actions to fix one or more diagnostics
    in the context. `CodeAction` contains the following primary members:'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RegisterCodeFixesAsync` 方法（抽象）：这是用于注册可修复诊断的代码操作的函数。每当代码修复引擎需要计算 VS IDE 中当前源行报告的诊断的代码操作时，都会调用此方法。此方法接受一个
    `CodeFixContext` 参数，它包含一组要修复给定诊断范围和文档的诊断。上下文中的所有诊断都有一个可修复的诊断 ID。`CodeFixProvider`
    可以将诊断范围映射到文档中的语法节点，并分析它以注册一个或多个代码操作来修复上下文中的一个或多个诊断。`CodeAction` 包含以下主要成员：'
- en: '`Title` property: This is the string that shows up with the light bulb when
    the code fix is offered.'
  id: totrans-43
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Title` 属性：这是当提供代码修复时显示在灯泡旁边的字符串。'
- en: '`Callback` method: This is the delegate to be called back when the user applies
    a registered code action. This method returns the changed document or solution
    and the code fix engine applies the changes to the workspace.'
  id: totrans-44
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Callback` 方法：这是当用户应用已注册的代码操作时将被调用的委托。此方法返回更改后的文档或解决方案，代码修复引擎将更改应用到工作区。'
- en: '`EquivalenceKey` property: This is the string representing the equivalence
    class of code actions that this code action belongs to. If the code fix provider
    supports `FixAllProvider`, then a FixAll code fix batches all code actions in
    the equivalence class of the invoked code action and fixes all of them simultaneously.'
  id: totrans-45
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EquivalenceKey` 属性：这是表示此代码操作所属的代码操作等价类的字符串。如果代码修复提供者支持 `FixAllProvider`，则
    FixAll 代码修复将批处理调用代码操作的等价类中的所有代码操作，并同时修复它们。'
- en: '`GetFixAllProviderAsync` method (virtual): Code fix providers can optionally
    override this method and return a non-null `FixAllProvider` if they want FixAll
    support for their code actions. We will discuss this in more detail in the next
    recipe.'
  id: totrans-46
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetFixAllProviderAsync` 方法（虚拟）：代码修复提供者可以选择覆盖此方法，并在需要为他们的代码操作提供 FixAll 支持时返回一个非空的
    `FixAllProvider`。我们将在下一道菜中更详细地讨论这个问题。'
- en: '`CodeFixProvider` implemented in this recipe has a single fixable diagnostic
    ID: `CS0219`, a compiler diagnostic flagging unused local variable declarations.
    Let''s expand on the implementation details of `RegisterCodeFixesAsync` override
    and its helpers.'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 本食谱中实现的 `CodeFixProvider` 有一个可修复的诊断 ID：`CS0219`，这是一个编译器诊断，标记未使用的局部变量声明。让我们详细说明
    `RegisterCodeFixesAsync` 覆盖及其辅助函数的实现细节。
- en: 'The first part of `RegisterCodeFixesAsync` computes a syntax node to remove
    for the variable that was flagged by invoking `GetNodeToRemoveAsync`*,* and bails
    out if we get a null node:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`RegisterCodeFixesAsync` 的第一部分计算要删除的语法节点，该节点是通过调用 `GetNodeToRemoveAsync`*标记*的变量，如果得到一个空节点，则退出：'
- en: '[PRE2]'
  id: totrans-49
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The initial part of `GetNodeToRemoveAsync` computes the syntax node that was
    flagged by the diagnostic:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetNodeToRemoveAsync` 的初始部分计算由诊断标记的语法节点：'
- en: '[PRE3]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'We first get the syntax root of the document being fixed. We then find the
    syntax token in the root at the start of the diagnostic span and find the first
    ancestor node of type `VariableDeclaratorSyntax`. For example, consider the following
    local declaration statement:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先获取正在修复的文档的语法根。然后我们在根中找到诊断范围开始的语法标记，并找到第一个 `VariableDeclaratorSyntax` 类型的祖先节点。例如，考虑以下局部声明语句：
- en: '[PRE4]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The entire statement is a `LocalDeclarationStatementSyntax` node. It has a child
    syntax node `VariableDeclarationSyntax`, which represents `int b = 1, c = 2`,
    and the syntax token for the semicolon. The variable declaration syntax node contains
    two variable declarator nodes, each of type `VariableDeclaratorSyntax`, and text
    `b = 1` and `c = 2`, respectively. The `VariableDeclaratorSyntax` node contains
    a token for the `IdentifierName` and a syntax node for the initializer of type
    `EqualsValueClauseSyntax`. `CS0219` is reported on the `IdentifierName` token
    for the unused variable declarator.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 整个语句是一个 `LocalDeclarationStatementSyntax` 节点。它有一个子语法节点 `VariableDeclarationSyntax`，表示
    `int b = 1, c = 2`，以及分号语法标记。变量声明语法节点包含两个变量声明符节点，每个节点都是 `VariableDeclaratorSyntax`
    类型，分别具有文本 `b = 1` 和 `c = 2`。`VariableDeclaratorSyntax` 节点包含一个 `IdentifierName`
    标记和一个类型为 `EqualsValueClauseSyntax` 的初始化器语法节点。`CS0219` 是在未使用的变量声明符的 `IdentifierName`
    标记上报告的。
- en: 'Use the Roslyn [SyntaxVisualizer](https://blogs.msdn.microsoft.com/csharpfaq/2014/04/17/visualizing-roslyn-syntax-trees/)
    to understand the parsed syntax node/tokens for a given C# or VB source code:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 Roslyn [SyntaxVisualizer](https://blogs.msdn.microsoft.com/csharpfaq/2014/04/17/visualizing-roslyn-syntax-trees/)
    来理解给定 C# 或 VB 源代码的解析语法节点/标记：
- en: '![](img/d66f9e4e-ad4e-4532-a35e-cf651484d56f.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/d66f9e4e-ad4e-4532-a35e-cf651484d56f.png)'
- en: 'The next part of `GetNodeToRemoveAsync` implements certain defensive checks
    to bail out early without registering any code action as shown in the following
    code snippet:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetNodeToRemoveAsync` 的下一部分实现了一些防御性检查，以便在不注册任何代码操作的情况下提前退出，如下面的代码片段所示：'
- en: '[PRE5]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: We first bail out if the diagnostic was reported on a token which does not have
    a **`VariableDeclaratorSyntax`** ancestor. We also bail out if the variable initializer
    is a non-constant, as removing it with the code fix can cause functional change
    by not executing the initializer code. Finally, we check if the variable declarator
    has a `VariableDeclarationSyntax` parent, which has a `LocalDeclarationStatementSyntax`
    parent.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 如果诊断是在没有 `VariableDeclaratorSyntax` 祖先的标记上报告的，我们首先退出。如果变量初始化器是一个非常量，因为使用代码修复删除它可能会导致功能变化，不执行初始化器代码。最后，我们检查变量声明符是否有
    `VariableDeclarationSyntax` 父节点，该父节点有一个 `LocalDeclarationStatementSyntax` 父节点。
- en: Defensive checks in the code fix provider are very important checks to protect
    us against an unexpected third-party analyzer reporting diagnostic with same diagnostic
    ID, but on a different syntax node kind to what our fixer expects. We should ensure
    that we gracefully bail out instead of crashing unexpectedly or registering an
    incorrect code fix.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 代码修复提供程序中的防御性检查非常重要，可以保护我们免受意外第三方分析器报告具有相同诊断 ID 但语法节点类型与我们的修复器期望不同的诊断的影响。我们应该确保我们优雅地退出，而不是意外崩溃或注册错误的代码修复。
- en: 'Finally, the method computes and returns the syntax node to be removed by the
    code fix:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该方法通过代码修复计算并返回要删除的语法节点：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We have two cases to cover:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 我们有两个情况要处理：
- en: If the local declaration statement declares only a single variable, then we
    can remove the entire statement. We also cover an additional bail out case where
    a local declaration is not parented by a block statement, in which case, removing
    the local declaration statement will cause a syntax error. Given that the compiler
    already reports a diagnostic *CS1023* (embedded statement cannot be a declaration
    or labeled statement) for this case, we just bail out.
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果局部声明语句只声明了一个变量，那么我们可以删除整个语句。我们还涵盖了一个额外的退出情况，即局部声明不是由块语句父化的，在这种情况下，删除局部声明语句将导致语法错误。鉴于编译器已经为这种情况报告了诊断
    *CS1023*（嵌入语句不能是声明或标记语句），我们只需退出。
- en: Otherwise, if the local declaration statement declares multiple variables, we
    can remove just the variable declarator.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 否则，如果局部声明语句声明了多个变量，我们可以只删除变量声明符。
- en: 'Once we have a non-null syntax node to remove, we register a code fix to remove
    the declaration node:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们有一个要删除的非空语法节点，我们注册一个代码修复来删除声明节点：
- en: '[PRE7]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We create a standard CodeAction, using the `CodeAction.Create` API, with the
    title `Remove unused local`, and use the same equivalance key. We register `RemoveDeclarationAsync`
    as the callback method to be invoked when the user applies the code fix:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `CodeAction.Create` API 创建一个标准的 CodeAction，标题为 `Remove unused local`，并使用相同的等效键。我们将
    `RemoveDeclarationAsync` 注册为当用户应用代码修复时要调用的回调方法：
- en: '[PRE8]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: This method uses the `SyntaxGenerator` helper utility to remove the declaration
    node from the original syntax root and returns the new document created with the
    new syntax root.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法使用 `SyntaxGenerator` 辅助实用工具从原始语法根中删除声明节点，并返回使用新语法根创建的新文档。
- en: '`SyntaxGenerator` is a powerful syntax factory with APIs to add, remove, or
    edit syntax nodes in a language agnostic way. It works for both VB and C# syntax
    nodes, and enables writing code fix providers that fix issues across both languages,
    without requiring language-specific implementations. See [http://source.roslyn.io/#q=SyntaxGenerator](http://source.roslyn.io/#q=SyntaxGenerator)
    for `SyntaxGenerator` reference source.'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: '`SyntaxGenerator` 是一个强大的语法工厂，具有在语言无关的方式中添加、删除或编辑语法节点的 API。它适用于 VB 和 C# 语法节点，并允许编写修复跨两种语言的代码修复提供程序，而无需特定的语言实现。有关
    `SyntaxGenerator` 的参考源，请参阅 [http://source.roslyn.io/#q=SyntaxGenerator](http://source.roslyn.io/#q=SyntaxGenerator)。'
- en: 'Applying batch code fixes (FixAll) across different scopes: document, project,
    and solution'
  id: totrans-72
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在不同作用域（文档、项目、解决方案）中应用批量代码修复（FixAll）
- en: In this section, you will learn how to apply batch code fixes to fix multiple
    instances of similar diagnostics across different scopes. We will apply the FixAll
    code fix for the Make uppercase code fix in the default analyzer + code fix template
    project and fix multiple type names across the document, project, and solution
    scopes so they all contain upper case letters only. We will show you how to invoke
    a FixAll code fix from the editor light bulb, and then use the FixAll preview
    changes dialog to selectively choose the fixes to apply to your solution.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，您将学习如何应用批量代码修复来修复不同作用域中相似诊断的多个实例。我们将应用默认分析器 + 代码修复模板项目中的 FixAll 代码修复，修复文档、项目和解决方案作用域中的多个类型名称，使它们都只包含大写字母。我们将向您展示如何从编辑器灯泡中调用
    FixAll 代码修复，然后使用 FixAll 预览更改对话框来选择性地选择要应用到解决方案中的修复。
- en: Getting ready
  id: totrans-74
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have Visual Studio 2017 installed on your machine to execute
    the recipes in this chapter. You can install a free community version of Visual
    Studio 2017 from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)***.***
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的机器上安装 Visual Studio 2017 以执行本章中的配方。您可以从 [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)
    安装 Visual Studio 2017 的免费社区版本***。
- en: Additionally, you should execute the recipe *Creating, debugging, and executing
    an analyzer project in Visual Studio*, from the first [chapter 1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml),
    *Writing Diagnostic Analyzers* to install the Analyzer + Code fix project templates
    and create a default project from the template, say `CSharpAnalyzers`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您应执行第一个 [第 1 章](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml)，*编写诊断分析器*中的配方
    *Creating, debugging, and executing an analyzer project in Visual Studio*，以安装分析器
    + 代码修复项目模板并从模板创建默认项目，例如 `CSharpAnalyzers`。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open `CSharpAnalyzers.sln` in Visual Studio. Set `CSharpAnalyzers.Vsix` as the
    start-up project and press *F5* to start a new VS instance with the code fix provider
    enabled.
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中打开 `CSharpAnalyzers.sln`。将 `CSharpAnalyzers.Vsix` 设置为启动项目，并按
    *F5* 启动一个新的 VS 实例，其中启用了代码修复提供程序。
- en: 'In the new VS instance, create a new C# class library project, say `ClassLibrary`,
    and replace the existing code with the following:'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 VS 实例中，创建一个新的 C# 类库项目，例如 `ClassLibrary`，并用以下代码替换现有的代码：
- en: '[PRE9]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Add a new source file, say `Class4.cs`, to the project with the following code:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目添加一个新的源文件，例如 `Class4.cs`，并使用以下代码：
- en: '[PRE10]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Add a new C# class library project to the solution, say `ClassLibrary2.csproj`,
    rename the source file to `Class5.cs`**,** and replace its source with the following:'
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将新 C# 类库项目 `ClassLibrary2.csproj` 添加到解决方案中，将源文件重命名为 `Class5.cs`**，**并用以下代码替换其源代码：
- en: '[PRE11]'
  id: totrans-84
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Verify five diagnostics in the error list, one for each class: Type name ''XXX''
    contains lower case letters*.*'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在错误列表中验证五个诊断，每个类一个：类型名称 'XXX' 包含小写字母*.*。
- en: Place the cursor on `Class1`, and hit *Ctrl* + dot to bring up the light bulb
    for code fix Make uppercase**.**
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标放在 `Class1` 上，按 *Ctrl* + 点号以显示代码修复的灯泡“Make uppercase**”。**
- en: '![](img/95a7bcd7-2119-4d85-bb71-7c1172203f81.png)'
  id: totrans-87
  prefs: []
  type: TYPE_IMG
  zh: '![](img/95a7bcd7-2119-4d85-bb71-7c1172203f81.png)'
- en: 'Click on the hyperlink Fix all occurrences in Document to bring up the Preview
    Changes - Fix All Occurrences dialog. Click on the Apply button to apply the Make
    uppercase fix to all types in `Class1.cs`:'
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击超链接“在文档中修复所有实例”以打开预览更改 - 修复所有实例对话框。点击应用按钮将“转换为大写”修复应用到 `Class1.cs` 中的所有类型：
- en: '![](img/be660758-6948-4031-9e2b-71ffcf68fb4f.png)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![](img/be660758-6948-4031-9e2b-71ffcf68fb4f.png)'
- en: Verify that `Class1`, `Class2`*,* and `Class3` are changed to `CLASS1`, `CLASS2`
    and `CLASS3`*,* respectively, but `Class4` and `Class5` are unchanged.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证 `Class1`、`Class2`**、**和 `Class3` 分别更改为 `CLASS1`、`CLASS2` 和 `CLASS3`**、**，但
    `Class4` 和 `Class5` 保持不变。
- en: Press *Ctrl* + *Z* to undo the batch code fix and verify the solution returns
    to the same state as before applying the fix all code fix.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *Z* 撤销批量代码修复，并验证解决方案返回到应用修复之前的状态。
- en: Again press *Ctrl* + dot, but this time click on Fix all occurrences in Project.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按 *Ctrl* + 点号，但这次点击项目中的“修复所有实例”。
- en: 'Uncheck the checkbox next to `public class CLASS2` and verify that `CLASS2`
    is switched back to `Class2` in the preview changes dialog:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中 `public class CLASS2` 旁边的复选框，并验证在预览更改对话框中 `CLASS2` 是否已切换回 `Class2`：
- en: '![](img/f5a86fa7-034e-4577-81aa-493cec472ed8.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f5a86fa7-034e-4577-81aa-493cec472ed8.png)'
- en: Apply the fix and verify that `Class1`, `Class3`, and `Class4` are changed to
    `CLASS1`, `CLASS3`, and `CLASS4`, respectively, but `Class2` and `Class5` are
    unchanged.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用修复并验证 `Class1`、`Class3` 和 `Class4` 分别更改为 `CLASS1`、`CLASS3` 和 `CLASS4`，但 `Class2`
    和 `Class5` 保持不变。
- en: Press *Ctrl* + *Z* to undo the project level code fix and verify changes to
    both source files `Class1.cs` and `Class4.cs` are reverted.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按 *Ctrl* + *Z* 撤销项目级别的代码修复，并验证源文件 `Class1.cs` 和 `Class4.cs` 的更改已回滚。
- en: Again press *Ctrl* + dot, and this time click on Fix all occurrences in Solution.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次按 *Ctrl* + 点号，这次点击解决方案中的“修复所有实例”。
- en: Apply the code fix and verify all five classes are changed to upper case, and
    *Ctrl* + *Z* reverts the changes to all types in the solution.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用代码修复并验证所有五个类都已更改为大写，然后按 *Ctrl* + *Z* 回滚解决方案中所有类型的更改。
- en: Creating a custom FixAllProvider to fix all occurrences of an issue across a
    scope
  id: totrans-99
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个自定义 FixAllProvider 来修复跨作用域内所有问题的所有实例
- en: 'In this section, we will show you how to a write a custom FixAll code fix provider
    to batch fix diagnostics. We will use the code fix implemented in the first recipe
    of this chapter to `Remove unused local`*.* As shown in that recipe, removal of
    an unused local might have different code fixes based on whether the enclosing
    local declaration statement declares a single or multiple variables. Additionally,
    we might have multiple unused locals declared in the single statement, and if
    all the locals declared in a statement are unused, the batch fix should remove
    the entire statement. Hence, we cannot use the well-known batch fixer. For example,
    for the following code, the batch fix should delete the entire first two local
    declaration statements, but only the declarator for `d` in the third declaration
    statement:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何编写一个自定义的FixAll代码修复提供者以批量修复诊断项。我们将使用本章第一个菜谱中实现的代码修复来`Remove unused
    local`*.* 如该菜谱所示，未使用局部变量的移除可能基于封装局部声明语句是否声明了一个或多个变量而具有不同的代码修复。此外，我们可能在单个语句中声明了多个未使用的局部变量，如果语句中声明的所有局部变量都是未使用的，则批量修复应删除整个语句。因此，我们不能使用知名的批量修复器。例如，对于以下代码，批量修复应删除前两个局部声明语句，但仅删除第三个声明语句中的`d`的声明符：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The default well-known `BatchFixer` used by code fixers only works well for
    simple code fixes. For other scenarios, we need to write a custom fix all provider.
    See ([https://github.com/dotnet/roslyn/blob/master/docs/analyzers/FixAllProvider.md](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/FixAllProvider.md))
    for documentation on FixAll providers and limitations of the well-known BatchFixer.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 默认的知名`BatchFixer`仅适用于简单的代码修复。对于其他场景，我们需要编写一个自定义的修复所有提供者。有关FixAll提供者和知名BatchFixer的限制的文档，请参阅([https://github.com/dotnet/roslyn/blob/master/docs/analyzers/FixAllProvider.md](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/FixAllProvider.md))。
- en: Getting ready
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You should execute the first recipe in this chapter, *Creating, debugging and
    executing a code fix provider to fix a compiler warning* to implement a code fix
    provider to `Remove unused local`.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 您应该执行本章的第一个菜谱，*创建、调试和执行一个代码修复提供者以修复编译器警告*来实现一个用于`Remove unused local`的代码修复提供者。
- en: How to do it...
  id: totrans-105
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Open `CSharpAnalyzers.sln` in Visual Studio and add two new source files to
    the project `CSharpAnalyzers`:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio中打开`CSharpAnalyzers.sln`项目，并将两个新的源文件添加到`CSharpAnalyzers`项目中：
- en: '`CustomFixAllProvider.cs`'
  id: totrans-107
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomFixAllProvider.cs`'
- en: '`CustomFixAllCodeAction.cs`'
  id: totrans-108
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`CustomFixAllCodeAction.cs`'
- en: Add code to `CustomFixAllProvider.cs` to implement a custom fix all provider
    from `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CustomFixAllProvider.cs`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`CustomFixAllProvider.cs`中添加代码以实现一个自定义的修复所有提供者，来自`CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CustomFixAllProvider.cs`。
- en: Add code to `CustomFixAllCodeAction.cs` from `CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CustomFixAllCodeAction.cs`
    to implement a custom `CodeAction`, which is returned by `CustomFixAllProvider.GetFixAsync`.
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从`CSharpAnalyzers/CSharpAnalyzers/CSharpAnalyzers/CustomFixAllCodeAction.cs`将代码添加到`CustomFixAllCodeAction.cs`中，以实现一个自定义的`CodeAction`，该`CodeAction`由`CustomFixAllProvider.GetFixAsync`返回。
- en: 'Make the following edits to `CodeFixProvider.cs`:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 对`CodeFixProvider.cs`进行以下修改：
- en: Change `GetNodeToRemoveAsync` to be an internal static method
  id: totrans-112
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`GetNodeToRemoveAsync`修改为一个内部静态方法
- en: Change `GetFixAllProviderAsync` to return a `new CustomFixAllProvider()`
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将`GetFixAllProviderAsync`修改为返回一个`new CustomFixAllProvider()`
- en: Set `CSharpAnalyzers.Vsix` as the start-up project and press *F5* to start a
    new VS instance with the code fix provider enabled.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CSharpAnalyzers.Vsix`设置为启动项目，并按*F5*启动一个新的带有代码修复提供者的VS实例。
- en: 'In the new VS instance, create a new C# class library project, say `ClassLibrary`,
    and replace the existing code with the following:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的VS实例中，创建一个新的C#类库项目，例如`ClassLibrary`，并用以下代码替换现有代码：
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Add a new source file, say `Class2.cs` to the project with the following code:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个新的源文件，例如`Class2.cs`，并添加以下代码：
- en: '[PRE14]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Add a new C# class library project to the solution, say `ClassLibrary2.csproj`,
    rename the source file to `Class3.cs`**,** and replace its source with the following:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的C#类库项目添加到解决方案中，例如`ClassLibrary2.csproj`，将源文件重命名为`Class3.cs`**,**并用以下代码替换其内容：
- en: '[PRE15]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Verify 12 diagnostics in the error list, one for each unused variable across
    the three classes*.*
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在错误列表中验证12个诊断项，每个类中有一个未使用的变量*.*
- en: Place the cursor on local *'a'* in `Class1.cs`, and hit *Ctrl* + dot to bring
    up the light bulb for code fix `Remove unused local`**.**
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标放在`Class1.cs`中的局部变量`'a'`上，然后按*Ctrl* + 点来弹出代码修复`Remove unused local`****的代码提示。**
- en: 'Click on the hyperlink Fix all occurrences in Document to bring up the Preview
    Changes - Fix All Occurrences dialog. Click on the Apply button to apply the Remove
    unused local to remove all four unused locals (*''*`a`*'', ''*`b`*'', ''*`c`*''*
    and *''*`d`*''*) in the `Class1.cs`:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击文档中的超链接“修复所有出现”以打开“预览更改 - 修复所有出现”对话框。点击“应用”按钮以应用“删除未使用局部变量”以删除`Class1.cs`中的所有四个未使用局部变量（`'*a*'`、`'*b*'`、`'*c*'`和`'*d*'`）：
- en: '![](img/ddcdc30c-56a6-4ede-a0e4-c0864b8ff700.png)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ddcdc30c-56a6-4ede-a0e4-c0864b8ff700.png)'
- en: Switch to unused local declarations in `Class2.cs` and attempt to Fix All Occurences
    in the solution/project scope and verify all unused locals are remove in the selected
    scope.
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 切换到`Class2.cs`中的未使用局部声明，并在解决方案/项目范围内尝试修复所有出现，并验证所选范围内所有未使用的局部变量是否已删除。
- en: How it works...
  id: totrans-126
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'FixAll providers are VS IDE extensions that register code actions for batch
    fixes corresponding to code actions registered by a specific code fix provider.
    The primary APIs on `FixAllProvider` are:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: FixAll提供程序是VS IDE扩展，它们注册与特定代码修复提供程序注册的代码操作对应的批量修复的代码操作。`FixAllProvider`上的主要API是：
- en: '`GetSupportedFixAllScopes` property (virtual): This gets the supported scopes
    for fixing all occurrences of a diagnostic. By default, it returns document, project,
    and solution scopes.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetSupportedFixAllScopes`属性（虚拟）：此方法获取修复诊断所有出现的支持的范围。默认情况下，它返回文档、项目和解决方案范围。'
- en: '`GetSupportedFixAllDiagnosticIds` method (virtual): This gets the diagnostic
    IDs for which fix all occurrences is supported. By default, it returns the `FixableDiagnosticIds`
    of the corresponding code fix provider.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetSupportedFixAllDiagnosticIds`方法（虚拟）：此方法获取支持修复所有出现的诊断ID。默认情况下，它返回相应代码修复提供程序的`FixableDiagnosticIds`。'
- en: '`GetFixAsync` method (abstract): This is the primary method that takes a `FixAllContext`
    argument and returns a code action for a batch fix corresponding to `FixAllContext`
    parameters: `CodeFixProvider`, `DiagnosticIds` to fix, `FixAllScope` and `EquivalenceKey`
    for the origin code action.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetFixAsync`方法（抽象）：这是主要方法，它接受一个`FixAllContext`参数，并返回与`FixAllContext`参数对应的批量修复的代码操作：`CodeFixProvider`、要修复的诊断ID、`FixAllScope`和原始代码操作的`EquivalenceKey`。'
- en: The code fix engine invokes the `CodeFixProvider.GetFixAllProviderAsync` method
    to get the optional FixAll provider supported by the code fixer. In our implementation,
    we ensure that we return `CustomFixAllProvider` for this method. Let's expand
    on the implementation details of `CustomFixAllProvider`.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 代码修复引擎调用`CodeFixProvider.GetFixAllProviderAsync`方法以获取代码修复器支持的可选FixAll提供程序。在我们的实现中，我们确保为此方法返回`CustomFixAllProvider`。让我们详细说明`CustomFixAllProvider`的实现细节。
- en: '`CustomFixAllProvider` only overrides the `GetFixAsync` method. The first part
    of `GetFixAsync` computes fix title and the documents to fix for the current `FixAllScope`:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`CustomFixAllProvider`仅覆盖`GetFixAsync`方法。`GetFixAsync`方法的第一部分计算修复标题和当前`FixAllScope`要修复的文档：'
- en: '[PRE16]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Then, we iterate through all the computed documents and compute the diagnostics
    to fix for each document and store them in a map. We return our `CustomFixAllCodeAction`
    with the computed title and diagnostics:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历所有计算出的文档，并为每个文档计算要修复的诊断，并将它们存储在一个映射中。我们返回带有计算标题和诊断的`CustomFixAllCodeAction`：
- en: '[PRE17]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Let's go through the implementation details for `CustomFixAllCodeAction`*.*
    The primary method that the custom code action overrides is `GetChangedSolutionAsync`.
    This method gets the new solution with edits from the batch fix. The code fix
    engine invokes this method when the user attempts to apply the batch fix .
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看一下`CustomFixAllCodeAction`*.*的实现细节。自定义代码操作覆盖的主要方法是`GetChangedSolutionAsync`。此方法获取带有批量修复编辑的新解决方案。当用户尝试应用批量修复时，代码修复引擎会调用此方法。
- en: 'The initial part of `GetChangedSolutionAsync` computes all local declaration
    and variable declarator syntax nodes to remove for each document, in a map named
    `nodesToRemove`, carrying out very basic batching of syntax nodes to fix:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetChangedSolutionAsync`方法的初始部分计算每个文档中要删除的所有本地声明和变量声明符语法节点，在一个名为`nodesToRemove`的映射中，执行非常基本的语法节点批量修复：'
- en: '[PRE18]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The second part tries to identify local declaration statements with multiple
    variable declarations, where all the declared locals are unused, and hence the
    entire statement can be removed. For such cases, we add the local declaration
    statement to `nodesToRemove` and remove all the individual unused variable declarators
    in the local declaration statement from `nodeToRemove` map:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 第二部分试图识别具有多个变量声明的局部声明语句，其中所有声明的局部变量都没有使用，因此整个语句可以被删除。对于这种情况，我们将局部声明语句添加到`nodesToRemove`中，并从`nodeToRemove`映射中移除局部声明语句中的所有单个未使用变量声明符：
- en: '[PRE19]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Finally, we iterate through all the `{Document, HashSet<SyntaxNode>}` pairs
    and for each document compute the new root with all the unused locals removed
    from the entire tree. We create a new document with the new root and apply the
    document change to the latest solution, which is tracked as `newSolution`. At
    the end of the loop, `newSolution` represents the current solution with all document
    changes applied, and is returned by the method:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们遍历所有的`{Document, HashSet<SyntaxNode>}`对，并为每个文档计算一个新的根，其中从整个树中移除了所有未使用的局部变量。我们创建一个新的文档，并使用新的根应用文档更改到最新的解决方案，该解决方案被跟踪为`newSolution`。循环结束时，`newSolution`代表应用了所有文档更改的当前解决方案，并由方法返回：
- en: '[PRE20]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Creating a CodeRefactoringProvider to refactor source code to recommend using
    C# 7.0 tuples
  id: totrans-143
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个`CodeRefactoringProvider`来重构源代码，推荐使用C# 7.0的元组
- en: Code refactoring providers are IDE extensions to refactor source code for better
    code structuring, without affecting the functional or semantic behavior of the
    code. These are built on top of Roslyn's Workspaces layer and operate on the current
    document being edited. When a user invokes a command such as *Ctrl* + dot in Visual
    Studio editor, the IDE code refactoring engine computes all the refactorings that
    can refactor the code in the currently selected text span in the editor. Each
    of these providers are then invoked with a code refactoring context containing
    the current document and span. Refactorings operate on the underlying syntax tree
    associated with the document by adding, removing, or editing the syntax nodes
    within the tree and returning the new document with the refactored code. They
    might also alter the contents of the containing project or solution. When the
    user commits the refactoring by pressing the *Enter* key, the code refactoring
    engine applies this refactoring to the user code.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构提供者是IDE扩展，用于重构源代码以优化代码结构，而不影响代码的功能或语义行为。这些是基于Roslyn的Workspaces层构建的，并操作于正在编辑的当前文档。当用户在Visual
    Studio编辑器中调用如*Ctrl* + 点的命令时，IDE代码重构引擎计算所有可以重构编辑器中当前所选文本跨度内代码的重构。然后，每个提供者都会使用包含当前文档和跨度的代码重构上下文被调用。重构通过在树中添加、删除或编辑语法节点来操作与文档关联的底层语法树，并返回带有重构代码的新文档。它们还可能更改包含的项目或解决方案的内容。当用户通过按*Enter*键提交重构时，代码重构引擎将此重构应用于用户代码。
- en: 'In this section, we will write a `CodeRefactoringProvider` to propose the usage
    of tuple expressions*,* a C# 7.0 feature, in methods returning more than one value.
    Prior to C# 7.0, methods that wanted to return more than one value had the following
    possible implementations:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个`CodeRefactoringProvider`，以建议在返回多个值的函数中使用元组表达式*，*这是一个C# 7.0的特性。在C#
    7.0之前，想要返回多个值的函数有以下可能的实现方式：
- en: Declare a non-void return type of one of the return values and `out` parameters
    for the remaining returned values.
  id: totrans-146
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个非无返回类型的其中一个返回值，并为剩余的返回值声明`out`参数。
- en: Declare a void return type and *out* parameters for each of the returned values.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为每个返回值声明无返回类型和*输出*参数。
- en: Declare a new type wrapping these values as fields, and return an instance of
    that type.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 声明一个新的类型，将这些值作为字段封装，并返回该类型的实例。
- en: 'With C# 7.0, the recommended implementation is to declare a tuple return type
    with elements defined for types of each of the returned values and have no out
    parameters. We will write a refactoring to identify the existing code with pattern
    1 earlier and recommend a refactoring to use tuples. For example, consider the
    following methods returning multiple return values:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 7.0中，推荐的实现方式是声明一个元组返回类型，并为每个返回值的类型定义元素，并且没有输出参数。我们将编写一个重构来识别之前提到的模式1的现有代码，并推荐使用元组的重构。例如，考虑以下返回多个返回值的函数：
- en: '[PRE21]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Our code refactoring will offer to convert these methods to:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的代码重构将提供将这些方法转换为：
- en: '[PRE22]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have Visual Studio 2017 installed on your machine to execute
    the recipes in this chapter. You can install a free community version of Visual
    Studio 2017 from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)***.***
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要在你的机器上安装 Visual Studio 2017 来执行本章中的配方。你可以从 [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)
    安装免费的 Visual Studio 2017 社区版本***。***
- en: Additionally, you should have installed the .NET Compiler Platform SDK to get
    the `CodeRefactoring` project template. For reference, see the recipe, *Creating,
    debugging, and executing an analyzer project in Visual Studio*, in [Chapter 1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml),
    *Writing Diagnostic Analyzers.*
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你应该已经安装了 .NET 编译器平台 SDK 来获取 `CodeRefactoring` 项目模板。有关参考，请参阅第 1 章 *编写诊断分析器*
    中的配方，*在 Visual Studio 中创建、调试和执行分析器项目*，在 [Chapter 1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml)。
- en: By default, the `CodeRefactoring` project template targets *.NET Portable v4.5*
    and references version *1.0.1* of `Microsoft.CodeAnalysis` packages. As we intend
    to use the C# 7.0 syntax, we need to upgrade the `CodeAnalysis` packages to version
    2.0.0 or later, which are based on .NET Standard and hence require the referencing
    project to be based on .NET standard templates or target .NET Framework v4.6 or
    higher. For this recipe, we change the project to target .NET Framework v4.6.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`CodeRefactoring` 项目模板针对 *.NET Portable v4.5* 并引用 `Microsoft.CodeAnalysis`
    包的 *1.0.1* 版本。由于我们打算使用 C# 7.0 语法，我们需要将 `CodeAnalysis` 包升级到 2.0.0 或更高版本，这些版本基于
    .NET Standard，因此需要引用的项目基于 .NET 标准模板或针对 .NET Framework v4.6 或更高版本。为此配方，我们将项目更改为针对
    .NET Framework v4.6。
- en: How to do it...
  id: totrans-157
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Start Visual Studio and click on File | New | Project...
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 启动 Visual Studio 并点击 文件 | 新建 | 项目...
- en: 'Change the project target framework combo box to the .NET Framework 4.6 (or
    above). Under Visual C# | Extensibility, choose Code Refactoring (VSIX), name
    your project `CodeRefactoring`**,** and click on OK:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将项目目标框架组合框更改为 .NET Framework 4.6（或更高）。在 Visual C# | 扩展性 下，选择代码重构（VSIX），将你的项目命名为
    `CodeRefactoring`**,** 并点击确定：
- en: '![](img/9a36cd4d-e003-4c0b-83b5-f1115f77ba1d.png)'
  id: totrans-160
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9a36cd4d-e003-4c0b-83b5-f1115f77ba1d.png)'
- en: 'You should now have a solution with two projects: `CodeRefactoring` and `CodeRefactoring.Vsix`.'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你应该有一个包含两个项目：`CodeRefactoring` 和 `CodeRefactoring.Vsix` 的解决方案。
- en: 'Change the `CodeRefactoring` project to target *.NET Framework v4.6* using
    the following steps:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下步骤将 `CodeRefactoring` 项目更改为针对 *.NET Framework v4.6*：
- en: Unload the project and edit `csproj` in Visual Studio
  id: totrans-163
  prefs:
  - PREF_IND
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 中卸载项目并编辑 `csproj` 文件
- en: Remove the properties `ProjectTypeGuids` and `TargetFrameworkProfile`
  id: totrans-164
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除属性 `ProjectTypeGuids` 和 `TargetFrameworkProfile`
- en: Change the property `TargetFrameworkVersion` from *v4.5* to *v4.6.*
  id: totrans-165
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将属性 `TargetFrameworkVersion` 从 *v4.5* 更改为 *v4.6.*。
- en: Replace the last Imports element in the file from portable targets to non-portable
    targets, that is, replace the line `<Import Project="$(MSBuildExtensionsPath32)\Microsoft\Portable\$(TargetFrameworkVersion)\Microsoft.Portable.CSharp.targets"
    />` with `<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />`
  id: totrans-166
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将文件中的最后一个 `Imports` 元素从可移植目标更改为非可移植目标，即，将以下行 `<Import Project="$(MSBuildExtensionsPath32)\Microsoft\Portable\$(TargetFrameworkVersion)\Microsoft.Portable.CSharp.targets"
    />` 替换为 `<Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />`
- en: Save changes and reload the project
  id: totrans-167
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保存更改并重新加载项目
- en: 'Right-click on project in solution explorer, click on Manage NuGet Packages,
    and update `Microsoft.CodeAnalysis.CSharp.Workspaces` to *2.0.0*:'
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中右键单击项目，点击 管理NuGet包，并将 `Microsoft.CodeAnalysis.CSharp.Workspaces`
    更新到 *2.0.0*：
- en: '![](img/b0d6778e-6938-40d1-8ee1-90f643271039.png)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![](img/b0d6778e-6938-40d1-8ee1-90f643271039.png)'
- en: Open `CodeRefactoringProvider.cs` in the `CodeRefactoringProvider` project and
    replace the existing implementation of the `ComputeRefactoringAsync` method with
    the code at `CodeRefactoring/CodeRefactoring/CodeRefactoringProvider.cs/` Method
    named `ComputeRefactoringAsync`*****.*****
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `CodeRefactoringProvider` 项目中打开 `CodeRefactoringProvider.cs` 并将现有的 `ComputeRefactoringAsync`
    方法实现替换为 `CodeRefactoring/CodeRefactoring/CodeRefactoringProvider.cs/` 中名为 `ComputeRefactoringAsync`*****.*****
    的代码。
- en: 'Add the following helper to compute *out* parameters from a parameter list:'
  id: totrans-171
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下辅助程序来从参数列表计算 *out* 参数：
- en: '[PRE23]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Remove the existing method `ReverseTypeNameAsync` and replace it with `UseValueTupleAsync`
    and a couple of helper methods, `GenerateTupleType` and `GenerateTupleExpression`,
    from code at `CodeRefactoring/CodeRefactoring/CodeRefactoringProvider.cs/` Methods
    named `GenerateTupleType and GenerateTupleExpression`. Additionally, also add
    a new using statement at the top of the file: `using Microsoft.CodeAnalysis.Formatting;`'
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 删除现有的方法`ReverseTypeNameAsync`，并用来自`CodeRefactoring/CodeRefactoring/CodeRefactoringProvider.cs`的`UseValueTupleAsync`以及几个辅助方法`GenerateTupleType`和`GenerateTupleExpression`替换。此外，在文件顶部添加一个新的using语句：`using
    Microsoft.CodeAnalysis.Formatting;`
- en: Set `CodeRefactoring.Vsix` as the Startup project and click on *F5* to build
    the refactoring and start debugging a new instance of Visual Studio with the refactoring
    enabled.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`CodeRefactoring.Vsix`设置为启动项目，然后单击*F5*来构建重构并启动一个带有启用重构的新实例的Visual Studio进行调试。
- en: 'In the new Visual Studio instance, create a new C# class library project, say
    `ClassLibrary` and add the following two methods to `Class1`:'
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的Visual Studio实例中，创建一个新的C#类库项目，例如`ClassLibrary`，并将以下两个方法添加到`Class1`中：
- en: '[PRE24]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Right-click on the project node | Manage Nuget Packages and add NuGet package
    reference to `System.ValueTuple`.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击项目节点 | 管理NuGet包，并将NuGet包引用添加到`System.ValueTuple`。
- en: Put the caret on `MethodReturningTwoValues` and hit *Ctrl* + dot and verify
    that we are offered a refactoring to Use ValueTuple return type*:*
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将光标放在`MethodReturningTwoValues`上，然后按*Ctrl* + 点并验证是否提供了将返回类型更改为`ValueTuple`的重构操作：
- en: '![](img/3dd67329-3a00-4a5b-a926-115c7efb7219.png)'
  id: totrans-179
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/3dd67329-3a00-4a5b-a926-115c7efb7219.png)'
- en: Apply the refactoring and verify that the method signature changes to return
    value tuple.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用重构并验证方法签名是否更改为返回值元组。
- en: 'Similarly, put the caret on `MethodReturningThreeValues` and hit *Ctrl* + dot
    and verify we are offered a refactoring to Use ValueTuple return type:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，将光标放在`MethodReturningThreeValues`上，然后按*Ctrl* + 点并验证是否提供了将返回类型更改为`ValueTuple`的重构操作：
- en: '![](img/cbcf251c-0e8c-47e3-8e87-86e606b3d586.png)'
  id: totrans-182
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbcf251c-0e8c-47e3-8e87-86e606b3d586.png)'
- en: How it works...
  id: totrans-183
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Code refactoring providers are VS IDE extensions that can register code actions
    for refactoring code to a recommended pattern without introducing any functional
    changes. The primary API on `CodeRefactoringProvider` is:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 代码重构提供者是VS IDE扩展，可以在不引入任何功能更改的情况下注册代码操作以将代码重构为推荐模式。`CodeRefactoringProvider`的主要API是：
- en: '`ComputeRefactoringsAsync` method (abstract): This is a method to register
    code actions for refactorings. This method is invoked by the code refactoring
    engine whenever it needs to compute the refactorings to offer on the current source
    line in the VS IDE. This method takes a `CodeRefactoringContext` argument, which
    contains the current span and document. `CodeRefactoringProvider` can map the
    span to syntax node in the document and analyze it to register one more code actions
    in the context. **CodeAction** contains the following primary members:'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ComputeRefactoringsAsync`方法（抽象）：这是一个用于注册代码操作以进行重构的方法。代码重构引擎在需要计算在VS IDE当前源行上提供的重构时调用此方法。此方法接受一个`CodeRefactoringContext`参数，它包含当前的范围和文档。`CodeRefactoringProvider`可以将范围映射到文档中的语法节点，并分析它以在上下文中注册一个额外的代码操作。**CodeAction**包含以下主要成员：'
- en: '**`Title`** property: String that shows up with the light bulb when the code
    refactoring is offered.'
  id: totrans-186
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**`Title`**属性：当提供代码重构时，显示在灯泡旁边的字符串。'
- en: '`Callback` method: Delegate to be called back when the user applies a registered
    code action. This method returns the changed document or solution and the code
    refactoring engine applies the changes to the workspace.'
  id: totrans-187
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`回调`方法：当用户应用已注册的代码操作时，委托将被调用。此方法返回更改后的文档或解决方案，代码重构引擎将应用这些更改到工作区。'
- en: Let's expand on the implementation details of `ComputeRefactoringsAsync` and
    its helpers.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们进一步探讨`ComputeRefactoringsAsync`及其辅助方法的实现细节。
- en: 'The first part of `ComputeRefactoringsAsync` computes syntax node for the current
    span:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: '`ComputeRefactoringsAsync`的第一个部分计算当前范围对应的语法节点：'
- en: '[PRE25]'
  id: totrans-190
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The next part of the method implements certain defensive checks to bail out
    early without registering any code action:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的下一部分实现了某些防御性检查，以便在没有注册任何代码操作的情况下提前退出：
- en: '[PRE26]'
  id: totrans-192
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: We first check if we are currently operating on a `MethodDeclarationSyntax`
    node with non-void return type and at least one out parameter. We also bail out
    if the analyzed compilation doesn't define a type named `System.ValueTuple` in
    `System.ValueTuple` assembly reference.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先检查我们是否正在操作一个具有非空返回类型和至少一个输出参数的 `MethodDeclarationSyntax` 节点。如果分析的编译未在 `System.ValueTuple`
    集合引用中定义名为 `System.ValueTuple` 的类型，我们也会退出。
- en: 'Finally, the method registers a code action with the title to display in the
    light bulb and a callback*,* `UseValueTupleAsync`*,* to compute the refactoring:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该方法注册了一个带有要在灯泡中显示的标题的代码操作，以及一个回调*，* `UseValueTupleAsync`*，*来计算重构：
- en: '[PRE27]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '`UseValueTupleAsync` uses the C# `SyntaxFactory` helper utility to edit the
    signature and body of the method declaration from the original syntax root, and
    returns the new document created with the new syntax root.'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: '`UseValueTupleAsync` 使用 C# 的 `SyntaxFactory` 辅助工具来编辑方法声明的签名和主体，并返回使用新语法根创建的新文档。'
- en: The first part of the method computes the new parameter list for refactored
    code. We remove all the *out* parameters from the parameter list and change the
    return type to be a tuple type. For example, for a method returning type T, and
    having parameters, A a, out B b, out C c, we return a `TupleTypeSyntax` (T, B,
    C) and change the method parameter list to contain just <q>A a</q>**:**
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的第一部分计算重构代码的新参数列表。我们从参数列表中删除所有 *out* 参数，并将返回类型更改为元组类型。例如，对于一个返回类型为 T 的方法，具有参数
    A a，out B b，out C c，我们返回一个 `TupleTypeSyntax` (T, B, C) 并将方法参数列表更改为仅包含 `<q>A a</q>**:**
- en: '[PRE28]'
  id: totrans-198
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'The next part of the method adds local declaration statements at the top of
    the method body block for each *out* parameter in the original parameter list.
    For the preceding example, we will add local declaration statements `B b;` and
    `C c;`:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 方法的下一部分在方法体块顶部为原始参数列表中的每个 *out* 参数添加局部声明语句。对于前面的示例，我们将添加局部声明语句 `B b;` 和 `C c;`：
- en: '[PRE29]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Then, we gather all the `ReturnStatementSyntax` nodes in the original method
    implementation and replace their expression with a tuple expression created by
    concatenating the original return expression with the identifier names of the
    newly declared locals. For our example, this will replace statements of the form
    `return x;` with `return (x, b, c);`:'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们收集原始方法实现中的所有 `ReturnStatementSyntax` 节点，并将它们的表达式替换为通过连接原始返回表达式和新生成局部变量的标识符名称创建的元组表达式。对于我们的示例，这将替换形式为
    `return x;` 的语句为 `return (x, b, c);`：
- en: '[PRE30]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Finally, we apply the formatter annotation on the method `decl` to ensure that
    formatting is done by the formatter engine. We then replace the updated `methodDecl`
    node in the original root and return the updated document:'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们在方法 `decl` 上应用格式化器注解，以确保格式化由格式化器引擎完成。然后我们替换原始根中的更新后的 `methodDecl` 节点，并返回更新后的文档：
- en: '[PRE31]'
  id: totrans-204
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: There s more...
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Our current implementation of the refactoring is incomplete -- we change the
    method signature to return tuple types, but do not update the call sites to consume
    them. For example, the highlighted callsite here will be broken by our refactoring:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 我们当前的重构实现是不完整的——我们更改了方法签名以返回元组类型，但没有更新调用位置以消费它们。例如，这里高亮的调用位置将被我们的重构破坏：
- en: '[PRE32]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: We leave it as an exercise for the reader to enhance this refactoring to use
    the `FindReferences` API ([http://source.roslyn.io/#q=FindReferencesSearchEngine.FindReferencesAsyn](http://source.roslyn.io/#q=FindReferencesSearchEngine.FindReferencesAsyn))
    to find callsites of the method and edit the code to fix the callsite. For the
    preceding example, we need to replace the `MethodReturningTwoValues` invocation
    with the highlighted code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将如何增强这个重构以使用 `FindReferences` API ([http://source.roslyn.io/#q=FindReferencesSearchEngine.FindReferencesAsyn](http://source.roslyn.io/#q=FindReferencesSearchEngine.FindReferencesAsyn))
    来查找方法的调用位置并编辑代码以修复调用位置，留作读者的练习。对于前面的示例，我们需要将 `MethodReturningTwoValues` 调用替换为高亮代码。
- en: '[PRE33]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Creating a CompletionProvider to provide additional intellisense items while
    editing code.
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建一个 CompletionProvider，在编辑代码时提供额外的智能感知项。
- en: '`CompletionProviders` are IDE extensions that provide completion items in the
    intellisense list when user is editing code in the Visual Studio IDE:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompletionProviders` 是 IDE 扩展，当用户在 Visual Studio IDE 中编辑代码时，在智能感知列表中提供完成项：'
- en: '![](img/e910df99-d4d7-4e0f-8ca6-076fd9e29d59.png)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/e910df99-d4d7-4e0f-8ca6-076fd9e29d59.png)'
- en: The preceding screenshot shows a completion list with all the accessible instance
    members from the current type and base types, and is generally shown when the
    user types `this.` inside executable code. Users can hit a commit character, such
    as *Enter* key, to invoke auto-complete with the chosen member.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 上述截图显示了一个包含当前类型及其基类型中所有可访问实例成员的完成列表，通常在用户在可执行代码中键入 `this.` 时显示。用户可以按提交字符，例如
    *Enter* 键，以调用所选成员的自动完成。
- en: In this section, we will write a `CompletionProvider` to provide the same *accessible
    members* completion items, but without requiring the user to have typed a `this`
    before a `.` character (yay! from all the lazy folks like me). Additionally, when
    invoked within a static method, the completion provider will provide only *static*
    accessible members in the completion list.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个 `CompletionProvider` 来提供相同的 *可访问成员* 完成项，但不需要用户在 `.` 字符之前输入 `this`（像我这样的懒惰人欢呼！）。此外，当在静态方法中调用时，完成提供程序将只提供完成列表中的
    *静态* 可访问成员。
- en: '![](img/7a743a1b-8549-4d16-992a-c4c953bc46cc.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7a743a1b-8549-4d16-992a-c4c953bc46cc.png)'
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have Visual Studio 2017 installed on your machine to execute
    the recipes in this chapter. You can install a free community version of Visual
    Studio 2017 from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)***.***
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的机器上安装 Visual Studio 2017 才能执行本章中的配方。您可以从 [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)
    安装免费的 Visual Studio 2017 社区版***。***
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open Visual Studio, click on File | New Project | Visual C# | Class library,
    ensure the .NET framework combo box is set to *v4.6.2,* and create a project named
    `CompletionProvider`.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio，单击文件 | 新建项目 | Visual C# | 类库，确保 .NET 框架组合框设置为 *v4.6.2*，并创建一个名为
    `CompletionProvider` 的项目。
- en: In solution explorer, right-click on the project node and execute the `Manage
    NuGet Packages` command to bring up the NuGet Package Manager. Add NuGet package
    references to `Microsoft.CodeAnalysis` and `Microsoft.CodeAnalysis.Features`,
    both version *2.0.0.*
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中，右键单击项目节点并执行 `管理 NuGet 包` 命令以打开 NuGet 包管理器。将 NuGet 包引用添加到 `Microsoft.CodeAnalysis`
    和 `Microsoft.CodeAnalysis.Features`，版本均为 *2.0.0.*。
- en: Rename the source file `Class1.cs` to `CustomCompletionProvider.cs` and add
    source code for `CustomCompletionProvider` from the code sample at `CompletionProvider/CompletionProvider/CustomCompletionProvider.cs/Type`
    named `CustomCompletionProvider`.
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将源文件 `Class1.cs` 重命名为 `CustomCompletionProvider.cs`，并从 `CompletionProvider/CompletionProvider/CustomCompletionProvider.cs/Type`
    中的代码示例添加 `CustomCompletionProvider` 的源代码。
- en: Add a C# VSIX project named `CompletionProvider.Vsix` to the solution.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将名为 `CompletionProvider.Vsix` 的 C# VSIX 项目添加到解决方案中。
- en: 'Replace the content of `source.extension.vsixmanifest` in the VSIX project
    with the following:'
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 VSIX 项目中的 `source.extension.vsixmanifest` 的内容替换为以下内容：
- en: '[PRE34]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: Add a project-to-project reference from `CompletionProvider.Vsix` to `CompletionProvider`.
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从 `CompletionProvider.Vsix` 添加项目到项目引用到 `CompletionProvider`。
- en: Set `CompletionProvider.Vsix` as the start-up project and click on *F5* to build
    the completion provider and start debugging a new instance of Visual Studio with
    the provider enabled.
  id: totrans-226
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `CompletionProvider.Vsix` 设置为启动项目，并单击 *F5* 以构建完成提供程序并启动一个启用提供程序的新实例的 Visual
    Studio 进行调试。
- en: 'In the new Visual Studio instance, create a new C# class library project, say
    `ClassLibrary` and add the following code to the source file:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在新的 Visual Studio 实例中，创建一个新的 C# 类库项目，例如 `ClassLibrary`，并将以下代码添加到源文件中：
- en: '[PRE35]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Put the caret after the `.` in `InstanceMethod` and hit *Ctrl* + *SpaceBar*
    to bring up our custom completion list. Verify all the instance members of type
    `Derived`, and accessible instance members of base type `Base` and `System.Object`
    are shown in the completion list.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `InstanceMethod` 中的 `.` 后面放置光标，然后按 *Ctrl* + *SpaceBar* 以显示我们的自定义完成列表。验证类型为
    `Derived` 的所有实例成员以及基类型 `Base` 和 `System.Object` 的可访问实例成员是否显示在完成列表中。
- en: Select a member, say `InstanceMemberDerived`, and hit the *Enter* key and verify
    that the `.` is replaced with `this.InstanceMemberDerived`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个成员，例如 `InstanceMemberDerived`，然后按 *Enter* 键，并验证 `.` 是否被替换为 `this.InstanceMemberDerived`。
- en: Put the caret after the `.` in `StaticMethod` and hit *Ctrl* + *Spacebar* to
    bring up the completion list. Verify all the static members of type *Derived*
    and accessible static members of base type `Base` and `System.Object` are shown
    in the completion list.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `StaticMethod` 中的 `.` 后放置光标，然后按 *Ctrl* + *Spacebar* 来弹出完成列表。验证类型为 *Derived*
    的所有静态成员以及基类型 `Base` 和 `System.Object` 的可访问静态成员是否显示在完成列表中。
- en: Select a member, say `StaticMemberBase`, and hit the *Enter* key, and verify
    that the `.` is replaced with `Base.StaticMemberBase`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择一个成员，例如 `StaticMemberBase`，然后按 *Enter* 键，并验证 `.` 是否被替换为 `Base.StaticMemberBase`。
- en: How it works...
  id: totrans-233
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的……
- en: 'Completion providers are VS IDE extensions that can register completion items
    to be shown in the Visual Studio IDE when the user is editing source code. The
    primary APIs on `CompletionProvider` are:'
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 完成提供者是 VS IDE 扩展，可以在用户编辑源代码时向 Visual Studio IDE 注册要显示的完成项。`CompletionProvider`
    上的主要 API 包括：
- en: '`ShouldTriggerCompletion` method (virtual): This is the method to decide if
    completion should be invoked for the given editing context. This method takes
    the following arguments: `SourceText` of the document being edited, `caretPosition`
    at which completion was invoked, `CompletionTrigger` (which contains the trigger
    kind - insertion, deletion, and so on, and the trigger character), and `OptionSet`
    for completion.'
  id: totrans-235
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ShouldTriggerCompletion` 方法（虚拟）：这是决定是否为给定的编辑上下文调用完成的方法。此方法接受以下参数：正在编辑的文档的
    `SourceText`、完成调用时的 `caretPosition`、包含触发类型（插入、删除等）和触发字符的 `CompletionTrigger`，以及完成项的
    `OptionSet`。'
- en: '`ProvideCompletionsAsync` method (abstract): This is the method to register
    completion items. This method is invoked by the completion engine whenever it
    needs to compute the completions to offer on the current completion trigger in
    the VS IDE. This method takes a `CompletionContext` argument, which contains the
    current caret position, document, completion trigger and options. `CompletionContext`
    exposes methods to add one or more completion items. `CompletionItem` contains
    the following primary components: `DisplayText` to be shown in the completion
    list, optional `FilterText` and `SortText` to modify the default filtering and
    sorting, respectively, the text `Span` of the syntax element is associated with
    the completion, a dictionary of `<string, string> Properties`, an array of `Tags`,
    and set of `CompletionRules` for how the completion items are handled.'
  id: totrans-236
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ProvideCompletionsAsync` 方法（抽象）：这是注册完成项的方法。当完成引擎需要计算在 VS IDE 中当前完成触发器上提供的完成时，会调用此方法。此方法接受一个
    `CompletionContext` 参数，它包含当前光标位置、文档、完成触发器和选项。`CompletionContext` 提供了添加一个或多个完成项的方法。`CompletionItem`
    包含以下主要组件：要在完成列表中显示的 `DisplayText`、可选的 `FilterText` 和 `SortText` 以修改默认的过滤和排序，与完成关联的语法元素的文本
    `Span`、一个 `<string, string>` 属性字典、一个 `Tags` 数组以及完成项的处理规则集。'
- en: '`GetDescriptionAsync` method (virtual): This method gets the description to
    show in the quick info for each completion item.'
  id: totrans-237
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetDescriptionAsync` 方法（虚拟）：此方法获取要显示在每个完成项快速信息中的描述。'
- en: '`GetChangeAsync` method (virtual): This method gets the `CompletionChange`
    to be applied when the user commits a specific completion item. `CompletionChange`
    contains the set of one or more text changes to apply to the document and new
    caret position after committing the completion item.'
  id: totrans-238
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GetChangeAsync` 方法（虚拟）：此方法获取当用户提交特定完成项时要应用的 `CompletionChange`。`CompletionChange`
    包含要应用到文档中的一组文本更改以及提交完成项后的新光标位置。'
- en: Let's expand on the implementation details of each of the preceding overrides
    in our `CustomCompletionProvider`.
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细说明我们 `CustomCompletionProvider` 中前面重写的每个覆盖方法的实现细节。
- en: 'Our implementation of `ShouldTriggerCompletion` first checks whether completion
    is invoked for the insertion trigger:'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `ShouldTriggerCompletion` 的实现首先检查是否为插入触发器调用了完成：
- en: '[PRE36]'
  id: totrans-241
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: The helper method `ShouldTriggerCompletion` checks if the current character
    is `.` and the previous character is either a whitespace, tab, or new line character.
    If so, we return true; otherwise we return false.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 辅助方法 `ShouldTriggerCompletion` 检查当前字符是否为 `.`，以及前一个字符是否为空格、制表符或换行符。如果是这样，我们返回
    true；否则返回 false。
- en: '[PRE37]'
  id: totrans-243
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: '`ProvideCompletionsAsync` implementation checks up front if we should register
    any completion items, and bails out if we are not in the supported completion
    context. We also bail out if we are not editing inside a method body.'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProvideCompletionsAsync` 方法的实现首先检查我们是否应该注册任何完成项，如果不是在支持完成的环境中，则退出。我们也会在不在方法体内编辑时退出。'
- en: '[PRE38]'
  id: totrans-245
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'We then compute all the accessible members in the current context using the
    helper methods `GetAccessibleMembersInThisAndBaseTypes` and `GetBaseTypesAndThis`:'
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用辅助方法`GetAccessibleMembersInThisAndBaseTypes`和`GetBaseTypesAndThis`计算当前上下文中的所有可访问成员：
- en: '[PRE39]'
  id: totrans-247
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'We then iterate through all the members to suggest, ignoring constructors,
    and create and register a completion item for each member:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们遍历所有成员以建议，忽略构造函数，并为每个成员创建和注册一个完成项：
- en: '[PRE40]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: We use the member's `Name` property as the `DisplayText` value for the completion
    item.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用成员的`Name`属性作为完成项的`DisplayText`值。
- en: 'We compute a couple of strings, namely, `Receiver` and `Description`, and store
    them as string properties on the completion item. These properties are used in
    `GetChangeAsync` and `GetDescriptionAsync` method overrides, respectively. `Receiver`
    is essentially the string to add to the left of the `.` character when user commits
    a completion item: `this` for instance members, and containing type''s `name`
    for static members. `Description` is the text to show in the quick info for each
    completion item. We use the symbol''s minimal display string as the description,
    but this can be enhanced to show colored tokens and use content from the XML documentation
    comments on the symbol.'
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们计算了几个字符串，即`Receiver`和`Description`，并将它们作为字符串属性存储在完成项上。这些属性分别用于`GetChangeAsync`和`GetDescriptionAsync`方法的重写。`Receiver`基本上是用户提交完成项时添加到`.`字符左侧的字符串：例如实例成员的`this`，静态成员的包含类型的`name`。`Description`是显示在每个完成项快速信息中的文本。我们使用符号的最小显示字符串作为描述，但可以增强以显示带颜色的标记并使用符号上的XML文档注释中的内容。
- en: 'We also compute and attach a set of string `Tags` to the completion items.
    These tags determine the glyphs to show for the completion items. Examples are
    symbol glyph: field, method, property, and so on, and accessibility glyph: private,
    protected, internal, public, and so on.'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还计算并附加一组字符串`Tags`到完成项。这些标签决定了完成项要显示的符号。例如，符号符号：字段、方法、属性等，以及可访问性符号：私有、受保护、内部、公共等。
- en: '`GetDescriptionAsync` override directly uses the Description property stored
    on the completion item to compute the `CompletionDescription`:'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetDescriptionAsync`重写直接使用存储在完成项上的`Description`属性来计算`CompletionDescription`：'
- en: '[PRE41]'
  id: totrans-254
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '`GetChangeAsync` override uses the computed *Receiver* property and the item''s
    `DisplayText` to form the `newText "{receiver}.{item.DisplayText}"` to be used
    in the text change when the user commits the completion item. The `TextSpan` of
    the text change uses `item.Span.Start - 1` as the start value and `1` as the length
    to account for the existing `.` character to be removed:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: '`GetChangeAsync`重写使用计算出的*Receiver*属性和项的`DisplayText`来形成用于文本更改的`newText "{receiver}.{item.DisplayText}"`。文本更改的`TextSpan`使用`item.Span.Start
    - 1`作为起始值，`1`作为长度，以考虑到要删除的现有`.`字符：'
- en: '[PRE42]'
  id: totrans-256
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Writing unit tests for a CodeFixProvider
  id: totrans-257
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 为CodeFixProvider编写单元测试
- en: In this section, we will show you how to write and execute unit tests for a
    `CodeFixProvider`.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将向您展示如何编写和执行`CodeFixProvider`的单元测试。
- en: Getting ready
  id: totrans-259
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: You will need to have created and opened an analyzer + code fixer project, say
    `CSharpAnalyzers` in Visual Studio 2017\. Refer to the recipe, *Creating, debugging,
    and executing an analyzer project in Visual Studio*, in [Chapter 1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml),
    *Writing Diagnostic Analyzers* for guidance.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要创建并打开一个分析器+代码修复器项目，例如Visual Studio 2017中的`CSharpAnalyzers`。请参考[第1章](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml)中的配方，“在Visual
    Studio中创建、调试和执行分析器项目”，以获取指导。
- en: Note that the template unit test project contains unit tests for both the `DiagnosticAnalyzer`
    and `CodeFixProvider`. This chapter deals with `CodeFixProvider` testing only.
    Refer to the recipe, *Writing unit tests for an analyzer project* in [Chapter
    1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml), *Writing Diagnostic Analyzers*
    for diagnostic analyzer unit tests.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，模板单元测试项目包含了对`DiagnosticAnalyzer`和`CodeFixProvider`的单元测试。本章仅处理`CodeFixProvider`测试。请参考[第1章](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml)中的配方，“为分析器项目编写单元测试”，以及“编写诊断分析器”部分，以了解诊断分析器单元测试。
- en: How to do it...
  id: totrans-262
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'Open `UnitTests.cs` in the `CSharpAnalyzers.Test` project in the solution explorer
    to view the default unit tests created for the default symbol analyzer and code
    fix provider in the project (Type names should not contain lower case letters):'
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在解决方案资源管理器中打开`UnitTests.cs`文件，该文件位于`CSharpAnalyzers.Test`项目中，以查看为项目中的默认符号分析器和代码修复提供者创建的默认单元测试（类型名称不应包含小写字母）：
- en: '![](img/46d1c8ea-ca5c-49a2-89fd-916547876e95.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![](img/46d1c8ea-ca5c-49a2-89fd-916547876e95.png)'
- en: 'Click on Test | Windows | Test Window to open the Test Explorer window to view
    the unit tests in the project. The default project has two unit tests:'
  id: totrans-265
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 点击测试 | 窗口 | 测试窗口以打开测试资源管理器窗口，查看项目中的单元测试。默认项目有两个单元测试：
- en: '`TestMethod1`: This tests the scenario where analyzer diagnostic does not fire
    on the test code.'
  id: totrans-266
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestMethod1`: 这个测试检查分析器诊断在测试代码上没有触发的情况。'
- en: '`TestMethod2`: This tests the scenario where analyzer diagnostic does fire
    on the test code and the code fix provider fixes the diagnostic.'
  id: totrans-267
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`TestMethod2`: 这个测试检查分析器诊断在测试代码上触发，并且代码修复提供者修复了诊断。'
- en: Delete `TestMethod1` as we only care about `CodeFixProvider` tests.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 删除`TestMethod1`，因为我们只关心`CodeFixProvider`测试。
- en: 'Run the unit tests for the project by right-clicking on Not Run tests node
    in the Test Explorer and execute `Run selected tests` context menu command and
    verify that the `TestMethod2` passes:'
  id: totrans-269
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过在测试资源管理器中右键单击未运行测试节点并执行运行选定测试上下文菜单命令来运行项目的单元测试，并验证`TestMethod2`通过：
- en: '![](img/c0dd4466-6188-4633-8618-1fd8f8360be6.png)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![](img/c0dd4466-6188-4633-8618-1fd8f8360be6.png)'
- en: 'Edit the test source to remove all the usings and add a new nested type `TypeName2`
    inside `TypeName` in both the test string and `fixTest` string:'
  id: totrans-271
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑测试源代码，移除所有使用语句，并在测试字符串和`fixTest`字符串中`TypeName`内部添加一个新的嵌套类型`TypeName2`：
- en: '[PRE43]'
  id: totrans-272
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Edit `TestMethod1` to fix the expected line number of the original expected
    diagnostic add a new excepted diagnostic for the new test code:'
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 编辑`TestMethod1`以修复原始预期诊断的预期行号，并为新的测试代码添加一个新的预期诊断：
- en: Right-click on `TestMethod2` in the editor and execute Run tests context menu
    command, and verify the test now fails with the diagnostic mismatch assert - expected
    1, actual 2.
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在编辑器中右键单击`TestMethod2`并执行运行测试上下文菜单命令，并验证测试现在失败，诊断不匹配断言 - 预期1，实际2。
- en: '[PRE44]'
  id: totrans-275
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Fix the expected `fixTest` code to contain `TYPENAME2` and verify that the test
    passes now.
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 修复预期的`fixTest`代码以包含`TYPENAME2`，并验证测试现在通过。
- en: Run the unit test again and note that the test still fails, but now it fails
    due to a difference in the fixed test code - `fixTest` has class `TypeName2` with
    lowercase letters, but the actual test code has `TYPENAME2`.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行单元测试，并注意测试仍然失败，但现在失败的原因是固定测试代码中的差异 - `fixTest`中的类`TypeName2`使用小写字母，但实际测试代码中有`TYPENAME2`。
- en: How it works...
  id: totrans-278
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: An analyzer + code fix unit test project allows us to write unit tests for the
    execution of our analyzer/code fix provider on different code samples. Each unit
    test is marked with a `TestMethod` attribute and defines sample test code, expected
    diagnostics reported by the analyzer on that code (if any), expected fixed test
    code after executing the code fix provider on the sample test code, and invocation
    of test helper methods, here `VerifyCSharpFix`*,* to verify code fix.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 分析器 + 代码修复单元测试项目允许我们为我们的分析器/代码修复提供者在不同的代码样本上的执行编写单元测试。每个单元测试都带有`TestMethod`属性，并定义样本测试代码，分析器在代码上报告的预期诊断（如果有），执行代码修复提供者后的预期修复测试代码，以及调用测试辅助方法，这里`VerifyCSharpFix`*，*以验证代码修复。
- en: To understand the basics of unit tests and the test framework for our unit test
    framework, refer to the *How it works... section* of the recipe, *Writing unit
    tests for an analyzer project* in [Chapter 1](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml),
    *Writing Diagnostic Analyzers* for diagnostic analyzer unit tests.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解单元测试的基础知识和我们的单元测试框架的测试框架，请参阅食谱中的*如何工作...部分*，[第1章](9928750a-c427-42e6-b8a2-cf67eb5465af.xhtml)中的*为诊断分析器编写单元测试*。
- en: 'In this section, we will give a brief explanation of the abstract type that
    our unit test container derives from: `CodeFixVerifier`. This type contains the
    `VerifyCSharpFix` and `VerifyBasicFix` helper methods for running C# and VB `CodeFixProvider`
    unit tests, respectively. These methods call into a common helper method `VerifyFix`,
    which works as follows:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将简要解释我们的单元测试容器从其中派生的抽象类型：`CodeFixVerifier`。此类型包含用于运行C#和VB `CodeFixProvider`单元测试的辅助方法`VerifyCSharpFix`和`VerifyBasicFix`。这些方法调用一个公共辅助方法`VerifyFix`，其工作方式如下：
- en: This method takes the original and expected sample test code as inputs - the
    original code on which to apply the code fixes, and the expected code after the
    code fixes have been applied.
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此方法接受原始和预期样本测试代码作为输入 - 应用代码修复的原始代码，以及应用代码修复后的预期代码。
- en: It also takes the language name, analyzer, and code fix provider, along with
    the index of the code action to apply, in case the fixer registers multiple code
    actions.
  id: totrans-283
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它还获取语言名称、分析器、代码修复提供者，以及要应用的代码操作的索引，以防修复器注册了多个代码操作。
- en: It runs the analyzer on the original test code to get the analyzer diagnostics.
    It also computes the compiler diagnostics on the test code.
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在原始测试代码上运行分析器以获取分析器诊断。它还在测试代码上计算编译器诊断。
- en: It uses the first analyzer diagnostic to create a `CodeFixContext` and invokes
    the code fix provider's `RegisterCodeFixesAsync` method with this context.
  id: totrans-285
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用第一个分析器诊断来创建一个 `CodeFixContext`，并使用此上下文调用代码修复提供者的 `RegisterCodeFixesAsync`
    方法。
- en: Then, it applies the registered code action at the given code fix index to compute
    the new document.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，它将在给定的代码修复索引处应用已注册的代码操作来计算新文档。
- en: It re-executes the analyzer on the new document to get new analyzer diagnostics.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在新文档上重新执行分析器以获取新的分析器诊断。
- en: Until there is at least one new analyzer diagnostic, it repeats the steps 4-6
    to apply the code fix on the new document.
  id: totrans-288
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 直到至少有一个新的分析器诊断出现，它将重复步骤 4-6 以在新文档上应用代码修复。
- en: Finally, it verifies the contents of the new document against the expected fixed
    code.
  id: totrans-289
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，它将新文档的内容与预期的修复代码进行验证。
