<html><head></head><body>
<div id="_idContainer072">
<h1 class="chapter-number" id="_idParaDest-204"><a id="_idTextAnchor219"/><span class="koboSpan" id="kobo.1.1">14</span></h1>
<h1 id="_idParaDest-205"><a id="_idTextAnchor220"/><span class="koboSpan" id="kobo.2.1">Implementing Centralized Logging for Microservices</span></h1>
<p><span class="koboSpan" id="kobo.3.1">One of the biggest challenges with APIs is the fact that we rarely get actual feedback on what is happening in our service. </span><span class="koboSpan" id="kobo.3.2">We do our best to design our services in a way that our HTTP responses indicate the success or failure of each operation, but this is not always enough. </span><span class="koboSpan" id="kobo.3.3">The most concerning types of responses are those in the 5xx range, without any useful information behind them.</span></p>
<p><span class="koboSpan" id="kobo.4.1">For this reason, we need to employ logging in our microservices application. </span><span class="koboSpan" id="kobo.4.2">Logging produces real-time information on the operations and events occurring in the service. </span><span class="koboSpan" id="kobo.4.3">Each log message helps us to understand the behavior of the application and aids with our investigations when things go wrong. </span><span class="koboSpan" id="kobo.4.4">So, the logs are the first line of defense against the ambiguous 5xx HTTP responses.</span></p>
<p><span class="koboSpan" id="kobo.5.1">During development, logs help us to contextualize some of the issues that we face and give us, when implemented well, a play-by-play sequence of the functions being called and their output. </span><span class="koboSpan" id="kobo.5.2">This will help us to more easily discern where our code might be breaking or why a function’s output is less than desired.</span></p>
<p><span class="koboSpan" id="kobo.6.1">In the case of a distributed application, we need to implement special measures that help us to centralize the logs being produced by the individual services. </span><span class="koboSpan" id="kobo.6.2">Yes, we are promoting autonomy in this kind of architecture, but all the components still combine to produce one application. </span><span class="koboSpan" id="kobo.6.3">This makes the point of failure more difficult to find if we need to sift through several log files and sources.</span></p>
<p><span class="koboSpan" id="kobo.7.1">After reading this chapter, we will be able to do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.8.1">Understand the use of log aggregation</span></li>
<li><span class="koboSpan" id="kobo.9.1">Know how to implement performance monitoring</span></li>
<li><span class="koboSpan" id="kobo.10.1">Know how to implement distributed tracing</span></li>
</ul>
<h1 id="_idParaDest-206"><a id="_idTextAnchor221"/><span class="koboSpan" id="kobo.11.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.12.1">The code references used in this chapter can be found in this project’s repository, which is hosted on GitHub at </span><a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch14"><span class="koboSpan" id="kobo.13.1">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch14</span></a><span class="koboSpan" id="kobo.14.1">.</span></p>
<h1 id="_idParaDest-207"><a id="_idTextAnchor222"/><span class="koboSpan" id="kobo.15.1">Logging and its importance</span></h1>
<p><span class="koboSpan" id="kobo.16.1">Logs are blocks</span><a id="_idIndexMarker717"/><span class="koboSpan" id="kobo.17.1"> of text that</span><a id="_idIndexMarker718"/><span class="koboSpan" id="kobo.18.1"> most applications produce during runtime. </span><span class="koboSpan" id="kobo.18.2">They are designed to be human-readable mini-reports about what is happening in the application, and they should allow us to be able to track and trace errors that occur in our applications.</span></p>
<p><span class="koboSpan" id="kobo.19.1">In a monolithic application, we typically write logs to a log file or a database. </span><span class="koboSpan" id="kobo.19.2">In fact, in .NET Core, we have access to powerful logging providers and third-party libraries that allow us to integrate with several log output destinations. </span><span class="koboSpan" id="kobo.19.3">There is no real best destination and while some work better than ours, it is a matter of project preference and overall comfort. </span><span class="koboSpan" id="kobo.19.4">Our monolithic logs contain information about everything happening in one application.</span></p>
<p><span class="koboSpan" id="kobo.20.1">In a distributed system, this becomes more complex since we have activities happening across several applications. </span><span class="koboSpan" id="kobo.20.2">The first inclination is to create logs per service, which might result in several log files, each containing bits of the overall information that we need to see for the application. </span><span class="koboSpan" id="kobo.20.3">Imagine needing to visit several log files to investigate a failure that occurred at 5:00 P.M. </span><span class="koboSpan" id="kobo.20.4">To understand this failure, we will need to review several sources to piece together anything sensible, which can be a difficult task.</span></p>
<p><span class="koboSpan" id="kobo.21.1">This investigation gets even more difficult if our logs are too verbose. </span><span class="koboSpan" id="kobo.21.2">A verbose log reports everything that occurs in the application. </span><span class="koboSpan" id="kobo.21.3">Even if we don’t report everything, we need to be pointed with what we log to reduce the noise and better highlight the key events that need to be captured.</span></p>
<p><span class="koboSpan" id="kobo.22.1">We will then need a clean way to centralize the logs that are generated across the services. </span><span class="koboSpan" id="kobo.22.2">A centralized database may seem like a good idea, but it may lead to resource and table locking if several services are attempting to write logs frequently. </span><span class="koboSpan" id="kobo.22.3">We will review the best centralization techniques later. </span><span class="koboSpan" id="kobo.22.4">For now, let us focus on deciding what are the best bits of information to log and how that can be achieved in .NET Core.</span></p>
<h2 id="_idParaDest-208"><a id="_idTextAnchor223"/><span class="koboSpan" id="kobo.23.1">Choosing what to log</span></h2>
<p><span class="koboSpan" id="kobo.24.1">An important </span><a id="_idIndexMarker719"/><span class="koboSpan" id="kobo.25.1">decision while implementing logging is what we want to log. </span><span class="koboSpan" id="kobo.25.2">Do we want to log a play-by-play sequence of everything that happens in our application, or do we only want to make note of the errors? </span><span class="koboSpan" id="kobo.25.3">Different systems have different requirements, and the correct choices depend on how crucial the service is to the overall running of the application.</span></p>
<p><span class="koboSpan" id="kobo.26.1">Now that we have determined the most essential services that need to be monitored more through logs, we need to determine what information will be logged. </span><span class="koboSpan" id="kobo.26.2">Recall that we don’t want our logs to be too chatty, but we don’t want to neglect to place pertinent information in the logs. </span><span class="koboSpan" id="kobo.26.3">Too much information can lead to large useless logs and high storage costs, and too little information will give us useless files. </span></p>
<p><span class="koboSpan" id="kobo.27.1">Useful information would include, but is not limited to the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.28.1">The ID of a resource that is being accessed through an API request</span></li>
<li><span class="koboSpan" id="kobo.29.1">The different functions being invoked during a request cycle</span></li>
</ul>
<p><span class="koboSpan" id="kobo.30.1">What we want to avoid is logging sensitive information. </span><span class="koboSpan" id="kobo.30.2">We do not want to log the following, for example:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.31.1">User credentials during an authentication flow</span></li>
<li><span class="koboSpan" id="kobo.32.1">Payment information</span></li>
<li><span class="koboSpan" id="kobo.33.1">Personally identifiable information</span></li>
</ul>
<p><span class="koboSpan" id="kobo.34.1">Despite our best security efforts, logs remain a source of truth about our system, and a security breach on log files that contain sensitive information could prove to be a detrimental event. </span><span class="koboSpan" id="kobo.34.2">There are legislations and data protection laws that govern how we should store and secure our logs. </span><span class="koboSpan" id="kobo.34.3">Therefore, it is better to log just IDs that can be looked up on demand, without giving any information away upfront.</span></p>
<p><span class="koboSpan" id="kobo.35.1">We also have the concept of </span><em class="italic"><span class="koboSpan" id="kobo.36.1">log levels</span></em><span class="koboSpan" id="kobo.37.1">, which are a categorization of the severity of a log message. </span><span class="koboSpan" id="kobo.37.2">These levels are split into </span><em class="italic"><span class="koboSpan" id="kobo.38.1">information</span></em><span class="koboSpan" id="kobo.39.1">, </span><em class="italic"><span class="koboSpan" id="kobo.40.1">debug</span></em><span class="koboSpan" id="kobo.41.1">, </span><em class="italic"><span class="koboSpan" id="kobo.42.1">warning</span></em><span class="koboSpan" id="kobo.43.1">, </span><em class="italic"><span class="koboSpan" id="kobo.44.1">error</span></em><span class="koboSpan" id="kobo.45.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.46.1">critical</span></em><span class="koboSpan" id="kobo.47.1">. </span><span class="koboSpan" id="kobo.47.2">There might be other categories in between, but these are the most used ones. </span><span class="koboSpan" id="kobo.47.3">This is what they stand for:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.48.1">Information</span></strong><span class="koboSpan" id="kobo.49.1">: A standard log level that is used when something has happened as expected. </span><span class="koboSpan" id="kobo.49.2">They are generally used to share information about an operation and can be useful in helping to trace the sequence of operations that might have led to an error.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.50.1">Debug</span></strong><span class="koboSpan" id="kobo.51.1">: A very informational log level that is more than we might need for everyday use. </span><span class="koboSpan" id="kobo.51.2">It is mostly useful for development and helps us to track more intricate operations in the code. </span><span class="koboSpan" id="kobo.51.3">Production systems generally do not produce debug logs.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.52.1">Warning</span></strong><span class="koboSpan" id="kobo.53.1">: This log level indicates that something has happened that isn’t an error but isn’t normal. </span><span class="koboSpan" id="kobo.53.2">Think of it as an amber light that suggests that some attention should be given to a situation, but it might not be mission critical.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.54.1">Error</span></strong><span class="koboSpan" id="kobo.55.1">: An error is an error. </span><span class="koboSpan" id="kobo.55.2">This type of log entry is usually created when an exception is encountered. </span><span class="koboSpan" id="kobo.55.3">This can be paired with the exception and stack trace and proves to be a critical type of log to have when debugging issues.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Critical</span></strong><span class="koboSpan" id="kobo.57.1">: This indicates that we encountered an error that we cannot recover from. </span><span class="koboSpan" id="kobo.57.2">This kind of log entry can be used when the application fails to start or fails to connect to a critical data source or dependency.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.58.1">Log levels are a universal language, and we should ensure that we accurately represent the situation being logged with the appropriate log level. </span><span class="koboSpan" id="kobo.58.2">We also want to avoid misclassifying our events and logging misleading information about what has happened in our system.</span></p>
<p><span class="koboSpan" id="kobo.59.1">Once again, the</span><a id="_idIndexMarker720"/><span class="koboSpan" id="kobo.60.1"> ultimate decision on what is logged is relative to the application, developer’s, and organization’s needs and we need to ensure that we are thorough enough to capture the essential bits about the application’s runtime. </span><span class="koboSpan" id="kobo.60.2">Now, let us review how we implement logging in to a .NET Core application.</span></p>
<h2 id="_idParaDest-209"><a id="_idTextAnchor224"/><span class="koboSpan" id="kobo.61.1">Using the .NET logging API</span></h2>
<p><span class="koboSpan" id="kobo.62.1">.NET has a</span><a id="_idIndexMarker721"/><span class="koboSpan" id="kobo.63.1"> built-in logging mechanism that is baked into our application startup operation. </span><span class="koboSpan" id="kobo.63.2">We get an out-of-the-box logging library that produces logs on all the happenings of our application as soon as it is started. </span><span class="koboSpan" id="kobo.63.3">This mechanism works with several third-party logging providers, making it extensible and powerful just the same. </span><span class="koboSpan" id="kobo.63.4">With our providers, we can determine the target destinations for our logs.</span></p>
<p><span class="koboSpan" id="kobo.64.1">We will start with the </span><em class="italic"><span class="koboSpan" id="kobo.65.1">ILogger</span></em><span class="koboSpan" id="kobo.66.1"> interface. </span><span class="koboSpan" id="kobo.66.2">This interface is an abstraction of the logging API that ships with .NET. </span><span class="koboSpan" id="kobo.66.3">It is made available to us through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.67.1">Microsoft.Extensions.Logging</span></strong><span class="koboSpan" id="kobo.68.1"> NuGet package. </span><span class="koboSpan" id="kobo.68.2">This library provides us with the necessary classes, interfaces, and functionality for application logging and has providers for logging to </span><em class="italic"><span class="koboSpan" id="kobo.69.1">Console</span></em><span class="koboSpan" id="kobo.70.1">, </span><em class="italic"><span class="koboSpan" id="kobo.71.1">Debug</span></em><span class="koboSpan" id="kobo.72.1">, </span><em class="italic"><span class="koboSpan" id="kobo.73.1">Azure Log Stream</span></em><span class="koboSpan" id="kobo.74.1">, </span><em class="italic"><span class="koboSpan" id="kobo.75.1">EventSource</span></em><span class="koboSpan" id="kobo.76.1">, and</span><em class="italic"><span class="koboSpan" id="kobo.77.1"> Windows Event Log</span></em><span class="koboSpan" id="kobo.78.1">:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.79.1">Console</span></strong><span class="koboSpan" id="kobo.80.1">: This provider outputs logs to the console. </span><span class="koboSpan" id="kobo.80.2">A console window appears when debugging and most IDEs (contextually, Visual Studio and Visual Studio Code) provide a debugging console window for runtime logs.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.81.1">Debug</span></strong><span class="koboSpan" id="kobo.82.1">: This provider writes log entries using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.83.1">System.Diagnostics.Debug</span></strong><span class="koboSpan" id="kobo.84.1"> class.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.85.1">EventSource</span></strong><span class="koboSpan" id="kobo.86.1">: A cross-platform provider that can act as an event source with the name </span><em class="italic"><span class="koboSpan" id="kobo.87.1">Microsoft-Extensions-Logging</span></em><span class="koboSpan" id="kobo.88.1">.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.89.1">Windows Event Log</span></strong><span class="koboSpan" id="kobo.90.1">: A Windows-only provider that sends log output to the Windows Event Log. </span><span class="koboSpan" id="kobo.90.2">It will only log </span><em class="italic"><span class="koboSpan" id="kobo.91.1">Warning</span></em><span class="koboSpan" id="kobo.92.1"> level messages by default but can be configured as needed.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.93.1">Azure Log Stream</span></strong><span class="koboSpan" id="kobo.94.1">: Azure Log Stream supports viewing logs from the Azure portal during application runtime. </span><span class="koboSpan" id="kobo.94.2">We can easily write logs to this provider.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.95.1">To get our .NET application</span><a id="_idIndexMarker722"/><span class="koboSpan" id="kobo.96.1"> to begin writing logs, we can simply inject </span><strong class="source-inline"><span class="koboSpan" id="kobo.97.1">ILogger&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.98.1"> into the class from which logs should originate. </span><strong class="source-inline"><span class="koboSpan" id="kobo.99.1">T</span></strong><span class="koboSpan" id="kobo.100.1"> represents the name of the class that we are injecting the service into. </span><span class="koboSpan" id="kobo.100.2">This helps with log categorization and filtering later because the logs will automatically indicate the class name when they are generated. </span><strong class="source-inline"><span class="koboSpan" id="kobo.101.1">ILogger&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.102.1"> is usually used by application code, which may exist in several places. </span><span class="koboSpan" id="kobo.102.2">Because the class name is being used as a </span><em class="italic"><span class="koboSpan" id="kobo.103.1">category</span></em><span class="koboSpan" id="kobo.104.1">, it makes it easy for us to link the log entries back to the class that produced them. </span><span class="koboSpan" id="kobo.104.2">In the following code, we are injecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.105.1">ILogger&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.106.1"> into our appointments service controller:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.107.1">
public class AppointmentsController : ControllerBase
    {
        /* Other fields */
        private readonly ILogger&lt;AppointmentsController&gt;
            logger;
        public AppointmentsController(/* Other Services */,
            ILogger&lt;AppointmentsController&gt; logger)
        {
            this.logger = logger;
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.108.1">Injecting </span><strong class="source-inline"><span class="koboSpan" id="kobo.109.1">ILogger&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.110.1"> is standard compared to how we inject other services. </span><span class="koboSpan" id="kobo.110.2">The benefit of now having this logger present is that we can write logs to inform of the activities and errors in our API. </span><span class="koboSpan" id="kobo.110.3">If we need to log each time a list of appointments is retrieved through </span><a id="_idIndexMarker723"/><span class="koboSpan" id="kobo.111.1">an API call, we can modify our </span><strong class="source-inline"><span class="koboSpan" id="kobo.112.1">GET</span></strong><span class="koboSpan" id="kobo.113.1"> method like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.114.1">
// GET: api/Appointments
        [HttpGet]
        public async Task&lt;ActionResult&lt;Ienumerable
            &lt;Appointment&gt;&gt;&gt; GetAppointments()
        {
            Logger.LogInformation("Returning
                Appointments");
            return await _context.Appointments
               .ToListAsync();
        }</span></pre>
<p><span class="koboSpan" id="kobo.115.1">Now, when we make requests to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">GET</span></strong><span class="koboSpan" id="kobo.117.1"> method for this service, we will see a message that looks like this appear in our console. </span><span class="koboSpan" id="kobo.117.2">Here, “console” refers to the console window that launches and shows us startup messages about the running .NET application, as well as the debug output in the IDE we are using:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.118.1">
HealthCare.Appointments.Api.Controllers.AppointmentsController: Information: Retrieving appointments</span></pre>
<p><span class="koboSpan" id="kobo.119.1">Note that we can see not only the source calls but its namespace, which also plays a big role in helping us to determine which exact class is producing the log. </span><span class="koboSpan" id="kobo.119.2">We also get a log-level flag so that we can tell the severity at first glance. </span><span class="koboSpan" id="kobo.119.3">You will also notice that there are many other default log entries that we didn’t orchestrate. </span><span class="koboSpan" id="kobo.119.4">We can control the global levels and sources of logs that we wish to have in our application through the </span><strong class="source-inline"><span class="koboSpan" id="kobo.120.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.121.1"> file. </span><span class="koboSpan" id="kobo.121.2">By default, it will have the following configuration:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.122.1">
"Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.AspNetCore": "Warning"
    }
  },</span></pre>
<p><span class="koboSpan" id="kobo.123.1">This specifies that the minimum default level that should be output to the destinations is </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">Information</span></strong><span class="koboSpan" id="kobo.125.1"> for the default logging source. </span><span class="koboSpan" id="kobo.125.2">Anything related to the inner workings of our application should only surface when it is a </span><strong class="source-inline"><span class="koboSpan" id="kobo.126.1">Warning</span></strong><span class="koboSpan" id="kobo.127.1">. </span><span class="koboSpan" id="kobo.127.2">If we modified and placed them both</span><a id="_idIndexMarker724"/><span class="koboSpan" id="kobo.128.1"> at </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">Information</span></strong><span class="koboSpan" id="kobo.130.1">, then our logs would become far more chatty from the get-go.</span></p>
<p><span class="koboSpan" id="kobo.131.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.132.1">LogLevel</span></strong><span class="koboSpan" id="kobo.133.1"> methods have a standard layout that allows us to easily include additional information as </span><a id="_idIndexMarker725"/><span class="koboSpan" id="kobo.134.1">needed. </span><span class="koboSpan" id="kobo.134.2">The possible parameters are as follows:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.135.1">eventId</span></strong><span class="koboSpan" id="kobo.136.1">: A numeric value that you would associate with an action in your application. </span><span class="koboSpan" id="kobo.136.2">There is no predefined standard for this, and you can assign your own values based on your organization and needs. </span><span class="koboSpan" id="kobo.136.3">This is an optional parameter but can be useful when we need to associate logs with a particular action.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.137.1">Exception</span></strong><span class="koboSpan" id="kobo.138.1">: This is most useful when we are logging an error or critical message and wish to include the details of the exception in the log. </span><span class="koboSpan" id="kobo.138.2">It is optional, but it is strongly suggested that you include it whenever an exception object is available, such as after catching an exception in a </span><strong class="source-inline"><span class="koboSpan" id="kobo.139.1">try</span></strong><span class="koboSpan" id="kobo.140.1">/</span><strong class="source-inline"><span class="koboSpan" id="kobo.141.1">catch</span></strong><span class="koboSpan" id="kobo.142.1"> block.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.143.1">Message</span></strong><span class="koboSpan" id="kobo.144.1">: Message is a straightforward text field. </span><span class="koboSpan" id="kobo.144.2">It is arguably the most important one as it allows us to express our custom thoughts on the event being logged. </span><span class="koboSpan" id="kobo.144.3">It is a parameterized string that allows us to use placeholders and provide variable values, without needing to concatenate or interpolate the string. </span><span class="koboSpan" id="kobo.144.4">An example of such a text looks like “</span><em class="italic"><span class="koboSpan" id="kobo.145.1">Logging request from {username}</span></em><span class="koboSpan" id="kobo.146.1">”. </span><span class="koboSpan" id="kobo.146.2">The value of </span><strong class="source-inline"><span class="koboSpan" id="kobo.147.1">{username}</span></strong><span class="koboSpan" id="kobo.148.1"> should then be provided in </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">messageArgs</span></strong><span class="koboSpan" id="kobo.150.1">.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.151.1">messageArgs</span></strong><span class="koboSpan" id="kobo.152.1">: This is an array of objects that will bind to placeholders that are outlined in the message string. </span><span class="koboSpan" id="kobo.152.2">The binding will occur in the order that the parameters</span><a id="_idIndexMarker726"/><span class="koboSpan" id="kobo.153.1"> appear, so the values should be provided in that order as well. </span><span class="koboSpan" id="kobo.153.2">If a value is not provided, the placeholder will be printed out in the string.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.154.1">An example that uses</span><a id="_idIndexMarker727"/><span class="koboSpan" id="kobo.155.1"> all the parameters could look something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.156.1">
public async Task&lt;ActionResult&lt;AppointmentDetailsDto&gt;&gt;
    GetAppointment(Guid id)
        {
            try
            {
                var appointment = await
                    _context.Appointments.FindAsync(id);
                if (appointment == null)
                {
                    return NotFound();
                }
                // Other service calls
                var patient = await _patientsApiRepository
                    .GetPatient(appointment
                        .PatientId.ToString());
                var appointmentDto = _mapper.Map
                   &lt;AppointmentDetailsDto&gt;(appointment);
                appointmentDto.Patient =
                    _mapper.Map&lt;PatientDto&gt;(patient);
                return appointmentDto;
            }
            catch (Exception ex)
            {
                logger.LogError(100, ex, "Failure
                    retrieving apointment with Id: {id}",
                        id);
                throw;
            }
        }</span></pre>
<p><span class="koboSpan" id="kobo.157.1">Here, we added exception handling to our endpoint, which gets the appointment record by ID. </span><span class="koboSpan" id="kobo.157.2">If there is an exception in carrying out any of the operations, we catch it and log it. </span><span class="koboSpan" id="kobo.157.3">We are using </span><strong class="source-inline"><span class="koboSpan" id="kobo.158.1">100</span></strong><span class="koboSpan" id="kobo.159.1"> as the </span><strong class="source-inline"><span class="koboSpan" id="kobo.160.1">eventId</span></strong><span class="koboSpan" id="kobo.161.1"> property for this operation, and we are logging the exception and including a custom message with some more information to help us contextualize the nature of the exception. </span><span class="koboSpan" id="kobo.161.2">We also included the ID of the record that caused the failure; notice the </span><strong class="source-inline"><span class="koboSpan" id="kobo.162.1">{id}</span></strong><span class="koboSpan" id="kobo.163.1"> placeholder that will map to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">id</span></strong><span class="koboSpan" id="kobo.165.1"> argument. </span><span class="koboSpan" id="kobo.165.2">Giving your parameters the same name is not necessary, but it does help to reduce any confusion with </span><a id="_idIndexMarker728"/><span class="koboSpan" id="kobo.166.1">the value bindings.</span></p>
<p><span class="koboSpan" id="kobo.167.1">If we want to extend the number of providers that should be used for each log message, we can configure the logging settings in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.168.1">Program.cs</span></strong><span class="koboSpan" id="kobo.169.1"> file of our application. </span><span class="koboSpan" id="kobo.169.2">In a standard boilerplate ASP.NET Core project, we can add code that looks like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.170.1">
builder.Logging.ClearProviders();
builder.Logging.AddConsole()
    .AddEventLog(new EventLogSettings { SourceName =
        "Appointments Service" })
    .AddDebug()
    .AddEventSourceLogger();</span></pre>
<p><span class="koboSpan" id="kobo.171.1">First, we must clear any preconfigured providers and then add all the providers that we wish to support. </span><span class="koboSpan" id="kobo.171.2">Now, one log message will be written to several destinations. </span><span class="koboSpan" id="kobo.171.3">This can be a convenient way to fan out our log messages and have different monitoring methods attached to each destination. </span><span class="koboSpan" id="kobo.171.4">Remember that you should always be aware of the information security rules that govern your country and company and try not to expose too much information in too many places. </span><span class="koboSpan" id="kobo.171.5">We can also provide specific configurations per provider by modifying the logging configuration in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.173.1"> file, like</span><a id="_idIndexMarker729"/><span class="koboSpan" id="kobo.174.1"> this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.175.1">
{
  "Logging": {
    "LogLevel": {
      "Default": "Error",
      "Microsoft": "Warning",
      "Microsoft.Hosting.Lifetime": "Warning"
    },
    "Debug": {
      "LogLevel": {
        "Default": "Trace"
      }
    },
    "Console": {
      "LogLevel": {
        "Default": "Information"
      }
    },
    "EventSource": {
      "LogLevel": {
        "Microsoft": "Information"
      }
    },
    "EventLog": {
      "LogLevel": {
        "Microsoft": "Information"
      }
    },
  }
}</span></pre>
<p><span class="koboSpan" id="kobo.176.1">We retain our default </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">LogLevel</span></strong><span class="koboSpan" id="kobo.178.1"> for each log source, but then provide overrides per provider. </span><span class="koboSpan" id="kobo.178.2">If the log source is not defined underneath the provider’s configuration, then it will retain the </span><a id="_idIndexMarker730"/><span class="koboSpan" id="kobo.179.1">default behaviors, but we do reserve the right to control what type of log each provider should prioritize.</span></p>
<p><span class="koboSpan" id="kobo.180.1">If we need to extend support to Azure systems, we could make use of the Azure application’s file storage and/or blob storage. </span><span class="koboSpan" id="kobo.180.2">We can start by including </span><strong class="source-inline"><span class="koboSpan" id="kobo.181.1">Microsoft.Extensions.Logging.AzureAppServices</span></strong><span class="koboSpan" id="kobo.182.1"> via the </span><strong class="source-inline"><span class="koboSpan" id="kobo.183.1">NuGet</span></strong><span class="koboSpan" id="kobo.184.1"> package manager and then we can configure the logging services with code like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.185.1">
builder.Logging.AddAzureWebAppDiagnostics();
builder.Services.Configure&lt;AzureFileLoggerOptions&gt;
    (options =&gt;
{
    options.FileName = "azure-log-filename";
    options.FileSizeLimit = 5 * 2048;
    options.RetainedFileCountLimit = 15;
});
builder.Services.Configure&lt;AzureBlobLoggerOptions&gt;
    (options =&gt;
{
    options.BlobName = "appLog.log";
});</span></pre>
<p><span class="koboSpan" id="kobo.186.1">This will configure the app to use the filesystem as well as Blob storage in Azure. </span><span class="koboSpan" id="kobo.186.2">Based on App Services logs settings, there are some defaults that we can look for in terms of log output locations. </span><span class="koboSpan" id="kobo.186.3">Similarly, we can override the default logs that are being outputted by this provider by adding sections to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.188.1"> file with the aliases </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">AzureAppServicesBlob</span></strong><span class="koboSpan" id="kobo.190.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">AzureAppServicesFile</span></strong><span class="koboSpan" id="kobo.192.1">. </span><span class="koboSpan" id="kobo.192.2">We can also define </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">ApplicationInsights</span></strong><span class="koboSpan" id="kobo.194.1"> if we intend to use that service for our application. </span><span class="koboSpan" id="kobo.194.2">To support </span><strong class="source-inline"><span class="koboSpan" id="kobo.195.1">ApplicationInsights</span></strong><span class="koboSpan" id="kobo.196.1">, we need the </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">Microsoft.Extensions.Logging.ApplicationInsights</span></strong><span class="koboSpan" id="kobo.198.1"> NuGet package. </span><span class="koboSpan" id="kobo.198.2">Azure Application Insights is a powerful log aggregation platform provided by Microsoft Azure and is an excellent choice for an Azure-hosted solution.</span></p>
<p><span class="koboSpan" id="kobo.199.1">Several third-party</span><a id="_idIndexMarker731"/><span class="koboSpan" id="kobo.200.1"> frameworks extend the capabilities of the built-in logging API of .NET. </span><span class="koboSpan" id="kobo.200.2">We will explore how to integrate a popular one called </span><strong class="bold"><span class="koboSpan" id="kobo.201.1">Serilog</span></strong><span class="koboSpan" id="kobo.202.1"> in the next section.</span></p>
<h2 id="_idParaDest-210"><a id="_idTextAnchor225"/><span class="koboSpan" id="kobo.203.1">Adding Serilog</span></h2>
<p><span class="koboSpan" id="kobo.204.1">Several</span><a id="_idIndexMarker732"/><span class="koboSpan" id="kobo.205.1"> third-party</span><a id="_idIndexMarker733"/><span class="koboSpan" id="kobo.206.1"> frameworks exist that extend the logging capabilities and options available to us in our .NET applications. </span><span class="koboSpan" id="kobo.206.2">Popular</span><a id="_idIndexMarker734"/><span class="koboSpan" id="kobo.207.1"> options</span><a id="_idIndexMarker735"/><span class="koboSpan" id="kobo.208.1"> include </span><strong class="bold"><span class="koboSpan" id="kobo.209.1">Serilog</span></strong><span class="koboSpan" id="kobo.210.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.211.1">Loggr</span></strong><span class="koboSpan" id="kobo.212.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.213.1">Elmah.io</span></strong><span class="koboSpan" id="kobo.214.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.215.1">NLog</span></strong><span class="koboSpan" id="kobo.216.1"> to </span><a id="_idIndexMarker736"/><span class="koboSpan" id="kobo.217.1">name a few. </span><span class="koboSpan" id="kobo.217.2">Each one has its pros and cons, but in this section, we will be exploring Serilog, how we can integrate it into our application, and what options it introduces to us.</span></p>
<p><span class="koboSpan" id="kobo.218.1">Serilog extends </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">Microsoft.Extensions.Logging</span></strong><span class="koboSpan" id="kobo.220.1"> and provides quick and fairly easy ways to override the default settings while retaining the full power and flexibility of the original framework. </span><span class="koboSpan" id="kobo.220.2">To get started, we need to install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">Serilog.AspNetCore</span></strong><span class="koboSpan" id="kobo.222.1"> package. </span><span class="koboSpan" id="kobo.222.2">For non-web .NET Core projects, we need to use </span><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">Serilog.Extensions.Hosting</span></strong><span class="koboSpan" id="kobo.224.1">:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.225.1">
Install-package Serilog.AspNetCore</span></pre>
<p><span class="koboSpan" id="kobo.226.1">Serilog has the concept of using sinks. </span><span class="koboSpan" id="kobo.226.2">A sink is like a logging provider in concept and represents an output channel for the logs being written by the framework. </span><span class="koboSpan" id="kobo.226.3">We need to add additional packages per sink that we wish to support. </span><span class="koboSpan" id="kobo.226.4">Popularly used sinks include </span><em class="italic"><span class="koboSpan" id="kobo.227.1">Console</span></em><span class="koboSpan" id="kobo.228.1">, </span><em class="italic"><span class="koboSpan" id="kobo.229.1">File</span></em><span class="koboSpan" id="kobo.230.1">, </span><em class="italic"><span class="koboSpan" id="kobo.231.1">Seq</span></em><span class="koboSpan" id="kobo.232.1">, </span><em class="italic"><span class="koboSpan" id="kobo.233.1">SQL Server</span></em><span class="koboSpan" id="kobo.234.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.235.1">Azure Application Insights</span></em><span class="koboSpan" id="kobo.236.1">, just to name a few. </span><span class="koboSpan" id="kobo.236.2">You can get a complete list from their GitHub wiki page: </span><a href="https://github.com/serilog/serilog/wiki/Provided-Sinks"><span class="koboSpan" id="kobo.237.1">https://github.com/serilog/serilog/wiki/Provided-Sinks</span></a><span class="koboSpan" id="kobo.238.1">.</span></p>
<p><span class="koboSpan" id="kobo.239.1">For this exercise, we will be configuring Serilog to use the file and console sinks. </span><span class="koboSpan" id="kobo.239.2">We will also be adding parameters to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.241.1"> file. </span><span class="koboSpan" id="kobo.241.2">We will need the </span><em class="italic"><span class="koboSpan" id="kobo.242.1">expressions</span></em><span class="koboSpan" id="kobo.243.1"> extension to the base library to support parsing the JSON text into the required settings:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.244.1">
Install-package Serilog.Expressions</span></pre>
<p><span class="koboSpan" id="kobo.245.1">Now, we can remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">Logging</span></strong><span class="koboSpan" id="kobo.247.1"> section from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.249.1"> file and replace it with </span><a id="_idIndexMarker737"/><span class="koboSpan" id="kobo.250.1">the</span><a id="_idIndexMarker738"/><span class="koboSpan" id="kobo.251.1"> following JSON text:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.252.1">
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "Microsoft.Hosting.Lifetime": "Information"
      }
    },
    "WriteTo": [
      {
        "Name": "File",
        "Args": { "path":  "./logs/log-.txt",
           "rollingInterval": "Day" }
      }
    ]
  },</span></pre>
<p><span class="koboSpan" id="kobo.253.1">Now, we have a similar structure where we can define logging defaults for the application, but we also have a </span><strong class="source-inline"><span class="koboSpan" id="kobo.254.1">WriteTo</span></strong><span class="koboSpan" id="kobo.255.1"> section that allows us to list the different channels that we want to support. </span><span class="koboSpan" id="kobo.255.2">We have only included the settings for </span><strong class="source-inline"><span class="koboSpan" id="kobo.256.1">File</span></strong><span class="koboSpan" id="kobo.257.1"> writes, and we have specified the target location to be a local folder called </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">logs</span></strong><span class="koboSpan" id="kobo.259.1">. </span><span class="koboSpan" id="kobo.259.2">Files will be created daily and automatically be given a name that is a combination of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.260.1">log-</span></strong><span class="koboSpan" id="kobo.261.1"> expression and a date. </span><span class="koboSpan" id="kobo.261.2">This will make it easy for us to source the relevant files by day and each log will indicate a timestamp, making it easier to review the events.</span></p>
<p><span class="koboSpan" id="kobo.262.1">Now, we can remove the </span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1">builder.Logging(…)</span></strong><span class="koboSpan" id="kobo.264.1"> configuration and replace it with this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.265.1">
  builder.Host.UseSerilog((ctx, lc) =&gt; lc
        .WriteTo.Console()
        .ReadFrom.Configuration(ctx.Configuration));</span></pre>
<p><span class="koboSpan" id="kobo.266.1">This will initialize our logger to use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">Console</span></strong><span class="koboSpan" id="kobo.268.1"> sink and read the configuration object for the Serilog section defined previously. </span><span class="koboSpan" id="kobo.268.2">This will initialize the </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">Console</span></strong><span class="koboSpan" id="kobo.270.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">File</span></strong><span class="koboSpan" id="kobo.272.1"> sinks. </span><span class="koboSpan" id="kobo.272.2">We can now look forward to seeing text files getting created and populated daily for each microservice that has implemented the file logging configuration for Serilog. </span><span class="koboSpan" id="kobo.272.3">The code that is needed to write the logs remains the same. </span><span class="koboSpan" id="kobo.272.4">We only need to repeat the injection steps outlined for </span><strong class="source-inline"><span class="koboSpan" id="kobo.273.1">ILogger&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.274.1">; Serilog will do the rest.</span></p>
<p><span class="koboSpan" id="kobo.275.1">Now, we have solved one issue where we are no longer blind to what is happening in our application. </span><span class="koboSpan" id="kobo.275.2">We can easily integrate logging into our services and review a more persistent output in the form of log files. </span><span class="koboSpan" id="kobo.275.3">However, we still have the challenge of needing to review several disparate logs across different systems to properly track what may have led to a failure at some point.</span></p>
<p><span class="koboSpan" id="kobo.276.1">This is where </span><a id="_idIndexMarker739"/><span class="koboSpan" id="kobo.277.1">we</span><a id="_idIndexMarker740"/><span class="koboSpan" id="kobo.278.1"> need to explore methods of aggregating the logs and having them visible and searchable from one interface. </span><span class="koboSpan" id="kobo.278.2">We will explore how this can be done in the next section.</span></p>
<h1 id="_idParaDest-211"><a id="_idTextAnchor226"/><span class="koboSpan" id="kobo.279.1">Log aggregation and its uses</span></h1>
<p><span class="koboSpan" id="kobo.280.1">Log aggregation is the</span><a id="_idIndexMarker741"/><span class="koboSpan" id="kobo.281.1"> concept </span><a id="_idIndexMarker742"/><span class="koboSpan" id="kobo.282.1">of capturing and consolidating logs from different sources into a centralized platform. </span><span class="koboSpan" id="kobo.282.2">This comes in handy in a distributed system where logs are generated from several sources, and we need a comprehensive view of all the messages and need to correlate and analyze the logs efficiently.</span></p>
<p><span class="koboSpan" id="kobo.283.1">This log aggregation acts as a single source of truth when we need to troubleshoot application performance and errors or identify bottlenecks and points of failure or vulnerability. </span><span class="koboSpan" id="kobo.283.2">Several platforms allow us to aggregate our logs and they range from free to paid to </span><a id="_idIndexMarker743"/><span class="koboSpan" id="kobo.284.1">cloud-hosted</span><a id="_idIndexMarker744"/><span class="koboSpan" id="kobo.285.1"> solutions. </span><span class="koboSpan" id="kobo.285.2">Some popular ones are </span><em class="italic"><span class="koboSpan" id="kobo.286.1">Azure Application Insights</span></em><span class="koboSpan" id="kobo.287.1">, </span><em class="italic"><span class="koboSpan" id="kobo.288.1">Seq, DataDog</span></em><span class="koboSpan" id="kobo.289.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.290.1">ELK (Elasticsearch, Logstash, and Kibana)</span></em><span class="koboSpan" id="kobo.291.1">, to name a few. </span><span class="koboSpan" id="kobo.291.2">In selecting a platform, we must consider the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.292.1">Efficiency</span></strong><span class="koboSpan" id="kobo.293.1">: We all love</span><a id="_idIndexMarker745"/><span class="koboSpan" id="kobo.294.1"> and want efficient systems. </span><span class="koboSpan" id="kobo.294.2">The platform that we choose needs to feed into this narrative and make it as easy as possible to integrate logging, export log information in various formats, and sift and sort through log information as quickly as possible. </span><span class="koboSpan" id="kobo.294.3">Most log aggregators allow us to author queries that can intelligently sift through the logging noise and give us more pointed data.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.295.1">Processing power</span></strong><span class="koboSpan" id="kobo.296.1">: The platform needs to allow for comfortable throughput from several sources and be able to index, compress, and efficiently store these logs. </span><span class="koboSpan" id="kobo.296.2">We may not necessarily know their techniques to achieve this, but we can assess the accuracy of the indexing functions through our queries and the overall presentation of the data.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.297.1">Real-time features</span></strong><span class="koboSpan" id="kobo.298.1">: Real-time monitoring is very important since we generally need log aggregation to monitor what is happening in our application. </span><span class="koboSpan" id="kobo.298.2">The more quickly the information is made available to us, the more quickly we can respond to a failure.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.299.1">Scalability</span></strong><span class="koboSpan" id="kobo.300.1">: The platform needs to be capable of handling varied periods of traffic and not breaking when there is a sudden shift in volume. </span><span class="koboSpan" id="kobo.300.2">We need to ensure that the performance of the system does not degrade under increased load.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.301.1">Alerting mechanisms</span></strong><span class="koboSpan" id="kobo.302.1">: Some platforms have the built-in functionality to alert us to certain types of log events. </span><span class="koboSpan" id="kobo.302.2">Even if this is not built-in, we should have integration options through </span><em class="italic"><span class="koboSpan" id="kobo.303.1">APIs</span></em><span class="koboSpan" id="kobo.304.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.305.1">WebHooks</span></em><span class="koboSpan" id="kobo.306.1"> that allow us to integrate with our third-party applications, which is where we spend most of our time.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.307.1">Security</span></strong><span class="koboSpan" id="kobo.308.1">: Security is very important for our logging information, as we have mentioned previously. </span><span class="koboSpan" id="kobo.308.2">An ideal platform will encrypt data while it is at rest and while it is in transit. </span><span class="koboSpan" id="kobo.308.3">This is often a given, but we need to make sure. </span><span class="koboSpan" id="kobo.308.4">We may also need to be able to control user access.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.309.1">Cost</span></strong><span class="koboSpan" id="kobo.310.1">: We all love free and cheap solutions. </span><span class="koboSpan" id="kobo.310.2">We cannot always have the best of both worlds but we can be sure that the platform offers a good return on the investment, relative </span><a id="_idIndexMarker746"/><span class="koboSpan" id="kobo.311.1">to the features that we are being offered. </span><span class="koboSpan" id="kobo.311.2">Ensure that you do a proper cost-benefit analysis.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.312.1">The easier way to integrate with a log aggregation platform is through tools and packages that are optimized for that kind of integration. </span><span class="koboSpan" id="kobo.312.2">We need to employ the services of libraries</span><a id="_idIndexMarker747"/><span class="koboSpan" id="kobo.313.1"> that </span><a id="_idIndexMarker748"/><span class="koboSpan" id="kobo.314.1">are tuned to efficiently integrate with these platforms. </span><span class="koboSpan" id="kobo.314.2">In the next section, we will see how we can leverage </span><em class="italic"><span class="koboSpan" id="kobo.315.1">Serilog</span></em><span class="koboSpan" id="kobo.316.1"> and integrate with </span><em class="italic"><span class="koboSpan" id="kobo.317.1">Seq</span></em><span class="koboSpan" id="kobo.318.1">.</span></p>
<h2 id="_idParaDest-212"><a id="_idTextAnchor227"/><span class="koboSpan" id="kobo.319.1">Integrating with Seq</span></h2>
<p><em class="italic"><span class="koboSpan" id="kobo.320.1">Seq</span></em><span class="koboSpan" id="kobo.321.1">, pronounced </span><a id="_idIndexMarker749"/><span class="koboSpan" id="kobo.322.1">seek, is a sleek (see what I did there?) log</span><a id="_idIndexMarker750"/><span class="koboSpan" id="kobo.323.1"> aggregation developed and maintained by </span><em class="italic"><span class="koboSpan" id="kobo.324.1">Datalust</span></em><span class="koboSpan" id="kobo.325.1">. </span><span class="koboSpan" id="kobo.325.2">This platform has been developed to support log messaging templates output by </span><em class="italic"><span class="koboSpan" id="kobo.326.1">ASP.NET Core</span></em><span class="koboSpan" id="kobo.327.1">, </span><em class="italic"><span class="koboSpan" id="kobo.328.1">Serilog</span></em><span class="koboSpan" id="kobo.329.1">, and </span><em class="italic"><span class="koboSpan" id="kobo.330.1">Nlog</span></em><span class="koboSpan" id="kobo.331.1">. </span><span class="koboSpan" id="kobo.331.2">It can also be extended to support other development frameworks as needed.</span></p>
<p><span class="koboSpan" id="kobo.332.1">It gives us access to a powerful dashboard with leading data presentation and querying features. </span><em class="italic"><span class="koboSpan" id="kobo.333.1">Seq</span></em><span class="koboSpan" id="kobo.334.1"> can be installed on a local machine for free for individual development but will attract some costs as we look to use it in a more enterprise setting. </span><span class="koboSpan" id="kobo.334.2">It also offers a hosted solution, which removes the need for users to set it up locally.</span></p>
<p><span class="koboSpan" id="kobo.335.1">For this activity, we will use it locally and for free on our machine. </span><span class="koboSpan" id="kobo.335.2">We now have two options; we can use a </span><em class="italic"><span class="koboSpan" id="kobo.336.1">Docker</span></em><span class="koboSpan" id="kobo.337.1"> image and spin up a container for the application or install it on our local machine. </span><span class="koboSpan" id="kobo.337.2">It is available for </span><em class="italic"><span class="koboSpan" id="kobo.338.1">Windows</span></em><span class="koboSpan" id="kobo.339.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.340.1">Linux</span></em><span class="koboSpan" id="kobo.341.1"> operating systems, so we will use the </span><em class="italic"><span class="koboSpan" id="kobo.342.1">Docker</span></em><span class="koboSpan" id="kobo.343.1"> option to cater to all scenarios.</span></p>
<p><span class="koboSpan" id="kobo.344.1">We will start by downloading the Docker image with this command:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.345.1">
docker pull datalust/seq</span></pre>
<p><span class="koboSpan" id="kobo.346.1">Now that we have the latest Seq image, we will create our container with this command:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.347.1">
docker run -–name seq -d --restart unless-stopped -e
ACCEPT_EULA=Y -p 5341:80 datalust/seq:latest</span></pre>
<p><span class="koboSpan" id="kobo.348.1">Now, we have a container that hosts an instance of Seq and can be accessed through port 5431, which is Seq’s default port. </span><span class="koboSpan" id="kobo.348.2">We can now navigate to </span><strong class="source-inline"><span class="koboSpan" id="kobo.349.1">http://localhost:5341/#/events</span></strong><span class="koboSpan" id="kobo.350.1"> to see our user interface for the aggregator. </span><span class="koboSpan" id="kobo.350.2">It will be empty, so now, we need to integrate our API with this new logging channel.</span></p>
<p><span class="koboSpan" id="kobo.351.1">Now that we have Seq up and running, we can modify our service to begin sending logs to this platform. </span><span class="koboSpan" id="kobo.351.2">We already have Serilog installed, so we can add the Seq sink to our project by adding this package:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.352.1">
Install-Package Serilog.Sinks.Seq</span></pre>
<p><span class="koboSpan" id="kobo.353.1">With this new package, we can modify our </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">appsettings.json</span></strong><span class="koboSpan" id="kobo.355.1"> Serilog section and add a new </span><a id="_idIndexMarker751"/><span class="koboSpan" id="kobo.356.1">object </span><a id="_idIndexMarker752"/><span class="koboSpan" id="kobo.357.1">block to the </span><strong class="source-inline"><span class="koboSpan" id="kobo.358.1">WriteTo</span></strong><span class="koboSpan" id="kobo.359.1"> section of the configuration. </span><span class="koboSpan" id="kobo.359.2">It will now look like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.360.1">
"WriteTo": [
      {
        //  File Configuration
      },
      {
        "Name": "Seq",
        "Args": { "serverUrl": "http://localhost:5341" }
      }
    ]</span></pre>
<p><span class="koboSpan" id="kobo.361.1">We already have the configuration section being read at application startup, so the next time that the application starts up, all the default logs will be written to our local file as expected, but now also the Seq platform.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.362.1">Figure 14.1</span></em><span class="koboSpan" id="kobo.363.1"> shows the Seq interface:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer070">
<span class="koboSpan" id="kobo.364.1"><img alt="Figure 14.1 – The Seq interface receiving logs from a microservice" src="image/Figure_14.1_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.365.1">Figure 14.1 – The Seq interface receiving logs from a microservice</span></p>
<p><span class="koboSpan" id="kobo.366.1">Here, we can see the user interface outlining the default logs that get produced at application startup. </span><span class="koboSpan" id="kobo.366.2">What appears in this interface is relative to the logging configurations that we have added, as well as the log entries that we make as we go along. </span><span class="koboSpan" id="kobo.366.3">You will also notice some color-coded dots, which indicate the log level for the log entry. </span><span class="koboSpan" id="kobo.366.4">We can click on a line and expand it to see the details of the log message.</span></p>
<p><span class="koboSpan" id="kobo.367.1">Now, these code modifications can be made to all services that we wish to add to the log </span><a id="_idIndexMarker753"/><span class="koboSpan" id="kobo.368.1">aggregation </span><a id="_idIndexMarker754"/><span class="koboSpan" id="kobo.369.1">initiative, and we can use this unified platform to interrogate logs as needed. </span><span class="koboSpan" id="kobo.369.2">With this in place, we need to understand the concept of log tracing in a distributed setting. </span><span class="koboSpan" id="kobo.369.3">We will discuss this next.</span></p>
<h1 id="_idParaDest-213"><a id="_idTextAnchor228"/><span class="koboSpan" id="kobo.370.1">Distributed log tracing</span></h1>
<p><span class="koboSpan" id="kobo.371.1">Distributed tracing is </span><a id="_idIndexMarker755"/><span class="koboSpan" id="kobo.372.1">the method of monitoring logs and tracing issues in a microservices application. </span><span class="koboSpan" id="kobo.372.2">Developers and DevOps engineers both rely on logs to follow the path of a request as it travels through the various systems and checkpoints and then attempts to ascertain the point of failure. </span><span class="koboSpan" id="kobo.372.3">The more robust the logging, the easier it will be for them to pinpoint weak points, bugs, and bottlenecks in the application.</span></p>
<p><span class="koboSpan" id="kobo.373.1">Because microservices are designed to be autonomous and scale independently, it is common to have multiple instances of the service running simultaneously, which further complicates the request tracing process. </span><span class="koboSpan" id="kobo.373.2">We now need to backtrack which instance of the service handled the request, leading to even more complex tracing situations.</span></p>
<p><span class="koboSpan" id="kobo.374.1">Distributed tracing is a technique that is geared toward solving these problems. </span><span class="koboSpan" id="kobo.374.2">It refers to a diagnostic methodology behind observing requests as they make their way through distributed systems. </span><span class="koboSpan" id="kobo.374.3">Each trace shows the activity of an individual user in the application. </span><span class="koboSpan" id="kobo.374.4">In an aggregated logging system, we will end up with a collection of traces that highlight the backend service and dependencies that have the biggest impact on performance. </span><span class="koboSpan" id="kobo.374.5">In distributed tracing, we have three main factors that help us to find our way around:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.375.1">Trace</span></strong><span class="koboSpan" id="kobo.376.1">: Represents an end-to-end request from user activity.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.377.1">Span</span></strong><span class="koboSpan" id="kobo.378.1">: Represents work done by a single service in a specific period. </span><span class="koboSpan" id="kobo.378.2">Spans combine to form a trace.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.379.1">Tags</span></strong><span class="koboSpan" id="kobo.380.1">: Metadata about the span that helps us to properly categorize and contextualize the logs.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.381.1">Each span is a step in the entire journey of the request and is encoded with important data relating to the</span><a id="_idIndexMarker756"/><span class="koboSpan" id="kobo.382.1"> process that is carried out in the operation. </span><span class="koboSpan" id="kobo.382.2">This information can include things such as the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.383.1">The service’s name and address</span></li>
<li><span class="koboSpan" id="kobo.384.1">Tags that can be used in queries and filters, such as the HTTP method, database host, and session ID, to name a few</span></li>
<li><span class="koboSpan" id="kobo.385.1">Stack traces and details error messages</span></li>
</ul>
<p><span class="koboSpan" id="kobo.386.1">.NET has evolved over the years to provide top-notch support for producing logs with these details as seamlessly as possible, through integrations with </span><strong class="source-inline"><span class="koboSpan" id="kobo.387.1">OpenTelemetry</span></strong><span class="koboSpan" id="kobo.388.1">. </span><span class="koboSpan" id="kobo.388.2">Microsoft Azure also provides an excellent distributed tracing platform in </span><em class="italic"><span class="koboSpan" id="kobo.389.1">Azure Application Insights</span></em><span class="koboSpan" id="kobo.390.1">, which is a platform that we mentioned previously. </span><span class="koboSpan" id="kobo.390.2">There are many other paid and open source solutions that can support our distributed tracing needs. </span><span class="koboSpan" id="kobo.390.3">For this chapter, we will use a free and simple platform called Jaeger. </span><span class="koboSpan" id="kobo.390.4">Let us explore how we can add telemetry enhancements to our services and visualize them with Jaeger.</span></p>
<h2 id="_idParaDest-214"><a id="_idTextAnchor229"/><span class="koboSpan" id="kobo.391.1">Enhanced logging for distributed tracing</span></h2>
<p><strong class="source-inline"><span class="koboSpan" id="kobo.392.1">OpenTelemetry</span></strong><span class="koboSpan" id="kobo.393.1"> is a</span><a id="_idIndexMarker757"/><span class="koboSpan" id="kobo.394.1"> popular open source project that</span><a id="_idIndexMarker758"/><span class="koboSpan" id="kobo.395.1"> is at the helm of standardizing logging standards for distributed and cloud-native applications. </span><span class="koboSpan" id="kobo.395.2">It helps us to generate and collect detailed logs, also called telemetry data, that contain traces and metrics. </span><span class="koboSpan" id="kobo.395.3">Given that it is an open standard, we are at liberty to choose a suitable visualization and analysis tool.</span></p>
<p><span class="koboSpan" id="kobo.396.1">To install </span><strong class="source-inline"><span class="koboSpan" id="kobo.397.1">OpenTelemetry</span></strong><span class="koboSpan" id="kobo.398.1"> in our ASP.NET Core application, we need to execute the following commands in </span><strong class="source-inline"><span class="koboSpan" id="kobo.399.1">dotnet cli</span></strong><span class="koboSpan" id="kobo.400.1">:</span></p>
<pre class="console"><span class="koboSpan" id="kobo.401.1">
dotnet add package --prerelease
    OpenTelemetry.Instrumentation.AspNetCore
dotnet add package OpenTelemetry.Exporter.Jaeger
dotnet add package --prerelease
    OpenTelemetry.Extensions.Hosting</span></pre>
<p><span class="koboSpan" id="kobo.402.1">Between these three packages, we are installing ASP.NET Core </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">OpenTelemetry</span></strong><span class="koboSpan" id="kobo.404.1"> support and support for exporting our telemetry data to a distributed tracing analysis platform called Jaeger. </span><span class="koboSpan" id="kobo.404.2">Jaeger is free and can be downloaded in ZIP format or set up as a Docker container. </span><span class="koboSpan" id="kobo.404.3">You can learn more here: </span><a href="https://www.jaegertracing.io/download/"><span class="koboSpan" id="kobo.405.1">https://www.jaegertracing.io/download/</span></a><span class="koboSpan" id="kobo.406.1">.</span></p>
<p><span class="koboSpan" id="kobo.407.1">Now that we have the packages, we can make the following adjustments to our </span><strong class="source-inline"><span class="koboSpan" id="kobo.408.1">Program.cs</span></strong><span class="koboSpan" id="kobo.409.1"> file:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.410.1">
builder.Services.AddOpenTelemetryTracing((builder) =&gt;
    builder
        .AddAspNetCoreInstrumentation(o =&gt;
        {
            o.EnrichWithHttpRequest = (activity,
                httpRequest) =&gt;
            {
                activity.SetTag("requestProtocol",
                    httpRequest.Protocol);
            };
            o.EnrichWithHttpResponse = (activity,
                httpResponse) =&gt;
            {
                activity.SetTag("responseLength",
                    httpResponse.ContentLength);
            };
            o.EnrichWithException = (activity,
                exception) =&gt;
            {
                activity.SetTag("exceptionType",
                    exception.GetType().ToString());
            };
        })
        .AddJaegerExporter()
    );</span></pre>
<p><span class="koboSpan" id="kobo.411.1">With this configuration, we are adding </span><strong class="source-inline"><span class="koboSpan" id="kobo.412.1">OpenTelemetry</span></strong><span class="koboSpan" id="kobo.413.1"> support to our application’s startup and </span><a id="_idIndexMarker759"/><span class="koboSpan" id="kobo.414.1">then</span><a id="_idIndexMarker760"/><span class="koboSpan" id="kobo.415.1"> outlining various enrichments that we wish to include with each message that is sent to Jaeger. </span><span class="koboSpan" id="kobo.415.2">Note that </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">OpenTelemetry</span></strong><span class="koboSpan" id="kobo.417.1"> has support for a few platforms, and you are at liberty to choose the one that best suits your needs. </span><span class="koboSpan" id="kobo.417.2">With this configuration, all traffic to our API endpoints will be logged with as many enrichment data points as we specified.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.418.1">Figure 14.2</span></em><span class="koboSpan" id="kobo.419.1"> shows the Jaeger interface:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer071">
<span class="koboSpan" id="kobo.420.1"><img alt="Figure 14.2 – Telemetry data that has been generated and deposited in the Jaeger aggregation platform" src="image/Figure_14.2_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.421.1">Figure 14.2 – Telemetry data that has been generated and deposited in the Jaeger aggregation platform</span></p>
<p><span class="koboSpan" id="kobo.422.1">Jaeger is simple enough for us to get started and, as depicted in </span><em class="italic"><span class="koboSpan" id="kobo.423.1">Figure 14.2</span></em><span class="koboSpan" id="kobo.424.1">, we can view all the services that send telemetry data, filter based on the operations we need to see, and review data across a specified timeline. </span><span class="koboSpan" id="kobo.424.2">These are general features of distributed</span><a id="_idIndexMarker761"/><span class="koboSpan" id="kobo.425.1"> tracing </span><a id="_idIndexMarker762"/><span class="koboSpan" id="kobo.426.1">platforms and, once again, we need to ensure that we choose one that gives us the best value for our needs.</span></p>
<p><span class="koboSpan" id="kobo.427.1">Now that we have explored logging and distributed tracing, let us wrap up this chapter.</span></p>
<h1 id="_idParaDest-215"><a id="_idTextAnchor230"/><span class="koboSpan" id="kobo.428.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.429.1">Logging is a simple concept that can save us a lot of time and trouble when reviewing our applications. </span><span class="koboSpan" id="kobo.429.2">The ability to write logs ships with .NET Core and we can easily leverage the native capabilities to begin producing log information about the operations of our applications.</span></p>
<p><span class="koboSpan" id="kobo.430.1">We need to ensure that we do not log sensitive information and we must be aware of company and security policies when authoring our logs. </span><span class="koboSpan" id="kobo.430.2">We also need to ensure that our logs are stored securely both in transit and at rest. </span><span class="koboSpan" id="kobo.430.3">We also can log to multiple channels, but we should be careful when choosing these channels, relative to our security guidelines.</span></p>
<p><span class="koboSpan" id="kobo.431.1">Several .NET Core frameworks enhance the natural capabilities of the built-in API and introduce even more integrations. </span><span class="koboSpan" id="kobo.431.2">A popular choice is Serilog, which has many extensions called sinks, which offer us a wide range of simultaneous log channel options. </span><span class="koboSpan" id="kobo.431.3">With it, we can easily create and manage log files on a rolling interval that we specify.</span></p>
<p><span class="koboSpan" id="kobo.432.1">Ideally, we will have multiple services writing logs and it will be tedious having each one log to its own file. </span><span class="koboSpan" id="kobo.432.2">This will force us to review multiple files to trace one request that might have spanned many touch points in our distributed application. </span><span class="koboSpan" id="kobo.432.3">For this reason, we employ the services of an aggregator, which will give our services a central area to deposit logs and give us and our team one area to focus on when sifting through logs.</span></p>
<p><span class="koboSpan" id="kobo.433.1">Then, we ran into another issue where our logs need to contain certain details that allow us to properly associate them with a request. </span><span class="koboSpan" id="kobo.433.2">After, we looked at enriching our logs with unique IDs that help us to associate them to a point of origin and each other. </span><span class="koboSpan" id="kobo.433.3">This is called distributed tracing. </span><span class="koboSpan" id="kobo.433.4">We also reviewed how to include </span><strong class="source-inline"><span class="koboSpan" id="kobo.434.1">OpenTelemetry</span></strong><span class="koboSpan" id="kobo.435.1"> in our service and the use of a visualization tool to assist with the querying activities.</span></p>
<p><span class="koboSpan" id="kobo.436.1">Now we have finished exploring logging activities and best practices in a distributed system, in the next chapter, we will conclude what we have learned so far.</span></p>
</div>
</body></html>