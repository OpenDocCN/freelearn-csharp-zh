- en: Game Loop and Update Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we are going to explore the Game Loop and Update Method. Both
    are core game development patterns that are often confused with each other by
    beginners because they both can be associated with the concept of continuous looping
    sequences. But, as we are going to see, the Game Loop and Update Method might
    be related, but have very distinct responsibilities and are implemented on different
    layers of Unity's architecture.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to understand the core principles behind the Game Loop and Update
    Method, then we need to consider what video games are in their most basic forms.
    The best definition I have encountered is that video games are simulations composed
    of interactive virtual spaces filled with objects and animated entities, with
    distinct behaviors. These virtual spaces are drawn frame by frame on a screen,
    while the continually-running system listens and reacts accordingly to a user's
    input.
  prefs: []
  type: TYPE_NORMAL
- en: But what exactly makes it possible for a video game to continually run a simulation
    and react to a user's input without any latency? The answer is the combination
    of the Game Loop, which can be described as the heartbeat of a running game, but
    also the Update Method, which can act as the ears of the system.
  prefs: []
  type: TYPE_NORMAL
- en: But as a Unity developer, you will never have to write a Game Loop or Update
    Method by hand, because they are already natively implemented in the engine. So,
    in the following sections, we are just going to explore the theory behind these
    patterns, so that we are of their presence when we are working in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following topic will be covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: A quick review of the core concepts behind the Game Loop and Update Method patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will focus on theory instead of practice; a basic understanding
    of programming is enough for this material.
  prefs: []
  type: TYPE_NORMAL
- en: What makes a game run?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As stated before, video games are simulations; a bullet buzzing through the
    air and then hitting an enemy combatant in *Call of Duty* is made possible because
    of a collection of systems interacting together to give the illusion that a 3D
    cylinder-shaped mesh traveling through space on a curved vector is being affected
    by gravity and wind resistance.
  prefs: []
  type: TYPE_NORMAL
- en: But the question we need to answer is, what is driving all these systems to
    run in perfect synchronization? Contrary to a spreadsheet or a browser, a video
    game is not event-driven; it's continuously processing, even when the player is
    not pressing any buttons. By implementing the Game Loop pattern, it's possible
    to have a system that cycles on itself at a constant rate, while calling sub-systems
    in perfect synchronicity, but still being able to react dynamically to a user's
    input.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, in this section, we will review two core concepts: the implementation of
    the main loop, and the importance of timing, because the primary purpose of the
    Game Loop is to simulate time, not just execute code over and over again.'
  prefs: []
  type: TYPE_NORMAL
- en: You might notice that game designers often talk about core game loops. They
    are usually referring to what we call experience or reward loops. This subject
    is beyond the scope of this book, but we could say that games are composed of
    loops at almost every level.
  prefs: []
  type: TYPE_NORMAL
- en: The main loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Even during the early 1980s, when programmers wrote games in pure assembly language
    without the help of an engine such as Unity, the concept of Game Loops existed.
    During that time, the implementation of a Game Loop needed to be precise in its
    timing, because it had to synchronize correctly with the movement of a CRT's television
    electron gun, or the image on the screen would get distorted and the game would
    become unresponsive.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an example of a game loop written in assembly for an Atari
    2600\. You can see the main routine calling a specific sequence of sub-routines
    cyclically. Each sub-routine runs at a particular phase of an analog television''s
    screen drawing sequence. Between every step, you can do calculations, capture
    the player''s input, or draw sprites:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The modern day implementations of a game loop are not that different, they might
    be more sophisticated, but the core principles and sequencing pattern are similar.
    Every game loop must gather the player's input data and calculate new transforms
    on the entities in the scene before calling the rendering pipeline (also known
    as the draw loop). You can't draw something before knowing where things are supposed
    to be related to the most recent input of the player.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed that one of the primary responsibilities of the
    Game Loop is to make sure that subroutines are called in the right order at every
    cycle. In other words, it's maintaining a continuous sequence of system calls.
    But in the next section, we are going to review another important responsibility
    of the Game Loop, which is keeping a degree of consistent timing.
  prefs: []
  type: TYPE_NORMAL
- en: Always keep in mind that a Game Loop and the Update Method are related, but
    they're not the same. They're both sequential patterns, but are not implemented
    the same way, and don't have the same responsibilities.
  prefs: []
  type: TYPE_NORMAL
- en: It's all about timing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As with comedy, timing is key to game programming; complex physics calculations
    are executed while thousands of pixels are rendered on a screen in a matter of
    milliseconds. Being aware of what is being called at every frame is key to mastering
    optimization.
  prefs: []
  type: TYPE_NORMAL
- en: In an engine such as Unity, the core game loop and rendering pipeline are abstracted,
    and we can only hook into its sequencing mechanism by the Scripting API's magic
    functions, such as: `FixedUpdate()`, `Update()`, and `LateUpdate()`. This approach
    permits the engine to protect its internal clock and its established sequence
    of system calls, while giving us the ability to execute code at specific moments
    of the Game Loop safely.
  prefs: []
  type: TYPE_NORMAL
- en: But the trade-off is that we lose granular control over the exact moment a specific
    system is updated. In most cases, this is not an issue, but for massive AAA production,
    this limitation can be a deal-breaker. Often, complex CPU-intensive games need
    a more granular approach to managing the timing of precise calculations; when
    having a ticking mechanism, this becomes essential. Instead of relying on trying
    to synchronize with the CPU's internal clock, Game Loops have a ticking mechanism
    that's very similar to what an analog watch might have. Like a clock, the Game
    Loop doesn't cycle around, but ticks. The Game Loop manages the variation of time
    between these ticks instead, depending on available operating systems and hardware
    resources. This approach permits us to have a more granular control in the way
    we schedule the processing time of specific game systems between every frame.
  prefs: []
  type: TYPE_NORMAL
- en: In the game industry, the terms *frame* and *tick* are often used interchangeably,
    but be careful, because they're not necessarily synonyms. We could say a **frame**
    is a unit of time based on the delay it takes to generate and draw a new frame
    onto the screen. And a **tick** is a unit of time that's related to a game's internal
    clock, which is simulated by the execution of the main game loop; it's similar
    to an analog clock's second hand ticks as it goes around the clock.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous sections, we examined a very high-level and simplified overview
    of the Game Loop pattern. Of course, the actual implementation details of a Game
    Loop in a modern AAA game engine is beyond the scope of this book. For those that
    want to dive deep into the subject matter, and have a more academic understanding
    of the subject matter, I recommend reading the listed books in the *Further reading*
    section.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we are going to explore Unity's implementation of the Update
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Update Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If we all agree that the Game Loop pattern's main goal is to abstract a CPU's
    clock cycle by implementing a ticker so we can time the execution of our code
    on every frame, in a consistent manner, then we could say that the Update Method
    pattern simplifies this process by offering a way to encapsulate our game entities,
    and let them update themselves on each frame.
  prefs: []
  type: TYPE_NORMAL
- en: In the following section of this book, we are going to review the Update Method
    and its implementation inside the Unity engine.
  prefs: []
  type: TYPE_NORMAL
- en: Over the years, I've noticed that game programming consists mostly of manipulating
    data with perfect timing. So, knowing how to manage data, and time, is essential
    for mastery of game programming.
  prefs: []
  type: TYPE_NORMAL
- en: Overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the biggest challenges of implementing a Game Loop is keeping track of
    all the entities contained inside a scene, and how to update their states at every
    frame. But the Update Method offers a scalable, but straightforward solution,
    by having every object expose an `Update()` function that's called every frame.
  prefs: []
  type: TYPE_NORMAL
- en: The Game Loop is not aware of the content of the `Update()` function of each
    object, just that every object that has one should be called at every frame. So,
    we are basically encapsulating the updating process of each game object's state
    through a single interface.
  prefs: []
  type: TYPE_NORMAL
- en: Challenge
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'As we can see in the following example, a basic Game Loop implementation looks
    simple, but can be very complicated to implement correctly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Once we capture the player''s controller inputs, we must update the transforms
    and states of our game''s objects before drawing them on the screen. But to achieve
    this, we need to know what entities to update, and how to request them to do so.
    If these entities don''t have a common object type or interface, we will need
    to manage them on a case-by-case basis:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: But our problems don't stop there; we also need to maintain a dynamic list of
    entities that will hold each object during their entire lifespan. As we can see,
    this type of approach doesn't scale well for larger games. So, the best solution
    would be to let the entities update themselves at every frame. In other words,
    let's have them encapsulate their behaviors, and the easiest to way to remind
    them to update themselves is to have a standard public function that we can call
    at every frame.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see in the next section how we can resolve all these issues with the Update
    Method.
  prefs: []
  type: TYPE_NORMAL
- en: Solution
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have found a solution that offers a standard interface to our game's
    scene entities and encapsulates them, we still need to maintain a list. Games
    are dynamic software; entities explode and spawn in a matter of seconds, manually
    managing a list of objects is error-prone.
  prefs: []
  type: TYPE_NORMAL
- en: But, if we had a common type for all our game's objects, then it will be easy
    for us to dynamically maintain a list of entities, and walk through it at every
    frame. If we have a container that holds all our game's objects, such as a scene,
    then we could iterate through it to find all the objects of a specific type, and
    call their `Update()` method.
  prefs: []
  type: TYPE_NORMAL
- en: That's mostly what `MonoBehaviour` is in Unity; it offers a common parent type
    for objects that are in a scene that need to update themselves at every frame.
    So, any component that is a child of the `MonoBehaviour` parent class has a magic
    method named `Update()`, which is called at every frame. So, while Unity does
    all the heavy lifting under the hood, you can focus on implementing the behaviors
    that you want to *tick* (update) at every frame by writing them inside a script's
    `Update()` method.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will dive deeper into Unity's implementation of the
    Update Method.
  prefs: []
  type: TYPE_NORMAL
- en: Unity's Update Method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a Unity developer, we don't need to implement our Update Method; it's native
    to the engine's scripting API. But the Unity engineers expanded on the core concept
    and exposed several types of `Update()` methods; each one permits us to execute
    code at different moments in the period of a frame.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram is an example of the steps of execution during the time
    it takes to render a frame to the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f1f4bef2-9388-44b6-a310-2eea7f70b8a5.png)'
  prefs: []
  type: TYPE_IMG
- en: Each step in the diagram is completed in less than 1/30 of a second and in a
    constant order. But the Unity engineers had the foresight to know that having
    a singular `Update()` is not enough, because specific systems need to be processed
    in different moments of a frame. So they decided to expose three main types of
    `Update()` methods, which we'll review individually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take note that only objects that are active in a scene and that inherit from
    the `MonoBehaviour` parent class will have their various `Update()` methods called:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Update()**: This method is called on at the same frequency as the game''s
    frame rate, which might be inconsistent, but at least frequent. In it, you should
    only implement code that needs to be executed in correspondence with every rendered
    frame. Because of its higher call frequency, it''s a good place to implement your
    input listeners.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LateUpdate()**: This method is called after `Update()`. It''s for code that
    needs to be executed after the completion of a call to `Update()`. Useful for
    camera movement translations that are dependent on the movement of a character
    that is being controlled by the player.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**FixedUpdate()**: This method is called each time the physics simulation is
    ticked (updated). The timing of the calls of the `FixedUpdate()` method offers
    stable delta times between each frame. This approach is necessary for physics
    calculations and the simulation of certain types of behaviors, such as accelerated
    motion.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following segment showcases the intervals between an `Update()` and a `FixedUpdate()`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/2c21f590-324b-48fa-bcba-056a6aced3f8.png)'
  prefs: []
  type: TYPE_IMG
- en: As we can see, a `FixedUpdate()` call is consistent, while an `Update()` varies
    over time.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is what the various Update Methods look like inside a typical
    `MonoBehaviour` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The most important takeaway is that we always need to be aware of when our code
    will be executed. Unity simplifies this task for us by abstracting the inner ticking
    (updating) mechanisms of the engine and exposing it through the API in the form
    of various Update Methods.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we reviewed the Game Loop pattern and its core principles.
    Like many modern engines, Unity abstracts the inner working of its core game loop,
    instead of some API hooks, which permits us to control the timing of the execution
    of our code at each frame, without having to synchronize manually with the CPU's
    internal clock.
  prefs: []
  type: TYPE_NORMAL
- en: We also skated over the surface of the core concepts that encompass the Update
    Method pattern. As Unity programmers, we don't need to manually implement this
    pattern because it's native to the scripting API, but we still have to be aware
    of its purpose. A solid understanding of the timing and sequencing of Unity's
    update functions is essential. Even if we don't know what's happening under the
    hood, we can at least have control over the sequence of execution of our code.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will dive into practical design patterns and apply them
    to resolve real-life game architecture issues and challenges. Our first subject
    will be the *Prototype* pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*Game Engine Architecture* by Jason Gregory:[http://www.gameenginebook.com](http://www.gameenginebook.com)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Racing the Beam* by Nick Montfort and Ian Bogost:[https://mitpress.mit.edu/books/racing-beam](https://mitpress.mit.edu/books/racing-beam)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
