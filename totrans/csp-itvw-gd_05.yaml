- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Fundamentals of C# Programming
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to [*Chapter 3*](B20871_03.xhtml#_idTextAnchor055), where we shall dive
    into the heart of technical interviews, specifically focusing on the fundamentals
    of C# programming. C# is a widely adopted, robust, and versatile language, used
    across various domains, including but not limited to game development, web services,
    and enterprise-level software.
  prefs: []
  type: TYPE_NORMAL
- en: Grasping the essentials of a programming language such as C# is crucial to excel
    in technical interviews. In this chapter, we will walk you through the vital principles
    of C#, commencing with essential concepts, data types, variables, and operators,
    and swiftly move to control structures and loops. Our aim is not just to acquaint
    you with the syntax but to also ensure that you comprehend the logic behind it,
    enabling you to write effective and clean code.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we shall delve into the basics of **object-oriented programming**
    (**OOP**) using C#. Understanding OOP allows you to design and manage complex
    applications, a skill that is greatly appreciated in the tech industry.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, you will possess a solid foundation in C# programming.
    This knowledge will empower you to confidently tackle coding challenges and demonstrate
    your problem-solving abilities during technical interviews. This chapter is designed
    to provide you with a balanced mix of theoretical understanding and practical
    exercises, thereby ensuring you can apply the learned concepts effectively.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Essential C# concepts and principles
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Working with data types, variables, and operators in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing control structures and loops in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the basics of OOP using C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Essential C# concepts and principles
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we aim to help you deepen your understanding of fundamental
    C# principles, enabling you to confidently answer the related questions you may
    encounter during technical interviews. This section is designed as a Q&A in which
    we will tackle potential interview questions covering a range of topics, from
    the basics of the C# syntax to key concepts of OOP in C#. We believe this interactive
    approach will help reinforce your knowledge and prepare you effectively for real-world
    interview scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s dive in and start exploring the questions you might face and how to approach
    answering them effectively.
  prefs: []
  type: TYPE_NORMAL
- en: What does the C# language represent, and for which platforms and applications
    is it intended?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: C# is a programming language created by Microsoft and part of the .NET platform.
    With C#, a variety of applications can be developed, such as desktop applications,
    web applications, mobile applications, gaming applications (via Unity), cloud
    computing solutions, and more. C# is supported across various platforms thanks
    to .NET Core and Xamarin.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the fundamental difference between .dll and .exe files in the context
    of C# projects?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of C# and .NET, an `.exe` (`.exe` file, the program starts its
    execution. On the other hand, a `.dll` (**dynamic-link library**) file is a code
    library that doesn’t have a direct entry point but can be called by another program
    or application. It’s a means of code reuse among different projects.
  prefs: []
  type: TYPE_NORMAL
- en: How does the entry point of a program written in C# look?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The entry point in a C# program is typically represented by the `Main()` method,
    which is located in the `Program` class. This method must be static and serves
    as the starting point for the program’s execution. Usually, its structure looks
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The `args` argument contains an array of strings that is passed to the program
    upon its launch.
  prefs: []
  type: TYPE_NORMAL
- en: How is memory management conducted in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, memory management is handled automatically thanks to the **garbage collector**
    mechanism. It automatically identifies objects that are no longer used by the
    program and frees the memory they occupy. While the garbage collector simplifies
    memory management, developers need to carefully manage unmanaged resources that
    are not controlled by the .NET garbage collector, such as database connections
    or file streams. If developers do not release these resources, they will persist
    for the lifetime of the application, potentially causing memory leaks and system
    strain.
  prefs: []
  type: TYPE_NORMAL
- en: What are the principles of OOP in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'OOP is based on four main principles: encapsulation, inheritance, polymorphism,
    and abstraction. In C#, this means the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Encapsulation** allows data and methods to be bundled into a unit (class)
    and restricts access to certain components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inheritance** permits one class (the child or derived class) to inherit the
    attributes and methods of another class (the parent or base class). This promotes
    the reuse of code and establishes a hierarchical relationship between classes.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Polymorphism** is the capability of a single function or method to work in
    various ways based on its inputs or on which object it is called upon. In C#,
    polymorphism can be achieved through method overriding, using the **override**
    keyword, and method hiding, utilizing the **new** keyword to hide a method in
    the base class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Abstraction** allows developers to hide complex implementations and show
    only the essential features of an object. This means that the user interacts with
    only what’s necessary and the internal workings are kept hidden. In C#, abstract
    classes and interfaces are tools that can help achieve abstraction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These principles help in designing robust and scalable applications, allowing
    for easy maintenance and further development. C# offers a rich set of features
    to implement and benefit from these principles effectively.
  prefs: []
  type: TYPE_NORMAL
- en: How is error handling done in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, the primary error handling mechanism is based on the use of `try`, `catch`,
    `finally`, and `throw` constructs. When code in a `try` block causes an error,
    execution jumps to the corresponding `catch` block, where the exception is handled.
    The `finally` block, if present, is typically executed after `try/catch`, regardless
    of whether there was an exception or not. However, there are critical exceptions,
    such as `StackOverflowException` or `OutOfMemoryException`, which can result in
    a program crash and thus the `finally` block won’t be executed.
  prefs: []
  type: TYPE_NORMAL
- en: What does the dependency injection principle mean and how is it implemented
    in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Dependency injection** (**DI**) is a software design approach that reduces
    tight coupling between system components. At the core of DI is the passing of
    dependencies (services, objects) to components rather than creating them inside
    those components. In C# and .NET, DI is often implemented using dependency containers,
    such as *Microsoft.Extensions.DependencyInjection*, *Ninject*, *Autofac*, and
    others.'
  prefs: []
  type: TYPE_NORMAL
- en: What are boxing and unboxing in C#, and why can they be a problem?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`object` type or any interface type implemented by that value type. `object`
    type is converted back to the corresponding value type. The primary concern with
    boxing and unboxing in C# is their potential to degrade application performance.
    Boxing necessitates heap memory allocation and value type copying, thus slowing
    operations, especially with large datasets or in high-frequency scenarios. Unboxing,
    if incorrectly managed, can lead to runtime errors due to improper type casting,
    disrupting program execution. Additionally, these operations can increase the
    workload on the garbage collector, causing more frequent collection cycles and
    negatively impacting the application’s responsiveness.'
  prefs: []
  type: TYPE_NORMAL
- en: What does Entity Framework represent and how is it applied?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Entity Framework** (**EF**) is an **object-relational mapping** (**ORM**)
    framework developed by Microsoft for the .NET ecosystem. It enables developers
    to work with databases using object models instead of writing direct SQL code.
    This tool simplifies the process of creating and managing data models, automating
    database schema migrations, and writing queries that make database interaction
    more intuitive.'
  prefs: []
  type: TYPE_NORMAL
- en: What’s the difference between threads and processes in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In an operating system, a process is a distinct execution entity that has its
    own memory space. A thread is the smallest unit of execution within a process.
    Each process can have one or multiple threads. In C#, threads can be managed using
    the `Thread` class from the `System.Threading` namespace. The main difference
    lies in the fact that threads within a single process can share the same memory
    area, whereas each process has its own isolated memory context.
  prefs: []
  type: TYPE_NORMAL
- en: What are the main development environments used for C#, and are there alternatives
    to Visual Studio?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main IDE for C# is Visual Studio from Microsoft. However, there are alternatives,
    such as Visual Studio Code (a lightweight code editor with support for C# extensions)
    and JetBrains Rider. Each environment has its own benefits and features, and the
    choice depends on the specific needs of the developer:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Features*: Comprehensive IDE with advanced tools for large-scale projects
    and multi-language support'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use case*: Best suited for enterprise-level applications, offering a range
    of tools for collaborative and complex projects'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Visual** **Studio Code**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Features*: Lightweight, open source code editor with a rich ecosystem of extensions,
    including C# support'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use case*: Ideal for individual developers or small teams, providing a flexible
    and extensible environment for various languages and frameworks'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**JetBrains Rider**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Features*: Cross-platform .NET IDE with powerful tools for .NET development
    and a rich set of plugins'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Use case*: Excellent for cross-platform development, offering consistent experiences
    and high-quality code analysis and refactoring tools'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: What programming patterns do you know, and which ones have you implemented in
    C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Programming patterns are proven solutions for common development challenges.
    They indicate the optimal way to implement a specific task. In C#, I often use
    patterns such as *Singleton*, *Factory*, *Observer*, *Strategy*, and *Decorator*.
  prefs: []
  type: TYPE_NORMAL
- en: Can you describe different software testing methods and their primary differences?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several types of testing, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Unit testing**: Focuses on individual pieces of code, particularly functions
    or methods'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Integration testing**: Checks the interaction between different parts of
    the software'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System testing**: Tests the entire system'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The main difference lies in the level of access and the scope of testing.
  prefs: []
  type: TYPE_NORMAL
- en: How do you determine the best time to conduct unit testing compared to integration
    or system testing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unit testing is best conducted during development when a specific component
    or function is being created or modified.
  prefs: []
  type: TYPE_NORMAL
- en: Integration testing should be applied after several components have been combined
    to verify their correct interaction.
  prefs: []
  type: TYPE_NORMAL
- en: System testing should be applied when the entire product or a significant portion
    of it is ready for release.
  prefs: []
  type: TYPE_NORMAL
- en: What is NuGet, and how can it be used to add libraries to your project?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**NuGet** is a package manager for the .NET platform that allows developers
    to easily add, update, and remove external libraries and dependencies in their
    projects. To add an external library to a project through NuGet, you need to open
    the NuGet console in the development environment (e.g., in Visual Studio) or use
    its graphical interface, find the desired package, and install it.'
  prefs: []
  type: TYPE_NORMAL
- en: Having mastered the essential concepts and principles of C#, you’ve already
    taken a significant step toward understanding this powerful programming language.
    But the journey doesn’t end here. Your next step is to delve into working with
    data types, variables, and operators in C#. Ready to continue? It’s time to dive
    even deeper!
  prefs: []
  type: TYPE_NORMAL
- en: Working with data types, variables, and operators in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When diving into C#, it’s essential to grasp data types, variables, and operators—they’re
    the backbone of your applications. In this section, we’ll explore these foundational
    elements, paving the way for more advanced coding. Ready to solidify your understanding?
    Let’s dive in!
  prefs: []
  type: TYPE_NORMAL
- en: What are the basic primitive data types in C#? What is the main difference between
    value type and reference type?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, there are primitive data types, such as `int`, `float`, `double`, `char`,
    `bool`, `byte`, and others. The main difference between the *value* type and *reference*
    type lies in how they are stored and how their memory management. Value types
    are stored on the stack and directly contain their value, while reference types
    are stored in the heap and contain a reference to the object in memory.
  prefs: []
  type: TYPE_NORMAL
- en: What is the primary distinction between string and StringBuilder in the context
    of strings?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `string` type in C# is immutable, meaning every time the string is modified,
    a new instance is created. On the other hand, `StringBuilder` is designed for
    efficiently modifying strings without the need to create numerous new instances.
  prefs: []
  type: TYPE_NORMAL
- en: How do you initialize and interact with one-dimensional and multidimensional
    arrays? What differentiates "string[][]" from "string[,]"?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A one-dimensional array in C# is initialized like this: `int[] arr = new int[5];`.
    As for multidimensional arrays, `string[,]` is a two-dimensional array, while
    `string[][]` is an array of arrays, also known as a *jagged* array.'
  prefs: []
  type: TYPE_NORMAL
- en: What are bitwise operations and which operators in C# support these operations?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Bitwise operations allow for manipulations at the level of individual bits of
    a numerical value. The primary bitwise operators in C# are `&` (*AND*), `|` (*OR*),
    `^` (*XOR*), and `~` (*NOT*).
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of "nullable" types in C# and how do you work with them
    correctly?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Nullable` types in C# allow representing an absent or uninitialized value
    for value types. They are typically used when there is a need to distinguish a
    *zero* value from the absence of a value. To check for the presence of a value,
    you can use the `HasValue` property, and to retrieve the value itself, you use
    `Value`.'
  prefs: []
  type: TYPE_NORMAL
- en: What is known about operator overloading in C# and why can it be useful?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Operator overloading allows defining the actions of operators for user-defined
    data types, such as classes. This can be useful, for instance, for easy manipulation
    of complex numbers, vectors, or other mathematical structures.
  prefs: []
  type: TYPE_NORMAL
- en: How can one overload an operator in C# and could you provide an example?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, operator overloading allows you to redefine the way built-in operators
    work for user-defined types such as classes and structs. To overload an operator,
    you define a static method in your class or struct with the `operator` keyword
    followed by the operator symbol you want to overload. The method must return a
    result and take at least one parameter of the type you’re overloading the operator
    for.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here’s a simple example of overloading the `+` operator for a custom `Vector`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: How do comparison and relational operators work in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Comparison (`==`, `!=`) and relational (`<`, `>`, `<=`, `>=`) operators are
    used to compare two values. It’s important to remember that when comparing reference
    types, the `==` operator checks for reference equality, not content.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of logical operators in C#, how do they function, and why
    is it important to pay attention to operator precedence?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Logical operators, such as `&&` (*logical “and”*), `||` (*logical “or”*), and
    `!` (*logical negation*), are used for combined logical conditions. It’s important
    to know operator precedence as it affects the order of operations. For example,
    the expression `A && B || C` will be interpreted as `(A && B) || C`, not `A &&
    (B || C)`, which can lead to different results.
  prefs: []
  type: TYPE_NORMAL
- en: When and why should you use “const” variables in C#? What’s the difference between
    them and “readonly”?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`const` variables should be used when you need to define a variable that doesn’t
    change throughout the program’s life cycle. They must have a value assigned at
    compile time. On the other hand, `readonly` can be initialized in a class constructor
    and ensure that its value cannot be changed afterward.'
  prefs: []
  type: TYPE_NORMAL
- en: Which method of object comparison in C# is better to use, “==” or “Equals()”,
    and why?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For value types, `==` and `Equals()` usually work the same way, but for reference
    types, `==` checks for reference equality, not content. `Equals()` can be overridden
    for custom classes to ensure content-based comparison. As a rule, if you want
    to compare the content of objects, it’s better to use `Equals()`.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the primary distinction between “is” and “as” when converting types in
    C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`is` checks whether an object is an instance of a certain type and returns
    a Boolean value. `as` is used for safe type casting and will return `null` if
    the conversion is not possible, rather than throwing an exception.'
  prefs: []
  type: TYPE_NORMAL
- en: What do explicit and implicit type conversions mean in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Implicit-type conversion happens automatically when a data type that can hold
    less information is converted to one that can hold more (for example, from `int`
    to `double`). Explicit-type conversion (casting) is required when there’s a risk
    of data loss during the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of the "??" operator in C# and in which scenarios should
    it be used?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `??` operator is a null-coalescing operator that returns the left operand
    if it’s not `null`; otherwise, it returns the right one. It’s useful for setting
    default values for potentially `null` values.
  prefs: []
  type: TYPE_NORMAL
- en: What are tuples, how are they used in C#, and what are their advantages compared
    to classes?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Tuples in C# are ordered collections of various types. They are useful for representing
    datasets without creating specific types. Compared to classes, tuples are typically
    lighter and more convenient for small, temporary datasets.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we delved into the core components of C#—data types, variables,
    and operators, which form the backbone of any C# application. We explored the
    differences between value and reference types and examined string manipulations,
    alongside the initialization and handling of various arrays. We also discussed
    the role of bitwise and logical operators, the use of nullable types, and the
    principles of operator overloading. We touched upon important topics such as object
    comparison methods, type conversions, and the advantages of using tuples for compact
    data representation. With this solid foundation, we are ready to advance to the
    next section, *Writing control structures and loops in C#*, to further enhance
    our programming skills.
  prefs: []
  type: TYPE_NORMAL
- en: Writing control structures and loops in C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Control structures and loops are fundamental elements of any program, allowing
    developers to efficiently manage the flow of code execution. In the C# language,
    there is a variety of powerful tools for this purpose. In this section, we will
    delve into various control structures, such as conditional statements and selection,
    as well as key concepts of looping through data using different types of loops.
    Through an in-depth study of these elements, you’ll gain a solid foundation for
    writing efficient and structured code in C#. Let’s begin!
  prefs: []
  type: TYPE_NORMAL
- en: What are the main loops available in C# and how do you choose the best loop
    for a specific situation?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In C#, several types of loops are available: `for`, `foreach`, `while`, and
    `do-while`. Let’s look at each of them:'
  prefs: []
  type: TYPE_NORMAL
- en: '**for**: This is the most commonly used loop when you know the number of iterations
    beforehand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**foreach**: This type of loop is perfect for iterating through collections
    or arrays when you need to work with each element sequentially.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**while**: This loop executes as long as the specified condition is true. It’s
    useful when you don’t know the number of iterations beforehand.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**do-while**: This loop is similar to **while**, but the condition is checked
    after executing the loop body, ensuring the loop body is executed at least once.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Choosing the best loop depends on the specific situation. If you need to iterate
    over all elements of a collection, `foreach` would be the most convenient. If
    you know the number of iterations, `for` would be the most efficient. In cases
    where you don’t know the number of iterations in advance, you can use `while`
    or `do-while`, depending on whether you want the loop body to execute at least
    once or not.
  prefs: []
  type: TYPE_NORMAL
- en: How do you use the “if”, “else if”, and “else” operators in C#? In which situations
    would you recommend using each of them?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `if`, `else if`, and `else` operators are used for conditional code execution.
    `if` checks a condition and, if it’s `true`, executes the code block following
    it. `else if` allows you to check additional conditions if the previous conditions
    were `false`. `else` executes a code block when none of the previous conditions
    were met. Use `if` to check a single primary condition, `else if` to check additional
    conditions, and `else` as a fallback code block to execute.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the difference between “for” and “foreach” loops? In which cases is it
    better to use each?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `for` loop is used when you know in advance how many times you need to execute
    the loop. The `foreach` loop is designed for iterating over collections, such
    as lists or arrays. Use `for` when you have a specific number of iterations, and
    `foreach` when you need to iterate over all elements in a collection.
  prefs: []
  type: TYPE_NORMAL
- en: What is the “switch” operator and how is it different from a sequence of “if-else”
    operators?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `switch` operator allows you to check a variable against multiple values.
    It is more compact and often more convenient for checking the values of a single
    variable. An `if-else` sequence, on the other hand, offers more flexibility as
    it can check different conditions, not being limited to just one variable.
  prefs: []
  type: TYPE_NORMAL
- en: What do the “continue” and “break” operators do in loops, and when can they
    be useful?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`continue` skips the current loop iteration and proceeds to the next one. `break`
    exits the loop prematurely. `continue` is useful when some loop iterations need
    to be skipped, and `break` when you need to terminate the loop execution under
    a certain condition.'
  prefs: []
  type: TYPE_NORMAL
- en: How do you combine multiple conditions in a single “if” statement using logical
    operators?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can use logical operators `&&` (*logical “and”*) and `||` (*logical “or”*)
    to combine multiple conditions, for example, `if (x > 5 && y <` `10) {...}`.
  prefs: []
  type: TYPE_NORMAL
- en: What is the peculiarity of the “do-while” loop compared to the regular “while”
    loop?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The primary difference is that in the `do-while` loop, the condition is checked
    after the loop body is executed, ensuring that the loop body runs at least once,
    regardless of the condition.
  prefs: []
  type: TYPE_NORMAL
- en: What does a nested loop look like and why can it be useful?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A nested loop is a loop placed inside another loop. It is often used for processing
    a two-dimensional array or matrix. See the following for an example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: How can you prevent a potentially infinite loop execution?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To prevent an infinite loop, it’s crucial to ensure that a loop termination
    condition will be met. This can be done by checking conditions before entering
    the loop, using execution time limiters, or through internal counters and monitoring
    tools.
  prefs: []
  type: TYPE_NORMAL
- en: What is recursion in C# and how do you prevent stack overflow when using recursive
    methods?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Recursion is a technique where a method calls itself. To prevent stack overflow,
    it’s important to have a clear base case that will halt the recursive calls and
    to limit the recursion depth.
  prefs: []
  type: TYPE_NORMAL
- en: How can you optimize a loop for processing a large amount of data in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To optimize a loop, you can use parallelism, employ efficient data structures,
    reduce the number of operations within the loop, and utilize caching where possible.
  prefs: []
  type: TYPE_NORMAL
- en: What is “yield return” in C# and when can it be useful?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`yield return` allows you to create iterators without the need to generate
    an auxiliary collection. It’s useful when you want to lazily generate values as
    you iterate through a collection.'
  prefs: []
  type: TYPE_NORMAL
- en: How do you create an infinite loop using “for”?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'An infinite loop can be created using `for` in the following manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Here, the condition, initialization, and increment are absent, so the loop will
    run indefinitely.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explored control structures and loops, essential tools for
    dictating the flow of code in C#. We discussed various loop types, such as `for`,
    `foreach`, `while`, and `do-while`, highlighting how to select the appropriate
    one depending on the task at hand. We also covered the usage and applications
    of conditional operators `if`, `else if`, and `else`. We examined the efficiency
    of the `switch` operator compared to that of a chain of `if-else` statements,
    and the roles of `continue` and `break` operators within loops. With this foundation,
    we are now prepared to delve into more advanced topics.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the basics of OOP using C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we turn our focus toward the basics of OOP using C#. As we
    venture further, we will unravel the core principles of OOP, a paradigm that facilitates
    organized and reusable code. Through C#, we will explore key OOP concepts such
    as classes, objects, inheritance, and polymorphism, fostering a deeper understanding
    and equipping you with the skills to craft robust and efficient applications.
    Let’s embark on this enlightening journey.
  prefs: []
  type: TYPE_NORMAL
- en: How does C# integrate the principles of OOP?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'C# supports all the core principles of OOP: *encapsulation*, *inheritance*,
    *polymorphism*, and *abstraction*. For instance, classes and interfaces in C#
    allow for the implementation of inheritance and polymorphism, while access modifiers
    facilitate encapsulation.'
  prefs: []
  type: TYPE_NORMAL
- en: How does encapsulation work in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, encapsulation is ensured through access modifiers such as `private`,
    `protected`, and `public`. These modifiers determine the visibility of class members,
    allowing for the hiding of implementation details and exposing only the necessary
    API.
  prefs: []
  type: TYPE_NORMAL
- en: How is polymorphism implemented in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Polymorphism in C# is realized through the ability to override methods in subclasses
    using the `virtual` and `override` keywords, as well as through interfaces that
    allow different classes to have a consistent set of methods.
  prefs: []
  type: TYPE_NORMAL
- en: What does inheritance entail in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Inheritance in C# allows for the creation of a new class based on an existing
    one, inheriting its attributes and behavior. This is achieved using the `:` keyword,
    followed by the name of the base class.
  prefs: []
  type: TYPE_NORMAL
- en: What is the difference between a class and its instance in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A class serves as a schematic or prototype that delineates the characteristics
    and functions of objects. An object (or instance of a class) is a specific representation
    of that class with a unique set of attribute values.
  prefs: []
  type: TYPE_NORMAL
- en: Why are access modifiers such as “public”, “private”, “protected”, and “internal”
    used in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: These modifiers determine the level of access to class members. `public` makes
    a member accessible to any code; `private` restricts access to only the methods
    of the given class; `protected` allows access to the given class and its descendants,
    and `internal` makes a member accessible to any code within the same assembly.
  prefs: []
  type: TYPE_NORMAL
- en: Can a class in C# inherit from multiple other classes simultaneously?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: No, C# does not support multiple inheritance for classes. However, a class can
    implement multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: How do method overloading and method overriding differ in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Method overloading allows having multiple versions of a single method in one
    class with different parameters. Method overriding allows a subclass to replace
    the implementation of a method provided by its base class.
  prefs: []
  type: TYPE_NORMAL
- en: What are the main differences between interfaces and base classes in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Interfaces define a contract (a set of methods without implementation) that
    must be adhered to by the class that implements it. Base classes contain an implementation
    that can be inherited and extended. A class can inherit only one base class but
    can implement multiple interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Why is composition sometimes considered a better choice than inheritance?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Composition offers greater flexibility, allowing dynamic changes to an object’s
    behavior on the fly, and reduces the risk of issues associated with tight coupling
    between classes. It also promotes the principle of *composition over inheritance*,
    suggesting that using composition for the reusability of code is a more desirable
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: What are properties in C# and how do they differ from fields?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Properties are a special kind of class member in C# that represents access to
    data with the ability to define logic when reading or writing that data. They
    allow you to control access to internal fields and can contain additional logic,
    for instance, for validation. Fields, on the other hand, are variables defined
    in the class and are used to store data.
  prefs: []
  type: TYPE_NORMAL
- en: What’s the main difference between abstract classes and interfaces in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Abstract classes can contain methods both with and without implementation. They
    cannot be instantiated directly. Interfaces only contain method declarations without
    implementation. A class can implement multiple interfaces but can inherit only
    one abstract class.
  prefs: []
  type: TYPE_NORMAL
- en: Why is encapsulating fields important for the SOLID principles?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Encapsulation helps keep the internal state of an object protected and hidden
    from the external world, which supports adherence to the *Open/Closed Principle*
    of SOLID. It also helps prevent unwanted state changes that could violate the
    *Single* *Responsibility Principle*.
  prefs: []
  type: TYPE_NORMAL
- en: What is the role of delegates in OOP in the context of C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Delegates in C# are objects that can point to methods. They allow for the realization
    of the function pointers concept in a type-safe manner. Delegates are often used
    to implement events and callbacks.
  prefs: []
  type: TYPE_NORMAL
- en: How are constructors used for object initialization and how do they differ from
    static constructors?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Constructors help initialize an object at the time of its creation, setting
    the necessary state or performing any other required setup. Static constructors
    are used to initialize static members of a class or to perform actions that should
    occur only once for the class, not for each individual object.
  prefs: []
  type: TYPE_NORMAL
- en: What do aggregation and association mean in OOP, and how are they implemented
    in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Aggregation** and **association** represent two distinct relationships between
    classes within the OOP paradigm. Association denotes a broader connection between
    two classes, indicating that one class incorporates the other.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let me show some examples of how they are implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Association is a bi-directional relationship between two classes. Here, we
    demonstrate a one-to-many association between a **Library** class and a **Book**
    class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, the `Library` class has a list of `Book` objects, illustrating
    a one-to-many association.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Aggregation represents a relationship where one class is a part of another
    class. Here, we illustrate an aggregation between a **Car** class and an **Engine**
    class:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In this example, the `Car` class contains an `Engine` object, demonstrating
    an aggregation relationship where the `Engine` class represents a part of the
    `Car` class.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Through these examples, we can see how both association and aggregation relationships
    can be implemented in C# using class properties and constructors.
  prefs: []
  type: TYPE_NORMAL
- en: How can multiple inheritance be implemented in C# if there is no direct support?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, there’s no direct support for multiple inheritance. However, multiple
    inheritance can be realized using interfaces. A class can implement multiple interfaces
    that may come from different sources.
  prefs: []
  type: TYPE_NORMAL
- en: What does the principle of “composition over inheritance” mean and when is it
    useful?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Composition** over **inheritance** is a software design approach that encourages
    the use of composition (where objects utilize other objects) over inheritance
    for code reusability. It can be useful when a class’s behavior requires dynamic
    changes or when inheritance might lead to undesired rigid coupling between classes.'
  prefs: []
  type: TYPE_NORMAL
- en: Why are exceptions in C# considered objects, and how do you create your own
    exception class?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, exceptions are implemented as objects that inherit from the base `Exception`
    class. This allows for passing additional information about the exception and
    creating custom exception types. To create your own exception class, simply inherit
    it from the `Exception` class or one of its subclasses.
  prefs: []
  type: TYPE_NORMAL
- en: What is the purpose of the “base” keyword in the context of inheritance in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `base` keyword allows you to call members from the base class when in a
    derived class. It is most commonly used in derived classes to call the constructor
    of the base class or to access other base class members that were overridden in
    the derived class.
  prefs: []
  type: TYPE_NORMAL
- en: How is the “this” keyword used in C#?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `this` keyword points to the present instance of the class. It is often
    used to point to the fields or methods of the current object, especially when
    method parameter names overlap with class field names.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve reached the end of our journey through the basics of C# and OOP in this
    chapter. With a strong foundation established, you’re well-equipped to tackle
    the most common C# coding scenarios in your technical interviews.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we dove deep into key concepts, explored data types, variables,
    and operators, dissected control structures and loops, and discovered the basics
    of OOP. However, becoming proficient in C# is a continuous learning journey.
  prefs: []
  type: TYPE_NORMAL
- en: As we turn the page, we’ll start navigating the more advanced terrain of C#
    programming in the next chapter. [*Chapter 4*](B20871_04.xhtml#_idTextAnchor127),
    *Advanced C# Concepts*, will bring light to the advanced facets of C#, including
    working with collections, LINQ, exception handling, debugging, asynchronous programming,
    and a lot more.
  prefs: []
  type: TYPE_NORMAL
- en: We will unravel the complexities of C# and learn how to make the best use of
    its capabilities to solve more intricate problems and enhance application performance.
    From creating reusable code with generic classes, methods, and interfaces to diving
    deep into multithreading and garbage collection, we’ll gear you up for a higher
    level of programming challenges. Remember, each concept is a stepping stone, leading
    you to master the art of C# programming. So, buckle up for the next exciting chapter
    in your learning journey!
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '*C# 12 and .NET 8 – Modern Cross-Platform Development Fundamentals - Eighth
    Edition,* by Mark J. Price'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/product/c-12-and-net-8-modern-cross-platform-development-fundamentals-eighth-edition/9781837635870](https://www.packtpub.com/product/c-12-and-net-8-modern-cross-platform-development-fundamentals-eighth-edition/9781837635870)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Refactoring with C#,* by Matt Eland'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/product/refactoring-with-c/9781835089989](https://www.packtpub.com/product/refactoring-with-c/9781835089989)'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
