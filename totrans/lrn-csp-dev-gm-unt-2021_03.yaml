- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Diving into Variables, Types, and Methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The initial steps into any programming language are plagued with a fundamental
    issueâ€”you can understand the words being typed out, but not the meaning behind
    them. Normally, this would be cause for a paradox, but programming is a special
    case.
  prefs: []
  type: TYPE_NORMAL
- en: C# is not its own language; it's written in English. The discrepancy between
    the words you use every day and the code in Visual Studio comes from missing context,
    which is something that has to be learned all over again. You know how to say
    and spell the words used in C#, but what you don't know is where, when, why, and,
    most importantly, how they make up the syntax of the language.
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter marks our departure from programming theory and the beginning
    of our journey into actual coding. We''ll talk about accepted formatting, debugging
    techniques, and putting together more complex examples of variables and methods.
    There''s a lot of ground to cover, but by the time you reach the last quiz, you''ll
    be comfortable with the following high-level topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Writing proper C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Debugging your code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding variables
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing operators
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Defining methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Writing proper C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Lines of code function like sentences, meaning they need to have some sort of
    separating or ending character. Every line of C#, called a statement, *must* end
    with a semicolon to separate them for the code compiler to process.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there''s a catch that you need to be aware of. Unlike the written
    word we''re all familiar with, a C# statement doesn''t technically have to be
    on a single line; whitespace and newlines are ignored by the code compiler. For
    example, a simple variable could be written like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Alternatively, it could also be written as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: These two code snippets are both perfectly acceptable to Visual Studio, but
    the second option is highly discouraged in the software community as it makes
    code extremely hard to read. The idea is to write your programs as efficiently
    and clearly as possible.
  prefs: []
  type: TYPE_NORMAL
- en: There will be times when a statement will be too long to reasonably fit on a
    single line, but those are few and far between. Just make sure that it's formatted
    in a way someone else could understand, and don't forget the semicolon.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second formatting rule you need to drill into your coding muscle memory
    is the use of curly brackets or braces: `{}`. Methods, classes, and interfaces
    all need a set of curly brackets after their declaration. We''ll talk about each
    of these in-depth later on, but it''s important to get the standard formatting
    in your head early on.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The traditional practice in C# is to include each bracket on a new line, as
    shown in the following method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'However, you might see the first curly bracket located on the same line as
    the declaration out in the wild. It''s all down to personal preference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: While this isn't something to tear your hair out over, the important thing is
    to be consistent. In this book, we'll stick with "pure" C# code, which will always
    put each bracket on a new line, while C# examples that have to do with Unity and
    game development will often follow the second example.
  prefs: []
  type: TYPE_NORMAL
- en: Good, consistent formatting style is paramount when starting in programming,
    but so is being able to see the fruits of your work. In the next section, we'll
    talk about how to print out variables and information straight to the Unity console.
  prefs: []
  type: TYPE_NORMAL
- en: Debugging your code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While we're working through practical examples, we'll need a way to print out
    information and feedback to the **Console** window in the Unity editor. The programmatic
    term for this is debugging, and both C# and Unity provide helper methods to make
    this process easier for developers. You already debugged your code from the last
    chapter, but we didn't go into much detail about how it actually works. Let's
    fix that.
  prefs: []
  type: TYPE_NORMAL
- en: 'Whenever I ask you to debug or print something out, use one of the following
    methods:'
  prefs: []
  type: TYPE_NORMAL
- en: 'For simple text or individual variables, use the standard `Debug.Log()` method.
    The text needs to be inside a set of parentheses, and variables can be used directly
    with no added characters; for example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will produce the following in the **Console** panel:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17573_03_01.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.1: Observing Debug.Log output'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more complex debugging, use `Debug.LogFormat()`. This will let you place
    variables inside the printed text by using placeholders. These are marked with
    a pair of curly brackets, each containing an index. An index is a regular number,
    starting at 0 and increasing sequentially by 1\. In the following example, the
    `{0}` placeholder is replaced with the `CurrentAge` value, `{1}` with `FirstName`,
    and so on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This will produce the following in the **Console** panel:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17573_03_02.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.2: Observing Debug.LogFormat output'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You might have noticed that we're using **dot notation** in our debugging techniques,
    and you'd be right! Debug is the class we're using, and `Log()` and `LogFormat()`
    are different methods that we can use from that class. More on this at the end
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: With the power of debugging under our belts, we can safely move on and do a
    deeper dive into how variables are declared, as well as the different ways that
    syntax can play out.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding variables
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we saw how variables are written and touched on the
    high-level functionality that they provide. However, we're still missing the syntax
    that makes all of that possible.
  prefs: []
  type: TYPE_NORMAL
- en: Declaring variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Variables don''t just appear at the top of a C# script; they have to be declared
    according to certain rules and requirements. At its most basic level, a variable
    statement needs to satisfy the following requirements:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of data the variable will store needs to be specified
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable has to have a unique name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If there is an assigned value, it must match the specified type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The variable declaration needs to end with a semicolon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The result of adhering to these rules is the following syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: Variables need unique names to avoid conflicts with words that have already
    been taken by C#, which are called keywords. You can find the full list of protected
    keywords at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/index).
  prefs: []
  type: TYPE_NORMAL
- en: This is simple, neat, and efficient. However, a programming language wouldn't
    be useful in the long run if there was only one way of creating something as pervasive
    as variables. Complex applications and games have different use cases and scenarios,
    all of which have unique C# syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Type and value declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The most common scenario for creating variables is one that has all of the
    required information available when the declaration is made. For instance, if
    we knew a player''s age, storing it would be as easy as doing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, all of the basic requirements have been met:'
  prefs: []
  type: TYPE_NORMAL
- en: A data type is specified, which is `int` (short for integer)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unique name is used, which is `CurrentAge`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`32` is an integer, which matches the specified data type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The statement ends with a semicolon
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, there will be scenarios where you'll want to declare a variable without
    knowing its value right away. We'll talk about this topic in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Type-only declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Consider another scenarioâ€”you know the type of data you want a variable to
    store and its name, but not its value. The value will be computed and assigned
    somewhere else, but you still need to declare the variable at the top of the script.
    This situation is perfect for a type-only declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Only the type (`int`) and unique name (`CurrentAge`) are defined, but the statement
    is still valid because we''ve followed the rules. With no assigned value, default
    values will be assigned according to the variable''s type. In this case, `CurrentAge`
    will be set to `0`, which matches the `int` type. As soon as the actual value
    of the variable becomes available, it can easily be set in a separate statement
    by referencing the variable name and assigning it a value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: You can find a complete list of all C# types and their default values at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/default-values).
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you might be asking why, so far, our variables haven't included
    the `public` keyword, called an *access modifier*, which we saw in earlier scripting
    examples. The answer is that we didn't have the necessary foundation to talk about
    them with any clarity. Now that we have that foundation, it's time to revisit
    them in detail.
  prefs: []
  type: TYPE_NORMAL
- en: Using access modifiers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now that the basic syntax is no longer a mystery, let's get into the finer details
    of variable statements. Since we read code from left to right, it makes sense
    to begin our variable deep dive with the keyword that traditionally comes firstâ€”an
    access modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a quick look back at the variables we used in the preceding chapter in
    `LearningCurve` and you''ll see they had an extra keyword at the front of their
    statements: `public`. This is the variable''s access modifier. Think of it as
    a security setting, determining who and what can access the variable''s information.'
  prefs: []
  type: TYPE_NORMAL
- en: Any variable that isn't marked `public` is defaulted to `private` and won't
    show up in the Unity Inspector panel.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you include a modifier, the updated syntax recipe we put together at the
    beginning of this chapter will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: While explicit access modifiers aren't necessary when declaring a variable,
    it's a good habit to get into as a new programmer. That extra word goes a long
    way toward readability and professionalism in your code.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four main access modifiers available in C#, but the two you''ll be
    working with most often as a beginner are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Public**: This is available to any script without restriction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Private**: This is only available in the class they''re created in (which
    is called the containing class). Any variable without an access modifier defaults
    to private.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The two advanced modifiers have the following characteristics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Protected**: Accessible from their containing class or types derived from
    it'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Internal**: Only available in the current assembly'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are specific use cases for each of these modifiers, but until we get to
    the advanced chapters, don't worry about **protected** and **internal**.
  prefs: []
  type: TYPE_NORMAL
- en: Two combined modifiers also exist, but we won't be using them in this book.
    You can find more information about them at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers).
  prefs: []
  type: TYPE_NORMAL
- en: Let's try out some access modifiers of our own! Just like information in real
    life, some data needs to be protected or shared with specific people. If there's
    no need for a variable to be changed in the **Inspector** window or accessed from
    other scripts, it's a good candidate for a private access modifier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Perform the following steps to update `LearningCurve`:'
  prefs: []
  type: TYPE_NORMAL
- en: Change the access modifier in front of `CurrentAge` from `public` to `private`
    and save the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Go back into Unity, select the Main Camera, and take a look at what changed
    in the `LearningCurve`section:![](img/B17573_03_03.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.3: LearningCurve script component attached to the Main Camera'
  prefs: []
  type: TYPE_NORMAL
- en: Since `CurrentAge` is now private, it's no longer visible in the **Inspector**
    window and can only be accessed within the `LearningCurve` script in code. If
    we click play, the script will still work exactly as it did before.
  prefs: []
  type: TYPE_NORMAL
- en: This is a good start on our journey into variables, but we still need to know
    more about what kinds of data they can store. This is where data types come in,
    which we'll look at in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Working with types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Assigning a specific type to a variable is an important choice, one that trickles
    down into every interaction a variable has over its entire lifespan. Since C#
    is what's called a *strongly-typed* or *type-safe* language, every variable has
    to have a data type without exception. This means that there are specific rules
    when it comes to performing operations with certain types, and regulations when
    converting a given variable type into another.
  prefs: []
  type: TYPE_NORMAL
- en: Common built-in types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'All data types in C# trickle down (or *derive*, in programmatic terms) from
    a common ancestor: `System.Object`. This hierarchy, called the **Common Type System**
    (**CTS**), means that different types have a lot of shared functionality. The
    following table lays out some of the most common data type options and the values
    they store:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_04.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.4: Common data types for variables'
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to specifying the kind of value a variable can store, types contain
    added information about themselves, including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Required storage space
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Minimum and maximum values
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Allowed operations
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Location in memory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Accessible methods
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Base (derived) type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If this seems overwhelming, take a deep breath. Working with all of the types
    C# offers is a perfect example of using documentation over memorization. Pretty
    soon, using even the most complex custom types will feel like second nature.
  prefs: []
  type: TYPE_NORMAL
- en: You can find a complete list of all of the C# built-in types and their specifications
    at [https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/types/index).
  prefs: []
  type: TYPE_NORMAL
- en: Before the list of types becomes a sticking point, it's best to experiment with
    them. After all, the best way to learn something new is to use it, break it, and
    then learn to fix it.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and open up `LearningCurve`and add a new variable for each type in
    the preceding chart from the *Common built-in types* section. The names and values
    you use are up to you; just make sure they''re marked as public so we can see
    them in the Inspector window. If you need inspiration, take a look at my code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: When dealing with string types, the actual text value needs to be inside a pair
    of double quotes, while float values need to end with a lowercase `f`, as you
    can see with `FirstName` and `Pi`.
  prefs: []
  type: TYPE_NORMAL
- en: All our different variable types are now visible. Take note of the `bool` variable
    that Unity displays as a checkbox (true is checked and false is unchecked).
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_05.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.5: LearningCurve script component with common variable types'
  prefs: []
  type: TYPE_NORMAL
- en: Remember, any variables you declare as private won't show up in the Inspector
    window. Before we move on to conversions, we need to touch on a common and powerful
    application of the string data type; namely, the creation of strings that have
    variables interspersed at will.
  prefs: []
  type: TYPE_NORMAL
- en: While number types behave as you'd expect from grade school math, strings are
    a different story. It's possible to insert variables and literal values directly
    into text by starting with a `$` character, which is called string interpolation.
    You've already used an interpolated string in your `LogFormat()` debugging; adding
    the `$` character lets you use them anywhere!
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a simple interpolated string of our own inside `LearningCurve`
    to see this in action. Print out the interpolated string inside the `Start()`
    method directly after `ComputeAge()` is called:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Thanks to the `$` character and curly brackets, the value of `FirstName` is
    treated as a value and is printed out inside the interpolated string. Without
    this special formatting, the string would just include `FirstName` as text instead
    of the variable value.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_06.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.6: Console showing debug log output'
  prefs: []
  type: TYPE_NORMAL
- en: It's also possible to create interpolated strings using the `+` operator, which
    we'll talk about in the *Introducing operators* section.
  prefs: []
  type: TYPE_NORMAL
- en: Type conversions
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We''ve already seen that variables can only hold values of their declared types,
    but there will be situations where you''ll need to combine variables of different
    types. In programming terminology, these are called conversions, and they come
    in two main flavors:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Implicit** conversions take place automatically, usually when a smaller value
    will fit into another variable type without any rounding. For example, any integer
    can be implicitly converted into a `double` or `float` value without additional
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The output in the **Console** pane can be seen in the following screenshot:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17573_03_07.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.7: Implicit type conversion debug log output'
  prefs: []
  type: TYPE_NORMAL
- en: '**Explicit** conversions are needed when there is a risk of losing a variable''s
    information during the conversion. For example, if we wanted to convert a `double`
    value into an `int` value, we would have to explicitly cast (convert) it by adding
    the destination type in parentheses before the value we want to convert.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'This tells the compiler that we are aware that data (or precision) might be
    lost:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this explicit conversion, `3.14` would be rounded down to `3`, losing the
    decimal values:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17573_03_08.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.8: Explicit type conversion debug log output'
  prefs: []
  type: TYPE_NORMAL
- en: C# provides built-in methods for explicitly converting values to common types.
    For example, any type can be converted into a string value with the `ToString()`
    method, while the `Convert` class can handle more complicated conversions. You
    can find more info about these features under the *Methods* section at [https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2](https://docs.microsoft.com/en-us/dotnet/api/system.convert?view=netframework-4.7.2).
  prefs: []
  type: TYPE_NORMAL
- en: So far, we've learned that types have rules regarding their interactions, operations,
    and conversion, but how do we handle a situation where we need to store a variable
    of an unknown type? This might sound crazy, but think about a data-download scenarioâ€”you
    know the information is coming into your game, but you're not sure what form it
    will take. We'll discuss how to handle this in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Inferred declarations
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Luckily, C# can *infer* a variable''s type from its assigned value. For example,
    the `var` keyword can let the program know that the type of the data, `CurrentAge`,
    needs to be determined by its value of `32`, which is an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: While this is handy in certain situations, don't be suckered into the lazy programming
    habit of using inferred variable declarations for everything. This adds a lot
    of guesswork to your code, where it should be crystal clear.
  prefs: []
  type: TYPE_NORMAL
- en: Before we wrap up our discussion on data types and conversion, we do need to
    briefly touch on the idea of creating custom types, which we'll do next.
  prefs: []
  type: TYPE_NORMAL
- en: Custom types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When we're talking about data types, it's important to understand early on that
    numbers and words (referred to as *literal values*) are not the only kinds of
    values a variable can store. For instance, a class, struct, or enumeration can
    be stored as variables. We will introduce these topics in *Chapter 5*, *Working
    with Classes, Structs, and OOP*, and explore them in greater detail in *Chapter
    10*, *Revisiting Types, Methods, and Classes*.
  prefs: []
  type: TYPE_NORMAL
- en: 'Types are complicated, and the only way to get comfortable with them is by
    using them. However, here are some important things to keep in mind:'
  prefs: []
  type: TYPE_NORMAL
- en: All variables need to have a specified type (be it explicit or inferred)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Variables can only hold values of their assigned type (a `string` value can't
    be assigned an `int` variable)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If a variable needs to be assigned or combined with a variable of a different
    type, a conversion needs to take place (either implicit or explicit)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The C# compiler can infer a variable's type from its value using the `var` keyword,
    but should only be used when the type isn't known when it's created
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: That's a lot of nitty-gritty detail we've just jammed into a few sections, but
    we're not done yet. We still need to understand how naming conventions work in
    C#, as well as where the variables live in our scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Naming variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Picking names for your variables might seem like an afterthought in light of
    everything we've learned about access modifiers and types, but it shouldn't be
    a straightforward choice. Clear and consistent naming conventions in your code
    will not only make it more readable but will also ensure that other developers
    on your team understand your intentions without having to ask.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first rule when it comes to naming a variable is that the name you give
    it should be meaningful; the second rule is that you use Pascal case. Let''s take
    a common example from games and declare a variable to store a player''s health:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: If you find yourself declaring a variable like this, alarm bells should be going
    off in your head. Whose health? Is it storing the maximum or minimum value? What
    other code will be affected when this value changes? These are all questions that
    should be easily answered by a meaningful variable name; you don't want to find
    yourself confused by your code in a week or a month.
  prefs: []
  type: TYPE_NORMAL
- en: 'With that said, let''s try to make this a bit better using a Pascal case name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Remember, Pascal case starts each word in the variable name with an uppercase
    letter.
  prefs: []
  type: TYPE_NORMAL
- en: That's much better. With a little thought, we've updated the variable name with
    meaning and context. Since there is no technical limit in terms of how long a
    variable name can be, you might find yourself going overboard and writing out
    ridiculously descriptive names, which will give you problems just as much as a
    short, non-descriptive name would.
  prefs: []
  type: TYPE_NORMAL
- en: As a general rule, make a variable name as descriptive as it needs to beâ€”no
    more, no less. Find your style and stick to it.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding variable scope
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re getting to the end of our dive into variables, but there''s still one
    more important topic we need to cover: scope. Similar to access modifiers, which
    determine which outside classes can grab a variable''s information, the variable
    scope is the term used to describe where a given variable exists and its access
    point within its containing class.'
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three main levels of variable scope in C#:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global** scope refers to a variable that can be accessed by an entire program;
    in this case, a game. C# doesn''t directly support global variables, but the concept
    is useful in certain cases, which we''ll cover in *Chapter 10*, *Revisiting Types,
    Methods, and Classes.*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Class** or **member** scope refers to a variable that is accessible anywhere
    in its containing class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Local** scope refers to a variable that is only accessible inside the specific
    block of code it''s created in.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot. You don''t need to put this into `LearningCurve`
    if you don''t want to; it''s only for visualization purposes at this point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_09.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.9: Diagram of different scopes in the LearningCurve script'
  prefs: []
  type: TYPE_NORMAL
- en: When we talk about code blocks, we're referring to the area inside any set of
    curly brackets. These brackets serve as a kind of visual hierarchy in programming;
    the farther right-indented they are, the deeper they are nested in the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s break down the class and local scope variables in the preceding screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CharacterClass` is declared at the very top of the class, which means we can
    reference it by name anywhere inside `LearningCurve`. You might hear this concept
    referred to as variable visibility, which is a good way of thinking about it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CharacterHealth` is declared inside the `Start()` method, which means it is
    only visible inside that block of code. We can still access `CharacterClass` from
    `Start()` with no issue, but if we attempted to access `CharacterHealth` from
    anywhere but `Start()`, we would get an error.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CharacterName` is in the same boat as `CharacterHealth`; it can only be accessed
    from the `CreateCharacter()` method. This was just to illustrate that there can
    be multiple, even nested, local scopes in a single class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If you spend enough time around programmers, you''ll hear discussions (or arguments,
    depending on the time of day) about the best place to declare a variable. The
    answer is simpler than you might think: variables should be declared with their
    use in mind. If you have a variable that needs to be accessed throughout a class,
    make it a class variable. If you only need a variable in a specific section of
    code, declare it as a local variable.'
  prefs: []
  type: TYPE_NORMAL
- en: Note that only class variables can be viewed in the Inspector window, which
    isn't an option for local or global variables.
  prefs: []
  type: TYPE_NORMAL
- en: With naming and scope in our toolbox, let's transport ourselves back to middle
    school math class and relearn how arithmetic operations work all over again!
  prefs: []
  type: TYPE_NORMAL
- en: Introducing operators
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Operator symbols in programming languages represent the *arithmetic*, *assignment*,
    *relational*, and *logical* functionality that types can perform. Arithmetic operators
    represent basic math functions, while assignment operators perform math and assignment
    functions together on a given value. Relational and logical operators evaluate
    conditions between multiple values, such as *greater than*, *less than*, and *equal
    to*.
  prefs: []
  type: TYPE_NORMAL
- en: C# also offers bitwise and miscellaneous operators, but these won't come into
    play for you until you're well on your way to creating more complex applications.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, it only makes sense to cover arithmetic and assignment operators,
    but we'll get to relational and logical functionality when it becomes relevant
    in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Arithmetic and assignments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''re already familiar with the arithmetic operator symbols from school:'
  prefs: []
  type: TYPE_NORMAL
- en: '`+` for addition'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`-` for subtraction'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`/` for division'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`*` for multiplication'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'C# operators follow the conventional order of operations, that is, evaluating
    parentheses first, then exponents, then multiplication, then division, then addition,
    and finally subtraction. For instance, the following equations will provide different
    results, even though they contain the same values and operators:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Operators work the same when applied to variables as they do with literal values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Assignment operators can be used as a shorthand replacement for any math operation
    by using any arithmetic and equals symbol together. For example, if we wanted
    to multiply a variable, you could use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The second, alternative, way to do this is shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The equals symbol is also considered an assignment operator in C#. The other
    assignment symbols follow the same syntax pattern as our preceding multiplication
    example: `+=`, `-=`, and `/=` for add and assign, subtract and assign, and divide
    and assign, respectively.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Strings are a special case when it comes to operators as they can use the addition
    symbol to create patchwork text, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'This will produce the following when logged in to the **Console** panel:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_10.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.10: Using operators on strings'
  prefs: []
  type: TYPE_NORMAL
- en: This approach tends to produce clunky code, making string interpolation the
    preferred method for putting together different bits of text in most cases.
  prefs: []
  type: TYPE_NORMAL
- en: Take note that arithmetic operators don't work on all data types. For example,
    the `*` and `/` operators don't work on string values, and none of these operators
    work on Booleans. Having learned that types have rules that govern what kind of
    operations and interactions they can have, let's give it a shot in practice in
    the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s do a little experiment: we''ll try to multiply our `string` and `float`
    variables together, as we did earlier with our numbers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_11.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.11: Visual Studio incorrect type operation error message'
  prefs: []
  type: TYPE_NORMAL
- en: Look at Visual Studio and you'll see we've got an error message letting us know
    that a `string` type and a `float` type can't be multiplied. This error will also
    show up in the Unity **Console**, and won't let the project build.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_12.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.12: Console showing operator errors on incompatible data types'
  prefs: []
  type: TYPE_NORMAL
- en: Whenever you see this type of error, go back and inspect your variable types
    for incompatibilities.
  prefs: []
  type: TYPE_NORMAL
- en: We must clean up this example, as the compiler won't allow us to run our game
    at this point. Choose between a pair of backslashes (`//`) at the beginning of
    the line `Debug.Log(FirstName*Pi)`, or delete it altogether.
  prefs: []
  type: TYPE_NORMAL
- en: That's as far as we need to go in terms of variables and types for the moment.
    Be sure to test yourself on this chapter's quiz before moving on!
  prefs: []
  type: TYPE_NORMAL
- en: Defining methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we briefly touched on the role methods play in our
    programs; namely, that they store and execute instructions, just like variables
    store values. Now, we need to understand the syntax of method declarations and
    how they drive action and behavior in our classes.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with variables, method declarations have their basic requirements, which
    are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The type of data that will be returned by the method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unique name, starting with a capital letter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of parentheses following the method name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A pair of curly brackets marking the method body (where instructions are stored)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Putting all of these rules together, we get a simple method blueprint:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s break down the default `Start()` method in `LearningCurve` as a practical
    example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'In the preceding output, we can see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The method starts with the `void` keyword, which is used as the method's return
    type if it doesn't return any data.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method has a unique name within the class. You can use the same name in
    different classes, but you should aim to always make your names unique no matter
    what.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method has a pair of parentheses after its name to hold any potential parameters.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The method body is defined by a set of curly brackets.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In general, if you have a method that has an empty method body, it's good practice
    to delete it from the class. You always want to be pruning your scripts of unused
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Like variables, methods can also have security levels. However, they can also
    have input parameters, both of which we'll be discussing next!
  prefs: []
  type: TYPE_NORMAL
- en: Declaring methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Methods can also have the same four access modifiers that are available to variables,
    as well as input parameters. Parameters are variable placeholders that can be
    passed into methods and accessed inside them. The number of input parameters you
    can use isn't limited, but each one needs to be separated by a comma, show its
    data type, and have a unique name.
  prefs: []
  type: TYPE_NORMAL
- en: Think of method parameters as variable placeholders whose values can be used
    inside the method body.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we apply these options, our updated blueprint will look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: If there is no explicit access modifier, the method defaults to private. A private
    method, like a private variable, cannot be called from other scripts.
  prefs: []
  type: TYPE_NORMAL
- en: 'To call a method (meaning to run or execute its instructions), we simply use
    its name, followed by a pair of parentheses, with or without parameters, and cap
    it off with a semicolon:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Like variables, every method has a fingerprint that describes its access level,
    return type, and parameters. This is called its method signature. Essentially,
    a method's signature marks it as unique to the compiler so Visual Studio knows
    what to do with it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand how methods are structured, let's create one of our own.
  prefs: []
  type: TYPE_NORMAL
- en: 'The *Methods are placeholders too* section in the previous chapter had you
    blindly copy a method called `ComputeAge()` into `LearningCurve` without you knowing
    what you were getting into. This time, let''s purposefully create a method:'
  prefs: []
  type: TYPE_NORMAL
- en: Declare a `public` method with a void return type called `GenerateCharacter():`
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a simple `Debug.Log()` inside the new method and print out a character
    name from your favorite game or movie:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Call `GenerateCharacter()` inside the `Start()` method and hit play:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: When the game starts up, Unity automatically calls `Start()`, which, in turn,
    calls our `GenerateCharacter()` method and prints the result to the Console window.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If you have read enough documentation, you'll see different terminology related
    to methods. Throughout the rest of this book, when a method is created or declared,
    I'll refer to this as **defining** a method. Similarly, I'll refer to running
    or executing a method as **calling** that method.
  prefs: []
  type: TYPE_NORMAL
- en: The power of naming is integral to the entirety of the programming landscape,
    so it shouldn't be a surprise that we're going to revisit naming conventions for
    methods before moving on.
  prefs: []
  type: TYPE_NORMAL
- en: Naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Like variables, methods need unique, meaningful names to distinguish them in
    code. Methods drive actions, so it's a good practice to name them with that in
    mind. For example, `GenerateCharacter()` sounds like a command, which reads well
    when you call it in a script, whereas a name such as `Summary()` is bland and
    doesn't paint a very clear picture of what the method will accomplish. Like variables,
    method names are written in Pascal case.
  prefs: []
  type: TYPE_NORMAL
- en: Methods as logic detours
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We've seen that lines of code execute sequentially in the order they're written,
    but bringing methods into the picture introduces a unique situation. Calling a
    method tells the program to take a detour into the method instructions, run them
    one by one, and then resume sequential execution where the method was called.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take a look at the following screenshot and see whether you can figure out
    in what order the debug logs will be printed out to the console:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_13.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.13: Considering the order of debug logs'
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the steps that occur:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Choose a character` prints out first because it''s the first line of code.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'When `GenerateCharacter()` is called, the program jumps to line 23, prints
    out `Character: Spike`, and then resumes execution at line 17.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`A fine choice` prints out last, after all the lines in `GenerateCharacter()`
    have finished running.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/B17573_03_14.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.14: Console showing the output of character building code'
  prefs: []
  type: TYPE_NORMAL
- en: Now, methods in themselves wouldn't be very useful beyond simple examples like
    these if we couldn't add parameter values to them, which is what we'll do next.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Chances are your methods aren''t always going to be as simple as `GenerateCharacter()`.
    To pass in additional information, we''ll need to define parameters that our method
    can accept and work with. Every method parameter is an instruction and needs to
    have two things:'
  prefs: []
  type: TYPE_NORMAL
- en: An explicit type
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A unique name
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Does this sound familiar? Method parameters are essentially stripped-down variable
    declarations and perform the same function. Each parameter acts like a local variable,
    only accessible inside their specific method.
  prefs: []
  type: TYPE_NORMAL
- en: You can have as many parameters as you need. Whether you're writing custom methods
    or using built-in ones, the parameters that are defined are what the method requires
    to perform its specified task.
  prefs: []
  type: TYPE_NORMAL
- en: 'If parameters are the blueprint for the types of values a method can accept,
    then arguments are the values themselves. To break this down further, consider
    the following:'
  prefs: []
  type: TYPE_NORMAL
- en: The argument that's passed into a method needs to match the parameter type,
    just like a variable type and its value
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Arguments can be literal values (for instance, the number 2) or variables declared
    elsewhere in the class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Argument names and parameter names don't need to match to compile.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on and add some method parameters to make `GenerateCharacter()`
    a bit more interesting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s update `GenerateCharacter()` so that it can take in two parameters:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add two method parameters: one for a character''s name of the `string` type,
    and another for a character''s level of the `int` type:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update `Debug.Log()` so that it uses these new parameters:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Update the `GenerateCharacter()` method call in `Start()` with your arguments,
    which can be either literal values or declared variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Your code should look like the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![](img/B17573_03_15.png)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 3.15: Updating the GenerateCharacter() method'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Here, we defined two parameters, `name` (string) and `level` (int), and used
    them inside the `GenerateCharacter()` method, just like local variables. When
    we called the method inside `Start()`, we added argument values for each parameter
    with corresponding types. In the preceding screenshot, you can see that using
    the literal string value in quotations produced the same result as using `characterLevel`.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_16.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.16: Console showing the output from method parameters'
  prefs: []
  type: TYPE_NORMAL
- en: Going even further with methods, you might be wondering how we can pass values
    from inside the method and back out again. This brings us to our next section
    on return values.
  prefs: []
  type: TYPE_NORMAL
- en: Specifying return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Aside from accepting parameters, methods can return values of any C# type. All
    of our previous examples have used the `void` type, which doesn't return anything,
    but being able to write instructions and pass back computed results is where methods
    shine.
  prefs: []
  type: TYPE_NORMAL
- en: According to our blueprints, method return types are specified after the access
    modifier. In addition to the type, the method needs to contain the `return` keyword,
    followed by the return value. A return value can be a variable, a literal value,
    or even an expression, as long as it matches the declared return type.
  prefs: []
  type: TYPE_NORMAL
- en: Methods that have a return type of `void` can still use the return keyword with
    no value or expression assigned. Once the line with the return keyword is reached,
    the method will stop executing. This is useful in cases where you want to avoid
    certain behaviors or guard against program crashes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add a return type to `GenerateCharacter()` and learn how to capture it
    in a variable. Let''s update the `GenerateCharacter()` method so that it returns
    an integer:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the return type in the method declaration from `void` to `int`, and
    set the return value to `level += 5` using the `return` keyword:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`GenerateCharacter()` will now return an integer. This is computed by adding
    `5` to the level argument. We haven''t specified how, or if, we want to use this
    return value, which means that right now, the script won''t do anything new.'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, the question becomes: how do we capture and use the newly added return
    value? Well, we''ll discuss that very topic in the following section.'
  prefs: []
  type: TYPE_NORMAL
- en: Using return values
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to using return values, there are two approaches available:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a local variable to capture (store) the returned value.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use the calling method itself as a stand-in for the returned value, using it
    just like a variable. The calling method is the actual line of code that fires
    the instructions, which, in our example, would be `GenerateCharacter("Spike",
    CharacterLevel)`. You can even pass a calling method into another method as an
    argument if need be.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first option is preferred in most programming circles for its readability.
    Throwing around method calls as variables can get messy fast, especially when
    we use them as arguments in other methods.
  prefs: []
  type: TYPE_NORMAL
- en: Let's give this a try in our code by capturing and debugging the return value
    that `GenerateCharacter()` returns.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to use both ways of capturing and using return variables with
    two simple debug logs:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new local variable in the `Start` method of the `int` type, called
    `NextSkillLevel`, and assign it to the return value of the `GenerateCharacter()`
    method call we already have in place:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add two debug logs, with the first printing out `NextSkillLevel` and the second
    printing out a new calling method with argument values of your choice:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Comment out the debug log inside `GenerateCharacter()` with two forward slashes
    (`//`) to make the console output less cluttered. Your code should look like the
    following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the file and hit play in Unity. To the compiler, the `NextSkillLevel` variable
    and the `GenerateCharacter()` method caller represent the same information, namely
    an integer, which is why both logs show the number `37`:![](img/B17573_03_17.png)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 3.17: Console output from the character generation code'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That was a lot to take in, especially given the exponential possibilities of
    methods with parameters and return values. However, we'll ease off the throttle
    here for a minute and consider some of Unity's most common methods to catch a
    little breathing room.
  prefs: []
  type: TYPE_NORMAL
- en: But first, see if you can handle a challenge in the next *Hero's trial*!
  prefs: []
  type: TYPE_NORMAL
- en: Hero's trial â€“ methods as arguments
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you're feeling brave, why not try creating a new method that takes in an
    `int` parameter and simply prints it out to the console? No return type is necessary.
    When you've got that, call the method in `Start`, pass in a `GenerateCharacter`
    method call as its argument, and take a look at the output.
  prefs: []
  type: TYPE_NORMAL
- en: Dissecting common Unity methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We''re now at a point where we can realistically discuss the most common default
    methods that come with any new Unity C# script: `Start()` and `Update()`. Unlike
    the methods we define ourselves, methods belonging to the `MonoBehaviour` class
    are called automatically by the Unity engine according to their respective rules.
    In most cases, it''s important to have at least one `MonoBehaviour` method in
    a script to kick off your code.'
  prefs: []
  type: TYPE_NORMAL
- en: You can find a complete list of all available MonoBehaviour methods and their
    descriptions at [https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
    You can also find the order in which each method is executed at [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).
  prefs: []
  type: TYPE_NORMAL
- en: Just like stories, it's always a good idea to start at the beginning. So, naturally,
    we should take a look at every Unity script's first default methodâ€”`Start()`.
  prefs: []
  type: TYPE_NORMAL
- en: The Start method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unity calls the `Start()` method on the first frame where a script is enabled
    for the first time. Since `MonoBehaviour` scripts are almost always attached to
    *GameObjects* in a scene, their attached scripts are enabled at the same time
    they are loaded when you hit play. In our project, `LearningCurve`is attached
    to the **Main Camera** *GameObject*, which means that its `Start()` method runs
    when the main camera is loaded into the scene. `Start()` is primarily used to
    set up variables or perform logic that needs to happen before `Update()` runs
    for the first time.
  prefs: []
  type: TYPE_NORMAL
- en: The examples we've worked on so far have all used `Start()`, even though they
    weren't performing setup actions, which isn't normally the way it would be used.
    However, it only fires once, making it an excellent tool to use for displaying
    one-time-only information on the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Other than `Start()`, there''s one other major Unity method that you''ll run
    into by default: `Update()`. Let''s familiarize ourselves with how it works in
    the following section before we finish off this chapter.'
  prefs: []
  type: TYPE_NORMAL
- en: The Update method
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you spend enough time looking at the sample code in the Unity Scripting Reference
    ([https://docs.unity3d.com/ScriptReference/](https://docs.unity3d.com/ScriptReference/)),
    you'll notice that a vast majority of the code is executed using the `Update()`
    method. As your game runs, the Scene window is displayed many times per second,
    which is called the frame rate or **frames per second** (**FPS**).
  prefs: []
  type: TYPE_NORMAL
- en: After each frame is displayed, the `Update()` method is called by Unity, making
    it one of the most executed methods in your game. This makes it ideal for detecting
    mouse and keyboard input or running gameplay logic.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you''re curious about the FPS rating on your machine, hit play in Unity
    and click the **Stats** tab in the upper-right corner of the **Game** view:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B17573_03_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3.18: Unity editor showing the Stats panel with graphics FPS count'
  prefs: []
  type: TYPE_NORMAL
- en: You'll be using the `Start()` and `Update()` methods in the lion's share of
    your initial C# scripts, so get acquainted with them. That being said, you've
    reached the end of this chapter with a pocketful of the most fundamental building
    blocks programming with C# has to offer.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter has been a fast descent from the basic theory of programming and
    its building blocks into the strata of real code and C# syntax. We've seen good
    and bad forms of code formatting, learned how to debug information in the Unity
    console, and created our first variables.
  prefs: []
  type: TYPE_NORMAL
- en: C# types, access modifiers, and variable scope weren't far behind, as we worked
    with member variables in the Inspector window and started venturing into the realm
    of methods and actions.
  prefs: []
  type: TYPE_NORMAL
- en: Methods helped us to understand written instructions in code, but more importantly,
    how to properly harness their power into useful behaviors. Input parameters, return
    types, and method signatures are all important topics, but the real gift they
    offer is the potential for new kinds of actions to be performed.
  prefs: []
  type: TYPE_NORMAL
- en: You're now armed with the two fundamental building blocks of programming; almost
    everything you'll do from now on will be an extension or application of these
    two concepts.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll take a look at a special subset of C# types called
    collections, which can store groups of related data, and learn how to write decision-based
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Pop quiz â€“ variables and methods
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is the proper way to write a variable name in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you make a variable appear in Unity's Inspector window?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the four access modifiers available in C#?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When are explicit conversions needed between types?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the minimum requirements for defining a method?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the purpose of the parentheses at the end of the method name?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What does a return type of `void` mean in a method definition?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How often is the `Update()` method called by Unity?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: JOIN us on Discord!
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Read this book alongside other users, Unity/C# experts, and Harrison Ferrone.
    Ask questions, provide solutions to other readers, chat with the author via *Ask
    Me Anything sessions* and much more.
  prefs: []
  type: TYPE_NORMAL
- en: Join Now!
  prefs: []
  type: TYPE_NORMAL
- en: '[https://packt.link/csharpunity2021](https://packt.link/csharpunity2021)'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/QR_Code_9781801813945.png)'
  prefs: []
  type: TYPE_IMG
