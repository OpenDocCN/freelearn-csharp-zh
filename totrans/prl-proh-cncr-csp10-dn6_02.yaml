- en: '*Chapter 1*: Managed Threading Concepts'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`async` and `await` keywords in C#. This book will cover all of these concepts
    in the chapters ahead.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will start with the basics of how to work with **managed
    threading** in .NET. You will learn how to create and destroy threads, handle
    exceptions, synchronize data, and utilize the objects provided by .NET to handle
    background operations. Additionally, you will gain a basic understanding of how
    threads can be managed in a .NET application. The practical examples in this chapter
    will illustrate how to leverage managed threading in C# projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: .NET threading basics
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and destroying threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling threading exceptions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Synchronizing data across threads
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scheduling and canceling work
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By starting with the core concepts of threading in .NET, you will gain a solid
    foundation as you move forward with your learning throughout this book. It is
    important to understand the basics to prevent common mistakes from being made
    while introducing threading and asynchrony to .NET applications. It is all too
    easy to exhaust resources or put the application’s data in an invalid state. Let’s
    get started with managed threading with C#.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To follow along with the examples in this chapter, the following software is
    recommended:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022 version 17.0 or later
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: .NET 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: While these are recommended, as long as you have .NET 6 installed, you can use
    your preferred editor. For example, Visual Studio 2022 for Mac, JetBrains Rider,
    or Visual Studio Code will work just as well.
  prefs: []
  type: TYPE_NORMAL
- en: All the code examples for this chapter can be found on GitHub at https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter01.
  prefs: []
  type: TYPE_NORMAL
- en: .NET threading basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: It’s time to get started by learning about the basics of threading in C# and
    .NET. We will be covering the managed threading concepts that are available in
    .NET 6, but many of these features have been part of .NET since the beginning.
    The `System.Threading` namespace has been available since .NET Framework 1.0\.
    In the subsequent 20 years, there have been many useful features added for developers.
  prefs: []
  type: TYPE_NORMAL
- en: In order to responsibly use threading in your applications, you should understand
    exactly what a **thread** is and how threads are used by your application’s **processes**.
  prefs: []
  type: TYPE_NORMAL
- en: Threads and processes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start our journey with the basic units of application processing, threads,
    and processes. A process encapsulates all the execution of an application. This
    is true for all platforms and frameworks. In .NET, you can think of a process
    as your `.exe` or hosted service.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In .NET Framework, the concept of **application domains** (or app domains),
    which create isolation units within a process, was introduced. These app domains
    provide security and reliability by isolating the execution of code loaded into
    a new app domain. App domains still exist but are not available for developers
    to create or unload in .NET Core and modern versions of .NET. To read more about
    app domains, check out this Microsoft Docs article at https://docs.microsoft.com/dotnet/framework/app-domains/application-domains.
  prefs: []
  type: TYPE_NORMAL
- en: A **thread** represents a single unit of execution within a process. By default,
    a .NET application will execute all its logic on a single thread (that is, the
    primary or main thread). Developers can leverage managed threads and other .NET
    constructs to move from a single-threaded to a multithreaded world, but how do
    you know when to take this step?
  prefs: []
  type: TYPE_NORMAL
- en: When should we use multithreading in .NET?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are multiple factors to consider when deciding whether to introduce threading
    to an application. These factors are both internal and external to the application.
    The external factors include the hardware in terms of where the application will
    be deployed, how powerful the processors are where the application will be running,
    and what other types of processes will be running on these systems?
  prefs: []
  type: TYPE_NORMAL
- en: If your application will be competing for limited resources, it is best to be
    judicious with the use of multiple threads. If users get the impression that your
    application is impacting the performance of their systems, you will need to scale
    back on the number of threads being consumed by your process. Another factor that
    comes into play is how critical your application is in relation to others on the
    system. Mission-critical applications will have more resources allocated to remain
    responsive when needed.
  prefs: []
  type: TYPE_NORMAL
- en: Other common reasons for introducing threading relate to the application itself.
    Desktop and mobile applications need to keep the **user interface** (**UI**) responsive
    to user input. If the application needs to process a large amount of data or load
    it from a database, file, or network resource, executing on the main thread can
    cause the UI to freeze or lag. Also, executing long-running tasks in parallel
    on multiple threads can reduce the overall execution time of the task.
  prefs: []
  type: TYPE_NORMAL
- en: These operations can be offloaded to **background threads** if the execution
    of the tasks is not critical to the application state. Let’s look at the difference
    between foreground threads and background threads in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Background threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The difference between foreground threads and background threads might not be
    what you think. A managed thread created as a foreground thread is not the UI
    thread or the main thread. Foreground threads are threads that will prevent the
    managed process from terminating if they are running. If an application is terminated,
    any running background threads will be stopped so that the process can shut down.
  prefs: []
  type: TYPE_NORMAL
- en: By default, newly created threads are foreground threads. To create a new background
    thread, set the `Thread.IsBackground` property to `true` before starting the thread.
    Additionally, you can use the `IsBackground` property to determine the background
    status of an existing thread. Let’s look at an example where you might want to
    use a background thread in your application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this example, we will create a console application in Visual Studio that
    will continuously check the status of a network connection on a background thread.
    Create a new .NET 6 console app project, name it `BackgroundPingConsoleApp`, and
    in `Program.cs`, enter the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s discuss each part of the preceding code before we run it and examine
    the output:'
  prefs: []
  type: TYPE_NORMAL
- en: The first `Console.WriteLine` statement was created by the project template.
    We’ll keep this here to help illustrate the order output in the console.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, we’re creating a new `Thread` type named `bgThread`. Inside the body of
    the thread, there is a `while` loop that will execute continuously until the thread
    is terminated. Inside the loop, we’re calling the `GetIsNetworkAvailable` method
    and outputting the result of that call to the console. Before starting over again,
    we’re using `Thread.Sleep` to inject a 100-millisecond delay.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next line after creating the thread is the key part of this lesson:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Setting the `IsBackground` property to `true` is what makes our new thread a
    background thread. This tells our application that the code executing inside the
    thread is not critical to the application, and the process can terminate without
    needing to wait for the thread to complete its work. That is a good thing here
    because the `while` loop we created will never be complete.
  prefs: []
  type: TYPE_NORMAL
- en: On the next line, we start the thread with the `Start` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, the application kicks off some work inside the application’s primary thread.
    A `for` loop will execute 10 times and output `"Main thread working..."` to the
    console. At the end of each iteration of the loop, `Task.Delay` is used to wait
    500 milliseconds, hopefully providing some time for the background thread to perform
    some work.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After the `for` loop, the application will output `"Done"` to the console and
    wait for the user input to terminate the application with the `Console.ReadKey`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, run the application and examine the console output. You can press any
    key to stop the application when you feel you have let it run for long enough:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Viewing the threaded console application output ](img/Figure_1.1_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Viewing the threaded console application output
  prefs: []
  type: TYPE_NORMAL
- en: The result might not be what you expected. You can see that the program executed
    all the logic on the primary thread before starting any of the background thread
    work. Later, we’ll see how to change the priority of the threads to manipulate
    which work will be processed first.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is important to understand, in this example, is that we were able to stop
    the console application by pressing a key to execute the `Console.ReadKey` command.
    Even though the background thread is still running, the process does not consider
    the thread to be critical to the application. If you comment out the following
    line, the application will no longer terminate by pressing a key:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: The application will have to be stopped by closing the command window or using
    the **Debug** | **Stop Debugging** menu item in Visual Studio. Later, in the *Scheduling
    and canceling work* section, we will learn how to cancel work in a managed thread.
  prefs: []
  type: TYPE_NORMAL
- en: Before we look at any more examples of using managed threads, we will take some
    time to learn exactly what they are.
  prefs: []
  type: TYPE_NORMAL
- en: What is managed threading?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In .NET, `System.Threading.Thread` class that we used in the previous example.
    The managed execution environment for the current process monitors all the threads
    that have been run as part of the process. `PInvoke`) calls from .NET code. If
    this thread is entering the managed environment for the first time, .NET will
    create a new `Thread` object to be managed by the execution environment.
  prefs: []
  type: TYPE_NORMAL
- en: A managed thread can be uniquely identified using the `ManagedThreadId` property
    of the `Thread` object. This property is an integer that is guaranteed to be unique
    across all threads and will not change over time.
  prefs: []
  type: TYPE_NORMAL
- en: The `ThreadState` property is a read-only property that provides the current
    execution state of the `Thread` object. In the example in the *.NET threading
    basics* section, if we had checked the `ThreadState` property before calling `bgThread.Start()`,
    it would have been `Unstarted`. After calling `Start`, the state will change to
    `Background`. If it were not a background thread, calling `Start` would change
    the `ThreadState` property to `Running`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a full list of the `ThreadState` enum values:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Aborted`: The thread has been aborted.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AbortRequested`: An abort has been requested but has not yet been completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Background`: The thread is running in the background (`IsBackground` has been
    set to true).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Running`: The thread is currently running.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Stopped`: The thread has been stopped.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`StopRequested`: A stop has been requested but has not yet been completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Suspended`: The thread has been suspended.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`SuspendRequested`: Thread suspension has been requested but has not yet been
    completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Unstarted`: The thread has been created but not yet started.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WaitSleepJoin`: The thread is currently blocked.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Thread.IsAlive` property is a less specific property that can tell you
    whether a thread is currently running. It is a `boolean` property that will return
    `true` if the thread has started and has not been stopped or aborted in some way.
  prefs: []
  type: TYPE_NORMAL
- en: Threads also have a `Name` property that defaults to `null` if they have never
    been set. Once a `Name` property is set on a thread, it cannot be changed. If
    you attempt to set the `Name` property of a thread that is not null, it will throw
    `InvalidOperationException`.
  prefs: []
  type: TYPE_NORMAL
- en: We will cover additional aspects of managed threads in the remainder of this
    chapter. In the next section, we will dive deeper into the available methods and
    options for creating and destroying threads in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Creating and destroying threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '`Thread` class that should be discussed first. Also, we will look at a few
    methods of pausing or interrupting thread execution. Finally, we will cover some
    ways to destroy or terminate a thread’s execution.'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s get started by going into more detail regarding creating and starting
    threads.
  prefs: []
  type: TYPE_NORMAL
- en: Creating managed threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Creating `Thread` object. The `Thread` class has four constructor overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Thread(ParameterizedThreadStart)`: This creates a new `Thread` object. It
    does this by passing a delegate with a constructor that takes an object as its
    parameter that can be passed when calling `Thread.Start()`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread(ThreadStart)`: This creates a new `Thread` object that will execute
    the method to be invoked, which is provided as the `ThreadStart` property.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread(ParameterizedThreadStart, Int32):` This adds a `maxStackSize` parameter.
    Avoid using this overload because it is best to allow .NET to manage the stack
    size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Thread(ThreadStart, Int32):` This adds a `maxStackSize` parameter. Avoid using
    this overload because it is best to allow .NET to manage the stack size.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Our first example used the `Thread(ThreadStart)` constructor. Let’s look at
    a version of that code that uses `ParameterizedThreadStart` to pass a value by
    limiting the number of iterations of the `while` loop:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: If you run the application, it will run just like the last example, but the
    background thread should only output 12 lines to the console. You can try passing
    different integer values into the `Start` method to see how that impacts the console
    output.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to get a reference to the thread that is executing the current
    code, you can use the `Thread.CurrentThread` static property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: This can be useful if your code needs to check the current thread’s `ManagedThreadId`,
    `Priority`, or whether it is running in the background.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at how we can pause or interrupt the execution of a thread.
  prefs: []
  type: TYPE_NORMAL
- en: Pausing thread execution
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Sometimes, it is necessary to pause the execution of a thread. A common real-life
    example of this is a retry mechanism on a background thread. If you have a method
    that sends log data to a network resource, but the network is unavailable, you
    can call `Thread.Sleep` to wait for a specific interval before trying again. `Thread.Sleep`
    is a static method that will block the current thread for the number of milliseconds
    specified. It is not possible to call `Thread.Sleep` on a thread other than the
    current one.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already used `Thread.Sleep` in the examples in this chapter, but let’s
    change the code slightly to see how it can impact the order of events. Change
    the `Thread.Sleep` interval inside the thread to `10`, remove the code that makes
    it a background thread, and change the `Task.Delay()` call to `Thread.Sleep(100)`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: 'When running the application again, you can see that putting a greater delay
    on the primary thread allows the process inside `bgThread` to begin executing
    before the primary thread completes its work:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Using Thread.Sleep to change the order of events ](img/Figure_1.2_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Using Thread.Sleep to change the order of events
  prefs: []
  type: TYPE_NORMAL
- en: The two `Thread.Sleep` intervals can be adjusted to see how they impact the
    console output. Give it a try!
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, it is possible to pass `Timeout.Infinite` to `Thread.Sleep`. This
    will cause the thread to pause until it is interrupted or aborted by another thread
    or the managed environment. Interrupting a blocked or paused thread is accomplished
    by calling `Thread.Interrupt`. When a thread is interrupted, it will receive a
    `ThreadInterruptedException` exception.
  prefs: []
  type: TYPE_NORMAL
- en: The exception handler should allow the thread to continue working or clean up
    any remaining work. If the exception is unhandled, the runtime will catch the
    exception and stop the thread. Calling `Thread.Interrupt` on a running thread
    will have no effect until that thread has been blocked.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you understand how to create an interrupt thread, let’s wrap up this
    section by learning how to destroy a thread.
  prefs: []
  type: TYPE_NORMAL
- en: Destroying managed threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Generally, `Thread.Abort` method. In .NET Framework, calling `Thread.Abort`
    on a thread would raise a `ThreadAbortedException` exception and stop the thread
    from running. Aborting threads was not made available in .NET Core or any of the
    newer versions of .NET. If some code needs to be forcibly stopped, it is recommended
    that you run it in a separate process from your other code and use `Process.Kill`
    to terminate the other process.
  prefs: []
  type: TYPE_NORMAL
- en: Any other thread termination should be handled cooperatively using cancelation.
    We will see how to do this in the *Scheduling and canceling work* section. Next,
    let’s discuss some of the exceptions to handle when working with managed threads.
  prefs: []
  type: TYPE_NORMAL
- en: Handling threading exceptions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are a couple of exception types that are specific to managed threading,
    including the `ThreadInterruptedException` exception that we covered in the previous
    section. Another exception type that is specific to threading is `ThreadAbortException`.
    However, as we discussed in the previous section, `Thread.Abort` is not supported
    in .NET 6, so, although this exception type exists in .NET 6, it is not necessary
    to handle it, as this type of exception is only possible in .NET Framework applications.
  prefs: []
  type: TYPE_NORMAL
- en: Two other exceptions are the `ThreadStartException` exception and the `ThreadStateException`
    exception. The `ThreadStartException` exception is thrown if there is a problem
    starting the managed thread before any user code in the thread can be executed.
    The `ThreadStateException` exception is thrown when a method on the thread is
    called that is not available when the thread is in its current `ThreadState` property.
    For example, calling `Thread.Start` on a thread that has already started is invalid
    and will cause a `ThreadStateException` exception. These types of exceptions can
    usually be avoided by checking the `ThreadState` property before acting on the
    thread.
  prefs: []
  type: TYPE_NORMAL
- en: It is important to implement comprehensive exception handling in multithreaded
    applications. If code in managed threads begins to fail silently without any logging
    or causing the process to terminate, the application can fall into an invalid
    state. This can also result in degrading performance and unresponsiveness. While
    this kind of degradation might be noticed quickly for many applications, some
    services, and other non-GUI-based applications, could continue for some time without
    any issues being noticed. Adding logging to the exception handlers along with
    a process to alert users when logs are reporting failures will help to prevent
    problems with undetected failing threads.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the next section, we’ll discuss another challenge with multithreaded code:
    keeping data in-sync across multiple threads.'
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing data across threads
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will look at some of the methods that are available in .NET
    for synchronizing data across multiple threads. Shared data across threads can
    be one of the primary pain points of multithreaded development if not handled
    properly. Classes in .NET that have protections in place for threading are said
    to be **thread-safe**.
  prefs: []
  type: TYPE_NORMAL
- en: 'Data in multithreaded applications can be synchronized in several different
    ways:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Monitor` class or with some help from the .NET compiler.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Manual synchronization**: There are several **synchronization primitives**
    in .NET that can be used to manually synchronize data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Synchronized context**: This is only available in .NET Framework and Xamarin
    applications.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**System.Collections.Concurrent classes**: There are specialized .NET collections
    to handle concurrency. We will examine these in [*Chapter 9*](B18552_09_ePub.xhtml#_idTextAnchor146).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we’ll look at the first two methods. Let’s start by discussing
    how to synchronize code regions in your application.
  prefs: []
  type: TYPE_NORMAL
- en: Synchronizing code regions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several techniques you can use to synchronize regions of your code.
    The first one we will discuss is the `Monitor` class. You can surround a block
    of code that can be accessed by multiple threads with calls to `Monitor.Enter`
    and `Monitor.Exit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: In this example, imagine you have an `order` object that is being updated by
    multiple threads in parallel. The `Monitor` class will lock access from other
    threads while the current thread adds an `orderDetail` item to the `order` object.
    The key to minimizing the chance of introducing wait time to other threads is
    by only locking the lines of code that need to be synchronized.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Interlocked` class, as discussed in this section, performs atomic operations
    in user mode rather than kernel mode. If you want to read more about this distinction,
    I recommend checking out this blog post by Nguyen Thai Duong: https://duongnt.com/interlocked-synchronization/.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Interlocked` class provides several methods for performing atomic operations
    on objects shared across multiple threads. The following list of methods is part
    of the `Interlocked` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Add`: This adds two integers, replacing the first one with the sum of the
    two'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`And`: This is a bitwise `and` operation for two integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CompareExchange`: This compares two objects for equality and replaces the
    first if they are equal'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Decrement`: This decrements an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Exchange`: This sets a variable to a new value'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Increment`: This increments an integer'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Or`: This is a bitwise `or` operation for two integers'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These `Interlocked` operations will lock access to the target object only for
    the duration of that operation.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `lock` statement in C# can be used to lock access to a block
    of code to only a single thread. The `lock` statement is a language construct
    implemented using the .NET `Monitor.Enter` and `Monitor.Exit` operations.
  prefs: []
  type: TYPE_NORMAL
- en: There is some built-in compiler support for the `lock` and `Monitor` blocks.
    If an exception is thrown inside one of these blocks, the lock is automatically
    released. The C# compiler generates a `try/finally` block around the synchronized
    code and makes a call to `Monitor.Exit` in the `finally` block.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s finish up this section on synchronization by looking at some other .NET
    classes that provide support for manual data synchronization.
  prefs: []
  type: TYPE_NORMAL
- en: Manual synchronization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The use of **manual synchronization** is common when synchronizing data across
    multiple threads. Some types of data cannot be protected in other ways, such as
    these:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Global fields**: These are variables that can be accessed globally across
    the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static fields**: These are static variables in a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Instance fields**: These are instance variables in a class.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These fields do not have method bodies, so there is no way to put a synchronized
    code region around them. With manual synchronization, you can protect all the
    areas where these objects are used. These regions can be protected with `lock`
    statements in C#, but some other synchronization primitives provide access to
    shared data and can coordinate the interactions between threads on a more granular
    level. The first construct we will examine is the `System.Threading.Mutex` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Mutex` class is similar to the `Monitor` class in that it blocks access
    to a region of code, but it can also provide the ability to grant access to other
    processes. When using the `Mutex` class, use the `WaitOne()` and `ReleaseMutex()`
    methods to acquire and release the lock. Let’s look at the same order/order details
    example. This time, we’ll use a `Mutex` class declared at the class level:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: 'If you want to enforce a timeout period on the `Mutex` class, you can call
    the `WaitOne` overload with a timeout value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: It is important to note that `Mutex` is a `Dispose()` on the object when you
    are finished using it. Additionally, you can also enclose a disposable type within
    a `using` block to have it disposed of indirectly.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, the last .NET manual locking construct we are going to examine
    is the `ReaderWriterLockSlim` class. You can use this type if you have an object
    that is used across multiple threads, but most of the code is reading data from
    the object. You don’t want to lock access to the object in the blocks of code
    that are reading data, but you do want to prevent reading while the object is
    being updated or simultaneously written. This is referred to as "multiple readers,
    single writer."
  prefs: []
  type: TYPE_NORMAL
- en: 'This `ContactListManager` class contains a list of contacts that can be added
    to or retrieved by a phone number. The class assumes that these operations can
    be called from multiple threads and uses the `ReaderWriterLockSlim` class to apply
    a read lock in the `GetContactByPhoneNumber` method and a write lock in the `AddContact`
    method. The locks are released in a `finally` block to ensure they are always
    released, even when exceptions are encountered:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE107]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE108]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE110]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE111]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE112]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: 'If you were to add a `DeleteContact` method to the `ContactListManager` class,
    you would leverage the same `EnterWriteLock` method to prevent any conflicts with
    the other operations in the class. If a lock is forgotten in one usage of `contacts`,
    it can cause any of the other operations to fail. Additionally, it is possible
    to apply a timeout to the `ReaderWriterLockSlim` locks:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: There are several other synchronization primitives that we have not covered
    in this section, but we have discussed some of the most common types that you
    will use. To read more about the available types for manual synchronization, you
    can visit Microsoft Docs at https://docs.microsoft.com/dotnet/standard/threading/overview-of-synchronization-primitives.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have examined different ways of synchronizing data when working
    with managed threads, let’s cover two more important topics before wrapping up
    this first chapter. We are going to discuss techniques to schedule work on threads
    and how to cancel managed threads cooperatively.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling and canceling work
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When orchestrating multithreaded processing in an application, it is important
    to understand how to schedule and cancel work on managed threads.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s start by looking at how scheduling works with managed threads in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: Scheduling managed threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When it comes to managed threads, scheduling is not as explicit as it might
    sound. There is no mechanism to tell the operating system to kick off work at
    specific times or to execute within certain intervals. While you could write this
    kind of logic, it is probably not necessary. The process of scheduling managed
    threads is simply managed by setting priorities on the threads. To do this, set
    the `Thread.Priority` property to one of the available `ThreadPriority` values:
    `Highest`, `AboveNormal`, `Normal` (default), `BelowNormal`, or `Lowest`.'
  prefs: []
  type: TYPE_NORMAL
- en: Generally, higher priority threads will execute before those of lower priority.
    Usually, a thread of `Lowest` priority will not execute until all the higher priority
    threads have been completed. If the `Lowest` priority thread has started and a
    `Normal` thread kicks off, the `Lowest` priority thread will be suspended so that
    the `Normal` thread can be run. These rules are not absolute, but you can use
    them as a guide. Most of the time, you will leave the default of `Normal` for
    your threads.
  prefs: []
  type: TYPE_NORMAL
- en: When there are multiple threads of the same priority, the operating system will
    cycle through them, giving each thread up to a maximum allotment of time before
    suspending work and moving on to the next thread of the same priority. The logic
    will vary by the operating system, and the prioritization of a process can change
    based on whether the application is in the foreground of the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s use our network checking code to test thread priorities:'
  prefs: []
  type: TYPE_NORMAL
- en: Start by creating a new console application in Visual Studio
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class to the project, named `NetworkingWork`, and add a method named
    `CheckNetworkStatus` with the following implementation:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE127]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The calling code will be passing a parameter with the priority of the thread
    that is currently executing the message. That will be added as part of the console
    output inside the `for` loop, so users can see which priority threads are running
    first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, replace the contents of `Program.cs` with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code creates five `Thread` objects, each with a different `Thread.Priority`
    value. To make things a little more interesting, the threads are being started
    in reverse order of their priorities. You can try changing this on your own to
    see how the order of execution is impacted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now run the application and examine the output:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Console output from five different threads ](img/Figure_1.3_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Console output from five different threads
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the operating system, which, in my case, is Windows 11, sometimes
    executes lower priority threads before all the higher priority threads have completed
    their work. The algorithm for selecting the next thread to run is a bit of a mystery.
    You should also remember that this is multithreading. Multiple threads are running
    at once. The exact number of threads that can run simultaneously will vary by
    the processor or virtual machine configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s wrap things up by learning how to cancel a running thread.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling managed threads
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Canceling managed threads** is one of the more important concepts to understand
    about managed threading. If you have long-running operations running on foreground
    threads, they should support cancelation. There are times when you might want
    to allow users to cancel the processes through your application’s UI, or the cancelation
    might be part of a cleanup process while the application is closing.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To cancel an operation in a managed thread, you will use a `CancellationToken`
    parameter. The `Thread` object itself does not have built-in support for cancellation
    tokens like some of the modern threading constructs .NET. So, we will have to
    pass the token to the method running in the newly created thread. In the next
    exercise, we will modify the previous example to support cancelation:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by updating `NetworkingWork.cs` so that the parameter passed to `CheckNetworkStatus`
    is a `CancellationToken` parameter:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The code will keep checking the network status inside a while loop until `IsCancellationRequested`
    becomes `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In `Program.cs`, we’re going to return to working with only one `Thread` object.
    Remove or comment out all of the previous background threads. To pass the `CancellationToken`
    parameter to the `Thread.Start` method, create a new `CancellationTokenSource`
    object, and name it `ctSource`. The cancellation token is available in the `Token`
    property:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE130]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, inside the `for` loop, add a `Thread.Sleep(100)` statement to allow `pingThread`
    to execute while the main thread is suspended:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'After the `for` loop is complete, invoke the `Cancel()` method, join the thread
    back to the main thread, and dispose of the `ctSource` object. The `Join` method
    will block the current thread and wait for `pingThread` to complete using this
    thread:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE132]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when you run the application, you will see the network checking stops
    shortly after the final `Thread.Sleep` statement on the main thread has been executed:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Canceling a thread in the console application ](img/Figure_1.4_B18552.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Canceling a thread in the console application
  prefs: []
  type: TYPE_NORMAL
- en: Now the network checker application is gracefully canceling the threaded work
    before listening for a keystroke to close the application.
  prefs: []
  type: TYPE_NORMAL
- en: When you have a long-running process on a managed thread, you should check for
    cancellation as the code iterates through loops, begins a new step in a process,
    and at other logical checkpoints in the process. If the operation uses a timer
    to periodically perform work, the token should be checked each time the timer
    executes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way to listen for cancellation is by registering a `Token.Register`
    method inside the managed thread to receive a cancellation callback. The following
    `CheckNetworkStatus2` method will work exactly like the previous example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE142]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE143]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE144]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE145]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE146]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: Using a delegate like this is more useful if you have multiple parts of your
    code that need to listen for a cancellation request. A **callback** method can
    call several cleanup methods or set another flag that is monitored throughout
    the thread. It encapsulates the cleanup operation nicely.
  prefs: []
  type: TYPE_NORMAL
- en: We will revisit cancellation in [*Chapter 11*](B18552_11_ePub.xhtml#_idTextAnchor173),
    as we introduce new parallelism and concurrency concepts. However, this section
    should provide a solid foundation for understanding what comes next.
  prefs: []
  type: TYPE_NORMAL
- en: That concludes the final section on managed threads. Let’s wrap things up and
    review what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the basics of managed threading and the `System.Threading.Thread`
    class. You should now have a good understanding of how to create and schedule
    a thread in .NET. You learned about some of the techniques for passing data to
    threads and how to use background threads for non-critical operations, so they
    don’t prevent your application from terminating. Finally, we used two different
    techniques for canceling threads in .NET.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, [*Chapter 2*](B18552_02_ePub.xhtml#_idTextAnchor034), we
    will learn how .NET has simplified and improved parallel programming and concurrency
    for developers over the last 20 years. Significant improvements were added in
    .NET 4.5 in the form of the `async` and `await` keywords, and .NET Core removed
    some of the legacy threading constructs of .NET Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is a managed thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you make a background thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens if you try to set the `IsBackground` property of a running thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How does .NET handle scheduling managed threads?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the highest thread priority?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What happens to a thread when you call `Thread.Abort()` in .NET 6?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can you pass data to a method in a new thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you register a callback to be invoked when a cancellation is requested
    on a thread?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
