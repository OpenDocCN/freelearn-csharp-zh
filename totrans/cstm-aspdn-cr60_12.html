<html><head></head><body>
		<div id="_idContainer052">
			<h1 id="_idParaDest-98"><em class="italic"><a id="_idTextAnchor172"/>Chapter 12</em>: Content Negotiation Using a Custom OutputFormatter</h1>
			<p>In this chapter, we are going to learn about how to send your data to the client in different formats and types. By default, the ASP.NET Core web API sends data as JSON, but there are some more ways to distribute data.</p>
			<p>We'll cover the following sections in this chapter:</p>
			<ul>
				<li>Introducing <strong class="source-inline">OutputFormatter</strong> objects </li>
				<li>Creating custom <strong class="source-inline">Outputformatter</strong> objects </li>
			</ul>
			<p>The topics in this chapter relate to the WebAPI layer of the ASP.NET Core architecture:</p>
			<div>
				<div id="_idContainer047" class="IMG---Figure">
					<img src="image/Figure_12.1_B17996.jpg" alt="Figure 12.1 – The ASP.NET Core architecture"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.1 – The ASP.NET Core architecture</p>
			<h1 id="_idParaDest-99"><a id="_idTextAnchor173"/>Technical requirements</h1>
			<p>To follow the examples in this chapter, you will need to create an ASP.NET Core MVC application. To do this, open your console, shell, or Bash terminal, and change to your working directory. Then, use the following command to create a new MVC application:</p>
			<p class="source-code">dotnet new webapi -n OutputFormatterSample -o OutputFormatterSample</p>
			<p>Now, open the project in Visual Studio by double-clicking the project file, or in Visual Studio Code by typing the following command in the already-open console:</p>
			<p class="source-code">cd OutputFormatterSample</p>
			<p class="source-code">code .</p>
			<p>All of the code samples in this chapter can be found in the <strong class="bold">GitHub</strong> repository for this book at <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter12">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/tree/main/Chapter12</a>.</p>
			<h1 id="_idParaDest-100">I<a id="_idTextAnchor174"/><a id="_idTextAnchor175"/>ntroducing OutputFormatter objects</h1>
			<p>In ASP.NET Core, <strong class="source-inline">OutputFormatters</strong> are classes that transform your existing data into different formats to send it<a id="_idIndexMarker174"/> through HTTP to clients. The web API uses a default <strong class="source-inline">OutputFormatters</strong> to turn objects into JSON, which is the default format to send structured data. Other built-in formatters include an XML formatter and a plain text formatter.</p>
			<p>With so-called <em class="italic">content negotiation</em>, clients are able to decide which format they want to retrieve. The client needs to specify the content type of the format in the <strong class="source-inline">Accept</strong> header. Content negotiation is implemented in <strong class="source-inline">ObjectResult</strong>.</p>
			<p>By default, the web API always returns JSON, even if you accept text/XML in the header. This is why the built-in XML formatter is not registered by default.</p>
			<p>There are two ways to add <strong class="source-inline">XmlSerializerOutputFormatter</strong> to <a id="_idIndexMarker175"/>ASP.NET Core: </p>
			<ul>
				<li>The first is shown in the following code snippet:<p class="source-code">builder.Services.AddControllers()</p><p class="source-code">    .AddXmlSerializerFormatters();</p></li>
				<li>Or, alternatively, you can use the following:<p class="source-code">builder.Services.AddControllers()</p><p class="source-code">    .AddMvcOptions(options =&gt;</p><p class="source-code">    {</p><p class="source-code">        options.OutputFormatters.Add(</p><p class="source-code">            new XmlSerializerOutputFormatter());</p><p class="source-code">    });</p></li>
			</ul>
			<p>You might need to add the <strong class="source-inline">Microsoft.AspNetCore.Mvc.Formatters</strong> namespace to the <strong class="source-inline">using</strong> statements.</p>
			<p>There is also a formatter called <strong class="source-inline">XmlDataContractSerializerOutputFormatter</strong> available, which uses <strong class="source-inline">DataContractSerializer</strong> internally and is more flexible in its configurations.</p>
			<p>By default, any <strong class="source-inline">Accept</strong> header will automatically be turned into <strong class="source-inline">application/json</strong>, even if you use one of these methods. However, we can fix that.</p>
			<p>If you want to allow the <a id="_idIndexMarker176"/>clients to accept different headers, you need to switch that translation off:</p>
			<p class="source-code">builder.Services.AddControllers()</p>
			<p class="source-code">    .AddMvcOptions(options =&gt;</p>
			<p class="source-code">    {</p>
			<p class="source-code">        options.RespectBrowserAcceptHeader = true; </p>
			<p class="source-code">          // false by default</p>
			<p class="source-code">    });</p>
			<p>Some third-party components that don't completely support ASP.NET Core 5.0 or later won't write asynchronously to the response stream, but the default configuration since ASP.NET Core 3.0 <em class="italic">only</em> allows asynchronous writing. </p>
			<p>To enable synchronous writing access, you will need to add these lines to the <strong class="source-inline">ConfigureServices</strong> method:</p>
			<p class="source-code">builder.Services.Configure&lt;KestrelServerOptions&gt;(options =&gt;</p>
			<p class="source-code">{</p>
			<p class="source-code">    options.AllowSynchronousIO = true;</p>
			<p class="source-code">});</p>
			<p>Add the <strong class="source-inline">Microsoft.AspNetCore.Server.Kestrel.Core</strong> namespace to the <strong class="source-inline">using</strong> statements to get access to the options.</p>
			<p>To try the formatters, let's set up a small test project<a id="_idTextAnchor176"/><a id="_idTextAnchor177"/>.</p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor178"/>Preparing a test project</h2>
			<p>Using the console, we <a id="_idIndexMarker177"/>will create a small ASP.NET Core web API project, using the command shown previously in the <em class="italic">Technical requirements</em> section:</p>
			<ol>
				<li>First, execute the following commands to add the necessary <strong class="bold">NuGet</strong> packages:<p class="source-code"><strong class="bold">dotnet add package GenFu</strong></p><p class="source-code"><strong class="bold">dotnet add package CsvHelper</strong></p><p>This creates a new web API project and adds two NuGet packages to it: <strong class="source-inline">GenFu</strong> is an awesome library to easily create test data, and the second package, <strong class="source-inline">CsvHelper</strong>, helps us to easily write CSV data.</p></li>
				<li>Now, open the project in Visual Studio or in VS Code and create a new API controller called <strong class="source-inline">PersonsController</strong> in the <strong class="source-inline">controller</strong> folder:<p class="source-code">[Route("api/[controller]")]</p><p class="source-code">[ApiController]</p><p class="source-code">public class PersonsController : ControllerBase</p><p class="source-code">{</p><p class="source-code">}</p></li>
				<li>Open <strong class="source-inline">PersonsController.cs</strong> and add a <strong class="source-inline">Get()</strong> method like this:<p class="source-code">[HttpGet]</p><p class="source-code">public ActionResult&lt;IEnumerable&lt;Person&gt;&gt; Get()</p><p class="source-code">{</p><p class="source-code">    var persons = A.ListOf&lt;Person&gt;(25);</p><p class="source-code">    return persons;</p><p class="source-code">}</p><p>You might need to add the following <strong class="source-inline">using</strong> statements at the beginning of the file:</p><p class="source-code">using GenFu;</p><p class="source-code">using Microsoft.AspNetCore.Mvc;</p><p class="source-code">using OutputFormatterSample.Models;</p><p>This creates a list of 25 persons by using <strong class="source-inline">GenFu</strong>. The properties will automatically be filled with realistic data. <strong class="source-inline">GenFu</strong> is an open source, fast, lightweight, and extendable test data generator. It contains built-in lists of names, cities, countries, phone numbers, and so on, and it fills the data automatically into the right properties of a class, depending on the property names. For example, a property called <strong class="source-inline">City</strong> will be filled with the name of a city, and a<a id="_idIndexMarker178"/> property called <strong class="source-inline">Phone</strong>, <strong class="source-inline">Telephone</strong>, or <strong class="source-inline">Phonenumber</strong> will be filled with a well-formatted fake phone number. You'll see the magic of <strong class="source-inline">GenFu</strong> and the results later on.</p></li>
				<li>Now, create a <strong class="source-inline">Models</strong> folder, and create a new file called <strong class="source-inline">Person.cs</strong> with the <strong class="source-inline">Person</strong> class inside:<p class="source-code">public class Person</p><p class="source-code">{</p><p class="source-code">    public int Id { get; set; }</p><p class="source-code">    public string? FirstName { get; set; }</p><p class="source-code">    public string? LastName { get; set; }</p><p class="source-code">    public int Age { get; set; }</p><p class="source-code">    public string? EmailAddress { get; set; }</p><p class="source-code">    public string? Address { get; set; }</p><p class="source-code">    public string? City { get; set; }</p><p class="source-code">    public string? Phone { get; set; }</p><p class="source-code">}</p></li>
				<li>Open <strong class="source-inline">Program.cs</strong> as well, add the XML formatters, and allow other <strong class="source-inline">AcceptHeader</strong>, as described earlier:<p class="source-code">builder.Services.AddControllers()</p><p class="source-code">    .AddMvcOptions(options =&gt;</p><p class="source-code">    {</p><p class="source-code">        options.RespectBrowserAcceptHeader = true; </p><p class="source-code">          // false by default</p><p class="source-code">        options.OutputFormatters.Add(</p><p class="source-code">            new XmlSerializerOutputFormatter());</p><p class="source-code">    });</p><p>That's it <a id="_idIndexMarker179"/>for now. Now, you are able to retrieve the data from the web API.</p></li>
				<li>Start the project by using the <strong class="source-inline">dotnet run</strong> command.</li>
			</ol>
			<p>Next, we'll test the API.</p>
			<h1 id="_idParaDest-102"><a id="_idTextAnchor179"/>Testing the web API</h1>
			<p>The best tools <a id="_idIndexMarker180"/>to test a <a id="_idIndexMarker181"/>web API <a id="_idIndexMarker182"/>are <strong class="bold">Fiddler</strong> (<a href="https://www.telerik.com/fiddler">https://www.telerik.com/fiddler</a>) or <strong class="bold">Postman</strong> (<a href="https://www.postman.com/">https://www.postman.com/</a>). I prefer Postman because I find it easier to use. You can use either tool, but in these demos, we will use P<a id="_idTextAnchor180"/>ostman:</p>
			<ol>
				<li value="1">In Postman, create a new request. Enter the API URL, which is <a href="https://localhost:5001/api/persons">https://localhost:5001/api/persons</a> (the port of the URL might vary), into the <strong class="source-inline">address</strong> field, and then, add a header with the <strong class="source-inline">Accept</strong> key and the <strong class="source-inline">application/json</strong> value.</li>
				<li>After<a id="_idIndexMarker183"/> clicking <strong class="bold">Send</strong>, you will see the JSON result in the response body, as shown in the following screenshot:<div id="_idContainer048" class="IMG---Figure"><img src="image/Figure_12.2_B17996.jpg" alt="Figure 12.2 – A screenshot of JSON output in Postman&#13;&#10;"/></div><p class="figure-caption">Figure 12.2 – A screenshot of JSON output in Postman</p><p>Here, you can see the autogenerated values. The <strong class="source-inline">GenFu</strong> object puts the data into the person's properties, based on the property type and the property name: real first names and real last names, as well as real cities and properly formatted phone numbers.</p></li>
				<li>Next, let's<a id="_idIndexMarker184"/> test the XML output formatter. In Postman, change the <strong class="source-inline">Accept</strong> header from <strong class="source-inline">application/json</strong> to <strong class="source-inline">text/xml</strong> and click <strong class="bold">Send</strong>:</li>
			</ol>
			<div>
				<div id="_idContainer049" class="IMG---Figure">
					<img src="image/Figure_12.3_B17996.jpg" alt="Figure 12.3 – A screenshot of XML output in Postman&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.3 – A screenshot of XML output in Postman</p>
			<p>We now have an XML-formatted output. Now, let's go a step further and create some custom <strong class="source-inline">OutputFormatter</strong> o<a id="_idTextAnchor181"/><a id="_idTextAnchor182"/>bjects.</p>
			<h1 id="_idParaDest-103"><a id="_idTextAnchor183"/>Creating custom OutputFormatter objects</h1>
			<p>In this <a id="_idIndexMarker185"/>example, our aim is to create a <strong class="bold">VCard</strong> output to be able to import the person's contact details directly into <strong class="bold">Microsoft</strong> <strong class="bold">Outlook</strong> or any other contact database that supports VCards. Later in this section, we also want to create a CSV output formatter.</p>
			<p>Both are text-based output formatters, and they will derive their values from <strong class="source-inline">TextOutputFormatter</strong>. Let's look at the steps to create the VCard output:</p>
			<ol>
				<li value="1">Create a new class in a new file called <strong class="source-inline">VcardOutputFormatter.cs</strong>.</li>
				<li>Now, insert the following class skeleton in the new file. You will find the implementations of the empty methods in the following code snippets. The constructor contains the supported media types and content encodings:<p class="source-code">public class VcardOutputFormatter : TextOutputFormatter</p><p class="source-code">{</p><p class="source-code">    public string? ContentType { get; }</p><p class="source-code">    public VcardOutputFormatter()</p><p class="source-code">    {</p><p class="source-code">        SupportedMediaTypes.Add(</p><p class="source-code">            MediaTypeHeaderValue.Parse("text/vcard"));</p><p class="source-code">        SupportedEncodings.Add(Encoding.UTF8);</p><p class="source-code">        SupportedEncodings.Add(Encoding.Unicode);</p><p class="source-code">    }</p><p class="source-code">    protected override bool CanWriteType(Type type)</p><p class="source-code">    {</p><p class="source-code">    }</p><p class="source-code">    public override Task WriteResponseBodyAsync(</p><p class="source-code">        OutputFormatterWriteContext context,</p><p class="source-code">         Encoding selectedEncoding)</p><p class="source-code">    {</p><p class="source-code">    }</p><p class="source-code">    private static void FormatVcard(</p><p class="source-code">        StringBuilder buffer, </p><p class="source-code">        Person person, </p><p class="source-code">        ILogger logger)</p><p class="source-code">    {</p><p class="source-code">    }</p><p class="source-code">}</p><p>You might <a id="_idIndexMarker186"/>need to add the following <strong class="source-inline">using</strong> statements:</p><p class="source-code">using Microsoft.AspNetCore.Mvc.Formatters;</p><p class="source-code">using System.Text;</p><p class="source-code">using Microsoft.Extensions.Logging;</p><p class="source-code">using Microsoft.Net.Http.Headers;</p><p class="source-code">using OutputFormatterSample.Models;</p></li>
				<li>The next code snippet shows the implementation of the <strong class="source-inline">CanWriteType</strong> method. It is optional to override this method, but it makes sense to restrict it to a specific condition. In this case, the <strong class="source-inline">OutputFormatter</strong> can only format objects of the <strong class="source-inline">Person</strong> type:<p class="source-code">protected override bool CanWriteType(Type type)</p><p class="source-code">{</p><p class="source-code">    if (typeof(Person).IsAssignableFrom(type)</p><p class="source-code">        || typeof(IEnumerable&lt;Person&gt;)</p><p class="source-code">            .IsAssignableFrom(type))</p><p class="source-code">    {</p><p class="source-code">        return base.CanWriteType(type);</p><p class="source-code">    }</p><p class="source-code">    return false;</p><p class="source-code">}</p></li>
				<li>You need to<a id="_idIndexMarker187"/> override <strong class="source-inline">WriteResponseBodyAsync</strong> to convert the actual <strong class="source-inline">Person</strong> objects into the output you want to have. To get the objects to convert, you need to extract them from <strong class="source-inline">OutputFormatterWriteContext</strong> object that gets passed into the method. You also get the HTTP response from this context. This is needed to write the results and send them to the client. </li>
				<li>Inside the method, we check whether we get one person or a list of persons and call the not yet implemented <strong class="source-inline">FormatVcard</strong> method:<p class="source-code">public override Task WriteResponseBodyAsync(</p><p class="source-code">    OutputFormatterWriteContext context,</p><p class="source-code">    Encoding selectedEncoding)</p><p class="source-code">{</p><p class="source-code">    var serviceProvider = </p><p class="source-code">      context.HttpContext.RequestServices;</p><p class="source-code">    var logger = serviceProvider.GetService(</p><p class="source-code">        typeof(ILogger&lt;VcardOutputFormatter&gt;)) as </p><p class="source-code">          ILogger;</p><p class="source-code">    var response = context.HttpContext.Response;</p><p class="source-code">    var buffer = new StringBuilder();</p><p class="source-code">    if (context.Object is IEnumerable&lt;Person&gt;)</p><p class="source-code">    {</p><p class="source-code">        foreach (var person in context.Object as </p><p class="source-code">          IEnumerable&lt;Person&gt;)</p><p class="source-code">        {</p><p class="source-code">            FormatVcard(buffer, person, logger);</p><p class="source-code">        }</p><p class="source-code">    }</p><p class="source-code">    else</p><p class="source-code">    {</p><p class="source-code">        var person = context.Object as Person;</p><p class="source-code">        FormatVcard(buffer, person, logger);</p><p class="source-code">    }</p><p class="source-code">    return response.WriteAsync(buffer.ToString());</p><p class="source-code">}</p></li>
				<li>To format<a id="_idIndexMarker188"/> the output to support standard <strong class="source-inline">Vcard</strong>, you need to do some manual work:<p class="source-code">private static void FormatVcard(</p><p class="source-code">    StringBuilder buffer, </p><p class="source-code">    Person person, </p><p class="source-code">    ILogger logger)</p><p class="source-code">{</p><p class="source-code">    buffer.AppendLine("BEGIN:VCARD");</p><p class="source-code">    buffer.AppendLine("VERSION:2.1");</p><p class="source-code">    buffer.AppendLine(</p><p class="source-code">        $"FN:{person.FirstName} {person.LastName}");</p><p class="source-code">    buffer.AppendLine(</p><p class="source-code">        $"N:{person.LastName};{person.FirstName}");</p><p class="source-code">    buffer.AppendLine(</p><p class="source-code">        $"EMAIL:{person.EmailAddress}");</p><p class="source-code">    buffer.AppendLine(</p><p class="source-code">        $"TEL;TYPE=VOICE,HOME:{person.Phone}");</p><p class="source-code">    buffer.AppendLine(</p><p class="source-code">         $"ADR;TYPE=home:;;{person.Address};</p><p class="source-code">             {person.City}");</p><p class="source-code">    buffer.AppendLine($"UID:{person.Id}");</p><p class="source-code">    buffer.AppendLine("END:VCARD");</p><p class="source-code">    logger.LogInformation(</p><p class="source-code">        $"Writing {person.FirstName}  </p><p class="source-code">          {person.LastName}");</p><p class="source-code">}</p></li>
				<li>Then, we<a id="_idIndexMarker189"/> need to register the new <strong class="source-inline">VcardOutputFormatter</strong> object in <strong class="source-inline">Program.cs</strong>:<p class="source-code">builder.Services.AddControllers()</p><p class="source-code">    .AddMvcOptions(options =&gt;</p><p class="source-code">    {</p><p class="source-code">        options.RespectBrowserAcceptHeader = true; </p><p class="source-code">          // false by default</p><p class="source-code">        options.OutputFormatters.Add(</p><p class="source-code">            new XmlSerializerOutputFormatter());</p><p class="source-code">        // register the VcardOutputFormatter</p><p class="source-code">        options.OutputFormatters.Add(</p><p class="source-code">            new VcardOutputFormatter());</p><p class="source-code">    });</p><p>You might need to add a <strong class="source-inline">using</strong> statement to <strong class="source-inline">OutputFormatterSample</strong>.</p></li>
				<li>Start the <a id="_idIndexMarker190"/>app again using <strong class="source-inline">dotnet run</strong>.</li>
				<li>Now, change the <strong class="source-inline">Accept</strong> header to <strong class="source-inline">text/vcard</strong>, and let's see what happens:<div id="_idContainer050" class="IMG---Figure"><img src="image/Figure_12.4_B17996.jpg" alt="Figure 12.4 – A screenshot of VCard output in Postman&#13;&#10;"/></div><p class="figure-caption">Figure 12.4 – A screenshot of VCard output in Postman</p><p>We now should see all of our data in <strong class="source-inline">VCard</strong> format.</p></li>
				<li>Now, let's do <a id="_idIndexMarker191"/>the same for a CSV output. We already added the <strong class="source-inline">CsvHelper</strong> library to the project. So, go to the following URL and download <strong class="source-inline">CsvOutputFormatter</strong> to put it into your project: <a href="https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter12/OutputFormatterSample6.0/CsvOutputFormatter.cs">https://github.com/PacktPublishing/Customizing-ASP.NET-Core-6.0-Second-Edition/blob/main/Chapter12/OutputFormatterSample6.0/CsvOutputFormatter.cs</a></li>
				<li>Let's have a quick look at the <strong class="source-inline">WriteResponseBodyAsync</strong> method:<p class="source-code">public override async Task WriteResponseBodyAsync(</p><p class="source-code">    OutputFormatterWriteContext context,</p><p class="source-code">    Encoding selectedEncoding)</p><p class="source-code">{</p><p class="source-code">    var response = context.HttpContext.Response;</p><p class="source-code">    var csv = new CsvWriter(</p><p class="source-code">        new StreamWriter(response.Body),</p><p class="source-code">        CultureInfo.InvariantCulture);</p><p class="source-code">    IEnumerable&lt;Person&gt; persons;</p><p class="source-code">    if (context.Object is IEnumerable&lt;Person&gt;)</p><p class="source-code">    {</p><p class="source-code">        persons = context.Object as </p><p class="source-code">          IEnumerable&lt;Person&gt;;</p><p class="source-code">    }</p><p class="source-code">    else</p><p class="source-code">    {</p><p class="source-code">        var person = context.Object as Person;</p><p class="source-code">        persons = new List&lt;Person&gt; { person };</p><p class="source-code">    }</p><p class="source-code">    await csv.WriteRecordsAsync(persons);</p><p class="source-code">}</p></li>
				<li>This almost <a id="_idIndexMarker192"/>works the same way as <strong class="source-inline">VcardOutputFormatter</strong>. We can pass the response stream via <strong class="source-inline">StreamWriter</strong> directly into <strong class="source-inline">CsvWriter</strong>. After that, we are able to feed the persons or the list of persons to the writer. That's it.</li>
				<li>We also need to register <strong class="source-inline">CsvOutputFormatter</strong> before we can test it:<p class="source-code">builder.Services.AddControllers()</p><p class="source-code">    .AddMvcOptions(options =&gt;</p><p class="source-code">    {</p><p class="source-code">        options.RespectBrowserAcceptHeader = true; </p><p class="source-code">           // false by default</p><p class="source-code">        options.OutputFormatters.Add(</p><p class="source-code">            new XmlSerializerOutputFormatter());</p><p class="source-code">        // register the VcardOutputFormatter</p><p class="source-code">        options.OutputFormatters.Add(</p><p class="source-code">            new VcardOutputFormatter());</p><p class="source-code">        // register the CsvOutputFormatter</p><p class="source-code">        options.OutputFormatters.Add(</p><p class="source-code">            new CsvOutputFormatter());</p><p class="source-code">    });</p></li>
				<li>In Postman, change<a id="_idIndexMarker193"/> the <strong class="source-inline">Accept</strong> header to <strong class="source-inline">text/csv</strong> and click <strong class="bold">Send</strong> again:</li>
			</ol>
			<div>
				<div id="_idContainer051" class="IMG---Figure">
					<img src="image/Figure_12.5_B17996.jpg" alt="Figure 12.5 – A screenshot of text/CSV output in Postman&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 12.5 – A screenshot of text/CSV output in Postman</p>
			<p>There we go – Postman was able to open all of the form<a id="_idTextAnchor184"/>ats we tested.</p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor185"/>Summary</h1>
			<p>Isn't that cool? The ability to change the format based on the <strong class="source-inline">Accept</strong> header is very handy. This way, you are able to create a web API for many different clients – an API that accepts many different formats, depending on the clients' preferences. There are still many potential clients out there that don't use JSON and prefer XML or CSV.</p>
			<p>The other way around would be an option to consume CSV or any other format inside the web API. For example, let's assume your client sends you a list of people in CSV format. How would you solve this? Parsing the string manually in the <strong class="source-inline">action</strong> method would work, but it's not an easy option.</p>
			<p>This is what <strong class="source-inline">ModelBinder</strong> objects can do for us. Let's see how they work in the next chapter.</p>
		</div>
	</body></html>