- en: Chapter 11. Improving Games with Extra Features and Optimization
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第11章.通过额外功能和优化改进游戏
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Pausing the game
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 暂停游戏
- en: Implementing slow motion
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现慢动作
- en: Preventing your game from running on unknown servers
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 防止你的游戏在未知服务器上运行
- en: State-driven behavior Do-It-Yourself states
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 状态驱动行为 Do-It-Yourself状态
- en: State-driven behavior using the State Design pattern
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用状态设计模式实现状态驱动行为
- en: Reducing the number of objects by destroying objects at a death time
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在死亡时间销毁对象来减少对象数量
- en: Reducing the number of enabled objects by disabling objects whenever possible
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过尽可能禁用对象来减少启用对象的数量
- en: Reducing the number of active objects by making objects inactive whenever possible
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过尽可能使对象无效来减少活动对象的数量
- en: Improving efficiency with delegates and events and avoiding SendMessage!
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过使用委托和事件以及避免SendMessage!来提高效率
- en: Executing methods regularly but independent of frame rate with coroutines
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协程定期执行方法，但与帧率无关
- en: Spreading long computations over several frames with coroutines
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用协程将长时间计算分散到几个帧上
- en: Evaluating performance by measuring max and min frame rates (FPS)
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过测量最大和最小帧率（FPS）来评估性能
- en: Identifying performance bottlenecks with the Unity performance Profiler
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Unity性能分析器识别性能瓶颈
- en: Identifying performance bottlenecks with Do-It-Yourself performance profiling
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用Do-It-Yourself性能分析识别性能瓶颈
- en: Cache GameObject and component references to avoid expensive lookups
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 缓存GameObject和组件引用以避免昂贵的查找
- en: Improving performance with LOD groups
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用LOD组提高性能
- en: Improving performance through reduced draw calls by designing for draw call
    batching
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过设计批处理绘制调用以减少绘制调用次数来提高性能
- en: Introduction
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: The first three recipes in this chapter provide some ideas for adding some extra
    features to your game (pausing, slow motion, and securing online games). The next
    two recipes then present ways to manage complexity in your games through managing
    states and their transitions.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 本章前三个食谱提供了一些为你的游戏添加额外功能（暂停、慢动作和确保在线游戏安全）的想法。接下来的两个食谱然后展示了通过管理状态及其转换来管理游戏复杂性的方法。
- en: The rest of the recipes in this chapter provide examples of how to investigate
    and improve the efficiency and performance of your game. Each of these optimization
    recipes begins by stating an optimization principle that it embodies.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 本章剩余的食谱提供了如何调查和改进游戏效率和性能的示例。每个优化食谱都首先陈述一个它所体现的优化原则。
- en: The big picture
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 整体情况
- en: Before getting on with the recipes, let's step back and think about the different
    parts of Unity games and how their construction and runtime behavior can impact
    on game performance.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续食谱之前，让我们退后一步，思考Unity游戏的不同部分以及它们的构建和运行时行为如何影响游戏性能。
- en: 'Games are made up of several different kinds of components:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏由几种不同类型的组件组成：
- en: Audio assets
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频资源
- en: 2D and 3D graphical assets
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D和3D图形资源
- en: Text and other file assets
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 文本和其他文件资源
- en: Scripts
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本
- en: 'When a game is running, there are many competing processing requirements for
    your CPU and GPU, including:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏运行时，CPU和GPU有许多相互竞争的处理需求，包括：
- en: Audio processing
  id: totrans-30
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 音频处理
- en: Script processing
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 脚本处理
- en: 2D physics processing
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 2D物理处理
- en: 3D physics processing
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D物理处理
- en: Graphical rendering
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 图形渲染
- en: GPU processing
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: GPU处理
- en: One way to reduce the complexity of graphical computations and to improve frame
    rates is to use simpler models whenever possible—this is the reduction of the
    **Level Of Detail** (**LOD**). The general strategy is to identify situations
    where a simpler model will not degrade the user's experience. Typically, situations
    include where a model is only taking up a small part of the screen (so less detail
    in the model will not change what the user sees), when objects are moving very
    fast across the screen (so the user is unlikely to have time to notice less detail),
    or where we are sure the users' visual focus is elsewhere (for example, in a car
    racing game, the user is not looking at the quality of the trees but on the road
    ahead). We provide a LOD recipe, *Improving performance with LOD groups*, in this
    chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 减少图形计算复杂度并提高帧率的办法之一是在可能的情况下使用更简单的模型——这就是**细节级别**（**LOD**）的降低。一般策略是识别那些使用更简单模型不会降低用户体验的情况。通常，这些情况包括模型只占据屏幕的一小部分（因此模型中的细节较少不会改变用户所看到的内容），当物体在屏幕上快速移动时（因此用户不太可能有时间注意到细节较少），或者我们确信用户的视觉焦点在其他地方（例如，在赛车游戏中，用户不会关注树木的质量，而是关注前方的道路）。我们在本章中提供了一个LOD食谱，*使用LOD组提高性能*。
- en: Unity's draw call batching may actually be *more efficient* than you or your
    team's 3D modelers are at reducing the triangle/vertex geometry. So, it may be
    that by manually simplifying a 3D model, you have removed Unity's opportunity
    to apply its highly effective vertex reduction algorithms; then, the geometric
    complexity may be larger for a small model than for a larger model, and so a smaller
    model may lead to a lower game performance! One recipe presents advice collected
    from several sources and the location of tools to assist in different strategies
    to try to reduce draw calls and improve graphical performance.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: Unity的绘制调用批处理可能实际上比您或您的团队的三维建模师在减少三角形/顶点几何形状方面更有效率。因此，可能的情况是，通过手动简化三维模型，您已经移除了Unity应用其高度有效的顶点减少算法的机会；然后，对于小模型，几何复杂性可能比大模型更大，因此小模型可能导致游戏性能降低！一个食谱提供了从多个来源收集的建议和辅助不同策略的工具位置，以尝试减少绘制调用并提高图形性能。
- en: We will present several recipes allowing you to analyze actual processing times
    and frame rates, so that you can collect data to confirm whether your design decisions
    are having the desired efficiency improvements.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将介绍几个食谱，让您能够分析实际的处理时间和帧率，以便您可以收集数据以确认您的设计决策是否带来了预期的效率提升。
- en: '|   | *"You have a limited CPU budget and you have to live with it"* |   |'
  id: totrans-39
  prefs: []
  type: TYPE_TB
  zh: '|   | *"你的CPU预算有限，你必须接受这一点"* |   |'
- en: '|   | --*Joachim Ante, Unite-07* |'
  id: totrans-40
  prefs: []
  type: TYPE_TB
  zh: '|   | --*约阿希姆·安特，Unite-07* |'
- en: At the end of the day, the best *balance* of heuristic strategies for your particular
    game project can only be discovered by an investment of time and hard work, and
    some form of profiling investigation. Certain strategies (such as caching to reduce
    component reflection lookups) should perhaps be standard practice in all projects,
    while other strategies may require *tweaking* for each unique game and level,
    to find which approaches work effectively to improve efficiency, frame rates,
    and, most importantly, the user experience when playing the game.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您特定的游戏项目的最佳启发式策略平衡只能通过投入时间和辛勤工作，以及某种形式的性能分析调查来发现。某些策略（如缓存以减少组件反射查找）可能应该是所有项目的标准做法，而其他策略可能需要针对每个独特的游戏和级别进行调整，以找到哪些方法有效地提高了效率、帧率和，最重要的是，游戏时的用户体验。
- en: '*"Premature Optimization is the root of all evil"*'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"过早优化是万恶之源"*'
- en: ''
  id: totrans-43
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: '*Donald Knuth, "Structured Programming With Go To Statements". Computing Surveys,
    Vol 6, No 4, December 1974*'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*唐纳德·克努特，《使用goto语句的结构化编程》。计算机调查，第6卷，第4期，1974年12月*'
- en: Perhaps, the core strategy to take away from this chapter is that there are
    many parts of a game that are candidates for possible optimization, and you should
    drive the actual optimizations you finally implement for a particular game based
    on the evidence you gain by profiling its performance.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 也许，从本章中可以吸取的核心策略是，游戏中的许多部分都是可能的优化候选者，您应该根据对特定游戏性能的分析所获得的数据来驱动您最终实施的优化。
- en: Pausing the game
  id: totrans-46
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 暂停游戏
- en: As compelling as your next game will be, you should always let players pause
    it for a short break. In this recipe, we will implement a simple and effective
    pause screen including controls for changing the display's quality settings.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管你的下一款游戏将非常吸引人，但你应该始终允许玩家短暂暂停游戏。在这个菜谱中，我们将实现一个简单而有效的暂停屏幕，包括用于更改显示质量设置的控件。
- en: Getting ready
  id: totrans-48
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a package named `BallGame` containing a playable
    scene. The package is in the `1362_11_01` folder.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们准备了一个名为`BallGame`的包，其中包含一个可玩场景。该包位于`1362_11_01`文件夹中。
- en: How to do it...
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To pause your game upon pressing the *Esc* key, follow these steps:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 要在按下*Esc*键时暂停游戏，请按照以下步骤操作：
- en: Import the `BallGame` package into your project and, from the **Project** view,
    open the level named `BallGame_01`.
  id: totrans-52
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BallGame`包导入到你的项目中，并从**项目**视图打开名为`BallGame_01`的关卡。
- en: In the **Inspector**, create a new tag **Ball**, apply this tag to prefab `ball`
    in `Prefabs` folder, and save the scene.
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，创建一个新的标签**球**，将此标签应用到“预制体”文件夹中的`ball`预制体上，并保存场景。
- en: From the **Hierarchy** view, use the **Create** drop-down menu to add a **Panel**
    to the UI (**Create** | **UI** | **Panel**). Note that it will automatically add
    it to the current **Canvas** in the scene. Rename the panel `QualityPanel`.
  id: totrans-54
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图，使用**创建**下拉菜单向UI添加一个**面板**（**创建** | **UI** | **面板**）。注意，它将自动将其添加到场景中的当前**Canvas**。将面板重命名为`QualityPanel`。
- en: Now use the **Create** drop-down menu to add a **Slider** to the UI (**Create**
    | **UI** | **Slider**). Rename it `QualitySlider`.
  id: totrans-55
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在使用**创建**下拉菜单向UI添加一个**滑动条**（**创建** | **UI** | **滑动条**）。将其重命名为`QualitySlider`。
- en: Finally, use the **Create** drop-down menu to add a **Text** to the UI (**Create**
    | **UI** | **Text**). Rename it `QualityLabel`. Also, from the **Inspector** view,
    **Rect Transform**, change its **Pos Y** to **-25**.
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，使用**创建**下拉菜单向UI添加一个**文本**（**创建** | **UI** | **文本**）。将其重命名为`QualityLabel`。此外，从**检查器**视图中的**Rect
    Transform**，将**Pos Y**更改为**-25**。
- en: 'Add the following C# script **PauseGame** to **First Person Controller**:'
  id: totrans-57
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本**PauseGame**添加到**第一人称控制器**：
- en: '[PRE0]'
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: From the **Hierarchy** view, select the **First Person Controller**. Then, from
    the **Inspector**, access the **Pause Game** component and populate the **QPanel**,
    **QSlider**, and **QLabel** fields with the game objects **QualityPanel**, **QualitySlider**,
    and **QualityLabel** respectively, as shown in the following screenshot:![How
    to do it...](img/1362OT_11_01.jpg)
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图中选择**第一人称控制器**。然后，从**检查器**中访问**暂停游戏**组件，并将游戏对象**QualityPanel**、**QualitySlider**和**QualityLabel**分别填充到**QPanel**、**QSlider**和**QLabel**字段中，如图所示：![如何操作...](img/1362OT_11_01.jpg)
- en: From the **Hierarchy** view, select **QualitySlider**. Then, from the **Inspector**
    view, **Slider** component, find the list named **On Value Changed (Single)**,
    and click on the **+** sign to add a command.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图中选择**QualitySlider**。然后，从**检查器**视图中的**滑动条**组件，找到名为**On Value Changed
    (Single)**的列表，并点击**+**符号添加一个命令。
- en: Drag the **First Person Controller** from the **Hierarchy** view into the game
    object field of the new command. Then, use the function selector to find the **SetQuality**
    function under **Dynamic float** (**No Function** | **PauseGame** | **Dynamic
    float** | **SetQuality**), as shown in the following screenshot:![How to do it...](img/1362OT_11_02.jpg)
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**第一人称控制器**从**层次结构**视图拖动到新命令的游戏对象字段中。然后，使用函数选择器在**Dynamic float**下的**SetQuality**函数（**无函数**
    | **PauseGame** | **Dynamic float** | **SetQuality**）中找到，如图所示：![如何操作...](img/1362OT_11_02.jpg)
- en: When you play the scene, you should be able to pause/resume the game by pressing
    the *Esc* key, also activating a slider that controls the game's quality settings.![How
    to do it...](img/1362OT_11_03.jpg)
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当你播放场景时，你应该能够通过按下*Esc*键暂停/恢复游戏，同时激活一个控制游戏质量设置的滑动条。![如何操作...](img/1362OT_11_03.jpg)
- en: How it works...
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Pausing the game is actually an easy, straightforward task in Unity: all we
    need to do is set the game''s **Time Scale** to `0` (and set it back to `1` to
    resume). In our code, we have included such a command within the `SetPause()`
    function, which is called whenever the player presses the *Esc* key, also toggling
    the `isPaused` variable. To make things more functional, we have included a **GUI
    panel** featuring a *QualitySettings* slider that is activated whenever the game
    is paused.'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中暂停游戏实际上是一个简单直接的任务：我们只需要将游戏的时间缩放设置为`0`（并将它设置回`1`以继续）。在我们的代码中，我们已经在`SetPause()`函数中包含了这样的命令，该函数在玩家按下*Esc*键时被调用，同时也切换`isPaused`变量。为了使功能更加完善，我们还包括了一个**GUI面板**，其中包含一个*质量设置*滑块，当游戏暂停时被激活。
- en: '![How it works...](img/1362OT_11_04.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![它如何工作...](img/1362OT_11_04.jpg)'
- en: Regarding the behavior for the QualitySettings slider and text, their parameters
    are adjusted at the start based on the game's variety of quality settings, their
    names, and its current state. Then, changes in the slider's value redefine the
    quality settings, also updating the label text accordingly.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 关于质量设置滑块和文本的行为，它们的参数在游戏开始时根据游戏的各种质量设置、它们的名称及其当前状态进行调整。然后，滑块值的更改重新定义了质量设置，并相应地更新标签文本。
- en: There's more...
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: You can always add more functionality to the *pause* screen by displaying sound
    volume controls, save/load buttons, and so on.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 你总是可以通过显示音量控制、保存/加载按钮等来为*暂停屏幕*添加更多功能。
- en: Learning more about QualitySettings
  id: totrans-69
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 了解更多关于质量设置的信息
- en: Our code for changing quality settings is a slight modification of the example
    given by Unity's documentation. If you want to learn more about the subject, check
    out [http://docs.unity3d.com/ScriptReference/QualitySettings.html](http://docs.unity3d.com/ScriptReference/QualitySettings.html).
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 我们更改质量设置的代码是对Unity文档中给出的示例的轻微修改。如果你想了解更多关于这个主题的信息，请查看[http://docs.unity3d.com/ScriptReference/QualitySettings.html](http://docs.unity3d.com/ScriptReference/QualitySettings.html)。
- en: See also
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Refer to the *Implementing slow motion* recipe in this chapter for more information.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的*实现慢动作*配方以获取更多信息。
- en: Implementing slow motion
  id: totrans-73
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现慢动作
- en: Since Remedy Entertainment's *Max Payne*, slow motion, or bullet time, became
    a popular feature in games. For example, Criterion's *Burnout* series has successfully
    explored the slow motion effect in the racing genre. In this recipe, we will implement
    a slow motion effect triggered by the pressing of the mouse's right button.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 自从Remedy Entertainment的*Max Payne*以来，慢动作或子弹时间成为游戏中的一个流行特性。例如， Criterion的*Burnout*系列成功探索了赛车类别中的慢动作效果。在这个配方中，我们将实现一个通过按下鼠标右键触发的慢动作效果。
- en: Getting ready
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we will use the same package as the previous recipe, `BallGame`
    in the `1362_11_02` folder.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们将使用与上一个配方相同的包，即`1362_11_02`文件夹中的`BallGame`。
- en: How to do it...
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'To implement slow motion, follow these steps:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现慢动作，请按照以下步骤操作：
- en: Import the `BallGame` package into your project and, from the **Project** view,
    open the level named `BallGame_01`.
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`BallGame`包导入到你的项目中，并从**项目**视图打开名为`BallGame_01`的场景。
- en: In the **Inspector**, create a new tag **Ball**, apply this tag to prefab `ball`
    in the `Prefabs` folder, and save the scene.
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中，创建一个新的标签**球**，将此标签应用于“预制体”文件夹中的`ball`预制体，并保存场景。
- en: 'Add the following C# script **BulletTime** to **First Person Controller**:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本**BulletTime**添加到**第一人称控制器**：
- en: '[PRE1]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: From the **Hierarchy** view, use the **Create** drop-down menu to add a **Slider**
    to the UI (**Create** | **UI** | **Slider**). Please note that it will be created
    as a child of the preexisting **Canvas** object. Rename it `EnergySlider`.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图，使用**创建**下拉菜单向UI添加一个**滑块**（**创建** | **UI** | **滑块**）。请注意，它将被创建为现有**画布**对象的子对象。将其重命名为`EnergySlider`。
- en: 'Select **EnergySlider** and, from the **Inspector** view, **Rect Transform**
    component, set its position as follows: **Left: 0**; **Pos Y: 0**; **Pos Z: 0**;
    **Right: 0**; **Height: 50**. Then, expand the **Anchors** settings and change
    it to: **Min X: 0**; **Y: 1**; **Max X: 0.5**; **Y: 1**; **Pivot X: 0**; **Y:
    1**, as shown in the following screenshot:![How to do it...](img/1362OT_11_05.jpg)'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**EnergySlider**，从**检查器**视图中的**矩形变换**组件，设置其位置如下：**左：0**；**Y位置：0**；**Z位置：0**；**右：0**；**高度：50**。然后，展开**锚点**设置，并将其更改为：**最小X：0**；**Y：1**；**最大X：0.5**；**Y：1**；**中心X：0**；**Y：1**，如以下截图所示：![如何做到这一点...](img/1362OT_11_05.jpg)
- en: Also select the **Handle Slide Area** child and disable it from the **Inspector**
    view, as shown in the following screenshot:![How to do it...](img/1362OT_11_06.jpg)
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 还选择**滑块手柄区域**子项，并在**检查器**视图中将其禁用，如图所示：![如何操作...](img/1362OT_11_06.jpg)
- en: Finally, select the **First Person Controller** from the **Hierarchy** view,
    find the **Bullet Time** component, and drag the **EnergySlider** from the **Hierarchy**
    view into its **Energy Bar** slot, as shown in the next screenshot:![How to do
    it...](img/1362OT_11_07.jpg)
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，从**层级**视图中选择**第一人称控制器**，找到**子弹时间**组件，并将**能量滑块**从**层级**视图拖动到其**能量栏**槽中，如图所示：![如何操作...](img/1362OT_11_07.jpg)
- en: Play your game. You should be able to activate slow motion by holding down the
    right mouse button (or whatever alternative you have set for **Input** axis **Fire2**).
    The slider will act as a progress bar that slowly shrinks, indicating the remaining
    *bullet time* you have.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 播放您的游戏。您应该能够通过按住右鼠标按钮（或您为**输入**轴**Fire2**设置的任何替代选项）来激活慢动作。滑块将充当进度条，缓慢缩小，指示您剩余的*子弹时间*。
- en: How it works...
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Basically, all we need to do to have the slow motion effect is decrease the
    `Time.timeScale` variable. In our script, we do that by using the `sloSpeed` variable.
    Please note that we also need to adjust the `Time.fixedDeltaTime` variable, updating
    the physics simulation of our game.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，要实现慢动作效果，我们只需要降低`Time.timeScale`变量。在我们的脚本中，我们通过使用`sloSpeed`变量来实现这一点。请注意，我们还需要调整`Time.fixedDeltaTime`变量，更新我们游戏的物理模拟。
- en: In order to make the experience more challenging, we have also implemented a
    sort of *energy bar* to indicate how much bullet time the player has left (the
    initial value is given, in seconds, by the `totalTime` variable). Whenever the
    player is not using bullet time, he has his quota filled according to the `recoveryRate`
    variable.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使体验更具挑战性，我们还实现了一种**能量栏**，以指示玩家剩余的子弹时间（初始值由`totalTime`变量给出，以秒为单位）。当玩家不使用子弹时间时，他的配额根据`recoveryRate`变量填充。
- en: Regarding the *GUI slider*, we have used the **Rect Transform** settings to
    place it on the top-left corner and set its dimensions to half of the screen's
    width and 50 pixels tall. Also, we have hidden the *handle slide area* to make
    it more similar to a traditional energy bar. Finally, instead of allowing direct
    interaction from the player with the slider, we have used the `BulletTime` script
    to change the slider's value.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**GUI滑块**，我们使用了**矩形变换**设置将其放置在屏幕左上角，并设置其尺寸为屏幕宽度的一半和50像素高。此外，我们还隐藏了**滑块手柄区域**，使其更类似于传统的能量栏。最后，我们不是允许玩家直接与滑块交互，而是使用了`BulletTime`脚本来改变滑块的值。
- en: There's more...
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: Some suggestions for you to improve your slow motion effect even further are
    as follows.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些建议，帮助您进一步提升慢动作效果。
- en: Customizing the slider
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 自定义滑块
- en: 'Don''t forget that you can personalize the slider''s appearance by creating
    your own sprites, or even by changing the slider''s *fill* color based on the
    slider''s value. Try adding the following lines of code to the end of the `Update`
    function:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 不要忘记，您可以通过创建自己的精灵或根据滑块的值更改滑块的**填充**颜色来自定义滑块的外观。尝试将以下代码行添加到`Update`函数的末尾：
- en: '[PRE2]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Adding Motion Blur
  id: totrans-97
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加运动模糊
- en: '**Motion Blur** is an image effect frequently identified with slow motion.
    Once attached to the camera, it could be enabled or disabled depending on the
    `speed` float value. For more information on the Motion Blur image effect, refer
    to [http://docs.unity3d.com/Manual/script-MotionBlur.html](http://docs.unity3d.com/Manual/script-MotionBlur.html).'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '**运动模糊**是一种常与慢动作相关的图像效果。一旦附加到相机，它可以根据`speed`浮点值启用或禁用。有关运动模糊图像效果的更多信息，请参阅[http://docs.unity3d.com/Manual/script-MotionBlur.html](http://docs.unity3d.com/Manual/script-MotionBlur.html)。'
- en: Creating sonic ambience
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建音效氛围
- en: '*Max Payne* famously used a strong, heavy heartbeat sound as sonic ambience.
    You could also try lowering the sound effects volume to convey the character focus
    when in slow motion. Plus, using audio filters on the camera could be an interesting
    option.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 《马克斯·佩恩》著名地使用了强烈、沉重的心跳声作为音效氛围。您也可以尝试降低音效音量，以传达在慢动作时角色的专注。此外，在相机上使用音频过滤器可能是一个有趣的选择。
- en: See also
  id: totrans-101
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the recipe *Pausing the game* in this chapter for more information.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 请参阅本章中的“暂停游戏”配方以获取更多信息。
- en: Preventing your game from running on unknown servers
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 防止您的游戏在未知服务器上运行
- en: After all the hard work you've had to go through to complete your web game project,
    it wouldn't be fair if it ended up generating traffic and income on someone else's
    website. In this recipe, we will create a script that prevents the main game menu
    from showing up unless it's hosted by an authorized server.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 在您完成所有艰苦的工作以完成您的网络游戏项目之后，如果它最终在别人的网站上产生流量和收入，那就太不公平了。在这个食谱中，我们将创建一个脚本，以防止除非它由授权服务器托管，否则主游戏菜单显示。
- en: Getting ready
  id: totrans-105
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: To test this recipe, you will need access to a webspace provider where you can
    host the game.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 要测试这个食谱，您需要访问一个可以托管游戏的网络空间提供商。
- en: How to do it...
  id: totrans-107
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To prevent your web game from being pirated, follow these steps:'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 为了防止您的网络游戏被盗版，请按照以下步骤操作：
- en: From the **Hierarchy** view, use the **Create** drop-down menu to create a **UI
    Text** GameObject (**Create** | **UI** | **Text**). Name it `Text – warning`.
    Then, from the **Text** component in the **Inspector**, change its **text** field
    to `Getting Info. Please wait`.
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**层次结构**视图，使用**创建**下拉菜单创建一个**UI Text**游戏对象（**创建** | **UI** | **文本**）。将其命名为`Text
    – warning`。然后，从**检查器**中的**文本**组件，将**文本**字段更改为`Getting Info. Please wait`。
- en: 'Add the following C# script to the `Text – warning` game object:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本添加到`Text – warning`游戏对象：
- en: '[PRE3]'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: From the **Inspector** view, leave the options **Check Domain** and **Full URL**
    checked, and increase **Size** of **Domain List** to `1` and fill out **Element
    0** with the complete URL for your game. Type in the sentence `This is not a valid
    copy of the game` in the **Message** field, as shown in the following screenshot.
    You might have to change the paragraph's **Horizontal Overflow** to **Overflow**.
  id: totrans-112
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**检查器**视图，保留**检查域名**和**完整URL**选项的勾选，并将**域名列表**的**大小**增加到`1`，并在**元素 0**中填写您游戏的完整URL。在**消息**字段中输入句子`This
    is not a valid copy of the game`，如以下截图所示。您可能需要将段落的**水平溢出**更改为**溢出**。
- en: Note
  id: totrans-113
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: Remember to include the Unity 3D file name and extension in the URL,
    and not the HTML where it is embedded.'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意：请记住在URL中包含Unity 3D文件名和扩展名，而不是它嵌入的HTML。
- en: '![How to do it...](img/1362OT_11_08.jpg)'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![如何操作...](img/1362OT_11_08.jpg)'
- en: Save your scene as `menu`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将场景保存为`menu`。
- en: Create a new scene and change its **Main Camera** background color to black.
    Save this scene as `nextLevel`.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的场景，并将其**主摄像机**的背景颜色更改为黑色。将此场景保存为`nextLevel`。
- en: Let's build the game. Go to the **File | Build Settings…** menu and include
    the scenes **menu** and **nextLevel**, in that order, in the build list (**Scenes**
    in **Build**). Also, select **Web Player** as your platform and click on **Build**.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们构建游戏。转到**文件 | 构建设置…**菜单，并按顺序将场景**menu**和**nextLevel**包含在构建列表中（**构建**中的**场景**）。此外，选择**Web
    Player**作为您的平台，然后点击**构建**。
- en: How it works...
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As soon as the scene starts, the script compares the actual URL of the `.unity3d`
    file to the ones listed in the `Block Access` component. If they don't match,
    the next level in the build is not loaded and a message appears on the screen.
    If they do match, the line of code `Application.LoadLevel(Application.loadedLevel
    + 1)` will load the next scene from the build list.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦场景开始，脚本就会将`.unity3d`文件的实际URL与`Block Access`组件中列出的URL进行比较。如果不匹配，则构建中的下一级不会加载，并在屏幕上显示消息。如果它们匹配，则代码行`Application.LoadLevel(Application.loadedLevel
    + 1)`将加载构建列表中的下一场景。
- en: There's more...
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多...
- en: Here is some information on how to fine tune and customize this recipe.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些关于如何微调和自定义这个食谱的信息。
- en: Improving security by using full URLs in your domain list
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过在域名列表中使用完整URL提高安全性
- en: Your game will be more secure if you fill out the domain list with complete
    URLs (such as [http://www.myDomain.com/unitygame/game.unity3d](http://www.myDomain.com/unitygame/game.unity3d)).
    In fact, it's recommended that you leave the **Full URL** option selected so that
    your game won't be stolen and published under a URL such as `www.stolenGames.com/yourgame.html?www.myDomain.com`.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您在域名列表中填写完整的URL（例如 [http://www.myDomain.com/unitygame/game.unity3d](http://www.myDomain.com/unitygame/game.unity3d)），您的游戏将更加安全。实际上，建议您选择**完整URL**选项，这样您的游戏就不会被盗版并在类似`www.stolenGames.com/yourgame.html?www.myDomain.com`的URL下发布。
- en: Allowing redistribution with more domains
  id: totrans-125
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 允许更多域的重新分发
- en: If you want your game to run from several different domains, increase **Size**
    and fill out more URLs. Also, you can leave your game completely free of protection
    by leaving the **Check Domain** option unchecked.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想让游戏从多个不同的域运行，请增加**大小**并填写更多URL。此外，您可以通过不勾选**检查域名**选项来完全取消保护您的游戏。
- en: State-driven behavior Do-It-Yourself states
  id: totrans-127
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 状态驱动行为 DIY 状态
- en: Games as a whole, and individual objects or characters, can often be thought
    of (or modeled as) passing through different *states* or *modes*. Modeling states
    and changes of state (due to *events* or game conditions) is a very common way
    to manage the complexity of games and game components. In this recipe, we create
    a simple three-state game (game playing/game won/game lost) using a single `GameManager`
    class.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 整个游戏以及单个对象或角色通常可以被视为（或建模为）通过不同的**状态**或**模式**。建模状态和状态的变化（由于**事件**或游戏条件）是管理游戏和游戏组件复杂性的非常常见方式。在这个菜谱中，我们使用单个`GameManager`类创建一个简单的三状态游戏（游戏进行/游戏胜利/游戏失败）。
- en: How to do it...
  id: totrans-129
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To use states to manage object behavior, follow these steps:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用状态来管理对象行为，请按照以下步骤操作：
- en: Create two UI buttons at the top middle of the screen. Name one **Button-win**
    and edit its text to read **Win Game**. Name the second **Button-lose** and edit
    its text to read **Lose Game**.
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕顶部中间创建两个 UI 按钮。将一个命名为**Button-win**，并编辑其文本为**Win Game**。将第二个命名为**Button-lose**，并编辑其文本为**Lose
    Game**。
- en: Create a UI text object at the top left of the screen. Name this **Text-state-messages**,
    and set its **Rect Transform** height property to **300** and its **Text (Script)
    Paragraph Vertical Overflow** property to **Overflow**.![How to do it...](img/1362OT_11_38.jpg)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕顶部左侧创建一个 UI 文本对象。将此命名为**Text-state-messages**，并将其**Rect Transform**高度属性设置为**300**，其**Text
    (Script) Paragraph Vertical Overflow**属性设置为**Overflow**。![如何操作...](img/1362OT_11_38.jpg)
- en: 'Add the following C# script class `GameManager` to **Main Camera**:'
  id: totrans-133
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 C# 脚本类 `GameManager` 添加到**Main Camera**：
- en: '[PRE4]'
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: In the **Hierarchy**, select the **Button-win** button, and for its **Button
    (Script)** component, add an `OnClick` action to call the `BUTTON_CLICK_ACTION_WIN_GAME()`
    method from the **GameManager** component in the **Main Camera** GameObject.
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择**Button-win**按钮，并为它的**Button (Script)**组件添加一个`OnClick`动作，以从**Main
    Camera** GameObject 中的**GameManager**组件调用`BUTTON_CLICK_ACTION_WIN_GAME()`方法。
- en: In the **Hierarchy**, select the **Button-lose** button, and for its **Button
    (Script)** component, add an `OnClick` action to call the `BUTTON_CLICK_ACTION_LOSE_GAME()`
    method from the **GameManager** component in the **Main Camera** GameObject.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择**Button-lose**按钮，并为它的**Button (Script)**组件添加一个`OnClick`动作，以从**Main
    Camera** GameObject 中的**GameManager**组件调用`BUTTON_CLICK_ACTION_LOSE_GAME()`方法。
- en: In the **Hierarchy**, select the **Main Camera** GameObject. Next, drag into
    the **Inspector** to ensure that all three **GameManager (Script)** public variables,
    **Text State Messages**, **Button Win Game**, and **Button Lose Game**, have the
    corresponding Canvas GameObjects dragged into them (the two buttons and the UI
    text GameObject).
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择**Main Camera** GameObject。接下来，将其拖入**Inspector**以确保所有三个**GameManager
    (Script)**公共变量、**Text State Messages**、**Button Win Game**和**Button Lose Game**都有相应的
    Canvas GameObjects 拖入其中（两个按钮和 UI 文本 GameObject）。
- en: How it works...
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何工作...
- en: As can be seen in the following state chart figure, this recipe models a simple
    game, which starts in the **GAME PLAYING** state; then, depending on the button
    clicked by the user, the game moves either into the **GAME WON** state or the
    **GAME LOST** state. Also, if the user waits too long to click on a button, the
    game moves into the **GAME LOST** state.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下状态图所示，这个菜谱模拟了一个简单的游戏，它从**GAME PLAYING**状态开始；然后，根据用户点击的按钮，游戏要么移动到**GAME WON**状态或**GAME
    LOST**状态。此外，如果用户等待太长时间才点击按钮，游戏将移动到**GAME LOST**状态。
- en: The possible states of the system are defined using the enumerated type `GameStateType`,
    and the current state of the system at any point in time is stored in the `currentState`
    variable.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 系统的可能状态由枚举类型`GameStateType`定义，而系统在任何时间点的当前状态存储在`currentState`变量中。
- en: '![How it works...](img/1362OT_11_39.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![如何工作...](img/1362OT_11_39.jpg)'
- en: A fourth state is defined (`Other`) to allow us to explicitly set the desired
    `GamePlaying` state in our `Start()` method. When we wish the game state to be
    changed, we call the `NewGameState(…)`method, passing the new state the game is
    to change into. The `NewGameState(…)`method first calls the `OnMyStateExit(…)`method
    with the current state, since there may be actions to be performed when a particular
    state is exited; for example, when the `GamePlaying` state is exited, it destroys
    the two buttons. Next, the `NewGameState(…)`method sets the `currentState` variable
    to be assigned the new state. Next, the `OnMyStateEnter(…)` method is called,
    since there may be actions to be performed immediately when a new state is entered.
    Finally, a message divider is posted to the UI Text box, with a call to the `PostMessageDivider()`method.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 定义了第四个状态（`Other`），以便我们可以在`Start()`方法中显式设置所需的`GamePlaying`状态。当我们希望游戏状态改变时，我们调用`NewGameState(…)`方法，传递游戏要改变到的新的状态。`NewGameState(…)`方法首先调用带有当前状态的`OnMyStateExit(…)`方法，因为当退出特定状态时可能需要执行某些操作；例如，当退出`GamePlaying`状态时，它销毁两个按钮。接下来，`NewGameState(…)`方法将`currentState`变量设置为分配给新状态。然后，调用`OnMyStateEnter(…)`方法，因为当进入新状态时可能需要立即执行某些操作。最后，向UI文本框发布一个消息分隔符，调用`PostMessageDivider()`方法。
- en: When the `GameManager` object receives messages (for example, every frame for
    `Update()`), its behavior must be appropriate for the current state. So, we see
    in this method a `Switch` statement, which calls state-specific methods. For example,
    if the current state is `GamePlaying`, then when an `Update()` message is received,
    the `UpdateStateGamePlaying()`method will be called.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 当`GameManager`对象接收到消息（例如，每帧的`Update()`）时，其行为必须适合当前状态。因此，我们在这个方法中看到一个`Switch`语句，它调用特定状态的方法。例如，如果当前状态是`GamePlaying`，那么当接收到`Update()`消息时，将调用`UpdateStateGamePlaying()`方法。
- en: The `BUTTON_CLICK_ACTION_WIN_GAME()` and `BUTTON_CLICK_ACTION_LOSE_GAME()` methods
    are executed if their corresponding buttons have been clicked. They move the game
    into the corresponding **WIN** or **LOSE** state.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 如果对应的按钮已被点击，将执行`BUTTON_CLICK_ACTION_WIN_GAME()`和`BUTTON_CLICK_ACTION_LOSE_GAME()`方法。它们将游戏移动到相应的**WIN**或**LOSE**状态。
- en: Logic has been written in the `UpdateStateGamePlaying() m`ethod, so once the
    `GameManager` has been in the `GamePlaying` state for more than a certain time
    (defined in variable `timeToPressAButton`), the game will automatically change
    into the `GameLost` state.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 逻辑已编写在`UpdateStateGamePlaying()`方法中，因此一旦`GameManager`处于`GamePlaying`状态超过一定时间（由变量`timeToPressAButton`定义），游戏将自动切换到`GameLost`状态。
- en: So, for each state, we may need to write methods for state exit, state entry,
    and update events, and also a main method for each event with a `Switch` statement
    to determine which state method should be called (or not). As can be imagined,
    the size of our methods and the number of methods in our `GameManager` class will
    grow significantly as more states and a more complex game logic are needed for
    non-trivial games. The next recipe takes a more sophisticated approach to state-driven
    games, where each state has its own class.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，对于每个状态，我们可能需要编写状态退出、状态进入和更新事件的相应方法，以及每个事件的主方法，其中包含一个`Switch`语句来决定应该调用哪个状态方法（或不应调用）。正如可以想象的那样，随着更多状态和更复杂的游戏逻辑的需求增加，我们的方法和`GameManager`类中的方法数量将显著增加。下一节将采用更复杂的方法来处理状态驱动游戏，其中每个状态都有自己的类。
- en: See also
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the next recipe in this chapter for more information on how to manage
    the complexity of states with class inheritance and the State Design Pattern.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章下一节以获取更多关于如何管理具有类继承和状态设计模式的状态复杂性的信息。
- en: State-driven behavior using the State Design pattern
  id: totrans-149
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用状态设计模式实现状态驱动行为
- en: The previous pattern illustrated not only the usefulness of modeling game states,
    but also how a game manager class can grow in size and become unmanageable. To
    manage the complexity of many states and complex behaviors of states, the State
    pattern has been proposed in the software development community. Design patterns
    are general purpose software component architectures that have been tried and
    tested and found to be good solutions to commonly occurring software system features.
    The key features of the State pattern are that each state is modeled by its own
    class and that all states inherit (are subclassed) from a single parent state
    class. The states need to know about each other in order to tell the game manager
    to change the current state. This is a small price to pay for the division of
    the complexity of the overall game behaviors into separate state classes.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的模式不仅说明了建模游戏状态的有用性，还说明了游戏管理类如何增长并变得难以管理。为了管理许多状态和状态的复杂行为的复杂性，软件开发社区提出了状态模式。设计模式是一般目的的软件组件架构，经过尝试和测试，被证明是解决常见软件系统特征的优秀解决方案。状态模式的关键特性是每个状态都由其自己的类进行建模，并且所有状态都继承（子类化）自单个父状态类。为了告诉游戏管理器更改当前状态，状态之间需要相互了解。这是为了将整体游戏行为的复杂性分解为单独的状态类而付出的微小代价。
- en: Note
  id: totrans-151
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'NOTE: Many thanks to the contribution from Bryan Griffiths which has helped
    improve this recipe.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：非常感谢Bryan Griffiths的贡献，这有助于改进这个配方。
- en: Getting ready
  id: totrans-153
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: This recipe builds upon the previous recipe. So, make a copy of that project,
    open it, and then follow the steps for this recipe.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方基于之前的配方。因此，复制那个项目，打开它，然后按照这个配方的步骤进行。
- en: How to do it...
  id: totrans-155
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To manage an object''s behavior using the state pattern architecture, perform
    the following steps:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 使用状态模式架构来管理对象的行为，请执行以下步骤：
- en: 'Replace the contents of C# script class `GameManager` with the following:'
  id: totrans-157
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 用以下内容替换C#脚本类`GameManager`的内容：
- en: '[PRE5]'
  id: totrans-158
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Create a new C# script class called `GameState`:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本类，命名为`GameState`：
- en: '[PRE6]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a new C# script class called `StateGamePlaying`:'
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本类，命名为`StateGamePlaying`：
- en: '[PRE7]'
  id: totrans-162
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Create a new C# script class called `StateGameWon`:'
  id: totrans-163
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本类，命名为`StateGameWon`：
- en: '[PRE8]'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Create a new C# script class called `StateGameLost`:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的C#脚本类，命名为`StateGameLost`：
- en: '[PRE9]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In the **Hierarchy**, select the **Button-win** button, and for its **Button
    (Script)** component, add an `OnClick` action to call the `BUTTON_CLICK_ACTION_WIN_GAME()`
    method from the **GameManager** component in the **Main Camera** GameObject.
  id: totrans-167
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择**Button-win**按钮，并为它的**Button (Script)**组件添加一个`OnClick`动作，调用**主摄像机**GameObject中的**GameManager**组件的`BUTTON_CLICK_ACTION_WIN_GAME()`方法。
- en: In the **Hierarchy**, select the **Button-lose** button, and for its **Button
    (Script)** component, add an `OnClick` action to call the `BUTTON_CLICK_ACTION_LOSE_GAME()`
    method from the **GameManager** component in the **Main Camera** GameObject.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择**Button-lose**按钮，并为它的**Button (Script)**组件添加一个`OnClick`动作，调用**主摄像机**GameObject中的**GameManager**组件的`BUTTON_CLICK_ACTION_LOSE_GAME()`方法。
- en: In the **Hierarchy**, select the **Main Camera** GameObject. Next, drag into
    the **Inspector** to ensure that all three **GameManager (Script)** public variables,
    **Text State Messages**, **Button Win Game**, and **Button Lose Game**, have the
    corresponding Canvas GameObjects dragged into them (the two buttons and the UI
    text GameObject).
  id: totrans-169
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中，选择**主摄像机**GameObject。接下来，将其拖入**检查器**中，以确保所有三个**GameManager (Script)**公共变量、**文本状态消息**、**胜利游戏按钮**和**失败游戏按钮**都有相应的Canvas
    GameObject拖入其中（两个按钮和UI文本GameObject）。
- en: How it works...
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 工作原理...
- en: The scene is very straightforward for this recipe. There is the single **Main
    Camera** GameObject that has the `GameManager` script object component attached
    to it.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方来说，场景非常直接。有一个单独的**主摄像机**GameObject，它附加了`GameManager`脚本对象组件。
- en: 'A C# scripted class is defined for each state that the game needs to manage—for
    this example, the three states `StateGamePlaying`, `StateGameWon`, and `StateGameLost`.
    Each of these state classes is a subclass of `GameState`. `GameState` defines
    properties and methods that all subclass states will possess:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 为游戏需要管理的每个状态定义一个C#脚本类——对于这个例子，有三个状态`StateGamePlaying`、`StateGameWon`和`StateGameLost`。这些状态类都是`GameState`的子类。`GameState`定义了所有子类状态将拥有的属性和方法：
- en: 'An enumerated type `ButtonType`, which defines the two possible button clicks
    that the game might generate: `ButtonWinGame` and `ButtonLoseGame`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个枚举类型`ButtonType`，它定义了游戏可能生成的两种可能的按钮点击：`ButtonWinGame`和`ButtonLoseGame`。
- en: 'The `gameManager` variable: so that each state object has a link to the game
    manager.'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`gameManager` 变量：以便每个状态对象都有一个指向游戏管理器的链接。'
- en: 'The constructor method that accepts a reference to the `GameManager`: that
    automatically makes the `gameManager` variable refer to the passed in `GameManager`
    object.'
  id: totrans-175
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 接受 `GameManager` 引用的构造函数方法：这将自动使 `gameManager` 变量指向传入的 `GameManager` 对象。
- en: The four abstract methods `OnMyStateEntered()`, `OnMyStateExit()`, `OnButtonClick(…)`,
    and `StateUpdate()`. Note that abstract methods must have their own implementation
    for each subclass.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 四个抽象方法 `OnMyStateEntered()`、`OnMyStateExit()`、`OnButtonClick(…)` 和 `StateUpdate()`。请注意，抽象方法必须为每个子类有自己的实现。
- en: 'When the `GameManager` class'' `Awake()` method is executed, three state objects
    are created, one for each of the playing/win/lose classes. These state objects
    are stored in their corresponding variables: `stateGamePlaying`, `stateGameWon`,
    and `stateGameLost`.'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 当 `GameManager` 类的 `Awake()` 方法执行时，将创建三个状态对象，每个对应于 playing/win/lose 类。这些状态对象存储在其相应的变量中：`stateGamePlaying`、`stateGameWon`
    和 `stateGameLost`。
- en: The `GameManager` class has a variable called `currentState`, which is a reference
    to the current state object at any time while the game runs (initially, it will
    be `null`). Since it is of the `GameState` class (the parent of all state classes),
    it can refer to any of the different state objects.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: '`GameManager` 类有一个名为 `currentState` 的变量，它是对当前状态对象的引用，在游戏运行期间任何时刻都有效（最初，它将是
    `null`）。由于它是 `GameState` 类（所有状态类的父类）的实例，它可以引用任何不同的状态对象。'
- en: After `Awake()`, `GameManager` will receive a `Start()` message. This method
    initializes the `currentState` to be the `stateGamePlaying` object.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Awake()` 之后，`GameManager` 将接收到一个 `Start()` 消息。此方法将 `currentState` 初始化为 `stateGamePlaying`
    对象。
- en: For each frame, the `GameManager` will receive `Update()`messages. Upon receiving
    these messages, `GameManager` sends a `StateUpdate()`messages to the `currentState`
    object. So, for each frame, the object for the current state of the game will
    execute those methods. For example, when the `currentState` is set to game playing,
    for each frame, the `gamePlayingObject` will calls its (in this case, empty) `StateUpdate()`
    method.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 对于每一帧，`GameManager` 将接收到 `Update()` 消息。在接收到这些消息后，`GameManager` 将向 `currentState`
    对象发送 `StateUpdate()` 消息。因此，对于每一帧，当前游戏状态的对象将执行这些方法。例如，当 `currentState` 设置为游戏进行时，对于每一帧，`gamePlayingObject`
    将调用其（在这种情况下，为空的）`StateUpdate()` 方法。
- en: The `StateGamePlaying` class implements statements in its `OnButtonClick()`
    method so that when the user clicks on a button, the `gamePlayingObject` will
    call the `GameManager` instance's `NewState()` method, passing it the object corresponding
    to the new state. So, if the user clicks on **Button-win**, the `NewState()` method
    is passed to `gameManager.stateGameWon`.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: '`StateGamePlaying` 类在其 `OnButtonClick()` 方法中实现了语句，以便当用户点击按钮时，`gamePlayingObject`
    将调用 `GameManager` 实例的 `NewState()` 方法，并传递对应新状态的对象。因此，如果用户点击 **Button-win** 按钮，`NewState()`
    方法将传递给 `gameManager.stateGameWon`。'
- en: Reducing the number of objects by destroying objects at death a time
  id: totrans-182
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过在死亡时销毁对象来减少对象数量
- en: '**Optimization principal 1**: Minimize the number of active and enabled objects
    in a scene.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化原则 1**：最小化场景中活跃和启用的对象数量。'
- en: One way to reduce the number of active objects is to destroy objects when they
    are no longer needed. As soon as an object is no longer needed, we should destroy
    it; this saves both memory and processing resources since Unity no longer needs
    to send the object such messages as `Update()` and `FixedUpdate()`, or consider
    object collisions or physics and so on.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 减少活跃对象数量的方法之一是在它们不再需要时销毁对象。一旦对象不再需要，就应该销毁它；这样可以节省内存和处理资源，因为 Unity 不再需要发送对象如
    `Update()` 和 `FixedUpdate()` 等消息，或者考虑对象碰撞或物理等。
- en: However, there may be times when we wish not to destroy an object immediately,
    but at some known point in the future. Examples might include after a sound has
    finished playing (see that recipe *Waiting for audio to finish before auto-destructing
    object* in [Chapter 9](ch09.html "Chapter 9. Playing and Manipulating Sounds"),
    *Playing and Manipulating Sounds*), the player only has a certain time to collect
    a bonus object before it disappears, or perhaps an object displaying a message
    to the player should disappear after a certain time.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有时我们可能希望不是立即销毁一个对象，而是在未来的某个已知点。例如，在声音播放完毕后（参见第9章中的配方 *在自动销毁对象前等待音频播放结束*，*播放和操作声音*），玩家只有一定时间收集奖励对象，或者可能显示给玩家的对象在一段时间后应该消失。
- en: This recipe demonstrates how objects can be told to *start dying*, and then
    to automatically destroy them after a given delay has passed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方演示了如何告诉对象 *开始死亡*，然后在给定延迟过后自动销毁它们。
- en: '![Reducing the number of objects by destroying objects at death a time](img/1362OT_11_14.jpg)'
  id: totrans-187
  prefs: []
  type: TYPE_IMG
  zh: '![通过在死亡时销毁对象来减少对象数量](img/1362OT_11_14.jpg)'
- en: How to do it...
  id: totrans-188
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To destroy objects after a specified time, follow these steps:'
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 要在指定时间后销毁对象，请按照以下步骤操作：
- en: Create a new 2D project.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 2D 项目。
- en: Create a UI **Button** named **Click Me**, and make it stretch to fill the entire
    window.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 **Click Me** 的 UI **按钮**，并使其填充整个窗口。
- en: In the **Inspector**, set the Button's **Text child** to have left-aligned and
    large text.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Inspector** 中，将按钮的 **Text child** 设置为左对齐和大号文本。
- en: 'Add the following script class `DeathTimeExample.cs` to **Button Click Me**:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下脚本类 `DeathTimeExample.cs` 添加到 **Button Click Me**：
- en: '[PRE10]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Drag the **Text** child of **Button Click Me** into the script's public variable
    **Button Text**, so this script is able to change the button text to show the
    countdown.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 **Button Click Me** 的 **Text** 子对象拖动到脚本的公共变量 **Button Text** 中，这样脚本就能更改按钮文本以显示倒计时。
- en: With **Button Click Me** selected in the **Hierarchy**, add a new **On Click()**
    event for this button, dragging the button itself as the target GameObject and
    selecting public function `BUTTON_ACTION_StartDying(),`as shown in the following
    screenshot:![How to do it...](img/1362OT_11_15.jpg)
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Hierarchy** 中选择 **Button Click Me**，为此按钮添加一个新的 **On Click()** 事件，将按钮本身作为目标
    GameObject，并选择公共函数 `BUTTON_ACTION_StartDying()`，如以下截图所示：![如何操作...](img/1362OT_11_15.jpg)
- en: Now, run the scene; once the button is clicked, the button's text should show
    the countdown. Once the countdown gets to zero, **Button Click Me** will be destroyed
    (including all its children, in this case, just the GameObject **Text**).
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行场景；一旦点击按钮，按钮的文本应该显示倒计时。一旦倒计时到达零，**Button Click Me** 将被销毁（包括所有子对象，在这种情况下，只是
    GameObject **Text**）。
- en: How it works...
  id: totrans-198
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The float variable `deathDelay` stores the number of seconds the object waits
    before destroying itself once the decision has been made for the object to start
    dying. The float variable `deathTime` either has a value of `-1` (no death time
    yet set) or it is a non-negative value, which is the time we wish the object to
    destroy itself.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 浮点变量 `deathDelay` 存储对象在决定开始死亡后等待销毁自己的秒数。浮点变量 `deathTime` 要么是 `-1`（尚未设置死亡时间），要么是一个非负值，这是我们希望对象销毁自己的时间。
- en: When the button is clicked, the `BUTTON_ACTION_StartDying()` method is called.
    This method sets this `deathTime` variable to the current time plus whatever value
    is set in `deathDelay`. This new value for `deathTime` will be a positive number,
    meaning the `IF`-statement in the `Update()` method will fire from this point
    onward.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 当按钮被点击时，会调用 `BUTTON_ACTION_StartDying()` 方法。此方法将 `deathTime` 变量设置为当前时间加上 `deathDelay`
    中设置的任何值。这个新的 `deathTime` 值将是一个正数，这意味着从这一点开始，`Update()` 方法中的 `IF` 语句将会触发。
- en: Every frame method `Update()` checks if `deathTime` is greater than zero (that
    is, a death time has been set), and, if so, it then calls, the `UpdateTimeDisplay()`
    and `CheckDeath()` methods.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 每一帧方法 `Update()` 检查 `deathTime` 是否大于零（即已设置死亡时间），如果是，则调用 `UpdateTimeDisplay()`
    和 `CheckDeath()` 方法。
- en: The `UpdateTimeDisplay()` methods creates a string message stating how many
    seconds are left and updates the **Button Text** to show this message.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: '`UpdateTimeDisplay()` 方法创建一个字符串消息，说明还剩下多少秒，并将 **Button Text** 更新以显示此消息。'
- en: The `CheckDeath()` method tests whether the current time has passed the `deathTime`.
    If the death time has passed, then the parent `gameObject` is immediately destroyed.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: '`CheckDeath()` 方法测试当前时间是否已经超过了 `deathTime`。如果死亡时间已过，则父 `gameObject` 将立即被销毁。'
- en: When you run the scene, you'll see the **Button** removed from the **Hierarchy**
    once its death time has been reached.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 当您运行场景时，您将看到一旦达到其死亡时间，**Button** 就会从 **Hierarchy** 中移除。
- en: See also
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter for more information:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅本章中的以下配方：
- en: Reducing the number of enabled objects by disabling objects whenever possible
  id: totrans-207
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在可能的情况下禁用对象来减少启用对象的数量
- en: Reducing the number of active objects by making objects inactive whenever possible
  id: totrans-208
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过在可能的情况下使对象不活跃来减少活动对象的数量
- en: Reducing the number of enabled objects by disabling objects whenever possible
  id: totrans-209
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过在可能的情况下禁用对象来减少启用对象的数量
- en: '**Optimization principal 1**: Minimize the number of active and enabled objects
    in a scene.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化原则 1**：最小化场景中活动对象和启用对象的数量。'
- en: Sometimes, we may not want to completely remove an object, but we can identify
    times when a scripted component of an object can be safely disabled. If a `MonoBehaviour`
    script is disabled, then Unity no longer needs to send the object messages, such
    as `Update()`and `FixedUpdate()`, for each frame.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能不想完全删除一个对象，但我们可以确定何时可以安全地禁用对象的脚本组件。如果一个 `MonoBehaviour` 脚本被禁用，那么 Unity
    就不再需要为每个帧发送对象消息，例如 `Update()` 和 `FixedUpdate()`。
- en: For example, if a **Non-Player Character** (**NPC**) should only demonstrate
    some behavior when the player can see that character, then we only need to be
    executing the behavior logic when the NPC is visible—the rest of the time, we
    can safely disable the scripted component.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果一个**非玩家角色**（**NPC**）只有在玩家可以看到该角色时才应该展示某些行为，那么我们只需要在 NPC 可见时执行行为逻辑——其余时间，我们可以安全地禁用脚本组件。
- en: Unity provides the very useful events `OnBecameInvisible()` and `OnBecameVisible()`,
    which inform an object when it moves out of and into the visible area for one
    or more cameras in the scene.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 提供了非常有用的事件 `OnBecameInvisible()` 和 `OnBecameVisible()`，它们会在对象从场景中的一个或多个摄像机的可见区域移出和进入时通知对象。
- en: 'This recipe illustrates the following rule of thumb: if an object has no reason
    to be doing actions when it cannot be seen, then we should disable that object
    while it cannot be seen.'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方说明了以下经验法则：如果一个对象在不可见时没有理由执行动作，那么我们应该在它不可见时禁用该对象。
- en: '![Reducing the number of enabled objects by disabling objects whenever possible](img/1362OT_11_16.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![通过在可能的情况下禁用对象来减少启用对象的数量](img/1362OT_11_16.jpg)'
- en: Getting ready
  id: totrans-216
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a package named `unity4_assets_handyman_goodDirt`
    containing the `3rdPersonController` handyman and Terrain material `goodDirt`.
    The package is in the `1362_11_07` folder.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们准备了一个名为 `unity4_assets_handyman_goodDirt` 的包，其中包含 `3rdPersonController`
    handyman 和地形材质 `goodDirt`。该包位于 `1362_11_07` 文件夹中。
- en: How to do it...
  id: totrans-218
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To disable objects to reduce computer processing workload requirements, follow
    these steps:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 要禁用对象以减少计算机处理工作负载的要求，请按照以下步骤操作：
- en: Create a new Unity project, importing the provided Unity package `unity4_assets_handyman_goodDirt`.
  id: totrans-220
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 Unity 项目，导入提供的 Unity 包 `unity4_assets_handyman_goodDirt`。
- en: Create a new **Terrain** (size **20 x 20**, located at **-10, 0, -10**) and
    texture-paint it with **GoodDirt** (which you'll find in the **Standard Assets**
    folder from your import of the **Terrain Assets** package).
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 **Terrain**（大小 **20 x 20**，位于 **-10, 0, -10**），并用 **GoodDirt**（您可以在从
    **Terrain Assets** 包导入的 **Standard Assets** 文件夹中找到）进行纹理绘制。
- en: Add a **3rdPersonController** at (**0, 1, 0**).
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在（**0, 1, 0**）位置添加一个**3rdPersonController**。
- en: Create a new **Cube** just in front of your **3rdPersonController** (so it is
    visible in the **Game** panel when you start running the game).
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在您的 **3rdPersonController** 前创建一个新的 **Cube**（这样当您开始运行游戏时，它在 **Game** 面板中是可见的）。
- en: 'Add the following C# script class `DisableWhenNotVisible` to your **Cube**:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 C# 脚本类 `DisableWhenNotVisible` 添加到您的 **Cube**：
- en: '[PRE11]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: How it works...
  id: totrans-226
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When visible, the scripted `DisableWhenNotVisible` component of **Cube** recalculates
    and displays the distance from itself to the **3rdPersonController** object's
    transform, via the variable `player` in the `Update()` method for each frame.
    However, when this object receives the message `OnBecameInvisible()`, the object
    sets its `enabled` property to `false`. This results in Unity no longer sending
    `Update()`messages to the `GameObject`, so the distance calculation in `Update()`
    is no longer performed; thus, reducing the game's processing workload. Upon receiving
    the message `OnBecameVisible()`, the `enabled` property is set back to `true`,
    and the object will then receive `Update()` messages for each frame. Note that
    you can see the scripted component become disabled by seeing the blue *tick* in
    its **Inspector** checkbox disappear if you have the **Cube** selected in the
    **Hierarchy** when running the game.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当可见时，**立方体**的脚本`DisableWhenNotVisible`组件会重新计算并通过`Update()`方法中的`player`变量显示其自身到**3rdPersonController**对象变换的距离，每帧进行一次。然而，当此对象接收到`OnBecameInvisible()`消息时，对象将其`enabled`属性设置为`false`。这导致Unity不再向`GameObject`发送`Update()`消息，因此`Update()`中的距离计算不再执行；从而减少了游戏的处理工作量。接收到`OnBecameVisible()`消息后，`enabled`属性被设置回`true`，并且对象将接收每帧的`Update()`消息。请注意，如果你在运行游戏时在**层次结构**中选择**立方体**，你可以通过看到其**检查器**中的蓝色*勾选*消失来看到脚本组件被禁用。
- en: '![How it works...](img/1362OT_11_17.jpg)'
  id: totrans-228
  prefs: []
  type: TYPE_IMG
  zh: '![工作原理...](img/1362OT_11_17.jpg)'
- en: The preceding screenshot shows our **Console** text output, logging how the
    user must have turned away from the cube at 6.9 seconds after starting the game
    (and so the cube was no longer visible); then, at 9.4 seconds, the user turned
    so that they could see the cube again, causing it to be re-enabled.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 上一张截图显示了我们的**控制台**文本输出，记录了用户在游戏开始后6.9秒转向立方体的情况（因此立方体不再可见）；然后，在9.4秒时，用户转向以便再次看到立方体，导致它被重新启用。
- en: There's more...
  id: totrans-230
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some details you don''t want to miss:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你不希望错过的细节：
- en: Note – viewable in Scene panel still counts as visible!
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意 – 在场景面板中可见仍然算作可见！
- en: Note that even if the **Game** panel is not showing (rendering) an object, if
    the object is visible in a **Scene** panel, then it will still be considered visible.
    Therefore, it is recommended that you hide/close the **Scene** panel when testing
    this recipe, otherwise it may be that the object does only becomes non-visible
    when the game stops running.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，即使**游戏**面板没有显示（渲染）对象，如果对象在**场景**面板中可见，那么它仍然会被视为可见。因此，建议你在测试此菜谱时隐藏/关闭**场景**面板，否则可能的情况是对象仅在游戏停止运行时才变为不可见。
- en: Another common case – only enable after OnTrigger()
  id: totrans-234
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 另一种常见情况 – 仅在OnTrigger()之后启用
- en: 'Another common situation is that we only want a scripted component to be active
    if the player''s character is nearby (within some minimum distance). In these
    situations, a sphere collider (with **Is Trigger** checked) can be set up on the
    object to be disabled/enabled (continuing our example, this would be on our **Cube**),
    and the scripted component can be enabled only when the player''s character enters
    that sphere. This can be implemented by replacing the `OnBecameInvisible()` and
    `OnBecameVisible()` methods with the `OnTriggerEnter()` and `OnTriggerExit()`
    methods as follows:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种常见情况是我们只想在玩家角色附近（在某个最小距离内）激活脚本组件。在这些情况下，可以在要禁用/启用的对象上设置一个球体碰撞器（勾选**Is Trigger**），例如在我们的**立方体**上。脚本组件只能在玩家角色进入该球体时启用。这可以通过将`OnBecameInvisible()`和`OnBecameVisible()`方法替换为`OnTriggerEnter()`和`OnTriggerExit()`方法来实现，如下所示：
- en: '[PRE12]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The following screenshot illustrates a large sphere collider having been created
    around the cube, with its **Trigger** enabled:'
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 以下截图说明了在立方体周围创建了一个大球体碰撞器，并且其**触发器**已启用：
- en: '![Another common case – only enable after OnTrigger()](img/1362OT_11_18.jpg)'
  id: totrans-238
  prefs: []
  type: TYPE_IMG
  zh: '![另一种常见情况 – 仅在OnTrigger()之后启用](img/1362OT_11_18.jpg)'
- en: 'Many computer games (such as *Half Life*) use environmental design such as
    corridors to optimize memory usage by loading and unloading different parts of
    the environment. For example, when a player hits a corridor trigger, environment
    objects load and unload. See the following for more information about such techniques:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 许多计算机游戏（如*半条命*）使用环境设计，如走廊，通过加载和卸载环境的不同部分来优化内存使用。例如，当玩家触发走廊触发器时，环境对象会加载和卸载。有关此类技术的更多信息，请参阅以下内容：
- en: '[http://gamearchitect.net/Articles/StreamingBestiary.html](http://gamearchitect.net/Articles/StreamingBestiary.html)'
  id: totrans-240
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://gamearchitect.net/Articles/StreamingBestiary.html](http://gamearchitect.net/Articles/StreamingBestiary.html)'
- en: '[http://cie.acm.org/articles/level-design-optimization-guidelines-for-game-artists-using-the-epic-games/](http://cie.acm.org/articles/level-design-optimization-guidelines-for-game-artists-using-the-epic-games/)'
  id: totrans-241
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://cie.acm.org/articles/level-design-optimization-guidelines-for-game-artists-using-the-epic-games/](http://cie.acm.org/articles/level-design-optimization-guidelines-for-game-artists-using-the-epic-games/)'
- en: '[http://gamedev.stackexchange.com/questions/33016/how-does-3d-games-work-so-fluent-provided-that-each-meshs-size-is-so-big](http://gamedev.stackexchange.com/questions/33016/how-does-3d-games-work-so-fluent-provided-that-each-meshs-size-is-so-big)'
  id: totrans-242
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://gamedev.stackexchange.com/questions/33016/how-does-3d-games-work-so-fluent-provided-that-each-meshs-size-is-so-big](http://gamedev.stackexchange.com/questions/33016/how-does-3d-games-work-so-fluent-provided-that-each-meshs-size-is-so-big)'
- en: See also
  id: totrans-243
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter for more information:'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下配方以获取更多信息：
- en: '*Reducing the number of objects by destroying objects at a death time*'
  id: totrans-245
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*在死亡时间销毁对象以减少对象数量*'
- en: '*Reducing the number of active objects by making objects inactive whenever
    possible*'
  id: totrans-246
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*尽可能使对象不活跃以减少活跃对象的数量*'
- en: Reducing the number of active objects by making objects inactive whenever possible
  id: totrans-247
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过尽可能使对象不活跃以减少活跃对象的数量
- en: '**Optimization principal 1**: Minimize the number of active and enabled objects
    in a scene.'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化原则1**：最小化场景中活跃和启用的对象数量。'
- en: 'Sometimes, we may not want to completely remove an object, but it is possible
    to go one step further than disabling a scripted component by making the parent
    `GameObject` that contains the scripted component `inactive`. This is just like
    deselecting the checkbox next to the `GameObject` in the **Inspector**, as shown
    in the following screenshot:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，我们可能不想完全删除一个对象，但可以通过使包含脚本组件的父`GameObject`不活跃来比禁用脚本组件更进一步。这就像在**检查器**中取消选中`GameObject`旁边的复选框一样，如图所示：
- en: '![Reducing the number of active objects by making objects inactive whenever
    possible](img/1362OT_11_19.jpg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![尽可能使对象不活跃以减少活跃对象的数量](img/1362OT_11_19.jpg)'
- en: How to do it...
  id: totrans-251
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To reduce computer processing *workload* requirements by making an object inactive
    when it becomes invisible, follow these steps:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 要通过在对象变得不可见时使其不活跃来减少计算机处理*工作量*要求，请按照以下步骤操作：
- en: Copy the previous recipe.
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 复制上一个配方。
- en: 'Remove the scripted component `DisableWhenNotVisible` from your **Cube**, and
    instead, add the following C# script class `InactiveWhenNotVisible` to **Cube**:'
  id: totrans-254
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从您的**立方体**中移除脚本组件`DisableWhenNotVisible`，并改为向**立方体**添加以下C#脚本类`InactiveWhenNotVisible`：
- en: '[PRE13]'
  id: totrans-255
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Create a new **Button**, containing the text `Make Cube Active Again`, and position
    the button so that it is at the top of the **Game** panel and stretches the entire
    width of the **Game** panel, as shown in the following screenshot:![How to do
    it...](img/1362OT_11_20.jpg)
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**按钮**，包含文本`Make Cube Active Again`，并将按钮放置在**游戏**面板的顶部，使其占据**游戏**面板的整个宽度，如图所示：![如何操作...](img/1362OT_11_20.jpg)
- en: With the **Button** selected in the **Hierarchy**, add a new **On Click()**
    event for this button, dragging the **Cube** as the target GameObject and selecting
    public function `BUTTON_ACTION_makeCubeActiveAgain()`.
  id: totrans-257
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**按钮**后，为此按钮添加一个新的**On Click()**事件，将**立方体**作为目标GameObject，并选择公共函数`BUTTON_ACTION_makeCubeActiveAgain()`。
- en: Uncheck the active checkbox next to the **Button** name in the **Inspector**
    (in other words, manually deactivate this **Button** so that we don't see the
    **Button** when the scene first runs).
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中取消选中**按钮**名称旁边的活动复选框（换句话说，手动停用此**按钮**，这样在场景首次运行时我们就看不到**按钮**）。
- en: Select the **Cube** in the **Inspector** and drag the **Button** into the `MakeActiveAgainButton`
    variable slot of its script class `InactiveWhenNotVisible` component, as shown
    in the following screenshot:![How to do it...](img/1362OT_11_21.jpg)
  id: totrans-259
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**检查器**中选择**立方体**，并将**按钮**拖动到其脚本组件`InactiveWhenNotVisible`的`MakeActiveAgainButton`变量槽中，如图所示：![如何操作...](img/1362OT_11_21.jpg)
- en: How it works...
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'Initially, the **Cube** is visible and the **Button** is inactive (so not visible
    to the user). When the **Cube** receives an `OnBecameInvisible` event message,
    its `OnBecameInvisible()` method will execute. This method performs two actions:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 初始时，**立方体**是可见的，而**按钮**是不可用的（因此对用户不可见）。当**立方体**接收到`OnBecameInvisible`事件消息时，其`OnBecameInvisible()`方法将执行。此方法执行两个动作：
- en: It first enables (and therefore makes visible) the `Button`.
  id: totrans-262
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它首先启用（因此使其可见）`按钮`。
- en: It then makes inactive the script's parent `gameObject` (that is, the `Cube`
    GameObject).
  id: totrans-263
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后使脚本的父级 `gameObject`（即 `Cube` GameObject）失效。
- en: When the **Button** is clicked, it makes the **Cube** object active again and
    makes the **Button** inactive again. So, at any one time, only one of the **Cube**
    and **Button** objects are active, and each makes itself inactive when the other
    is active.
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 当 **按钮** 被点击时，它会再次激活 **Cube** 对象，并再次使 **按钮** 失效。因此，在任何时候，只有 **Cube** 和 **按钮**
    对象中的一个处于活动状态，并且当另一个对象处于活动状态时，每个对象都会使自身失效。
- en: Note that an inactive `GameObject` does not receive *any* messages, so it will
    not receive the `OnBecameVisible()` message, and this may not be appropriate for
    every object that is out of sight of the camera. However, when deactivating objects
    is appropriate, a larger performance saving is made compared to simply disabling
    a single scripted `Monobehaviour` component of a `GameObject`.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，一个失效的 `GameObject` 不会接收任何消息，因此它不会接收到 `OnBecameVisible()` 消息，这可能不适合每个在摄像机视线之外的物体。然而，当使对象失效是合适的时候，与简单地禁用
    `GameObject` 的单个脚本 `Monobehaviour` 组件相比，可以节省更多的性能。
- en: The only way to reactivate an inactive object is for another object to set the
    `GameObject` component's active property back to `true`. In this recipe, it is
    the `Button` GameObject, which, when clicked, runs the `BUTTON_ACTION_makeCubeActiveAgain()`
    method, which allows our game to make the **Cube** active again.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 激活失效对象的唯一方法是将 `GameObject` 组件的激活属性设置回 `true`。在本食谱中，是 `Button` GameObject，当点击时，运行
    `BUTTON_ACTION_makeCubeActiveAgain()` 方法，允许我们的游戏再次激活 **Cube**。
- en: See also
  id: totrans-267
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考内容
- en: 'Refer to the following recipes in this chapter for more information:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅本章中的以下食谱：
- en: '*Reducing the number of objects by destroying objects at a death time*'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过在死亡时间销毁对象来减少对象数量*'
- en: '*Reducing the number of enabled objects by disabling objects whenever possible*'
  id: totrans-270
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过在可能的情况下禁用对象来减少启用对象的数量*'
- en: Improving efficiency with delegates and events and avoiding SendMessage!
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用委托和事件提高效率并避免使用 SendMessage！
- en: '**Optimization principal 2**: Minimize actions requiring Unity to perform "reflection"
    over objects and searching of all current scene objects.'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化原则 2**：最小化需要 Unity 对对象进行“反射”操作和搜索所有当前场景对象的动作。'
- en: When events can be based on visibility, distance, or collisions, we can use
    such events as `OnTriggerExit` and `OnBecomeInvisible`, as described in some of
    the previous recipes. When events can be based on time periods, we can use coroutines,
    as described in other recipes in this chapter. However, some events are unique
    to each game situation, and C# offers several methods of broadcasting user-defined
    event messages to scripted objects. One approach is the `SendMessage(…)` method,
    which, when sent to a GameObject, will check every `Monobehaviour` scripted component
    and execute the named method if its parameters match. However, this involves an
    inefficient technique known as **reflection**. C# offers another event message
    approach known as **delegates and events**, which we describe and implement in
    this recipe. Delegates and events work in a similar way to `SendMessage(…)`, but
    are much more efficient since Unity maintains a defined list of which objects
    are *listening* to the broadcast events. `SendMessage(…)` should be avoided if
    performance is important, since it means that Unity has to analyze each scripted
    object (*reflect over* the object) to see whether there is a public method corresponding
    to the message that has been sent; this is much slower than using delegates and
    events.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件可以根据可见性、距离或碰撞来触发时，我们可以使用如 `OnTriggerExit` 和 `OnBecomeInvisible` 这样的事件，正如在前面的一些食谱中所描述的。当事件可以根据时间段来触发时，我们可以使用协程，正如本章其他食谱中所描述的。然而，某些事件是每个游戏情况独有的，C#
    提供了多种方法将用户定义的事件消息广播到脚本对象。一种方法是 `SendMessage(…)` 方法，当发送到 `GameObject` 时，将检查每个 `Monobehaviour`
    脚本组件，如果其参数匹配，则执行命名方法。然而，这涉及一种称为 **反射** 的低效技术。如果性能很重要，应避免使用 `SendMessage(…)`，因为这意味着
    Unity 必须分析每个脚本对象（对对象进行 **反射**）以查看是否存在与发送的消息相对应的公共方法；这比使用委托和事件慢得多。
- en: Delegates and events implement the **publish-subscribe design pattern** (**pubsub**).
    This is also known as the **observer** design pattern. Objects can subscribe one
    of their methods to receive a particular type of event message from a particular
    publisher. In this recipe, we'll have a manager class that will publish new events
    when UI buttons are clicked. We'll create some UI objects, some of which **subscribe**
    to the color change events, so that each time a color change event is published,
    subscribed UI objects receive the event message and change their color accordingly.
    C# publisher objects don't have to worry about how many objects subscribe to them
    at any point in time (it could be none or 1,000!); this is known as **loose coupling**,
    since it allows different code components to be written (and maintained) independently
    and is a desirable feature of object-oriented code.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 委托和事件实现了**发布-订阅设计模式**（**pubsub**）。这也被称为**观察者**设计模式。对象可以将它们的方法之一订阅到接收特定发布者特定类型的事件消息。在这个菜谱中，我们将有一个管理类，当UI按钮被点击时，它将发布新的事件。我们将创建一些UI对象，其中一些对象**订阅**颜色更改事件，以便每次发布颜色更改事件时，订阅的UI对象都会接收到事件消息并相应地更改它们的颜色。C#发布者对象不必担心在任何时候有多少对象订阅它们（可能是没有或1000个！）；这被称为**松耦合**，因为它允许独立编写（和维护）不同的代码组件，并且是面向对象代码的一个理想特性。
- en: How to do it...
  id: totrans-275
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To implement delegates and events, follow these steps:'
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 要实现委托和事件，请按照以下步骤操作：
- en: Create a new 2D project.
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的2D项目。
- en: 'Add the following C# script class **ColorManager** to the **Main Camera**:'
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本类**ColorManager**添加到**主相机**：
- en: '[PRE14]'
  id: totrans-279
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Create two UI **Image** objects and two UI **Text** objects. Position one **Image**
    and **Text** object to the lower left of the screen and position the other to
    the lower right of the screen. Make the text on the lower left read **Not listening**,
    and make the text on the right of the screen read **I am listening**. For good
    measure, add a **Slider** UI object in the top right of the screen.
  id: totrans-280
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建两个UI**图像**对象和两个UI**文本**对象。将一个**图像**和**文本**对象定位在屏幕的左下角，将另一个定位在屏幕的右下角。使左下角的文本读作**未监听**，使屏幕右边的文本读作**我在监听**。为了保险起见，在屏幕右上角添加一个**滑块**UI对象。
- en: Create three UI buttons in the top left of the screen, named **Button-GREEN**,
    **Button-BLUE**, and **Button-RED**, with corresponding text reading `make things
    <color=green>GREEN</color>`, `make things <color=blue>BLUE</color>`, and `make
    things <color=red>RED</color>`.![How to do it...](img/1362OT_11_22.jpg)
  id: totrans-281
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在屏幕左上角创建三个UI按钮，分别命名为**Button-GREEN**、**Button-BLUE**和**Button-RED**，对应的文本分别为`make
    things <color=green>GREEN</color>`、`make things <color=blue>BLUE</color>`和`make
    things <color=red>RED</color>`。![如何操作...](img/1362OT_11_22.jpg)
- en: 'Attach the following C# script class `ColorChangeListenerImage` to both the
    lower-right **Image** and also the **Slider**:'
  id: totrans-282
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本类`ColorChangeListenerImage`附加到右下角的**图像**和**滑块**：
- en: '[PRE15]'
  id: totrans-283
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Attach the following C# script class `ColorChangeListenerText` to the **I am
    listening Text** UI object:'
  id: totrans-284
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本类`ColorChangeListenerText`附加到**我在监听 Text** UI对象：
- en: '[PRE16]'
  id: totrans-285
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: With button-**GREEN** selected in the **Hierarchy**, add a new **On Click()**
    event for this button, dragging the **Main Camera** as the target GameObject and
    selecting public function `BUTTON_ACTION_make_green()`. Do the same for the **BLUE**
    and **RED** buttons with functions `BUTTON_ACTION_make_blue()` and `BUTTON_ACTION_make_red()`
    respectively.
  id: totrans-286
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**层次结构**中选择**绿色**按钮，为该按钮添加一个新的**点击()**事件，将**主相机**作为目标GameObject，并选择公共函数`BUTTON_ACTION_make_green()`。对**蓝色**和**红色**按钮分别使用函数`BUTTON_ACTION_make_blue()`和`BUTTON_ACTION_make_red()`执行相同的操作。
- en: Run the game. When you click a change color button, the three UI objects on
    the right of the screen show all changes to the corresponding color, while the
    two UI objects at the bottom left of the screen remain in the default **White**
    color.
  id: totrans-287
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏。当你点击更改颜色按钮时，屏幕右侧的三个UI对象会显示所有对应颜色的更改，而屏幕左下角的两个UI对象将保持默认的**白色**颜色。
- en: How it works...
  id: totrans-288
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: First, let's consider what we want to happen—we want the right-hand **Image**,
    **Slider**, and **Text** objects to change their color when they receive an event
    message `OnChangeColor()` with a new color argument.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们考虑我们想要发生的事情——我们希望右侧的**图像**、**滑块**和**文本**对象在接收到带有新颜色参数的事件消息`OnChangeColor()`时改变它们的颜色。
- en: This is achieved by each object having an instance of the appropriate `ColorChangeListener`
    class that subscribes their `OnChangeColor()` method to listen for color change
    events published from the `ColorManager` class. Since both the **Image** and **Slider**
    objects have an image component whose color will change, they have scripted components
    of our C# class `ColorChangeListenerImage`, while the **Text** object needs a
    different class since it is the color of the text component whose color is to
    be changed (so we add an instance of C# scripted component `ColorChangeListenerText`
    to the **Text** UI object). So, as we can see, different objects may respond to
    receiving the same event messages in ways appropriate to each different object.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过每个对象都有一个适当的`ColorChangeListener`类的实例来实现的，该实例将它们的`OnChangeColor()`方法订阅到监听从`ColorManager`类发布的颜色更改事件。由于**Image**和**Slider**对象都有一个颜色会改变的形象组件，因此它们有我们C#类的脚本组件`ColorChangeListenerImage`，而**Text**对象需要一个不同的类，因为要改变颜色的是文本组件的颜色（因此我们在**Text**
    UI对象中添加了一个C#脚本组件`ColorChangeListenerText`）。所以，正如我们所看到的，不同的对象可能会以适合每个不同对象的方式响应接收相同的事件消息。
- en: Since our scripted objects may be disabled and enabled at different times, each
    time a scripted `ColorChangeListener` object is enabled (such as when its GameObject
    parent is instantiated), its `OnChangeColor()` method is added (`+=`) to the list
    of those subscribed to listen for color change events, likewise each time `ColorChangeListenerImage/Text`
    objects are disabled, those methods are removed (`-=`) from the list of event
    subscribers.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们的脚本对象可能在不同的时间启用和禁用，因此每次脚本`ColorChangeListener`对象被启用（例如，当其GameObject父对象被实例化时），其`OnChangeColor()`方法就会被添加到订阅监听颜色更改事件的列表中（同样，每次`ColorChangeListenerImage/Text`对象被禁用时，这些方法就会从事件订阅者列表中移除）。
- en: When a `ColorChangeListenerImage/Text` object receives a color change message,
    its subscribed `OnChangeColor()` method is executed and the color of the appropriate
    component is changed to the received `Color` value (`green`/`red`/`blue`).
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 当`ColorChangeListenerImage/Text`对象接收到颜色更改消息时，其订阅的`OnChangeColor()`方法将被执行，并且相应组件的颜色将更改为接收到的`Color`值（`green`/`red`/`blue`）。
- en: The `ColorManager` class has a public class (static) variable `changeColorEvent`,
    which defines an *event* to which Unity maintains a dynamic list of all the subscribed
    object methods. It is to this event that `ColorChangeListenerImage/Text` objects
    register or deregister their methods.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorManager`类有一个公共类（静态）变量`changeColorEvent`，它定义了一个*事件*，Unity维护一个动态列表，其中包含所有订阅的对象方法。`ColorChangeListenerImage/Text`对象就是向这个事件注册或注销它们的方法的。'
- en: 'The `ColorManager` class displays three buttons to the user to change all listening
    objects to a specific color: green, red, and blue. When a button is clicked, the
    `changeColorEvent` is told to publish a new event, passing a corresponding `Color`
    argument to all subscribed object methods.'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorManager`类向用户显示三个按钮，以将所有监听对象更改为特定颜色：绿色、红色和蓝色。当点击按钮时，`changeColorEvent`会被告知发布一个新的事件，并将相应的`Color`参数传递给所有订阅的对象方法。'
- en: The `ColorManager` class declares a *Delegate* named `ColorChangeHandler`. Delegates
    define the return type (in this case, `void`) and argument *signature* of methods
    that can be delegated (subscribed) to an event. In this case, methods must have
    the argument signature of a single parameter of type `Color`. Our `OnChangeColor()`
    method in classes `ColorChangeListenerImage/Text` match this argument signature
    and so are permitted to subscribe to the `changeColorEvent` in the `ColorManager`
    class.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: '`ColorManager`类声明了一个名为`ColorChangeHandler`的*委托*。委托定义了可以委托（订阅）到事件的方法的返回类型（在这种情况下，`void`）和参数*签名*。在这种情况下，方法必须具有单个参数类型为`Color`的参数签名。我们类`ColorChangeListenerImage/Text`中的`OnChangeColor()`方法与这个参数签名相匹配，因此可以订阅`ColorManager`类中的`changeColorEvent`。'
- en: Note
  id: totrans-296
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: An easy to understand video about Unity delegates and events can be found
    at [http://www.youtube.com/watch?v=N2zdwKIsXJs](http://www.youtube.com/watch?v=N2zdwKIsXJs).'
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：您可以在[http://www.youtube.com/watch?v=N2zdwKIsXJs](http://www.youtube.com/watch?v=N2zdwKIsXJs)找到关于Unity委托和事件的简单易懂的视频。
- en: See also
  id: totrans-298
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the *Cache GameObject and component references to avoid expensive lookups*
    recipe in this chapter for more information.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，有关更多信息，请参阅*缓存GameObject和组件引用以避免昂贵的查找*配方。
- en: Executing methods regularly but independent of frame rate with coroutines
  id: totrans-300
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协程定期执行方法，但与帧率无关
- en: '**Optimization principal 3**: Call methods as few times as possible.'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化原则3**：尽可能少地调用方法。'
- en: While it is very simple to put logic into `Update()` and have it regularly executed
    for each frame, we can improve game performance by executing logic as rarely as
    possible. So, if we can get away with only checking for a situation every 5 seconds,
    then great performance savings can be made to move that logic out of `Update()`.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然将逻辑放入`Update()`并使其为每个帧定期执行非常简单，但我们可以通过尽可能少地执行逻辑来提高游戏性能。所以，如果我们能够每5秒只检查一次情况，那么就可以通过将逻辑移出`Update()`来节省大量性能。
- en: A **coroutine** is a function that can suspend its execution until a `yield`
    action has completed. One kind of yield action simply waits for a given number
    of seconds. In this recipe, we use coroutines and yield to show how a method can
    be only executed every 5 seconds; this could be useful for NPCs to decide whether
    they should randomly *wake up* or perhaps choose a new location to start moving
    toward.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: '**协程**是一个可以暂停其执行直到`yield`动作完成的函数。一种yield动作简单地等待给定数量的秒数。在这个菜谱中，我们使用协程和yield来展示一个方法如何每5秒只执行一次；这可能对NPC决定是否随机*醒来*或选择一个新的位置开始移动很有用。'
- en: '![Executing methods regularly but independent of frame rate with coroutines](img/1362OT_11_23.jpg)'
  id: totrans-304
  prefs: []
  type: TYPE_IMG
  zh: '![使用协程定期执行但独立于帧率的执行方法](img/1362OT_11_23.jpg)'
- en: How to do it...
  id: totrans-305
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To implement methods at regular intervals independent of the frame rate, follow
    these steps:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 要在帧率独立的情况下定期执行方法，请遵循以下步骤：
- en: 'Add the following C# script class `TimedMethod` to the **Main Camera**:'
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本类`TimedMethod`添加到**主相机**：
- en: '[PRE17]'
  id: totrans-308
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: How it works...
  id: totrans-309
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: When the `Start()` message is received, the `Tick()` method is started as a
    coroutine. The `Tick()` method sets the delay between executions (variable `delaySeconds`)
    to 5 seconds. An infinite loop is then started, where the method does its actions
    (in this case, just printing out the time); finally, a `yield` instruction is
    executed, which causes the method to suspend execution for the given delay of
    5 seconds. After the yield instruction has completed, the loop will continue executing
    once again and so on. What is important to understand when working with coroutines
    is that the method will *resume executing* from the same state it yielded.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当接收到`Start()`消息时，`Tick()`方法以协程的形式启动。`Tick()`方法将执行之间的延迟（变量`delaySeconds`）设置为5秒。然后启动一个无限循环，其中方法执行其操作（在这种情况下，只是打印出时间）；最后，执行一个`yield`指令，这会导致方法暂停执行5秒。在`yield`指令完成后，循环将再次继续执行，依此类推。在处理协程时，重要的是要理解方法将从它yield的相同状态恢复执行。
- en: You may have noticed that *there are no* `Update()` *or* `FixedUpdate()` *methods
    at all*. So, although our game has logic being regularly executed, in this example,
    there is no logic that has to be executed every frame—fantastic!
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到*根本没有任何*`Update()`或`FixedUpdate()`方法。所以，尽管我们的游戏有定期执行的逻辑，但在本例中，没有必须每帧执行的逻辑——太棒了！
- en: There's more...
  id: totrans-312
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some details you don''t want to miss:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你不希望错过的细节：
- en: Have different actions happening at different intervals
  id: totrans-314
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 让不同的动作在不同的间隔发生
- en: Coroutines can be used to have different kinds of logic being executed at different
    regular intervals. So, logic that needs frame-by-frame execution goes into `Update()`,
    and logic that works fine once or twice a second might go into a coroutine with
    a 0.5-second delay; logic that can get away with less occasional updating can
    go into another coroutine with a 2- or 5-second delay, and so on. Effective and
    noticeable performance improvements can be found by carefully analyzing (and testing)
    different game logic to identify the *least frequent execution* that is still
    acceptable.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 协程可用于在不同的常规间隔执行不同类型的逻辑。因此，需要逐帧执行的逻辑放入`Update()`，而每秒或每两秒执行一次即可的逻辑可能放入一个延迟为0.5秒的协程中；可以更少地偶尔更新的逻辑可以放入另一个延迟为2秒或5秒的协程中，依此类推。通过仔细分析（并测试）不同的游戏逻辑，可以找到仍然可接受的*最不频繁执行*，从而找到有效和明显的性能提升。
- en: See also
  id: totrans-316
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: Refer to the next recipe for more information.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 参考下一道菜谱以获取更多信息。
- en: Spreading long computations over several frames with coroutines
  id: totrans-318
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用协程在多个帧上分散长计算
- en: '**Optimization principal 3**: Call methods as few times as possible.'
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化原则3**：尽可能少地调用方法。'
- en: Coroutines allow us to write asynchronous code—we can ask a method to go off
    and calculate something, but the rest of the game can keep on running without
    having to wait for that calculation to end. Or, we can call a coroutine method
    for each frame from `Update()` and organize the method to complete part of a complex
    calculation each time it is called.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 协程允许我们编写异步代码——我们可以要求一个方法去计算某件事，而游戏的其他部分可以继续运行，无需等待该计算结束。或者，我们可以在`Update()`方法中调用协程方法，并组织每次调用时完成复杂计算的一部分。
- en: Note that coroutines are not *threads*, but they are very handy in that each
    can progress each frame further. It also allows us to write code that does not
    have to wait for certain methods to complete before another can begin.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，协程不是**线程**，但它们非常方便，因为每个协程都可以在每个帧上进一步推进。它还允许我们编写不需要等待某些方法完成就可以开始另一个方法的代码。
- en: When games start requiring complex computations, such as for artificial intelligence
    reasoning, it may not be possible to maintain acceptable game performance when
    trying to complete all calculations in a single frame—this is where coroutines
    can be an excellent solution.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
  zh: 当游戏开始需要复杂的计算，例如人工智能推理时，在尝试在一个帧内完成所有计算时，可能无法维持可接受的游戏性能——这就是协程可以成为优秀解决方案的地方。
- en: This recipe illustrates how a complex calculation can be structured into several
    pieces, each to be completed one frame at a time.
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 这个示例说明了一个复杂计算如何被结构化为几个部分，每个部分一次完成一个帧。
- en: Note
  id: totrans-324
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: An excellent description of coroutines (and other Unity topics) can be
    found on Ray Pendergraph''s wikidot website [http://raypendergraph.wikidot.com/unity-developer-s-notes#toc6](http://raypendergraph.wikidot.com/unity-developer-s-notes#toc6).'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：关于协程（以及其他Unity主题）的出色描述可以在Ray Pendergraph的wikidot网站上找到 [http://raypendergraph.wikidot.com/unity-developer-s-notes#toc6](http://raypendergraph.wikidot.com/unity-developer-s-notes#toc6)。
- en: How to do it...
  id: totrans-326
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做...
- en: 'To spread computations over several frames, follow these steps:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 要将计算分散到几个帧上，请按照以下步骤操作：
- en: 'Add the following script class `SegmentedCalculation` to the **Main Camera**:'
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下脚本类`SegmentedCalculation`添加到**主摄像机**：
- en: '[PRE18]'
  id: totrans-329
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Run the game, and you'll see how the search for highest and lowest values in
    the array progresses in steps, avoiding undesirable delays between each new frame.![How
    to do it...](img/1362OT_11_24.jpg)
  id: totrans-330
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏，你会看到数组中最高和最低值的搜索是如何逐步进行的，避免了每个新帧之间的不希望出现的延迟。![如何做...](img/1362OT_11_24.jpg)
- en: How it works...
  id: totrans-331
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `randomNumbers` array of random integers is created in `Awake()`. Then,
    the `FindMinMax()` method is started as a coroutine. The size of the array is
    defined by constant `ARRAY_SIZE`, and the number of elements to process each frame
    by `SEGMENT_SIZE`.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 随机整数数组`randomNumbers`在`Awake()`中创建。然后，`FindMinMax()`方法以协程的方式启动。数组的大小由常量`ARRAY_SIZE`定义，每帧要处理的元素数量由`SEGMENT_SIZE`定义。
- en: The `FindMinMax()` method sets initial values for *min* and *max* and begins
    to loop through the array. If the current index is divisible by the `SEGMENT_SIZE`
    (remainder 0), then we make the method display the current frame number and variable
    values and suspend execution for one frame with a `yield null` statement. For
    every loop, the value for the current array index is compared with `min` and `max`,
    and those values are updated if a new minimum or maximum has been found. When
    the loop is completed, the scripted component disables itself.
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: '`FindMinMax()`方法为`min`和`max`设置初始值，并开始遍历数组。如果当前索引可以被`SEGMENT_SIZE`整除（余数为0），则我们让该方法显示当前帧号和变量值，并使用`yield
    null`语句暂停执行一个帧。对于每个循环，当前数组索引的值与`min`和`max`进行比较，如果找到新的最小值或最大值，则更新这些值。当循环完成后，脚本组件会禁用自己。'
- en: There's more...
  id: totrans-334
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some details you don''t want to miss:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 一些您不想错过的细节：
- en: Retrieving the complete Unity log text files from your system
  id: totrans-336
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从您的系统中检索完整的Unity日志文本文件
- en: 'As well as seeing log texts in the **Console** panel, you can also access the
    Unity editor log text file as follows:'
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 除了在**控制台**面板中查看日志文本外，您还可以按照以下方式访问Unity编辑器日志文本文件：
- en: 'Mac:'
  id: totrans-338
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Mac:'
- en: '`~/Library/Logs/Unity/Editor.log`'
  id: totrans-339
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`~/Library/Logs/Unity/Editor.log`'
- en: And access through the standard Console app
  id: totrans-340
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过标准控制台应用程序访问
- en: 'Windows:'
  id: totrans-341
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'Windows:'
- en: '`C:\Users\username\AppData\Local\Unity\Editor\Editor.log`'
  id: totrans-342
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`C:\Users\username\AppData\Local\Unity\Editor\Editor.log`'
- en: Mobile devices (see the Unity documentation for accessing device log data)![Retrieving
    the complete Unity log text files from your system](img/1362OT_11_25.jpg)
  id: totrans-343
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 移动设备（请参阅Unity文档以访问设备日志数据）![从您的系统中检索完整的Unity日志文本文件](img/1362OT_11_25.jpg)
- en: For more information about Unity logs files, see the online manual at [http://docs.unity3d.com/Manual/LogFiles.html](http://docs.unity3d.com/Manual/LogFiles.html).
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 有关 Unity 日志文件的更多信息，请参阅在线手册 [http://docs.unity3d.com/Manual/LogFiles.html](http://docs.unity3d.com/Manual/LogFiles.html)。
- en: See also
  id: totrans-345
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Refer to the *Executing methods regularly but independent of frame rate with
    coroutines* recipe in this chapter for more information.
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 有关本章中 *定期执行但与帧率无关的方法* 菜谱的更多信息，请参阅。
- en: Evaluating performance by measuring max and min frame rates (FPS)
  id: totrans-347
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过测量最大和最小帧率（FPS）来评估性能
- en: '**Optimization principal 4**: Use performance data to drive design and coding
    decisions.'
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化原则 4**：使用性能数据来驱动设计和编码决策。'
- en: A useful raw measurement of game performance is the maximum and minimum frame
    rate for a section of a game. In this recipe, we make use of a Creative Commons
    **Frames Per Second** (**FPS**) calculation script to record the maximum and minimum
    frame rates for a game performing mathematics calculations for each frame.
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 游戏性能的一个有用的原始测量是游戏某部分的最高和最低帧率。在这个菜谱中，我们使用 Creative Commons 的 **每秒帧数**（**FPS**）计算脚本来记录进行每帧数学计算的游戏的最高和最低帧率。
- en: '![Evaluating performance by measuring max and min frame rates (FPS)](img/1362OT_11_26.jpg)'
  id: totrans-350
  prefs: []
  type: TYPE_IMG
  zh: '![通过测量最大和最小帧率（FPS）来评估性能](img/1362OT_11_26.jpg)'
- en: Getting ready
  id: totrans-351
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have provided C# script `FPSCounter.cs` in the `1362_11_12`
    folder. This file is the one we have modified to include the maximum and minimum
    values based on the **Do-It-Yourself** (**DIY**) frame rate calculation script
    from Annop "Nargus" Prapasapong, kindly published under Creative Commons on the
    Unify wiki at [http://wiki.unity3d.com/index.php?title=FramesPerSecond](http://wiki.unity3d.com/index.php?title=FramesPerSecond).
  id: totrans-352
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们在 `1362_11_12` 文件夹中提供了 C# 脚本 `FPSCounter.cs`。这是我们修改过的文件，它包括了基于 Annop
    "Nargus" Prapasapong 的 **Do-It-Yourself**（**DIY**）帧率计算脚本的最高和最低值，该脚本已友好地发布在 Creative
    Commons 下的 Unify wiki 上 [http://wiki.unity3d.com/index.php?title=FramesPerSecond](http://wiki.unity3d.com/index.php?title=FramesPerSecond)。
- en: How to do it...
  id: totrans-353
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To calculate and record the maximum and minimum FPS, follow these steps:'
  id: totrans-354
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算和记录最大和最小 FPS，请按照以下步骤操作：
- en: Start a new project, and import the `FPSCounter.cs` script.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的项目，并导入 `FPSCounter.cs` 脚本。
- en: Add the `FPSCounter` script class to the **Main Camera**.
  id: totrans-356
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `FPSCounter` 脚本类添加到 **主相机**。
- en: 'Add the following C# script class `SomeCalculations` to the **Main Camera**:'
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 C# 脚本类 `SomeCalculations` 添加到 **主相机**：
- en: '[PRE19]'
  id: totrans-358
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Run the game for 20 to 30 seconds. On the screen, you should see the current
    average and the maximum and minimum frame rates displayed.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏 20 到 30 秒。在屏幕上，你应该能看到当前的平均帧率以及最大和最小帧率显示。
- en: Stop the game running. You should now see in the **Console** a summary message
    stating the max and min frames per second, as shown in the following screenshot:![How
    to do it...](img/1362OT_11_27.jpg)
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止游戏运行。你现在应该在 **控制台** 中看到一个总结信息，显示每秒最大和最小帧数，如下截图所示：![如何操作...](img/1362OT_11_27.jpg)
- en: How it works...
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `SomeCalculations` script ensures that we make Unity do something for each
    frame, in that it performs lots of calculations when the `Update()` method is
    called for each frame. There is an outer loop (loop counter `i`) of public variable
    `outerLoopIterations` iterations (which we set to `20`), and an inner loop (loop
    counter `j`), which is a random number of iterations between 2, and the value
    of public variable `innerLoopMaxIterations` (which we set to `100`).
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: '`SomeCalculations` 脚本确保我们让 Unity 为每一帧做些事情，它在每一帧调用 `Update()` 方法时执行大量计算。有一个外循环（循环计数器
    `i`）是公共变量 `outerLoopIterations` 的迭代次数（我们将其设置为 `20`），还有一个内循环（循环计数器 `j`），它是介于 2
    和公共变量 `innerLoopMaxIterations`（我们将其设置为 `100`）之间的随机迭代次数。'
- en: The work for the calculations of average **Frames Per Second** (**FPS**) is
    performed by the `FPSCounter` script, which runs coroutine method `FPS()` at the
    chosen frequency (which we can change in the **Inspector**). Each time the `FPS()`method
    executes, it recalculates the average frames per second, updates the max and minimum
    values if appropriate, and, if the **Display While Running** checkbox was ticked,
    then a **GUIText** object on screen is updated with a message of the average,
    max, and min FPS.
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
  zh: 计算平均 **每秒帧数**（**FPS**）的工作由 `FPSCounter` 脚本执行，该脚本在选择的频率下运行协程方法 `FPS()`（我们可以在
    **检查器** 中更改）。每次 `FPS()` 方法执行时，它都会重新计算平均每秒帧数，如果适当的话，更新最大和最小值，如果勾选了 **运行时显示** 复选框，那么屏幕上的
    **GUIText** 对象会更新为平均、最大和最小 FPS 的消息。
- en: Finally, the `OnApplicationQuit()` method in script class `FPSCounter` is executed
    when the game is terminated and prints to the console the summary max/min FPS
    message.
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当游戏结束时，脚本类`FPSCounter`中的`OnApplicationQuit()`方法会被执行，并将最大/最小FPS摘要信息打印到控制台。
- en: There's more...
  id: totrans-365
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: 'Some details you don''t want to miss:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你不希望错过的细节：
- en: Turn off runtime display to reduce FPS processing
  id: totrans-367
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关闭运行时显示以减少FPS处理
- en: We have added an option so that you can turn off the runtime display, which
    will reduce the processing required for the FPS calculations. You just have to
    un-check the **Display While Running** checkbox in the **Inspector**.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个选项，允许你关闭运行时显示，这将减少FPS计算所需的处理。你只需在**检查器**中取消选中**运行时显示**复选框即可。
- en: '![Turn off runtime display to reduce FPS processing](img/1362OT_11_28.jpg)'
  id: totrans-369
  prefs: []
  type: TYPE_IMG
  zh: '![关闭运行时显示以减少FPS处理](img/1362OT_11_28.jpg)'
- en: See also
  id: totrans-370
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter for more information:'
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下食谱以获取更多信息：
- en: '*Identifying performance bottlenecks with the Unity performance Profiler*'
  id: totrans-372
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Unity性能分析器识别性能瓶颈*'
- en: '*Identifying performance bottlenecks with Do-It-Yourself. performance profiling*'
  id: totrans-373
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Do-It-Yourself性能分析器识别性能瓶颈*'
- en: Identifying performance bottlenecks with the Unity performance Profiler
  id: totrans-374
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Unity性能分析器识别性能瓶颈
- en: '**Optimization principal 4**: Use performance data to drive design and coding
    decisions.'
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化原则4**：使用性能数据来驱动设计和编码决策。'
- en: As well as following general asset and code design principals, which we know
    ought to lead to improved performance, we should be aware that each game is different
    and that, in reality, the only way to know which design decisions affect performance
    the most is to collect and analyze runtime performance data. While a raw **Frames
    Per Second** (**FPS**) measurement is useful, to choose between different decisions
    having detailed information about the processing requirements for rendering and
    code execution for each frame is invaluable.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 除了遵循一般的资源和代码设计原则，我们知道这些原则应该能提高性能之外，我们还应该意识到每个游戏都是不同的，而在现实中，唯一知道哪些设计决策对性能影响最大的是收集和分析运行时性能数据。虽然原始的**每秒帧数**（**FPS**）测量是有用的，但在选择不同的决策时，了解每个帧的渲染和代码执行的处理需求是极其宝贵的。
- en: The Unity 5 **Profiler** offers a detailed breakdown of code and rendering processing
    requirements, as well as processing required by GPU, audio, and both 2D and 3D
    physics. Perhaps the most useful, it allows programmers to explicitly record data
    for named code segments. We will name our profile `MATT_SomeCalculations` and
    record and examine frame-by-frame processing requirements for our calculations.
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 5 **性能分析器**提供了代码和渲染处理需求的详细分解，以及GPU、音频以及2D和3D物理所需的处理。也许最有用的一点是，它允许程序员明确记录命名代码段的数据。我们将命名我们的配置文件为`MATT_SomeCalculations`，并记录和检查我们计算每帧的处理需求。
- en: '![Identifying performance bottlenecks with the Unity performance Profiler](img/1362OT_11_29.jpg)'
  id: totrans-378
  prefs: []
  type: TYPE_IMG
  zh: '![使用Unity性能分析器识别性能瓶颈](img/1362OT_11_29.jpg)'
- en: How to do it...
  id: totrans-379
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To record processing requirements using the Unity **Profiler**, follow these
    steps:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Unity **性能分析器**记录处理需求，请按照以下步骤操作：
- en: Start a new 2D project.
  id: totrans-381
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新的2D项目。
- en: Open the **Profiler** window from the **Window** menu and ensure that the **Record**
    option is selected, and that the **Scripts** performance data is being collected,
    as shown in the following screenshot:![How to do it...](img/1362OT_11_30.jpg)
  id: totrans-382
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**窗口**菜单打开**性能分析器**窗口，确保已选中**记录**选项，并且正在收集**脚本**性能数据，如下截图所示：![如何操作...](img/1362OT_11_30.jpg)
- en: 'Add the following C# script class `ProfileCalculations` to the **Main Camera**:'
  id: totrans-383
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本类`ProfileCalculations`添加到**主摄像机**：
- en: '[PRE20]'
  id: totrans-384
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Run the game for 20 to 30 seconds.
  id: totrans-385
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏20到30秒。
- en: Stop the game running. You should now see in the **Profiler** panel details
    of the breakdown of processing required for the selected frame—each of the jagged
    lines in the top right of the **Profiler** panel represents the collected data
    for a frame.
  id: totrans-386
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止运行的游戏。你现在应该在**性能分析器**面板中看到所选帧所需处理细节的分解——**性能分析器**面板右上角的每一条锯齿形线条代表一个帧收集的数据。
- en: 'View data for different frames by dragging the white line to a different horizontal
    position—the current frame and the total number of frames are shown at the top
    right in the form **Frame: frame / totalFrames**.'
  id: totrans-387
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过拖动白色线条到不同的水平位置来查看不同帧的数据——当前帧和总帧数显示在右上角，形式为**帧：frame / totalFrames**。
- en: Since we have named a code profile sample, prefixed with **MATT**, we can limit
    the display of data to only samples containing that word. In the search text box
    (next to the little magnifying glass,) type `MATT`, and you should now see just
    a single row of profile data for our sample **MATT_calculations**. We can see
    that for frame 83, our code took up 1.2 percent of the processing for that frame.![How
    to do it...](img/1362OT_11_31.jpg)
  id: totrans-388
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于我们给代码配置样本命名，并以**MATT**为前缀，我们可以限制只显示包含该单词的样本数据。在搜索文本框（位于小放大镜旁边）中输入`MATT`，你现在应该只看到一行关于我们的样本**MATT_calculations**的配置数据。我们可以看到，在第83帧，我们的代码占用了该帧处理时间的1.2%。![如何操作...](img/1362OT_11_31.jpg)
- en: How it works...
  id: totrans-389
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: The `ProfileCalculations` script ensures that we make Unity do something for
    each frame; it does lots of calculations with an inner and outer loop, just like
    in the previous FPS recipe.
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: '`ProfileCalculations`脚本确保Unity为每一帧执行一些操作；它使用内循环和外循环进行大量计算，就像在之前的FPS食谱中一样。'
- en: The two important statements are those that mark the beginning and ending of
    a named code sample to be recorded and presented in the **Profiler**. The `Profiler.BeginSample("MATT_calculations")`
    statement starts our named profile and it is ended with the `EndSample()` statement.
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 两个重要的语句是标记要记录和展示在**Profiler**中的命名代码样本的开始和结束。`Profiler.BeginSample("MATT_calculations")`语句开始我们的命名配置，它通过`EndSample()`语句结束。
- en: Using an eye-catching prefix allows us to easily isolate our named code profile
    for analysis, using the search text box in the **Profiler** panel.
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 使用引人注目的前缀，我们可以轻松地隔离我们的命名代码配置以进行分析，使用**Profiler**面板中的搜索文本框。
- en: See also
  id: totrans-393
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考信息
- en: 'Refer to the following recipes in this chapter for more information:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下食谱以获取更多信息：
- en: '*Evaluating performance by measuring max and min frame rates (FPS)*'
  id: totrans-395
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过测量最大和最小帧率（FPS）来评估性能*'
- en: '*Identifying performance bottlenecks with Do-It-Yourself performance profiling*'
  id: totrans-396
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Do-It-Yourself性能配置识别性能瓶颈*'
- en: Identifying performance "bottlenecks" with Do-It-Yourself performance profiling
  id: totrans-397
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Do-It-Yourself性能配置识别性能“瓶颈”
- en: '**Optimization principal 4**: Use performance data to drive design and coding
    decisions.'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化原则4**：使用性能数据来驱动设计和编码决策。'
- en: The Unity 5 performance profiler is great, but there may be times where we wish
    to have completed control over the code we are running and how it displays or
    logs data. In this recipe, we explore how to use a freely available script for
    DIY performance profiling. While it's not quite as fancy as the graphical and
    detailed profiling of the performance profiler from Unity, it still provides low-level
    data about the time required for each frame by named parts of scripts, which is
    sufficient for making code design decisions to improve game performance.
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 5性能配置器很棒，但有时我们可能希望对正在运行的代码以及它如何显示或记录数据有完全的控制。在这个食谱中，我们探讨了如何使用一个免费可用的脚本进行DIY性能配置。虽然它不像Unity性能配置器的图形和详细配置那样花哨，但它仍然提供了关于脚本命名部分所需时间的低级数据，这对于做出改进游戏性能的代码设计决策是足够的。
- en: '![Identifying performance "bottlenecks" with Do-It-Yourself performance profiling](img/1362OT_11_32.jpg)'
  id: totrans-400
  prefs: []
  type: TYPE_IMG
  zh: '![使用Do-It-Yourself性能配置识别性能“瓶颈”](img/1362OT_11_32.jpg)'
- en: Getting ready
  id: totrans-401
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have provided C# script `Profile.cs` in the `1362_11_14`
    folder. This is the DIY profiling script from Michael Garforth, kindly published
    under *Creative Commons* on the Unify Wiki at [http://wiki.unity3d.com/index.php/Profiler](http://wiki.unity3d.com/index.php/Profiler).
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个食谱，我们在`1362_11_14`文件夹中提供了C#脚本`Profile.cs`。这是Michael Garforth的DIY配置脚本，他友好地将其发布在Unify
    Wiki上的*Creative Commons*下，网址为[http://wiki.unity3d.com/index.php/Profiler](http://wiki.unity3d.com/index.php/Profiler)。
- en: How to do it...
  id: totrans-403
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To record processing requirements using Do-It-Yourself code profiling, follow
    these steps:'
  id: totrans-404
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用Do-It-Yourself代码配置来记录处理需求，请按照以下步骤操作：
- en: Start a new project, and import the `Profile.cs` script.
  id: totrans-405
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 开始一个新项目，并导入`Profile.cs`脚本。
- en: 'Add the following C# script class `DIYProfiling` to the **Main Camera**:'
  id: totrans-406
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本类`DIYProfiling`添加到**主摄像机**：
- en: '[PRE21]'
  id: totrans-407
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Run the game for a few seconds.
  id: totrans-408
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏几秒钟。
- en: Stop the game running. You should now see in the **Console** a summary message
    stating total processing time for our named Profile, average time, and number
    of iterations, and also the total time for which the game was run.
  id: totrans-409
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 停止游戏运行。你现在应该在**控制台**中看到一个总结消息，说明我们命名配置的总处理时间、平均时间和迭代次数，以及游戏运行的总时间。
- en: How it works...
  id: totrans-410
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see, the script is almost identical to that used with the Unity profiling
    in the previous recipe. Rather than calling the Unity **Profiler**, we call static
    (class) methods of Michael Garforth's `Profile` class.
  id: totrans-411
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，脚本几乎与之前配方中使用的 Unity 性能分析脚本相同。我们不是调用 Unity 的 **Profiler**，而是调用 Michael Garforth
    的 `Profile` 类的静态（类）方法。
- en: We call `Profile` class methods `StartProfile(…)` and `EndProfile(…)` with the
    string name for what is to be analyzed (in this example, `MATT_calculations`).
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `Profile` 类方法 `StartProfile(…)` 和 `EndProfile(…)`，并传入要分析内容的字符串名称（在本例中为
    `MATT_calculations`）。
- en: Finally, the `OnApplicationQuit()`method is executed when the game is terminated,
    calling the `PrintResuls()` method of the `Profile` class, which prints to the
    console the summary performance information.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，当游戏终止时，会执行 `OnApplicationQuit()` 方法，调用 `Profile` 类的 `PrintResults()` 方法，该方法将性能摘要信息打印到控制台。
- en: The `Profile` class records how many times, and how long between Start and End,
    each named profile is called, outputting summary information about these executions
    when `PrintResuls()` is called.
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: '`Profile` 类记录每个命名配置文件被调用的次数以及从开始到结束之间的持续时间，当调用 `PrintResults()` 时，输出关于这些执行的摘要信息。'
- en: See also
  id: totrans-415
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参见
- en: 'Refer to the following recipes in this chapter for more information:'
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 有关更多信息，请参阅本章以下配方：
- en: '*Evaluating performance by measuring max and min frame rates (FPS)*'
  id: totrans-417
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*通过测量最大和最小帧率（FPS）来评估性能*'
- en: '*Identifying performance bottlenecks with the Unity performance Profiler*'
  id: totrans-418
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用 Unity 性能分析器识别性能瓶颈*'
- en: Cache GameObject and component references to avoid expensive lookups
  id: totrans-419
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 缓存 GameObject 和组件引用以避免昂贵的查找
- en: '**Optimization principal 2**: Minimize actions requiring Unity to perform "reflection"
    over objects and searching of all current scene objects.'
  id: totrans-420
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化原则 2**：最小化需要 Unity 对对象进行“反射”操作和搜索所有当前场景对象的动作。'
- en: Reflection is when, at run time, Unity has to analyze objects to see whether
    they contain a method corresponding to a "message" that the object has received
    - an example would be `SendMessage()`. An example of making Unity perform a search
    over all active objects in a scene would be the simple and useful, but slow, `FindObjectsByTag()`.
    Another action that slows Unity down is each time we make it look up an object's
    component using `GetComponent()`.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 反射是指在运行时，Unity 必须分析对象以查看它们是否包含与对象接收到的“消息”相对应的方法 - 例如 `SendMessage()`。Unity 在场景中搜索所有活动对象的简单而有用但速度较慢的
    `FindObjectsByTag()` 是一个示例。每次我们使用 `GetComponent()` 查找对象的组件时，都会减慢 Unity 的速度。
- en: '![Cache GameObject and component references to avoid expensive lookups](img/1362OT_11_33.jpg)'
  id: totrans-422
  prefs: []
  type: TYPE_IMG
  zh: '![缓存 GameObject 和组件引用以避免昂贵的查找](img/1362OT_11_33.jpg)'
- en: In the olden days for many components, Unity offered *quick component property
    getters* such as `.audio` to reference the `AudioSource` component of a script's
    parent **GameObject**, `rigidbody` to reference the **RigidBody** component, and
    so on. However, this wasn't a consistent rule, and in other cases, you had to
    use `GetComponent()`. With Unity 5, all these *quick component property getters*
    have been removed (with the exception of `.transform`, which is automatically
    cached, so has no performance cost to use). To help game developers update their
    scripts to work with Unity 5, they introduced *Automatic Script Updating*, whereby
    (after a suitable warning to have backed up files before going ahead!) Unity will
    go through scripts replacing *quick component property getters* code with the
    standardized `GetComponent<ComponentTyle>()` code pattern, such as `GetComponent<Rigidbody>()`
    and `GetComponent<AudioSource>()`. However, while script updating makes things
    consistent, and also makes explicit all these `GetComponent()` reflection statements,
    each `GetComponent()` execution eats up valuable processing resources.
  id: totrans-423
  prefs: []
  type: TYPE_NORMAL
  zh: 在过去，对于许多组件，Unity 提供了诸如 `.audio` 这样的 *快速组件属性获取器*，以引用脚本父 **GameObject** 的 `AudioSource`
    组件，`rigidbody` 以引用 **RigidBody** 组件，等等。然而，这并不是一个一致的规则，在其他情况下，您必须使用 `GetComponent()`。在
    Unity 5 中，所有这些 *快速组件属性获取器* 都已被移除（除了 `.transform`，它被自动缓存，因此使用时没有性能成本）。为了帮助游戏开发者更新他们的脚本以与
    Unity 5 兼容，他们引入了 *自动脚本更新*，其中（在适当警告并在继续之前备份文件之后！）Unity 会遍历脚本，将 *快速组件属性获取器* 代码替换为标准化的
    `GetComponent<ComponentType>()` 代码模式，例如 `GetComponent<Rigidbody>()` 和 `GetComponent<AudioSource>()`。然而，尽管脚本更新使事物保持一致，并明确所有这些
    `GetComponent()` 反射语句，但每次 `GetComponent()` 执行都会消耗宝贵的处理资源。
- en: Note
  id: totrans-424
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'You can read more about Unity''s reasons for this (and the alternative *Extension
    Methods* approach they rejected; a shame—I think we''ll see them appear in a later
    version of Unity since it''s an elegant way to solve this coding situation) in
    this June 2014 blog post and manual page at:'
  id: totrans-425
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在以下2014年6月的博客文章和手册页面中了解更多关于Unity这样做的原因（以及他们拒绝的替代方案*Extension Methods*；真遗憾——我认为我们将在Unity的后续版本中看到它们，因为这是一种优雅地解决这种编码情况的方法）：
- en: '[http://blogs.unity3d.com/2014/06/23/unity5-api-changes-automatic-script-updating/](http://blogs.unity3d.com/2014/06/23/unity5-api-changes-automatic-script-updating/)'
  id: totrans-426
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://blogs.unity3d.com/2014/06/23/unity5-api-changes-automatic-script-updating/](http://blogs.unity3d.com/2014/06/23/unity5-api-changes-automatic-script-updating/)'
- en: '[http://unity3d.com/learn/tutorials/modules/intermediate/scripting/extension-methods](http://unity3d.com/learn/tutorials/modules/intermediate/scripting/extension-methods)'
  id: totrans-427
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://unity3d.com/learn/tutorials/modules/intermediate/scripting/extension-methods](http://unity3d.com/learn/tutorials/modules/intermediate/scripting/extension-methods)'
- en: In this recipe, we'll incrementally refactor a method, making it more efficient
    at each step by removing reflection and component lookup actions. The method we'll
    improve is to find half the distance from the **GameObject** in the scene tagged
    `Player` (a **3rd Person Controller**) and 1,000 other **GameObjects** in the
    scene tagged `Respawn`.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将逐步重构一个方法，通过移除反射和组件查找操作，使其在每一步都变得更加高效。我们将改进的方法是找到场景中标记为`Player`（一个**3rd
    Person Controller**）的**GameObject**和场景中标记为`Respawn`的1,000个其他**GameObject**之间的一半距离。
- en: Getting ready
  id: totrans-429
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared a package named `unity4_assets_handyman_goodDirt`
    containing the 3rdPersonController handyman and Terrain material `goodDirt`. The
    package is in the folder `1362_11_15`.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们准备了一个名为`unity4_assets_handyman_goodDirt`的包，包含3rdPersonController handyman和地形材质`goodDirt`。该包位于文件夹`1362_11_15`。
- en: How to do it...
  id: totrans-431
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To improve code performance by caching component lookups, follow these steps:'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: 为了通过缓存组件查找来提高代码性能，请按照以下步骤操作：
- en: Create a new 3D project, importing the provided Unity package `unity4_assets_handyman_goodDirt`.
  id: totrans-433
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的3D项目，导入提供的Unity包`unity4_assets_handyman_goodDirt`。
- en: Create a new **Terrain** (size **200 x 200**, located at **-100, 0, -100**)
    and texture-paint it with **GoodDirt**.
  id: totrans-434
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**地形**（大小为**200 x 200**，位于**-100, 0, -100**），并使用**GoodDirt**进行纹理绘制。
- en: Add a **3rdPersonController** at the center of the terrain (that is, **0, 1,
    0**). Note that this will already be tagged **Player**.
  id: totrans-435
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在地形的中心添加一个**3rdPersonController**（即**0, 1, 0**）。请注意，这已经标记为**Player**。
- en: Create a new **Sphere** and give it the tag **Respawn**.
  id: totrans-436
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的**球体**，并给它添加**Respawn**标签。
- en: In the **Project** panel, create a new empty prefab named **prefab_sphere**
    and drag the **Sphere** from the **Hierarchy** panel into your prefab in the **Project**
    panel.
  id: totrans-437
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Project**面板中，创建一个新的空预制件，命名为**prefab_sphere**，并将**球体**从**Hierarchy**面板拖动到**Project**面板中的预制件中。
- en: Now, delete the **Sphere** from the **Hierarchy** panel (since all its properties
    have been copied into our prefab).
  id: totrans-438
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，从**Hierarchy**面板中删除**球体**（因为所有属性都已复制到我们的预制件中）。
- en: 'Add the following C# script class `SphereBuilder` to the **Main Camera**:'
  id: totrans-439
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本类`SphereBuilder`添加到**主相机**：
- en: '[PRE22]'
  id: totrans-440
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: With the **Main Camera** selected in the **Hierarchy**, drag **prefab_sphere**
    from the Project panel in **Inspector** public variable `Sphere Prefab`, for script
    component `SphereBuilder,` as shown in the following screenshot:![How to do it...](img/1362OT_11_34.jpg)
  id: totrans-441
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Hierarchy**中选择**主相机**，从**Inspector**中的**Project**面板拖动**prefab_sphere**到公共变量`Sphere
    Prefab`，如以下截图所示：![如何操作...](img/1362OT_11_34.jpg)
- en: 'Add the following C# script class `SimpleMath` to the **Main Camera**:'
  id: totrans-442
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本类`SimpleMath`添加到**主相机**：
- en: '[PRE23]'
  id: totrans-443
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: Method 1 – AverageDistance calculation
  id: totrans-444
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法1 – 平均距离计算
- en: 'Follow these steps:'
  id: totrans-445
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'Add the following C# script class `AverageDistance` to the **Main Camera**:'
  id: totrans-446
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下C#脚本类`AverageDistance`添加到**主相机**：
- en: '[PRE24]'
  id: totrans-447
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Open the **Profiler** panel and ensure that **record** is selected and and that
    the script processing load is being recorded.
  id: totrans-448
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Profiler**面板，确保已选择**record**，并且正在记录脚本处理负载。
- en: Run the game for 10 to 20 seconds.
  id: totrans-449
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏10到20秒。
- en: In the **Profiler** panel, restrict the listed results to only samples starting
    with `TEST`. For whichever frame you select, you should see the percentage CPU
    load and milliseconds required for **TESTING_method1**.
  id: totrans-450
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Profiler**面板中，仅限制列出的结果为以`TEST`开头的样本。对于您选择的任何帧，您应该看到**TESTING_method1**的CPU负载百分比和所需的毫秒数。
- en: Method 2 – Cache array of Respawn object transforms
  id: totrans-451
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法2 – 缓存Respawn对象变换数组
- en: 'Follow these steps:'
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: '`FindGameObjectWithTag()` is slow, so let''s fix that for the search for objects
    tagged `Respawn`. First, in C# script class `AverageDistance`, add a private `Transform`
    array variable named `sphereTransformArrayCache`:'
  id: totrans-453
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`FindGameObjectWithTag()`很慢，所以让我们修复搜索带有`Respawn`标记的对象的问题。首先，在C#脚本类`AverageDistance`中添加一个名为`sphereTransformArrayCache`的私有`Transform`数组变量：'
- en: '[PRE25]'
  id: totrans-454
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'Now, add the `Start()` method, the statement that stores in this array references
    to the **Transform** component of all our `Respawn` tagged objects:'
  id: totrans-455
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，添加`Start()`方法，该语句将存储在这个数组中，指向所有带有`Respawn`标记对象的`Transform`组件的引用：
- en: '[PRE26]'
  id: totrans-456
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Now, in the `Update()`method, start a new **Profiler** sample named **TESTING_method2**,
    which uses our cached array of games objects tagged with `Respawn`:'
  id: totrans-457
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Update()`方法中，开始一个新的名为**TESTING_method2**的**Profiler**样本，它使用我们缓存的带有`Respawn`标记的游戏对象数组：
- en: '[PRE27]'
  id: totrans-458
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Once again, run the game for 10 to 20 seconds and set the **Profiler** panel
    to restrict the listed results to only samples starting with `TEST`. For whichever
    frame you select, you should see the percentage CPU load and milliseconds required
    for **TESTING_method1** and **TESTING_method2**.
  id: totrans-459
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 再次运行游戏10到20秒，并将**Profiler**面板设置为仅列出以`TEST`开头的样本。对于你选择的任何帧，你应该看到**TESTING_method1**和**TESTING_method2**的CPU负载百分比和所需的毫秒数。
- en: Method 3 – Cache reference to Player transform
  id: totrans-460
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法3 – 缓存玩家变换引用
- en: 'That should run faster. But wait! Let''s improve things some more. Let''s make
    use of a cached reference to **Cube-Player** component''s transform, avoiding
    the slow object-tag reflection lookup altogether. Follow these steps:'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: 这样应该会更快。但是等等！让我们再进一步改进。让我们利用缓存的`Cube-Player`组件的变换引用，完全避免缓慢的对象标记反射查找。按照以下步骤操作：
- en: 'First, add a new private variable and a statement in the `Start()`method to
    assign the `Player` object''s transform in this variable `playerTransformCache`:'
  id: totrans-462
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Start()`方法中添加一个新的私有变量和一个语句，将`Player`对象的变换分配到这个变量`playerTransformCache`中：
- en: '[PRE28]'
  id: totrans-463
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Now, in `Update()`, add the following code to start a new **Profiler** sample
    named **TESTING_method3**:'
  id: totrans-464
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Update()`中添加以下代码以启动一个新的名为**TESTING_method3**的**Profiler**样本：
- en: '[PRE29]'
  id: totrans-465
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'Finally, we need to write a new method that calculates the half distance making
    use of the cached player transform variable we have set up. So, add this new method,
    `HalfDistanceCachePlayerTransform( sphereTransformArrayCache[i] )`:'
  id: totrans-466
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们需要编写一个新的方法，该方法利用我们设置的缓存的玩家变换变量来计算半距离。所以，添加这个新方法，`HalfDistanceCachePlayerTransform(sphereTransformArrayCache[i])`：
- en: '[PRE30]'
  id: totrans-467
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: Method 4 – Cache Player's Vector3 position
  id: totrans-468
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法4 – 缓存玩家的Vector3位置
- en: Let's improve things some more. If, for our particular game, we can make the
    assumption that the player character does not move, we have an opportunity to
    cache the player's **position** once, rather than retrieving it for each frame.
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们再进一步改进。如果我们假设对于我们的特定游戏，玩家角色不会移动，那么我们可以缓存玩家的**位置**一次，而不是每次帧都检索它。
- en: 'Follow these steps:'
  id: totrans-470
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'At the moment, to find `pos1`, we are making Unity find the position `Vector3`
    value inside `playerTransform` *every time the* `Update()` *method is called.*
    Let''s cache this `Vector3` position with a variable and statement in `Start()`,
    as follows:'
  id: totrans-471
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 目前，为了找到`pos1`，我们每次在`Update()`方法调用时都让Unity找到`playerTransform`中的`Vector3`位置值。让我们使用`Start()`中的变量和语句将这个`Vector3`位置缓存起来，如下所示：
- en: '[PRE31]'
  id: totrans-472
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Now, write a new half-distance method that makes use of this cached position:'
  id: totrans-473
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，编写一个新的半距离方法，利用这个缓存的**位置**：
- en: '[PRE32]'
  id: totrans-474
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Now, in the `Update()` method, add the following code so that we create a new
    sample for our method 4, and call our new half-distance method:'
  id: totrans-475
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Update()`方法中添加以下代码，以便为我们创建一个新的样本，并调用我们新的半距离方法：
- en: '[PRE33]'
  id: totrans-476
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Method 5 – Cache reference to SimpleMath component
  id: totrans-477
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法5 – 缓存SimpleMath组件引用
- en: 'That should improve things again. But we can still improve things—you''ll notice
    in our latest half-distance method that we have an explicit `GetComponent()` call
    to get a reference to our `mathObject`; this will be executed *every time the
    method is called.* Follow these steps:'
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 这样应该再次改进。但我们还可以进一步改进——你会在我们最新的半距离方法中注意到，我们有一个显式的`GetComponent()`调用，用于获取我们的`mathObject`的引用；这将*每次方法被调用时*执行。按照以下步骤操作：
- en: 'Let''s cache this scripted component reference as well to save a `GetComponent()`
    reflection for each iteration. We''ll declare a variable `mathObjectCache`, and
    in `Awake()`, we will set it to refer to our `SimpleMath` scripted component:'
  id: totrans-479
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们将这个脚本组件引用也缓存起来，以节省每次迭代的`GetComponent()`反射。我们将声明一个变量`mathObjectCache`，并在`Awake()`中将其设置为指向我们的`SimpleMath`脚本组件：
- en: '[PRE34]'
  id: totrans-480
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Let''s write a new half-distance method that uses this cached reference to
    the math component `HalfDistanceCacheMathComponent(i)`:'
  id: totrans-481
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个新的半距离方法，该方法使用这个缓存的数学组件引用`HalfDistanceCacheMathComponent(i)`：
- en: '[PRE35]'
  id: totrans-482
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Now, in the `Update()` method, add the following code so that we create a new
    sample for our *method5* and call our new half-distance method:'
  id: totrans-483
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Update()`方法中添加以下代码，以便为我们的*method5*创建一个新的样本并调用我们新的半距离方法：
- en: '[PRE36]'
  id: totrans-484
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: Method 6 – Cache array of sphere Vector3 positions
  id: totrans-485
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 方法6 – 缓存球体Vector3位置数组
- en: We've improved things quite a bit, but there is still a glaring opportunity
    to use caching to improve our code (if we can assume that the spheres do not move,
    which seems reasonable in this example). At present, for every frame and every
    sphere in our half-distance calculation method, we are asking Unity to retrieve
    the value of the `Vector3` position property in the transform of the current sphere
    (this is our variable `pos2`), and this position is used to calculate the distance
    of the current sphere from `Player`. Let's create an array of all those `Vector3`
    positions so that we can pass the current one to our half-distance calculation
    method and save the work of retrieving it so many times.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经改进了很多，但仍然有一个明显的机会可以通过缓存来改进我们的代码（如果我们假设球体不会移动，这在示例中似乎是合理的）。目前，在半距离计算方法中的每一帧和每个球体，我们都要求Unity检索当前球体变换中的`Vector3`位置属性值（这是我们变量`pos2`），这个位置用于计算当前球体与`Player`的距离。让我们创建一个包含所有这些`Vector3`位置的数组，这样我们就可以将当前的值传递给我们的半距离计算方法，并节省多次检索它的工作。
- en: 'Follow these steps:'
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下步骤操作：
- en: 'First, add a new private variable and a statement inside our existing loop
    in the `Start()` method to assign each sphere''s `Vector3` transform position
    in the array `spherePositionArrayCache`:'
  id: totrans-488
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在`Start()`方法中添加一个新的私有变量和一条语句，将每个球体的`Vector3`变换位置分配到数组`spherePositionArrayCache`中：
- en: '[PRE37]'
  id: totrans-489
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'Let''s write a new half-distance method that uses this array of cached positions:'
  id: totrans-490
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们编写一个新的半距离方法，该方法使用这个缓存的位位置数组：
- en: '[PRE38]'
  id: totrans-491
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: 'Now, in the `Update()`method, add the following code so that we create a new
    sample for our *method6* and call our new half-distance method:'
  id: totrans-492
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，在`Update()`方法中添加以下代码，以便为我们的*method6*创建一个新的样本并调用我们新的半距离方法：
- en: '[PRE39]'
  id: totrans-493
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Open the **Profiler** panel and ensure that **record** is selected and script
    processing load is being recorded.
  id: totrans-494
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**Profiler**面板并确保**record**被选中，正在记录脚本处理负载。
- en: Run the game for 10 to 20 seconds.
  id: totrans-495
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行游戏10到20秒。
- en: In the **Profiler** panel, restrict the listed results to only samples starting
    with `TEST`. For whichever frame you select, you should see the percentage CPU
    load and milliseconds required for each method (lower is better for both these
    values!). For almost every frame, you should see how/if each method refined by
    caching has reduced the CPU load.![Method 6 – Cache array of sphere Vector3 positions](img/1362OT_11_35.jpg)
  id: totrans-496
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在**Profiler**面板中，仅限制列出的结果为以`TEST`开头的样本。对于您选择的任何帧，您应该看到每个方法的CPU负载百分比和所需毫秒数（这两个值都越低越好！）。对于几乎每一帧，您都应该看到通过缓存改进的每个方法是如何/是否减少了CPU负载。![方法6
    – 缓存球体Vector3位置数组](img/1362OT_11_35.jpg)
- en: How it works...
  id: totrans-497
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: This recipe illustrates how we try to cache references once, before any iteration,
    for variables whose value will not change, such as references to `GameObjects`
    and their components, and, in this example, the `Transform` components and `Vector3`
    positions of objects tagged `Player` and `Respawn`. Of course, as with everything,
    there is a "cost" associated with caching, and that cost is the memory requirements
    to store all those references. This is known as the **Space-Time Tradeoff**. You
    can learn more about this classic computer science speed versus memory tradeoff
    at [https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff](https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff).
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 这个配方说明了我们如何尝试在迭代之前一次性缓存不会改变的变量的引用，例如`GameObjects`及其组件的引用，以及在这个示例中，标记为`Player`和`Respawn`的对象的`Transform`组件和`Vector3`位置。当然，与所有事情一样，缓存也有“成本”，这个成本就是存储所有这些引用所需的内存需求。这被称为**时空权衡**。您可以在[https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff](https://en.wikipedia.org/wiki/Space%E2%80%93time_tradeoff)了解更多关于这个经典的计算机科学速度与内存权衡。
- en: In methods that need to be performed many times, this removing of implicit and
    explicit component and object lookups may offer a measurable performance improvement.
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 在需要多次执行的方法中，这种移除隐式和显式组件和对象查找可能提供可测量的性能改进。
- en: Note
  id: totrans-500
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Note: Two good places to learn more about Unity performance optimization techniques
    are from the *Performance Optimization* web page in the Unity script reference
    and from Unity''s Jonas Echterhoff and Kim Steen Riber Unite2012 presentation
    *Performance Optimization Tips and Tricks for Unity*. Many recipes in this chapter
    had their origins from suggestions in the following sources:'
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 注意：了解Unity性能优化技术的两个好地方是Unity脚本参考中的*性能优化*网页以及Unity的Jonas Echterhoff和Kim Steen
    Riber Unite2012演示*Unity性能优化技巧和窍门*。本章中的许多配方都源于以下来源的建议：
- en: '[http://docs.unity3d.com/410/Documentation/ScriptReference/index.Performance_Optimization.html](http://docs.unity3d.com/410/Documentation/ScriptReference/index.Performance_Optimization.html)'
  id: totrans-502
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/410/Documentation/ScriptReference/index.Performance_Optimization.html](http://docs.unity3d.com/410/Documentation/ScriptReference/index.Performance_Optimization.html)'
- en: '[http://unity3d.com/unite/archive/2012](http://unity3d.com/unite/archive/2012)'
  id: totrans-503
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://unity3d.com/unite/archive/2012](http://unity3d.com/unite/archive/2012)'
- en: See also
  id: totrans-504
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: 'Refer to the following recipes in this chapter for more information:'
  id: totrans-505
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的以下配方以获取更多信息：
- en: '*Improving efficiency with delegates and events and avoiding SendMessage!*'
  id: totrans-506
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用委托和事件提高效率并避免SendMessage!*'
- en: '*Identifying performance bottlenecks with the Unity performance Profiler*'
  id: totrans-507
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Unity性能分析器识别性能瓶颈*'
- en: '*Identifying performance bottlenecks with Do-It-Yourself performance profiling*'
  id: totrans-508
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*使用Do-It-Yourself性能分析识别性能瓶颈*'
- en: Improving performance with LOD groups
  id: totrans-509
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用LOD组提高性能
- en: '**Optimization principal 5**: Minimize the number of draw calls.'
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化原则5**：最小化绘制调用次数。'
- en: 'Detailed geometry and high-resolution texture maps can be a double-edged sword:
    they can deliver a better visual experience, but they can impact negatively on
    the game''s performance. **LOD groups** address this issue by replacing high-quality
    objects by simplified versions whenever that object takes up a smaller portion
    of the screen than necessary for a high-quality version to make a significant
    difference.'
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 精细几何和高分辨率纹理图可以是一把双刃剑：它们可以提供更好的视觉体验，但它们可能会对游戏性能产生负面影响。**LOD组**通过在对象占据屏幕的必要部分小于高质量版本能产生显著差异时，用简化版本替换高质量对象来解决这个问题。
- en: 'In this recipe, we will use a **LOD group** to create a game object featuring
    two different levels of detail: a high-quality version for whenever the object
    takes up more than 50 percent of the screen and a low-quality version for the
    times it takes up less than that amount. We would like to thank Carl Callewaert,
    from Unity, for his demonstration of the LOD Group functionality, which has informed
    this recipe in many ways.'
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将使用**LOD组**来创建一个具有两个不同细节级别的游戏对象：当对象占据屏幕超过50%时的高质量版本，以及占据少于该数量的低质量版本。我们想感谢Unity的Carl
    Callewaert，他为LOD Group功能进行了演示，这在许多方面为这个配方提供了信息。
- en: '![Improving performance with LOD groups](img/1362OT_11_09.jpg)'
  id: totrans-513
  prefs: []
  type: TYPE_IMG
  zh: '![使用LOD组提高性能](img/1362OT_11_09.jpg)'
- en: Getting ready
  id: totrans-514
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备工作
- en: For this recipe, we have prepared two prefabs for the high- and low-quality
    versions of the game object. They share the same dimensions and transform settings
    (position, rotation, and scale), so that they can replace each other seamlessly.
    Both prefabs are contained within the package named `LODGroup`, available in the
    `1362_11_16` folder.
  id: totrans-515
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个配方，我们为游戏对象的高质量和低质量版本准备了两个预制件。它们具有相同的尺寸和变换设置（位置、旋转和缩放），以便它们可以无缝替换。这两个预制件都包含在名为`LODGroup`的包中，位于`1362_11_16`文件夹内。
- en: How to do it...
  id: totrans-516
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: 'To create a LOD group, follow these steps:'
  id: totrans-517
  prefs: []
  type: TYPE_NORMAL
  zh: 要创建一个LOD组，请按照以下步骤操作：
- en: Import the **LODGroup** package into your project.
  id: totrans-518
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**LODGroup**包导入到您的项目中。
- en: 'From the **Project** view, inside the **LOD** folder, drag the **batt-high**
    prefab into the **Hierarchy** view. Then, do the same for the **batt-low** prefab.
    Make sure that they are placed at the same **Position** (**X**: **0**; **Y**:
    **0**; **Z**: **0**).'
  id: totrans-519
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Project**视图，在**LOD**文件夹内，将**batt-high**预制件拖放到**Hierarchy**视图。然后，对**batt-low**预制件做同样的操作。确保它们放置在相同的**位置**（**X**：**0**；**Y**：**0**；**Z**：**0**）。
- en: From the **Create** drop-down menu in the **Hierarchy** view, create a new empty
    game object (**Create** | **Create Empty**). Rename it `battLOD`.
  id: totrans-520
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 从**Hierarchy**视图中的**Create**下拉菜单创建一个新的空游戏对象（**Create** | **Create Empty**）。将其重命名为`battLOD`。
- en: Add the **LODGroup** component to **battLOD** (menu **Component** | **Rendering**
    | **LODGroup**).
  id: totrans-521
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**LODGroup**组件添加到**battLOD**（菜单**Component** | **Rendering** | **LODGroup**）。
- en: 'Select the **battLOD** object, and, from the **Inspector** view, **LODGroup**
    component, right-click on **LOD 2** and delete it (since we''ll have only two
    different LODs: **LOD 0** and **LOD 1**), as shown in the following screnshot:![How
    to do it...](img/1362OT_11_10.jpg)'
  id: totrans-522
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**battLOD**对象，并在**检查器**视图中的**LODGroup**组件上，右键点击**LOD 2**并删除它（因为我们将只有两个不同的LOD：**LOD
    0**和**LOD 1**），如下截图所示：![如何操作...](img/1362OT_11_10.jpg)
- en: Select the **LOD 0** area, click on the **Add** button, and select the **batt-high**
    game object from the list. A message about reparenting objects will appear. Select
    **Yes, Reparent**.![How to do it...](img/1362OT_11_11.jpg)
  id: totrans-523
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**LOD 0**区域，点击**添加**按钮，并从列表中选择**batt-high**游戏对象。会出现关于重新父化对象的消息。选择**是，重新父化**。![如何操作...](img/1362OT_11_11.jpg)
- en: Select the **LOD 1** section, click on **Add**, and select the **batt-low**
    object. Again, chose **Yes, Reparent** when prompted.![How to do it...](img/1362OT_11_12.jpg)
  id: totrans-524
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 选择**LOD 1**部分，点击**添加**，并选择**batt-low**对象。再次，当提示时选择**是，重新父化**。![如何操作...](img/1362OT_11_12.jpg)
- en: 'Drag the limits of the LOD renderers to set them as: **LOD 0: 100%**, **LOD
    1**: **50%**, **Culled: 1%.** That will make Unity render **bat-high** whenever
    it occupies 51 percent to 100 percent of the screen space, **batt-low** when 2
    percent to 50 percent, and will not render anything if 1 percent or less.![How
    to do it...](img/1362OT_11_13.jpg)'
  id: totrans-525
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 拖动LOD渲染器的限制以将其设置为：**LOD 0：100**%，**LOD 1**：**50**%，**裁剪：1**%。这样，当**bat-high**占据屏幕空间的51%到100%时，Unity将渲染它；当占据2%到50%时，将渲染**batt-low**；如果占据1%或更少，则不会渲染任何内容。![如何操作...](img/1362OT_11_13.jpg)
- en: Move the scene's camera toward the **battLOD** object and back. You will notice
    how Unity swaps between the high- and low-definition LOD renderer as it occupies
    more or less than 50 percent of the screen's space.
  id: totrans-526
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将场景的摄像机移向**battLOD**对象并返回。你会注意到Unity如何根据对象占据屏幕空间的多少在高清和低清LOD渲染器之间切换。
- en: How it works...
  id: totrans-527
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: Once we have populated the LOD renderers with the appropriate models, the **LODGroup**
    component will select and display the right renderer based on how much of the
    screen's percentage the object takes up, or even display nothing at all.
  id: totrans-528
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们用适当的模型填充了LOD渲染器，**LODGroup**组件将根据对象占据屏幕百分比的大小选择并显示正确的渲染器，甚至可以完全不显示。
- en: There's more...
  id: totrans-529
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some details you don''t want to miss:'
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你不应该错过的细节：
- en: Adding more LOD renderers
  id: totrans-531
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加更多LOD渲染器
- en: You can add more LOD renderers by right-clicking on an existing LOD renderer
    and selecting **Insert Before** from the context menu.
  id: totrans-532
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过在现有的LOD渲染器上右键点击并从上下文菜单中选择**插入之前**来添加更多LOD渲染器。
- en: Fading LOD transitions
  id: totrans-533
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: LOD过渡淡入
- en: In case you want to minimize the *popping* that occurs when renderers are swapped,
    you can try changing the parameter **Fade Mode** from **None** to **Percentage**
    or **Crossfade**.
  id: totrans-534
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想最小化渲染器交换时发生的**闪烁**，你可以尝试将参数**淡入模式**从**无**更改为**百分比**或**交叉淡入**。
- en: See also
  id: totrans-535
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 相关内容
- en: Refer to the next recipe in this chapter for more information
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章下一节以获取更多信息
- en: Improving performance through reduced draw calls by designing for draw call
    batching
  id: totrans-537
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过设计绘制调用批处理来提高性能
- en: '**Optimization principal 5**: Minimize the number of draw calls.'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: '**优化原则5**：最小化绘制调用次数。'
- en: One way to minimize draw calls is by prioritizing design decisions to qualify
    objects for Unity's *Static* and *Dynamic draw call batching*.
  id: totrans-539
  prefs: []
  type: TYPE_NORMAL
  zh: 减少绘制调用的一种方法是通过优先考虑设计决策，使对象符合Unity的**静态**和**动态绘制调用批处理**资格。
- en: The more CPU-efficient batching method is Unity's **static batching**. It allows
    reduction of draw calls for any sized geometry. If that is not possible, then
    the next best thing is **dynamic batching**, which again allows Unity to process
    together several moving objects in a single draw call.
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: 更CPU高效的批处理方法是Unity的**静态批处理**。它允许减少任何尺寸几何形状的绘制调用次数。如果这不可能，那么最好的选择是**动态批处理**，它再次允许Unity在单个绘制调用中处理多个移动对象。
- en: Note that there is a cost—batching uses memory, and static batching uses more
    memory than dynamic memory. So, you can improve performance with batching, but
    you'll be increasing the scene's memory "footprint." As always, use memory and
    performance profiling to evaluate which use of techniques is best for your game
    and its intended deployment device.
  id: totrans-541
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这里有一个成本——批处理使用内存，静态批处理比动态内存使用更多。因此，你可以通过批处理来提高性能，但你会增加场景的内存“足迹”。像往常一样，使用内存和性能分析来评估哪种技术最适合你的游戏及其目标部署设备。
- en: How to do it...
  id: totrans-542
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作...
- en: In this section, we will learn how to make possible **static batching** and
    **dynamic batching**.
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将学习如何实现 **静态批处理** 和 **动态批处理**。
- en: Static batching
  id: totrans-544
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 静态批处理
- en: 'To make possible Unity **static batching**, you need to do the following:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Unity 的 **静态批处理** 成为可能，你需要执行以下操作：
- en: Ensure that models share the same material.
  id: totrans-546
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保模型共享相同的材质。
- en: Mark models as **Static**, as shown in the following screenshot:![Static batching](img/1362OT_11_37.jpg)
  id: totrans-547
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 标记模型为 **静态**，如图所示：![静态批处理](img/1362OT_11_37.jpg)
- en: Objects that can be safely marked as **Static** include environment objects
    that won't move or be scaled.
  id: totrans-548
  prefs: []
  type: TYPE_NORMAL
  zh: 可以安全标记为 **静态** 的对象包括那些不会移动或缩放的环境对象。
- en: 'Many techniques can be used to ensure models share the same material including:'
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用许多技术来确保模型共享相同的材质，包括：
- en: Avoid using textures by directly painting vertices of the model (useful links
    for this are provided in the *There's more…* section)
  id: totrans-550
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免通过直接绘制模型的顶点来使用纹理（有关此内容的链接在 *还有更多…* 部分提供）
- en: Increasing the number of objects textured with exactly the same texture
  id: totrans-551
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 增加使用完全相同纹理的纹理对象的数量
- en: Artificially enabling objects to share the same texture by combining multiple
    textures into a single one (texture atlassing)
  id: totrans-552
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过将多个纹理组合成一个来人工启用对象共享相同的纹理（纹理图集）
- en: Maximizing script use of `Renderer.sharedMaterial` rather than `Renderer.material`
    (since use of `Render.material` involves making a copy of the material and, therefore,
    disqualifies that GameObejct for batching)
  id: totrans-553
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最大化使用 `Renderer.sharedMaterial` 而不是 `Renderer.material`（因为使用 `Render.material`
    会涉及复制材质，因此该 GameObejct 将无法进行批处理）
- en: In fact, both static and dynamic batching only work with objects that use the
    same material, so all methods above apply equally for making dynamic batching
    possible as well.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，静态和动态批处理都仅适用于使用相同材质的对象，因此上述所有方法同样适用于使动态批处理成为可能。
- en: Dynamic batching
  id: totrans-555
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态批处理
- en: 'To make possible Unity **dynamic batching**, you need to do the following:'
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 Unity 的 **动态批处理** 成为可能，你需要执行以下操作：
- en: Ensure that models share the same material.
  id: totrans-557
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确保模型共享相同的材质。
- en: Keep the number of **vertex attributes** below 900 for each mesh.
  id: totrans-558
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将每个网格的 **顶点属性** 数量保持在 900 以下。
- en: Have the group of objects to quality for dynamic batching to use the same transform
    scale (although non-uniform scaled models can still be batched).
  id: totrans-559
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要使对象组符合动态批处理条件，需要使用相同的变换缩放（尽管非均匀缩放的模型仍然可以批处理）。
- en: If possible, have dynamic lightmapped objects point to the same lightmap location
    to facilitate dynamic batching.
  id: totrans-560
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能，让动态光照映射对象指向相同的光照贴图位置，以方便动态批处理。
- en: Avoid the use of multi-pass shaders and real-time shadows if possible, since
    both of these prevent dynamic batching.
  id: totrans-561
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果可能，避免使用多通道着色器和实时阴影，因为这两者都会阻止动态批处理。
- en: To calculate the number of **vertex attributes**, you need to multiply the number
    of vertices by the number of attributes used by the **Shader**. For example, for
    a **Shader** using three attributes (vertex position, normal, and UV), it would
    mean that a model must have less than 300 vertices to keep the total number of
    attributes below 900 to qualify for dynamic batching.
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 要计算 **顶点属性** 的数量，你需要将顶点数乘以 **Shader** 使用的属性数。例如，对于使用三个属性（顶点位置、法线和 UV）的 **Shader**，这意味着模型必须少于
    300 个顶点，以保持属性总数低于 900，从而符合动态批处理的条件。
- en: There's more...
  id: totrans-563
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 还有更多...
- en: 'Some details you don''t want to miss:'
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 一些你不希望错过的细节：
- en: Reduce the need for textures by vertex painting
  id: totrans-565
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过顶点绘制减少对纹理的需求
- en: 'For more information about this topic, see the following:'
  id: totrans-566
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参阅以下内容：
- en: 'Blender:'
  id: totrans-567
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Blender：
- en: '[http://wiki.blender.org/index.php/Doc:2.6/Manual/Materials/Special_Effects/Vertex_Paint](http://wiki.blender.org/index.php/Doc:2.6/Manual/Materials/Special_Effects/Vertex_Paint)'
  id: totrans-568
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://wiki.blender.org/index.php/Doc:2.6/Manual/Materials/Special_Effects/Vertex_Paint](http://wiki.blender.org/index.php/Doc:2.6/Manual/Materials/Special_Effects/Vertex_Paint)'
- en: '3D Studio Max:'
  id: totrans-569
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 3D Studio Max：
- en: '[http://3dmax-tutorials.com/Vertex_Paint_Modifier.html](http://3dmax-tutorials.com/Vertex_Paint_Modifier.html)'
  id: totrans-570
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://3dmax-tutorials.com/Vertex_Paint_Modifier.html](http://3dmax-tutorials.com/Vertex_Paint_Modifier.html)'
- en: 'Maya: free Vertex Chameleon plugin'
  id: totrans-571
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Maya：免费的 Vertex Chameleon 插件
- en: '[http://renderheads.com/portfolio/VertexChameleon/](http://renderheads.com/portfolio/VertexChameleon/)'
  id: totrans-572
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://renderheads.com/portfolio/VertexChameleon/](http://renderheads.com/portfolio/VertexChameleon/)'
- en: Information sources about reducing textures and materials
  id: totrans-573
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于减少纹理和材质的信息来源
- en: 'For more information about this topic, see the following:'
  id: totrans-574
  prefs: []
  type: TYPE_NORMAL
  zh: 有关此主题的更多信息，请参阅以下内容：
- en: 'Unity manual page for Draw Call Batching:'
  id: totrans-575
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity 手册页面关于 Draw Call Batching：
- en: '[http://docs.unity3d.com/Manual/DrawCallBatching.html](http://docs.unity3d.com/Manual/DrawCallBatching.html)'
  id: totrans-576
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/Manual/DrawCallBatching.html](http://docs.unity3d.com/Manual/DrawCallBatching.html)'
- en: 'Paladin Studios:'
  id: totrans-577
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paladin Studios：
- en: '[http://www.paladinstudios.com/2012/07/30/4-ways-to-increase-performance-of-your-unity-game/](http://www.paladinstudios.com/2012/07/30/4-ways-to-increase-performance-of-your-unity-game/)'
  id: totrans-578
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.paladinstudios.com/2012/07/30/4-ways-to-increase-performance-of-your-unity-game/](http://www.paladinstudios.com/2012/07/30/4-ways-to-increase-performance-of-your-unity-game/)'
- en: 'Nvidia white paper on texture atlassing to increase draw call batching opportunities:'
  id: totrans-579
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nvidia关于纹理图集以增加绘制调用批处理机会的白色论文：
- en: '[http://http.download.nvidia.com/developer/NVTextureSuite/Atlas_Tools/Texture_Atlas_Whitepaper.pdf](http://http.download.nvidia.com/developer/NVTextureSuite/Atlas_Tools/Texture_Atlas_Whitepaper.pdf)'
  id: totrans-580
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://http.download.nvidia.com/developer/NVTextureSuite/Atlas_Tools/Texture_Atlas_Whitepaper.pdf](http://http.download.nvidia.com/developer/NVTextureSuite/Atlas_Tools/Texture_Atlas_Whitepaper.pdf)'
- en: 'Nvidia free texture tools and Photoshop plug-in:'
  id: totrans-581
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Nvidia免费纹理工具和Photoshop插件：
- en: '[http://www.nvidia.com/object/texture_atlas_tools.html](http://www.nvidia.com/object/texture_atlas_tools.html)'
  id: totrans-582
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.nvidia.com/object/texture_atlas_tools.html](http://www.nvidia.com/object/texture_atlas_tools.html)'
- en: See also
  id: totrans-583
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 参考以下内容
- en: Refer to the *Improving performance with LOD groups* recipe in this chapter
    for more information
  id: totrans-584
  prefs: []
  type: TYPE_NORMAL
  zh: 参考本章中的“使用LOD组提高性能”配方以获取更多信息
- en: Conclusion
  id: totrans-585
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结论
- en: In this chapter, we have introduced some extra features and a range of approaches
    to improve game performance and collect performance data for analysis.
  id: totrans-586
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了一些额外功能以及一系列提高游戏性能和收集性能数据进行分析的方法。
- en: The first three recipes in this chapter provide some ideas for adding some extra
    features to your game (pausing, slow motion, and securing online games). The rest
    of the recipes in this chapter provide examples of how to investigate and improve
    the efficiency and performance of your game.
  id: totrans-587
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的前三个配方提供了一些为您的游戏添加额外功能（暂停、慢动作和确保在线游戏安全）的想法。本章的其余配方提供了如何调查和改进游戏效率与性能的示例。
- en: There's more...
  id: totrans-588
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多内容...
- en: Just as there are many components in a game, there are many parts of a game
    where processing *bottlenecks* may be found and need to be addressed to improve
    overall game performance. Some additional suggestions and further reference sources
    are now provided to provide a launching pad for your further exploration of the
    issues of optimization and performance, since such topics could take up a whole
    book rather than just one chapter.
  id: totrans-589
  prefs: []
  type: TYPE_NORMAL
  zh: 正如游戏中有很多组件一样，游戏中有许多部分可能会发现处理**瓶颈**并需要解决以提升整体游戏性能。现在提供了一些额外的建议和进一步参考资料，以提供一个起点，以便您进一步探索优化和性能问题，因为这些问题可能需要整本书来讨论，而不仅仅是一章。
- en: Game audio optimization
  id: totrans-590
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 游戏音频优化
- en: Mobile devices have considerably less memory and processing resources than consoles,
    desktops, or even laptops, and often raise the biggest challenges when it comes
    to game audio. For example, the iPhone can only decompress one audio clip at a
    time, so a game may suffer processing spikes (that is, slow down game frame rate)
    due to audio decompression issues.
  id: totrans-591
  prefs: []
  type: TYPE_NORMAL
  zh: 移动设备相较于游戏机、桌面或笔记本电脑，内存和处理资源都相对较少，因此在游戏音频方面常常面临最大的挑战。例如，iPhone一次只能解压缩一个音频剪辑，因此游戏可能会因为音频解压缩问题而出现处理峰值（即降低游戏帧率）。
- en: 'Paladin Studios recommend the following audio file compression strategies for
    mobile games:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: Paladin Studios推荐以下音频文件压缩策略用于移动游戏：
- en: '**Short Clips**: Native (no compression)'
  id: totrans-593
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**短剪辑**：原生（无压缩）'
- en: '**Longer clips** (or ones that loop): Compressed in memory'
  id: totrans-594
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**长剪辑**（或循环的剪辑）：在内存中压缩'
- en: '**Music**: Stream from disc'
  id: totrans-595
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**音乐**：从光盘流式传输'
- en: '**Files which consistently cause CPU spikes**: Decompress on load'
  id: totrans-596
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**持续引起CPU峰值波动的文件**：加载时解压缩'
- en: 'For more information about this topic, see the following:'
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 关于此主题的更多信息，请参阅以下链接：
- en: 'Unity manual audio:'
  id: totrans-598
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity手册音频：
- en: '[http://docs.unity3d.com/Manual/AudioFiles.html](http://docs.unity3d.com/Manual/AudioFiles.html)'
  id: totrans-599
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/Manual/AudioFiles.html](http://docs.unity3d.com/Manual/AudioFiles.html)'
- en: 'Paladin Studios:'
  id: totrans-600
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Paladin Studios：
- en: '[http://www.paladinstudios.com/2012/07/30/4-ways-to-increase-performance-of-your-unity-game/](http://www.paladinstudios.com/2012/07/30/4-ways-to-increase-performance-of-your-unity-game/)'
  id: totrans-601
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.paladinstudios.com/2012/07/30/4-ways-to-increase-performance-of-your-unity-game/](http://www.paladinstudios.com/2012/07/30/4-ways-to-increase-performance-of-your-unity-game/)'
- en: 'Apple developers audio page:'
  id: totrans-602
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Apple开发者音频页面：
- en: '[https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/MultimediaPG/UsingAudio/UsingAudio.html](https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/MultimediaPG/UsingAudio/UsingAudio.html)'
  id: totrans-603
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/MultimediaPG/UsingAudio/UsingAudio.html](https://developer.apple.com/library/ios/documentation/AudioVideo/Conceptual/MultimediaPG/UsingAudio/UsingAudio.html)'
- en: Physics engine optimization
  id: totrans-604
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 物理引擎优化
- en: 'For some strategies relating to physics, you might consider to improve performance
    the following:'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一些与物理相关的策略，你可能需要考虑以下方法来提高性能：
- en: 'If possible, use **geometric primitive colliders** (2D box/2D circle/3D box/3D
    sphere/3D cylinder):'
  id: totrans-606
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果可能，使用**几何原语碰撞体**（2D盒子/2D圆形/3D盒子/3D球体/3D圆柱体）：
- en: You can have multiple primitive colliders
  id: totrans-607
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你可以有多个原语碰撞体
- en: 'You can also have primitive colliders on child objects:'
  id: totrans-608
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 你也可以在子对象上使用原语碰撞体：
- en: As long as you have a rigid body on the root object in the object hierarchy
  id: totrans-609
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只要对象层次结构中的根对象上有刚体
- en: 'Avoid **2D polygon** and **3D mesh** colliders:'
  id: totrans-610
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用**2D多边形**和**3D网格**碰撞体：
- en: These are much more processor intensive
  id: totrans-611
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这些操作对处理器的需求更大
- en: 'Try increasing the delay between each `FixedUpdate()` method call to reduce
    physics:'
  id: totrans-612
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 尝试增加每次`FixedUpdate()`方法调用之间的延迟，以减少物理计算：
- en: Although not to the point where user experience or game behavior is below acceptable
    quality!
  id: totrans-613
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 虽然不会降低用户体验或游戏行为到不可接受的质量水平！
- en: 'Wherever possible, start off rigid bodies in sleep mode (so that they don''t
    require physics processing until woken up by code or a collision). See the following
    Unity script reference pages for making objects go to sleep and wake up:'
  id: totrans-614
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，将刚体设置为睡眠模式（这样它们在代码唤醒或碰撞之前不需要物理处理）。有关使对象进入睡眠和唤醒的Unity脚本参考页面如下：
- en: '[http://docs.unity3d.com/ScriptReference/Rigidbody.Sleep.html](http://docs.unity3d.com/ScriptReference/Rigidbody.Sleep.html)'
  id: totrans-615
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/ScriptReference/Rigidbody.Sleep.html](http://docs.unity3d.com/ScriptReference/Rigidbody.Sleep.html)'
- en: '[http://docs.unity3d.com/ScriptReference/Rigidbody.WakeUp.html](http://docs.unity3d.com/ScriptReference/Rigidbody.WakeUp.html)'
  id: totrans-616
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/ScriptReference/Rigidbody.WakeUp.html](http://docs.unity3d.com/ScriptReference/Rigidbody.WakeUp.html)'
- en: '![Physics engine optimization](img/1362OT_11_36.jpg)'
  id: totrans-617
  prefs:
  - PREF_IND
  type: TYPE_IMG
  zh: '![物理引擎优化](img/1362OT_11_36.jpg)'
- en: More tips for improving script efficiency
  id: totrans-618
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高脚本效率的更多技巧
- en: 'Some code strategies you might consider to improve performance include the
    following:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑以下一些代码策略来提高性能：
- en: Use **Structs** rather than **Classes** to improve speed up processing.
  id: totrans-620
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用**结构体**而不是**类**来提高处理速度。
- en: Wherever possible, use simple arrays of primitive types rather than **ArrayLists**,
    **Dictionaries,** or more complex collection classes. A good article about choosing
    the most appropriate collection in Unity can be found at [http://wiki.unity3d.com/index.php/Choosing_the_right_collection_type](http://wiki.unity3d.com/index.php/Choosing_the_right_collection_type).
  id: totrans-621
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在可能的情况下，使用简单的原始类型数组而不是**ArrayLists**、**Dictionaries**或更复杂的集合类。关于在Unity中选择最合适的集合类型的好文章可以在[http://wiki.unity3d.com/index.php/Choosing_the_right_collection_type](http://wiki.unity3d.com/index.php/Choosing_the_right_collection_type)找到。
- en: Raycasting is slow, so avoid performing it every frame, for example, use coroutines
    to only raycast every 3rd or 10th frame.
  id: totrans-622
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 光线投射较慢，因此避免每帧都进行光线投射，例如，可以使用协程仅在每3帧或第10帧进行光线投射。
- en: Finding objects is slow, so avoid finding objects in `Update()` or inner loops,
    and you can have objects set up a `public static` variable to allow quick instance
    retrieval, rather than using a `Find(…)` method. Or you could use the Singleton
    design pattern.
  id: totrans-623
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 查找对象较慢，因此避免在`Update()`或内部循环中查找对象，并且你可以让对象设置一个`public static`变量以允许快速实例检索，而不是使用`Find(…)`方法。或者你可以使用Singleton设计模式。
- en: Avoid using `OnGUI()`, since it is called every frame just like `Update()`;
    this is much easier to avoid now with the new Unity 5 UI system.
  id: totrans-624
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 避免使用`OnGUI()`，因为它与`Update()`一样，每帧都会被调用；现在使用新的Unity 5 UI系统更容易避免。
- en: Sources of more wisdom about optimization
  id: totrans-625
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多关于优化的智慧来源
- en: 'Here are several other sources that you might want to explore to learn more
    about game optimization topics:'
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些其他来源，你可能想要探索以了解更多关于游戏优化主题的信息：
- en: 'Unity general mobile optimization page:'
  id: totrans-627
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Unity通用移动优化页面：
- en: '[http://docs.unity3d.com/Manual/MobileOptimisation.html](http://docs.unity3d.com/Manual/MobileOptimisation.html)'
  id: totrans-628
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/Manual/MobileOptimisation.html](http://docs.unity3d.com/Manual/MobileOptimisation.html)'
- en: 'X-team Unity best practices:'
  id: totrans-629
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: X-team Unity最佳实践：
- en: '[http://x-team.com/2014/03/unity-3d-optimisation-and-best-practices-part-1/](http://x-team.com/2014/03/unity-3d-optimisation-and-best-practices-part-1/)'
  id: totrans-630
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://x-team.com/2014/03/unity-3d-optimisation-and-best-practices-part-1/](http://x-team.com/2014/03/unity-3d-optimisation-and-best-practices-part-1/)'
- en: 'Code Project:'
  id: totrans-631
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 代码项目：
- en: '[http://www.codeproject.com/Articles/804021/Unity-and-Csharp-Performance-Optimisation-tips](http://www.codeproject.com/Articles/804021/Unity-and-Csharp-Performance-Optimisation-tips)'
  id: totrans-632
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://www.codeproject.com/Articles/804021/Unity-and-Csharp-Performance-Optimisation-tips](http://www.codeproject.com/Articles/804021/Unity-and-Csharp-Performance-Optimisation-tips)'
- en: 'General graphics optimization:'
  id: totrans-633
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通用图形优化：
- en: '[http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html](http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html)'
  id: totrans-634
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html](http://docs.unity3d.com/Manual/OptimizingGraphicsPerformance.html)'
- en: 'Learn more about mobile physics at Unity''s iPhone optimization physics page:'
  id: totrans-635
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 Unity 的 iPhone 优化物理页面了解更多关于移动物理的信息：
- en: '[http://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html](http://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html)'
  id: totrans-636
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html](http://docs.unity3d.com/Manual/iphone-Optimizing-Physics.html)'
- en: Published articles that discuss premature optimization
  id: totrans-637
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论过早优化的文章
- en: 'Here are several articles discussing Donald Knuth''s famous quotation about
    premature optimization being "evil":'
  id: totrans-638
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些讨论唐纳德·克努特关于过早优化是“邪恶”的著名引言的文章：
- en: 'Joe Duffy''s blog:'
  id: totrans-639
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 乔·达菲的博客：
- en: '[http://joeduffyblog.com/2010/09/06/the-premature-optimization-is-evil-myth/](http://joeduffyblog.com/2010/09/06/the-premature-optimization-is-evil-myth/)'
  id: totrans-640
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://joeduffyblog.com/2010/09/06/the-premature-optimization-is-evil-myth/](http://joeduffyblog.com/2010/09/06/the-premature-optimization-is-evil-myth/)'
- en: '"When is optimization premature?" Stack Overflow:'
  id: totrans-641
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '"何时优化是过早的？" Stack Overflow：'
- en: '[http://stackoverflow.com/questions/385506/when-is-optimisation-premature](http://stackoverflow.com/questions/385506/when-is-optimisation-premature)'
  id: totrans-642
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://stackoverflow.com/questions/385506/when-is-optimisation-premature](http://stackoverflow.com/questions/385506/when-is-optimisation-premature)'
- en: '*The Fallacy of Premature Optimization*, Randall Hyde (published by ACM), source:
    Ubiquity Volume 10, Issue 3, 2009:'
  id: totrans-643
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*过早优化的谬误*，兰德尔·海德（由 ACM 出版），来源：Ubiquity 第 10 卷，第 3 期，2009：'
- en: '[http://ubiquity.acm.org/article.cfm?id=1513451](http://ubiquity.acm.org/article.cfm?id=1513451)'
  id: totrans-644
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[http://ubiquity.acm.org/article.cfm?id=1513451](http://ubiquity.acm.org/article.cfm?id=1513451)'
- en: Sources of more about Game Managers and the State Pattern
  id: totrans-645
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 关于游戏管理器和状态模式的更多信息来源
- en: 'Learn more about implementing the State Pattern and Game Managers in Unity
    from the following sites:'
  id: totrans-646
  prefs: []
  type: TYPE_NORMAL
  zh: 从以下网站了解更多关于在 Unity 中实现状态模式和游戏管理器的信息：
- en: '[http://rusticode.com/2013/12/11/creating-game-manager-using-state-machine-and-singleton-pattern-in-unity3d/](http://rusticode.com/2013/12/11/creating-game-manager-using-state-machine-and-singleton-pattern-in-unity3d/)'
  id: totrans-647
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[http://rusticode.com/2013/12/11/creating-game-manager-using-state-machine-and-singleton-pattern-in-unity3d/](http://rusticode.com/2013/12/11/creating-game-manager-using-state-machine-and-singleton-pattern-in-unity3d/)'
- en: '[https://github.com/thefuntastic/Unity3d-Finite-State-Machine](https://github.com/thefuntastic/Unity3d-Finite-State-Machine)'
  id: totrans-648
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '[https://github.com/thefuntastic/Unity3d-Finite-State-Machine](https://github.com/thefuntastic/Unity3d-Finite-State-Machine)'
