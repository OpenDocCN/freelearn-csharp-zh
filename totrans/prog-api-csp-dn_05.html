<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-67">
    <a id="_idTextAnchor067">
    </a>
    
     5
    
   </h1>
   <h1 id="_idParaDest-68">
    <a id="_idTextAnchor068">
    </a>
    
     Data Validation
    
   </h1>
   <p>
    
     Sending data from your API to the database only to find out that the input is invalid is unnecessarily expensive.
    
    
     Far better is to test the data on the way in to make sure it meets basic criteria.
    
    
     This preliminary set of tests (known as validation) examines the input data to make sure it meets the minimum criteria and that it is
    
    
     
      formatted properly.
     
    
   </p>
   <p>
    
     In this chapter, you will learn
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      How to validate
     
     
      
       input data
      
     
    </li>
    <li>
     
      How to respond to
     
     
      
       invalid data
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-69">
    <a id="_idTextAnchor069">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     For this chapter, create
    
    <a id="_idIndexMarker094">
    </a>
    
     a new branch off the existing
    
    <strong class="bold">
     
      data transfer object
     
    </strong>
    
     (
    
    <strong class="bold">
     
      DTO
     
    </strong>
    
     ) branch (so that we start with valid data).
    
    
     You will need
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="bold">
       
        Visual Studio
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        AutoMapper
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        FluentValidation
       
      </strong>
     
    </li>
   </ul>
   <p>
    
     The
    
    <strong class="source-inline">
     
      FluentValidation
     
    </strong>
    
     library is
    
    <a id="_idIndexMarker095">
    </a>
    
     a powerful tool for creating validators that we will use throughout this chapter.
    
    
     You can install it in various ways, but the easiest is as a NuGet package.
    
    
     You’ll also want the package for ASP.NET, as shown in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    
     <em class="italic">
      
       .1
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 5.1 – NuGet installation" src="img/B21998_05_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.1 – NuGet installation
    
   </p>
   <p>
    
     You can
    
    <a id="_idIndexMarker096">
    </a>
    
     find the complete documentation for
    
    <strong class="source-inline">
     
      FluentValidation
     
    </strong>
    
     at
    
    <a href="https://docs.fluentvalidation.net/en/latest/index.html#">
     
      https://docs.fluentvalidation.net/en/latest/index.html#
     
    </a>
    
     .
    
    
     I will provide detailed steps as we
    
    
     
      go along.
     
    
   </p>
   <p>
    
     The code files for this chapter can be found in the GitHub repository
    
    
     
      here:
     
    
    <a href="https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter05">
     
      
       https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter05
      
     
    </a>
   </p>
   <h1 id="_idParaDest-70">
    <a id="_idTextAnchor070">
    </a>
    
     Tuning your API
    
   </h1>
   <p>
    
     Now that we have the fundamentals for our program, we want to validate the data that is coming in, both to
    
    <a id="_idIndexMarker097">
    </a>
    
     speed things up and to protect against malicious data.
    
    
     We can do that with validation, but first, we need to make a couple of changes to give us good code to
    
    
     
      work with.
     
    
   </p>
   <h1 id="_idParaDest-71">
    <a id="_idTextAnchor071">
    </a>
    
     Paging
    
   </h1>
   <p>
    
     Remember that
    
    <a id="_idIndexMarker098">
    </a>
    
     we are simulating an automobile buying and selling application.
    
    
     There can be literally hundreds of cars in our database.
    
    
     We need to add paging to our
    
    <strong class="source-inline">
     
      Get
     
    </strong>
    
     endpoint so that when we get the list of vehicles, they don’t all come down at once.
    
    
     This will also give us something
    
    
     
      to validate.
     
    
   </p>
   <p>
    
     To facilitate this, we need to know
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      How big the page is – that is, the number of cars on
     
     
      
       each page
      
     
    </li>
    <li>
     
      The index of the page the client wants
     
     
      
       to see
      
     
    </li>
   </ul>
   <p>
    
     We’ll accomplish this by modifying our
    
    <strong class="source-inline">
     
      Get
     
    </strong>
    
     endpoint to take two
    
    
     
      additional parameters:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="source-inline">
       
        pageOffset
       
      </strong>
     
    </li>
    <li>
     
      <strong class="source-inline">
       
        pageSize
       
      </strong>
     
    </li>
   </ul>
   <p>
    
     Both of
    
    <a id="_idIndexMarker099">
    </a>
    
     these are
    
    <strong class="source-inline">
     
      int
     
    </strong>
    
     data types, as
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
[HttpGet]
public async Task&lt;IEnumerable&lt;Car&gt;&gt; Get([FromRoute] bool showDeleted, int pageNumber, int pageSize )</pre>
   <p>
    
     The first new parameter (
    
    <strong class="source-inline">
     
      pageNumber
     
    </strong>
    
     ) will tell
    
    <strong class="source-inline">
     
      Get
     
    </strong>
    
     which page it is on, and the second (
    
    <strong class="source-inline">
     
      pageSize
     
    </strong>
    
     ) will tell how many rows to get.
    
    
     Let’s look at an example in Postman, as shown in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    
     <em class="italic">
      
       .2
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 5.2 – Paging" src="img/B21998_05_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.2 – Paging
    
   </p>
   <p>
    
     Here, we have set
    
    <strong class="source-inline">
     
      pageNumber
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     , indicating we want to start at the beginning of the list, and
    
    <strong class="source-inline">
     
      pageSize
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      3
     
    </strong>
    
     , indicating we want only three records.
    
    
     As a result, the API will extract the first three records.
    
    
     If we set
    
    <strong class="source-inline">
     
      pageNumber
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      3
     
    </strong>
    
     , we will get records
    
    <strong class="source-inline">
     
      10
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      11
     
    </strong>
    
     , and
    
    <strong class="source-inline">
     
      12
     
    </strong>
    
     (that is, start at the fourth page and get the next
    
    
     
      three records).
     
    
   </p>
   <p>
    
     One enhancement you might want to make to reduce confusion for the user is to subtract 1 from the page number to get the offset.
    
    
     This will allow the user to enter Page 1 for
    
    
     
      offset 0.
     
    
   </p>
   <h1 id="_idParaDest-72">
    <a id="_idTextAnchor072">
    </a>
    
     Validation
    
   </h1>
   <p>
    
     It is a best practice to validate the incoming properties on your endpoint
    
    <em class="italic">
     
      before
     
    </em>
    
     executing the
    
    <a id="_idIndexMarker100">
    </a>
    
     associated method.
    
    
     This not only increases the performance of the API, but it also protects you from some forms of hacking (for
    
    
     
      example, injection).
     
    
   </p>
   <p>
    
     Our recommendation is to use the
    
    <strong class="source-inline">
     
      FluentValidation
     
    </strong>
    
     NuGet package, which you can install as shown in the
    
    <em class="italic">
     
      Technical requirements
     
    </em>
    
     section at the start of
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Once installed, you have many options as to how to capture errors.
    
    
     Let’s look at
    
    
     
      a few.
     
    
   </p>
   <h1 id="_idParaDest-73">
    <a id="_idTextAnchor073">
    </a>
    
     Capturing errors
    
   </h1>
   <p>
    
     You’ll
    
    <a id="_idIndexMarker101">
    </a>
    
     remember that our
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     object (defined in
    
    <a href="B21998_03.xhtml#_idTextAnchor038">
     
      <em class="italic">
       
        Chapter 3
       
      </em>
     
    </a>
    
     ) looks
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
public class Car
{
    public int id { get; set; }
    public string name { get; set; }
    public string mpg { get; set; }
    public string cylinders { get; set; }
    public string displacement { get; set; }
    public string horsepower { get; set; }
    public string weight { get; set; }
    public string acceleration { get; set; }
    public string model_year { get; set; }
    public string origin { get; set; }
    public string? is_deleted { get; set;}
}</pre>
   <p>
    
     Let’s also say that cars must not be deleted.
    
    
     You can create a validator for that pretty quickly.
    
    
     First, add a
    
    
     <strong class="source-inline">
      
       Using
      
     </strong>
    
    
     
      statement:
     
    
   </p>
   <pre class="source-code">
Using FluentValidation</pre>
   <p>
    
     Next, create a class that derives
    
    
     
      from
     
    
    
     <strong class="source-inline">
      
       AbstractValidator
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
public class <code>CarDtoValidator</code> : AbstractValidator&lt;Car&gt;</pre>
   <p>
    
     Finally, put your
    
    <a id="_idIndexMarker102">
    </a>
    
     validation rules in the constructor for that class.
    
    
     Each rule is created by using the
    
    <strong class="source-inline">
     
      RuleFor
     
    </strong>
    
     keyword and a lambda expression that indicates which property you want to validate and the validation rule.
    
    
     Our simple example will look
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
using Cars.Data.DTOs;
using FluentValidation;
namespace Cars.Validators
{
    public class <code>CarDtoValidator</code> : AbstractValidator&lt;CarDto&gt;
    {
        public <code>CarDtoValidator()</code>
        {
            RuleFor(x =&gt; x.Is_Deleted).Equal("0");
        }
    }
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      Equal
     
    </strong>
    
     operator is
    
    <a id="_idIndexMarker103">
    </a>
    
     one of many that you can find on the
    
    <strong class="source-inline">
     
      FluentValidation
     
    </strong>
    
     documentation
    
    
     
      page:
     
    
    <a href="https://docs.fluentvalidation.net/en/latest/built-in-validators.html">
     
      
       https://docs.fluentvalidation.net/en/latest/built-in-validators.html
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     We’ll test the data and then either compare it to what is valid and return an error if appropriate, or, more commonly, we’ll throw an exception if the data
    
    
     
      fails validation.
     
    
   </p>
   <h3>
    
     Testing the return value
    
   </h3>
   <p>
    
     There are
    
    <a id="_idIndexMarker104">
    </a>
    
     a number of ways to deal with a validation error.
    
    
     One is to return an error to the calling method.
    
    
     Thus, to validate a
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     object, conceptually you want
    
    
     
      the following:
     
    
   </p>
   <pre class="source-code">
CarDto car = new CarDto();
CarDtoValidator carDtoValidator = new CarDtoValidator ();
carDtoValidator.Validate(car);</pre>
   <p>
    
     In our
    
    <strong class="source-inline">
     
      insert
     
    </strong>
    
     method, we’ll check to make sure
    
    <strong class="source-inline">
     
      CarDto
     
    </strong>
    
     is valid (in this case, that it is
    
    
     
      not deleted):
     
    
   </p>
   <pre class="source-code">
[HttpPost]
 public async Task&lt;ActionResult&lt;Car&gt;&gt; Insert([FromBody] CarDto 
 carAsDto)
 {
     try
     {
         if (carAsDto == null)
         {
             return BadRequest("No car was provided");
         }
         CarDtoValidator validator = new CarDtoValidator();
<strong class="bold">         var result = validator.Validate(carAsDto);</strong>
<strong class="bold">         if (!result.IsValid)</strong>
<strong class="bold">         {</strong>
<strong class="bold">             return BadRequest(result.Errors);</strong>
<strong class="bold">         }</strong>
         var carToInsert = _mapper.Map&lt;Car&gt;(carAsDto);
         var insertedCar = await _carService.Insert(carToInsert);
         var insertedCarDto = _mapper.Map&lt;CarDto&gt;(insertedCar);
         var location = $"https://localhost:5001/car/
         {insertedCarDto.Id}";
         return Created(location, insertedCarDto);
     }
     catch (Exception e)
     {
         return StatusCode(StatusCodes.Status500InternalServerError);
     }
 }</pre>
   <p>
    
     Let’s take
    
    <a id="_idIndexMarker105">
    </a>
    
     a look at returning an error code for data that fails our
    
    
     
      validation check.
     
    
   </p>
   <h3>
    
     Returning an error
    
   </h3>
   <p>
    
     If we
    
    <a id="_idIndexMarker106">
    </a>
    
     now send
    
    <strong class="source-inline">
     
      CarDto
     
    </strong>
    
     to the endpoint using Postman but set
    
    <strong class="source-inline">
     
      Is_Deleted
     
    </strong>
    
     to
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     , we will get an error as shown in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    
     <em class="italic">
      
       .3
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 5.3 – Validation error" src="img/B21998_05_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.3 – Validation error
    
   </p>
   <p>
    
     Notice that
    
    <a id="_idIndexMarker107">
    </a>
    
     the return HTTP value is
    
    <strong class="source-inline">
     
      400 – Bad Request
     
    </strong>
    
     .
    
    
     This makes sense as the DTO passed in was
    
    
     
      not valid.
     
    
   </p>
   <h3>
    
     Adding a custom message
    
   </h3>
   <p>
    
     This input is
    
    <a id="_idIndexMarker108">
    </a>
    
     great and provides a lot of information, but the
    
    <strong class="source-inline">
     
      1
     
    </strong>
    
     value that is in the
    
    <strong class="source-inline">
     
      Is_Deleted
     
    </strong>
    
     field has meaning; specifically that the record is already deleted.
    
    
     This fails the
    
    
     
      validation check.
     
    
   </p>
   <p>
    
     We can make the error clearer with a custom message.
    
    
     Return to
    
    <strong class="source-inline">
     
      CarDtoValidator
     
    </strong>
    
     and modify the rule
    
    
     
      as follows:
     
    
   </p>
   <pre class="source-code">
RuleFor(x =&gt; x.Is_Deleted).Equal("0").<strong class="bold">WithMessage</strong>("Car must not be deleted");</pre>
   <p>
    
     You can see a new error message in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    
     <em class="italic">
      
       .4
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 5.4 – Custom error message" src="img/B21998_05_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.4 – Custom error message
    
   </p>
   <p>
    
     Custom
    
    <a id="_idIndexMarker109">
    </a>
    
     messages provide vital information to your client.
    
    
     They help avoid confusion and make immediately clear what is wrong with the
    
    
     
      submitted data.
     
    
   </p>
   <h3>
    
     Chaining
    
   </h3>
   <p>
    
     If you
    
    <a id="_idIndexMarker110">
    </a>
    
     want to validate more than one aspect of a property, you can chain tests using the
    
    
     <strong class="source-inline">
      
       dot
      
     </strong>
    
    
     
      operator:
     
    
   </p>
   <pre class="source-code">
RuleFor(x=&gt; x.Is_Deleted).NotEmpty().Equal("0").WithMessage("Car must not be deleted");</pre>
   <p>
    
     This test ensures that the
    
    <strong class="source-inline">
     
      Is_Deleted
     
    </strong>
    
     field is not empty and also verifies that its value is equal to
    
    <strong class="source-inline">
     
      0
     
    </strong>
    
     , and returns an error message if the submitted value is
    
    
     
      not valid.
     
    
   </p>
   <p>
    
     The default is that even if the first test (
    
    <strong class="source-inline">
     
      NotEmpty
     
    </strong>
    
     ) fails, the second test will run (
    
    <strong class="source-inline">
     
      Equal("0"
     
    </strong>
    
     ).
    
    
     You can prevent this by
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       CascadeMode
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     If you do not want the second test (
    
    <strong class="source-inline">
     
      NotEmpty
     
    </strong>
    
     ) to run if the first test (
    
    <strong class="source-inline">
     
      Is_Deleted
     
    </strong>
    
     ) fails, use
    
    <strong class="source-inline">
     
      CascadeMode.Stop
     
    </strong>
    
     as
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
RuleFor(x=&gt; x.Is_Deleted)<strong class="bold">.Cascade(CascadeMode.Stop).</strong>NotEmpty().Equal("0").WithMessage("Car must not be deleted");</pre>
   <p>
    
     This now
    
    <a id="_idIndexMarker111">
    </a>
    
     works like
    
    <strong class="source-inline">
     
      &amp;&amp;
     
    </strong>
    
     in C# – that is, if the first test fails the second is never evaluated.
    
    
     The two values for
    
    <strong class="source-inline">
     
      CascadeMode
     
    </strong>
    
     are
    
    <strong class="source-inline">
     
      Stop
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Continue
     
    </strong>
    
     , with the latter being
    
    
     
      the default.
     
    
   </p>
   <h3>
    
     Throwing an exception
    
   </h3>
   <p>
    
     As an
    
    <a id="_idIndexMarker112">
    </a>
    
     alternative to validating and then checking the result, you can call
    
    <strong class="source-inline">
     
      ValidateAndThrow
     
    </strong>
    
     .
    
    
     With this terser expression each of your rules will be evaluated, and if one fails, an exception will
    
    
     
      be thrown:
     
    
   </p>
   <pre class="source-code">
CarDtoValidator validator = new CarDtoValidator();
//var result = validator.Validate(carAsDto);
//if (!result.IsValid)
//{
//    return BadRequest(result.Errors);
//}
<strong class="bold">validator.ValidateAndThrow(carAsDto);</strong></pre>
   <p>
    
     The exception that is thrown is of type
    
    <strong class="source-inline">
     
      ValidationException
     
    </strong>
    
     , so you can test for that in your
    
    <strong class="source-inline">
     
      catch
     
    </strong>
    
     blocks.
    
    
     In addition, that exception has an
    
    <strong class="source-inline">
     
      Errors
     
    </strong>
    
     property, which has the error message for your
    
    
     
      failed attempt.
     
    
   </p>
   <p>
    
     In the next code snippet, you can see how to set up to throw an exception if the validation fails.
    
    
     We create the validator and then call
    
    <strong class="source-inline">
     
      ValidateAndThrow
     
    </strong>
    
     , passing in the
    
    <strong class="source-inline">
     
      Dto
     
    </strong>
    
     object.
    
    
     You
    
    <a id="_idIndexMarker113">
    </a>
    
     can then catch that exception and examine
    
    
     
      the errors:
     
    
   </p>
   <pre class="source-code">
try
{
    if (carAsDto == null)
    {
        return BadRequest("No car was provided");
    }
    CarDtoValidator validator = new CarDtoValidator();
    <strong class="bold">validator.ValidateAndThrow(carAsDto);</strong>
   //…
}
<strong class="bold">catch(ValidationException e)</strong>
<strong class="bold">{</strong>
<strong class="bold">    IEnumerable&lt;ValidationFailure&gt; errors = e.Errors;</strong>
    return BadRequest(errors);
}
catch (Exception e)
{
    return StatusCode(StatusCodes.Status500InternalServerError);
}</pre>
   <p>
    
     To save you the time and effort of creating custom validators for common scenarios,
    
    <strong class="source-inline">
     
      FluentValidation
     
    </strong>
    
     provides a number of
    
    
     
      built-in validators.
     
    
   </p>
   <h1 id="_idParaDest-74">
    <a id="_idTextAnchor074">
    </a>
    
     Built-in validators
    
   </h1>
   <p>
    
     There is a cornucopia of built-in validators in addition to the
    
    <strong class="source-inline">
     
      Equal
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      NotEmpty
     
    </strong>
    
     validators
    
    <a id="_idIndexMarker114">
    </a>
    
     we’ve seen so far.
    
    
     I won’t provide a comprehensive list (see the documentation) but one of the most interesting is the
    
    <strong class="source-inline">
     
      PredicateValidator
     
    </strong>
    
     validator.
    
    
     This passes the value of the property to a delegate, which can use custom validation logic.
    
    
     This is accomplished with the keyword
    
    <strong class="source-inline">
     
      Must
     
    </strong>
    
     keyword, as
    
    
     
      shown here:
     
    
   </p>
   <pre class="source-code">
RuleFor(car =&gt; car.Is_Deleted)<strong class="bold">.Must</strong>(isDeleted =&gt; isDeleted == "0").WithMessage("Car must have value zero");</pre>
   <p>
    
     If this validation fails, the issue is displayed in the results as shown in
    
    
     <em class="italic">
      
       Figure 5
      
     </em>
    
    
     <em class="italic">
      
       .5
      
     </em>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 5.5 – PredicateValidator error" src="img/B21998_05_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 5.5 – PredicateValidator error
    
   </p>
   <p>
    
     There is a
    
    <strong class="source-inline">
     
      RegularExpression
     
    </strong>
    
     validator that uses the
    
    <strong class="source-inline">
     
      Matches
     
    </strong>
    
     keyword (instead of
    
    <strong class="source-inline">
     
      Must
     
    </strong>
    
     ), but one of my favorites is
    
    <strong class="source-inline">
     
      EmailValidator
     
    </strong>
    
     , which ensures that the value submitted is a valid email.
    
    
     Similarly, there is a
    
    
     <strong class="source-inline">
      
       CreditCard
      
     </strong>
    
    
     
      validator:
     
    
   </p>
   <pre class="source-code">
RuleFor(cc =&gt; cc.CreditCard).CreditCard();</pre>
   <p>
    
     There are
    
    <a id="_idIndexMarker115">
    </a>
    
     quite a few more, such as
    
    <strong class="source-inline">
     
      NotNull
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      NotEmpty
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      Equal
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      NotEqual
     
    </strong>
    
     , and
    
    
     
      so forth.
     
    
   </p>
   <p>
    
     The best place to see a complete list of built-in validators and how to use them is in the
    
    <strong class="source-inline">
     
      FluentValidation
     
    </strong>
    
     
      documentation:
     
    
    <a href="https://docs.fluentvalidation.net/en/latest/index.html#">
     
      
       https://docs.fluentvalidation.net/en/latest/index.html#
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-75">
    <a id="_idTextAnchor075">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, you saw how to use
    
    <strong class="source-inline">
     
      FluentValidation
     
    </strong>
    
     to validate input properties before executing code for
    
    
     
      the API.
     
    
   </p>
   <p>
    
     You saw how to create rules, how to chain them, and how to ensure that a second rule in a chain is not evaluated if the
    
    
     
      first fails.
     
    
   </p>
   <p>
    
     You learned two ways of dealing with errors – testing the return error or throwing an exception – and you saw how to create a custom
    
    
     
      error message.
     
    
   </p>
   <p>
    
     In the next chapter, we will turn our attention to Azure Functions – a critical part of programming APIs in .NET.
    
    
     Following that, we will look at Durable Azure Functions and what they add to
    
    
     
      Azure Functions.
     
    
   </p>
   <h1 id="_idParaDest-76">
    <a id="_idTextAnchor076">
    </a>
    
     You try it
    
   </h1>
   <p>
    
     Create a set of rules for the
    
    <strong class="source-inline">
     
      Car
     
    </strong>
    
     class (or another class you create) and throw an exception if a validation rule is violated.
    
    
     Ensure that the failure of the validation
    
    
     
      is handled.
     
    
   </p>
   <p>
    
     As a bonus, create a predicate (
    
    <strong class="source-inline">
     
      must
     
    </strong>
    
     ) custom rule and test
    
    
     
      against that.
     
    
   </p>
  </div>
 </body></html>