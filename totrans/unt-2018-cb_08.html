<html><head></head><body>
        

                            
                    <h1 class="header-title">Lights and Effects</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Directional Light with a cookie Texture to simulate a cloudy day</li>
<li>Creating and applying a cookie Texture to a spotlight</li>
<li>Adding a custom reflection map to a scene</li>
<li>Creating a laser aim with a projector</li>
<li>Enhancing the laser aim with a line renderer</li>
<li>Setting up an environment with Procedural Skybox and Directional Light</li>
<li>Reflecting surrounding objects with reflection probes</li>
<li>Using material emission to bake light from a glowing lamp onto scene objects</li>
<li>Lighting a scene with lightmaps and light probes</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Whether you're trying to make a better-looking game or you want to add interesting features, lights and effects can boost your project and help you deliver a higher quality product. Modern game engines, including Unity, use complex mathematics and physical modelling of how light from light sources interacts with objects in a <strong>Scene</strong>.</p>
<p>For visually realistic virtual game <strong>Scenes</strong>, the game engine must model sources of light, how light falls directly from those sources onto surfaces, and also how light then indirectly bounces from those surfaces to other objects in the scene, and again onto other objects and so on. For rich, complex <strong>Scenes</strong> containing many objects and light sources, it would be impossible to calculate everything from scratch every frame, so pre-computation needs to take place to model these light source and surface interactions.</p>
<p class="mce-root"/>
<p>In this chapter, we will look at the creative ways of using lights and effects, and also take a look at some of Unity's key <strong>Lighting</strong> features, such as Procedural Skyboxes, Reflection emissive <strong>Materials</strong>, Probes, Light Probes, custom Reflection Sources, and <strong>Global Illumination</strong> (<strong>GI</strong>).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The big picture</h1>
                
            
            
                
<p>There are many ways of creating light sources in Unity. Here's a quick overview of the most common methods.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lights</h1>
                
            
            
                
<p>Lights are placed into the scene as GameObjects, featuring a Light component. They can function in Realtime, Baked, or Mixed modes. Among the other properties, they can have their Range, Color, Intensity, and Shadow Type set by the user. There are four types of lights:</p>
<ul>
<li><strong>Directional Light</strong>: This is normally used to simulate the sunlight</li>
<li><strong>Spot Light</strong>: This works like a cone-shaped spot light</li>
<li><strong>Point Light</strong>: This is a bulb-like, omnidirectional light</li>
<li><strong>Area Light</strong>: This baked-only light type is emitted in all directions from a rectangle-shaped entity, allowing for a smooth, realistic shading</li>
</ul>
<p>The following screenshot illustrates different types of lights, with their scene panel icons:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1cf7e68d-aa83-492f-a1a8-423f8e583a2c.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Environment lighting</h1>
                
            
            
                
<p>Unity's Environment Lighting is often achieved through the combination of a Skybox <strong>Material</strong> and sunlight defined by the scene's <strong>Directional Light</strong>. Such a combination creates an ambient light that is integrated into the scene's environment, and which can be set as real-time or baked into <strong>Lightmaps</strong>.</p>
<p>Ambient lighting doesn't come from any locational source, as it exists evenly throughout the scene. Ambient light can be used to influence the overall brightness of a scene:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/af27aa4e-7612-4a3d-b7ae-06b79a62fe02.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Emissive materials</h1>
                
            
            
                
<p>When applied to static objects, materials featuring the Emission colors or maps will cast light over surfaces nearby, in both <strong>Real-Time</strong> and <strong>Baked</strong> modes, as shown in the following screenshot:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/e935fb04-6498-4e0d-9853-ae197c5df3ea.png" style="width:42.17em;height:19.42em;"/></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Projector</h1>
                
            
            
                
<p>As its name suggests, a Projector can be used to simulate projected lights and shadows, basically by projecting a material and its <strong>Texture</strong> map onto the other objects:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/75b02737-7317-418c-924b-a50ed54ed431.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Lightmaps</h1>
                
            
            
                
<p>Lightmaps are basically <strong>Texture</strong> maps generated from the <strong>Scene's</strong> lighting information and applied to the scene's static objects in order to avoid the use of processing-intensive <strong>Real-Time</strong> lighting.</p>
<p>Pre-computation of lighting in a <strong>Scene</strong> is known as Lightmap <em>Baking. Static</em> – immovable – parts of the scene (lights and other objects) can have their lighting "baked" (pre-computed), before the game is run. Then, during <strong>Run-Time</strong>, game performance is improved, since the pre-calculated Lightmaps can be used rather than having to re-calculate each frame at <strong>Run-Time</strong> (although this does require more memory to store the pre-computations).</p>
<p class="mce-root"/>
<p>Unity offers two lightmappers, Enlighten, and more recently the Progressive lightmapper. Enlighten can work well for Precomputed real-time Global Illumination (ambient lighting). The Progressive lightmapper is recommended for Baked Lightmaps.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Light probes</h1>
                
            
            
                
<p>Light Probes are a way of sampling the <strong>Scene's</strong> illumination at specific points in order to have it applied onto dynamic objects without the use of <strong>Real-Time</strong> lighting. <em>Moving</em> (dynamic) objects can use Light Probes so that their lighting changes in relation to where the baked light sources are located in the <strong>Scene</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Lighting settings window</h1>
                
            
            
                
<p>The Lighting window, (menu: Window | Rendering | Lighting Settings), is the hub for setting and adjusting the scene's illumination features, such as Lightmaps, Global Illumination, Fog, and much more:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/0a6dba89-0bc9-4b8a-ac62-cc7f2b5f3d22.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">The Light Explorer panel</h1>
                
            
            
                
<p>When working with Lights and Lighting, a useful tool in Unity is the Lighting Explorer panel, which allows editing and viewing the properties of all of the lights in the current scene. The Lighting Explorer panel lists all Lights in a single panel, making it easy to work with each individually, or change the settings of several at the same time. It can be a great time-saving tool when working with scenes involving lots of Light Game Objects.</p>
<p>To display the Light Explorer panel, choose the following menu: Window | Rendering | Light Explorer:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5ac03c9f-1459-45f7-8197-ae1fdc54c015.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cucoloris cookies</h1>
                
            
            
                
<p>Lights can have a cookie <strong>Texture</strong> applied. Cookies are <strong>Textures</strong> used to cast shadows or silhouettes in a <strong>Scene</strong>. They are produced by using the cookie Texture as a mask between the light source and the surfaces being rendered. Their name, and usage, comes from the use of physical devices called cucoloris (nicknamed cookies) used in theatre and movie production, to give the shadow effects implying environments such as moving clouds, the bars of a prison window, or the sunlight broken up by a jungle leaf canopy.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Color space (Gamma and Linear)</h1>
                
            
            
                
<p>Unity now offers a choice of two Color spaces: Gamma (the default) and Linear. You can select your desired Color Space via the following menu: Edit | Project Settings | Player. While Linear space has significant advantages, it isn't supported by all hardware (especially mobile systems), so which you choose will depend on which platform you are deploying for.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Further resources</h1>
                
            
            
                
<p>This chapter aims to present you with some of Unity's lighting features, and offer a few tricks with lights and effects. As you work through the recipes in this chapter, you may wish to learn more about this chapter's topics from some of these sources:</p>
<ul>
<li>The Unity lighting manual entry: <a href="https://docs.unity3d.com/Manual/Lighting.html">https://docs.unity3d.com/Manual/Lighting.html</a></li>
<li>Unity's <strong>Global Illumination</strong> (<strong>GI</strong>) pages:
<ul>
<li><a href="https://docs.unity3d.com/Manual/GIIntro.html">https://docs.unity3d.com/Manual/GIIntro.html</a></li>
<li><a href="http://docs.unity3d.com/Manual/GlobalIllumination.html">http://docs.unity3d.com/Manual/GlobalIllumination.html</a></li>
</ul>
</li>
<li>Unity's information about cookie <strong>Textures</strong> can be found at their manual page: <a href="https://docs.unity3d.com/Manual/Cookies.html">https://docs.unity3d.com/Manual/Cookies.html</a></li>
<li>Another source about Unity and cookie <strong>Textures</strong> is the <em>CgProgramming WikiBook</em> for Unity: <a href="https://en.wikibooks.org/wiki/Cg_Programming/Unity/Cookies">https://en.wikibooks.org/wiki/Cg_Programming/Unity/Cookies</a></li>
<li>Unity manual about choosing a color space: <a href="https://unity3d.com/learn/tutorials/topics/graphics/choosing-color-space">https://unity3d.com/learn/tutorials/topics/graphics/choosing-color-space</a></li>
<li>Unity manual about the Lighting Explorer panel: <a href="https://docs.unity3d.com/Manual/LightingExplorer.html">https://docs.unity3d.com/Manual/LightingExplorer.html</a></li>
<li>About Linear and Gamma lighting workflows: <a href="https://docs.unity3d.com/Manual/LinearRendering-LinearOrGammaWorkflow.html">https://docs.unity3d.com/Manual/LinearRendering-LinearOrGammaWorkflow.html</a></li>
<li>LMHPoly article on 7 tips for better Unity Lighting: <a href="https://lmhpoly.com/7-tips-for-better-lighting-in-unity/">https://lmhpoly.com/7-tips-for-better-lighting-in-unity/</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Directional Light with cookie Texture to simulate a cloudy day</h1>
                
            
            
                
<p>As can be seen in many first-person shooters and survival horror games, lights and shadows can add a great deal of realism to a <strong>Scene</strong>, helping to create the right atmosphere for the game immensely. In this recipe, we will create a cloudy outdoor environment using cookie <strong>Textures</strong>. Cookie <strong>Textures</strong> work as masks for lights. It functions by adjusting the intensity of the light projection to the cookie texture's alpha channel. This allows for a silhouette effect (just think of the bat signal) or, as in this particular case, subtle variations that give a filtered quality to the lighting.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>If you don't have access to an image editor, or prefer to skip the <strong>Texture</strong> map elaboration in order to focus on the implementation, we have provided the prepared cookie image file cloudCookie.tga, inside the <kbd>07_01</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To simulate a cloudy outdoor environment, follow these steps:</p>
<ol>
<li>In your image editor, create a new 512 x 512 pixel image.</li>
<li>Using black as the foreground color and white as the background color, apply the Clouds filter – in Photoshop, choose the following menu: Filter | Render | Clouds:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/2d798ed3-09b7-469e-944d-e3b5734a00b4.png"/></p>
<p>Learning about the Alpha channel is useful, but you could get the same result without it. Skip steps 3 to 7, save your image as cloudCookie.png and, when changing texture type in step 9, leave Alpha from Greyscale checked.</p>
<ol start="3">
<li>Select your entire image and copy it.</li>
<li>Open the Channels window (in Photoshop, this can be done choosing the following menu: Window | Channels.</li>
<li>There should be three channels: Red, Green, and Blue. Create a new channel. This will be the Alpha channel.</li>
<li>In the Channels window, select the Alpha 1 channel and paste your image into it:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/091ede6b-80fd-4f7f-adf1-a43d80bfedd7.png"/></p>
<ol start="7">
<li>Save your image file as cloudCookie.PSD or TGA.</li>
<li>Import your image file to Unity and select it in the <strong>Project</strong> panel.</li>
<li>From the <strong>Inspector</strong>, change its Texture Type to Cookie and its Light Type to Directional. Then, click on Apply, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/08ab0e68-3598-4d9d-8b16-8cab91722c8f.png"/></p>
<ol start="10">
<li>Let's add a light to our scene. Since we want to simulate sunlight, the best option is to create a <strong>Directional Light</strong>. Choose the Hierarchy menu: Create | Light | Directional Light.</li>
</ol>
<ol start="11">
<li>We will need a surface to actually see the lighting effect. You can either add a 3D plane to your scene (menu: GameObject | 3D Object | Plane), or create a 3D Terrain (menu: GameObject | 3D Object | Terrain).</li>
<li>In the Inspector, reset the light's Transform Position to (<kbd>0, 0, 0</kbd>) and its Rotation to (<kbd>90, 0, 0</kbd>).</li>
<li>In the Cookie field, select the cloudCookie texture that you imported earlier. Change the Cookie Size field to 15, or a value that you feel is more appropriate for the <strong>Scene's</strong> dimensions. Set the Shadow Type as No Shadows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6dfecb4f-03ad-4dcc-b58b-53a72a383e52.png"/></p>
<ol start="14">
<li>Create a new C# script class named ShadowMover, and add an instance object as a component to the <strong>Directional Light</strong>:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px"> public class ShadowMover : MonoBehaviour {<br/>         public float windSpeedX = 2;<br/>         public float windSpeedZ = 2;<br/> <br/>         private float lightCookieSize;<br/>         private Vector3 startPosition;<br/>         private float limitX;<br/>         private float limitZ;<br/>         private Vector3 windMovement;<br/> <br/>         void Start() {<br/>             startPosition = transform.position;<br/>             lightCookieSize = GetComponent&lt;Light&gt;().cookieSize;<br/>             limitX = Mathf.Abs(startPosition.x) + lightCookieSize;<br/>             limitZ = Mathf.Abs(startPosition.z) + lightCookieSize;<br/>             windMovement = new Vector3(windSpeedX, 0, windSpeedZ);<br/>         }<br/> <br/>         void Update() {<br/>             Vector3 position = transform.position + (Time.deltaTime <br/>             * windMovement);<br/>             position.x = WrapValue(position.x, limitX,     <br/>             startPosition.x);<br/>             position.z = WrapValue(position.z, limitZ,         <br/>             startPosition.z);<br/>             transform.position = position;<br/>         }<br/> <br/>         private float WrapValue(float n, float limit, float  <br/>         startValue) {<br/>             float absoluteValue = Mathf.Abs(n);<br/>             if (absoluteValue &gt; limit)<br/>                 return startValue;<br/>             else<br/>                 return n;<br/>         }<br/>     }</pre>
<ol start="15">
<li>Select the Directional Light. In the Inspector, change the parameters Wind Speed X and Wind Speed Z to different values.</li>
<li>Play your scene. The shadows will now be moving.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The script class offers two public values for the X- and Z- speeds of movement (simulating wind).</p>
<p>When the scene starts, first, the initial position of the Directional Light is stored. Then, the size of the cookie is read from the sibling Light component, and used to calculate maximum X and Z values. Finally, a Vector3 is created, for the amount to move our light by in seconds, based on the X and Z window speeds (Y is zero, since we don't need to move the Directional Light in the Y axis).</p>
<p>The <kbd>WrapValue(...)</kbd> method is defined, which returns a value. If the positive value of the first parameter exceeds the second parameter (the limit), then the third parameter (the initial value) is returned. Otherwise, the value of the first parameter is returned. This allows is to ensure that if a value (for example, our X or Z coordinate) goes beyond a limit, we can "wrap" it back to its start value.</p>
<p class="mce-root"/>
<p>The <kbd>Update()</kbd> method is executed in each frame. The next position for the light is calculated (current position plus the current frame's proportion of the wind speed per second vector). The X and Z values of this new position are set using our <kbd>WrapValue(...)</kbd> method, so we know that their limit values are not exceeded. Finally, the position of the light is set to this new position, <kbd>Vector3</kbd>.</p>
<p>The reason we are not enabling shadows is because the light angle for the X axis must be 90 degrees (or there will be a noticeable gap when the light resets to the original position). If you want dynamic shadows in your scene, please add a second <strong>Directional Light</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating and applying a cookie texture to a spotlight</h1>
                
            
            
                
<p>Cookie Textures can work well with Unity <strong>Spotlight</strong>s to simulate shadows coming from projectors, windows, and so on. An example of this would be for the bars of a prison window.</p>
<p>In this recipe, we'll create and apply a cookie <strong>Texture</strong> suitable to use with Unity <strong>Spotlights</strong>:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/f1e123b2-093a-4a82-8397-0653e9e437d0.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>If you don't have access to an image editor, or prefer to skip the <strong>Texture</strong> map elaboration in order to focus on the implementation, we have provided the prepared cookie image file called spotCookie.tif inside the <kbd>07_02</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create and apply a cookie texture to a spotlight, follow these steps:</p>
<ol>
<li>In your image editor, create a new 512 x 512 greyscale pixel image.</li>
<li>Ensure that the border is completely black by setting the brush tool color to black and drawing around the four edges of the image. Then, draw some criss-crossed lines. Save your image, naming it spotCookie:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a45d26bf-879e-4eaa-aede-eba662c5a63d.png"/></p>
<ol start="3">
<li>Import your image file to Unity and select it in the Project panel.</li>
</ol>
<ol start="4">
<li>From the Inspector, change its Texture Type to Cookie and its Light Type to Spotlight, and set the Alpha Source to From Grayscale. Then, click on Apply, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/944c9df7-c815-45f6-ab0b-051b460b5062.png"/></p>
<ol start="5">
<li>Create a scene containing the following:
<ul>
<li>A flat 3D Terrain or Plane as our ground</li>
<li>A 3D Cube or Plane, stretched to act as a wall</li>
<li>Two or three other 3D objects in front of the wall</li>
</ul>
</li>
<li>Position the <strong>Main Camera</strong> to be showing the 3D objects in front of the "wall".</li>
<li>Now, add a Spotlight to the scene by choosing the following menu: Create | Light | Spotlight.</li>
<li>Orient the Spotlight to be pointing in the direction of the <strong>Main Camera</strong>  – you'll probably have to rotate the Y value by 180 degrees.</li>
<li>Set Shadow Type to No Shadows, and drag your spotCookie <strong>Texture</strong> from the Project panel into the Cookie slot.</li>
<li>Play your Scene. You should now see the spotlight casting shadows as if a light had been shone through a grid of planks of wood or metal.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>We created a greyscale Texture for use with Unity Spotlights – that's completely black around the edges – so that light does not "bleed" around the edge of our Spotlight emission. The black lines in the Texture are used by Unity to create shadows in the light emitted from the Spotligh, creating the effect that there are some straight beams of wood or metal through which the Spotlight is being shone.</p>
<p class="mce-root"/>
<p>You can learn more about creating Spotlight cookies in Unity at the Unity tutorial page: <a href="http://docs.unity3d.com/Manual/HOWTO-LightCookie.html">http://docs.unity3d.com/Manual/HOWTO-LightCookie.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a custom Reflection map to a scene</h1>
                
            
            
                
<p>Unity's Standard Shader gets its reflection from the scene's Reflection Source, as configured in the scene section of the Lighting window. The level of reflectiveness for each Material is defined by its Metallic value or Specular value, depending on which Shader is being used. This approach can be a real time-saver, allowing you to quickly assign the same reflection map to every object in the scene. It also helps keep the overall look of the scene coherent and cohesive. In this recipe, we will learn how to take advantage of the Reflection Source feature:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/10c82279-c87a-4a62-a0d6-d9cbcc483828.png" style="width:59.50em;height:28.25em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we will prepare a Reflection Cubemap, which is basically the environment to be projected as a reflection onto the material. It can be made from either six or, as shown in this recipe, a single image file.</p>
<p>To help us with this recipe, we have provided a Unity package (batteryPrefab.unitypackage), containing a prefab made of a 3D object and a basic Material (using a TIFF as a Diffuse map), and also a JPG file to be used as the reflection map. All of these files are inside the <kbd>07_03</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To add Reflectiveness and Specularity to a material, follow these steps:</p>
<ol>
<li>Import the batteryPrefab.unitypackage package into a new project. Then, select the battery_prefab object from the Assets folder, in the <strong>Project</strong> panel.</li>
<li>From the Inspector, expand the <strong>Material</strong> component and observe the asset preview window. Thanks to the Specular map, the material already features a reflective look. However, it looks as if it is reflecting the scene's default Skybox, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/bb7e8060-e994-4381-a5f5-09fb4a21f8e5.png" style="width:49.92em;height:26.92em;"/></p>
<ol start="3">
<li>Import the CustomReflection.jpg image file. Ensure that this asset is selected in the Project panel.</li>
<li>In the Inspector for its Import Settings, set the following properties:
<ul>
<li><strong>Texture Type</strong>: Default</li>
<li><strong>Texture Shape</strong>: Cube</li>
<li><strong>Mapping</strong>: Latitude-Longitude Layout (Cylindrical)</li>
<li><strong>Convolution Type</strong>: None</li>
<li><strong>Fixup Edge Seams</strong>: Checked</li>
<li><strong>Filter Mode</strong>: Trilinear</li>
<li>Now, click on the Apply button, as follows:</li>
</ul>
</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/77e0476b-b1f9-434e-b874-07a5da933ff7.png"/></p>
<ol start="5">
<li>Let's replace the scene's Skybox with our newly created Cubemap as the Reflection map for our scene (menu: Window | Rendering | Lighting Settings).</li>
</ol>
<ol start="6">
<li>Select the <strong>Scene</strong> section and use the drop-down menu to change the Reflection Source to Custom. Finally, assign the newly created CustomReflection texture as the Cubemap, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a3f86985-e065-4875-9955-64ecdf9782db.png"/></p>
<ol start="7">
<li>Check out the new reflections on the battery_prefab object.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The material's specular map provides a reflective look, including the intensity and smoothness of the reflection. However, the image you see in the refection itself is given by the Cubemap that we created.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Reflection Cubemaps can be achieved in many ways and have different mapping properties.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Mapping coordinates</h1>
                
            
            
                
<p>The Cylindrical mapping that we applied was well-suited for the photograph that we used. However, depending on how the reflection image is generated, a Cubic- or Spheremap-based mapping can be more appropriate. Also, note that the Fixup Edge Seams option will try to make the image seamless.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sharp reflections</h1>
                
            
            
                
<p>You might have noticed that the reflection is somewhat blurry compared to the original image; this is because we have ticked the Glossy Reflections box. To get a sharper-looking reflection, deselect this option; in this case, you can also leave the Filter Mode option as default (Bilinear).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Maximum size</h1>
                
            
            
                
<p>At 512 x 512 pixels, our reflection map will probably run fine on lower-end machines. However, if the quality of the reflection map is not very important in your game's context, and the original image dimensions are big (say, 4,096 x 4,096), you might want to change the texture's Max Size from the Import Settings menu to a lower number.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Creating a laser aim with a projector</h1>
                
            
            
                
<p>Although using UI elements, such as a cross-hair, is a valid way to allow players to aim, replacing (or combining) it with a projected laser dot might be a more interesting approach. In this recipe, we will use a light projector to implement this concept:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/8c056206-f8fc-4668-92e3-9449290e9aca.png" style="width:36.58em;height:13.08em;"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>To help us with this recipe, in the <kbd>07_04</kbd> folder, we've provided a Unity package (laserAssets.unitypackage) containing a sample scene featuring a character holding a laser pointer, and also a texture map named LineTexture.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a laser dot aim with a Projector, follow these steps:</p>
<ol>
<li>Start a new 3D project.</li>
<li>We'll be importing the Projectors components from the <strong>Unity Standard Assets</strong>. If you didn't install the <strong>Standard Assets</strong> when you installed Unity, go the the <strong>Asset Store</strong> and install the free <strong>Standard Assets</strong> now.</li>
<li>Import <kbd>laserAssets.unitypackage</kbd> into a new project. Then, open the scene named basic_scene_MsLaser. This is a basic scene, featuring a player character in a maze, with standard arrow keys or WASD movement.</li>
<li>Import the <strong>Projectors</strong> contents from the Effects Unity Standard Assets package folder:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1b104465-fe16-4357-bf92-835121da42c0.png" style="width:36.50em;height:20.75em;"/></p>
<ol start="5">
<li>From the <strong>Inspector</strong>, locate the ProjectorLight shader (inside the Assets | Standard Assets | Effects | Projectors | Shaders folder). Duplicate the file and name the new copy as ProjectorLaser.</li>
<li>Open ProjectorLaser. From the first line of the code, change Shader <kbd>"Projector/Light"</kbd> to Shader <kbd>"Projector/Laser"</kbd>. Then, locate <kbd>Blend DstColor One</kbd> and change it to <kbd>Blend One One</kbd>. Save and close the file:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/2b81dbb7-7f13-44a0-89ee-4983dc962b0b.png" style="width:26.33em;height:15.75em;"/></p>
<p>The reason for editing the shader for the laser was to make it stronger by changing its blend type to Additive. Shader programming is a complex subject, which is beyond the scope of this book. However, if you want to learn more about it, check out Unity's documentation on the subject, which is available at <a href="http://docs.unity3d.com/Manual/SL-Reference.html">http://docs.unity3d.com/Manual/SL-Reference.html</a>, and also the book called <em>Unity Shaders and Effects Cookbook</em>, published by Packt.</p>
<ol start="7">
<li>Create a new material called m_laser. In the Inspector, change its Shader to Projector/Laser.</li>
<li>Locate the Falloff Texture in the <strong>Project</strong> panel (inside Effects | Projectors | Textures).</li>
<li>Open it in your image editor and, except for the first and last columns column of pixels, which should be black, paint everything white. Save the changed image file as Falloff_laser and go back to Unity:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/975973c3-39ff-43e4-8bb6-78b4e70dce8b.png" style="width:18.67em;height:5.50em;"/></p>
<ol start="10">
<li>Select the m_laser asset in the <strong>Project</strong> panel. In the Inspector, set the Main Color to red (RGB: 255, 0, 0). Then, from the texture slots, drag <strong>Texture</strong> Light into the Cookie slot, and <strong>Texture</strong> Falloff_laser into the Falloff slot (these <strong>Textures</strong> are inside your imported folder, Effects | Projectors | Textures):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/1c593dac-3b31-443f-8def-b81718501e15.png" style="width:42.50em;height:14.75em;"/></p>
<ol start="11">
<li>From the <strong>Hierarchy</strong>, find and select the pointerPrefab object (MsLaser | mixamorig:Hips | mixamorig:Spine | mixamorig:Spine1 | mixamorig:Spine2 | mixamorig:RightShoulder | mixamorig:RightArm | mixamorig:RightForeArm | mixamorig:RightHand | pointerPrefab). Then, create a new child GameObject (menu: Create | Create Empty Child). Rename this new child laserProjector:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b5fd3c3e-d3cc-45b6-9685-a3c913efd00b.png" style="width:43.00em;height:22.58em;"/></p>
<ol start="12">
<li>Select the laserProjector object. Then, from the <strong>Inspector</strong>, click the Add Component button and navigate to Effects | Projector. Then, from the new Projector component, set the Orthographic option as true and set Orthographic Size as <kbd>0.1</kbd>. Finally, select m_laser from the Material slot.</li>
<li>Run the scene. You will be able to see the laser aim dot.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In this recipe, the size of the aim dot has been exaggerated. Should you need a more realistic thickness for your laser pointer, change the Orthographic Size of the <strong>Projector</strong> component to something smaller, like 0.025.</p>
<p>The laser aim effect was achieved by using a Projector. A Projector can be used to simulate light, shadows, and more, and is a component that projects a Material (and its Texture) onto other game objects. By attaching a projector to the laserPointer object, we have ensured that it will face the right direction at all times. To get the desired, vibrant look, we edited the projector Material's Shader code, making it brighter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ways to enhance this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Limiting the range of the laser with Raycast hit to limit the far clip plane</h1>
                
            
            
                
<p>Our laser target should highlight the first object it hits – it shouldn't go through all of the objects ahead of it. The project's far clip plane defined the distance at which the projector stops. We can use a simple script to fire a Raycast, and use the distance to the first object it hits as a guide for setting this far clip plane:</p>
<pre class="SourceCode">using UnityEngine;<br/> <br/>     public class LaserAim : MonoBehaviour  {<br/>         private Projector projector;<br/>         private float margin = 0.5f;<br/> <br/>         void Start () {<br/>             projector = GetComponent&lt;Projector&gt; ();<br/>         }<br/> <br/>         void Update ()  {<br/>             RaycastHit hit;<br/>             Vector3 forward =         <br/>             transform.TransformDirection(Vector3.forward);<br/> <br/>             if (Physics.Raycast(transform.position, forward, out hit))<br/>                 projector.farClipPlane = hit.distance + margin;<br/>         }<br/>     }</pre>
<p>If the Raycast hits an object, we set the <strong>Projector</strong> far clip plane to that distance, plus a little margin if 0.5 Unity units (for example, it might be a curved surface).</p>
<p>We scripted a way to prevent projections from going through objects, by setting its far clip plane on approximately the same level of the first object that is receiving the projection. The line of code that is responsible for this action is as follows:</p>
<pre>projector.farClipPlane = hit.distance + margin </pre>


            

            
        
    

        

                            
                    <h1 class="header-title">Further reading</h1>
                
            
            
                
<p>Learn more about projectors from the Unity manual page: <a href="https://docs.unity3d.com/Manual/class-Projector.html">https://docs.unity3d.com/Manual/class-Projector.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Enhancing the laser aim with a Line Renderer</h1>
                
            
            
                
<p>Let's improve the previous recipe by displaying a laser beam from the character's laser gun to the projected laser target. We'll implement the laser beam through scripting a Line Renderer, which is being redrawn each frame:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/12ea8a77-6e6f-4674-a686-7eb991393261.png" style="width:39.33em;height:12.67em;"/></p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe ­is based on the previous one, so make a copy of that project and work with its copy. You'll also need a <strong>Texture</strong> for the beam color; one is provided in the <kbd>07_05</kbd> folder called beam.psd.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To enhance the laser aim with a Line Renderer, follow these steps:</p>
<ol>
<li>Our Line Renderer will need a <strong>Material</strong> to work with. Create a new Material named m_beam.</li>
<li>In the <strong>Inspector</strong>, set the Shader of the m_beam to Particles/Additive. Also, set its Tint Color to red (<strong>RGB</strong>: <kbd>255;0;0</kbd>).</li>
<li>Import the beam image file. Then, set it as the Particle <strong>Texture</strong> for the m_beam, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/e1d367f2-f940-403c-a420-42bee06ca636.png"/></p>
<ol start="4">
<li>Create a new C# script class named LaserBeam, and add an instance object as a component to the Game Object's Laser Projector:</li>
</ol>
<pre style="padding-left: 60px">public class LaserBeam : MonoBehaviour  {<br/>     public float lineWidth = 0.2f;<br/>     public Color regularColor = new Color (0.15f, 0, 0, 1);<br/>     public Material beamMaterial;<br/> <br/>     private Vector3 lineEnd;<br/>     private LineRenderer line;<br/> <br/>     void Start () {<br/>         line = gameObject.AddComponent&lt;LineRenderer&gt;();<br/>         line.material = beamMaterial;<br/>         line.material.SetColor("_TintColor", regularColor);<br/>         line.SetVertexCount(2);<br/>         line.SetWidth(lineWidth, lineWidth);<br/>     }<br/> <br/>     void Update () {<br/>         RaycastHit hit;<br/>         Vector3 forward = <br/>         transform.TransformDirection(Vector3.forward);<br/> <br/>         if (Physics.Raycast (transform.position, forward, out hit))<br/>             lineEnd =  hit.point;<br/>         else<br/>             lineEnd = transform.position + forward * 10f;<br/> <br/>         line.SetPosition(0, transform.position);<br/>         line.SetPosition(1, lineEnd);<br/>     }<br/> }</pre>
<ol start="5">
<li>Select the LaserProjector Game Object. From the Inspector, find the Laser Beam (Script) component and drag the m_beam Material from the Project panel into the Beam Material.</li>
<li>Play the scene. The red laser beam should be shining in a line from the laser gun to the first object hit by the beam.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The laser aim effect was achieved by using a dynamic Line Renderer, which created and updated each frame through code.</p>
<p>In this recipe, the width of the laser beam has been exaggerated. Should you need a more realistic thickness for your beam, change the Line Width field of the Laser Beam (Script) component to 0.05. Also, remember to make the beam more opaque by setting the Regular Color of the Laser Beam component brighter. You'll probably want to match the size of the laser aim Projector, too, so set the Orthographic Size of the <strong>Projector</strong> component to something smaller, such as 0.025.</p>
<p>Regarding the Line Renderer, we have opted to create it dynamically, via code, instead of manually adding the component to the game object.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ways to enhance this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Changing the beam color when the Fire key is held down</h1>
                
            
            
                
<p>It's always good to provide the player with audio or visual feedback when they do something. So, when the player presses the <em>Fire</em> button (for example, the mouse button) let's change the color of the beam. Do the following:</p>
<ol>
<li>Add a new public variable for the fire beam color:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">public Color firingColor = new Color (0.31f, 0, 0, 1);</pre>
<ol start="2">
<li>Add a new method to set up changing a color (using a Sine wave value):</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">private void SetupColor() {<br/>         float lerpSpeed = Mathf.Sin (Time.time * 10f);<br/>         lerpSpeed = Mathf.Abs(lerpSpeed);<br/>         Color lerpColor = Color.Lerp(regularColor, firingColor, <br/>         lerpSpeed);<br/>         line.material.SetColor("_TintColor", lerpColor);<br/>     }</pre>
<ol start="3">
<li>Add statements at the end of the <kbd>Update()</kbd> method to detect when the Fire button is pressed/released to trigger a color change:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">void Update ()  {<br/>         // … (as before)<br/> <br/>         if(Input.GetButton("Fire1"))<br/>             SetupColor();<br/> <br/>         if(Input.GetButtonUp("Fire1"))<br/>             line.material.SetColor("_TintColor", regularColor);<br/>     }</pre>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting up an environment with Procedural Skybox and Directional Light</h1>
                
            
            
                
<p>Besides the traditional six-sided and Cubemap Skyboxes, Unity also features a third type of skybox: the Procedural Skybox. Easy to create and set up, the Procedural Skybox can be used in conjunction with a Directional Light to provide Environment Lighting in your scene. In this recipe, we will learn about the different parameters of the Procedural Skybox:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/1ce3efd7-fb5a-4ba9-a8a6-839ab2563b02.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To set up Environment Lighting using the Procedural Skybox and <strong>Directional Light</strong>, follow these steps:</p>
<ol>
<li>Create a new <strong>Scene</strong> inside a Unity project. Observe that a new scene already includes two objects: the Main Camera and a Directional Light.</li>
<li>In the scene, create a 3D Plane named Plane-ground; positioned at (0, 0, 0) and scaled to (<kbd>20, 20, 20</kbd>).</li>
<li>Add some 3D Cubes to your scene, like so:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/db1ab526-ed1f-4ee3-8a1a-74d7626c56af.png"/></p>
<ol start="4">
<li>Create a new <strong>Material</strong> asset file named m_skybox. In the Inspector, change the Shader from Standard to Skybox/Procedural.</li>
<li>Open the Lighting window (Window | Rendering | Lighting Settings), and access the scene section. In the Environment Lighting subsection, populate the Skybox slot with the m_skybox Material, and the Sun slot with the scene's default Directional Light. Ensure that the real-time Global Illumination option is checked (from real-time Lighting), and that the Environment Ambient Mode is set to real-time.</li>
<li>From the <strong>Project</strong> panel, select m_skybox. Then, from the Inspector, set the Sun Size as 0.05 and the Atmosphere Thickness as 1.4. Experiment by changing the Sky Tint color to RGB: 148; 128; 128, and the Ground color to a value that resembles the scene cube floor's color (such as RGB: 202; 202; 202). If you feel that the scene is too bright, try bringing the Exposure level down to 0.85, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/bbebd520-8302-4a77-a6bb-b01c3a73b3d9.png"/></p>
<p class="mce-root"/>
<ol start="7">
<li>Select the Directional Light and change its Rotation to 5, 170, 0. Also ensure that its Light Mode setting is real-time (not baked or Mixed).</li>
<li>Run the scene  – it should resemble a dawning environment.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Ultimately, the appearance of Unity's native Procedural Skyboxes depends on the five parameters that make them up:</p>
<ul>
<li>Sun size: The size of the bright yellow sun that is drawn onto the Skybox is located according to the Directional Light's Rotation on the X and Y axes.</li>
<li>Atmosphere Thickness: This simulates how dense the atmosphere is for this Skybox. Lower values (less than 1.0) are good for simulating the outer space settings. Moderate values (around 1.0) are suitable for earth-based environments. Values that are slightly above 1.0 can be useful when simulating air pollution and other dramatic settings. Exaggerated values (for example, more than 2.0) can help to illustrate extreme conditions or even alien settings.</li>
<li>Sky Tint: This is the color that is used to tint the Skybox. It is useful for fine-tuning or creating stylized environments.</li>
<li>Ground: This is the color of the ground. It can really affect the Global Illumination of the scene. So, choose a value that is close to the level's terrain and/or geometry (or a neutral one).</li>
<li>Exposure: This determines the amount of light that gets in the Skybox. The higher levels simulate overexposure, while the lower values simulate underexposure.</li>
</ul>
<p>It is important to note that the Skybox appearance will respond to the scene's Directional Light, playing the role of the sun. In this case, rotating the light around its X axis can create dawn and sunset scenarios, whereas rotating it around its Y axis will change the position of the sun, changing the cardinal points of the scene.</p>
<p>Also, regarding the Environment Lighting, note that although we have used the Skybox as the Ambient Source, we could have chosen a Gradient or a single color instead, in which case the scene's illumination wouldn't be attached to the Skybox's appearance.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Finally, also regarding the Environment Lighting, please note that we have set the Ambient GI to real-time. The reason for this was to allow the real-time changes in the GI, promoted by the rotating Directional Light. In case we didn't need these changes at runtime, we could have chosen the baked alternative.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>Here are some ways to enhance this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Setting and rising the sun through scripted rotation of Directional Light</h1>
                
            
            
                
<p>Let's make things even more interesting by using code to change the rotation of the Directional Light. This will give a dynamic rising/setting sun effect as our scene runs.</p>
<p>Ceate a new C# script class named RotateLight, and add an instance object as a component to the Directional Light Game Object:</p>
<pre class="SourceCode" style="padding-left: 60px">using UnityEngine;<br/>     using System.Collections;<br/>     public class RotateLight : MonoBehaviour {<br/>       public float speed = -1.0f;<br/>       void Update () {<br/>         transform.Rotate(Vector3.right * speed * Time.deltaTime);<br/>       }<br/>     }</pre>
<p>Now, when you run the scene, you will see the sun rising/setting and the lighting colors changing accordingly.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Adding a sun flare</h1>
                
            
            
                
<p>Let's add a sun flare effect to our scene.</p>
<p>For this step, you will need to import Unity's Standard Assets Effects package, which you should have installed when you installed Unity, but you can also add it to an individual project via the Unity Asset Store.</p>
<ol>
<li>Import the Light Flares contents from the Effects Unity Standard Assets package folder.</li>
</ol>
<ol start="2">
<li>Select the Directional Light. In the Inspector, for the Light component, populate the Flare slot with the sun flare (from the project panel, the Effects | Light Flares | Flares folder).</li>
<li>From the scene section of the Lighting window, find the Other Settings subsection. Then, set Flare Fade Speed to 1 and Flare Strength to 0.46, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/977297a5-2005-4b84-a05b-e6021e33e58e.png"/></p>
<ol start="4">
<li>Play the scene. A sun flare effect should have been applied to the scene's lighting.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">Reflecting surrounding objects with Reflection Probes</h1>
                
            
            
                
<p>If you want your scene's environment to be reflected by Game Objects by featuring reflective Materials (such as the ones with high Metallic or Specular levels), then you can achieve such an effect by using Reflection Probes. They allow for real-time, baked, or even Custom reflections through the use of Cubemaps.</p>
<p>real-time reflections can be expensive in terms of processing; in which case, you should favor baked reflections, unless it's really necessary to display dynamic objects being reflected (mirror-like objects, for instance). Still, there are some ways real-time reflections can be optimized. In this recipe, we will test three different configurations for reflection probes:</p>
<ul>
<li>real-time reflections (constantly updated)</li>
<li>real-time reflections (updated on-demand via scripting)</li>
<li>baked reflections (from the editor)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared a basic scene, featuring three sets of reflective objects: one is constantly moving, one is static, and one moves whenever it is interacted with. The <kbd>reflectionProbes.unitypackage</kbd> package that is containing the scene can be found inside the <kbd>07_07</kbd> folder.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To reflect the surrounding objects using the Reflection Probes, follow these steps:</p>
<ol start="1">
<li>Import the Unity package <kbd>reflectionProbes.unitypackage</kbd>. Then, open the scene named reflective_objects. This is a basic scene featuring three sets of reflective objects.</li>
<li>Ensure that the Quality setting for the project has enabled real-time Reflection Probes. Do this by choosing menu: Edit | Project Settings | Quality, and ensuring that the real-time Reflection Probes option is checked for the quality setting you wish to use.</li>
<li>Play the scene. Observe that one of the systems is dynamic, one is static, and one rotates randomly, whenever a key is pressed.</li>
<li>Stop the scene.</li>
<li>First, let's create a constantly updated real-time Reflection Probe for the scene (menu: Create | Light | Reflection Probe). Name it ReflectionProbe-real-time.</li>
<li>Make ReflectionProbe-real-time a child of the Game Object System 1 real-time | MainSphere. Then, in the Inspector, set its Transform Position to (0, 0, 0):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/a3b50102-891d-44f1-875d-145f4d30f154.png"/></p>
<p class="mce-root"/>
<ol start="7">
<li>In the Inspector, find the Reflection Probe component. Set the Type as real-time, Refresh Mode as Every Frame, and Time Slicing as No time slicing, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/c4253593-b2c5-44f6-8e20-c2af70874c7d.png"/></p>
<ol start="8">
<li>Play the scene. The reflections on System 1 real-time will now be updated in real-time. Stop the scene.</li>
<li>Observe that the only object displaying the real-time reflections is System 1 real-time | MainSphere. The reason for this is the size of the box of the Reflection Probe. From the Reflection Probe component, change its size to (25, 10, 25). Note that the small red spheres are now affected as well. However, it is important to note that all objects display the same reflection. Since our Reflection Probe's origin is placed at the same location as the MainSphere, all reflective objects will display reflections from that point of view:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f3446e6a-e0d9-41b8-99e0-bc5164cb79b0.png"/></p>
<p class="mce-root"/>
<ol start="10">
<li>If you want to eliminate the reflection from the reflective objects within the Reflection Probe, such as the small red spheres, select the objects and, from the Mesh Renderer component, set Reflection Probes as Off, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ebb2c12a-221a-4f57-83c0-ae8ae69c33ab.png"/></p>
<ol start="11">
<li>Add a new Reflection Probe to the scene. This time, name it ReflectionProbe-onDemand and make it a child of the System 2 On Demand | MainSphere GameObject. Then, in the Inspector, change its transform position to (0,0,0).</li>
<li>Now, go to the Reflection Probe component. Set Type as real-time, Refresh Mode as Via scripting, and Time Slicing as Individual faces, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8920f18b-65a6-4d85-a52d-b83fb1ca4e72.png"/></p>
<ol start="13">
<li>Create a new C# script class named UpdateProbe, and add an instance object as a component to GameObject ReflectionProbe-onDemand:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px"> using UnityEngine;<br/> using System.Collections;<br/> <br/> public class UpdateProbe : MonoBehaviour {<br/>    private ReflectionProbe probe;<br/> <br/>    void Awake () {<br/>       probe = GetComponent&lt;ReflectionProbe&gt; ();<br/>       probe.RenderProbe();<br/>    }<br/> <br/>    public void RefreshProbe(){<br/>       probe.RenderProbe();<br/>    }<br/> }</pre>
<ol start="14">
<li>Now, find the script class named RandomRotation, which is attached to the System 2 On Demand | Spheres object, and replace it with the following:</li>
</ol>
<pre class="SourceCode" style="padding-left: 60px">using UnityEngine;<br/> <br/>public class RandomRotation : MonoBehaviour {<br/>   private GameObject probe;<br/>   private UpdateProbe updateProbe;<br/> <br/>   void Awake() {<br/>      probe = GameObject.Find("ReflectionProbe-onDemand");<br/>      updateProbe = probe.GetComponent&lt;UpdateProbe&gt;();<br/>   }<br/> <br/>   void Update () {<br/>      if (Input.anyKeyDown) {<br/>          Vector3 newRotation = transform.eulerAngles;<br/>          newRotation.y = Random.Range(0F, 360F);<br/>          transform.eulerAngles = newRotation;<br/>          updateProbe.RefreshProbe();<br/>      }<br/>   }<br/>}</pre>
<ol start="15">
<li>Save the script and test your scene. Observe how the Reflection Probe is updated whenever a key is pressed.</li>
<li>Stop the scene. Add a third Reflection Probe to the scene. Name it ReflectionProbe-custom and make it a child of the System 3 On Custom | MainSphere GameObject. Then, from the Inspector, change its Transform Position to (0,0,0).</li>
</ol>
<ol start="17">
<li>Go to the Reflection Probe component. Set Type as Custom and click on the Bake button, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6743b6f1-ab65-40a9-b4fd-1fd00639c0f7.png"/></p>
<ol start="18">
<li>A Save File dialog window will show up. Save the file as ReflectionProbe-custom-reflectionHDR.exr.</li>
</ol>
<ol start="19">
<li>Observe that the reflection map does not include the reflection of red spheres on it. To change this, you have two options: set the System 3 On Custom | Spheres GameObject (and all its children) as Reflection Probe Static, like so:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/598c9a68-f0ae-4fb3-8ebc-769daec38cfd.png" style="width:37.67em;height:41.08em;"/></p>
<ol start="20">
<li>Or check the Dynamic Objects option Reflection Probe component of the ReflectionProbe-custom GameObject. Note that with this option, you will also see a reflection of the other two large spheres and their belt of red spheres in the reflection on the MainSphere of System 3 Custom.</li>
</ol>
<ol start="21">
<li>Select GameObject ReflectionProbe-custom, and click the Bake button again. You should now see the reflection of red spheres on it.</li>
<li>If you want your reflection Cubemap to be dynamically baked while you edit your scene, you can set the Reflection Probe Type to baked, open the Lighting window (menu: Window | Rendering | Lighting Settings), access the scene section, and check the Auto Generate option, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/ec69e6fb-7c18-4432-ba07-5768ab822e07.png"/></p>
<p>This mode won't include dynamic objects in the reflection, so be sure to set System 3 Custom | Spheres and System 3 Custom | MainSphere as Reflection Probe Static.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The Reflection Probes element acts like omnidirectional cameras that render Cubemaps and applies them onto the objects within their constraints. When creating Reflection Probes, it's important to be aware of how the different types work:</p>
<ul>
<li><strong>Real-time Reflection Probes</strong>: <strong>Cubemaps</strong> are updated at runtime. The real-time Reflection Probes have three different Refresh Modes: On Awake (Cubemap is baked once, right before the scene starts); Every frame (Cubemap is constantly updated); Via scripting (Cubemap is updated whenever the RenderProbe function is used). Since Cubemaps feature six sides, the Reflection Probes features Time Slicing, so each side can be updated independently. There are three different types of Time Slicing: All Faces at Once (renders all faces at once and calculates mipmaps over 6 frames. It updates the probe in 9 frames); Individual Faces (each face is rendered over a number of frames. It updates the probe in 14 frames. The results can be a bit inaccurate, but it is the least expensive solution in terms of frame rate impact); No Time Slicing (the Probe is rendered and mipmaps are calculated in one frame. It provides high accuracy, but it also the most expensive in terms of frame rate).</li>
<li>baked: Cubemaps are baked when editing the screen. Cubemaps can be either manually or automatically updated, depending on whether the Auto Generation option is checked (it can be found at the Scene section of the Lighting Settings window).</li>
<li>Custom: The Custom Reflection Probes can be either manually baked from the scene (and even include Dynamic objects), or created from a premade Cubemap.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are a number of additional settings that can be tweaked, such as Importance, Intensity, Box Projection, Resolution, HDR (Hight Dynamic Range), and so on. For a complete view on each of these settings, we strongly recommend that you read Unity's documentation on the subject, which is available at <a href="http://docs.unity3d.com/Manual/class-ReflectionProbe.html">http://docs.unity3d.com/Manual/class-ReflectionProbe.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Using Material Emission to bake light from a glowing lamp onto scene objects</h1>
                
            
            
                
<p>As well as Lights, other objects can also emit light if their Materials have Emmision properties (such as a Texture, and/or tint color). In this recipe we'll create a lamp that glows green via its Emission Texture. The lamp and other 3D objects in the scene will be baked in order to create a pre-computed Lightmap for the scene:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/72bc19b6-ed07-4243-8c82-8c248898838e.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have provided a 3D lamp model (lamp), as well as a green Texture (lamp_emission) in the <kbd>lamp.unitypackage</kbd> Unity package in the <kbd>07_08</kbd> folder .</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a glowing lamp using Material Emission, follow these steps:</p>
<ol>
<li>Create a new 3D Project. You should start with a basic <strong>scene</strong> containing a Main Camera and a Directional Light.</li>
<li>Import the Unity package <kbd>lamp.unitypackage</kbd> containing the 3D lamp model (lamp), as well as a green Texture (lamp_emission).</li>
<li>With the 3D model asset lamp selected in the Project panel, in the Inspector, check its Generate Lightmap UVs option, and click on the Apply button to confirm the changes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/b9f09f3a-3ac6-475a-9b55-eb1c5a3aefb2.png"/></p>
<p class="mce-root"/>
<ol start="4">
<li>In the Project panel, select Material m_lamp. Check the Emission option, and then assign Texture lamp_emission to its Emission Color property. Set the Global Illumination drop-down menu to baked. This will make the lamp object emit a green light that will be baked into the Lightmap:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/25a9c5cc-44c6-4b12-8fcd-87ce395edfe9.png"/></p>
<ol start="5">
<li>Also, for <strong>Material</strong> m_lamp, click the HDR color box, and increase the intensity of this light emitting Material to 1 or 2 (this is a value you may wish to play with and "tweak" in order to get your desired settings for a scene):</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/3625d0fc-d38f-481b-a77e-ccc329e3a0e7.png"/></p>
<ol start="6">
<li>Add some 3D GameObjects to create a simple 3D scene containing a 3D Plane (the ground) and three 3D cubes. Position and scale the 3D cubes so that there is large one at the back of the 3D Plane, a medium sized one in the middle, and a small one in the front.</li>
<li>Now, drag an instance of the 3D lamp model from the Project panel into the scene, placing it near the front-most 3D cube:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f30a7637-0f32-4ad2-b990-d92d2f0b533c.png"/></p>
<ol start="8">
<li>You may need to adjust the Main Camera position and rotation so that you can see the lamp and the three 3D cubes sitting on the 3D Plane.</li>
<li>Baked lighting only works for static objects, so, with the exception of the Main Camera, select everything in the Hierarchy and check the Static option at the top-right of the Inspector panel:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/0dffc329-6fdc-4607-a0c6-19a9bddc41a1.png"/></p>
<ol start="10">
<li>Now, select the Directional Light in the Hierarchy and change its Light Mode drop-down menu property to baked:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/558568d7-d39a-461a-bb3f-867941a07e66.png"/></p>
<ol start="11">
<li>We can now assign the <strong>Directional Light</strong> as an Environmental Lighting Sun source. Open the Lighting Settings window (choose menu: Window | Rendering | Lighting Settings), and drag the <strong>Directional Light</strong> from the <strong>Hierarchy</strong> into the Sun slot for the scene Environment properties. Also, set the Environment Lighting Ambient Mode drop-down menu to baked. In the Debug Settings, uncheck Auto Generate and click the Generate Lighting button to "bake" the Ambient light and green lamp emission light into the Scene:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7d55fc5d-37d4-4cc4-992f-d8b15ae8ccb2.png"/></p>
<ol start="12">
<li>For a few seconds (depending on the speed of your computer and the complexity of the scene), you'll see a progess bar of the Lightmap baking process at the bottom-right of the Unity Editor application window:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8aae3ffc-2d07-4b23-a377-60ce4cd5b95a.png" style="width:22.67em;height:2.33em;"/></p>
<p class="mce-root"/>
<ol start="13">
<li>Play your <strong>Scene</strong>. You should see how the <strong>Scene</strong> objects are lit both by the Directional Light, and by the green Texture emitted from the lamp.</li>
<li>Change the rotation of the Directional Light, and try setting its Light Intensity and Indirect Multiplier to 0.5. Also, play with the HDR intensity of the Material m_lamp, and re-bake the Lightmap to make the lamp emission more emphasized (and the <strong>Directional Light</strong> play a lessor role).</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You have added an emissive <strong>Material</strong> to a GameObject (the lamp), and baked a Lightmap based on the static objects in the <strong>Scene</strong> (which include the lamp, the <strong>Directional Light</strong>, and the 3D Plane and cubes). The environment's Global Illumination ambient lighting is sourced from the Directional Light settings.</p>
<p>Lightmaps are basically Texture maps including scene lights/shadows, global illumination, indirect illumination, and objects featuring the Emissive Materials. They can be generated automatically or on demand by Unity's lighting engine. However, there are some points that you should pay attention to, such as the following:</p>
<ul>
<li>Set all the non-moving objects and lights to be baked as Static</li>
<li>Set the game lights as Baked</li>
<li>Set the scene's Ambient GI as Baked</li>
<li>Set the Global Illumination option of the emissive materials as baked</li>
<li>Generate Light UVs for all 3D meshes (specially the imported ones)</li>
<li>Either build the Lightmaps manually from the Lighting Settings window, or check the Auto Generate option</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Lighting a simple scene with Lightmaps and Light Probes</h1>
                
            
            
                
<p>Lightmaps are a great alternative to real-time lighting, as they can provide the desired look to an environment without being processor-intensive. There is one downside, though – since there is no way of baking Lightmaps onto the dynamic objects, the lighting of the important elements of the game (such as player characters themselves) can look artificial, failing to match the intensity of the surrounding area. The solution? Light Probes.</p>
<p class="mce-root"/>
<p>Light Probes work by sampling the light intensity over the location that they are placed at. Dynamic objects, once Light Probe-enabled, will be lit according to the interpolation of the nearest probes around them:</p>
<p class="CDPAlignCenter CDPAlign"><img src="img/5e09c847-75d9-42bc-859a-3f5c5f281e9f.png"/></p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>For this recipe, we have prepared a basic Unity package (rollerballLevel.unitypackage), including a game environment containing emissive lamps (from the previous recipe!), and Game Objects, making a suitable level for a RollerBall game. The Game Objects are static, and the Directional Light and Emissive Material are set to baked, so the scene has been set up as a baked Lightmapped scene.</p>
<p>The rollerBallLevel.unitypackage package, containing the scene, can be found inside the <kbd>07_09</kbd> folder. You'll also find the two PNG images you need to create the RollerBall Material (RollerBallAlbedo.png and RollerBallSpecularGloss.png).</p>
<p>The geometry for this scene was created using ProBuilder, an extension developed by ProCore, which is now free as part of Unity 2018. ProBuilder is a fantastic level design tool that speeds up the design process considerably for both simple and complex level design. You can learn more at <a href="http://www.procore3d.com">http://www.procore3d.com</a> and <a href="https://blogs.unity3d.com/2018/02/15/probuilder-joins-unity-offering-integrated-in-editor-advanced-level-design/">https://blogs.unity3d.com/2018/02/15/probuilder-joins-unity-offering-integrated-in-editor-advanced-level-design/</a>.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To reflect the surrounding objects using the Reflection Probes, follow these steps:</p>
<ol>
<li>Import rollerBallLevel.unitypackage into a new project. Then, open the scene named scene0_level_baked. The scene features a basic environment, with a Directional Light and some green emissive lamps.</li>
<li>Import Standard Assets into your project. We need three packages, as follows:
<ul>
<li>Cameras</li>
<li>Characters (we need the RollerBall, so you can uncheck FirstPersonCharacter and ThirdPersonCharacter when importing)</li>
<li>Effects (we just need the Projectors assets, so you can uncheck all other folders apart from that one when importing)</li>
</ul>
</li>
<li>Drag the RollerBall prefab from the <strong>Project</strong> panel (Standard Assets | Characters | RollerBall | Prefabs) into the scene.</li>
<li>Drag the FreeLookCameraRig prefab from the <strong>Project</strong> panel (Standard Assets | Cameras | Prefabs) into the scene. If this does not automatically target the RollerBall character, then drag the RollerBall Game Object from the <strong>Hierarchy</strong> into the Free Look Cam (Script) Target slot in the <strong>Inspector</strong>.</li>
<li>Let's add a little color to our RollerBall by creating and applying a new <strong>Material</strong> for this GameObject. Create a new Material m_rollerballColor with a Specular setup. Set the Albedo Texture to RollerBallAlbedo and its tint to 127/127/127. Set the Specular Texture to RollerBallSpecularGloss.</li>
<li>Select Game Object RollerBall in the <strong>Hierarchy</strong>. Apply the m_rollerballColor <strong>Material</strong> to the RollerBall Game Object. This should now be a two-colored ball.</li>
</ol>
<ol start="7">
<li>We now need to ensure that the RollerBall GameObject will be dynamically affected by Light Probes, so with Game Object RollerBall still selected in the Hierarchy, for the Mesh Renderer component for the Light Probes option, choose the Blend Probes option from the drop-down menu:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d3b17fbc-c1d1-409a-b690-745e2db1ad2c.png"/></p>
<ol start="8">
<li>Now, we need to create the Light Probes for the scene. Choose the Hierarchy menu: Create | Light | Light Probe Group. This will give you a basic group of eight Light Probes, arranged in pairs to form a cubic volume.</li>
</ol>
<p>It is important to note that even if you are working on a level that is flat, you shouldn't place all your probes on the same level, as Light Probe Groups will form a volume in order for the interpolation to be calculated correctly.</p>
<ol start="9">
<li>To facilitate the manipulation of the probes, type <strong>Probe</strong> into the search field of the Hierarchy panel. This will isolate the newly created Light Probe Group, making it the only editable object on the scene:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d1cc991c-8776-40d9-ba91-193396c50b6e.png"/></p>
<ol start="10">
<li>Change your viewport layout to 4 Split by choosing Window | Layouts | 4 Split. Then, set viewports as Top, Front, Right, and Persp. Optionally, change Top, Front, and Right views to Wireframe mode. Finally, make sure that they are set to Orthographic view, as shown in the following screenshot. This will make it easier for you to position the Light Probes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/d470e30f-9659-4ce5-9704-84340d157293.png"/></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="11">
<li>Position the initial Light Probes at the corners of the top room of the level. To move the Probes around, simply click and drag them, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/333f2e3e-1ed4-47a6-a342-6d0b3eb9a8f6.png"/></p>
<ol start="12">
<li>Select the four probes to the left side of the tunnel's entrance. Then, duplicate them (use the <em>Ctrl/Cmd + D</em> keys). Finally, drag the new probes slightly to the right, to a point that they are no longer over the shadow that is projected by the wall, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/2ed9c4e6-67cb-4df5-b159-c45bb722c52f.png"/></p>
<p class="mce-root"/>
<ol start="13">
<li>Repeat the last step, this time duplicating the probes next to the tunnel's entrance and bringing them inward toward the group. To delete the selected probes, either use the respective button on the Light Probe Group component, or use the <em>Ctrl/Cmd + Backspace</em> keys:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/7704c28b-874e-4a22-b873-f34c77a2fc43.png"/></p>
<ol start="14">
<li>Duplicate and reposition the four probes that are nearest to the tunnel, repeating the operation five times and conforming each duplicate set to the shadow projected by the tunnel:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/8beb8aca-bcf0-4409-9a45-5b45aa6295dd.png"/></p>
<p class="mce-root"/>
<ol start="15">
<li>Use the Add Probe button to place the three probes over well-lit areas of the scene:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/beaef73f-b81e-416b-967f-005384f857ab.png"/></p>
<ol start="16">
<li>Now, add Light Probes within the shadow that is projected by the L-shaped wall:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6093f2df-5778-4305-9047-51375d48c138.png"/></p>
<ol start="17">
<li>Since the Rollerball is able to jump, place the higher probes even higher so that they will sample the lighting above the shadowed areas of the scene:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/6805e6ad-fca4-41f2-9abd-9cd5f466332a.png" style="width:31.33em;height:13.92em;"/></p>
<ol start="18">
<li>Placing too many Light Probes on a scene might be memory intensive. Try optimizing the Light Probes Group by removing the probes from the regions that the player won't have access to. Also, avoid overcrowding the regions of continuous lighting conditions by removing the probes that are too close to others in the same lighting condition:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/bc5888fa-5610-42cc-a2db-84aed4342886.png" style="width:33.75em;height:28.83em;"/></p>
<ol start="19">
<li>To check out which Light Probes are influencing the Rollerball at any place, move the Rollerball Game Object around the scene. A polyhedron will indicate which probes are being interpolated at that position, as follows:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/99f89ca1-7468-4067-a51c-29e931c04614.png"/></p>
<ol start="20">
<li>From the bottom of the Lighting Settings window, click on the Generate Lighting button and wait for the Lightmaps to be baked.</li>
<li>Test the scene. The Rollerball will be lit according to the Light Probes:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/f115318f-ebc8-4883-ae64-8b64b081a35d.png" style="width:43.58em;height:17.50em;"/></p>
<ol start="22">
<li>Keep adding probes until the level is completely covered.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>Light Probes work by sampling the scene's illumination at the point that they're placed at. A dynamic object that has Use Light Probes enabled has its lighting determined by the interpolation between the lighting values of the four Light Probes, defining a volume around it (or, in case there are no probes suited to define a volume around the dynamic object, a triangulation between the nearest probes is used).</p>
<p>More information on this subject can be found in the Unity's documentation at <a href="http://docs.unity3d.com/Manual/LightProbes.html">http://docs.unity3d.com/Manual/LightProbes.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>In case you can spare some processing power, you can exchange the use of Light probes for a Mixed light.</p>
<p>Do the following:</p>
<ol>
<li>Delete the Light Probe Group from your scene.</li>
<li>Select the <strong>Directional Light</strong> and, from the Light component, change Baking to Mixed.</li>
<li>Set Shadow Type as Soft Shadows and Strength as 0.5, as shown in the following screenshot:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="img/9e3fd18f-9612-4bfc-8122-87001918ac49.png" style="width:41.25em;height:17.58em;"/></p>
<ol start="4">
<li>Finally, click on the Generate Lighting button and wait for the Lightmaps to be baked. The <strong>Real-Time</strong> light/shadows will be cast into/from the dynamic objects, such as Rollerball.</li>
</ol>


            

            
        
    </body></html>