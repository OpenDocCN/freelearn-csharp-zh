<html><head></head><body>
		<div><h1 id="_idParaDest-37" class="chapter-number"><a id="_idTextAnchor041"/>3</h1>
			<h1 id="_idParaDest-38"><a id="_idTextAnchor042"/>Demystifying through Existing Real-World Examples</h1>
			<p>In this chapter, we will look <a id="_idIndexMarker088"/>into how Microsoft’s <strong class="bo d">ASP.NET</strong> leverages metaprogramming in order to automate tedious configuration.</p>
			<p>Since the first <a id="_idIndexMarker089"/>release of <strong class="bo d">ASP.NET MVC</strong> back in 2009, there has been quite a lot of automation going on to make developers more productive. The main objective of this chapter is to demystify what metaprogramming is by showing that you might already be leveraging something that takes advantage of metaprogramming.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>ASP.NET controllers</li>
				<li>ASP.NET validation</li>
			</ul>
			<p>By the end of this chapter, you will understand how ASP.NET leverages metaprogramming with a non-intrusive approach and see the benefits of automation<a id="_idTextAnchor043"/>.</p>
			<h1 id="_idParaDest-39"><a id="_idTextAnchor044"/>Technical requirements</h1>
			<p>To follow the instructions in this chapter, you will need the following:</p>
			<ul>
				<li>A computer with either Windows, macOS, or Linux installed</li>
				<li>The <strong class="bo d">.NET </strong><strong class="bo d">6 SDK</strong></li>
				<li>Preferably, a code editor or IDE (such as Visual Studio Code, Visual Studio, or JetBrains Rider)</li>
			</ul>
			<p>The finished code for this chapter can be found here: <a href="https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter3">https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter3</a></p>
			<h1 id="_idParaDest-40"><a id="_idTextAnchor045"/>Prerequisites for your system</h1>
			<p>In this chapter, we’ll dive concretely into code, so you need to have your system prepared.</p>
			<p>The first thing we’ll <a id="_idIndexMarker090"/>need is the Microsoft .NET SDK. Go to <a href="https://dot.net">https://dot.net</a> and download the SDK by clicking the <strong class="bo d">Download</strong> button.</p>
			<p class="ca out-heading">Important note</p>
			<p class="ca out">This book is based on <em class="ita ic">version 7</em> of the .NET SDK.</p>
			<p>To create <a id="_idIndexMarker091"/>and edit files, it all depends on your own preferences and also what system you’re running on. Visual Studio Code and JetBrains Rider are both available on Windows, macOS, and Linux. Visual Studio is only available for Windows and macOS. You can download any of these editors from the following links; if you don’t have a preference, VSCode <a id="_idIndexMarker092"/>is lightweight <a id="_idIndexMarker093"/>and will <a id="_idIndexMarker094"/>get you up and running very fast:</p>
			<ul>
				<li><strong class="bo d">VSCode</strong> (<a href="https://code.visualstudio.com/">https://code.visualstudio.com/</a>)</li>
				<li><strong class="bo d">JetBrains </strong><strong class="bo d">Rider</strong> (<a href="https://www.jetbrains.com/rider/">https://www.jetbrains.com/rider/</a>)</li>
				<li><strong class="bo d">Visual </strong><strong class="bo d">Studio</strong> (<a href="https://visualstudio.com/">https://visualstudio.com/</a>)</li>
			</ul>
			<p>Once you’ve picked your editor, go ahead and follow the installation process relevant to the product you chose.</p>
			<p>To call on APIs, you can <a id="_idIndexMarker095"/>use the <a id="_idIndexMarker096"/>web browser, <strong class="bo d">Wget</strong>, or <strong class="bo d">cURL</strong>, but I <a id="_idIndexMarker097"/>recommend using <strong class="bo d">Postman</strong> (<a href="https://www.postman.com/">https://www.postman.com/</a>) for this. Samples in this book will use<a id="_idTextAnchor046"/> Postman.</p>
			<h1 id="_idParaDest-41"><a id="_idTextAnchor047"/>ASP.NET controllers</h1>
			<p>Being explicit <a id="_idIndexMarker098"/>with registering artifacts of your application is very common among different frameworks. Discovering the artifacts and just doing an automated self-registration of them is becoming more popular. But it’s very common that you will have to go and explicitly add everything manually.</p>
			<p>Although it is very clear what is going on with these registrations, the downside of manual registration is that you are basically adding code that is not directly contributing to the business value you’re trying to achieve. It is also code that is highly repeatable and tends to end up in large files with all the initialization going on.</p>
			<p>For instance, with <strong class="bo d">ASP.NET Core 6</strong> we got <a id="_idIndexMarker099"/>a brand-new minimal API, which is designed to have a smaller footprint and less ceremony to get started. You can start creating a Web API with three lines of setup code and then add your API as HTTP methods with routes at will.</p>
			<p>This is all fine and dandy, but can quite easily become unmaintainable as the project grows.</p>
			<p>Let’s dive more concretely into how this works.</p>
			<p>Create a new folder for this on your system called <a href="B19418_03.xhtml#_idTextAnchor041"><em class="ita ic">Chapter 3</em></a>. In this folder, we want to create a simple ASP.NET web application. This can be done in various ways, depending on the editor/IDE choice you made and also your personal preferences. However, throughout the book, we’ll just stick with doing it from the command line, as that will work in all environments.</p>
			<p>Open up a <a id="_idIndexMarker100"/>command-line interface (Windows CMD, macOS Terminal, Linux bash, or similar). Navigate to the folder you created for this (<a href="B19418_03.xhtml#_idTextAnchor041"><em class="ita ic">Chapter 3</em></a>). Then run the following command:</p>
			<pre class="conso e">dotnet new web</pre>
			<p>This will produce a minimal setup to get started. Open the folder/project in your editor/IDE. Your <strong class="source-in ine">Program.cs</strong> file should look like this:</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.MapGet("/", () =&gt; "Hello World!");
app.Run();</pre>
			<p>It basically sets up a web application and adds a route at the root level that will return <strong class="source-in ine">"Hello World!"</strong> when navigating to it using your web browser.</p>
			<p>The <strong class="source-in ine">app.MapGet()</strong> call is a very simple way to expose an endpoint and could in fact be used to build simple REST APIs. Let’s create a simple one for returning employees <a id="_idTextAnchor048"/>of a system.</p>
			<h2 id="_idParaDest-42"><a id="_idTextAnchor049"/>Custom HTTP Get handler</h2>
			<p>Start by creating a new file called <strong class="source-in ine">Employee.cs</strong> and adding the following to the file:</p>
			<pre class="source-code">
namespace Chapter3;
public record Employee(string FirstName, string LastName);</pre>
			<p>This holds <a id="_idIndexMarker101"/>just a simple representation <a id="_idIndexMarker102"/>of an employee with their first and last name. Obviously, in a proper system, you would add more properties to this. But for the sake of this sample, this will suffice.</p>
			<p>With the <strong class="source-in ine">Employee</strong> type in place, we can now change our <strong class="source-in ine">Get</strong> action to a different route and also just return a collection of the <strong class="source-in ine">Employee</strong> type. Swap out the <strong class="source-in ine">.MapGet()</strong> method call with the following:</p>
			<pre class="source-code">
app.MapGet("/api/employees", () =&gt; new Employee[]
        {
            new("Jane", "Doe"),
            new("John", "Doe")
        });</pre>
			<p>At the top of the file, you also need to add a <strong class="source-in ine">using</strong> statement for the <strong class="source-in ine">Chapter3</strong> namespace. The new <strong class="source-in ine">Program.cs</strong> file should look like the following:</p>
			<pre class="source-code">
using Chapter3;
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.MapGet("/api/employees", () =&gt; new Employee[]
        {
            new("Jane", "Doe"),
            new("John", "Doe")
        });
app.Run();</pre>
			<p>You can run this using <strong class="source-in ine">dotnet run</strong> from your terminal/console or if you prefer to run it with your IDE, you should get a running program listing something like this:</p>
			<pre class="conso e">info: Microsoft.Hosting.Lifetime[14]</pre>
			<pre class="conso e">      Now listening on: https://localhost:7027</pre>
			<pre class="conso e">info: Microsoft.Hosting.Lifetime[14]</pre>
			<pre class="conso e">      Now listening on: http://localhost:5016</pre>
			<pre class="conso e">info: Microsoft.Hosting.Lifetime[0]</pre>
			<pre class="conso e">      Application started. Press Ctrl+C to shut down.</pre>
			<pre class="conso e">info: Microsoft.Hosting.Lifetime[0]</pre>
			<pre class="conso e">      Hosting environment: Development</pre>
			<pre class="conso e">info: Microsoft.Hosting.Lifetime[0]</pre>
			<pre class="conso e">      Content root path: /Users/einari/Projects/Metaprogramming-in-C/Chapter3/</pre>
			<p>The two lines saying <strong class="source-in ine">Now listening on:</strong> will have different ports on your computer, as it is <a id="_idIndexMarker103"/>randomly assigned when <a id="_idIndexMarker104"/>creating the project. Combine the URL with <strong class="source-in ine">/api/employees</strong> from the <strong class="source-in ine">.MapGet()</strong> method. It should be something like <strong class="source-in ine">https://localhost:7027/api/employees</strong> or the non-HTTPS <strong class="source-in ine">http://localhost:5016/api/employees</strong>, just remember to put your ports into it. Take this combined URL and navigate to it in your browser. You should see the following:</p>
			<pre class="conso e">[{"firstName":"Jane","lastName":"Doe"},{"firstName":"John","lastName":"Doe"}]</pre>
			<p>Obviously, if you’re adding a bunch of these API endpoints right there in the program file with additional logic within the handler method, this file will become big and hard to read and maintain.</p>
			<p>This is where we can improve a lot and let ASP.NET be clever. Let’s start by creating a controller f<a id="_idTextAnchor050"/>or this instead.</p>
			<h2 id="_idParaDest-43"><a id="_idTextAnchor051"/>Controller</h2>
			<p>Add a new <a id="_idIndexMarker105"/>file called <strong class="source-in ine">EmployeesController.cs</strong> to the project. Make the file look like this:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Mvc;
namespace Chapter3;
[Route("/api/employees")]
public class EmployeesController : Controller
{
    [HttpGet]
    public IEnumerable&lt;Employee&gt; AllEmployees()
    {
        return new Employee[]
        {
            new("Jane", "Doe"),
            new("John", "Doe")
        };
    }
}</pre>
			<p>This will now create a Web API controller that leverages explicit metadata using the available C# attributes found in ASP.NET. In front of the <strong class="source-in ine">EmployeesController</strong> class, you have the <strong class="source-in ine">[Route]</strong> attribute, which tells at which base route the controller will be located. Then we have a method we want to represent a particular HTTP verb; this is the <strong class="source-in ine">[</strong><strong class="source-in ine">HttpGet]</strong> attribute.</p>
			<p>We have now <a id="_idIndexMarker106"/>rigged our code to be automatically discovered and configured by the ASP.NET engine itself. All we need to do is change the startup of this application and instruct ASP.NET to add controllers to our system. Open the <strong class="source-in ine">Program.cs</strong> file and replace the content with the following:</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers();
var app = builder.Build();
app.MapControllers();
app.Run();</pre>
			<p>The <strong class="source-in ine">builder.Services.AddControllers()</strong> call will instruct ASP.NET to discover all the controllers in the current assembly. The second call you’ll notice is <strong class="source-in ine">app.MapControllers()</strong>. This call maps all the controllers to the routes specified in the metadata.</p>
			<p>By running this application and navigating the browser to the same URL as before, we should see the exact same result.</p>
			<p>The beauty now with this model is that we can quite easily add a second controller without having to go into the configuration of our application to get it configured. It will just be discovered and automatically be there.</p>
			<p>That means we can now concentrate on building out the business value and it is by default more manageable and maintainable, especially when you bring other developers into it to work together or if someone is inheriti<a id="_idTextAnchor052"/>ng your code base.</p>
			<h1 id="_idParaDest-44"><a id="_idTextAnchor053"/>ASP.NET validation</h1>
			<p>When doing <a id="_idIndexMarker107"/>HTTP requests against ASP.NET, it goes through a pipeline consisting of different middlewares with specific responsibilities. This pipeline is completely configurable and extensible by you as a developer. Out of the box, it comes pre-configured with a specific middleware that handles the validation of objects sent to a request. The validation engine behind this recognizes rules in the form of metadata that can be applied to the objects. This metadata again is based on C# attributes.</p>
			<p>Let’s start by changing our <strong class="source-in ine">Employee</strong> object a bit. Open the <strong class="source-in ine">Employee.cs</strong> file and make it look like the following:</p>
			<pre class="source-code">
public record Employee(
    [Required]
    string FirstName,
    [Required]
    string LastName);</pre>
			<p>This makes the <strong class="source-in ine">FirstName</strong> and <strong class="source-in ine">LastName</strong> properties required by adding the <strong class="source-in ine">[Required]</strong> attribute to them. The ASP.NET pipeline will pick this up and check any input being <a id="_idIndexMarker108"/>sent to see if these properties have values.</p>
			<p>However, ASP.NET does not decide for you how to treat invalid objects; it just populates an object called <strong class="source-in ine">ModelState</strong> for you to decide how you want to deal with this.</p>
			<p>For us to deal with something like registering a new employee, we need to have an action in our controller that deals with that. Open <strong class="source-in ine">EmployeesController</strong> and add the <strong class="source-in ine">Register</strong> method as follows:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Mvc;
namespace Chapter3;
[Route("/api/employees")]
public class EmployeesController : Controller
{
    [HttpPost]
    public IActionResult Register(Employee employee)
    {
        if (!ModelState.IsValid)
        {
            return ValidationProblem(ModelState);
        }
        // ...
        // Do some business logic
        // ...
        return Ok();
    }
}</pre>
			<p>Notice the <strong class="source-in ine">ModelState.IsValid</strong> statement. If there are validation rules that are not valid, it will return <strong class="source-in ine">ValidationProblem</strong> as the result containing the errors found in <strong class="source-in ine">ModelState</strong>.</p>
			<p>Run the <a id="_idIndexMarker109"/>application and open Postman as discussed earlier. In Postman, you can create a new request by clicking on the button with the <strong class="bo d">+</strong> sign on it:</p>
			<div><div><img src="img/Figure_3.1_B19418.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.1 -Creating a new request in Postman</p>
			<p>This will create a new tab, much like a regular web browser that contains everything for the request. Select <strong class="bo d">POST</strong> as an HTTP verb in the left dropdown of the request, then enter the URL for our API. Now you can simply click the <strong class="bo d">Send</strong> button and see the result in the lower part:</p>
			<div><div><img src="img/Figure_3.2_B19418.jpg" alt=""/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 3.2 – Creating a new tab that contains the request details</p>
			<p>Since we’re <a id="_idIndexMarker110"/>not really passing it an object, none of the properties are set. The errors listed will therefore say that the prop<a id="_idTextAnchor054"/>erties are required.</p>
			<h2 id="_idParaDest-45"><a id="_idTextAnchor055"/>Automatically hooking up model state handling</h2>
			<p>In ASP.NET, everything revolves around what is known as middlewares – small, special-purpose code <a id="_idIndexMarker111"/>blocks that perform a single task and then hand <a id="_idIndexMarker112"/>over to the next middleware. Every HTTP request that is handled by ASP.NET has these, and even the code that handles the controller is one of these. Every middleware can decide whether it should continue to the next middleware or whether it should exit with or without an error.</p>
			<p>Controller handlers are just one of many formalized middlewares we can tap into.</p>
			<p>You can find more details on middlewares here:</p>
			<p><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0</a></p>
			<p>If you never want to allow an invalid state to enter your controllers and want to get rid of the possibility of developers doing this manually, then there is a particular middleware we can put into the pipeline that allows us to stop it before we even hit the controller.</p>
			<p>ASP.NET has the concept <a id="_idIndexMarker113"/>of an <strong class="bo d">action filter</strong>. This gets called before the controller performs any action and lets us decide whether we want to continue with the pipeline or not. You can <a id="_idIndexMarker114"/>read more about action filters here: <a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-7.0">https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-7.0</a><a href="https://learn.microsoft.com/en-us/aspnet/core/mvc/controllers/filters?view=aspnetcore-6.0."/>.</p>
			<p>Let’s create <a id="_idIndexMarker115"/>a new file called <strong class="source-in ine">ValidationFilter.cs</strong> and make <a id="_idIndexMarker116"/>it look like the following:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Mvc.Filters;
namespace Chapter3;
public class ValidationFilter : IAsyncActionFilter
{
    public async Task OnActionExecutionAsync(ActionExecutingContext context, ActionExecutionDelegate next)
    {
        if (context.ModelState.IsValid)
        {
            await next();
        }
        else
        {
            context.Result = new BadRequestObjectResult(new ValidationProblemDetails(context.ModelState));
        }
    }
}</pre>
			<p>This takes over the checking of whether <strong class="source-in ine">ModelState</strong> is valid. The line with <strong class="source-in ine">await next()</strong> is the continuation of the pipeline. So by only calling this when things are valid, we avoid getting to the controller if we’re in an invalid state. Instead, we then create the same object the ASP.NET pipeline creates when calling the <strong class="source-in ine">ValidationProblem</strong> method from the controller and return this.</p>
			<p>We can then simplify the controller to look like the following:</p>
			<pre class="source-code">
using Microsoft.AspNetCore.Mvc;
namespace Chapter3;
[Route("/api/employees")]
public class EmployeesController : Controller
{
    [HttpPost]
    public IActionResult Register(Employee employee)
    {
        // ...
        // Do some business logic
        // ...
        return Ok();
    }
}</pre>
			<p>This code <a id="_idIndexMarker117"/>does not need to consider <strong class="source-in ine">ModelState</strong> at all and just assumes it is taken care of, simplifying the implementation of every <a id="_idIndexMarker118"/>controller and making it focus on its single purpose of registering an employee. For most controllers, this would be fine and, in fact, you’re now removing the possibility of developers forgetting to check for validity before doing their business logic.</p>
			<p>The last piece of the puzzle is to hook it up in the ASP.NET pipeline. Open the <strong class="source-in ine">Program.cs</strong> file and change the content to the following:</p>
			<pre class="source-code">
using Chapter3;
var builder = WebApplication.CreateBuilder(args);
builder.Services.AddControllers(mvcOptions =&gt; mvcOptions.Filters.Add&lt;ValidationFilter&gt;());
var app = builder.Build();
app.MapControllers();
app.Run();</pre>
			<p>The <strong class="source-in ine">.AddControllers()</strong> call takes a delegate that lets us configure <strong class="source-in ine">MvcOptions</strong>. Within this, we can add our new action filter.</p>
			<p>Run the application and verify that you get the exact same result by clicking the<a id="_idTextAnchor056"/> <strong class="bo d">Send</strong> button inside postman.</p>
			<h1 id="_idParaDest-46"><a id="_idTextAnchor057"/>Summary</h1>
			<p>In this chapter, we learned how an existing piece of technology leverages the power of the .NET runtime to make it easier for developers using the technology to do so. From the use of metadata in the right context, we get to focus on delivering business value and don’t have to worry about how it is all configured. It also automatically gives us a certain structure to abide by, which in the long run will yield a more maintainable, extensible, and predictable code base. By adding the action filter as we did, we added what we call a cross-cutting concern, something we will revisit in more detail in <a href="B19418_13.xhtml#_idTextAnchor206"><em class="ita ic">Chapter 13</em></a>, <em class="ita ic">Applying </em><em class="ita ic">Cross-Cutting Concerns</em>.</p>
			<p>In the next chapter, we will dive into how frameworks such as ASP.NET are capable of doing discovery and automation, and how we can leverage the .NET runtime type system to discover types and metadata to achieve something similar.</p>
		</div>
	

		<div><h1 id="_idParaDest-47"><a id="_idTextAnchor058"/>Part 2:Leveraging the Runtime</h1>
			<p>In this part, you will see how powerful the .NET runtime is and dive into the details of its capabilities for metaprogramming. You’ll see the different metaprogramming models the runtime provides and get an idea of how they can be leveraged with real-world examples.</p>
			<p>This part has the following chapters:</p>
			<ul>
				<li><a href="B19418_04.xhtml#_idTextAnchor059"><em class="ita ic">Chapter 4</em></a>, <em class="ita ic">Reasoning about Types Using Reflection</em></li>
				<li><a href="B19418_05.xhtml#_idTextAnchor083"><em class="ita ic">Chapter 5</em></a>, <em class="ita ic">Leveraging Attributes</em></li>
				<li><a href="B19418_06.xhtml#_idTextAnchor098"><em class="ita ic">Chapter 6</em></a>, <em class="ita ic">Dynamic Proxy Generation</em></li>
				<li><a href="B19418_07.xhtml#_idTextAnchor118"><em class="ita ic">Chapter 7</em></a>, <em class="ita ic">Reasoning about Expressions</em></li>
				<li><a href="B19418_08.xhtml#_idTextAnchor132"><em class="ita ic">Chapter 8</em></a>, <em class="ita ic">Building and Executing Expressions</em></li>
				<li><a href="B19418_09.xhtml#_idTextAnchor146"><em class="ita ic">Chapter 9</em></a>, <em class="ita ic">Taking Advantage of the Dynamic Language Runtime</em></li>
			</ul>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
		<div><div></div>
		</div>
	</body></html>