<html><head></head><body>
		<div id="_idContainer022">
			<h1 class="chapter-number" id="_idParaDest-88"><a id="_idTextAnchor087"/>4</h1>
			<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/>The One with the  Thread Tangles</h1>
			<p><em class="italic">Concurrency </em><span class="No-Break"><em class="italic">and threading</em></span></p>
			<p><strong class="bold">Threading</strong> and <strong class="bold">concurrency</strong> are <a id="_idIndexMarker251"/>things that most developers think they know all about. The theory sounds so simple, yet in practice, threading is where a lot of mistakes are made and where all those frustrating bugs originate. Threading can be quite<a id="_idIndexMarker252"/> complex, but the people of the BCL and CLR teams have done their best to help us as much as they can to make <span class="No-Break">things simpler.</span></p>
			<p>Once you get the hang of it, threading is a great addition to your skills and can make a major difference in <span class="No-Break">your systems.</span></p>
			<p>We will look at the following topics in <span class="No-Break">this chapter:</span></p>
			<ul>
				<li>What is concurrency <span class="No-Break">and threading?</span></li>
				<li>How do threads work internally in .NET <span class="No-Break">and Windows?</span></li>
				<li>How does the CLR <span class="No-Break">help us?</span></li>
				<li>What <span class="No-Break">is async/await?</span></li>
				<li>How do we synchronize threads and make them <span class="No-Break">work together?</span></li>
				<li>How can I make sure my code behaves nicely when working <span class="No-Break">with threads?</span></li>
				<li>How can I use collections <span class="No-Break">over threads?</span></li>
			</ul>
			<p>Let’s look into this <span class="No-Break">fascinating topic!</span></p>
			<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/>Technical requirements</h1>
			<p>All the source code and samples in this chapter can be downloaded from this book’s GitHub repository <span class="No-Break">at </span><a href="https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter04"><span class="No-Break">https://github.com/PacktPublishing/Systems-Programming-with-C-Sharp-and-.NET/tree/main/SystemsProgrammingWithCSharpAndNet/Chapter04</span></a><span class="No-Break">.</span></p>
			<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/>Concurrency and threading – the basics</h1>
			<p>This morning, I woke up as I do every day. I got out of bed, took a shower, and got dressed. Then I walked the dog for 30 minutes (it’s a Sunday today). I returned home, made some coffee, and then sat down to <span class="No-Break">write this.</span></p>
			<p>I am sure that<a id="_idIndexMarker253"/> your day looks the same in general. You do something, then you do the next thing. Things are done in order. Sometimes, I make a phone call to people in other time zones when I walk the dog, but most of the time, I do the things I do <a id="_idIndexMarker254"/>one at a time. It is more efficient that way. If I were to sit down to write this chapter but stop to walk the dog a bit after five minutes, then leave him standing near a tree while I run back to the house to write for five more minutes, followed by me running back to the dog to walk another 500 meters, things would never get done. I would get a workout with all the running back and forth, but it would <span class="No-Break">be inefficient.</span></p>
			<p>That is a silly way to lead your life (no judgment; if this is what you do, I am okay with it, it just doesn’t work <span class="No-Break">for me).</span></p>
			<p>However, in the case of computers, we tend to assume that this way of working enables work to get done quicker. Why do we <span class="No-Break">think that?</span></p>
			<p>Computers cannot do two things at the same time. No, wait. Let me rephrase that. CPU cores cannot do two things at the same time. In the old days, before AMD released the <strong class="bold">Athlon 64 X2 processor</strong> in 2005 and before Intel released the Pentium D in the same year, regular computers were all single-core. That means that computers, before 2005, could generally only do one thing at <span class="No-Break">a time.</span></p>
			<p>These days, most devices have multiple cores. Your computer, laptop, and phone all have a multi-core processor. However, as a system programmer, you might encounter devices with only one core. Think of IoT devices: they need to be cheap and very low in power consumption. Those systems often have a single core. Systems programmers run into single-core devices more often than people writing <span class="No-Break">other software.</span></p>
			<p>However, in the end, that doesn’t really matter. My primary development machine has 16 cores. That sounds like a lot. However, if I look at my Task Manager, I can see many things running simultaneously, much more than those 16 cores can handle. So, even in a multi-core environment, machines must do something to enable all those tasks. As systems programmers, we have to be aware of how to write our software to get the most benefit out of <span class="No-Break">those cores.</span></p>
			<p>We are thus dealing with two separate topics here. One is concurrency; the other <span class="No-Break">is threading.</span></p>
			<p>Concurrency<a id="_idIndexMarker255"/> is the concept<a id="_idIndexMarker256"/> whereby the system executes several sequences of operations in overlapping periods. It is not really simultaneous execution; that is called parallelism. It is all about tasks running at what seems to be the same time without waiting for other tasks. It is a concept, not a <span class="No-Break">programming technique.</span></p>
			<p>Threads, on the other hand, are a programmer’s construct. Threading is one of the ways to <span class="No-Break">achieve concurrency.</span></p>
			<p class="callout-heading">Nice to know</p>
			<p class="callout">Threads can be hardware threads or software threads. The CPU handles the first type; the second is handled in our software. The <strong class="bold">Operating System</strong> (<strong class="bold">OS</strong>) can assign threads to actual hardware threads, but as a developer, you are almost always going to be working with software threads. I will mostly be talking about software threads here, but I will point it out when I mean hardware <span class="No-Break">threads instead.</span></p>
			<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/>The beginnings of concurrency – the IRQ</h2>
			<p>For now, let us ignore the fact that computers cannot multitask aside from spreading the load across the physical cores a CPU might have. To make life easier, we will assume that a computer can do two things <span class="No-Break">at once.</span></p>
			<p>This has not always been the case. In the early days, a computer did one thing at a time. That meant that if you wrote some software for a computer, you had complete control over all available hardware. Everything was yours and <span class="No-Break">yours alone.</span></p>
			<p>Well, when I say that it was yours, I mean that it was mainly yours. Sometimes, something would happen that would need the attention of the CPU. In those days, we had something<a id="_idIndexMarker257"/> called an <strong class="bold">Interrupt Request</strong> (<strong class="bold">IRQ</strong>). An<a id="_idIndexMarker258"/> IRQ is a hardware feature that is usually tied to other hardware. An external device, such as a floppy disk drive or a modem, could signal the CPU (by putting a voltage on a particular connection to the CPU). When this happened, the CPU finished the instruction it was doing, stored all of its state in memory, looked up the address belonging to that IRQ (there could be more than one), and started the code in that address. When that function finished, the whole thing would be reversed: the CPU would load the previous stored state and continue executing the original code as if nothing <span class="No-Break">had happened.</span></p>
			<p>This mechanism <a id="_idIndexMarker259"/>worked reasonably well, but there were a lot of potential issues. For instance, there were only a handful of IRQ lines available. If your code overwrote the registration of another piece of code attached to some hardware, that hardware would fail <span class="No-Break">to work.</span></p>
			<p>To make things worse, if you made a silly mistake and your code never returned from the IRQ, you could bring the whole machine to a halt. It would simply never return from your code and the running program would be on hold indefinitely. So you had to be very careful to ensure that you had no such bugs in <span class="No-Break">your code!</span></p>
			<p>IRQs are still used today, especially in low-power devices such as Raspberry Pi. We will encounter those later in <span class="No-Break">this book.</span></p>
			<h2 id="_idParaDest-93"><a id="_idTextAnchor092"/>Cooperative and preemptive multitasking</h2>
			<p>IRQs work okay, but they should be used by hardware devices. Since there aren’t that many IRQs, and since they have the potential to kill running processes, we have moved away from using them in <span class="No-Break">normal software.</span></p>
			<p>However, having a computer and only being able to do one thing at a time with it seemed like a waste of resources. Computers became more and more powerful. They could soon do more things than we asked them to do. That was when multitasking OSs came <span class="No-Break">into play.</span></p>
			<p>For instance, the<a id="_idIndexMarker260"/> versions of Windows before Windows 95, such as Windows 3.1, used something called <strong class="bold">cooperative multitasking</strong>. The principle was reasonably straightforward. A piece of code would do something, and when it thought it could use a break, it would just tell the OS: “Hey, I am on a break; if you need me to do something, just let me know.” It would then halt execution. This meant that the OS could allocate CPU time to <span class="No-Break">another process.</span></p>
			<p>We called this cooperative multitasking because we expected the software to cooperate and share the <span class="No-Break">resources fairly.</span></p>
			<p>Of course, if a program misbehaved, it could still claim all the CPU time, thus stopping other software from running <span class="No-Break">as intended.</span></p>
			<p>A better way <a id="_idIndexMarker261"/>was needed. Windows NT 3.1 and later Windows 95 did much better: they introduced <span class="No-Break"><strong class="bold">preemptive multitasking</strong></span><span class="No-Break">.</span></p>
			<p>The idea is straightforward: allocate some time for a process to run, and when that time is out, store the state of that process, park it somewhere, and move on to the next process. When the time comes for the original process to do something again, the OS loads the program<a id="_idIndexMarker262"/> back into memory and restores the state, then the process can continue. The process was utterly oblivious to the time it had been dormant unless it kept track of <span class="No-Break">the clock.</span></p>
			<p>Processes could no longer claim all of the available CPU time. The OS would pause the process if its time had <span class="No-Break">run out.</span></p>
			<p>Preemptive multitasking is still the way modern OSs <span class="No-Break">work today.</span></p>
			<p>However, all of this deals with multiple processes on a computer running simultaneously. How can we have one process doing multiple things at the same time? Well, one solution would be to <span class="No-Break">use threads.</span></p>
			<h1 id="_idParaDest-94"><a id="_idTextAnchor093"/>Threads in C#</h1>
			<p>Threads are<a id="_idIndexMarker263"/> a concept that allows computers to seem to be doing more than one thing at once in your program. Just as an OS allows multiple programs to run simultaneously, threads allow your program to run multiple flows in your application concurrently. A thread is nothing more than an <strong class="bold">execution flow</strong> in your program. You always have at least one thread: the one that got started when the program began its execution. We call this the main thread. The runtime manages this thread and you have little control over it. All the other threads, however, are yours, and you can do whatever you want <span class="No-Break">with them.</span></p>
			<p>Threads are nothing magical. The<a id="_idIndexMarker264"/> basic principle is <span class="No-Break">quite easy:</span></p>
			<ol>
				<li>Create a method, function, or any other piece of code you want <span class="No-Break">to run.</span></li>
				<li>Create a thread, giving it the address of <span class="No-Break">the method.</span></li>
				<li>Start <span class="No-Break">the thread.</span></li>
				<li>The OS or runtime executes that method or function while running the main <span class="No-Break">thread simultaneously.</span></li>
				<li>You can monitor the progress of that thread. You can wait for it to end, or you can use a fire-and-forget strategy by just letting it do <span class="No-Break">its work.</span></li>
			</ol>
			<p>How you do these steps depends on which version you want to use. Do you choose the .NET way or go <a id="_idIndexMarker265"/>down the rabbit hole we know as the <span class="No-Break">Win32 API?</span></p>
			<p>In .NET, threads are represented by an actual class (or, more precisely, an instance of a class). In Win32, they are just something created by the <span class="No-Break">Win32 API.</span></p>
			<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/>Win32 threads</h2>
			<p>In Win32, you <a id="_idIndexMarker266"/>use the <strong class="source-inline">CreateThread</strong> API to create a thread. I <a id="_idIndexMarker267"/>want to show you how this works, but I must be honest: you will probably never do this in your code. There are better ways to create threads than using the Win32 API. Still, there might be circumstances when having complete control of the Win32 threads might <span class="No-Break">be necessary.</span></p>
			<p>Let me show you how to do this in the <span class="No-Break">Win32 API.</span></p>
			<p>We will begin by declaring a <strong class="source-inline">delegate</strong>. This <strong class="source-inline">delegate</strong> is the form of the function that contains the work that the <span class="No-Break">thread executes:</span></p>
			<pre class="source-code">
public delegate uint ThreadProc(IntPtr lpParameter);</pre>			<p>Since we are calling Win32 APIs, we need to <span class="No-Break">import them:</span></p>
			<pre class="source-code">
[DllImport("kernel32.dll", SetLastError = true)]
public static extern IntPtr CreateThread(
    IntPtr lpThreadAttributes,
    uint dwStackSize,
    ThreadProc lpStartAddress,
    IntPtr lpParameter,
    uint dwCreationFlags,
    out uint lpThreadId
);
[DllImport("kernel32.dll", SetLastError = true)]
public static extern bool CloseHandle(IntPtr hObject);
[DllImport("kernel32.dll", SetLastError = true)]
public static extern uint WaitForSingleObject(IntPtr
hHandle, uint dwMilliseconds);</pre>			<p>We will import three APIs: <strong class="source-inline">CreateThread</strong>, <strong class="source-inline">CloseHandle</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">WaitForSingleObject</strong></span><span class="No-Break">.</span></p>
			<p>Before we <a id="_idIndexMarker268"/>can use these APIs, we have to write the code that does<a id="_idIndexMarker269"/> something useful. In this case, it is not really useful, but this is the code that will be executed in <span class="No-Break">the thread:</span></p>
			<pre class="source-code">
public uint MyThreadFunction(IntPtr lpParameter)
{
    for (int i = 0; i &lt; 1000; i++)
        Console.WriteLine("Unmanaged thread");
    return 0;
}</pre>			<p>This <strong class="source-inline">MyThreadFunction</strong> function matches the delegate that we <span class="No-Break">defined earlier.</span></p>
			<p>With all of that out of our way, we can create the threads and have our program do something. Or rather, it can do lots of somethings simultaneously. Here <span class="No-Break">we go:</span></p>
			<pre class="source-code">
public void DoWork()
{
    uint threadId;
    var threadHandle = CreateThread(
        IntPtr.Zero,
        0,
        MyThreadFunction,
        IntPtr.Zero,
        0,
        out threadId
    );
    // Wait for the thread to be finished
    WaitForSingleObject(threadHandle, 1000);
    // Clean up
    CloseHandle(threadHandle);
}</pre>			<p>The <strong class="source-inline">DoWork()</strong> method <a id="_idIndexMarker270"/>creates a thread by calling the <strong class="source-inline">CreateThread</strong> Win32 API. This API has<a id="_idIndexMarker271"/> some parameters. Let me explain what they do with the help of <span class="No-Break"><em class="italic">Table 4.1</em></span><span class="No-Break">:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table001-4">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Parameter</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">IntPtr lpThreadAttributes</span></p>
						</td>
						<td class="No-Table-Style">
							<p>A pointer to the security <span class="No-Break">attributes struct</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">uint dwStackSize</span></p>
						</td>
						<td class="No-Table-Style">
							<p>The size of the stack required for <span class="No-Break">this thread</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">ThreadProc lpStartAddress</span></p>
						</td>
						<td class="No-Table-Style">
							<p>A pointer to the function that the <span class="No-Break">thread runs</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">IntPtr lpParameter</span></p>
						</td>
						<td class="No-Table-Style">
							<p>A pointer to a variable that is passed to <span class="No-Break">the thread</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break">uint dwCreationFlags</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Additional flags determining how the thread <span class="No-Break">is created</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>out <span class="No-Break">uint lpThreadId</span></p>
						</td>
						<td class="No-Table-Style">
							<p>An out parameter with the ID of <span class="No-Break">the thread</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.1: Parameters for the CreateThread Win32 API</p>
			<p>The security attributes define who or what has access to the thread and what this thread can use. The security attributes are rather complex. I will not be diving into them here, mainly because with threads they are not often used. Here, we have set the security attribute <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">IntPtr.Zero</strong></span><span class="No-Break">.</span></p>
			<p>The <strong class="source-inline">dwStackSize</strong> parameter<a id="_idIndexMarker272"/> defines the stack size that the thread uses. As discussed before, each thread gets its own stack, where it can store its value types. This stack is reclaimed when the thread <span class="No-Break">is done.</span></p>
			<p>Then, we get the function pointer that the thread will execute as soon as that thread starts. In C#, we can pass the method’s name and let the compiler do the hard work of figuring out the <span class="No-Break">memory address.</span></p>
			<p>After supplying the start address of the method, we get something more interesting: we can pass data into the thread method. The <strong class="source-inline">lpParameter</strong> parameter is a pointer to the memory where that data is located. To get data into the thread is quite a lot of work unless you want to use a simple <strong class="source-inline">Int32</strong>. After all, an <strong class="source-inline">IntPtr</strong> is a 32-bit value, so you can take an int and cast it back and forth to get that data in the thread function. I am not passing anything here, but will I show you how to do that a little later in <span class="No-Break">this chapter.</span></p>
			<p>Next are the flags that define how the system creates the thread. There are two flags that we can use, not counting the default <strong class="source-inline">0</strong>, which means “do nothing special.” These flags are explained in <span class="No-Break"><em class="italic">Table 4.2</em></span><span class="No-Break">.</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table002-3">
				<colgroup>
					<col/>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Flag</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Value</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Meaning</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p>0</p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">0x00000000</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Do <span class="No-Break">nothing special</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">CREATE_SUSPENDED</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">0x00000004</span></p>
						</td>
						<td class="No-Table-Style">
							<p>Create the thread, but suspend it immediately instead of <span class="No-Break">starting it.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">STACK_SIZE_PARAM_IS_A_RESERVATION</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break">0x00010000</span></p>
						</td>
						<td class="No-Table-Style">
							<p>If this is set, the stack size is a reservation. If not, the stack size <span class="No-Break">is committed.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.2: Thread creation options</p>
			<p><strong class="source-inline">CREATE_SUSPENDED</strong> creates the thread but puts it in a suspended state when it is created. The default behavior is to run the code that <strong class="source-inline">lpStartAddress</strong> points <span class="No-Break">to immediately.</span></p>
			<p><strong class="source-inline">STACK_SIZE_PARAM_IS_A_RESERVATION</strong> is an interesting one. This flag is one of the main reasons you might want to use the Win32 version of creating threads instead of the .NET one. Each<a id="_idIndexMarker273"/> thread has its own stack. You can specify how big that stack should be, but when you do that, all that happens is that the system reserves <a id="_idIndexMarker274"/>that memory. This reserving is a quick operation. Reservation only tells the system that you want to use this amount of memory at some point. You will get an error if the system doesn’t have enough memory to fulfill <span class="No-Break">your request.</span></p>
			<p>However, the memory is not yet committed. Committed means that the OS reserves the memory you requested and marks it as being used by a process. Reservation is just telling it that you want the memory to be <span class="No-Break">available later.</span></p>
			<p class="callout-heading">Page faults</p>
			<p class="callout">When your application requests memory or tries to access memory from the system, certain things <span class="No-Break">can happen.</span></p>
			<p class="callout">The first instance happens when the memory is available in your stack or heap. You get the pointer to that memory; it’s all <span class="No-Break">yours now.</span></p>
			<p class="callout">The next happens if the memory is <em class="italic">not</em> in your stack or heap yet but it is available on the system. This results in a soft page fault. The system will add the new memory to the current stack <span class="No-Break">or heap.</span></p>
			<p class="callout">Next, it’s possible that the memory you want to reach is not in your computer’s memory chips. In this case, it has probably been swapped to disk. This is a hard page fault. The OS will load the memory from the disk and add it to your <span class="No-Break">working set.</span></p>
			<p class="callout">Page faults are great for adding flexibility to the system. However, they come with a big <span class="No-Break">performance hit.</span></p>
			<p>A page fault <a id="_idIndexMarker275"/>might occur when you reserve memory and want<a id="_idIndexMarker276"/> to access it. When this happens, your application’s performance <span class="No-Break">will degrade.</span></p>
			<p>If you commit <a id="_idIndexMarker277"/>memory, it is guaranteed to be available when it is needed. This makes your memory footprint larger and faster since you will not get a <span class="No-Break">page fault.</span></p>
			<p>You must choose here: which of the two scenarios do you prefer? You can control that for the stack with the <span class="No-Break"><strong class="source-inline">STACK_SIZE_PARAM_IS_A_RESERVATION</strong></span><span class="No-Break"> flag.</span></p>
			<p>The code sample ends with two statements: <strong class="source-inline">WaitForSingleObject()</strong> and <strong class="source-inline">CloseHandle()</strong>. The <em class="italic">Synchronizing threads</em> section in this chapter explains <strong class="source-inline">WaitForSingleObject()</strong> in much more detail. Still, the short description is as follows: wait for the thread to finish before continuing on the <span class="No-Break">main thread.</span></p>
			<p><strong class="source-inline">CloseHandle</strong> clears up all used resources. Yes, this is an unmanaged resource. This would be a great place to use the <span class="No-Break"><strong class="source-inline">IDisposable</strong></span><span class="No-Break"> pattern.</span></p>
			<h2 id="_idParaDest-96"><a id="_idTextAnchor095"/>.NET threads</h2>
			<p>Threads in <a id="_idIndexMarker278"/>the .NET BCL are much simpler to use. Of course, when something is simplified, you usually sacrifice flexibility as <span class="No-Break">a result.</span></p>
			<p>The following <a id="_idIndexMarker279"/>sample shows how to do the same work as we did with the Win32 thread using the .<span class="No-Break">NET constructs.</span></p>
			<p>We will begin with the thread function, which runs on the new thread. It is almost the same as the Win32 sample. The following snippet shows the code that we want to run inside <span class="No-Break">the thread:</span></p>
			<pre class="source-code">
void MyThreadFunction()
{
    for (var i = 0; i &lt; 1000; i++)
        Console.WriteLine("Managed thread");
}</pre>			<p>In the main<a id="_idIndexMarker280"/> body of our code, we create the thread, give it the function to run, and <span class="No-Break">start it:</span></p>
			<pre class="source-code">
var myManagedThread = new Thread(MyThreadFunction);
myManagedThread.Start();
myManagedThread.Join();</pre>			<p>We create a new instance of the <strong class="source-inline">Thread</strong> class and pass the method we want to use in the constructor. Then we start it. Then, we use <strong class="source-inline">Join()</strong> to wait for it, effectively pausing the main thread until our new thread is done doing whatever it <span class="No-Break">is doing.</span></p>
			<p>That’s it. If <a id="_idIndexMarker281"/>you compare this with the Win32 version, I am sure that you will appreciate <span class="No-Break">this simplicity.</span></p>
			<p>However, do not be fooled: this simplicity does not mean that you cannot control your threads. You can control them and you can do much more than what I have just shown you. For instance, you can also specify the stack size you want to use for <span class="No-Break">your thread:</span></p>
			<pre class="source-code">
var myHugeStackSize = 8 * 1024 * 1024; // 8 MB
var myManagedThread = new Thread(MyThreadFunction, myHugeStackSize);</pre>			<p>Here, we allocate 8 MB for the stack for our <span class="No-Break">new thread.</span></p>
			<p class="callout-heading">Nice to know</p>
			<p class="callout">The default stack size for a 32-bit application is 1 MB; for a 64-bit application, it is 4 MB. You will rarely need more than that. Requesting a big stack should only be done if you have tested your application and found that you really <span class="No-Break">need it.</span></p>
			<p>In the Win32 sample, we had to explicitly state that we wanted to create a thread in a suspended state. If we did not do that, it would have started immediately. In .NET, things work differently. A <a id="_idIndexMarker282"/>newly created thread in .NET is considered <em class="italic">unstarted</em>. This means that it will not be starting immediately. It is also not yet suspended; there is quite a difference <span class="No-Break">in behavior.</span></p>
			<p>A suspended thread<a id="_idIndexMarker283"/> is fully formed and placed on the OS’s scheduler list. Its stack is allocated and all resources <span class="No-Break">are present.</span></p>
			<p>An <strong class="bold">unstarted thread</strong><a id="_idIndexMarker284"/> is just an instance of the <strong class="source-inline">Thread</strong> class. The stack is not yet allocated and it has not yet been given to the OS, so it is not yet on the scheduler, and <span class="No-Break">so on.</span></p>
			<p>When we call <strong class="source-inline">Start()</strong> on that .NET thread, the runtime does all that work. Creating a thread is much faster than the <strong class="source-inline">CreateThread()</strong> call in Win32, but that performance gain is lost when you start the thread. Think of it as <span class="No-Break">lazy initialization.</span></p>
			<p>The designers of the CLR took advantage of this. If it is relatively cheap to create threads and only becomes expensive when we use them, why not move that burden of creation to the beginning of the program? Starting an application takes time; if we extend that a bit, it does not matter. However, that would mean that we have a faster system when it is in use. We can have a pool of threads available when we need one or two. That is precisely what <span class="No-Break">they did.</span></p>
			<p>An example <a id="_idIndexMarker285"/>will probably make this clearer. However, before I can show you that, we must make some modifications. We want to create many threads that run simultaneously. To distinguish the output from each thread, we need to pass some data to that thread so that it can display it. Thus, we need to have something to store <span class="No-Break">data in.</span></p>
			<p>We need immutable data for reasons that will become clear when we discuss thread safety later in this chapter. The <strong class="source-inline">record</strong>, which was added to C# 9, is a great way to <span class="No-Break">do this::</span></p>
			<pre class="source-code">
internal record ThreadData(int LoopCounter);</pre>			<p>We can now work on our method that executes in <span class="No-Break">that thread:</span></p>
			<pre class="source-code">
void MyThreadFunction(object? myObjectData)
{
    // Verify that we have a ThreadData object
    if (myObjectData is not ThreadData myData)
        throw new ArgumentException("Parameter is not a                     ThreadData object");
    // Get the thread ID
    var currentThreadId = Thread.CurrentThread.ManagedThreadId;
    // Write the data to the Console
    Console.WriteLine(
        $"Managed thread in Thread {currentThreadId} " +
        $"with loop counter {myData.LoopCounter}");
}</pre>			<p>The<a id="_idIndexMarker286"/> thread gets a parameter of the <strong class="source-inline">Nullable&lt;object&gt;</strong> type. We cannot declare it as any other type, as this is what the <span class="No-Break">runtime expects.</span></p>
			<p>To use this <a id="_idIndexMarker287"/>data, we need to cast it to the <span class="No-Break">right type.</span></p>
			<p>Then, we will get the ID of the current thread. Each thread has a unique ID, so we can interact with it, although we will only display <span class="No-Break">it here.</span></p>
			<p>Let us create <span class="No-Break">some threads:</span></p>
			<pre class="source-code">
for (int i = 0; i &lt; 100; i++)
{
    ThreadData threadData = new(i);
    var newThread = new Thread(MyThreadFunction);
    newThread.Start(threadData);
}
Console.ReadKey();</pre>			<p>We will create one hundred threads and start them immediately after creation. We will give them some data to see where in the loop <span class="No-Break">we are.</span></p>
			<p>After the loop, I added the <strong class="source-inline">Console.ReadKey()</strong> so the program does not exit before all threads are done. The main thread that starts when running your program is special: if that ends, the CLR ends the whole program and unloads all memory. So, keeping your main thread alive is crucial until you are sure that all work is done. In a real-world scenario, you wouldn’t use <strong class="source-inline">Console.ReadLine()</strong> for this, but for this demo, it works <span class="No-Break">just fine.</span></p>
			<p>If you run this, you will probably see the thread ID increasing in line with the loop counter. They are not equal. The CLR already created a dozen or so threads before you ran <span class="No-Break">your loop.</span></p>
			<p>If you increase<a id="_idIndexMarker288"/> the loop to do a much higher number of iterations, you will eventually see the same thread ID now and then. The CLR reuses threads to avoid <span class="No-Break">thread starvation.</span></p>
			<p>However, I promised to show you the thread pool. Replace the part of the code where we had the for-loop with the <span class="No-Break">following code:</span></p>
			<pre class="source-code">
for (int i = 0; i &lt; 100; i++)
{
    ThreadData threadData = new(i);
    ThreadPool.QueueUserWorkItem(MyThreadFunction, threadData);
}
Console.ReadKey();</pre>			<p>We will<a id="_idIndexMarker289"/> use the thread pool here to pull threads out of the pool when needed. If you run this, you repeatedly see the same thread IDs. Threads are pulled out of the pool and started with the correct data. When the thread is done, it is winded down, its resources are de-allocated, and it is placed back in the pool, ready to be used again <span class="No-Break">if needed.</span></p>
			<p>The overhead is minimal and the advantages are enormous. Systems using this are much <span class="No-Break">more efficient.</span></p>
			<p><strong class="source-inline">ThreadPool</strong> hides many more secrets and tricks that you can use, but its usage has largely been replaced by the <strong class="bold">Task Parallel Library</strong> (<strong class="bold">TPL</strong>), which handles most of this for you. Let us have <span class="No-Break">a look.</span></p>
			<h1 id="_idParaDest-97"><a id="_idTextAnchor096"/>Tasks and Parallel Library – the TPL</h1>
			<p>The TPL has <a id="_idIndexMarker290"/>been around for quite some time. It was introduced back in 2010 with the release of .<span class="No-Break">NET 4.0.</span></p>
			<p>The TPL simplifies many of the things we used to do with threads. Threads still have their place, especially when dealing with third-party libraries. However, in most cases, we can let the TPL figure <span class="No-Break">things out.</span></p>
			<p>In the TPL, the <strong class="source-inline">Task</strong> class is the main class to work with. <strong class="source-inline">Task</strong> is a class that handles the instantiation of threads when needed. It does much more, but we will deal with <span class="No-Break">that later.</span></p>
			<p>I said “when needed” because it is smart enough to determine when a new thread <span class="No-Break">is needed.</span></p>
			<p>Let us begin with a straightforward example and then work <span class="No-Break">from there:</span></p>
			<pre class="source-code">
Task myTask = Task.Run(() =&gt; { Console.WriteLine("Hello from the task."); });
Console.WriteLine("Main thread is done.");
Console.ReadKey();</pre>			<p><strong class="source-inline">Task</strong> is just another C# class that handles much of the concurrency for us. In this case, we call <strong class="source-inline">static method Run()</strong>, which takes a delegate that <span class="No-Break">it performs.</span></p>
			<p>We can rewrite this <span class="No-Break">as follows:</span></p>
			<pre class="source-code">
Task myTask = Task.Run(DoWork);
Console.WriteLine("Main thread is done.");
Console.ReadKey();
return 0;
void DoWork()
{
    Console.WriteLine("Hello from the task.");
}</pre>			<p>This code<a id="_idIndexMarker291"/> snippet does the same, but we call the method instead of using the <span class="No-Break">lambda expression.</span></p>
			<p>We can more or less do the same thing in a slightly <span class="No-Break">different way:</span></p>
			<pre class="source-code">
Task myTask = new Task(DoWork);
myTask.Start();</pre>			<p>I have omitted the <strong class="source-inline">Console</strong> stuff and the actual method; they will remain the same (until I say that I have <span class="No-Break">changed them).</span></p>
			<p>This code does more or less the same thing as the previous sample. The difference is that the <strong class="source-inline">Task</strong> does not start unless we explicitly <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">Start()</strong></span><span class="No-Break">.</span></p>
			<p>The second example gives you more control over the <strong class="source-inline">Task</strong>. You can set properties and change the task’s behavior before starting it. <strong class="source-inline">Task.Run()</strong> is mostly designed for fire-and-forget scenarios. <strong class="source-inline">Start()</strong> is more flexible; it allows us to change the scheduling and, for instance, tell it to run on a specific thread. You can also specify the priority of the <strong class="source-inline">Task</strong> <span class="No-Break">this way.</span></p>
			<p>This example is not very exciting. Let us try to make it a bit more exhilarating. We can change our method to <span class="No-Break">the following:</span></p>
			<pre class="source-code">
void DoWork(int id)
{
    Console.WriteLine($"call Id {id}.");
}</pre>			<p>We will add a parameter to our method to identify who calls the method. Since we now have a parameter, we must also change how we pass this to the <strong class="source-inline">Task</strong> constructor. Let’s not stop there. Imagine that we want to chain method calls. After the <strong class="source-inline">Task</strong> has finished with <strong class="source-inline">DoWork</strong> with <strong class="source-inline">Id 1</strong>, we want it to call that method again but with <strong class="source-inline">Id 2</strong> this time. In real life, you would probably chain two completely different methods, but the way of working is <span class="No-Break">the same.</span></p>
			<p>The code looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Task myTask = new Task(() =&gt; DoWork(1));
myTask.ContinueWith((prevTask) =&gt; DoWork(2));
myTask.Start();</pre>			<p>We have <a id="_idIndexMarker292"/>changed the parameter in the constructor so that we can pass that <strong class="source-inline">1</strong> integer to the method. The following line is more interesting. It says: “When you finish the first step, call <strong class="source-inline">DoWork</strong> again, but this time with <strong class="source-inline">Id 2</strong>.” The <strong class="source-inline">prevTask</strong> parameter is the previous <strong class="source-inline">Task</strong> that has finished its work. This triggered the start of the <span class="No-Break">second </span><span class="No-Break"><strong class="source-inline">Task</strong></span><span class="No-Break">.</span></p>
			<p>If you run this, you will see the lines printed to the console in the <span class="No-Break">correct order.</span></p>
			<p>Let us rewrite the method that gets called one <span class="No-Break">more time:</span></p>
			<pre class="source-code">
void DoWork(int id)
{
    Console.WriteLine($"call Id {id}, " +
                      $"running on thread " +
                      $"{Thread.CurrentThread.ManagedThreadId}.");
}</pre>			<p>We added the <strong class="source-inline">id</strong> of the thread this method runs on to the output. I also want to see that <strong class="source-inline">id</strong> thread before we start the tasks. Our calling code now looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
Console.WriteLine($"Our main thread id =
{Thread.CurrentThread.ManagedThreadId}.");
Task myTask = new Task(() =&gt; DoWork(1));
myTask.ContinueWith((prevTask) =&gt; DoWork(2));
myTask.Start();</pre>			<p>If you run this, you will probably see that the tasks run on a different thread rather than the main one. If you repeat this a few times, it might even happen that the second task runs on a different thread from the first one. It is impossible to predict when this will happen; the scheduler picks whatever works best given the current conditions. We do not have to worry about this. It just works. Neat, <span class="No-Break">isn’t it?</span></p>
			<p>Another nice class that is available in the TPL is the <strong class="source-inline">Parallel</strong> class. It allows us to do stuff in parallel. Let’s <span class="No-Break">see that</span></p>
			<pre class="source-code">
Console.WriteLine($"Our main thread id =
{Thread.CurrentThread.ManagedThreadId}.");
int[] myIds = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
Parallel.ForEach(myIds, (i) =&gt; DoWork(i));</pre>			<p>First, we<a id="_idIndexMarker293"/> will print the <strong class="source-inline">id</strong> of the current thread. Then we will create an array of integers from <strong class="source-inline">1</strong> to <strong class="source-inline">10</strong>; nothing special here. After that, we will call the static <strong class="source-inline">ForEach</strong> method on the <strong class="source-inline">Parallel</strong> class and give it the array and the lambda to call. The method iterates through the array and calls the lambda with the correct parameter. It does that in parallel, not sequentially, as with a standard <span class="No-Break"><strong class="source-inline">ForEach</strong></span><span class="No-Break"> loop.</span></p>
			<p>When you run this, you will see some exciting results. The order in which the program prints the IDs is entirely random. You will see that the runtime uses multiple threads, but sometimes it reuses some of <span class="No-Break">these threads.</span></p>
			<p>Again, the TPL determines the best way to do this and handles all the threads’ creation and scheduling <span class="No-Break">for you.</span></p>
			<p>TPL is extremely powerful. It is also the backbone of the async await pattern. This is a pattern that simplifies working with concurrency so much that most users do not realize what is happening behind the scenes. With your newfound knowledge, you should have no problem following what is happening. So, let’s have a look <span class="No-Break">at async/await.</span></p>
			<h1 id="_idParaDest-98"><a id="_idTextAnchor097"/>Async/await</h1>
			<p>Software <a id="_idIndexMarker294"/>hardly ever runs in isolation. Most software needs to reach outside of its boundaries and access something that is not part of the code block at some point. Examples include reading and writing files, reading data from a network, sending something to a printer, and so on. Suppose that a typical machine can access a byte in memory in about 10 nanoseconds. Reading that same byte from an SSD takes approximately 1,000,000 nanoseconds or even longer. Reading data from external devices is usually about 100,000 to 1,000,0000 times slower than reading local data from memory. Think about that when you try to optimize your code if you know that your software transfers data to and from <span class="No-Break">external hardware.</span></p>
			<p>Let’s take this one step further. Let us assume that you have a decent machine that can quickly process data. You need to read data from an external website. Your program must wait very long before that data is available. It can take milliseconds before that data reaches us. For us mere humans, that is pretty fast, but the computer could have done a million other tasks in the meantime. That seems like a colossal waste of our expensive <span class="No-Break">resources, right?</span></p>
			<p>Threading <a id="_idIndexMarker295"/>can help, of course. You can create a thread to call the external website and wait for that to finish, doing other things in the meantime. However, as we have seen, threads can be quite cumbersome. The TPL helps, but still, things can get complicated. Reading data from external sources or writing data to external targets is so common that the CLR designers decided to help us by <span class="No-Break">introducing async/await.</span></p>
			<p>The top-down approach is simple: anything that takes more time than simple operations should be done asynchronously. However, we do not want to deal with the threads themselves. Async/await, which uses the TPL internally, is a pattern that <span class="No-Break">can help.</span></p>
			<p>What it does is this: as soon as you have code that needs to be run asynchronously, the compiler injects code that wraps our code into a state machine. This state machine tracks the threads and the progress of our code and switches back and forth between the blocks of code that <span class="No-Break">need attention.</span></p>
			<p>Does that sound complicated? Well, it is. The usage, however, is straightforward. However, before I show it to you, I want to introduce a little piece of helper code I often use when discussing async/await. This code is just an extension method on the <strong class="source-inline">string</strong> class and outputs a <strong class="source-inline">string</strong> to the console and adds the <strong class="source-inline">ManagedThreadId</strong>. It even allows for coloring the output, making it easier to distinguish between the different threads. If you want to use this, go ahead. If you would rather use <strong class="source-inline">Console.WriteLine()</strong> everywhere yourself instead, be my guest. However, using this makes the critical part of the code more readable. Here is my <span class="No-Break">extension method:</span></p>
			<pre class="source-code">
using static System.Threading.Thread;
namespace ExtensionLibrary;
public static class StringExtensions
{
    public static string Dump(this string message,         ConsoleColor printColor = ConsoleColor.Cyan)
    {
        var oldColor = Console.ForegroundColor;
        Console.ForegroundColor = printColor;
      Console.WriteLine($"({CurrentThread.ManagedThreadId})\t :         {message}");
        Console.ForegroundColor = oldColor;
        return message;
    }
}</pre>			<p>You can also<a id="_idIndexMarker296"/> find this code in the <span class="No-Break">GitHub repository.</span></p>
			<p>First, I want to show you the most <span class="No-Break">simple example:</span></p>
			<pre class="source-code">
using ExtensionLibrary;
DoWork();
// The program is paused until DoWork is finished.
// This is a waste of CPU!
"Just before calling the long-running DoWork()"
    .Dump(ConsoleColor.DarkBlue);
"Program has finished".Dump(ConsoleColor.DarkBlue);
Console.ReadKey();
void DoWork()
{
    "We are doing important stuff!".Dump(ConsoleColor.DarkYellow);
    // Do something useful, then wait a bit.
    Thread.Sleep(1000);
}</pre>			<p>Imagine<a id="_idIndexMarker297"/> that we want do something that takes a long time, such as reading a file from storage, in our <strong class="source-inline">DoWork()</strong> method. I have simulated that here by pausing the current thread for a second. Our entire program is paused while we call this in our main method. Our costly and powerful CPU is left to do nothing (at least not for our program). That seems wasteful! We’ve seen that we can use threads or the TPL to improve that. However, that code is also wrapped in the async/await pattern, so why not <span class="No-Break">use this?</span></p>
			<p>To do this, I replaced <strong class="source-inline">Thread.Sleep()</strong> with a call to <strong class="source-inline">Task.Delay()</strong>. That more or less does the same thing but allows us to improve on our code. Remember: this <strong class="source-inline">Thread.Sleep()</strong> and the new <strong class="source-inline">Task.Delay()</strong> method are just a stand-in for the real work your application should be doing. Having a <strong class="source-inline">Sleep()</strong> or <strong class="source-inline">Delay()</strong> method in your code is usually a <span class="No-Break">bad idea.</span></p>
			<p>If you have to call an async method, you must wait for it. So, we will add the <strong class="source-inline">await</strong> keyword before the call <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">Task.Delay()</strong></span><span class="No-Break">.</span></p>
			<p>Once we have done that replacement, I will also prefix our method with the <strong class="source-inline">async</strong> keyword. This keyword tells the compiler that it should wrap this method in the state machine I mentioned earlier. However, any async method should never return void for reasons that will become clear later. We need to return a <strong class="source-inline">Task</strong> or a <strong class="source-inline">Task&lt;&gt;</strong> if you actually return something. So, we changed our void to <strong class="source-inline">Task</strong>. Again, any async method needs to be called with the <strong class="source-inline">await</strong> keyword. So, the result looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
using ExtensionLibrary;
"Just before calling the long-running DoWork()"
    .Dump(ConsoleColor.DarkBlue);
await DoWork();
// The program is no longer paused until DoWork is finished.
// This allows the CPU to keep working!
"Program has finished".Dump(ConsoleColor.DarkBlue);
Console.ReadKey();
async Task DoWork()
{
    "We are doing important stuff!".Dump(ConsoleColor.DarkYellow);
    // Do something useful, then wait a bit.
    await Task.Delay(1000);
}</pre>			<p>Run this and see <span class="No-Break">what happens.</span></p>
			<p>You will probably see that <a id="_idIndexMarker298"/>the program starts on one thread and then carries out the <strong class="source-inline">DoWork()</strong> method on that same thread, but that it switches to a new thread when that is done. That is because the compiler sees our <strong class="source-inline">Task.Delay()</strong> await and decides to free up the CPU to do other things. The runtime puts our current thread on hold and stores its state in memory, leaving our main code free to do other things. Only when <strong class="source-inline">Task.Delay()</strong> finishes is our main thread revived. However, since the main thread is no longer associated with our code here, we need a new thread. That one is pulled from the <strong class="source-inline">ThreadPool</strong> (remember: that is fast since the threads there were created at startup) and populated with the state we had. Then the system can continue on that thread. The program ends on that new thread <span class="No-Break">as well!</span></p>
			<p>I mentioned that all async methods need the async modifier and should return a <strong class="source-inline">Task</strong> instead of a void. There is a simple reason for this. If you do not do this, your code will work but not as expected. The <strong class="bold">Async all the way to the top</strong> rule is simple but <span class="No-Break">very important.</span></p>
			<p class="callout-heading">Async all the way to the top!</p>
			<p class="callout">If you have a method <a id="_idIndexMarker299"/>containing an <strong class="source-inline">await</strong> keyword, the method needs to be async and return a <strong class="source-inline">Task</strong>. However, since you will probably call that method yourself somewhere, the calling code must also be async and return some form of <strong class="source-inline">Task</strong> or <strong class="source-inline">Task&lt;&gt;</strong>. Since that method is also called… well, you get the idea. The rule is: async all the way to the top! Every method in that chain needs to have <span class="No-Break">that async!</span></p>
			<p>Another rule, which is <a id="_idIndexMarker300"/>not as strict as the “Async all the way to the top” rule, is that all async methods should be named as such. Our <strong class="source-inline">DoWork()</strong> method should be renamed <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">DoWorkAsync()</strong></span><span class="No-Break">.</span></p>
			<p>However, before we do that, let us see what happens if we are sloppy and do not return a <strong class="source-inline">Task</strong>. Try it yourself: replace the <strong class="source-inline">Task</strong> return type with a void and remove the await before <strong class="source-inline">DoWork()</strong> (you cannot await a void, so you will get an error if you do not <span class="No-Break">remove that).</span></p>
			<p>Run it. It works just fine, right? Okay, there is no new thread created, but who cares? The software does what it needs <span class="No-Break">to do.</span></p>
			<p>Now, let’s change our <strong class="source-inline">DoWork()</strong> method <span class="No-Break">a bit:</span></p>
			<pre class="source-code">
using ExtensionLibrary;
"Just before calling the long-running DoWork()"
    .Dump(ConsoleColor.DarkBlue);
DoWork();
"Program has finished".Dump(ConsoleColor.DarkBlue);
//Console.ReadKey();
async void DoWork()
{
    "We are doing important stuff!"
        .Dump(ConsoleColor.DarkYellow);
    await Task.Delay(1000);
    throw new Exception(
        "Something went terribly wrong."
    );
    "We're done with the hard work."
        .Dump(ConsoleColor.DarkYellow);
}</pre>			<p>I also temporarily removed the <strong class="source-inline">ReadLine()</strong> to make the program more lifelike. The main thread finishes when everything <span class="No-Break">is done.</span></p>
			<p>Run it. See<a id="_idIndexMarker301"/> that we do not get the <strong class="source-inline">“We’re done with the hard work” </strong>message. That makes sense; there is an exception in front of it. However, please notice that we also do not see <span class="No-Break">that exception.</span></p>
			<p>Why is this? It’s complicated, but the simplified explanation is that the state machine is still created since <strong class="source-inline">DoWork</strong> is still an async method. The exception is raised on a different thread (after the <strong class="source-inline">Task.Delay()</strong> await). However, since the state machine is not configured to wait for all results (because we omitted the <strong class="source-inline">await</strong> keywords), it just ignores that thread. If you move that “We’re done with the hard work” <strong class="source-inline">Dump()</strong> line to the line before the exception, you will see that it is not called. In reality, it <em class="italic">is</em> called; you just don’t see it. This thread has become a fire-and-forget thread. You lost all control <span class="No-Break">over it.</span></p>
			<p>Can you imagine a complex piece of software where something goes wrong deep in the bowels of your code? Can you imagine not getting the exception? Can you imagine the horror of <span class="No-Break">debugging that?</span></p>
			<p>You will get that exception if you use async/await all the <span class="No-Break">way up.</span></p>
			<p>Oh, before I forget: the reason that I removed the <strong class="source-inline">Console.ReadKey()</strong> line is that by doing so, I forced the main thread to quit as soon as possible, resulting in unloading the application from memory. If you restore that line, you will see the exception, since the main thread is paused there. Now other things will be allowed <span class="No-Break">to happen.</span></p>
			<p>However, that is <a id="_idIndexMarker302"/>not really a solution to our problem. You do not want to wait for the main thread to become idle before you get exceptions. It could take ages for that <span class="No-Break">to happen.</span></p>
			<p>Please restore the async/await keywords, replace the void in <strong class="source-inline">DoWork()</strong> with <strong class="source-inline">Task</strong>, and run it. The exception is thrown precisely where you would expect it <span class="No-Break">to be.</span></p>
			<p>This is really important, so I like to repeat it once more: async all the way to <span class="No-Break">the top!</span></p>
			<h2 id="_idParaDest-99"><a id="_idTextAnchor098"/>Task.Wait() and Task.Result</h2>
			<p>There are<a id="_idIndexMarker303"/> many blog posts and articles about why you should not use <strong class="source-inline">Task.Wait()</strong> or <strong class="source-inline">Task.Result</strong>. The<a id="_idIndexMarker304"/> reason for this is pretty simple: these calls block the current thread. Using them removes the scheduler’s ability to resume work on the calling thread and return to the execution flow when the <strong class="source-inline">Task</strong> is done. If you do this, why use async/await in the first place? Async/await also allows for thread synchronization, so there is no need to use <strong class="source-inline">Wait()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Result</strong></span><span class="No-Break">.</span></p>
			<p>Hold on. There are some situations where you might decide to use <span class="No-Break">them anyway:</span></p>
			<ul>
				<li>You may want to use them if you are working on legacy code that you are modernizing. The rule is “Async all the way to the top,” which might require extensive code refactoring. That is not always feasible. In those cases, you might use <strong class="source-inline">Wait()</strong> and <span class="No-Break"><strong class="source-inline">Result</strong></span><span class="No-Break"> instead.</span></li>
				<li>In unit tests, you can mock or stub async methods. However, sometimes it might be better for the unit test to use <strong class="source-inline">Wait()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Result</strong></span><span class="No-Break">.</span></li>
				<li>You might not care about the main thread staying responsive in systems programming. There is no user interface, after all. So, blocking the main thread may not be a big problem. I still think that it is bad form not to use async/await, but in these cases, you can get away with using <strong class="source-inline">Wait()</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">Result</strong></span><span class="No-Break">.</span></li>
			</ul>
			<p>As with all rules in software development, be vigilant about these rules and apply them as much as possible, only breaking them if you have a good reason and have thought about it well. Also, please do your future self a favor and document why you chose to deviate from the usual way of working in the <span class="No-Break">source code.</span></p>
			<p>So, now you know how to use async/await. Although they do not always result in multiple threads, they are a great way to balance the load in your application. They help tremendously in keeping your code organized. You are relieved of the burden to do all synchronization between threads. However, that doesn’t mean that you never have to care about synchronization at all. There is no avoiding that, so I think we should talk about it <span class="No-Break">right now.</span></p>
			<h1 id="_idParaDest-100"><a id="_idTextAnchor099"/>Synchronizing threads</h1>
			<p>The async/await pattern<a id="_idIndexMarker305"/> has made life easier for us developers. If you have a long-running task (and remember: anything that uses devices outside the CPU is long-running), you can call that method asynchronously. Then you can sit back and wait for it to finish without blocking the execution of your app in other places. The TPL takes care of the <span class="No-Break">thread management.</span></p>
			<p>However, sometimes you may want to have a bit more control. You might have a situation where you must wait for a method to finish before you can continue. Imagine that you have your main thread and call the <strong class="source-inline">A()</strong> method. That method is long-running, so you make it async (rename it to something ending with ‘async’) and change the return type to <strong class="source-inline">Task</strong> or <strong class="source-inline">Task&lt;&gt;</strong>. Now you can wait for it. However, another thread might have to wait until your <strong class="source-inline">Aasync()</strong> method is finished. How do you <span class="No-Break">do that?</span></p>
			<p>Welcome to the wonderful world of <span class="No-Break">thread synchronization.</span></p>
			<h2 id="_idParaDest-101"><a id="_idTextAnchor100"/>Synchronization – how do we do that?</h2>
			<p>In the old days, when <a id="_idIndexMarker306"/>we still used threads and the <strong class="source-inline">ThreadPool</strong>, synchronization could be a hassle. However, with <strong class="source-inline">Task</strong> and async/await, things have become much easier without having real downsides. Before I show you that, I want to show you how to synchronize threads instead <span class="No-Break">of tasks.</span></p>
			<p>Let me start with the <span class="No-Break">base program:</span></p>
			<pre class="source-code">
using ExtensionLibrary;
"In the main part of the app.".Dump(ConsoleColor.White);
ThreadPool.QueueUserWorkItem(DoSomethingForTwoSeconds);
ThreadPool.QueueUserWorkItem(DoSomethingForOneSecond);
"Main app is done.\nPress any key to
stop.".Dump(ConsoleColor.White);
Console.ReadKey();
return 0;
void DoSomethingForOneSecond(object? notUsed)
{
    $"Doing something for one second.".Dump(ConsoleColor.Yellow);
    Thread.Sleep(1000);
    $"Finished something for one second".Dump(ConsoleColor.Yellow);
}
void DoSomethingForTwoSeconds(object? notUsed)
{
    "Doing something for two
        seconds.".Dump(ConsoleColor.DarkYellow);
    Thread.Sleep(2900);
    "Done doing something for two
        seconds.".Dump(ConsoleColor.DarkYellow)
}</pre>			<p>This sample should be obvious now. I have two methods that do something that takes a long time to finish. I pull some threads out of the <strong class="source-inline">ThreadPool</strong> and run all of <span class="No-Break">this simultaneously.</span></p>
			<p>If you run this, the <strong class="bold">Main app is done</strong> message is printed first. The only reason why we see the other messages is because we have the <strong class="source-inline">Console.ReadKey()</strong> in place. What could we do if we want to wait for the two methods to be finished before we <span class="No-Break">move on?</span></p>
			<p>The answer is to<a id="_idIndexMarker307"/> use a synchronization mechanism. This means that we have an object that we can use to flag certain states. We can write it ourselves, but we must take care of a lot of synchronization and thread safety. Luckily, we do not have to. The Win32 API provides tools that are neatly wrapped in <span class="No-Break">BCL classes.</span></p>
			<p>One of these is the <strong class="source-inline">CountdownEvent</strong> class. As the name suggests, it allows us to count <span class="No-Break">down events.</span></p>
			<p>Change your main method to look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
"In the main part of the app.".Dump(ConsoleColor.White);
// Tell the system we want to wait for 2 threads to finish.
CountdownEvent countdown = new(2);
ThreadPool.QueueUserWorkItem(DoSomethingForOneSecond);
ThreadPool.QueueUserWorkItem(DoSomethingForTwoSeconds);
// Do the actual waiting.
countdown.Wait();
"Main app is done.\nPress any key to stop.".Dump(ConsoleColor.White);
Console.ReadKey();
return 0;</pre>			<p>We will create a new instance of the <strong class="source-inline">CountdownEvent</strong> class and initialize it <span class="No-Break">to </span><span class="No-Break"><strong class="source-inline">2</strong></span><span class="No-Break">.</span></p>
			<p>Then, we will get the threads and allow them to do <span class="No-Break">their work.</span></p>
			<p>In the code in the methods, I have added <span class="No-Break">one line:</span></p>
			<pre class="source-code">
void DoSomethingForOneSecond(object? notUsed)
{
    $"Doing something for one second.".Dump(ConsoleColor.Yellow);
    Thread.Sleep(1000);
    $"Finished something for one second".Dump(ConsoleColor.Yellow);
    countdown.Signal();
}</pre>			<p>At the bottom <a id="_idIndexMarker308"/>of the method, you will see the <strong class="source-inline">.Signal()</strong> countdown. Since that instance is reachable in this method, I can use it. <strong class="source-inline">Signal()</strong> tells the countdown to decrease the number of events to <span class="No-Break">wait for.</span></p>
			<p>I did the same to the <span class="No-Break"><strong class="source-inline">DoSomethingForTwoSeconds()</strong></span><span class="No-Break"> method.</span></p>
			<p>That means that when both methods are done, they call <strong class="source-inline">Signal()</strong> on the countdown. In the main method, I added <strong class="source-inline">countdown.Wait()</strong> after the <strong class="source-inline">ThreadPool</strong> code, telling the main thread to pause until the countdown <span class="No-Break">reaches zero.</span></p>
			<p>If you run this, you will see it works wonderfully and that the rest of the main thread is perfectly synchronized with <span class="No-Break">the threads.</span></p>
			<p>However, what if I want the <strong class="source-inline">DoSomethingForTwoSeconds</strong> method to start when <strong class="source-inline">DoSomethingForOneSecond</strong> <span class="No-Break">is finished?</span></p>
			<p>That is almost as easy. We can use one of the other synchronization classes to help us out. Let me show you how to do this using the <strong class="source-inline">ManualResetEvent</strong>. This class does more or less the same as the <strong class="source-inline">CountdownEvent</strong>. The difference is that the <strong class="source-inline">ManualResetEvent</strong> class does not count; it just waits for <span class="No-Break">a signal.</span></p>
			<p>In the main method, before calling the <strong class="source-inline">ThreadPool</strong>, I have added <span class="No-Break">this line:</span></p>
			<pre class="source-code">
ManualResetEvent mre = new(false);</pre>			<p>I have set it in the initial <strong class="source-inline">False</strong> state. Doing so results in any thread waiting for the event to <span class="No-Break">be set.</span></p>
			<p>In <strong class="source-inline">DoSomethingForOneSecond()</strong>, I have added one line right at <span class="No-Break">the end:</span></p>
			<pre class="source-code">
// Tell the second thread it can start
mre.Set();</pre>			<p>The call to <strong class="source-inline">Set</strong> tells the <strong class="source-inline">ManalResetEvent</strong> that any waiting thread <span class="No-Break">can continue.</span></p>
			<p>In <strong class="source-inline">DoSomethingForTwoSeconds()</strong>, I have added the following to the beginning of <span class="No-Break">the method:</span></p>
			<pre class="source-code">
// Wait for the first thread to finish.
mre.WaitOne();</pre>			<p><strong class="source-inline">WaitOne()</strong> tells the code to pause the thread until the <strong class="source-inline">mre</strong> gets a signal (which happens at the end <span class="No-Break">of </span><span class="No-Break"><strong class="source-inline">DoSomethingForOneSecond()</strong></span><span class="No-Break">).</span></p>
			<p>If you run your <a id="_idIndexMarker309"/>program now, you will notice that everything is nicely synchronized and waiting for other stuff <span class="No-Break">to finish.</span></p>
			<p>Of course, you might have achieved precisely the same result by not using threads. We have basically removed all multitasking from our application. If you need to synchronize threads, now you know how. However, be careful: you might introduce weird errors if you make mistakes. Trust me: debugging multithreaded applications is no walk in <span class="No-Break">the park.</span></p>
			<h2 id="_idParaDest-102"><a id="_idTextAnchor101"/>Synchronization with async/await</h2>
			<p>You might<a id="_idIndexMarker310"/> have guessed by now that using async/await dramatically reduces the complexity of working with threads and synchronizing <span class="No-Break">between them.</span></p>
			<p>Let us return to our example of the <strong class="source-inline">DoSomethingForOneSecond</strong> and <strong class="source-inline">DoSomethingForTwoSeconds</strong> methods. This time, we will rewrite them to <span class="No-Break">use async/await.</span></p>
			<p>Your <strong class="source-inline">DoSomethingForOneSecond</strong> should be <span class="No-Break">like this:</span></p>
			<pre class="source-code">
async Task DoSomethingForOneSecondAsync()
{
    $"Doing something for one second.".Dump(ConsoleColor.Yellow);
    await Task.Delay(1000);
    $"Finished something for one second".Dump(ConsoleColor.Yellow);
}</pre>			<p>I renamed the function to end with async, as I should have done <span class="No-Break">much earlier.</span></p>
			<p>The <strong class="source-inline">DoSomethingForTwoSecondsAsync()</strong> should get the <span class="No-Break">same treatment.</span></p>
			<p>Calling the <a id="_idIndexMarker311"/>methods in the main method now looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
"In the main part of the app.".Dump(ConsoleColor.White);
await DoSomethingForOneSecondAsync();
await DoSomethingForTwoSecondsAsync();
"Main app is done.\nPress any key to stop.".Dump(ConsoleColor.White);
Console.ReadKey();
return 0;</pre>			<p>The results are identical to those from the example where we did all the synchronization ourselves, with the only difference being that we have no blocking threads anymore. So this is not only easier to do but it is also <span class="No-Break">much better.</span></p>
			<p>However, what happens if we do not want to do the methods sequentially? What if we want them to <span class="No-Break">run simultaneously?</span></p>
			<p>Well, that is easy enough. Since our methods return a <strong class="source-inline">Task</strong>, we can work with that. Instead of waiting for them individually, we can simultaneously wait for them. Let me <span class="No-Break">show you:</span></p>
			<pre class="source-code">
var task1 = DoSomethingForOneSecondAsync();
var task2 = DoSomethingForTwoSecondsAsync();
// Wait for all tasks to be finished
Task.WaitAll(task1, task2);
"Main app is done.\nPress any key to stop.".Dump(ConsoleColor.White);
Console.ReadKey();
return 0;</pre>			<p>We will take advantage of the fact that we get tasks back. The <strong class="source-inline">Task</strong> class has a static method called <strong class="source-inline">WaitAll()</strong> that only returns when all tasks <span class="No-Break">are finished.</span></p>
			<p>There are<a id="_idIndexMarker312"/> other methods, such as <strong class="source-inline">WaitAny</strong> (only continue when any of the tasks finish), WhenAll (do something when they are all done), and WhenAny (you can figure this out <span class="No-Break">by yourself).</span></p>
			<p>The difference between <strong class="source-inline">WaitAll</strong> or <strong class="source-inline">WaitAny</strong> and <strong class="source-inline">WhenAll</strong> or <strong class="source-inline">WhenAny</strong> is that <strong class="source-inline">WaitXXX</strong> is a blocking call. It blocks the current thread until the condition has been met<strong class="source-inline">. WhenXXX</strong> returns a Task itself that you can await and thus does not block <span class="No-Break">the thread.</span></p>
			<p>However, there is a bigger difference: <strong class="source-inline">WhenAll</strong> allows you to capture the return result. If any tasks that you want to wait for return a result, you can get that with <strong class="source-inline">WhenAll</strong>. <strong class="source-inline">WhenAll</strong> returns the results to you in an array. You can get at them, which is something you cannot do with <strong class="source-inline">WaitAll</strong> <span class="No-Break">or </span><span class="No-Break"><strong class="source-inline">WaitAny</strong></span><span class="No-Break">.</span></p>
			<p>In case you were wondering, <strong class="source-inline">WhenAny</strong> returns a <strong class="source-inline">Task&lt;T&gt;</strong>. That <strong class="source-inline">Task&lt;T&gt;</strong> has a property called <strong class="source-inline">Result</strong>; you can read that property to get access to the result of that Task. This is one example when using <strong class="source-inline">Result</strong> is actually a <span class="No-Break">good thing!</span></p>
			<h2 id="_idParaDest-103"><a id="_idTextAnchor102"/>Canceling a thread</h2>
			<p>Sometimes, you want to <a id="_idIndexMarker313"/>stop a thread from running. There might be several good reasons to do this, but whatever your reason, be sure to clean up after yourself. Threads are expensive to use and leaving them in an unknown state is a horrible practice: you shoot yourself in the foot <span class="No-Break">one day.</span></p>
			<p>In the days of.NET Framework, the <strong class="source-inline">Thread</strong> class had a method called <strong class="source-inline">Abort()</strong>. However, it turned out that the method did more harm than good, so the BCL and CLR people decided to get rid of it. If you try to abort a thread, you will get a <strong class="source-inline">PlatformNotSupportedException</strong>. I guess they really do not want us to use <span class="No-Break">that anymore.</span></p>
			<p>The best way to stop a running thread is the same way you should stop a running <strong class="source-inline">Task</strong>: using something we <a id="_idIndexMarker314"/>call <strong class="bold">cooperative cancellation</strong>. A calling thread can request another thread to stop. It is up to that second thread to honor that request – or not. There is <span class="No-Break">no guarantee.</span></p>
			<p>The standard way of doing this is by using a <strong class="source-inline">CancellationToken</strong>. A <strong class="source-inline">CancellationToken</strong> is an object we use to signal that we want to <span class="No-Break">cancel something.</span></p>
			<p>Of course, you <a id="_idIndexMarker315"/>can write this class yourself. There is not much going on besides some thread safety. However, having a <strong class="source-inline">CancellationToken</strong> in your threads or tasks makes it clear to the user that it can <span class="No-Break">be canceled.</span></p>
			<p>I am going to rewrite our <strong class="source-inline">DoSomethingForOneSecondAsyncMethod()</strong> <span class="No-Break">a bit:</span></p>
			<pre class="source-code">
async Task DoSomethingForOneSecondAsync()
{
    $"Doing something for one second.".Dump(ConsoleColor.Yellow);
    for(int i=0;i&lt;1000;i++)
        await Task.Delay(1);
    $"Finished something for one second".Dump(ConsoleColor.Yellow);
}</pre>			<p>Instead of having the <strong class="source-inline">Task.Delay(1000) </strong>call, I do <strong class="source-inline">1000 </strong>await <strong class="source-inline">Task.Delay1)</strong>. In theory, that would result in a one-second delay. However, when you run this, it takes considerably longer. The await call itself takes up some time <span class="No-Break">as well.</span></p>
			<p>I could measure how long it takes and then recalculate the number of iterations, or I could simply rename the method to <strong class="source-inline">DoSomethingForSomeUnderterminedAmountOfTimeAsync()</strong>. I will leave that decision up <span class="No-Break">to you.</span></p>
			<p>Assume that we get bored after 500 milliseconds after waiting in our main method and decide to stop this thread. How would we <span class="No-Break">achieve that?</span></p>
			<p>This is where the <strong class="source-inline">CancellationToken</strong> steps in. Again, a <strong class="source-inline">CancellationToken</strong> is a simple class. You can create one if you want to, but it is better to use a specialized class. This <strong class="source-inline">CancellationTokenSource</strong> class is created specifically for this and works in all sorts of weird conditions. It is <span class="No-Break">inherently thread-safe.</span></p>
			<p>Let us create <a id="_idIndexMarker316"/>one right at the beginning of the <span class="No-Break">main method:</span></p>
			<pre class="source-code">
using ExtensionLibrary;
"In the main part of the app.".Dump(ConsoleColor.White);
using var cts = new CancellationTokenSource();
var task1 = DoSomethi<a id="_idTextAnchor103"/>ngForOneSecondAsync();
Task.WaitAny(task1);
"Main app is done.\nPress any key to stop.".Dump(ConsoleColor.White);
Console.ReadKey();
return 0;</pre>			<p>I use <strong class="source-inline">WaitAny</strong> here because we want to cancel that task after the moment when we create it and before it has finished. Also, note the <strong class="source-inline">using</strong> statement. <strong class="source-inline">CancellationTokenSource</strong> implements <strong class="source-inline">IDisposable</strong>, so we must <span class="No-Break">honor that.</span></p>
			<p>Canceling is simple. Between the <strong class="source-inline">var task1</strong> and <strong class="source-inline">Task.WaitAny()</strong> lines, add <span class="No-Break">the following:</span></p>
			<pre class="source-code">
await Task.Delay(500);
"We got bored. Let's cancel.".Dump(ConsoleColor.White);
cts.Cancel();</pre>			<p>We will wait a bit, then get bored and <span class="No-Break">call </span><span class="No-Break"><strong class="source-inline">cts.Cancel()</strong></span><span class="No-Break">.</span></p>
			<p>However, if you run this, nothing will happen. That’s not entirely true; many things will happen. To be precise, the entire loop in <span class="No-Break"><strong class="source-inline">DoSomethingForOneSecondAsync</strong></span><span class="No-Break"> happens.</span></p>
			<p><strong class="source-inline">CancellationToken</strong> is not a magic way to cancel running tasks. You have to check for that <span class="No-Break">token yourself.</span></p>
			<p>We have to add a parameter to our method of the <strong class="source-inline">CancellationToken</strong> type. The method signature will now look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
async Task DoSomethingForOneSecondAsync(CancellationToken cancellationToken)</pre>			<p>We have to <a id="_idIndexMarker317"/>pass in that token when we call it. In our main method, change the line calling this method <span class="No-Break">to this:</span></p>
			<pre class="source-code">
var task1 = DoSomethingForOneSecondAsync(cts.Token);</pre>			<p>We will take our <strong class="source-inline">CancellationTokenSource</strong> and get its token. That is what we will pass on to <span class="No-Break">our method.</span></p>
			<p>Inside our method, we must check to see whether we need to cancel. Yes, that is why I added the loop around the <strong class="source-inline">Delay</strong>. The full method will now look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
async Task DoSomethingForOneSecondAsync(CancellationToken cancellationToken)
{
    $"Doing something for one second.".Dump(ConsoleColor.Yellow);
    bool hasBeenCancelled = false;
    int i = 0;
    for (i = 0; i &lt; 1000; i++)
    {
        if (cancellationToken.IsCancellationRequested)
        {
            hasBeenCancelled = true;
            break;
        }
        await Task.Delay(1);
    }
    if(hasBeenCancelled)
    {
        $"We got interrupted after {i} iterations.".Dump(ConsoleColor.            Yellow);
    }
    else
    {
        $"Finished something for one second".Dump(ConsoleColor.            Yellow);
    }
}</pre>			<p>If someone calls <strong class="source-inline">Cancel</strong> on the <strong class="source-inline">CancellationTokenSource</strong>, the <strong class="source-inline">IsCancellationRequested</strong> flag on the token will be set to <strong class="source-inline">True</strong>. We have to honor that. I do that by breaking out of the <strong class="source-inline">for</strong> loop. I have also set a <strong class="source-inline">hasBeenCancelled</strong> variable to <strong class="source-inline">True</strong> so I can inform our users that we have canceled this loop and tell them after how many iterations it <span class="No-Break">was canceled.</span></p>
			<p>We could <a id="_idIndexMarker318"/>have skipped this boolean and used <strong class="source-inline">IsCancellationRequested</strong> again. However, there might have been a risk of the request coming in right after the loop was done but before the printing of the message. In that case, the loop was not interrupted. But we said it was anyway, which is incorrect. This way we avoid printing the <span class="No-Break">wrong message.</span></p>
			<p>Run it and see what happens. On my machine, I get about 40 iterations before <span class="No-Break">it cancels.</span></p>
			<p>There is one bug in this code. It is good practice to pass on the <strong class="source-inline">CancellationToken</strong> to any method that accepts it. In our case, that would be <strong class="source-inline">Task.Delay()</strong>. There is an overload that accepts <span class="No-Break">a </span><span class="No-Break"><strong class="source-inline">CancellationToken</strong></span><span class="No-Break">.</span></p>
			<p>I deliberately left that out here. Since the code would be in that line almost 100% of the time, awaiting the Delay, we would cancel that and never see any printed messages. However, let’s now <span class="No-Break">add it:</span></p>
			<pre class="source-code">
await Task.Delay(1, cancellationToken);</pre>			<p>Rerun it and see <span class="No-Break">what happens.</span></p>
			<p>You might notice that we are missing a lot of screen output. The reason is simple. <strong class="source-inline">Task.Delay()</strong> throws an <strong class="source-inline">OperationCancelledException</strong> when it is canceled. However, we are not using <strong class="source-inline">await</strong> on our <strong class="source-inline">Task</strong> in the main method, so we will miss the <a id="_idIndexMarker319"/>exception. Remember when I said it was all too easy to miss exceptions when not everything is <span class="No-Break">done right?</span></p>
			<p>Synchronization helps to prevent errors from happening. However, there are a lot of techniques to make sure our code is thread-safe. Let’s dive into <span class="No-Break">those now.</span></p>
			<h1 id="_idParaDest-104"><a id="_idTextAnchor104"/>Thread-safe programming techniques</h1>
			<p>Look at this <a id="_idIndexMarker320"/>piece of code. Run it and see <span class="No-Break">what happens:</span></p>
			<pre class="source-code">
using ExtensionLibrary;
int iterationCount = 100;
ThreadPool.QueueUserWorkItem(async (state) =&gt;
{
    await Task.Delay(500);
    iterationCount = 0;
    $"We are stopping it...".Dump(ConsoleColor.Red);
});
await WaitAWhile();
$"In the main part of the app.".Dump(ConsoleColor.White);
"Main app is done.\nPress any key to stop.".Dump(ConsoleColor.White);
Console.ReadKey();
return 0;
async Task WaitAWhile()
{
    do
    {
        $"In the loop at iterations {iterationCount}".            Dump(ConsoleColor.Yellow);
        await Task.Delay(1);
    }while (--iterationCount &gt; 0) ;
}</pre>			<p>We have a <strong class="source-inline">Task</strong> that counts down from 100 to 0. Since we <strong class="source-inline">await</strong> this, the main part of the code waits nicely for this to finish before continuing. However, we also have a second thread that waits for 500 milliseconds and then sets the counter to <strong class="source-inline">0</strong>. The result is that the loop <span class="No-Break">finishes prematurely.</span></p>
			<p>What we see here is easy to debug. Every line of code is one screen, so I imagine that you will be able to spot the bug <span class="No-Break">quite easily.</span></p>
			<p>However, what<a id="_idIndexMarker321"/> if the integer used here is a member of a class? As you know, instances of classes are reference types. Reference types get passed on by reference, not by value. So if the Task has access to that instance, it can alter the members in that instance. However, every other task, thread, or piece of code sees the effects <span class="No-Break">of that.</span></p>
			<p>Thread safety is all about avoiding these kinds <span class="No-Break">of things.</span></p>
			<p>Value types are inherently safe. You will have no issues if you pass a value type such as integer to your <strong class="source-inline">Task</strong>. The value of the integer is copied and you are not changing the <span class="No-Break">original value.</span></p>
			<p>However, if you need to access more complex types, you will need to think about this. The good news is that the runtime offers us several tools to mitigate <span class="No-Break">this issue.</span></p>
			<p>One of the tools you get is the <span class="No-Break"><strong class="source-inline">Lock()</strong></span><span class="No-Break"> keyword.</span></p>
			<h2 id="_idParaDest-105"><a id="_idTextAnchor105"/>Lock()</h2>
			<p>The<a id="_idIndexMarker322"/> simplest way to safeguard your data is to have a lock around it. A lock is an object that more or less works as a moat around a piece of code. A lock ensures that only one thread can simultaneously be in that code block. The syntax <span class="No-Break">is straightforward:</span></p>
			<pre class="source-code">
lock (new object())
{
    iterationCount--;
}</pre>			<p>The lock takes one argument. It uses this to identify the area to lock. It doesn’t do anything with this object; this is just something to hook the lock to. So, having a new <strong class="source-inline">object()</strong> <span class="No-Break">will suffice.</span></p>
			<p>Any code in this code block is safe, meaning that only one thread can decrement the <strong class="source-inline">iterationCount</strong> simultaneously. When another thread tries to do the same thing simultaneously, it blocks as soon as it reaches the lock statement. That thread remains blocked until the previous threat exits the <span class="No-Break">code block.</span></p>
			<p>Yes, this means that if the other thread crashes in that code (not very likely in this example: crashing on a <strong class="source-inline">--</strong> operator happens very infrequently), the rest of the system can never enter that <span class="No-Break">code block.</span></p>
			<p><strong class="source-inline">Lock()</strong> is syntactic sugar around a monitor object. The compiler actually uses <strong class="source-inline">Monitor</strong>s. So, the following code results in the same IL (<span class="No-Break">Intermediate language):</span></p>
			<pre class="source-code">
var lockObject = new object();
Monitor.Enter(lockObject);
try
{
    iterationCount--;
}
finally
{
    Monitor.Exit(lockObject);
    lockObject = null;
}</pre>			<p>I do not know <a id="_idIndexMarker323"/>about you, but the <strong class="source-inline">lock()</strong> statement looks much more effortless <span class="No-Break">to me.</span></p>
			<h2 id="_idParaDest-106"><a id="_idTextAnchor106"/>Records</h2>
			<p>The <a id="_idIndexMarker324"/>best way to ensure that data is not accidentally overridden is to ensure that the data cannot be altered. Immutable types are designed to do <span class="No-Break">just that.</span></p>
			<p>Let me create a <span class="No-Break">record first:</span></p>
			<pre class="source-code">
record Counter(int InitialValue);</pre>			<p>A record is a reference type, so its memory is allocated on the heap. However, records are meant to be immutable. You can create records that are not immutable, but that does not help <span class="No-Break">us here.</span></p>
			<p>Right now, I have a record with one member, <strong class="source-inline">InitialValue</strong>. I have to set the value for that when constructing the <strong class="source-inline">Counter</strong>, but I can never change it after that. So, no thread can come along and mess with that <span class="No-Break">value anymore.</span></p>
			<p>However, since I cannot change it anywhere, I also have to change the code in the <strong class="source-inline">Task</strong>. It will now look <span class="No-Break">like this:</span></p>
			<pre class="source-code">
async Task WaitAWhile()
{
    var actualCounter = myCounter.InitialValue;
    do
    {
        $"In the loop at iterations {actualCounter}".            Dump(ConsoleColor.Yellow);
        await Task.Delay(1);
    } while (--actualCounter &gt; 0);
}</pre>			<p>I have made a copy of the value to decrement that in the loop. If you are a bit like me, you might say, “Wait a minute. Why didn’t I just copy that original <strong class="source-inline">iterationCount</strong> to a local variable and use that instead of <span class="No-Break">this record?”</span></p>
			<p>I see many <a id="_idIndexMarker325"/>people doing that. However, that is not guaranteed to work. What if a separate thread changes the value of <strong class="source-inline">iterationCount</strong> before you can make a copy? You would start with the wrong <span class="No-Break">initial value.</span></p>
			<p>Immutable records guarantee that the values inside it do not change, ever. Period. You <span class="No-Break">are safe.</span></p>
			<h2 id="_idParaDest-107"><a id="_idTextAnchor107"/>Avoid static members and classes</h2>
			<p>I know that<a id="_idIndexMarker326"/> it can be a nuisance to create instances of classes. Sometimes, it seems easier to create a static class filled with static members and use those instead. They certainly do have some use cases. However, remember this: static classes are not thread-safe out of the box. Static members are shared across threads so that anybody can <span class="No-Break">change them.</span></p>
			<h2 id="_idParaDest-108"><a id="_idTextAnchor108"/>Using the volatile keyword</h2>
			<p>Sometimes, code <a id="_idIndexMarker327"/>seems straightforward, but it might not be. Look at <span class="No-Break">this line:</span></p>
			<pre class="source-code">
int a=42;</pre>			<p>We know how this works. This integer is on the stack. If we change the value, the value at that memory address changes. Simple, right? Wrong. The compiler does all sorts of tricks to optimize our code, especially when you build it in Release mode. Building in Release mode means that the compiler might cache the value of even a simple integer to speed things up. It might even decide to move that line to another place in the code if it thinks it will not make a difference in <span class="No-Break">the execution.</span></p>
			<p>That is not a problem until multiple threads or tasks deal with that code. The compiler might make mistakes. It cannot determine which tasks can access that <span class="No-Break">variable simultaneously.</span></p>
			<p>Yes, even simple writing to an integer can go wrong in a <span class="No-Break">multithreaded system.</span></p>
			<p>If we use <strong class="source-inline">lock()</strong>, we can guarantee that only one thread can access that code block, but that still does not mitigate the issue of the <span class="No-Break">compiler optimizations.</span></p>
			<p>To solve this problem, we can use the <strong class="source-inline">volatile</strong> keyword. It looks <span class="No-Break">like this:</span></p>
			<pre class="source-code">
private static volatile int _initialValue = 100;</pre>			<p>Instead <a id="_idIndexMarker328"/>of using a cached value, the compiler ensures that we always go directly to the memory address and stored value. That means that all threads will go to the same place and work with the same integer, thus eliminating the risk of working on old, stale, or <span class="No-Break">cached data.</span></p>
			<p>You might be tempted to add that <strong class="source-inline">volatile</strong> keyword everywhere, but I suggest that you refrain. It does mess with the compiler’s optimization techniques. You should only use it if you suspect that there might be an issue with that particular piece <span class="No-Break">of code.</span></p>
			<p>So, now you know how to be more safe when dealing with threads. This is very important: if you mess things up you can get horrible and hard-to-debug bugs in your code. This is especially true if you are dealing with collections in multiple threads. How do you keep them synchronized? We’re in luck though; the BCL has got us covered there. Let’s talk about <span class="No-Break">concurrent collections.</span></p>
			<h1 id="_idParaDest-109"><a id="_idTextAnchor109"/>Concurrent collections in .NET</h1>
			<p>Collections are <a id="_idIndexMarker329"/>the backbone of many programs. Arrays, lists, dictionaries – we use them all the time. However, are they thread-safe? Let us <span class="No-Break">find out:</span></p>
			<pre class="source-code">
using ExtensionLibrary;
var allLines = new List&lt;string&gt;();
for(int i = 0; i &lt; 1000; i++)
{
    allLines.Add($"Line {i:000}");
}
ThreadPool.QueueUserWorkItem((_) =&gt;
{
    Thread.Sleep(1000);
    allLines.Clear();
});
await DumpArray(allLines);
"Main app is done.\nPress any key to stop.".Dump(ConsoleColor.White);
Console.ReadKey();
return 0;
async Task DumpArray(List&lt;string&gt; someData)
{
    foreach(var data in someData)
    {
        data.Dump(ConsoleColor.Yellow);
        await Task.Delay(100);
    }
}</pre>			<p>We have a <strong class="source-inline">List&lt;string&gt;</strong>. Then we added 1000 strings to that list We have a task that iterates through them, displays them on the screen, and waits <span class="No-Break">a bit.</span></p>
			<p>We also have a separate thread that clears the list after waiting for <span class="No-Break">a second.</span></p>
			<p>If you have read the previous section in this chapter, you might expect the loop in the task to abort prematurely. It should not print all items, since the list is suddenly empty and thus the <span class="No-Break"><strong class="source-inline">ForEach()</strong></span><span class="No-Break"> stops.</span></p>
			<p>However, if you run it, you will see a different result. You will get a nice <strong class="source-inline">InvalidOperationException</strong> telling you that the collection was modified, which messed up the <span class="No-Break"><strong class="source-inline">ForEach</strong></span><span class="No-Break"> code.</span></p>
			<p>Collections in the<a id="_idIndexMarker330"/> BCL are not thread-safe. If one thread works with them and another decides it needs to deal with that collection, things <span class="No-Break">go wrong.</span></p>
			<p>The following collections are not thread-safe and should be avoided when working <span class="No-Break">with tasks:</span></p>
			<ul>
				<li><span class="No-Break"><strong class="source-inline">List&lt;T&gt;</strong></span></li>
				<li><strong class="source-inline">Dictionary&lt;TKey</strong> <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">TValue&gt;</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Queue&lt;T&gt;</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">Stack&lt;T&gt;</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">HashSet&lt;T&gt;</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">ArrayList</strong></span></li>
				<li><span class="No-Break"><strong class="source-inline">HashTable</strong></span></li>
				<li><strong class="source-inline">SortedList&lt;TKey</strong>, <strong class="source-inline">TValue&gt;</strong>, <span class="No-Break">and </span><span class="No-Break"><strong class="source-inline">TSortedList</strong></span></li>
			</ul>
			<p>Do not use these in multiple threads or <span class="No-Break">tasks simultaneously.</span></p>
			<p>Some collections are thread-safe. This is what they are and what <span class="No-Break">they do:</span></p>
			<table class="No-Table-Style _idGenTablePara-1" id="table003-2">
				<colgroup>
					<col/>
					<col/>
				</colgroup>
				<thead>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Collection name</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="bold">Description</strong></span></p>
						</td>
					</tr>
				</thead>
				<tbody>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ConcurrentDictionary&lt;TKey, TValue&gt;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A thread-safe collection of key-value pairs. It allows for concurrent adds, updates, <span class="No-Break">and removals.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ConcurrentQueue&lt;T&gt;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A thread-safe version of a <strong class="bold">First-in, First-out</strong> (<span class="No-Break"><strong class="bold">FIFO</strong></span><span class="No-Break">) collection.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ConcurrentStack&lt;T&gt;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A thread-safe version of a <strong class="bold">Last-in, First-out</strong> (<span class="No-Break"><strong class="bold">LIFO</strong></span><span class="No-Break">) collection.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">ConcurrentBag&lt;T&gt;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>A thread-safe, unordered collection of objects. It is suitable for scenarios where the order is <span class="No-Break">not important.</span></p>
						</td>
					</tr>
					<tr class="No-Table-Style">
						<td class="No-Table-Style">
							<p><span class="No-Break"><strong class="source-inline">BlockingCollection&lt;T&gt;</strong></span></p>
						</td>
						<td class="No-Table-Style">
							<p>Represents a thread-safe collection that can be bounded in size. It provides blocking and non-blocking <strong class="source-inline">add</strong> and <span class="No-Break"><strong class="source-inline">take</strong></span><span class="No-Break"> operations.</span></p>
						</td>
					</tr>
				</tbody>
			</table>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Table 4.3: Thread-safe collections</p>
			<p>The first four <a id="_idIndexMarker331"/>collections are just thread-safe versions of the collections that we already know. Most people, however, would not recognize the last one: the <span class="No-Break"><strong class="source-inline">BlockingCollection&lt;T&gt;</strong></span><span class="No-Break"> collection.</span></p>
			<p>This collection is, first of all, thread-safe. It also allows for blocking. Let me give you <span class="No-Break">an example:</span></p>
			<pre class="source-code">
using ExtensionLibrary;
using System.Collections.Concurrent;
// We have a collection that blocks as soon as
// 5 items have been added. Before this thread
// can continue, one has to be taken away first.
var allLines = new BlockingCollection&lt;string&gt;(boundedCapacity:5);
ThreadPool.QueueUserWorkItem((_) =&gt; {
    for (int i = 0; i &lt; 10; i++)
    {
        allLines.Add($"Line {i:000}");
        Thread.Sleep(1000);
    }
    allLines.CompleteAdding();
});
// Give the first thread some time to add items before
// we take them away again.
Thread.Sleep(6000);
// Read all items by taking them away
ThreadPool.QueueUserWorkItem((_) =&gt; {
    while (!allLines.IsCompleted)
    {
        try
        {
            var item = allLines.Take();
            item.Dump(ConsoleColor.Yellow);
            Thread.Sleep(10);
        }
        catch (InvalidOperationException)
        {
            // This can happen if
            // CompleteAdding has been called
            // but the collection is already empty
            // in our case: this thread finished before the
            // first one
        }
    }
});
"Main app is done.\nPress any key to stop.".Dump(ConsoleColor.White);
Console.ReadKey();
return 0;</pre>			<p>A lot is happening here, so let me walk you <span class="No-Break">through it.</span></p>
			<p>First, we created an instance of the <strong class="source-inline">BlockingCollection</strong>. This class has a nice overloaded constructor that only allows this number of items to be added. If there are more, block the thread. I do not need that functionality here, but I found adding <span class="No-Break">it funny.</span></p>
			<p>Then we<a id="_idIndexMarker332"/> spun up a new thread that adds items to this collection. We can try to add 10, but again, it only allows five items. So, when the fifth item is added, this thread blocks until we have removed one of <span class="No-Break">those items.</span></p>
			<p>At the end of the loop, we told the collection that we had nothing left to add. We did this by <span class="No-Break">calling </span><span class="No-Break"><strong class="source-inline">CompleteAdding()</strong></span><span class="No-Break">.</span></p>
			<p>Before we read the data in the second thread, we waited for a few seconds so the first one had time to fill <span class="No-Break">the collection.</span></p>
			<p>The second thread (third if you also count the main thread) took that collection and took an item from it. It is a FIFO collection, so the first item we could take was the first item added to the list. We displayed what we took and waited a bit. We needed to catch the <strong class="source-inline">InvalidOperationException</strong>. If the <strong class="source-inline">CompleteAdding</strong> was called due to timings by the time we had already taken all the items from the collection, an exception would have occurred. We need to <span class="No-Break">catch that.</span></p>
			<p>Due to our timings and <strong class="source-inline">Thread.Sleep()</strong> calls, we will see a fascinating effect. The first thread fills up the collection with five items. Then it waits. This operation takes five seconds in total. Six seconds after the start of the program, we will start taking items. Since there are plenty of them (five to be exact), the program will print these items on the screen quickly. When we take one item, the first thread gets permission to add a new item. However, since it takes a second to add an item, the second thread has to wait until it has been added. <strong class="source-inline">Take()</strong> will also block if there is nothing to <span class="No-Break">take yet.</span></p>
			<p>Only when the first thread calls the <strong class="source-inline">CompleteAdding()</strong> method does the second thread know it is done (since we checked the <strong class="source-inline">IsCompleted</strong> property). Then, we can exit <span class="No-Break">the threads.</span></p>
			<p>There is much synchronization behind the scenes, but it works amazingly well. This is undoubtedly an excellent addition to <span class="No-Break">your toolbox!</span></p>
			<h1 id="_idParaDest-110"><a id="_idTextAnchor110"/>Next steps</h1>
			<p>That was quite a ride. Threading can be complicated, but we got through it <span class="No-Break">all right.</span></p>
			<p>We looked at many different things in this chapter. We described what multitasking is, starting with old-fashioned IRQs, walking through cooperative multitasking, and arriving at the modern style of <span class="No-Break">pre-emptive multitasking.</span></p>
			<p>Then, we investigated Win32 threads and their .NET counterparts. We saw how to create threads but quickly found that the <strong class="source-inline">Threadpool</strong> offers a better way of doing so in most cases. However, we learned that most of that is moot, since the TPL handles many details <span class="No-Break">for us.</span></p>
			<p>In particular, we learned that async/await hides much complexity and makes writing multithreaded code a breeze. As with all tools, we learned that async/await comes with risks. You have to know what happens and where bad things can happen. Luckily, we covered those situations <span class="No-Break">as well.</span></p>
			<p>We looked at collections and how to make your code thread-safe. We also learned something fundamental regarding async/await: async all the way to <span class="No-Break">the top!</span></p>
			<p>Asynchronous programming is imperative when dealing with devices outside the CPU. One of the areas where we need to use these techniques extensively is in the file system. However, file systems have a lot of other things that you need to know about. So, it’s great that the next chapter deals with <span class="No-Break">that topic!</span></p>
		</div>
	</body></html>