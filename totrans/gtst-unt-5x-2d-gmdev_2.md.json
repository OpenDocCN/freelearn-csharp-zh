["```cs\npublic int testVariable; \n\n```", "```cs\n            [Header(\"This is a heading\")] \n            public int testVariable; \n\n    ```", "```cs\n            [HideInInspector]\n            public int testVariable;\n    ```", "```cs\n            [Range(-10, 10)] \n            public int testVariable; \n\n    ```", "```cs\n            [Tooltip(\"This is a tooltip\")] \n            public int testVariable; \n\n    ```", "```cs\n*//This line is commented* \nThis other one is not. \n*/*Here it is \nagain \ncommented*/*\n\n```", "```cs\npublic float damage;    * //How much damage will the enemy receive* \npublic float speed = 1f;       *//How fast the projectile moves* \npublic Vector3 direction; *//What direction the projectile is heading* \npublic float lifeDuration = 10f; *//How long the projectile lives before*\n *self-destructing*\n\n```", "```cs\nvoid Start() { \n *//Normalize the direction* \n  direction = direction.normalized; \n\n *//Fix the rotation* \n  float angle = Mathf.Atan2(-direction.y, direction.x) * Mathf.Rad2Deg; \n  transform.rotation = Quaternion.AngleAxis(angle, Vector3.forward); \n\n *//Set the timer for self-destruction* \n  Destroy(gameObject, lifeDuration); \n} \n\n```", "```cs\n*// Update the position of the projectile according to time and speed* \nvoid Update() { \n  transform.position += direction * Time.deltaTime * speed; \n} \n\n```", "```cs\npublic float rangeRadius;  *//Maximum distance that the Cupcake Tower\n  can shoot* \npublic float reloadTime;   *//Time before the Cupcake Tower is able to\n  shoot again* \npublic GameObject projectilePrefab; *//Projectile type that is fired\n  from the Cupcake Tower* \nprivate float elapsedTime; *//Time elapsed from the last time the\n  Cupcake Tower has shot*\n\n```", "```cs\nvoid Update () { \n  if (elapsedTime >= reloadTime) { \n    *//Rest of the code* \n  } \n  elapsedTime += Time.deltaTime; \n} \n\n```", "```cs\nif (elapsedTime >= reloadTime) { \n * //Reset elapsed Time* \n  elapsedTime = 0; \n *//Find all the gameObjects with a collider within the range of the\n    Cupcake Tower* \n  Collider2D[] hitColliders =\n    Physics2D.OverlapCircleAll(transform.position, rangeRadius); \n * //Check if there is at least one gameObject found*\n  if (hitColliders.Length != 0) { \n   * //Rest of the code* \n  } \n} \n\n```", "```cs\n if (hitColliders.Length != 0) { \n  *//Loop over all the gameObjects to identify the closest to the\n     Cupcake Tower* \n   float min = int.MaxValue; \n   int index = -1; \n\n   for (int i = 0; i < hitColliders.Length; i++) { \n     if (hitColliders[i].tag == \"Enemy\") { \n       float distance =\n         Vector2.Distance(hitColliders[i].transform.position,\n           transform.position); \n       if (distance < min) { \n         index = i; \n         min = distance; \n       } \n     } \n   } \n   if (index == -1) \n   return; \n   *//Rest of the code* \n } \n\n```", "```cs\n*//Get the direction of the target * \nTransform target = hitColliders[index].transform; \nVector2 direction = (target.position - transform.position).normalized; \n\n```", "```cs\n*//Create the Projectile* \nGameObject projectile = GameObject.Instantiate(projectilePrefab,\n  transform.position, Quaternion.identity) as GameObject; \nprojectile.GetComponent<ProjectileScript>().direction = direction; \n\n```", "```cs\npublic int upgradeLevel; * //Level of the Cupcake Tower*\n\n```", "```cs\npublic Sprite[] upgradeSprites; *//Different sprites for the different\n  levels of the Cupcake Tower*\n\n```", "```cs\n*//Boolean to check if the tower is upgradable* \npublic bool isUpgradable = true; \n\n```", "```cs\npublic void Upgrade() { \n * //Check if the tower is upgradable* \n  if (!isUpgradable) { \n    return; \n  } \n\n  *//Increase the level of the tower* \n  upgradeLevel++; \n\n * //Check if the tower has reached its last level* \n  if(upgradeLevel < upgradeSprites.Length) { \n    isUpgradable = false; \n  } \n\n * //Increase the stats of the tower* \n  rangeRadius += 1f; \n  reloadTime -= 0.5f; \n\n * //Change graphics of the tower* \n  GetComponent<SpriteRenderer>().sprite = upgradeSprites[upgradeLevel]; \n} \n\n```", "```cs\n*//Generates a random number between 2 and 30* \nRandom.Range(2, 30); \n\n```"]