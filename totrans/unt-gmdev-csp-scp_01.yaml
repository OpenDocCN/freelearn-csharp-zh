- en: '1'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with Unity and C# – Game Objects and Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Before starting, I wanted to discuss mistakes. It’s something we all do, or,
    as John Powell said, *The only real mistake is the one from which we learn nothing*
    ([https://www.goodreads.com/quotes/118431-the-only-real-mistake-is-the-one-from-which-we](https://www.goodreads.com/quotes/118431-the-only-real-mistake-is-the-one-from-which-we)).
    Every effort is being made to ensure that this book is as accurate as possible.
    The topics will be reviewed by a team after I submit this draft. I’ll receive
    feedback, and any errors will be corrected.
  prefs: []
  type: TYPE_NORMAL
- en: As a learner, you too will experience mistakes. This is expected, and, as John
    Powell emphasized, we need to learn from them. Try not to get discouraged. This
    is such an exciting topic at a time when opportunities are appearing in every
    industry using what I cover in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Unity 6 has now introduced new templates and development tools that help streamline
    the game creation process, from early-stage prototyping to final production. These
    tools include predefined templates for both 2D and 3D games, advanced profiling
    tools for performance optimization, and the UI Toolkit for creating user interfaces
    efficiently. Throughout this book, you will learn how to effectively use these
    tools along with Unity’s essential components and workflows to transform your
    game ideas into fully functional, playable experiences. Whether you're developing
    for 2D or 3D, the performance improvements and enhanced productivity features
    in Unity 6 make it the ideal platform for your next project.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter offers a detailed exploration of Unity interfaces, starting with
    installing Unity to set a solid foundation for your game development journey.
    It covers navigating the Unity Hub, mastering the Unity Editor where your game
    ideas will come to life, and utilizing the Unity Asset Store for additional resources.
    This guide aims to provide you with a comprehensive understanding of Unity’s essential
    tools and interfaces, equipping you with the knowledge and confidence to embark
    on your game development projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Unity interface overview
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exploring the Unity Editor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a C# script
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Basic concepts of C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this book, we’ll make use of three main pieces of software: Unity Hub,
    Unity Editor, and an **Integrated Development Environment** (**IDE**). An IDE
    is basically a very smart text editor. When configured for Unity and C#, it will
    check your coding for errors and highlight those for you.'
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Hub is available from Unity’s website. Unity will require that you
    create an account. For most beginners, select the Free plan. The Unity Hub download
    is located at [https://unity.com/download](https://unity.com/download).
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Editor is most conveniently installed through the Unity Hub. That
    process is described in this chapter. Though it is possible to download the Editor
    directly from Unity’s website, it is not recommended. The Editor must be installed
    in a location that the Unity Hub searches.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you need an IDE. A popular choice is Microsoft Visual Studio. When
    you install an Editor through the Unity Hub, Visual Studio is an available option.
    You can download Visual Studio directly from [https://visualstudio.microsoft.com/downloads/](https://visualstudio.microsoft.com/downloads/).
  prefs: []
  type: TYPE_NORMAL
- en: There are other IDEs available for use with Unity. A popular choice is JetBrains’
    Rider. It offers a free trial; after that, Rider is a paid service. It can be
    found at [https://www.jetbrains.com/rider/download/](https://www.jetbrains.com/rider/download/).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find the examples/files related to this chapter here: [https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter01](https://github.com/PacktPublishing/Unity-6-Game-Development-with-C-Scripting/tree/main/Chapter01)'
  prefs: []
  type: TYPE_NORMAL
- en: Unity interface overview
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we delve into the intricacies of the Unity3D interface, an
    essential component for any game developer. We’ll start with an introduction to
    the Unity Hub, your centralized gateway for managing Unity projects and installations.
    From there, we’ll explore the Unity Editor, breaking down its layout and key functionalities.
    You’ll learn how to navigate through different windows and panels, customize the
    workspace to suit your workflow, and utilize essential tools like the Scene and
    Game views.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.1 – Unity Hub – starting point each time you open Unity](img/B22128_01_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.1 – Unity Hub – starting point each time you open Unity
  prefs: []
  type: TYPE_NORMAL
- en: Projects windows show available projects. Selecting a project will open the
    project and its assigned Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: Having explored the Unity software interface, let’s now move on to installing
    Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Installing Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When installing Unity Hub and the Unity Editor, it’s crucial to first check
    the current system requirements on the official Unity website to ensure compatibility
    with your hardware and operating system. Unity regularly updates these requirements
    to match the capabilities of new versions of the software. After confirming that
    your system meets these requirements, proceed to download and install Unity Hub,
    which serves as a management tool for Unity installations and projects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.2 – Unity Hub Terms of Service screen with Agree and Disagree options](img/B22128_01_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.2 – Unity Hub Terms of Service screen with Agree and Disagree options
  prefs: []
  type: TYPE_NORMAL
- en: The initial installation of the Unity Hub will include the Unity Terms of Service.
    To continue, simply select the **Agree** button.
  prefs: []
  type: TYPE_NORMAL
- en: Within Unity Hub, when selecting the Unity Editor version to install, it’s advisable
    to opt for a **Long-Term Support** (**LTS**) version. LTS versions are stable
    releases that receive continuous updates and bug fixes for an extended period,
    making them ideal for production environments where stability is paramount. Choosing
    an LTS version ensures you have a reliable and well-supported foundation for your
    game development projects, allowing you to focus on creativity and innovation
    without worrying about the stability of your development tools.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.3 – Unity Hub screens – installed editors, available editors, and
    installation options](img/B22128_01_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.3 – Unity Hub screens – installed editors, available editors, and installation
    options
  prefs: []
  type: TYPE_NORMAL
- en: The left screen is the Unity Editor **Installs** window where you manage your
    installations of Unity editors. Click the **Install Editor** button in the upper-right
    corner to view the middle screen, the **Install Editor** window. Here, you can
    select additional Unity editors to install. Selecting one of the available options
    brings up the right-hand screen, where you can select additional options for your
    Unity editor.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding LTS and naming conventions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: LTS versions of Unity are stable releases that are supported and maintained
    by Unity Technologies for a longer period, typically two years. They receive regular
    updates to fix bugs and improve performance but don’t include new features.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s move on to the naming conventions. Unity names its editors based
    on the year and version – for example, Unity 2020.1.
  prefs: []
  type: TYPE_NORMAL
- en: 'As of my last update, Unity had two release streams:'
  prefs: []
  type: TYPE_NORMAL
- en: '**TECH stream**: These are the latest versions with new features and improvements.
    They are named based on the year and incremental updates (e.g., Unity 2023.1).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LTS stream**: These versions follow the TECH stream but are focused on stability
    and extended support. They are named similarly but with **LTS** at the end (e.g.,
    Unity 2020.3 LTS).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Starting in 2024, Unity will once again change its naming conventions. Unity
    6 will be introduced. Along with its version name change, Unity’s pricing plan
    will also change. The vast majority of Unity developers will not be affected by
    these charges.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s end this section with some of my own suggestions regarding the installation
    process:'
  prefs: []
  type: TYPE_NORMAL
- en: Always check the Unity website for the latest system requirements and versions,
    as they are subject to change with new updates.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For specific development needs (such as VR or AR), additional setup and components
    may be required (see [*Chapter 14*](B22128_14.xhtml#_idTextAnchor324)).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Ensure that your system’s graphics drivers are up to date for the best performance
    with Unity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Having set up our initial build environment with the Hub, Editor, and IDE, let’s
    explore the Editor some more. Most of our game development time will be spent
    in the Editor. It is best to get familiar with the layout and the processes to
    build a game.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the Unity Editor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we embark on a practical journey through Unity’s core functionalities,
    beginning with the crucial step of starting a new project. This foundational process
    sets the stage for what follows: a comprehensive exploration of the Editor’s screen
    layout. By understanding how to initiate projects and navigate the Editor’s interface,
    we equip ourselves with the essential skills needed to bring our game development
    ideas to life.'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start a new project in Unity Hub, follow along with these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Click **New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.4 – Unity Hub Projects window](img/B22128_01_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.4 – Unity Hub Projects window
  prefs: []
  type: TYPE_NORMAL
- en: Click the **New Project** button in the upper-right corner. This opens the next
    screen where you initially configure the new project.
  prefs: []
  type: TYPE_NORMAL
- en: Then, choose an **Editor Version** number and select a template such as **3D
    Core** for beginners.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 1.5 – Unity Hub New project window](img/B22128_01_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.5 – Unity Hub New project window
  prefs: []
  type: TYPE_NORMAL
- en: The box at the top of the project configuration screen lists the available installed
    editors. Initially, it will only display the editor you installed earlier. The
    middle column displays templates for your project. It’s best to select **3D Core**
    as it is the most basic option.
  prefs: []
  type: TYPE_NORMAL
- en: Name your project, choose its location (ensuring sufficient space), and click
    `Assets` folder for project content and avoiding modifications outside this folder
    for smooth operation.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wait. When first launching a new project, Unity will take longer to load. In
    the background, Unity is installing and configuring various resources for the
    project. Subsequent launches will not take as long.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This new project will appear in the Hub. Return to the Hub and click on the
    project title each time you start a new Editor session.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 1.6 – The main Unity Editor screen is a collection of windows that
    showcase aspects of the project. The editing process will require switching between
    the various windows](img/B22128_01_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 1.6 – The main Unity Editor screen is a collection of windows that showcase
    aspects of the project. The editing process will require switching between the
    various windows
  prefs: []
  type: TYPE_NORMAL
- en: 'Upon launching, the Unity Editor allows customizable layouts with core windows
    such as **Hierarchy**, **Scene** and **Game**, **Inspector**, and **Project**,
    each tailored to streamline the development process. Here’s what they do:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hierarchy**: Organizes scene objects in a parent-child structure, facilitating
    scene management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scene** and **Game**: **Scene** provides a workspace for object manipulation,
    while **Game** offers a real-time gameplay preview.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Inspector**: Displays properties of selected objects, enabling customization
    and component management.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project**: Manages all game assets, supporting organization and asset editing.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These windows are integral to Unity’s workflow, offering tools and functionalities
    essential for game development.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Editor – a closer look
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After setting up a new project, the Unity Editor reveals itself as a multifaceted
    workspace designed to cater to the diverse needs of game development. This section
    delves into the intricate details of the Editor, offering a more granular view
    of its capabilities and how they coalesce to form a cohesive development environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Below is an overview of the key components of the Unity Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Main Toolbar**: At the very top, the main toolbar extends a quick access
    strip to essential features such as playtesting, time management, and scene controls.
    This toolbar is pivotal for testing game scenes directly within the Editor, allowing
    developers to iterate rapidly by switching between play and edit modes seamlessly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Layout Customization**: Unity’s flexible workspace accommodates diverse workflows
    through customizable layouts. You can drag and rearrange windows to suit your
    working style, and even save specific layouts for different tasks such as coding,
    animating, or UI design. This adaptability is key for maintaining efficiency across
    the multifaceted development process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asset Importing and Management**: Beyond project creation, the Unity Editor
    excels in asset management. The **Assets** menu and **Project** window work in
    tandem, allowing developers to import, organize, and manipulate game assets such
    as textures, models, and sounds with ease. Understanding the import settings and
    how Unity handles different asset types is crucial for optimizing game performance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Console Window**: Debugging is an integral part of development, and the **Console**
    window is where Unity communicates with developers. It displays errors, warnings,
    and other crucial messages from the Editor and your scripts. Learning how to interpret
    these messages can significantly expedite the debugging process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Animation and Animator Windows**: Unity offers robust tools for animating
    characters and objects within the Editor. The **Animation** window allows for
    the creation and editing of animation clips, while the **Animator** window manages
    state machines for complex animations. Grasping these tools can elevate the dynamic
    elements of your game, adding a layer of polish and interactivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lighting and Rendering**: Unity’s powerful lighting and rendering options
    are accessible through the **Lighting** window and the **Renderer** component
    in the Inspector. Understanding these features is essential for setting the right
    mood and visual fidelity in your game, from adjusting global illumination to fine-tuning
    individual object materials.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Scripting with MonoDevelop or Visual Studio**: While the Unity Editor lays
    the groundwork, scripting breathes life into your game. Unity integrates seamlessly
    with code editors such as MonoDevelop and Visual Studio, providing a rich environment
    for writing and debugging C# scripts. Familiarity with these tools and Unity’s
    scripting API opens up limitless possibilities for game mechanics and interactivity.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Asset Store Integration**: Lastly, Unity’s Asset Store is directly integrated
    into the Editor, offering a vast repository of assets and tools that can accelerate
    development. From ready-made models and textures to entire game systems, leveraging
    the Asset Store can be a game-changer, especially for teams with limited resources.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: So, the Unity Editor is more than just a starting point for projects; it’s a
    comprehensive suite of tools designed to accommodate every facet of game development.
    By understanding and utilizing these components effectively, developers can streamline
    their workflow, enhance productivity, and ultimately, bring their creative visions
    to life with greater fidelity and efficiency.
  prefs: []
  type: TYPE_NORMAL
- en: Now, with a basic overview of the workspace inside the Unity Editor, let’s explore
    the process used for C# scripts. The vast majority of game programming is either
    inside the editor or editing scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a C# script
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating your first C# script is a crucial step in your Unity journey, introducing
    you to the essential scripting that animates your game’s elements. This isn’t
    just a one-off task; it’s a core skill you’ll use regularly to craft behaviors
    and interactions in your game. Mastering this early on opens the door to transforming
    your creative visions into dynamic, interactive realities.
  prefs: []
  type: TYPE_NORMAL
- en: To create a folder and a C# script in Unity, follow these steps in the `Assets`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, create a `Scripts` folder by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and choose `Scripts` for script file organization.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Then, to create a C# script, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Scripts` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click and select `NewBehaviourScript` to your desired name, such as `MyFirstScript`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Unity provides alternative ways to add scripts to a project. These include dragging
    script files into the **Project** window, adding scripts in your IDE, and others.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here are some additional tips:'
  prefs: []
  type: TYPE_NORMAL
- en: Unity automatically compiles scripts when they are created or modified, so you
    can immediately use them in your project.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It’s a good practice to keep your project organized by using folders such as
    `Scripts`, `Materials`, `Prefabs`, and so on, to ensure easy navigation and management
    as your project grows.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, to edit your script using an IDE (such as Visual Studio or JetBrains Rider),
    follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Double-click the `MyFirstScript.cs` file in the `Scripts` folder to open it
    in your IDE.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the script, add the following line inside the `Start` method to print a
    message to the console:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save the script and return to Unity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Attach the script to a GameObject in your scene by dragging the script onto
    the GameObject in the Hierarchy.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the **Play** button in Unity. You should see the message **“Hello, Unity!”**
    appear in the **Console** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This simple exercise helps you get familiar with the interaction between Unity
    and your IDE and provides immediate feedback in the **Console** window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In conclusion, familiarizing yourself with the Unity interface and your chosen
    IDE is a crucial step in game development. Understanding the layout and functionality
    of various windows such as **Hierarchy**, **Scene**, **Game**, **Inspector**,
    and **Project**, and mastering the art of asset management sets a solid foundation
    for your projects. As you transition from the intuitive Unity interface to the
    realm of programming, you’ll encounter the fundamental language of Unity game
    development: C#. Grasping the basic concepts of C# is essential for bringing your
    game ideas to life. This powerful, versatile language allows you to script the
    behavior of your game objects, control the game flow, and interact with the Unity
    Engine in a more profound way. As we delve into C#, remember that it’s the synergy
    between the Unity interface and C# scripting that transforms your creative vision
    into an engaging, interactive gaming experience.'
  prefs: []
  type: TYPE_NORMAL
- en: Basic concepts of C#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Welcome to our in-depth exploration of programming fundamentals within Unity3D,
    focusing on leveraging C# for game development. This section introduces the core
    concepts and structures of C#, starting with data types and variables.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress, we’ll dive into control structures, functions, and methods,
    uncovering how to control the flow of your game, execute code blocks, and encapsulate
    functionality for reuse and clarity. Understanding these elements is crucial for
    scripting game logic.
  prefs: []
  type: TYPE_NORMAL
- en: This section aims to briefly explore C#, familiarizing you with basic programming
    elements. Whether you’re a beginner or looking to enhance your C# prowess in Unity3D,
    this journey will equip you with the skills necessary for advanced game development.
    Let’s embark on this transformative path, where your creative ideas become tangible
    realities in the world of gaming.
  prefs: []
  type: TYPE_NORMAL
- en: Utilizing C# data types for creative game development
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In C#, data types such as variables store information that is used in games.
    For example, we could use an integer, a variable that only contains whole numbers,
    to record how many lives a player has remaining.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding variables
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In C#, variables are essential elements that act as storage locations in the
    computer’s memory, holding data that can be modified during program execution.
    They are fundamental in defining the behavior and state of a program, playing
    a crucial role in C# programming, especially in Unity for game development. Variables
    are characterized by their type, which determines the kind of data they can hold
    and the operations that can be performed on them.
  prefs: []
  type: TYPE_NORMAL
- en: The most common variable types in C# include `int` for integers, `float` for
    floating-point numbers, `double` for double-precision floating-point numbers,
    `bool` for Boolean values, `char` for characters, and `string` for sequences of
    characters. Additionally, C# supports more complex types such as arrays and objects,
    enabling developers to handle more sophisticated data structures. Each of these
    variable types serves a distinct purpose, such as controlling loop iterations
    with integers, managing spatial coordinates with floats, or handling textual data
    with strings, thus providing a versatile toolkit for a wide array of programming
    tasks in game development.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a generic sample C# script that uses the variable types just
    described. You can see the structure for initializing or declaring a variable.
    It starts with the variable type, such as `int`. That is followed by the variable’s
    name, such as `playerScore`. Then, an equal sign (`=`) is used to assign the value
    to the variable. Further in the script, the value of each variable is added to
    the game project log, which is viewable in the Editor’s **Console** window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The provided script demonstrates a basic C# script in Unity, starting with `using
    UnityEngine;` to import essential Unity Engine utilities. It introduces a public
    class named `VariablesExample`, adhering to Unity’s convention where the class
    and filename should match, and inherits from `MonoBehaviour`, a key Unity class
    enabling Unity-specific functions such as `Start()`, which runs on initialization.
    Variables are declared with their type, such as `int` for integers, followed by
    a camel case named `identifier` and an optional initial value, with strings enclosed
    in quotes. This setup lays the groundwork for utilizing Unity’s features and writing
    game logic.
  prefs: []
  type: TYPE_NORMAL
- en: The preceding script also demonstrates the concept of global and local variables.
    Both `_playerScore` and `_playerSpeed` are instance variables, declared outside
    of any method or function, within the class but typically referred to as fields
    in C#. The use of `private` means other scripts cannot access these variables
    directly. To share a variable, you would use `public`, though this is not recommended
    in most cases due to encapsulation principles. Within a method or function, you
    do not need to redeclare the variable type; it was already specified when the
    variable was initially declared. It is a common practice to start a private field’s
    name with an underscore character.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring control structures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Control structures are pivotal elements in C# programming, guiding the execution
    flow within scripts. Among these, `If-Then` statements are particularly common.
    They evaluate a variable’s value; if `true`, a specific code block runs, otherwise,
    it’s bypassed. This enables scripts to react dynamically to different conditions
    and states within the game.
  prefs: []
  type: TYPE_NORMAL
- en: Loops form another critical category of control structures, repeatedly executing
    a code block based on a condition. Unlike If-Then statements, which perform a
    one-time check, loops continue until a certain condition is met. The `For-Next`
    loop is ideal for scenarios with a predetermined iteration count, ensuring a code
    segment runs a specific number of times. On the other hand, the `While` loop is
    suited for less definite situations, such as continuously checking a condition
    such as a player’s status (e.g., “while the player is falling”), and executing
    the loop’s body until the condition changes. Another example is using a `While`
    loop to keep spawning enemies until the player reaches a certain score threshold.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding and effectively utilizing these control structures is essential
    for creating responsive and efficient game logic in Unity using C#.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring functions and methods
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Unity, when you’re making games with C#, you’ll hear a lot about **functions**
    and **methods**. Think of them as special boxes of instructions that do specific
    jobs. In C#, we usually call these boxes *methods*, but it’s just like functions
    in other coding languages.
  prefs: []
  type: TYPE_NORMAL
- en: You can use these methods whenever you want to make something happen in your
    game. They help with all sorts of things, such as making your characters move,
    responding when players press buttons, or keeping track of scores.
  prefs: []
  type: TYPE_NORMAL
- en: It’s like having a bunch of helpful tools in your toolbox. Whenever you need
    a particular job done, you pick the right tool (or method) for that job. This
    makes your game’s code neat, easier to handle, and even lets you use the same
    tool for different parts of your game.
  prefs: []
  type: TYPE_NORMAL
- en: Structure and syntax of functions/ methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: In C#, a method typically consists of a visibility keyword, a return type, a
    method name, and a set of parentheses, which may contain parameters. The body
    of the method, enclosed in curly braces, contains the code to be executed. For
    instance, `public void MovePlayer(float speed){}` is a method in Unity that could
    move a player at a specified speed. The `public` keyword makes it accessible from
    other classes, `void` implies that it doesn’t return any value, and `float speed`
    is a parameter that can be passed to the method. Another example is `private int
    CalculateScore(int points) { return points * 10; }`, which is a `private` method
    that calculates and returns a player’s score based on the points earned.
  prefs: []
  type: TYPE_NORMAL
- en: Common Unity methods
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Unity provides several built-in methods that are essential in the game development
    life cycle. Methods such as `Start()` and `Update()` are the most frequently used.
    `Start()` is called before the first frame update, perfect for initializing variables
    or game states. `Update()`, on the other hand, is called once per frame and is
    where you’ll primarily manage player inputs, update game logic, and handle real-time
    interactions.
  prefs: []
  type: TYPE_NORMAL
- en: Custom methods for game mechanics
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: Beyond the standard methods, developers can create custom methods to define
    specific behaviors or actions. For instance, a method named `CalculateScore()`
    could be created to update the player’s score. Custom methods enhance the modularity
    and reusability of your code, making your game more organized and easier to debug
    and maintain.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters and return types
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Methods in C# can also have parameters and return types. Parameters allow you
    to pass values into a method, making them more dynamic and flexible. For example,
    a `DealDamage(int damage)` method can take an integer parameter to apply damage
    to a character. Return types, on the other hand, enable methods to send back a
    value. A `GetHealth()` method might return an integer value representing a character’s
    health.
  prefs: []
  type: TYPE_NORMAL
- en: Learning about classes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the context of Unity game development, C# classes play a crucial role. They
    act as blueprints for every entity in the game world, from the simplest UI element
    to the most complex characters and environments. Understanding classes in C# is
    vital for Unity developers, as they provide the structure and functionality to
    game objects, making them integral to creating immersive and interactive game
    experiences.
  prefs: []
  type: TYPE_NORMAL
- en: Classes as blueprints for game objects
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Unity, a class defines the properties and behaviors of game objects. Think
    of a class as a template that describes the characteristics and capabilities of
    something in the game. For instance, a `Player` class might include properties
    such as `health`, `speed`, and `strength`, and behaviors such as `move`, `jump`,
    and `attack`. When you create an instance of the `Player` class, you’re essentially
    creating a specific player character in your game with those properties and behaviors.
  prefs: []
  type: TYPE_NORMAL
- en: Properties and behaviors defined by classes
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The properties of a class are variables that hold data relevant to the object,
    such as scores, health points, or positional coordinates. These properties can
    be simple data types such as integers and strings, or more complex types such
    as arrays or other classes. Behaviors, on the other hand, are defined by methods
    within the class. These methods contain the logic that dictates how an object
    acts or responds to game events. For example, a method within the `Enemy` class
    could dictate how the enemy detects and chases the player.
  prefs: []
  type: TYPE_NORMAL
- en: Mastering classes for complex game development
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Mastering the use of classes is pivotal for developers aiming to create complex
    and interactive games. Classes allow for the encapsulation of data and functionality,
    leading to code that is more organized, modular, and reusable. This is particularly
    important in game development, where different types of objects often share properties
    and behaviors. By using classes effectively, you can create a hierarchy of game
    objects, inherit properties and behaviors, and override them to create specialized
    behaviors. This not only streamlines the development process but also makes the
    code base more manageable and scalable.
  prefs: []
  type: TYPE_NORMAL
- en: In Unity, `MonoBehaviour` is a base class from which most game scripts are derived.
    It provides access to important life cycle methods such as `Start` and `Update`,
    which are essential for game logic. Understanding how to extend `MonoBehaviour`
    and utilize its features is a key part of working effectively with Unity.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we delved into the essentials of C# programming within Unity3D,
    starting with an introduction to key concepts such as data types and variables,
    crucial for managing game data. We progressed to control structures and methods,
    foundational for scripting game logic, and explored object-oriented principles
    through classes and objects, enhancing game component design. Additionally, we
    touched on Unity-specific scripting with MonoBehaviour and ScriptableObjects,
    concluding with an overview of extending the Unity Editor through scripting, equipping
    you with a solid foundation in C# for game development.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter served as an introduction to Unity and C# for game development,
    emphasizing the learning process. It guided beginners through setting up Unity,
    including installing Unity Hub and the Unity Editor, and choosing the right version
    and IDE for their projects. The chapter provided a walk-through of the Unity Editor,
    explaining key components such as the **Hierarchy**, **Scene**, **Inspector**,
    and **Project** windows, essential for organizing and managing game development
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a C# script was highlighted as a fundamental skill, with step-by-step
    instructions on how to set up a `Scripts` folder and write your first script.
    This laid the groundwork for more advanced topics in game programming.
  prefs: []
  type: TYPE_NORMAL
- en: The chapter then introduced basic C# concepts crucial for game development,
    such as data types, variables, control structures, functions, and methods. These
    concepts form the foundation of scripting in Unity, enabling you to start bringing
    your game ideas to life. Through practical tips and clear explanations, the chapter
    prepared you for the journey ahead in game development with Unity and C#.
  prefs: []
  type: TYPE_NORMAL
- en: Building on the basics, the next chapter shifts focus to hands-on creation,
    guiding you through starting a new Unity project, navigating the Editor, managing
    assets, and manipulating game objects. We’ll cap it off by setting up your first
    scene, transitioning smoothly from foundational theory to the practical steps
    of bringing your game ideas to life.
  prefs: []
  type: TYPE_NORMAL
