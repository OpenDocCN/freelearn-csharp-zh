- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Building a Simple Demo Application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will build a very simple demo application that will form
    the basis and framework of the SaaS application that we will build out in subsequent
    chapters. The purpose of this chapter is to get familiar with all of the tools
    and techniques that we will leverage later in this book, and in our careers as
    builders of SaaS applications! Once we have this foundational knowledge and framework
    app, it will be much easier to start to build more complex functionality.
  prefs: []
  type: TYPE_NORMAL
- en: Before we start building the framework application, we must first discover and
    install the tools that we will use. Then, we’ll build out the skeleton application.
    Once we have that working, then we will start to think about what would be required
    to flesh this out into a real-world SaaS application!
  prefs: []
  type: TYPE_NORMAL
- en: This chapter will give you a very brief look at a lot of different technologies.
    Please don’t feel overwhelmed! We are going to configure a dev environment from
    scratch, using Docker, and then we are going to initialize a database, API, and
    UI.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter uses a lot of different technologies, some of which you may not
    be familiar with. Don’t worry! Everything in this chapter is written out in detail,
    and anything that is skipped over quickly in this chapter will be explained fully
    in subsequent chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Developing SaaS applications, almost by definition, requires a wide array of
    different technologies. We will take a quick look at them all in this chapter,
    and then deepen our knowledge and understanding in subsequent chapters!
  prefs: []
  type: TYPE_NORMAL
- en: 'This chapter covers the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Getting set up – installing the tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Building a simple example application
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Where do we go from here?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you’ll have built, installed, and configured your
    development environment, and you’ll have initialized all of the components required
    to build out a SaaS app. Hopefully, you will finish this chapter inspired to understand
    how we will make the most out of these tools and techniques!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All code from this chapter can be found at [https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-2](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-2).
  prefs: []
  type: TYPE_NORMAL
- en: Setting up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll cover the tools that I recommend using to work through
    the examples in this book. Please note that there are not really any specific
    tools for building a SaaS application – the typical set of developer tools that
    you are probably accustomed to will do the job. However, I will refer to a specific
    set of tools in this book, and so I’ll describe them in this section, explain
    my selection, and cover how to install and configure the tools.
  prefs: []
  type: TYPE_NORMAL
- en: I am sure that any of the popular tools out there would be perfectly sufficient,
    so don’t feel like you *must* go with my selection, and feel free to use whatever
    you are most comfortable with! You should be able to adapt the examples to work
    with your tooling of choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are only two tools that need to be installed on your machine to follow
    along with the code that will be supplied in this book:'
  prefs: []
  type: TYPE_NORMAL
- en: Docker Desktop
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These tools are fairly stable, and it is likely the best choice to use the latest
    version. For reference, I am using Docker v20.10.17 and VS Code v1.71.2.
  prefs: []
  type: TYPE_NORMAL
- en: These tools are chosen deliberately as they are available for all operating
    systems, they are free to use, and they will give us a consistent base on which
    to work through the code examples. These are the two tools that I find most useful
    in my day-to-day work as a software developer! They are typically the first two
    applications that I install when building a new developer machine.
  prefs: []
  type: TYPE_NORMAL
- en: I’m going to use a neat trick with Docker to containerize the entire developer
    setup, which is why these two tools are the only ones that you need to install
    on your machine, and it is also the reason that I am confident that the example
    provided will work on any operating system.
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio Code has gone from being a *lite* version of the full Visual Studio
    application to being an absolute workhorse for all manner of development work.
    With the availability of a massive range of extensions, it can be configured for
    just about any coding task, and then further modified to suit individual preferences.
  prefs: []
  type: TYPE_NORMAL
- en: VSCode has become my IDE of choice for many different projects, but the real
    strength of a SaaS project is that it can be configured to support all of the
    different layers that will be built. You can add extensions for database development,
    API development, and UI development and build a highly customized developer environment
    that is specifically tailored to your project and your preferred tooling.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by installing Visual Studio Code. This is done simply by clicking this
    URL and following the instructions for your operating system of choice: [https://code.visualstudio.com/download](https://code.visualstudio.com/download)'
  prefs: []
  type: TYPE_NORMAL
- en: When VSCode is installed, you will also need to install a couple of extensions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need three extensions for VS Code:'
  prefs: []
  type: TYPE_NORMAL
- en: Remote containers
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remote WSL
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The tags for the required extensions are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'When VSCode is correctly configured, the **EXTENSIONS** pane should look like
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Visual Studio Code with extensions configured](img/B19343_Figure_2.1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 – Visual Studio Code with extensions configured
  prefs: []
  type: TYPE_NORMAL
- en: We will use a number of other extensions specific to the project, but these
    will be installed in a dev container for ease of use – more on this later!
  prefs: []
  type: TYPE_NORMAL
- en: Docker
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Docker is a relatively recent addition to the developer toolbox, but it has
    quickly become completely invaluable for building and deploying applications.
    In more recent years, Docker has also become an incredible tool to encapsulate
    all of the setup required on a developer machine.
  prefs: []
  type: TYPE_NORMAL
- en: Docker is a containerization tool. The principle at play is derived from shipping
    containers. Shipping containers are a standard size, which means that the machinery
    to move them and load them at the port and onto ships is completely standardized
    around the globe. Of course, what goes into the shipping containers can be anything
    from cars to cucumbers, but the infrastructure to move the containers is identical
    regardless.
  prefs: []
  type: TYPE_NORMAL
- en: This principle is applied to software packaged with Docker. Whatever software
    tool is to be run is put inside a Docker container – analogous to a shipping container
    – and the Docker infrastructure is then used to run the container.
  prefs: []
  type: TYPE_NORMAL
- en: You can consider a container to be a tiny virtual machine, or maybe an executable
    of its own. The important thing to keep in mind is that any piece of code, application,
    service, and so on that has been placed inside a Docker container will run on
    any computer with Docker installed. Furthermore, it will run (or not run!) in
    an identical way regardless of whether or not the host operating system is Windows,
    Mac, or Linux.
  prefs: []
  type: TYPE_NORMAL
- en: This concept of containers is fantastic for shipping running software. I can
    now pull a Docker image for just about any software utility I can think of, and
    no matter what platform I am working with, I can execute that software.
  prefs: []
  type: TYPE_NORMAL
- en: From a software provider’s point of view, the huge benefit is that they can
    be certain that their code will run correctly on my machine because it’s running
    against a standard platform – Docker!
  prefs: []
  type: TYPE_NORMAL
- en: You may be wondering why this is important when it comes to setting up a developer
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: Dev containers are a relatively new but extremely powerful concept that can
    take all of the power that Docker has when running applications and apply that
    to developing applications. It is now possible to configure an entire dev environment
    – with all of the associated dependencies – and put all of that in a container!
  prefs: []
  type: TYPE_NORMAL
- en: This may not be of the utmost importance for a more basic project, but a SaaS
    application is rarely a basic project.
  prefs: []
  type: TYPE_NORMAL
- en: 'The nature of a SaaS application typically requires that many project-specific
    tools are installed on each developer machine. Worse, it is very common that specific
    versions of the tools will be required, which can often make the initial setup
    for new team members particularly painful. These tools can include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A database platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A framework, such as .NET – very often with specific version requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Package management, such as NPM or NuGet
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A web server of some kind for the frontend
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A huge number of CLI tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: And many other dev tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your dev team supports multiple projects – as is often the case – this can
    become a real pain point.
  prefs: []
  type: TYPE_NORMAL
- en: I try to use dev containers as much as I possibly can to wrap up dependencies,
    and I will use this technique in the examples in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Please note that Docker is an enormous topic in itself, and it is out of the
    scope of this book to cover it in any sort of depth. I will cover just enough
    to get familiar with the techniques that I am using, and leave it up to the reader
    to do more of a deep dive into all things Docker!
  prefs: []
  type: TYPE_NORMAL
- en: Dev containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As developers, we all have our favorite set of tools that we work with on a
    day-to-day basis. This will start with our choice of operating system, and from
    there we will pick IDEs, database platforms, frontend frameworks, and all of the
    associated tooling.
  prefs: []
  type: TYPE_NORMAL
- en: This huge variety of systems, tools, platforms, and frameworks provides a challenge
    for the author of a book describing how to build a SaaS platform…
  prefs: []
  type: TYPE_NORMAL
- en: In order for the tutorials in this book to appeal to the broadest range of developers
    possible, I am going to make use of a relatively new concept known as **Dev Containers**.
    This allows us to configure a Docker container to do all of our development. This
    will give you a consistent platform with which to work and will ensure that all
    of the examples that are provided will work on literally any machine.
  prefs: []
  type: TYPE_NORMAL
- en: Making use of dev containers gives us a completely consistent development platform
    to work with so that we can be sure that all readers of this book will be able
    to run the example code that is provided, but there is a small configuration overhead
    to get started.
  prefs: []
  type: TYPE_NORMAL
- en: What is a dev container?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Continuing with the analogy of a shipping container, a dev container is simply
    a wrapper around the myriad of developer tools that you will use when working
    on the code in this book.
  prefs: []
  type: TYPE_NORMAL
- en: 'Broadly speaking, the tools and services that will be required are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A database platform
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The .NET SDK
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions to support database development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions to support API development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Extensions to support frontend and Blazor development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All of the above will be packaged up in a dev container.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring the Docker containers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The code for this first example is available at [https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-2](https://github.com/PacktPublishing/Building-Modern-SaaS-Applications-with-C-and-.NET/tree/main/Chapter-2).
    Either clone the repo or follow through with this example setup.
  prefs: []
  type: TYPE_NORMAL
- en: If you are following along, then start by creating a new folder that will form
    the root of your project, and then open that folder in VSCode. This is a completely
    blank canvas, but by the end of this chapter, we will have the skeleton framework
    for a functioning SaaS application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating the following folder and file structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Expected folder structure](img/B19343_Figure_2.2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.2 – Expected folder structure
  prefs: []
  type: TYPE_NORMAL
- en: With the folder structure created, we can now start to fill out these files.
    We’ll start with the Dockerfile in the `dev-env` folder. This will be used to
    configure the developer environment and will contain the instructions to install
    the tools that will be used to build the application.
  prefs: []
  type: TYPE_NORMAL
- en: Dockerfile
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Open the file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'And paste in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'This configures the developer environment to facilitate .NET application development.
    Let’s go through this in detail. The first line determines the version of .NET
    that will be used:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We are using 7.0, which is the latest version at the time of writing.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the version of Node is configured:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: No node version is installed. It is often useful to enable node or npm, but
    they are not needed at present.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next command is used to install any packages or tools that you may want
    to use:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This command updates the package manager and installs the Vim CLI tool, which
    we will use later.
  prefs: []
  type: TYPE_NORMAL
- en: 'The above has all been a “standard” configuration of the environment. Next,
    we will add some bespoke customizations that will allow us to make use of Entity
    Framework:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: This command installs the .NET **Entity Framework** (**EF**) tools that we will
    use to interact with the database.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we will add the dot net tools to the `path` variable so that we are
    able to make use of them from the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Sqlserver.env
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This file simply sets some environment variables for the SQL Server instance
    that we will spin up shortly. Copy in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: It should go without saying that passwords should never be used in any environment
    other than this example! Also, note that checking in passwords is extremely bad
    practice, and should not be done when working on a production application. We
    will remedy this when we talk about security in [*Chapter 8*](B19343_08.xhtml#_idTextAnchor200)*.*
  prefs: []
  type: TYPE_NORMAL
- en: Docker-compose.yaml
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This is where things get interesting. Docker Compose is a tool that lets us
    use multiple containers at the same time. It is a container orchestration tool!
  prefs: []
  type: TYPE_NORMAL
- en: 'Paste the following into the `docker-compose` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The preceding commands for Docker Compose tie everything that we have done together.
    With this script, we can start up a set of Docker containers that allow us to
    build the API, and the UI, and also interact with a database – all without having
    to install anything directly on the host machine!
  prefs: []
  type: TYPE_NORMAL
- en: 'To recap: we have constructed a container called `dev-env` that is specific
    to our requirements. We have also provisioned a container with an instance of
    SQL Server 2022 running in it that will serve as our database platform.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the containers
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: That is all of the Docker-specific configurations. Now we will run the containers
    and start to interact.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have built a Docker-based environment – now it’s time to start it up. To
    do this, open VSCode, open a new terminal, and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Your terminal should look like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Expected output](img/B19343_Figure_2.3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.3 – Expected output
  prefs: []
  type: TYPE_NORMAL
- en: This can take a while the first time you run this command, but it is significantly
    faster in subsequent uses. This command will start up the services that are described
    in the `docker compose` file. Namely, a SQL Server instance, and the developer
    environment that we configured with .NET 6.0 and Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the above, we have created a container with .NET and Entity Framework
    installed. You can convince yourself that we have actually achieved that by trying
    the following. Open a new terminal in VSCode and enter the following to `exec`
    into the dev-env container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The `exec` command allows interactions with an already running container through
    the terminal.
  prefs: []
  type: TYPE_NORMAL
- en: 'Running the preceding command will open an interactive terminal in the `dev-env`
    Docker container where we can check to see whether the .NET and EF tools are correctly
    installed by typing the following into the console that was opened by the preceding
    `exec` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding commands should return the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – Expected terminal output](img/B19343_Figure_2.4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.4 – Expected terminal output
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we can do something similar to ensure the SQL Server container is running.
    Again, open a new terminal in VSCode and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, this will open another interactive terminal in the `sqlserver` container.
    You can convince yourself of this by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'And when prompted, enter the password from the `sqlserver.env` file (`Password1`)
    to enter the SQL Server command-line interface. You can do simple checks on the
    database platform, such as checking the version:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Checking the version](img/B19343_Figure_2.5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.5 – Checking the version
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we have done all of the Docker container setups, but the only
    way that we can interact with our environments is to use the command line, and
    these days, that is not really acceptable! Thankfully, Visual Studio Code has
    a neat trick up its sleeve!
  prefs: []
  type: TYPE_NORMAL
- en: Configuring dev containers in VSCode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You will remember that we installed the `Remote Containers` extension for VSCode.
    This will allow us to open an instance of VSCode that makes use of the Docker
    containers that we have set up previously. This will require a little bit of additional
    configuration, but once set up, it will “just work” for the remainder of the project!
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by creating a folder called `dev-env` in the project root:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This is where VSCode will look to get the configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this folder, create a file called `devcontainer.json`. Your folder structure
    should look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Folder structure](img/B19343_Figure_2.6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.6 – Folder structure
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `devcontiner.json` file, paste the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s go through this line by line. The following line of code tells VSCode
    where to look for the `docker compose` file. This is the file that we created
    previously, which configures the two Docker containers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The following line simply tells VSCode that the container named `dev-env` is
    the primary container:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The next line defines a working folder inside the container – more on this
    shortly:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following is quite clever including the dev container configuration. This
    section allows us to define which extensions we want to have available to us when
    we start to work in the dev container. I have listed three extensions to get us
    started, but this list will grow as the project gains complexity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: This is a particularly clever addition from Microsoft because this allows the
    VSCode configuration to exist as JSON within the project. This file is checked
    into the repo and moved with the code, meaning that any time a new team member
    pulls this repo, they will immediately have a fully configured editor that is
    specific to the project.
  prefs: []
  type: TYPE_NORMAL
- en: We have all become familiar with *infrastructure as code* in recent years. Using
    a dev container allows you to configure the *developer environment as code*. Doing
    this makes it incredibly easy to onboard new team members, and also means the
    end of *well, it works on my machine*. Using this technique means that everyone
    is working on a completely consistent platform, regardless of the physical hardware,
    the operating system choice, or the specific version of .NET or Node.
  prefs: []
  type: TYPE_NORMAL
- en: This is a huge win for developing SaaS applications, given the complex and often
    arduous route to getting a new team member up and running.
  prefs: []
  type: TYPE_NORMAL
- en: Starting the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: That is the end of the configuration. I hope that we are all now working on
    a consistent and predictable platform, and will have no trouble following along
    with the examples in this book!
  prefs: []
  type: TYPE_NORMAL
- en: 'To start the environment in Docker, hit *F1* to open the command menu, and
    search for `Remote-Containers: Rebuild and Reopen` `in Container`.'
  prefs: []
  type: TYPE_NORMAL
- en: You will see the options in *Figure 2**.7* appear. Select the first one and
    hit *Enter* to continue.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Rebuild and Reopen in Container](img/B19343_Figure_2.7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – Rebuild and Reopen in Container
  prefs: []
  type: TYPE_NORMAL
- en: This will close the current instance of VSCode, and reopen a new instance that
    is operating out of the `dev-env` container that was configured previously. Note
    that this can take some time the first time you do it, but it is faster in subsequent
    uses.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice a few differences! First of all, look in the bottom-left corner,
    and you will see that you are running in a dev container called `SaaS Book`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B19343_Icon.jpg)'
  prefs: []
  type: TYPE_IMG
- en: If you click to view the installed extensions, you will see a separate pane
    that shows the extensions that are installed in this instance of VSCode match
    the extensions specified in the `devcontainers.json` file. This list will start
    to grow significantly as the project takes shape throughout the course of this
    book.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 2**.8* shows some of the extensions that are installed in the container:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Installed extensions](img/B19343_Figure_2.8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.8 – Installed extensions
  prefs: []
  type: TYPE_NORMAL
- en: 'If you open a terminal, you will also notice that this is a Linux environment.
    You can convince yourself of that by checking the version by running the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'You’ll see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – Output](img/B19343_Figure_2.9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.9 – Output
  prefs: []
  type: TYPE_NORMAL
- en: This shows that we are in a Debian environment. Notice also that we are working
    in a folder called `workspace`, which is what was configured in the `devcontainer.json`
    file previously. This is configurable as per your preferences.
  prefs: []
  type: TYPE_NORMAL
- en: 'To further convince ourselves that this is indeed the `dev-env` container that
    we configured earlier, you can check the .NET, and the Entity Framework versions
    again in the terminal in VSCode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Terminal output](img/B19343_Figure_2.10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.10 – Terminal output
  prefs: []
  type: TYPE_NORMAL
- en: 'That is the environment configured to the extent that is currently required.
    Let’s recap:'
  prefs: []
  type: TYPE_NORMAL
- en: We have a container that has the .NET SDK installed, ready to use to build any
    kind of .NET applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The same container has Entity Framework command-line tools installed so that
    we can use Entity Framework to build and interact with a database. You will recall
    that we have installed Entity Framework in the Dockerfile.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have a separate container running SQL Server, which hosts the database that
    we can interact with. It is worth noting that we have not installed SQL Server
    itself on the host machine. We have access to the database via a Docker container.
    You will see more of this in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082) and
    [*Chapter 4*](B19343_04.xhtml#_idTextAnchor102).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This is now the basis of a developer machine that can be used to build SaaS
    applications, and we have achieved this without ever having to install any of
    these tools directly on the machine that you are working on – everything is packaged
    up in Docker containers. This configuration exists as code, and as such it moves
    with the repo. Any developer who clones this repository locally will immediately
    have access to all of the project-specific tools and configurations.
  prefs: []
  type: TYPE_NORMAL
- en: As we progress through this project, this setup will become more complex. It
    will grow as the project grows. But this is sufficient for now, so we will leave
    it here and start to piece together a very basic application.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring VSCode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'At this early stage, there is not much config required, as we do not really
    have any application-specific code. However, we’ll lay the groundwork here. Open
    a terminal, and enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the following into `settings.json`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: The preceding is some config for an HTTP testing tool that we will make use
    of in [*Chapter 5*](B19343_05.xhtml#_idTextAnchor116). We don’t need to put anything
    into `launch.json` or `tasks.json` yet.
  prefs: []
  type: TYPE_NORMAL
- en: That should be all the configuration that is required for the time being, so
    we can move on.
  prefs: []
  type: TYPE_NORMAL
- en: Exiting the environment
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Getting out of the dev container environment and back to your host is straightforward.
    Simply hit *F1* again and search for `Reopen` `Folder Locally`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Return to the local workspace](img/B19343_Figure_2.11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.11 – Return to the local workspace
  prefs: []
  type: TYPE_NORMAL
- en: This will quickly return you to the host. You will no longer see the indicator
    in the lower-left corner that you are in a dev container, and the terminal will
    again connect directly to the host machine.
  prefs: []
  type: TYPE_NORMAL
- en: We have achieved a lot in this section, and we have set ourselves up to start
    working in a Dockerized environment. This may seem like a bit more work than simply
    starting to write code on your local machine, but I hope that as we proceed through
    this book together, you will start to see the value in taking the time to build
    out this environment right at the start of the project!
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll really start to build out the application and start
    to show the power of the preceding techniques.
  prefs: []
  type: TYPE_NORMAL
- en: Building out a sample application
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll use the tools that we have just installed to create a
    very basic wireframe for a SaaS application. At this point, this will simply be
    a skeleton application that we can build out much more fully in subsequent chapters.
    However, this will introduce us to all of the different tools that we will be
    using.
  prefs: []
  type: TYPE_NORMAL
- en: The sample application that we will build as we work through this book will
    be an application to track a habit – something that you may like to try to do
    every day – such as learning a new language, or writing a few pages of a book
    in order to stay up to date with your publishing deadlines! I hope that this is
    something that you may be able to make use of after you have finished working
    through this book!
  prefs: []
  type: TYPE_NORMAL
- en: Database technologies
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We will start with the database. We are using SQL Server as the database platform
    – this is a book based on Microsoft technologies, so we will stick with them as
    much as possible! However, other database platforms are available, and can easily
    be used. The Docker-based setup provided above makes it very easy to experiment
    with other database platforms. You can replace the SQL Server container with a
    Postgres container and see if everything still works!
  prefs: []
  type: TYPE_NORMAL
- en: The database and the database platform are often a source of some pain when
    getting developers onboarded and up to speed on a project. This is particularly
    evident in a SaaS project and is only partly mitigated using the Dockerized solution
    above.
  prefs: []
  type: TYPE_NORMAL
- en: It is very common these days to make use of an **Object Relational Mapper**
    (**ORM**) to manage the interactions between the code and the database, and this
    is a pattern that I will adhere to in this book. I will be using Entity Framework
    for all interactions initially, but note that when we discuss performance and
    scaling, I will touch on other techniques that can be used when database performance
    is paramount.
  prefs: []
  type: TYPE_NORMAL
- en: I will make use of Entity Framework’s “code-first” approach to define the database
    and populate it with some initial startup data, and I’ll make use of the migrations
    to keep the database up to date. This will come in very handy in later chapters
    when we talk about testing with a database, and also when we look at CI/CD and
    how to update a production database.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the database
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Make sure that you are in the dev container (check the bottom left of VSCode)
    and open a new terminal. Use the terminal to create a new .NET class library called
    `GoodHabits.Database` with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You should see the folder appear in File Explorer, and the following output
    in the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Create the database](img/B19343_Figure_2.12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.12 – Create the database
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we can use this project to interact with the database, we need to add
    a few NuGet packages. So, again, in the terminal, enter the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: With the preceding, we have instructed the .NET CLI to add all of the required
    NuGet packages to facilitate interactions with the database. We have also added
    a `GoodHabitsDbContext` class, a `SeedData` class, and a `Habit` class. We’ll
    now add some basic setup into these three files that will give us a foundation
    to work on in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Enter the following code into the `Habits.cs` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: The above is a very straightforward entity class representing a habit that a
    user of the app may want to embed into their day-to-day lives.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, add some dummy data, by adding the following code to the `SeedData.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'Now create a `DbContext` by entering the following code into the `GoodHabitsDbContext.cs`
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: This does a few things. Firstly, we define a `DbSet`. This is mapped onto a
    table in the database.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we hardcode the database connection string. Of course, it is bad practice
    to hardcode the connection string, and doubly bad to have the password there in
    plain text. We will correct these errors in [*Chapter 3*](B19343_03.xhtml#_idTextAnchor082),
    but this is sufficient to prove that we are connected to the database.
  prefs: []
  type: TYPE_NORMAL
- en: With this setup done, we can test this out and see whether we can migrate this
    information into the SQL Server database that we have running in a second Docker
    container.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do this, let’s start by using Entity Framework to create an initial migration.
    Enter the following into the terminal to generate the initial migration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: You will see a `Migrations` folder has appeared in File Explorer with the `InitialSetup`
    migration modeled as a class. You don’t have to worry too much about this at present,
    but it’s worth taking the time to have a look at this class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then enter the following to deploy the migration to the SQL Server database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This sends the migration to the database.
  prefs: []
  type: TYPE_NORMAL
- en: And that is it for now. We have configured a basic database using Entity Framework
    in “code-first” mode, and have sent the first migration to the database.
  prefs: []
  type: TYPE_NORMAL
- en: How do we know that this has worked?
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It’s one thing to understand that the command has been executed successfully,
    but seeing is believing, and we need to dip into the database to really be sure
    that all of this is actually working as expected.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will notice that when we defined the extensions that we wanted to be installed
    in the dev container, we specified the following extension should be included:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an extension for VSCode from Microsoft that allows us to query a SQL
    server database directly from VSCode. Click on the extension and we will add a
    new connection, with the following information added:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Parameter** | **Value** | **Notes** |'
  prefs: []
  type: TYPE_TB
- en: '| Hostname | `sqlerver` | *This is the name of the Docker container that we
    configured to run the SQL Server* *2022 instance* |'
  prefs: []
  type: TYPE_TB
- en: '| Database to connect | `GoodHabitsDatabase` | *This was defined i**n* *the*
    `DbContext` *class on the* *connection string* |'
  prefs: []
  type: TYPE_TB
- en: '| Authentication Type | `SQL Login` |  |'
  prefs: []
  type: TYPE_TB
- en: '| User name | `sa` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Password | `Password1` | *Defined* *in* `sqlserver.env` |'
  prefs: []
  type: TYPE_TB
- en: '| Save Password | `Yes` |  |'
  prefs: []
  type: TYPE_TB
- en: '| Display Name | `GoodHabits` |  |'
  prefs: []
  type: TYPE_TB
- en: You may need to okay a security popup.
  prefs: []
  type: TYPE_NORMAL
- en: 'With the above correctly entered, you should now get a view of the database,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Browse the database](img/B19343_Figure_2.13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.13 – Browse the database
  prefs: []
  type: TYPE_NORMAL
- en: You will note that the `Habits` table that we have defined as a `DbSet` in the
    `DbContext` file has been successfully migrated to the SQL Server database. You
    can right-click on the table named `dbo.Habits` and then click on **Select to
    1000** to see the contents.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Data stored in the database](img/B19343_Figure_2.14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.14 – Data stored in the database
  prefs: []
  type: TYPE_NORMAL
- en: Again, you will see that the information that we have added in the `DbContext`
    file is present and correct in the database.
  prefs: []
  type: TYPE_NORMAL
- en: API technology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Next, we will move on to the API. The purpose of the API is to facilitate the
    storage and retrieval of information from the database by the users and also to
    do any required data processing.
  prefs: []
  type: TYPE_NORMAL
- en: There are many different technologies that are available with which to build
    an API. This book is focused on Microsoft technologies, so we will use the .NET
    Web API framework and the C# language. However, the tools and techniques described
    could easily be adapted to make use of different technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, there are many different ideas about how best to structure an
    API, and there is no *one size fits all* approach that will work with every project
    out there. I have decided that I will use the RESTful paradigm for the examples
    in this book, but again, the concepts and ideas that are presented should copy
    over very well if your project is using some other structure, such as GraphQL.
  prefs: []
  type: TYPE_NORMAL
- en: The nature of a SaaS application is such that there are a huge number of choices
    to make when the project is getting started. This remains true even when the project
    is a demo application in a book!
  prefs: []
  type: TYPE_NORMAL
- en: Creating the HabitService API
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Making sure that you are in the dev container environment, and are in the root
    of the project (the `workspace` folder), create a new `webapi` project with the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The .NET CLI does a lot of work setting up the API. We need to make a change
    to the `launchSettings.json` file. Open the `Properties` folder and replace the
    default launch settings with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: The most important thing to note is that we will be running the `HabitService`
    on port `5100`. This is important to keep track of when we start to look at microservices
    in [*Chapter 6*](B19343_06.xhtml#_idTextAnchor140).
  prefs: []
  type: TYPE_NORMAL
- en: 'Out of the box, the default web API comes with the Weather API, which you can
    take a look at to get an idea of how these endpoints are configured. We can test
    this by entering the following into the terminal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will start the application running on the port that is specified in `launchSettings.json`
    – port `5100` in this case.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Console output indicating success](img/B19343_Figure_2.15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.15 – Console output indicating success
  prefs: []
  type: TYPE_NORMAL
- en: 'You can check to see whether the application is running by going to the following
    URL in your browser (remember to check the port number!): [http://127.0.0.1:5100/swagger/index.html](http://127.0.0.1:5100/swagger/index.html)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that you may get some HTTPS warnings from your browser, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.16 – The GoodHabits API](img/B19343_Figure_2.16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.16 – The GoodHabits API
  prefs: []
  type: TYPE_NORMAL
- en: User interface technology
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Finally, we need a user interface on which to display the information.
  prefs: []
  type: TYPE_NORMAL
- en: As I have pointed out for both the database and the API, there are many different
    UI technologies, and the underlying tools and techniques that you will learn in
    this book can be applied to any one of them. Often, the best technology to use
    in any given situation is the one that you are most comfortable with.
  prefs: []
  type: TYPE_NORMAL
- en: This is a Microsoft-centric book aimed at existing .NET developers, so I will
    use Blazor for the examples that are provided. If you prefer Angular, React, Vue,
    or any of the other millions of UI frameworks that are out there, please don’t
    be put off. In fact, adapting these examples to work with your UI of choice would
    be an excellent exercise to further your understanding of the concepts that we
    will cover in this book.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Creating a simple demo Blazor UI is straightforward with the CLI tools provided
    by Microsoft. Enter the following commands into the terminal to create the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'This follows the same pattern that we used to create the HabitServer project.
    And, like the HabitServer project, we will need to modify the launch configuration
    in `launchSettings.json`. Again, look in the `Properties` folder, and overwrite
    the contents with this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Again, take note of the port that the client is running on. We will use `5900`
    for the client.
  prefs: []
  type: TYPE_NORMAL
- en: With the config done, you can now start the client by typing `dotnet run` into
    the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, you will see that the `Client` app is running on the ports specified
    in `launchSettings.json`, which should be port `5900`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Console output indicating success](img/B19343_Figure_2.17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.17 – Console output indicating success
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, as per the API, you can follow this link in your browser to see the
    Blazor app running:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Hello, world!](img/B19343_Figure_2.18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.18 – Hello, world!
  prefs: []
  type: TYPE_NORMAL
- en: Starting the application
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Currently, we only have two projects to run, the HabitService API and the Blazor
    client. So, we can fairly easily start the whole project by typing `dotnet run`
    twice. As we build on this application, it will become more and more complex,
    and harder to run in this way. So, we’ll create build and launch configurations
    to tell VSCode how to start the application.
  prefs: []
  type: TYPE_NORMAL
- en: We have already created the config files for this in the `.``vscode` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Start by opening `tasks.json`, and copy in the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: You can see in the above JSON that two tasks are defined to build the client
    and the habit service.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, modify `launch.json` by adding the following JSON config:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: Again, you can see that two configurations are added to run the individual project.
    You can also see nearer the bottom that there is a `compounds launch` command
    set to run all of the projects.
  prefs: []
  type: TYPE_NORMAL
- en: You can test this out by pressing *Ctrl* + *Shift* + *D* to enter the **Run
    and Debug** menu, selecting **Run** All from the dropdown, and pressing the play
    button.
  prefs: []
  type: TYPE_NORMAL
- en: You will see that this starts the API and the client at the same time. This
    will be very handy as the number of projects starts to grow!
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can also hit *F5* to start the application as well.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a solution file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There is one last small piece of setup to do before we move on to really building
    out the application, and that is to add a solution file. This is not strictly
    necessary, but it is commonly done when working with .NET projects and will allow
    us to easily build, clean, and test the projects with a single command.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a solution file, simply navigate to the project root, and run the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: This simply adds a solution file and references the three projects that we have
    created.
  prefs: []
  type: TYPE_NORMAL
- en: And that is the final piece of setup work to do – now we can progress to building
    the application.
  prefs: []
  type: TYPE_NORMAL
- en: Where do we go from here?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have done a lot of work in this chapter, but we haven’t really started to
    build the application yet. We have instead focused on choosing the tools that
    we will use and building a development environment around those tools. We now
    have the outline of a SaaS application that we can continue to work with as we
    move through this book.
  prefs: []
  type: TYPE_NORMAL
- en: Taking the time at the start of the project to select the correct tools is an
    important step of any SaaS project, and it should not be skipped.
  prefs: []
  type: TYPE_NORMAL
- en: Being successful in developing any application requires that some thought is
    put into the technologies and frameworks that will be used, and also the tooling
    that will be used. In this chapter, we have set ourselves up very well to be able
    to get our hands dirty and try things out as we explore the concepts that are
    required to build a SaaS application.
  prefs: []
  type: TYPE_NORMAL
- en: The following chapters will start to introduce a lot more SaaS-specific considerations,
    and we will use this outline app to demonstrate them.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have briefly touched on a lot of different tools, topics,
    and techniques. This is the nature of developing SaaS applications – please don’t
    feel overwhelmed! To get started, we installed the tools that we need to work
    with, namely Docker Desktop and Visual Studio Code. This is quite a light set
    of tools for a SaaS project. But as you have seen, we used Docker to wrap up the
    developer environment. We learned about dev containers, and how they significantly
    streamline project setup for complex projects, such as a SaaS application, and
    we then configured a dev container and learned how to work in that environment.
  prefs: []
  type: TYPE_NORMAL
- en: With the core of the environment set up, we set up a database and populated
    it with some data using Entity Framework, then made the data available through
    an API, and finally surfaced the data on a Blazor UI!
  prefs: []
  type: TYPE_NORMAL
- en: With all of the above, we have configured all of the individual parts required
    to build up a fully featured SaaS application. Read on, and we will do just that!
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, you will learn about a core part of building SaaS applications,
    and that is multi-tenancy. We will cover what this is and why it is so important,
    and start to think about how we will implement it in our sample application.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Developing inside a Container: [https://code.visualstudio.com/docs/devcontainers/containers](https://code.visualstudio.com/docs/devcontainers/containers)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Entity Framework Dev Environment in Docker: [https://itnext.io/database-development-in-docker-with-entity-framework-core-95772714626f](https://itnext.io/database-development-in-docker-with-entity-framework-core-95772714626f)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET Development in Docker with Dev Containers: [https://itnext.io/net-development-in-docker-6509d8a5077b](https://itnext.io/net-development-in-docker-6509d8a5077b)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Blazor Tutorial - Build your first Blazor app: [https://dotnet.microsoft.com/en-us/learn/aspnet/blazor-tutorial/intro](https://dotnet.microsoft.com/en-us/learn/aspnet/blazor-tutorial/intro)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Tutorial: Create a web API with ASP.NET Core: [https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-7.0&tabs=visual-studio](https://learn.microsoft.com/en-us/aspnet/core/tutorials/first-web-api?view=aspnetcore-7.0&tabs=visual-studio)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What are the advantages of using dev containers?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How were we able to use SQL Server without having to install it on our developer
    machines?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the HTTP verbs commonly associated with RESTful APIs?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the benefits of using Entity Framework?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have covered a lot in this chapter! Don’t worry if the answers to the above
    questions are not 100% clear at this stage – we will expand on all of them in
    the coming chapters.
  prefs: []
  type: TYPE_NORMAL
- en: 'Part 2: Building the Backend'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section covers all things backend related, starting with the database and
    building up to the API layer. This section also introduces the topics of multi-tenancy
    and microservices, both of which are very important for developing SaaS applications.
  prefs: []
  type: TYPE_NORMAL
- en: 'This section has the following chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '[*Chapter 3*](B19343_03.xhtml#_idTextAnchor082), *What Is Multi-Tenancy, and
    Why Is It Important in SaaS Applications?*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 4*](B19343_04.xhtml#_idTextAnchor102), *Building Databases and Planning
    for Data-Rich Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 5*](B19343_05.xhtml#_idTextAnchor116), *Building R**EST**ful APIs*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[*Chapter 6*](B19343_06.xhtml#_idTextAnchor140), *Microservices for SaaS Applications*'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
