<html><head></head><body>
		<div id="_idContainer135">
			<h1 id="_idParaDest-137"><em class="italic"><a id="_idTextAnchor139"/>Chapter 7</em>: LINQ Performance</h1>
			<p>LINQ has a reputation for being slow. But contrary to people's views, there are ways to use LINQ that ensure optimal performance. </p>
			<p>In this chapter, you will learn how to perform LINQ queries with performance in mind. Depending on how you use LINQ, different methods that return the same result can behave and perform differently. And so, in this chapter, you will learn how best to perform queries on LINQ to improve the performance of your applications.</p>
			<p>Here, you will benchmark different ways to determine the most performative ways to obtain the last element of a LINQ query. You will learn about the performance penalty of using the <strong class="source-inline">let</strong> keyword in LINQ statements, and why you should avoid using it. Benchmarking different <strong class="source-inline">Group By</strong> methods, you will gain insight into the most performant way to perform GroupBy queries using LINQ. When performing queries and data manipulation using LINQ, there may be times when you need to use closures. By writing parametrized and non-parameterized closures, you will see that parameterized closures perform much better than non-parameterized closures.</p>
			<p>We will be covering the following topics in this chapter:</p>
			<ul>
				<li>Setting up our sample database</li>
				<li>Setting up our in-memory sample data </li>
				<li>Querying a database using LINQ </li>
				<li>Getting the last value of a collection </li>
				<li>Avoid using the let keyword in LINQ queries </li>
				<li>Increasing Group By performance in LINQ queries </li>
				<li>Filtering lists </li>
				<li>Understanding closures </li>
			</ul>
			<p>By the end of this chapter, you will have the skills to securely store secrets and query databases and in-memory data using efficient LINQ. You will also be able to understand the performance impact of using the <strong class="source-inline">let</strong> keyword in your queries and performing efficient filtering and grouping of data using LINQ. </p>
			<h1 id="_idParaDest-138"><a id="_idTextAnchor140"/>Technical requirements</h1>
			<p>In order to follow along with this chapter, you will need access to the following tools:</p>
			<ul>
				<li>Visual Studio 2022</li>
				<li>SQL Server 2019</li>
				<li>SQL Server Management Studio</li>
				<li>The book's source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH07 ">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH07</a></li>
			</ul>
			<h1 id="_idParaDest-139"><a id="_idTextAnchor141"/>Setting up a sample database</h1>
			<p>In this chapter, we will be demonstrating the difference between how different collection interfaces handle data, and for the demonstrations, you require access to database data. To do so, you will<a id="_idIndexMarker743"/> create a database, add a table, and populate it with data. You will use SQL Server for your database engine, and use SQL Server Management Studio to develop your sample database.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">In the <strong class="source-inline">CH07_LinqPerformance.Data</strong> source code folder, you will find a database creation script called <strong class="source-inline">SampleData.Product.sql</strong> that creates the database and populates it with data. You can run this script in SQL Server Management Studio. This will save you from having to run through setting up the database in this section. But if you are new to SQL Server, you may want to run through this section.</p>
			<p>To add your database, follow these steps:</p>
			<ol>
				<li>Open SQL Server Management Studio and connect to your database engine.</li>
				<li>Right-click on the <strong class="bold">Databases</strong> folder in <strong class="bold">Object Explorer</strong> as shown in <em class="italic">Figure 7.1</em>:</li>
			</ol>
			<div>
				<div id="_idContainer122" class="IMG---Figure">
					<img src="image/B16617_07_01.jpg" alt="Figure 7.1: The SQL Server Management Studio Object Explorer tab&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.1: The SQL Server Management Studio Object Explorer tab</p>
			<ol>
				<li value="3">Select <strong class="bold">New Database</strong> from the <a id="_idIndexMarker744"/>context menu. This will display the <strong class="bold">New Database</strong> dialog as shown in <em class="italic">Figure 7.2</em>:</li>
			</ol>
			<div>
				<div id="_idContainer123" class="IMG---Figure">
					<img src="image/B16617_07_02.jpg" alt="Figure 7.2: The SQL Server Management Studio New Database dialog&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.2: The SQL Server Management Studio New Database dialog</p>
			<ol>
				<li value="4">Once you have entered <strong class="source-inline">SampleData</strong> for the database name, click on the <strong class="bold">OK</strong> button to <a id="_idIndexMarker745"/>create the database.</li>
				<li>Locate the database by expanding the <strong class="bold">Databases</strong> folder, and then expand the database. Right-click on the <strong class="bold">Tables</strong> folder and select <strong class="bold">New</strong> | <strong class="bold">Table</strong>. Add a new table called <strong class="source-inline">Products</strong> as shown in the following figure:</li>
			</ol>
			<div>
				<div id="_idContainer124" class="IMG---Figure">
					<img src="image/Table_7.1.jpg" alt="Table 7.1: The Products table design&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 7.1: The Products table design</p>
			<ol>
				<li value="6">Save the table and then expand the <strong class="bold">Tables</strong> folder. Right-click on the <strong class="bold">Products</strong> table and <a id="_idIndexMarker746"/>select <strong class="bold">Edit Top n records</strong> where <em class="italic">n</em> will be the number of configured records to edit, which is <em class="italic">200</em> by default.</li>
				<li>Add the data shown in the following figure to the <strong class="bold">Product</strong> table:</li>
			</ol>
			<div>
				<div id="_idContainer125" class="IMG---Figure">
					<img src="image/Table_7.2.jpg" alt="Table 7.2: The Product table row data&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Table 7.2: The Product table row data</p>
			<p>We now have a<a id="_idIndexMarker747"/> database with a single table filled with data that we will use later in the chapter. In the next section, we will be adding our in-memory sample data.</p>
			<h1 id="_idParaDest-140"><a id="_idTextAnchor142"/>Setting up our in-memory sample data</h1>
			<p>You will be studying<a id="_idIndexMarker748"/> LINQ performance, therefore, you are going to need a collection to work with. You will work with a collection of <strong class="source-inline">Person</strong> objects. Each person will be named from the Greek alphabet. A <strong class="source-inline">Person</strong> object will consist of a <strong class="source-inline">FirstName</strong>, <strong class="source-inline">LastName</strong>, and <strong class="source-inline">FullName</strong> property. The <strong class="source-inline">FullName</strong> property will be an interpolated string that combines the first and last name of the person. </p>
			<p>Let us now begin coding our LINQ <a id="_idIndexMarker749"/>coding combined with <strong class="bold">benchmarking</strong>, so that we can measure the performance of our LINQ statements:</p>
			<ol>
				<li value="1">Create a new .NET 6.0 console application called <strong class="source-inline">CH07_LinqPerformance</strong>.</li>
				<li>Install the NuGet package <strong class="source-inline">BenchmarkDotNet</strong>.</li>
				<li>Add the following <strong class="source-inline">Person</strong> struct:<p class="source-code">public struct Person</p><p class="source-code">{</p><p class="source-code">      public string FirstName { get; set; }</p><p class="source-code">      public string LastName { get; set; }</p><p class="source-code">      public string FullName { get { return </p><p class="source-code">        $"{FirstName} {LastName}"; } }</p><p class="source-code">public Person(string firstName, string lastName)</p><p class="source-code">{</p><p class="source-code">    FirstName = firstName;</p><p class="source-code">    LastName = lastName;</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>This structure defines the <strong class="source-inline">Person</strong> with their <strong class="source-inline">FirstName</strong>, <strong class="source-inline">LastName</strong>, and computed <strong class="source-inline">FullName</strong>. </p>
			<ol>
				<li value="4">Now, add a new <a id="_idIndexMarker750"/>class called <strong class="source-inline">LinqPerformance</strong> with the following <strong class="source-inline">using </strong>statements:<p class="source-code">using BenchmarkDotNet.Attributes;</p><p class="source-code">using BenchmarkDotNet.Order;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Linq;</p></li>
			</ol>
			<p>These <strong class="source-inline">using</strong> statements provide you with access to benchmarking, generic collections, and LINQ classes. </p>
			<ol>
				<li value="5">Add the following code to the top of the class:<p class="source-code">private List&lt;Person&gt; _people = new List&lt;Person&gt;();</p><p class="source-code">private string[] _group1 = new string[] { "iota", </p><p class="source-code">    "epsilon", "sigma", "upsilon" };</p><p class="source-code">private string[] _group2 = new string[] { "alpha", </p><p class="source-code">    "omega" };</p></li>
			</ol>
			<p>You have declared a list of people and two arrays. Both these arrays contain the surnames of people in lowercase that belong to those groups. </p>
			<ol>
				<li value="6">Now, add the global <a id="_idIndexMarker751"/>setup class that will prepare your collection for benchmarking various LINQ queries:<p class="source-code">[GlobalSetup]</p><p class="source-code">public void PrepareBenchmarks()</p><p class="source-code">{</p><p class="source-code">  _people.Add(new Person("Alpha", "Beta"));</p><p class="source-code">  _people.Add(new Person("Chi", "Delta"));</p><p class="source-code">  _people.Add(new Person("Epsilon", "Phi"));</p><p class="source-code">  _people.Add(new Person("Gamma", "iota"));</p><p class="source-code">  _people.Add(new Person("Kappa", "Lambda"));</p><p class="source-code">  _people.Add(new Person("Mu", "Nu"));</p><p class="source-code">  _people.Add(new Person("Omicron", "Pi"));</p><p class="source-code">  _people.Add(new Person("Theta", "Rho"));</p><p class="source-code">  _people.Add(new Person("Sigma", "Tau"));</p><p class="source-code">  _people.Add(new Person("Upsilon", "Omega"));</p><p class="source-code">  _people.Add(new Person("Xi", "Psi"));</p><p class="source-code">  _people.Add(new Person("Zeta", "Iota"));</p><p class="source-code">  _people.Add(new Person("Alpha", "Omega"));</p><p class="source-code">     _people.Add(new Person("Omega", "Chi"));</p><p class="source-code">     _people.Add(new Person("Sigma", "Tau"));</p><p class="source-code">}</p></li>
			</ol>
			<p>You now have your sample database and in-memory sample data in place for the topics we will be covering in this chapter. So, let us start by investigating various ways of querying a database <a id="_idIndexMarker752"/>and their effects on LINQ query performance.</p>
			<h1 id="_idParaDest-141"><a id="_idTextAnchor143"/>Database query performance</h1>
			<p>We saw in <a href="B16617_06_Final_SB_Epub.xhtml#_idTextAnchor117"><em class="italic">Chapter 6</em></a>, <em class="italic">The .NET Collection</em>, how <strong class="source-inline">IEnumerator</strong> is different from <strong class="source-inline">IEnumerable</strong>, and how <strong class="source-inline">IEnumerator</strong> performs faster than <strong class="source-inline">IEnumerable</strong> when iterating through an in-memory collection. Now, we will query a database and iterate through the<a id="_idIndexMarker753"/> resulting collection using various benchmarked techniques. To do so, we will follow these steps:</p>
			<ol>
				<li value="1">Add a new class called <strong class="source-inline">IEnumeratorVsIQueryable</strong>.</li>
				<li>You will be connecting to a SQL Server database and will have the information you need to keep secret. Your <strong class="source-inline">secret.json</strong> files do not get checked into version control. So, right-click on the project and select <strong class="bold">Manage User Secrets</strong> from the context menu.</li>
				<li>A dialog will pop up informing you that additional packages are required. Click on <strong class="bold">Yes</strong>.</li>
			</ol>
			<div>
				<div id="_idContainer126" class="IMG---Figure">
					<img src="image/B16617_07_03.jpg" alt="Figure 7.3: Dialog Informing you that additional packages are required to manage user secrets&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.3: Dialog Informing you that additional packages are required to manage user secrets</p>
			<ol>
				<li value="4">Visual Studio will then open the <strong class="source-inline">secrets.json</strong> file in a new tab. This is where you will add your user secrets.</li>
				<li>Open <strong class="bold">Package Manager Console</strong> and add the following packages:<p class="source-code">Microsoft.EntityFrameworkCore</p><p class="source-code">Microsoft.EntityFrameworkCore.SqlServer</p><p class="source-code">Microsoft.EntityFrameworkCore.Tools</p><p class="source-code">Microsoft.Extensions.Configuration</p><p class="source-code">Microsoft.Extensions.Configuration.EnvironmentVariables</p><p class="source-code">Microsoft.Extensions.Configuration.UserSecrets</p><p class="source-code">Microsoft.Extensions.OptionsConfigurationExtensions</p></li>
			</ol>
			<p>These packages<a id="_idIndexMarker754"/> enable you to connect to and extract data from the SQL Server database. </p>
			<ol>
				<li value="6">Update your <strong class="source-inline">secrets.json</strong> file with the connection string to the database you created at the start of the chapter:<p class="source-code">{</p><p class="source-code">  "DatabaseSettings": {</p><p class="source-code">    "ConnectionString": "YOUR_CONNECTION_STRING"</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>This connection string will be used to connect to your database, perform a query that returns some data, and enable you to iterate through that data and perform operations on it. </p>
			<ol>
				<li value="7">Add a folder called <strong class="source-inline">Configuration</strong>, and in that folder, add a class called <strong class="source-inline">SecretsManager</strong> with an empty static constructor and the following <strong class="source-inline">using</strong> statements:<p class="source-code">using Microsoft.Extensions.Configuration;</p><p class="source-code">using System;</p><p class="source-code">using System.IO;</p></li>
			</ol>
			<p>You need these <strong class="source-inline">using</strong> statements for your file I/O and system configuration such as obtaining secrets from a <strong class="source-inline">secrets.json</strong> file. </p>
			<ol>
				<li value="8">Add the following line at the top of the <strong class="source-inline">SecretsManager</strong> class:<p class="source-code">public static IConfigurationRoot Configuration </p><p class="source-code">    { get; set; }</p></li>
			</ol>
			<p>This line declares your static configuration property that is used to obtain your configuration data within your application. </p>
			<ol>
				<li value="9">Now add the <a id="_idIndexMarker755"/>following code:<p class="source-code">public static T GetSecrets&lt;T&gt;(string sectionName) </p><p class="source-code">    where T : class</p><p class="source-code">{</p><p class="source-code">var devEnvironmentVariable = Environment</p><p class="source-code">      .GetEnvironmentVariable("NETCORE_ENVIRONMENT");</p><p class="source-code">var isDevelopment = string.IsNullOrEmpty</p><p class="source-code">       (devEnvironmentVariable) || devEnvironment</p><p class="source-code">            Variable.ToLower() == "development";</p><p class="source-code">var builder = new ConfigurationBuilder() </p><p class="source-code">    .SetBasePath(Directory.GetCurrentDirectory())</p><p class="source-code">.AddJsonFile("appsettings.json", optional: true, </p><p class="source-code">    reloadOnChange: true)</p><p class="source-code">.AddEnvironmentVariables();</p><p class="source-code">if (isDevelopment) //only add secrets in development</p><p class="source-code">{</p><p class="source-code">    builder.AddUserSecrets&lt;T&gt;();</p><p class="source-code">}</p><p class="source-code">Configuration = builder.Build();</p><p class="source-code">return Configuration.GetSection(sectionName).Get&lt;T&gt;();</p></li>
			</ol>
			<p>This code gets the environment variables for the .NET Core environment. It then gets the code to see if it is running in a software development environment or production environment. The configuration is then built for the environment it will be running in. So, if we are in debug mode, the configuration will be built for the development <a id="_idIndexMarker756"/>environment. And if we are in release mode, the configuration will be built for the production environment. If we are in development, then we add our <strong class="source-inline">secrets</strong> class as defined by the <strong class="source-inline">T</strong> variable.</p>
			<ol>
				<li value="10"> Create a new folder, <strong class="source-inline">Models</strong>, and add the <strong class="source-inline">Product</strong> class using the following code:<p class="source-code">using System.ComponentModel.DataAnnotations;</p><p class="source-code">public class Product</p><p class="source-code">{</p><p class="source-code">       public Product() { }</p><p class="source-code">       public Product(int id)</p><p class="source-code">       {</p><p class="source-code">            Id = id;</p><p class="source-code">           Name = $"Item {Id} Name";</p><p class="source-code">           Description = $"Item {Id} description.";</p><p class="source-code">         }</p><p class="source-code">       [Key]</p><p class="source-code">       public int Id { get; private set; }</p><p class="source-code">       public string Name { get; private set; }</p><p class="source-code">       public string Description { get; private set; }</p><p class="source-code">       public override string ToString()</p><p class="source-code">       {</p><p class="source-code">      return $"Id: {Id}, Name: {Name}, </p><p class="source-code">        Description: {Description}";</p><p class="source-code">       }</p><p class="source-code">}</p></li>
			</ol>
			<p>Our <strong class="source-inline">Product</strong> class provides the model for our product data with <strong class="source-inline">Id</strong>, <strong class="source-inline">Name</strong>, and <strong class="source-inline">Description</strong> properties<a id="_idIndexMarker757"/> that are set via the constructor. We also <a id="_idIndexMarker758"/>override the <strong class="source-inline">ToString</strong> method to return a textual representation of the property values.</p>
			<ol>
				<li value="11">Add a <strong class="source-inline">using</strong> statement for <strong class="source-inline">System.ComponentModel.DataAnnotations</strong>. Change the struct to a class, and add the <strong class="source-inline">[Key]</strong> attribute to the <strong class="source-inline">Id</strong> property. We need these changes since we are using Entity Framework to connect to a database and extract data.</li>
				<li>In the <strong class="source-inline">CH07_LinqPerformance.Data</strong> folder, add the <strong class="source-inline">DatabaseContext</strong> class:<p class="source-code">using Microsoft.EntityFrameworkCore;</p><p class="source-code">using CH07_LinqPerformance.Models;</p><p class="source-code">public class DatabaseContext : DbContext</p><p class="source-code">{</p><p class="source-code">}</p></li>
			</ol>
			<p>We have declared our <strong class="source-inline">DatabaseContext</strong> class, which inherits from the <strong class="source-inline">DbContext</strong> class. Now we'll need to add its internals.</p>
			<ol>
				<li value="13">Add the following items to the <strong class="source-inline">DatabaseContext</strong> class:<p class="source-code">public DbSet&lt;Product&gt; Products { get; set; }</p><p class="source-code">public DatabaseContext(string connectionString) : </p><p class="source-code">    base(GetOptions(connectionString))</p><p class="source-code">{</p><p class="source-code">}</p></li>
			</ol>
			<p>In this code, we have declared our <strong class="source-inline">DbSet</strong> of products property, which will hold a collect of our <strong class="source-inline">Product</strong> class, and a connection string member variable that will hold the string that connects us to our database. Our constructor is then declared, which takes in <a id="_idIndexMarker759"/>a connection string, which we pass into the <strong class="source-inline">GetOptions</strong> method that then gets passed into the base class constructor. </p>
			<ol>
				<li value="14">Add the <strong class="source-inline">GetOptions</strong> method to the <strong class="source-inline">DatabaseContext</strong> class:<p class="source-code">private static DbContextOptions GetOptions(string </p><p class="source-code">    connectionString)</p><p class="source-code">{</p><p class="source-code">       return SqlServerDbContextOptionsExtensions</p><p class="source-code">             .UseSqlServer(</p><p class="source-code">                   new DbContextOptionsBuilder(),  </p><p class="source-code">                   connectionString)</p><p class="source-code">             .Options;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method <a id="_idIndexMarker760"/>returns the <strong class="source-inline">DbContextOptions</strong> for our SQL Server database connection. The connection string used is the one that is stored in our <strong class="source-inline">secrets.json</strong> file in development and in <strong class="source-inline">appsettings.json</strong> when in production.</p>
			<ol>
				<li value="15">Add the <strong class="source-inline">OnModelCreating</strong> method:<p class="source-code">protected override void OnModelCreating(ModelBuilder </p><p class="source-code">    modelBuilder)</p><p class="source-code">{</p><p class="source-code">       modelBuilder.Entity&lt;Product&gt;(entity =&gt;</p><p class="source-code">     {</p><p class="source-code">                 entity.HasKey(e =&gt; e.Id);</p><p class="source-code">           entity.Property(e =&gt; e.Name)</p><p class="source-code">                  .HasMaxLength(50);</p><p class="source-code">             Entity.Property(e =&gt; e.Description)</p><p class="source-code">                .HasMaxLength(255);</p><p class="source-code">            });</p><p class="source-code">        }</p></li>
			</ol>
			<p>Here, we are configuring our <strong class="source-inline">Product</strong> class that will be used in our <strong class="source-inline">DbSet</strong>. We are declaring that the <strong class="source-inline">Id</strong> field is<a id="_idIndexMarker761"/> our primary key and that the <strong class="source-inline">Name</strong> field has a maximum<a id="_idIndexMarker762"/> length of 50 while the <strong class="source-inline">Description</strong> field has a maximum length of 255.</p>
			<ol>
				<li value="16">Add the <strong class="source-inline">DatabaseSettings</strong> class to the <strong class="source-inline">Configuration</strong> folder:<p class="source-code">public class DatabaseSettings</p><p class="source-code">{</p><p class="source-code">      public string ConnectionString { get; set; }</p><p class="source-code">}</p></li>
			</ol>
			<p>This class has a single property called <strong class="source-inline">ConnectionString</strong> that will hold your connection string to our <strong class="source-inline">SampleData</strong> database. Notice that the name of the class and property match the name of the JSON section and property! </p>
			<ol>
				<li value="17">Now, add <strong class="source-inline">appsettings.json</strong> to the root of your project with the following contents:<p class="source-code">{</p><p class="source-code">  "DatabaseSettings": {</p><p class="source-code">    "ConnectionString": "Set in Azure. For </p><p class="source-code">        development, set in User Secrets"</p><p class="source-code">  }</p><p class="source-code">}</p></li>
			</ol>
			<p>This file has the same layout as the <strong class="source-inline">secrets.json</strong> file and the <strong class="source-inline">DatabaseSettings</strong> class. This file is used to store your connection string. In development, it is set in the<a id="_idIndexMarker763"/> secrets file, and in production, it is set in Azure. Now that you have your database configuration in place, you can add your benchmarking code.</p>
			<ol>
				<li value="18">Add a new class in the root of the project called <strong class="source-inline">DatabaseQueryAndIteration</strong> that implements <strong class="source-inline">IDisposable</strong> with the following code:<p class="source-code">using BenchmarkDotNet.Attributes;</p><p class="source-code">using BenchmarkDotNet.Order;</p><p class="source-code">using CH07_Collections.Configuration;</p><p class="source-code">using CH07_Collections.Data;</p><p class="source-code">using CH07_Collections.Models;</p><p class="source-code">using Microsoft.Extensions.Options;</p><p class="source-code">using System;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Diagnostics;</p><p class="source-code">using System.Linq;</p><p class="source-code">[MemoryDiagnoser]</p><p class="source-code">[Orderer(SummaryOrderPolicy.Declared)]</p><p class="source-code">[RankColumn]</p><p class="source-code">public class DatabaseQueryAndIteration : IDisposable </p><p class="source-code">{</p><p class="source-code">}</p></li>
			</ol>
			<p>This code declares our class and defines the fact that it implements <strong class="source-inline">IDisposable</strong>. It is also <a id="_idIndexMarker764"/>configured to be benchmarked.</p>
			<ol>
				<li value="19">Implement the <strong class="source-inline">IDisposable</strong> interface in our class:<p class="source-code">private bool disposedValue;</p><p class="source-code">protected virtual void Dispose(bool disposing)</p><p class="source-code">{</p><p class="source-code">    if (!disposedValue) {</p><p class="source-code">        if (disposing)</p><p class="source-code">            _context.Dispose();</p><p class="source-code">        disposedValue = true;</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">public void Dispose(){</p><p class="source-code">    Dispose(disposing: true);</p><p class="source-code">    GC.SuppressFinalize(this);</p><p class="source-code">}</p></li>
			</ol>
			<p>This code disposes of our managed resources and suppresses the call to the class finalizer method.</p>
			<ol>
				<li value="20">We have everything in place to benchmark the methods in this class, access database resources, and clean up after ourselves. Add the following code to the class:<p class="source-code">private DatabaseContext _context;</p><p class="source-code">[GlobalSetup]</p><p class="source-code">public void GlobalSetup()</p><p class="source-code">{</p><p class="source-code">      var connectionString = SecretsManager</p><p class="source-code">        .GetSecrets&lt;DatabaseSettings&gt;(nameof</p><p class="source-code">          (DatabaseSettings)).ConnectionString;</p><p class="source-code">  _context = new DatabaseContext(connectionString);</p><p class="source-code">}</p><p class="source-code">[GlobalCleanup]</p><p class="source-code">public void GlobalCleanup()</p><p class="source-code">{</p><p class="source-code">      Dispose(true);</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">_context</strong> variable provides us with our database access. The <strong class="source-inline">GlobalSetup()</strong> method gets our <a id="_idIndexMarker765"/>connection string from our secrets file, and creates a new <strong class="source-inline">DatabaseContext</strong> using the safely stored connection string. The <strong class="source-inline">GlobalSetup()</strong> method will run before our benchmarks. The <strong class="source-inline">GlobalCleanup()</strong> method calls the <strong class="source-inline">Dispose(disposing)</strong> method to clean up our managed resources after our benchmarks have finished running.</p>
			<ol>
				<li value="21">Next, add the <strong class="source-inline">QueryDb()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void QueryDb()</p><p class="source-code">{</p><p class="source-code">      var products = (from p in _context.Products</p><p class="source-code">                      where p.Id &gt; 1select p);</p><p class="source-code">foreach (var product in products)</p><p class="source-code">    Debug.WriteLine(product.Name);</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">QueryDb()</strong> method performs a simple LINQ query on the database by selecting products with an ID of <a id="_idIndexMarker766"/>greater than <strong class="source-inline">1</strong>. It then iterates each product in the <strong class="source-inline">IQueryable&lt;Product&gt;</strong> list and writes the product name out to the debug window. </p>
			<ol>
				<li value="22">Now, add the <strong class="source-inline">QueryDbAsList()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void QueryDbAsList()</p><p class="source-code">{</p><p class="source-code">List&lt;Product&gt; products = (from p in _context.Products</p><p class="source-code">  where p.Id &gt; 1select p).ToList&lt;Product&gt;();</p><p class="source-code">foreach (var product in products)</p><p class="source-code">Debug.WriteLine(product.Name);</p><p class="source-code">}</p></li>
			</ol>
			<p><strong class="source-inline">QueryDbAsList()</strong> performs the same query as <strong class="source-inline">QueryDb()</strong>, except the processed type is of type <strong class="source-inline">List&lt;Product&gt;</strong>. </p>
			<ol>
				<li value="23">Add the <strong class="source-inline">QueryDbAsIEnumerable()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void QueryDbAsIEnumerable()</p><p class="source-code">{</p><p class="source-code">var products = (from p in _context.Products</p><p class="source-code">                where p.Id &gt; 1</p><p class="source-code">                select p).AsEnumerable&lt;Product&gt;();</p><p class="source-code">foreach (var product in products)</p><p class="source-code">    Debug.WriteLine(product.Name);</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">QueryDbAsIEnumerable()</strong> method performs the same query as <strong class="source-inline">QueryDbAsList</strong>, but processes a<a id="_idIndexMarker767"/> type of <strong class="source-inline">IEnumerable&lt;Product&gt;</strong> instead. </p>
			<ol>
				<li value="24">Add the <strong class="source-inline">QueryDbAsIEnumerator()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void QueryDbAsIEnumerator()</p><p class="source-code">{</p><p class="source-code">      var products = (from p in _context.Products</p><p class="source-code">                      where p.Id &gt; 1</p><p class="source-code">                      select p).GetEnumerator();</p><p class="source-code">    while (products.MoveNext())</p><p class="source-code">    Debug.WriteLine(products.Current.Name);</p><p class="source-code">}</p></li>
			</ol>
			<p><strong class="source-inline">QueryDbAsIEnumerator()</strong> does the same as the previous methods but operates on a type of <strong class="source-inline">IEnumerator&lt;Product&gt;</strong> and iterates using a <strong class="source-inline">while</strong> loop instead of a <strong class="source-inline">foreach</strong> loop. </p>
			<ol>
				<li value="25">The final method in this class that we need to add is the <strong class="source-inline">QueryDbAsIQueryable()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void QueryDbAsIQueryable()</p><p class="source-code">{</p><p class="source-code">var products = (from p in _context.Products</p><p class="source-code">                where p.Id &gt; 1</p><p class="source-code">                select p).AsQueryable&lt;Product&gt;();</p><p class="source-code">foreach (var product in products)</p><p class="source-code">    Debug.WriteLine(product.Name);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method is the same as <strong class="source-inline">QueryDb</strong> but explicitly operates on a type of <strong class="source-inline">IQueryable&lt;Product&gt;</strong>. </p>
			<ol>
				<li value="26">Replace the code in the <strong class="source-inline">Main</strong> method<a id="_idIndexMarker768"/> within the <strong class="source-inline">Program</strong> class with the following:<p class="source-code">BenchmarkRunner.Run&lt;DatabaseQueryAndIteration&gt;();</p></li>
			</ol>
			<p>This code runs your benchmarks. Do a release build of the code and run the executable from the command line. You should see a summary report similar to the following:</p>
			<div>
				<div id="_idContainer127" class="IMG---Figure">
					<img src="image/B16617_07_04.jpg" alt="Figure 7.4: The different times and memory allocation of various database query types using LINQ&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.4: The different times and memory allocation of various database query types using LINQ</p>
			<p>Let us summarize what we learn <a id="_idIndexMarker769"/>from the summary report after running our query benchmarks:</p>
			<ul>
				<li>In terms of memory usage, the worst performer is the <strong class="source-inline">QueryDb()</strong> method followed by the <strong class="source-inline">QueryDbAsList()</strong> method. <strong class="source-inline">QueryDbAsIEnumerable()</strong> and <strong class="source-inline">QueryDbAsIQueryable()</strong> are both slightly better than the previous two. But the best performing method in terms of memory allocation out of all five methods is the <strong class="source-inline">QueryDbAsIEnumerator()</strong> method.</li>
				<li>Speed wise, the <strong class="source-inline">QueryDb()</strong> method was the worst again. Followed by <strong class="source-inline">QueryDbAsIEnumerable()</strong>, then <strong class="source-inline">QueryDbAsList()</strong>, and then <strong class="source-inline">QueryDbAsIQueryable()</strong>. And again, the best performer in terms of speed is the <strong class="source-inline">QueryDbAsIEnumerator()</strong> method.</li>
			</ul>
			<p>So, we can see that the best performing method for querying and iterating a database in both speed and memory usage terms is the <strong class="source-inline">QueryDbAsIEnumerator()</strong> method out of all the methods we've chosen to investigate. </p>
			<p>In the next section, we will be investigating which is the fastest method for obtaining the last item in a collection.</p>
			<h1 id="_idParaDest-142"><a id="_idTextAnchor144"/>Getting the last value of a collection</h1>
			<p>You are now going to<a id="_idIndexMarker770"/> see how the LINQ method that obtains the last element in the collection is really slow when compared to directly accessing the item by its index. This will be accomplished using benchmarking to measure the performance of different methods:</p>
			<ol>
				<li value="1">Update the <strong class="source-inline">Main</strong> method as follows:<p class="source-code">static void Main(string[] args)</p><p class="source-code">{</p><p class="source-code">      BenchmarkRunner.Run&lt;LinqPerformance&gt;();</p><p class="source-code">}</p></li>
				<li>Open the <strong class="source-inline">LinqPerformance</strong> class.</li>
				<li>Add the <strong class="source-inline">GetLastPersonVersion1()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void GetLastPersonVersion1()</p><p class="source-code">{</p><p class="source-code">      var lastPerson = _people.Last();</p><p class="source-code">}</p></li>
			</ol>
			<p>This method gets the last person in the collection using the LINQ-provided <strong class="source-inline">Last()</strong> method. </p>
			<ol>
				<li value="4">Add the <strong class="source-inline">GetLastPersonVersion2()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void GetLastPersonVersion2()</p><p class="source-code">{</p><p class="source-code">      var lastPerson = _people[_people.Count - 1];</p><p class="source-code">}</p></li>
				<li>Here, we are using the index of the list to extract the last person in the list. At this point, it is worth noting that the difference between the two methods is that in the first method, this <strong class="source-inline">Last()</strong> method call is actually declared in <strong class="source-inline">System.Linq.Enumerable</strong>. The method signature is as follows:<p class="source-code">public static TSource Last&lt;TSource&gt;(this </p><p class="source-code">    IEnumerable&lt;TSource&gt; source);</p></li>
			</ol>
			<p>So, the <strong class="source-inline">Last()</strong> call in<a id="_idIndexMarker771"/> the <strong class="source-inline">GetLastPersonVersion1()</strong> method performs various checks before the last value is returned. But the <strong class="source-inline">GetLastPersonVersion2()</strong> method does not perform these checks, and immediately returns the value at the last position. This explains why the method used in <strong class="source-inline">GetLastPersonVersion1()</strong> is much slower than accessing an element by its index in <strong class="source-inline">GetLastPersonVersion2()</strong>, as you will see in the following screenshot: </p>
			<div>
				<div id="_idContainer128" class="IMG---Figure">
					<img src="image/B16617_07_05.jpg" alt="Figure 7.5: Get Last Person example performance using the Last() method and direct index access&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.5: Get Last Person example performance using the Last() method and direct index access</p>
			<p>Looking at the summary report of the benchmarks we have just run, it is evident that using the index for direct access is better than using the <strong class="source-inline">Last()</strong> method call in terms of improved performance.</p>
			<p>We have seen how we can quickly access the last element in a collection. Let us now consider why we should avoid<a id="_idIndexMarker772"/> using the <strong class="source-inline">let</strong> keyword in LINQ queries.</p>
			<h1 id="_idParaDest-143"><a id="_idTextAnchor145"/>Avoid using the let keyword in LINQ queries</h1>
			<p>You can use the <strong class="source-inline">let</strong> keyword to declare <a id="_idIndexMarker773"/>a variable and assign it a value to use in your LINQ query if the value is to be used several times within the query. At first glance, this may seem like you are improving performance since you only<a id="_idIndexMarker774"/> perform a single assignment, and then use the same variable several times. But this is not actually the case. Using the <strong class="source-inline">let</strong> keyword in your LINQ queries can actually decrease the performance of your LINQ query.</p>
			<p>Let us work through some benchmark examples. In the <strong class="source-inline">LinqPerformance</strong> class, do the following:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">ReadingDataWithoutUsingLet()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void ReadingDataWithoutUsingLet()</p><p class="source-code">{</p><p class="source-code">var result = from person in _people</p><p class="source-code">    where person.LastName.Contains("Omega")</p><p class="source-code">    &amp;&amp; person.FirstName.Equals("Upsilon")</p><p class="source-code">    select person;</p><p class="source-code">}</p></li>
			</ol>
			<p>In this method, we are selecting people from the <strong class="source-inline">_people</strong> list with a last name of <em class="italic">Omega</em>, and a first name of <em class="italic">Upsilon</em> using LINQ without the <strong class="source-inline">let</strong> keyword.</p>
			<ol>
				<li value="2">Now, add the <strong class="source-inline">ReadingDataUsingLet()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void ReadingDataUsingLet()</p><p class="source-code">{</p><p class="source-code">      var result = from person in _people</p><p class="source-code">      let lastName = person.LastName.Contains("Omega")</p><p class="source-code">      let firstName = person.FirstName.Equals("Upsilon")</p><p class="source-code">      where lastName &amp;&amp; firstName</p><p class="source-code">      select person;</p><p class="source-code">}</p></li>
			</ol>
			<p>In this method, we are also selecting people from the <strong class="source-inline">_people</strong> list with a last name of <em class="italic">Omega</em> and a<a id="_idIndexMarker775"/> first name of <em class="italic">Upsilon</em>. But this time, we <a id="_idIndexMarker776"/>use the <strong class="source-inline">let</strong> keyword for both the filters and use them in the <strong class="source-inline">where</strong> clause.</p>
			<ol>
				<li value="3">Build the project and run the executable from the command line. You should see results similar to those shown in <em class="italic">Figure 7.6</em>:</li>
			</ol>
			<div>
				<div id="_idContainer129" class="IMG---Figure">
					<img src="image/B16617_07_06.jpg" alt="Figure 7.6: BenchmarkDotNet results for reading data with and without using the let keyword&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.6: BenchmarkDotNet results for reading data with and without using the let keyword</p>
			<p>As you can see from these results, the use of the <strong class="source-inline">let</strong> keyword in our query reduced the performance. The processing time increased and so did the memory allocation.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">You will see websites that promote the use of the <strong class="source-inline">let</strong> keyword in LINQ queries to improve performance and readability. But as you have seen in the example we have worked through, using the <strong class="source-inline">let</strong> keyword can seriously slow down the performance of your queries and increase memory usage. So, as a rule of thumb, take to measuring your performance for your particular queries and choosing the method that performs best for your query task.</p>
			<p>In this section, we<a id="_idIndexMarker777"/> have seen how the use of the <strong class="source-inline">let</strong> keyword can<a id="_idIndexMarker778"/> increase the time taken and memory used to perform a simple <strong class="source-inline">select</strong> query using LINQ. This performance decrease can become a real problem when working with large volumes of data. In the next section, we will look at several methods for grouping data and see which method performs the best.</p>
			<h1 id="_idParaDest-144"><a id="_idTextAnchor146"/>Increasing Group By performance in LINQ queries</h1>
			<p>In this section, we will look at<a id="_idIndexMarker779"/> three different ways of performing the same <strong class="source-inline">Group By</strong> operation. Each way provides a different <a id="_idIndexMarker780"/>performance level. You will see by the end of this section which method is best for performing fast <strong class="source-inline">Group By</strong> queries. The methods that we add in this section will be added to the <strong class="source-inline">LinqPerformance</strong> class.</p>
			<p>For our scenario, we want to get a list of people from a collection that all share the same name. To extract those people, we will perform a <strong class="source-inline">Group By</strong> operation. Then, we will extract all those for whom the group count is greater than one, and then add them to a list of people. </p>
			<p>Let us add our three methods that use the <strong class="source-inline">GroupBy</strong> clause to return a list of people:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">GroupByVersion1()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void GroupByVersion1()</p><p class="source-code">{</p><p class="source-code">List&lt;Person&gt; People = _people.GroupBy(x =&gt; x.LastName)</p><p class="source-code">              .Where(x =&gt; x.Count() &gt; 1)</p><p class="source-code">              .SelectMany(group =&gt; group)</p><p class="source-code">              .ToList();</p><p class="source-code">}</p></li>
			</ol>
			<p>As you can see, we are <a id="_idIndexMarker781"/>grouping on the person's last name. We then filter the groups to include only those groups with a count greater than <em class="italic">1</em>. Those groups are then selected and <a id="_idIndexMarker782"/>then returned as a list of people. </p>
			<ol>
				<li value="2">Now, add the <strong class="source-inline">GroupByVersion2()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void GroupByVersion2()</p><p class="source-code">{</p><p class="source-code">      IEnumerator&lt;IGrouping&lt;string, Person&gt;&gt; test = </p><p class="source-code">          _people.GroupBy(p =&gt; p.LastName)</p><p class="source-code">    .Where(p =&gt; p.Count() &gt; 2).GetEnumerator();</p><p class="source-code">List&lt;Person&gt; people = new List&lt;Person&gt;();</p><p class="source-code">while (test.MoveNext())</p><p class="source-code">{</p><p class="source-code">    IGrouping&lt;string, Person&gt; current = test.Current;</p><p class="source-code">    foreach (Person person in current)</p><p class="source-code">    {</p><p class="source-code">        people.Add(person);</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>In this method, we obtain an enumerator by grouping people by their last name and then filtering the groups to only include those groups with a count of <em class="italic">2</em> or more. Then we declare a <a id="_idIndexMarker783"/>new list of people. We then loop<a id="_idIndexMarker784"/> through the enumerator and obtain the current <strong class="source-inline">IGrouping&lt;string, Person&gt;</strong>. The grouping is then iterated through, and each person in the group is added to the list of people. </p>
			<ol>
				<li value="3">Add the <strong class="source-inline">GroupByVersion3()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void GroupByVersion3()</p><p class="source-code">{</p><p class="source-code">      IEnumerator&lt;IGrouping&lt;string, Person&gt;&gt; test = </p><p class="source-code">        _people.ToArray().GroupBy(p =&gt; p.LastName)</p><p class="source-code">    .Where(p =&gt; p.Count() &gt; 2).GetEnumerator();</p><p class="source-code">    List&lt;Person&gt; people = new List&lt;Person&gt;();</p><p class="source-code">while (test.MoveNext())</p><p class="source-code">      {</p><p class="source-code">    var current = test.Current;</p><p class="source-code">    foreach (var person in current)</p><p class="source-code">    {</p><p class="source-code">        people.Add(person);</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>The <strong class="source-inline">GroupByVersion3()</strong> method is the same as and behaves the same as the <strong class="source-inline">GroupByVersion2()</strong> method, but with one main difference. We convert the list of people to an array before we perform the <strong class="source-inline">Group By</strong>.</p>
			<ol>
				<li value="4">Add the following<a id="_idIndexMarker785"/> annotations to the top of the <strong class="source-inline">LinqPerformance</strong> class:<p class="source-code">[MemoryDiagnoser]</p><p class="source-code">[Orderer(SummaryOrderPolicy.FastestToSlowest)]</p><p class="source-code">[RankColumn]</p></li>
			</ol>
			<p>These annotations will expand the data contained in the summary report as you will see shortly. Do a <a id="_idIndexMarker786"/>release build of the project and then run the project from the command line to benchmark these three methods. You should see the following benchmark summary report:</p>
			<div>
				<div id="_idContainer130" class="IMG---Figure">
					<img src="image/B16617_07_07.jpg" alt="Figure 7.7: The BenchmarkDotNet Group By summary report&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.7: The BenchmarkDotNet Group By summary report</p>
			<p>As we can see, our first attempt at performing a <strong class="source-inline">Group By</strong> operation takes <em class="italic">2.204</em> microseconds, our second attempt takes <em class="italic">2.011</em> microseconds, and our third and final attempt takes <em class="italic">2.204</em> microseconds. So, we can see that converting our list to an array before performing a <strong class="source-inline">Group By</strong> speeds things up. Our final version is <em class="italic">0.243</em> microseconds faster than our original version, and that is despite the fact that more code is involved!</p>
			<p>The section that follows will <a id="_idIndexMarker787"/>take you through the benchmarking of<a id="_idIndexMarker788"/> five different ways to provide filtering of lists. You will see how the different methods affect the performance of LINQ queries.</p>
			<h1 id="_idParaDest-145"><a id="_idTextAnchor147"/>Filtering lists</h1>
			<p>In this section, we will look at<a id="_idIndexMarker789"/> various ways to filter a list using LINQ. We will see that the various ways all perform differently. By the end of this section, you will know the best way to filter a list for increased performance. You will be writing two different benchmarks that demonstrate query performance differences when using the <strong class="source-inline">let</strong> keyword and not using the <strong class="source-inline">let</strong> keyword. Let's begin writing our benchmarks:</p>
			<ol>
				<li value="1">Add the <strong class="source-inline">FilterGroupsVersion1()</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public List&lt;Person&gt; FilterGroupsVersion1()</p><p class="source-code">{</p><p class="source-code"> return (from p in _people where </p><p class="source-code">             _group1.Contains(p.LastName.ToLower())</p><p class="source-code">             || _group2.Contains(p.LastName.ToLower())</p><p class="source-code">             select p).ToList(</p><p class="source-code">}</p></li>
			</ol>
			<p>The first of our benchmarks filters people that belong to <strong class="source-inline">_group1</strong> and <strong class="source-inline">_group2</strong>. Since the arrays are in lowercase, <strong class="source-inline">LastName</strong> is also converted to lowercase. The filtered people are then returned as a list of people. </p>
			<ol>
				<li value="2">Add the <strong class="source-inline">FilterGroupsVersion2()</strong> benchmark:<p class="source-code">[Benchmark]</p><p class="source-code">public List&lt;Person&gt; FilterGroupsVersion2()</p><p class="source-code">{</p><p class="source-code">      return (from p in _people</p><p class="source-code">          let lastName = p.LastName.ToLower()</p><p class="source-code">          where _group1.Contains(lastName)</p><p class="source-code">          || _group2.Contains(lastName)</p><p class="source-code">          select p).ToList();</p><p class="source-code">}</p></li>
			</ol>
			<p>This does the same as our first benchmark. The main difference is that we introduce the <strong class="source-inline">lastName</strong> variable using the <strong class="source-inline">let</strong> keyword, and assign it the lowercase <strong class="source-inline">LastName</strong> of the person.</p>
			<ol>
				<li value="3">Compile the project in<a id="_idIndexMarker790"/> release mode and run it from the command line. The benchmarks will be generated, and you should see a benchmark report similar to the one in <em class="italic">Figure 7.8</em>:</li>
			</ol>
			<div>
				<div id="_idContainer131" class="IMG---Figure">
					<img src="image/B16617_07_08.jpg" alt="Figure 7.8: Benchmark Report for LINQ with and without using the let keyword&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.8: Benchmark Report for LINQ with and without using the let keyword</p>
			<p>We can see in the summary report that using the <strong class="source-inline">let</strong> keyword slows things down considerably. And so, we will now investigate why the <strong class="source-inline">let</strong> keyword slows things down.</p>
			<ol>
				<li value="4">Open <strong class="bold">ILDASM</strong>, and load in <strong class="source-inline">CH07_LinqPerformance.dll</strong>.</li>
				<li>Expand <strong class="bold">CH07_LinqPerformance</strong> | <strong class="bold">CH07_ Linq.LinqPerformace.LinqPerformance</strong>. You will see the two methods called <strong class="source-inline">FilterGroupsVersion1</strong> and <strong class="source-inline">FilterGroupsVersion2</strong>.</li>
				<li>Double-click on the method <strong class="source-inline">FilterGroupsVersion1</strong> to reveal the intermediate language generated by the compiler.</li>
				<li>Now, do the same<a id="_idIndexMarker791"/> with the <strong class="source-inline">FilterGroupsVersion2</strong> method. When you compare the IL for both methods, you will clearly see that the IL for <strong class="source-inline">FilterGroupsVersion2</strong> contains more lines of code than the IL for <strong class="source-inline">FilterGroupsVersion1</strong>.</li>
			</ol>
			<p>And that explains why the <strong class="source-inline">let</strong> version of the code performs slower than the original code that does not use the <strong class="source-inline">let</strong> keyword. But can we do better than <strong class="source-inline">FilterGroupsVersion1</strong> in terms of performance? Well, it turns out that, yes, we can. </p>
			<ol>
				<li value="8">Add the <strong class="source-inline">FilterGroupsVersion3</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public List&lt;Person&gt; FilterGroupsVersion3()</p><p class="source-code">{</p><p class="source-code">List&lt;Person&gt; people = new List&lt;Person&gt;();</p><p class="source-code">for (int i = 0; i &lt; _people.Count; i++)</p><p class="source-code">{</p><p class="source-code">    var person = _people[i];</p><p class="source-code">    var lastName = person.LastName.ToLower();</p><p class="source-code">    if (</p><p class="source-code">        _group1.Contains(lastName) </p><p class="source-code">        || _group2.Contains(lastName)</p><p class="source-code">    )</p><p class="source-code">    people.Add(person);</p><p class="source-code">}</p><p class="source-code">return people;</p><p class="source-code">}</p></li>
			</ol>
			<p>As you can see, we create a new people list. We then loop through the <strong class="source-inline">_people</strong> list. For each person, we get them from the <strong class="source-inline">_people</strong> list. We then assign the lowercase <a id="_idIndexMarker792"/>form of their name to a local variable. Using this variable, we check to see if either <strong class="source-inline">_group1</strong> or <strong class="source-inline">_group2</strong> contains the names. If they do, then the person is added to the <strong class="source-inline">_people</strong> list. Once the iteration has finished, the <strong class="source-inline">_people</strong> collection is returned.</p>
			<ol>
				<li value="9">Build and run the code again. You should see the following report:</li>
			</ol>
			<div>
				<div id="_idContainer132" class="IMG---Figure">
					<img src="image/B16617_07_09.jpg" alt="Figure 7.9: The BenchmarkDotNet summary report showing FilterGroupsVersion3's performance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.9: The BenchmarkDotNet summary report showing FilterGroupsVersion3's performance</p>
			<p>As you can see, we have three different versions of the code that produce the same output, and each one's execution time is different. Between these three different methods, <strong class="source-inline">FilterGroupsVersion3</strong> is by far the quickest method in achieving the desired result.</p>
			<ol>
				<li value="10">We will have another <a id="_idIndexMarker793"/>go at improving the performance of our LINQ filter query. Add the <strong class="source-inline">FilterGroupsVersion4</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public List&lt;Person&gt; FilterGroupsVersion4()</p><p class="source-code">{</p><p class="source-code">      List&lt;Person&gt; people = new List&lt;Person&gt;();</p><p class="source-code">for (int i = 0; i &lt; _people.Count; i++)</p><p class="source-code">{</p><p class="source-code">    var person = _people[i];</p><p class="source-code">    var lastName = person.LastName.ToLower();</p><p class="source-code">    if (</p><p class="source-code">        _group2.Contains(lastName) </p><p class="source-code">        || _group1.Contains(lastName)</p><p class="source-code">    )</p><p class="source-code">    people.Add(person);</p><p class="source-code">}</p><p class="source-code">return people;</p><p class="source-code">}</p></li>
			</ol>
			<p>It can be seen that the only difference between <strong class="source-inline">FilterGroupsVersion3</strong> and <strong class="source-inline">FilterGroupsVersion4</strong> is the ordering of the <strong class="source-inline">if</strong> condition check. </p>
			<ol>
				<li value="11">Build the project and run the benchmark tests. <em class="italic">Figure 7.10</em> shows the performance summary:</li>
			</ol>
			<div>
				<div id="_idContainer133" class="IMG---Figure">
					<img src="image/B16617_07_10.jpg" alt="Figure 7.10: The BenchmarkDotNet summary report showing FilterGroupsVersion4's performance&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.10: The BenchmarkDotNet summary report showing FilterGroupsVersion4's performance</p>
			<p>It is clear from the benchmark report that version 4 of our filter is the winning method in terms of performance. So, why is version 4 better than version 3? The <strong class="source-inline">_group2</strong> array contains fewer items than <strong class="source-inline">_group1</strong>. If you understand the business domain, you will be able to order<a id="_idIndexMarker794"/> the filter checks in such a way that the arrays with fewer items will be checked first. </p>
			<p>You have seen how using the <strong class="source-inline">let</strong> keyword slows things down. But you have also seen how the ordering of checks in a conditional statement can also have an impact on performance. Placing the check with the least elements first within a conditional check statement will improve performance.</p>
			<p>In the next section, we will look at closures in LINQ statements and how they affect query performance.</p>
			<h1 id="_idParaDest-146"><a id="_idTextAnchor148"/>Understanding closures</h1>
			<p>In this section, we will understand closures from a C# perspective, and apply them to LINQ queries. Let's start with the<a id="_idIndexMarker795"/> definition of computer programming closures according to the content on Wikipedia.</p>
			<p class="author-quote">Wikipedia: "In programming languages, a closure, also lexical closure or function closure, is a technique for implementing lexically scoped name binding in a language with first-class functions. </p>
			<p class="author-quote">Operationally, a closure is a record storing a function together with an environment. </p>
			<p class="author-quote">The environment is a mapping associating each free variable of the function (variables that are used locally but defined in an enclosing scope) with the value or reference to which the name was bound when the closure was created.</p>
			<p class="author-quote">Unlike a plain function, a closure allows the function to access those captured variables through the closure's copies of their values or references, even when the function is invoked outside their scope."</p>
			<p>To understand what's being said here, we will begin by understanding what first-class functions are.</p>
			<p>A first-class function is a method that is treated by C# as a first-class data type. This means that you can assign a method to a variable and pass it around, and you can invoke it as you would a normal method. First-class functions can be created using anonymous methods<a id="_idIndexMarker796"/> and lambdas.</p>
			<p>Free variables are variables that are not parameter variables to a method, and they are variables that are not local to that method, which, in plain English, means that they are variables that exist outside of a method, but are being referenced within a method's closing scope.</p>
			<p>We are going to apply closures to a LINQ expression and benchmark them. The first one will be using LINQ with a closure that takes parameters, and the second one will be using LINQ with a closure that uses free variables. Follow these steps:</p>
			<ol>
				<li value="1">In the <strong class="source-inline">LinqPerformance</strong> class, comment out the current <strong class="source-inline">[Benchmark]</strong> annotated methods.</li>
				<li>Add the <strong class="source-inline">LinqClosureUsingParameters</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void LinqClosureUsingParameters()</p><p class="source-code">{           Func&lt;string, char, char, bool&gt; Between()</p><p class="source-code">       {</p><p class="source-code">             Func&lt;string, char, char, bool&gt; IsBetween </p><p class="source-code">                   = delegate (</p><p class="source-code">              string param1, char param2, char param3)</p><p class="source-code">             {</p><p class="source-code">                 var character = param1[0];</p><p class="source-code">                   return (</p><p class="source-code">                         (character &gt;= param2) </p><p class="source-code">                         &amp;&amp; (character &lt;= param3)</p><p class="source-code">                   );</p><p class="source-code">             };</p><p class="source-code">             return IsBetween;</p><p class="source-code">       }</p><p class="source-code">       var IsBetween = Between();</p><p class="source-code">       var data = (from p in _people.ToList()</p><p class="source-code">                where IsBetween(p.LastName, 'A', 'G')</p><p class="source-code">                  select p).ToList();</p><p class="source-code">}</p></li>
			</ol>
			<p>In the <strong class="source-inline">LinqClosureUsingParameters</strong> method, we declare closure using a delegate with parameters. We declare a variable called <strong class="source-inline">IsBetween</strong> and assign the <strong class="source-inline">Between</strong> method to it. Then<a id="_idIndexMarker797"/> we perform a LINQ query and filter the results by calling <strong class="source-inline">IsBetween</strong>. The result is that we will have only those people whose last name's first letters are between A and G.</p>
			<ol>
				<li value="3">We can also use free variables. So, let us now look at a different example that uses free variables. Add the <strong class="source-inline">LinqClosureUsingVariables</strong> method:<p class="source-code">[Benchmark]</p><p class="source-code">public void LinqClosureUsingVariables()</p><p class="source-code">{</p><p class="source-code">Func&lt;string, bool&gt; Between()</p><p class="source-code">       {</p><p class="source-code">                 char first = 'A';</p><p class="source-code">           char last = 'G';</p><p class="source-code">           Func&lt;string, bool&gt; IsBetweenAG = delegate </p><p class="source-code">               (string param1)</p><p class="source-code">           {</p><p class="source-code">                 var character = param1[0];</p><p class="source-code">                return ((character &gt;= first) &amp;&amp; </p><p class="source-code">                    (character &lt;= last));</p><p class="source-code">             };</p><p class="source-code">             return IsBetweenAG;</p><p class="source-code">       }</p><p class="source-code">       var IsBetweenAG = Between();</p><p class="source-code">       var data = (from p in _people.ToList()</p><p class="source-code">                   where IsBetweenAG(p.LastName)</p><p class="source-code">                    select p).ToList();</p><p class="source-code">}</p></li>
			</ol>
			<p>In the <strong class="source-inline">LinqClosureUsingVariables</strong> method, we declare our closure using free variables to declare the first and last characters used for filtering the dataset. We then <a id="_idIndexMarker798"/>assign the <strong class="source-inline">Between</strong> method to the <strong class="source-inline">IsBetweenAG</strong> variable. Then, we perform a LINQ query and filter the results by passing in the last name of each individual into the <strong class="source-inline">IsBetweenAG</strong> method.</p>
			<ol>
				<li value="4">Add a method called <strong class="source-inline">NonLinqFilter</strong>:<p class="source-code">[Benchmark]</p><p class="source-code">public void NonLinqFilter()</p><p class="source-code">{</p><p class="source-code">       var data = _people.FindAll(</p><p class="source-code">       x =&gt; x.LastName[0] &gt;= 'A' &amp;&amp; x.LastName[0] </p><p class="source-code">           &lt;= 'G');</p><p class="source-code">}</p></li>
			</ol>
			<p>In this method, we simply filter a list using its own <strong class="source-inline">FindAll</strong> method.</p>
			<ol>
				<li value="5">Make sure you are in Release<a id="_idIndexMarker799"/> mode and then run your project. You should end up with results similar to those in the following screenshot:</li>
			</ol>
			<div>
				<div id="_idContainer134" class="IMG---Figure">
					<img src="image/B16617_07_11.jpg" alt="Figure 7.11: Closure benchmarks with and without parameters&#13;&#10;"/>
				</div>
			</div>
			<p class="figure-caption">Figure 7.11: Closure benchmarks with and without parameters</p>
			<p>As we can clearly see in the benchmarks of <em class="italic">Figure 7.11</em>, closures with parameters are faster and allocate less memory than closures without parameters. But it is far better to use a list's own <strong class="source-inline">FindAll</strong> method for filtering as it is faster and uses less allocated memory than LINQ and closures.</p>
			<p>A situation when you may need to apply your own custom closures for use in LINQ queries is when you have complex data manipulation and query generation that cannot be dealt with easily with normal LINQ. In this case, closures would be of benefit to you. Having performed the benchmarking of closures, you now know to use closures with parameters for optimal performance when using LINQ. But if you don't need to use LINQ, then using a list's own methods may be more advantageous. And if you do have to work on lists, then it could pay to do the filtering of the dataset using non-LINQ methods first, then perform your<a id="_idIndexMarker800"/> LINQ queries on the filtered lists.</p>
			<p>This chapter is now complete. But before we move on to <a href="B16617_08_Final_SB_Epub.xhtml#_idTextAnchor152"><em class="italic">Chapter 8</em></a>, <em class="italic">File and Stream I/O</em>, let us summarize what we have learned in this chapter.</p>
			<h1 id="_idParaDest-147"><a id="_idTextAnchor149"/>Summary</h1>
			<p>In this chapter, we studied LINQ performance by benchmarking a variety of ways to query, group, filter, and iterate data obtained from databases and in-memory collections. The most performant way to query a database was found to be using the <strong class="source-inline">IEnumerator</strong> interface. By disassembling code, we saw that the <strong class="source-inline">let</strong> keyword can degrade performance due to the extra lines of IL code produced by the compiler. We also saw how accessing the last element in a collection using its index is faster than calling the <strong class="source-inline">Last()</strong> method. And we also learned that filtering lists by filtering on objects with the least items first improves filter performance operations. Closures provided better overall performance when passing in parameters, compared to not passing in parameters.</p>
			<p>In the next chapter, we will be looking at file and stream I/O performance. But for now, see if you can answer the following questions, and check out the further reading material to solidify what you have learned in this chapter.</p>
			<h1 id="_idParaDest-148"><a id="_idTextAnchor150"/>Questions</h1>
			<ol>
				<li value="1">Name some ways to improve LINQ performance.</li>
				<li>What is wrong with using the <strong class="source-inline">let</strong> keyword in a LINQ query?</li>
				<li>What is the best way to improve the performance of a <strong class="source-inline">Group By</strong> query?</li>
				<li>What performs better, closures with parameters, or closures without parameters?</li>
			</ol>
			<h1 id="_idParaDest-149"><a id="_idTextAnchor151"/>Further reading</h1>
			<ul>
				<li><strong class="bold">Console User Secrets</strong>: <a href="https://github.com/jasonshave/ConsoleSecrets">https://github.com/jasonshave/ConsoleSecrets</a>.</li>
				<li><strong class="bold">Optimising LINQ</strong>: <a href="https://mattwarren.org/2016/09/29/Optimising-LINQ/&#13;">https://mattwarren.org/2016/09/29/Optimising-LINQ/</a></li>
				<li><strong class="bold">Five Tips to Improve LINQ to SQL Performance</strong>: <a href="https://visualstudiomagazine.com/articles/2010/06/24/five-tips-linq-to-sql.aspx">https://visualstudiomagazine.com/articles/2010/06/24/five-tips-linq-to-sql.aspx</a>.</li>
				<li><strong class="bold">Make your C# applications faster with LINQ joins</strong>: <a href="https://timdeschryver.dev/blog/make-your-csharp-applications-faster-with-linq-joins">https://timdeschryver.dev/blog/make-your-csharp-applications-faster-with-linq-joins</a>.</li>
				<li><strong class="bold">LINQ Stinks – code smells in your LINQ</strong>: <a href="https://markheath.net/post/linq-stinks">https://markheath.net/post/linq-stinks</a>.</li>
				<li><strong class="bold">How to get a value out of a Span&lt;T&gt; with Linq expression trees?</strong>: <a href="https://stackoverflow.com/questions/52112628/how-to-get-a-value-out-of-a-spant-with-linq-expression-trees">https://stackoverflow.com/questions/52112628/how-to-get-a-value-out-of-a-spant-with-linq-expression-trees</a>.</li>
				<li><strong class="bold">Linq ToLookup Method in C#</strong>: <a href="https://dotnettutorials.net/lesson/linq-tolookup-operator/">https://dotnettutorials.net/lesson/linq-tolookup-operator/</a>.</li>
				<li><strong class="bold">LINQ (C#) – ToLookup Operator Example And Tutorial</strong>: <a href="https://www.completecsharptutorial.com/linqtutorial/tolookup-operator-example-csharp-linq-tutorial.php">https://www.completecsharptutorial.com/linqtutorial/tolookup-operator-example-csharp-linq-tutorial.php</a>.</li>
				<li><strong class="bold">A Simple Explanation of C# Closures</strong>: <a href="https://www.simplethread.com/c-closures-explained/">https://www.simplethread.com/c-closures-explained/</a>.</li>
			</ul>
		</div>
	</body></html>