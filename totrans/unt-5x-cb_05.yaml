- en: Chapter 5. Using Cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a picture-in-picture effect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching between multiple cameras
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making textures from screen content
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zooming a telescopic camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Displaying a mini-map
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating an in-game surveillance camera
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As developers, we should never forget to pay attention to the cameras. After
    all, they are the windows through which our players see our games. In this chapter,
    we will take a look at interesting ways of using cameras that enhance the player's
    experience.
  prefs: []
  type: TYPE_NORMAL
- en: The big picture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Cameras can be customized in many ways:'
  prefs: []
  type: TYPE_NORMAL
- en: They can exclude objects on specific layers from rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be set to render in **Orthographic** mode (that is, without perspective)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can have their **Field of View** (**FOV**) manipulated to simulate a wide
    angle lens
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be rendered on top of other cameras or within specific areas of the
    screen
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: They can be rendered onto Textures
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The list goes on.
  prefs: []
  type: TYPE_NORMAL
- en: '![The big picture](img/1362OT_05_00.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Two simultaneous camera views
  prefs: []
  type: TYPE_NORMAL
- en: Note that throughout this chapter you will notice that some recipes feature
    a camera rig that follows the player's third-person character. That rig is the
    **Multipurpose Camera Rig**, originally available from Unity's sample assets,
    which can be imported into your projects by navigating to **Assets** | **Import
    Package** | **Camera**. To make things easier, we organized the `MultipurposeCamera`
    Unity Package containing it as a prefab, which can be found in the `1362_05_codes`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a picture-in-picture effect
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Having more than one viewport displayed can be useful in many situations. For
    example, you may want to show simultaneous events going on in different locations,
    or you may want to have a separate window for hot-seat multiplayer games. Although
    you can do this manually by adjusting the **Normalized Viewport Rect** parameters
    on your camera, this recipe includes a series of extra preferences to make it
    more independent from the user's display configuration.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the `BasicScene` Unity package, containing
    a scene named `BasicScene`. The package is in the `1362_05_codes` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a picture-in-picture display, just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `BasicScene` package into your Unity Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, open the **BasicScene** level. This is a basic scene
    featuring an animated character and some extra geometry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new **Camera** to the scene through the **Create** drop-down menu on top
    of the **Hierarchy** view (**Create** | **Camera**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the camera you have created and, from the **Inspector** view, change
    its **Depth** to **1**, as shown in the following screenshot:![How to do it...](img/1362OT_05_01.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, create a new **C# Script** file and rename it `PictureInPicture`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your script and replace everything with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: In case you haven't noticed, we are not achieving percentages by dividing numbers
    by 100, but rather multiplying them by 0.01\. The reason behind this is that computer
    processors are faster at multiplying than dividing.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save your script and attach it to the camera you previously created.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Uncheck the new camera''s **Audio Listener** component and change some of the
    **PictureInPicture** parameters: change **Hor Align** to `right`, **Ver Align**
    to `top`, and **Unit** to `pixels`. Leave **XOffset** and **YOffset** as `0`,
    change **Width** to `400` and **Height** to `200`, as shown here:![How to do it...](img/1362OT_05_02.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your scene. The new camera's viewport should be visible in the top-right
    corner of the screen, as shown below:![How to do it...](img/1362OT_05_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this example, we added a second camera in order to display the scene from
    a different point of view. The second camera's relative viewport was originally
    placed on top of the **Main Camera**'s viewport, hence taking up all of the screen
    space.
  prefs: []
  type: TYPE_NORMAL
- en: The `PictureInPicture` script changes the camera's **Normalized Viewport Rect**,
    thus resizing and positioning the viewport according to the user's preferences.
  prefs: []
  type: TYPE_NORMAL
- en: First, it reads user preferences for the component (dimensions, alignment, and
    offset for the PiP viewport) and converts dimensions in screen percentage to pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Later, from the `if(unit == UnitsIn.screen_percentage){` conditional, the script
    calculates two of the viewport Rect parameters (width and height) according to
    the user's selection.
  prefs: []
  type: TYPE_NORMAL
- en: Later on, to **switch** statements to adjust the other two viewport Rect parameters
    (horizontal and vertical location) according to the total screen dimensions, PiP
    viewport dimension, vertical/horizontal alignment, and offset.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, a line of code tells the camera to change the location and dimensions
    of the camera''s **Viewport Rect**:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following are some aspects of your picture-in-picture that you could change:'
  prefs: []
  type: TYPE_NORMAL
- en: Making the picture-in-picture proportional to the screen's size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you change the **Unit** option to `screen_percentage`, the viewport size
    will be based on the actual screen's dimensions instead of pixels.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the position of the picture-in-picture
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Ver Align** and **Hor Align** options can be used to change the viewport's
    vertical and horizontal alignment. Use them to place it where you wish.
  prefs: []
  type: TYPE_NORMAL
- en: Preventing the picture-in-picture from updating on every frame
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Leave the **Update** option unchecked if you don't plan to change the viewport
    position in running mode. Also, it's a good idea to leave it checked when testing
    and uncheck it once the position has been decided and set up.
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Displaying a mini-map* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Switching between multiple cameras
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Choosing from a variety of cameras is a common feature in many genres: racing,
    sports, tycoon/strategy, and many others. In this recipe, you will learn how to
    give players the ability to choose from many cameras by using their keyboards.'
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the `BasicScene` Unity package containing
    a scene named `BasicScene`. The package is in the `1362_05_codes` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To implement switchable cameras, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `BasicScene` package into a new **Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, open the **BasicScene** level. This is a basic scene
    featuring an animated character and some extra geometry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add two more cameras to the scene through the **Create** drop-down menu on top
    of the **Hierarchy** view (**Create** | **Camera**). Rename them `cam1` and `cam2`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `cam2` camera's position and rotation so that it won't be identical
    to `cam1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an **Empty** GameObject by navigating to the **Create** drop-down menu
    on top of the **Hierarchy** view (**Create** | **Create Empty**). Then, rename
    it `Switchboard`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Inspector** view, disable the **Camera** and **Audio Listener** components
    of both `cam1` and `cam2`. Also, set their **Tags** as **MainCamera**, as shown:![How
    to do it...](img/1362OT_05_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, create a new **C# Script** file. Rename it `CameraSwitch`
    and open it in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your script and replace everything with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Attach `CameraSwitch` to the `Switchboard` GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Inspector** view, set both the **Cameras** and **Shortcuts** sizes
    to `3`. Then, drag and populate the **Cameras** slots with the cameras from the
    scene (including the **Main Camera**, within the **Multipurpose Camera Rig** |
    **Pivot** GameObject) Then, type `1`, `2`, and `3` into the **Shortcuts** text
    fields, as shown in the next screenshot:![How to do it...](img/1362OT_05_05.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your scene and test your cameras by pressing *1*, *2*, and *3* on the keyboard.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The script is very straightforward. First, it compares the key being pressed
    to the list of shortcuts. If the key is indeed included on a list of shortcuts,
    it is passed on to the `SwitchCamera` function, which, in turn, goes through a
    list of cameras, enables the one associated with the shortcut that was received,
    and also enables its **Audio Listener**, in case the **Change Audio Listener**
    option is checked.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Here are some ideas about how you could try twisting this recipe a bit.
  prefs: []
  type: TYPE_NORMAL
- en: Using a single-enabled camera
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A different approach to the problem would be keeping all secondary cameras disabled
    and assigning their position and rotation to the main camera via a script (you
    would need to make a copy of the main camera and add it to the list, in case you
    wanted to save its **Transform** settings).
  prefs: []
  type: TYPE_NORMAL
- en: Triggering the switch from other events
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Also, you can change your camera from other GameObjects'' scripts by using
    a line of code such as the one given here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The *Creating an in-game surveillance camera* recipe in this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Making textures from screen content
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you want your game or player to take in-game snapshots and apply them as
    textures, this recipe will show you how. This can be very useful if you plan to
    implement an in-game photo gallery or display a snapshot of a past key moment
    at the end of a level (racing games and stunt simulations use this feature a lot).
    For this particular example, we will take a snapshot from within a framed region
    of the screen and print it on the top-right corner of the display.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the `BasicScene` Unity package, containing
    a scene named `BasicScene`. The package is in the `1362_05_codes` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create textures from screen content, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `BasicScene` package into a new **Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, open the **BasicScene** level. This is a basic scene
    featuring an animated character and some extra geometry. It also features a **Canvas**
    for UI elements.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an **UI Image** GameObject from the **Create** drop-down menu on top
    of the **Hierarchy** view (**Create** | **UI** | **Image**). Please note that
    it will be created as a child of the **Canvas** GameObject. Then, rename it `frame`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Inspector** view, find the **Image (Script)** component of the **frame**
    GameObject and set `InputFieldBackground` as its **Source Image**. This is a sprite
    that comes bundled with Unity, and it's already sliced for resizing purposes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, from the **Inspector** view, change **Rect Transform** to the following
    values: **Anchors** | **Min** | **X**: `0.25`, **Y**: `0.25`; **Anchors** | **Max**
    | **X**: `0.75`, **Y**: `0.75`; **Pivot** | **X**: `0.5`, **Y**: `0.5;` **Left**:
    `0`; **Top**: `0`; **Pos Z**: `0`; **Right**: `0`; **Bottom**: `0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Image (Script)** component, uncheck the **Fill Center** option, as
    shown below:![How to do it...](img/1362OT_05_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an **UI Raw Image** GameObject from the **Create** drop-down menu on
    top of the **Hierarchy** view (**Create** | **UI** | **RawImage**). Please note
    that it will be created as a child of the **Canvas** GameObject. Then, rename
    it `Photo`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Inspector** view, find the **Raw Image (Script)** component of the
    **Photo** GameObject and set `None` as its **Texture**. Also, from the top of
    the **Inspector** view, disable the **Photo** GameObject by unchecking the box
    on the side of its name.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, from the **Inspector** view, change the **Rect Transform** to the following
    values: **Width**: `1`; **Height**: `1`; **Anchors** | **Min** | **X**: `0`, **Y**:
    `1`; **Anchors** | **Max** | **X**: `0`, **Y**: `1`; **Pivot** | **X**: `0`, **Y**:
    `1`; **Pos X**: `0`; **Pos Y**: `0`; **Pos Z**: `0` as shown in the following
    screenshot:![How to do it...](img/1362OT_05_07.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to create a script. In the **Project** view, click on the **Create**
    drop-down menu and choose **C# Script**. Rename it `ScreenTexture` and open it
    in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your script and replace everything with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your script and apply it to the **Main Camera** GameObject within the **Multipurpose
    Camera Rig** | **Pivot** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Inspector** view, find the **Screen Texture** component and populate
    the fields **Photo GUI** and **Frame GUI** with the GameObjects **Photo** and
    **frame** respectively:![How to do it...](img/1362OT_05_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the scene. You will be able to take a snapshot of the screen (and have
    it displayed in the top-left corner at a quarter of the original size) by clicking
    the mouse button, as shown in the following screenshot:![How to do it...](img/1362OT_05_09.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we created a GUI frame from which to take a snapshot and a GUI element
    onto which to apply the texture. Then, we applied a script to the **Main Camera**
    to capture the screen content and apply a new texture to it.
  prefs: []
  type: TYPE_NORMAL
- en: The script creates a new texture and captures the left mouse button being pressed,
    whereupon it starts a coroutine to calculate a Rect area, copy screen pixels from
    that area, and apply them to a texture to be displayed by the **photo** GUI element,
    which is also resized to fit the texture.
  prefs: []
  type: TYPE_NORMAL
- en: The size of the Rect is calculated from the screen's dimensions and the frame's
    **Rect Transform** settings, particularly its Pivot, Anchors, Width, and Height.
    The screen pixels are then captured by the `ReadPixels()` command, and applied
    to the texture, which is then applied to the **Raw Image** photo, which is resized
    to meet the desired ratio between the photo size and the original pixels.
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Apart from displaying the texture as a GUI element, you can use it in other
    ways.
  prefs: []
  type: TYPE_NORMAL
- en: Applying your texture to a material
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can apply your texture to an existing object's material by adding a line
    similar to `GameObject.Find("MyObject").renderer.material.mainTexture = texture;`
    to the end of the `CaptureScreen` function.
  prefs: []
  type: TYPE_NORMAL
- en: Using your texture as a screenshot
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can encode your texture as a PNG image file and save it. Check out Unity's
    documentation on this feature at [http://docs.unity3d.com/Documentation/ScriptReference/Texture2D.EncodeToPNG.html](http://docs.unity3d.com/Documentation/ScriptReference/Texture2D.EncodeToPNG.html).
  prefs: []
  type: TYPE_NORMAL
- en: See also
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Saving screenshots from the game recipe in Chapter 10, Working with the
    External Resource Files and Devices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Zooming a telescopic camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this recipe, we will create a telescopic camera that zooms in whenever the
    left mouse button is pressed. This can be very useful, for instance, if we have
    a sniper in our game.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the `BasicScene` Unity package, containing
    a scene named `BasicScene`. The package is in the `1362_05_codes` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a telescopic camera, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `BasicScene` package into a new **Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, open the **BasicScene** level. This is a basic scene
    featuring an animated character and some extra geometry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Import Unity's **Effects** package by navigating to **Assets** | **Import Package**
    | **Effects.**
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Main Camera** GameObject within the **Multipurpose Camera Rig**
    | **Pivot** GameObject and apply the **Vignette** image effect (by navigating
    to **Component** | **Image Effects** | **Camera** | **Vignette and Chromatic Aberration**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need to create a script. In the **Project** view, click on the **Create**
    drop-down menu and choose **C# Script**. Rename it `TelescopicView` and open it
    in your editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open your script and replace everything with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Save your script and apply it to the **Main Camera** GameObject within the **Multipurpose
    Camera Rig** | **Pivot** GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play the level. You should see an animated vignette effect in addition to the
    zooming:![How to do it...](img/1362OT_05_10.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The zooming effect is actually caused by changes to the value of the camera's
    **Field Of View** (**FOV**) property; small values result in closer views of a
    smaller area, while high values enlarge the FOV.
  prefs: []
  type: TYPE_NORMAL
- en: The `TelescopicView` script changes the camera's field of view by subtracting
    from it whenever the left mouse button is pressed. It also adds to the FOV value
    when the mouse button is *not* being held, until it reaches its original value.
  prefs: []
  type: TYPE_NORMAL
- en: 'The zoom limit of the FOV can be deduced from the code `minFov = initFov /
    zoom;`. This means that the minimum value of the FOV is equal to its original
    value divided by the zoom amount. For instance, if our camera features, originally,
    a FOV of `60`, and we set the **Telescopic View Zoom** amount to `2.0`, the minimum
    FOV allowed will be `60/2 = 30`. The difference is shown in the following two
    screenshots:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works...](img/1362OT_05_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can also add a variable to control the **Blur Vignette** level of the **Vignette**
    image effect.
  prefs: []
  type: TYPE_NORMAL
- en: Displaying a mini-map
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In many games, a broader view of the scene can be invaluable for navigation
    and information. Mini-maps are great for giving players that extra perspective
    that they may need when in first- or third-person mode.
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the `BasicScene` Unity Package, containing
    a scene named `BasicScene`. You will also need to import three image files named
    `Compass.png, compassMarker.png`, and `compassMask.png`. All files are available
    in the `1362_05_05` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a mini-map, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `BasicScene` package into a new **Project**. Also, import the provided
    `png` files. Open the **BasicScene** level.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, select the `Compass`, `compassMarker`, and `compassMask`
    texture files. Then, from the **Inspector**, change their **Texture Type** to
    **Sprite (2D and UI)**, leaving the **Sprite Mode** as **Single** and the **Pivot**
    at **Center**. Click on **Apply** to confirm the changes, as shown in the following
    screenshot:![How to do it...](img/1362OT_05_12.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** view, create a new **UI Panel** object (**Create** |
    **UI** | **Panel**). It will be created as a child of the UI **Canvas** GameObject.
    Rename it `MiniMap`. Then, from the **Inspector** view, set its alignment to **Top/Right**,
    change both the **Width** and **Height** to `256`, and its **Pos X** and **Pos
    Y** fields to `-128`. Also, populate the **Source Image** field, within the **Image**
    component, with the **compassMask** sprite, adjusting the **Color** field by bringing
    **Alpha** up to `255`, as shown in the following screenshot:![How to do it...](img/1362OT_05_13.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a **Mask** component to **MiniMap** (from the main menu, select **Component**
    | **UI** | **Mask**). Then, from the **Inspector** view, find the **Mask** component
    and uncheck **Show Mask Graphic** (it will become invisible, serving as a mask
    for the mini-map).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **MsLaser** GameObject (which is the player's character), and, from
    the top of the **Inspector** view, access the **Layer** drop-down menu. Select
    **Add Layer…** and then name a **User Layer** `Player`, as shown in the following
    screenshot:![How to do it...](img/1362OT_05_14.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **MsLaser** character again, and, from the **Layer** drop-down menu,
    select **Player**:![How to do it...](img/1362OT_05_15.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, create a new **Render Texture** and name it `Map_Render`.
    Then, from **Inspector**, change its size to `256 x 256`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Hierarchy** view, create a new camera (**Create** | **Camera**)
    and rename it `MapCamera`. From the **Inspector** view, change its parameters
    as follows (shown in the screenshot that will follow):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Clear Flags**: `Depth Only`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Culling Mask**: `Mixed…` (unselect **Player**)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Projection**: `Orthographic`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Depth**: `1` (or higher)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Target Texture**: `Map_Render`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Also, uncheck the camera's **Audio Listener** component
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1362OT_05_16.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: From the **Hierarchy** view, right-click on **MiniMap** and navigate to **UI**
    | **Raw Image** to create a child UI element. Name it `MapTexture`. Then, from
    the **Inspector** view, populate the **Texture** field with the `Map_Render` texture
    and click on the **Set Native Size** button, as shown in the following screenshot:![How
    to do it...](img/1362OT_05_17.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, right-click on **MiniMap** and navigate to **UI** | **Image** to create
    another child element. Name it `Compass`. Then, from the **Inspector** view, populate
    the **Source Image** field with the `Compass` image and click on the **Set Native
    Size** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Once again, right-click on **MiniMap** and navigate to **UI** | **Image** to
    add another child element. Name it `Marker`. Then, from the **Inspector** view,
    populate the **Source Image** field with the `compassMarker` image and click on
    the **Set Native Size** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Project** view, create a new **C# Script** and name it `MiniMap`.
    Open it and replace everything with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Save the script and attach it to **MapCamera**. Then, from the **Inspector**
    view, change the parameters of the **Mini Map** component as follows (shown in
    the screenshot that will follow):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Target**: `MsLaser`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Marker**: `Marker` (the UI element previously created)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Map GUI**: `MiniMap` (the UI panel previously created)'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Height**: `10`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Distance**: `10`'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Rotate**: Checked'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '![How to do it...](img/1362OT_05_18.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Play the scene. You should be able to see the mini-map functioning in the top-right
    corner of the screen:![How to do it...](img/1362OT_05_19.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The main element of the mini-map is a texture, used as a GUI element, rendered
    from an orthographic camera that follows the player from a top-down perspective.
    Some necessary adjustments were made to **MapCamera**:'
  prefs: []
  type: TYPE_NORMAL
- en: Changing its **Projection** mode to **Orthographic** (to make it two-dimensional)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Excluding the **Player** tag from its **Culling Mask** (to make the character's
    model invisible to the camera)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Disabling its **Audio Listener** (so it won't conflict with the main camera)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The mini-map was embellished with a compass frame and a marker indicating the
    player''s position. All these GUI elements were parented by a **Panel** that also
    functioned as a **Mask** to the visual elements. Finally, a script was created,
    serving three purposes: configuring preferences for the **Camera** (such as the
    area covered), repositioning the **Camera** at runtime according to the player''s
    transform settings, and rotating the appropriate UI elements.'
  prefs: []
  type: TYPE_NORMAL
- en: There's more...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you want to experiment more with your mini-map, read on.
  prefs: []
  type: TYPE_NORMAL
- en: Covering a wider or narrower area
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The range of the mini-map is given by the **Distance** parameter. A higher value
    will result in coverage of a wider area, as the **MiniMap** class uses the same
    value as the viewport size of the orthographic camera.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the map's orientation
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The mini-map, by default, is set to rotate as the player changes direction.
    Should you want it to be static, uncheck the **Rotate** option to make the **Marker**
    rotate instead.
  prefs: []
  type: TYPE_NORMAL
- en: Adapting your mini-map to other styles
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can easily modify this recipe to make a top or isometric view of a racing
    game circuit map. Just position the camera manually and prevent it from following
    the character.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an in-game surveillance camera
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Although using a second viewport can be useful in many situations, there will
    be times when you need to output the image rendered from a camera to a texture
    at runtime. To illustrate this point, in this recipe, we will make use of **Render
    Texture** to create an in-game surveillance camera that transmits its video to
    a monitor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating an in-game surveillance camera](img/1362OT_05_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: In-game surveillance cameras
  prefs: []
  type: TYPE_NORMAL
- en: Getting ready
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: For this recipe, we have prepared the `BasicScene` Unity package, containing
    a scene named `BasicScene`, and also two FBX 3D models for the monitor and camera
    objects. The package is in the `1362_05_codes` folder, and the 3D models are in
    the `1362_05_06` folder.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create a picture-in-picture display, just follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `BasicScene` package and the `monitor` and `camera` models into your
    Unity Project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Project** view, open the **BasicScene** level. This is a basic scene
    featuring an animated character and some extra geometry.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'From the **Project** view, place the **monitor** and **camera** objects into
    the scene by dragging them into the **Hierarchy** panel. Their **Transform** settings
    should be (shown in the following screenshot): **monitor**: **Position**: **X**:
    `0`; **Y**: `0.09`; **Z**: `4`. **Rotation**: **X**: `0`; **Y**: `180`; **Z**:
    `0`. **camera**: **Position**: **X**: `-3`; **Y**: `0.06`; **Z**: `4`. **Rotation**:
    **X**: `0`; **Y**: `90`; **Z**: `0`:![How to do it...](img/1362OT_05_20.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create, from the **Project** view, a new **Render Texture**, and rename it `screen`.
    Then, from the **Inspector** view, change its **Size** to `512` x `512`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new **Camera** to the scene through the **Create** drop-down menu on
    top of the **Hierarchy** view (**Create** | **Camera**). Then, from the **Inspector**
    view, name it `Surveillance` and make it a child of the **camera** GameObject.
    Then, change its **Transform** settings to the following: **Position**: **X**:
    `0`; **Y**: `2`; **Z**: `0`, and **Rotation**: **X**: `0`; **Y**: `0`; **Z**:
    `0`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the `Surveillance` camera you have created, and, from the **Inspector**
    view, change its **Clipping Planes** | **Near** to `0.6`. Also, populate the **Target
    Texture** slot with the **Render Texture** screen and disable the camera's **Audio
    Listener** component, as shown in the following screenshot:![How to do it...](img/1362OT_05_21.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** view, expand the **monitor** object and select its **screen**
    child. Then, from the **Inspector**, find its material (named **Desert**), and,
    from the **Shader** drop-down menu, change itto **Unlit/Texture**. Finally, set
    the **screen** texture as its base texture, as shown in the following screenshot:![How
    to do it...](img/1362OT_05_22.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now it's time to add some post-processing to the texture. From the main menu,
    import the **Effects** package (**Assets** | **Import Package** | **Effects**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the **Hierarchy** view, select the `Surveillance` camera. Then, from the
    main menu, add the **Grayscale** image effect component (**Component** | **Image
    Effects** | **Color Adjustments** | **Grayscale**). Also, add the **Noise And
    Grain** image effect (**Component** | **Image Effects** | **Noise** | **Noise
    and Grain (Filmic)**). Finally, from the **Inspector** view, set the **Intensity
    Multiplier** of the **Noise And Grain** to `4`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Play your scene. You should be able to see your actions in real time on the
    monitor's screen, as shown here:![How to do it...](img/1362OT_05_23.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works...
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We achieved the final result by using the surveillance camera as source for
    the **Render Texture** applied to the **screen**. The camera was made a child
    of the camera's 3D model for easier relocation. Also, its **Near Clipping** plane
    was readjusted in order to avoid displaying parts of the camera's 3D model geometry,
    and its **Audio Source** component was disabled so that it wouldn't clash with
    the main camera's component.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to setting up the surveillance camera, two **Image Effects** were
    added to it: **Noise And Grain** and **Greyscale**. Together, these effects should
    make **Render Texture** look more like a cheap monitor''s screen.'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, our **screen** render texture was applied to the screen's 3D object's
    material (which had its shader changed to **Unlit/texture** so it could be seen
    in low/no light conditions, like a real monitor).
  prefs: []
  type: TYPE_NORMAL
