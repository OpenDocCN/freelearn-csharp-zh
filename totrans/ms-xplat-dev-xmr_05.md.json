["```cs\nslsvcutil http://localhost/ ReferenceService.svc /d:c:\\bin\\\n\n```", "```cs\n[OperationContract (AsyncPattern=true, Action=\"master.xamarin.com/ReferenceService/GetRegions\", ReplyAction=\"master.xamarin.com/ReferenceService/GetRegionsResponse\")]\nIAsyncResult BeginGetRegions(Xamarin.Master.TravelTrace.Data.Region filter, AsyncCallback callback, object asyncState)\nList<Xamarin.Master.TravelTrace.Data.Region> EndGetRegions(IAsyncResult result)\n\npublic void GetRegionsAsync(Xamarin.Master.TravelTrace.Data.Region filter)\n```", "```cs\n// Web Service Generated Client.\n[System.ComponentModel.DesignerCategoryAttribute(\"code\")]\n[System.Web.Services.WebServiceBindingAttribute(Name=\"BasicHttpBinding_ReferenceService\", Namespace=\"master.xamarin.com\")]\n[GeneratedCodeAttribute(\"System.Web.Services\", \"4.6.79.0\")]\npublic partial class AsmxReferenceServiceClient : System.Web.Services.Protocols.SoapHttpClientProtocol\n\n// WCF Generated Client\n[GeneratedCodeAttribute(\"System.ServiceModel\", \"4.0.0.0\")]\npublic partial class ReferenceServiceClient : System.ServiceModel.ClientBase<ReferenceService>, ReferenceService\n```", "```cs\npublic BaseClient(string baseAddress, string securityToken)\n{\n    if (string.IsNullOrEmpty(baseAddress)) throw new ArgumentNullException(\"baseAddress\");\n\n    BaseAddress = new Uri(baseAddress);\n\n  // Storing the security token in a class property of type string\n    SecurityToken = securityToken.StartsWith(\"Bearer\") ? securityToken.Substring(7) : securityToken;\n\n    m_HttpClient = CreateHttpClient();\n}\n```", "```cs\nprivate HttpClient CreateHttpClient()\n{\n    var httpClient = new HttpClient();\n    httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue(\"application/json\"));\n\n    if (string.IsNullOrEmpty(SecurityToken))\n    {\n        httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue(\"Bearer\", SecurityToken);\n    }\n\n    return httpClient;\n}\n```", "```cs\nprotected async Task<string> GetStringAsync(string path)\n{\n    // if we are using the BaseClient multiple times\n    // we can create a new transport with each method\n    //HttpClient httpClient = CreateHttpClient();\n\n    try\n    {\n        // Get the response from the server url and REST path for the data\n        var response = await m_HttpClient.GetAsync(new Uri(BaseAddress, path));\n\n        if (response.StatusCode == HttpStatusCode.Unauthorized)\n        {\n            throw new UnauthorizedAccessException(\"Access Denied\");\n        }\n        if (response.IsSuccessStatusCode)\n        {\n            return await response.Content.ReadAsStringAsync();\n        }\n\n        throw new WebException(response.ReasonPhrase);\n    }\n    catch (Exception ex)\n    {\n        // TODO:\n        throw ex;\n    }\n}\n```", "```cs\nvar regions = await GetStringAsync(\"regions\");\n```", "```cs\npublic async Task<List<Region>> GetRegionsAsync(Region filter = null)\n{\n    var result = new List<Region>();\n\n    var regions = await GetStringAsync(\"regions\");\n    var resultingList = JToken.Parse(regions);\n\n    await Task.Run(() =>\n    {\n        result.AddRange(resultingList[\"value\"]\n            .Select(item => item.ToObject<Region>()));\n    });\n\n    return result;\n}\n```", "```cs\nprotected async Task<List<T>> GetListAsync<T>(string path)\n{\n    List<T> result = new List<T>();\n\n    try\n    {\n        var response = await GetStringAsync(path);\n        var resultingList = JToken.Parse(response);\n\n        await Task.Run(() =>\n        {\n            result.AddRange(resultingList[\"value\"]\n                .Select(item => item.ToObject<T>()));\n        });\n    }\n    catch (Exception ex)\n    {\n        // TODO:\n        throw ex;\n    }\n\n    return result;\n}\n```", "```cs\nvar authenticationBroker = new OAuth2Authenticator(\n    clientId: \"<App ID from https://developers.facebook.com/apps>\",\n    scope: \"\",\n    authorizeUrl: new Uri(\"https://m.facebook.com/dialog/oauth/\"),\n    redirectUrl: new Uri(\"http://www.facebook.com/connect/login_success.html\"));\n\nauthenticationBroker.Completed += (sender, eventArgs) =>\n{\n    DismissViewController(true, null);\n\n    if (eventArgs.IsAuthenticated)\n    {\n        // TODO: eventArgs.Account contains the authenticated user info\n    }\n    else\n    {\n        // TODO: Possibly the user denied access to the account or\n        // the user could not authenticate with the provider\n    }\n};\n\n// The GetUI method returns UINavigationControllers on iOS, and Intents on Android\nPresentViewController(authenticationBroker.GetUI(), true, null);\n```", "```cs\n// Connect to the server\nvar hubConnection = new HubConnection(\"http://xamarin.traveltrace.com/\");\n\n// Create a proxy to the 'MainHub' on the SignalR server\nvar myHubProxy = hubConnection.CreateHubProxy(\"MainHub\");\n\n// Subscribe to message from the server\nmyHubProxy.On<string>(\"ServerStringCall\", message =>\n{\n    // TODO: use the message update from the channel\n});\n\n// Subscribe to message with a complex type\nmyHubProxy.On<Region>(\"ServerComplexCall\", message =>\n{\n    // TODO: use the message update from the channel\n});\n\n// Start the connection\nawait hubConnection.Start();\n```", "```cs\nawait myHubProxy.Invoke(\"MySimpleServerMethod\", \"myParameter\");\nawait myHubProxy.Invoke<Region>(\"MyComplexServerMethod\", new Region{Continent = Continent.Europe});\n```", "```cs\npublic Task<List<Region>> GetRegionsAsync(Region filter = null)\n{\n    var taskAwaiter = new TaskCompletionSource<List<Region>>();\n\n    var client = CreateServiceClient();\n\n    EventHandler<GetRegionsCompletedEventArgs> completedDelegate = null;\n\n    completedDelegate = (sender, args) =>\n        {\n            if (args.Error != null)\n            {\n                taskAwaiter.SetException(args.Error);\n            }\n\n            taskAwaiter.SetResult(args.Result);\n\n            client.GetRegionsCompleted -= completedDelegate;\n        };\n\n    client.GetRegionsCompleted += completedDelegate;\n\n    client.GetRegionsAsync(new Region { Continent = Continent.Europe });\n\n    return taskAwaiter.Task;\n}\n```", "```cs\npublic Task<List<Region>> GetRegionsAsync(Region filter = null)\n{\n    var client = (ReferenceService.ReferenceService)CreateServiceClient();\n\n    var task = Task<List<Region>>.Factory\n        .FromAsync(\n        (callback, o) => client.BeginGetRegions(filter, callback, o),\n        result => client.EndGetRegions(result),\n        null);\n\n    return task;\n}\n```", "```cs\npublic class Region\n{\n    [JsonProperty(\"id\")]\n    public Guid Id { get; set; }\n\n    [JsonProperty(\"name\")]\n    public string Name { get; set; }\n\n    [JsonProperty(\"continent\")]\n    public Continent Continent { get; set; }\n}\n```", "```cs\nnamespace Xamarin.Master.TravelTrace.Common.Infrastructure\n{\n    public interface IReferenceService\n    {\n        List<Region> GetRegions(Region filter = null);\n\n        List<Country> GetCountries(Country filter = null);\n\n        List<City> GetCities(City filter = null);\n    }\n\n    public interface IReferenceServiceAsync\n    {\n        Task<List<Region>> GetRegionsAsync(Region filter = null);\n\n        Task<List<Country>> GetCountriesAsync(Country filter = null);\n\n        Task<List<City>> GetCitiesAsync(City filter = null);\n    }\n} \n```", "```cs\nslsvcutil http://localhost/ReferenceService.svc \n /d:c:\\bin\\ /r:C:\\Local\\Xamarin.Master.TravelTrace.Common.dll\n\n```", "```cs\npublic class Region\n{\n    public Region()\n    {\n        Countries = new List<Country>();\n    }\n\n    [PrimaryKey]\n    [JsonProperty(\"id\")]\n    public Guid Id { get; set; }\n\n    [JsonProperty(\"name\")]\n    public string Name { get; set; }\n\n    [JsonProperty(\"continent\")]\n    public Continent Continent { get; set; }\n\n    [OneToMany(CascadeOperations = CascadeOperation.CascadeInsert | CascadeOperation.CascadeRead)]\n    [JsonProperty(\"countries\")]\n    public List<Country> Countries { get; set; } \n}\n```", "```cs\npublic class DataSyncContext : IReferenceServiceAsync\n{\n    public IReferenceServiceAsync LocalDataService { get; set; }\n\n    public IReferenceServiceAsync RemoteDataService { get; set; }\n\n...\n\n    public async Task<List<Region>> GetRegionsAsync(Region filter = null)\n    {\n        try\n        {\n            // Getting the online results\n            var results = await RemoteDataService.GetRegionsAsync(filter);\n\n            // If there were any online changes.\n            SyncToLocal(results);\n        }\n        catch (Exception ex)\n        {\n            // TODO:\n        }\n\n        // Returning the local storage results (with or without updates)\n        return await LocalDataService.GetRegionsAsync(filter);\n    }\n...\n}\n```", "```cs\nAction<List<Region>> onRegionsLoaded = regions =>\n{\n    // Update the view-model data or the UI.\n};\n\nDataContext.LocalDataService.GetRegionsAsync()\n    .ContinueWith((task) =>\n    {\n        onRegionsLoaded(task.Result);\n    });\n\nDataContext.GetRegionsAsync()\n    .ContinueWith((task) =>\n    {\n        onRegionsLoaded(task.Result);\n    });\n```", "```cs\n<uses-permission android:name=\"android.permission.INTERNET\" />\n```", "```cs\n<uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" />\n<uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" />\n```", "```cs\npublic Task<List<Region>>  GetRegionsAsync(Region filter = null)\n{\n    var nsUrlRequest = new NSUrlRequest(new NSUrl(myServiceEndpoint));\n\n    var taskSource = new TaskCompletionSource<List<Region>>();\n\n    var nsUrlConnection = new NSUrlConnection(nsUrlRequest,\n        new ConnectionSerializingHandler<List<Region>>(taskSource));\n    nsUrlConnection.Start();\n\n    return taskSource.Task;\n}\n```", "```cs\npublic class ConnectionSerializingHandler<T> : \n        NSUrlConnectionDataDelegate where T:class,new()\n{\n    private StringBuilder m_ResponseStore;\n\n    private TaskCompletionSource<T> m_TaskCompletion; \n    public bool IsFinishedLoading { get; set; }\n    public string ResponseContent { get; set; }\n\n    public ConnectionSerializingHandler(TaskCompletionSource<T> taskCompletionSource)\n        : base()\n    {\n        m_ResponseStore = new StringBuilder();\n        m_TaskCompletion = taskCompletionSource;\n    }\n    public override void ReceivedData(NSUrlConnection connection, NSData data)\n    {\n        if (data != null)\n        {\n            m_ResponseStore.Append(data);\n        }\n    }\n\n    public override void FinishedLoading(NSUrlConnection connection)\n    {\n        IsFinishedLoading = true;\n        ResponseContent = m_ResponseStore.ToString();\n\n        // TODO: implement deserialization and \n        m_TaskCompletion.SetResult(result);\n    }\n}\n```", "```cs\nglobal::Android.Net.Uri downloadUri = global::Android.Net.Uri.Parse(\"<URL to Download>\");\nDownloadManager.Request request = new DownloadManager.Request(downloadUri);\n\n// Types of networks on which this download will be executed.\nrequest.SetAllowedNetworkTypes(DownloadNetwork.Wifi);\n\n// Allowed on Roaming connection?\nrequest.SetAllowedOverRoaming(false);\n\n// Allowed on Metered Connection?\nrequest.SetAllowedOverMetered(false);\n\n//Set the title of this downloaded\nrequest.SetTitle(\"My Background Download\");\n\n//Set the description of this downloaded\nrequest.SetDescription(\"Xamarin.Android download using DownloadManager\");\n\n//Set the local destination for the downloaded file\nrequest.SetDestinationInExternalFilesDir(this, global::Android.OS.Environment.DirectoryDownloads, \"MyDownloadedData.xml\");\n// or use the request.SetDestinationUri()\n```", "```cs\nm_DownloadManager = (DownloadManager)GetSystemService(DownloadService);\n\n// Enqueue the request\n// The download reference will be used to retrieve the status\nm_CurrentDownloadReference = m_DownloadManager.Enqueue(request);\n```", "```cs\n// Removing the queued request from the DownloadManager queue.\nm_DownloadManager.Remove(m_CurrentDownloadReference);\n\n//\n// Retrieving the current status of the download queue\n// Create a query to retrieve the download status(s)\nDownloadManager.Query myDownloadQuery = new DownloadManager.Query();\nmyDownloadQuery.SetFilterById(m_CurrentDownloadReference);\n// Request the queued download items as a data table.\nvar cursor = m_DownloadManager.InvokeQuery(myDownloadQuery);\nvar statusColumn = cursor.GetColumnIndex(DownloadManager.ColumnStatus);\nvar status = (DownloadStatus)cursor.GetInt(statusColumn);\n```", "```cs\npublic class DownloadBroadcastReceiver : BroadcastReceiver\n{\n    public override void OnReceive(Context context, Intent intent)\n    {\n        // Get the download reference from the intent broadcast\n        long referenceId = intent.GetLongExtra(DownloadManager.ExtraDownloadId, -1);\n\n        // TODO: Implement the delegated execution\n    }\n}\n```", "```cs\n//set filter to only when download is complete and register broadcast receiver\nIntentFilter filter = new IntentFilter(DownloadManager.ActionDownloadComplete);\n// TODO: We can extend the DownloadBroadcastReceiver with delegates\nRegisterReceiver(new DownloadBroadcastReceiver(), filter);\n```", "```cs\npublic class DownloadTaskDelegate : NSUrlSessionDownloadDelegate\n{\n    public override void DidFinishDownloading(NSUrlSession session, NSUrlSessionDownloadTask downloadTask, NSUrl location)\n    {\n        // TODO: Implement the delegate for download finished\n    }\n    public override void DidBecomeInvalid(NSUrlSession session, NSError error)\n    {\n        //base.DidBecomeInvalid(session, error);\n\n        // TODO: Implement the delegate for error\n    }\n    public override void DidWriteData(NSUrlSession session, NSUrlSessionDownloadTask downloadTask, long bytesWritten, long totalBytesWritten,\n        long totalBytesExpectedToWrite)\n    {\n        //base.DidWriteData(session, downloadTask, bytesWritten, \n        //  totalBytesWritten, totalBytesExpectedToWrite);\n\n        // TODO: Implement the delegate for download progress\n    }\n} \n```", "```cs\nNSUrlSessionConfiguration downloadSessionConfiguration = NSUrlSessionConfiguration.BackgroundSessionConfiguration (\"com.TravelTravel.BackgroundTransfer\");\nm_DownloadSession = NSUrlSession\n    .FromConfiguration(downloadSessionConfiguration, \n    new DownloadTaskDelegate(), \n    new NSOperationQueue());\nNSUrl url = NSUrl.FromString(\"<URL to Download>\");\nNSUrlRequest request = NSUrlRequest.FromUrl(url);\nm_DownloadTask = m_DownloadSession.CreateDownloadTask(request);\n```", "```cs\npublic partial class Region\n{\n    public Region()\n    {\n        Countries = new List<Country>();\n    }\n\n#if !AZURE\n    [PrimaryKey]\n    [JsonProperty(\"id\")]\n    public Guid Id { get; set; }\n#endif\n\n#if !AZURE\n    [JsonProperty(\"name\")]\n#endif\n    public string Name { get; set; }\n\n#if !AZURE\n    [JsonProperty(\"continent\")]\n#endif\n    public Continent Continent { get; set; }\n\n#if !AZURE\n    [OneToMany(CascadeOperations = CascadeOperation.CascadeInsert | CascadeOperation.CascadeRead)]\n    [JsonProperty(\"countries\")]\n#endif\n\n    public List<Country> Countries { get; set; } \n}\n```", "```cs\npublic partial class Region : EntityData\n{\n}\n```", "```cs\npublic static MobileServiceClient MobileService = new MobileServiceClient(\n    \"https://traveltrace.azure-mobile.net/\",\n    \"<Removed for security reasons>\"\n    );\n```", "```cs\n// Intialization the mobile services on the mobile platform\nCurrentPlatform.Init();\n\n// Adding a region item to the database\nvar item = new Region {Continent = Continent.Europe, Name = \"Balkan\"};\nMobileService.GetTable<Region>().InsertAsync(item).ContinueWith((result) =>\n{\n    System.Diagnostics.Debug.Write(result.Status);\n});\n```", "```cs\nprivate async Task InitLocalStoreAsync()\n{\n    // new code to initialize the SQLite store\n    string path = Path.Combine(\n        Environment.GetFolderPath(\n        Environment.SpecialFolder.Personal), \"traveltrace.db\");\n\n    if (!File.Exists(path))\n    {\n        File.Create(path).Dispose();\n    }\n\n    var store = new MobileServiceSQLiteStore(path);\n    store.DefineTable<Region>();\n\n    // Uses the default conflict handler, which fails on conflict\n    await MobileService.SyncContext.InitializeAsync(store);\n}\n```", "```cs\nprivate async Task SyncAsync()\n{\n    // IMobileServiceSyncTable<Region> RegionsTable = MobileService.GetSyncTable<Region>();\n    await MobileService.SyncContext.PushAsync();\n    await RegionsTable.PullAsync(\"AllRegions\", RegionsTable.CreateQuery());\n}\n```", "```cs\n[AuthorizeLevel(AuthorizationLevel.User)]\npublic class RegionController : TableController<Region>\n```", "```cs\nMobileService.LoginAsync(this, MobileServiceAuthenticationProvider.MicrosoftAccount).ContinueWith((task) =>\n{\n    System.Diagnostics.Debug.WriteLine(\"Currently authenticated user's ID is {0}\", task.Result.UserId);\n});\n```"]