- en: '2'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Metaprogramming Concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have a few ideas about how metaprogramming can benefit you, we need
    to cover the basic concepts.
  prefs: []
  type: TYPE_NORMAL
- en: When working with metaprogramming, you get metadata for free from the environment
    it’s running in, and there is the opportunity to explicitly add more. With explicitness,
    you can enable clarity in your code base, and a level of transparency for the
    developers writing and reading the code.
  prefs: []
  type: TYPE_NORMAL
- en: Some parts of your source code will benefit from more explicit metadata rather
    than having it implicitly and just magically do things that can be hard for developers
    to reason about why.
  prefs: []
  type: TYPE_NORMAL
- en: With explicitness also comes the possibility of representing the domain language
    of your business in code and with increasing expressiveness.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit – using what is already there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit – additional adornment of code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Domain-specific languages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you should have a good feel for the different metaprogramming
    concepts you can leverage, when to use which concept, and the benefits of each
    concept.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find all the source code used in this chapter in the GitHub repository:
    [https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter2](https://github.com/PacktPublishing/Metaprogramming-in-C-Sharp/tree/main/Chapter2).'
  prefs: []
  type: TYPE_NORMAL
- en: Implicit – using what is already there
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The compiler that compiles **C#** parses all our code and ends up creating
    what is referred to as **IL-code**, short for **Intermediate Language code**.
    This is standardized and part of the **ECMA-335** standard for the Common Language
    Infrastructure. You can read more about the standard here: [https://www.ecma-international.org/publications-and-standards/standards/ecma-335/](https://www.ecma-international.org/publications-and-standards/standards/ecma-335/).
    This type of code is not something that the CPU in the system understands and
    it requires another step for the CPU to understand it. The last step of translation
    is done when we run our programs and the **.NET runtime** takes over, interprets
    the IL, and generates the necessary instructions for the CPU type of the computer
    the program is running on.'
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the binary output, you can’t necessarily tell the difference. But
    by opening up the binary using a decompiler tool such as **ildasm**, or something
    more visual, such as **JetBrains dotPeek** ([https://www.jetbrains.com/decompiler/](https://www.jetbrains.com/decompiler/)),
    we can get a glimpse at what our programs look like.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take, for instance, the following program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Compiling this will produce a **Dynamic Link Library** (**DLL**) file, and
    on opening the file with a decompiler, we would see something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'On an x86/AMD64-based CPU, this then gets translated into something like the
    following disassembled code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: The actual **Hello world!** string is then placed in memory at the location
    used by the first **mov** instruction. If you’re interested in trying out code
    and seeing how it translates yourself, I recommend heading over to [https://sharplab.io](https://sharplab.io).
  prefs: []
  type: TYPE_NORMAL
- en: In the finished compiled result, there is actually no metadata whatsoever, making
    it impossible to reason about our code in any meaningful way.
  prefs: []
  type: TYPE_NORMAL
- en: While the IL contains everything we wrote, all the type information is intact
    (type names, method names, and so forth).
  prefs: []
  type: TYPE_NORMAL
- en: With that, we are being set up for success to do some proper metaprogramming.
  prefs: []
  type: TYPE_NORMAL
- en: Leveraging the power of reflection
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All this information is available to us, and it all starts with the powerful,
    and my personal favorite, namespace called **System.Reflection**. This holds all
    the C# types representing the different code elements we write. Since C# is a
    managed language running on top of the managed runtime, we get all the details
    about all the code we write.
  prefs: []
  type: TYPE_NORMAL
- en: Since every type we have created and will create is inherent of the **Object**
    type, every derived type inherently gets its methods and properties. One of these
    methods is called **GetType()**. This method returns an instance of the type of
    the object in the form of **Type**. It holds all the details about the particular
    type – everything from what namespace it resides in, to fields, properties, methods
    on it, and much more. For the type, we can even look at what it is inheriting
    and what interfaces it might implement. We can even see which assembly (DLL) it
    is defined in.
  prefs: []
  type: TYPE_NORMAL
- en: If you look at object-relational mappers such as **Microsoft’s Entity Framework**,
    **Dapper**, **NHibernate**, or even the **MongoDB C# Driver**, they all use reflection
    to reason about the types you have to translate into something expected by the
    underlying data store. For a relational store, it would typically translate into
    the correct **SQL** statements, while for MongoDB, it would be the correct MongoDB
    **Binary JSON** (**BSON**) objects.
  prefs: []
  type: TYPE_NORMAL
- en: The same is done by things that serialize from .NET types to other formats,
    such as JSON. Libraries such as **Newtonsoft.JSON** or the built-in **System.Text.Json**
    namespace leverages reflection to know what to translate.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s say you have a **Person** type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'An extremely simplistic conversion to JSON could easily be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This can then be used as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The output of running this would yield some nice JSON:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The code basically gets the type information from the instance and gets the
    properties on it. It outputs a string containing the property name and leverages
    **PropertyInfo** to get a value from the instance and just outputs its **.****ToString()**
    representation.
  prefs: []
  type: TYPE_NORMAL
- en: Obviously, this sample is very simple and non-recursive for complex types or
    support arrays and doesn’t recognize well-known JSON primitive types. But this
    proves how easily you can get to the information.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit metadata and the type system of .NET can be very powerful. The further
    down the rabbit hole you go with reflection, the more you’ll probably feel like
    going further and doing more. The flip side of that is for everything you do automatically,
    you lose the transparency of what’s going on. It needs to be balanced and be as
    close to the element of least surprise as possible.
  prefs: []
  type: TYPE_NORMAL
- en: For some things, you’re better off going with being very explicit. There is
    also metadata that can’t be discovered with what the compiler generates, and the
    only way to go is to be very explicit.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit – additional adornment of code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Pretty much all code elements can have additional information added to them.
    These are called **attributes**. Attributes are a powerful method of associating
    metadata with the element. Within the .NET framework itself, you’ll see quite
    a few of these attribute types that can be used.
  prefs: []
  type: TYPE_NORMAL
- en: In the **System.ComponentModel.DataAnnotations** namespace, you can find some
    great examples of attributes that add metadata used by the runtime. Here, you’ll
    find attributes used for adding validation metadata. ASP.NET picks up the usage
    of these attributes and checks objects being sent to controller actions for validity
    according to the rules applied. As we saw briefly in [*Chapter 1*](B19418_01.xhtml#_idTextAnchor015),
    *How Can Metaprogramming Benefit You?*, with our **RegisterPerson** type, we could
    instruct properties that should be required. It contains much more, for instance,
    **[StringLength]** and **[Range]**. These are great examples of metadata recognized
    by the framework and components that support them.
  prefs: []
  type: TYPE_NORMAL
- en: 'Some attributes in the framework are recognized by the compiler and will direct
    the compiler to perform certain things. For instance, the **[Flags]** attribute
    can be added to enums that instruct it to require every value to represent a bit
    field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With this type of enum, we define flags, with each flag being a left bitwise
    shift for the number of places to move to represent the correct bit. You can also
    do this by giving the actual decimal or hexadecimal number of the bit (**1**,
    **2**, **4**, or **8**, or **0x1**, **0x2**, **0x4**, **0x8**, **0x10**, and so
    on).
  prefs: []
  type: TYPE_NORMAL
- en: 'The **System.Text.Json** serializer also makes use of metadata. It uses metadata
    to know how to serialize or deserialize what it is given. For instance, it can
    ignore properties in an object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Serializing an instance of this would leave out **FullName**.
  prefs: []
  type: TYPE_NORMAL
- en: Creating custom attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You can easily create your own custom attributes by adding the metadata you
    want for your code. All attributes can take arguments with the extra metadata
    you want to have associated with them. This gives you the opportunity to be very
    specific on what data you want to associate as metadata with the code element
    being adorned.
  prefs: []
  type: TYPE_NORMAL
- en: All of the metadata added to an attribute needs to be resolvable by the compiler
    at compile time. That limits us to only have things that are typical primitive
    types and constant in nature. You can’t dynamically create instances of things
    to pass into an attribute.
  prefs: []
  type: TYPE_NORMAL
- en: An example of an attribute could, for instance, be for describing types or properties
    that hold **personal identifiable information** (**PII**). This can be very useful
    to be able to later reason about your code, to know what PII is being collected
    about users, which can be presented to the user themselves. With the European
    Union privacy law called **GDPR**, it could also be used as a reporting mechanism
    if your company is audited or have a GDPR-related incident and need to report
    it to the authorities.
  prefs: []
  type: TYPE_NORMAL
- en: A huge benefit, once you have tagged types and properties with this metadata,
    is that you get an opportunity for future use cases – for example, the encryption
    of PII data or anything else.
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating a custom attribute is in its basic form as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: The **PersonalIdentifiableInformationAttribute** type needs to inherit the base
    **Attribute** type. The compiler also expects the type you create to be suffixed
    with **Attribute** as part of the name. However, when using your custom attribute,
    you can then leave out **Attribute** in the name, the compiler will map this to
    the full name with the suffix added to it.
  prefs: []
  type: TYPE_NORMAL
- en: The next thing you need to specify is actually a bit of metadata for the compiler.
    This is done using the **[AttributeUsage]** attribute. With this, we need to specify
    what target code elements are supported, and we can support multiple by *ORing*
    (the **OR** operation) them together.
  prefs: []
  type: TYPE_NORMAL
- en: 'For **PersonalIdentifiableInformationAttribute**, we’d typically want this
    for classes, properties, and fields:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: In addition, we specify that we don’t want to allow multiple copies of the same
    attribute. A good practice is to have your attributes be very specific and not
    create any inheritance chains of attributes. This will make your attribute a **sealed**
    type not allow inheritance from a C# perspective.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the things that GDPR mentions is to record the collection purpose. So,
    to add to this, we could include the purpose as optional metadata. You can do
    this by adding a constructor that takes the metadata as an argument, and if you
    want it to be optional, you can give it a default value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, in addition to adding the constructor with the argument for
    the metadata, you need to add the **Purpose** property that exposes the metadata.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we can start applying the **PersonalIdentifiableInformation** attribute
    to properties on something, such as a **Person** object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: We will go into more depth on how we can leverage this further in [*Chapter
    5*](B19418_05.xhtml#_idTextAnchor083), *Leveraging Attributes*.
  prefs: []
  type: TYPE_NORMAL
- en: We’ve discussed how we can reason about our code through implicit structures
    and also how we can add explicit additional metadata and even our own custom data.
    What about going the other way? By this, we mean going from something and basically
    generating code.
  prefs: []
  type: TYPE_NORMAL
- en: As we talked about previously, the programming language itself is basically
    a higher-level metadata language designed to be able to express code more efficiently.
  prefs: []
  type: TYPE_NORMAL
- en: With that mindset, there is really nothing stopping us from inventing our own
    language and leveraging the infrastructure to generate running code.
  prefs: []
  type: TYPE_NORMAL
- en: Domain-specific languages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The concept of creating your own **domain-specific language** (**DSL**) is nothing
    new and has been done for years by companies. This can be a very efficient way
    to include your domain experts in the mix and provide a way for them to contribute
    code in a language that is more familiar to them. The code they write is typically
    then on a much higher level and has a vocabulary that is supported by lower-level
    code constructs, which are actually doing the heavy lifting.
  prefs: []
  type: TYPE_NORMAL
- en: Think of this as a programming language and a compiler for your business, expressing
    your business problems.
  prefs: []
  type: TYPE_NORMAL
- en: It could also be used for technical aspects and not just for the business side
    – for instance, if you have complex state machines or workflows that have their
    own vocabulary and you want to make it into a language that is easier to reason
    about. You could also imagine that the language is represented in a well-known
    file format such as JSON, YAML, or even Excel.
  prefs: []
  type: TYPE_NORMAL
- en: The purpose of going to the length of generating the code for this higher-level
    representation is that you get an opportunity to make the end result more optimal,
    and you can make decisions to optimize the flow before it hits the runtime. You
    also get a snappier startup of your application, as it doesn’t have to parse things
    at startup and hand it over to an engine that runs it. It will ultimately just
    be code running, just as any other code in your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Gherkin – technical sample
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you’re familiar with writing unit tests, the typical structure is **arrange**,
    **act**, and then **assert**. A test would look something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: This code tests a calculator to verify that its add functionality works as expected.
    It does this by setting up the inputs and expected results, then calling into
    the calculator, and finally, verifying the result by using assertions that claim
    the result should be the same as the expected result.
  prefs: []
  type: TYPE_NORMAL
- en: While this is the more traditional **test-driven development** (**TDD**) style,
    there is something called **behavior-driven design** (**BDD**). This approach
    focuses much more on the behavior of a system and interactions between parts of
    your system rather than its state. For expressing this interaction, a DSL was
    created called **Gherkin**. It is somewhat similar in its basic form with *given*,
    *when*, and *then*, which maps pretty much to the same as TDD’s *arrange*, *act*,
    and *assert*. In addition, it has the concepts of features, scenarios, and steps.
    The goal is to write concrete functional requirements for a system.
  prefs: []
  type: TYPE_NORMAL
- en: For higher-order functionality, it is hard for domain experts to reason about
    C# code to verify whether we’re testing the right thing or delivering what is
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: With the correct tool, we can start articulating the functionality of a system
    in plain English and let it be hooked up to code snippets that perform the actual
    code we need to test or specify.
  prefs: []
  type: TYPE_NORMAL
- en: 'A great example of an implementation of this is the .NET BDD framework called
    **SpecFlow** ([https://specflow.org/](https://specflow.org/)). When navigating
    to their site, you’re presented with their data privacy dialog, and they’ve included
    the specification of the scenario:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_2.1_B19418.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 2.1 - SpecFlow data privacy dialog
  prefs: []
  type: TYPE_NORMAL
- en: SpecFlow embraces Gherkin and provides a compiler that compiles the DSL to runnable
    code, mixing in the necessary code to call for the feature under test.
  prefs: []
  type: TYPE_NORMAL
- en: We will be looking at how we can do this at runtime using dynamic code generation
    emitting IL code into the running application in [*Chapter 6*](B19418_06.xhtml#_idTextAnchor098),
    *Dynamic Proxy Generation*, and also how we can leverage .NET Expression to create
    code and how these can be compiled on the fly in [*Chapter 8*](B19418_08.xhtml#_idTextAnchor132),
    *Building and Executing Expressions*. In [*Chapter 16*](B19418_16.xhtml#_idTextAnchor272),
    *Generating Code*, we will be looking at how we can really make this fly by doing
    it at the compiler level.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You should now have a clearer idea of the different concepts of metaprogramming
    and a better understanding of when to use what. You’ll see health warnings throughout
    the book about being careful about doing too many implicit or magical things that
    the developers might not understand. This balance can be very hard to get right,
    and there is also a certain level of maturity involved for individual developers
    and teams as a whole involved as well.
  prefs: []
  type: TYPE_NORMAL
- en: The .NET compiler and what it produces give a lot of power to you as a developer.
    Use it wisely.
  prefs: []
  type: TYPE_NORMAL
- en: In order to demystify and demonstrate more day-to-day use of metaprogramming,
    we will look into how Microsoft’s ASP.NET leverages metaprogramming techniques
    in the next chapter. This should give you some security in feeling it is not too
    exotic, and also get a feel for how it can make you more productive and be of
    help.
  prefs: []
  type: TYPE_NORMAL
