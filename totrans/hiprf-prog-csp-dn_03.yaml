- en: '*Chapter 2*: Implementing C# Interoperability'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter is an optional chapter for those who would like to or need to use
    C# to interoperate with Excel, Python, C++, and **Visual Basic 6** (**VB6**).
  prefs: []
  type: TYPE_NORMAL
- en: Python has become a very popular programming language in recent months and is
    now a very big player in data science and machine learning. Since big data employs
    various technologies that are required to work with each other under various business
    scenarios, in this chapter, you will learn how to execute Python scripts and code
    from C#. You can also use IronPython.NET on the .NET platform, but since this
    book is for C# programmers, we will not be considering IronPython.NET in this
    chapter.
  prefs: []
  type: TYPE_NORMAL
- en: There are times when it is necessary to access libraries written in C++ – especially
    when performance is an issue, and you need that extra performance in advanced
    games.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn about Microsoft .NET interoperability. It is
    advantageous to move your complete code base to a single code base that uses a
    familiar language that your whole development team is comfortable with using.
    But sometimes, to do this in one move is often not practical or cost-effective,
    or even safe. And that is where interoperability comes in.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, you will learn how to interact with managed and unmanaged code.
    You will be looking at using unsafe code, unmanaged code with **Platform Invoke**
    (**P/Invoke**), COM interoperability, and disposing of unsafe code.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Using unmanaged code in C# does not always improve performance. Sometimes, it
    degrades it. But the logic of including this chapter within this book on high
    performance is to provide the knowledge and tools you will need to gradually replace
    your unmanaged code base with a managed code base. By doing so, all your developers
    only work with a single language and its supporting languages (in this case, C#).
    Your software can use the high-performing and highly scalable features of Azure
    or any other .NET cloud provider to build world-class cloud-based systems. The
    other advantage of doing this is that it makes code management and maintenance
    much easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will be covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Using unsafe code**: C# does a good job of shielding programmers from having
    to deal with pointers. But sometimes, it is necessary to use pointers to improve
    performance. Due to this, in this section, we will be looking at what unsafe code
    is and how to implement them.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Exposing static entry points using Platform Invoke**: P/Invoke allows you
    to access code in unmanaged libraries from your managed C# code. In this section,
    we will learn how to access code that hasn''t been built using .NET.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Performing COM interoperability**: In this section, we will learn how to
    make COM components and libraries visible for C# projects to use. We will also
    look at how to make our components and libraries visible to COM components to
    use.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Safely disposing of unsafe code**: C# does a very good job of performing
    garbage collection to free up resources when code is finished with, but when you''re
    dealing with unmanaged code, you are responsible for cleaning up unmanaged resources.
    So, in this section, you will be shown how to do this.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'After completing this chapter, you will be able to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Understand the use of unsafe code in C#
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Call native code from managed code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use COM libraries and components in managed and unmanaged code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release unsafe resources when they're no longer needed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, some of the code includes interoperability between C# managed
    assemblies and COM-based ActiveX UserControls, DLLs, and executables.
  prefs: []
  type: TYPE_NORMAL
- en: 'To write the code and build the projects in this chapter, you will need the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2022
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latest x86 preview of .NET 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The latest x64 preview of .NET 6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: Visual C++'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: Visual Studio Tools for Microsoft Office'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Optional: Visual Basic 6'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The code files for this chapter can be found in this book''s GitHub repository:
    [https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH02](https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH02).'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Although Visual Basic 6 is obsolete and no longer supported by Microsoft, it
    is still heavily used in production code within various businesses and sectors,
    such as automotive software providers and the education sector. Interoping with
    VB6 and .NET enables phased migrations from VB6 to .NET. By modernizing applications
    built with old technology, you can make them highly scalable across time zones
    using various cloud providers, such as Azure.
  prefs: []
  type: TYPE_NORMAL
- en: We will start this chapter by looking at unsafe code.
  prefs: []
  type: TYPE_NORMAL
- en: Using Platform Invocation (P/Invoke)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: P/Invoke is a **Common Language Infrastructure** (**CLI**) feature that enables
    native code to be called by managed applications. Native code is not managed by
    the **Common Language Runtime** (**CLR**), so, the code's safety is firmly placed
    in the hands of the programmer.
  prefs: []
  type: TYPE_NORMAL
- en: In managed code, the garbage collector automatically cleans up objects in memory
    and is responsible for assigning generations to objects. We will cover the garbage
    collector in more detail in [*Chapter 4*](B16617_04_Final_SB_Epub.xhtml#_idTextAnchor072),
    *Memory Management*. A new object always starts life as generation zero when it
    is less than 80,000 bytes in size and will be placed on the small object heap.
    Objects equal to or greater than 80,000 bytes in size are placed on the large
    object heap. Objects that survive generation zero get promoted by the garbage
    collector to generation one. Finally, objects that survive generation one get
    promoted to generation two.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Instantiated objects equal to or greater than 80,000 bytes may start as generation
    zero but be promoted, so they would not be seen as generation zero.
  prefs: []
  type: TYPE_NORMAL
- en: When an object is promoted from one generation to another by the garbage collector,
    its memory address changes. This breaks any pointers that refer to that address.
    To prevent the address from being modified by the garbage collector, the pointer
    code must be declared using the `fixed` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at using the `unsafe` and `fixed` keywords.
  prefs: []
  type: TYPE_NORMAL
- en: Using unsafe and fixed code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To remind the programmer of their responsibility for ensuring code safety, unmanaged
    code is wrapped in a code block marked as unsafe using the `unsafe` keyword. Unsafe
    code makes use of pointers to refer to locations in memory.
  prefs: []
  type: TYPE_NORMAL
- en: '**Unsafe code** provides programmers with access to pointer types in C#, which
    can be necessary when they''re working with the underlying operating system, system
    drivers, or working on time-critical code that needs to be executed in the smallest
    amount of time.'
  prefs: []
  type: TYPE_NORMAL
- en: Even though we say the code that deals with pointers is unsafe code, it is safe
    to work with. Such code is marked with the `unsafe` keyword. Despite being called
    unsafe, such code is safe to use in managed code – it is just not verified by
    the CLR. Therefore, it is possible to introduce security risks and/or pointer
    errors. You can have an unsafe `pointer_type`, `value_type`, or `reference_type`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The topic of unsafe code is deep, so if you wish to learn more, please view
    the language specification that discusses unsafe code at https://docs.microsoft.com/dotnet/csharp/language-reference/language-specification/unsafe-code.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will write a console application that puts the various unsafe
    code mechanisms to work. You can view the project's source code at [https://github.com/PacktPublishing/C-9-and-.NET-5-High-Performance/tree/master/CH02/CH02_UnsafeCode](https://github.com/PacktPublishing/C-9-and-.NET-5-High-Performance/tree/master/CH02/CH02_UnsafeCode).
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider the following computer program:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, you can see that we allocate memory space for an array
    of five `int` values using the `new` keyword. We can do the same thing using unsafe
    code. But instead of using the `new` keyword, we can use `stackalloc` and wrap
    the code in a code block marked as `unsafe`.
  prefs: []
  type: TYPE_NORMAL
- en: When dealing with unsafe code such as array pointers, it is necessary to use
    the `fixed` keyword. To understand why the `fixed` keyword is important, you need
    to understand garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: When objects are created, they are generation-zero objects. The garbage collector
    will remove any unreferenced generation one objects. If the space for allocating
    generation zero objects becomes full, the garbage collector moves the generation
    zero objects to generation one. Then, new objects can be added to generation zero.
    If the generation one and generation two objects become full, and all the objects
    are in use, then the garbage collector moves the generation one objects to generation
    two. This, in turn, moves the generation zero objects to generation one.
  prefs: []
  type: TYPE_NORMAL
- en: 'New objects are then added to generation zero. At this point, if the generation
    two, generation one, and generation zero storage spaces are full, which means
    that no new objects can be added, then you end up with an out-of-memory exception.
    The following diagram shows this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Garbage collection management of object generations'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.1_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Garbage collection management of object generations
  prefs: []
  type: TYPE_NORMAL
- en: Since the garbage collector is moving the items from one generation to another,
    the memory locations change. However, the pointers to those objects in your code
    do not change. Therefore, when retrieving the information from the pointer address,
    the data will be incorrect.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prevent this from happening, we can use the `fixed` keyword. The `fixed`
    keyword tells the garbage collector to leave the address space that `arrayPointer`
    is pointing to alone. This means that we can ensure that the pointer will be pointing
    to the correct address space and data. The following code shows the `unsafe` and
    `fixed` keywords being used to deal with an array:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, because we are using unsafe code, we used an `unsafe`
    code block. Since we don't want the array to be affected by the garbage collector,
    we kept the object at its current generation by using the `fixed` code block.
  prefs: []
  type: TYPE_NORMAL
- en: 'One caveat you need to be aware of when using unsafe code is the effect of
    accessing an array that''s out of bounds. When you access an array that''s out
    of bounds in managed code, you are presented with `IndexOutOfBoundsException`.
    You do not have that luxury with unmanaged code. You are responsible for ensuring
    that the correct indexes are accessed. If you happen to access an index that is
    outside the bounds of the array, then you will not have `IndexOutOfBoundsException`
    thrown. Instead, you will have whatever is at that memory address returned to
    you. In that case, you may or may not end up with some type of exception being
    thrown. The following code demonstrates this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: Here, the array is added to the stack. The value of the array at position `99`
    is correct, but the array position of `100` is out of bounds, so an incorrect
    value is returned. This means that `IndexOutOfBoundsException` is thrown. That
    is why you must be careful with unmanaged code when dealing with indexes.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The reason for the `unsafe` keyword is to alert the programmer to their responsibility
    for code safety. When dealing with pointers, runtime exceptions aren't raised.
    Instead, whatever is at that memory location is returned. That's why you must
    take extra care when programming unsafe code. You must also use the `fixed` keyword
    when you can't afford for the garbage collector to switch the generations of your
    objects and move them.
  prefs: []
  type: TYPE_NORMAL
- en: In C#, you can only use structs and primitives with unsafe and fixed code. Classes
    and strings that access the heap are not allowed. This means that nothing that
    will be garbage collected can be referenced using unsafe code. So, when using
    C# pointers, you can use value types, but you cannot use reference types.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code will not compile:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'The `testObject` variable is a reference type pointer, so the compiler throws
    an exception if you build the code. This code returns the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CS0208`: Cannot take the address of, get the size of, or declare a pointer
    to a managed type (`''TestObject''`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `text` variable is a string pointer, and the compiler throws an exception
    if you build the code. This code returns the following exception:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CS0208`: Cannot take the address of, get the size of, or declare a pointer
    to a managed type (`''string''`)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Using fixed objects can result in memory fragmentation. So, avoid using the
    `fixed` keyword until you need to, and only use it for as long as you need it.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Now, let's look at exposing static entry points using P/Invoke.
  prefs: []
  type: TYPE_NORMAL
- en: Exposing static entry points using P/Invoke
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: P/Invoke allows you to make static entry points available to other applications.
    If you have ever used WinAPI, then you have accessed code in DLLs via their public
    static entry points. These access points would have been made available using
    P/Invoke.
  prefs: []
  type: TYPE_NORMAL
- en: 'To use P/Invoke, you will need to import the `System.Runtime.InteropServices`
    namespace. Then, you must make the static entry call using `DllImportAttribute`:'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: To identify the static entry points of a file, you can use the `dumpbin.exe`
    file that's located in the `C:\Program Files (x86)\Microsoft Visual Studio\2019\Preview\VC\Tools\MSVC\14.28.29115\bin\Hostx64\x64`
    folder. This version of 14.28.29.115 was correct at the time of writing. When
    you come to execute the following code, this version will have changed. Use the
    latest version that you have installed on your computer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s learn how to use `dumpbin` to see what methods and properties the
    `User32.dll` system library exports using the command line:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the command line or developer command prompt. Then, enter the following
    command (note that there might be a different version on your computer – use the
    latest version number you have):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'You should see something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – Command line showing the outcome from executing dumpbin on User32.dll'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.2_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – Command line showing the outcome from executing dumpbin on User32.dll
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s write a C++ library and call it from C# using P/Invoke. First, we must
    create a new empty C++ project, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Creating a new empty C++ project'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.3_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Creating a new empty C++ project
  prefs: []
  type: TYPE_NORMAL
- en: Delete the `Header Files`, `Resource File`, and `Source Files` folders. Add
    a new class called `Product`. Delete the header file that has the `.h` file extension.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Modify the `Product.cpp` file so that it contains the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, we must import three libraries: `string`, `iostream`, and `comdef.h`.
    Then, we must declare a struct with `Id` and `Name` values. In C++, strings are
    typically defined using `std::string`, but when it comes to.NET, we declare strings
    as the BSTR type for OLE/automation by convention. The BSTR APIs use the `CoTask*`
    memory allocator, which is the implied interop contract for native on Windows.
    On non-Windows systems, .NET 5 uses `malloc`/`free`. We also have a void method
    called `BuyProduct()` that prints the `Id` and `Name` values as well as a newline,
    to the console''s output window.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The next thing we must do is export two methods called `CreateProduct()` and
    `BuyProduct(Product product)`. Now, `CreateProduct()` creates a new `Product`
    and returns it to the caller, while `BuyProduct(Product product)` calls the `BuyProduct()`
    method on the passed-in `Product` struct.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new class called `Greeting`. Delete the `Greeting.h` file. Update the
    `Greeting.cpp` file so that it contains the following source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have included `iostream` and `comdef.h`. We have four methods called
    `SendGreeting()`, `Add(int x, int y)`, `IsLengthGreaterThan5(const char* value)`,
    and `GetName()`. We expose these methods to external callers.
  prefs: []
  type: TYPE_NORMAL
- en: '`SendGreeting()` takes no parameters and outputs a string to the standard output
    window. `Add(int x, int y)` adds to integers passed in by the caller and returns
    the result. `IsLengthGreaterThan5(const char* value)` checks if the length of
    the string that''s been passed in by the caller is greater than `5`. If it is,
    then `true` is returned. Otherwise, `false` is returned. `GetName()` returns a
    string. The return type for a string must be `BSTR`. To return a string in a method,
    you must call `SysAllocString(L"the string you want returning")`. This correctly
    initializes the string to a wide-character array and initializes the count.'
  prefs: []
  type: TYPE_NORMAL
- en: 'That is all there is to our C++ library. Now, we just need to configure it.
    But before we do that, we will write our C# client, which will consume the C++
    library. The reason for doing this is that once we have the build folder for our
    C# client, we will get our C++ library to output the DLL to the C# build folder.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a new .NET Core 3.1 console application project to your solution, and then
    set it as the startup project. Add a class called `Product`. Update the contents
    of the `Product.cs` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we have created a mirror of the C++ struct in our C# client and included
    the `System.Runtime.InteropServices` library. Our C# struct has the same two fields
    as our C++ struct and they are in the same order. The struct itself is annotated
    with `[StructLayout(LayoutKind.Sequential)]`, which states that the field order
    must be processed sequentially. This ensures a match between the fields in the
    C++ library and the fields in the C# library. Additionally, the `Name` property
    is a string, so it needs to be annotated with the `[MarshalAs(UnmanagedType.Bstr)]`
    annotation. This tells the compiler that the C# string is to be treated as a C++
    BSTR.
  prefs: []
  type: TYPE_NORMAL
- en: 'Modify the `Program.cs` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we imported the `System` and `System.Runtime.InteropServices` libraries,
    and then modified the `Main(string[] args)` method by replacing the `args` parameter's
    name with the default operator.
  prefs: []
  type: TYPE_NORMAL
- en: Set the build configuration to x64.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Append the following line to the `PropertyGroup` section of your C++ project
    file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Build the project. This will produce our output folder where we will place our
    compiled C++ library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click on the C++ project and select **Properties**. You should see the
    **CH02_NativeLibrary Property Pages** dialog box:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – CH02_NativeLibrary Property Pages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.4_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – CH02_NativeLibrary Property Pages
  prefs: []
  type: TYPE_NORMAL
- en: Change **Output Directory** to your C# project's output directory. Then, change
    **Configuration Type** to **Dynamic Library (.dll)**. Build the C++ library.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Back in your C# project, add the COM library by browsing for it in your C# build
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following DLL imports to the `Program` class, above the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'These `DllImport` statements make our `CH02_NativeLibrary.dll` methods available
    to C#. Update the `Main` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Our `Main` method calls the methods that were imported from our `CH02_NativeLibrary.dll`
    binary. We pass values in and receive values and structures back.
  prefs: []
  type: TYPE_NORMAL
- en: Now that you know what unsafe and fixed code is, let's learn how to interact
    with Python code in C#.
  prefs: []
  type: TYPE_NORMAL
- en: Interacting with Python code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Python is one of the world's top programming languages and is a favorite of
    data scientists and programmers working in the field of artificial intelligence
    and machine learning. Automation of day-to-day mundane infrastructure tasks has
    been carried out by infrastructure professionals using the Python programming
    language.
  prefs: []
  type: TYPE_NORMAL
- en: Python code has been designed in such a way that programmers can code tasks
    quicker than they can in C#. So, the programming writing experience in Python
    can be quicker than in C#. Some programmers state that Python can be more readable
    than C#, although I find C# easier to read and understand when compared to Python.
    This means that readability is rather subjective, but more programmers create
    programs in Python than they do in C#.
  prefs: []
  type: TYPE_NORMAL
- en: C# beats Python when it comes to compiled code performance. Python can be quicker
    to write but requires a lot of testing and its garbage collector and interpreter
    can affect the performance of Python applications. C# uses JIT, AOT, and Ngen,
    which are also available to VB.NET, C#, F#, and other .NET languages, to perform
    various types of compilation. The result is that C# produces native code on the
    target machine, thus providing much faster-executing code than Python. And with
    the advent of further performance improvements being added to .NET 5 and C# 9.0
    by Microsoft, C# will be even faster than it was in its previous versions.
  prefs: []
  type: TYPE_NORMAL
- en: With so much good work being accomplished in the Python arena, it is good for
    C# programmers to be able to capitalize on Python by using Python code from C#.
    At the same time, some companies are striving to have all their code in a single
    code base, so they want to move away from languages such as Java and Python and
    become fully C#-oriented. Another advantage of moving the existing Python code
    over to C# is that the same tasks will be much faster in C# than they are in Python.
    The first step in being able to move away from Python to C# is to be able to use
    the existing Python code within the C# programming language.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this section, you will learn how to execute Python code inside C#. You will
    also learn how to call and execute an external Python script. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, make sure you add the Python payload from within Visual Studio Installer
    and add Python to your `PATH` environment variable.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Start a new .NET Core 3.1 console application. Then, add the `IronPython` NuGet
    package. This will only work with Python 2.x code. If you require Python 3.x support,
    then use Python.NET, which is available at http//pythonnet.github.io. You will
    need the following `using` statements:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need `System` because we will be outputting text to the console window. The
    `IronPython.Hosting` library is needed to host and execute Python code in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a file called `welcome.py` to the project, set it to `Copy` always, and
    add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This Python code will print out the text to our console window. Add the following
    code to the `Main` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we are prompting the user to input some text. Then, we read the line of
    text the user enters. A variable is created that can be used to execute Python
    code. A `try`/`catch`/`finally` block is then used to execute the Python code.
    First, we execute pure Python code directly from within C#. Then, we execute the
    code that was executed in our Python script. Any exceptions are caught with the
    exception message that was written to the console window. Finally, we wait for
    the user to press any key before we exit.
  prefs: []
  type: TYPE_NORMAL
- en: And that is all there is to executing Python code directly within C# and via
    external Python scripts. Now, let's learn the COM interface.
  prefs: []
  type: TYPE_NORMAL
- en: Performing Component Object Model (COM) interoperability
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Component Object Model** (**COM**) is an interface standard that was introduced
    by Microsoft in 1993\. It enables components written in the same or different
    languages to communicate with each other, and COM components can pass data between
    each other. Communication is accomplished through **Inter-Process Communication**
    (**IPC**) and dynamic object creation. COM is not a programming language; it provides
    a software architecture that consists of binary and network standards.
  prefs: []
  type: TYPE_NORMAL
- en: Many business employees use spreadsheets because they are an easy way to combine
    and manipulate data for various reasons. Spreadsheets are also the perfect tools
    for statistical analysis. Many companies expand the power of spreadsheets by building
    useful add-ons using C# and other languages. But spreadsheets are also useful
    for ingesting data into databases for day-to-day operations and reporting purposes.
    In this section, you will learn how to create and manipulate spreadsheets in C#,
    as well as write C# plugins for Excel.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Visual Studio Tools for Office** (**VSTO**) is only available in .NET 4.8
    and below. It will not work in C# 9 and .NET 5.0\. Due to this, we will perform
    C# interoperability using .NET 4.8\. Microsoft has moved away from VSTO and the
    COM model to focus on the cross-platform extensibility of Excel using JavaScript.
    Since this book is on C#, we will focus on VSTO in .NET 4.8\. To find out more
    about Microsoft Office extensibility using the JavaScript API, please read the
    following documentation: [https://docs.microsoft.com/office/dev/add-ins/develop/understanding-the-javascript-api-for-office](https://docs.microsoft.com/office/dev/add-ins/develop/understanding-the-javascript-api-for-office).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we will provide two demonstrations. The first demonstration
    will read data from an existing spreadsheet. It is useful to know how to do this
    as there is often a business need for programmers to work with spreadsheet data.
    After that, we will add an Excel VSTO add-in for Excel. It can be very useful
    to provide add-ins to end users that make their work more expedient and enjoyable.
  prefs: []
  type: TYPE_NORMAL
- en: Reading data from an Excel spreadsheet
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, we are going to write a small program to read an Excel file,
    count the number of lines, and then update the Excel spreadsheet with the used
    line count from within C#. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a folder called `C:\Temp`. Then, create a new spreadsheet in it called `LineCount.xlsx`.
    Add 10 rows of text in the first column. Save and close the spreadsheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add a new .NET 4.8 console application. Add the following reference using the
    NuGet package manager to install the latest versions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following namespaces to the `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With that, we can interact with Excel from C#. Now, modify the `Main` method,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The preceding code creates a new Excel application. The workbook we created
    and modified earlier on is opened. At this point, we can obtain the actively used
    range on the active sheet and the count of how many rows there are. The count
    is then saved on a new row, after which we can close the workbook and quit Excel.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the code as many times as you like and then open the spreadsheet. You should
    see something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.5 – Excel showing rows added by C#'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.5_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – Excel showing rows added by C#
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, working with Excel files is straightforward.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: The most performant way to populate an Excel spreadsheet from a database result
    set is to use `Worksheet.Range.CopyFromRecordset(Object, Object, Object)`. See
    the official Microsoft documentation at [https://docs.microsoft.com/dotnet/api/microsoft.office.interop.excel.range.copyfromrecordset?view=excel-pia](https://docs.microsoft.com/dotnet/api/microsoft.office.interop.excel.range.copyfromrecordset?view=excel-pia).
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create an Excel add-in.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an Excel add-in
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'What does creating an Excel add-in have to do with.NET high performance? Well,
    VSTO performance can be improved by implementing the following strategies:'
  prefs: []
  type: TYPE_NORMAL
- en: Load VSTO add-ins on demand.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish Office solutions by using Windows Installer.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Bypass Ribbon reflection.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perform expensive operations in a separate thread.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this section, we are going to write an Excel add-in that will appear on
    the **Add-ins** tab within Excel. When the button is clicked, it will read the
    text in the currently selected cell and display the contents in a message box.
    Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new Excel VSTO add-in project. This will target .NET 4.8\. You cannot
    use VSTO with .NET 5.0.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new Ribbon (Visual Designer) and call it `CsRibbonExtension`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename `group1` to `CsGroup` and change the label to `C# Group`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a button to `CsGroup`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the button's name to `GetCellValueButton` and change its label to `Get
    Cell Value`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Double-click the button to generate the click event. Update the click event
    like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In our click event, we save the current language and then change it to American
    English. Then, we obtain the active cell. The `Value2` property is a dynamic type.
    We check if the value for the active cell is null. If the cell is not null, then
    we display the active cell's value in a message box. Finally, we return the language
    to its original language.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, press F5 to deploy the solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open Excel and start a blank workbook.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'On the ribbon, if the **Add-ins** tab is not visible, click on **Customize
    Quick Access Toolbar** and then **More Commands…** to bring up the **Excel Options**
    dialog, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The Excel Options dialog'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.6_B16617.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – The Excel Options dialog
  prefs: []
  type: TYPE_NORMAL
- en: Make sure that the **Add-ins** option is ticked, as shown in the preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click on **OK** to close the dialog. Type anything you like in a cell and then
    click on the **Add-ins** tab. You should see something similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.7 – Excel showing the Add-ins tab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Image87430.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – Excel showing the Add-ins tab
  prefs: []
  type: TYPE_NORMAL
- en: 'Make sure that your text cell is selected. Then, click on the **Get Cell Value**
    ribbon item. You should see a message similar to the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Excel message displaying the text in the active cell'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Image87438.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Excel message displaying the text in the active cell
  prefs: []
  type: TYPE_NORMAL
- en: Loading our VSTO add-in on demand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now, let''s add a performance improvement to our Excel add-in by only loading
    it when the customer demands it instead of at startup. Follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the Excel add-in project and select **Properties**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, select the **Publish** page.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Publish** page, click on the **Options** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the **Publish Options** dialog, select **Office Settings**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Load on Demand** option and click on the **OK** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Bypassing Ribbon reflection
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can bypass Ribbon reflection by overriding `Microsoft.Office.Core.IRibbonExtensibility.CreateRibbonExtensibleObject()`.
    Instead of letting VSTO reflect what Ribbon object to load, you must use a conditional
    statement to explicitly load the correct Ribbon.
  prefs: []
  type: TYPE_NORMAL
- en: Executing expensive operations in a separate thread of execution
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Any time-consuming tasks such as database operations and transferring objects
    over a network should be carried out in separate threads.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You must execute calls to the Office object model in the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: Further performance improvements
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'For further guidance on performance improvements that you can make to VSTO
    add-ins, check out the official Microsoft documentation: [https://docs.microsoft.com/en-us/visualstudio/vsto/improving-the-performance-of-a-vsto-add-in?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/vsto/improving-the-performance-of-a-vsto-add-in?view=vs-2019).'
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have looked at various methods of interacting with other programs
    and programming languages. Now, let's learn how to safely dispose of unmanaged
    code.
  prefs: []
  type: TYPE_NORMAL
- en: Safely disposing of unmanaged code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When working with unmanaged resources, you must explicitly dispose of them yourself
    to free up resources. If you do not, then you may end up with exceptions being
    raised or, worse, your application completely crashing. You must make sure that
    your applications don't continue running and supplying wrong data when exceptions
    are encountered. Should exceptions be encountered where the data would become
    invalid if the application were to continue, then it is better to exit the program.
    You must also make sure that if your application encounters a catastrophic exception
    that it is unable to recover from, either a message is displayed or some kind
    of logging takes place before it shuts down.
  prefs: []
  type: TYPE_NORMAL
- en: 'In C#, there are two ways to dispose of unmanaged resources: using the disposable
    pattern and using finalizers. We will discuss both methods in this section via
    code examples.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding C# finalization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A **finalizer** is a destructor in C# and is used to perform any necessary final
    cleanup that needs to be performed manually. You can use finalizers in classes,
    but you cannot use them in structs. A class can have one finalizer, but a class
    cannot inherit or overload finalizers. You cannot call finalizers as they are
    invoked automatically when the class is destroyed. Also, modifiers do not accept
    modifiers or have any parameters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You have no control over when a finalizer runs. If the GC was to run too infrequently,
    then you could experience `OutOfMemory` exceptions. Instead of relying on finalizers,
    you should implement the Dispose design pattern best practice, which will call
    the finalizer as a last resort. Consider finalizer code running as a bug when
    you're disposing of managed and unmanaged objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are two syntactic ways to write finalizers in C#. The first is the classic
    method, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: 'The second way to write a finalizer is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: As a programmer, you must know that, despite using finalizers to clean up code,
    you have no control over whether or when the garbage collector will call them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: As a rule of thumb, most of your code is managed code. This means that there
    should never be a need for you to touch finalizers. Only use them if you need
    to when cleaning up unmanaged objects.
  prefs: []
  type: TYPE_NORMAL
- en: Using the disposable pattern to release managed and unmanaged resources
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'When you''re dealing with managed and unmanaged objects, it is necessary to
    implement the disposable design pattern. The disposable pattern implements the
    `Dispose(bool disposing)` method, as shown in the source code for the `CH02_ObjectCleanup`
    project on GitHub. This is what we will do in this demonstration. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Start a new .NET console application. Then, add a class called `DisposableBase`,
    as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, we declared the class abstract and implemented the `IDisposable` interface.
    Our `_disposed` Boolean value will be accessed by subclasses, so we need to declare
    that it is protected. Add the `Dispose()` method, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'This method calls the `Dispose(bool disposing)` method, which cleans up both
    managed and unmanaged resources. Then, it stops the finalizer from being executed.
    Let''s add the finalizer:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Should our finalizer run – and it is not guaranteed to run – it will call the
    `Dispose(bool disposing)` method when the programmer fails to call the `Dispose()`
    method. Now, let''s add the final part of our `DisposableBase` class – that is,
    the `Disposable(bool disposing)` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If our class has already been disposed of, then we can exit the method. If the
    class has not been disposed of, then we must free up managed resources. Once the
    managed resources have been cleaned up, we can clean up the unmanaged objects
    and set large fields to null. Finally, we must set the `_disposed` Boolean to
    `true`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a class inherits our abstract class, its finalizer will call `Dispose(false)`.
    The subclass will override the `Dispose(bool disposing)` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create an object and destroy it, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: Here, the `ObjectThree` class is instantiated and then disposed of by calling
    the `Dispose()` method.
  prefs: []
  type: TYPE_NORMAL
- en: That brings us to the end of this chapter on C# interoperability. Let's summarize
    what we have learned.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by looking into P/Invoke regarding C# interoperability
    using pointer code. We looked at unsafe and fixed code. Unsafe code is code that
    is not managed by the .NET platform, while mixed code is objects fixed in memory
    that are not promoted by the garbage collector because they are accessed using
    pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned how to call methods in a C++ DLL, including passing parameters
    and returning structs.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we learned how to interact with Python code. We learned how to install
    Python and then add the IronPython NuGet package. This allows us to execute Python
    2.x code directly in a C# class and execute Python code that resides in a Python
    script. The ironPython 2.7.10 library only supports Python 2.x versions.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we learned how to perform COM interoperability by reading data from an
    Excel spreadsheet. We also built an Excel add-in that was able to read the data
    of the active cell and display a message box.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we learned how to safely dispose of managed and unmanaged objects.
    We built a reusable abstract class called `DisposableBase`. At this point, you
    know to call `Disposable(false)` in subclass finalizers if `Dispose()` is not
    called, as well as how to override `Disposable(bool disposing)` in your base classes.
  prefs: []
  type: TYPE_NORMAL
- en: Now, it is time for you to answer some questions to reinforce your learning
    before moving on to the *Further reading* section. In the next chapter, we will
    learn about primitives and object types.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Answer the following questions to test your knowledge of this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: What is P/Invoke short for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain what P/Invoke is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `unsafe` keyword used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Explain object generations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the `fixed` keyword used for?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What is the C++ type for a string?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What NuGet package do you have to import to work with Python code?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What pattern do you use to safely dispose of managed and unmanaged objects?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How do you dispose of large fields?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Unsafe code language specification*: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/unsafe-code).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*C# tutorial for beginners: What is Unsafe Code?* [https://www.youtube.com/watch?v=oIqEBMw_Syk](https://www.youtube.com/watch?v=oIqEBMw_Syk).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Interoperating with unmanaged code*: [https://docs.microsoft.com/en-us/dotnet/framework/interop/](https://docs.microsoft.com/en-us/dotnet/framework/interop/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Interop Marshaling*: [https://docs.microsoft.com/en-us/dotnet/framework/interop/interop-marshaling](https://docs.microsoft.com/en-us/dotnet/framework/interop/interop-marshaling).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Marshalling Data with Platform Invoke*: [https://docs.microsoft.com/en-us/dotnet/framework/interop/marshaling-data-with-platform-invoke](https://docs.microsoft.com/en-us/dotnet/framework/interop/marshaling-data-with-platform-invoke).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*P/Invoke Tips*: [http://benbowen.blog/post/pinvoke_tips/](http://benbowen.blog/post/pinvoke_tips/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Debugging Finalizers*: [https://docs.microsoft.com/en-us/archive/msdn-magazine/2007/november/net-matters-debugging-finalizers](https://docs.microsoft.com/en-us/archive/msdn-magazine/2007/november/net-matters-debugging-finalizers).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Destructors in C#*: [https://www.geeksforgeeks.org/destructors-in-c-sharp/](https://www.geeksforgeeks.org/destructors-in-c-sharp/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '.NET Memory Performance Analysis: [https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md#The-effect-of-a-generational-GC](https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md#The-effect-of-a-generational-GC).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Improving the performance of a VSTO add-in*: [https://docs.microsoft.com/en-us/visualstudio/vsto/improving-the-performance-of-a-vsto-add-in?view=vs-2019](https://docs.microsoft.com/en-us/visualstudio/vsto/improving-the-performance-of-a-vsto-add-in?view=vs-2019).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*When everything you know is wrong, part one*: [https://ericlippert.com/2015/05/18/when-everything-you-know-is-wrong-part-one/](https://ericlippert.com/2015/05/18/when-everything-you-know-is-wrong-part-one/).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*.NET Memory Performance Analysis*: [https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md.](https://github.com/Maoni0/mem-doc/blob/master/doc/.NETMemoryPerformanceAnalysis.md.)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*OLE/Automation BSTR (String Manipulation Functions)*: [https://docs.microsoft.com/previous-versions/windows/desktop/automat/string-manipulation-functions](https://docs.microsoft.com/previous-versions/windows/desktop/automat/string-manipulation-functions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*How to pass arrays of objects from C# to C++*: [https://alekdavis.blogspot.com/2012/07/how-to-pass-arrays-of-objects-from-c-to.html](https://alekdavis.blogspot.com/2012/07/how-to-pass-arrays-of-objects-from-c-to.html).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
