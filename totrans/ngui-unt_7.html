<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch07"/>Chapter 7. Creating a Game with NGUI</h1></div></div></div><p>In this final chapter, we will create a game using NGUI elements, and this will ensure that you understand them and know how to use them perfectly.</p><p>Together, we will learn how to<a id="id297" class="indexterm"/> create these basic game rules, which are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">Enemies fall down from the top of our scrollable viewport.</li><li class="listitem">The player drops Barriers on the Viewport—if the enemy collides with a built Barrier, he or she is destroyed along with the Barrier.</li><li class="listitem">Some enemies have encrypted self-destruct code. The player clicks on the enemy to hack it. When the hacking process is complete, its destruct code is displayed above it.</li><li class="listitem">The player must type in the code to destroy the enemy.</li></ol></div><p>We will also add a health bar that will represent the player's health points and will decrease when enemies hit the bottom of the screen. The game will look as follows:</p><div><img src="img/8667OT_07_01.jpg" alt="Creating a Game with NGUI"/></div><div><div><div><div><h1 class="title"><a id="ch07lvl1sec50"/>Enemy spawning</h1></div></div></div><p>We want <a id="id298" class="indexterm"/>our enemies to spawn at the top of the viewport's background.<a id="id299" class="indexterm"/> At spawn, the Y value can be the same for each of the enemies, but we want a random X value.</p><p>First of all, let's open our <strong>Game</strong> scene.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec67"/>Creating the enemies container</h2></div></div></div><p>Our enemies<a id="id300" class="indexterm"/> will be nested in a container placed at the top left-hand corner of our background in order to have the {0, 0} positioned at the top left-hand corner of the viewport.</p><p>First, let's create our enemies holder by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select our <strong>Viewport</strong> GameObject and perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Create a new child by pressing <em>Alt</em> + <em>Shift</em> + <em>N</em>.</li><li class="listitem">Rename this new child as <code class="literal">Enemies</code>.</li></ol></div></li><li class="listitem">Attach <strong>Anchor</strong> to it by navigating to <strong>NGUI</strong> | <strong>Attach</strong>. Then perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Drag our <strong>Background</strong> from Viewport into the <strong>Container</strong> field.</li><li class="listitem">Set its <strong>Side</strong> parameter to <strong>TopLeft</strong>.</li></ol></div></li></ol></div><p>Ok, we now have our enemies container in which we will instantiate our <strong>Enemy</strong> prefab.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec68"/>Creating the Enemy prefab</h2></div></div></div><p>Let's create <a id="id301" class="indexterm"/>the <strong>Enemy</strong> prefab that will be instantiated as child of the <strong>Enemies</strong> GameObject. You must add the <code class="literal">Enemy.png</code> file included in the <code class="literal">Assets.zip</code> file to the <strong>Game</strong> atlas before you continue or you may create your own 128 x 160 sprite. We will use a <strong>Rigidbody</strong> to detect collisions between the enemies and our barriers.</p><p>Once the <code class="literal">Enemy.png</code> sprite has been added to the <strong>Game</strong> atlas, follow the given steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select our <strong>Viewport</strong> GameObject and perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Create a new child with <em>Alt</em> + <em>Shift</em> + <em>N</em>.</li><li class="listitem">Rename this new child as <code class="literal">Spaceship</code>.</li></ol></div></li><li class="listitem">Select our new <strong>Spaceship</strong> GameObject.</li><li class="listitem">Attach a collider to it by navigating to <strong>NGUI</strong> | <strong>Attach a Collider</strong> and perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Uncheck its <strong>Is Trigger</strong> Boolean to detect collisions.</li><li class="listitem">Set <strong>Size</strong> to {<code class="literal">128</code>, <code class="literal">160</code>, <code class="literal">1</code>}.</li></ol></div></li><li class="listitem">Attach a <strong>Rigidbody</strong> component to it by navigating to <strong>Component</strong> | <strong>Physics</strong> and then perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Uncheck its <strong>Use Gravity</strong> Boolean.</li><li class="listitem">Check its <strong>Is Kinematic</strong> Boolean.</li><li class="listitem">Check the <strong>Freeze Position</strong> and <strong>Freeze Rotation</strong> Booleans for all its <strong>Constraints</strong> in order to avoid any unwanted behavior.</li></ol></div></li><li class="listitem">With our selected <strong>Spaceship</strong> GameObject, create a new <strong>Sprite</strong> by navigating to <strong>NGUI</strong> | <strong>Create</strong> | <strong>Sprite</strong>:<div><ol class="orderedlist arabic"><li class="listitem">Change its <strong>Sprite</strong> to our new <strong>Enemy</strong> sprite.</li><li class="listitem">Change its <strong>Dimensions</strong> to <code class="literal">128</code> x <code class="literal">160</code>.</li><li class="listitem">Set its <strong>Depth</strong> to <code class="literal">1</code>.</li></ol></div></li><li class="listitem">Drag our <strong>Spaceship</strong> GameObject in your <code class="literal">Prefabs</code> folder.</li><li class="listitem">Delete our <strong>Spaceship</strong> instance from the scene.</li></ol></div><p>Ok, we now have our <strong>Enemy</strong> prefab ready. Let's add a new script to it that will handle the enemy's initialization and movement, and perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <strong>Project</strong> view, select our <strong>Spaceship</strong> prefab.</li><li class="listitem">Create and attach a new <code class="literal">EnemyController.cs</code> C# script to it.</li><li class="listitem">Open this new <code class="literal">EnemyController.cs</code> script.</li></ol></div><p>Let's create <a id="id302" class="indexterm"/>a new <code class="literal">Initialize()</code> method that will set the enemy's position outside the game with a random X and a tween duration depending on the float value that is passed as a parameter in the following manner:</p><div><pre class="programlisting">public void Initialize(float _movementDuration)
{
  //Get the Viewport's Background size
  Vector2 bgSize = 
    transform.parent.parent.FindChild("Background").GetComponent&lt;UISprite&gt;().localSize;
  //Get this enemy's sprite size
  Vector2 spriteSize = 
    transform.FindChild("Sprite").GetComponent&lt;UISprite&gt;().localSize;
  //Set its position to a random X, and Y of -(enemyHeight/2)
  transform.localPosition = 
<strong>    new Vector3(Random.Range(spriteSize.x *0.5f, bgSize.x - (spriteSize.x *0.5f)), -(spriteSize.y *0.5f), 0);</strong>
  //Tween its position towards end of background
  TweenPosition.Begin(gameObject, _movementDuration,
    new Vector3(transform.localPosition.x, -bgSize.y + (spriteSize.y * 0.5f), 0));
}</pre></div><p>We used <code class="literal">spriteSize.x * 0.5f</code> in the preceding code because our enemy has a centered pivot and we want to avoid spawning it outside the background's width.</p><p>The <code class="literal">_movementDuration</code> parameter is used to define how much time the enemy will take to cross our entire background; it is used as speed. But to balance the speed, a value of 10 is used, which means that the enemy will need 10 seconds to hit the bottom of the background.</p><p>At this stage, your hierarchy should look as follows:</p><div><img src="img/8667OT_07_02.jpg" alt="Creating the Enemy prefab"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec69"/>Creating the enemy spawn controller</h2></div></div></div><p>Before<a id="id303" class="indexterm"/> we can launch the game, we need to add an <code class="literal">EnemySpawnController.cs</code> script<a id="id304" class="indexterm"/> that will handle enemy spawn rates and instantiate enemies when needed. To add the script, perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select the <strong>Enemies</strong> GameObject from <strong>Viewport</strong>.</li><li class="listitem">Create and attach a new <code class="literal">EnemySpawnController.cs</code> C# script.</li><li class="listitem">Open this new <code class="literal">EnemySpawnController.cs</code> script.</li></ol></div><p>In this new script, we need to add a <code class="literal">SpawnEnemy()</code> coroutine that will be called at random intervals to instantiate <strong>Enemy</strong> prefabs and initialize them with the correct position and tween duration. First, we need to declare these variables as shown in the following code snippet:</p><div><pre class="programlisting">//We need our Enemy Prefab for Instantiation
public Object enemyPrefab;
//Random-control variables
public int firstEnemyDelay = 1;
//Min and Max intervals between 2 spawns
public float minInterval = 4;
public float maxInterval = 15;
//Min and Max Enemy MovementTime
public float minMovementTime = 20;
public float maxMovementTIme = 50;</pre></div><p>The variables declared in the previous code will be used to control our random values. You may change them in the <strong>Inspector</strong> view. We need to assign our <code class="literal">enemyPrefab</code> variable.</p><p>To do this, go back to Unity and follow the given steps:</p><div><ol class="orderedlist arabic"><li class="listitem">Select the <strong>Enemies</strong> GameObject from <strong>Viewport</strong>.</li><li class="listitem">Drag our <strong>Spaceship</strong> prefab from the <strong>Project</strong> view inside the <strong>Enemy Prefab</strong> field in <strong>Enemy Spawn Controller</strong>.</li></ol></div><p>Ok, the necessary <a id="id305" class="indexterm"/>variables are initialized. Now, let's go back to our <code class="literal">EnemySpawnController.cs</code> script and add a new <code class="literal">SpawnEnemy()</code> coroutine by using the following code snippet:</p><div><pre class="programlisting">//Coroutine that spawns enemies
IEnumerator SpawnEnemy()
{
  //First time, set to firstEnemyDelay
  float delay = firstEnemyDelay;
  //Loop while the game is running
  while(true){
    //Wait for the correct delay
    yield return new WaitForSeconds(delay);
    //Create a new enemy, stock its EnemyController
    EnemyController newEnemy =
      NGUITools.AddChild(gameObject, enemyPrefab as GameObject).GetComponent&lt;EnemyController&gt;();
    //Initialize it with random speed
    newEnemy.Initialize(Random.Range (minMovementTime, maxMovementTIme));
    //Set the new random delay
    delay = Random.Range(minInterval, maxInterval);
  }
}</pre></div><p>Our coroutine is ready. Let's start it when the game starts running. We can use the <code class="literal">Start()</code> method for this. Add this method just below our <code class="literal">SpawnEnemy()</code> coroutine in the following manner:</p><div><pre class="programlisting">void Start ()
{
  //Start the Spawn Coroutine with first delay
  StartCoroutine(SpawnEnemy());
}</pre></div><p>Save the script and click on the play button. The first enemy is spawned after the <code class="literal">firstEnemyDelay</code>. After the first enemy, new enemies are spawned at random X positions, at random intervals, and at a random speed.</p><p>Your <strong>Hierarchy</strong> view should look as follows when a few enemies have spawned:</p><div><img src="img/8667OT_07_03.jpg" alt="Creating the enemy spawn controller"/></div><p>Spawned enemies move down and stop at the end of the Viewport's background as shown in the following screenshot:</p><div><img src="img/8667OT_07_04.jpg" alt="Creating the enemy spawn controller"/></div></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec70"/>Forwarding events to viewport</h2></div></div></div><p>Ok, we<a id="id306" class="indexterm"/> now have our mobile enemies, but we still have a slight problem. You may have noticed that you cannot drag the viewport if you click on an enemy. We had the same problem before with the <strong>ActiveBarrier</strong> prefab.</p><p>We need to add a <strong>UIForwardEvents</strong> component to the <strong>Spaceship</strong> prefab by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <strong>Project</strong> view, select our <strong>Spaceship</strong> prefab.</li><li class="listitem">Attach a <strong>Forward Events</strong> component to it by navigating to <strong>Component</strong> | <strong>NGUI</strong> | <strong>Interaction</strong>. Then perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Check its <strong>OnPress</strong> Boolean.</li><li class="listitem">Check its <strong>OnDrag</strong> Boolean.</li></ol></div></li><li class="listitem">Open its attached <code class="literal">EnemyController.cs</code> script.</li></ol></div><p>Add the following line at the end of the <code class="literal">Initialize()</code> method of <code class="literal">EnemyController.cs</code> script:</p><div><pre class="programlisting">//Set the Viewport as target for UIForwardEvents
GetComponent&lt;UIForwardEvents&gt;().target = transform.parent.parent.gameObject;</pre></div><p>You can now pan the viewport even if you click on an enemy. It is time to handle collisions with barriers.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec51"/>Handling enemy collisions</h1></div></div></div><p>We need to<a id="id307" class="indexterm"/> handle collisions between our enemies and<a id="id308" class="indexterm"/> ActiveBarriers. Since we have a Rigidbody attached to our <strong>Enemy</strong> prefab, it will receive the <code class="literal">OnTriggerEnter()</code> event<a id="id309" class="indexterm"/> when it hits the collider of an <strong>ActiveBarrier</strong> GameObject.</p><p>Once the collisions with ActiveBarriers are implemented, we'll add collisions with the bottom of the screen, which will reduce the player's health.</p><div><div><div><div><h2 class="title"><a id="ch07lvl2sec71"/>Collisions with active barriers</h2></div></div></div><p>First of all,<a id="id310" class="indexterm"/> we must disable the ActiveBarrier's collider by default and enable it when the barrier is built in the following manner:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <strong>Project</strong> view, select our <strong>ActiveBarrier</strong> prefab.</li><li class="listitem">Disable its <strong>Box Collider</strong> component using its checkbox.</li><li class="listitem">Open the <code class="literal">ActiveBarrierController.cs</code> script attached to it.</li><li class="listitem">We will need a new <code class="literal">built</code> boolean that will help us know if the barrier has finished its building process. Along with our <code class="literal">UISlider</code> and <code class="literal">UILocalize</code> variables, declare the following:<div><pre class="programlisting">private bool built = false;</pre></div></li><li class="listitem">Now, add the following two lines at the end of the <a id="id311" class="indexterm"/><code class="literal">BuildFinished()</code> method:<div><pre class="programlisting">//Set the build value to true and activate collider
built = true;
collider.enabled = true;</pre></div></li><li class="listitem">Ok, now the collider is enabled only when the barrier is built. We can add a <code class="literal">HitByEnemy()</code> method with the concerned <code class="literal">enemy</code> passed as a parameter that will destroy t<a id="id312" class="indexterm"/>he barrier and the enemy in the following manner:<div><pre class="programlisting">public void HitByEnemy(EnemyController enemy)
{
  //If the barrier isn't built, don't go further
  if(!built) return;
  //Else, kill the enemy
  StartCoroutine(enemy.Kill());
  //Kill the barrier too
  StartCoroutine(RemoveBarrier());
}</pre></div></li><li class="listitem">Here, we start two coroutines: one to kill the enemy and another one to remove<a id="id313" class="indexterm"/> the barrier. Let's add the <code class="literal">RemoveBarrier()</code> coroutine now with the following code snippet:<div><pre class="programlisting">IEnumerator RemoveBarrier()
{
  //Tween for smooth disappearance
  TweenScale.Begin(gameObject, 0.2f, Vector3.zero);
  //Notify the Viewport that a Barrier has been removed
  transform.parent.SendMessage("BarrierRemoved");
  //Wait for end of tween, then destroy the barrier
  yield return new WaitForSeconds(0.2f);
  Destroy(gameObject);
}</pre></div><p>The coroutine in the previous code scales down the barrier before it is destroyed. We send a message to the parent (<strong>Viewport</strong>) because we need to decrease the <code class="literal">barrierCount</code> value.</p></li><li class="listitem">Let's add the <code class="literal">BarrierRemoved()</code> method<a id="id314" class="indexterm"/> in the <code class="literal">ViewportHolder.cs</code> script. In the <strong>Hierarchy</strong> view, select our <strong>Viewport</strong> GameObject and open the <code class="literal">ViewportHolder.cs</code> script attached to it.</li><li class="listitem">In our <code class="literal">ViewportHolder.cs</code> script, add the following new <code class="literal">BarrierRemoved()</code> method:<div><pre class="programlisting">void BarrierRemoved()
{
  //Decrease the barrierCount value
  barrierCount--;
}</pre></div></li><li class="listitem">The <code class="literal">barrierCount</code> value will be updated as soon as a barrier is destroyed. Now, let's open the <code class="literal">EnemyController.cs</code> script and add the <code class="literal">Kill()</code> coroutine as shown in the following code snippet:<div><pre class="programlisting">public IEnumerator Kill()
{
  //Tween for smooth disappearance
  TweenScale.Begin(gameObject, 0.2f, Vector3.zero);
  //Deactivate the collider now
  collider.enabled = false;
  //Wait end of tween, then destroy the enemy
  yield return new WaitForSeconds(0.2f);
  Destroy(gameObject);
}</pre></div></li><li class="listitem">Great! All of our coroutines and methods are ready. Now, we need to call the <code class="literal">HitByEnemy()</code> method of the concerned <strong>ActiveBarrier</strong> when a collision occurs.</li><li class="listitem">We just have to add the following <code class="literal">OnTriggerEnter()</code> method inside our <code class="literal">EnemyController.cs</code> script, which will call this method only if the collided object actually is a barrier:<div><pre class="programlisting">void OnTriggerEnter(Collider other)
{
  //Store the collided object's ActiveBarrierController
  ActiveBarrierController barrierController = other.GetComponent&lt;ActiveBarrierController&gt;();
  //If it has a BarrierController, call HitByEnemy
  if(barrierController != null)
  barrierController.HitByEnemy(this);
}</pre></div></li><li class="listitem">Save all of<a id="id315" class="indexterm"/> the scripts and click on the play button. </li></ol></div><p>If you place a barrier on an enemy's trajectory, both of them will be destroyed when they collide! If the building process isn't over, nothing happens.</p><p>In the case where a barrier finishes its building process while an enemy is still inside it, a collision will occur. Perfect!</p><p>Now that the player can destroy his or her enemies, let's add a way for the enemies to destroy the player.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec72"/>Colliding with the bottom of the screen</h2></div></div></div><p>We can<a id="id316" class="indexterm"/> now add a collider at the bottom of the viewport's background that will destroy enemies and reduce the player's health. Before we do this, let's create a Healthbar with a HealthController script.</p><div><div><div><div><h3 class="title"><a id="ch07lvl3sec27"/>Healthbar</h3></div></div></div><p>To create<a id="id317" class="indexterm"/> this Healthbar<a id="id318" class="indexterm"/>, we need the <code class="literal">Button.png</code> file available in the <code class="literal">Assets.zip</code> file. If you haven't added it to the <strong>Game</strong> Atlas as a sliced sprite yet, please do so before you continue.</p><p>We will use a Progress Bar to create a Healthbar on which we will add a <code class="literal">HealthController.cs</code> script to handle the display of damage and health points. Perform the <a id="id319" class="indexterm"/>following steps to do so:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <strong>Hierarchy</strong> view, select the <strong>UI</strong> GameObject from <strong>Anchor</strong>.</li><li class="listitem">Open the <strong>Widget Tool</strong> window by navigating to <strong>NGUI</strong> | <strong>Create a Widget</strong>. Then perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Select our <strong>Game</strong> Atlas.</li><li class="listitem">Select the <strong>Progress Bar</strong> template.</li><li class="listitem">Select our <strong>Button</strong> sprite for the <strong>Empty</strong> field.</li><li class="listitem">Select our <strong>Button</strong> sprite for the <strong>Full</strong> field.</li><li class="listitem">With our <strong>UI</strong> GameObject selected, click on the <strong>Add To</strong> button.</li></ol></div></li><li class="listitem">Select <a id="id320" class="indexterm"/>the new <strong>Progress Bar</strong> GameObject and rename it as <code class="literal">Healthbar</code>.</li><li class="listitem">Attach an <strong>Anchor</strong> to it by navigating to <strong>NGUI</strong> | <strong>Attach</strong>. Then perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Drag our <strong>Viewport</strong> GameObject in the <strong>Container</strong> field.</li><li class="listitem">Set the <strong>Side</strong> parameter to <strong>Top</strong>.</li><li class="listitem">Set <strong>Pixel Offset</strong> to {<code class="literal">-160</code>, <code class="literal">-30</code>}.</li></ol></div></li><li class="listitem">Select the <strong>Background</strong> GameObject from <strong>Healthbar</strong> and perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Set <strong>Color Tint</strong> to {<code class="literal">255</code>, <code class="literal">120</code>, <code class="literal">120</code>, <code class="literal">140</code>}.</li><li class="listitem">Set <strong>Dimensions</strong> to <code class="literal">320</code> x <code class="literal">42</code>.</li><li class="listitem">Change <strong>Sprite Type</strong> to <strong>Sliced</strong>.</li><li class="listitem">Click on the <strong>Edit</strong> button next to the <strong>Sprite</strong> field.</li><li class="listitem">Set all four border values to <code class="literal">6</code> for slicing parameters.</li></ol></div></li><li class="listitem">Select the <strong>Foreground</strong> GameObject from <strong>Healthbar</strong> and then perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Set <strong>Color Tint</strong> to {<code class="literal">25</code>, <code class="literal">245</code>, <code class="literal">255</code>, <code class="literal">255</code>}.</li><li class="listitem">Set <strong>Dimensions</strong> to <code class="literal">320</code> x <code class="literal">42</code>.</li><li class="listitem">Change <strong>Sprite Type</strong> to <strong>Sliced</strong>.</li></ol></div></li></ol></div><p>Ok, we have a configured health bar centered at the top of the screen. We need to add a script to it that will handle health points and modify the value of <strong>Slider</strong> accordingly. The steps to do so are as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <strong>Hierarchy</strong> view, select our <strong>Healthbar</strong> GameObject.</li><li class="listitem">Create and add a new <code class="literal">HealthController.cs</code> script to it.</li><li class="listitem">Open this new <code class="literal">HealthController.cs</code> script.</li></ol></div><p>In this new script, we will save a static reference to the instance of the <code class="literal">HealthController</code> class so that its methods are easily accessible from other scripts. First, let's declare necessary variables and initialize them on <code class="literal">Awake()</code> as shown in the following code:</p><div><pre class="programlisting">//Static variable that will store this instance
public static HealthController Instance;
//We will need the attached slider and a HP value
private UISlider slider;
private float hp = 100;

void Awake()
{
  //Store this instance in the Instance variable
  Instance = this;
  //Get the slider Component
  slider = GetComponent&lt;UISlider&gt;();
}</pre></div><p>Ok, our <a id="id321" class="indexterm"/>variables are now initialized correctly. Let's create a <code class="literal">Damage()</code> method that will reduce the <code class="literal">hp</code> value and update the slider as follows:</p><div><pre class="programlisting">public void Damage(float dmgValue)
{
  //Set new HP value with a clamp between 0 and 100
  hp = Mathf.Clamp(hp - dmgValue, 0, 100);
  //Update the slider to a value between 0 and 1
  slider.value = hp * 0.01f;
  //If hp &lt;= 0, restart level
  if(hp &lt;= 0)
  Application.LoadLevel(Application.loadedLevel);
}</pre></div><p>Great! The <code class="literal">Damage()</code> method<a id="id322" class="indexterm"/> is ready. Let's create the <strong>EndOfScreen</strong> widget that will collide with the enemies.</p></div><div><div><div><div><h3 class="title"><a id="ch07lvl3sec28"/>The EndOfScreen widget</h3></div></div></div><p>Let's create<a id="id323" class="indexterm"/> the <a id="id324" class="indexterm"/>
<strong>EndOfScreen</strong> widget that will help detect enemy collisions as follows:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <strong>Hierarchy</strong> view, select our <strong>Viewport</strong> GameObject and perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Create a new child by pressing <em>Alt</em> + <em>Shift</em> + <em>N</em>.</li><li class="listitem">Rename this new child as <code class="literal">EndOfScreen</code>.</li></ol></div></li><li class="listitem">Attach a collider to it by navigating to <strong>NGUI</strong> | <strong>Attach a Collider</strong> and set <strong>Size</strong> to {<code class="literal">3840</code>, <code class="literal">43</code>, <code class="literal">1</code>}.</li><li class="listitem">Attach <a id="id325" class="indexterm"/><strong>Anchor</strong> to it by navigating to <strong>NGUI</strong> | <strong>Attach</strong>.<div><ol class="orderedlist arabic"><li class="listitem">Drag the <strong>Background</strong> GameObject from <strong>Viewport</strong> in the <strong>Container</strong> field.</li><li class="listitem">Set its <strong>Side</strong> parameter to <strong>Bottom</strong>.</li><li class="listitem">Set its <strong>Pixel Offset</strong> to {<code class="literal">0</code>, <code class="literal">33</code>}.</li></ol></div></li><li class="listitem">Click <a id="id326" class="indexterm"/>on the <strong>Untagged / Add Tag…</strong> button at the top of the <strong>Inspector</strong> view.</li><li class="listitem">Create a new <code class="literal">DamageZone</code> tag.</li><li class="listitem">Select our <strong>EndOfScreen</strong> GameObject.</li><li class="listitem">Set <strong>Tag</strong> to <strong>DamageZone</strong>.</li><li class="listitem">Make sure our <strong>EndOfScreen</strong> GameObject is selected.</li><li class="listitem">Create a new sprite by navigating to <strong>NGUI</strong> | <strong>Create</strong> | <strong>Sprite</strong> and perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Set its <strong>Atlas</strong> type to the <strong>SciFi</strong> Atlas.</li><li class="listitem">Set its <strong>Sprite</strong> type to the <strong>Honeycomb</strong> sprite.</li><li class="listitem">Set its <strong>Sprite Type</strong> to <strong>Tiled</strong>.</li><li class="listitem">Set its <strong>Color Tint</strong> values to <strong>R</strong>: <code class="literal">255</code>, <strong>G</strong>: <code class="literal">120</code>, <strong>B</strong>: <code class="literal">120</code>, and <strong>A</strong>: <code class="literal">255</code>.</li><li class="listitem">Set its <strong>Depth</strong> value to <code class="literal">2</code>.</li><li class="listitem">Set its <strong>Dimensions</strong> parameter to <code class="literal">3840</code> x <code class="literal">43</code>.</li></ol></div></li></ol></div><p>Good. We now have an <strong>EndOfScreen</strong> limit with a sprite and a collider. Now, we need to edit our <code class="literal">EnemyController.cs</code> script's <code class="literal">OnTriggerEnter()</code> method<a id="id327" class="indexterm"/> to check if the collided object has the <strong>DamageZone</strong> tag and hurt the player if needed. Perform the following steps to do so:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <strong>Project</strong> view, select our <strong>SpaceShip</strong> prefab and open the <code class="literal">EnemyController.cs</code> script attached to it.</li><li class="listitem">Within the <code class="literal">EnemyController.cs</code> script, at the very first line of the <code class="literal">OnTriggerEnter()</code> method, add the following lines to check if the collided object has a <strong>DamageZone</strong> tag:<div><pre class="programlisting">//Is the collided object a DamageZone?
if(other.CompareTag("DamageZone"))
{
  //In that case, hurt the player
  HealthController.Instance.Damage(30f);
  //Then, kill the enemy and don't go further
  StartCoroutine(Kill());
  return;
}</pre></div></li><li class="listitem">Save all of the <a id="id328" class="indexterm"/>scripts and click on the play button. Now, our enemies are destroyed when they collide with the end of the Viewport, and the player's health is decreased!</li></ol></div><p>Now, let's add another way to destroy our enemies.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec52"/>Creating self-destruct code</h1></div></div></div><p>Dropping <a id="id329" class="indexterm"/>barriers on the screen is not enough. <a id="id330" class="indexterm"/>We will use a self-destruct code to destroy enemies too.</p><p>Each enemy will get a chance to have a self-destruct code. If it has one, an empty slider with <strong>Code Encrypted</strong> displayed inside it will appear above the concerned enemy.</p><p>When the player clicks on the enemy, the hacking process starts. When the hacking is complete, a word will appear as shown in the following screenshot, and the player will have to type it on his keyboard to destroy it:</p><div><img src="img/8667OT_07_05.jpg" alt="Creating self-destruct code"/></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec73"/>The hacking slider</h2></div></div></div><p>Let's start<a id="id331" class="indexterm"/> by creating the hacking slider indicator inside our <strong>Spaceship</strong> prefab by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <strong>Project</strong> view, select our <strong>Spaceship</strong> prefab.</li><li class="listitem">Drag it in the <strong>Hierarchy</strong> view as child of the <strong>Viewport</strong> GameObject.</li><li class="listitem">Open the <strong>Wiget Tool</strong> window by navigating to <strong>NGUI</strong> | <strong>Create a Widget</strong> and then perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Select the <strong>Game</strong> Atlas.</li><li class="listitem">Select the <strong>Progress Bar</strong> template.</li><li class="listitem">Select the <strong>Button</strong> sprite for the <strong>Empty</strong> field.</li><li class="listitem">Select the <strong>Button</strong> sprite for the <strong>Full</strong> field.</li></ol></div></li><li class="listitem">With<a id="id332" class="indexterm"/> our <strong>Spaceship</strong> instance selected, click on the <strong>Add To</strong> button.</li><li class="listitem">Select the new <strong>Progress Bar</strong> GameObject and perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Rename it as <code class="literal">DestructCode</code>.</li><li class="listitem">Set its <strong>Transform</strong> position to {<code class="literal">-100</code>, <code class="literal">100</code>, <code class="literal">0</code>}.</li><li class="listitem">Set the value of <strong>UISlider</strong> to <code class="literal">0</code>.</li></ol></div></li><li class="listitem">Select the <strong>Background</strong> GameObject from <strong>DestructCode</strong>. Then perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Change its <strong>Color Tint</strong> values to {<code class="literal">255</code>, <code class="literal">140</code>, <code class="literal">140</code>, <code class="literal">255</code>}.</li><li class="listitem">Set its <strong>Depth</strong> value to <code class="literal">2</code>.</li></ol></div></li><li class="listitem">Select the <strong>Foreground</strong> GameObject from <strong>DestructCode</strong> and then perform the given steps:<div><ol class="orderedlist arabic"><li class="listitem">Change <strong>Color Tint</strong> to {<code class="literal">50</code>, <code class="literal">180</code>, <code class="literal">220</code>, <code class="literal">255</code>}.</li><li class="listitem">Set its <strong>Depth</strong> value to <code class="literal">3</code>.</li></ol></div></li></ol></div><p>Ok, the slider is ready. Let's add a label that will display <strong>Code Encrypted</strong> and will change to the self-destruct code when the hacking process is finished.</p><div><ol class="orderedlist arabic"><li class="listitem">In the <strong>Hierarchy</strong> view, select our <strong>DestructCode</strong> GameObject.</li><li class="listitem">Open the <strong>Widget Tool</strong> window by navigating to <strong>NGUI</strong> | <strong>Create a Widget</strong> and perform the given steps:<div><ol class="orderedlist arabic"><li class="listitem">Select the <strong>SciFi Font – Normal</strong> font.</li><li class="listitem">Select the <strong>Label</strong> template.</li><li class="listitem">Change the <strong>Color</strong> to <strong>R</strong>: <code class="literal">255</code>, <strong>G</strong>: <code class="literal">215</code>, <strong>B</strong>: <code class="literal">190</code>, and <strong>A</strong>: <code class="literal">255</code>.</li></ol></div></li><li class="listitem">With the <strong>DestructCode</strong> GameObject selected, click on the <strong>Add To</strong> button.</li><li class="listitem">Select the new <strong>Label</strong> GameObject from <strong>DestructCode</strong> and perform the following steps:<div><ol class="orderedlist arabic"><li class="listitem">Set its <strong>Transform</strong> position to {<code class="literal">100</code>, <code class="literal">0</code>, <code class="literal">0</code>}.</li><li class="listitem">Set its text to <code class="literal">Code Encrypted</code>.</li></ol></div></li></ol></div><p>Your <strong>Hierarchy</strong> view and <strong>Spaceship</strong> should look as follows:</p><div><img src="img/8667OT_07_06.jpg" alt="The hacking slider"/></div><p>Great! Let's <a id="id333" class="indexterm"/>apply these new modifications to our <strong>Spaceship</strong> prefab by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <strong>Hierarchy</strong> view, select our <strong>Spaceship</strong> GameObject.</li><li class="listitem">Click on the <strong>Apply</strong> button at the top of the <strong>Inspector</strong> view to update the prefab.</li><li class="listitem">Delete the <strong>Spaceship</strong> instance from our <strong>Hierarchy</strong> view.</li></ol></div><p>Ok, we now have a slider that will indicate the hacking status and a label that will display the self-destruct code.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec74"/>Self-destruct code</h2></div></div></div><p>Let's add <a id="id334" class="indexterm"/>some self-destruct code and hacking status in the localization files. Open the <code class="literal">English.txt</code> and add the following lines:</p><div><pre class="programlisting">//Hacking status
CodeEncrypted = Code Encrypted
Hacking = [FF6666]Hacking...
//Self-Destruct Codes
Space = space
Neptune = neptune
Moon = moon
Mars = mars
Jupiter = jupiter</pre></div><p>Now, open the <code class="literal">French.txt</code> file and add the following lines:</p><div><pre class="programlisting">//Hacking status
CodeEncrypted = Code Crypté
Hacking = [FF6666]Piratage...
//Self-Destruct Codes
Space = espace
Neptune = neptune
Moon = lune
Mars = mars
Jupiter = jupiter</pre></div><p>Good! We now have our necessary localization strings.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec75"/>Assigning code to an enemy</h2></div></div></div><p>We will now add a <a id="id335" class="indexterm"/>new <code class="literal">SetDestructCode()</code> method in our <code class="literal">EnemyController.cs</code> script that will assign a self-destruct code to our enemy during initialization. First, let's add the necessary global variables to it.</p><p>Open our <code class="literal">EnemyController.cs</code> script and add the following global variables:</p><div><pre class="programlisting">//Boolean to check if enemy is hacked or not
public bool hacked = false;
//We will need the Self-Destruct Code Label
private UILabel codeLabel;
//We will also need the hacking slider
private UISlider hackSlider;
//We will need to store the destructCode
public string destructCode = "";
//We will need a hackSpeed float
float hackSpeed = 0.2f;</pre></div><p>We must set these variables. Add the following lines at the end of the <code class="literal">Initialize()</code> method:</p><div><pre class="programlisting">//Get the hacking slider
hackSlider = transform.FindChild("DestructCode").GetComponent&lt;UISlider&gt;();
//Get the hacking status label
codeLabel = hackSlider.transform.FindChild("Label").GetComponent&lt;UILabel&gt;();</pre></div><p>Ok, now, let's add the <code class="literal">SetDestructCode()</code> method<a id="id336" class="indexterm"/> that will assign a self-destruct code to the enemy. This method will have a string parameter containing the key of the self-destruct code to be assigned, as shown in the following code:</p><div><pre class="programlisting">public void SetDestructCode(string randomWordKey)
{
  //If the randomWordKey is not empty...
  if(!string.IsNullOrEmpty(randomWordKey))
  {
    //... Get the corresponding localized code
    destructCode = Localization.instance.Get(randomWordKey);
    //Set the Label to "Code Encrypted" 
    codeLabel.text = Localization.instance.Get("CodeEncrypted");
  }
  //If the randomWordKey is empty, disable hacking slider
  else
  hackSlider.gameObject.SetActive(false);
}</pre></div><p>Ok, we have a <a id="id337" class="indexterm"/>method that sets the correct destruct code. Now, let's create a <code class="literal">Hack()</code> coroutine that will be called to start the hacking process.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec76"/>The hacking process</h2></div></div></div><p>The <code class="literal">Hack()</code> coroutine <a id="id338" class="indexterm"/>will gradually fill the hacking slider and display the enemy's self-destruct code when the hacking is complete.</p><p>Add the <code class="literal">Hack()</code> coroutine to the <code class="literal">EnemyController.cs</code> script using the following code snippet:</p><div><pre class="programlisting">IEnumerator Hack()
{
  //Set the Label to "Hacking..."
  codeLabel.text = Localization.instance.Get("Hacking");
  //While hacking slider is not full
  while(hackSlider.value &lt; 1)
  {
    //Increase slider value, framerate independant
    hackSlider.value += Time.deltaTime * hackSpeed;
    //Wait for next frame
    yield return null;
  }
  //Make sure slider is at 1
  hackSlider.value = 1;
  //Set the hacked bool to true for this enemy
  hacked = true;
  //Display the Self-Destruct code now
  codeLabel.text = "[99FF99]" + destructCode;
}</pre></div><p>Now, let's add an <code class="literal">OnClick()</code> method that will actually launch the hacking process when the enemy is clicked on by the player. We do this in the following manner:</p><div><pre class="programlisting">void OnClick()
{
  //If the enemy has a destruct code, launch hacking
  if(!string.IsNullOrEmpty(destructCode))
    StartCoroutine(Hack());
}</pre></div><p>Ok, the methods <a id="id339" class="indexterm"/>are set for our enemy. Now, we can edit our <code class="literal">EnemySpawnController.cs</code> script to call the <code class="literal">SetDestructCode()</code> method when a new enemy is initialized and pass a random destruct code in parameter. First, we will add the necessary variables.</p><p>We will need a <code class="literal">List</code> array to store the enemies in the scene. A <code class="literal">List</code> is like an array but easier to manage with useful methods, such as <code class="literal">Add()</code> and <code class="literal">Remove()</code>. In order to use a <code class="literal">List</code>, you need to include a specific library.</p><p>Open the <code class="literal">EnemySpawnController.cs</code> script and simply add the following line at the very beginning of the file, along with the two other include lines already present:</p><div><pre class="programlisting">//Include Lists
using System.Collections.Generic;</pre></div><p>Now, add these new global variables within our <code class="literal">EnemySpawnController</code> class:</p><div><pre class="programlisting">//Chance for each enemy to have a destructCode
public float destructCodeChance = 60;
//Array of strings to store destructCodes keys
public string[] wordKeys;
//We will need a list of enemies
private List&lt;EnemyController&gt; enemies;
//We will need a static instance of this script
public static EnemySpawnController instance;
//This will store the current word typed by the player
public string currentWord;</pre></div><p>Ok, now initialize some of these variables in the new <code class="literal">Awake()</code> method:</p><div><pre class="programlisting">void Awake()
{
  //Store the instance of this script
  instance = this;
  //Initialize the List
  enemies = new List&lt;EnemyController&gt;();
}</pre></div><p>Before we continue, let's assign the remaining variables in the <strong>Inspector</strong> view. Save the script, go back to Unity, and select our <strong>Enemies</strong> GameObject from <strong>Viewport</strong>.</p><p>Now, set the <strong>Word Keys</strong> array and spawning values as follows:</p><div><img src="img/8667OT_07_07.jpg" alt="The hacking process"/></div><p>Good, our <strong>Word Keys</strong> array<a id="id340" class="indexterm"/> is now set up. Let's return to our <code class="literal">EnemySpawnController.cs</code> script and add the following lines in the <code class="literal">SpawnEnemy()</code> coroutine at the very end of its <code class="literal">while()</code> loop:</p><div><pre class="programlisting">//Create a new empty string for destruct code
string randomCode = "";
//If the random is valid, get a random word
if(Random.Range(0f,100f) &lt; destructCodeChance)
randomCode = GetRandomWord();
//Set the enemy's the DestructCode newEnemy.SetDestructCode(randomCode);
//Add the enemy to the list of enemies
enemies.Add(newEnemy);</pre></div><p>When an enemy is initialized, the previous code adds it to the <code class="literal">List</code> of enemies and sets its self-destruct code. Now, using the following code, let's create the <code class="literal">GetRandomWord()</code> method<a id="id341" class="indexterm"/> that will return one of our predefined words:</p><div><pre class="programlisting">private string GetRandomWord()
{
  //Return a random Word Key
  return wordKeys[Random.Range(0, wordKeys.Length)];
}</pre></div><p>Good. Some of our enemies have a destruct code assigned. Let's just add a method to remove an enemy from the <code class="literal">List</code>, which will be called each time an enemy is destroyed. The method is added as follows:</p><div><pre class="programlisting">public void EnemyDestroyed(EnemyController destroyedEnemy)
{
  //Remove the destroyed enemy from the List
  enemies.Remove(destroyedEnemy);
}</pre></div><p>Open<a id="id342" class="indexterm"/> the <code class="literal">EnemyController.cs</code> script. Within the <code class="literal">Kill()</code> coroutine, just before the <code class="literal">Destroy(gameObject)</code> line, add the following line to remove the enemy from the <code class="literal">List</code>:</p><div><pre class="programlisting">//Remove enemy from the List
EnemySpawnController.instance.EnemyDestroyed(this);</pre></div><p>Perfect. Save all of the scripts and hit the play button. If you click on an enemy that has the hacking slider, the hacking process starts and displays a destruct code when finished. </p><p>The last step is to handle the player's input in order to check if he or she types one of the enemies' self-destruct words.</p></div><div><div><div><div><h2 class="title"><a id="ch07lvl2sec77"/>Handling player input</h2></div></div></div><p>We will <a id="id343" class="indexterm"/>use the <code class="literal">Update()</code> method of our <code class="literal">EnemySpawnController.cs</code> script to check which characters the player types with his or her keyboard. These characters will be stored one by one and will be compared to our enemies' destruct codes.</p><p>Open our <code class="literal">EnemySpawnController.cs</code> script and create a new <code class="literal">Update()</code> method:</p><div><pre class="programlisting">void Update()
{
  //If the player has typed a character
  if(!string.IsNullOrEmpty(Input.inputString)) 
  {
    //Add this new character to the currentWord
    currentWord += Input.inputString;
    //We need to know if the code matches at least 1 enemy
    bool codeMatches = false;
    //Check enemies' destruct codes one by one
    for each(EnemyController enemy in enemies)
    {
      //If the enemy has a destruct code AND is hacked
      if(enemy.destructCode != "" &amp;&amp; enemy.hacked)
      {
        //currentWord contain the destruct code?
        if(currentWord.Contains(enemy.destructCode))
        {
          //Yes - Destroy it and update our bool
          StartCoroutine(enemy.Kill());
          codeMatches = true;
        }
      }
    }
    //Did the word match at least 1 enemy?
    if(codeMatches)
    //In that case, reset the currentWord to empty
    currentWord = "";
  }
}</pre></div><p>Save this script.<a id="id344" class="indexterm"/> Now, when you hack an enemy, you can destroy it by typing its self-destruct code! If multiple enemies have the same code, they will be destroyed simultaneously.</p><div><div><h3 class="title"><a id="note29"/>Note</h3><p>Typing a word may scroll the viewport; this is because Q, A, S, and D are set as Horizontal and Vertical axes by default. Go to <strong>Edit</strong> | <strong>Project Settings</strong> | <strong>Input</strong> and delete (a, d) and (s, w) from the Horizontal and Vertical axes' Alt Positive Button and Alt Negative Button fields respectively.</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch07lvl1sec53"/>Summary</h1></div></div></div><p>In this chapter, we used everything we learned in the earlier chapters with respect to creating a simple game.</p><p>We created an enemy spawning system, which instantiates enemies on the scene. Rigidbodies and colliders have been added to handle collisions between enemies in the barriers at the bottom of the screen.</p><p>We also added a health bar widget that is linked to health points; if four enemies touch the end of the screen, the game restarts.</p><p>The <code class="literal">Update()</code> method was used to handle player input and compare the typed word with destruct codes in order to destroy enemies if needed.</p><p>For now, the game is quite simple. Some ideas to enhance the game are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Add more self-destruct words</li><li class="listitem" style="list-style-type: disc">Display what the player types on the screen (visual feedback)</li><li class="listitem" style="list-style-type: disc">Slowly increase the spawning rate as the player destroys enemies</li><li class="listitem" style="list-style-type: disc">Slowly increase the enemy's speed as the player destroys enemies</li><li class="listitem" style="list-style-type: disc">Add a scoring system</li><li class="listitem" style="list-style-type: disc">Implement the Time power (hint: Time.timeScale)</li><li class="listitem" style="list-style-type: disc">Implement the Bomb power</li><li class="listitem" style="list-style-type: disc">Make the hack time depend on barrierCount (more barriers, faster hacking)</li><li class="listitem" style="list-style-type: disc">Include the possibility of removing an ActiveBarrier with a right click</li><li class="listitem" style="list-style-type: disc">Add clickable objects to regain health; some enemies leave them behind</li><li class="listitem" style="list-style-type: disc">Add a combo reward if the player destroys multiple enemies within 3 seconds</li><li class="listitem" style="list-style-type: disc">Include harder words for hard difficulty</li><li class="listitem" style="list-style-type: disc">Insert a visual indicator (arrow) to show the direction of the enemies outside the screen</li><li class="listitem" style="list-style-type: disc">Add more visual variety in the background (galaxies and so on) to help orientation</li><li class="listitem" style="list-style-type: disc">Display a game over screen with the main menu and restart buttons</li><li class="listitem" style="list-style-type: disc">Create tutorial pop ups</li></ul></div><p>If you add some of the previous features, our game will become more interesting.</p><p>In order to improve your knowledge of NGUI, you can refer to more tutorials at <a class="ulink" href="http://www.tasharen.com/forum/index.php?topic=6754">http://www.tasharen.com/forum/index.php?topic=6754</a>.</p><p>The complete NGUI scripting documentation is available at <a class="ulink" href="http://www.tasharen.com/ngui/docs/index.html">http://www.tasharen.com/ngui/docs/index.html</a>.</p><p>That's it! We have now finished working with Unity and NGUI using this book. Thank you for your attention and I wish you all the best for your future projects.</p></div></body></html>