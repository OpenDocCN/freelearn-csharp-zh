- en: '*Chapter 7*: Task Parallel Library (TPL) and Dataflow'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '*第7章*：任务并行库（TPL）和数据流'
- en: The **Task Parallel Library** (**TPL**) **dataflow library** contains building
    blocks to orchestrate asynchronous workflows in .NET. This chapter will introduce
    the TPL Dataflow library, describe the types of **dataflow blocks** in the library,
    and illustrate some common patterns for using dataflow blocks through hands-on
    examples.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: '**任务并行库**（**TPL**）数据流库包含构建块，用于在.NET中编排异步工作流。本章将介绍TPL数据流库，描述库中**数据流块**的类型，并通过实际示例说明使用数据流块的一些常见模式。'
- en: The dataflow library can be useful when processing large amounts of data in
    multiple stages or when your application receives data in a continuous stream.
    The dataflow blocks provide a fantastic way of implementing the **producer/consumer
    design pattern**.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 当处理大量数据并在多个阶段进行处理，或者您的应用程序以连续流接收数据时，数据流库非常有用。数据流块提供了一种实现**生产者/消费者设计模式**的绝佳方式。
- en: To understand this, we will create a sample project that implements this pattern
    and examine other real-world uses of the dataflow library.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 为了理解这一点，我们将创建一个实现此模式的示例项目，并检查数据流库的其他实际应用。
- en: Note
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: It’s important to know that the TPL Dataflow library isn’t distributed as part
    of the .NET runtime or SDK. It’s available as a NuGet package from Microsoft.
    We will add it to our sample projects with **NuGet Package Explorer** (**NPE**)
    in Visual Studio.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要知道TPL数据流库不是作为.NET运行时或SDK的一部分进行分发的。它可以从Microsoft的NuGet包中获取。我们将使用Visual Studio中的**NuGet包资源管理器**（**NPE**）将其添加到我们的示例项目中。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: Introducing the TPL Dataflow library
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 介绍TPL数据流库
- en: Implementing the producer/consumer pattern
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现生产者/消费者模式
- en: Creating a data pipeline with multiple blocks
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用多个块创建数据管道
- en: Manipulating data from multiple data sources
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 处理来自多个数据源的数据
- en: By the end of this chapter, you will understand the purpose of each type of
    dataflow block and be able to add the dataflow library to your projects, where
    appropriate.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将了解每种类型的数据流块的目的，并能够在适当的项目中添加数据流库。
- en: You will also know when dataflow blocks do not provide an advantage over simpler
    parallel programming alternatives, such as `Parallel.ForEach`.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 您还将了解在哪些情况下，数据流块不比简单的并行编程替代方案（如`Parallel.ForEach`）提供优势。
- en: Technical requirements
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'To follow along with the examples in this chapter, the following software is
    recommended for Windows developers:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 为了跟随本章中的示例，以下软件是推荐给Windows开发者的：
- en: Visual Studio 2022 version 17.0 or later
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Visual Studio 2022版本17.0或更高版本
- en: .NET 6
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 6
- en: To complete the WPF sample, you will need to install the .NET desktop development
    workload for Visual Studio
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 要完成WPF示例，您需要安装Visual Studio的.NET桌面开发工作负载
- en: While these are recommended, if you have .NET 6 installed, you can use your
    preferred editor. For example, Visual Studio 2022 for Mac on macOS 10.13 or later,
    JetBrains Rider, or Visual Studio Code will work just as well.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这些是推荐的，但如果您已安装.NET 6，您可以使用您喜欢的编辑器。例如，macOS 10.13或更高版本的Visual Studio 2022 for
    Mac、JetBrains Rider或Visual Studio Code都将同样有效。
- en: The code examples for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码示例可以在GitHub上找到：[https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07)。
- en: Let’s get started by discussing the TPL Dataflow library and why it can be a
    great way to implement parallel programming in .NET.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从讨论TPL数据流库及其为什么可以成为在.NET中实现并行编程的绝佳方式开始。
- en: Introducing the TPL Dataflow library
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 介绍TPL数据流库
- en: The TPL Dataflow library has been available for as long as TPL itself. It was
    released in 2010 after `System.Threading.Tasks.Dataflow` namespace. The dataflow
    library is intended to build on the basics of parallel programming that are provided
    in TPL, expanding to address data flow scenarios (hence the name of the library).
    The dataflow library is made up of foundational classes called **blocks**. Each
    data flow block is responsible for a particular action or step in the overall
    flow.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: TPL 数据流库与 TPL 本身一样可用。它在2010年随`System.Threading.Tasks.Dataflow`命名空间发布。数据流库旨在建立在
    TPL 提供的并行编程基础知识之上，扩展以解决数据流场景（因此库的名称）。数据流库由称为**块**的基础类组成。每个数据流块负责整体流程中的特定操作或步骤。
- en: 'The dataflow library consists of three basic types of blocks:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流库由三种基本类型的块组成：
- en: '`ISourceBlock<TOutput>` interface. Source blocks can have their data read from
    the workflow you define.'
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ISourceBlock<TOutput>`接口。源块可以从你定义的工作流程中读取其数据。'
- en: '`ITargetBlock<TInput>` interface and is a data receiver.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ITargetBlock<TInput>`接口，是一个数据接收器。'
- en: '`IPropagatorBlock<TInput, TOutput>` interface. Applications can read data from
    these blocks and write to them.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IPropagatorBlock<TInput, TOutput>`接口。应用程序可以从中读取数据并将数据写入它们。'
- en: When you connect multiple dataflow blocks to create a workflow, the resulting
    system is referred to as a `ISourceBlock<TOutput>.LinkTo` method. This is where
    propagator blocks can fit in the middle of a pipeline. They can act as both the
    source and target of a link in the workflow. If a message from a source block
    can be processed by more than one target, you can add filtering to examine the
    properties of the object provided by the source to determine which target or propagator
    block should receive the object.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当你将多个数据流块连接起来创建一个工作流程时，所得到的系统被称为`ISourceBlock<TOutput>.LinkTo`方法。这就是传播器块可以在管道中间发挥作用的地方。它们可以作为工作流程中链接的源和目标。如果一个源块的消息可以被多个目标处理，你可以添加过滤功能来检查源提供的对象属性，以确定哪个目标或传播器块应该接收该对象。
- en: The objects that are passed between dataflow blocks are commonly referred to
    as **messages**. You can think of a dataflow pipeline as a **network** or messaging
    system. The units of data that flow through the network are the messages. Each
    block is responsible for reading, writing, or transforming each message in some
    way.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在数据流块之间传递的对象通常被称为**消息**。你可以将数据流管道视为**网络**或消息系统。通过网络流动的数据单元是消息。每个块都负责以某种方式读取、写入或转换每个消息。
- en: To send a message to a target block, you can use the `Post` method to send it
    synchronously or the `SendAsync` method to send it asynchronously. In source blocks,
    messages can be received with the `Receive`, `TryReceive`, and `ReceiveAsync`
    methods. The `Receive` and `TryReceive` methods are both synchronous. The `Choose`
    method will monitor multiple source blocks for data and return a message from
    the first source to provide data.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 要向目标块发送消息，你可以使用`Post`方法同步发送或使用`SendAsync`方法异步发送。在源块中，可以使用`Receive`、`TryReceive`和`ReceiveAsync`方法接收消息。`Receive`和`TryReceive`方法都是同步的。`Choose`方法将监视多个源块以获取数据，并从第一个提供数据的源返回一个消息。
- en: 'To offer a message from a source block to a target block, the source can call
    the `OfferData` method of a target. The `OfferData` method returns a `DataflowMessageStatus`
    enum that has several possible values:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 要将源块的消息提供给目标块，源可以调用目标的`OfferData`方法。`OfferData`方法返回一个`DataflowMessageStatus`枚举，它有几个可能的值：
- en: '`Accepted`: The message was accepted and will be processed by the target.'
  id: totrans-31
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Accepted`：消息已被接受，并将由目标处理。'
- en: '`Declined`: The message was declined by the target. The source block still
    owns the message and cannot process its next message until the current message
    has been accepted by another target.'
  id: totrans-32
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Declined`：消息被目标拒绝。源块仍然拥有该消息，并且无法处理其下一个消息，直到当前消息被另一个目标接受。'
- en: '`DecliningPermanently`: The message was declined, and the target is no longer
    available for processing. All subsequent messages will be declined by the current
    target. Source blocks will unlink from a target that returns this status.'
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DecliningPermanently`：消息已被拒绝，目标不再可用于处理。所有后续的消息都将被当前目标拒绝。源块将解除与返回此状态的目标的链接。'
- en: '`Postponed`: Accepting the message has been postponed. It may be accepted by
    the target at a later time. In this case, the source can wait or attempt to pass
    the message to an alternative target block.'
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Postponed`：接受消息已被推迟。它可能在稍后由目标接受。在这种情况下，源可以等待或尝试将消息传递给另一个替代目标块。'
- en: '`NotAvailable`: The message was no longer available when the target tried to
    accept it. This can occur when the target attempts to accept a message after it
    had been postponed, but the source block has already passed the message to a different
    target block.'
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`NotAvailable`：当目标尝试接受消息时，消息不再可用。这可能在目标在消息被推迟后尝试接受消息时发生，但源块已经将消息传递给另一个目标块。'
- en: Dataflow blocks support the concept of `Complete` method and a `Completion`
    property. The `Complete` method is called to request completion on a block, while
    the `Completion` property returns a `Task`, known as the block’s `IDataflowBlock`
    interface, which is inherited by both `ISourceBlock` and `ITargetBlock`.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流块支持`Complete`方法和`Completion`属性的概念。`Complete`方法用于在块上请求完成，而`Completion`属性返回一个`Task`，称为块的`IDataflowBlock`接口，该接口由`ISourceBlock`和`ITargetBlock`共同继承。
- en: 'The completion task can be used to determine if a block has encountered an
    error or has been canceled. Let’s see how:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 完成任务可以用来确定一个块是否遇到了错误或已被取消。让我们看看如何：
- en: 'The simplest way to handle errors encountered by a dataflow block is to call
    `Wait` on the `Completion` property of the block and handle the `AggregateException`
    exception type in the `try`/`catch` block:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 处理数据流块遇到错误的最简单方法是调用块的`Completion`属性的`Wait`，并在`try`/`catch`块中处理`AggregateException`异常类型：
- en: '[PRE0]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'If you want to do the same thing without using the blocking `Wait` call, you
    can `await` the completion task and handle the `Exception` type:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果你想在不需要使用阻塞的`Wait`调用的情况下做同样的事情，你可以`await`完成任务并处理`Exception`类型：
- en: '[PRE1]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Another alternative is to use the `ContinueWith` method on the completion task.
    Inside the continuation block, you can check the status of the task to determine
    if it is `Faulted` or `Canceled`:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 另一种选择是在完成任务上使用`ContinueWith`方法。在延续块内部，你可以检查任务的状态以确定它是否为`Faulted`或`Canceled`：
- en: '[PRE2]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: We will see more comprehensive examples of dataflow block use when we create
    a sample project using the producer/consumer pattern in the next section. Before
    we examine the types of dataflow blocks, let’s discuss why Microsoft created the
    library.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们在下一节创建一个使用生产者/消费者模式的示例项目时，我们将看到更多关于数据流块使用的综合示例。在我们检查数据流块类型之前，让我们讨论一下为什么微软创建了该库。
- en: Why use the TPL Dataflow library?
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么使用TPL数据流库？
- en: 'The TPL dataflow library was created by Microsoft as a means of orchestrating
    asynchronous data processing workflows. Data flows into the first dataflow block
    in the pipeline from a data source. The source can be a database, a local or network
    folder, a camera, or just about any other type of input device that .NET can access.
    One or more blocks can be part of the pipeline, with each being responsible for
    a single operation. The following diagram illustrates two abstractions of dataflow
    pipelines:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: TPL数据流库是由微软创建的，作为一种编排异步数据处理工作流的方法。数据从数据源流入管道中的第一个数据流块。源可以是数据库、本地或网络文件夹、摄像头或.NET可以访问的几乎所有其他类型的输入设备。一个或多个块可以是管道的一部分，每个块负责单个操作。以下图表说明了数据流管道的两个抽象：
- en: '![Figure 7.1 – Dataflow pipeline examples ](img/Figure_7.1_B18552.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1 – 数据流管道示例](img/Figure_7.1_B18552.jpg)'
- en: Figure 7.1 – Dataflow pipeline examples
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1 – 数据流管道示例
- en: One real-world example you can consider is using a webcam to capture image frames.
    In a two-step flow, as shown in *Example 1*, consider the webcam as **Data Input**.
    **Dataflow Block 1** could perform some image processing to optimize the image
    appearance, while **Dataflow Block 2** will call an **Azure Cognitive Services**
    API to identify objects in each image. **Result** would contain a new .NET class
    for each input image containing the image binary data and properties that contain
    the identified objects within each image.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以考虑的一个现实世界示例是使用网络摄像头来捕获图像帧。在两步流程中，如*示例1*所示，将网络摄像头视为**数据输入**。**数据流块1**可以对图像进行一些图像处理以优化图像外观，而**数据流块2**将调用**Azure认知服务**API以识别每张图像中的对象。**结果**将包含一个.NET类，每个输入图像都包含图像二进制数据和包含每个图像中识别对象的属性。
- en: Next, let’s learn about the types of blocks available in the dataflow library.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们了解数据流库中可用的块类型。
- en: Types of dataflow blocks
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 数据流块类型
- en: There are nine predefined blocks in the dataflow library. These can be divided
    into three different categories. The first category is **buffering blocks**.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 数据流库中有九个预定义的块。这些可以分成三个不同的类别。第一个类别是**缓冲区块**。
- en: Buffering blocks
  id: totrans-53
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 缓冲区块
- en: The purpose of `BufferBlock<T>`, `BroadcastBlock<T>`, and `WriteOnceBlock<T>`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferBlock<T>`、`BroadcastBlock<T>` 和 `WriteOnceBlock<T>` 的用途。'
- en: BufferBlock
  id: totrans-55
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 缓冲区块
- en: '`BufferBlock<T>` is an asynchronous queuing mechanism that implements a `BufferBlock`
    can have multiple data sources and multiple targets configured. However, each
    message in a `BufferBlock` can only be delivered to one target block. The message
    is removed from the queue after it has been successfully delivered.'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferBlock<T>` 是一个异步队列机制，实现 `BufferBlock` 可以有多个数据源和多个目标配置。然而，`BufferBlock`
    中的每条消息只能被发送到一个目标块。消息在成功发送后从队列中移除。'
- en: 'The following snippet pushes customer names into a `BufferBlock` and subsequently
    reads the first five names out to the console:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段将客户姓名推送到 `BufferBlock`，然后读取前五个姓名并在控制台输出：
- en: '[PRE3]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: '[PRE4]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '[PRE7]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: '[PRE9]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: '[PRE10]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: '[PRE11]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: '[PRE12]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: '[PRE13]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '[PRE15]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: '[PRE16]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: '[PRE17]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: BroadcastBlock
  id: totrans-73
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 广播块
- en: '`BroadcastBlock<T>` is used similarly to `BufferBlock`, but it is intended
    to provide only the most recently posted message available to consumers. It can
    also be used to send the same value to many consumers. The message that’s posted
    to a `BroadcastBlock` is not removed after it has been received by a consumer.'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: '`BroadcastBlock<T>` 与 `BufferBlock` 的使用方式相似，但其目的是只为消费者提供最近发布的消息。它也可以用来向多个消费者发送相同的值。发送到
    `BroadcastBlock` 的消息在消费者接收后不会被移除。'
- en: 'The following snippet will read the same alert message each time the `Receive`
    method is called:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 以下片段每次调用 `Receive` 方法时都会读取相同的警报消息：
- en: '[PRE18]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: '[PRE19]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '[PRE20]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: '[PRE21]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: '[PRE22]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: '[PRE23]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: WriteOnceBlock
  id: totrans-82
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 单次写入块
- en: As the name suggests, `WriteOnceBlock<T>` can only be written to once. After
    the first message has been received, all calls to `Post` or `SendAsync` will be
    ignored by the block. No exceptions will be thrown. The data is simply discarded.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，`WriteOnceBlock<T>` 只能写入一次。在接收到第一条消息后，所有对 `Post` 或 `SendAsync` 的调用都将被块忽略。不会抛出异常。数据将被简单地丢弃。
- en: 'The following example is similar to our `BufferBlock` snippet. However, because
    we’re now using a `WriteOnceBlock`, only the first customer’s name will be accepted
    by the block:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例与我们的 `BufferBlock` 片段类似。然而，因为我们现在使用的是 `WriteOnceBlock`，所以只有第一个客户的姓名将被块接受：
- en: '[PRE24]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: '[PRE25]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: '[PRE26]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: '[PRE27]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: '[PRE28]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: '[PRE29]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Execution blocks
  id: totrans-91
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 执行块
- en: '`ActionBlock<TInput>` is a `TransformBlock<TInput, TOuput>` and `TransformManyBlock<TInput,
    TOutput>` are both **propagator** blocks.'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionBlock<TInput>` 是一个 `TransformBlock<TInput, TOuput>`，而 `TransformManyBlock<TInput,
    TOutput>` 都是**传播**块。'
- en: ActionBlock
  id: totrans-93
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 操作块
- en: '`ActionBlock` is a block that accepts either `Action<T>` or `Func<TInput, Task>`
    as its constructor. An action on an input message is considered complete when
    the action returns or the task of `Func` completes. You can use an action for
    synchronous delegates or `Func` for async operations.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionBlock` 是一个接受 `Action<T>` 或 `Func<TInput, Task>` 作为其构造函数参数的块。当操作返回或 `Func`
    的任务完成时，对输入消息的操作被认为是完成的。你可以使用操作同步委托或 `Func` 进行异步操作。'
- en: 'In this snippet, we will output customer names to the console with `Console.WriteLine`,
    which is provided in an `Action`, to the block:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在此片段中，我们将使用 `Console.WriteLine` 将客户姓名输出到控制台，这是在 `Action` 中提供的，并将其发送到块：
- en: '[PRE30]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: '[PRE31]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: '[PRE32]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: '[PRE33]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: '[PRE34]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: '[PRE35]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: '[PRE36]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: '[PRE37]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: TransformBlock
  id: totrans-104
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 传播块
- en: '`TransformBlock<TInput, TOutput>` is similar to `ActionBlock`. However, as
    a propagator block, it returns an output value for each message that’s received.
    The two possible delegate signatures that can be provided to the `TransformBlock`
    constructor are `Func<TInput, TOutput>` for synchronous operations and `Func<TInput,
    Task<TOutput>>` for asynchronous operations.'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformBlock<TInput, TOutput>` 与 `ActionBlock` 类似。然而，作为一个传播块，它为接收到的每条消息返回一个输出值。可以提供给
    `TransformBlock` 构造函数的两个可能的委托签名是 `Func<TInput, TOutput>` 用于同步操作和 `Func<TInput,
    Task<TOutput>>` 用于异步操作。'
- en: 'The following example uses a `TransformBlock` that will convert a customer
    name into all capitals before the first five output values are retrieved to be
    displayed on the console:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 以下示例使用一个 `TransformBlock`，它将在检索到前五个输出值并在控制台显示之前将客户姓名转换为大写：
- en: '[PRE38]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: '[PRE39]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: '[PRE40]'
  id: totrans-109
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: '[PRE41]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: '[PRE42]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: '[PRE43]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: '[PRE44]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: '[PRE45]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: '[PRE46]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: '[PRE47]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: TransformManyBlock
  id: totrans-117
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: TransformManyBlock
- en: '`TransformManyBlock<TInput, TOutput>` is similar to `TransformBlock` except
    that the block can return one or more values for every input value that’s received.
    The possible delegate signatures for `TransformManyBlock` are `Func<TInput, IEnumerable<TOutput>>`
    and `Func<TInput, Task<IEnumerable<TOutput>>>` for synchronous and asynchronous
    operations, respectively.'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: '`TransformManyBlock<TInput, TOutput>` 与 `TransformBlock` 类似，但该块可以为接收到的每个输入值返回一个或多个值。`TransformManyBlock`
    的可能委托签名分别为 `Func<TInput, IEnumerable<TOutput>>` 和 `Func<TInput, Task<IEnumerable<TOutput>>>`，分别用于同步和异步操作。'
- en: 'In this snippet, we will pass one customer name to `TransformManyBlock`, which
    will return an enumerable containing the individual characters in the customer’s
    name:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码片段中，我们将向 `TransformManyBlock` 传递一个客户名称，该块将返回一个包含客户名字中各个字符的可枚举：
- en: '[PRE48]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: '[PRE49]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: '[PRE50]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: '[PRE51]'
  id: totrans-123
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: '[PRE52]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: '[PRE53]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: '[PRE54]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Grouping blocks
  id: totrans-127
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 分组块
- en: '`BatchBlock<T>` is a propagator block, while `JoinBlock<T1, T2>` and `BatchedJoinBlock<T1,
    T2>` are both source blocks.'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatchBlock<T>` 是一个传播块，而 `JoinBlock<T1, T2>` 和 `BatchedJoinBlock<T1, T2>` 都是源块。'
- en: BatchBlock
  id: totrans-129
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BatchBlock
- en: '`BatchBlock` accepts batches of data and produces arrays of output data. When
    creating a `BatchBlock`, you specify the input batch size. `BatchBlock` has a
    `Greedy` property in the `dataflowBlockOptions` optional constructor parameter
    that specifies the **greedy mode**:'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatchBlock` 接受数据批次并生成输出数据数组。在创建 `BatchBlock` 时，你指定输入批次大小。`BatchBlock` 在 `dataflowBlockOptions`
    可选构造函数参数中有一个 `Greedy` 属性，用于指定**贪婪模式**：'
- en: When `Greedy` is `true`, which is its default value, the block continues processing
    every input value as it is received and outputs an array as the batch size is
    reached.
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `Greedy` 为 `true`，这是其默认值时，该块会继续处理每个接收到的输入值，并在达到批大小后输出一个数组。
- en: When `Greedy` is `false`, incoming messages can be paused while an array of
    the batch size is being created.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当 `Greedy` 为 `false` 时，在创建批大小为数的数组时，可以暂停接收到的消息。
- en: '`Greedy` mode usually performs better, but if you are coordinating input from
    multiple sources, you may need to use **non-greedy mode**.'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 贪婪模式通常性能更好，但如果你需要协调来自多个源的输入，你可能需要使用**非贪婪模式**。
- en: 'In this example, `BatchBlock` separates student names into classes with a maximum
    size of 12:'
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，`BatchBlock` 将学生名字按班级分开，最大容量为 12：
- en: '[PRE55]'
  id: totrans-135
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: '[PRE56]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '[PRE57]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: '[PRE58]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: '[PRE59]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: '[PRE60]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: '[PRE61]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: '[PRE62]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: '[PRE63]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: '[PRE64]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: '[PRE65]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: '[PRE66]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: '[PRE67]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: JoinBlock
  id: totrans-148
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: JoinBlock
- en: '`JoinBlock` has two signatures: `JoinBlock<T1, T2>` and `JoinBlock<T1, T2,
    T3>`. `JoinBlock<T1, T2>` has `Target1` and `Target2` properties to accept inputs
    and returns a `Tuple<T1, T2>` as each pair of targets is filled. `JoinBlock<T1,
    T2, T3>` has `Target1`, `Target2`, and `Target3` properties and returns a `Tuple<T1,
    T2, T3>` as each set of targets is completed.'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: '`JoinBlock` 有两个签名：`JoinBlock<T1, T2>` 和 `JoinBlock<T1, T2, T3>`。`JoinBlock<T1,
    T2>` 有 `Target1` 和 `Target2` 属性，用于接受输入并返回一个 `Tuple<T1, T2>`，当每个目标对被填充时。`JoinBlock<T1,
    T2, T3>` 有 `Target1`、`Target2` 和 `Target3` 属性，并在每个目标集完成时返回一个 `Tuple<T1, T2, T3>`。'
- en: '`JoinBlock` also has greedy and non-greedy modes, with greedy mode being the
    default behavior. When you switch to non-greedy mode, all input is postponed to
    targets that have already received input until a complete output set is populated
    and sent as output.'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: '`JoinBlock` 也具有贪婪和非贪婪模式，贪婪模式是默认行为。当切换到非贪婪模式时，所有输入都会推迟到已经接收输入的目标，直到填充完整的输出集并发送为输出。'
- en: 'In this example, we will create a `JoinBlock` to combine a person’s first name,
    last name, and age into the output tuple:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本例中，我们将创建一个 `JoinBlock` 来将一个人的名字、姓氏和年龄组合到输出元组中：
- en: '[PRE68]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: '[PRE69]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: '[PRE70]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: '[PRE71]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: '[PRE72]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: '[PRE73]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: '[PRE74]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: '[PRE75]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: '[PRE76]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: '[PRE77]'
  id: totrans-161
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: '[PRE78]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: '[PRE79]'
  id: totrans-163
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: '[PRE80]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: '[PRE81]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: '[PRE82]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: '[PRE83]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: '[PRE84]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '[PRE85]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: '[PRE86]'
  id: totrans-170
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: '[PRE87]'
  id: totrans-171
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: '[PRE88]'
  id: totrans-172
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: BatchedJoinBlock
  id: totrans-173
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: BatchedJoinBlock
- en: 'A `BatchedJoinBlock` is like a `JoinBlock` except the tuple in the output contains
    `IList` items of the size of the batch specified in the constructor: `Tuple(IList(T1),
    IList(T2))` or `Tuple(IList(T1), IList(T2), IList(T3))`. The batching concept
    is the same as it is for `BatchBlock`.'
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: '`BatchedJoinBlock` 类似于 `JoinBlock`，但输出中的元组包含构造函数中指定的批量大小的 `IList` 项目：`Tuple(IList(T1),
    IList(T2))` 或 `Tuple(IList(T1), IList(T2), IList(T3))`。批处理的概念与 `BatchBlock` 相同。'
- en: As an exercise, try to build on the `JoinBlock` example to add more people to
    the list, divide them into batches of four, and output the name of the oldest
    person in each batch.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 作为练习，尝试在 `JoinBlock` 示例的基础上添加更多人员到列表中，将他们分成每组四人的批次，并输出每个批次中最年长的人的名字。
- en: Now that we have explored examples of all of the available dataflow blocks,
    let’s get into some real-world dataflow examples. In the next section, we will
    use some dataflow blocks to create a producer/consumer implementation.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经探讨了所有可用数据流块的一些示例，让我们进入一些真实世界的数据流示例。在下一节中，我们将使用一些数据流块来创建生产者/消费者实现。
- en: Implementing the producer/consumer pattern
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现生产者/消费者模式
- en: The blocks in the TPL Dataflow library provide a fantastic platform for implementing
    the **producer/consumer pattern**. If you are not familiar with this design pattern,
    it involves two operations and a queue of work. The **producer** is the first
    operation. It is responsible for filling the queue with data or units of work.
    The **consumer** is responsible for taking items from the queue and acting on
    them in some way. There can be one or more producers and one or more consumers
    in the system. You can change the number of producers or consumers, depending
    on which part of the process is the bottleneck.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: TPL数据流库中的块为实施**生产者/消费者模式**提供了一个出色的平台。如果你不熟悉这个设计模式，它涉及两个操作和一个工作队列。**生产者**是第一个操作。它负责用数据或工作单元填充队列。**消费者**负责从队列中取出项目并以某种方式对其采取行动。系统中可以有一个或多个生产者和一个或多个消费者。你可以根据流程的哪个部分是瓶颈来改变生产者或消费者的数量。
- en: Real-World Scenario Example
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 现实世界场景示例
- en: To relate the producer/consumer pattern to a *real-world scenario*, think about
    preparing gifts for a holiday gathering. You and a partner are working together
    to prepare the gifts. You are fetching and staging the gifts to be wrapped. You
    are the *producer*. Your partner is taking items from your queue and wrapping
    each gift. They are the *consumer*. If the queue starts to get backed up, you
    can find another friend (or consumer) to help with the wrapping and increase the
    overall throughput. If, on the other hand, you are taking too much time to find
    each gift to be wrapped, you can add another producer to help find them and fill
    the queue. This will keep the consumers busy and increase the efficiency of the
    process.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 将生产者/消费者模式与一个*现实世界场景*联系起来，想想为节日聚会准备礼物的情况。你和一位伙伴一起合作准备礼物。你负责取来并摆放待包装的礼物。你是*生产者*。你的伙伴从你的队列中取走物品，并为每个礼物包装。他们是*消费者*。如果队列开始拥堵，你可以找到另一个朋友（或消费者）来帮忙包装，从而提高整体吞吐量。另一方面，如果你花费太多时间寻找待包装的每个礼物，你可以添加另一个生产者来帮助他们找到并填充队列。这将使消费者保持忙碌，并提高流程的效率。
- en: In our .NET producer/consumer example, we are going to build a simple WPF application
    that fetches blog posts from multiple RSS feeds and displays them in a single
    `ListView` control. Each row in the list will include the blog post’s date, categories,
    and an HTML summary of the post’s content. The producers in the application will
    fetch posts from an RSS feed and add a `SyndicationItem` to the queue for each
    blog post. We will get posts from three blogs and create a producer for each.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的.NET生产者/消费者示例中，我们将构建一个简单的WPF应用程序，从多个RSS源获取博客文章，并在单个`ListView`控件中显示它们。列表中的每一行将包括博客文章的日期、类别以及文章内容的HTML摘要。应用程序中的生产者将从RSS源获取文章，并为每篇博客文章添加一个`SyndicationItem`到队列中。我们将从三个博客获取文章，并为每个博客创建一个生产者。
- en: 'The consumers will take a `SyndicationItem` from the queue and use an `ActionBlock`
    delegate to create a `BlogPost` object for each `SyndicationItem`. We will create
    three consumers to keep up with the items that have been queued by our three producers.
    When the process completes, the list of `BlogPost` objects will be set as `ItemSource`
    for `ListView`. Let’s get started:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 消费者将从队列中取出`SyndicationItem`，并使用`ActionBlock`委托为每个`SyndicationItem`创建一个`BlogPost`对象。我们将创建三个消费者，以跟上我们三个生产者排队的项目。当过程完成后，`BlogPost`对象的列表将被设置为`ListView`的`ItemSource`。让我们开始吧：
- en: Start by creating a new WPF project with .NET 6\. Name the project `ProducerConsumerRssFeeds`.
  id: totrans-183
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，创建一个新的WPF项目，使用.NET 6。将项目命名为`ProducerConsumerRssFeeds`。
- en: Open **NuGet Package Manager** for the solution, search for **Syndication**
    on the **Install** tab, and add the **System.ServiceModel.Syndication** package
    to the project. This package will make it simple to fetch data from any RSS feed.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开**NuGet包管理器**，在**安装**选项卡中搜索**Syndication**，并将**System.ServiceModel.Syndication**包添加到项目中。这个包将使从任何RSS源获取数据变得简单。
- en: 'Add a new class to the project named `BlogPost`. This will be our model object
    for each blog post to be displayed in `ListView`. Add the following properties
    to the new class:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为`BlogPost`的新类。这将是我们在`ListView`中显示的每篇博客文章的模型对象。向新类添加以下属性：
- en: '[PRE89]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: 'Now, it’s time to create a service class to fetch the blog posts for a given
    RSS feed URL. Add a new class named `RssFeedService` to the project and add a
    method named `GetFeedItems` to the class:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候创建一个服务类来获取给定RSS源URL的博客文章了。向项目中添加一个名为`RssFeedService`的新类，并向该类添加一个名为`GetFeedItems`的方法：
- en: '[PRE90]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: The static `SyndicationFeed.Load` method uses `XmlReader` to fetch the XML from
    the provided `feedUrl` and transform it into `IEnumerable<SyndicationItem>` to
    return from the method.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 静态 `SyndicationFeed.Load` 方法使用 `XmlReader` 从提供的 `feedUrl` 获取 XML 并将其转换为 `IEnumerable<SyndicationItem>`
    以从方法返回。
- en: 'Next, create a new class named `FeedAggregator`. This class will contain the
    producer/consumer logic that calls `GetFeedItems` for each blog and transforms
    the feed data for each blog post so that it can be displayed in the UI. The three
    blogs that we are aggregating are as follows:'
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `FeedAggregator` 的新类。这个类将包含调用每个博客的 `GetFeedItems` 并将每个博客帖子的数据转换以便在
    UI 中显示的生产者/消费者逻辑。我们正在聚合的三个博客如下：
- en: The .NET blog
  id: totrans-191
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET 博客
- en: The Windows blog
  id: totrans-192
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: Windows 博客
- en: The Microsoft 365 blog
  id: totrans-193
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: 微软 365 博客
- en: 'The first step with `FeedAggregator` is creating a producer method named `ProduceFeedItems`
    and a parent method named `QuseueAllFeeds` that will start three instances of
    the producer method:'
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 使用 `FeedAggregator` 的第一步是创建一个名为 `ProduceFeedItems` 的生产者方法和一个名为 `QuseueAllFeeds`
    的父方法，这将启动三个生产者方法的实例：
- en: '[PRE91]'
  id: totrans-195
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: We are using `BufferBlock<SyndicationItem>` as our queue. Every producer calls
    `GetFeedItems` and adds each `SyndicationItem` that’s returned to `BufferBlock`.
    The `QueueAllFeeds` method uses `Task.WhenAll` to wait for all of the producers
    to finish adding items to the queue. Then, it signals to `BufferBlock` that all
    the producers are done by calling `itemQueue.Complete()`.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用 `BufferBlock<SyndicationItem>` 作为我们的队列。每个生产者都调用 `GetFeedItems` 并将返回的每个
    `SyndicationItem` 添加到 `BufferBlock`。`QueueAllFeeds` 方法使用 `Task.WhenAll` 等待所有生产者完成向队列添加项目。然后，它通过调用
    `itemQueue.Complete()` 通知 `BufferBlock` 所有生产者已完成。
- en: 'Next, we will create our consumer method. This method, named `ConsumeFeedItem`,
    will be responsible for taking a `SyndicationItem` provided by `BufferBlock` and
    converting it into a `BlogPost` object. Each `BlogPost` will be added to `ConcurrentBag<BlogPost>`.
    We’re using a thread-safe collection here because there will be multiple consumers
    adding output to the list:'
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将创建我们的消费者方法。这个方法，命名为 `ConsumeFeedItem`，将负责将 `BufferBlock` 提供的 `SyndicationItem`
    转换成一个 `BlogPost` 对象。每个 `BlogPost` 都将被添加到 `ConcurrentBag<BlogPost>` 中。我们在这里使用线程安全的集合，因为将有多个消费者向列表中添加输出：
- en: '[PRE92]'
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Now, it’s time to tie the producer/consumer logic together. Create a method
    named `GetAllMicrosoftBlogPosts`:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，是时候将生产者/消费者逻辑结合起来。创建一个名为 `GetAllMicrosoftBlogPosts` 的方法：
- en: '[PRE93]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: 'The method starts by creating a `ConcurrentBag<BlogPost>` to aggregate the
    final list of posts for the UI. Then, it creates the `itemQueue` object with a
    `BoundedCapacity` of `10`. This bounded capacity means that no more than 10 items
    can be enqueued at any time. Once the queue reaches 10, all the producers must
    wait for the consumers to dequeue some items. This can slow the performance of
    the process, but it prevents potential out-of-memory issues in production code.
    Our sample is not in any danger of running out of memory when processing posts
    from three blogs, but you can see how to use `BoundedCapacity` when it is needed
    in your applications. You can create the queue with no `BoundedCapacity` like
    this:'
  id: totrans-201
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法首先创建一个 `ConcurrentBag<BlogPost>` 来聚合最终用于 UI 的帖子列表。然后，它创建一个具有 `BoundedCapacity`
    为 `10` 的 `itemQueue` 对象。这个有界容量意味着在任何时候不能入队超过 10 个项目。一旦队列达到 10，所有生产者都必须等待消费者退队一些项目。这可能会降低处理过程的性能，但可以防止生产代码中潜在的内存溢出问题。我们的示例在处理来自三个博客的帖子时不会出现内存不足的危险，但你可以在需要时看到如何使用
    `BoundedCapacity`。你可以像这样创建没有 `BoundedCapacity` 的队列：
- en: '[PRE94]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: The next part of the method creates three consumers that use `ActionBlock<SyndicationItem>`
    with `ConsumeFeedItem` as the provided delegate. Each consumer is linked to the
    queue with the `LinkTo` method. Setting `BoundedCapacity` of the consumers to
    `1` tells the producers to move on to the next consumer if the current one is
    already busy processing an item.
  id: totrans-203
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 方法的下一部分创建了三个使用 `ActionBlock<SyndicationItem>` 并以 `ConsumeFeedItem` 作为提供的代理的消费者。每个消费者都通过
    `LinkTo` 方法链接到队列。将消费者的 `BoundedCapacity` 设置为 `1` 告诉生产者在当前消费者正在忙于处理一个项目时，可以继续到下一个消费者。
- en: 'Once the links have been established, we can start the producers by calling
    `QueueAllFeeds`. Then, we must `await` the producers and the `Completion` object
    of each consumer `ActionBlock`. By linking the completion of the producers and
    consumers, we don’t need to explicitly `await` the `Completion` object of the
    consumers:'
  id: totrans-204
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦建立了链接，我们可以通过调用 `QueueAllFeeds` 来启动生产者。然后，我们必须 `await` 生产者和每个消费者 `ActionBlock`
    的 `Completion` 对象。通过将生产者和消费者的完成状态链接起来，我们不需要显式地 `await` 消费者的 `Completion` 对象：
- en: '[PRE95]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: 'The next step is to create some UI controls to display the information to our
    users. Open the `MainWindow.xaml` file and replace the existing `Grid` with the
    following markup:'
  id: totrans-206
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是创建一些UI控件来向用户显示信息。打开`MainWindow.xaml`文件，并用以下标记替换现有的`Grid`：
- en: '[PRE96]'
  id: totrans-207
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: 'Explaining the details of WPF, XAML, and data binding are outside the scope
    of this book. If you would like to learn more about WPF, check out *Mastering
    Windows Presentation Foundation*, by Sheridan Yeun: [https://www.packtpub.com/product/mastering-windows-presentation-foundation-second-edition/9781838643416](https://www.packtpub.com/product/mastering-windows-presentation-foundation-second-edition/9781838643416).
    What this markup does is create a new `ListView` control with a `DataTemplate`
    to define the structure of each list item in the control. For each item, we are
    defining either a `TextBlock` or `TextBox` to hold the values for each `BlogPost`
    object in the list.'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 解释WPF、XAML和数据绑定的细节超出了本书的范围。如果您想了解更多关于WPF的信息，请查看Sheridan Yeun的《Mastering Windows
    Presentation Foundation》：[https://www.packtpub.com/product/mastering-windows-presentation-foundation-second-edition/9781838643416](https://www.packtpub.com/product/mastering-windows-presentation-foundation-second-edition/9781838643416)。这个标记的作用是创建一个新的`ListView`控件，并使用`DataTemplate`来定义控件中每个列表项的结构。对于每个项，我们定义一个`TextBlock`或`TextBox`来保存列表中每个`BlogPost`对象的价值。
- en: 'The last thing we must do is call the `GetAllMicrosoftBlogPosts` method and
    populate the UI. Open `MainWindow.xaml.cs` and add the following code:'
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们必须做的最后一件事是调用`GetAllMicrosoftBlogPosts`方法并填充UI。打开`MainWindow.xaml.cs`并添加以下代码：
- en: '[PRE97]'
  id: totrans-210
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE97]'
- en: After `MainWindow` has loaded, the items that have been returned from `GetAllMicrosoftBlogPosts`
    are set as `mainListView.ItemsSource`. This will allow the data to bind to the
    elements in `DataTemplate`, which we defined in the XAML.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MainWindow`加载后，从`GetAllMicrosoftBlogPosts`返回的项目被设置为`mainListView.ItemsSource`。这将允许数据绑定到我们在XAML中定义的`DataTemplate`元素。
- en: 'Now, run the project and see how things look:'
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，运行项目并查看效果：
- en: '![Figure 7.2 – Running the ProducerConsumerRssFeeds WPF application for the
    first time ](img/Figure_7.2_B18552.jpg)'
  id: totrans-213
  prefs: []
  type: TYPE_IMG
  zh: '![图7.2 – 首次运行ProducerConsumerRssFeeds WPF应用程序](img/Figure_7.2_B18552.jpg)'
- en: Figure 7.2 – Running the ProducerConsumerRssFeeds WPF application for the first
    time
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.2 – 首次运行ProducerConsumerRssFeeds WPF应用程序
- en: As you can see, the list displays 10 blog post summaries from each of the Microsoft
    blogs. This is the default maximum number of items that can be returned by Microsoft’s
    blogs.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，列表显示了来自每个微软博客的10篇博客摘要。这是微软博客默认可以返回的最大项目数。
- en: You can try experimenting by increasing or decreasing the number of producers
    and consumers in the project. Does adding more consumers speed up the process?
    Try adding some of your favorite blogs’ feeds to the list of producers and see
    what happens.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过增加或减少项目中的生产者和消费者数量来尝试实验。增加更多的消费者是否会加快处理速度？尝试将您最喜欢的博客源添加到生产者列表中，看看会发生什么。
- en: Note
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You may have noticed that the content summary that’s returned by the RSS feeds
    contains HTML, and we are just rendering it as plain text in a `TextBox` control.
    If you would like to use a `RichTextBox` that renders the HTML properly, take
    a look at this sample project on CodeProject that uses a WPF `RichTextBox`: [https://www.codeproject.com/articles/1097390/displaying-html-in-a-wpf-richtextbox](https://www.codeproject.com/articles/1097390/displaying-html-in-a-wpf-richtextbox).'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 您可能已经注意到，由RSS源返回的内容摘要包含HTML，我们只是在`TextBox`控件中以纯文本形式渲染它。如果您想使用正确渲染HTML的`RichTextBox`，请查看CodeProject上的这个示例项目，它使用WPF
    `RichTextBox`：[https://www.codeproject.com/articles/1097390/displaying-html-in-a-wpf-richtextbox](https://www.codeproject.com/articles/1097390/displaying-html-in-a-wpf-richtextbox)。
- en: In the next section, we will create another example that uses different types
    of dataflow blocks to create a data pipeline.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将创建另一个示例，使用不同类型的数据流块来创建数据管道。
- en: Creating a data pipeline with multiple blocks
  id: totrans-220
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用多个块创建数据管道
- en: 'One of the biggest advantages of using dataflow blocks is the ability to link
    them and create a complete workflow or data pipeline. In the previous section,
    we saw how this linking worked between producer and consumer blocks. In this section,
    we will create a console application with a pipeline of five dataflow blocks all
    linked together to complete a series of tasks. We will leverage `TransformBlock`,
    `TransformManyBlock`, and `ActionBlock` to take an RSS feed and output a list
    of categories that are unique across all blog posts in the feed. Follow these
    steps:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 使用数据流块的最大优点之一是能够将它们连接起来，创建一个完整的工作流程或数据管道。在上一节中，我们看到了生产者和消费者块之间是如何进行连接的。在本节中，我们将创建一个包含五个数据流块的控制台应用程序，这些块全部连接在一起以完成一系列任务。我们将利用
    `TransformBlock`、`TransformManyBlock` 和 `ActionBlock` 从 RSS 源中提取并输出一个列表，其中包含所有博客文章中独特的分类。按照以下步骤操作：
- en: Start by creating a new .NET 6 console application in Visual Studio named `OutputBlogCategories`.
  id: totrans-222
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Visual Studio 中创建一个新的 .NET 6 控制台应用程序，命名为 `OutputBlogCategories`。
- en: Add the **System.ComponentModel.Syndication** NuGet package that we used in
    the previous example.
  id: totrans-223
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加我们在上一个示例中使用的 **System.ComponentModel.Syndication** NuGet 包。
- en: Add the same `RssFeedService` class from the previous example. You can right-click
    on the project in `RssFeedService` and copy/paste the same code we used in the
    previous example.
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加与上一个示例中相同的 `RssFeedService` 类。您可以在 `RssFeedService` 项目的上下文中右键单击，然后复制/粘贴我们在上一个示例中使用的相同代码。
- en: 'Add a new class named `FeedCategoryTransformer` to the project and create a
    method named `GetCategoriesForFeed`:'
  id: totrans-225
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目中添加一个名为 `FeedCategoryTransformer` 的新类，并创建一个名为 `GetCategoriesForFeed` 的方法：
- en: '[PRE98]'
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Over the next few steps, we will create the implementation for the `GetCategoriesForFeed`
    method. First, create a `TransformBlock` named `downloadFeed` that accepts `url`
    as a string and returns `IEnumerable<SyndicationItem>` from the `GetFeedItems`
    method:'
  id: totrans-227
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在接下来的几个步骤中，我们将为 `GetCategoriesForFeed` 方法创建实现。首先，创建一个名为 `downloadFeed` 的 `TransformBlock`，它接受字符串
    `url` 并从 `GetFeedItems` 方法返回 `IEnumerable<SyndicationItem>`：
- en: '[PRE99]'
  id: totrans-228
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE99]'
- en: 'Next, create a `TransformBlock` that accepts `IEnumerable<SyndicationItem>`
    and returns `List<SyndicationCategory>`. This block will fetch the complete list
    of categories from every blog post and return them as a single list:'
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个接受 `IEnumerable<SyndicationItem>` 并返回 `List<SyndicationCategory>` 的
    `TransformBlock`。这个块将从每篇博客文章中获取完整的分类列表，并将它们作为一个单独的列表返回：
- en: '[PRE100]'
  id: totrans-230
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Now, create another `TransformBlock`. This block will accept `List<SyndicationCategory>`
    from the previous block, remove all duplicates, and return the filtered `List<SyndicationCategory>`:'
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建另一个 `TransformBlock`。这个块将接受来自上一个块的 `List<SyndicationCategory>`，移除所有重复项，并返回过滤后的
    `List<SyndicationCategory>`：
- en: '[PRE101]'
  id: totrans-232
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'To use the LINQ Distinct extension method on a complex object such as `SyndicationCategory`,
    a custom comparer that implements `IEqualityComparer<T>` is required. You can
    get the complete source for `CategoryComparer` from this chapter’s GitHub repository:
    [https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07).'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 要在复杂对象如 `SyndicationCategory` 上使用 LINQ Distinct 扩展方法，需要一个实现 `IEqualityComparer<T>`
    的自定义比较器。你可以从本章的 GitHub 仓库中获取 `CategoryComparer` 的完整源代码：[https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07](https://github.com/PacktPublishing/Parallel-Programming-and-Concurrency-with-C-sharp-10-and-.NET-6/tree/main/chapter07)。
- en: 'Next, create a `TransformManyBlock` named `createCategoryString`. This block
    will accept the de-duplicated `List<SyndicationCategory>` and return a string
    for each `Name` property of the categories. So, the block is invoked once for
    the entire list, but it will, in turn, invoke the next block in the flow once
    for every item in the list:'
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `createCategoryString` 的 `TransformManyBlock`。这个块将接受去重的 `List<SyndicationCategory>`
    并为每个分类的 `Name` 属性返回一个字符串。因此，该块对整个列表调用一次，但将依次为列表中的每个项目调用流程中的下一个块：
- en: '[PRE102]'
  id: totrans-235
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE102]'
- en: 'The final block is an `ActionBlock` named `printCategoryInCaps`. This block
    will output each category name to the console in all caps using `ToUpper`:'
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一个块是一个名为 `printCategoryInCaps` 的 `ActionBlock`。这个块将使用 `ToUpper` 将每个分类名称输出到控制台，全部转换为大写：
- en: '[PRE103]'
  id: totrans-237
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Now that the dataflow blocks have been configured, it’s time to link them.
    Create a `DataflowLinkOptions` that will propagate the completion of each block.
    Then, use the `LinkTo` method to link each block in the chain to the next one:'
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在数据流块已经配置好了，是时候将它们连接起来。创建一个 `DataflowLinkOptions`，它将传播每个块的完成状态。然后，使用 `LinkTo`
    方法将链中的每个块连接到下一个块：
- en: '[PRE104]'
  id: totrans-239
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE104]'
- en: 'The last few steps of creating the `GetCategoriesForFeed` method involve sending
    `url` to the first block, marking it as `Complete`, and waiting for the last block
    in the chain:'
  id: totrans-240
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `GetCategoriesForFeed` 方法的最后几个步骤包括将 `url` 发送到第一个块，将其标记为 `Complete`，并等待链中的最后一个块：
- en: '[PRE105]'
  id: totrans-241
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE105]'
- en: 'Now, open `Program.cs` and update the code so that it calls `GetCategoriesForFeed`,
    providing the URL for the Windows blog RSS feed:'
  id: totrans-242
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，打开 `Program.cs` 并更新代码，使其调用 `GetCategoriesForFeed` 方法，提供 Windows 博客 RSS feed
    的 URL：
- en: '[PRE106]'
  id: totrans-243
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE106]'
- en: 'Run the program and examine the list of categories in the output:'
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行程序并检查输出中的分类列表：
- en: '![Figure 7.3 – Displaying a deduplicated list of categories from the Windows
    blog feed ](img/Figure_7.3_B18552.jpg)'
  id: totrans-245
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.3 – 显示来自 Windows 博客 feed 的去重分类列表](img/Figure_7.3_B18552.jpg)'
- en: Figure 7.3 – Displaying a deduplicated list of categories from the Windows blog
    feed
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.3 – 显示来自 Windows 博客 feed 的去重分类列表
- en: Now that you understand how to create a data pipeline with a series of dataflow
    blocks, we will look at an example of combining data from multiple sources with
    a `JoinBlock`.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经了解了如何使用一系列数据流块创建数据管道，我们将查看一个使用 `JoinBlock` 将多个来源的数据组合的示例。
- en: Manipulating data from multiple data sources
  id: totrans-248
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 操作来自多个数据源的数据
- en: 'A `JoinBlock` can be configured to receive different data types from two or
    three data sources. As each set of data types is completed, the block is completed
    with a `Tuple` containing all three object types to be acted upon. In this example,
    we will create a `JoinBlock` that accepts a `string` and `int` pair and passes
    `Tuple(string, int)` along to an `ActionBlock`, which outputs their values to
    the console. Follow these steps:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: '`JoinBlock` 可以配置为从两个或三个数据源接收不同的数据类型。当每一组数据类型完成时，该块将使用包含要操作的所有三个对象类型的 `Tuple`
    完成。在这个例子中，我们将创建一个接受 `string` 和 `int` 对的 `JoinBlock`，并将 `Tuple(string, int)` 传递给一个
    `ActionBlock`，该 `ActionBlock` 将它们的值输出到控制台。按照以下步骤操作：'
- en: Start by creating a new console application in Visual Studio
  id: totrans-250
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在 Visual Studio 中创建一个新的控制台应用程序
- en: 'Add a new class named `DataJoiner` to the project and add a static method to
    the class named `JoinData`:'
  id: totrans-251
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 向项目中添加一个名为 `DataJoiner` 的新类，并在该类中添加一个名为 `JoinData` 的静态方法：
- en: '[PRE107]'
  id: totrans-252
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'Add the following code to create two `BufferBlock` objects, a `JoinBlock<string,
    int>`, and an `ActionBlock<Tuple<string, int>>`:'
  id: totrans-253
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加以下代码以创建两个 `BufferBlock` 对象、一个 `JoinBlock<string, int>` 和一个 `ActionBlock<Tuple<string,
    int>>`：
- en: '[PRE108]'
  id: totrans-254
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Setting the block to non-greedy mode means it will wait for an item of each
    type before executing the block.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 将块设置为非贪婪模式意味着它将在执行块之前等待每种类型的一个项目。
- en: 'Now, create the links between the blocks:'
  id: totrans-256
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建块之间的链接：
- en: '[PRE109]'
  id: totrans-257
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'Next, push some data to the two `BufferBlock` objects, wait for a second, and
    then mark them both as complete:'
  id: totrans-258
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向两个 `BufferBlock` 对象推送一些数据，等待一秒钟，然后将它们都标记为完成：
- en: '[PRE110]'
  id: totrans-259
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'Add the following code to `Program.cs` to run the example code:'
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到 `Program.cs` 中以运行示例代码：
- en: '[PRE111]'
  id: totrans-261
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE111]'
- en: 'Finally, run the application and examine the output. You will see that `ActionBlock`
    outputs a `string` and `integer` pair for each set of values provided:'
  id: totrans-262
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，运行应用程序并检查输出。你会看到 `ActionBlock` 为每一组提供的值输出一个 `string` 和 `integer` 对：
- en: '![Figure 7.4 – Running the JoinBlockExample console application ](img/Figure_7.4_B18552.jpg)'
  id: totrans-263
  prefs: []
  type: TYPE_IMG
  zh: '![图 7.4 – 运行 JoinBlockExample 控制台应用程序](img/Figure_7.4_B18552.jpg)'
- en: Figure 7.4 – Running the JoinBlockExample console application
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 图 7.4 – 运行 JoinBlockExample 控制台应用程序
- en: That’s all there is to using the `JoinBlock` dataflow block. Try making some
    changes on your own, such as changing the `Greedy` option or the order in which
    data is added to each `BufferBlock`. How does that impact the output?
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是使用 `JoinBlock` 数据流块的全部内容。尝试自己做一些更改，比如更改 `Greedy` 选项或向每个 `BufferBlock` 添加数据的顺序。这会如何影响输出？
- en: Before we finish up this chapter, let’s review everything we’ve learned.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们完成本章之前，让我们回顾一下我们所学到的所有内容。
- en: Summary
  id: totrans-267
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we learned all about the various blocks in the TPL Dataflow
    library. We started by learning a little about each block type and providing a
    brief code snippet for each. Next, we created a practical example that implemented
    the producer/consumer pattern to fetch blog data from three different Microsoft
    blogs. We also examined `TransformBlock`, `TransformManyBlock`, and `JoinBlock`
    more closely in .NET console applications. You should now feel confident in your
    ability to use some of the dataflow blocks in your applications to automate some
    complex data workflows.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们学习了 TPL Dataflow 库中的各种块。我们首先简要了解了每种块类型，并为每个块提供了一个简短的代码片段。接下来，我们创建了一个实际示例，实现了生产者/消费者模式，从三个不同的微软博客中获取博客数据。我们还更详细地考察了
    `.NET 控制台应用程序中的 `TransformBlock`、`TransformManyBlock` 和 `JoinBlock`。现在，你应该对自己的能力有信心，能够在你的应用程序中使用一些数据流块来自动化一些复杂的数据工作流。
- en: 'If you would like some additional reading about the TPL Dataflow library, you
    can download *Introduction to TPL Dataflow* from the Microsoft Download Center:
    [https://www.microsoft.com/en-us/download/details.aspx?id=14782](https://www.microsoft.com/en-us/download/details.aspx?id=14782).'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于 TPL Dataflow 库的阅读材料，你可以从微软下载中心下载 *TPL Dataflow 简介*：[https://www.microsoft.com/en-us/download/details.aspx?id=14782](https://www.microsoft.com/en-us/download/details.aspx?id=14782)。
- en: In the next chapter, [*Chapter 8*](B18552_08_ePub.xhtml#_idTextAnchor130), we
    will take a closer look at the collections in the `System.Collections.Concurrent`
    namespace. We will also discover some practical uses of PLINQ in modern .NET applications.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章（[*第8章*](B18552_08_ePub.xhtml#_idTextAnchor130)）中，我们将更深入地研究 `System.Collections.Concurrent`
    命名空间中的集合。我们还将发现 PLINQ 在现代 .NET 应用程序中的实际用途。
- en: Questions
  id: totrans-271
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: 'Answer the following questions to test your knowledge of this chapter:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 回答以下问题以测试你对本章知识的掌握：
- en: What type of data flow block aggregates data from two or three data sources?
  id: totrans-273
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种类型的数据流块可以聚合来自两个或三个数据源的数据？
- en: What type of block is a `BufferBlock`?
  id: totrans-274
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`BufferBlock` 是哪种类型的块？'
- en: What type of block is populated by a producer in the producer/consumer pattern?
  id: totrans-275
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在生产者/消费者模式中，哪种类型的块由生产者填充？
- en: What method links the completion of two blocks?
  id: totrans-276
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 哪种方法将两个块的完成状态连接起来？
- en: What method is called to signal that our code is done adding data to a source
    block?
  id: totrans-277
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用哪种方法来表示我们的代码已经完成向源块添加数据？
- en: What is the async equivalent of calling `Post()`?
  id: totrans-278
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `Post()` 的异步等价方法是什么？
- en: What is the async equivalent of calling `Receive()`?
  id: totrans-279
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 调用 `Receive()` 的异步等价方法是什么？
