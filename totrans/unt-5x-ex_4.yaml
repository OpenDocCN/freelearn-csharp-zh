- en: Chapter 4. Continuing the Space Shooter
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第4章：继续太空射击游戏
- en: 'This chapter continues from the previous one in creating a twin-stick space
    shooter game. At this stage, we have a working game. At least, the gamer can control
    a spaceship using two axes: movement and rotation. WASD keys on the keyboard control
    movement (up, down, left, and right) and the mouse cursor controls rotation—the
    spaceship always rotates to face the cursor. In addition to player controls, the
    level features enemy characters that spawn at regular intervals, fly around the
    level, and move toward the player with hostile intent. Finally, both the player
    and enemies support a Health component, which means both are susceptible to damage
    and can be destroyed. Right now, however, the player lacks two important features:
    it cannot fire a weapon and it cannot increase the score. This chapter tackles
    these issues and more. Firing weapons, as we''ll see, represents a particularly
    interesting problem. Overall, this chapter covers the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从上一章继续讲述创建双摇杆太空射击游戏。目前，我们有一个可以工作的游戏。至少，玩家可以使用两个轴来控制一艘太空船：移动和旋转。键盘上的WASD键控制移动（上、下、左、右），鼠标光标控制旋转——太空船总是旋转以面对光标。除了玩家控制外，关卡还包含在固定间隔内生成的敌人角色，它们在关卡中飞行，并带着敌意向玩家移动。最后，玩家和敌人都支持健康组件，这意味着它们都容易受到伤害，可以被摧毁。然而，目前玩家缺少两个重要功能：不能开火和不能增加分数。本章将解决这些问题以及其他更多问题。正如我们将看到的，开火武器代表了一个特别有趣的问题。总体而言，本章涵盖了以下主题：
- en: Weapons and spawning ammo
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 武器和弹药生成
- en: Memory management and pooling
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 内存管理和池化
- en: Sound and audio
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 声音和音频
- en: Scoring
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 得分
- en: Debugging and testing
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 调试和测试
- en: Building and distribution
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构建和分发
- en: Note
  id: totrans-8
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The completed project so far can be found in the book's companion files in the
    `Chapter04/Start` folder. You can start here and follow along with this chapter
    if you don't have your own project already.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止的完整项目可以在书的配套文件中的`Chapter04/Start`文件夹中找到。如果您还没有自己的项目，可以从这里开始，并跟随本章进行。
- en: Guns and gun turrets
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 枪械和枪塔
- en: Let's start tackling weapons in detail. Specifically, the level contains a player
    and enemy ships. The player must shoot enemies but, right now, cannot do so. See
    *Figure 4.1*. On thinking carefully about weapons, we identify three main concepts
    or things that need development. First, there's the spawner or generator—the object
    that actually fires ammo in the scene when the fire button is pressed. Second,
    there's the ammo itself that, once generated, travels through the level on its
    own. Third, there's the ability for ammo to collide with other objects and damage
    them.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们详细地解决武器问题。具体来说，关卡包含一个玩家和敌人飞船。玩家必须射击敌人，但现在还不能这样做。参见*图4.1*。仔细思考武器后，我们确定了三个主要的概念或需要开发的事物。首先，有一个生成器或生成器——当按下开火按钮时，在场景中实际发射弹药的对象。其次，有弹药本身，一旦生成，就会在关卡中自行移动。第三，弹药能够与其他对象碰撞并造成伤害。
- en: '![Guns and gun turrets](img/B05118_04_01.jpg)'
  id: totrans-12
  prefs: []
  type: TYPE_IMG
  zh: '![枪械和枪塔](img/B05118_04_01.jpg)'
- en: 'Figure 4.1: The game so far'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1：到目前为止的游戏
- en: 'Tackling each area in order, we begin with turrets—the points where bullets
    are spawned and fired. For this game, the player will have only one turret, but
    ideally, the game should support the addition of more, if desired, allowing the
    player to dual-fire or more! To create the first turret, add a new empty game
    object to the scene by selecting **GameObject** | **Create Empty** from the application
    menu. Name this `Turret`. Then, position the `Turret` object to the front of the
    spaceship, making sure that the blue forward vector arrow is pointing ahead in
    the direction that ammo will be fired. Finally, make the turret a child of the
    spaceship by dragging and dropping it in the **Hierarchy** panel. See *Figure
    4.2*:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 按顺序解决每个区域，我们首先从炮塔开始——子弹生成和发射的点。对于这个游戏，玩家将只有一个炮塔，但理想情况下，游戏应该支持添加更多，如果需要的话，允许玩家进行双发射或更多！要创建第一个炮塔，从应用程序菜单中选择**GameObject**
    | **Create Empty**，在场景中添加一个新的空游戏对象。将其命名为`Turret`。然后，将`Turret`对象定位在太空船的前面，确保蓝色前向向量箭头指向弹药将被发射的方向。最后，通过拖放它到**Hierarchy**面板中，使炮塔成为太空船的子对象。参见*图4.2*：
- en: '![Guns and gun turrets](img/B05118_04_02.jpg)'
  id: totrans-15
  prefs: []
  type: TYPE_IMG
  zh: '![枪械和枪塔](img/B05118_04_02.jpg)'
- en: Figure 4.2:Positioning a Turret object as a child of the spaceship
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2：将炮塔对象作为太空船的子对象定位
- en: Creating a `Turret` object for the ammo as a spawn location is a splendid beginning,
    but for ammo to actually be fired, we'll need an ammo object. Specifically, we'll
    create an `Ammo` prefab that can be instantiated as ammo, when needed. We'll do
    this next.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 为弹药创建一个作为生成位置的 `Turret` 对象是一个很好的开始，但为了实际发射弹药，我们需要一个弹药对象。具体来说，我们将创建一个 `Ammo`
    预制件，在需要时可以实例化为弹药。我们将在下一步进行操作。
- en: Ammo prefabs
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹药预制件
- en: When the player presses the fire button, the spaceship should shoot ammo objects
    in the scene. These objects will be based on an `Ammo` prefab. Let's create this
    prefab now. To start, we'll configure the texture to be used as an ammo graphic.
    Open the `Textures` folder in the **Project** panel, and select the `Ammo` texture.
    This texture features several different versions of an ammo sprite, aligned in
    a row side by side. See *Figure 4.3*. When ammo is fired, we don't want to show
    the complete texture; instead, we want to show either just one of the images or
    the images played as an animation sequence, frame by frame.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家按下射击按钮时，宇宙飞船应该在场景中发射弹药对象。这些对象将基于一个 `Ammo` 预制件。现在让我们创建这个预制件。首先，我们将配置用作弹药图形的纹理。在**项目**面板中打开
    `Textures` 文件夹，并选择 `Ammo` 纹理。这个纹理展示了几个不同版本的弹药精灵，并排排列。参见*图 4.3*。当发射弹药时，我们不想显示完整的纹理；相反，我们只想显示其中的一张图片或图片作为动画序列逐帧播放。
- en: '![Ammo prefabs](img/B05118_04_03.jpg)'
  id: totrans-20
  prefs: []
  type: TYPE_IMG
  zh: '![弹药预制件](img/B05118_04_03.jpg)'
- en: 'Figure 4.3: Preparing to create an Ammo prefab'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.3：准备创建弹药预制件
- en: 'Presently, Unity recognizes the texture (and each ammo element) as a complete
    unit. We can use Sprite Editor, however, to separate each part. To do this, select
    the **Texture** in the project (if it''s not already selected), and then (from
    the **Object Inspector**) change the **Sprite Mode** drop-down from **Single**
    to **Multiple**. This signifies that more than one sprite is contained within
    the texture space. See *Figure 4.4*:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，Unity 将纹理（以及每个弹药元素）识别为一个完整的单元。然而，我们可以使用精灵编辑器来分离每个部分。为此，在项目中选择**纹理**（如果尚未选择），然后（从**对象检查器**）将**精灵模式**下拉菜单从**单个**更改为**多个**。这表示纹理空间中包含多个精灵。参见*图
    4.4*：
- en: '![Ammo prefabs](img/B05118_04_04.jpg)'
  id: totrans-23
  prefs: []
  type: TYPE_IMG
  zh: '![弹药预制件](img/B05118_04_04.jpg)'
- en: 'Figure 4.4: Select multiple sprites for textures featuring more than one sprite'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4：选择具有多个精灵的纹理中的多个精灵
- en: Click on the **Apply** button, and then click on the **Sprite Editor** button
    from the **Object Inspector**. This opens the Sprite Editor, allowing you to separate
    each sprite. To do this, click and drag your mouse to select each sprite, making
    sure that the **Pivot** is aligned to the object **Center**. See *Figure 4.5*.
    Then, click on **Apply** to accept the changes.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 点击**应用**按钮，然后从**对象检查器**中点击**精灵编辑器**按钮。这会打开精灵编辑器，允许您分离每个精灵。为此，点击并拖动鼠标选择每个精灵，确保**锚点**与对象**中心**对齐。参见*图
    4.5*。然后，点击**应用**以接受更改。
- en: '![Ammo prefabs](img/B05118_04_05.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![弹药预制件](img/B05118_04_05.jpg)'
- en: 'Figure 4.5: Separating multiple sprites in the Sprite Editor'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5：在精灵编辑器中分离多个精灵
- en: 'After accepting the changes in the Sprite Editor, Unity automatically cuts
    the relevant sprites into separate units, each of which can now be selected as
    a separate object in the **Project** panel. Click on the right arrow at the side
    of the texture, and all sprites within will expand outwards. See *Figure 4.6*:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 在接受精灵编辑器中的更改后，Unity 会自动将相关的精灵切割成单独的单位，每个单位现在都可以在**项目**面板中作为一个单独的对象选择。点击纹理旁边的右箭头，纹理内的所有精灵都会向外展开。参见*图
    4.6*：
- en: '![Ammo prefabs](img/B05118_04_06.jpg)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![弹药预制件](img/B05118_04_06.jpg)'
- en: 'Figure 4.6: Expand all sprites within a texture'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6：展开纹理内的所有精灵
- en: 'Now, drag and drop one of the sprites from the **Project** panel to the **Scene**
    via the **Hierarchy** panel. On doing this, it will be added as a sprite object.
    This represents the beginning of our `Ammo` prefab. The sprite itself may not
    initially be oriented to face upward at the game camera. If so, rotate the sprite
    by **90** degrees until it looks correct. See *Figure 4.7*:'
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将**项目**面板中的一个精灵拖放到**场景**中，通过**层次结构**面板进行。这样做后，它将被添加为一个精灵对象。精灵本身可能最初没有面向游戏摄像头向上。如果是这样，旋转精灵
    90 度直到它看起来正确。参见*图 4.7*：
- en: '![Ammo prefabs](img/B05118_04_07.jpg)'
  id: totrans-32
  prefs: []
  type: TYPE_IMG
  zh: '![弹药预制件](img/B05118_04_07.jpg)'
- en: 'Figure 4.7: Aligning the ammo sprite'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7：对齐弹药精灵
- en: Now create a new, empty game object in the scene (**GameObject** | **Create
    Empty** from the application menu) and rename it `Ammo`. Make this new object
    a parent of `Ammo_Sprite` and ensure that its local forward vector is pointing
    in the direction that the ammo should travel. We'll soon reuse the `Mover` script
    (created in the previous chapter) on the ammo to make it move.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 现在在场景中创建一个新的空游戏对象（从应用程序菜单 **GameObject** | **Create Empty**），并将其重命名为 `Ammo`。使这个新对象成为
    `Ammo_Sprite` 的父对象，并确保其局部前进向量指向弹药应该移动的方向。我们将很快在弹药上重用上一章中创建的 `Mover` 脚本，使其移动。
- en: '![Ammo prefabs](img/B05118_04_08.jpg)'
  id: totrans-35
  prefs: []
  type: TYPE_IMG
  zh: '![弹药预制件](img/B05118_04_08.jpg)'
- en: 'Figure 4.8: Building an ammo object'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8：构建弹药对象
- en: 'Drag and drop the `Mover.cs` script from the **Project** panel to the `Ammo`
    parent object via the **Hierarchy** panel in order to add it as a component. Then,
    select the `Ammo` object and, from the **Object Inspector**, change the ammo''s
    **Max Speed** in the **Mover** component to `7`. Finally, add a **Box Collider**
    to the object to approximate its volume (**Component** | **Physics** | **Box Collider**
    from the application menu), and then test this all in the viewport by pressing
    play on the toolbar. The `Ammo` object should shoot forward as though fired from
    a weapon. If it moves up or down incorrectly, then make sure that the parent object
    is rotated so that its blue forward vector really is pointing forward. See *Figure
    4.9*:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 将 **项目** 面板中的 `Mover.cs` 脚本拖放到 **层次** 面板中的 `Ammo` 父对象，以将其添加为组件。然后，选择 `Ammo`
    对象，从 **对象检查器** 中，将 **移动器** 组件中的弹药 **最大速度** 更改为 `7`。最后，向对象添加一个 **盒子碰撞器** 以近似其体积（从应用程序菜单
    **组件** | **物理** | **盒子碰撞器**），然后在视口中通过按工具栏上的播放按钮测试所有这些。`Ammo` 对象应该向前射击，就像是从武器中发射出来的一样。如果它向上或向下移动不正确，那么请确保父对象已旋转，使其蓝色前进向量真正指向前方。参见
    *图 4.9*：
- en: '![Ammo prefabs](img/B05118_04_09.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![弹药预制件](img/B05118_04_09.jpg)'
- en: 'Figure 4.9: Moving forward with an Ammo prefab (Mover and Collider)'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9：使用弹药预制件（移动器和碰撞器）前进
- en: 'Next, add a **Rigidbody** component to the ammo to make it part of the Unity
    physics system. To do this, select the `Ammo` object and navigate to **Component**
    | **Physics** | **Rigidbody** from the application menu. Then, from the **Rigidbody**
    component in the **Inspector**, disable the **Use Gravity** checkbox to prevent
    the ammo from falling to the ground during gameplay. For our purposes, gravity
    need not apply to the ammo as it should simply travel along and eventually be
    destroyed. This highlights an important point in game development generally: real-world
    physics need not apply to every object accurately. We only need enough physics
    to make objects appear correct to the player when they''re looking. See *Figure
    4.10*:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，将一个**刚体**组件添加到弹药中，使其成为 Unity 物理系统的一部分。为此，选择 `Ammo` 对象，从应用程序菜单导航到 **组件**
    | **物理** | **刚体**。然后，在 **检查器**中的 **刚体** 组件中，取消选中 **使用重力** 复选框，以防止弹药在游戏过程中掉落到地面。就我们的目的而言，重力不需要作用于弹药，因为它应该简单地沿着路径移动，最终被销毁。这突出了游戏开发中的一般重要观点：现实世界的物理不一定需要精确地应用于每个对象。我们只需要足够的物理效果，使对象在玩家看来是正确的。参见
    *图 4.10*：
- en: '![Ammo prefabs](img/B05118_04_10.jpg)'
  id: totrans-41
  prefs: []
  type: TYPE_IMG
  zh: '![弹药预制件](img/B05118_04_10.jpg)'
- en: 'Figure 4.10: Removing gravity from the Ammo object'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10：从弹药对象中移除重力
- en: 'In addition to adding a `Mover` script and physics components, we also need
    the ammo to behave distinctly. Specifically, it should damage the objects with
    which it collides, and it should also destroy or disable itself on collision.
    To achieve this, a new script file must be created, `Ammo.cs`. The entire code
    for this is included in *Code Sample 4.1* as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 除了添加 `Mover` 脚本和物理组件外，我们还需要弹药具有独特的表现。具体来说，它应该损坏与它碰撞的对象，并且在碰撞时应该销毁或禁用自己。为了实现这一点，必须创建一个新的脚本文件，`Ammo.cs`。整个代码包含在
    *代码示例 4.1* 中，如下所示：
- en: '[PRE0]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Code Sample 4-1
  id: totrans-45
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 4-1
- en: 'The following points summarize the code sample:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `Ammo` class should be attached to the `Ammo` prefab object and will be
    instantiated for all ammo objects created. Its main purpose is to damage any objects
    with which it collides.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Ammo` 类应该附加到 `Ammo` 预制件对象上，并将为所有创建的弹药对象实例化。其主要目的是损坏与它碰撞的任何对象。'
- en: The `OnTriggerEnter` function is invoked for the ammo when it enters a trigger
    attached to a movable unit, such as the player or enemies. Specifically, it retrieves
    the `Health` component attached to the object, if it has one, and reduces its
    health by the `Damage` amount. The `Health` component was created in the previous
    chapter.
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当弹药进入一个连接到可移动单位（如玩家或敌人）的触发器时，会调用`OnTriggerEnter`函数。具体来说，它会检索对象上附加的`Health`组件（如果有的话），并减少其健康值。`Health`组件是在上一章中创建的。
- en: Notice that each ammo object will have a Lifetime. This represents the amount
    of time in seconds for which the ammo should remain alive and active after it
    is fired and generated in the scene. After the lifetime expires, the ammo should
    either be destroyed entirely or deactivated (more on this shortly).
  id: totrans-49
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注意，每个弹药对象都将有一个生命周期。这代表弹药在发射并生成到场景中后应该保持活跃的时间（以秒为单位）。生命周期结束后，弹药应该被完全销毁或停用（关于这一点稍后会有更多说明）。
- en: The `Invoke` function is used to deactivate the ammo object after the `LifeTime`
    interval. This happens during the `OnEnable` event. This is called automatically
    by Unity each time an object is activated (that is, changed from being disabled
    to enabled).
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`Invoke`函数在`LifeTime`间隔后停用弹药对象。这发生在`OnEnable`事件期间。Unity会在每次对象被激活时自动调用这个函数（即，从禁用状态变为启用状态）。
- en: 'Now, drag and drop the `Ammo` script file from the `Scripts` folder in the
    **Project** panel to the `Ammo` object, and then finally, drag and drop the whole
    `Ammo` object in the **Scene** back to the **Project** panel in the `Prefabs`
    folder in order to create a new `Ammo` prefab. See *Figure 4.11*:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将`Ammo`脚本文件从**项目**面板中的`Scripts`文件夹拖放到`Ammo`对象上，然后最后，将整个`Ammo`对象从**场景**面板拖放到`Prefabs`文件夹中的**项目**面板，以创建一个新的`Ammo`预制体。参见*图
    4.11*：
- en: '![Code Sample 4-1](img/B05118_04_11.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 4-1](img/B05118_04_11.jpg)'
- en: 'Figure 4.11: Creating an Ammo prefab'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11：创建弹药预制体
- en: Congratulations! You've now created an `Ammo` prefab, which can be spawned from
    weapon points to attack enemies directly. This is good, but we've still not handled
    the spawning process itself and we'll address this next.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 恭喜！你现在已经创建了一个`Ammo`预制体，可以从武器点生成以直接攻击敌人。这是好的，但我们还没有处理生成过程本身，我们将在下一部分解决这个问题。
- en: Ammo spawning
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 弹药生成
- en: The `Ammo` prefab created so far presents us with a technical problem that,
    if not taken seriously, has the potential to cause some serious performance penalties
    for our game. Specifically, when the spaceship weapon is fired, we'll need to
    generate ammo that launches into the scene and destroys the enemies on collision.
    This is fine in general, but the problem is that the player could potentially
    press the fire button many times in quick succession and could even hold down
    the fire button for long periods of time, and thereby spawn potentially hundreds
    of ammo prefabs. We could, of course, use the `Instantiate` function seen already
    to generate these prefabs dynamically, but this is problematic because instantiate
    is computationally expensive. When used to generate many items in succession,
    it will typically cause a nightmarish slowdown that'll reduce the FPS to unacceptable
    levels. We need to avoid this!
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止创建的`Ammo`预制体给我们带来了一个技术问题，如果这个问题不被认真对待，可能会对我们的游戏造成一些严重的性能惩罚。具体来说，当太空船武器发射时，我们需要生成弹药，使其进入场景并在碰撞时摧毁敌人。这在一般情况下是可以的，但问题是玩家可能会连续多次按下射击按钮，甚至可能长时间按住射击按钮，从而产生可能成百上千的弹药预制体。当然，我们可以使用之前看到的`Instantiate`函数动态生成这些预制体，但这样做是有问题的，因为实例化在计算上很昂贵。当连续生成许多物品时，它通常会导致令人难以忍受的减速，将帧数降低到不可接受的水平。我们需要避免这种情况！
- en: 'The solution is known as **Pooling**, **Object Pooling**, or **Object Caching**.
    In essence, it means that we must spawn a large and recyclable batch of ammo objects
    at the level startup (a pool of objects) that initially, begin hidden or deactivated,
    and we simply activate the objects as and when needed (when the player fires a
    weapon). When the ammo collides with an enemy or when its lifetime expires, we
    don''t destroy the object entirely, we simply deactivate it again, returning it
    to the pool for reuse later if needed. In this way, we avoid all calls to `Instantiate`
    and simply recycle all ammo objects that we have. To get started with coding this
    functionality, we''ll make an `AmmoManager` class. This class will be responsible
    for two features: first, generating a pool of ammo objects at scene startup, and
    second, giving us a valid and available ammo object from the pool on demand, such
    as on weapon-fire. Consider the following `AmmoManager` *Code Sample 4.2* to achieve
    this:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 这种解决方案被称为**池化**、**对象池化**或**对象缓存**。本质上，这意味着我们必须在关卡启动时（一个对象池）生成大量可回收的弹药对象，最初它们是隐藏的或停用的，我们只需在需要时激活对象（当玩家开火时）。当弹药与敌人碰撞或其生命周期结束时，我们不会完全销毁对象，而是再次停用它，如果需要的话，将其返回池中以供以后重用。这样，我们就避免了所有对`Instantiate`的调用，并简单地回收我们拥有的所有弹药对象。为了开始编写此功能，我们将创建一个`AmmoManager`类。这个类将负责两个功能：首先，在场景启动时生成弹药对象池，其次，在需要时（例如在武器开火时）从池中提供一个有效且可用的弹药对象。以下是一个`AmmoManager`
    *代码示例4.2*，以实现这一目标：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Code Sample 4.2
  id: totrans-59
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例4.2
- en: 'The following points summarize the code sample:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: '`AmmoManager` features an `AmmoArray` member variable, which holds a complete
    list (sequential array of references) of all ammo objects to be generated at startup
    (during the `Awake` event).'
  id: totrans-61
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AmmoManager`具有一个`AmmoArray`成员变量，它保存了在启动时（在`Awake`事件期间）要生成的所有弹药对象的完整列表（引用的顺序数组）。'
- en: '`AmmoArray` will be sized to `PoolSize`. This refers to the total number of
    ammo objects to be generated. The `Awake` function generates the ammo objects
    at the beginning of the level, and these are added to the queue with `Enqueue`.'
  id: totrans-62
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AmmoArray`的大小将设置为`PoolSize`。这指的是要生成的弹药对象的总数。`Awake`函数在关卡开始时生成弹药对象，并使用`Enqueue`将它们添加到队列中。'
- en: Once generated, each ammo object is deactivated with `SetActive(false)` and
    is held in the pool until needed.
  id: totrans-63
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦生成，每个弹药对象都会通过`SetActive(false)`被停用，并保留在池中，直到需要时使用。
- en: '`AmmoManager` uses the `Queue` class from the `Mono` library to manage how
    specific ammo objects are selected from the pool to be activated when fire is
    pressed. The queue works as a **First-In-First-Out** (**FIFO**) object. That is,
    ammo objects are added to the queue one at a time and can be removed when selected
    to be activated. The object removed from the queue is always the object at the
    front. More information on the `Queue` class can be found online at [https://msdn.microsoft.com/en-us/library/7977ey2c%28v=vs.110%29.aspx](https://msdn.microsoft.com/en-us/library/7977ey2c%28v=vs.110%29.aspx).'
  id: totrans-64
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AmmoManager`使用来自`Mono`库的`Queue`类来管理在按下射击键时如何从池中选择特定的弹药对象进行激活。队列作为一个**先进先出**（**FIFO**）对象工作。也就是说，弹药对象逐个添加到队列中，并在被选中激活时移除。从队列中移除的对象总是位于队列前端的对象。有关`Queue`类的更多信息，可以在网上找到，链接为[https://msdn.microsoft.com/en-us/library/7977ey2c%28v=vs.110%29.aspx](https://msdn.microsoft.com/en-us/library/7977ey2c%28v=vs.110%29.aspx)。'
- en: The `Enqueue` function of the `Queue` object is called during `Awake` to add
    objects initially to the queue, one by one, as they are generated.
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在`Queue`对象中，`Enqueue`函数在`Awake`阶段被调用，用于逐个将生成的对象最初添加到队列中。
- en: The `SpawnAmmo` function should be called to generate a new item of ammo in
    the scene. This function does not rely on the `Instantiate` function but uses
    the `Queue` object instead. It removes the first ammo object from the queue, activates
    it, and then adds it to the end of the queue again behind all the other ammo objects.
    In this way, a cycle of generation and regeneration happens, allowing all ammo
    objects to be recycled.
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应该调用`SpawnAmmo`函数来在场景中生成新的弹药项目。此函数不依赖于`Instantiate`函数，而是使用`Queue`对象。它从队列中移除第一个弹药对象，激活它，然后将其再次添加到队列的末尾，位于所有其他弹药对象之后。这样，就发生了一个生成和再生的循环，允许所有弹药对象得到回收。
- en: '`AmmoManager` is coded as a singleton object, meaning that one, and only one,
    instance of the object should exist in the scene at any one time. This functionality
    is achieved through the static member, `AmmoManagerSingleton`. For more information
    on singleton objects, refer to *Mastering Unity Scripting* by *Packt Publishing*
    at [https://www.packtpub.com/game-development/mastering-unity-5x-scripting](https://www.packtpub.com/game-development/mastering-unity-5x-scripting).'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AmmoManager` 被编码为一个单例对象，这意味着在任何时候场景中都应该只有一个此类对象实例。这种功能是通过静态成员 `AmmoManagerSingleton`
    实现的。有关单例对象的更多信息，请参阅 *Packt Publishing* 出版的 *Mastering Unity Scripting*（[https://www.packtpub.com/game-development/mastering-unity-5x-scripting](https://www.packtpub.com/game-development/mastering-unity-5x-scripting)）。'
- en: 'To use this class, create a new `GameObject` in the scene called `AmmoManager`
    by selecting **GameObject** | **Create Empty** from the application menu. Then,
    drag and drop the `AmmoManager` script from the **Project** panel to select the
    object in the scene. Once created, drag and drop the `Ammo` prefab from the `Prefabs`
    folder to the **Ammo Prefab** slot for the **Ammo Manager** component in the **Object
    Inspector**. See *Figure 4.12*:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用此类，在场景中创建一个新的 `GameObject`，命名为 `AmmoManager`，通过从应用程序菜单中选择 **GameObject**
    | **Create Empty** 来实现。然后，从 **Project** 面板拖放 `AmmoManager` 脚本到场景中的对象上。一旦创建，将 `Prefabs`
    文件夹中的 `Ammo` 预制体拖放到 **Object Inspector** 中的 **Ammo Manager** 组件的 **Ammo Prefab**
    槽中。参见 *图 4.12*：
- en: '![Code Sample 4.2](img/B05118_04_12.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 4.2](img/B05118_04_12.jpg)'
- en: 'Figure 4.12: Adding the Ammo Manager to an object'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12：将弹药管理器添加到对象中
- en: 'Now, the scene features an `AmmoManager` object to hold an ammo pool, offscreen
    and hidden. However, still nothing about our existing functionality actually connects
    a fire button press from the gamer with the generation of ammo in the scene. That
    is, we have no code to actually make the ammo visible and working! This connection
    should now be made via the `PlayerController` script that we started in the previous
    chapter. This class should now be amended to handle ammo generation. The recoded
    `PlayerController` class is included in the following *Code Sample 4.3*. The amendments
    are highlighted:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，场景中有一个 `AmmoManager` 对象来存储弹药池，它位于屏幕外且不可见。然而，关于我们现有的功能实际上并没有将玩家的射击按钮按下与场景中弹药生成连接起来。也就是说，我们没有代码来使弹药变得可见并工作！这种连接现在应该通过我们在上一章中开始的
    `PlayerController` 脚本来实现。这个类现在应该修改以处理弹药生成。修改后的 `PlayerController` 类包含在下面的 *代码示例
    4.3* 中。修改内容已突出显示：
- en: '[PRE2]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Code Sample 4.3
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 4.3
- en: 'The following points summarize the code sample:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: '`PlayerController` now features a `TurretTransform` array variable, listing
    all child empties being used as turret spawn locations.'
  id: totrans-75
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`PlayerController` 现在具有一个 `TurretTransform` 数组变量，列出了所有用作炮塔生成位置的子空对象。'
- en: During the `Update` function, `PlayerController` checks for fire button presses.
    If detected, the code cycles through all turrets and spawns one ammo object at
    each turret location.
  id: totrans-76
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `Update` 函数期间，`PlayerController` 检查射击按钮的按下。如果检测到，代码将遍历所有炮塔并在每个炮塔位置生成一个弹药对象。
- en: Once ammo is fired, `ReloadDelay` is engaged (set to `true`). This means that
    the delay must first expire before new ammo can be fired again later.
  id: totrans-77
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一旦发射了弹药，`ReloadDelay` 就会被激活（设置为 `true`）。这意味着在再次发射新弹药之前，必须首先等待延迟时间结束。
- en: 'After adding this code to `PlayerController`, select the `Player` object in
    the scene and then drag and drop the `Turret` empty object on to the `TurretTransform`
    slot. This example uses only one turret, but you could add more if desired. See
    *Figure 4.13*:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在将此代码添加到 `PlayerController` 之后，选择场景中的 `Player` 对象，然后将 `Turret` 空对象拖放到 `TurretTransform`
    槽中。此示例仅使用一个炮塔，但如果需要，可以添加更多。参见 *图 4.13*：
- en: '![Code Sample 4.3](img/B05118_04_13.jpg)'
  id: totrans-79
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 4.3](img/B05118_04_13.jpg)'
- en: 'Figure 4.13: Configuring TurretTransform for spawning ammo'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13：配置 TurretTransform 以生成弹药
- en: Now you're ready to play test and fire ammo. By playing the scene and pressing
    fire on the keyboard or mouse (left-click), ammo will be generated. Excellent!
    However, on testing this, you may notice two main problems. First, the ammo appears
    too big or too small. Second, the ammo sometimes bounces, flips, or reacts to
    the player spaceship. Let's fix these in turn.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你可以进行游戏测试并发射弹药。通过播放场景并按键盘或鼠标（左键）的射击按钮，将生成弹药。太棒了！然而，在测试时，你可能注意到两个主要问题。首先，弹药看起来太大或太小。其次，弹药有时会弹跳、翻转或对玩家的宇宙飞船做出反应。让我们依次修复这些问题。
- en: 'If the ammo appears wrongly-sized, you can simply change the scale of the prefab.
    Select the `Ammo` prefab in the **Project** panel, and from the **Object Inspector**,
    enter a new scale in the **Transform** component. See *Figure 4.14*:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 如果弹药看起来大小不正确，您可以简单地更改预制体的缩放比例。在**项目**面板中选择`Ammo`预制体，然后从**对象检查器**中在**变换**组件中输入新的缩放比例。参见*图
    4.14*：
- en: '![Code Sample 4.3](img/B05118_04_14.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 4.3](img/B05118_04_14.jpg)'
- en: 'Figure 4.14: Changing the Ammo prefab scale'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14：更改弹药预制体的缩放比例
- en: 'If the ammo appears to bounce or react to the player spaceship, then we''ll
    need to make the ammo immune or unresponsive to the player. To achieve this, we
    can use physics layers. In short, both the player spaceship and ammo should be
    added to a single layer, and all objects on this layer should be defined as immune
    to each other in terms of physical reactions. First, select the `Player` object
    in the scene. Then, from the **Object Inspector**, click on the **Layer** drop-down,
    and choose **Add Layer** from the context menu. See *Figure 4.15*:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果弹药看起来会弹跳或对玩家飞船做出反应，那么我们需要使弹药对玩家免疫或不敏感。为了实现这一点，我们可以使用物理层。简而言之，玩家飞船和弹药应该被添加到单个层中，并且该层上的所有对象在物理反应方面都应定义为相互免疫。首先，在场景中选择`Player`对象。然后，从**对象检查器**中点击**层**下拉菜单，并在上下文菜单中选择**添加层**。参见*图
    4.15*：
- en: '![Code Sample 4.3](img/B05118_04_15.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 4.3](img/B05118_04_15.jpg)'
- en: 'Figure 4.15: Creating a new layer for Physics exclusions'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.15：为物理排除创建新层
- en: 'Name the layer `Player`. This is to indicate that all objects attached to the
    layer are associated with the `Player`. See *Figure 4.16*:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 将层命名为`Player`。这是为了表明所有附加到该层的对象都与`Player`相关联。参见*图 4.16*：
- en: '![Code Sample 4.3](img/B05118_04_16.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 4.3](img/B05118_04_16.jpg)'
- en: 'Figure 4.16: Creating layers'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.16：创建层
- en: Now, assign both the `Player` object in the scene and `Ammo` prefab in the **Project**
    panel to the newly created **Player** layer. Select each, and simply click on
    the **Layer** drop-down, selecting the **Player** option. See *Figure 4.17*. If
    prompted with a pop-up dialog, choose to change children also. This makes sure
    that all child objects are also associated with the same **Layer** as the parent.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将场景中的`Player`对象和**项目**面板中的`Ammo`预制体分配到新创建的**玩家**层。选择每个对象，然后简单地点击**层**下拉菜单，选择**玩家**选项。参见*图
    4.17*。如果出现弹出对话框，请选择更改子对象。这确保了所有子对象也与父对象的相同**层**相关联。
- en: '![Code Sample 4.3](img/B05118_04_17.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 4.3](img/B05118_04_17.jpg)'
- en: 'Figure 4.17: Assigning Player and Ammo to the Player layer'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.17：将玩家和弹药分配到玩家层
- en: 'Both **Player** and **Ammo** have now been assigned to the same layer. From
    here, we can make all objects in the same layer immune from each other insofar
    as **Physics** applies. To do this, navigate to **Edit** | **Project Settings**
    | **Physics** from the application menu. See *Figure 4.18*:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 现在**玩家**和**弹药**已经被分配到相同的层。从这里，我们可以使同一层上的所有对象在**物理**方面相互免疫。要做到这一点，从应用程序菜单导航到**编辑**
    | **项目设置** | **物理**。参见*图 4.18*：
- en: '![Code Sample 4.3](img/B05118_04_18.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 4.3](img/B05118_04_18.jpg)'
- en: 'Figure 4.18: Accessing Physics options'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.18：访问物理选项
- en: 'The global **Physics** settings appear in the **Object Inspector**. At the
    bottom of the **Inspector**, the **Layer** **Collision Matrix** displays how layers
    affect each other. Intersecting layers with a check mark can and will affect each
    other. For this reason, remove the check mark for the **Player** layer to prevent
    collisions occurring between objects on this layer. See *Figure 4.19*:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 全局**物理**设置显示在**对象检查器**中。在**检查器**底部，**层** **碰撞矩阵**显示层如何相互影响。带有勾选标记的交叉层可以并且将相互影响。因此，取消**玩家**层的勾选标记以防止该层上的对象之间发生碰撞。参见*图
    4.19*：
- en: '![Code Sample 4.3](img/B05118_04_19.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 4.3](img/B05118_04_19.jpg)'
- en: 'Figure 4.19: Setting the Layer Collision Matrix for improved collisions'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.19：设置层碰撞矩阵以改善碰撞
- en: 'With the **Layer Collision Matrix** set from the **Object Inspector**, test
    run the game so far by pressing play on the toolbar. When you do this and press
    fire, ammo will issue from the turrets and no longer react to the player spaceship.
    The ammo should, however, collide with, and destroy, the enemies. See *Figure
    4.20*:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 通过从**对象检查器**设置**层碰撞矩阵**，按工具栏上的播放按钮测试运行到目前为止的游戏。当你这样做并按射击键时，弹药将从炮塔中发射出来，并且不再对玩家飞船做出反应。然而，弹药应该会与敌人碰撞并摧毁它们。参见*图
    4.20*：
- en: '![Code Sample 4.3](img/B05118_04_20.jpg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 4.3](img/B05118_04_20.jpg)'
- en: 'Figure 4.20: Destroying enemies by shooting guns!'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.20：通过射击枪支摧毁敌人！
- en: Excellent work! We now have a spaceship that can fire weapons and destroy enemies,
    and the physics works as expected. Maybe you'd like to customize player controls
    a little or perhaps you want to use a gamepad. The next section will explore this
    issue further.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的工作！我们现在有一个可以发射武器并摧毁敌人的宇宙飞船，物理效果也如预期。也许您想稍微自定义玩家控制，或者可能想使用游戏手柄。下一节将进一步探讨这个问题。
- en: User controls
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户控制
- en: 'Maybe you don''t like the default controls and key combinations associated
    with the input axes—**Horizontal**, **Vertical**, and **Fire1**. Maybe you want
    to change them. These input axes are read using the `Input.GetAxis` function (shown
    earlier) and are specified by human readable names, but it''s not immediately
    clear how Unity maps specific input buttons and devices to these virtual axes.
    Here, we''ll see briefly how to customize these. To get started, let''s access
    the **Input** settings by navigating to **Edit** | **Project Settings** | **Input**
    from the application menu. See *Figure 4.21*:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 也许您不喜欢默认的控件和与输入轴关联的默认按键组合——**水平**、**垂直**和**Fire1**。也许您想更改它们。这些输入轴是通过`Input.GetAxis`函数（之前已展示）读取的，并且由可读名称指定，但并不立即清楚Unity如何将特定的输入按钮和设备映射到这些虚拟轴。在这里，我们将简要介绍如何自定义这些设置。要开始，让我们通过从应用程序菜单导航到**编辑**
    | **项目设置** | **输入**来访问**输入**设置。请参阅*图4.21*：
- en: '![User controls](img/B05118_04_21.jpg)'
  id: totrans-106
  prefs: []
  type: TYPE_IMG
  zh: '![用户控制](img/B05118_04_21.jpg)'
- en: 'Figure 4.21: Accessing the Input menu'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.21：访问输入菜单
- en: On selecting this option, a collection of custom-defined input axes appear as
    a list in the **Object Inspector**. See *Figure 4.22*. This defines all axes used
    by the input system. The **Horizontal** and **Vertical** axes should be listed
    here.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 选择此选项后，一系列自定义定义的输入轴将作为列表出现在**对象检查器**中。请参阅*图4.22*。这定义了输入系统使用的所有轴。**水平**和**垂直**轴应列在这里。
- en: '![User controls](img/B05118_04_22.jpg)'
  id: totrans-109
  prefs: []
  type: TYPE_IMG
  zh: '![用户控制](img/B05118_04_22.jpg)'
- en: 'Figure 4.22: Exploring the input axes'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.22：探索输入轴
- en: 'By expanding each axis in the **Object Inspector**, you can easily customize
    how user input is mapped, that is, how specific keys and controls on hardware
    devices, such as a keyboard and mouse, will map to an axis. The **Horizontal**
    axis, for example, is defined twice. For the first definition, **Horizontal**
    is mapped to the `left`, `right`, and *A* and *D* keys on the keyboard. Right
    and *D* are mapped as **Positive Button** because, when pressed, they produce
    positive floating-point values from the `Input.GetAxis` function (0-1). Left and
    *A* are mapped as **Negative Button** because, when pressed, they result in negative
    floating-points values for `Input.GetAxis`. This makes it easy to move objects
    left and right using negative and positive numbers. See *Figure 4.23*:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 通过在**对象检查器**中展开每个轴，您可以轻松地自定义用户输入的映射方式，即特定的键和硬件设备上的控件（如键盘和鼠标）如何映射到轴。例如，**水平**轴被定义了两次。对于第一个定义，**水平**被映射到键盘上的`左`、`右`和*A*和*D*键。右和*D*被映射为**正按钮**，因为当按下时，它们从`Input.GetAxis`函数产生正的浮点值（0-1）。左和*A*被映射为**负按钮**，因为当按下时，它们对`Input.GetAxis`产生负的浮点值。这使得使用负数和正数轻松地左右移动对象变得容易。请参阅*图4.23*：
- en: '![User controls](img/B05118_04_23.jpg)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![用户控制](img/B05118_04_23.jpg)'
- en: 'Figure 4.23: Configuring an Input axis'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.23：配置输入轴
- en: 'Notice that **Horizontal** is defined twice in the **Object Inspector**—once
    near the top of the list and once near the bottom. These two definitions are accumulative
    and not contradictory—they stack atop one another. They allow you to map multiple
    devices to the same axis, giving you cross-platform and multidevice control over
    your games. By default, **Horizontal** is mapped in the first definition to the
    `left`, `right`, *A*, and *D* keys on the keyboard, and in the second definition,
    to joystick motion. Both definitions are valid and work together. You can have
    as many definitions for the same axis as you need, depending on the controls you
    need to support. See *Figure 4.24*:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在**对象检查器**中**水平**被定义了两次——一次在列表顶部附近，一次在底部附近。这两个定义是累积的，而不是矛盾的——它们堆叠在一起。这允许您将多个设备映射到同一个轴，从而让您能够跨平台和多设备控制您的游戏。默认情况下，**水平**在第一个定义中被映射到键盘上的`左`、`右`、*A*和*D*键，在第二个定义中，被映射到操纵杆运动。这两个定义都是有效的，并且可以一起工作。您可以为同一个轴定义尽可能多的定义，具体取决于您需要支持的控件。请参阅*图4.24*：
- en: '![User controls](img/B05118_04_24.jpg)'
  id: totrans-115
  prefs: []
  type: TYPE_IMG
  zh: '![用户控制](img/B05118_04_24.jpg)'
- en: 'Figure 4.24: Defining two horizontal axes'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.24：定义两个水平轴
- en: For this project, the controls will remain at their defaults, but go ahead and
    change or add additional controls if you want to support different configurations.
    More information on player input and customizing controls can be found in the
    online Unity documentation at [http://docs.unity3d.com/Manual/class-InputManager.html](http://docs.unity3d.com/Manual/class-InputManager.html).
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个项目，控制将保持默认设置，但如果您想支持不同的配置，请继续更改或添加额外的控制。有关玩家输入和自定义控制的更多信息，请参阅在线Unity文档中的[http://docs.unity3d.com/Manual/class-InputManager.html](http://docs.unity3d.com/Manual/class-InputManager.html)。
- en: Scores and scoring – UI and text objects
  id: totrans-118
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 得分和计分 – UI和文本对象
- en: Let's move on to the scoring system and, in creating this, we'll create `GameController`.
    `GameController` is simply a script or class that manages all game-wide and overarching
    behavior. This includes the score because, for this game, the score refers to
    one single and global number representing the achievements and progress of the
    player. Before jumping into the implementation, start by creating a simple GUI
    to display the game score. GUI is an acronym for Graphic User Interface, and this
    refers to all the 2D graphical elements that sit atop the game window and provide
    information to the player. To create this, create a new GUI canvas object by selecting
    **GameObject** | **UI** | **Canvas** from the application menu. See *Figure 4.25*.
    More details on GUIs can be found in the next two chapters.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续讨论计分系统，在创建这个系统时，我们将创建`GameController`。`GameController`只是一个管理整个游戏和全局行为的脚本或类。这包括得分，因为在这个游戏中，得分指的是代表玩家成就和进度的单个和全局数字。在开始实现之前，首先创建一个简单的GUI来显示游戏得分。GUI是图形用户界面的缩写，这指的是位于游戏窗口上方并提供给玩家的所有2D图形元素。为此，从应用程序菜单中选择**GameObject**
    | **UI** | **Canvas**来创建一个新的GUI画布对象。参见*图4.25*。有关GUI的更多详细信息，请参阅下一章。
- en: '![Scores and scoring – UI and text objects](img/B05118_04_25.jpg)'
  id: totrans-120
  prefs: []
  type: TYPE_IMG
  zh: '![得分和计分 – UI和文本对象](img/B05118_04_25.jpg)'
- en: 'Figure 4.25: Adding a Canvas object to the scene'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.25：将Canvas对象添加到场景中
- en: 'The `Canvas` object defines the total surface or area in which the GUI lives,
    including all buttons, text, and other widgets. On being generated in the scene,
    `Canvas` also features in the **Hierarchy** panel. Initially, the `Canvas` object
    may be too large or too small to be seen clearly in the viewport, so select the
    `Canvas` object in the **Hierarchy** panel and press the *F* key on the keyboard
    to focus the object. It should appear as a large vertically-aligned rectangle.
    See *Figure 4.26*:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: '`Canvas`对象定义了GUI存在的总面积或区域，包括所有按钮、文本和其他小部件。在场景中生成后，`Canvas`也出现在**层次结构**面板中。最初，`Canvas`对象可能太大或太小，在视图中看不清楚，因此请在**层次结构**面板中选择`Canvas`对象，然后在键盘上按*F*键以聚焦对象。它应该显示为一个大的垂直对齐矩形。参见*图4.26*：'
- en: '![Scores and scoring – UI and text objects](img/B05118_04_26.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![得分和计分 – UI和文本对象](img/B05118_04_26.jpg)'
- en: 'Figure 4.26: Examining the Canvas object in the viewport'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.26：在视图中检查Canvas对象
- en: 'The `Canvas` object is not visible itself in the **Game** tab. Rather, it acts
    simply as a container. Even so, it strongly influences how contained objects appear
    on the screen in terms of size, position, and scale. For this reason, before adding
    objects and refining the design of an interface, it''s helpful to configure your
    `Canvas` object first. To do this, select the `Canvas` object in the scene, and
    from the **Object Inspector**, click on the **UI Scale Mode** drop-down option
    from the **Canvas Scaler** component. From the drop-down list, choose the **Scale
    With Screen Size** option and enter an HD resolution in the **Reference Resolution**
    field, that is, specify `1920` for the **X** field and `1080` for the **Y** field.
    See *Figure 4.27*:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在**游戏**选项卡中，`Canvas`对象本身是不可见的。它仅仅作为一个容器。即便如此，它对包含的对象在屏幕上的大小、位置和缩放方式有强烈的影响。因此，在添加对象和细化界面设计之前，首先配置您的`Canvas`对象是有帮助的。为此，在场景中选择`Canvas`对象，然后从**对象检查器**中，点击**Canvas
    Scaler**组件中的**UI缩放模式**下拉选项。从下拉列表中，选择**随屏幕大小缩放**选项，并在**参考分辨率**字段中输入高清分辨率，即对于**X**字段指定`1920`，对于**Y**字段指定`1080`。参见*图4.27*：
- en: '![Scores and scoring – UI and text objects](img/B05118_04_27.jpg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![得分和计分 – UI和文本对象](img/B05118_04_27.jpg)'
- en: 'Figure 4.27: Adjusting the Canvas Scaler component'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.27：调整Canvas Scaler组件
- en: 'By adjusting the **Canvas Scaler** to **Scale With Screen Size**, the user
    interface for the game will automatically stretch and shrink (up- and down-scale)
    to fit the target resolution, ensuring that each element is scaled to the same
    proportions, maintaining the overall look and feel. This is a quick and easy method
    to create a UI once and have it adjust size to fit nearly any resolution. It may
    not always be the best solution to maintaining the highest quality graphical fidelity,
    but it''s functional and suitable in many cases. In any case, before proceeding
    with the UI design, it''s helpful to see both the **Scene** viewport and **Game**
    tab side by side in the interface (or across two monitors, if you have a multi-monitor
    configuration). This allows us to build the interface in the **Scene** viewport,
    and then preview its effects in the **Game** tab. You can rearrange the **Scene**
    and **Game** tabs simply by dragging and dropping the **Game** tab beside the
    **Scene** tab in the **Unity Editor**. See *Figure 4.28*:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 通过将**画布缩放器**调整为**与屏幕大小缩放**，游戏的用户界面将自动拉伸和收缩（向上和向下缩放），以适应目标分辨率，确保每个元素按相同比例缩放，保持整体外观和感觉。这是一个快速简单的方法，一次创建
    UI，然后调整大小以适应几乎任何分辨率。这可能不是始终是保持最高质量图形保真度的最佳解决方案，但它功能性强，在许多情况下都适用。在任何情况下，在进行 UI
    设计之前，在界面中（或如果你有多个显示器配置，则跨两个显示器）并排查看**场景**视口和**游戏**标签都是很有帮助的。这允许我们在**场景**视口中构建界面，然后在**游戏**标签中预览其效果。你可以通过在**Unity
    编辑器**中将**游戏**标签拖放到**场景**标签旁边来重新排列**场景**和**游戏**标签。参见*图 4.28*：
- en: '![Scores and scoring – UI and text objects](img/B05118_04_28.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![得分和计分 – UI 和文本对象](img/B05118_04_28.jpg)'
- en: 'Figure 4.28: Docking the Scene and Game tabs side by side'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.28：将场景和游戏标签并排停靠
- en: Next, let's add the text widget to the GUI to display the game score. To do
    this, select the `Canvas` object in the **Hierarchy** panel, and then right-click
    on that object (in the **Hierarchy** panel) to display a context menu. From here,
    select **UI** | **Text**. This creates a new text object as a child of the `Canvas`
    object as opposed to a top-level object with no parent. See *Figure 4.29*. The
    `Text` object is useful to draw text onscreen with a specific color, size, and
    font setting.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，让我们将文本小部件添加到 GUI 中以显示游戏得分。为此，在**层次结构**面板中选择`画布`对象，然后在该对象上（在**层次结构**面板中）右键单击以显示上下文菜单。从这里，选择**UI**
    | **文本**。这将在`画布`对象下创建一个新的文本对象，而不是一个没有父对象的顶层对象。参见*图 4.29*。`文本`对象用于在屏幕上绘制具有特定颜色、大小和字体设置的文本。
- en: '![Scores and scoring – UI and text objects](img/B05118_04_29.jpg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![得分和计分 – UI 和文本对象](img/B05118_04_29.jpg)'
- en: 'Figure 4.29: Creating a text object for the UI'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.29：为 UI 创建文本对象
- en: By default, the `Text` object may not initially appear visible in either the
    scene or viewport, even though it's listed as an object in the **Hierarchy** panel.
    However, look more closely in the **Scene** and you're likely to see very small
    and dark text, which appears both in the **Canvas** and **Game** tab. See *Figure
    4.30*. By default, new text objects feature black text at a small font size. For
    this project, these settings will need to be changed.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`文本`对象可能最初在场景或视图中不可见，尽管它在**层次结构**面板中被列为一个对象。然而，仔细观察**场景**，你可能会看到非常小且暗淡的文本，这些文本出现在**画布**和**游戏**标签中。参见*图
    4.30*。默认情况下，新文本对象具有黑色文本和较小的字体大小。对于这个项目，这些设置需要更改。
- en: '![Scores and scoring – UI and text objects](img/B05118_04_30.jpg)'
  id: totrans-135
  prefs: []
  type: TYPE_IMG
  zh: '![得分和计分 – UI 和文本对象](img/B05118_04_30.jpg)'
- en: 'Figure 4.30: Newly created text objects can sometimes be difficult to see'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.30：新创建的文本对象有时难以看到
- en: 'Select the `Text` object in the **Hierarchy** panel, if it''s not already selected,
    and from the **Object Inspector** (in the **Text** component), change the text
    **Color** to white and **Font Size** to `20`. See *Figure 4.31*:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 如果尚未选择，请在**层次结构**面板中选择`文本`对象，然后从**对象检查器**（在**文本**组件中），将文本**颜色**更改为白色，并将**字体大小**更改为`20`。参见*图
    4.31*：
- en: '![Scores and scoring – UI and text objects](img/B05118_04_31.jpg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![得分和计分 – UI 和文本对象](img/B05118_04_31.jpg)'
- en: 'Figure 4.31: Changing text size and color'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.31：更改文本大小和颜色
- en: 'The text, however, still appears too small even after changing its size. If
    you increase the size further, however, the text may disappear from view. This
    happens because each `Text` object has a rectangular boundary defining its limits,
    and when the font size increases beyond what can fit in the boundary, the text
    is automatically hidden altogether. To fix this, we''ll increase the text boundary.
    To do this, switch to the **Rect Transform** tool with *T* or select the tool
    from the toolbar. See *Figure 4.32*:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，即使更改了大小，文本仍然显得太小。但是，如果你进一步增加大小，文本可能会从视图中消失。这是因为每个`Text`对象都有一个定义其边界的矩形边界，当字体大小增加到超出边界能容纳的范围时，文本会自动完全隐藏。为了解决这个问题，我们将增加文本边界。为此，使用
    *T* 键切换到**矩形变换**工具或从工具栏中选择该工具。参见*图4.32*：
- en: '![Scores and scoring – UI and text objects](img/B05118_04_32.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![得分和评分 – UI 和文本对象](img/B05118_04_32.jpg)'
- en: 'Figure 4.32: Selecting the Rect Transform tool'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.32：选择矩形变换工具
- en: On activating the **Rect Transform** tool, a clearly defined boundary will be
    drawn around the selected `Text` object in the **Scene** viewport, indicating
    its rectangular extents. Let's increase the boundary size to accommodate larger
    text. To do this, simply click and drag on the boundary edges with the mouse to
    extend them as needed. See *Figure 4.33*. This will increase the boundary size
    and now you can increase **Font Size** to improve text readability.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 激活**矩形变换**工具后，将在**场景**视图中围绕选定的`Text`对象绘制一个清晰定义的边界，指示其矩形范围。让我们增加边界大小以适应更大的文本。为此，只需用鼠标点击并拖动边界边缘，按需扩展它们。参见*图4.33*。这将增加边界大小，现在你可以增加**字体大小**以提高文本可读性。
- en: '![Scores and scoring – UI and text objects](img/B05118_04_33.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_IMG
  zh: '![得分和评分 – UI 和文本对象](img/B05118_04_33.jpg)'
- en: 'Figure 4.33: Adjust the text rectangle to support larger font sizes'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.33：调整文本矩形以支持更大的字体大小
- en: 'In addition to setting the text boundary size, the text can also be vertically
    aligned to the boundary center. Simply click on the center alignment button for
    the vertical group. For horizontal alignment, the text should remain left-aligned
    to allow for the score display. See *Figure 4.34*:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 除了设置文本边界大小外，文本还可以垂直对齐到边界中心。只需单击垂直组的中心对齐按钮。对于水平对齐，文本应保持左对齐，以便显示得分。参见*图4.34*：
- en: '![Scores and scoring – UI and text objects](img/B05118_04_34.jpg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![得分和评分 – UI 和文本对象](img/B05118_04_34.jpg)'
- en: 'Figure 4.34: Aligning text within the boundary'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.34：在边界内对齐文本
- en: 'Although the text is now aligned vertically within its containing boundary,
    we''ll still need to align it as a whole to the canvas container to ensure that
    it remains on screen at the same position and orientation, even if the **Game**
    window is resized and realigned. To do this, we''ll use **Anchors**. To start,
    use the transform tool (*W*) to reposition the `Text` object to the top right
    corner of the screen at the location where the **Score** should appear. The object
    will automatically move within a 2D plane as opposed to 3D space. As you move
    the `Text` object in the **Scene** viewport, check its appearance in the **Game**
    tab to ensure that it looks correct and appropriate. See *Figure 4.35*:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然文本现在在其包含边界内垂直对齐，但我们仍需要将其整体对齐到画布容器，以确保即使在**游戏**窗口调整大小和重新对齐时，它也保持在屏幕上的相同位置和方向。为此，我们将使用**锚点**。首先，使用变换工具(*W*)将`Text`对象重新定位到屏幕右上角，即**得分**应该出现的位置。对象将自动在二维平面上移动，而不是在三维空间中。当你将`Text`对象在**场景**视图中移动时，检查**游戏**标签中的外观，以确保它看起来正确且合适。参见*图4.35*：
- en: '![Scores and scoring – UI and text objects](img/B05118_04_35.jpg)'
  id: totrans-150
  prefs: []
  type: TYPE_IMG
  zh: '![得分和评分 – UI 和文本对象](img/B05118_04_35.jpg)'
- en: 'Figure 4.35: Positioning the Score text within the Game tab'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.35：在游戏标签中定位得分文本
- en: 'To secure the position of the `Text` object on screen (preventing it from sliding
    or moving), even if the **Game** tab is resized by the user, we can set the object''s
    anchor position to the top right corner of the screen. This ensures that the text
    is always positioned as a constant, proportional offset from its anchor. To do
    this, click on the **Anchor Presets** button in the **Rect Transform** component
    in the **Object Inspector**. When you do this, a preset menu appears from which
    you can choose a range of alignment locations. Each preset is graphically presented
    as a small diagram, including a red dot at the location of anchor alignment. Select
    the top right preset. See *Figure 4.36*:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 为了确保 `Text` 对象在屏幕上的位置（防止它滑动或移动），即使用户调整了 **Game** 选项卡的大小，我们也可以将对象的锚点位置设置为屏幕的右上角。这确保了文本始终以恒定的、成比例的偏移量从其锚点定位。为此，在
    **Object Inspector** 中的 **Rect Transform** 组件上的 **Anchor Presets** 按钮上单击。当你这样做时，一个预设菜单会出现，你可以从中选择一系列对齐位置。每个预设都通过一个小图表示图形化展示，包括一个位于锚点对齐位置的红点。选择右上角的预设。参见
    *图 4.36*：
- en: '![Scores and scoring – UI and text objects](img/B05118_04_36.jpg)'
  id: totrans-153
  prefs: []
  type: TYPE_IMG
  zh: '![得分和计分 - UI 和文本对象](img/B05118_04_36.jpg)'
- en: 'Figure 4.36: Aligning the Text object to the screen'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.36：将文本对象对齐到屏幕
- en: Excellent work! The `Text` object is now created and ready to use. Of course,
    in play mode, the text remains unchanged and doesn't display a real score. That's
    because we need to add some code. However, overall, the `Text` object is in place
    and we can move on.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 优秀的作品！现在 `Text` 对象已经创建并准备好使用。当然，在播放模式下，文本保持不变，不会显示真实的得分。这是因为我们需要添加一些代码。然而，总的来说，`Text`
    对象已经到位，我们可以继续前进。
- en: Working with scores – scripting with text
  id: totrans-156
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 与得分一起工作 - 使用文本脚本
- en: To display a score in the GUI, we'll first need score functionality, that is,
    code to create a score system. Essentially, the score functionality will be added
    to a general, overarching `GameController` class, responsible for all game-wide
    logic and features. The code for `GameController` and its score feature set is
    included in *Code Sample 4.4*, as follows. This file should be added to the `Scripts`
    folder of the project.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 要在 GUI 中显示得分，我们首先需要得分功能，即创建得分系统的代码。本质上，得分功能将被添加到一个通用的、全面的 `GameController` 类中，该类负责所有游戏逻辑和功能。`GameController`
    及其得分功能集的代码包含在 *代码示例 4.4* 中，如下所示。此文件应添加到项目的 `Scripts` 文件夹中。
- en: '[PRE3]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Code Sample 4.4
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 代码示例 4.4
- en: 'The following points summarize the code sample:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 以下要点总结了代码示例：
- en: The `GameController` class uses the `UnityEngine.ui` namespace. This is important
    because it includes access to all the UI classes and objects in Unity. If you
    don't include this namespace in your source files, then you cannot use UI objects
    from that script.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameController` 类使用 `UnityEngine.ui` 命名空间。这很重要，因为它包括了访问 Unity 中所有 UI 类和对象的方法。如果你没有在你的源文件中包含这个命名空间，那么你将无法从该脚本中使用
    UI 对象。'
- en: The `GameController` class features two text public members, namely, `ScoreText`
    and `GameOverText`. These refer to two text objects, both of which are optional
    insofar as the `GameController` code will work just fine, even if the members
    are null. `ScoreText` is a reference to a text GUI object to display score text,
    and `GameOverText` is to display any message when a game-over condition occurs.
  id: totrans-162
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`GameController` 类有两个公共文本成员，即 `ScoreText` 和 `GameOverText`。这些成员在 `GameController`
    代码中是可选的，因为即使成员为空，代码也能正常工作。`ScoreText` 是一个指向用于显示得分文本的文本 GUI 对象的引用，而 `GameOverText`
    用于在游戏结束条件发生时显示任何消息。'
- en: To use the `GameController` code, create a new, empty object in the scene named
    `GameController`. Then, drag and drop the `GameController` script file to that
    object. Once added, drag and drop the `ScoreText` object to the **Score Text**
    field for `GameController` in the **Object Inspector**. See *Figure 4.37*. In
    the **Score Prefix** field, enter the text that should prefix the `Score` itself.
    The score, on its own, is simply a number (such as 1,000). The prefix allows you
    to add text to the front of this score, indicating to the player what the numbers
    mean.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用 `GameController` 代码，在场景中创建一个新的空对象，命名为 `GameController`。然后，将 `GameController`
    脚本文件拖放到该对象上。一旦添加，将 `ScoreText` 对象拖放到 **Object Inspector** 中的 `GameController`
    的 **Score Text** 字段。参见 *图 4.37*。在 **Score Prefix** 字段中，输入应加在 `Score` 前面的文本。得分本身只是一个数字（如
    1,000）。前缀允许你在得分前面添加文本，向玩家说明这些数字的含义。
- en: '![Code Sample 4.4](img/B05118_04_37.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例 4.4](img/B05118_04_37.jpg)'
- en: 'Figure 4.37: Creating a GameController to maintain the game score'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.37：创建一个用于维护游戏得分的 GameController
- en: 'Now, take the game for a test run and you''ll see the score display at the
    top right corner of the `Game` tab using the GUI text object. This is fine, but
    the score always remains at `0` right now. This is because we have no code, yet,
    to increase the score. For our game, the score should increase when an `Enemy`
    object is destroyed. To achieve this, we''ll create a new script file, `ScoreOnDestroy`.
    This is included in *Code Sample 4.5*, as follows:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，进行游戏测试运行，你会在**游戏**标签页的右上角看到使用GUI文本对象显示的分数。这是可以的，但现在分数总是保持在`0`。这是因为我们还没有编写增加分数的代码。对于我们的游戏，当`敌人`对象被销毁时，分数应该增加。为了实现这一点，我们将创建一个新的脚本文件，`ScoreOnDestroy`。这包含在*代码示例4.5*中，如下所示：
- en: '[PRE4]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The script should be attached to any object that assigns you points when it''s
    destroyed, such as the enemies. The total number of points assigned is specified
    by `ScoreValue`. To attach the script to the enemy prefab, select the `Prefabs`
    in the **Project** panel, and from the **Object Inspector**, click on the **Add
    Component** button. Then type `ScoreOnDestroy` in the search field to add the
    component to the prefab. Once added, specify the total number of points to be
    allocated for destroying an enemy. For this game, a value of 50 points is assigned.
    See *Figure 4.38*:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 脚本应该附加到任何在销毁时为你分配分数的对象上，例如敌人。分配的分数总数由`ScoreValue`指定。要将脚本附加到敌人预制体上，在**项目**面板中选择`预制体`，然后在**对象检查器**中点击**添加组件**按钮。然后在搜索字段中输入`ScoreOnDestroy`以将组件添加到预制体。一旦添加，指定销毁敌人时要分配的总分数。对于这个游戏，分配了50分的值。见*图4.38*：
- en: '![Code Sample 4.4](img/B05118_04_38.jpg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![代码示例4.4](img/B05118_04_38.jpg)'
- en: 'Figure 4.38: Adding a Score component to the Enemy prefab'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.38：向敌人预制体添加分数组件
- en: Great work! You now have destroyable enemies that assign you points on destruction.
    This means that you can finally have an in-game score and could even extend gameplay
    to include high-score features and leaderboards. This also means that our game
    is almost finished and ready to build. Next, we'll add some final touches.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 干得好！你现在有了可破坏的敌人，它们在销毁时为你分配分数。这意味着你终于可以拥有游戏中的分数，甚至可以扩展游戏以包括高分功能和排行榜。这也意味着我们的游戏几乎完成，准备构建。接下来，我们将添加一些最后的修饰。
- en: Polishing
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 磨光
- en: 'In this section, we''ll add the final touches to the game. First on the agenda
    is to fix the game background! Until now, the background has simply displayed
    the default background color associated with the game camera. However, as the
    game is set in space, we should display a space background. To do this, create
    a new **Quad** object in the **Scene** that''ll display a space image. Navigate
    to **GameObject** | **3D Object** | **Quad** from the menu. Then rotate the object
    and move it downward so that it displays a flat, vertically-aligned backdrop.
    You may need to scale the object to look correct. See *Figure 4.39*:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将为游戏添加最后的修饰。首先，我们要解决游戏背景的问题！到目前为止，背景只是简单地显示了与游戏摄像机关联的默认背景颜色。然而，由于游戏设定在太空中，我们应该显示太空背景。为此，在**场景**中创建一个新的**四边形**对象，该对象将显示太空图像。从菜单中选择**游戏对象**
    | **3D对象** | **四边形**。然后旋转对象并向下移动，使其显示一个平坦的、垂直对齐的背景。你可能需要调整对象的大小以使其看起来正确。见*图4.39*：
- en: '![Polishing](img/B05118_04_39.jpg)'
  id: totrans-174
  prefs: []
  type: TYPE_IMG
  zh: '![磨光](img/B05118_04_39.jpg)'
- en: 'Figure 4.39: Creating a backdrop for the level and building a Quad'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.39：为关卡创建背景并构建四边形
- en: 'Now, drag and drop the space texture from the **Project** panel to **Quad**
    in the **Scene** to apply it as a material. Once assigned, select the **Quad**
    and change the **Tiling** settings from the material properties in the **Object
    Inspector**. Increase the **X** and **Y** tiling to `3`. See *Figure 4.40*:'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，将**项目**面板中的太空纹理拖放到**场景**中的**四边形**上，将其作为材质应用。一旦分配，选择**四边形**，并在**对象检查器**中的材质属性中更改**平铺**设置。将**X**和**Y**平铺增加到`3`。见*图4.40*：
- en: '![Polishing](img/B05118_04_40.jpg)'
  id: totrans-177
  prefs: []
  type: TYPE_IMG
  zh: '![磨光](img/B05118_04_40.jpg)'
- en: 'Figure 4.40: Configuring the texture tiling'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.40：配置纹理平铺
- en: 'If texture tiling seems broken for you, then be sure to check the Texture Importing
    settings. To do this, select the texture in the **Project** panel, and from the
    **Object Inspector**, ensure that **Texture Type** is set to **Texture** and the
    **Wrap Mode** is set to **Repeat**. See *Figure 4.41*:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果纹理平铺看起来有问题，那么请务必检查纹理导入设置。为此，在**项目**面板中选择纹理，然后在**对象检查器**中，确保**纹理类型**设置为**纹理**，**包裹模式**设置为**重复**。见*图4.41*：
- en: '![Polishing](img/B05118_04_41.jpg)'
  id: totrans-180
  prefs: []
  type: TYPE_IMG
  zh: '![磨光](img/B05118_04_41.jpg)'
- en: 'Figure 4.41: Configuring a texture for seamless tiling'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.41：配置纹理以实现无缝平铺
- en: Now the level has a suitable background. Let's add some background music, which
    will play on a loop. To do this, first select the music track in the **Project**
    panel in the `Audio` folder. When selected, make sure that the music **Load Type**,
    from the **Object Inspector**, is set to **Streaming** and **Preload Audio Data**
    is disabled. See *Figure 4.42*. This improves loading times as Unity will not
    need to load all music data to memory as the scene begins.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在关卡有了合适的背景。让我们添加一些背景音乐，它将循环播放。为此，首先在`音频`文件夹中的**项目**面板中选择音乐轨道。选择后，确保从**对象检查器**中设置音乐的**加载类型**为**流式传输**，并且禁用**预加载音频数据**。参见*图4.42*。这提高了加载时间，因为Unity不需要在场景开始时将所有音乐数据加载到内存中。
- en: '![Polishing](img/B05118_04_42.jpg)'
  id: totrans-183
  prefs: []
  type: TYPE_IMG
  zh: '![抛光](img/B05118_04_42.jpg)'
- en: 'Figure 4.42: Configuring audio data ready for playback'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.42：配置音频数据以准备播放
- en: 'Next, create a new, empty **GameObject** in the scene named `Music`, and then
    drag and drop the `Music` track from the **Project** panel to the `Music` object,
    adding it as an **Audio Source** component. **Audio** **Source** components play
    sound effects and music. See *Figure 4.43*:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，在场景中创建一个新的、空的**GameObject**，命名为`Music`，然后将`Music`轨道从**项目**面板拖放到`Music`对象中，添加它作为**音频源**组件。**音频源**组件播放声音效果和音乐。参见*图4.43*：
- en: '![Polishing](img/B05118_04_43.jpg)'
  id: totrans-186
  prefs: []
  type: TYPE_IMG
  zh: '![抛光](img/B05118_04_43.jpg)'
- en: 'Figure 4.43: Creating a GameObject with an AudioSource component'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.43：创建具有音频源组件的GameObject
- en: 'From the **Audio Source** component in the **Object Inspector**, enable the
    **Play On Awake** and **Loop** checkboxes to ensure that the music is played from
    the level beginning and loops endlessly for as long as the game is running. The
    **Spatial Blend** field should be set to `0`, meaning 2D. In short, 2D sounds
    have a consistent volume throughout the level regardless of the player''s position.
    This is because 2D sounds are not spatially located. 3D sounds, in contrast, are
    used for gunshots, footsteps, explosions, and other sounds that exist in 3D space
    and whose volume should change based on how close the player is standing to them
    when they play. See *Figure 4.44*:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 从**对象检查器**中的**音频源**组件，启用**播放唤醒**和**循环**复选框，以确保音乐从关卡开始播放并且无限循环，直到游戏运行结束。**空间混合**字段应设置为`0`，表示2D。简而言之，2D声音在整个关卡中保持一致的音量，不受玩家位置的影响。这是因为2D声音没有空间定位。相比之下，3D声音用于枪声、脚步声、爆炸声和其他存在于3D空间中的声音，其音量应根据玩家在播放时距离它们的远近而变化。参见*图4.44*：
- en: '![Polishing](img/B05118_04_44.jpg)'
  id: totrans-189
  prefs: []
  type: TYPE_IMG
  zh: '![抛光](img/B05118_04_44.jpg)'
- en: 'Figure 4.44: Looping a music track'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.44：循环音乐轨道
- en: 'Now, let''s take the game for a test run! Click on the play button on the toolbar
    and test it out. If the music doesn''t play, check that the **Mute Audio** button
    is not enabled from the **Game** tab. See *Figure 4.45*:'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们对游戏进行测试运行！点击工具栏上的播放按钮并测试它。如果音乐没有播放，请检查**游戏**标签页上的**静音音频**按钮是否未启用。参见*图4.45*：
- en: '![Polishing](img/B05118_04_45.jpg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![抛光](img/B05118_04_45.jpg)'
- en: 'Figure 4.45: Playing a game – disabling Mute Audio, if necessary'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.45：玩游戏 – 如有必要，禁用静音音频
- en: Testing and diagnosis
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 测试和诊断
- en: 'With practically all games, you''ll need to spend considerable time testing
    and debugging heavily to reduce bugs and errors as much as humanly possible. With
    this sample program, very little debugging and testing has been required by you,
    but that''s not because the game is simple. It''s because I''ve already prechecked
    and pretested most of the code and functionality before presenting the material
    to you in this book, ensuring that you get a smooth learning experience. For your
    own projects, however, you''ll need to do lots of testing. One way to get started
    is using the **Stats** panel. To open this, click on the **Stats** button on the
    **Game** tab. See *Figure 4.46*:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 对于几乎所有游戏，你需要花费相当多的时间进行测试和调试，以尽可能减少错误和漏洞。使用这个示例程序，你需要进行的调试和测试非常少，但这并不是因为游戏很简单。这是因为我在将材料呈现给你之前，已经预先检查和测试了大部分代码和功能，确保你获得流畅的学习体验。然而，对于你自己的项目，你将需要进行大量的测试。一种开始的方式是使用**统计**面板。要打开它，点击**游戏**标签页上的**统计**按钮。参见*图4.46*：
- en: '![Testing and diagnosis](img/B05118_04_46.jpg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![测试和诊断](img/B05118_04_46.jpg)'
- en: 'Figure 4.46: Viewing game performance information via the Stats panel'
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.46：通过统计面板查看游戏性能信息
- en: More details on the **Stats** panel are included in [Chapter 2](ch02.html "Chapter 2. Project
    A – the Collection Game Continued"), *Project A – the Collection Game Continued*
    of this book, and more information can be found online in the Unity documentation
    at [http://docs.unity3d.com/Manual/RenderingStatistics.html](http://docs.unity3d.com/Manual/RenderingStatistics.html).
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**统计信息**面板的更多细节包含在本书的[第 2 章](ch02.html "第 2 章。项目 A – 收藏品游戏的继续")，*项目 A – 收藏品游戏的继续*中，更多信息可以在
    Unity 文档的[http://docs.unity3d.com/Manual/RenderingStatistics.html](http://docs.unity3d.com/Manual/RenderingStatistics.html)在线找到。
- en: 'Another debugging tool is the **Profiler**. This is useful when the **Stats**
    panel has already helped you identify a general problem, such as a low FPS, and
    you want to dig deeper to find where the problem might be located. More details
    on **Profiler** are included later in [Chapter 6](ch06.html "Chapter 6. Continuing
    the 2D Adventure"), *Continuing the 2D Adventure* but a short introduction is
    worth including here. To access the **Profiler** tool, select **Window** | **Profiler**
    from the application menu. This displays the **Profiler** window. See *Figure
    4.47*:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个调试工具是**分析器**。当**统计信息**面板已经帮助你识别了一个一般问题，例如低帧率，而你想要进一步挖掘以找到问题可能所在的位置时，这很有用。关于**分析器**的更多细节将在[第
    6 章](ch06.html "第 6 章。继续 2D 冒险")，*继续 2D 冒险*中介绍，但在这里简要介绍是值得的。要访问**分析器**工具，从应用程序菜单中选择**窗口**
    | **分析器**。这会显示**分析器**窗口。见*图 4.47*：
- en: '![Testing and diagnosis](img/B05118_04_47.jpg)'
  id: totrans-200
  prefs: []
  type: TYPE_IMG
  zh: '![测试和诊断](img/B05118_04_47.jpg)'
- en: 'Figure 4.47: Accessing the Profiler window'
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.47：访问分析器窗口
- en: With the **Profiler** window open, click on play on the toolbar to play test
    your game. When you do this, the **Profiler** window fills with color-coded performance
    data in a graph. See *Figure 4.48*. Green represents the performance of rendering
    (graphical) data. Reading and understanding the graph requires some experience,
    but as a general rule, watch out for mountains and peaks, that is, watch out for
    sharp fluctuations in the graph (sharp ups and downs) as this could indicate a
    problem, especially when it roughly coincides with frame rate drops.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 在打开**分析器**窗口的情况下，点击工具栏上的播放按钮来测试你的游戏。当你这样做时，**分析器**窗口会填充上色编码的性能数据图表。见*图 4.48*。绿色代表渲染（图形）数据的性能。阅读和理解图表需要一些经验，但一般来说，要注意图表中的山峰和顶峰，即注意图表中的急剧波动（急剧上升和下降），因为这可能表明存在问题，尤其是在帧率下降时。
- en: '![Testing and diagnosis](img/B05118_04_48.jpg)'
  id: totrans-203
  prefs: []
  type: TYPE_IMG
  zh: '![测试和诊断](img/B05118_04_48.jpg)'
- en: 'Figure 4.48: During gameplay, the Profiler populates with data'
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.48：在游戏过程中，分析器窗口会填充数据
- en: 'If you want to investigate further, simply pause the game, and then click in
    the graph. The horizontal axis (*X* axis) represents the most recent frames, and
    the vertical axis represents workload. When you click in the graph, a line marker
    is added to indicate the frame under investigation. Beneath the graph, a list
    of all main processes for that frame are presented, typically ordered from top
    to bottom by the heaviness of their workload and proportion of frame time for
    which the process accounted. Heavier processes are listed at the top. See *Figure
    4.49*:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想进一步调查，只需暂停游戏，然后在图表中点击。水平轴（*X* 轴）代表最近的帧，垂直轴代表工作量。当你点击图表时，会添加一个线标记来指示正在调查的帧。在图表下方，列出了该帧的所有主要进程，通常按工作量的轻重和占帧时间的比例从上到下排序。较重的进程列在顶部。见*图
    4.49*：
- en: '![Testing and diagnosis](img/B05118_04_49.jpg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![测试和诊断](img/B05118_04_49.jpg)'
- en: 'Figure 4.49: Investigating performance data with the Profiler'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.49：使用分析器调查性能数据
- en: Note
  id: totrans-208
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: More information on the **Profiler** can be found in the online Unity documentation
    at [http://docs.unity3d.com/Manual/Profiler.html](http://docs.unity3d.com/Manual/Profiler.html).
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 关于**分析器**的更多信息可以在 Unity 在线文档的[http://docs.unity3d.com/Manual/Profiler.html](http://docs.unity3d.com/Manual/Profiler.html)找到。
- en: Building
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建
- en: 'Now, finally, we''re ready to build our game to a standalone form ready to
    send off to friends, family, and testers! The process to do this is the same as
    detailed in [Chapter 2](ch02.html "Chapter 2. Project A – the Collection Game
    Continued"), *Project A – the Collection Game Continued*, to build the coin collection
    game. From the application menu, choose **File** | **Build Settings**. From the
    build dialog, add our level to the level list by simply clicking on the **Add
    Current** button. Otherwise, drag and drop the level from the **Project** panel
    to the level list. See *Figure 4.50*:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，最后，我们终于准备好将我们的游戏构建成独立的形式，准备发送给朋友、家人和测试人员！执行此操作的过程与[第2章](ch02.html "第2章。项目A
    – 收集游戏继续")中详细描述的相同，*项目A – 收集游戏继续*，以构建收集游戏。从应用程序菜单中选择**文件** | **构建设置**。从构建对话框中，通过简单地点击**添加当前**按钮将我们的关卡添加到关卡列表中。否则，从**项目**面板拖放关卡到关卡列表中。见*图4.50*：
- en: '![Building](img/B05118_04_50.jpg)'
  id: totrans-212
  prefs: []
  type: TYPE_IMG
  zh: '![Building](img/B05118_04_50.jpg)'
- en: 'Figure 4.50: Preparing to build the space shooter'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.50：准备构建太空射击游戏
- en: 'For this game, the target platform will be Windows. Consequently, select the
    **PC, Mac & Linux Standalone** option from the **Platform** list, if it''s not
    selected already. If the **Switch Platform** button (at the bottom left) is not
    disabled, then you will need to press this button, confirming to Unity that it
    should build for the selected platform as opposed to a different platform. Then,
    click on the **Build And Run** button. On clicking this, Unity prompts you to
    select a folder on your computer where the built file will be output and saved.
    Once generated, double-click the executable to run it and test. See *Figure 4.51*:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个游戏，目标平台将是Windows。因此，如果尚未选择，请从**平台**列表中选择**PC, Mac & Linux Standalone**选项。如果**切换平台**按钮（在左下角）未禁用，那么您需要按下此按钮，向Unity确认它应该为所选平台构建，而不是其他平台。然后，点击**构建并运行**按钮。点击此按钮后，Unity会提示您选择一个文件夹，构建文件将输出并保存到该文件夹中。一旦生成，双击可执行文件以运行并测试。见*图4.51*：
- en: '![Building](img/B05118_04_51.jpg)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![Building](img/B05118_04_51.jpg)'
- en: 'Figure 4.51: Test running the game as a standard Windows executable'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.51：以标准Windows可执行文件运行游戏的测试
- en: Summary
  id: totrans-217
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: Great work! We're really on a roll now, having completed two solid Unity projects.
    The first project was a coin collection game and the second was a twin-stick shooter.
    Both are, ultimately, simple games in that they don't rely on advanced mechanics
    or display sophisticated features. However, even very sophisticated games, when
    boiled down to their fundamental ingredients, can be found to rest on a similar
    foundation of essential concepts such as the ones that we've covered so far. That's
    why our projects are so critical to understanding Unity in a deep way. Next, we'll
    move on to creating a more 2D-focused game, considering interfaces, sprites, and
    physics, and lots more!
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 太棒了！我们现在真的在一条好路上，已经完成了两个坚实的Unity项目。第一个项目是一个收集游戏，第二个是一个双摇杆射击游戏。从本质上讲，这两个游戏都很简单，因为它们不依赖于高级机制或展示复杂的功能。然而，即使是非常复杂的游戏，当简化到其基本成分时，也可以发现它们建立在类似的基础概念之上，就像我们到目前为止所涵盖的那些。这就是为什么我们的项目对于深入理解Unity至关重要。接下来，我们将继续创建一个更注重2D的游戏，考虑界面、精灵和物理，以及更多内容！
