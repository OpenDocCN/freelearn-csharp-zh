<html><head></head><body>
		<div><h1 id="_idParaDest-318" class="chapter-number"><a id="_idTextAnchor317"/>13</h1>
			<h1 id="_idParaDest-319"><a id="_idTextAnchor318"/>Real-Time Messaging with SignalR</h1>
			<p>Now that we’ve created various tests, added telemetry data, monitored the solution, and scaled our services, starting with this chapter, we’ll continue creating services and using different communication technologies.</p>
			<p>In this chapter, we’ll use ASP.NET Core SignalR. SignalR is a technology that allows us to send real-time information from services to clients. The client initiates a connection to the service, which is then kept alive to send messages to the clients as information becomes available.</p>
			<p>In this chapter, you’ll learn how to do the following:</p>
			<ul>
				<li>Create a SignalR service</li>
				<li>Send real-time information to clients</li>
				<li>Create a SignalR client</li>
				<li>Use Azure SignalR Service</li>
			</ul>
			<h1 id="_idParaDest-320"><a id="_idTextAnchor319"/>Technical requirements</h1>
			<p>In this chapter, like the previous chapters, you’ll need an Azure subscription and Docker Desktop.</p>
			<p>The code for this chapter can be found in this book’s GitHub repository: <a href="https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/">https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure/</a>.</p>
			<p>The <code>ch13</code> folder contains this chapter’s projects, as well as their results. To add the functionality from this chapter, you can start with the source code from the previous chapter.</p>
			<p>The projects we’ll be considering are as follows:</p>
			<ul>
				<li><code>Codebreaker.AppHost</code>: The .NET Aspire host project. The app model has been enhanced by an additional project running a SignalR hub and using Azure SignalR Service.</li>
				<li><code>Codebreaker.Live</code>: This is a new project that hosts minimal APIs invoked by the <code>game-apis</code> service and the SignalR hub.</li>
				<li><code>Codebreaker.GameAPIs</code>: This project has been enhanced and can forward completed games to <code>live-service</code>.</li>
				<li><code>LiveTestClient</code>: This is a new console application that registers with the SignalR hub to receive completed games.</li>
			</ul>
			<h1 id="_idParaDest-321"><a id="_idTextAnchor320"/>Creating a SignalR service</h1>
			<p>In this chapter, we’ll create <a id="_idIndexMarker1034"/>a new service that offers real-time information to return games that are played to every connected client. <em class="italic">Figure 13</em><em class="italic">.1</em> shows how the services of the solution collaborate:</p>
			<div><div><img src="img/B21217_13_01.jpg" alt="Figure 13.1 – Codebreaker services"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.1 – Codebreaker services</p>
			<p>The <code>game-apis</code> service has existed since <a href="B21217_02.xhtml#_idTextAnchor031"><em class="italic">Chapter 2</em></a>. The client of <code>game-apis</code> invokes the REST API to start games and set moves. What’s new is Codebreaker’s <code>live-service</code>. This service offers a simple REST API that’s invoked by the <code>game-apis</code> service every time a game completes. The main functionality of this service makes use of ASP.NET Core SignalR to offer real-time information to all connected clients. Clients need to subscribe before they can receive game completion messages.</p>
			<p>What’s offered by <a id="_idIndexMarker1035"/>SignalR? As connections can never be started from a server to a client, and this is also true of SignalR, a client needs to connect to the SignalR service and subscribe to receive real-time information. The connection stays open, which allows the service to send information to the clients.</p>
			<p>ASP.NET Core SignalR makes <a id="_idIndexMarker1036"/>use of <strong class="bold">WebSockets</strong> if this technology is available – but the programming model with SignalR is a lot easier than using WebSockets directly. Contrary to HTTP, with WebSockets, the connection that’s initiated by the client stays open, which allows the service to send messages when these are available.</p>
			<p>WebSockets isn’t always<a id="_idIndexMarker1037"/> available and can be disabled by a proxy or a firewall and are not available everywhere. For example, <strong class="bold">Azure Front Door</strong> doesn’t support WebSockets at this time.</p>
			<p>If WebSockets isn’t<a id="_idIndexMarker1038"/> available, SignalR switches to other communication techniques, such as <code>text/event-stream</code> data and asks the server to keep the connection alive (via the <code>Connection: keep-alive</code> HTTP header). All modern browsers support SSE nowadays. With polling, the client repeatedly asks the server if new data is available, opening new connections again and again. Long polling is a technique that reduces the number of requests from the client by the server not returning information immediately, stating that nothing new is available. Instead, the server waits for the timeout to nearly end before returning. If some new information is available while waiting, this new information is returned.</p>
			<p>Using SignalR, there’s no need to change programming constructs to decide between WebSockets, SSE, and long polling. This is done automatically by SignalR. However, in all these scenarios, compared to simple HTTP requests, the server has more overhead: connections with the clients need to stay alive and thus be kept in memory. To remove this overhead from our services, we’ll use Azure SignalR Service later in this chapter.</p>
			<p>To create a SignalR service, we just need to create an empty ASP.NET Core Web project. Because this service also offers a REST API, let’s create a new Web API project:</p>
			<pre class="console">
dotnet new webapi --use-minimal-apis -o Codebreaker.Live</pre>
			<p>This creates a minimal API<a id="_idIndexMarker1040"/> project, similar to what we have for the <code>game-apis</code> project. This project needs to be configured as a .NET Aspire project. With Visual Studio, use <code>Codebreaker.Live</code> project. Then, add a project reference to the <code>ServiceDefaults</code> project to the live project.</p>
			<p>The <code>Codebreaker.Live</code> service project needs to be configured with the .NET Aspire app model:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
// else path using Azure services
<strong class="bold">var live = builder.AddProject&lt;Projects.Codebreaker_Live&gt;("live")</strong>
<strong class="bold">  .WithExternalHttpEndpoints()</strong>
<strong class="bold">  WithReference(appInsights)</strong>
<strong class="bold"> .WithEnvironment("StartupMode", startupMode);</strong>
<strong class="bold">var gameAPIs = builder.AddProject&lt;Projects.Codebreaker_GameAPIs&gt;("gameapis")</strong>
  .WithExternalHttpEndpoints()
  .WithReference(cosmos)
  .WithReference(redis)
  .WithReference(appInsights)
<strong class="bold">  .WithReference(live)</strong>
  .WithEnvironment("DataStore", dataStore)
  .WithEnvironment("StartupMode", startupMode);
  // code removed for brevity</pre>
			<p>By doing this, the project is added to the app model and referenced from the <code>game-apis</code> service as it needs the<a id="_idIndexMarker1041"/> link from <code>live-service</code> to invoke the REST API on game completions.</p>
			<p>Next, we’ll add a SignalR hub that can be used by clients to connect.</p>
			<h2 id="_idParaDest-322"><a id="_idTextAnchor321"/>Creating a SignalR hub</h2>
			<p>SignalR is already part <a id="_idIndexMarker1042"/>of ASP.NET Core, so we don’t need to add another NuGet package. Let’s add the SignalR hub class – that is, <code>LiveHub</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Endpoints/LiveHub.cs</p>
			<pre class="source-code">
public class <strong class="bold">LiveHub</strong>(ILogger&lt;LiveHub&gt; logger) : <strong class="bold">Hub</strong>
{
  public async Task <strong class="bold">SubscribeToGameCompletions</strong>(string gameType)
  {
    logger.ClientSubscribed(Context.ConnectionId, gameType);
    <strong class="bold">await Groups.AddToGroupAsync(Context.ConnectionId, gameType);</strong>
  }
  public async Task <strong class="bold">UnsubscribeFromGameCompletions</strong>(string gameType)
  {
    logger.ClientUnsubscribed(Context.ConnectionId, gameType);
<strong class="bold">    await Groups.RemoveFromGroupAsync(Context.ConnectionId, gameType);</strong>
  }
}</pre>
			<p>A SignalR hub derives from the <code>Hub</code> base class (the <code>Microsoft.AspNetCore.SignalR</code> namespace). This class defines the <code>OnConnectedAsync</code> and <code>OnDisconnectedAsync</code> methods, both of which can be overridden to react on client connects and disconnects. Here, we define the <code>RegisterGameCompletions</code> method with <code>gameType</code> as its parameter. This method is invoked by SignalR clients.</p>
			<p>Using SignalR, a hub can send real-time information to all clients, one client, or a group of clients. With this implementation, we allow clients to register with a group. Game types are used to differentiate different groups. The <code>Hub</code> class defines a <code>Groups</code> property to subscribe and unsubscribe from a group. The <code>AddToGroupAsync</code> method adds the client and <code>RemoveFromGroupAsync</code> removes the client from the group. A connected client can be identified using <code>ConnectionId</code>, which can be accessed using the <code>Context</code> property.</p>
			<p>To send information to connected clients, the <code>Hub</code> class offers the <code>Clients</code> property, which allows you to send to all clients (<code>Clients.All.SendAsync</code>), or a group (<code>Clients.Group("group-name").SendAsync</code>). However, in this case, we need to send the information outside of the <code>LiveHub</code> class (after receiving a REST invocation) from the <code>game-apis</code> service. We’ll do this by implementing the <code>LiveGamesEndpoints</code> class.</p>
			<h2 id="_idParaDest-323"><a id="_idTextAnchor322"/>Returning live information to the clients</h2>
			<p>The <code>LiveGamesEndpoints</code> class uses<a id="_idIndexMarker1043"/> minimal APIs to implement a REST endpoint. What’s special is that it can send information to connected clients:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Endpoints/LiveGamesEndpoints.cs</p>
			<pre class="source-code">
public static class LiveGamesEndpoints
{
  public static void MapLiveGamesEndpoints(this IEndpointRouteBuilder routes, ILogger logger)
  {
    var group = routes.MapGroup("/live")
      .WithTags("Game Events API");
<strong class="bold">    group.MapPost("/game", async (GameSummary gameSummary, </strong>
<strong class="bold">      IHubContext&lt;LiveHub&gt; hubContext) =&gt;</strong>
    {
      logger.LogInformation("Received game ended {type} {gameid}", 
        gameSummary.GameType, gameSummary.Id);
<strong class="bold">      await hubContext.Clients.Group(gameSummary.GameType).</strong>
        <strong class="bold">SendAsync("GameCompleted", gameSummary);</strong>
      return TypedResults.Ok();
    })
    .WithName("ReportGameEnded")
    .WithSummary("Report game ended to notify connected clients")
    .WithOpenApi();
  }
}</pre>
			<p>The <code>GameSummary</code> class that’s received by the <code>MapPost</code> method is implemented in the <code>CNinnovation.Codebreaker.BackendModels</code> NuGet package. This class contains summary information of a <a id="_idIndexMarker1044"/>completed game. Along with this HTTP POST body parameter, the <code>MapPost</code> method receives an <code>IHubContext&lt;LiveHub&gt;</code> instance from the DI container. This interface is registered when the DI container is configured for SignalR to retrieve a context to the registered hub to send information to clients. Using the <code>Clients.Group</code> method, when <a id="_idIndexMarker1045"/>passing the name of the group, an <code>IClientProxy</code> object is returned. This proxy is then used to send the <code>GameCompleted</code> method with the game summary.</p>
			<p>Now, all we need to do is register SignalR and the hub with the DI container and the middleware.</p>
			<h2 id="_idParaDest-324"><a id="_idTextAnchor323"/>Registering SignalR services and the hub</h2>
			<p>To use SignalR, and to make the <a id="_idIndexMarker1046"/>hub available as an endpoint, we <a id="_idIndexMarker1047"/>must implement the <code>ApplicationServices</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/ApplicationServices.cs</p>
			<pre class="source-code">
public static class ApplicationServices
{
  public static void AddApplicationServices(this IHostApplicationBuilder builder)
  {
<strong class="bold">    builder.Services.AddSignalR();</strong>
    // code removed for brevity
  }
  public static WebApplication MapApplicationEndpoints(this WebApplication app, ILogger logger)
  {
<strong class="bold">    app.MapLiveGamesEndpoints(logger);</strong>
<strong class="bold">    </strong><strong class="bold">app.MapHub&lt;LiveHub&gt;("/livesubscribe");</strong>
    return app;
  }
}</pre>
			<p>The <code>AddApplicationServices</code> method extends <code>IHostApplicationBuilder</code> to register the<a id="_idIndexMarker1048"/> service classes that are needed for SignalR by invoking the <code>AddSignalR</code> method. The <code>MapApplicationEndpoints</code> method registers <a id="_idIndexMarker1049"/>the SignalR hub and minimal API endpoint. The SignalR hub is registered with the endpoints by passing the <code>Hub</code> class with the generic parameter of the <code>MapHub</code> method. <code>/livesubscribe</code> is the link that’s used by clients to connect to this service.</p>
			<p>The methods of the <code>ApplicationServices</code> class are invoked from the top-level statements of the SignalR project:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/Program.cs</p>
			<pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
<strong class="bold">builder.AddServiceDefaults();</strong>
<strong class="bold">builder.AddApplicationServices();</strong>
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();
var app = <strong class="bold">builder.Build();</strong>
<strong class="bold">app.MapDefaultEndpoints();</strong>
<strong class="bold">app.MapApplicationEndpoints(app.Logger);</strong>
app.Run();</pre>
			<p>The DI container is configured by invoking the <code>AddServiceDefaults</code> method, which is defined by the <a id="_idIndexMarker1050"/>common <code>ServiceDefaults</code> project. This adds the DI container registration that’s <a id="_idIndexMarker1051"/>needed by all projects of the solution. The <code>AddApplicationServices</code> method adds the services that are needed from <code>live-service</code>, such as SignalR. Using <code>builder.Build</code> concludes the information that’s needed via the DI container. The app instance starts configuring the middleware, which is where <code>MapDefaultEndpoints</code> and <code>MapApplicationEndpoints</code> are invoked. <code>MapDefaultEndpoints</code> registers links such as common health checks (covered in <a href="B21217_12.xhtml#_idTextAnchor294"><em class="italic">Chapter 12</em></a>). <code>MapApplicationEndpoints</code> registers the endpoints offered by this service project.</p>
			<p>Now that <code>live-service</code> is ready to go, let’s call the API from the <code>game-apis</code> service.</p>
			<h2 id="_idParaDest-325"><a id="_idTextAnchor324"/>Forwarding requests from the game-apis service</h2>
			<p>Recall the sequence<a id="_idIndexMarker1052"/> diagram from earlier. We’ve updated this diagram to show how <code>game-apis</code> and <code>live-service</code> communicate:</p>
			<div><div><img src="img/B21217_13_02.jpg" alt="Figure 13.2 – REST calls to live-service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.2 – REST calls to live-service</p>
			<p>After a game is completed, the <code>game-apis</code> service invokes <code>live-service</code> with game completion information. To invoke <code>live-service</code>, create the <code>LiveReportClient</code> class, which<a id="_idIndexMarker1053"/> injects <code>HttpClient</code>:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/Services/LiveReportClient.cs</p>
			<pre class="source-code">
<strong class="bold">public class LiveReportClient(HttpClient httpClient, ILogger&lt;LiveReportClient&gt; logger)</strong> : ILiveReportClient
{
  private readonly static JsonSerializerOptions s_jsonOptions = new()
  {
    PropertyNameCaseInsensitive = true
  };
<strong class="bold">  public async Task ReportGameEndedAsync(GameSummary gameSummary, </strong>
    <strong class="bold">CancellationToken cancellationToken = default)</strong>
<strong class="bold">  {</strong>
    try
    {
<strong class="bold">      await httpClient.PostAsJsonAsync("/live/game", gameSummary, </strong>
        <strong class="bold">options: s_jsonOptions, cancellationToken: cancellationToken);</strong>
    }
    catch (Exception ex) when (ex is HttpRequestException or 
      TaskCanceledException or JsonException)
    {
      logger.ErrorWritingGameCompletedEvent(gameSummary.Id, ex);
    }
  }
}</pre>
			<p>The <code>ReportGameEndedAsync</code> method uses the <code>HttpClient</code> class to make an HTTP POST request to <code>/live/game</code> and send <code>GameSummary</code> information.</p>
			<p>Let’s configure the <code>HttpClient</code> class by <a id="_idIndexMarker1054"/>updating the <code>ApplicationServices</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.GameAPIs/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
  // code removed for brevity
  builder.Services.AddScoped&lt;IGamesService, GamesService&gt;();
<strong class="bold">  builder.Services.AddHttpClient&lt;ILiveReportClient, </strong>
    <strong class="bold">LiveReportClient&gt;(client =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    client.BaseAddress = new Uri("https+http://live");</strong>
<strong class="bold">  });</strong>
  builder.AddRedisDistributedCache("redis");
}</pre>
			<p>Using .NET Aspire<a id="_idIndexMarker1055"/> orchestration, the URL of the live client is retrieved by using service discovery with the <code>https+http://live</code> expression. This expression prefers the <code>https</code> schema, but if it isn’t available, it uses the <code>http</code> schema. The name is resolved with service discovery via the app model, as explained in <a href="B21217_01.xhtml#_idTextAnchor014"><em class="italic">Chapter 1</em></a>.</p>
			<p>With that, <code>game-apis</code> has been configured to send game summary information. Now, all we need to do is create a client that receives real-time information from the SignalR service.</p>
			<h1 id="_idParaDest-326"><a id="_idTextAnchor325"/>Creating a SignalR client</h1>
			<p>As a simple client<a id="_idIndexMarker1056"/> receiving real-time information, all we need is a console application that connects to <code>live-service</code>. By doing this, it’s simple to implement this functionality with any other client.</p>
			<p>Start by creating a console project:</p>
			<pre class="console">
dotnet new console -o LiveTestClient</pre>
			<p>The <code>Microsoft.AspNetCore.SignalR.Client</code> NuGet package needs to be added to call a SignalR service. We must also add <code>Microsoft.Extensions.Hosting</code> for the DI container and <code>CNinnovation.Codebreaker.BackendModels</code> with the <code>GameSummary</code> type.</p>
			<p>Create the <code>LiveClient</code> class, which will communicate with the SignalR service:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/LiveClient.cs</p>
			<pre class="source-code">
<strong class="bold">internal class LiveClient(IOptions&lt;LiveClientOptions&gt; options) : IAsyncDisposable</strong>
{
  // code removed for brevity
}
public class LiveClientOptions
{
  public string? LiveUrl { get; set; }
}</pre>
			<p>The <code>LiveClient</code> class specifies a constructor with <code>IOptions&lt;LiveClientOptions&gt;</code>. This will be configured with the DI container so that it can pass the URL string from <code>live-service</code>.</p>
			<p>Add <code>appsettings.json</code> to configure the URL:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/appsettings.json</p>
			<pre class="source-code">
{
  "Codebreaker.Live": {
    "LiveUrl": "http://localhost:5130/livesubscribe"
  }
}</pre>
			<p>For local testing, the port number needs to match the port number that’s specified with <code>launchSettings.json</code>. Don’t forget to <a id="_idIndexMarker1057"/>configure so that <code>appsettings.json</code> is copied to the output directory.</p>
			<p>The connection to the service is initiated by the <code>StartMonitorAsync</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/LiveClient.cs</p>
			<pre class="source-code">
internal class LiveClient(IOptions&lt;LiveClientOptions&gt; options) : IAsyncDisposable
{
  private HubConnection? _hubConnection;
<strong class="bold">  public async Task StartMonitorAsync(CancellationToken </strong>
    <strong class="bold">cancellationToken = default)</strong>
  {
    string liveUrl = options.Value.LiveUrl ??
      throw new InvalidOperationException("LiveUrl not configured");
<strong class="bold">    _hubConnection = new HubConnectionBuilder()</strong>
<strong class="bold">      .WithUrl(liveUrl)</strong>
<strong class="bold">      .Build();</strong>
<strong class="bold">    _hubConnection.On("GameCompleted", (GameSummary summary) =&gt;</strong>
<strong class="bold">    </strong><strong class="bold">{</strong>
<strong class="bold">      string status = summary.IsVictory ? "won" : "lost";</strong>
<strong class="bold">      Console.WriteLine($"Game {summary.Id} {status} by {summary.</strong>
        <strong class="bold">PlayerName} after " +</strong>
<strong class="bold">        "{summary.Duration:g}  with {summary.NumberMoves} moves");</strong>
<strong class="bold">    });</strong>
<strong class="bold">    await _hubConnection.StartAsync(cancellationToken);</strong>
  }
  // code removed for brevity
  public async ValueTask DisposeAsync()
  {
    if (_hubConnection is not null)
    {
      await _hubConnection.DisposeAsync();
    }
  }
}</pre>
			<p>To connect to the SignalR hub, <code>HubConnectionBuilder</code> is used to set up a connection. With this builder, the connection can be configured – for example, logging, server timeout, and <a id="_idIndexMarker1058"/>reconnect behaviors can be set up. The connection is then initiated by invoking the <code>StartAsync</code> method.</p>
			<p>The <code>On</code> method of <code>HubConnection</code> configures the receiving side: when a <code>GameCompleted</code> message is received, the <code>GameSummary</code> parameter specifies the data that’s been received and writes a message about the game to the console. The name <code>GameCompleted</code> needs to match the name that has been passed with the <code>SendAsync</code> method of the service.</p>
			<p>To subscribe to the messages from the service, implement the <code>SubscribeToGame</code> method:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/LiveClient.cs</p>
			<pre class="source-code">
public async Task SubscribeToGame(string gameType, CancellationToken cancellationToken = default)
{
  if (_hubConnection is null) throw new InvalidOperationException("Start a connection first");
<strong class="bold">  await _hubConnection.InvokeAsync("SubscribeToGameCompletions", </strong>
    <strong class="bold">gameType, cancellationToken);</strong>
}</pre>
			<p>With this implementation, the <code>InvokeAsync</code> method of <code>HubConnection</code> is used. <code>SubscribeToGameCompletions</code> matches <a id="_idIndexMarker1059"/>the name of the hub method, which uses the <code>game-type</code> parameter.</p>
			<p>The top-level statements of the client application make use of the <code>LiveClient</code> class:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/Program.cs</p>
			<pre class="source-code">
Console.WriteLine("Test client - wait for service, then press return to continue");
Console.ReadLine();
var builder = Host.CreateApplicationBuilder(args);
builder.Services.AddSingleton&lt;LiveClient&gt;();
builder.Services.Configure&lt;LiveClientOptions&gt;(builder.Configuration.GetSection("Codebreaker.Live"));
using var host = builder.Build();
<strong class="bold">var client = host.Services.GetRequiredService&lt;LiveClient&gt;();</strong>
<strong class="bold">await client.StartMonitorAsync();</strong>
<strong class="bold">await client.SubscribeToGame("Game6x4");</strong>
await host.RunAsync();
Console.WriteLine("Bye...");</pre>
			<p>After configuring the <code>LiveClient</code> class in the DI container, the <code>StartMonitorAsync</code> and <code>SubscribeToGame</code> methods are invoked.</p>
			<p>With this in place, you can start the AppHost so that it runs all the services and multiple instances of the client application. Use <code>bot-service</code> to play multiple games. You’ll see success messages<a id="_idIndexMarker1060"/> from the bot, as shown in <em class="italic">Figure 13</em><em class="italic">.3</em>.</p>
			<div><div><img src="img/B21217_13_03.jpg" alt="Figure 13.3 – Live client receiving game summaries"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.3 – Live client receiving game summaries</p>
			<p>Using the bot, multiple games have been started with a think time of 0 and 1 seconds between game moves. These<a id="_idIndexMarker1061"/> results show game wins that occur between 0.27 and 4.79 seconds.</p>
			<h1 id="_idParaDest-327"><a id="_idTextAnchor326"/>Changing the serialization protocol</h1>
			<p>By default, SignalR <a id="_idIndexMarker1062"/>serializes messages with JSON. Using the <code>Microsoft.AspNetCore.SignalR.Protocols.MessagePack</code> NuGet package, a binary serialization format can be used instead. This is an optimization that reduces the data that’s sent.</p>
			<p>To support this, all we need to do is update the DI configuration in the service, after adding the NuGet package:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
  builder.Services.AddSignalR()
<strong class="bold">    .AddMessagePackProtocol();</strong>
}
// code removed for brevity</pre>
			<p>The <code>AddMessagePackProtocol</code> method adds <code>MessagePack</code> as another option for serialization. JSON is still available.</p>
			<p>Regarding the client, the same NuGet package is required, but this time with the following configuration:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">LiveTestClient/LiveClient.cs</p>
			<pre class="source-code">
string liveUrl = options.Value.LiveUrl ?? throw new InvalidOperationException("LiveUrl not configured");
_hubConnection = new HubConnectionBuilder()
  .WithUrl(liveUrl)
<strong class="bold">  .ConfigureLogging(logging =&gt;</strong>
<strong class="bold">  {</strong>
<strong class="bold">    logging.AddConsole();</strong>
<strong class="bold">    logging.SetMinimumLevel(LogLevel.Debug);</strong>
<strong class="bold">  })</strong>
<strong class="bold">  .AddMessagePackProtocol()</strong>
  .Build();</pre>
			<p>Like the server, the same NuGet package for the protocol is needed for the client, as well as the <code>AddMessagePackProtocol</code> API. With the client, logging is now turned on as well. Logging providers for SignalR can be configured using the <code>ConfigureLogging</code> method. Here, the console provider is added, and the minimum logging level is set to <code>LogLevel.Debug</code>. With this, we can see all communication between the client and the server, including the message protocols that are used and the ping messages that <a id="_idIndexMarker1063"/>are sent.</p>
			<p>When using MessagePack, you need to be aware of an important restriction: <code>DateTime.Kind</code> is not serialized. Thus, this type should be converted into UTC before being sent.</p>
			<p>With this in place, you can <a id="_idIndexMarker1064"/>start the solution again, start the bot to play some games, and start the SignalR client. When you look at the logging information, you’ll see WebSockets and MessagePack in action:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Logging from the client application</p>
			<pre class="source-code">
<strong class="bold">dbug: Microsoft.AspNetCore.SignalR.Client.HubConnection[40]</strong>
<strong class="bold">  Registering handler for client method 'GameCompleted'.</strong>
// some log outputs removed for clarity
<strong class="bold">dbug: Microsoft.AspNetCore.Http.Connections.Client.HttpConnection[8]</strong>
<strong class="bold">  Establishing connection with server at 'http://localhost:5130/livesubscribe'.</strong>
<strong class="bold">dbug: Microsoft.AspNetCore.Http.Connections.Client.HttpConnection[9]</strong>
<strong class="bold">  Established connection '1YXBdJ3Yi7A_86ZqoMKgiA' with the server.</strong>
<strong class="bold">info: Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport[1]</strong>
<strong class="bold">  Starting transport. Transfer mode: Binary. Url: 'ws://localhost:5130/livesubscribe?id=CHpPUMdrJoxV0zLHsskN1Q'.</strong>
<strong class="bold">dbug: Microsoft.AspNetCore.Http.Connections.Client.HttpConnection[18]</strong>
<strong class="bold">      Transport 'WebSockets' started.</strong>
<strong class="bold">info: Microsoft.AspNetCore.SignalR.Client.HubConnection[24]</strong>
<strong class="bold">      Using HubProtocol 'messagepack v1'.</strong>
<strong class="bold">dbug: Microsoft.AspNetCore.Http.Connections.Client.Internal.WebSocketsTransport[13]</strong>
<strong class="bold">      Received message from application. Payload size: 39.</strong></pre>
			<p>Now that we’ve switched the serialization format, let’s reduce the load from the service when a larger number <a id="_idIndexMarker1065"/>of clients is connected by using Azure SignalR Service.</p>
			<h1 id="_idParaDest-328"><a id="_idTextAnchor327"/>Using Azure SignalR Service</h1>
			<p>There’s some overhead <a id="_idIndexMarker1066"/>associated with SignalR since the server has open connections with all SignalR clients.</p>
			<p>To remove this overhead from our services, we can use <strong class="bold">Azure SignalR Service</strong>. This service acts as an intermediary between clients and the SignalR service, as depicted in <em class="italic">Figure 11</em><em class="italic">.4</em>:</p>
			<div><div><img src="img/B21217_13_04.jpg" alt="Figure 1﻿3.4 – Using Azure SignalR Service"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.4 – Using Azure SignalR Service</p>
			<p>The preceding figure <a id="_idIndexMarker1067"/>shows multiple monitor clients that each have a connection open to Azure SignalR Service. <code>live-service</code> just needs to deal with a single connection. Azure SignalR subscribes to the events and forwards them to a single client, a group of clients, or all clients, as specified by <code>live-service</code>.</p>
			<p>The load for every client connection is handled by Azure SignalR Service, while this service just acts as a single client to the SignalR service.</p>
			<p>A free version of this service without SLA that’s limited to 20 connections and 20,000 messages per day can be used for development purposes. Standard and premium SKUs can scale up to 1,000 connections per unit, 100 units, and unlimited messages.</p>
			<p>To activate Azure SignalR Service within the app model, we need to update <code>app-model</code> within the AppHost project:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.AppHost/Program.cs</p>
			<pre class="source-code">
var builder = DistributedApplication.CreateBuilder(args);
<strong class="bold">var signalR = builder.AddAzureSignalR("signalr");</strong>
// code removed for brevity
var live = builder.AddProject&lt;Projects.Codebreaker_Live&gt;("live")
  .WithExternalHttpEndpoints()
  .WithReference(appInsights)
<strong class="bold">  .WithReference(signalR);</strong></pre>
			<p>With .NET Aspire provisioning, Azure SignalR Service is created when the application is started. When using the <code>WithReference</code> method, the URI is forwarded to the <code>Codebreaker.Live</code> service. Here, the <code>Microsoft.Azure.SignalR</code> NuGet package is required to <a id="_idIndexMarker1068"/>connect this service:</p>
			<p class="SC---Heading" lang="en-US" xml:lang="en-US">Codebreaker.Live/ApplicationServices.cs</p>
			<pre class="source-code">
public static void AddApplicationServices(this IHostApplicationBuilder builder)
{
  var signalRBuilder = builder.Services.AddSignalR()
    .AddMessagePackProtocol();
  if (Environment.GetEnvironmentVariable("StartupMode") != "OnPremises")
  {
<strong class="bold">      signalRBuilder.AddNamedAzureSignalR("signalr");</strong>
<strong class="bold">  }</strong>
}</pre>
			<p>Using <code>AddNamedAzureSignalR</code>, the connection string is retrieved via service discovery, and the SignalR hub is connected to this Azure service.</p>
			<p>Now, start the application again and check the Azure portal to see that the service has been created. Use the Aspire dashboard to see the environment variable that’s been assigned to the <code>Codebreaker.Live</code> service, and check the logs to see the connections that have been made to Azure SignalR Service. Run the bot so that it plays several games and then start several SignalR client (<code>LiveTestClient</code>) processes.</p>
			<p>When you open the Azure portal, open the resource group of the developer environment (<code>rg-aspire-&lt;yourhost&gt;-codebreaker.apphost</code>) and select Azure SignalR Service. In <a id="_idIndexMarker1069"/>the <strong class="bold">Monitoring</strong> category in the left bar, select <strong class="bold">Live trace settings</strong>. Click the <strong class="bold">Enable Live Trace</strong> checkbox and choose to collect information for <strong class="bold">ConnectivityLogs</strong>, <strong class="bold">MessagingLogs</strong>, and <strong class="bold">HttpRequestLogs</strong>. Then, click the <strong class="bold">Open Live Trace Tool</strong> button. You’ll receive the following output:</p>
			<div><div><img src="img/B21217_13_05.jpg" alt="Figure 13.5 – Azure SignalR Service live trace. This screenshot only intends to show the output result page; text readability is not essential"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.5 – Azure SignalR Service live trace. This screenshot only intends to show the output result page; text readability is not essential</p>
			<p>With the Azure SignalR Service live trace, you can see all the messages that have been sent from the Codebreaker <a id="_idIndexMarker1070"/>live service, as well as the messages that have been sent to the subscribing clients.</p>
			<p>To see metrics data, go back (or open a new browser window) to the <strong class="bold">Overview</strong> page of Azure SignalR Service. There, you can see the number of connections that have been opened, as shown in <em class="italic">Figure 13</em><em class="italic">.6</em>:</p>
			<div><div><img src="img/B21217_13_06.jpg" alt="Figure 13.6 – Azure SignalR Service connection metrics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.6 – Azure SignalR Service connection metrics</p>
			<p><em class="italic">Figure 13</em><em class="italic">.7</em> shows the number <a id="_idIndexMarker1071"/>of messages that have been sent:</p>
			<div><div><img src="img/B21217_13_07.jpg" alt="Figure 13.7 – Azure SignalR Sevice message metrics"/>
				</div>
			</div>
			<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 13.7 – Azure SignalR Sevice message metrics</p>
			<p>Now that everything is up and running, you’ve earned a well-deserved break so that you can play some <a id="_idIndexMarker1072"/>games (which you can monitor as well).</p>
			<h1 id="_idParaDest-329"><a id="_idTextAnchor328"/>Summary</h1>
			<p>In this chapter, you learned how to offer real-time data using SignalR. You created a live service containing a SignalR hub that offers real-time information about completed games. Clients can register to a subset – a group – of the information offered. You also created a simple console application that acts as a client. The same functionality can be implemented in other clients. You can check this out in the Blazor client application provided in this book’s GitHub repository, which contains the SignalR client functionality.</p>
			<p>Then, you learned how to use Azure SignalR Service, which reduces the load on the service hosting the SignalR hub as the clients directly interact with Azure SignalR Service while this service acts as one client to SignalR.</p>
			<p>With the implementation of this chapter, we created a REST API that’s invoked by the <code>game-apis</code> service to send completed games. REST is great for easy communication with all clients, but it doesn’t offer the best performance. The only client for the <code>Codebreaker.Live</code> service is the <code>game-apis</code> service.</p>
			<p>Regarding service-to-service communication, instead of using REST APIs, less overhead is used when binary serialization is used alongside protocols such as gRPC. This will be covered in the next chapter.</p>
			<h1 id="_idParaDest-330"><a id="_idTextAnchor329"/>Further reading</h1>
			<p>To learn more about the topics that were discussed in this chapter, please refer to the following links:</p>
			<ul>
				<li><em class="italic">ASP.NET Core </em><em class="italic">SignalR</em>: <a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction">https://learn.microsoft.com/en-us/aspnet/core/signalr/introduction</a></li>
				<li><em class="italic">Message Pack </em><em class="italic">protocol</em>: <a href="https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol">https://learn.microsoft.com/en-us/aspnet/core/signalr/messagepackhubprotocol</a></li>
				<li><em class="italic">Azure SignalR </em><em class="italic">Service</em>: <a href="https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview">https://learn.microsoft.com/en-us/azure/azure-signalr/signalr-overview</a></li>
				<li>.<em class="italic">NET Aspire support for Azure SignalR </em><em class="italic">Service</em>: <a href="https://learn.microsoft.com/en-us/dotnet/aspire/real-time/azure-signalr-scenario">https://learn.microsoft.com/en-us/dotnet/aspire/real-time/azure-signalr-scenario</a></li>
			</ul>
		</div>
	</body></html>