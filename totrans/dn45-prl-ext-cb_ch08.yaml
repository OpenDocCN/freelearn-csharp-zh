- en: Chapter 8. Async
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following recipes:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating an `async` method
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Handling `Exceptions` in asynchronous code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancelling an asynchronous operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Cancelling `async` operation after timeout period
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Processing multiple `async` tasks as they complete
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Improving performance of `async` solution with `Task.WhenAll`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using `async` for file access
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Checking the progress of an asynchronous task
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We've all seen client applications that do not respond to mouse events or update
    the display for noticeable periods of time. This delay is likely the result of
    code holding on to the single UI thread for far too long. Maybe it is waiting
    for network I/O or maybe it is performing an intensive computation. Meanwhile,
    the user is left sitting there waiting, as our application grinds to a halt. The
    answer to this problem is asynchrony.
  prefs: []
  type: TYPE_NORMAL
- en: How is the concept of asynchrony different from parallelism? Parallelism, with
    which you are quite familiar by this point in the book, is mainly about application
    performance. Parallelism enables developers to perform CPU intensive work on multiple
    threads at once, taking advantage of modern multi-core computer architectures.
    Asynchrony on the other hand, is a superset of concurrency. It includes concurrency
    as well as other asynchronous calls which are more I/O bound than CPU bound. Let's
    say you are saving a large file to your hard drive or you want to download some
    data from the server. These kinds of I/O bound tasks are ideal for asynchrony.
    Asynchrony is a pattern which yields control instantly, and waits for a callback
    or other notification to occur before continuing.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, just do things using an asynchronous pattern and your UI responsiveness
    problems are solved, right? Well, yes, but there is one small problem. Asynchronous
    code is difficult, at least historically speaking. However, asynchrony is taking
    a huge leap forward in terms of usability. Microsoft has delivered this by building
    on the `Task` functionality in .NET 4.5, as well as the addition of two new keywords
    to the .NET Framework: `async` and `await`.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will walk through several recipes that show how to maintain
    a responsive UI or scalable services by using the new **Task-based Asynchronous
    Pattern** (**TAP**) of the .NET Framework 4.5.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an async method
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The TAP is a new pattern for asynchronous programming in .NET Framework 4.5\.
    It is based on a task, but in this case a task doesn't represent work which will
    be performed on another thread. In this case, a task is used to represent arbitrary
    asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: Let's start learning how `async` and `await` work by creating a **Windows Presentation**
    **Foundation** (**WPF**) application that accesses the web using `HttpClient`.
    This kind of network access is ideal for seeing TAP in action. The application
    will get the contents of a classic book from the web, and will provide a count
    of the number of words in the book.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's go to Visual Studio 2012 and see how to use the `async` and `await` keywords
    to maintain a responsive UI by doing the web communications asynchronously.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **WPF Application** project template and assign
    `WordCountAsync` as **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Begin by opening `MainWindow.xaml` and adding the following XAML to create
    a simple user interface containing `Button` and `TextBlock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/0225OT_08_01.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next, open up `MainWindow.xaml.cs`. Go to the **Project** and add a reference
    to `System.Net.Http`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a button click event for the `StartButton` and add the `async` modifier
    to the method signature to indicate that this will be a `async` method. Please
    note that `async` methods that return `void` are normally only used for event
    handlers, and should be avoided.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create a `async` method called `GetWordCountAsync` that returns
    `Task<int>`. This method will create `HttpClient` and call its `GetStringAsync`
    method to download the book contents as a string. It will then use the `Split`
    method to split the string into a `wordArray`. We can return the count of the
    `wordArray` as our `return` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's complete the implementation of our button click event. The `Click`
    event handler will just call `GetWordCountAsync` with the `await` keyword and
    display the results to `TextBlock`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Click on the **Start**
    button, and your application should appear as shown in the following screenshot:![How
    to do it…](img/0225OT_08_02.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the TAP, asynchronous methods are marked with an `async` modifier. The `async`
    modifier on a method does not mean that the method will be scheduled to run asynchronously
    on a worker thread. It means that the method contains control flow that involves
    waiting for the result of an asynchronous operation, and will be rewritten by
    the compiler to ensure that the asynchronous operation can resume this method
    at the right spot.
  prefs: []
  type: TYPE_NORMAL
- en: Let me try to put this a little more simply. When you add the `async` modifier
    to a method, it indicates that the method will wait on an asynchronous code to
    complete. This is done with the `await` keyword. The compiler actually takes the
    code that follows the `await` keyword in an `async` method and turns it into a
    continuation that will run after the result of the `async` operation is available.
    In the meantime, the method is suspended, and control returns to the method's
    caller.
  prefs: []
  type: TYPE_NORMAL
- en: If you add the `async` modifier to a method, and then don't `await` anything,
    it won't cause an error. The method will simply run synchronously.
  prefs: []
  type: TYPE_NORMAL
- en: 'An `async` method can have one of the three return types: `void`, `Task`, or
    `Task<TResult>`. As mentioned before, a task in this context doesn''t mean that
    this is something that will execute on a separate thread. In this case, task is
    just a container for the asynchronous work, and in the case of `Task<TResult>`,
    it is a promise that a result value of type `TResult` will show up after the asynchronous
    operation completes.'
  prefs: []
  type: TYPE_NORMAL
- en: In our application, we use the `async` keyword to mark the button click event
    handler as asynchronous, and then we wait for the `GetWordCountAsync` method to
    complete by using the `wait` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The code that follows the a`wait` keyword, in this case, the same line of code
    that updates `TextBlock`, is turned by the compiler into a continuation that will
    run after the `integer` result is available.
  prefs: []
  type: TYPE_NORMAL
- en: If the `Click` event is fired again while this asynchronous task is in progress,
    another asynchronous task is created and awaited. To prevent this, it is a common
    practice to disable the button that is clicked.
  prefs: []
  type: TYPE_NORMAL
- en: It is a convention to name an asynchronous method with an `Async` postfix, as
    we have done with `GetWordCountAsync`.
  prefs: []
  type: TYPE_NORMAL
- en: Handling Exceptions in asynchronous code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So how would you add `Exception` handling to code that is executed asynchronously?
    In previous asynchronous patterns, this was very difficult to achieve. In C# 5.0
    it is much more straightforward because you just have to wrap the asynchronous
    function call with a standard `try`/`catch` block.
  prefs: []
  type: TYPE_NORMAL
- en: On the surface this sounds easy, and it is, but there is more going on behind
    the scene that will be explained right after we build our next example application.
  prefs: []
  type: TYPE_NORMAL
- en: For this recipe, we will return to our classic books word count scenario, and
    we will be handling an `Exception` thrown by `HttpClient` when it tries to get
    the book contents using an incorrect URL.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's build another WPF application and take a look at how to handle `Exceptions`
    when something goes wrong in one of our asynchronous methods.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **WPF Application** project template and assign
    `AsyncExceptions` as **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Begin by opening `MainWindow.xaml` and adding the following XAML to create
    a simple user interface containing `Button` and a `TextBlock`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, open up `MainWindow.xaml.cs`. Go to the **Project Explorer**, right-click
    on **References**, click on **Framework** from the menu on the left side of the
    **Reference Manager**, and then add a reference to `System.Net.Http`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create our `GetWordCountAsync` method. This method will be very similar
    to the last recipe, but it will be trying to access the book on an incorrect URL.
    The asynchronous code will be wrapped in a `try`/`catch` block to handle `Exception`.
    We will also use a `finally` block to dispose of `HttpClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let create the `Click` event handler for our `StartButton`. This is
    pretty much the same as the last recipe, just wrapped in a `try`/`catch` block.
    Don't forget to add the `async` modifier to the method signature.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, in Visual Studio 2012, press *F5* to run the project. Click on the **Start**
    button. Your application should appear as shown in the following screenshot:![How
    to do it…](img/0225OT_08_03.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Wrapping your asynchronous code in a `try`/`catch` block is pretty easy. In
    fact, it hides some of the complex work Visual Studio 2012 to doing for us.
  prefs: []
  type: TYPE_NORMAL
- en: To understand this, you need to think about the context in which your code is
    running.
  prefs: []
  type: TYPE_NORMAL
- en: When the TAP is used in Windows Forms or WPF applications, there's already a
    context that the code is running in, such as the message loop UI thread. When
    `async` calls are made in those applications, the awaited code goes off to do
    its work asynchronously and the `async` method exits back to its caller. In other
    words, the program execution returns to the message loop UI thread.
  prefs: []
  type: TYPE_NORMAL
- en: The `Console` applications don't have the concept of a context. When the code
    hits an awaited call inside the `try` block, it will exit back to its caller,
    which in this case is `Main`. If there is no more code after the awaited call,
    the application ends without the `async` method ever finishing.
  prefs: []
  type: TYPE_NORMAL
- en: To alleviate this issue, Microsoft included `async` compatible context with
    the TAP that is used for `Console` apps or unit test apps to prevent this inconsistent
    behavior. This new context is called `GeneralThreadAffineContext`.
  prefs: []
  type: TYPE_NORMAL
- en: Do you really need to understand these context issues to handle async `Exceptions`?
    No, not really. That's part of the beauty of the Task-based Asynchronous Pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Cancelling an asynchronous operation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In .NET 4.5, asynchronous operations can be cancelled in the same way that parallel
    tasks can be cancelled, by passing in `CancellationToken` and calling the `Cancel`
    method on `CancellationTokenSource`.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a WPF application that gets the contents
    of a classic book over the web and performs a word count. This time though we
    are going to set up a **Cancel** button that we can use to cancel the `async`
    operation if we don't want to wait for it to finish.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a WPF application to show how we can add cancellation to our asynchronous
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **WPF Application** project template and assign
    `AsyncCancellation` as **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Begin by opening `MainWindow.xaml` and adding the following XAML to create our
    user interface. In this case, the UI contains `TextBlock`, `StartButton`, and
    `CancelButton`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, open up `MainWindow.xaml.cs`, click on the **Project Explorer**, and add
    a reference to `System.Net.Http`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create the `GetWordCountAsync` method. This method is very similar
    to the method explained before. It needs to be marked as asynchronous with the
    `async` modifier and it returns `Task<int>`. This time however, the method takes
    a `CancellationToken` parameter. We also need to use the `GetAsync` method of
    `HttpClient` instead of the `GetStringAsync` method, because the former supports
    cancellation, whereas the latter does not. We will add a small delay in the method
    so we have time to cancel the operation before the download completes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's create the `Click` event handler for our `CancelButton`. This method
    just needs to check if `CancellationTokenSource` is `null`, and if not, it calls
    the `Cancel` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ok, let's finish up by adding a `Click` event handler for `StartButton`. This
    method is the same as explained before, except we also have a `catch` block that
    specifically handles `OperationCancelledException`. Don't forget to mark the method
    with the `async` modifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project Click on the **Start**
    button, then the **Cancel** button. Your application should appear as shown in
    the following screenshot:![How to do it…](img/0225OT_08_04.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cancellation is an aspect of user interaction that you need to consider to build
    a professional `async` application. In this example, we implemented cancellation
    by using a **Cancel** button, which is one of the most common ways to surface
    cancellation functionality in a GUI application.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, cancellation follows a very common flow.
  prefs: []
  type: TYPE_NORMAL
- en: The caller (start button click event handler) creates a `CancellationTokenSource`
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The caller calls a cancelable method, and passes `CancellationToken` from `CancellationTokenSource`
    (`CancellationTokenSource.Token`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The cancel button click event handler requests cancellation using the `CancellationTokenSource`
    object (`CancellationTokenSource.Cancel()`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The task acknowledges the cancellation by throwing `OperationCancelledException`,
    which we handle in a `catch` block in the start button click event handler.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Cancelling async operation after timeout period
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another common scenario for cancelling asynchronous tasks is to set a timeout
    period by using the `CancellationTokenSource.CancelAfter` method. This method
    schedules the cancellation of any associated tasks that aren't complete within
    the period of time that's designated by the `CancelAfter` expression.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a WPF application that gets the contents
    of a classic book over the web and performs a word count. This time though, we
    are going to set a timeout period after which the task gets cancelled.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's see how we can create an asynchronous task that cancels after a specified
    timeout period.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **WPF Application** project template and assign
    `CancelAfterTimeout` as **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Begin by opening `MainWindow.xaml` and add the following XAML to create our
    user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/0225OT_08_05.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: Next, open up `MainWindow.xaml.cs`. Go to the **Project Explorer** and add a
    reference to `System.Net.Http`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create the `GetWordCountAsync` method. This method is exactly the
    same as the last recipe. It needs to be marked as asynchronous with the `async`
    modifier and it returns `Task<int>`. The method takes a `CancellationToken` parameter.
    We will add a small delay in the method so we have time to cancel the operation
    before the download completes.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Ok, let's finish up by adding a `Click` event handler for `StartButton`. This
    method is similar to the last recipe, except we call the `CancellationTokenSource.CancelAfter`
    method, passing it the value of our `timeout` textbox. Don't forget to mark the
    method with the `async` modifier.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Set the `timeout` value
    to `100`. Your application should appear as shown in the following screenshot:![How
    to do it…](img/0225OT_08_06.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The application is very similar to the application we created in the last recipe,
    except this time the `Cancel` button isn't used. The actual cancellation follows
    a similar flow however.
  prefs: []
  type: TYPE_NORMAL
- en: The caller (start button click event handler) creates a `CancellationTokenSource`
    object, and then calls the `CancelAfter` method to pass in the `timeout` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The caller calls a cancelable method, and passes `CancellationToken` from `CancellationTokenSource`
    (`CancellationTokenSource.Token`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: After the timeout period expires, `CancellationTokenSource` triggers a cancellation
    same as if we had made a call to `CancellationTokenSource.Cancel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The task acknowledges the cancellation by throwing `OperationCancelledException`,
    which we handle in a `catch` block in the start button click event handler.
  prefs: []
  type: TYPE_NORMAL
- en: Processing multiple async tasks as they complete
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Many of the methods of the `Task` class that we learned about in [Chapter 1](ch01.html
    "Chapter 1. Getting Started with Task Parallel Library"), *Getting Started with
    Task Parallel Library*, are as useful when writing an asynchronous code as they
    are when writing a parallel code. In this recipe, we are going to download the
    contents of multiple books and use `Task.WhenAny` to process them as they finish.
  prefs: []
  type: TYPE_NORMAL
- en: This application will use a `while` loop to create a collection of tasks. Each
    task downloads the contents of a specified book. In each iteration of a loop,
    an awaited call to `WhenAny` returns the task in the collection of tasks that
    finishes first. That task is removed from the collection and processed. The loop
    repeats until the collection contains no more tasks.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, let's create a WPF application that creates multiple asynchronous tasks
    and processes them as they complete.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **WPF Application** project template and assign
    `AsyncMultipleRequest` as **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Begin by opening `MainWindow.xaml` and adding the following XAML to create
    our user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, open up `MainWindow.xaml.cs`. Go to the **Project Explorer**, and add
    a reference to `System.Net.Http`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's start by creating a helper function that builds a list of `KeyValuePair<string,string>`
    which represents our book titles and URLs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create an `async` method that does the book download and returns `KeyValuePair<string,
    int>` that represents our book titles and word count. This method will need to
    accept a `KeyValuePair<string, string>` parameter representing the book title
    and URL. The method also needs an `HttpClient` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we need to create another `async` method called `GetMultipleWordCount`.
    This method executes a query on our list of books. Each query calls the `ProcessBook`
    method to actually do the download and obtain the word count. After the query,
    we set up a `while` loop that loops while our list of book processing tasks is
    greater than zero. Each iteration of the loop awaits a call to `Task.WhenAny`.
    When a task is completed, the results are written out and `Task` is removed from
    the `Task` list. This method takes no parameters and returns `Task`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's create our start button click event handler. The handler only
    needs to call the `GetMultipleWordCount` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    appear as shown in the following screenshot:![How to do it…](img/0225OT_08_07.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have already seen in the previous recipes that the `WhenAny` method of the
    `Task` class can be used on a list of parallel tasks to continue processing when
    any of the tasks in the array is complete.
  prefs: []
  type: TYPE_NORMAL
- en: Even though a task in the `async` context doesn't mean that our list of `async`
    tasks are running in parallel on separate worker threads, we can still use the
    `WhenAny` method to handle `async` requests as they complete.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we downloaded the text of multiple books and displayed the word
    count of each of the books as the download finished. The start button's click
    event handler doesn't do much other than add some text to `TextBlock` and `await`
    a call to the `GetMultipleWordCount` method. After creating `HttpClient`, the
    `GetMultipleWordCount` method makes a call to the `GetBookUrls` helper method
    that we created, which just returns a list of three books and their URLs.
  prefs: []
  type: TYPE_NORMAL
- en: After getting the list of books and their URLs, the `GetMultipleWordCount` method
    creates `IEnumerable<Task<TResult>>` by executing a LINQ query that calls the
    `ProcessBook` method on each `book` in the list.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Next, we set up a `while` loop on the condition that `bookTasks.Count` is greater
    than zero. In the body of the `while` loop, we `await` a call to the `Task.WhenAny`
    method, which will return when the first list of tasks is complete. We then remove
    this `Task` from `bookTasks` so the count is decremented. Below that, we await
    the `firstFinished` task variable. This has the effect of the compiler creating
    a continuation for us at this point that will run, as soon as the `task` variable
    `firstFinished` is completed, the compiler-created continuation will contain the
    code to update the `TextBlock` with the word count for the book.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Improving performance of async solution with Task.WhenAll
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen how we can use the `Task.WhenAny` method to handle asynchronous
    tasks as they complete. You will also find the `Task.WhenAll` method very useful
    in the asynchronous context. In some applications that create multiple asynchronous
    requests, it can improve application performance by using `Task.WhenAll` to hold
    off on processing results until all the asynchronous tasks have completed.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a WPF application that downloads the
    contents of multiple books asynchronously, but holds off on processing the results
    until all the tasks have completed.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start a new project using the **WPF Application** project template and assign
    `AsyncMultipleRequest` as **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Begin by opening `MainWindow.xaml` and adding the following XAML to create
    our user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, open up `MainWindow.xaml.cs`. Go to the **Project Explorer**, and add
    a reference to `System.Net.Http`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Let's start by creating a helper function that builds a list of `KeyValuePair<string,string>`,
    which represents our book titles and URLs.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's create a `async` method that performs the book download and returns
    `KeyValuePair<string, int>` that represents our book titles and word count. This
    method will need to accept a `KeyValuePair<string, string>` parameter representing
    the book title and URL. The method also needs a `HttpClient` parameter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, we need to create the `GetWordCount` method. This method will execute
    a LINQ query to call the `ProcessBook` method on each `book` in the list of books.
    It then calls `Task.WhenAll` to `await` the tasks completed of all of the tasks.
    When all tasks have finished, it needs to write the results to the `TextBlock`
    in a `for` loop.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, the start button click event handler just needs to call the `GetWordCount`
    method and `await` the task.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    have results as shown in the following screenshot:![How to do it…](img/0225OT_08_08.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In this recipe, the `GetWordCount` method calls the `ProcessBook` method for
    each book in the list by executing a LINQ query. This returns an `IEnumerable<Task<TResult>>`,
    when we turn in to an array of tasks by calling the `ToArray` method.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: Next, we just `await` a call to the `Task.WhenAll` method which will return
    when all of the asynchronous tasks complete. Finally, we just use a `for` loop
    to update the `TextBlock`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: Using async for file access
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have created applications that use `async` for web access, using
    `HttpClient`. Another common use for `async` is performing asynchronous file I/O
    without blocking the main thread.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a WPF application that can write to and
    read from a file asynchronously. The application will have two text boxes, one
    containing the text to write to a file, and the other containing text to read
    from a file.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Start a new project using the **WPF Application** project template and assign
    `AsyncFileAccess` as **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Begin by opening `MainWindow.xaml` and adding the following XAML to create
    our user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/0225OT_08_09.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of the `MainWindow` class, add a `path` constant for the path of
    the text file you will be writing. This can be any path you like.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, let's create a `async` method called `WriteToFileAsync` that returns `Task`.
    This method gets a `Unicode` encoded `byte` array of the text in our `TextBox`,
    creates a file stream, and writes the text to the file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now create an asynchronous `Click` event handler for the `Write` button. Here,
    we just need to `await` a call to `WriteFileAsync`, passing it the input string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's create an asynchronous method called `ReadFromFileAsync` that returns
    `Task<string>`. This method creates `FileStream` and reads the contents of the
    file into `string`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's create the read button click handler. This `async` method just
    needs to check for the existence of the file, and `await` a call to `ReadFromFileAsync`.
    Set the results of the method call to the proper `TextBox`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    appear as shown in the following screenshot:![How to do it…](img/0225OT_08_010.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `Click` event handler is pretty straightforward. It is marked with the `async`
    keyword because it awaits a call to `WriteToFileAsync`. You must have noticed
    that we disabled the `Write` button at the start of the method and enabled it
    again at the end. This is a good practice to control reentrancy with `async` methods.
    The UI is free to respond to clicks and will fire the `Click` event handler again,
    if it receives a click.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: The `WriteToFileAsync` method gets a `Unicode` encoded `byte` array of the input
    string then creates `FileStream` with `Write` access in the `Append` mode. Once
    `stream` is open, we `await` a call to the `WriteAsync` method of `FileStream`,
    passing it our `byte` array.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: The `ReadFromFileAsync` method just creates `FileStream` in open mode with read
    access. Once the `stream` is open, we `await` a call to the `ReadAsync` method
    of `FileStream` in a `while` loop, and read its contents.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Checking the progress of an asynchronous task
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If an asynchronous functionality in your application involves a noticeable delay
    while the user waits for the result, you might want to inform users that there
    will be a wait and provide a sense of how long the wait might be. The progress
    and cancellation features of the `async` programming model enable you to deliver
    on these needs.
  prefs: []
  type: TYPE_NORMAL
- en: In this recipe, we are going to create a WPF application that uses the progress
    events of `WebClient` to display the status of a `Download` task with a `ProgressBar`.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let's create a WPF application and see how we can add progress reporting to
    our asynchronous operations.
  prefs: []
  type: TYPE_NORMAL
- en: Start a new project using the **WPF Application** project template and assign
    `AsyncProgress` as **Solution name**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Begin by opening `MainWindow.xaml` and add the following XAML to create our
    user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '![How to do it…](img/0225OT_08_011.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Add the following `using` directives to the top of your `MainWindow` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: At the top of the `MainWindow` class, add a `character` array constant that
    will be used to split the contents of the book into a word array. Also add a `string`
    constant for the user agent header for a `WebClient`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now let's add a method called `client_DownloadFileCompleted` that will be the
    event handler for the `DownloadFileCompleted` event of a `WebClient`. This method
    just needs to add some text to `TextBlock` to indicate that the download has finished.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Next, create a method called `client_DownloadProgressChanged`. This method will
    be the event handler for the WebClient's `DownloadProgressChanged` event, and
    needs to calculate the bytes received, the total bytes, the percentage complete,
    and update the progress bar.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now we need to create our asynchronous `GetWordCountAsync` method. This method
    returns `Task<int>`, and after creating `WebClient`, and wiring up the `DownloadFileCompletedEvent`
    and `DownloadProgressChanged` events, it awaits a call to the `DownloadStringTaskAsync`
    method of `WebClient` to download the contents of the book and split the words
    into an array of strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, let's create an asynchronous `Click` event handler for `StartButton`.
    This button just writes some text to `TextBlock` and awaits a call to `GetWordCountAsync`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In Visual Studio 2012, press *F5* to run the project. Your application should
    display the results as shown in the following screenshot:![How to do it…](img/0225OT_08_012.jpg)
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How it works…
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'This application was able to show the progress of its download by wiring up
    two events of the `WebClient` class: `DownloadProgressChanged` and `DownloadFileCompleted`.
    It then calls the `DownloadStringTaskAsync` method of `WebClient`, which triggers
    the events as the download progresses.'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: The event handler for `DownloadFileCompleted` is pretty self-explanatory. The
    event handler for `DownloadProgressChanged` is where the calculation of the progress
    actually happens. Each time the event fires, we get the number of bytes the `WebClient`
    has received, the total number of bytes to receive, and we calculate the percentage
    completed of the download. Finally, we set the `Value` property of `ProgressBar`
    with the results of the `percentage` calculation.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
