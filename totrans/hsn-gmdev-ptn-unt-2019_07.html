<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Factory Method</h1>
                </header>
            
            <article>
                
<p>The Factory Method is probably the most famous design pattern because it offers a solid structural base for most software architectures. There are two main variations of this pattern:</p>
<ul>
<li>The Factory Method</li>
<li>Abstract factory</li>
</ul>
<p>The main difference between both patterns is that the Factory Method is centered around a single Factory Method, while the Abstract Factory provides a way to encapsulate and group factories that have a familiar theme. These descriptions might sound abstract at the moment, but we will implement both of these variations in separate chapters so that we can better understand the core differences between each type of Factory pattern.</p>
<p>On a personal note, my only issue with the Factory pattern, in general, is that programmers tend to be irregular in the ways they implement it, and so sometimes consistency is lost because of personal style. But as we are going to see throughout this book, the most popular patterns tend to have significant alterations in the way they are implemented by professional programmers. We are going to try and take an approach that's always compatible with Unity's API and coding model.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>An overview of the Factory Method</li>
<li>Implementing a <strong>non-player characters</strong> (<strong>NPC</strong>) spawn system while using the Factory Method as the foundation of our architecture</li>
</ul>
<div class="packt_infobox">The core difference between the Factory and Prototype patterns is that the Factory pattern is useful when you want to delegate the creation process of objects, while the Prototype pattern is an optimal solution when creating new instances of objects is too costly.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter is hands on; you will need to have a basic understanding of Unity and C# to continue.<br/></p>
<p>We will be using the following specific Unity engine and C# language concepts:</p>
<ul>
<li>Enums</li>
<li>Composition</li>
</ul>
<p>If you're unfamiliar with these concepts, please review them before starting this chapter.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2WvN2vp">http://bit.ly/2WvN2vp</a></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An overview of the Factory Method</h1>
                </header>
            
            <article>
                
<p>The Factory pattern is one of those patterns whose name is a good indication of its core purpose. There's a robust real-world correlation that can help us visualize its intent <span>– </span>imagine yourself ordering a new car at a dealership. During this process, does the dealer inform you of the manufacturing process of your new vehicle? The answer is probably no; usually, the dealer sends your order to the factory, and then they ship the requested final product back to you.</p>
<p>In other words, as the consumer of a product, you should focus on ordering and receiving, not manufacturing and distributing. And that's the primary goal of the Factory pattern; it simplifies the <em>order</em> process of specific types of objects by providing an interface that's abstract to the inner workings of the <em>manufacturing</em> process of the requested objects.</p>
<p>As we mentioned in the introduction, there are two main variations of the Factory, but in this chapter, we will review only the simplest form of this pattern, which is the Factory Method.</p>
<p class="mce-root"/>
<p>Let's start by reviewing a UML diagram of a use case that's using the Factory Method:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/071dc34a-e237-45b8-999d-cfea94e4589c.png"/></p>
<p>As we can see from this diagram, the <kbd>GetNPC()</kbd> method of the <kbd>NPCFactory</kbd> class is responsible for getting a specific type of NPC (<strong>Beggar</strong>, <strong>Shopowner</strong>, or <strong>Farmer</strong>). So, if a client requests a particular type of NPC, it needs to ask <kbd>NPCFactory</kbd> to produce it.</p>
<p>The core purpose of the Factory pattern is to abstract the creation and localize the creation process of a particular type of object.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits and drawbacks</h1>
                </header>
            
            <article>
                
<p>The Factory Method pattern has an excellent reputation and is often the cornerstone of a reliable code base. Let's have a look at a few of the benefits and drawbacks of the Factory Method.</p>
<p class="mce-root"/>
<p>These are the benefits:</p>
<ul>
<li><strong>Loose coupling</strong>: Because the client doesn't need to know the details of the initialization process of a specific type of object, it reduces coupling and dependencies between classes</li>
<li><strong>Encapsulation of the creation process</strong>: The fact that the Factory Method takes the responsibility of creating specific object types, you can localize complex initialization processes in a single class</li>
</ul>
<p>These are the drawbacks:</p>
<ul>
<li><strong>Extra code complexity</strong>: Code becomes harder to read because you are adding abstraction and additional classes.</li>
<li><strong>Open to interpretation</strong>: Programmers often confuse the Factory Method and its cousin, the Abstract Factory. This issue might cause inconsistent implementations, which can provoke uncertainty and confusion between programmers working on the same code base.</li>
</ul>
<div class="packt_tip">It's sometimes difficult to isolate recurrent drawbacks with a specific pattern because often it's a question of context. But a universal truth about design patterns is that they can become a regressive part of your architecture if you misapply them.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use case example</h1>
                </header>
            
            <article>
                
<p>Now that we have a basic understanding of the Factory Method, let's build a game system with it. To stay consistent with our previous chapter, we are going to implement another spawn system, but this time for NPCs. Because the Factory Method is a Creational pattern, it's a natural fit for a spawn system. As we are going to see in the following code example, the Factory Method is a perfect pattern to use when you need to centralize the initialization pipeline of various entities.</p>
<div class="packt_tip packt_infobox">In a professional game project, you might end up having to build separate spawn systems for different groups of entities. For example, in an open-world game, you might have a specific method to spawn civilians and one to generate cops because each primary type of AI character might have different requirements and loading processes.</div>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>As we mentioned before, the Factory Method is the most straightforward approach to implementing a Factory pattern. As its name implies, it primarily focuses on providing a standard interface for the creation of specific object types through a Factory Method. So, if we have a <kbd>Client</kbd> class that needs to initialize an object of a particular kind (also known as a <strong>product</strong>) but we don't know the exact class or the process to call, instead, we merely refer to a Factory to produce the requested product and return it to us. Let's follow these steps to get started with our example:</p>
<ol>
<li>Let's build a simple spawn system for NPCs using the Factory Method as our base. But before we do that, we need to declare our general NPC type. The best way to do this in code is to have a standard interface for all our NPC characters. For reasons of simplicity, all of our NPCs entities will have a common functionality; they can speak scripted dialogue:</li>
</ol>
<pre style="padding-left: 60px">public interface INPC<br/>{<br/>   void Speak();<br/>}</pre>
<ol start="2">
<li>Now that we have a standard interface for NPCs called <kbd>INPC</kbd>, we need concrete classes for each type of NPC that we might want to spawn. We will limit ourselves to the typical characters we might find in a farming village in a classical RPG game:</li>
</ol>
<ul>
<li style="padding-left: 30px">First is our <kbd>Beggar</kbd>, who begs for precious coins:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Beggar : INPC<br/>{<br/>    public void Speak()<br/>    {<br/>        Debug.Log("Do you have some change to spare?");<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px">Then there's our <kbd>Shopowner</kbd>, who's always ready to sell us some goods:</li>
</ul>
<pre class="mce-root" style="padding-left: 60px">using UnityEngine;<br/><br/>public class Shopowner : INPC<br/>{<br/>    public void Speak()<br/>    {<br/>        Debug.Log("Do you wish to purchase something?");<br/>    }<br/>}</pre>
<ul>
<li style="padding-left: 30px">Finally, we have our <kbd>Farmer</kbd>, with their words of wisdom:</li>
</ul>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Farmer : INPC<br/>{<br/>    public void Speak()<br/>    {<br/>        Debug.Log("You reap what you sow!");<br/>    }<br/>}</pre>
<ol start="3">
<li>So, now that we have concrete classes for each of our main NPC types, we need a way to refer to them when we need to. Let's write a public <kbd>enum</kbd> that will be easily accessible. We will disclose a list of available NPC types:</li>
</ol>
<pre style="padding-left: 60px">public enum NPCType<br/>{<br/>    Farmer,<br/>    Beggar,<br/>    Shopowner<br/>}</pre>
<ol start="4">
<li>The next step is to implement our <kbd>NPCFactory</kbd> class with a public Factory Method that will create the requested instance (product) of an NPC:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class NPCFactory : MonoBehaviour<br/>{<br/>    public INPC GetNPC(NPCType type)<br/>    {<br/>        switch (type)<br/>        {<br/>            case NPCType.Beggar:<br/>                INPC beggar = new Beggar();<br/>                return beggar;<br/>            case NPCType.Farmer:<br/>                INPC farmer = new Farmer();<br/>                return farmer;<br/>            case NPCType.Shopowner:<br/>                INPC shopowner = new Shopowner();<br/>                return shopowner;<br/>        }<br/>        return null;<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As we can see, our concrete implementation of the Factory Method is a function named <kbd>GetNPC()</kbd>, which is composed of a switch case that returns an <kbd>INPC</kbd> instance of a specified <kbd>NPCType</kbd>.</p>
<ol start="5">
<li>But the benefits of this design are evident in our client, which, in this example, will be our <kbd>NPCSpawner</kbd> class:</li>
</ol>
<pre class="mce-root" style="padding-left: 60px">using UnityEngine;<br/><br/>public class NPCSpawner : MonoBehaviour<br/>{<br/>    public NPCFactory m_Factory;<br/><br/>    private INPC m_Farmer;<br/>    private INPC m_Beggar;<br/>    private INPC m_Shopowner;<br/>    <br/>    public void SpawnVillagers()<br/>    {<br/>        /** <br/>        We don't want to specify the class to instiate for each type <br/>        of villager.<br/>        Instead, we ask the factory to "manufacture" it for us.<br/>        **/<br/><br/>        m_Beggar = m_Factory.GetNPC(NPCType.Beggar);<br/>        m_Farmer = m_Factory.GetNPC(NPCType.Farmer);<br/>        m_Shopowner = m_Factory.GetNPC(NPCType.Shopowner);<br/><br/>        m_Beggar.Speak();<br/>        m_Farmer.Speak();<br/>        m_Shopowner.Speak();<br/>    }<br/>}</pre>
<ol start="6">
<li>We can test this implementation of the Factory Method and the <kbd>NPCSpawner</kbd> with the following test class:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Client : MonoBehaviour<br/>{<br/>    public NPCSpawner m_SpawnerNPC;<br/><br/>    public void Update()<br/>    {<br/>        if (Input.GetKeyDown(KeyCode.S))<br/>        {<br/>            m_SpawnerNPC.SpawnVillagers();<br/>        }<br/>    }<br/> }</pre>
<p>We are now able to spawn instances of a specific NPC without having to know the location or the exact name of its concrete class. It might not look impressive when dealing with just three basic types, but imagine if every type of NPC had a different initializing process with multiple dependencies.</p>
<p>For example, imagine a circumstance in which the <kbd>Beggar</kbd> NPC is not a character but a behavior component that can be attached to any civilian character in our scene, while the <kbd>Farmer</kbd> NPC type is a self-contained prefab. With a Factory Method, we don't have to keep in mind all of these specifications every time we want to spawn a specific NPC; instead, we let the Factory Method do the dirty work for us and decide the best way to create those particular entities.</p>
<div class="packt_infobox">Choosing between using an abstract or an interface when implementing a common parent for a specific family of objects can be daunting. In this example, I decided to go with an interface because I didn't want to share implementations <span>– I wanted to </span>declare a group type.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we were introduced to the core principles of the Factory pattern and implemented its first variation, the Factory Method. With this pattern, we can localize the creation process of types of objects. This might be fine and dandy, but what happens if we want complex products that combine various kinds of objects each with their specific creation method? Are we going to need to know and call each factory separately and assemble them manually?<br/>
<br/>
This issue is what we are going to solve in the next chapter by implementing a more advanced version of the Factory pattern; the <strong>Abstract Factory</strong>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<div class="packt_tip">When you analyze the usefulness of a design pattern, always keep in mind that they are designed for teamwork. The Factory is a perfect example of this. As a solo developer, you might find most design patterns redundant, but imagine yourself working on a massive code base with dozens of programmers. In that case, layers of abstractions and common interfaces can help you maintain your sanity as your team and code base grows.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Practice</h1>
                </header>
            
            <article>
                
<p class="mce-root">In the previous chapter, we learned how to design a spawn system by using the Prototype pattern as our base. Due to this, our system behaved basically like a Xerox machine; it made copies of existing instances. This mechanism reduced the initialization overhead, but this was only beneficial if we already had a reference in memory to copy.<br/>
<br/>
But now, we have the Factory Method in our toolkit; we can localize the process of creating new objects of certain types. What would be interesting to try is combining both. Could you have the Factory Method check if an instance of that type of object already exists in memory?<br/>
<br/>
Combining patterns is a good exercise and will give you a broader range of approaches to complex implementations.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><span><em>Game Programming Patterns</em> by Robert Nystrom: <a href="http://gameprogrammingpatterns.com/">http://gameprogrammingpatterns.com</a></span></li>
<li><span><em>Design Patterns: Elements of Reusable Object-Oriented Software</em> by Erich Gamma, John Vlissides, Ralph Johnson, and Richard Helm: <a href="http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610">http://www.informit.com/store/design-patterns-elements-of-reusable-object-oriented-9780201633610</a></span></li>
</ul>


            </article>

            
        </section>
    </body></html>