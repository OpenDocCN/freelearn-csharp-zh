["```cs\nasync { <expression>... } \n\n```", "```cs\nopen System \nopen System.Net \nopen System.IO \nopen Microsoft.FSharp.Control.WebExtensions \n\nlet urlList = [ \"Microsoft.com\", \"http://www.microsoft.com/\"  \n                \"MSDN\", \"http://msdn.microsoft.com/\"  \n                \"Bing\", \"http://www.bing.com\" \n              ] \n\nlet fetchAsync(name, url:string) = \n    async {  \n        try  \n            let uri = new System.Uri(url) \n            let webClient = new WebClient() \n            let! html = webClient.AsyncDownloadString(uri) \n            printfn \"Read %d characters for %s\" html.Length name \n        with \n            | :? IOException as ex -> printfn \"IO Exception: %s\" (ex.Message); \n            | :? System.Net.HttpListenerException as httplistenerexn -> printfn \"IO Exception: %s\" (httplistenerexn.Message); \n            | genex -> printfn \"General Exception: %s\" (genex.Message); \n    } \n\nlet runAll() = \n    urlList \n    |> Seq.map fetchAsync \n    |> Async.Parallel  \n    |> Async.RunSynchronously \n    |> ignore \n\nrunAll() \n\n```", "```cs\n// let just stores the result as an asynchronous operation. \nlet (result1 : Async<byte[]>) = stream.AsyncRead(bufferSize) \n// let! completes the asynchronous operation and returns the data. \nlet! (result2 : byte[])  = stream.AsyncRead(bufferSize) \n\n```", "```cs\nopen System.Data \nopen System.Data.SqlClient \n\nlet UseBangSample (dbconstring: string) = \n    async { \n        use dbCon = new SqlConnection(dbconstring) \n        use sqlCommand = new SqlCommand(\"SELECT * FROM INFORMATION_SCHEMA.TABLES\") \n        use! dataReader = Async.AwaitTask(sqlCommand.ExecuteReaderAsync(CommandBehavior.Default)) \n        printfn \"Finished querying\" \n    } \n\n```", "```cs\n.method public static class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> \n        UseBangSample(string dbconstring) cil managed \n{ \n  // Code size       21 (0x15) \n  .maxstack  5 \n  .locals init ([0] class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder builder@) \n  IL_0000:  nop \n  IL_0001:  call       class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder [FSharp.Core]Microsoft.FSharp.Core.ExtraTopLevelOperators::get_DefaultAsyncBuilder() \nIL_0006:  stloc.0 \n  IL_0007:  ldloc.0 \n  IL_0008:  ldarg.0 \nIL_0009:  ldloc.0 \nIL_000a:  newobj     instance void Program/UseBangSample@10::.ctor(string, \n                                                                     class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder) \n  IL_000f:  callvirt   instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Delay<class [FSharp.Core]Microsoft.FSharp.Core.Unit>(class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<class [FSharp.Core]Microsoft.FSharp.Core.Unit,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!0>>) \nIL_0014:  ret \n} // end of method Program::UseBangSample \n\n```", "```cs\n.method public strict virtual instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<class [FSharp.Core]Microsoft.FSharp.Core.Unit> \n        Invoke(class [FSharp.Core]Microsoft.FSharp.Core.Unit unitVar) cil managed \n{ \n  // Code size       35 (0x23) \n  .maxstack  8 \n  IL_0000:  nop \nIL_0001:  ldarg.0 \n  IL_0002:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Program/UseBangSample@10::builder@ \nIL_0007:  ldarg.0 \n  IL_0008:  ldfld      string Program/UseBangSample@10::dbconstring \nIL_000d:  newobj     instance void [System.Data]System.Data.SqlClient.SqlConnection::.ctor(string) \n  IL_0012:  ldarg.0 \n  IL_0013:  ldfld      class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder Program/UseBangSample@10::builder@ \n  IL_0018:  newobj     instance void Program/'UseBangSample@11-1'::.ctor(class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder) \n  IL_001d:  callvirt   instance class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!1> [FSharp.Core]Microsoft.FSharp.Control.FSharpAsyncBuilder::Using<class [System.Data]System.Data.SqlClient.SqlConnection,class [FSharp.Core]Microsoft.FSharp.Core.Unit>(!!0, \n                                                                                                                                                                                                                                                                     class [FSharp.Core]Microsoft.FSharp.Core.FSharpFunc`2<!!0,class [FSharp.Core]Microsoft.FSharp.Control.FSharpAsync`1<!!1>>) \n  IL_0022:  ret \n} // end of method UseBangSample@10::Invoke \n\n```", "```cs\nopen System.Windows.Forms \n\nlet bufferData = Array.zeroCreate<byte> 100000000 \n\nlet asyncChild filename = \n        async { \n            printfn \"Child job start: %s\" filename \n            use outputFile = System.IO.File.Create(filename) \n            do! outputFile.AsyncWrite(bufferData) \n            printfn \"Child job end: %s \" filename \n        } \n\nlet asyncParent = \n        async { \n            printfn \"Parent job start.\" \n            let! childAsync1 = Async.StartChild(asyncChild \"longoutput1.dat\") \n            let! childAsync2 = Async.StartChild(asyncChild \"longoutput2.dat\") \n            let! result1 = childAsync1 \n            let! result2 = childAsync2 \n            printfn \"Parent job end.\" \n        } \n\nlet form = new Form(Text = \"Test Form\") \nlet button = new Button(Text = \"Start\") \nform.Controls.Add(button) \nbutton.Click.Add(fun args -> Async.Start(asyncParent) \n                             printfn \"Completed execution.\" ) \nApplication.Run(form) \n\n```", "```cs\nstatic member FromBeginEnd : (AsyncCallback * obj -> IAsyncResult) * (IAsyncResult ->'T) * ?(unit -> unit) -> Async<'T> \n\n```", "```cs\nFromBeginEnd : 'Arg1 * ('Arg1 * AsyncCallback * obj -> IAsyncResult) * (IAsyncResult ->'T) * ?(unit -> unit) -> Async<'T> \nFromBeginEnd : 'Arg1 * 'Arg2 * ('Arg1 * 'Arg2 * AsyncCallback * obj -> IAsyncResult) * (IAsyncResult ->'T) * ?(unit -> unit) -> Async<'T> \nFromBeginEnd : 'Arg1 * 'Arg2 * 'Arg3 * ('Arg1 * 'Arg2 * 'Arg3 * AsyncCallback * obj -> IAsyncResult) * (IAsyncResult ->'T) * ?(unit -> unit) -> Async<'T> \n\n```", "```cs\nmodule SocketServer = \n\n    open System.Net \n    open System.Net.Sockets \n    open System.Collections.Generic \n\n    let toIList<'T> (data : 'T array) = \n        let segment = new System.ArraySegment<'T>(data) \n        let data = new List<System.ArraySegment<'T>>() :> IList<System.ArraySegment<'T>> \n        data.Add(segment) \n        data \n\n    type Socket with  \n        member this.MyAcceptAsync() = \n            Async.FromBeginEnd((fun (callback, state) -> this.BeginAccept(callback, state)), \n                               this.EndAccept) \n        member this.MyConnectAsync(ipAddress : IPAddress, port : int) = \n            Async.FromBeginEnd(ipAddress, port, \n                               (fun (ipAddress:IPAddress, port, callback, state) -> \n                                   this.BeginConnect(ipAddress, port, callback, state)), \n                               this.EndConnect) \n        member this.MySendAsync(data : byte array, flags : SocketFlags) = \n            Async.FromBeginEnd(toIList data, flags,  \n                               (fun (data : IList<System.ArraySegment<byte>>, \n                                     flags : SocketFlags, callback, state) -> \n                                         this.BeginSend(data, flags, callback, state)), \n                               this.EndSend) \n        member this.MyReceiveAsync(data : byte array, flags : SocketFlags) = \n            Async.FromBeginEnd(toIList data, flags,  \n                               (fun (data : IList<System.ArraySegment<byte>>, \n                                     flags : SocketFlags, callback, state) -> \n                                         this.BeginReceive(data, flags, callback, state)), \n                               this.EndReceive) \n\n```", "```cs\n    let port = 11000 \n\n    let socket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp) \n    let ipHostInfo = Dns.Resolve(Dns.GetHostName()) \n    let localIPAddress = ipHostInfo.AddressList.[0] \n    let localEndPoint = new IPEndPoint(localIPAddress, port) \n    socket.Bind(localEndPoint) \n\n    let connectSendReceive (socket : Socket) = \n        async { \n            do! socket.MyConnectAsync(ipHostInfo.AddressList.[0], 11000) \n            let buffer1 = [| 0uy .. 255uy |] \n            let buffer2 = Array.zeroCreate<byte> 255 \n            let flags = new SocketFlags() \n            let! flag = socket.MySendAsync(buffer1, flags) \n            let! result = socket.MyReceiveAsync(buffer2, flags) \n            return buffer2 \n        } \n\n```", "```cs\nopen System.Windows.Forms \nopen System.IO \n\nlet filename = \"longoutput.dat\" \n\nif File.Exists(filename) then File.Delete(filename) \nlet watcher = new FileSystemWatcher(Directory.GetCurrentDirectory(), filename, NotifyFilter = NotifyFilters.LastWrite) \nwatcher.Changed.Add <| fun args -> printfn \"The file %s is changed.\" args.Name \nwatcher.EnableRaisingEvents <- true \n\nlet async2 filename =  \n    async {  \n        printfn \"Waiting for file system watcher notification.\" \n        // If you omit the call to AwaitEvent, an exception is thrown that indicates that the \n        // file is locked. \n        let! _args = Async.AwaitEvent(watcher.Changed) \n        printfn \"Attempting to open and read file %s.\" filename \n        use inputFile = File.OpenRead(filename) \n        let! buffer = inputFile.AsyncRead(100000000) \n        printfn \"Successfully read file %s.\" filename \n        return buffer \n    } \n\n```", "```cs\nstatic member Ignore : Async<'T> -> Async<unit> \n\n```", "```cs\nSleep : int -> Async<unit> \n\n```", "```cs\nAsync.Sleep(100) \n\n```", "```cs\n#if FSHARP_CORE_NETCORE_PORTABLE \n        static member Sleep(dueTime : int) : Async<unit> =  \n            // use combo protectedPrimitiveWithResync + continueWith instead of AwaitTask so we can pass cancellation token to the Delay task \n            unprotectedPrimitiveWithResync ( fun ({ aux = aux} as args) -> \n                let mutable edi = null \n\n                let task =  \n                    try  \n                        Task.Delay(dueTime, aux.token) \n                    with exn -> \n                        edi <- ExceptionDispatchInfo.RestoreOrCapture(exn) \n                        null \n\n                match edi with \n                | null -> TaskHelpers.continueWithUnit(task, args) \n                | _ -> aux.econt edi \n            ) \n#else \n        static member Sleep(dueTime) : Async<unit> = \nunprotectedPrimitiveWithResync (fun ({ aux = aux } as args) -> \nlet timer = ref (None : Timer option) \n                let savedCont = args.cont \n                let savedCCont = aux.ccont \n                let latch = new Latch() \n                let registration = \n                    aux.token.Register( \n                        (fun _ -> \n                            if latch.Enter() then \n                                match !timer with \n                                | None -> () \n                                | Some t -> t.Dispose() \n                                aux.trampolineHolder.Protect(fun () -> savedCCont(new OperationCanceledException())) |> unfake \n                            ), \n                        null) \n                let mutable edi = null \n                try \n                    timer := new Timer((fun _ -> \n                                        if latch.Enter() then \n                                            registration.Dispose() \n                                            match !timer with \n                                            |  None -> () \n                                            |  Some t -> t.Dispose() \n                                            aux.trampolineHolder.Protect (fun () -> savedCont()) |> unfake), \n                                     null, dueTime=dueTime, period = -1) |> Some \n                with exn -> \n                    if latch.Enter() then  \n                        edi <- ExceptionDispatchInfo.RestoreOrCapture(exn) // post exception to econt only if we successfully enter the latch (no other continuations were called) \n\n                match edi with  \n                | null -> \n                    FakeUnit \n                | _ -> \n                    aux.econt edi \n                ) \n#endif \n\n```", "```cs\nopen System \nopen System.Data \nopen System.Data.SqlClient \nopen System.Threading \nopen System.Threading.Tasks \n\nlet UseBangCancellationSample (dbconstring: string, tokenSource:CancellationTokenSource) = \n    async { \n        use dbCon = new SqlConnection(dbconstring) \n        use sqlCommand = new SqlCommand(\"SELECT * FROM INFORMATION_SCHEMA.TABLES\") \n        use! dataReader = Async.AwaitTask(sqlCommand.ExecuteReaderAsync(CommandBehavior.Default, tokenSource.Token)) \n        printfn \"Finished querying\" \n    } \n\n```", "```cs\nlet async1 = \nasync { \n   use outputFile = System.IO.File.Create(\"longoutput.dat\") \n  do! outputFile.AsyncWrite(bufferData)  \n} \n\n[<EntryPoint>] \n[<STAThread>] \nlet main argv =  \n    let form = new Form(Text = \"Test Form\") \n    let button = new Button(Text = \"Start\") \n    form.Controls.Add(button) \n    button.Click.Add(fun args -> let task = Async.StartAsTask(async1) \nprintfn \"Do some other work...\" \ntask.Wait() \nprintfn \"done\") \n    form.Show() \n    Application.Run(form) \n\n```", "```cs\nSystem.InvalidOperationException: Starting a second message loop on a single thread is not a valid operation. Use Form.ShowDialog instead. \n\n```", "```cs\nopen System.Data \nopen System.Data.SqlClient \n\nlet UseBangSample (dbconstring: string) = \n    async { \n        use dbCon = new SqlConnection(dbconstring) \n        use sqlCommand = new SqlCommand(\"SELECT * FROM INFORMATION_SCHEMA.TABLES\") \n use! dataReader = Async.AwaitTask(sqlCommand.ExecuteReaderAsync(CommandBehavior.Default)) \n        printfn \"Finished querying\" \n    } \n\n```"]