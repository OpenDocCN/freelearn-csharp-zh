<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Pluggable Protocols in .NET Core</h1>
                </header>
            
            <article>
                
<p>In the previous chapters, we covered a wide breadth of topics related to general network programming concepts, challenges, and patterns. With this chapter, we'll see how to work on that knowledge to define our own application layer protocols within .NET Core. We'll learn about the concept of a <strong>pluggable protocol</strong>. We'll see how .NET Core gives you the ability to extend the <kbd>WebRequest</kbd> class to define your own standards and expectations for network interactions. We'll look at how to register your new protocol for use by the <kbd>WebRequest</kbd> factory methods. Finally, we'll discuss the advantages of doing so, and when you should consider using it.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>Understanding pluggable protocols</li>
<li>How to implement a sub-class of the <kbd>WebRequest</kbd> class from the <kbd>System.Net</kbd> namespace</li>
<li>The support infrastructure, which allows custom communication protocols to be leveraged in .NET Core</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p>To follow along with the code samples in this chapter, or open them up and modify them for your own purposes, you'll need an IDE or code editor (Visual Studio or Visual Studio Code, of course) as well as the source code, which can be found here: <a href="https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2017"><span>https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter 17</span></a><span>.</span><a href="https://github.com/PacktPublishing/Hands-On-Network-Programming-with-C-and-.NET-Core/tree/master/Chapter%2017"/></p>
<p>Additionally, we'll continue to take advantage of our preferred REST client, so be ready with either PostMan<span> (</span><a href="https://www.getpostman.com/downloads/">https://www.getpostman.com/downloads/</a>) or the Insomnia REST client <a href="https://www.getpostman.com/downloads/">(</a><a href="https://insomnia.rest/">https://insomnia.rest/</a><a href="https://www.getpostman.com/downloads/">)</a><a href="https://insomnia.rest/">.</a><a href="https://insomnia.rest/"/></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Understanding pluggable protocols</h1>
                </header>
            
            <article>
                
<p>To understand how best to leverage pluggable protocols, and when they might be valuable in your software, we first have to understand what they are. We need to know the problems they were designed to solve and how they seek to solve them. So, we'll start with a simple definition of what pluggable protocols are, and then look at why we might want to use them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">What exactly is a pluggable protocol?</h1>
                </header>
            
            <article>
                
<p>A <strong>pluggable protocol</strong> is an implementation of a custom, application-layer communication protocol, written to be integrated with the .NET Core <kbd>WebRequest</kbd> model for processing network interactions. Or, put more simply, it's a how .NET Core supports non-standard communication protocols. That's it.</p>
<p>In <a href="b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml" target="_blank">Chapter 5</a><em>, Generating Network Requests with C#</em>, we saw how powerful the simple request/response pattern can be for facilitating source-agnostic network communications in our app. Moreover, we saw how well the .NET Core framework reduces the complexity of those kinds of interactions by supporting out-of-the-box <kbd>WebRequest</kbd> sub-classes to support the most common application-layer protocols in our source code. However, where the framework itself provides us with out-of-the-box implementations of common protocols, the pluggable protocols implementation pattern gives us an entry point through which we can extend that system for less-common, or custom, protocols. It gives us the ability to define our own implementations and configure them to be used just as easily and reliably as the framework classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Why use pluggable protocols?</h1>
                </header>
            
            <article>
                
<p>Let's imagine for a second that you want to streamline communication between two critical resources in your software ecosystem. To facilitate this, you've devised a highly optimized packet structure and interaction mechanism. The headers are only exactly as large as is necessary to communicate details about the proprietary application packets. Let's also assume that this protocol uses a brief negotiation phase that takes place between hosts to facilitate data transfer. </p>
<p>Since this is proprietary, you could just hand-roll your interactions between the two hosts in each of their respective applications. However, this approach doesn't exactly scale with the potential growth of users of your protocol. What if another team decides that they also want to leverage your optimized protocol? You'd be responsible for communicating the specific details of your program's interactions with them, introducing a time and productivity cost to anyone involved in the knowledge transfer process.</p>
<p>Alternatively, how durable would such an approach be against turnover on your own teams? If you lose original members of your team that had intimate knowledge of your protocol's design and use, you'll need to on-board new team members to fill the gaps. Having to code a proprietary interaction mechanism between two network hosts increases the time to on-board new members.</p>
<p>What if, instead of requiring the use of bespoke interaction mechanisms for any consumers of your protocol, you could encapsulate it behind a pattern with which new users are already familiar? With pluggable protocols, you can do exactly that. The only prerequisite to leveraging the conventions and simplicity of the <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> classes is that the interactions of your protocol can be reduced, at their most basic conceptual level, to the well-understood request/response pattern.</p>
<p>By encompassing the operations of our custom protocol behind the conventions of the <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> classes, we can mitigate all of the challenges introduced by a proprietary protocol. New teams no longer have to be concerned with the intricacies of your header structure, or figure out the handshake that's necessary to initiate a data transfer. You can simply implement those components within your custom <kbd>WebRequest</kbd> subclass, and expose the resulting data stream after you've successfully acquired a response. Additionally, on-boarding new team members requires no additional overhead in learning the intricacies of your protocol. </p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining a pluggable protocol</h1>
                </header>
            
            <article>
                
<p>While it may be obvious what benefits you'll reap by encapsulating custom communication protocols, behind the <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> classes, you might be surprised to learn that it's also a fairly simple goal to achieve. The biggest challenge you'll face is simply learning the methods and properties you'll need to override or implement as you create your subclass. But, at a high level, creating a pluggable protocol is fairly straightforward. Let's look at the steps you'll need to follow, and then we'll take those steps in the next section as we implement our own pluggable protocol.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining your schema</h1>
                </header>
            
            <article>
                
<p>As I mentioned earlier in this section, pluggable protocols represent a custom application-layer protocol for web interactions. Requests that are sent between two applications over this protocol will need to be handled in a unique way. To distinguish requests that are transmitted over your custom protocol from other, more common protocols, you'll need to define the schema for it.</p>
<p>As you may remember from <a href="ec4ace03-62c3-4f7f-be9e-6a54f0438e57.xhtml" target="_blank">Chapter 2</a>, <em>DNS and Resource Location</em>, the schema component of a URL is how routers and web hosts determine how to attempt to parse headers of request packets. Using the <kbd>http</kbd> or <kbd>https</kbd> schemas indicates to the recipient host that the message details can be derived by parsing the incoming byte stream according to the partitioning and delineating standards of an HTTP header. So, a host receiving a request with the schema specified as <kbd>http://</kbd> in the request URI will expect the first bytes of the incoming stream to specify the HTTP verb, the specific resource path, and the version, followed by a line-terminal character, like so:</p>
<pre>GET /some/resource HTTP/1.1</pre>
<p>However, suppose your protocol is designed to do away with those HTTP-specific message details. Let's say you're designing a message queue that accepts an arbitrary number of records with fields of a single fixed length. Now, let's say that the request messages for your protocol are formatted with a header composed of pipe-delimited values noting various details about the structure of the packet, such as the 0-indexed packet length, the number of optional details specified in the headers, and the byte-size of each field in the records of your message, so that your message header looks like this:</p>
<pre>512|1|32</pre>
<p>If you sent a message using the <kbd>http://</kbd> schema and its first line of incoming bytes contained those details, the consuming application would simply respond with a <kbd>401 - Bad Request</kbd> status. It wouldn't be able to parse the information in the header because it wouldn't have the proper context for doing so. That's what a schema provides to remote hosts: the initial context for parsing its messages. To that end, it's important that you define a schema that you're certain will be unique from other custom protocols or schemas (and certainly distinct from any standardized protocols, such as HTTP or FTP). Your schema will need to be uniquely identifiable so that there's no failure <span>to parse your messages on</span><span> any hosts that leverage it.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing your protocol interactions</h1>
                </header>
            
            <article>
                
<p>As I've alluded to at least a few times in this section, your first task for implementing your protocol as a pluggable protocol is to encapsulate its interactions into the most basic request/response pattern. You'll need to do this inside a class that defines itself as a sub-class of the <kbd>WebRequest</kbd> base class. Within this sub-class, your first order of business will be to override the <kbd>GetResponse()</kbd> and <kbd>GetResponseAsync()</kbd> methods.</p>
<p>These methods are where you'll be defining any protocol-specific interactions for your custom <kbd>WebRequest</kbd>, including defining the transport layer over which your messages will be sent, and any protocol header parsing that should happen prior to your clients receiving the response stream. When you intend to create a sub-class of the <kbd>WebRequest</kbd> object, writing your own implementations of these classes is the minimum required step you'll need to take in order to write a conventional pluggable protocol.</p>
<p>If your protocol specification has any additional features or aspects that you need to account for, such as authentication mechanisms, or response caching, you'll need to override those aspects of the <kbd>WebRequest</kbd> class as well. Additionally, anything that isn't captured by the public interface of the <kbd>WebRequest</kbd> class that is specific to your protocol will need to be exposed through some methods or properties that are specific to your protocol.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Registering your schema</h1>
                </header>
            
            <article>
                
<p>Now that you understand how we can distinguish incoming messages from our protocol from those of other application-layer protocols, you'll need to notify your application context to do so. Once you've defined your schema, you can register a handler with the <kbd>WebRequest</kbd> class.</p>
<p>You might remember from <a href="b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml" target="_blank">Chapter 5</a><em>, Generating Network Requests in C#</em>, in the <em>The Sub-Classes of WebRequest </em><span>section</span>, I mentioned that the <kbd>WebRequest</kbd> create method will provide default sub-class implementations for a request based on its specified schema. So, if you were to call <kbd>WebRequest.Create("http://somedomain.com")</kbd>, the <kbd>WebRequest</kbd> instance returned to you would be an instance of the <kbd>HttpWebRequest</kbd> type (though, as we already saw in that section, and throughout all of <a href="e93c024e-3366-46f3-b565-adc20317e6ec.xhtml" target="_blank">Chapter 9</a>,<em> HTTP in .NET</em>, the <kbd>HttpWebRequest</kbd> class should be considered obsolete at this point).</p>
<p>By registering our custom sub-class of the <kbd>WebRequest</kbd> class, and specifying the schema for which it should be used, we can get that same behavior. Users wouldn't need to create a specific instance of our class to use it; they could just call <kbd>WebRequest.Create(&lt;url&gt;)</kbd> and pass in a URL whose schema segment identifies our protocol. At that point, the <kbd>WebRequest</kbd> class simply returns an instance of whatever class we've specified to handle that schema.</p>
<p>Now that we know what it takes to implement and incorporate a pluggable protocol in our .NET Core apps, it's time to see it in action.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Building our custom subclasses</h1>
                </header>
            
            <article>
                
<p>The first thing we'll want to do is define the interaction mechanisms for our custom protocol. These interactions will be how we distinguish our protocol from alternative application-layer protocols. You might recall when I said in <a href="ec99753c-1004-4a9f-b651-8d4bb467a879.xhtml" target="_blank">Chapter 10</a>, <em>FTP and SMTP</em>, that each application-layer protocol is designed to optimize a specific business-layer application task. This principle should hold true with any custom protocols you've implemented as well. To that end, we'll define our protocol to meet a very specific business need. Of course, since this is still entirely for demonstration purposes, we won't concern ourselves with whether or not it's the most optimum design for our business need, but only that it is well-defined in its interactions. Once we have that in place, we can implement that specification within our <kbd>WebRequest</kbd> sub-class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Defining our protocol</h1>
                </header>
            
            <article>
                
<p>For the demonstrations in this chapter, we'll be using a new protocol optimized for sending a list of records to a database server. Because we can call our protocol whatever we want, and I find it amusing to do so, we'll call it the <strong>DwayneTheRockJohnson</strong> protocol, or just the <strong>Rock</strong> protocol for short, and it will use <kbd>dtrj://</kbd> as its schema specification in request URIs.</p>
<p>Request messages in our protocol will be sent, targeting a specific table in a database, and will have a body consisting of an arbitrary number of updates to make to that table. We'll define three verbs for requests in our protocol: DELETE, INSERT, and UPDATE. A request message that's sent with any given verb can only perform the specified update on the table, and the records in the body will consist of an array of pipe-delimited fields. For our purposes, our message header will consist of pipe-delimited fields in the following format:</p>
<ul>
<li><strong>VERB</strong>: A 2-bit verb indicator: <kbd>00 = DELETE</kbd>, <kbd>01 = INSERT</kbd>, <kbd>10 = UPDATE</kbd>.</li>
<li><strong>SIZE</strong>: A 30-bit field indicating the total size of the message, including all header values, in bytes (providing for a maximum size of 13<span>4</span> <span>MB</span> messages).</li>
<li><strong>FIELDS</strong>: A 28-byte field indicating how many fields are in each record, allowing for a maximum field count greater than could ever possible be reached by any existing database system. We're only choosing that for a consistent alignment of our headers against the typical word length of 16 bits.</li>
<li><strong>CHECKSUM</strong>: A 32-byte secure hash of the message body, to prevent tampering.</li>
</ul>
<p>After this 64-byte header, the rest of the body is presumed to be a sequence of pipe-delimited records, which our target hosts will be able to parse based on the <strong>FIELDS</strong> value of the header, and the convention of the pipe-delimiter. Taken together, the structure of our Rock message will look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-947 image-border" src="assets/3f082c2e-ff16-48df-a395-9229e177fb03.png" style="width:21.75em;height:9.83em;"/></p>
<p>When a server has successfully received a message, its response, assuming everything was processed accordingly, will include the following headers:</p>
<ul>
<li><strong>STATUS</strong>: A 2-bit message indicating the success of the update attempt against the data source: <kbd>00 = SUCCESS</kbd>, <kbd>01 = PARTIAL SUCCESS</kbd>, and <kbd>10 = FAILURE</kbd></li>
<li><strong>TIMESTAMP</strong>: A 14-bit timestamp indicating when the updates were successfully committed to the database</li>
<li><strong>SIZE</strong>: A 16-bit field indicating the size of the message included, along with the rest of the response</li>
</ul>
<p>This 32-bit header will be followed by any status message that's included along with the status code provided in the header, which may include information about which records were successfully updated, or why some or all records failed to update. With this, our response will look like this:</p>
<p class="CDPAlignCenter CDPAlign"><img class="alignnone size-full wp-image-948 image-border" src="assets/0bcb8e7a-4767-4a07-991d-5b5a55766edd.png" style="width:20.42em;height:5.50em;"/></p>
<p>There would obviously be a lot more thought to defining a communication protocol than what we've put forth here, but this will be sufficient for the purposes of learning how to implement them in our .NET Core projects. So, now that we know what our schema definition will look like, and how our protocols should be composed and parsed, let's get to work defining our <kbd>WebRequest</kbd> sub-class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing our protocol</h1>
                </header>
            
            <article>
                
<p>Our first order of business will be creating a <kbd>WebRequest</kbd> subclass with a constructor that accepts a <kbd>URI</kbd> instance, or a simple URI string as its input. This is what's used by the <kbd>WebRequest.Create()</kbd> method to instantiate our specific class whenever it is given a URI with our schema. We'll be implementing this class in a simple console app, so first create your application:</p>
<pre><strong>dotnet new console -n CustomProtocolDemo</strong></pre>
<p>Next, create a class for our <kbd>WebRequest</kbd> subclass, and define its constructors. For this example, I'll be creating a <kbd>RockWebRequest</kbd> class, with a constructor being used to set the <kbd>URI</kbd> instance that's used when sending our request out to the target host:</p>
<pre>public class RockWebRequest : WebRequest {<br/>    public override Uri RequestUri { get; }<br/>    ...<br/><br/>    public RockWebRequest(Uri uri) {<br/>        RequestUri = uri;<br/>    }</pre>
<p>Here, it's important to note that a <kbd>WebRequest</kbd> instance (or an instance of any of its subclasses) is intended to only ever be used once. Subsequent requests require additional instances of the class. This is why the <kbd>RequestUri</kbd> field (which is derived from the parent class, but must be implemented by our subclass to be used) is read-only and only ever written to upon initialization of a new instance. It won't, and shouldn't, change after the request is created.</p>
<p>The next thing we'll need to do is give users of our <kbd>WebRequest</kbd> class a mechanism by which they can define the records being sent over, as well as the message verb to be used on those records. This will give our users an opportunity to configure their message accordingly, prior to requesting a response. To do this, we'll define a couple of properties for our header and for our request body. We could use the <kbd>Method</kbd> property that is derived from the <kbd>WebRequest</kbd> class to define our message verb, but I'd prefer to enforce things a little more strictly in our component. We'll create a new property, whose type will be an <kbd>enum</kbd> that defines our three possible verbs. Using an <kbd>enum</kbd> will also give us the benefit of mapping the user-provided value to its underlying 2-bit representation: </p>
<pre>public enum RockVerb {<br/>    Delete = 0b00000000000000000000000000000000,<br/>    Insert = 0b01000000000000000000000000000000,<br/>    Update = 0b10000000000000000000000000000000<br/>}</pre>
<p>Here, we're representing our 2-bit codes as the most significant bits of a 32-bit integer value to make it especially easy to perform a bit-wise <kbd>OR</kbd> operation with our <kbd>size</kbd> header value.</p>
<p>Next, we'll define the corresponding property on our <kbd>RockWebRequest</kbd>. Additionally, we'll define an <kbd>IEnumerable</kbd> for the records that will be sent in any given request, with an <kbd>int</kbd> to store the number of fields in each record. Since we want our protocol to handle arbitrary record definitions, but we don't want to spend too much time writing sufficient serialization code and generic object parsers, we'll just define our records to be strings, and leave it to a consumer to generate a pipe-delimited format for their record list:</p>
<pre>public RockVerb Verb { get; set; } = RockVerb.Update;<br/>public IEnumerable&lt;string&gt; Records { get; set; }<br/>public long Fields { get;set; }</pre>
<p>Here, we'll default our <kbd>Verb</kbd> to <kbd>Insert</kbd>. For the purposes of this demonstration, we'll say that <kbd>Update</kbd> operations will only work if and only if there isn't an existing record with same the key as the record to be inserted. With this rule in place, <kbd>Insert</kbd> is the only operation that is safe to perform, since it can't ever incidentally override existing data. Given that, it will suit us well for our default <kbd>Verb</kbd> value. Once this is in place, however, we're ready to implement our <kbd>GetResponse()</kbd> and <kbd>GetResponseAsync()</kbd> methods. Each other property of our header can be derived without input from the user, so we'll do so in these methods.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the request pipeline</h1>
                </header>
            
            <article>
                
<p>The next, and final, step to implement our pluggable protocol is to define the request and response behavior for our messages. We'll start by overriding the synchronous <kbd>GetResponse()</kbd> method. This method will be responsible for building a byte stream with the appropriate values for our header specification, and submitting over the transport protocol of our choice. For this demo, we'll be using TCP, since we've already seen how to do so in <a href="a4847953-41ef-48ee-aa39-75f920467992.xhtml" target="_blank">Chapter 11</a>,<em> The Transport Layer – TCP, UDP, and Multicasting</em>.</p>
<div class="packt_tip">Always put as much consideration and thought as you can into deciding what transport-layer protocol you'll use to support any custom application layer protocols you may write. The performance and specific use cases of any transport layer protocol can have as much of an impact on the performance of your custom protocol as any other aspect of your design. Always try to use the right tool for the job at hand.</div>
<p>As with all of our demonstrations, we'll be assuming that consumers of our software always use it appropriately, and so we'll forego any sort of pre-request validations. We'll just assume that we have some records configured for our message body, and that our verb has been defined appropriately.</p>
<p>At this point, it would serve us well to examine the high-level workflow of building and sending a message according to our protocol. Since we're assuming that we have records available prior to attempting to send a request (and that our server will assume the responsibility of validating our data), we'll build out our message body by concatenating each record (which our users have already conveniently serialized into pipe-delimited strings of all fields in each record), and separate each record with a pipe. Next, we'll convert the concatenated string into a byte array. From that, we'll build our checksum hash, as well as define the size of our message. Then, we'll build a completed byte array with our headers and message body, and write them to a <kbd>TcpClient</kbd> stream targeting the designated host URI.</p>
<p>Putting that into action, we'll start by generating our message byte array:</p>
<pre>public override WebResponse GetResponse() {<br/>    var messageString = ConcatenateRecords();<br/>    var message = Encoding.ASCII.GetBytes(messageString);</pre>
<p>In the following code, the actual concatenation happens in a separate, private method, to aid the readability of our code:</p>
<pre>private string ConcatenateRecords() {<br/>    StringBuilder messageBuilder = new StringBuilder();<br/>    foreach (var record in Records) {<br/>        if (messageBuilder.ToString().Length &gt; 0) {<br/>            messageBuilder.Append(Environment.NewLine);<br/>        }<br/>        messageBuilder.Append(record);<br/>    }<br/>    return messageBuilder.ToString();<br/>}</pre>
<p>As you can see, we're using the same pipe delimiter between records that we're using to separate fields in a record. We have the freedom to do this because our <kbd>fields</kbd> header notifies the server of how many individual fields should be parsed per-record. Using the same delimiter for records that we're using for fields saves the server from having to look for an exceptional case for the end of a record. It can simply look for the next instance of the delimiter character and proceed accordingly, starting a new record when the field count has been reached for the previous one.</p>
<p>Next, we'll compute our checksum based on our requests' body content. If you were truly defining your own protocol for a business purpose, you would likely allow clients to specify hashing algorithms from among those they have implementations for. However, for our purposes, we'll just say it's always going to be computed using SHA-256. Once we've computed our hash, we can set our <kbd>VERB</kbd> bits based on the value provided by the client. Next, we'll determine the size of our packet (the 64 byte header, plus the length of our message byte array), and write all of our bytes to a binary stream. In our <kbd>GetResponse()</kbd> method, that will simply read as follows:</p>
<pre>var byteList = new List&lt;byte&gt;();<br/><br/>var checksum = SHA256.Create().ComputeHash(message);<br/><br/>byteList.AddRange(GetHeaderBytes(message.Length));<br/>byteList.AddRange(checksum);<br/>byteList.AddRange(message);</pre>
<p>The <kbd>GetHeaderBytes(message.Length)</kbd> method is used to convert the binary value of our <kbd>Verb</kbd>, the given message size, and the <kbd>Fields</kbd> property, into the 32-byte header that precedes the 32 byte checksum. The method is relatively straightforward and merely applies some bit-manipulation of the appropriate values, as shown here:</p>
<pre>private IEnumerable&lt;byte&gt; GetHeaderBytes(int messageSize) {<br/>    var headerBytes = new List&lt;byte&gt;();<br/>    int verbAndSize = (int)Verb | (messageSize &gt;&gt; 2);<br/>    headerBytes.AddRange(BitConverter.GetBytes(verbAndSize));<br/><br/>    //Add empty byte padding in the FIELDS header<br/>    for (var i = 0; i &lt; 20; i++) {<br/>        headerBytes.Add(0b00000000);<br/>    }<br/><br/>    headerBytes.AddRange(BitConverter.GetBytes(Fields));<br/>    return headerBytes;<br/>}</pre>
<p>Once that header value is computed, we can apply it, followed by the checksum, followed by the byte array of our request message, to our output byte stream. Finally, since we've declared that our protocol will use TCP as its underlying transport mechanism, we'll create our <kbd>TcpClient</kbd> instance, connecting to the host and port specified by the <kbd>RequestUri</kbd> field. Once again, we'll be making a lot of assumptions about our ability to connect to the specified URI. In realistic circumstances, you'd be implementing your <kbd>TcpClient</kbd> connections with more robust error handling and connection validation, as we did in <a href="a4847953-41ef-48ee-aa39-75f920467992.xhtml" target="_blank">Chapter 11</a>, <em>The Transport Layer - TCP and UDP</em>. For now, though, we'll simply assume our connection succeeded, write our bytes to our <kbd>NetworkStream</kbd> instance, and then pass it along to our <kbd>RockWebResponse</kbd> instance, which we'll return from our method:</p>
<pre>    TcpClient client = new TcpClient(RequestUri.Host, RequestUri.Port);<br/>    var stream = client.GetStream();<br/>    stream.Write(byteList.ToArray(), 0, byteList.Count);<br/>    return new RockWebResponse(stream);<br/>}</pre>
<p>This completes our implementation of the <kbd>GetResponse()</kbd> method. Obviously, implementing the <kbd>GetResponseAsync()</kbd> method will look extremely similar in practice, but we will use the asynchronous programming patterns we established in <a href="b5d28c0a-6e7c-4547-855d-e6c6d1842bd6.xhtml" target="_blank"/><a href="b5d28c0a-6e7c-4547-855d-e6c6d1842bd6.xhtml" target="_blank">Chapter 6</a>,<em> Streams, Threads, and Asynchronous Data Transfer</em>. I'll leave it as an exercise for you to implement that specific method in our <kbd>RockWebRequest</kbd> class.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Deriving from the WebResponse class</h1>
                </header>
            
            <article>
                
<p>As you may have noticed, the <kbd>GetResponse()</kbd> method of our <kbd>RockWebRequest</kbd> returns an instance of a <kbd>RockWebResponse</kbd> class. This is the other side of the implementation coin for writing a pluggable protocol. You have to define a handler that can strip away and validate any protocol specific meta-data or header information from the response stream and store them in read-only properties in your custom <kbd>WebResponse</kbd> class, prior to returning the response stream back to the method that invoked it. One of the key benefits users will expect from your pluggable protocols is that they will abstract away all of the details of parsing and manipulating that protocol-specific information out of the response byte stream.</p>
<p>Our implementation for this demo will be extremely simple. We're only seeking to illustrate the conceptual steps you'll need to take if you undertake this task in the future. However, because of the highly specific nature of a pluggable protocol, anything more than that high-level, conceptual approach would ultimately prove futile. Given that, our full <kbd>RockWebResponse</kbd> class is as follows:</p>
<pre>public class RockWebResponse : WebResponse {<br/>    private Stream _responseStream { get; set; }<br/>    public DateTime TimeStamp { get; set; }<br/>    public RockStatus Status { get; set; }<br/>    public int Size { get; set; }<br/>        <br/>    public RockWebResponse(Stream responseStream) {<br/>        _responseStream = responseStream;<br/><br/>        byte[] header = new byte[4];<br/>        _responseStream.Read(header, 0, 4);<br/>        var isValid = ValidateHeaders(header);<br/>    }<br/><br/>    public Stream GetResponseStream() {<br/>        return _responseStream;<br/>    }<br/><br/>    private bool ValidateHeaders(byte[] header) {<br/>        //validate headers<br/>        return true;<br/>    }<br/>}</pre>
<p>The first thing we do is define public properties for each of the relevant header values that a user might be concerned with. Here, we've defined a simple <kbd>RockStatus</kbd> enum to capture our three possible status states, and we represent the timestamp header value as <kbd>DateTime</kbd>.</p>
<p>The crux of the class definition is in the constructor for it. Here, our <kbd>RockWebResponse</kbd> instance is responsible for parsing the header values out of the response stream, and populating its instance properties with their corresponding values. Note that we read the first 4 bytes from the stream, which corresponds to our 32-bit header definition. Once that's done, we pass the byte array along to our header validation function, and return our new instance (of course, in production code, you would throw an error on validation failure, instead of returning a new instance). Since we've read the header information out of our response stream prior to returning an instance to our consumers, the call to <kbd>GetResponseStream()</kbd> will return a stream containing only the response body.</p>
<p>By defining this protocol-specific response handler, we've (conceptually) completed our pluggable protocol implementation. There are a number of other methods you'll have to override if you truly want to create a valid subclass of <kbd>WebRequest</kbd>, and there is substantial information in the Microsoft documentation on specifically what is required. However, following the model we've established here, you should be in the right mindset to tackle those tasks when it becomes necessary to do so. At this point, the only thing left for us to do is expose it to other engineers through the <kbd>WebRequest</kbd> factory methods, which we'll look at in the next section.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Leveraging a custom protocol</h1>
                </header>
            
            <article>
                
<p>Defining our pluggable protocol is really about defining the protocol-specific interactions of our custom protocol in the context of the <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> paradigms. Now that we've done that, though, we have to notify the <kbd>WebRequest</kbd> class that we've satisfied the requirements for use by any consumers seeking to use our schema. That means we'll need to define a factory class that creates instances of our derived classes.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Implementing the IWebRequestCreate interface</h1>
                </header>
            
            <article>
                
<p>We want to register our class with the <kbd>WebRequest</kbd> class so that instances of <kbd>RockWebRequest</kbd> will be returned when the <kbd>WebRequest.Create(&lt;uri&gt;)</kbd> method is called with the appropriate schema. To do that, though, we'll need to provide <kbd>WebRequest</kbd> with a factory class that can build well-formed instances of our <kbd>RockWebRequest</kbd> class on demand. This behavior is defined by the <kbd>IWebRequestCreate</kbd> interface, and that's the interface we'll need to implement in our factory class to register it for use with <kbd>WebRequest</kbd>.</p>
<p>The footprint of this interface is, thankfully, extremely simple. In fact, it's only one method. Our whole implementation is fewer than a dozen lines long:</p>
<pre>public class RockWebRequestCreator : IWebRequestCreate {<br/>    public WebRequest Create(Uri uri) {<br/>        return new RockWebRequest(uri);<br/>    }<br/>}</pre>
<p>With this, though, we can register our custom protocol class for use whenever our schema shows up in a URI given to the <kbd>WebRequest.Create(&lt;uri&gt;)</kbd> method. Simply invoke the <kbd>RegisterPrefix()</kbd> method in the startup of your application:</p>
<pre>WebRequest.RegisterPrefix("dtrj", new RockWebRequestCreator());</pre>
<p>Now, your custom <kbd>WebRequest</kbd> class will be freely available to respond to URIs with the designated schema.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Going beyond WebRequest</h1>
                </header>
            
            <article>
                
<p>At the time of writing this book, the Microsoft documentation for the <kbd>WebRequest</kbd> class explicitly advises against using <kbd>WebRequest</kbd> or any of its subclasses. The recommendation is for developers writing new software to instead use <kbd>HttpClient</kbd>, or similar classes. So, what does that mean for the value or use of pluggable protocols?</p>
<p>Simply put, it means your work isn't done quite yet. As I mentioned in <a href="b2bbfe0e-f0de-49ca-a3c8-b8ced18e42bf.xhtml" target="_blank">Chapter 5</a>, <em>Generating Network Requests in C#</em>, the <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> classes still operate, in some form or other, under the hood of the <kbd>HttpClient</kbd> class. Defining your protocol interactions through these classes is still very much an essential part of implementing custom protocols in .NET Core. Deriving from these classes gives you the flexibility to parse and process application headers directly out of the <kbd>NetworkStream</kbd> of whichever transport protocol you choose to use. In fact, even the ability to specify your transport protocol is something that cannot be done with the <kbd>HttpClient</kbd> class. This sort of control over your raw protocol requests can only be leveraged with something such as <kbd>WebRequest</kbd> or <kbd>WebResponse</kbd>.</p>
<p>However, as new developers consistently move away from the conventions of <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd>, you'll need to define more modern abstractions to keep your protocol library relevant. To that end, if you find yourself needing to define custom protocol interactions, consider defining a standardized client implementation instead. Your client can (and perhaps <em>should</em>) continue to leverage a pluggable protocol derived from the <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> classes.</p>
<p>However, by defining a clean abstraction for working with those requests and responses, you present an easier-to-use, and easier-to-understand, tool for your library's users. If and when you find yourself writing any custom communication protocols, keep this in mind if you want to see it adopted by a wider audience in the .NET community.</p>
<p>With that, we can wrap up our discussion of pluggable protocols. In the next chapter, we'll continue down the path of advanced, lower-level subjects. There, we'll explore network analysis and packet sniffing strategies for a deeper understanding of the wider context your network software exists within.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>This chapter took an extremely in-depth look at the very narrow topic of pluggable protocols in .NET Core. We learned that a pluggable protocol is really just an in-framework representation of any custom, application-layer communication protocol you want to define. As we established this understanding, we considered why we should take the time to implement new communication protocols as pluggable protocols in our code. We saw how the alternative—using custom, protocol-specific code throughout our application—introduced a time and productivity cost that could be all but eliminated by simply implementing custom subclasses of the <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> classes.</p>
<p>After we established the case for <em>using</em> pluggable protocols, we looked at <em>how</em> we could do so in our own projects. We learned about the three core steps we would have to follow to implement a pluggable protocol. As we did, we learned how each step served to create a clean, convention-based abstraction for our custom protocols. Finally, we looked at how to implement the different protocols in our software. We designed our own test protocol, and then took the necessary steps to implement <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> subclasses that handled interactions for that test protocol.</p>
<p>Finally, we looked at how to incorporate our new classes directly into the <kbd>WebRequest</kbd> and <kbd>WebResponse</kbd> framework for a seamless transition for new developers, who may want to take advantage of our work. As we wrapped up, we learned about the next steps we should take to stay consistent with more modern patterns of abstracting interactions behind protocol-specific <kbd>Client</kbd> classes. In the next chapter, we'll be looking at how we can analyze the state of network interfaces and network traffic on our host machines, and what sort of applications that capability opens up for us.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Questions</h1>
                </header>
            
            <article>
                
<ol>
<li>What is a pluggable protocol?</li>
<li>What are the advantages of implementing a protocol as a pluggable protocol?</li>
<li>What steps are necessary for building a pluggable protocol in .NET Core?</li>
<li>Why is accurate schema definition important for a listening server to process a request?</li>
<li>What is the minimum footprint of <kbd>WebRequest</kbd> methods you'll have to override to implement a pluggable protocol?</li>
<li>What additional interface must you provide to register your pluggable protocol for use by the <kbd>WebRequest.Create()</kbd> method?</li>
<li>What additional steps should you take to make adoption of your pluggable protocol easier and more consistent with modern conventions?</li>
</ol>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<p><span>This being a rather niche subject in a vast framework, there isn't much to recommend in terms of further reading on the specific topic of pluggable protocols themselves. However, if you're curious to learn more about the contexts and architectures that might motivate the need for custom protocol implementation, I would recommend checking out the <em>Serverless Programming Cookbook</em> by <em>Heartin Kanikathottu</em>. Its discussion of various network interactions from cloud platform-hosted source code paints a compelling picture for new, optimized communication paradigms. It can be found from Packt, here: </span><a href="https://www.packtpub.com/application-development/serverless-programming-cookbook">https://www.packtpub.com/application-development/serverless-programming-cookbook</a><a href="https://www.packtpub.com/application-development/serverless-programming-cookbook">.</a></p>


            </article>

            
        </section>
    </body></html>