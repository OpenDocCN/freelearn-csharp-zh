<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dependency Injection in ASP.NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In </span><a href="087ee78f-87f2-49ef-bfca-ae04dfa47880.xhtml" target="_blank"><span class="koboSpan" id="kobo.3.1">Chapter 3</span></a><span class="koboSpan" id="kobo.4.1">, </span><em><span class="koboSpan" id="kobo.5.1">Introducing Dependency Injection in .NET Core 2.0</span></em><span class="koboSpan" id="kobo.6.1">, we were focusing on .NET Core exclusively, analyzing the possibilities the platform offers in relation to Dependency Injection and distinct ways to implement it. </span><span class="koboSpan" id="kobo.6.2">In this chapter, we'll continue analyzing DI, but, this time, focusing on the implementation of ASP.NET Core and the possibilities offered to the programmer at the time of configuring websites and other related functionality which spreads along the whole life cycle.</span></p>
<p><span class="koboSpan" id="kobo.7.1">The idea is to start with the CLI (command-line tools) and see how to modify a console application and turn it into a web app, so you can better understand the concept of middleware and the way it's used in ASP.NET Core.</span></p>
<p><span class="koboSpan" id="kobo.8.1">With that, we will be ready to move onto an analysis of the default templates that Visual Studio 2017 offers for ASP.NET Core apps, and the specific features linked to DI in those initial models.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Finally, we'll see how to tune up our own services and how to use them via Dependency Injection in registration options, controllers, and views.</span></p>
<p><span class="koboSpan" id="kobo.10.1">In all, we will cover the following topics in this chapter:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.11.1">Building ASP .NET Core apps using command-line tools.</span></li>
<li><span class="koboSpan" id="kobo.12.1">Middleware architecture in ASP .NET Core.</span></li>
<li><span class="koboSpan" id="kobo.13.1">Analyzing the default templates offered by Visual Studio.</span></li>
<li><span class="koboSpan" id="kobo.14.1">Features of DI in ASP.NET applications. </span><span class="koboSpan" id="kobo.14.2">Customized services.</span></li>
</ul>
<div class="packt_tip"><span class="koboSpan" id="kobo.15.1">Notice the official documentation site uses the same code as the templates offered by Visual Studio 2017. </span><span class="koboSpan" id="kobo.15.2">You can find it at </span><a href="https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc"><span class="koboSpan" id="kobo.16.1">https://docs.microsoft.com/en-us/aspnet/core/tutorials/first-mvc-app/start-mvc</span></a><span class="koboSpan" id="kobo.17.1">.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">ASP.NET Core from the command-line tools</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Once we have installed .NET Core in our boxes and updated (if necessary) to version 2.0, we can start a very simple, but explanatory, website from scratch using command-line tools and see how we can move from that minimum .NET Core Console app to an ASP.NET Core app in a few steps.</span></p>
<p><span class="koboSpan" id="kobo.3.1">This process will help you understand the profound changes in architecture that ASP.NET Core carries, and how some of the SOLID principles that we have seen are applied in a variety of ways to achieve this goal.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Thus, the first step should be to check out our installed version of .NET Core, which we can do in a command-line window (remember that Visual Studio 2017 installs several links to these windows in the Windows menu, and that the Developer Command Prompt already has environment variables defined to suit the main needs of a programmer).</span></p>
<p><span class="koboSpan" id="kobo.5.1">If you do not already have the .NET Core command-line tools installed, remember that you can do it in a separate install from the site </span><a href="https://www.microsoft.com/net/download/core"><span class="koboSpan" id="kobo.6.1">https://www.microsoft.com/net/download/core</span></a><span class="koboSpan" id="kobo.7.1"> in the </span><span class="packt_screen"><span class="koboSpan" id="kobo.8.1">Command-Line/Other</span></span><span class="koboSpan" id="kobo.9.1"> section, which lets you download the installer for all versions currently supported. </span><span class="koboSpan" id="kobo.9.2">When run, the installer should look as follows:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.10.1"><img height="329" width="443" class=" image-border" src="assets/b275b9f4-c822-417a-b523-a698ca3f9a57.png"/></span></div>
<p><span class="koboSpan" id="kobo.11.1">After installation, a new folder should appear at </span><kbd><span class="koboSpan" id="kobo.12.1">C:\Program Files\dotnet\sdk</span></kbd><span class="koboSpan" id="kobo.13.1"> named 2.0, (or whichever is the latest version available at the time).</span></p>
<p><span class="koboSpan" id="kobo.14.1">So, we can just check the current version's details with the </span><kbd><span class="koboSpan" id="kobo.15.1">dotnet -version and dotnet --info</span></kbd><span class="koboSpan" id="kobo.16.1"> commands, and see if we have version 2.0 installed:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.17.1"><img height="311" width="462" class=" image-border" src="assets/7f441d89-37a8-487c-a579-975db3284c70.png"/></span></div>
<p><span class="koboSpan" id="kobo.18.1">The window will show some basic commands, such as </span><kbd><span class="koboSpan" id="kobo.19.1">--help</span></kbd><span class="koboSpan" id="kobo.20.1"> and </span><kbd><span class="koboSpan" id="kobo.21.1">--version</span></kbd><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">To check the types of templates available for the latest version, just type </span><kbd><span class="koboSpan" id="kobo.23.1">dotnet new</span></kbd><span class="koboSpan" id="kobo.24.1"> (with no extra parameters), and you'll be presented a list of this kind:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.25.1"><img height="238" width="589" class=" image-border" src="assets/fa8e1542-c4ac-4f29-98dd-de37b409f4fa.png"/></span></div>
<div class="packt_tip"><span class="koboSpan" id="kobo.26.1">Notice that the first time you type that command it will decompress some files (it takes a few seconds), to initially populate your </span><span class="packt_screen"><span class="koboSpan" id="kobo.27.1">local package cache</span></span><span class="koboSpan" id="kobo.28.1">. </span><span class="koboSpan" id="kobo.28.2">That will only happen once, improving restore speed and enabling offline access.</span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Creating the minimum possible application</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">We have 11 default types of templates (you can install extra ones from GitHub) for as many project types, plus a solution option that creates a </span><kbd><span class="koboSpan" id="kobo.3.1">.sln</span></kbd><span class="koboSpan" id="kobo.4.1"> file including the projects inside the depending folders, and distinct options related to configuration and Web/ASP.NET solutions.</span></p>
<p><span class="koboSpan" id="kobo.5.1">To test this latest version, inside the Command Prompt, create a new folder, move to it, and just type a </span><kbd><span class="koboSpan" id="kobo.6.1">dotnet new console</span></kbd><span class="koboSpan" id="kobo.7.1"> command. </span><span class="koboSpan" id="kobo.7.2">This creates two files that define the simplest app (console app) for .NET Core.</span></p>
<p><span class="koboSpan" id="kobo.8.1">At that moment, you should see a </span><kbd><span class="koboSpan" id="kobo.9.1">program.cs</span></kbd><span class="koboSpan" id="kobo.10.1"> and a </span><kbd><span class="koboSpan" id="kobo.11.1">[NameOfDirectory].csproj</span></kbd><span class="koboSpan" id="kobo.12.1"> file, which contains dependency information for your app.</span></p>
<p><span class="koboSpan" id="kobo.13.1">Notice that previous versions used a </span><kbd><span class="koboSpan" id="kobo.14.1">project.json</span></kbd><span class="koboSpan" id="kobo.15.1"> file instead, with the same information, but if you open any previous project with V. </span><span class="koboSpan" id="kobo.15.2">Studio 2017 it will recognize it and migrate it automatically.</span></p>
<p><span class="koboSpan" id="kobo.16.1">The contents of the </span><kbd><span class="koboSpan" id="kobo.17.1">.csproj</span></kbd><span class="koboSpan" id="kobo.18.1"> file, contain a few basic directives in XML format.</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.19.1">To keep working with very basic resources in this initial demo, I'm going to use Notepad++ for code coloring and some other editing features.</span></div>
<p><span class="koboSpan" id="kobo.20.1">You should see the following content in the </span><kbd><span class="koboSpan" id="kobo.21.1">.csproj</span></kbd><span class="koboSpan" id="kobo.22.1"> file:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.23.1"><img height="219" width="442" class=" image-border" src="assets/0be4c177-7e07-4c2f-ab76-a0d51b1513af.png"/></span></div>
<p><span class="koboSpan" id="kobo.24.1">As you see, it indicates we're using the .NET SDK, the output is an </span><kbd><span class="koboSpan" id="kobo.25.1">exe</span></kbd><span class="koboSpan" id="kobo.26.1"> file, and we're targeting NET Core 2.0.</span></p>
<p><span class="koboSpan" id="kobo.27.1">The contents of our </span><kbd><span class="koboSpan" id="kobo.28.1">program.cs</span></kbd><span class="koboSpan" id="kobo.29.1"> file are as expected (no changes from a typical Console application, in a classical .NET Framework):</span></p>
<pre><span class="koboSpan" id="kobo.30.1">    class Program 
   { 
      static void Main(string[] args) 
      { 
         Console.WriteLine("Hello World!"); 
      } 
   }  </span></pre>
<p><span class="koboSpan" id="kobo.31.1">But, still, we need to download the dependencies, a task that is performed using a </span><kbd><span class="koboSpan" id="kobo.32.1">dotnet restore</span></kbd><span class="koboSpan" id="kobo.33.1"> command previous to any other options. </span><span class="koboSpan" id="kobo.33.2">After issuing that command, you'll see how it downloads all required packages, and a new </span><kbd><span class="koboSpan" id="kobo.34.1">obj</span></kbd><span class="koboSpan" id="kobo.35.1"> directory shows up.</span></p>
<p><span class="koboSpan" id="kobo.36.1">And that's it. </span><span class="koboSpan" id="kobo.36.2">You can finally issue the </span><kbd><span class="koboSpan" id="kobo.37.1">dotnet run</span></kbd><span class="koboSpan" id="kobo.38.1"> command, which, in turn, compiles and executes the app, showing the expected message in the console (nothing new, I omited the output).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Changing to ASP .NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Now, to change our application into an ASP.NET Core app, the first thing to do is to install the package called </span><kbd><span class="koboSpan" id="kobo.3.1">Microsoft.AspNetCore</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">We can do this by issuing the </span><kbd><span class="koboSpan" id="kobo.5.1">dotnet add package Microsoft.AspNetCore</span></kbd><span class="koboSpan" id="kobo.6.1"> command.</span></p>
<p><span class="koboSpan" id="kobo.7.1">When we do that, the command-line tool will download the appropriate package and modify our </span><kbd><span class="koboSpan" id="kobo.8.1">.csproj</span></kbd><span class="koboSpan" id="kobo.9.1"> accordingly, so it is included in our solution as well (see the new version of </span><kbd><span class="koboSpan" id="kobo.10.1">csproj</span></kbd><span class="koboSpan" id="kobo.11.1"> after issuing the command):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img height="290" width="657" class=" image-border" src="assets/ef2bb94e-08b9-42aa-8ff6-3a586b085d2f.png"/></span></div>
<p><span class="koboSpan" id="kobo.13.1">We see the presence of a new </span><kbd><span class="koboSpan" id="kobo.14.1">&lt;ItemGroup&gt;</span></kbd><span class="koboSpan" id="kobo.15.1"> tag, indicating the reference to include and the version that has been downloaded and added to the project.</span></p>
<p><span class="koboSpan" id="kobo.16.1">We're now ready to create our web starting now that will take the form of a class named </span><kbd><span class="koboSpan" id="kobo.17.1">Startup.cs</span></kbd><span class="koboSpan" id="kobo.18.1"> (of course you can name it as you want as long as you configure it later. </span><span class="koboSpan" id="kobo.18.2">It's not a convention name).</span></p>
<p><span class="koboSpan" id="kobo.19.1">Inside that file, we'll reference the three extra namespaces required to create a website (although a basic one):</span></p>
<ul>
<li><kbd><span class="koboSpan" id="kobo.20.1">Microsoft.AspNetCore.Builder</span></kbd><span class="koboSpan" id="kobo.21.1">: To actually build a web server using the </span><kbd><span class="koboSpan" id="kobo.22.1">config</span></kbd><span class="koboSpan" id="kobo.23.1"> parameters we've defined</span></li>
<li><kbd><span class="koboSpan" id="kobo.24.1">Microsoft.AspNetCore.Hosting</span></kbd><span class="koboSpan" id="kobo.25.1">: To hold the web application</span></li>
<li><kbd><span class="koboSpan" id="kobo.26.1">Microsoft.AspNetCore.Http</span></kbd><span class="koboSpan" id="kobo.27.1">: For all HTTP-related activities</span></li>
</ul>
<p><span class="koboSpan" id="kobo.28.1">With those references, we need to add a method named </span><kbd><span class="koboSpan" id="kobo.29.1">Configure</span></kbd><span class="koboSpan" id="kobo.30.1"> (and this is by convention), where we will indicate the minimum actions to perform when the server is launched.</span></p>
<p><span class="koboSpan" id="kobo.31.1">Here, we will start seeing DI in action, because the shape of this very basic method is as follows:</span></p>
<pre><span class="koboSpan" id="kobo.32.1">    using Microsoft.AspNetCore.Builder; 
    using Microsoft.AspNetCore.Hosting; 
    using Microsoft.AspNetCore.Http; 
 
    namespace WebApplication1 
    { 
      public class Startup 
      { 
        public void Configure(IApplicationBuilder app, </span><br/><span class="koboSpan" id="kobo.33.1">            IHostingEnvironment env) 
        { 
          if (env.IsDevelopment()) 
          { 
            app.UseDeveloperExceptionPage(); 
          } 
          app.Run(async (context) =&gt; 
          { 
            await context.Response.WriteAsync("This is a first</span><br/><span class="koboSpan" id="kobo.34.1">                  web app..."); 
          }); 
        } 
      } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.35.1">But, before we start explaining the inner details of that file, let's make sure it compiles correctly and that we redirect our application to the new website.</span></p>
<p><span class="koboSpan" id="kobo.36.1">So, we will issue another </span><kbd><span class="koboSpan" id="kobo.37.1">dotnet restore</span></kbd><span class="koboSpan" id="kobo.38.1"> command, so all new references are located properly, and the next step will be to modify our main entry point, to create a new web host that uses the </span><kbd><span class="koboSpan" id="kobo.39.1">Startup</span></kbd><span class="koboSpan" id="kobo.40.1"> class just created.</span></p>
<p><span class="koboSpan" id="kobo.41.1">With that purpose, the new </span><kbd><span class="koboSpan" id="kobo.42.1">Main()</span></kbd><span class="koboSpan" id="kobo.43.1"> entry point will use a reference to </span><kbd><span class="koboSpan" id="kobo.44.1">Microsoft.AspNetCore.Hosting</span></kbd><span class="koboSpan" id="kobo.45.1"> namespace, and define the following:</span></p>
<pre><span class="koboSpan" id="kobo.46.1">    using Microsoft.AspNetCore; 
    using Microsoft.AspNetCore.Hosting; 
 
    namespace WebApplication1 
    { 
      public class Program 
      { 
        public static void Main(string[] args) 
        { 
            BuildWebHost(args).Run(); 
        } 
 
        public static IWebHost BuildWebHost(string[] args) =&gt; 
            WebHost.CreateDefaultBuilder(args) 
                .UseStartup&lt;Startup&gt;() 
                .Build(); 
      } 
    } </span></pre>
<p><span class="koboSpan" id="kobo.47.1">Finally, we can repeat the </span><kbd><span class="koboSpan" id="kobo.48.1">dotnet run</span></kbd><span class="koboSpan" id="kobo.49.1"> command and we will see two different outputs. </span><span class="koboSpan" id="kobo.49.2">On one side, the CLI environment, we will generate a web host and run it (by default, using port number </span><kbd><span class="koboSpan" id="kobo.50.1">5000</span></kbd><span class="koboSpan" id="kobo.51.1">), indicating that in the console output:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.52.1"><img height="141" width="578" class=" image-border" src="assets/af29f757-4ed4-4201-85d3-1a87a2859dea.png"/></span></div>
<p><span class="koboSpan" id="kobo.53.1">That host will keep on running and listen on that port until we stop it using </span><em><span class="koboSpan" id="kobo.54.1">Ctrl</span></em><span class="koboSpan" id="kobo.55.1"> + </span><em><span class="koboSpan" id="kobo.56.1">C</span></em><span class="koboSpan" id="kobo.57.1">. </span><span class="koboSpan" id="kobo.57.2">Now, we can open a browser and type the URL to see the following page:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.58.1"><img height="119" width="393" class=" image-border" src="assets/e08ab7b6-8bbb-41a9-b255-a85a7d515ce5.png"/></span></div>
<p><span class="koboSpan" id="kobo.59.1">Of course, that page doesn't contain any HTML, only the text we order the server to send back to the user when a request is received on that port. </span><span class="koboSpan" id="kobo.59.2">Just take a look at the source code if you want to check this out.</span></p>
<p><span class="koboSpan" id="kobo.60.1">But, before we continue the explanation of the previous code, it's important to understand the concept of Middleware, present from the beginning in ASP.NET Core.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Middleware</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Of course, middleware refers to software, but to a software that is assembled using an application pipeline in a manner that facilitates handling requests and responses.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Obviously, you may wonder what an application pipeline is. </span><span class="koboSpan" id="kobo.3.2">Wikipedia defines the terms like this: "</span><em><span class="koboSpan" id="kobo.4.1">In software engineering, a pipeline consists of a chain of processing elements (processes, threads, coroutines, functions, etc.), arranged so that the output of each element is the input of the next; the name is by analogy to a physical pipeline</span></em><span class="koboSpan" id="kobo.5.1">".</span></p>
<p><span class="koboSpan" id="kobo.6.1">These pipelines are common in many software languages, even in modern constructions as in JavaScript Promises, which define asynchronous pipelines for a sequence of calls, improving execution control.</span></p>
<p><span class="koboSpan" id="kobo.7.1">One important feature of pipelines is that each component of the pipeline can decide whether it passes information to the next component or returns directly, and has the ability to perform custom actions before and after that component is invoked.</span></p>
<p><span class="koboSpan" id="kobo.8.1">In ASP.NET Core, to build a request pipeline, we use delegates to handle each request. </span><span class="koboSpan" id="kobo.8.2">And, again, we find some of the SOLID principles present in this architecture.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Every time you need to configure one of these delegates, you use one method belonging to the method's families called </span><kbd><span class="koboSpan" id="kobo.10.1">Use*</span></kbd><span class="koboSpan" id="kobo.11.1">, </span><kbd><span class="koboSpan" id="kobo.12.1">Run*</span></kbd><span class="koboSpan" id="kobo.13.1"> and </span><kbd><span class="koboSpan" id="kobo.14.1">Map*</span></kbd><span class="koboSpan" id="kobo.15.1"> (they are sets of predefined extension methods starting with these prefixes, each one with a specific purpose).</span></p>
<p><span class="koboSpan" id="kobo.16.1">These methods are linked to the </span><kbd><span class="koboSpan" id="kobo.17.1">IApplicationBuilder</span></kbd><span class="koboSpan" id="kobo.18.1"> object that the </span><kbd><span class="koboSpan" id="kobo.19.1">Configure</span></kbd><span class="koboSpan" id="kobo.20.1"> method receives via Dependency Injection. </span><span class="koboSpan" id="kobo.20.2">The following schema visually explains this structure (notice that the thread of execution follows the black arrows):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.21.1"><img height="392" width="543" src="assets/e904ea53-abd1-4178-941b-77b86fa9fec2.png"/></span></div>
<p><span class="koboSpan" id="kobo.22.1">In this manner, it's totally up to the programmer to keep on passing the </span><kbd><span class="koboSpan" id="kobo.23.1">IApplicationBuilder</span></kbd><span class="koboSpan" id="kobo.24.1"> object to another middleware piece (notice the call to </span><kbd><span class="koboSpan" id="kobo.25.1">next()</span></kbd><span class="koboSpan" id="kobo.26.1">) or avoid any other call, in which case it returns to the calling method.</span></p>
<p><span class="koboSpan" id="kobo.27.1">If one of these delegates decides not to pass a request to the next delegate, that's called </span><strong><span class="koboSpan" id="kobo.28.1">short-circuiting</span></strong><span class="koboSpan" id="kobo.29.1"> the request pipeline. </span><span class="koboSpan" id="kobo.29.2">This is often convenient to avoid having to perform any unnecessary work.</span></p>
<p><span class="koboSpan" id="kobo.30.1">In the case of exception handling delegates, they need to be called early in the pipeline, to allow them to catch exceptions that might occur later in the sequence.</span></p>
<p><span class="koboSpan" id="kobo.31.1">Let's go now for the explanation of the previous code with all this in mind.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Startup class and Dependency Injection</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The </span><kbd><span class="koboSpan" id="kobo.3.1">Startup</span></kbd><span class="koboSpan" id="kobo.4.1"> class coded previously is, therefore, the component in charge of configuring the request pipeline and handling all requests made to the application.</span></p>
<p><span class="koboSpan" id="kobo.5.1">This class is mandatory (although, as mentioned, it could be named differently) because the runtime will look inside it for the methods that take care of configuration aspects, and that includes services as well. </span><span class="koboSpan" id="kobo.5.2">You can consider it as a convenient way to achieve independent configurations via the first SOLID principle (SoC).</span></p>
<p><span class="koboSpan" id="kobo.6.1">One of the interesting features linked to this separation of responsibility is that you can define distinct </span><strong><span class="koboSpan" id="kobo.7.1">Startup</span></strong><span class="koboSpan" id="kobo.8.1"> classes depending on the environment (development, production, and so on). </span><span class="koboSpan" id="kobo.8.2">The appropriate one will be selected at runtime.</span></p>
<p><span class="koboSpan" id="kobo.9.1">This class is defined in such a way that accepts dependencies provided via Dependency Injection, as well. </span><span class="koboSpan" id="kobo.9.2">For instance, you can declare variables of types </span><kbd><span class="koboSpan" id="kobo.10.1">IHostingEnvironment</span></kbd><span class="koboSpan" id="kobo.11.1"> or </span><kbd><span class="koboSpan" id="kobo.12.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.13.1"> to gain the ability to configure diverse functionality related to hosting or logging (remember in, </span><a href="" target="_blank"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.14.1">Chapter 3</span></span></a><span class="koboSpan" id="kobo.15.1">, </span><em><span class="koboSpan" id="kobo.16.1">Introducing Dependency Injection in .Net Core 2.0</span></em><span class="koboSpan" id="kobo.17.1">).</span></p>
<p><span class="koboSpan" id="kobo.18.1">So, what is mandatory in this class and what is optional? </span><span class="koboSpan" id="kobo.18.2">The </span><kbd><span class="koboSpan" id="kobo.19.1">Configure</span></kbd><span class="koboSpan" id="kobo.20.1"> method is mandatory. </span><span class="koboSpan" id="kobo.20.2">No matter what the name of the class, the runtime will look for it inside and call it to make sure the required conditions apply.</span></p>
<p><span class="koboSpan" id="kobo.21.1">However, the </span><kbd><span class="koboSpan" id="kobo.22.1">ConfigureServices()</span></kbd><span class="koboSpan" id="kobo.23.1"> method is optional, but if it is present, it will be called prior to </span><kbd><span class="koboSpan" id="kobo.24.1">Configure()</span></kbd><span class="koboSpan" id="kobo.25.1"> during that initial process. </span><span class="koboSpan" id="kobo.25.2">The following schema illustrates this sequence:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.26.1"><img height="181" width="198" src="assets/c606338c-ce7b-447d-8d4c-ad99ecd6ffad.png"/></span></div>
<div class="packt_figure packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.27.1">(Image courtesy: </span><a href="http://developer.telerik.com/featured/understanding-asp-net-core-initialization/"><span class="URLPACKT"><span class="koboSpan" id="kobo.28.1">http://developer.telerik.com/featured/understanding-asp-net-core-initialization/</span></span></a><span class="koboSpan" id="kobo.29.1">)</span></div>
<p><span class="koboSpan" id="kobo.30.1">Before going any further in demos, let's explain the previous code in more detail.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Code explanation</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Starting with the </span><kbd><span class="koboSpan" id="kobo.3.1">Main()</span></kbd><span class="koboSpan" id="kobo.4.1"> method, after a reference to the </span><kbd><span class="koboSpan" id="kobo.5.1">Hosting</span></kbd><span class="koboSpan" id="kobo.6.1"> subspace that we mentioned previously, we build a new web server by calling the </span><kbd><span class="koboSpan" id="kobo.7.1">WebHostBuilder</span></kbd><span class="koboSpan" id="kobo.8.1"> class. </span><span class="koboSpan" id="kobo.8.2">This class permits configuration and building of a web server using various middleware pieces and entry point conditions.</span></p>
<p><span class="koboSpan" id="kobo.9.1">Thus, after calling the constructor, we piped another three calls:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.10.1">One to </span><kbd><span class="koboSpan" id="kobo.11.1">UseKestrel()</span></kbd><span class="koboSpan" id="kobo.12.1">, which is the default, light-weight server for development that Visual Studio 2017 (and the CLI) uses (we'll explain that in a while)</span></li>
<li><span class="koboSpan" id="kobo.13.1">Another call to </span><kbd><span class="koboSpan" id="kobo.14.1">UseStartup&lt;Startup&gt;()</span></kbd><span class="koboSpan" id="kobo.15.1">, to indicate where the server will find the </span><kbd><span class="koboSpan" id="kobo.16.1">Configure()</span></kbd><span class="koboSpan" id="kobo.17.1"> method to initiate its process (remember the name of the class is irrelevant, as far as it contains the method </span><kbd><span class="koboSpan" id="kobo.18.1">Kestrel</span></kbd><span class="koboSpan" id="kobo.19.1"> looks for initially)</span></li>
<li><span class="koboSpan" id="kobo.20.1">And, finally, another one to </span><kbd><span class="koboSpan" id="kobo.21.1">Build()</span></kbd><span class="koboSpan" id="kobo.22.1">, which creates and initializes the new server with those previous values</span></li>
</ul>
<p><span class="koboSpan" id="kobo.23.1">With all that in place, that last sentence simply calls the </span><kbd><span class="koboSpan" id="kobo.24.1">Run()</span></kbd><span class="koboSpan" id="kobo.25.1"> method to launch the process.</span></p>
<p><span class="koboSpan" id="kobo.26.1">When launching that process, the </span><kbd><span class="koboSpan" id="kobo.27.1">Configure</span></kbd><span class="koboSpan" id="kobo.28.1"> method turns on. </span><span class="koboSpan" id="kobo.28.2">Its only parameter (in this case), is of type </span><kbd><span class="koboSpan" id="kobo.29.1">IApplicationBuilder</span></kbd><span class="koboSpan" id="kobo.30.1">, and, as you see, is served to this method by Dependency Injection (no previous references or instantiation were made by our code).</span></p>
<p><span class="koboSpan" id="kobo.31.1">Consequently, when a server is created, the main, basic objects implied in the communication process are served in this manner, expecting from the user all required behaviors in the form of subsequent calls to its methods.</span></p>
<p><span class="koboSpan" id="kobo.32.1">It's pretty self-explanatory if we take a look at the interface definition:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.33.1"><img height="202" width="576" class=" image-border" src="assets/fa04f5a6-c91e-46c7-844a-ad9e9c73504a.png"/></span></div>
<p><span class="koboSpan" id="kobo.34.1">By the time the </span><kbd><span class="koboSpan" id="kobo.35.1">Configure</span></kbd><span class="koboSpan" id="kobo.36.1"> method receives an instance of the </span><kbd><span class="koboSpan" id="kobo.37.1">IApplicationBuilder</span></kbd><span class="koboSpan" id="kobo.38.1"> class, a bunch of extra functionality is available. </span><span class="koboSpan" id="kobo.38.2">As mentioned previously, it has been made available via extension methods, adopting the form of </span><kbd><span class="koboSpan" id="kobo.39.1">Use*</span></kbd><span class="koboSpan" id="kobo.40.1">, </span><kbd><span class="koboSpan" id="kobo.41.1">Run*</span></kbd><span class="koboSpan" id="kobo.42.1">, and </span><kbd><span class="koboSpan" id="kobo.43.1">Map*</span></kbd><span class="koboSpan" id="kobo.44.1"> methods, which help the programmer in coding configuration aspects and obtaining more independence and granularity.</span></p>
<p><span class="koboSpan" id="kobo.45.1">Notice how the following screenshot shows different configuration options and suggests the use of middleware:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.46.1"><img height="207" width="560" class=" image-border" src="assets/6e14830b-65c3-4608-afee-98d832519948.png"/></span></div>
<p><span class="koboSpan" id="kobo.47.1">Each of these extension methods supplies a way to call the implied delegate. </span><span class="koboSpan" id="kobo.47.2">Notice that while the </span><kbd><span class="koboSpan" id="kobo.48.1">Use*</span></kbd><span class="koboSpan" id="kobo.49.1"> family of methods calls </span><kbd><span class="koboSpan" id="kobo.50.1">Next()</span></kbd><span class="koboSpan" id="kobo.51.1"> implicitly many times to keep on going in the pipeline (actually it depends on other features), the </span><kbd><span class="koboSpan" id="kobo.52.1">Run*</span></kbd><span class="koboSpan" id="kobo.53.1"> family stops the propagation and short-circuits the pipeline (therefore, it doesn't call a next request delegate).</span></p>
<p><span class="koboSpan" id="kobo.54.1">Also, the </span><kbd><span class="koboSpan" id="kobo.55.1">Map*</span></kbd><span class="koboSpan" id="kobo.56.1"> family allows branching the pipeline, making calls that return to that point and extending functionality accordingly.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The New ASP.NET servers</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's quickly review some important aspects of the servers used when programming for ASP.NET Core since that is one of the main changes linked to this new platform.</span></p>
<p><span class="koboSpan" id="kobo.3.1">First of all, an ASP.NET Core application runs an in-process HTTP server implementation. </span><span class="koboSpan" id="kobo.3.2">That implementation is listening for HTTP requests and sends those requests to the application wrapped in an object named </span><kbd><span class="koboSpan" id="kobo.4.1">HttpContext</span></kbd><span class="koboSpan" id="kobo.5.1"> that holds a set of features composed into it.</span></p>
<p><span class="koboSpan" id="kobo.6.1">This version of ASP.NET provides two distinct server implementations: </span><kbd><span class="koboSpan" id="kobo.7.1">Kestrel</span></kbd><span class="koboSpan" id="kobo.8.1"> and </span><kbd><span class="koboSpan" id="kobo.9.1">WebListener</span></kbd><span class="koboSpan" id="kobo.10.1">. </span><span class="koboSpan" id="kobo.10.2">As the official documentation reminds us:</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Kestrel</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">Kestrel</span></kbd><span class="koboSpan" id="kobo.3.1"> is a cross-platform HTTP server based on </span><kbd><span class="koboSpan" id="kobo.4.1">libuv</span></kbd><span class="koboSpan" id="kobo.5.1">, a cross-platform asynchronous I/O library:</span></p>
<p><kbd><span class="koboSpan" id="kobo.6.1">libuv</span></kbd><span class="koboSpan" id="kobo.7.1"> is defined as a multi-platform support library with a focus on asynchronous I/O. </span><span class="koboSpan" id="kobo.7.2">It was primarily developed for use by Node.js, but it's also used by Luvit, Julia, pyuv, and others.</span></p>
<p><span class="koboSpan" id="kobo.8.1">Kestrel is the web server included by default in the ASP.NET Project templates. </span><span class="koboSpan" id="kobo.8.2">The advantage is that if your application accepts requests exclusively from an internal network, it can be used by itself.</span></p>
<p><span class="koboSpan" id="kobo.9.1">This is the working scheme of a default scenario with Kestrel:</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.10.1"><img height="103" width="389" src="assets/eda9b927-3790-45fd-b410-dad0faef0c7a.png"/></span></div>
<div class="CDPAlignCenter CDPAlign packt_figref"><span class="koboSpan" id="kobo.11.1">(Image courtesy: </span><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/"><span class="koboSpan" id="kobo.12.1">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/</span></a><span class="koboSpan" id="kobo.13.1">)</span></div>
<p><span class="koboSpan" id="kobo.14.1">However, if you expose the application to the internet, there are some security issues for which Kestrel is not prepared to cope (it's relatively new and still doesn't have the whole required set of defense resources). </span><span class="koboSpan" id="kobo.14.2">For those cases, the recommended configuration is to use a reverse proxy server, such as IIS, Apache, or Nginx, to provide functionality.</span></p>
<p><span class="koboSpan" id="kobo.15.1">Notice that a reverse proxy server, as the documentation states, </span><em><span class="koboSpan" id="kobo.16.1">receives HTTP requests from the Internet and forwards them to Kestrel after some preliminary handling</span></em><span class="koboSpan" id="kobo.17.1"> (see the following screenshot):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.18.1"><img height="93" width="548" src="assets/bcbed41a-719b-4b2f-a69e-ef755a25a391.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.19.1">(Image </span><span><span class="koboSpan" id="kobo.20.1">courtesy:</span></span> <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/"><span class="koboSpan" id="kobo.21.1">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/</span></a><span class="koboSpan" id="kobo.22.1">)</span></div>
<p><span class="koboSpan" id="kobo.23.1">Another important point is that you can't use any of those reverse proxy servers without Kestrel or a custom server implementation. </span><span class="koboSpan" id="kobo.23.2">This is because ASP.NET Core was designed to run in its own process so it can behave consistently across platforms.</span></p>
<p><span class="koboSpan" id="kobo.24.1">The problem that we might face here is that IIS, Nginx, and Apache prescribe their own startup process and environment. </span><span class="koboSpan" id="kobo.24.2">The consequence is that to use them directly it should adapt to the requirements of each one.</span></p>
<p><span class="koboSpan" id="kobo.25.1">In this way, Kestrel gives ASP.NET Core the ability to code </span><kbd><span class="koboSpan" id="kobo.26.1">Program</span></kbd><span class="koboSpan" id="kobo.27.1"> and </span><kbd><span class="koboSpan" id="kobo.28.1">Startup</span></kbd><span class="koboSpan" id="kobo.29.1"> classes in any required form to suit the user's needs, while avoiding another dependency on a concrete, specific server. </span><span class="koboSpan" id="kobo.29.2">That's one of the reasons why middleware is so important in this context.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">WebListener</span></h1>
                </header>
            
            <article>
                
<p><kbd><span class="koboSpan" id="kobo.2.1">WebListener</span></kbd><span class="koboSpan" id="kobo.3.1"> is a Windows-only HTTP server based on the </span><kbd><span class="koboSpan" id="kobo.4.1">Http.Sys</span></kbd><span class="koboSpan" id="kobo.5.1"> kernel driver. </span><span class="koboSpan" id="kobo.5.2">It serves as an alternative for those scenarios where exposing our app to the internet is mandatory, but we don't wish to use IIS if we cannot do it for some reason.</span></p>
<p><span class="koboSpan" id="kobo.6.1">The following schema represents the role of WebListener in a similar scenario as the one presented previously with Kestrel:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.7.1"><img height="100" width="382" src="assets/c4bb5714-625b-4f2c-ad9f-25e870db28dd.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.8.1">(Image courtesy: </span><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/"><span class="koboSpan" id="kobo.9.1">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/</span></a><span class="koboSpan" id="kobo.10.1">)</span></div>
<p><span class="koboSpan" id="kobo.11.1">In the same way, if you need some of the features that Kestrel doesn't support while working on an internal network, you could use WebListener in a quite comparable configuration:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img height="99" width="378" src="assets/7796eaba-9226-486a-822e-513f4c0a8157.png"/></span></div>
<div class="packt_figref CDPAlignCenter CDPAlign"><span><span class="koboSpan" id="kobo.13.1">(Image courtesy:</span></span> <a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/"><span class="koboSpan" id="kobo.14.1">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/</span></a><span class="koboSpan" id="kobo.15.1">)</span></div>
<p><span class="koboSpan" id="kobo.16.1">Finally, keep in mind that for internal network scenarios, Kestrel is recommended because it provides improved performance. </span><span class="koboSpan" id="kobo.16.2">In any case, if you want to know more about the features provided by WebListener, the official documentation is available at </span><a href="https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/weblistener"><span class="URLPACKT"><span class="koboSpan" id="kobo.17.1">https://docs.microsoft.com/en-us/aspnet/core/fundamentals/servers/weblistener</span></span></a><span class="koboSpan" id="kobo.18.1">.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dependency Inversion in the architecture - OWIN</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">It's also possible to create your own server implementation to work with ASP.NET Core. </span><strong><span class="koboSpan" id="kobo.3.1">Open Web Interface for .NET</span></strong><span class="koboSpan" id="kobo.4.1"> (</span><strong><span class="koboSpan" id="kobo.5.1">OWIN</span></strong><span class="koboSpan" id="kobo.6.1">) is the third possible implementation supported by the platform.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In some ways, the implementation of OWIN also relates to the Dependency Inversion Principle. </span><span class="koboSpan" id="kobo.7.2">Its main goal is to make web applications decoupled from web servers.</span></p>
<p><span class="koboSpan" id="kobo.8.1">With that purpose, it defines standard ways to create middleware that can be used in the pipeline, to configure and tune your server.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Analyzing the default template</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Now it's time to open Visual Studio 2017 (or 2015, with ASP.NET Core installed) and take a look at it and explain how the default templates behave.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Remember that ASP.NET Core can execute using the classical.NET Framework as well, so, when you create a new Web project you'll be asked, initially, to choose between three main options: classical ASP.NET, ASP.NET Core with NET Core, and ASP.NET Core with classical .NET Framework:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.4.1"><img class=" image-border" src="assets/d5a62e2e-b436-405f-b72b-1ded0e64ec91.png"/></span></div>
<p><span class="koboSpan" id="kobo.5.1">Once selected, you'll be offered another choice window: </span><span class="packt_screen"><span class="koboSpan" id="kobo.6.1">Empty</span></span><span class="koboSpan" id="kobo.7.1">, </span><span class="packt_screen"><span class="koboSpan" id="kobo.8.1">Web API</span></span><span class="koboSpan" id="kobo.9.1">, </span><span class="packt_screen"><span class="koboSpan" id="kobo.10.1">Web Applicatio</span></span><span class="packt_screen"><span class="koboSpan" id="kobo.11.1">n</span></span><span class="koboSpan" id="kobo.12.1">, </span><span class="packt_screen"><span class="koboSpan" id="kobo.13.1">Web Application (Model-View-Controller)</span></span><span class="koboSpan" id="kobo.14.1">, and some new options added to version 2.0 for third-party libraries, which include </span><span class="packt_screen"><span class="koboSpan" id="kobo.15.1">Angular</span></span><span class="koboSpan" id="kobo.16.1">, </span><span class="packt_screen"><span class="koboSpan" id="kobo.17.1">React.js</span></span><span class="koboSpan" id="kobo.18.1">, and </span><span class="packt_screen"><span class="koboSpan" id="kobo.19.1">React.js and Redux</span></span><span class="koboSpan" id="kobo.20.1">.</span></p>
<p><span class="koboSpan" id="kobo.21.1">In the first case, the one we're using now creates an application with the minimum configuration to be able to create and run a web server using Kestrel and present some text in the browser. </span><span class="koboSpan" id="kobo.21.2">It's simple, but it allows us to check out how it is done with more detail and to make some changes.</span></p>
<p><span class="koboSpan" id="kobo.22.1">The other three (</span><span class="packt_screen"><span class="koboSpan" id="kobo.23.1">Web API</span></span><span class="koboSpan" id="kobo.24.1">, </span><span class="packt_screen"><span class="koboSpan" id="kobo.25.1">Web Application</span></span><span class="koboSpan" id="kobo.26.1">, and </span><span class="packt_screen"><span class="koboSpan" id="kobo.27.1">Web App MVC</span></span><span class="koboSpan" id="kobo.28.1">) remind their counterpart in classic ASP.NET, with the difference that they use the new architecture and configuration files. </span><span class="koboSpan" id="kobo.28.2">In this manner, we'll be able to better appreciate the migration process needed to pass from the old architecture to the new one.</span></p>
<p><span class="koboSpan" id="kobo.29.1">You should see the following dialog box:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.30.1"><img height="376" width="577" class=" image-border" src="assets/ed226be6-21c8-4aae-b66f-e4f0e56055a2.png"/></span></div>
<p><span class="koboSpan" id="kobo.31.1">Notice that you can also change authentication as in previous versions and that you have a checkbox that allows enabling </span><span class="packt_screen"><span class="koboSpan" id="kobo.32.1">Docker</span></span><span class="koboSpan" id="kobo.33.1"> support.</span></p>
<p><span class="koboSpan" id="kobo.34.1">The resulting project is a bit more complex than the basic demo we did previously, although the basic pieces are the same. </span><span class="koboSpan" id="kobo.34.2">However, there are some noticeable changes in configuration.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Configuration files</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Once you compile the application and activate the </span><span class="packt_screen"><span class="koboSpan" id="kobo.3.1">See all files</span></span><span class="koboSpan" id="kobo.4.1"> option in the Solution Explorer, you'll notice some extra configuration files that take care of a few tasks, such as launching the browser on the default URL. </span><span class="koboSpan" id="kobo.4.2">These options are defined inside the </span><kbd><span class="koboSpan" id="kobo.5.1">launchSettings.json</span></kbd><span class="koboSpan" id="kobo.6.1"> file available inside the </span><kbd><span class="koboSpan" id="kobo.7.1">Properties</span></kbd><span class="koboSpan" id="kobo.8.1"> directory.</span></p>
<p><span class="koboSpan" id="kobo.9.1">A look at it is also quite explanatory:</span></p>
<pre><span class="koboSpan" id="kobo.10.1">    { 
      "iisSettings": { 
        "windowsAuthentication": false, 
        "anonymousAuthentication": true, 
        "iisExpress": { 
          "applicationUrl": "http://localhost:57539/", 
          "sslPort": 0 
        } 
      }, 
      "profiles": { 
        "IIS Express": { 
          "commandName": "IISExpress", 
          "launchBrowser": true, 
          "environmentVariables": { 
            "ASPNETCORE_ENVIRONMENT": "Development" 
          } 
        }, 
        "ASPNETCoreDemo1": { 
          "commandName": "Project", 
          "launchBrowser": true, 
          "environmentVariables": { 
           "ASPNETCORE_ENVIRONMENT": "Development" 
          }, 
          "applicationUrl": "http://localhost:57540" 
        } 
      } </span></pre>
<p><span class="koboSpan" id="kobo.11.1">As you see, three main areas of configuration apply here: </span><kbd><span class="koboSpan" id="kobo.12.1">iisSettings</span></kbd><span class="koboSpan" id="kobo.13.1">, to indicate IIS behavior, including the URL to use, a </span><kbd><span class="koboSpan" id="kobo.14.1">profiles</span></kbd><span class="koboSpan" id="kobo.15.1"> section that only contains one profile for </span><kbd><span class="koboSpan" id="kobo.16.1">IISExpress</span></kbd><span class="koboSpan" id="kobo.17.1">, indicating that a browser should be launched and a hint on the development mode, and a final one under the name of the application itself (</span><kbd><span class="koboSpan" id="kobo.18.1">ASPNETCoreDemo1</span></kbd><span class="koboSpan" id="kobo.19.1">), with similar information.</span></p>
<p><span class="koboSpan" id="kobo.20.1">Of course, if you dig into the </span><kbd><span class="koboSpan" id="kobo.21.1">\bin</span></kbd><span class="koboSpan" id="kobo.22.1"> or </span><kbd><span class="koboSpan" id="kobo.23.1">\obj</span></kbd><span class="koboSpan" id="kobo.24.1"> directories, you'll see some more, such as </span><kbd><span class="koboSpan" id="kobo.25.1">ASPNETCoreDemo1.runtimeconfig.json</span></kbd><span class="koboSpan" id="kobo.26.1"> with extra information. </span><span class="koboSpan" id="kobo.26.2">And, finally, if you examine the .</span><kbd><span class="koboSpan" id="kobo.27.1">csproj</span></kbd><span class="koboSpan" id="kobo.28.1"> you'll see some additions as well:</span></p>
<div class="packt_tip"><span class="koboSpan" id="kobo.29.1">Remember that on the project's </span><span class="packt_screen"><span class="koboSpan" id="kobo.30.1">context</span></span><span class="koboSpan" id="kobo.31.1"> menu option at the </span><span class="packt_screen"><span class="koboSpan" id="kobo.32.1">Solution Explorer</span></span><span class="koboSpan" id="kobo.33.1"> you now have an option that allows you to open it directly in Visual Studio 2017.</span></div>
<pre><span class="koboSpan" id="kobo.34.1">     &lt;Project Sdk="Microsoft.NET.Sdk.Web"&gt; 
     &lt;PropertyGroup&gt; 
      &lt;TargetFramework&gt;netcoreapp1.1&lt;/TargetFramework&gt; 
     &lt;/PropertyGroup&gt; 
 
     &lt;ItemGroup&gt; 
      &lt;Folder Include="wwwroot\" /&gt; 
    &lt;/ItemGroup&gt; 
    &lt;ItemGroup&gt; 
      &lt;PackageReference Include= "Microsoft.ApplicationInsights.AspNetCore" </span><br/><span class="koboSpan" id="kobo.35.1">           Version="2.0.0" /&gt; 
      &lt;PackageReference Include="Microsoft.AspNetCore" Version="1.1.1" /&gt; 
    &lt;/ItemGroup&gt; 
    &lt;/Project&gt; </span></pre>
<p><span class="koboSpan" id="kobo.36.1">Not many changes, but now it indicates the use of the </span><kbd><span class="koboSpan" id="kobo.37.1">wwwroot</span></kbd><span class="koboSpan" id="kobo.38.1"> folder and it adds the </span><kbd><span class="koboSpan" id="kobo.39.1">ApplicationInsights</span></kbd><span class="koboSpan" id="kobo.40.1"> call. </span><span class="koboSpan" id="kobo.40.2">And, obviously, there's no indication of filetype, since, by default, the compiled assembly is a DLL.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The Entry Point</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Let's start with </span><kbd><span class="koboSpan" id="kobo.3.1">program.cs</span></kbd><span class="koboSpan" id="kobo.4.1">. </span><span class="koboSpan" id="kobo.4.2">Its </span><kbd><span class="koboSpan" id="kobo.5.1">main()</span></kbd><span class="koboSpan" id="kobo.6.1"> method is similar, but it contains new middleware:</span></p>
<pre><span class="koboSpan" id="kobo.7.1">    public static void Main(string[] args)</span><br/><span class="koboSpan" id="kobo.8.1">    {</span><br/><span class="koboSpan" id="kobo.9.1">      var host = new WebHostBuilder()</span><br/><span class="koboSpan" id="kobo.10.1">      .UseKestrel()</span><br/><span class="koboSpan" id="kobo.11.1">      .UseContentRoot(Directory.GetCurrentDirectory())</span><br/><span class="koboSpan" id="kobo.12.1">      .UseIISIntegration()</span><br/><span class="koboSpan" id="kobo.13.1">      .UseStartup&lt;Startup&gt;()</span><br/><span class="koboSpan" id="kobo.14.1">      .UseApplicationInsights()</span><br/><span class="koboSpan" id="kobo.15.1">      .Build();</span><br/><span class="koboSpan" id="kobo.16.1">      host.Run();</span><br/><span class="koboSpan" id="kobo.17.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.18.1">The three main differences are: </span><kbd><span class="koboSpan" id="kobo.19.1">UseContentRoot()</span></kbd><span class="koboSpan" id="kobo.20.1">, </span><kbd><span class="koboSpan" id="kobo.21.1">UseIISIntegration()</span></kbd><span class="koboSpan" id="kobo.22.1">, and </span><kbd><span class="koboSpan" id="kobo.23.1">UseApplicationInsights()</span></kbd><span class="koboSpan" id="kobo.24.1">.</span></p>
<p><kbd><span class="koboSpan" id="kobo.25.1">UseContentRoot(Directory.GetCurrentDirectory())</span></kbd><span class="koboSpan" id="kobo.26.1">, indicates that whenever the user requests a physical resource, that's the directory to search in. </span><span class="koboSpan" id="kobo.26.2">By default, it's going to point to the </span><kbd><span class="koboSpan" id="kobo.27.1">wwwroot</span></kbd><span class="koboSpan" id="kobo.28.1"> directory.</span></p>
<p><kbd><span class="koboSpan" id="kobo.29.1">UseIISIntegration()</span></kbd><span class="koboSpan" id="kobo.30.1"> is there to indicate that IIS will be used as a reverse proxy (as we mentioned previously), and finally, </span><kbd><span class="koboSpan" id="kobo.31.1">UseApplicationInsights()</span></kbd><span class="koboSpan" id="kobo.32.1"> helps monitor and audit your application.</span></p>
<p><span class="koboSpan" id="kobo.33.1">As the official documentation states (</span><a href="https://github.com/Microsoft/ApplicationInsights-aspnetcore/wiki/Getting-Started-with-Application-Insights-for-ASP.NET-Core"><span class="URLPACKT"><span class="koboSpan" id="kobo.34.1">https://github.com/Microsoft/ApplicationInsights-aspnetcore/wiki/Getting-Started-with-Application-Insights-for-ASP.NET-Core</span></span></a><span class="koboSpan" id="kobo.35.1">) it allows us to </span><em><span class="koboSpan" id="kobo.36.1">Monitor your live ASP.NET Core applications with Visual Studio Application Insights. </span><span class="koboSpan" id="kobo.36.2">Application Insights is an extensible analytics platform that monitors the performance and usage of your live web applications. </span><span class="koboSpan" id="kobo.36.3">With the feedback you get about the performance and effectiveness of your app in the wild, you can make informed choices about the direction of the design in each development lifecycle.</span></em></p>
<p><span class="koboSpan" id="kobo.37.1">So, we have an entry point reinforced with new middleware, and thus, we can use DI from the start. </span><span class="koboSpan" id="kobo.37.2">Let's see what it's done in the </span><kbd><span class="koboSpan" id="kobo.38.1">Startup</span></kbd><span class="koboSpan" id="kobo.39.1"> class (the configuration).</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The default Startup class</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The first point to notice is the presence of </span><kbd><span class="koboSpan" id="kobo.3.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.4.1"> (even if it's empty). </span><span class="koboSpan" id="kobo.4.2">As you can see in the following screenshot, it allows adding distinct services to our pipeline, storing them in the </span><kbd><span class="koboSpan" id="kobo.5.1">services</span></kbd><span class="koboSpan" id="kobo.6.1"> collection. </span><span class="koboSpan" id="kobo.6.2">This will be the place to register our own services as well.</span></p>
<p><span class="koboSpan" id="kobo.7.1">Also notice that some of these methods are ready to add services with distinct lifetime configuration (</span><kbd><span class="koboSpan" id="kobo.8.1">AddSingleton</span></kbd><span class="koboSpan" id="kobo.9.1">, </span><kbd><span class="koboSpan" id="kobo.10.1">AddScoped</span></kbd><span class="koboSpan" id="kobo.11.1">, and </span><kbd><span class="koboSpan" id="kobo.12.1">AddTransient</span></kbd><span class="koboSpan" id="kobo.13.1">). </span><span class="koboSpan" id="kobo.13.2">Later, we'll see how to add services at this point to allow applications to use a given functionality, such as Database Access, and so on, using this </span><kbd><span class="koboSpan" id="kobo.14.1">IServiceCollection</span></kbd><span class="koboSpan" id="kobo.15.1"> object that it received through Dependency Injection (see the following screenshot):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.16.1"><img height="250" width="618" class=" image-border" src="assets/0d92032f-eea0-49fc-804b-c8bf0531f737.png"/></span></div>
<p><span class="koboSpan" id="kobo.17.1">As for the </span><kbd><span class="koboSpan" id="kobo.18.1">Configure()</span></kbd><span class="koboSpan" id="kobo.19.1"> method, this time it receives (via Dependency Injection, of course), three instances of types </span><kbd><span class="koboSpan" id="kobo.20.1">IApplicationBuilder</span></kbd><span class="koboSpan" id="kobo.21.1">, </span><kbd><span class="koboSpan" id="kobo.22.1">IHostingEnvironment</span></kbd><span class="koboSpan" id="kobo.23.1">, and </span><kbd><span class="koboSpan" id="kobo.24.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.25.1"> as the following code shows:</span></p>
<pre><span class="koboSpan" id="kobo.26.1">    // This method gets called by the runtime. </span><span class="koboSpan" id="kobo.26.2">Use this method to //</span><br/><span class="koboSpan" id="kobo.27.1">    // configure the HTTP request pipeline. 
    </span><span class="koboSpan" id="kobo.27.2">public void Configure(IApplicationBuilder app, </span><br/><span class="koboSpan" id="kobo.28.1">       IHostingEnvironment env, ILoggerFactory loggerFactory) 
    { 
      loggerFactory.AddConsole(); 
 
      if (env.IsDevelopment()) 
      { 
        app.UseDeveloperExceptionPage(); 
      } 
 
      app.Run(async (context) =&gt; 
      { 
        await context.Response.WriteAsync("Hello World!"); 
      }); 
    } </span></pre>
<p><span class="koboSpan" id="kobo.29.1">The first one is used at the end to launch the application, only this time using the </span><kbd><span class="koboSpan" id="kobo.30.1">async/await</span></kbd><span class="koboSpan" id="kobo.31.1"> structure to guarantee a formal asynchronous call, returning a string.</span></p>
<p><kbd><span class="koboSpan" id="kobo.32.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.33.1"> is used in a similar manner as we did in </span><a href="" target="_blank"><span class="koboSpan" id="kobo.34.1">Chapter 3</span></a><span class="koboSpan" id="kobo.35.1">, </span><em><span class="koboSpan" id="kobo.36.1">Introducing Dependency Injection in .NET Core 2.0</span></em><span class="koboSpan" id="kobo.37.1">, to configure messages that will be output to the console.</span></p>
<p><span class="koboSpan" id="kobo.38.1">Finally, the </span><kbd><span class="koboSpan" id="kobo.39.1">IHostingEnvironment</span></kbd><span class="koboSpan" id="kobo.40.1"> variable is used to check if the application is in development mode, and, in that case, to configure a developer exception page, which we can define elsewhere.</span></p>
<p><span class="koboSpan" id="kobo.41.1">ASP.NET Core distinguishes four possible development modes: </span><kbd><span class="koboSpan" id="kobo.42.1">development</span></kbd><span class="koboSpan" id="kobo.43.1">, </span><kbd><span class="koboSpan" id="kobo.44.1">production</span></kbd><span class="koboSpan" id="kobo.45.1">, </span><kbd><span class="koboSpan" id="kobo.46.1">staging</span></kbd><span class="koboSpan" id="kobo.47.1">, and a fourth one </span><kbd><span class="koboSpan" id="kobo.48.1">environment</span></kbd><span class="koboSpan" id="kobo.49.1"> that allows defining your own. </span><span class="koboSpan" id="kobo.49.2">That value is configurable inside the </span><kbd><span class="koboSpan" id="kobo.50.1">Project/Properties/Debug</span></kbd><span class="koboSpan" id="kobo.51.1"> window, where you can now add distinct environment variables, as you can see in the following screenshot:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.52.1"><img height="325" width="535" class=" image-border" src="assets/67749781-f661-4470-910e-e6817c4b0d8c.png"/></span></div>
<p><span class="koboSpan" id="kobo.53.1">These values are read by the </span><kbd><span class="koboSpan" id="kobo.54.1">IHostingEnvironment</span></kbd><span class="koboSpan" id="kobo.55.1"> object allowing the insertion of actions prior to the application launching process. </span><span class="koboSpan" id="kobo.55.2">Notice it's not a single value, but a collection, so you can add as many environment values as needed and use this object's methods to read whether some of them are true.</span></p>
<p><span class="koboSpan" id="kobo.56.1">You could also use something like </span><kbd><span class="koboSpan" id="kobo.57.1">ASPNETCORE_ENVIRONMENT"="MyCompany</span></kbd><span class="koboSpan" id="kobo.58.1"> to define your own and check this value easily, using the </span><kbd><span class="koboSpan" id="kobo.59.1">IsEnvironment()</span></kbd><span class="koboSpan" id="kobo.60.1"> method, as you can see in the following screenshot:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.61.1"><img height="183" width="568" class=" image-border" src="assets/f9d6845f-e431-40aa-b5e7-8af821d6c4da.png"/></span></div>
<p><span class="koboSpan" id="kobo.62.1">So, if we change the previous </span><kbd><span class="koboSpan" id="kobo.63.1">development</span></kbd><span class="koboSpan" id="kobo.64.1"> value for a customized one, such as </span><kbd><span class="koboSpan" id="kobo.65.1">PACKT</span></kbd><span class="koboSpan" id="kobo.66.1">, we can modify the exit in the browser with the following:</span></p>
<pre><span class="koboSpan" id="kobo.67.1">    app.Run(async (context) =&gt; 
    { 
       if (env.IsEnvironment("Packt")) 
       { 
        await context.Response.WriteAsync("We're in PACKT </span><br/><span class="koboSpan" id="kobo.68.1">             development mode!"); 
       } 
       else await context.Response.WriteAsync("Hello World!"); 
    }); </span></pre>
<p><span class="koboSpan" id="kobo.69.1">The output will be different in this case, so we're free to configure anything and mix it with other values to have a totally customized, mode-dependent, experience:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.70.1"><img height="134" width="406" class=" image-border" src="assets/029c6027-b9b3-4666-aeb9-0b9ebc5ec85e.png"/></span></div>
<p><span class="koboSpan" id="kobo.71.1">But, there's much more in relation to DI, as we're going to see in the next sections.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Dependency Injection in ASP.NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Of course, this behavior is possible thanks to the presence of a DI Container inside the ASP.NET Core engine. </span><span class="koboSpan" id="kobo.2.2">The official documentation states it very clearly: </span><em><span class="koboSpan" id="kobo.3.1">if a given type has declared that it has dependencies, and the container has been configured to provide the dependency types, it will create the dependencies as part of creating the requested instance</span></em><span class="koboSpan" id="kobo.4.1">.</span></p>
<p><span class="koboSpan" id="kobo.5.1">The container, in this way, manages an object's lifetime and avoids the need for hard-coded object construction.</span></p>
<p><span class="koboSpan" id="kobo.6.1">Besides other built-in implementations, remember that ASP.NET Core provides a simple DI Container (that we already tested in </span><a href="" target="_blank"><span class="ChapterrefPACKT"><span class="koboSpan" id="kobo.7.1">Chapter 3</span></span></a><span class="koboSpan" id="kobo.8.1">, </span><em><span class="koboSpan" id="kobo.9.1">Introducing Dependency Injection in .Net Core 2.0</span></em><span class="koboSpan" id="kobo.10.1">), represented by the </span><kbd><span class="koboSpan" id="kobo.11.1">IServiceProvider</span></kbd><span class="koboSpan" id="kobo.12.1"> interface.</span></p>
<p><span class="koboSpan" id="kobo.13.1">As we mentioned, the place to configure services using that interface in this platform is the </span><kbd><span class="koboSpan" id="kobo.14.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.15.1"> method, which we will analyze in the following section.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Services provided by ASP.NET Core</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">There's quite a large list of services available inside ASP.NET Core via Dependency Injection. </span><span class="koboSpan" id="kobo.2.2">The following table shows these services together with an indication of its lifetime:</span></p>
<table class="table">
<tbody>
<tr>
<td><strong><span class="koboSpan" id="kobo.3.1">Service Type</span></strong></td>
<td><strong><span class="koboSpan" id="kobo.4.1">Lifetime</span></strong></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.5.1">Microsoft.AspNetCore.Hosting.IHostingEnvironment</span></kbd></td>
<td><span class="koboSpan" id="kobo.6.1">Singleton</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.7.1">Microsoft.Extensions.Logging.ILoggerFactory</span></kbd></td>
<td><span class="koboSpan" id="kobo.8.1">Singleton</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.9.1">Microsoft.Extensions.Logging.ILogger&lt;T&gt;</span></kbd></td>
<td><span class="koboSpan" id="kobo.10.1">Singleton</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.11.1">Microsoft.AspNetCore.Hosting.Builder.IApplicationBuilderFactory</span></kbd></td>
<td><span class="koboSpan" id="kobo.12.1">Transient</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.13.1">Microsoft.AspNetCore.Http.IHttpContextFactory</span></kbd></td>
<td><span class="koboSpan" id="kobo.14.1">Transient</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.15.1">Microsoft.Extensions.Options.IOptions&lt;T&gt;</span></kbd></td>
<td><span class="koboSpan" id="kobo.16.1">Singleton</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.17.1">System.Diagnostics.DiagnosticSource</span></kbd></td>
<td><span class="koboSpan" id="kobo.18.1">Singleton</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.19.1">System.Diagnostics.DiagnosticListener</span></kbd></td>
<td><span class="koboSpan" id="kobo.20.1">Singleton</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.21.1">Microsoft.AspNetCore.Hosting.IStartupFilter</span></kbd></td>
<td><span class="koboSpan" id="kobo.22.1">Transient</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.23.1">Microsoft.Extensions.ObjectPool.ObjectPoolProvider</span></kbd></td>
<td><span class="koboSpan" id="kobo.24.1">Singleton</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.25.1">Microsoft.Extensions.Options.IConfigureOptions&lt;T&gt;</span></kbd></td>
<td><span class="koboSpan" id="kobo.26.1">Transient</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.27.1">Microsoft.AspNetCore.Hosting.Server.IServer</span></kbd></td>
<td><span class="koboSpan" id="kobo.28.1">Singleton</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.29.1">Microsoft.AspNetCore.Hosting.IStartup</span></kbd></td>
<td><span class="koboSpan" id="kobo.30.1">Singleton</span></td>
</tr>
<tr>
<td><kbd><span class="koboSpan" id="kobo.31.1">Microsoft.AspNetCore.Hosting.IApplicationLifetime</span></kbd></td>
<td><span class="koboSpan" id="kobo.32.1">Singleton</span></td>
</tr>
</tbody>
</table>
<p><span class="koboSpan" id="kobo.33.1"> </span></p>
<p><span class="koboSpan" id="kobo.34.1">As you see, this is a pretty comprehensive list of choices, to which we have to add the functionality already available and "installable" via </span><kbd><span class="koboSpan" id="kobo.35.1">Run*</span></kbd><span class="koboSpan" id="kobo.36.1">, </span><kbd><span class="koboSpan" id="kobo.37.1">Use*</span></kbd><span class="koboSpan" id="kobo.38.1">, and </span><kbd><span class="koboSpan" id="kobo.39.1">Map*</span></kbd><span class="koboSpan" id="kobo.40.1"> methods commented on previously.</span></p>
<p><span class="koboSpan" id="kobo.41.1">So, we can distinguish two flavors of method, here: those already available and ready to include at will (the ones shown in </span><kbd><span class="koboSpan" id="kobo.42.1">Program/Main</span></kbd><span class="koboSpan" id="kobo.43.1">), and those that you can customize (using the </span><kbd><span class="koboSpan" id="kobo.44.1">Startup</span></kbd><span class="koboSpan" id="kobo.45.1"> class), either by addition or by creating your own classes and interfaces and adding them to the </span><kbd><span class="koboSpan" id="kobo.46.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.47.1"> initial process.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">The relation of services available at startup</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In summary, we have several ways to include functionality via Dependency Injection in ASP.NET Core 2.0, via the Startup class:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.3.1">By creating your own constructor for the Startup class, which refers to a previously define map Interface =&gt; Class</span></li>
<li><span class="koboSpan" id="kobo.4.1">By referring to the service required in the </span><kbd><span class="koboSpan" id="kobo.5.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.6.1"> method</span></li>
<li><span class="koboSpan" id="kobo.7.1">By using the </span><kbd><span class="koboSpan" id="kobo.8.1">Configure()</span></kbd><span class="koboSpan" id="kobo.9.1"> method in the ways we've seen</span></li>
</ul>
<p><span class="koboSpan" id="kobo.10.1">If you consider the methods of </span><kbd><span class="koboSpan" id="kobo.11.1">Startup</span></kbd><span class="koboSpan" id="kobo.12.1"> in the order they are executed, the following services are at your disposal:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.13.1">Constructor: </span><kbd><span class="koboSpan" id="kobo.14.1">IHostingEnvironment</span></kbd><span class="koboSpan" id="kobo.15.1">, </span><kbd><span class="koboSpan" id="kobo.16.1">ILoggerFactory</span></kbd></li>
<li><kbd><span class="koboSpan" id="kobo.17.1">* ConfigureServices</span></kbd><span class="koboSpan" id="kobo.18.1">: </span><kbd><span class="koboSpan" id="kobo.19.1">IServiceCollection</span></kbd></li>
<li><span class="koboSpan" id="kobo.20.1">Configure: </span><kbd><span class="koboSpan" id="kobo.21.1">IApplicationBuilder</span></kbd><span class="koboSpan" id="kobo.22.1">, </span><kbd><span class="koboSpan" id="kobo.23.1">IHostingEnvironment</span></kbd><span class="koboSpan" id="kobo.24.1">, </span><kbd><span class="koboSpan" id="kobo.25.1">ILoggerFactory</span></kbd><span class="koboSpan" id="kobo.26.1">, </span><kbd><span class="koboSpan" id="kobo.27.1">IApplicationLifetime</span></kbd></li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Identifying Services in the Web Application template</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">The Web Application template is much more revealing regarding the use of services and the role of Dependency Injection, so we're going to create a project equivalent to the classic ASP.NET MVC 5 available for a classic .NET Framework so we can compare both, identifying this functionality.</span></p>
<p><span class="koboSpan" id="kobo.3.1">Once you create one of these new projects, you'll probably identify many of the elements that were present in the previous version: folders for controllers and views, Razor files defining the distinct views in the application, and so on.</span></p>
<p><span class="koboSpan" id="kobo.4.1">But, now that we've seen some of the main changes, a review of the critical files is quite enlightening. </span><span class="koboSpan" id="kobo.4.2">There are no changes in </span><kbd><span class="koboSpan" id="kobo.5.1">Program/Main</span></kbd><span class="koboSpan" id="kobo.6.1">, but we'll find a lot in the </span><kbd><span class="koboSpan" id="kobo.7.1">Startup</span></kbd><span class="koboSpan" id="kobo.8.1"> class. </span><span class="koboSpan" id="kobo.8.2">The references (</span><kbd><span class="koboSpan" id="kobo.9.1">using</span></kbd><span class="koboSpan" id="kobo.10.1"> statements) are the same as in the basic demo, so I'm omitting the code here.</span></p>
<p><span class="koboSpan" id="kobo.11.1">The most interesting come inside the </span><kbd><span class="koboSpan" id="kobo.12.1">Startup</span></kbd><span class="koboSpan" id="kobo.13.1"> class itself:</span></p>
<pre><span class="koboSpan" id="kobo.14.1">    public class Startup 
    { 
      public Startup(IHostingEnvironment env) 
      { 
        var builder = new ConfigurationBuilder() 
            .SetBasePath(env.ContentRootPath) 
            .AddJsonFile("appsettings.json", optional: false,  
                         reloadOnChange: true) 
          .AddJsonFile($"appsettings.{env.EnvironmentName}.json",  
                         optional: true) 
            .AddEnvironmentVariables(); 
        Configuration = builder.Build(); 
      }   
 
      public IConfigurationRoot Configuration { get; } 
 
      // This method gets called by the runtime. </span><span class="koboSpan" id="kobo.14.2">Use this method to  
      // add services to the container. 
      </span><span class="koboSpan" id="kobo.14.3">public void ConfigureServices(IServiceCollection services) 
      { 
        // Add framework services. 
        </span><span class="koboSpan" id="kobo.14.4">services.AddMvc(); 
      } </span></pre>
<p><span class="koboSpan" id="kobo.15.1">Up to this point, the default template only initializes the MVC engine, considering it an extra service, totally optional to the user.</span></p>
<p><span class="koboSpan" id="kobo.16.1">Further on, we'll see how to use this method to register and configure other built-in or customized services:</span></p>
<pre><span class="koboSpan" id="kobo.17.1">    // This method gets called by the runtime. </span><span class="koboSpan" id="kobo.17.2">Use this method to  
    // configure  the HTTP request pipeline. 
    </span><span class="koboSpan" id="kobo.17.3">public void Configure(IApplicationBuilder app,  
        IHostingEnvironment env, ILoggerFactory loggerFactory) 
    { 
        loggerFactory.AddConsole(Configuration.GetSection("Logging")); 
        loggerFactory.AddDebug(); 
 
        if (env.IsDevelopment()) 
        { 
            app.UseDeveloperExceptionPage(); 
            app.UseBrowserLink(); 
        } 
        else 
        { 
            app.UseExceptionHandler("/Home/Error"); 
        } 
 
        app.UseStaticFiles(); 
 
        app.UseMvc(routes =&gt; 
        { 
            routes.MapRoute( name: "default", 
                template:{controller=Home}/{action=Index}/{id?}"); 
        }); 
     } </span></pre>
<p><span class="koboSpan" id="kobo.18.1">First of all, we now have a constructor and a read-only private property (</span><kbd><span class="koboSpan" id="kobo.19.1">Configuration</span></kbd><span class="koboSpan" id="kobo.20.1">) of type </span><kbd><span class="koboSpan" id="kobo.21.1">IConfigurationRoot</span></kbd><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">Well, it happens that the </span><kbd><span class="koboSpan" id="kobo.23.1">builder.Build()</span></kbd><span class="koboSpan" id="kobo.24.1"> method called at the end of the constructor, is of this type and provides a convenient way to include and access all configuration information loaded from several </span><kbd><span class="koboSpan" id="kobo.25.1">.json</span></kbd><span class="koboSpan" id="kobo.26.1"> files in the distinct application's folders.</span></p>
<p><span class="koboSpan" id="kobo.27.1">All that information is collected at the very beginning of the process of initialization, so whatever has to be read from the outside is ready before </span><kbd><span class="koboSpan" id="kobo.28.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.29.1"> and </span><kbd><span class="koboSpan" id="kobo.30.1">Configure</span></kbd><span class="koboSpan" id="kobo.31.1"> come into play (see the following screenshot showing the value of </span><kbd><span class="koboSpan" id="kobo.32.1">Configuration</span></kbd><span class="koboSpan" id="kobo.33.1"> after loading):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.34.1"><img height="350" width="652" class=" image-border" src="assets/973d5311-1183-457c-ad0f-8d1af9f5db9f.png"/></span></div>
<p><span class="koboSpan" id="kobo.35.1">As you see, the </span><kbd><span class="koboSpan" id="kobo.36.1">ConfigurationBuilder</span></kbd><span class="koboSpan" id="kobo.37.1"> class is created in the first sentence of the constructor, and takes care of loading and reading the content of all these .</span><kbd><span class="koboSpan" id="kobo.38.1">json</span></kbd><span class="koboSpan" id="kobo.39.1"> files, and adding environment variables. </span><span class="koboSpan" id="kobo.39.2">This allows further access to any </span><kbd><span class="koboSpan" id="kobo.40.1">json</span></kbd><span class="koboSpan" id="kobo.41.1">-defined value, and the ability to tune-up the application with external information.</span></p>
<p><span class="koboSpan" id="kobo.42.1">With all that info collected, the </span><kbd><span class="koboSpan" id="kobo.43.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.44.1"> method comes and registers a set of services, such as MVC, by adding a </span><kbd><span class="koboSpan" id="kobo.45.1">UseMvc</span></kbd><span class="koboSpan" id="kobo.46.1"> call (yes, it's not available by default, and has to be explicitly added to the pipeline if we want to use that architecture).</span></p>
<p><span class="koboSpan" id="kobo.47.1">As you've seen along these samples, this ASP.NET middleware, such as MVC, follows a convention of using a single </span><kbd><span class="koboSpan" id="kobo.48.1">Add</span><em><span class="koboSpan" id="kobo.49.1">ServiceName</span></em></kbd><span class="koboSpan" id="kobo.50.1"> extension method to register all of the services required by that feature. </span><span class="koboSpan" id="kobo.50.2">Also, notice that this call only adds the service to the collection of services, but it does not configure it (that comes later).</span></p>
<p><span class="koboSpan" id="kobo.51.1">Then, the </span><kbd><span class="koboSpan" id="kobo.52.1">Configure()</span></kbd><span class="koboSpan" id="kobo.53.1"> method comes in. </span><span class="koboSpan" id="kobo.53.2">It first recovers information from the </span><kbd><span class="koboSpan" id="kobo.54.1">Configuration</span></kbd><span class="koboSpan" id="kobo.55.1"> object (</span><kbd><span class="koboSpan" id="kobo.56.1">Logging</span></kbd><span class="koboSpan" id="kobo.57.1"> section) and adds debugging capabilities in the way we saw in the previous chapter.</span></p>
<p><span class="koboSpan" id="kobo.58.1">It follows with error handling, by checking if we are in development mode or another one (it also enables </span><kbd><span class="koboSpan" id="kobo.59.1">BrowserLink</span></kbd><span class="koboSpan" id="kobo.60.1"> capabilities), and goes on with a call to </span><kbd><span class="koboSpan" id="kobo.61.1">UseStaticFiles()</span></kbd><span class="koboSpan" id="kobo.62.1">, to allow recovering and serving local files (you guessed it, it's not available by default, either).</span></p>
<p><span class="koboSpan" id="kobo.63.1">Notice that this feature can be configured to point someplace else (relative request path) on the server (see the screenshot):</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.64.1"><img height="94" width="564" class=" image-border" src="assets/3c44a65c-ad4a-4160-8695-e06c9ca28e45.png"/></span></div>
<p><span class="koboSpan" id="kobo.65.1">The last step is configuring MVC routes with a call to </span><kbd><span class="koboSpan" id="kobo.66.1">UseMvc()</span></kbd><span class="koboSpan" id="kobo.67.1">, in which the route's configuration is provided. </span><span class="koboSpan" id="kobo.67.2">Notice how different this approach is in comparison to classical ASP.NET MVC 4/5, in which you would register these routes in a different file. </span><span class="koboSpan" id="kobo.67.3">However, the syntax is similar, only this time you define it via lambda expressions.</span></p>
<p><span class="koboSpan" id="kobo.68.1">As you can deduct from the code, the first lambda argument is given by Dependency Injection and it's of type </span><kbd><span class="koboSpan" id="kobo.69.1">IRootBuilder</span></kbd><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">Take a look at the Intellisense information provided by the IDE to check this feature, which is shown in the following screenshot:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.71.1"><img height="65" width="508" class=" image-border" src="assets/af2577e7-c2ee-40f8-a2ee-8d4ffc87c0b9.png"/></span></div>
<p><span class="koboSpan" id="kobo.72.1">The default route is then configured to point to the </span><kbd><span class="koboSpan" id="kobo.73.1">HomeController</span></kbd><span class="koboSpan" id="kobo.74.1"> class and the </span><kbd><span class="koboSpan" id="kobo.75.1">Index</span></kbd><span class="koboSpan" id="kobo.76.1"> action method if no other combination is supplied by the request (the syntax has also been a bit simplified).</span></p>
<p><span class="koboSpan" id="kobo.77.1">So, our conclusion after this trip through the </span><kbd><span class="koboSpan" id="kobo.78.1">Startup</span></kbd><span class="koboSpan" id="kobo.79.1"> class is that the most important architectural aspects of ASP.NET Core and its MVC variant are provided via Dependency Injection, and that it is the developer's duty to tune up their application in this manner having the ability to include/exclude only those pieces that are needed by the application, with the minimum overload.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using Dependency Injection in ASP.NET MVC Views</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Steve Smith proposes a demo (</span><a href="http://ardalis.com/how-to-list-all-services-available-to-an-asp-net-core-app"><span class="URLPACKT"><span class="koboSpan" id="kobo.3.1">http://ardalis.com/how-to-list-all-services-available-to-an-asp-net-core-app</span></span></a><span class="koboSpan" id="kobo.4.1">) that can clarify the total of services available at a given moment.</span></p>
<p><span class="koboSpan" id="kobo.5.1">This gave me an idea for another demo about how to include the namespace </span><kbd><span class="koboSpan" id="kobo.6.1">Microsoft.Extensions.DependencyInjection</span></kbd><span class="koboSpan" id="kobo.7.1"> inside a view, using MVC to obtain a list of all services available. </span><span class="koboSpan" id="kobo.7.2">So let's start with the default template we just analyzed, and make the proper modifications.</span></p>
<p><span class="koboSpan" id="kobo.8.1">First, if we want to integrate the list as a new option inside the main menu of the Web Application template, we need to add a new link inside the </span><kbd><span class="koboSpan" id="kobo.9.1">_Layout.cshtml</span></kbd><span class="koboSpan" id="kobo.10.1"> file that points to the corresponding view that will show all our services. </span><span class="koboSpan" id="kobo.10.2">That's quite straightforward (notice that there's no </span><kbd><span class="koboSpan" id="kobo.11.1">ActionLinks</span></kbd><span class="koboSpan" id="kobo.12.1"> here as in the previous version):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.13.1"><img height="106" width="612" class=" image-border" src="assets/7e975755-6c3a-42ad-8fae-71d1dd60d6cf.png"/></span></div>
<p><span class="koboSpan" id="kobo.14.1">With this new line, we're creating a new application menu element and the corresponding view (later named </span><kbd><span class="koboSpan" id="kobo.15.1">ServicesAvailable</span></kbd><span class="koboSpan" id="kobo.16.1">) will take advantage of Bootstrap classes loaded in the </span><kbd><span class="koboSpan" id="kobo.17.1">_Layout.cshtml</span></kbd><span class="koboSpan" id="kobo.18.1"> header, to format the output and make it more readable.</span></p>
<p><span class="koboSpan" id="kobo.19.1">Now, if we think about the controller (</span><kbd><span class="koboSpan" id="kobo.20.1">HomeController</span></kbd><span class="koboSpan" id="kobo.21.1"> in this case), we can add a new action method, following the syntax of the other methods, using the </span><kbd><span class="koboSpan" id="kobo.22.1">ViewData</span></kbd><span class="koboSpan" id="kobo.23.1"> object to pass the required information to our new view.</span></p>
<p><span class="koboSpan" id="kobo.24.1">The information we need is stored in the instance of the </span><kbd><span class="koboSpan" id="kobo.25.1">IServiceCollection</span></kbd><span class="koboSpan" id="kobo.26.1"> object defined inside </span><kbd><span class="koboSpan" id="kobo.27.1">Startup.cs</span></kbd><span class="koboSpan" id="kobo.28.1">, and we want to make it available for the controller so we can later assign it to our </span><kbd><span class="koboSpan" id="kobo.29.1">ViewData</span></kbd><span class="koboSpan" id="kobo.30.1"> messenger.</span></p>
<p><span class="koboSpan" id="kobo.31.1">Let's revisit the </span><kbd><span class="koboSpan" id="kobo.32.1">Startup</span></kbd><span class="koboSpan" id="kobo.33.1">, and make a few changes (not many). </span><span class="koboSpan" id="kobo.33.2">Actually, only these are required:</span></p>
<pre><span class="koboSpan" id="kobo.34.1">    public static IServiceCollection _services { get; private set; } 
    public void ConfigureServices(IServiceCollection services) 
    { 
      // Add framework services. 
      </span><span class="koboSpan" id="kobo.34.2">services.AddMvc(); 
      _services = services; 
   } </span></pre>
<p><span class="koboSpan" id="kobo.35.1">We create a public static variable (</span><kbd><span class="koboSpan" id="kobo.36.1">_services</span></kbd><span class="koboSpan" id="kobo.37.1">) to hold all services once they have been configured and assign the </span><kbd><span class="koboSpan" id="kobo.38.1">services</span></kbd><span class="koboSpan" id="kobo.39.1"> variable to it with the sole purpose of accessing its content from the controller.</span></p>
<p><span class="koboSpan" id="kobo.40.1">Now, back to the </span><kbd><span class="koboSpan" id="kobo.41.1">HomeController</span></kbd><span class="koboSpan" id="kobo.42.1">, we can add a new controller with this code:</span></p>
<pre><span class="koboSpan" id="kobo.43.1">    public IActionResult ServicesAvailable() 
    { 
      ViewData["Services"] = Startup._services; 
      return View(); 
    } </span></pre>
<p><span class="koboSpan" id="kobo.44.1">With these few lines, our services are now available inside the controller, and we can pass them to the view in a very simple way (notice there's no data model here since it's just a simple collection of data and the </span><kbd><span class="koboSpan" id="kobo.45.1">ViewData</span></kbd><span class="koboSpan" id="kobo.46.1"> object serves just fine for this purpose).</span></p>
<p><span class="koboSpan" id="kobo.47.1">Finally, the last step will be to add the </span><kbd><span class="koboSpan" id="kobo.48.1">ServicesAvailable</span></kbd><span class="koboSpan" id="kobo.49.1"> view. </span><span class="koboSpan" id="kobo.49.2">The code will be the following (I'll start with the header's explanation):</span></p>
<pre><span class="koboSpan" id="kobo.50.1">    @using Microsoft.Extensions.DependencyInjection; 
    @{ 
      ViewData["Title"] = "Services Available"; 
      var _services = @ViewData["Services"]; 
    } 
    &lt;h2&gt;@ViewData["Title"]&lt;/h2&gt; 
    &lt;h1&gt;All Services&lt;/h1&gt; </span></pre>
<p><span class="koboSpan" id="kobo.51.1">First, recall that when we make a reference to a namespace inside a view, the </span><kbd><span class="koboSpan" id="kobo.52.1">using</span></kbd><span class="koboSpan" id="kobo.53.1"> sentence shall not belong to a block of code. </span><span class="koboSpan" id="kobo.53.2">Instead, it will be a standalone sentence headed by the </span><kbd><span class="koboSpan" id="kobo.54.1">@</span></kbd><span class="koboSpan" id="kobo.55.1"> sign (we need the </span><kbd><span class="koboSpan" id="kobo.56.1">DependencyInjection</span></kbd><span class="koboSpan" id="kobo.57.1"> namespace to cast the information passed inside the </span><kbd><span class="koboSpan" id="kobo.58.1">ViewData</span></kbd><span class="koboSpan" id="kobo.59.1"> object into a real </span><kbd><span class="koboSpan" id="kobo.60.1">IServiceCollection</span></kbd><span class="koboSpan" id="kobo.61.1"> object).</span></p>
<p><span class="koboSpan" id="kobo.62.1">Next, we recover that info inside a variable (that will be available locally in the whole view). </span><span class="koboSpan" id="kobo.62.2">Observe that I'm using the </span><kbd><span class="koboSpan" id="kobo.63.1">var</span></kbd><span class="koboSpan" id="kobo.64.1"> keyword instead of the interface name because otherwise the compiler will complain. </span><span class="koboSpan" id="kobo.64.2">It's easier to do it this way and make the casting later in the code.</span></p>
<p><span class="koboSpan" id="kobo.65.1">Finally, we'll use a table to present some information hold in three of the services of </span><kbd><span class="koboSpan" id="kobo.66.1">IServiceCollection</span></kbd><span class="koboSpan" id="kobo.67.1"> (called </span><kbd><span class="koboSpan" id="kobo.68.1">_services</span></kbd><span class="koboSpan" id="kobo.69.1"> in the view). </span><span class="koboSpan" id="kobo.69.2">Notice also the casting is made here with the </span><kbd><span class="koboSpan" id="kobo.70.1">as</span></kbd><span class="koboSpan" id="kobo.71.1"> operator to get a real </span><kbd><span class="koboSpan" id="kobo.72.1">IServiceCollection</span></kbd><span class="koboSpan" id="kobo.73.1"> object:</span></p>
<pre><span class="koboSpan" id="kobo.74.1">    &lt;table class="table table-bordered"&gt; 
    &lt;thead&gt; 
        &lt;tr&gt; 
            &lt;th&gt;Type&lt;/th&gt; 
            &lt;th&gt;Lifetime&lt;/th&gt; 
            &lt;th&gt;Instance&lt;/th&gt; 
        &lt;/tr&gt; 
    &lt;/thead&gt; 
    &lt;tbody&gt; 
     @foreach (var svc in _services as IServiceCollection) 
     { 
       &lt;tr&gt; 
       &lt;td&gt;@svc.ServiceType.Name&lt;/td&gt;           </span><br/><span class="koboSpan" id="kobo.75.1">        &lt;td&gt;@svc.Lifetime&lt;/td&gt;            </span><br/><span class="koboSpan" id="kobo.76.1">        &lt;td&gt;@svc.ImplementationType?.Name&lt;/td&gt; 
        &lt;/tr&gt; 
     } 
    &lt;/tbody&gt; 
    &lt;/table&gt; </span></pre>
<p><span class="koboSpan" id="kobo.77.1">And that's all! </span><span class="koboSpan" id="kobo.77.2">Now we can launch the application and select the new menu element </span><em><span class="koboSpan" id="kobo.78.1">List of Services</span></em><span class="koboSpan" id="kobo.79.1">. </span><span class="koboSpan" id="kobo.79.2">A new view will show up containing a, pretty long list of services available in this architecture, showing at the same time how we can make use of the </span><kbd><span class="koboSpan" id="kobo.80.1">DependencyInjection</span></kbd><span class="koboSpan" id="kobo.81.1"> namespace (or any other) inside a view (see the following screenshot):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.82.1"><img height="479" width="630" class=" image-border" src="assets/a075f92c-562f-47fe-8bcb-068821d7d668.png"/></span></div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Garbage Collection and Custom Services</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In relation to Garbage Collection behavior, ASP.NET MVC automates some operations and leaves others to the user's discretion.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The main rule is as follows: if you register a service and call its constructor inside the process, it's your obligation to dispose of that object, otherwise if the container is in charge of creating the object, it will call </span><kbd><span class="koboSpan" id="kobo.4.1">Dispose()</span></kbd><span class="koboSpan" id="kobo.5.1"> on any object it implements.</span></p>
<p><span class="koboSpan" id="kobo.6.1">In practice, imagine we have a couple of services (</span><kbd><span class="koboSpan" id="kobo.7.1">Service1</span></kbd><span class="koboSpan" id="kobo.8.1"> and </span><kbd><span class="koboSpan" id="kobo.9.1">Service2</span></kbd><span class="koboSpan" id="kobo.10.1">) located in a folder (</span><kbd><span class="koboSpan" id="kobo.11.1">Services</span></kbd><span class="koboSpan" id="kobo.12.1">), and that both implement the </span><kbd><span class="koboSpan" id="kobo.13.1">Disposable</span></kbd><span class="koboSpan" id="kobo.14.1"> interface. </span><span class="koboSpan" id="kobo.14.2">To simplify this part, I collapsed the code, so I'm just showing the relevant lines to understand this idea (see the following screenshot):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.15.1"><img height="160" width="295" class=" image-border" src="assets/1359a310-8963-41da-ae98-a8389a0eb133.png"/></span></div>
<p><span class="koboSpan" id="kobo.16.1">The behavior will be different depending on the instantiation of each service (I've commented on each case so you'll see the difference):</span></p>
<pre><span class="koboSpan" id="kobo.17.1">    publicvoidConfigureServices</span><strong><span class="koboSpan" id="kobo.18.1">(</span></strong><strong><span class="koboSpan" id="kobo.19.1">IServiceCollection</span></strong><span class="koboSpan" id="kobo.20.1">services</span><strong><span class="koboSpan" id="kobo.21.1">)</span><br/></strong><strong><span class="koboSpan" id="kobo.22.1">    {</span><br/></strong><span class="koboSpan" id="kobo.23.1">     // Add framework services</span><br/><span class="koboSpan" id="kobo.24.1">     services</span><strong><span class="koboSpan" id="kobo.25.1">.</span></strong><span class="koboSpan" id="kobo.26.1">AddMvc</span><strong><span class="koboSpan" id="kobo.27.1">();</span><br/></strong><span class="koboSpan" id="kobo.28.1">     // container will create the instance(s) of these types</span><br/><span class="koboSpan" id="kobo.29.1">     // and will dispose themservices</span><br/><span class="koboSpan" id="kobo.30.1">     AddScoped</span><strong><span class="koboSpan" id="kobo.31.1">&lt;</span></strong><strong><span class="koboSpan" id="kobo.32.1">Service1</span></strong><strong><span class="koboSpan" id="kobo.33.1">&gt;();</span><br/></strong><span class="koboSpan" id="kobo.34.1">     // Here, the container did not create instance (we do it)</span><br/><span class="koboSpan" id="kobo.35.1">     // so it will NOT dispose itservices</span><br/><span class="koboSpan" id="kobo.36.1">     AddSingleton</span><strong><span class="koboSpan" id="kobo.37.1">(</span></strong><span class="koboSpan" id="kobo.38.1">new</span><strong><span class="koboSpan" id="kobo.39.1">Service2</span></strong><strong><span class="koboSpan" id="kobo.40.1">());</span><br/></strong><strong><span class="koboSpan" id="kobo.41.1">    }</span></strong></pre>
<p><span class="koboSpan" id="kobo.42.1">In all, it is a pretty convenient way to manage garbage collection of services.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using Custom Services through Dependency Injection</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">With this architecture, it is very easy to create any class belonging to our data model, or any other part of the application, and have it ready and available for Dependency Injection, with all the advantages linked to it.</span></p>
<p><span class="koboSpan" id="kobo.3.1">For example, imagine that we want some adornment in one of our views in the form of a random sentence (about programmers and software engineers, for instance), and that we would like the classes that hold the information to be treated as a service, via Dependency Injection, so we can use that content in distinct application's views.</span></p>
<p><span class="koboSpan" id="kobo.4.1">We can rename the classes used in the previous sample as </span><kbd><span class="koboSpan" id="kobo.5.1">ProgrammerSentenceSvc</span></kbd><span class="koboSpan" id="kobo.6.1"> and </span><kbd><span class="koboSpan" id="kobo.7.1">EngineerSentenceSvc</span></kbd><span class="koboSpan" id="kobo.8.1"> and add some very simple information: a </span><kbd><span class="koboSpan" id="kobo.9.1">List&lt;string&gt;</span></kbd><span class="koboSpan" id="kobo.10.1"> of sentences that will be used later inside our controller to randomly retrieve a couple of these sentences and pass them to the corresponding view.</span></p>
<p><span class="koboSpan" id="kobo.11.1">So let's modify our services to hold the required information (I'm just showing these captures, to focus on the relevant code):</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.12.1"><img height="198" width="446" class=" image-border" src="assets/a6432441-aa7a-425b-ab22-2004c42d6e48.png"/></span></div>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.13.1"><img height="213" width="442" class=" image-border" src="assets/0fbe71e2-7b9f-4116-bf79-1334804b7ca8.png"/></span></div>
<p><span class="koboSpan" id="kobo.14.1">The next step will be to register these classes in the </span><kbd><span class="koboSpan" id="kobo.15.1">Startup</span></kbd><span class="koboSpan" id="kobo.16.1"> class via </span><kbd><span class="koboSpan" id="kobo.17.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.18.1">, as we've seen before (I'm using two distinct syntaxes just to show):</span></p>
<pre><span class="koboSpan" id="kobo.19.1">    publicvoidConfigureServices</span><strong><span class="koboSpan" id="kobo.20.1">(</span></strong><strong><span class="koboSpan" id="kobo.21.1">IServiceCollection</span></strong><span class="koboSpan" id="kobo.22.1">services</span><strong><span class="koboSpan" id="kobo.23.1">)</span><br/></strong><strong><span class="koboSpan" id="kobo.24.1">   {</span><br/></strong><span class="koboSpan" id="kobo.25.1">    // Add framework services.</span><br/><span class="koboSpan" id="kobo.26.1">    services</span><strong><span class="koboSpan" id="kobo.27.1">.</span></strong><span class="koboSpan" id="kobo.28.1">AddMvc</span><strong><span class="koboSpan" id="kobo.29.1">();</span><br/></strong><span class="koboSpan" id="kobo.30.1">    // container will create the instance(s) of these types</span><br/><span class="koboSpan" id="kobo.31.1">    // and will dispose them</span><br/><span class="koboSpan" id="kobo.32.1">    services</span><strong><span class="koboSpan" id="kobo.33.1">.</span></strong><span class="koboSpan" id="kobo.34.1">AddScoped</span><strong><span class="koboSpan" id="kobo.35.1">&lt;</span></strong><strong><span class="koboSpan" id="kobo.36.1">ProgrammerSentenceSvc</span></strong><strong><span class="koboSpan" id="kobo.37.1">&gt;();</span><br/></strong><span class="koboSpan" id="kobo.38.1">    // Here, the container did not create instance (we do it)</span><br/><span class="koboSpan" id="kobo.39.1">    // so it will NOT dispose it</span><br/><span class="koboSpan" id="kobo.40.1">    services</span><strong><span class="koboSpan" id="kobo.41.1">.</span></strong><span class="koboSpan" id="kobo.42.1">AddSingleton</span><strong><span class="koboSpan" id="kobo.43.1">(</span></strong><span class="koboSpan" id="kobo.44.1">new</span><strong><span class="koboSpan" id="kobo.45.1">EngineerSentenceSvc</span></strong><strong><span class="koboSpan" id="kobo.46.1">());</span><br/></strong><strong><span class="koboSpan" id="kobo.47.1">  }</span></strong></pre>
<p><span class="koboSpan" id="kobo.48.1">That's all we need to have our services available inside any controller. </span><span class="koboSpan" id="kobo.48.2">So, let's revisit our </span><kbd><span class="koboSpan" id="kobo.49.1">HomeController</span></kbd><span class="koboSpan" id="kobo.50.1">, and add the following action method (remember that we have to make a reference to our Services namespace, via </span><kbd><span class="koboSpan" id="kobo.51.1">using ASPNETCoreDisposeDemo.Services;</span></kbd><span class="koboSpan" id="kobo.52.1">):</span></p>
<pre><span class="koboSpan" id="kobo.53.1">    publicIActionResultSentences(ProgrammerSentenceSvcsvc,</span><br/><span class="koboSpan" id="kobo.54.1">        EngineerSentenceSvcsvc2</span><br/><span class="koboSpan" id="kobo.55.1">     {</span><br/><span class="koboSpan" id="kobo.56.1">      Randomrnd = newRandom();ViewData["ProgSentence"] = </span><br/><span class="koboSpan" id="kobo.57.1">          svc.programmersSentences[rnd.Next(1,5)];</span><br/><span class="koboSpan" id="kobo.58.1">      ViewData["EngSentence"] = svc2.engineersSentences[rnd.Next(1,5)];</span><br/><span class="koboSpan" id="kobo.59.1">      returnView();</span><br/><span class="koboSpan" id="kobo.60.1">     }</span></pre>
<p><span class="koboSpan" id="kobo.61.1">And that's it! </span><span class="koboSpan" id="kobo.61.2">Any service registered in that manner is automatically available inside a controller via Dependency Injection, merely by making a reference to it as a parameter of the corresponding action method.</span></p>
<p><span class="koboSpan" id="kobo.62.1">The last step is to create the view named </span><kbd><span class="koboSpan" id="kobo.63.1">Sentences</span></kbd><span class="koboSpan" id="kobo.64.1"> to recover the information and present it to the user:</span></p>
<pre><span class="koboSpan" id="kobo.65.1">    @{ViewData["Title"] = "Random sentences about programmers</span><br/><span class="koboSpan" id="kobo.66.1">       and engineers";</span><br/><span class="koboSpan" id="kobo.67.1">    }</span><br/><span class="koboSpan" id="kobo.68.1">     &lt;h1&gt;@ViewData["Title"].&lt;/h1&gt;</span><br/><span class="koboSpan" id="kobo.69.1">     &lt; hr /&gt;</span><br/><span class="koboSpan" id="kobo.70.1">     &lt; h1 &gt; Programmer's Sentence &lt;/ h1 &gt;</span><br/><span class="koboSpan" id="kobo.71.1">     &lt;h2&gt;@ViewData["ProgSentence"]&lt;/h2&gt;</span><br/><span class="koboSpan" id="kobo.72.1">     &lt; h1 &gt; Engineers' Sentence &lt;/ h1 &gt;</span><br/><span class="koboSpan" id="kobo.73.1">     &lt;h2&gt;@ViewData["EngSentence"]&lt;/h2&gt;</span></pre>
<p><span class="koboSpan" id="kobo.74.1">If we have added (just like before), a new link next to the default menu pointing to the name of this action method, we'll see the following output:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.75.1"><img height="409" width="541" class=" image-border" src="assets/995a1979-bb06-4548-8fc9-ea56097b31b8.png"/></span></div>
<p><span class="koboSpan" id="kobo.76.1">As you see, the output is the expected one, and the general architecture of the application with respect to the MVC model is quite similar to previous versions.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Services and data management</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">Although data management is not the target of this book, I'd like to mention that the architecture proposed when accessing data inside ASP.NET Core MVC applications is relatively alike.</span></p>
<p><span class="koboSpan" id="kobo.3.1">To test this feature and highlight those parts directly related to Dependency Injection, follow the initial instructions at </span><a href="https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/existing-db"><span class="URLPACKT"><span class="koboSpan" id="kobo.4.1">https://docs.microsoft.com/en-us/ef/core/get-started/aspnetcore/existing-db</span></span></a><span class="koboSpan" id="kobo.5.1">. </span><span class="koboSpan" id="kobo.5.2">That creates a very simple database using SQLLocalDb called </span><kbd><span class="koboSpan" id="kobo.6.1">Blogging</span></kbd><span class="koboSpan" id="kobo.7.1">. </span><span class="koboSpan" id="kobo.7.2">It creates a </span><kbd><span class="koboSpan" id="kobo.8.1">Blogs</span></kbd><span class="koboSpan" id="kobo.9.1"> table and adds three registers, just to have some data to work with. </span><span class="koboSpan" id="kobo.9.2">You'll also find a link to the complete sample it proposes using several approaches: Database First, New Database, and so on.</span></p>
<p><span class="koboSpan" id="kobo.10.1">What I would like to point out here is those fragments of code that imply the use of DI inside that solution.</span></p>
<p><span class="koboSpan" id="kobo.11.1">In the </span><kbd><span class="koboSpan" id="kobo.12.1">Models'</span></kbd><span class="koboSpan" id="kobo.13.1"> application folder you'll find the definition of the model based on that database in a similar way to the usual result when you scaffold an existing database using classic Entity Framework. </span><span class="koboSpan" id="kobo.13.2">The main class inherits from </span><kbd><span class="koboSpan" id="kobo.14.1">DbContext</span></kbd><span class="koboSpan" id="kobo.15.1">, defines public virtual properties pointing to the existing entities, and names the </span><kbd><span class="koboSpan" id="kobo.16.1">DBContext</span></kbd><span class="koboSpan" id="kobo.17.1"> instance </span><kbd><span class="koboSpan" id="kobo.18.1">BloggingContext</span></kbd><span class="koboSpan" id="kobo.19.1">.</span></p>
<p><span class="koboSpan" id="kobo.20.1">Consequently, the first ste</span><span><span class="koboSpan" id="kobo.21.1">p is to register that context inside the</span></span> <kbd><span class="koboSpan" id="kobo.22.1">ConfigureServices</span></kbd> <span><span class="koboSpan" id="kobo.23.1">method, for which it does the following:</span></span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.24.1"><img height="111" width="595" src="assets/58d934a3-79f8-442f-9b63-1cfd15f74918.png"/></span></div>
<p><span class="koboSpan" id="kobo.25.1">As you see, the connection string is defined directly so that it points to the newly created database (</span><kbd><span class="koboSpan" id="kobo.26.1">Blogging</span></kbd><span class="koboSpan" id="kobo.27.1">).</span></p>
<p><span class="koboSpan" id="kobo.28.1">Next, the services variable is populated with a new entry via the generic method </span><kbd><span class="koboSpan" id="kobo.29.1">AddDbContext&lt;BlogginContext&gt;.</span></kbd><span class="koboSpan" id="kobo.30.1"> And, to link that </span><kbd><span class="koboSpan" id="kobo.31.1">DbContext</span></kbd><span class="koboSpan" id="kobo.32.1"> to the </span><kbd><span class="koboSpan" id="kobo.33.1">Blogging</span></kbd><span class="koboSpan" id="kobo.34.1"> database and </span><kbd><span class="koboSpan" id="kobo.35.1">Action</span></kbd><span class="koboSpan" id="kobo.36.1"> delegate is passed to the method, allowing it to override the </span><kbd><span class="koboSpan" id="kobo.37.1">OnConfiguring</span></kbd><span class="koboSpan" id="kobo.38.1"> method of the </span><kbd><span class="koboSpan" id="kobo.39.1">BloggingContext</span></kbd><span class="koboSpan" id="kobo.40.1"> class. </span><span class="koboSpan" id="kobo.40.2">In this manner, the real connection configuration can be delayed until this method is called.</span></p>
<p><span class="koboSpan" id="kobo.41.1">Finally, how does the </span><kbd><span class="koboSpan" id="kobo.42.1">BloggingController</span></kbd><span class="koboSpan" id="kobo.43.1"> class access this </span><kbd><span class="koboSpan" id="kobo.44.1">BloggingContext</span></kbd><span class="koboSpan" id="kobo.45.1">? </span><span class="koboSpan" id="kobo.45.2">By Dependency Injection in its constructor. </span><span class="koboSpan" id="kobo.45.3">It operates in a similar way to what we did in the previous sample:</span></p>
<div class="CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.46.1"><img height="139" width="357" src="assets/f9857b83-0a7e-46c5-a34b-3f7a5a705364.png"/></span></div>
<p><span class="koboSpan" id="kobo.47.1">The output shows the three entries loaded in the </span><kbd><span class="koboSpan" id="kobo.48.1">Blogs</span></kbd><span class="koboSpan" id="kobo.49.1"> table, just as expected, with the typical CRUD options, presenting the information via Razor views, but it's interesting to highlight the role of DI in this architecture as well (see the following screenshot):</span></p>
<div class="mce-root CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.50.1"><img height="304" width="514" src="assets/ff666b1a-21c5-4c90-96f0-f0ef01760a83.png"/></span></div>
<p><span class="koboSpan" id="kobo.51.1">Again, you've seen how DI is also present in .NET Core-related platforms, such as Entity Framework Core.</span></p>
<p><span class="koboSpan" id="kobo.52.1">However, there's an interesting point we haven't covered yet. </span><span class="koboSpan" id="kobo.52.2">We saw how to make a reference to the </span><kbd><span class="koboSpan" id="kobo.53.1">DependencyInjection Namespace</span></kbd><span class="koboSpan" id="kobo.54.1"> inside a view, but we were not really using DI. </span><span class="koboSpan" id="kobo.54.2">Let's see how to use the new </span><kbd><span class="koboSpan" id="kobo.55.1">@inject</span></kbd><span class="koboSpan" id="kobo.56.1"> directive inside a view with a simple demo.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Using Dependency Injection inside Views</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">For completeness, I'm going to explain a simple demo of how to use DI inside a Razor view. </span><span class="koboSpan" id="kobo.2.2">It's a quite interesting feature and it can be useful to access data, service-related information, or even your own Razor helpers.</span></p>
<p><span class="koboSpan" id="kobo.3.1">The idea is to create another view that is able to access the same data as our previous </span><kbd><span class="koboSpan" id="kobo.4.1">Services</span></kbd><span class="koboSpan" id="kobo.5.1"> View, but this time without implying the controller in the business logic. </span><span class="koboSpan" id="kobo.5.2">Besides that, I'll create a Razor helper just to show how we can do both tasks thanks to the </span><kbd><span class="koboSpan" id="kobo.6.1">@inject</span></kbd><span class="koboSpan" id="kobo.7.1"> directive.</span></p>
<p><span class="koboSpan" id="kobo.8.1">First, inside a new folder (</span><kbd><span class="koboSpan" id="kobo.9.1">Helpers</span></kbd><span class="koboSpan" id="kobo.10.1">), let's create a simple helper that provides some kind of information (for instance the current system's time):</span></p>
<pre><span class="koboSpan" id="kobo.11.1">    namespaceASPNETCoreDisposeDemo.Helpers{</span><br/><span class="koboSpan" id="kobo.12.1">      publicclassDateTimeHelpers</span><br/><span class="koboSpan" id="kobo.13.1">      {</span><br/><span class="koboSpan" id="kobo.14.1">        publicDateTimeHelpers()</span><br/><span class="koboSpan" id="kobo.15.1">        {</span><br/><span class="koboSpan" id="kobo.16.1">          LocalTime = DateTime.Now.TimeOfDay.ToString();</span><br/><span class="koboSpan" id="kobo.17.1">        }</span><br/><span class="koboSpan" id="kobo.18.1">          publicstringLocalTime { get; privateset; }</span><br/><span class="koboSpan" id="kobo.19.1">      }</span><br/><span class="koboSpan" id="kobo.20.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.21.1">With this new service in place, we need to register it as we did with the </span><kbd><span class="koboSpan" id="kobo.22.1">Sentences*</span></kbd><span class="koboSpan" id="kobo.23.1"> services. </span><span class="koboSpan" id="kobo.23.2">The new version of the </span><kbd><span class="koboSpan" id="kobo.24.1">ConfigureServices</span></kbd><span class="koboSpan" id="kobo.25.1"> method will look as follows:</span></p>
<pre><span class="koboSpan" id="kobo.26.1">    publicvoidConfigureServices(IServiceCollectionservices)</span><br/><span class="koboSpan" id="kobo.27.1">    {</span><br/><span class="koboSpan" id="kobo.28.1">      // Add framework services.</span><br/><span class="koboSpan" id="kobo.29.1">      services.AddMvc();</span><br/><span class="koboSpan" id="kobo.30.1">      // container will create the instance(s) of these types</span><br/><span class="koboSpan" id="kobo.31.1">      // and will dispose them</span><br/><span class="koboSpan" id="kobo.32.1">      services.AddScoped&lt;ProgrammerSentenceSvc&gt;();</span><br/><span class="koboSpan" id="kobo.33.1">      // Here, the container did not create instance (we do it)</span><br/><span class="koboSpan" id="kobo.34.1">      // so it will NOT dispose it</span><br/><span class="koboSpan" id="kobo.35.1">      services.AddSingleton(newEngineerSentenceSvc());</span><br/><span class="koboSpan" id="kobo.36.1">      services.AddTransient&lt;DateTimeHelpers&gt;();</span><br/><span class="koboSpan" id="kobo.37.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.38.1">This is all we need on the business logic side since we can use the existing services, only in a different way. </span><span class="koboSpan" id="kobo.38.2">So, I'll create another action method as part of the </span><kbd><span class="koboSpan" id="kobo.39.1">HomeController</span></kbd><span class="koboSpan" id="kobo.40.1"> named </span><kbd><span class="koboSpan" id="kobo.41.1">ServicesDI</span></kbd><span class="koboSpan" id="kobo.42.1">, and try to replicate the previous functionality.</span></p>
<p><span class="koboSpan" id="kobo.43.1">We can also use the </span><kbd><span class="koboSpan" id="kobo.44.1">[Route("key")]</span></kbd><span class="koboSpan" id="kobo.45.1"> attribute to redirect URL queries to this action method. </span><span class="koboSpan" id="kobo.45.2">Actually, it's even simpler than the others:</span></p>
<pre><span class="koboSpan" id="kobo.46.1">    [Route("SentencesDI")]publicIActionResultSentencesDI()</span><br/><span class="koboSpan" id="kobo.47.1">    {</span><br/><span class="koboSpan" id="kobo.48.1">       returnView();</span><br/><span class="koboSpan" id="kobo.49.1">    }</span></pre>
<p><span class="koboSpan" id="kobo.50.1">The rest of the programming logic is deferred to the view itself. </span><span class="koboSpan" id="kobo.50.2">Thus, the </span><kbd><span class="koboSpan" id="kobo.51.1">SentencesDI</span></kbd><span class="koboSpan" id="kobo.52.1"> View will have to reference the namespaces related to the services it is going to use, and declare any service required:</span></p>
<pre><span class="koboSpan" id="kobo.53.1">    @usingASPNETCoreDisposeDemo.Helpers</span><br/><span class="koboSpan" id="kobo.54.1">    @usingASPNETCoreDisposeDemo.Services</span><br/><span class="koboSpan" id="kobo.55.1">    @inject DateTimeHelpersTimeHelpers</span><br/><span class="koboSpan" id="kobo.56.1">    @inject ProgrammerSentenceSvcPSentences</span><br/><span class="koboSpan" id="kobo.57.1">    @inject EngineerSentenceSvcESentences</span><br/><span class="koboSpan" id="kobo.58.1">    @{</span><br/><span class="koboSpan" id="kobo.59.1">      Randomrnd = newRandom();</span><br/><span class="koboSpan" id="kobo.60.1">       ViewData["Title"] = "Random sentences obtained via</span><br/><span class="koboSpan" id="kobo.61.1">            Dependency Injection";</span><br/><span class="koboSpan" id="kobo.62.1">     }</span><br/><span class="koboSpan" id="kobo.63.1">     &lt;h1&gt;@ViewData["Title"]&lt;/h1&gt;</span><br/><span class="koboSpan" id="kobo.64.1">     &lt;h3&gt;Local Time: @TimeHelpers.LocalTime&lt;/h3&gt;</span><br/><span class="koboSpan" id="kobo.65.1">     &lt; hr /&gt;</span><br/><span class="koboSpan" id="kobo.66.1">     &lt; h2 &gt; Programmer's Sentences (DI) &lt;/ h2 &gt;</span><br/><span class="koboSpan" id="kobo.67.1">     &lt;h3&gt;@PSentences.programmersSentences[rnd.Next(1,5)]&lt;/h3&gt;</span><br/><span class="koboSpan" id="kobo.68.1">     &lt; h2 &gt; Engineers' Sentences (DI) &lt;/ h2 &gt;</span><br/><span class="koboSpan" id="kobo.69.1">     &lt;h3&gt;@ESentences.engineersSentences[rnd.Next(1,5)]&lt;/h3&gt;</span></pre>
<p><span class="koboSpan" id="kobo.70.1">As you can see, the rest of the code is pretty self-explanatory. </span><span class="koboSpan" id="kobo.70.2">Once services are registered and references made, we can use the </span><kbd><span class="koboSpan" id="kobo.71.1">@inject</span></kbd><span class="koboSpan" id="kobo.72.1"> directive to instruct the DI container about the resources that our view is going to need. </span><span class="koboSpan" id="kobo.72.2">The syntax is:</span></p>
<pre><span class="koboSpan" id="kobo.73.1">    @inject [Type] [Name/Alias]  </span></pre>
<p><span class="koboSpan" id="kobo.74.1">In this way, any functionality related to a service that is injected in a view can access the data inside the service without having to process it in the controller. </span><span class="koboSpan" id="kobo.74.2">You might say that this breaks in some way the architecture of the MVC foundations, but there are some circumstances in which it might be interesting to separate certain data from the controller if it is only related to a particular view.</span></p>
<p><span class="koboSpan" id="kobo.75.1">And, surely, you'll find more useful possibilities. </span><span class="koboSpan" id="kobo.75.2">By the way, you can type </span><kbd><span class="koboSpan" id="kobo.76.1">localhost:[port]/ServicesDI</span></kbd><span class="koboSpan" id="kobo.77.1"> in the browser to get the corresponding output:</span></p>
<div class="packt_figure CDPAlignCenter CDPAlign"><span class="koboSpan" id="kobo.78.1"><img height="373" width="505" src="assets/f711fe22-b931-4bf8-a799-3ee618634c7c.png"/></span></div>
<p><span class="koboSpan" id="kobo.79.1">In short, another feature related to Dependency Injection, this time inside the Razor views, that we can use inside the ASP.NET Core platform.</span></p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title"><span class="koboSpan" id="kobo.1.1">Summary</span></h1>
                </header>
            
            <article>
                
<p><span class="koboSpan" id="kobo.2.1">In this chapter, we focused on ASP.NET Core and Dependency Injection, analyzing how the whole architecture and configuration process is based on the internal DI Container of ASP.NET Core.</span></p>
<p><span class="koboSpan" id="kobo.3.1">We also saw how to move from a simple Console app to an ASP.NET Core app, and finally, how the distinct servers for development and production can be tuned up.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Then, we analyzed the main templates offered by Visual Studio 2017 in relation to ASP.NET Core apps and reviewed how they used DI in order to configure and manage the required information and functionality.</span></p>
<p><span class="koboSpan" id="kobo.5.1">Finally, we saw how to use our own custom services and integrate them inside ASP.NET Core using DI, either in the controllers or in the Razor Views.</span></p>
<p><span class="koboSpan" id="kobo.6.1">In </span><a href="c2b6c427-7a04-43d9-93bf-076daeb0f024.xhtml" target="_blank"><span class="koboSpan" id="kobo.7.1">Chapter 5</span></a><span class="koboSpan" id="kobo.8.1">, </span><em><span class="koboSpan" id="kobo.9.1">Object Composition</span></em><span class="koboSpan" id="kobo.10.1">, we will analyze Object Composition and its use within DI contexts.</span></p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    </body></html>