- en: '14'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '14'
- en: Implementing Microservices with .NET
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET实现微服务
- en: In *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise Application*,
    you learned the theory and basic concepts of microservices. In this chapter, you
    will learn how to put into practice those general concepts and tools to implement
    microservices in .NET. This way, you will have a practical understanding of how
    high-level architectural decisions translate into concrete .NET code.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在第11章“将微服务架构应用于您的企业应用程序”中，您学习了微服务的理论和基本概念。在本章中，您将学习如何将这些通用概念和工具应用于.NET中实现微服务。这样，您将有一个实际的理解，了解高级架构决策如何转化为具体的.NET代码。
- en: The focus of this chapter is on worker microservices; that is, microservices
    that are not part of the public interface of your application. Other kinds of
    microservices will be focused on in other chapters. Worker microservices process
    jobs that are not connected to a specific user. They somehow prepare the data
    that will be used by frontend microservices to satisfy all user requests. They
    are the assembly line of each application, so their design priorities are efficiency
    in both communication and local processing, together with protocols that ensure
    data coherence and fault tolerance.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的重点是工作微服务；也就是说，这些微服务不是您应用程序公共接口的一部分。其他类型的微服务将在其他章节中集中讨论。工作微服务处理与特定用户不相关的作业。它们以某种方式准备将被前端微服务使用的数据，以满足所有用户请求。它们是每个应用程序的装配线，因此它们的设计优先级是通信和本地处理的效率，以及确保数据一致性和容错性的协议。
- en: 'You will learn how to implement a frontend service in *Chapter 18*, *Implementing
    Frontend Microservices with ASP.NET Core*, after having learned about techniques
    for implementing a presentation layer in *Chapter 17*, *Presenting ASP.NET Core*.
    Other techniques for implementing presentation layers are described in *Chapter
    19, Client Frameworks: Blazor*, while techniques for implementing public APIs
    will be discussed in *Chapter 15*, *Applying Service-Oriented Architectures with
    .NET*.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在学习了如何在第17章“展示ASP.NET Core”中实现表示层的技术之后，您将在第18章“使用ASP.NET Core实现前端微服务”中学习如何实现前端服务。其他实现表示层的技术在第19章“客户端框架：Blazor”中描述，而实现公共API的技术将在第15章“使用.NET应用服务导向架构”中讨论。
- en: This chapter explains the structure of a .NET microservice and discusses the
    options for exchanging messages and serializing .NET data structures. In particular,
    we will put into practice a lot of concepts analyzed in *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*, such as the concept
    of Generic Host, the techniques for ensuring reliable communication (exponential
    retry, etc.), forward communication, and idempotency of messages.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 本章解释了.NET微服务的结构，并讨论了交换消息和序列化.NET数据结构的选项。特别是，我们将实践在第11章“将微服务架构应用于您的企业应用程序”中分析的大量概念，例如通用宿主的概念、确保可靠通信的技术（指数重试等）、正向通信和消息的幂等性。
- en: 'More specifically, in this chapter, you will learn about the following subjects:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，在本章中，您将学习以下主题：
- en: Communication and data serialization
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通信和数据序列化
- en: Implementing worker microservices with ASP.NET Core
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用ASP.NET Core实现工作微服务
- en: Implementing microservices with .NET worker services and message brokers
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用.NET工作服务和消息代理实现微服务
- en: Each point will be discussed in depth, and the reader can find further practical
    details in the section *A worker microservice with ASP* *.NET core* of *Chapter
    21, Case Study*, which describes in detail three complete implementations of worker
    microservices.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 每个问题都将进行深入讨论，读者可以在第21章“案例研究”的“带有ASP.NET core的工作微服务”部分中找到更多实际细节，该部分详细描述了三个完整的工作微服务实现。
- en: The first section of the chapter discusses the main coordination and queuing
    problems that arise in microservices communication and how to solve them with
    either message brokers or custom permanent queues. These topics are fundamental
    in the design of efficient and fault-tolerant communication, which, in turn, are
    essential requirements for ensuring coherent behavior and low response times of
    the overall application.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的第一部分讨论了微服务通信中出现的协调和排队问题，以及如何通过消息代理或自定义永久队列来解决这些问题。这些主题在设计高效和容错通信时是基本的，而高效的通信和低响应时间是确保整体应用程序行为一致性和响应时间低的基本要求。
- en: The remaining sections include examples of how to implement the same microservice
    with two different techniques. The techniques in the second section are based
    on the ASP.NET Core implementation of gRPC and an SQL Server-based permanent queue.
    It is worth pointing out that this technique requires HTTP/2\. The example in
    the third section shows how to use message brokers and two serialization techniques.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 剩余部分包括使用两种不同技术实现相同微服务的示例。第二部分的技术基于gRPC的ASP.NET Core实现和基于SQL Server的永久队列。值得注意的是，这种技术需要HTTP/2。第三部分的示例展示了如何使用消息代理和两种序列化技术。
- en: 'Message brokers are fundamental for three main reasons:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 消息代理对于以下三个主要原因至关重要：
- en: They take care of most of the communication overhead.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们处理了大部分通信开销。
- en: They support the publisher/subscriber pattern, which promotes the independence
    of communicating microservices.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们支持发布/订阅模式，这促进了通信微服务的独立性。
- en: All main cloud providers offer message broker services. The example uses **RabbitMQ**,
    but RabbitMQ can be replaced by **Azure Service Bus**,the message broker offered
    by Azure. The chapter also explains the pros and cons of different serialization
    techniques.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有主要云服务提供商都提供消息代理服务。示例使用**RabbitMQ**，但RabbitMQ可以被Azure提供的**Azure Service Bus**消息代理所替代。本章还解释了不同序列化技术的优缺点。
- en: Technical requirements
  id: totrans-17
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the free Visual Studio 2022 Community edition or better
    with all database tools installed. The code for this chapter is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要免费Visual Studio 2022 Community版或更高版本，并安装所有数据库工具。本章的代码可在[https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)找到。
- en: Experimenting with message brokers also requires the installation of the RabbitMQ
    message broker (version 3.9 or higher), which in turn requires the previous installation
    of a 64-bit version of Erlang. An adequate Erlang version for RabbitMQ 3.9 can
    be downloaded from [https://github.com/erlang/otp/releases/download/OTP-24.0.6/otp_win64_24.0.6.exe](https://github.com/erlang/otp/releases/download/OTP-24.0.6/otp_win64_24.0.6.exe).
    The RabbitMQ Windows installer can be downloaded from [https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.5/rabbitmq-server-3.9.5.exe](https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.5/rabbitmq-server-3.9.5.exe).
    We recommend you launch both installations from an administrative account.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试消息代理还需要安装RabbitMQ消息代理（版本3.9或更高），这反过来又需要先安装64位版本的Erlang。适用于RabbitMQ 3.9的适当Erlang版本可以从[https://github.com/erlang/otp/releases/download/OTP-24.0.6/otp_win64_24.0.6.exe](https://github.com/erlang/otp/releases/download/OTP-24.0.6/otp_win64_24.0.6.exe)下载。RabbitMQ
    Windows安装程序可以从[https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.5/rabbitmq-server-3.9.5.exe](https://github.com/rabbitmq/rabbitmq-server/releases/download/v3.9.5/rabbitmq-server-3.9.5.exe)下载。我们建议您从管理员账户启动这两个安装。
- en: Three complete examples of worker microservices are in the *A worker microservice
    with ASP.NET core* and *A worker microservice based on RabbitMQ* sections of *Chapter
    21, Case Study*. Each of them exemplifies a technique described in this chapter
    and shows an alternative way of collecting travel statistics in the case study
    application.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在第21章“案例研究”的“具有ASP.NET core的工人微服务”和“基于RabbitMQ的工人微服务”部分中，有三个完整的工人微服务示例。每个示例都展示了本章中描述的技术，并展示了在案例研究应用程序中收集旅行统计数据的替代方法。
- en: Communication and data serialization
  id: totrans-21
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通信和数据序列化
- en: As explained in the *Microservice design principles* subsection of *Chapter
    11*, *Applying a Microservice Architecture to Your Enterprise Application*, requests
    to a microservices-based application can’t cause long chains of recursive microservices
    calls.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 如第11章“微服务设计原则”小节中所述，在“将微服务架构应用于您的企业应用程序”中，对基于微服务的应用程序的请求不能导致递归微服务调用链的长时间链。
- en: In fact, each call adds both a wait time and a communication time to the actual
    processing time, thus leading to unacceptable levels of overall response time,
    as shown in the following figure.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，每次调用都会向实际处理时间添加等待时间和通信时间，从而导致总体响应时间达到不可接受的水平，如下面的图所示。
- en: '![Shape, circle  Description automatically generated](img/B19820_14_01.png)'
  id: totrans-24
  prefs: []
  type: TYPE_IMG
  zh: '![形状，圆形 描述自动生成](img/B19820_14_01.png)'
- en: 'Figure 14.1: Tree of blocking RPC calls'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.1：阻塞RPC调用树
- en: Messages **1-6** are triggered by a request to the **A** microservice and are
    sent in sequence, so their processing times sum up to the response time. Moreover,
    once sent, message **1** from microservice **A** remains blocked until it receives
    the last message (**6**); that is, it remains blocked for the whole lifetime of
    the overall recursive communication process.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 消息 **1-6** 是由对 **A** 微服务的请求触发的，并且按顺序发送，因此它们的处理时间总和等于响应时间。此外，一旦发送，微服务 **A** 发出的消息
    **1** 将保持阻塞状态，直到收到最后一条消息（**6**）；也就是说，它在整个递归通信过程的整个生命周期中保持阻塞。
- en: Microservice **B** remains blocked twice, waiting for an answer to a request
    it issued. The first time is during the **2-3** communication and then the second
    is during the **4-5** communication. To sum up, **Remote Procedure Calls** (**RPCs**)
    involve high response times and a waste of microservices computation time.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 微服务 **B** 两次被阻塞，等待其对请求的响应。第一次是在 **2-3** 沟通期间，第二次是在 **4-5** 沟通期间。总的来说，**远程过程调用**
    (**RPC**) 涉及高响应时间，以及微服务计算时间的浪费。
- en: That’s why microservices avoid blocking recursive RPCs and prefer a data-driven
    approach that starts from the leaves of the procedure calls tree. Put simply,
    tree nodes, instead of waiting for requests from their parent nodes, send pre-processed
    data to all their possible callers each time their private data changes, as shown
    in the following figure.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 正因如此，微服务避免阻塞递归RPC，而更倾向于从过程调用树叶子开始的数据驱动方法。简单来说，树节点，而不是等待父节点的请求，每次其私有数据发生变化时，都会将预处理的发送给所有可能的调用者，如图所示。
- en: '![Diagram  Description automatically generated](img/B19820_14_02.png)'
  id: totrans-29
  prefs: []
  type: TYPE_IMG
  zh: '![图描述自动生成](img/B19820_14_02.png)'
- en: 'Figure 14.2: Data-driven asynchronous communication'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.2：数据驱动异步通信
- en: Both communications labeled **1** are triggered when the data of the **C**/**D**
    microservices changes, and they may occur in parallel. Moreover, once a communication
    is sent, each microservice can return to its job without waiting for a response.
    Finally, when a request arrives at microservice **A**, **A** already has all the
    data it needs to build the response with no need to interact with other microservices.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 在一般情况下，基于数据驱动方法的微服务预先处理数据，并将其发送给可能感兴趣的其他服务。这样，每个微服务已经包含了可以立即用于响应用户请求的预计算数据，无需进行进一步的需求特定通信。
- en: In general, microservices based on the data-driven approach pre-process data
    and send it to whichever other service might be interested. This way, each microservice
    already contains pre-computed data it can use to respond immediately to user requests
    with no need for further request-specific communications.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 标记为 **1** 的通信是在 **C**/**D** 微服务的数据发生变化时触发的，并且可能并行发生。此外，一旦发送通信，每个微服务都可以返回其工作，无需等待响应。最后，当请求到达微服务
    **A** 时，**A** 已经拥有了构建响应所需的所有数据，无需与其他微服务交互。
- en: More specifically, as new data becomes available, each microservice does its
    job and then sends the results to all interested microservices with asynchronous
    communications; that is, a microservice doesn’t wait for any acknowledgment from
    its recipients. Asynchronous communication is a must since each communication
    act usually triggers other communication acts recursively for the recipient, so
    we can’t block the whole tree of microservices until the final acknowledgment
    arrives from all the tree leaves, as in the case of RPC.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '更具体地说，随着新数据的可用，每个微服务完成其工作后，通过异步通信将结果发送给所有感兴趣的微服务；也就是说，微服务不会等待任何接收方的确认。由于每次通信通常都会触发接收方的一系列其他通信，因此异步通信是必需的，我们不能像在RPC的情况下那样，直到从所有树叶节点收到最终确认之前，阻塞整个微服务树。 '
- en: However, while being the only acceptable option for high-traffic microservices,
    the data-driven approach is more difficult to implement. In particular, the absence
    of acknowledgments creates complex coordination problems that increase the application
    development and testing time. We will discuss how to face coordination problems
    later on in the chapter.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，尽管数据驱动方法是高流量微服务的唯一可接受选项，但它的实现更为困难。特别是，缺乏确认会导致复杂的协调问题，从而增加了应用程序开发和测试的时间。我们将在本章后面讨论如何面对协调问题。
- en: Here it is just worth stating the following rule of thumb.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 这里只需陈述以下经验法则。
- en: Use the data-driven approach for all high-traffic worker microservices, but
    for services with shorter request-response cycles and experiencing low to moderate
    amounts of requests, use utilizing RPC (Remote Procedure Call).
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对于所有高流量工作微服务，使用数据驱动方法，但对于请求-响应周期较短且请求量低到中等的微服务，则使用RPC（远程过程调用）。
- en: Therefore, actual applications mix efficient short-path RPC calls with the data-driven
    approach.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，实际应用中通常会结合高效的短路径RPC调用和数据驱动方法。
- en: Another point that is worth mentioning is communication security. When security
    is needed, and communication relies on an underlying TCP/IP connection, we can
    simply use TLS/SSL (the same protocol used by HTTPS connections). However, in
    this case, since we are speaking of communications among servers, so there is
    no actual client, it is common that both communicating microservices authenticate
    each other with private key certificates, and then agree on a cryptographic protocol
    and key to secure their TLS/SS communication. .NET furnishes all tools for negotiating
    a TLS/SSL connection based on reciprocal authentication based on servers.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个值得注意的点是通信安全。当需要安全通信且通信依赖于底层TCP/IP连接时，我们可以简单地使用TLS/SSL（与HTTPS连接相同的协议）。然而，在这种情况下，由于我们讨论的是服务器之间的通信，因此没有实际的客户端，通常两个通信微服务会使用私钥证书相互认证，然后就加密协议和密钥达成一致，以保护它们的TLS/SSL通信。.NET提供了所有基于服务器相互认证进行TLS/SSL连接协商的工具。
- en: However, when all microservices are part of the same private network, it is
    common to secure just the communication in/out of this private network and not
    secure all the intranet communications, both to simplify the design of the overall
    communication strategy and to save the performance cost of encryption.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当所有微服务都属于同一个私有网络时，通常只保护这个私有网络内的通信，而不保护所有内部网络通信，这样做既可以简化整体通信策略的设计，也可以节省加密的性能成本。
- en: Another typical optimization of inter-application communications is the usage
    of binary serialization, which produces shorter messages and requires less bandwidth
    and less processing time. In fact, for instance, representing an integer within
    an object with a binary serialization costs about 4 bytes, that is, basically
    the same number of bytes needed to store it in the computer memory (there is a
    small overhead, for protocol-handling metadata), while representing the same integer
    as a text requires a byte for each digit, plus the bytes needed for the field
    name.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序间通信的另一种典型优化是使用二进制序列化，它生成更短的消息，需要更少的带宽和处理时间。实际上，例如，在二进制序列化中，表示一个整数在对象中只需要大约4个字节，即基本上与在计算机内存中存储它所需的字节数相同（存在一点协议处理元数据的开销），而将相同的整数作为文本表示则需要每个数字一个字节，再加上字段名所需的字节。
- en: Binary serialization is discussed in detail in the next subsection. Then, also,
    RPC- and data-driven asynchronous communication will be analyzed in dedicated
    subsections.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 二进制序列化将在下一小节中详细讨论。然后，也将专门分析基于RPC和数据驱动的异步通信。
- en: Efficient and flexible binary serialization
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效且灵活的二进制序列化
- en: Serialization is the process of transforming data in a way that they can be
    sent on a communication channel, or stored in a file. Therefore, the way data
    are serialized has a strong impact on the quantity of data that will be sent.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 序列化是将数据转换为可以在通信通道上发送或存储在文件中的过程。因此，数据序列化的方式对将要发送的数据量有重大影响。
- en: The .NET echo system contains several fast, platform-specific binary serializers,
    which are able to produce compact, short messages with very low computational
    costs. In the *Implementing microservices with .NET worker services and message
    brokers* section, we will test one of the fastest, the *Binaron* package.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: .NET生态系统包含几个快速的平台特定二进制序列化器，它们能够以非常低的计算成本生成紧凑的短消息。在*使用.NET工作服务和消息代理实现微服务*这一章节中，我们将测试其中最快的，即*Binaron*包。
- en: 'Unfortunately, efficient binary serializers suffer from a couple of well-known
    problems:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，高效的二进制序列化器存在一些众所周知的问题：
- en: Since the most performant binary serializers are tied to a specific platform,
    they are not interoperable. Thus, for instance, the Java binary format is not
    compatible with the .NET binary format. This constraint creates problems when
    your application microservices are heterogeneous and use different technologies.
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于性能最优秀的二进制序列化器与特定平台绑定，因此它们不可互操作。因此，例如，Java二进制格式与.NET二进制格式不兼容。这种限制在您的应用程序微服务异构且使用不同技术时会导致问题。
- en: If one uses the same platform-specific, in-memory binary format, adding/removing
    properties to/from an object breaks compatibility. Thus, a microservice that uses
    an old version of a class is not able to de-serialize data created with a newer
    version of the same class. This constraint creates dependencies between the microservices’
    CI/CD cycles because when a microservice changes to meet new requirements, it
    causes recursive changes in all other microservices that communicate with it.
  id: totrans-47
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果使用相同的平台特定、内存中的二进制格式，向/从对象添加/删除属性会破坏兼容性。因此，使用旧版本类的微服务无法反序列化使用相同类的新版本创建的数据。这种限制在微服务的CI/CD周期之间创建了依赖关系，因为当微服务为了满足新要求而更改时，会导致与其通信的所有其他微服务的递归更改。
- en: In *Chapter 15*, *Applying Service-Oriented Architectures with .NET*, we will
    see that the JSON format was widely adopted because it avoids these two problems
    since it is not tied to any specific language/runtime, and added properties can
    simply be ignored, while removed properties are handled by assigning default values.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 在第15章“使用.NET应用面向服务的架构”中，我们将看到JSON格式被广泛采用，因为它避免了这两个问题，因为它不绑定到任何特定的语言/运行时，并且可以简单地忽略添加的属性，而删除的属性则通过分配默认值来处理。
- en: The **ProtoBuf** binary format was conceived to ensure the same JSON serialization/deserialization
    advantages for binary formats.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: '**ProtoBuf**二进制格式是为了确保二进制格式具有与JSON序列化/反序列化相同的优势而设计的。'
- en: ProtoBuf achieves interoperability by defining abstract elementary types and
    their binary representations. Then, each framework takes care of converting its
    native types to/from them. Elementary types are combined into complex structures
    called **messages**, which represent classes.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: ProtoBuf通过定义抽象的基本类型及其二进制表示来实现互操作性。然后，每个框架负责将其本地类型转换为/从这些类型转换。基本类型组合成称为**消息**的复杂结构，代表类。
- en: Compatibility between different versions of the same message is ensured by assigning
    a unique integer number to each property. This way, when a message is de-serialized
    into an object, just the integers that mark the property of the given message
    version are searched in the serialized data and de-serialized. When a property
    number is not found in the serialized data, the default value is taken for the
    associate property. This way, ProtoBuf messages have the same serialization/deserialization
    advantages as JSON objects. In a few words compatibility among different versions
    is ensured if the developer doesn’t change the number associated with each property.
    The developer can also remove properties, but without assigning their numbers
    to new properties, because these numbers have the purpose of naming (with very
    short names) all fields. The receiver uses these integer names to restore the
    messages.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为每个属性分配一个唯一的整数编号，确保了同一消息不同版本之间的兼容性。这样，当一条消息反序列化为一个对象时，只需在序列化数据中搜索标记给定消息版本属性的整数即可进行反序列化。如果在序列化数据中找不到属性编号，则使用关联属性的默认值。因此，ProtoBuf消息具有与JSON对象相同的序列化/反序列化优势。简而言之，如果开发者不更改每个属性关联的编号，就可以确保不同版本之间的兼容性。开发者还可以删除属性，但不应将这些编号分配给新的属性，因为这些编号的目的是命名（使用非常短的名字）所有字段。接收者使用这些整数名称来恢复消息。
- en: There are also other serialization proposals similar to ProtoBuf. Some of them
    also ensure better performance, but at the moment, ProtoBuf, which was created
    by Google, is the de facto standard for interoperable binary communication.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 还有其他与ProtoBuf类似的序列化建议。其中一些也确保了更好的性能，但截至目前，由Google创建的ProtoBuf是互操作二进制通信的事实标准。
- en: ProtoBuf messages are defined in `.proto` files and are then compiled into code
    in the target language by language-specific tools. The section that follows describes
    the ProtoBuf data description language.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: ProtoBuf消息定义在`.proto`文件中，然后通过特定语言的工具编译成目标语言的代码。接下来的部分将描述ProtoBuf数据描述语言。
- en: The ProtoBuf language
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProtoBuf语言
- en: 'Each `.proto` file starts with a declaration of the version of ProtoBuf. At
    the moment, the highest available version is `proto3`:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `.proto` 文件以 ProtoBuf 版本的声明开始。目前，最高可用的版本是 `proto3`：
- en: '[PRE0]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since .NET SDK will generate classes out of ProtoBuf definitions, then, if
    the target language is .NET, you can specify the namespace where you generate
    all the .NET classes corresponding to the ProtoBuf types defined in the file:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 .NET SDK 会从 ProtoBuf 定义中生成类，因此，如果目标语言是 .NET，你可以指定生成所有与文件中定义的 ProtoBuf 类型对应的
    .NET 类的命名空间：
- en: '[PRE1]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Then, you can import definitions contained in other `.proto` files, with one
    or more `import` declarations:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以通过一个或多个 `import` 声明导入其他 `.proto` 文件中包含的定义：
- en: '[PRE2]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The above definition imports the definition of the `TimeStamp` type, which encodes
    both the `DateTime` and `DateTimeOffset` .NET types. `TimeStamp` is not a ProtoBuf
    simple type but is defined in a standard ProtoBuf types library.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 上述定义导入了 `TimeStamp` 类型的定义，该类型编码了 `.NET` 的 `DateTime` 和 `DateTimeOffset` 类型。`TimeStamp`
    不是一个 ProtoBuf 简单类型，而是在标准 ProtoBuf 类型库中定义的。
- en: 'Finally, we can scope all message definitions to a `package` to avoid name
    collisions. ProtoBuf packages have the same role as a .NET namespace but are not
    automatically converted into .NET namespaces during .NET code generation, since
    .NET namespaces are specified with the `option C#` declaration:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以将所有消息定义范围到一个 `package` 中，以避免名称冲突。ProtoBuf 包具有与 .NET 命名空间相同的角色，但在 .NET
    代码生成过程中不会自动转换为 .NET 命名空间，因为 .NET 命名空间是通过 `option C#` 声明指定的：
- en: '[PRE3]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Each `.proto` file can contain several message definitions. Here is an example
    message:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 `.proto` 文件可以包含多个消息定义。以下是一个示例消息：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Each property is specified by the property type followed by the property name,
    and then by the unique integer associated with that property. Property names must
    be in camel case, but they are converted to Pascal case during .NET code generation.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 每个属性通过属性类型、属性名称以及与该属性关联的唯一整数来指定。属性名称必须使用驼峰式命名法，但在 .NET 代码生成过程中会转换为帕斯卡式命名法。
- en: 'If a new version of `PurchaseMessage` is created, compatibility with the past
    version can be maintained by not reusing the integers assigned to the properties
    of the old version, and by removing just unused properties, as in the following
    example:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果创建 `PurchaseMessage` 的新版本，可以通过不重用分配给旧版本属性的唯一整数，以及仅删除未使用的属性来保持与过去版本的兼容性，如下例所示：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The new version of `PurchaseMessage` doesn’t contain properties `2` and `3`,
    but it contains the new `reseller` property, marked with the new `7` integer.
    The `Reseller` type is defined by another message that can be contained either
    in the same `.proto` file or an imported file.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`PurchaseMessage` 的新版本不包含属性 `2` 和 `3`，但它包含新的 `reseller` 属性，标记为新的 `7` 整数。`Reseller`
    类型由另一个消息定义，该消息可以位于相同的 `.proto` 文件或导入的文件中。'
- en: Clearly, compatibility is maintained just with clients that don’t use the removed
    properties, while clients directly affected by the changes must be updated.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，只有不使用已删除属性的客户端才能保持兼容性，而直接受影响的客户端必须进行更新。
- en: 'Collections are represented by prefixing the name of the collection element
    type with the `repeated` keyword:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 集合通过在集合元素类型名称前加 `repeated` 关键字来表示：
- en: '[PRE6]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Repeated data are translated into the `Google.Protobuf.Collections.RepeatedField<T>`
    .NET type, which implements `IList<T>`.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 重复数据被转换为实现 `IList<T>` 的 `Google.Protobuf.Collections.RepeatedField<T>` .NET
    类型。
- en: 'Dictionaries are represented with the `map<T1, T2>` type:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 字典用 `map<T1, T2>` 类型表示：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Messages can be nested in other messages, in which case they generate classes
    defined in other .NET classes during code generation:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 消息可以嵌套在其他消息中，在这种情况下，它们在代码生成期间生成其他 .NET 类定义的类：
- en: '[PRE8]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'We can also define `enum` types that translate directly to .NET `enum` types:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还可以定义直接转换为 .NET `enum` 类型的 `enum` 类型：
- en: '[PRE9]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'It is also possible to define messages with conditional content. This is useful
    for sending either a response or error information:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以定义具有条件内容的消息。这对于发送响应或错误信息很有用：
- en: '[PRE10]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Once a microservice receives a .NET object of the `ResponseMessage` type, it
    can process it as follows:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦微服务接收到 `ResponseMessage` 类型的 .NET 对象，它可以按以下方式处理：
- en: '[PRE11]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'The table below summarizes all the ProtoBuf simple types and their equivalent
    .NET types:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了所有 ProtoBuf 简单类型及其等效的 .NET 类型：
- en: '| **.NET types** | **Protobuf types** |'
  id: totrans-85
  prefs: []
  type: TYPE_TB
  zh: '| **.NET 类型** | **Protobuf 类型** |'
- en: '| `double` | `double` |'
  id: totrans-86
  prefs: []
  type: TYPE_TB
  zh: '| `double` | `double` |'
- en: '| `float` | `float` |'
  id: totrans-87
  prefs: []
  type: TYPE_TB
  zh: '| `float` | `float` |'
- en: '| `string` | `string` |'
  id: totrans-88
  prefs: []
  type: TYPE_TB
  zh: '| `string` | `string` |'
- en: '| `bool` | `bool` |'
  id: totrans-89
  prefs: []
  type: TYPE_TB
  zh: '| `bool` | `bool` |'
- en: '| `ByteString` | `bytes` |'
  id: totrans-90
  prefs: []
  type: TYPE_TB
  zh: '| `ByteString` | `bytes` |'
- en: '| `int` | `int32, sint32, sfixed32` |'
  id: totrans-91
  prefs: []
  type: TYPE_TB
  zh: '| `int` | `int32, sint32, sfixed32` |'
- en: '| `uint` | `uint32, fixed32` |'
  id: totrans-92
  prefs: []
  type: TYPE_TB
  zh: '| `uint` | `uint32, fixed32` |'
- en: '| `long` | `int64, sint64, sfixed64` |'
  id: totrans-93
  prefs: []
  type: TYPE_TB
  zh: '| `long` | `int64, sint64, sfixed64` |'
- en: '| `ulong` | `uint64, fixed64` |'
  id: totrans-94
  prefs: []
  type: TYPE_TB
  zh: '| `ulong` | `uint64, fixed64` |'
- en: 'Table 14.1: Mapping Protobuf Simple Types to .NET Equivalents'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.1：将 Protobuf 简单类型映射到 .NET 等价类型
- en: The `ByteString` .NET type is defined in the `Google.Protobuf` namespace contained
    in the `Google.Protobuf` NuGet package. It can be converted to `byte[]` with its
    `.ToByteArray()` method. A `byte[]` object can be converted into a `ByteString`
    with the `ByteString.CopyFrom(byte[] data)` static method.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: '`ByteString` .NET 类型定义在 `Google.Protobuf` NuGet 包中包含的 `Google.Protobuf` 命名空间中。它可以使用其
    `.ToByteArray()` 方法转换为 `byte[]`。一个 `byte[]` 对象可以使用 `ByteString.CopyFrom(byte[]
    data)` 静态方法转换为 `ByteString`。'
- en: '`int32`, `sint32`, and `sfixed32` encode .NET `int`. Now, `sint32` is convenient
    when the integer is more likely to be negative, while the `sfixed32` type is convenient
    when the integer is likely to contain more than 28 bits. Similar considerations
    apply to `uint32` and `fixed32`.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`int32`, `sint32`, 和 `sfixed32` 编码 .NET 的 `int`。现在，当整数更有可能为负数时，`sint32` 更方便，而当整数可能包含超过
    28 位时，`sfixed32` 类型更方便。类似的考虑也适用于 `uint32` 和 `fixed32`。'
- en: The same criteria apply to 64-bit integers, but in this case, the threshold
    for the convenience of `sfixed64` and `fixed64` is 56 bits.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 相同的标准适用于 64 位整数，但在此情况下，`sfixed64` 和 `fixed64` 方便性的阈值是 56 位。
- en: ProtoBuf simple types are not nullable. This means that they can’t have a null
    value, and if no value is assigned to them, they take a default value. The default
    value of a `string` is an empty `string`, while the default value of a `ByteString`
    is an empty `ByteString`.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: ProtoBuf 简单类型不可为空。这意味着它们不能有空值，如果没有为它们分配值，它们将采用默认值。`string` 的默认值是一个空 `string`，而
    `ByteString` 的默认值是一个空的 `ByteString`。
- en: 'If you need nullable types, you must include a predefined `.proto` file:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果需要可空类型，必须包含预定义的 `.proto` 文件：
- en: '[PRE12]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Here is a table that details the correspondence between .NET nullable simple
    types and ProtoBuf nullable wrappers:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个详细说明 .NET 可空简单类型与 ProtoBuf 可空包装器之间对应关系的表格：
- en: '| **.NET types** | **ProtoBuf types** |'
  id: totrans-103
  prefs: []
  type: TYPE_TB
  zh: '| **.NET 类型** | **ProtoBuf 类型** |'
- en: '| `double?` | `google.protobuf.DoubleValue` |'
  id: totrans-104
  prefs: []
  type: TYPE_TB
  zh: '| `double?` | `google.protobuf.DoubleValue` |'
- en: '| `float?` | `google.protobuf.FloatValue` |'
  id: totrans-105
  prefs: []
  type: TYPE_TB
  zh: '| `float?` | `google.protobuf.FloatValue` |'
- en: '| `string?` | `google.protobuf.StringValue` |'
  id: totrans-106
  prefs: []
  type: TYPE_TB
  zh: '| `string?` | `google.protobuf.StringValue` |'
- en: '| `bool?` | `google.protobuf.BoolValue` |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| `bool?` | `google.protobuf.BoolValue` |'
- en: '| `ByteString?` | `google.protobuf.BytesValue` |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `ByteString?` | `google.protobuf.BytesValue` |'
- en: '| `int?` | `google.protobuf.Int32Value` |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `int?` | `google.protobuf.Int32Value` |'
- en: '| `uint?` | `google.protobuf.UInt32Value` |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `uint?` | `google.protobuf.UInt32Value` |'
- en: '| `long?` | `google.protobuf.Int64Value` |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `long?` | `google.protobuf.Int64Value` |'
- en: '| `ulong?` | `google.protobuf.UInt64Value` |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `ulong?` | `google.protobuf.UInt64Value` |'
- en: Table 14.2
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.2
- en: '`DateTime`, `DateTimeOffset`, and `TimeSpan` have no direct equivalent in ProtoBuf,
    but the `Google.Protobuf.WellKnownTypes` namespace contained in the `Google.Protobuf`
    NuGet package contains the `Timestamp` type, which maps from/to `DateTime` and
    `DateTimeOffset`, and the `Duration` type, which maps from/to `TimeSpan`. The
    mapping is completely analogous to that of `ByteString`. Thus, for instance, a
    `Duration` is obtained from a `TimeSpan` with the `Duration.FromTimeSpan` static
    method, while a `Duration` is transformed into a `TimeSpan` by calling its `.ToTimeSpan`
    instance method.'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: '`DateTime`, `DateTimeOffset`, 和 `TimeSpan` 在 ProtoBuf 中没有直接等价类型，但 `Google.Protobuf.WellKnownTypes`
    命名空间包含在 `Google.Protobuf` NuGet 包中，它包含 `Timestamp` 类型，该类型将 `DateTime` 和 `DateTimeOffset`
    映射到/从，以及 `Duration` 类型，该类型将 `TimeSpan` 映射到/从。映射与 `ByteString` 的映射完全类似。因此，例如，可以通过
    `Duration.FromTimeSpan` 静态方法从 `TimeSpan` 获取 `Duration`，而通过调用其 `.ToTimeSpan` 实例方法将
    `Duration` 转换为 `TimeSpan`。'
- en: 'The usage of `Duration` and `Timestamp` in `.proto` files is shown in the following:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: '`.proto` 文件中使用 `Duration` 和 `Timestamp` 的示例如下：'
- en: '[PRE13]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Please notice that usage needs the import of predefined `.proto` files.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，使用时需要导入预定义的 `.proto` 文件。
- en: 'At the moment, there is no equivalent to the .NET `decimal` type, but it will
    probably be introduced in the next version. However, you can encode decimals with
    two integers, one for the integer part and the other for the decimal part, with
    a message like the one in the following:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，没有 .NET `decimal` 类型的等价类型，但可能会在下一个版本中引入。然而，可以使用两个整数来编码小数，一个用于整数部分，另一个用于小数部分，如下面的消息所示：
- en: '[PRE14]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'We can add implicit conversion to the .NET `decimal`, with a partial class
    that combines with another partial class, which is automatically generated from
    the `.proto` file:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以向 .NET 的 `decimal` 添加隐式转换，通过一个与另一个从 `.proto` 文件自动生成的部分类结合的部分类来实现：
- en: '[PRE15]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We have described almost completely the ProtoBuf data description language.
    The only missing subject is the representation of variable/unknown types, which
    are rarely used. However, the *Further reading* section contains a link to the
    official documentation. The next section explains how to serialize and de-serialize
    messages.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们几乎完全描述了 ProtoBuf 数据描述语言。唯一缺少的主题是可变/未知类型的表示，这些类型很少使用。然而，*进一步阅读*部分包含了一个指向官方文档的链接。下一节解释了如何序列化和反序列化消息。
- en: ProtoBuf serialization
  id: totrans-123
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ProtoBuf 序列化
- en: 'An object tree can be serialized as shown in the following:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 对象树可以按照以下方式序列化：
- en: '[PRE16]'
  id: totrans-125
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `WriteTo` method needs a stream so create an in-memory stream. After, we
    create a byte array from the stream with `ToArray`, which ensures that the stream
    buffer is actually written into the stream before attempting the extraction of
    the byte array:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`WriteTo` 方法需要一个流，因此创建一个内存流。之后，我们使用 `ToArray` 从流中创建一个字节数组，这确保在尝试提取字节数组之前，流缓冲区实际上已写入流中：'
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Here, since `ParseFrom` also needs a stream, we generate a stream from the message
    bytes.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，由于 `ParseFrom` 也需要一个流，我们从消息字节生成一个流。
- en: The next subsection describes the usage of RPC in microservices.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节描述了在微服务中使用 RPC 的用法。
- en: Efficient and flexible RPC
  id: totrans-130
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 高效且灵活的 RPC
- en: 'The RPC approach can be adopted in some application microservices with good
    results if the following conditions are met:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 如果满足以下条件，可以在某些应用程序微服务中采用 RPC 方法并获得良好的结果：
- en: The chain of recursive calls is very short, usually just one call without recursive
    calls.
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 递归调用的链非常短，通常只有一个没有递归调用的调用。
- en: Low communication latency and high channel bandwidth. This condition is met
    by intranet communications that take place on high-speed Ethernet within the same
    data center.
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 低通信延迟和高通道带宽。这种条件由在同一数据中心内高速以太网上进行的数据中心内部通信满足。
- en: Data is serialized quickly and in a very size-efficient format. This condition
    is met by any efficient binary serializer.
  id: totrans-134
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 数据以快速且非常高效的格式序列化。任何高效的二进制序列化器都能满足这一条件。
- en: Long chains of recursive calls are avoided whenever RPC is used just to queue
    a request and to receive confirmation that the request has been correctly queued,
    without waiting for any processing result. In this case, RPC is used to simulate
    an asynchronous communication with reception confirmation. If this is the case,
    all of these conditions are easily met whenever all communicating microservices
    are part of the same **local area network** (**LAN**) where all computers are
    connected with high-speed physical connections.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 当 RPC 仅用于排队请求并接收请求已正确排队的确认，而不等待任何处理结果时，应避免使用长链递归调用。在这种情况下，RPC 用于模拟带有接收确认的异步通信。如果情况如此，只要所有通信的微服务都是同一
    **局域网**（**LAN**）的一部分，其中所有计算机都通过高速物理连接连接，所有这些条件都很容易满足。
- en: On the contrary, when the communicating microservices are geographically distributed
    and are part of a WAN instead of a LAN, waiting for confirmation of the reception
    of an RPC message might be unacceptable for high-traffic microservices. In this
    case, it is better to rely on message brokers that support completely asynchronous
    communications.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，当通信的微服务在地理上分布，并作为 WAN 而不是 LAN 的一部分时，对于高流量微服务来说，等待 RPC 消息接收确认可能是不可以接受的。在这种情况下，最好依赖于支持完全异步通信的消息代理。
- en: The gRPC protocol brings all the advantages of ProtoBuf to RPC since, by default,
    it is based on ProtoBuf. gRPC/ProtoBuf is a binary protocol that works over an
    HTTP/2 connection. It is worth pointing out that gRPC can’t work with HTTP versions
    less than 2\. In the remainder of the chapter, we will always assume that gRPC
    uses ProtoBuf.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 协议将 ProtoBuf 的所有优点带到了 RPC，因为默认情况下，它基于 ProtoBuf。gRPC/ProtoBuf 是一个在 HTTP/2
    连接上工作的二进制协议。值得注意的是，gRPC 不能与小于 2 的 HTTP 版本一起工作。在本章的剩余部分，我们将始终假设 gRPC 使用 ProtoBuf。
- en: 'gRPC uses `.proto` files, but together with data, gRPC `.proto` files also
    define services with their RPC methods. Here is a service definition:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: gRPC 使用 `.proto` 文件，但与数据一起，gRPC `.proto` 文件还定义了带有其 RPC 方法的服务。以下是一个服务定义：
- en: '[PRE18]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Each service is introduced by the `service` keyword, while each method is introduced
    by the `rpc` keyword. Each service specifies an input message and an output message.
    If either of these two messages is empty, we can use the predefined `google.protobuf.Empty`
    message, as shown in the following:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 每个服务通过`service`关键字引入，而每个方法通过`rpc`关键字引入。每个服务指定一个输入消息和一个输出消息。如果这两个消息中的任何一个为空，我们可以使用预定义的`google.protobuf.Empty`消息，如下所示：
- en: '[PRE19]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: '`.proto` files can be used to generate both server code and client code. In
    client code, each service is translated into a proxy class with the same methods
    declared in the service. Each of the proxy methods automatically invokes the remote
    service method and returns its result.'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: '`.proto` 文件可以用来生成服务器端代码和客户端代码。在客户端代码中，每个服务被转换为一个具有相同方法的代理类。每个代理方法会自动调用远程服务方法并返回其结果。'
- en: The server code, instead, translates each service into an abstract class, whose
    virtual methods correspond to methods declared in the service. The developer is
    responsible for inheriting from this abstract class and providing implementations
    for all service methods.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，服务器端代码将每个服务转换为一个抽象类，其虚拟方法对应于服务中声明的方法。开发者负责从该抽象类继承并提供所有服务方法的实现。
- en: 'Below is an example of how to inherit from a similar class:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是如何从类似类继承的示例：
- en: '[PRE20]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Each method receives both the input message and a context object. Since gRPC
    services use ASP.NET Core infrastructure, the context object furnishes access
    to the request `HttpContext` through `context.GetHttpContext()`.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 每个方法都接收输入消息和上下文对象。由于gRPC服务使用ASP.NET Core基础设施，上下文对象通过`context.GetHttpContext()`提供了对请求`HttpContext`的访问。
- en: An ASP.NET Core application is enabled to gRPC with `builder.Services.AddGrpc()`
    and by declaring each service with something like `app.MapGrpcService<CounterService>();`.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core应用程序可以通过`builder.Services.AddGrpc()`启用gRPC，并通过声明每个服务，例如`app.MapGrpcService<CounterService>();`来声明每个服务。
- en: More details on both gRPC servers and clients will be given while discussing
    the example in the *A worker microservice with ASP.NET core* section of *Chapter
    21, Case Study*.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 在讨论第21章“案例研究”的“*具有ASP.NET core的工作微服务*”部分中的示例时，将给出关于gRPC服务器和客户端的更多详细信息。
- en: Services can receive as input and return continuous streams of data, where a
    long-term connection between the client and server is established. However, the
    usage of streams in microservices is not common since microservices are ephemeral
    processes that are frequently shut down and moved from one processing node to
    another by orchestrators, so long-term connections are not easy to maintain.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 服务可以作为输入接收并返回连续的数据流，其中客户端和服务器之间建立了一个长期连接。然而，在微服务中流的使用并不常见，因为微服务是短暂的进程，经常被编排器关闭并从一个处理节点移动到另一个处理节点，因此长期连接难以维护。
- en: 'Here is a service that accepts and returns a stream:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个接受并返回流的服务示例：
- en: '[PRE21]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Each input stream is passed as an argument to the .NET implementation of the
    method. If the method returns a stream, the .NET implementation of the method
    must return a `Task`, and also the output stream is passed as an argument to the
    method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 每个输入流作为参数传递给.NET方法的实现。如果方法返回一个流，则.NET方法的实现必须返回一个`Task`，并且输出流也作为参数传递给方法：
- en: '[PRE22]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'On the client side, both input and output streams are available in the `call`
    object that is returned when the proxy method is called without awaiting it, as
    shown in the following:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在客户端，当代理方法在没有等待的情况下被调用时，返回的`call`对象中既可用输入流，也可用输出流，如下所示：
- en: '[PRE23]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The `CompleteAsync()` method closes the request stream, declaring that the input
    is finished.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: '`CompleteAsync()` 方法关闭请求流，声明输入已完成。'
- en: More practical details on the client usage are given in the example in the *A
    worker microservice with ASP.NET core* section of *Chapter 21, Case Study*, while
    the *Further reading* section contains a link to the .NET gRPC official documentation.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在第21章“案例研究”的“*具有ASP.NET core的工作微服务*”部分中给出了关于客户端使用的更多示例细节，而“*进一步阅读*”部分包含了一个指向.NET
    gRPC官方文档的链接。
- en: The next subsection describes how to implement data-driven asynchronous communication.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节将描述如何实现数据驱动的异步通信。
- en: Reliable data-driven asynchronous communication
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可靠的数据驱动异步通信
- en: 'Non-blocking communication must necessarily rely on non-volatile queues to
    decouple the sender thread from the receiving thread. Decoupling can be achieved
    with just one queue on each communication path, but sometimes additional queues
    improve performance and increase CPU usage. Queues, can be placed in three places:
    within the microservice that sends the message, within the microservice that receives
    the message, or outside both microservices using dedicated services known as message
    brokers. by using dedicated queuing services called **message brokers**.'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 非阻塞通信必须依赖于非易失性队列，以解耦发送线程和接收线程。解耦可以通过每个通信路径上的一个队列实现，但有时额外的队列可以提高性能并增加CPU使用率。队列可以放置在三个地方：在发送消息的微服务内、在接收消息的微服务内，或者使用称为消息代理的专用服务在两个微服务之外。通过使用称为**消息代理**的专用队列服务。
- en: '**Azure Service Bus**, which we described in the *.NET communication facilities*
    subsection of *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise
    Application*, is a message broker that, like most message brokers, offers queuing
    services and publisher/subscriber communication. In this chapter, we will also
    describe **RabbitMQ**, which offers queuing services and publisher/subscriber
    communication that is broadly similar to **Azure Service Bus** **topics**. Since
    it is easier to debug code that uses a local instance of RabbitMQ, often it is
    convenient to use RabbitMQ during development and then move to Azure Service Bus.'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: '**Azure Service Bus**，我们在第11章的“*.NET通信设施*”小节中描述过，是提供队列服务和发布/订阅通信的消息代理，类似于大多数消息代理。在本章中，我们还将描述**RabbitMQ**，它提供与**Azure
    Service Bus** **主题**广泛相似的队列服务和发布/订阅通信。由于使用本地RabbitMQ实例的代码更容易调试，因此在开发过程中通常更方便使用RabbitMQ，然后迁移到Azure
    Service Bus。'
- en: 'Queues decouple the sender and receiver but do not ensure that messages are
    not lost. In the *Resilient task execution* section of *Chapter 11,* we have already
    discussed strategies for achieving reliable communication. Here we give more practical
    details for preventing message losses with confirmations and timeouts:'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 队列解耦了发送者和接收者，但并不保证消息不会丢失。在第11章的“*弹性任务执行*”部分中，我们已经讨论了实现可靠通信的策略。在这里，我们给出更多关于使用确认和超时防止消息丢失的实用细节：
- en: Queues must be stored on permanent storage; otherwise, their content can be
    lost if the processes controlling them either crash or are shut down.
  id: totrans-163
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列必须存储在持久存储上；否则，如果控制它们的进程崩溃或关闭，其内容可能会丢失。
- en: If a confirmation that the message was successfully inserted in the queue doesn’t
    arrive within a timeout time, the source assumes that the message was lost and
    retries the operation.
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果在超时时间内没有收到确认消息已成功插入队列的消息，则源假定消息已丢失并重试操作。
- en: When a message is extracted from a queue, it remains blocked and inaccessible
    to other consumers. If a confirmation that the message has been successfully processed
    arrives within a timeout time, the message is removed from the queue; otherwise,
    it is unblocked and becomes available again to other consumers.
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当从队列中提取消息时，它将保持阻塞状态，对其他消费者不可用。如果在超时时间内收到确认消息已成功处理的消息，则从队列中删除该消息；否则，它将被解除阻塞并再次可供其他消费者使用。
- en: All confirmations can be handled asynchronously with the exception of the insertion
    in the first queue of a communication path. In fact, if the sending code doesn’t
    remain blocked waiting for the confirmation but moves to further processing and
    the message is lost, there is no way to resend the message, since the message
    cannot be taken from any other queue.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 所有确认都可以异步处理，除了通信路径的第一个队列中的插入操作。实际上，如果发送代码不保持阻塞等待确认，而是转移到进一步处理，并且消息丢失，则无法重新发送消息，因为无法从任何其他队列中获取该消息。
- en: For this reason, sometimes microservices that use a message broker also have
    an internal queue. More specifically, the main microservice thread produces all
    messages and stores them in a local queue that can be implemented with a database
    table. Another thread takes care of extracting messages from this queue and sending
    them to the message broker.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，有时使用消息代理的微服务也具有内部队列。更具体地说，主微服务线程生成所有消息并将它们存储在可以由数据库表实现的本地队列中。另一个线程负责从该队列中提取消息并将它们发送到消息代理。
- en: Messages that are removed from the local queue are blocked and removed only
    when an asynchronous confirmation arrives from the message broker. This technique
    is used in the example of *Chapter 18*, *Implementing Frontend Microservices with
    ASP.NET Core*. The main advantage of the local queue is that confirmation from
    a local queue usually arrives faster because there is less concurrency with other
    threads/processes (don’t forget that each microservice should have a private database/permanent
    storage), so the blocking time is more acceptable.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 从本地队列中移除的消息将被阻塞，并且只有在从消息代理收到异步确认后才会被移除。这种技术在*第18章，使用ASP.NET Core实现前端微服务*的示例中使用。本地队列的主要优势是，由于与其他线程/进程的并发性较低（不要忘记每个微服务都应该有一个私有数据库/永久存储），因此来自本地队列的确认通常更快，所以阻塞时间更可接受。
- en: 'Using a queue inside each receiver is a viable alternative to message brokers.
    The main advantage of private queues is that the process that handles the queue
    is not shared among several microservices, so all queue operations are faster.
    In particular, the confirmation of each insertion is immediate, so the sender
    can use a blocking RPC call to send the message. However, this simple solution
    has the following disadvantages:'
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 在每个接收器内部使用队列是消息代理的一个可行替代方案。私有队列的主要优势在于处理队列的过程不会被多个微服务共享，因此所有队列操作都更快。特别是，每次插入的确认都是立即的，因此发送者可以使用阻塞的RPC调用来发送消息。然而，这个简单的解决方案有以下缺点：
- en: There is no way to implement the publisher/subscriber pattern.
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 无法实现发布/订阅模式。
- en: Just one microservice instance can extract messages from the queue. Therefore,
    microservices can’t be scaled horizontally. Limited vertical scaling can be achieved
    by increasing the number of processor cores and by processing queue messages with
    parallel threads.
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只有一个微服务实例可以从队列中提取消息。因此，微服务无法进行水平扩展。可以通过增加处理器核心的数量以及使用并行线程处理队列消息来实现有限的垂直扩展。
- en: 'A similar approach can be efficiently implemented with gRPC and ASP.NET Core
    as follows:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 可以使用gRPC和ASP.NET Core有效地实现类似的方法如下：
- en: The sender sends the message to a gRPC method.
  id: totrans-173
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 发送者将消息发送到gRPC方法。
- en: The gRPC method just enqueues the message and immediately returns a confirmation
    to the sender.
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: gRPC方法只是将消息入队并立即向发送者返回确认。
- en: An ASP.NET Core hosted process takes care of extracting the messages from the
    queue and passing them to several parallel threads.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ASP.NET Core托管进程负责从队列中提取消息并将它们传递给多个并行线程。
- en: When a message is passed to a thread, it remains blocked and inaccessible. It
    is removed only after the thread confirms that the message has been successfully
    processed. If, instead, a thread reports a failure, the corresponding message
    is unblocked so it can be passed to another thread.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当消息传递给一个线程时，它会保持阻塞和不可访问。只有在线程确认消息已成功处理后，它才会被移除。如果线程报告失败，相应的消息将被解锁，以便传递给另一个线程。
- en: ASP.NET Core threads take care of the necessary input parallelism. Some horizontal
    parallelism can be achieved by using load balancers and several web servers. However,
    in this case, either all the web servers use the same database, thus increasing
    the concurrency on the queue, or we use several sharded databases.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: ASP.NET Core线程负责必要的输入并行性。可以通过使用负载均衡器和多个Web服务器来实现一些水平并行性。然而，在这种情况下，要么所有Web服务器使用相同的数据库，从而增加队列的并发性，要么我们使用多个分片数据库。
- en: This approach is described in more detail in the example in the *Implementing
    worker microservices with ASP.NET core* section. As we will see, it is simple
    to implement and ensures good response time, but due to its limited scalability,
    it is adequate just for small or medium-sized applications with low to medium
    traffic.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在*使用ASP.NET core实现工作微服务*的示例中描述得更为详细。正如我们将看到的，它易于实现并确保良好的响应时间，但由于其有限的可扩展性，它仅适用于小型或中型应用，且流量较低到中等。
- en: If, for some reason, either an insertion in a queue or the processing of a message
    extracted by a queue requires more time than the timeout time, the operation is
    repeated so that the same message is processed twice. Therefore, messages must
    be idempotent, meaning processing them once or several times must have the same
    effect. Record updates and deletions are intrinsically idempotent since repeating
    an update or a deletion several times doesn’t change the result, but record additions
    are not.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 如果由于某种原因，在队列中插入或处理由队列提取的消息所需的时间超过了超时时间，则操作会重复，导致同一消息被处理两次。因此，消息必须是一致的，这意味着一次或多次处理它们必须产生相同的效果。记录更新和删除本质上是一致的，因为多次更新或删除不会改变结果，但记录添加则不是。
- en: Idempotency can always be forced by assigning a unique identifier to messages
    and then storing the identifiers of the already processed messages. This way,
    each incoming message can be discarded when its identifier is found among the
    identifiers of the already processed messages. We will use this technique in all
    examples in this chapter.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 一致性可以通过为消息分配一个唯一的标识符，然后存储已处理消息的标识符来实现。这样，当发现其标识符已存在于已处理消息的标识符中时，可以丢弃每个传入的消息。在本章的所有示例中，我们将使用这种技术。
- en: Queues, confirmations, and message resends ensure that requests to a single
    microservice are safely processed, but how can we handle requests that involve
    several cooperating microservices? We will discover that in the next subsection.
    There, we will explain how distributed microservices can coordinate and reach
    agreements to yield coherent behavior with only the help of asynchronous communication.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 队列、确认和消息重发确保单个微服务的请求被安全处理，但如何处理涉及多个协作微服务的请求呢？我们将在下一小节中找到答案。在那里，我们将解释分布式微服务如何通过仅使用异步通信来协调和达成一致，以产生一致的行为。
- en: Distributed transactions
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分布式事务
- en: 'Everyone knows what a database transaction is: several records are modified
    one after the other, but if a single action fails, all previous modifications
    are also undone before aborting the transaction. That is, either all operations
    succeed or they fail simultaneously.'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都知道什么是数据库事务：多个记录依次被修改，但如果单个操作失败，则在终止事务之前，所有之前的修改也会被撤销。也就是说，要么所有操作都成功，要么它们同时失败。
- en: A distributed transaction does the same job, but in this case, the records are
    not part of a single database but are distributed among the databases associated
    with several cooperating microservices.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 分布式事务执行相同的工作，但在这个情况下，记录不是单个数据库的一部分，而是分布在与多个协作微服务关联的数据库中。
- en: The reliable data-driven communication techniques described so far are the building
    blocks for solving more complex cooperation problems.
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止所描述的可靠的数据驱动通信技术是解决更复杂合作问题的基石。
- en: Let’s suppose that a user operation triggers processing and storage in several
    related microservices. The user operation can be considered successfully completed
    only if all involved processing/storage operations succeed.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 假设一个用户操作触发了多个相关微服务的处理和存储。只有当所有涉及的处理/存储操作都成功时，用户操作才能被认为是成功完成的。
- en: 'Moreover, if a single processing/storage operation also fails for some fundamental
    reason, retrying the failed operation doesn’t help. Think, for instance, of a
    purchase that fails because the user has not got enough funds to complete the
    payment: the only way out is to undo all the operations that have already been
    performed.'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果单个处理/存储操作由于某些基本原因而失败，重试失败的操作也没有帮助。例如，考虑一个购买操作失败，因为用户没有足够的资金来完成支付：唯一的出路是撤销所有已执行的操作。
- en: 'In general, similar situations must be handled in a transactional way; either
    all operations are performed, or no operation is performed. Transactions that
    span several microservices are known as **distributed transactions**. In theory,
    **distributed transactions** can be handled with the following two-stage protocol:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，类似的情况必须以事务方式处理；要么所有操作都执行，要么没有任何操作执行。跨越多个微服务的交易被称为**分布式事务**。在理论上，**分布式事务**可以通过以下两阶段协议来处理：
- en: In the first stage, all operations are executed, each one in the scope of a
    local transaction (for instance, within the scope of each microservice database
    transaction). The success or failure of each operation is then returned to a transaction
    coordinator.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第一阶段，所有操作都在本地事务的范围内执行，每个操作都在本地事务的范围内（例如，在各个微服务数据库事务的范围内）。然后，每个操作的成功或失败被返回给事务协调器。
- en: In the second stage, the transaction coordinator informs all microservices of
    the success or failure of the overall operation. In the case of failure, all local
    transactions are rolled back; otherwise, they are committed.
  id: totrans-190
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在第二阶段，事务协调器通知所有微服务整体操作的成功或失败。在失败的情况下，所有本地事务都会回滚；否则，它们会被提交。
- en: When using asynchronous messages, confirmations may arrive after quite a large
    amount of time and may interleave with other transactions performed on the same
    resources. Therefore, having all local resources blocked by a local transaction
    during a possibly time-consuming distributed transaction is not acceptable.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 当使用异步消息时，确认可能会在相当长的时间后到达，并且可能与在相同资源上执行的其他事务交织在一起。因此，在可能耗时的分布式事务期间，所有本地资源都被本地事务阻塞是不可接受的。
- en: 'For this reason, microservices transactions use the **saga** pattern: all local
    operations are performed without opening a local transaction, and in the case
    of failure, they are compensated by other operations that undo the initial operations.'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，微服务事务使用**saga**模式：所有本地操作都在不打开本地事务的情况下执行，并且在失败的情况下，它们通过其他操作来补偿初始操作。
- en: Undoing a database insertion is quite easy since it is enough to remove the
    added item, but undoing modifications and deletes is quite difficult and requires
    the storage of additional information. The general solution to this problem is
    storing records that represent all database changes in a table. These records
    can be used to compute a compensation operation or to restore the previous database
    state starting from a reference database state. We already discussed this storage
    technique, which is called **event sourcing**, in the *Event sourcing* section
    of *Chapter 7*, *Understanding the Different Domains in Software Solutions*. Just
    to recap, and in a few words, each database stores not only the actual state but
    also the history of all changes up to a certain previous time.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 撤销数据库插入相当容易，因为只需要移除添加的项目即可，但撤销修改和删除则相当困难，需要存储额外的信息。解决这个问题的通用方法是存储一个表中的记录，这些记录代表所有数据库更改。这些记录可以用来计算补偿操作，或者从参考数据库状态开始恢复之前的数据库状态。我们已经在“第7章，理解软件解决方案中的不同领域”的“事件溯源”部分讨论了这种存储技术。为了回顾，简单地说，每个数据库不仅存储实际状态，还存储到某个之前时间点的所有更改的历史。
- en: When a saga transaction is undone, if other saga transactions depend on the
    undone changes, we must also undo them. For instance, suppose that an accepted
    purchase order depends on the funds uploaded by a user on an e-commerce platform.
    Then, if the funds upload transaction is undone, the purchase must also be undone.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 当撤销一个saga事务时，如果其他saga事务依赖于已撤销的更改，我们也必须撤销它们。例如，假设一个已接受的采购订单依赖于用户在电子商务平台上上传的资金。那么，如果资金上传事务被撤销，采购订单也必须被撤销。
- en: In order to avoid similar chain reactions when a saga transaction is undone,
    often new transactions are accepted only if they depend on changes that took place
    before a certain safety interval. Thus, for instance, uploaded funds are made
    available only after, say, 5-10 minutes, because it is very unlikely that a transaction
    will be undone after more than 5-10 minutes.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免在撤销saga事务时出现类似的连锁反应，通常只有在它们依赖于在某个安全间隔之前发生的变化时才接受新的交易。因此，例如，上传的资金只有在大约5-10分钟后才可用，因为交易在超过5-10分钟后被撤销的可能性非常小。
- en: 'Saga transactions may use two fundamental techniques:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: Saga事务可能使用两种基本技术：
- en: '**Orchestration**: When the transaction starts, an orchestrator component is
    created that takes care of sending the necessary messages to all involved microservices
    and receiving their success/failure messages. This technique is easy to implement
    but creates dependencies between the software lifetimes of the involved microservices
    since the orchestrator must depend on the details of all microservices involved
    in the saga. Moreover, this technique may have poor performance since the orchestrator
    becomes a bottleneck.'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编排**：在事务开始时，创建一个编排组件，负责向所有涉及的微服务发送必要的消息并接收它们的成功/失败消息。这种技术易于实现，但会在涉及微服务的软件生命周期之间创建依赖关系，因为编排器必须依赖于参与叙事的所有微服务的详细信息。此外，由于编排器成为瓶颈，这种技术可能性能较差。'
- en: '**Choreography**: There is no centralized control of the transaction but each
    microservice is invoked by a different sending microservice and forwards the success/failure
    messages it receives to other communication neighbors. Choreography overcomes
    the disadvantages of orchestration but it is more difficult to implement and test.'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编排**：事务没有集中控制，但每个微服务都是由不同的发送微服务调用的，并将接收到的成功/失败消息转发给其他通信邻居。编排克服了编排的缺点，但实现和测试更困难。'
- en: The following table summarizes the pros and cons of the two techniques.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 下表总结了两种技术的优缺点。
- en: '|  | **Code maintainability** | **Difficulties in designing and debugging**
    |'
  id: totrans-200
  prefs: []
  type: TYPE_TB
  zh: '|  | **代码可维护性** | **设计和调试的困难** |'
- en: '| **Choreography** | Good | Quite high |'
  id: totrans-201
  prefs: []
  type: TYPE_TB
  zh: '| **编排** | 好 | 相当高 |'
- en: '| **Orchestration** | Low | No particular difficulty |'
  id: totrans-202
  prefs: []
  type: TYPE_TB
  zh: '| **编排** | 低 | 没有特别的困难 |'
- en: 'Table 14.3: Pros and cons of choreography and orchestration'
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 表 14.3：编排和编排的优缺点
- en: Implementing worker microservices with ASP.NET Core
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core 实现工作微服务
- en: In order to avoid blocking the caller’s synchronous request for too much time,
    an ASP.NET Core-based solution requires the implementation of an internal queue
    where it can store all received messages. This way, when a message is received,
    it is immediately enqueued without processing it, so that a “received” response
    can be immediately returned.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免阻塞调用者的同步请求太长时间，基于 ASP.NET Core 的解决方案需要实现一个内部队列，其中可以存储所有接收到的消息。这样，当收到消息时，它立即入队而不处理它，以便可以立即返回“已接收”响应。
- en: 'Therefore, the application level needs a repository interface that handles
    the queue. Here is a possible definition of this interface:'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，应用层需要一个处理队列的存储库接口。以下是此接口的可能定义：
- en: '[PRE24]'
  id: totrans-207
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Where:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 'Where:'
- en: '`QueueItem` is a class that contains all request information'
  id: totrans-209
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`QueueItem` 是一个包含所有请求信息的类'
- en: '`Enqueue` adds a new message to the queue'
  id: totrans-210
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Enqueue` 向队列中添加一条新消息'
- en: '`Top` returns the first `n` queue items without removing them from the queue'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Top` 返回前 `n` 个队列项，但不从队列中移除它们'
- en: '`Dequeue` removes the first `n` messages from the queue'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Dequeue` 从队列中移除前 `n` 条消息'
- en: The actual implementation of the preceding interface can be based on a database
    table, or any other storage media.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 前述接口的实际实现可以基于数据库表或其他任何存储介质。
- en: 'The application level can be implemented with an ASP.NET Core gRPC project
    that organizes all the gRPC stuff for you:'
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层可以使用一个 ASP.NET Core gRPC 项目来实现，该项目为您组织所有 gRPC 东西：
- en: '![](img/B19820_14_03.png)'
  id: totrans-215
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_14_03.png)'
- en: 'Figure 14.3: Creating a gRPC Server project'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 图 14.3：创建 gRPC 服务器项目
- en: 'The actual request processing is performed by a worker-hosted service that
    runs in parallel with the ASP.NET Core pipeline. It is implemented with the hosted
    services we discussed in the *Using generic hosts* section of *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*. It is worth recalling
    that hosted services are implementations of the `IHostedService` interface defined
    in the dependency injection engine as follows:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 实际的请求处理是由一个在 ASP.NET Core 管道并行运行的工人托管服务执行的。它是在第 11 章“将微服务架构应用于您的企业应用”中“使用通用宿主”部分讨论的托管服务中实现的。值得回忆的是，托管服务是实现依赖注入引擎中定义的
    `IHostedService` 接口的实现，如下所示：
- en: '[PRE25]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Being defined in the dependency injection engine, they are automatically injected
    services in their constructors. Hosted services are used to execute parallel threads
    that run independently of the remainder of the application. Usually, they are
    not defined by directly implementing the `IHostedService` interface, but by inheriting
    from the abstract `BackgroundService` class and overriding its `Task ExecuteAsync(CancellationToken
    token)` abstract method.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是在依赖注入引擎中定义的，它们在其构造函数中自动注入为服务。托管服务用于执行独立于应用程序其余部分的并行线程。通常，它们不是通过直接实现 `IHostedService`
    接口来定义的，而是通过继承抽象的 `BackgroundService` 类并重写其 `Task ExecuteAsync(CancellationToken
    token)` 抽象方法来定义。
- en: The `ExecuteAsync` method usually contains an endless loop that exits only when
    the application is shut down. This endless loop defines the behavior of a worker-hosted
    service that repeats a certain task. In our case, the task to repeat is the continuous
    extraction and processing of `N` items from the queue.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '`ExecuteAsync` 方法通常包含一个无限循环，只有当应用程序关闭时才会退出。这个无限循环定义了工作托管服务的行为，该服务会重复执行某个任务。在我们的情况下，要重复的任务是从队列中持续提取和处理
    `N` 个项目。'
- en: 'Here is a possible implementation of our hosted service:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是我们托管服务的一个可能的实现：
- en: '[PRE26]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: The class constructor is not injected with the specific services it needs but
    instead has the `IServiceProvider` that can be used to get any service defined
    in the dependency injection engine. The reason for this choice is that it will
    launch several threads (one for each of the `N` messages extracted from the queue),
    and, in general, different threads can’t share the same service instance.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 类构造函数没有注入它需要的特定服务，而是注入了 `IServiceProvider`，它可以用来获取依赖注入引擎中定义的任何服务。选择这个方案的原因是它将启动多个线程（每个线程对应从队列中提取的
    `N` 条消息中的一个），通常情况下，不同的线程不能共享同一个服务实例。
- en: The problem is caused by services with a session scope. Usually, these services
    are not designed to be thread-safe since the single session-scoped instance used
    throughout a whole ASP.NET Core request is never shared among parallel threads.
    However, we are not going to use our services from within the usual ASP.NET Core
    pipeline but from within parallel threads launched by our hosted service. Therefore,
    we need a different session scope for each parallel thread.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是由具有会话作用域的服务引起的。通常，这些服务没有被设计成线程安全的，因为在整个 ASP.NET Core 请求中使用的单个会话作用域实例永远不会在并行线程之间共享。然而，我们不会从通常的
    ASP.NET Core 管道内部使用我们的服务，而是从由我们的托管服务启动的并行线程内部使用。因此，我们需要为每个并行线程提供一个不同的会话作用域。
- en: Thus, the right way to process is to use `IServiceProvider` to create each necessary
    scope and then use each scope to get a different instance for each parallel thread.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正确的处理方式是使用 `IServiceProvider` 创建每个必要的范围，然后使用每个范围为每个并行线程获取不同的实例。
- en: The inner `while` loop runs until the queue is empty, then the worker thread
    sleeps for 100 milliseconds and then tries the inner loop again to see if in the
    meantime some new message reached the queue.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 内部 `while` 循环会一直运行，直到队列变为空，然后工作线程会休眠 100 毫秒，然后再次尝试内部循环，以查看在此期间是否有新的消息到达队列。
- en: When the application is shut down, the `stoppingToken` `CancellationToken` is
    signaled and both loops exit, so that the whole `ExecuteAsync` method exits and
    the worker thread dies.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 当应用程序关闭时，`stoppingToken` `CancellationToken` 被触发，两个循环退出，这样整个 `ExecuteAsync`
    方法就会退出，工作线程就会死亡。
- en: 'Here is the content of the inner loop:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是内部循环的内容：
- en: '[PRE27]'
  id: totrans-229
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: A session scope surrounds the whole code since we need a unique instance of
    `IMessageQueue` to manipulate the queue.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们需要一个唯一的 `IMessageQueue` 实例来操作队列，所以会话作用域包围了整个代码。
- en: The code tries to extract `N` messages from the queue. If no message is found,
    `queueEmpty` is set to `true`, so that the inner loop exits; otherwise, a `for`
    loop creates a separate task for each extracted request and inserts it in the
    `tasks` array.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 代码尝试从队列中提取 `N` 条消息。如果没有找到消息，`queueEmpty` 被设置为 `true`，这样内部循环就会退出；否则，一个 `for`
    循环为每个提取的请求创建一个单独的任务，并将其插入到 `tasks` 数组中。
- en: Then, `Task.WhenAll` awaits all tasks. Finally, `queue.Dequeue` removes from
    the queue all not-null requests returned from the tasks. Since a not-null request
    is returned only in the case of successful processing, `queue.Dequeue` removes
    just the successfully processed requests.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，`Task.WhenAll` 等待所有任务完成。最后，`queue.Dequeue` 从队列中移除所有从任务返回的非空请求。由于只有在处理成功的情况下才会返回非空请求，因此
    `queue.Dequeue` 只移除成功处理的请求。
- en: The `toExecute` method performs the actual request processing that depends on
    the specific application.
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '`toExecute`方法执行实际请求处理，这取决于特定应用程序。'
- en: A complete example containing all details and a step-by-step guide to its practical
    implementation is described in the *A worker microservice with ASP.NET Core* section
    of *Chapter 21, Case Study*. The complete source code of the example is contained
    in the folder associated with this chapter in the book’s GitHub repository.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 在第21章“案例研究”的“A worker microservice with ASP.NET Core”部分中，描述了一个包含所有细节和其实践实施步骤的完整示例。该示例的完整源代码包含在本书GitHub仓库中与该章节相关联的文件夹中。
- en: The next section shows you how to modify the code of this example to use queued
    communication based on the **RabbitMQ** message broker.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 下一节将向您展示如何修改此示例的代码以使用基于**RabbitMQ**消息代理的队列通信。
- en: Implementing microservices with .NET worker services and message brokers
  id: totrans-236
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用.NET工作服务和消息代理实现微服务
- en: This section explains the modifications needed to use a message broker instead
    of gRPC communication with an internal queue. This kind of solution is usually
    more difficult to test and design but allows for better horizontal scaling.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 本节解释了使用消息代理而不是与内部队列的gRPC通信所需的修改。这种解决方案通常更难测试和设计，但允许更好的水平扩展。
- en: The message broker used in the code is **RabbitMQ**. However, we could also
    replace it with **Azure Service Bus** using the code available in the GitHub repository
    associated with the book. The next subsection explains how to install RabbitMQ
    on your development machine. We used RabbitMQ to give the reader the opportunity
    to install and study it, since Azure Service Bus needs less configuration and
    is immediately ready to use. In an actual production system, one might choose
    RabbitMQ, just so you are not tied to a specific cloud provider, because while
    Azure Service Bus is available just on Azure, RabbitMQ can be installed in any
    cloud or on-premises environment.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 代码中使用的消息代理是**RabbitMQ**。然而，我们也可以使用GitHub仓库中与本书相关联的代码将其替换为**Azure Service Bus**。下一小节将解释如何在您的开发机器上安装RabbitMQ。我们使用RabbitMQ是为了给读者提供安装和学习的可能性，因为Azure
    Service Bus需要更少的配置并且立即可以使用。在实际的生产系统中，人们可能会选择RabbitMQ，这样您就不会绑定到特定的云提供商，因为虽然Azure
    Service Bus仅在Azure上可用，但RabbitMQ可以安装在任何云或本地环境中。
- en: Installing RabbitMQ
  id: totrans-239
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 安装RabbitMQ
- en: Before installing **RabbitMQ,** you need to install **Erlang** from the link
    given in the *Technical requirements* section. Just download and execute the installer
    from an administrative account. After that, you can download and install RabbitMQ
    from the link in the *Technical requirements* section.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 在安装**RabbitMQ**之前，您需要从“技术要求”部分提供的链接安装**Erlang**。只需下载并从管理员账户执行安装程序即可。之后，您可以从“技术要求”部分提供的链接下载并安装RabbitMQ。
- en: If installation is successful, you should find a service called **RabbitMQ**
    among your machine’s Windows services. If either you don’t find it or it is not
    running, restart your computer.
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 如果安装成功，您应该在您的机器的Windows服务中找到一个名为**RabbitMQ**的服务。如果您找不到它或它没有运行，请重新启动您的计算机。
- en: Administrative commands can be issued to RabbitMQ from the command prompt, which
    you can find in the **RabbitMQ Server** Windows menu folder.
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 可以从命令提示符向RabbitMQ发出管理命令，您可以在**RabbitMQ Server** Windows菜单文件夹中找到它。
- en: 'You can also enable a web-based administrative UI. Let’s open the RabbitMQ
    command prompt and issue the following command:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 您还可以启用基于Web的管理UI。让我们打开RabbitMQ命令提示符并输入以下命令：
- en: '[PRE28]'
  id: totrans-244
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Then, go to `http://localhost:15672`. You will be prompted for a username and
    password. Initially, they are both set to **guest**. From there, you may inspect
    all active connections and channels and all communication queues that have been
    created. The queues page contains all queues that have been defined. By clicking
    on each of them, you move to a queue-specific page where you can inspect the queue
    content and perform various operations on the specific queue.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，转到`http://localhost:15672`。您将被提示输入用户名和密码。最初，它们都被设置为**guest**。从那里，您可以检查所有活动连接和通道以及所有已创建的通信队列。队列页面包含所有已定义的队列。通过单击每个队列，您将转到特定队列的页面，在那里您可以检查队列内容并对特定队列执行各种操作。
- en: The next subsection contains a short survey of RabbitMQ features.
  id: totrans-246
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节包含了对RabbitMQ功能的简要调查。
- en: RabbitMQ basics
  id: totrans-247
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: RabbitMQ基础知识
- en: Natively, RabbitMQ supports the AMQP asynchronous message protocol, which is
    one of the most used asynchronous protocols, the other being MQTT, which has a
    specific syntax for the publisher/subscriber pattern.
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: RabbitMQ原生支持AMQP异步消息协议，这是最常用的异步协议之一，另一个是具有特定发布/订阅语法的MQTT。
- en: 'Support for MQTT can be added with a plugin, but RabbitMQ has facilities for
    implementing easily a publisher/subscriber pattern on top of AMQP. Moreover, RabbitMQ
    offers several tools to support scalability, disaster recovery, and redundancy,
    so it fulfills all requirements to be a first-class actor in cloud and microservices
    environments. More specifically, it supports data replication like most SQL and
    NoSQL databases and also supports cooperation among several servers based on sophisticated
    and flexible techniques. For lack of space, in this section, we will describe
    just RabbitMQ’s basic operations, but the reader can find more details in the
    tutorials and documentation of RabbitMQ’s official website: [https://www.rabbitmq.com/](https://www.rabbitmq.com/).'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过插件添加对MQTT的支持，但RabbitMQ提供了在AMQP之上轻松实现发布/订阅模式的工具。此外，RabbitMQ提供了一些工具来支持可伸缩性、灾难恢复和冗余，因此它满足了在云和微服务环境中成为一流演员的所有要求。更具体地说，它支持类似于大多数SQL和NoSQL数据库的数据复制，并且还支持基于复杂和灵活技术的多个服务器之间的协作。由于篇幅限制，在本节中，我们仅将描述RabbitMQ的基本操作，但读者可以在RabbitMQ官方网站的教程和文档中找到更多详细信息：[https://www.rabbitmq.com/](https://www.rabbitmq.com/)。
- en: RabbitMQ messages must be prepared in binary format since RabbitMQ messages
    must be just an array of bytes. Therefore, we need to serialize .NET objects with
    a binary formatter before sending them. In the example in this section, we will
    test both the ProtoBuf serializer and a fast .NET-specific serializer called *Binaron*.
    It might also be possible to use a JSON serializer to ensure better compatibility
    if there are compatibility issues among microservices implemented with different
    frameworks by different teams, and/or if there are legacy microservices. It is
    worth recalling that JSON is usually more compatible but less efficient, while
    binary formats are less compatible. ProtoBuf tries to solve the binary compatibility
    issue by defining a universal binary language, but it is not an official standard
    but a de facto standard.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 由于RabbitMQ的消息必须是字节数组，因此RabbitMQ的消息必须以二进制格式准备。因此，在发送之前，我们需要使用二进制格式化程序序列化.NET对象。在本节中的示例中，我们将测试ProtoBuf序列化程序和一个称为*Binaron*的快速.NET特定序列化程序。如果不同团队使用不同框架实现的微服务之间存在兼容性问题，或者存在遗留微服务，则也可能使用JSON序列化程序以确保更好的兼容性。值得回忆的是，JSON通常具有更好的兼容性但效率较低，而二进制格式则兼容性较差。ProtoBuf试图通过定义一种通用的二进制语言来解决二进制兼容性问题，但它不是一个官方标准，而是一种事实上的标准。
- en: Messages are not sent directly to queues, but to other entities called **exchanges**
    that route them to queues. Exchanges are AMQP-specific concepts, and are RabbitMQ’s
    way of configuring complex communication protocols like the publisher/subscriber
    protocol.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 消息不是直接发送到队列，而是发送到其他被称为**交换机**的实体，这些实体将消息路由到队列。交换机是AMQP特定的概念，是RabbitMQ配置复杂通信协议（如发布/订阅协议）的方式。
- en: '![](img/B19820_14_04.png)'
  id: totrans-252
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_14_04.png)'
- en: 'Figure 14.4: RabbitMQ exchanges'
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.4：RabbitMQ交换机
- en: 'To adequately define the exchange routing strategy, we can implement several
    patterns. More specifically:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 为了充分定义交换机的路由策略，我们可以实现几种模式。更具体地说：
- en: When we use a default exchange, the message is sent to a single queue and we
    can implement asynchronous direct calls.
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用默认交换机时，消息将发送到单个队列，我们可以实现异步直接调用。
- en: When we use a `fanout` exchange, the exchange will send the message to all queues
    that subscribe to that exchange. This way, we can implement the publisher/subscriber
    pattern.
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 当我们使用`fanout`交换机时，交换机会将消息发送到所有订阅该交换机的队列。这样，我们可以实现发布/订阅模式。
- en: There is also a `topic` exchange that enhances the publisher/subscriber pattern
    by enabling the matching of several events with wildcard chars. However, it is
    not usually needed in microservices for enterprise applications.
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个`topic`交换机，它通过允许使用通配符字符匹配多个事件来增强发布/订阅模式。然而，在企业级微服务中通常不需要它。
- en: Our examples will describe just direct calls, but the *Further reading* section
    contains a link to RabbitMQ tutorials that show examples of publisher/subscriber
    implementations.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的示例将仅描述直接调用，但*进一步阅读*部分包含一个链接到RabbitMQ教程，其中展示了发布/订阅实现的示例。
- en: The next section explains how to modify the code in the previous section to
    use RabbitMQ-based direct communication.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分解释了如何修改上一部分的代码以使用基于RabbitMQ的直接通信。
- en: Replacing internal queues with RabbitMQ
  id: totrans-260
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 将内部队列替换为RabbitMQ
- en: As previously discussed, in high-traffic WAN networks also receiving a synchronous
    received-message acknowledgment has an unacceptable performance impact, so no
    RPC protocol can be used. Moreover, often microservices use the publisher/subscriber
    pattern to achieve the best decoupling. In these cases, using a message broker
    is a MUST. Finally, having all queues handled by a unique scalable broker enables
    the independent and easy scaling of the communication resources. This capability
    is fundamental for optimizing the performance of applications made of hundreds
    or thousands of microservices.
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，在高流量WAN网络中，接收同步接收消息确认也有不可接受的性能影响，因此不能使用任何RPC协议。此外，通常微服务使用发布/订阅模式来实现最佳的解耦。在这些情况下，使用消息代理是必需的。最后，让所有队列都由一个唯一的可扩展代理处理，可以独立且容易地扩展通信资源。这种能力对于优化由数百或数千个微服务组成的应用程序的性能是基本的。
- en: Summing up, there are cases where message brokers are a MUST or are at least
    the best choice. Therefore, in this section, we will show how to use them by transforming
    the previous project so that it uses RabbitMQ instead of gRPC and internal queues.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，有些情况下，消息代理是必需的，或者至少是最好的选择。因此，在本节中，我们将展示如何通过将先前项目转换为使用RabbitMQ而不是gRPC和内部队列来使用它们。
- en: Unluckily this transformation requires a complete restructuration of the microservice
    project. We can save business and data layers but we need to move from an ASP.NET
    Core project to a different project template called **Worker Service**.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 不幸的是，这种转换需要完全重构微服务项目。我们可以保留业务和数据层，但我们需要从ASP.NET Core项目迁移到一个名为**Worker Service**的不同项目模板。
- en: 'Therefore, let’s replace the ASP.NET Core project with a **Worker Service**
    project:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们将ASP.NET Core项目替换为**Worker Service**项目：
- en: '![](img/B19820_14_05.png)'
  id: totrans-265
  prefs: []
  type: TYPE_IMG
  zh: '![img/B19820_14_05.png]'
- en: 'Figure 14.5: Setup Process for a gRPC Server Project in ASP.NET Core'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 图14.5：ASP.NET Core中gRPC服务器项目的设置过程
- en: We don’t need the gRPC services anymore, but we need ProtoBuf because RabbitMQ
    works with binary messages.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再需要gRPC服务，但我们需要ProtoBuf，因为RabbitMQ与二进制消息一起工作。
- en: 'The Worker Service project automatically scaffolds a hosted service (hosted
    services were discussed in detail in the *Using generic hosts* section of *Chapter
    11, Applying a Microservice Architecture to Your Enterprise Application*). However,
    the `ExecuteAsync` method of this hosted service must be a little bit different:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: Worker Service项目自动生成一个托管服务（托管服务在第11章“将微服务架构应用于您的企业应用程序”的*使用通用宿主*部分中进行了详细讨论）。然而，这个托管服务的`ExecuteAsync`方法必须略有不同：
- en: '[PRE29]'
  id: totrans-269
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Inside the main loop, if an exception is thrown, it is intercepted by the empty
    `catch`. Since the two `using` statements are left, both the connection and channel
    are disposed of. Therefore, after the exception, a new loop is executed that creates
    a new fresh connection and a new channel.
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 在主循环中，如果抛出异常，它会被空的`catch`拦截。由于两个`using`语句都留下来了，所以连接和通道都被释放了。因此，在异常之后，会执行一个新的循环，创建一个新的新鲜连接和一个新的通道。
- en: 'Intercepting exceptions is fundamental for several reasons:'
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 拦截异常是几个基本原因：
- en: First of all, it avoids the microservice crash.
  id: totrans-272
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 首先，它避免了微服务的崩溃。
- en: It enables a complete reset of all client objects involved in the communication
    with the RabbitMQ server that might be damaged by the error.
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它使所有参与与RabbitMQ服务器通信的客户端对象能够完全重置，这些对象可能因错误而损坏。
- en: It allows an error logging that, in the actual production environment, is the
    basic monitoring tool. For simplicity, error logging is not shown in the code
    snippets.
  id: totrans-274
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它允许错误记录，在实际的生产环境中，这是基本的监控工具。为了简单起见，错误记录在代码片段中没有显示。
- en: In the `using` statement body, we ensure that our queue exists, and then set
    `prefetch` to `1`.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在`using`语句的主体中，我们确保我们的队列存在，然后将`prefetch`设置为`1`。
- en: Ensuring queues exist and creating them if they don’t exist is better than relying
    on a single microservice for creating them since this approach avoids introducing
    complex dependencies and maintenance challenges related to the sequence in which
    microservices will run.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 确保队列存在，并在它们不存在时创建它们，比依赖于单个微服务来创建它们更好，因为这种方法避免了引入复杂的依赖关系和维护挑战，这些挑战与微服务运行的顺序有关。
- en: Setting `prefetch` to `1` causes each server to extract just one message at
    a time, which ensures a fair distribution of the load among all servers. However,
    setting `prefetch` to `1` might not be convenient when each server runs several
    equal parallel threads to process the incoming messages since it sacrifices thread
    usage optimization in favor of fair distribution of messages among servers. As
    a consequence, threads that could successfully process further messages (after
    the first) might remain idle, thus possibly wasting processor cores available
    on each server machine.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 将`prefetch`设置为`1`会导致每个服务器一次只提取一条消息，这确保了所有服务器之间负载的公平分配。然而，当每个服务器运行多个相等的并行线程来处理传入的消息时，将`prefetch`设置为`1`可能不太方便，因为它牺牲了线程使用优化以换取消息在服务器之间公平分配。因此，可能成功处理后续消息（在第一条之后）的线程可能会保持空闲，从而可能浪费每个服务器机器上可用的处理器核心。
- en: Then, we define a `message received` event handler. `BasicConsume` starts the
    actual message reception. With `autoAck` set to `false`, when a message is read
    from the queue, it is not removed but just blocked, so it is not available to
    other servers that read from the same queue. The message is actually removed when
    a confirmation that it has been successfully processed is sent to RabbitMQ. We
    can also send a failure confirmation, in which case the message is unblocked and
    becomes available for processing again.
  id: totrans-278
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们定义一个`消息接收`事件处理器。`BasicConsume`启动实际的消息接收。当`autoAck`设置为`false`时，从队列中读取消息后，消息不会被移除，而是被阻塞，因此它对从同一队列读取的其他服务器不可用。当向RabbitMQ发送确认消息，表明消息已被成功处理时，消息实际上被移除。我们还可以发送一个失败确认，在这种情况下，消息被解除阻塞并再次可用于处理。
- en: If no confirmation is received, the message remains blocked till the connection
    and channel are disposed of.
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有收到确认，消息将保持阻塞，直到连接和通道被释放。
- en: Since `BasicConsume` is non-blocking, the `Task.Delay` after it blocks until
    the cancellation token is signaled. In any case, after 1 second `Task.Delay` unblocks
    and both the connection and the channel are replaced with fresh ones. This prevents
    non-confirmed messages from remaining blocked forever.
  id: totrans-280
  prefs: []
  type: TYPE_NORMAL
  zh: 由于`BasicConsume`是非阻塞的，其后的`Task.Delay`会阻塞，直到取消令牌被信号。在任何情况下，1秒后`Task.Delay`解除阻塞，连接和通道都被替换为新的。这防止了未确认的消息永远被阻塞。
- en: Making instructions like `BasicConsume` non-blocking prevents a thread from
    wasting processor cores by remaining blocked while waiting for an event. Instead,
    the thread is put in sleeping mode by instructions like `Task.Delay`, thus freeing
    up all its resources and its assigned processor core, which, this way, can be
    assigned to another parallel thread that was waiting for a free core for its execution.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 将像`BasicConsume`这样的指令设置为非阻塞，可以防止线程在等待事件时浪费处理器核心。相反，线程通过像`Task.Delay`这样的指令进入睡眠模式，从而释放其所有资源及其分配的处理器核心，这样，它就可以分配给另一个等待空闲核心以执行其执行的并行线程。
- en: Let’s move on to the code inside the “message received” event. This is the place
    where the actual message processing takes place.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续看“消息接收”事件内部的代码。这是实际消息处理发生的地方。
- en: 'As a first step, the code verifies if the application is being shut down, in
    which case it disposes of the channel and connection and returns without performing
    any further operations:'
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，代码会验证应用程序是否正在关闭，如果是的话，它会释放通道和连接，并返回而不执行任何进一步的操作：
- en: '[PRE30]'
  id: totrans-284
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'Then, a session scope is created to access all session-scoped dependency injection
    services:'
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，创建一个会话作用域以访问所有会话作用域的依赖注入服务：
- en: '[PRE31]'
  id: totrans-286
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In the case that an exception is thrown during the message processing, a `Nack`
    message is sent to RabbitMQ to inform it that the message processing failed. `ea.DeliveryTag`
    is a tag that uniquely identifies the message. The second argument set to `false`
    informs RabbitMQ that the `Nack` is just for the message identified by `ea.DeliveryTag`
    that doesn’t also involve all other messages waiting for confirmation from this
    server. Finally, the last argument set to `true` asks RabbitMQ to requeue the
    message whose processing failed.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在消息处理过程中抛出异常，会向RabbitMQ发送一个`Nack`消息，通知它消息处理失败。`ea.DeliveryTag`是一个唯一标识消息的标签。第二个参数设置为`false`通知RabbitMQ，`Nack`只是为了由`ea.DeliveryTag`标识的消息，而不涉及等待此服务器确认的所有其他消息。最后，将最后一个参数设置为`true`请求RabbitMQ重新队列处理失败的消息。
- en: 'Inside the `try` block, there is the actual message processing. Its first step
    is the message deserialization:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 在`try`块内部，进行的是实际的消息处理。其第一步是消息反序列化：
- en: '[PRE32]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'After that, there is the actual application-dependent message processing. If
    this processing fails, we must send a `Nack`; otherwise, we must send an `Ack`:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 之后，是实际的应用依赖的消息处理。如果这个处理失败，我们必须发送`Nack`；否则，我们必须发送`Ack`：
- en: '[PRE33]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: The full code of a complete example is in the `GrpcMicroServiceRabbitProto`
    subfolder of the `ch15` folder in the GitHub repository of this book. A detailed
    description of this example is in the *A worker microservice based on RabbitMQ*
    section of *Chapter 21*, *Case Study*.
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 完整示例的完整代码位于本书GitHub仓库中`ch15`文件夹的`GrpcMicroServiceRabbitProto`子文件夹中。该示例的详细描述在*第21章*，*案例研究*中的*基于RabbitMQ的工作微服务*部分。
- en: The next chapter describes service-oriented architecture and how to implement
    it with ASP.NET Core.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章描述了面向服务的架构以及如何使用ASP.NET Core实现它。
- en: Summary
  id: totrans-294
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed various options for efficient internal microservices
    communication. We explained the importance of a binary serialization that is interoperable
    and that ensures compatibility with previous message versions, and we described
    ProtoBuf in detail.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了高效内部微服务通信的各种选项。我们解释了互操作性和确保与先前消息版本兼容的二进制序列化的重要性，并详细描述了ProtoBuf。
- en: We analyzed the limits of RPC communication and why data-driven communication
    must be preferred. Then, we focused on how to achieve reliable asynchronous communication
    and efficient distributed transactions.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 我们分析了RPC通信的局限性以及为什么数据驱动通信必须优先考虑。然后，我们关注了如何实现可靠的异步通信和高效的分布式事务。
- en: After having described the conceptual problems and techniques of reliable asynchronous
    communication, we looked at two architectures. The first one was based on gRPC,
    ASP.NET Core, and internal queues, and the second one was based on message brokers
    like RabbitMQ and .NET worker services.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 在描述了可靠异步通信的概念问题和技术之后，我们探讨了两种架构。第一种是基于gRPC、ASP.NET Core和内部队列的，第二种是基于像RabbitMQ和.NET工作服务的消息代理。
- en: The chapter explained, using practical examples, how to implement all the communication
    protocols that have been discussed and the architectural options for implementing
    worker microservices that are available in .NET.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 本章通过实际示例解释了如何实现所讨论的所有通信协议以及.NET中可用的实现工作微服务的架构选项。
- en: Questions
  id: totrans-299
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: Why are queues so important in microservices communication?
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么队列在微服务通信中如此重要？
- en: How do we recall another `.proto` file?
  id: totrans-301
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何重新调用另一个`.proto`文件？
- en: How can we represent a `TimeSpan` in the ProtoBuf language?
  id: totrans-302
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在ProtoBuf语言中表示`TimeSpan`？
- en: What are the advantages of ProtoBuf and gRPC over other binary options?
  id: totrans-303
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: ProtoBuf和gRPC相较于其他二进制选项有哪些优势？
- en: What are the advantages of using message brokers instead of internal queues?
  id: totrans-304
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用消息代理而不是内部队列有哪些优势？
- en: Why is it acceptable to use a blocking gRPC call to enqueue a message in a recipient
    queue?
  id: totrans-305
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么使用阻塞的gRPC调用来在接收队列中入队消息是可以接受的？
- en: How do we enable `.proto` file code generation in a .NET project file?
  id: totrans-306
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们如何在.NET项目文件中启用`.proto`文件代码生成？
- en: How do I send a message on a RabbitMQ channel with the official .NET client?
  id: totrans-307
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我该如何使用官方.NET客户端在RabbitMQ通道上发送消息？
- en: How do you ensure that a message sent on a RabbitMQ channel is safely saved
    on disk using the official .NET client?
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你如何确保使用官方.NET客户端在RabbitMQ通道上发送的消息能够安全地保存在磁盘上？
- en: Further reading
  id: totrans-309
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'The official .NET documentation on ProtoBuf can be found here: [https://docs.microsoft.com/it-it/aspnet/core/grpc/protobuf?view=aspnetcore-6.0](https://docs.microsoft.com/it-it/aspnet/core/grpc/protobuf?view=aspnetcore-6.0).'
  id: totrans-310
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方的.NET ProtoBuf文档可以在这里找到：[https://docs.microsoft.com/it-it/aspnet/core/grpc/protobuf?view=aspnetcore-6.0](https://docs.microsoft.com/it-it/aspnet/core/grpc/protobuf?view=aspnetcore-6.0)。
- en: 'The .NET documentation on gRPC is here: [https://docs.microsoft.com/it-it/aspnet/core/grpc/?view=aspnetcore-6.0](https://docs.microsoft.com/it-it/aspnet/core/grpc/?view=aspnetcore-6.0).'
  id: totrans-311
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET关于gRPC的文档可以在这里找到：[https://docs.microsoft.com/it-it/aspnet/core/grpc/?view=aspnetcore-6.0](https://docs.microsoft.com/it-it/aspnet/core/grpc/?view=aspnetcore-6.0)。
- en: 'The official Google documentation on the whole ProtoBuf language is here: [https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3).'
  id: totrans-312
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 官方Google关于整个ProtoBuf语言的文档在这里：[https://developers.google.com/protocol-buffers/docs/proto3](https://developers.google.com/protocol-buffers/docs/proto3)。
- en: 'Complete tutorials on RabbitMQ can be found here: [https://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html](https://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html).'
  id: totrans-313
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ 的完整教程可以在这里找到：[https://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html](https://www.rabbitmq.com/tutorials/tutorial-two-dotnet.html).
- en: 'The complete documentation for RabbitMQ is here: [https://www.rabbitmq.com/](https://www.rabbitmq.com/).'
  id: totrans-314
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: RabbitMQ 的完整文档在这里：[https://www.rabbitmq.com/](https://www.rabbitmq.com/).
- en: Learn more on Discord
  id: totrans-315
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Discord 上了解更多
- en: 'To join the Discord community for this book – where you can share feedback,
    ask questions to the authors, and learn about new releases – follow the QR code
    below:'
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 要加入这本书的 Discord 社区——在那里您可以分享反馈、向作者提问，并了解新版本——请扫描下面的二维码：
- en: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/SoftwareArchitectureCSharp12Dotnet8](https://packt.link/SoftwareArchitectureCSharp12Dotnet8)'
- en: '![](img/QR_Code175081751210902046.png)'
  id: totrans-318
  prefs: []
  type: TYPE_IMG
  zh: '![](img/QR_Code175081751210902046.png)'
