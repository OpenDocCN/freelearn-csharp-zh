- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Getting Started with Unit Testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Unit testing** is the core of TDD and a prerequisite for practicing it. I
    want to briefly go through the minimal necessary theory and focus more instead
    on familiarizing you with the tools and techniques that unit testing practitioners
    utilize in their daily code.'
  prefs: []
  type: TYPE_NORMAL
- en: Here, you will learn how to write unit tests that cover moderate coding scenarios.
    In *Part 2*, *Building an Application with TDD*, of this book, we will take the
    knowledge acquired in this chapter to a higher level and use it in a lifelike
    fashion.
  prefs: []
  type: TYPE_NORMAL
- en: In the previous chapter, we built the **weather forecasting application** (**WFA**)
    and made it a **dependency injection** (**DI**)-ready. We will use this application
    in this chapter as the basis for learning about unit testing. If you are not familiar
    with DI and DI containers, I recommend starting with [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037),
    *Understanding Dependency Injection by Example*, first.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduce unit testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explain the structure of a unit testing project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyze the anatomy of a unit test class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Discuss the basics of xUnit
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Show how SOLID principles and unit testing are related
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to write basic unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The code for this chapter can be found at the following GitHub repository:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch03](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch03)'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As a TDD practitioner, you will be writing much more unit test code than production
    code (the regular application code). Unlike other test categories, unit tests
    will dictate some architectural decisions of your application and enforce DI.
  prefs: []
  type: TYPE_NORMAL
- en: We won’t dwell on long definitions. Instead, we will demonstrate unit testing
    with a plethora of examples. In this section, we will discuss the xUnit unit testing
    framework and the unit test structure.
  prefs: []
  type: TYPE_NORMAL
- en: What is unit testing?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '*Unit testing is testing a behavior while swapping real dependencies with test
    doubles*. Let me back up this definition with an example from `WeatherForecastController`
    in the WFA:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This method converts Celsius to Fahrenheit and logs every call. Logging is not
    the concern here because this method’s concern is the conversion.
  prefs: []
  type: TYPE_NORMAL
- en: The *behavior* of this method is *converting input degrees from Celsius to Fahrenheit*,
    and the logging *dependency* here is accessed through the `_logger` object. At
    runtime, we are injecting a `Logger<>` that will be writing to a physical medium,
    but we possibly want to eliminate the writing side effect when testing.
  prefs: []
  type: TYPE_NORMAL
- en: Based on the earlier definition, we need to *swap the real dependency* that
    `_logger` uses at runtime with its test double counterpart and test the conversion
    behavior. We will show how to do this later on in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Take another example from the same class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The behavior of this method is getting the real weather forecast and passing
    it to the caller. The `_client` object here represents the OpenWeather dependency.
    This method’s behavior is *not* about interacting with the details of the RESTful
    protocol of the OpenWeather API or the HTTP protocol. This is handled by `_client`.
    We need to swap the real dependency, `Client`, that `_client` uses at runtime,
    and replace it with one that is suitable for testing (we call this a **test double**).
    I will show how this is done, in many ways, in [*Chapter 4*](B18370_04.xhtml#_idTextAnchor097),
    *Real Unit Testing with Test Doubles*.
  prefs: []
  type: TYPE_NORMAL
- en: At this stage, the concept is still cryptic, I know; just bear with me, and
    we will start expanding gently. In the next section, we will discuss unit testing
    frameworks. We will need this to unit test the preceding examples and the WFA.
  prefs: []
  type: TYPE_NORMAL
- en: Unit testing frameworks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '.NET 6 has three major unit testing frameworks. The most popular one is **xUnit**,
    which we will use across this book. The other two are **NUnit** and **MSTest**:'
  prefs: []
  type: TYPE_NORMAL
- en: '*NUnit* is an open source library. It started as a port from Java’s JUnit framework
    and was then completely rewritten. You will still encounter it in legacy projects,
    but the majority of today’s projects start with xUnit.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*MSTest* is Microsoft’s unit testing framework that gained popularity because
    it used to be shipped with Visual Studio and no extra effort was needed to install
    it, especially since NuGet did not exist back then. It became open source in version
    2, and it was always lagging behind NUnit and then xUnit in terms of features.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*xUnit* is an open source project that was started by developers from NUnit.
    It is feature-rich and in constant development.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The term **XUnit** is an umbrella term for different languages’ unit test frameworks,
    such as **JUnit** (**Java**), **NUnit** (**.NET**), **xUnit** (**.NET**), and
    **CUnit** (**C language**). This should not be confused with the library name
    *xUnit*, which is a .NET unit test library, where the founders picked an already-taken
    and confusing name.
  prefs: []
  type: TYPE_NORMAL
- en: Learning one framework and then switching to another should take no time, as
    they are similar, and you just need to figure out the terminology used by the
    specific framework. Next, we will add an xUnit project to the solution to unit
    test the WFA.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding test projects
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: xUnit templates come as part of VS. We will show how to add an xUnit project
    using the **.NET CLI** approach. At this stage, if you have not opened the companion
    source code that is ported from [*Chapter 2*](B18370_02.xhtml#_idTextAnchor037),
    *Understanding Dependency Injection by Example*, to this chapter, I encourage
    you to do so.
  prefs: []
  type: TYPE_NORMAL
- en: Adding xUnit via the CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, we have a solution with one ASP.NET Core project. Now, we want to
    add the unit tests library to our solution. To do so, create a new xUnit project
    called `Uqs.Weather.Tests.Unit` in a directory with the same name, and use .NET
    6.0:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Add the newly created project to the solution file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: Now, we have two projects in our solution. As the unit test project will be
    testing the ASP.NET Core project, the unit test project should have a reference
    to the ASP.NET Core project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a project reference from `Uqs.Weather.Tests.Unit` on `Uqs.Weather`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We now have our solution fully constructed via the CLI. You can see the full
    interaction here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.1 – Creating a new xUnit project in a solution via the CLI ](img/Figure_3.1_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – Creating a new xUnit project in a solution via the CLI
  prefs: []
  type: TYPE_NORMAL
- en: We now have a project to contain our unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Test project naming convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: You have noticed that we have appended `.Tests.Unit` to the original project
    name, so the unit test project became `Uqs.Weather.Tests.Unit`. This is a common
    convention in naming test projects.
  prefs: []
  type: TYPE_NORMAL
- en: 'This convention extends to other testing projects, such as integration testing
    and Sintegration testing, to be discussed in the *More testing categories* section
    in [*Chapter 4*](B18370_04.xhtml#_idTextAnchor097). You might also have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Uqs.Weather.Tests.Integration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Uqs.Weather.Tests.Sintegration`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The wisdom behind this convention is that you can look at your list of projects
    and rapidly find the test projects related to one production code project ordered
    next to each other, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.2 – Ordered unit test projects ](img/Figure_3.2_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – Ordered unit test projects
  prefs: []
  type: TYPE_NORMAL
- en: 'The convention also helps in targeting all your test projects in the continuous
    integration, which will be covered in [*Chapter 11*](B18370_11.xhtml#_idTextAnchor265),
    *Implementing Continuous Integration with GitHub Actions*, in case you wanted
    to run all categories of tests. Here is an example: `Uqs.Weather.Tests.*`.'
  prefs: []
  type: TYPE_NORMAL
- en: Running the sample unit test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The xUnit template comes with a sample unit test class called `UnitTest1.cs`
    that has a sample unit test method with the following content:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: This has a single unit test called `Test1` that is empty and does nothing at
    the moment. To check that the xUnit framework and the integration with VS does
    work, you can try executing this single test.
  prefs: []
  type: TYPE_NORMAL
- en: From the VS menu, select **Test** | **Run All Tests** or similarly use the *Ctrl*
    + *R*, *A* keyboard shortcut. This will execute all your tests in the project
    (which is currently one test), and you will have the following tool, known as
    **Test Explorer**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.3 – Test Explorer ](img/Figure_3.3_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.3 – Test Explorer
  prefs: []
  type: TYPE_NORMAL
- en: The hierarchy displayed here is **Project Name** | **Test Class Namespace**
    | **Test Class Name** | **Test Method Name**.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you are the CLI kind of person, you can go to the solution directory with
    the command prompt and execute the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'This is what you may get:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – CLI dotnet test results ](img/Figure_3.4_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – CLI dotnet test results
  prefs: []
  type: TYPE_NORMAL
- en: I have seen **Test Explorer** used more in day-to-day TDD-style development
    than the CLI. The CLI is useful for running the whole solution or for continuous
    integration and automated runs.
  prefs: []
  type: TYPE_NORMAL
- en: Test Explorer
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Test Explorer comes with VS. Additionally, xUnit adds a few libraries that allow
    Test Explorer and VS to interact with xUnit tests. There are third-party providers
    that have more advanced test runners. One of them is *JetBrains ReSharper Unit
    Test Explorer*. We have everything ready to start writing unit test code.
  prefs: []
  type: TYPE_NORMAL
- en: Unit test class anatomy
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When we unit test, we tend to write a **unit test class** that is targeting
    a parallel production class – one test class against one production class.
  prefs: []
  type: TYPE_NORMAL
- en: Applying this concept to our WFA project, our production class is `WeatherForecastController`
    and the unit test class is going to be called `WeatherForecastControllerTests`.
    So, rename the `UnitTest1` sample class to `WeatherForecastControllerTests`.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can set your text cursor anywhere within the class name in the source code
    (in the previous case, it was `UnitTest1`) and hit *Ctrl* + *R*, *R* (hold *Ctrl*
    then press *R* quickly twice). Type the new name `WeatherForecastControllerTests`
    and hit *Enter*. This will also rename the file if the **Rename symbol’s file**
    checkbox is ticked.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will see how to organize our unit test class and its methods.
  prefs: []
  type: TYPE_NORMAL
- en: Class naming convention
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: I found the most commonly used convention is calling the unit test class name
    the same as the production code class name, appending the `Tests` suffix. For
    example, the `MyProductionCode` test class counterpart would be `MyProductionCodeTests`.
  prefs: []
  type: TYPE_NORMAL
- en: When practicing TDD, you will need to switch between the test class and its
    counterpart production code class multiple times in a short period. Naming them
    using this pattern allows you to find the test and its related counterpart easily,
    or vice versa. It also clarifies the relationship between the two classes.
  prefs: []
  type: TYPE_NORMAL
- en: Test methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Each test class contains methods that test pieces of functionality, known as
    units, from the production code class. Let’s take the example of testing the `ConvertCToF`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: Test example 1
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Part of the requirements that we have is testing the conversion with a single
    decimal point accuracy. So, let’s consider one testing case by taking a zero degree
    (0.0 C) and testing if the method is returning 32.0 F. To do that, we can delete
    the `Test1` method in the unit tests class and replace it with the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: This code initializes the production code class, calls the method under test,
    and then assesses the results of the test with our expectations.
  prefs: []
  type: TYPE_NORMAL
- en: '`Fact` is an attribute that makes a method a unit test. `Assert` is a static
    class that has useful methods for comparing expected results to actual results.
    Both `Fact` and `Assert` are part of the xUnit framework.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run this test with Test Explorer using *Ctrl* + *R*, *A*, and the test will
    yield the following screen:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Fail output in Test Explorer ](img/Figure_3.5_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Fail output in Test Explorer
  prefs: []
  type: TYPE_NORMAL
- en: 'If we look inside the controller, we find that VS has a red sign to map the
    route that led to this failure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.6 – VS showing the failed test route ](img/Figure_3.6_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – VS showing the failed test route
  prefs: []
  type: TYPE_NORMAL
- en: 'It is apparent from the error message what is causing `ArgumentNullException`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'This is expected, as we have passed the `logger` parameter from the unit test
    as `null`. We want `_logger.LogInformation` to do nothing, and in order to do
    that, we will be using `NullLogger<>`, which does nothing, as indicated by the
    official documentation. Our unit test code needs to change to the following so
    that we can replace the real logger with a dummy one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: If you run the test again, all the reds will turn green, and the test will pass.
  prefs: []
  type: TYPE_NORMAL
- en: Test example 2
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To test another input and output for the method, we can add more unit tests
    to the class and follow the same test method name pattern. We can have the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'But, there is a succinct solution for avoiding writing a similar unit test
    for every value combination, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Notice that we are using `Theory` rather than `Fact`. Every `InlineData` will
    act as a single unit test. You can even eliminate *example 1* and make it an `InlineData`
    attribute. No need to say that `Theory` and `InlineData` are attributes from xUnit.
  prefs: []
  type: TYPE_NORMAL
- en: You can go ahead and run the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Other examples are covered in [*Chapter 1*](B18370_01.xhtml#_idTextAnchor014),
    *Writing Your First TDD Implementation*, similar to the previous ones in this
    chapter, so you could have a look for more clarity.
  prefs: []
  type: TYPE_NORMAL
- en: '*Examples 1* and *2* target a simple method, `ConvertCToF`, that has a single
    dependency, `_logger`. We will cover more sophisticated testing scenarios after
    learning about test doubles in [*Chapter 4*](B18370_04.xhtml#_idTextAnchor097),
    *Real Unit Testing with Test Doubles*. In reality, your production code will be
    more complicated than a simple conversion method and will contain multiple dependencies,
    but there is a first step for everything.'
  prefs: []
  type: TYPE_NORMAL
- en: Naming convention
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unit test method names follow a popular convention: `MethodUnderTest_Condition_Expectation`.
    We have seen this convention used earlier. Here are more hypothetical examples:'
  prefs: []
  type: TYPE_NORMAL
- en: '`SaveData_CannotConnectToDB_InvalidOperationException`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrderShoppingBasket_EmptyBasket_NoAction`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This book contains plenty of other examples that should clarify this convention
    further.
  prefs: []
  type: TYPE_NORMAL
- en: The Arrange-Act-Assert pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The previous test method, and generally all unit test methods, follows a similar
    pattern:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a state, declare some variables, and do some preparations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Call the method under test.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assert the actual results against expectations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Practitioners decided to give these three stages the following names:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Arrange**, **Act**, and **Assert** (**AAA**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'They mark the code with a comment to show the stages and emphasize the separation.
    According to this, we can write one of the previous test methods as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Notice the comments that were added to the code.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: Some teams dislike having the separation by writing comments. Instead, they
    choose a different way to mark AAA, for example, by leaving a single line space
    between each section.
  prefs: []
  type: TYPE_NORMAL
- en: The AAA practice is more than a convention. It makes the method easier to read
    on-the-fly. It also emphasizes that there should be only one *Act* in a unit test
    method. Consequently, a unit test, based on best practices, is not supposed to
    have more than a single AAA structure.
  prefs: []
  type: TYPE_NORMAL
- en: Using VS code snippets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Every unit test is going to have the same structure. VS allows you to cut down
    on writing the same structure with the help of `CodeSnippets` directory in this
    chapter source code. It is called `aaa.snippet`. You can open it and view/edit
    its content via a regular text editor (not a word processor).
  prefs: []
  type: TYPE_NORMAL
- en: 'To use this snippet on Windows, copy `aaa.snippet` to this directory (choosing
    the right VS version):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Once this is copied, in your unit test class, type `aaa`, then hit the *Tab*
    button, and you will get the following generated code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: Rather than speaking more about having a single AAA in your unit test, we will
    demonstrate this across this book to illuminate the style that seniors use in
    writing unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we had an overview of the class anatomy and the unit test method structure,
    we will explore the unit test class’s counterpart: the system under test.'
  prefs: []
  type: TYPE_NORMAL
- en: System under test
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A unit test is meant to test a single functionality of a production code. Each
    unit test class has a production code counterpart that is being tested. We refer
    to the production code being tested as the **system under test** (**SUT**). You
    can see here an illustration of what the SUT is:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – Unit tests operating against the SUT ](img/Figure_3.7_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – Unit tests operating against the SUT
  prefs: []
  type: TYPE_NORMAL
- en: The term SUT is the most dominant one, but you might find others refer to it
    as **class under test** (**CUT**), **code under test** (**CUT** – yes, it is the
    same acronym), or **method under test** (**MUT**).
  prefs: []
  type: TYPE_NORMAL
- en: 'The term *SUT* is used in developers’ conversations, and it is also commonly
    used in the code to make it clear what is being tested, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'It is important to understand the SUT of your unit test class. You will gradually
    notice as your project grows that you will have a pattern being formed, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Unit test project versus production code project ](img/Figure_3.8_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Unit test project versus production code project
  prefs: []
  type: TYPE_NORMAL
- en: Every unit test class is paired with an SUT counterpart.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have seen a few features of xUnit both here and in [*Chapter 1*](B18370_01.xhtml#_idTextAnchor014),
    *Writing Your First TDD Implementation*, it is time to have a closer look at xUnit.
  prefs: []
  type: TYPE_NORMAL
- en: The basics of xUnit
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: xUnit provides the hosting environment for your tests. One important feature
    of xUnit is that it is AAA-convention friendly. It also integrates with the VS
    IDE and its Test Explorer.
  prefs: []
  type: TYPE_NORMAL
- en: Extensive examples using xUnit appear naturally in this book. However, it is
    worth dedicating a few sections to discussing the principal features of this framework.
  prefs: []
  type: TYPE_NORMAL
- en: Fact and theory attributes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In your test project, any method that is decorated with `Fact` or `Theory` will
    become a test method. `Fact` is meant for a non-parametrized unit test, and `Theory`
    is for a parametrized one. With `Theory`, you can add other attributes, such as
    `InlineData`, for parametrization.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: VS will give you a visual indication above the method name that you can run
    the methods decorated with these attributes, but sometimes it doesn’t until you
    run all the tests.
  prefs: []
  type: TYPE_NORMAL
- en: Running the tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Each unit test will *run independently* and instantiate the class. The unit
    tests *do not share* each other’s states. So, a unit test class runs differently
    than a normal class. Let me elaborate with a sample code, shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The previous unit tests do pass. Notice that while I am incrementing `_instanceField`
    in both test methods, the value of `_instanceField` is not shared between the
    two methods, and every time xUnit is instantiating a method, all my class is instantiated
    again. This is why the value is reset back to `0` before every method execution.
    This characteristic of xUnit promotes a unit test principle known as **no interdependency**,
    which will be discussed in [*Chapter 6*](B18370_06.xhtml#_idTextAnchor140), *The
    FIRSTHAND Guidelines of TDD*.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the static field was shared between the two methods and its
    value has changed.
  prefs: []
  type: TYPE_NORMAL
- en: Important Note
  prefs: []
  type: TYPE_NORMAL
- en: While I have used both instance and static fields to illustrate the distinctive
    behavior of a unit test class, I want to emphasize that using a static `read-write`
    field in a unit test is an anti-pattern because this breaks the *no interdependency*
    principle. In general, you should have no common `write` fields in unit test classes,
    and fields are better to be marked with the `readonly` keyword.
  prefs: []
  type: TYPE_NORMAL
- en: Instead, if the same methods are part of a regular code class (not a unit test
    class) and both are called, we expect to find the value of `_instanceField` incremented
    to `2`, but this was not the case here.
  prefs: []
  type: TYPE_NORMAL
- en: Assert class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`Assert` is a static class, and it is part of xUnit. This is how the official
    documentation defines the `Assert` class:'
  prefs: []
  type: TYPE_NORMAL
- en: Contains various static methods that are used to verify0 that conditions are
    met.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a quick overview of some of the methods of `Assert`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Equal(expected, actual)`: These are a series of overloads that will compare
    the expectations to actuals. You have seen a few examples of `Equal` in [*Chapter
    1*](B18370_01.xhtml#_idTextAnchor014), *Writing Your First TDD Implementation*,
    and in this chapter.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`True(actual)`: Rather than using `Equal` to compare two objects, you can use
    this one where relevant to promote readability. Let’s clarify this with an example:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`False(actual)`: The opposite of the previous method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Contains(expected, collection)`: A group of overloads that check for the existence
    of a single element in a collection.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoesNotContain(expected, collection)`: The opposite of the previous method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Empty(collection)`: This verifies that a collection is empty.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Assert.IsType<Type>(actual)`: This verifies whether an object is of a certain
    type.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'As there are more methods, I encourage you to visit the official xUnit site
    to have a look, or to do what most developers do: write `Assert` in a unit test
    class, and type a *dot* after it to trigger IntelliSense and view the displayed
    methods.'
  prefs: []
  type: TYPE_NORMAL
- en: The methods of `Assert` will communicate with the test runner, such as Test
    Explorer, to report back the result of the assertions.
  prefs: []
  type: TYPE_NORMAL
- en: Record class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `Record` class is a static class that records exceptions so that you can
    test whether your method is throwing or not throwing the right exception. This
    is an example of one of its static methods, which is called `Exception()`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`public static System.Exception Exception(Action testCode)`'
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous code returns the exception that is thrown by `Action`. Let’s take
    this example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are checking whether the `Load` method will throw `FormatException`
    if it is presented with an invalid JSON input.
  prefs: []
  type: TYPE_NORMAL
- en: This was a summary of xUnit’s functionality, and this should get you started
    writing basic unit tests.
  prefs: []
  type: TYPE_NORMAL
- en: Applying SOLID principles to unit testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The SOLID principles are highly covered and advertised on the web and in books.
    Chances are that this is not the first time that you’ve heard or read about them.
    They are a popular interview question as well. SOLID principles stand for the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '*S*ingle-responsibility principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*O*pen-closed principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*L*iskov Substitution principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*I*nterface Segregation principle'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*D*ependency Inversion'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this section, we are interested mostly in the relationship between the SOLID
    principles and unit testing. While not all the principles have strong ties with
    unit testing, we will cover all of them for completion.
  prefs: []
  type: TYPE_NORMAL
- en: Single-responsibility principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **single-responsibility principle** (**SRP**) is about having each class
    with one responsibility only. This will lead it to have one reason to change.
    The benefits of this approach are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easier to read and understand classes**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The classes will have fewer methods, which should cause less code. Its interface
    will have fewer methods as well.
  prefs: []
  type: TYPE_NORMAL
- en: '**Less rippling effect when changing a feature**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There are fewer classes to change, which would lead to an easier change.
  prefs: []
  type: TYPE_NORMAL
- en: '**Less probability of change, which means fewer potential bugs**:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More code means more potential bugs, and changing code would also lead to potential
    bugs. Having less code in the first place means fewer code changes.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The SRP is not an exact science, and the challenge is being able to decide what
    *responsibility* is. Every developer has their own view. The next example illustrates
    the idea.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s assume you have created your own file format called *ABCML* to solve
    a particular problem, as the existing file formats (such as JSON, XML, and others)
    do not satisfy your specific need. A set of classes with each having a single
    responsibility could be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: A class to validate whether the content of the file is in the right structure
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class to export ABCML to a generic format
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class that inherits the generic ABCML export to support exporting to JSON,
    and another class that supports exporting to XML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A class that represents a node in your ABCML
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: More classes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: You can see how I split responsibilities into individual classes, although there
    is no single design for having a single responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: SRP and unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Naturally, when doing unit testing, you think of a single responsibility for
    a class, and you call your unit test class the same name with the `tests` suffix.
    So, if you are thinking of testing the validation of the ABCML file format, you
    might have `ABCMLValidationTests`.
  prefs: []
  type: TYPE_NORMAL
- en: In your unit test class, each unit test targets a single behavior in your SUT.
    Those behaviors combined lead to a single responsibility.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Multiple single behavior tests targeting a single responsibility
    ](img/Figure_3.9_B18370.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Multiple single behavior tests targeting a single responsibility
  prefs: []
  type: TYPE_NORMAL
- en: 'The previous figure shows multiple tests, each test is focused on a single
    behavior, and they are targeting one responsibility: *validation*. On the right,
    there is one method, but this is only for illustration, as you might have multiple
    public methods and you can still have a single responsibility.'
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B18370_06.xhtml#_idTextAnchor140), *The FIRSTHAND Guidelines
    of TDD*, we will introduce a guideline known as the *single-behavior guideline*.
    This guideline works with TDD and unit tests to encourage the SRP.
  prefs: []
  type: TYPE_NORMAL
- en: Open-closed principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **open-closed principle** (**OCP**) is about preparing your class to be
    inheritable (having it open) so that any feature addition could just inherit this
    class without modifying it (having it closed).
  prefs: []
  type: TYPE_NORMAL
- en: The essence of this principle is to minimize unnecessary changes every time
    a new feature is added.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s take an example that will make this clearer. Assume we have created a
    library to do arithmetic calculations. Let’s start by *not being OCP-compliant*,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: The `Calculate` method in the preceding code will have to change every time
    we add a new `ArithmeticOperation`. If we want to add the multiplication operation,
    per the commented line, as a feature at a later stage, then the `Calculate` method
    will need to change to accommodate the new feature.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can make this implementation more OCP-compliant by eliminating the need
    to change the `Calculate` method every time a new operation is added. Let’s see
    how this can be done:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The previous example leveraged polymorphism to stop the `Calculation` method
    from being changed every time a new operation is added. You can see from the commented
    line how a new multiplication operation can be added. This is a more OCP-compliant
    approach.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: While I had all the classes and interfaces listed together here and on the GitHub
    code, I did this for illustration, as they are usually separated into their own
    files. So, with the OCP, you also reduce the chance of changing the file and make
    it easier on the source control level to understand what changed.
  prefs: []
  type: TYPE_NORMAL
- en: OCP and unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unit testing protects changes in any class by making sure that a change does
    not inadvertently break an existing feature. The OCP and unit testing work hand
    in hand. So, while the OCP reduces the chance of avoidable changes, the unit testing
    adds an additional protection layer when a change is made by verifying business
    rules.
  prefs: []
  type: TYPE_NORMAL
- en: Liskov substitution principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Liskov substitution principle** (**LSP**) states that an instance of a
    child class must replace an instance of the parent class without affecting the
    results that we would get from an instance of the base class itself. A child class
    should be a true representation of its parent class.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We shall use an academic type of example that will make the concept easier
    to understand. Let’s take the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'In the previous code, and according to LSP, `Ostrich` should not have inherited
    `Bird`. Let’s rectify the code to comply with the LSP:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: We have changed the inheritance hierarchy by introducing a new intermediary
    class called `FlyingBird` for compliance with the LSP.
  prefs: []
  type: TYPE_NORMAL
- en: LSP and unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unit testing has no direct impact on the LSP, but the LSP is mentioned here
    for completion.
  prefs: []
  type: TYPE_NORMAL
- en: Interface segregation principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **interface segregation principle** (**ISP**) states that child classes
    should not be forced to depend upon interfaces that they do not use. Interfaces
    should be smaller so that whoever is implementing them can mix and match.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'I always find the way collections implement in .NET is the best example to
    explain this principle. Let’s look at how `List<T>` is declared:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: It is implementing six interfaces. Each interface contains a limited number
    of methods. `List<T>` provides a huge number of methods, but the way it does that
    is by selecting multiple interfaces, with each interface adding a few of the methods.
  prefs: []
  type: TYPE_NORMAL
- en: One method that `List<T>` exposes is `GetEnumerator()`. This method comes from
    the `IEnumerable<T>` interface; actually, it is the only method on `IEnumerable<T>`.
  prefs: []
  type: TYPE_NORMAL
- en: By having small interfaces (interfaces of few and related methods), as in this
    example, `List<T>` was able to choose what it needs to implement, no more and
    no less.
  prefs: []
  type: TYPE_NORMAL
- en: ISP and unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unit testing has no direct impact on the ISP, but the ISP is mentioned here
    for completion.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency inversion principle
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **dependency inversion principle** (**DIP**) states that high-level modules
    should not depend on low-level modules. Both should depend on abstractions. Abstractions
    should not depend on details. Details should depend on abstractions. In other
    words, the DIP is a principle that promotes loose coupling between classes by
    using abstractions and DI.
  prefs: []
  type: TYPE_NORMAL
- en: Example
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '[*Chapter 2*](B18370_02.xhtml#_idTextAnchor037), *Understanding Dependency
    Injection by Example*, is focused on this topic, and it is rich with examples
    of changing the code to enable DI.'
  prefs: []
  type: TYPE_NORMAL
- en: DIP and unit testing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There is a tight relationship between the DIP and unit testing. Real unit tests
    cannot function without DI. In fact, the effort spent on making everything injectable
    and having the proper interface designs for classes without interfaces promotes
    the DIP as a byproduct.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the SRP and the DIP are promoted by unit testing. So, while
    you are increasing your production quality, your design quality is improving as
    a result. There is no argument that unit testing requires effort, but part of
    this effort is already paid into your design quality and code readability.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we touched on basic unit testing-related topics, and we went
    through several examples.
  prefs: []
  type: TYPE_NORMAL
- en: If I was to categorize unit testing experience from 1 to 5, with level 1 being
    a beginner and 5 being an expert, this chapter should get you to level 2\. Fear
    not! After going through the rest of the book, where more realistic examples will
    come, you will be at level 4, so I am glad you have made it so far. Keep going!
  prefs: []
  type: TYPE_NORMAL
- en: '*Is this book going to take me to level 5?* I hear you asking. Well, unit testing
    is not a sprint, it is a marathon; it takes years of practice to get to that level,
    and only getting your hands dirty in unit testing will get you there.'
  prefs: []
  type: TYPE_NORMAL
- en: We also covered the relationship between SOLID principles and unit testing to
    show you the big picture and how everything fits nicely together.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, I have deliberately avoided examples that require a deep understanding
    of test doubles, so as to introduce you to unit testing in a gentle way. However,
    in reality, most unit tests will require test doubles. Let’s move forward to a
    more realistic spectrum and dive into this concept in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics discussed in the chapter, you can refer to the
    following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Walkthrough: Create a code snippet*: [https://docs.microsoft.com/en-us/visualstudio/ide/walkthrough-creating-a-code-snippet](https://docs.microsoft.com/en-us/visualstudio/ide/walkthrough-creating-a-code-snippet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*xUnit*: [https://xunit.net](https://xunit.net)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
