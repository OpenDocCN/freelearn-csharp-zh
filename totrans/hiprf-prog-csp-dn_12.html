<html><head></head><body>
		<div id="_idContainer160">
			<h1 id="_idParaDest-185"><em class="italic"><a id="_idTextAnchor189"/>Chapter 10</em>: Setting Up Our Database Project</h1>
			<p>In this and the following two chapters, we will be improving the performance of your database-based applications. In this chapter, we will be setting up our relational database and the code to access that database. In the next chapter, we will write benchmarks to test the performance of the different frameworks, which consist of Entity Framework, Dapper, and ADO.NET. Finally, in <a href="B16617_12_Final_SB_Epub.xhtml#_idTextAnchor215"><em class="italic">Chapter 12</em></a>, <em class="italic">Responsive User Interfaces</em>, we will learn how to improve the performance of SQL Server and Cosmos DB.</p>
			<p>Data is extensively used in all aspects of our daily lives. In today's world of big data, the volume of data being collected and stored for all kinds of analysis is phenomenal. When working with data, performance can slow down exponentially as the size of your data grows. And depending on how much data you have to process, time is often critical.</p>
			<p>In this chapter, we will create a database and populate it, and we will write the code to access the database and perform insert, update, select, and delete operations. Our database access code will consist of Entity Framework, Dapper.NET, and ADO.NET.</p>
			<p class="callout-heading">Note</p>
			<p class="callout">No code performance improvements will be discussed in this chapter. We are only concerned with setting up our database and source code in preparation for the benchmarking that we will be doing in the next chapter.</p>
			<p>In this chapter, we will cover the following topics:</p>
			<ul>
				<li>Creating and populating a SQL Server database</li>
				<li>Writing code to access the database using Entity Framework</li>
				<li>Writing code to access the database using Dapper.NET</li>
				<li>Writing code to access the database using ADO.NET</li>
			</ul>
			<p>After completing this chapter, you will be able to do the following:</p>
			<ul>
				<li>Log on to SQL Server Management Studio and execute database creation and seeding scripts</li>
				<li>Store secrets in <strong class="source-inline">secrets.json</strong> when developing so that secrets don't get stored in version control</li>
				<li>Access SQL Server databases and perform <strong class="bold">Create/Insert, Read/Select, Update, and Delete</strong> (<strong class="bold">CRUD</strong>) operations using Entity Framework</li>
				<li>Access SQL Server databases and perform CRUD operations using Dapper.NET</li>
				<li>Access SQL Server databases and perform CRUD operations using ADO.NET</li>
			</ul>
			<h1 id="_idParaDest-186"><a id="_idTextAnchor190"/>Technical requirements</h1>
			<p>To follow along with this chapter, you will need to ensure that you have the following:</p>
			<ul>
				<li>SQL Server 2019 Express Edition or higher</li>
				<li>SQL Server Management Studio</li>
				<li>Visual Studio 2022</li>
				<li>This book's source code: <a href="https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10">https://github.com/PacktPublishing/High-Performance-Programming-in-CSharp-and-.NET/tree/master/CH10</a><a href="https://github.com/PacktPublishing/Mastering-High-Performance-with-C-10.0-and-.NET-6&#13;"/></li>
			</ul>
			<h1 id="_idParaDest-187"><a id="_idTextAnchor191"/>Setting up our database</h1>
			<p>In this section, we will set up our database and get our project ready for benchmarking. We will be <a id="_idIndexMarker1038"/>benchmarking different methods of inserting, updating, selecting, and deleting data. Let's start with setting up our database:</p>
			<ol>
				<li>Visit <a href="https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs">https://github.com/Microsoft/sql-server-samples/tree/master/samples/databases/northwind-pubs</a>.</li>
				<li>Download the <strong class="source-inline">instnwnd.sql</strong> file.</li>
				<li>Once the file has been downloaded, open it in SQL Server Management Studio.</li>
				<li>Execute the file. This will install the database.</li>
				<li>Open a <a id="_idIndexMarker1039"/>new query window and enter the following SQL code:<p class="source-code">USE [Northwind]</p><p class="source-code">GO</p><p class="source-code">SET ANSI_NULLS ON</p><p class="source-code">GO</p><p class="source-code">SET QUOTED_IDENTIFIER ON</p><p class="source-code">GO</p><p class="source-code">CREATE PROCEDURE [dbo].[InsertProduct] </p><p class="source-code">    @ProductName NVARCHAR(40),</p><p class="source-code">    @CategoryID INT,</p><p class="source-code">    @SupplierID INT,</p><p class="source-code">    @Discontinued BIT</p><p class="source-code">AS</p><p class="source-code">BEGIN</p><p class="source-code">SET NOCOUNT ON;</p><p class="source-code">INSERT INTO </p><p class="source-code">        Products (</p><p class="source-code">            ProductName,</p><p class="source-code">            CategoryID,</p><p class="source-code">            SupplierID,</p><p class="source-code">            Discontinued,</p><p class="source-code">             QuantityPerUnit</p><p class="source-code">        )</p><p class="source-code">    VALUES (</p><p class="source-code">        @ProductName,</p><p class="source-code">        @CategoryID,</p><p class="source-code">        @SupplierID,</p><p class="source-code">        @Discontinued,</p><p class="source-code">         '1'</p><p class="source-code">    )</p><p class="source-code">END</p><p class="source-code">GO</p></li>
			</ol>
			<p>Once the code has been entered, execute the script. This code generates the <strong class="source-inline">InsertProduct</strong> stored <a id="_idIndexMarker1040"/>procedure. This stored procedure inserts a product into the <strong class="source-inline">Products</strong> table of the <strong class="source-inline">Northwind</strong> database.</p>
			<ol>
				<li value="6">Replace the existing SQL with the following SQ<a id="_idTextAnchor192"/>L:<p class="source-code">USE [Northwind]</p><p class="source-code">GO</p><p class="source-code">SET ANSI_NULLS ON</p><p class="source-code">GO</p><p class="source-code">SET QUOTED_IDENTIFIER ON</p><p class="source-code">GO</p><p class="source-code">CREATE PROCEDURE [dbo].[GetProductName]</p><p class="source-code">    @ProductName NVARCHAR(40)</p><p class="source-code">AS</p><p class="source-code">BEGIN</p><p class="source-code">    SET NOCOUNT ON;</p><p class="source-code">    SELECT </p><p class="source-code">        Top 1 ProductName </p><p class="source-code">    FROM </p><p class="source-code">        Products</p><p class="source-code">    WHERE</p><p class="source-code">        ProductName LIKE @ProductName</p><p class="source-code">END</p><p class="source-code">GO</p></li>
			</ol>
			<p>Execute the SQL to generate the <strong class="source-inline">GetProductName</strong> stored procedure. A product <a id="_idIndexMarker1041"/>name can have different variations. This stored procedure gets the top 1 name for the given product.</p>
			<ol>
				<li value="7">Replace the existing SQL code with the following SQL:<p class="source-code">USE [Northwind]</p><p class="source-code">GO</p><p class="source-code">SET ANSI_NULLS ON</p><p class="source-code">GO</p><p class="source-code">SET QUOTED_IDENTIFIER ON</p><p class="source-code">GO</p><p class="source-code">CREATE PROCEDURE [dbo].[FilterProducts]</p><p class="source-code">    @ProductName NVARCHAR(40)</p><p class="source-code">AS</p><p class="source-code">BEGIN</p><p class="source-code">        SET NOCOUNT ON;</p><p class="source-code">        SELECT </p><p class="source-code">            * </p><p class="source-code">        FROM </p><p class="source-code">            Products</p><p class="source-code">        WHERE</p><p class="source-code">            ProductName LIKE @ProductName</p><p class="source-code">END</p><p class="source-code">GO</p></li>
			</ol>
			<p>Execute the SQL to generate the <strong class="source-inline">FilterProducts</strong> stored procedure. The stored procedure returns all the products whose names contain the search term.</p>
			<ol>
				<li value="8">Now, replace <a id="_idIndexMarker1042"/>the existing SQL with this SQL:<p class="source-code">USE [Northwind]</p><p class="source-code">GO</p><p class="source-code">SET ANSI_NULLS ON</p><p class="source-code">GO</p><p class="source-code">SET QUOTED_IDENTIFIER ON</p><p class="source-code">GO</p><p class="source-code">CREATE PROCEDURE [dbo].[UpdateProductName]</p><p class="source-code">        @OldProductName NVARCHAR(40),</p><p class="source-code">        @NewProductName NVARCHAR(40)</p><p class="source-code">AS</p><p class="source-code">BEGIN</p><p class="source-code">    SET NOCOUNT ON;</p><p class="source-code">     UPDATE </p><p class="source-code">         Products</p><p class="source-code">         SET </p><p class="source-code">            ProductName = @NewProductName</p><p class="source-code">         WHERE</p><p class="source-code">            ProductName = @OldProductName</p><p class="source-code">END</p><p class="source-code">GO</p></li>
			</ol>
			<p>Execute this SQL to generate the <strong class="source-inline">UpdateProductName</strong> stored procedure. This procedure updates a product name from its current name to a new name.</p>
			<ol>
				<li value="9">Replace <a id="_idIndexMarker1043"/>the existing SQL with the following:<p class="source-code">USE [Northwind]</p><p class="source-code">GO</p><p class="source-code">SET ANSI_NULLS ON</p><p class="source-code">GO</p><p class="source-code">SET QUOTED_IDENTIFIER ON</p><p class="source-code">GO</p><p class="source-code">CREATE PROCEDURE [dbo].[DeleteProduct]</p><p class="source-code">    @ProductName NVARCHAR(40)</p><p class="source-code">AS</p><p class="source-code">BEGIN</p><p class="source-code">    SET NOCOUNT ON;</p><p class="source-code">     DELETE FROM </p><p class="source-code">            Products</p><p class="source-code">     WHERE</p><p class="source-code">            ProductName = @ProductName</p><p class="source-code">END</p><p class="source-code">GO</p></li>
			</ol>
			<p>Execute this code to generate the <strong class="source-inline">DeleteProduct</strong> stored procedure. This deletes products from the database that match the given product name.</p>
			<ol>
				<li value="10">Once the database <a id="_idIndexMarker1044"/>has been installed and all the procedures have been written and executed, you can close SQL Server Management Studio.</li>
			</ol>
			<p>Now that we have set up our database, we will set up our database access project.</p>
			<h1 id="_idParaDest-188"><a id="_idTextAnchor193"/>Setting up our database access project</h1>
			<p>In this section, we will be creating our database access project and classes. In the next chapter, we will <a id="_idIndexMarker1045"/>be writing some benchmarks that reference the classes that we will write in this chapter. Create the project as follows: </p>
			<ol>
				<li value="1">Open Visual Studio and create a new .NET 6.0 console application called <strong class="source-inline">CH10_DataAccessBenchmarks</strong>.</li>
				<li>Add the latest version of the <strong class="source-inline">Microsoft.EntityFrameworkCore.SqlServer</strong> NuGet package.</li>
				<li>Add the latest version of the <strong class="source-inline">Dapper</strong> NuGet package.</li>
				<li>Add the latest version of the <strong class="source-inline">System.Data.SqlClient</strong> NuGet package.</li>
				<li>Add a new folder called <strong class="source-inline">Configuration</strong>, and add two classes called <strong class="source-inline">DatabaseSettings</strong> and <strong class="source-inline">SecretsManager</strong>.</li>
				<li>Add a folder called <strong class="source-inline">Data</strong>, and add three classes called <strong class="source-inline">AdoDotNetData</strong>, <strong class="source-inline">DapperDotNet</strong>, and <strong class="source-inline">EntityFrameworkCoreData</strong>.</li>
				<li>Add a folder called <strong class="source-inline">Models</strong>, and add three classes called <strong class="source-inline">Product</strong>, <strong class="source-inline">SqlCommandModel</strong>, and <strong class="source-inline">SqlCommandParameterModel</strong>.</li>
				<li>Add a folder called <strong class="source-inline">Reflection</strong>, and add a class called <strong class="source-inline">Properties</strong>.</li>
				<li>On the main root, add a class called <strong class="source-inline">BenchmarkTests</strong>.</li>
				<li>Save the project.</li>
			</ol>
			<p>With that, we have created and updated our database with the stored procedures we will be calling, and <a id="_idIndexMarker1046"/>we have also put in place the project, folders, and class files that we will be using to benchmark the various types of data operations we normally perform on a database from code. Let's start by writing the <strong class="source-inline">Properties</strong> class.</p>
			<h2 id="_idParaDest-189"><a id="_idTextAnchor194"/>Writing the Properties class</h2>
			<p>As part of our <a id="_idIndexMarker1047"/>benchmarking, we need to <a id="_idIndexMarker1048"/>obtain the <strong class="source-inline">FieldCount</strong> value of a <strong class="source-inline">DbDataRecord</strong>. But the property is not readily accessible without using reflection. Therefore, to make our lives easier, we will write a class called <strong class="source-inline">Properties</strong> that helps us get the values of properties using reflection easily. Follow these steps:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">Properties</strong> class and add the following <strong class="source-inline">using</strong> statements:<p class="source-code">using System.Data.Common;</p><p class="source-code">using System.Reflection;</p><p class="source-code">internal class Properties </p><p class="source-code">{</p><p class="source-code">}</p></li>
			</ol>
			<p>We need both these namespaces to be imported as we are using reflection and need access to the <strong class="source-inline">DbDataRecord</strong> class.</p>
			<ol>
				<li value="2">Add the <strong class="source-inline">GetProperty</strong> method:<p class="source-code">public static PropertyInfo GetProperty&lt;T&gt;(string name)</p><p class="source-code">{</p><p class="source-code">      return typeof(T).GetProperty(name);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes a generic type and a property name. Then, it obtains the property and returns it as a <strong class="source-inline">PropertyInfo</strong> instance.</p>
			<ol>
				<li value="3">Now, add the <strong class="source-inline">GetValue</strong> method:<p class="source-code">public static T GetValue&lt;T, U&gt;(U source, string name)</p><p class="source-code">{</p><p class="source-code">      return (T)GetProperty&lt;U&gt;(name).GetValue(source);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method <a id="_idIndexMarker1049"/>takes a generic object <a id="_idIndexMarker1050"/>type, return type, and property name. Then, it calls the <strong class="source-inline">GetProperty</strong> method by passing in the generic object type and property name. The <strong class="source-inline">GetValue</strong> method is then called, passing in the source object. The result is cast to the generic return type and returned to the caller.</p>
			<ol>
				<li value="4">Add the <strong class="source-inline">GetFieldCount</strong> method:<p class="source-code">    public static int GetFieldCount(DbDataRecord </p><p class="source-code">        record)</p><p class="source-code">    {</p><p class="source-code">        return GetValue&lt;int, DbDataRecord&gt;(</p><p class="source-code">        record, "FieldCount"</p><p class="source-code">    );</p><p class="source-code">}</p></li>
			</ol>
			<p>This method accepts a <strong class="source-inline">DbDataRecord</strong> object. It calls our <strong class="source-inline">GetValue</strong> method by passing in the return type, our <strong class="source-inline">DbDataRecord</strong>, and our <strong class="source-inline">FieldCount</strong> property name. An integer is returned that contains the number of fields that our <strong class="source-inline">DbDataRecord</strong> object has.</p>
			<p>With that, we have created our <strong class="source-inline">Properties</strong> class. As part of our benchmarking, we will be inserting, reading, editing, and deleting data from a SQL Server database. And so, in the next section, we will update our <strong class="source-inline">DatabaseSettings</strong> class.</p>
			<h2 id="_idParaDest-190"><a id="_idTextAnchor195"/>Writing the DatabaseSettings class</h2>
			<p>Our <strong class="source-inline">DatabaseSettings</strong> class is <a id="_idIndexMarker1051"/>really simple: it contains a single property. Open the database and add the following property:</p>
			<pre class="source-code">public string ConnectionString { get; set; }</pre>
			<p>This property holds our connection string for the SQL Server database. We will be setting this property in each of our benchmark methods. Then, it will be passed to the constructors of our data access classes.</p>
			<p>Because database connection strings are a sensitive form of data that should be kept very private, we will be storing our database connection strings in a <strong class="source-inline">secrets.json</strong> file during the development process. But in production, we will obtain the connection string from an <strong class="source-inline">appsettings.json</strong> file. And so, in the next section, we will be writing a <strong class="source-inline">SecretsManager</strong> class.</p>
			<h1 id="_idParaDest-191"><a id="_idTextAnchor196"/>Writing the SecretsManager</h1>
			<p>In this section, we are <a id="_idIndexMarker1052"/>going to update our <strong class="source-inline">SecretsManager</strong> class so that we can safely obtain secrets. </p>
			<p class="callout-heading">Note</p>
			<p class="callout">Our development environment will use a <strong class="source-inline">secrets.json</strong> file. This is very serious as private credentials have been found and accessed on source code hosting sites such as GitHub before now, and we don't want to be the ones responsible for checking in code that contains secrets that should be kept private.</p>
			<p>Follow these steps:</p>
			<ol>
				<li value="1">Add the following NuGet packages:<p class="source-code">Microsoft.Extensions.Configuration</p><p class="source-code">Microsoft.Extensions.Configuration.JsonFile</p><p class="source-code">Microsoft.Extensions.Configuration.EnvironmentVariables</p><p class="source-code">Microsoft.Extensions.Configuration.UserSecrets</p></li>
			</ol>
			<p>We need these packages so that we can configure the project for user secrets and <strong class="source-inline">appsettings.json</strong>.</p>
			<ol>
				<li value="2">Open the <strong class="source-inline">SecretsManager</strong> class and add the following <strong class="source-inline">using</strong> statements:<p class="source-code">using Microsoft.Extensions.Configuration;</p><p class="source-code">using System;</p><p class="source-code">using System.IO;</p></li>
			</ol>
			<p>We need <a id="_idIndexMarker1053"/>these <strong class="source-inline">using</strong> statements for our property, filesystem, and environment variable access, and for access to the Microsoft <strong class="source-inline">IConfiguration</strong> interface.</p>
			<ol>
				<li value="3">Add the <strong class="source-inline">Configuration</strong> property:<p class="source-code">public static IConfiguration Configuration </p><p class="source-code">{</p><p class="source-code">      get; private set; </p><p class="source-code">}</p></li>
			</ol>
			<p>This property will hold the correct configuration object, which depends on whether we are in development or production mode.</p>
			<ol>
				<li value="4">Now, add the <strong class="source-inline">GetSecrets</strong> method:<p class="source-code">public static string GetSecrets&lt;T&gt;(string sectionName)</p><p class="source-code">where T : class</p><p class="source-code">{</p><p class="source-code">var devEnvironmentVariable = </p><p class="source-code">    Environment</p><p class="source-code">        .GetEnvironmentVariable("NETCORE_ENVIRONMENT");</p><p class="source-code">var isDevelopment = </p><p class="source-code">    string.IsNullOrEmpty(devEnvironmentVariable) </p><p class="source-code">    || devEnvironmentVariable.ToLower() == "development";</p><p class="source-code">var builder = new ConfigurationBuilder()</p><p class="source-code">    .SetBasePath(Directory.GetCurrentDirectory())</p><p class="source-code">        .AddJsonFile(</p><p class="source-code">            "appsettings.json", </p><p class="source-code">            optional: true, </p><p class="source-code">            reloadOnChange: true</p><p class="source-code">    )</p><p class="source-code">    .AddEnvironmentVariables();</p><p class="source-code">//only add secrets in development</p><p class="source-code">if (isDevelopment) </p><p class="source-code">{</p><p class="source-code">    builder.AddUserSecrets&lt;T&gt;();</p><p class="source-code">}</p><p class="source-code">Configuration = builder.Build();</p><p class="source-code">return Configuration.GetSection($"{typeof(T).Name}</p><p class="source-code">      :{sectionName}").Value;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method determines whether we are in development or non-development mode. If we are <a id="_idIndexMarker1054"/>in development mode, then we use the secrets configuration mode. Otherwise, we obtain secrets from the <strong class="source-inline">appsettings.json</strong> file. The method accepts a section name, which is the name of the secret we want to retrieve, and it returns the value of that secret.</p>
			<p>With that, we have finished writing our <strong class="source-inline">secrets</strong> class. For our data manipulation benchmarks, we will <a id="_idIndexMarker1055"/>be focusing on a single table – the <strong class="source-inline">Products</strong> table of the <strong class="source-inline">Northwind</strong> database. We will need a class that will act as a model for the data. So, in the next section, we'll write the <strong class="source-inline">Product</strong> class.</p>
			<h1 id="_idParaDest-192"><a id="_idTextAnchor197"/>Writing the Product class</h1>
			<p>In this section, we <a id="_idIndexMarker1056"/>will update our <strong class="source-inline">Product</strong> class. It is a simple object that is used for data manipulation benchmarks and contains properties that match the <strong class="source-inline">Products</strong> table in the <strong class="source-inline">Northwind</strong> database. Follow these steps:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">Product</strong> class and update it as follows:<p class="source-code">using System;</p><p class="source-code">using System.ComponentModel.DataAnnotations;</p><p class="source-code">using System.ComponentModel.DataAnnotations.Schema;</p><p class="source-code">[Table("Products")]</p><p class="source-code">public class Product</p><p class="source-code">{</p><p class="source-code">}</p></li>
			</ol>
			<p>Here, we annotated our class with the <strong class="source-inline">Table</strong> annotation, passing the name of the table in the <strong class="source-inline">Northwind</strong> database that this class maps to into the annotation.</p>
			<ol>
				<li value="2">Add the following properties and annotations:<p class="source-code">[Key]</p><p class="source-code">public int ProductID { get; set; }</p><p class="source-code">public string ProductName { get; set; }</p><p class="source-code">[ForeignKey("Suppliers")]</p><p class="source-code">public int SupplierID { get; set; }</p><p class="source-code">[ForeignKey("Categories")]</p><p class="source-code">public int CategoryID { get; set; }</p><p class="source-code">public string QuantityPerUnit { get; set; } = "1"</p><p class="source-code">public decimal UnitPrice { get; set; }</p><p class="source-code">public Int16 UnitsInStock { get; set; }</p><p class="source-code">public Int16 UnitsOnOrder { get; set; }</p><p class="source-code">public Int16 ReorderLevel { get; set; }</p><p class="source-code">public bool Discontinued { get; set; }</p></li>
			</ol>
			<p>These properties match the columns of the <strong class="source-inline">Product</strong> table in the <strong class="source-inline">Northwind</strong> database. The <strong class="source-inline">[Key]</strong> annotation identifies the <strong class="source-inline">ProductID</strong> property as the table's primary <a id="_idIndexMarker1057"/>key. Two foreign keys are identified by the <strong class="source-inline">[ForeignKey]</strong> annotation. We pass the name of the table into this annotation, which contains the primary key.</p>
			<p>And that's it – we've finished writing our <strong class="source-inline">Product</strong> class. We will be using several commands  and parameters when accessing data. To make life easy, we will have a <strong class="source-inline">SqlCommandModel</strong><strong class="source-inline"> </strong>class for defining our commands, and a <strong class="source-inline">SqlCommandParameterModel</strong> class for defining our command parameters. Let's begin by writing the <strong class="source-inline">SqlCommandModel</strong> class.</p>
			<h1 id="_idParaDest-193"><a id="_idTextAnchor198"/>Writing the SqlCommandModel class</h1>
			<p>In this section, we <a id="_idIndexMarker1058"/>write a simple class that models a SQL command. Follow these steps:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">SqlCommandModel</strong> class, define the class as public, and add the <strong class="source-inline">System.Data</strong> namespace.</li>
				<li>Now, add the following three properties:<p class="source-code">public string CommandText { get; set; }</p><p class="source-code">public CommandType CommandType { get; set; }</p><p class="source-code">public SqlCommandParameterModel[] CommandParameters { </p><p class="source-code">    get; set; }</p></li>
			</ol>
			<p>The <strong class="source-inline">CommandText</strong> property holds our SQL command. This may be the name of a stored <a id="_idIndexMarker1059"/>procedure or a SQL statement. The <strong class="source-inline">CommandType</strong> property determines whether the command is a <strong class="source-inline">Text</strong> command or a <strong class="source-inline">StoredProcedure</strong> command, while the <strong class="source-inline">CommandParameters</strong> property contains an array of SQL command parameters.</p>
			<p>Now that we have written <strong class="source-inline">SqlCommandModel</strong>, let's write the <strong class="source-inline">SqlCommandParameterModel</strong> class.</p>
			<h1 id="_idParaDest-194"><a id="_idTextAnchor199"/>Writing the SqlCommandParameterModel class</h1>
			<p>In this <a id="_idIndexMarker1060"/>section, we'll write our <strong class="source-inline">SqlCommandParameterModel</strong> class. This class is simply a SQL parameter definition model.</p>
			<p>Open the <strong class="source-inline">SqlCommandParameterModel</strong> class, make the class public, and add the <strong class="source-inline">System.Data</strong> namespace.</p>
			<p>Now, add the following three parameters:</p>
			<pre class="source-code">public string ParameterName { get; set; }</pre>
			<pre class="source-code">public DbType DataType { get; set; }</pre>
			<pre class="source-code">public dynamic Value { get; set; }</pre>
			<p>This class models a standard parameter that consists of the name of the parameter, its database type, and its value.</p>
			<p>With that, we have created the core functionality that we need in place for our data access classes. In the following sections, we will be writing data access classes to access data using Entity Framework, Dapper, and ADO.NET.</p>
			<p>The reason behind choosing SQL Server for the database server is that it is one of the most common database servers and is used in many business scenarios the world over. In professional <a id="_idIndexMarker1061"/>environments where SQL Server is employed, the three most common data access methods are Entity Framework, Dapper, and ADO.NET. That is why we will be benchmarking them in this chapter. Let's start by writing our ADO.NET data access class.</p>
			<h1 id="_idParaDest-195"><a id="_idTextAnchor200"/>Writing the AdoDotNet class</h1>
			<p>In this section, we will <a id="_idIndexMarker1062"/>be writing our data insertion methods. However, we will not be running our benchmarks, which will be performed in the next chapter as we analyze our results. Follow these steps:</p>
			<ol>
				<li value="1">Update the <strong class="source-inline">AdoDotNetData</strong> class, as follows:<p class="source-code">using CH10_DataAccessBenchmarks.Models;</p><p class="source-code">using CH10_DataAccessBenchmarks.Reflection;</p><p class="source-code">using System;</p><p class="source-code">using System.Collections;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using System.Data.Common;</p><p class="source-code">using System.Data.SqlClient;</p><p class="source-code">using System.Reflection;</p><p class="source-code">internal class AdoDotNetData : IDisposable</p><p class="source-code">{</p><p class="source-code">private readonly SqlConnection _sqlConnection;</p><p class="source-code">private bool _isDisposed;</p><p class="source-code">public AdoDotNetData(string connectionString)</p><p class="source-code">{</p><p class="source-code">          _sqlConnection = </p><p class="source-code">           new SqlConnection(connectionString);</p><p class="source-code">}</p><p class="source-code">public void Dispose()</p><p class="source-code">{</p><p class="source-code">    Dispose(_isDisposed);</p><p class="source-code">}</p><p class="source-code">public void Dispose(bool disposing)</p><p class="source-code">{</p><p class="source-code">        if (disposing)</p><p class="source-code">        {</p><p class="source-code">        _sqlConnection.Dispose();</p><p class="source-code">        _isDisposed = true;</p><p class="source-code">    }</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>In the <a id="_idIndexMarker1063"/>preceding code, we implemented the <strong class="source-inline">IDisposable</strong> pattern. When we have finished with our class, we dispose of our class, which also disposes of disposable objects that it holds in memory.</p>
			<ol>
				<li value="2">Add the <strong class="source-inline">ExecuteNonQuery</strong> method:<p class="source-code">    internal void ExecuteNonQuery(SqlCommandModel </p><p class="source-code">        model)</p><p class="source-code">    {</p><p class="source-code">        SqlCommand sqlCommand </p><p class="source-code">         = new (model.CommandText, _sqlConnection);</p><p class="source-code">     sqlCommand.CommandType = model.CommandType;</p><p class="source-code">     foreach (SqlCommandParameterModel parameter in </p><p class="source-code">        model.CommandParameters)</p><p class="source-code">     sqlCommand.Parameters.Add(new SqlParameter()</p><p class="source-code">        {</p><p class="source-code">            ParameterName = parameter.ParameterName,</p><p class="source-code">            DbType = parameter.DataType,</p><p class="source-code">            Value = parameter.Value</p><p class="source-code">     });</p><p class="source-code">     _sqlConnection.Open();</p><p class="source-code">     sqlCommand.ExecuteNonQuery();</p><p class="source-code">     _sqlConnection.Close();</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes a <strong class="source-inline">SqlCommandModel</strong> object. A new instance of the <strong class="source-inline">SqlCommand</strong> object is created. We pass the SQL command and SQL connection <a id="_idIndexMarker1064"/>into the constructor during instantiation. Then, we loop through the command parameters, instantiating and adding a <strong class="source-inline">SqlParameter</strong> for each <strong class="source-inline">model.CommandParameter</strong> to the <strong class="source-inline">sqlCommand</strong> object. Next, we open a connection to the database, execute the query, and close the connection.</p>
			<ol>
				<li value="3">Add the following code:<p class="source-code">internal int ExecuteNonQuery(string sql)</p><p class="source-code">{</p><p class="source-code">try</p><p class="source-code">{</p><p class="source-code">_sqlConnection.Open();</p><p class="source-code">return new SqlCommand(sql, _sqlConnection)</p><p class="source-code">    .ExecuteNonQuery();</p><p class="source-code">}</p><p class="source-code">finally</p><p class="source-code">{</p><p class="source-code">_sqlConnection.Close();</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>The preceding code executes the non-query SQL code that's been passed in via the <strong class="source-inline">sql</strong> string.</p>
			<ol>
				<li value="4">Add the <a id="_idIndexMarker1065"/>following generic scalar method:<p class="source-code">internal T ExecuteScalar&lt;T&gt;(string sql)</p><p class="source-code">{</p><p class="source-code">     try</p><p class="source-code">     {</p><p class="source-code">        _sqlConnection.Open();</p><p class="source-code">        return (T)new SqlCommand(sql, _sqlConnection)</p><p class="source-code">            .ExecuteScalar();</p><p class="source-code">}</p><p class="source-code">    finally</p><p class="source-code">    {</p><p class="source-code">        _sqlConnection.Close();</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes a SQL command as a string. A connection to the database is opened, and a new <strong class="source-inline">SqlCommand</strong> is instantiated. The <strong class="source-inline">ExecuteScalar</strong> command is executed, which returns a single value from the database. Before the value is returned, it is cast to the generic type specified by the caller and returned as that type. The connection is then closed.</p>
			<ol>
				<li value="5">Add the <a id="_idIndexMarker1066"/>following scalar method:<p class="source-code">internal T ExecuteScalar&lt;T&gt;(SqlCommandModel model)</p><p class="source-code">{</p><p class="source-code">SqlCommand sqlCommand = new(</p><p class="source-code">     model.CommandText, _sqlConnection);</p><p class="source-code">sqlCommand.CommandType = model.CommandType;</p><p class="source-code">    foreach (SqlCommandParameterModel parameter in </p><p class="source-code">        model.CommandParameters)</p><p class="source-code">        sqlCommand.Parameters.Add(new SqlParameter()</p><p class="source-code">        {</p><p class="source-code">            ParameterName = parameter.ParameterName,</p><p class="source-code">            DbType = parameter.DataType,</p><p class="source-code">            Value = parameter.Value</p><p class="source-code">     });</p><p class="source-code">  _sqlConnection.Open();</p><p class="source-code">    T data = (T)sqlCommand.ExecuteScalar();</p><p class="source-code">    _sqlConnection.Close();</p><p class="source-code">    return data;</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes a <strong class="source-inline">SqlCommandModel</strong> and uses it to build up a <strong class="source-inline">SqlCommand</strong>. The <strong class="source-inline">SqlCommand</strong> class is executed by calling the <strong class="source-inline">ExecuteScalar</strong> method and is cast to the generic type before being returned.</p>
			<ol>
				<li value="6">Add <a id="_idIndexMarker1067"/>the following reader method:<p class="source-code">internal IEnumerator&lt;T&gt; ExecuteReader&lt;T&gt;(string sql)</p><p class="source-code">{</p><p class="source-code">    Type TypeT = typeof(T);</p><p class="source-code">    ConstructorInfo ctor = </p><p class="source-code">      TypeT.GetConstructor(Type.EmptyTypes);</p><p class="source-code">if (ctor == null)</p><p class="source-code">    {</p><p class="source-code">throw new InvalidOperationException($"Type </p><p class="source-code">    {TypeT.Name} does not have a default</p><p class="source-code">        constructor.");</p><p class="source-code">}</p><p class="source-code">    _sqlConnection.Open();</p><p class="source-code">IEnumerator data = new SqlCommand(sql, _sqlConnection)</p><p class="source-code"> .ExecuteReader().GetEnumerator();    </p><p class="source-code">while (data.MoveNext())</p><p class="source-code">    {</p><p class="source-code">        T newInst = (T)ctor.Invoke(null);</p><p class="source-code">        DbDataRecord record = (DbDataRecord)</p><p class="source-code">                data.Current;</p><p class="source-code">        int fieldCount = Properties</p><p class="source-code">             .GetFieldCount((DbDataRecord)</p><p class="source-code">                data.Current);</p><p class="source-code">     for (int i = 0; i &lt; fieldCount; i++)</p><p class="source-code">        {</p><p class="source-code">            string propertyName = record.GetName(i);</p><p class="source-code">            PropertyInfo propertyInfo = TypeT</p><p class="source-code">                 .GetProperty(propertyName);</p><p class="source-code">             if (propertyInfo != null)</p><p class="source-code">            {</p><p class="source-code">                object value = record[i];</p><p class="source-code">                if (value == DBNull.Value)</p><p class="source-code">                    propertyInfo</p><p class="source-code">                         .SetValue(newInst, null);</p><p class="source-code">                 else</p><p class="source-code">                    propertyInfo</p><p class="source-code">                         .SetValue(newInst, value);</p><p class="source-code">         }</p><p class="source-code">     }</p><p class="source-code">        yield return newInst;</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes a SQL statement and executes it by calling the <strong class="source-inline">ExecuteReader</strong> method. Once the method has been executed, we obtain the <a id="_idIndexMarker1068"/>reader's enumerator. Then, we iterate through the enumerator and build up an object for the current iteration and yield the result.</p>
			<ol>
				<li value="7">Add the following reader method:<p class="source-code">internal IEnumerator&lt;T&gt; ExecuteReader&lt;T&gt;</p><p class="source-code">     (SqlCommandModel model) {</p><p class="source-code">Type TypeT = typeof(T);</p><p class="source-code">ConstructorInfo ctor </p><p class="source-code">         = TypeT.GetConstructor(Type.EmptyTypes);</p><p class="source-code">if (ctor == null) {</p><p class="source-code">throw new InvalidOperationException($"Type </p><p class="source-code">    {TypeT.Name} does not have a default</p><p class="source-code">         constructor.");</p><p class="source-code">}</p><p class="source-code">SqlCommand sqlCommand </p><p class="source-code">    = new(model.CommandText, _sqlConnection);</p><p class="source-code">sqlCommand.CommandType = model.CommandType;</p><p class="source-code">foreach (SqlCommandParameterModel parameter in </p><p class="source-code">    model.CommandParameters)</p><p class="source-code">sqlCommand.Parameters.Add(new SqlParameter() {</p><p class="source-code">ParameterName = parameter.ParameterName,</p><p class="source-code">DbType = parameter.DataType, Value = </p><p class="source-code">    parameter.Value});</p><p class="source-code">_sqlConnection.Open();</p><p class="source-code">SqlDataReader reader = sqlCommand.ExecuteReader();</p><p class="source-code">if (reader.HasRows) {</p><p class="source-code">while (reader.Read()) {</p><p class="source-code">T newInst = (T)ctor.Invoke(null);</p><p class="source-code">for (int i = 0; i &lt; reader.FieldCount; i++) {</p><p class="source-code">     string propertyName = reader.GetName(i);</p><p class="source-code">     PropertyInfo propertyInfo </p><p class="source-code">         = TypeT.GetProperty(propertyName);</p><p class="source-code">     if (propertyInfo != null) {</p><p class="source-code">         object value = reader[i];</p><p class="source-code">         if (value == DBNull.Value)</p><p class="source-code">               propertyInfo.SetValue(newInst, null);</p><p class="source-code">         else  </p><p class="source-code">               propertyInfo.SetValue(newInst, value);</p><p class="source-code">     }</p><p class="source-code">}        </p><p class="source-code">    yield return newInst;</p><p class="source-code">}</p><p class="source-code">}</p><p class="source-code">  _sqlConnection.Close();</p><p class="source-code">}</p></li>
			</ol>
			<p>This reader method takes a <strong class="source-inline">SqlCommandModel</strong> and builds up a <strong class="source-inline">SqlCommand</strong>. It executes the reader and obtains <strong class="source-inline">SqlDataReader</strong>. It iterates <a id="_idIndexMarker1069"/>through the reader and builds up an instance of the generic type that is then yielded to the user.</p>
			<p>That's our ADO.NET data access class completed. Now, let's learn how to write the Entity Framework data access class.</p>
			<h1 id="_idParaDest-196"><a id="_idTextAnchor201"/>Writing the EntityFrameworkCoreData class</h1>
			<p>In this section, we <a id="_idIndexMarker1070"/>will be writing the methods for our Entity Framework data access class. The code we will write in this section will be executed in the next chapter. Follow these steps:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">EntityFrameworkCoreData</strong> class and edit it as follows:<p class="source-code">using CH10_DataAccessBenchmarks.Models;</p><p class="source-code">using Microsoft.EntityFrameworkCore;</p><p class="source-code">using System.Collections.Generic;</p><p class="source-code">using Microsoft.Data.SqlClient;</p><p class="source-code">using System.Linq;</p><p class="source-code">using Microsoft.EntityFrameworkCore.SqlServer</p><p class="source-code">    .Infrastructure.Internal;</p><p class="source-code">public class EntityFrameworkCoreData : DbContext</p><p class="source-code">{</p><p class="source-code">    private string _connectionString = string.Empty;</p><p class="source-code">    public DbSet&lt;Product&gt; Products { get; set; }</p><p class="source-code">    public EntityFrameworkCoreData(string </p><p class="source-code">        connectionString) : base(GetOptions</p><p class="source-code">             (connectionString))</p><p class="source-code">    {</p><p class="source-code">        _connectionString = connectionString;</p><p class="source-code">    }</p><p class="source-code">    private static DbContextOptions GetOptions(string </p><p class="source-code">        connectionString)</p><p class="source-code">    {</p><p class="source-code">    return SqlServerDbContextOptionsExtensions</p><p class="source-code">        .UseSqlServer(new DbContextOptionsBuilder(), </p><p class="source-code">            connectionString).Options;</p><p class="source-code">    }</p></li>
			</ol>
			<p>Our class inherits from the <strong class="source-inline">DbContext</strong> class of the <strong class="source-inline">Microsoft.EntityFrameworkCore</strong> library. We declare a variable to hold our database connection string, and a variable to hold a collection of <strong class="source-inline">Products</strong>. In our constructor, we set the connection string and call the base constructor.</p>
			<ol>
				<li value="2">Add <a id="_idIndexMarker1071"/>the <strong class="source-inline">OnConfiguring</strong> method:<p class="source-code">protected override void OnConfiguring</p><p class="source-code">     (DbContextOptionsBuilder optionsBuilder)</p><p class="source-code">{     </p><p class="source-code">      optionsBuilder.UseSqlServer(_connectionString);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method determines that we will be using SQL Server and passes in the SQL Server connection string that we will be using.</p>
			<ol>
				<li value="3">Add the following method, which executes raw SQL:<p class="source-code">public int ExecuteSQL(string sql)</p><p class="source-code">    {</p><p class="source-code">        return Database.ExecuteSqlRaw(sql, null);</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes a SQL statement and executes it against the database as raw SQL. The returned value is the number of records affected by the execution of the statement.</p>
			<ol>
				<li value="4">Add the following method for executing a stored procedure as a non-query:<p class="source-code">public int ExecuteNonQuerySP(SqlCommandModel model)</p><p class="source-code">    {</p><p class="source-code">        SqlParameter[] parameters </p><p class="source-code">        = new SqlParameter[model.CommandParameters</p><p class="source-code">            .Length];</p><p class="source-code">        for (int i = 0; i &lt; parameters.Length; i++)</p><p class="source-code">        {</p><p class="source-code">            parameters[i] = new SqlParameter(</p><p class="source-code">            model.CommandParameters[i].ParameterName,</p><p class="source-code">             model.CommandParameters[i].Value</p><p class="source-code">             );</p><p class="source-code">     }</p><p class="source-code">        if (parameters.Length == 4)</p><p class="source-code">            return Database.ExecuteSqlRaw(</p><p class="source-code">             model.CommandText, parameters[0], </p><p class="source-code">             parameters[1], parameters[2], </p><p class="source-code">             parameters[3]</p><p class="source-code">         );</p><p class="source-code">     else if (parameters.Length == 2)</p><p class="source-code">         return Database.ExecuteSqlRaw(</p><p class="source-code">             model.CommandText, parameters[0], </p><p class="source-code">             parameters[1]</p><p class="source-code">         );</p><p class="source-code">     else</p><p class="source-code">         return Database.ExecuteSqlRaw(</p><p class="source-code">             model.CommandText, parameters[0]</p><p class="source-code">         );</p><p class="source-code">}</p></li>
			</ol>
			<p>In this method, we build up a <strong class="source-inline">SqlParameter</strong> array from our <strong class="source-inline">SqlCommandModel</strong>. Then, we execute raw SQL by passing in each of the parameters to the stored procedure. This execution is a non-query and returns the number of rows affected by running the procedure.</p>
			<ol>
				<li value="5">The following <a id="_idIndexMarker1072"/>method will execute and return a scalar value of the <strong class="source-inline">string</strong> type:<p class="source-code">public string ExecuteScalarSP(string productName)</p><p class="source-code">    {</p><p class="source-code">        return Products.FromSqlRaw(</p><p class="source-code">            "EXEC FilterProducts @ProductName={0}",</p><p class="source-code">            new SqlParameter() { </p><p class="source-code">        ParameterName = "@ProductName", Value = </p><p class="source-code">                productName })</p><p class="source-code">            .AsEnumerable().FirstOrDefault()</p><p class="source-code">              .ProductName;</p><p class="source-code">    }</p></li>
			</ol>
			<p>This method executes a stored procedure with a single parameter. We obtain the enumerable return object and filter it to get the first record. The name of the product is then returned as a string.</p>
			<ol>
				<li value="6">Add the final method to our class, which returns an enumerator:<p class="source-code">public IEnumerator&lt;Product&gt; ExecuteReaderSP(string </p><p class="source-code">    productName)</p><p class="source-code">{</p><p class="source-code">return Products.FromSqlRaw(</p><p class="source-code">        "EXEC FilterProducts @ProductName={0}", </p><p class="source-code">        new SqlParameter() { </p><p class="source-code">             ParameterName = "@ProductName", </p><p class="source-code">             Value = productName </p><p class="source-code">         }</p><p class="source-code">     ).GetEnumerator();</p><p class="source-code">}</p></li>
			</ol>
			<p>This executes a stored procedure with a single parameter and returns an enumerator full of filtered products.</p>
			<p>With that, we <a id="_idIndexMarker1073"/>have written all our Entity Framework classes. Now, it's time to write our Dapper.NET methods.</p>
			<h1 id="_idParaDest-197"><a id="_idTextAnchor202"/>Writing the DapperDotNet class</h1>
			<p>In this section, we'll <a id="_idIndexMarker1074"/>write our Dapper.NET methods. This is the last section before we write our benchmarking methods. We will run the code we write in this section in the next chapter. Follow these steps:</p>
			<ol>
				<li value="1">Open the <strong class="source-inline">DapperDotNet</strong> class, add the <strong class="source-inline">SimpleCRUD</strong> package, and modify it as follows:<p class="source-code">public class DapperDotNet : IDisposable</p><p class="source-code">{</p><p class="source-code">    private bool isDisposed = false;</p><p class="source-code">     private IDbConnection _dbConnection;</p><p class="source-code">     public DapperDotNet(string connection)</p><p class="source-code">    {</p><p class="source-code">     SimpleCRUD</p><p class="source-code">            .SetDialect(SimpleCRUD.Dialect.SQLServer);</p><p class="source-code">         _dbConnection = new SqlConnection</p><p class="source-code">             (connection);</p><p class="source-code">     }</p><p class="source-code">     public void Dispose()</p><p class="source-code">    {</p><p class="source-code">         Dispose(true);</p><p class="source-code">        GC.SuppressFinalize(this);</p><p class="source-code">     }</p><p class="source-code">     protected virtual void Dispose(bool disposing)</p><p class="source-code">    {</p><p class="source-code">        if (isDisposed)</p><p class="source-code">            return;</p><p class="source-code">         if (disposing)</p><p class="source-code">             _dbConnection.Dispose();</p><p class="source-code">         isDisposed = true;</p><p class="source-code">}</p><p class="source-code">}</p></li>
			</ol>
			<p>We implement the <strong class="source-inline">IDisposable</strong> pattern in this class and set the SQL dialect to the <a id="_idIndexMarker1075"/>SQL Server.</p>
			<ol>
				<li value="2">Add the following non-query method:<p class="source-code">    public int ExecuteNonQuery(string sql)</p><p class="source-code">    {</p><p class="source-code">        try</p><p class="source-code">        {</p><p class="source-code">            _dbConnection.Open();</p><p class="source-code">            return _dbConnection.Execute(sql);</p><p class="source-code">     }</p><p class="source-code">        finally</p><p class="source-code">        {</p><p class="source-code">            _dbConnection.Close();</p><p class="source-code">     }</p><p class="source-code">    }</p></li>
			</ol>
			<p>This method executes raw SQL and returns the number of records affected by the SQL statement.</p>
			<ol>
				<li value="3">Add <a id="_idIndexMarker1076"/>the following method to execute a non-query:<p class="source-code">public void ExecuteNonQuery(SqlCommandModel model)</p><p class="source-code">    {</p><p class="source-code">        try</p><p class="source-code">        {</p><p class="source-code">            _dbConnection.Open();</p><p class="source-code">         var parameters = new DynamicParameters();</p><p class="source-code">            foreach (</p><p class="source-code">             SqlCommandParameterModel parameter in  </p><p class="source-code">             model.CommandParameters</p><p class="source-code">         ) </p><p class="source-code">             parameters.Add(</p><p class="source-code">                 parameter.ParameterName, </p><p class="source-code">                 parameter.Value</p><p class="source-code">             );</p><p class="source-code">             _dbConnection.Query(</p><p class="source-code">             model.CommandText, </p><p class="source-code">             parameters, </p><p class="source-code">             commandType: CommandType.StoredProcedure</p><p class="source-code">         );</p><p class="source-code">        }</p><p class="source-code">        finally</p><p class="source-code">     {</p><p class="source-code">            _dbConnection.Close();</p><p class="source-code">        }</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes a <strong class="source-inline">SqlCommandModel</strong> instance and builds up a <strong class="source-inline">DynamicParameter</strong> bag. Then, it executes a stored procedure defined by the model's <strong class="source-inline">CommandText</strong>.</p>
			<ol>
				<li value="4">Add <a id="_idIndexMarker1077"/>the following generic scalar method:<p class="source-code">    public T ExecuteScalar&lt;T&gt;(string sql)</p><p class="source-code">    {</p><p class="source-code">        try</p><p class="source-code">        {</p><p class="source-code">            _dbConnection.Open();</p><p class="source-code">            return _dbConnection.ExecuteScalar</p><p class="source-code">                &lt;T&gt;(sql);</p><p class="source-code">     }</p><p class="source-code">        finally</p><p class="source-code">        {</p><p class="source-code">            if (_dbConnection != null </p><p class="source-code">             &amp;&amp; _dbConnection.State </p><p class="source-code">                 == ConnectionState.Open)</p><p class="source-code">             _dbConnection.Close();</p><p class="source-code">     }</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes a SQL statement and executes it, returning a single value of the required type.</p>
			<ol>
				<li value="5">Add the <a id="_idIndexMarker1078"/>following method, which executes a stored procedure and returns a string:<p class="source-code">public string ExecuteScalarSP(SqlCommandModel model)</p><p class="source-code">{</p><p class="source-code">        try</p><p class="source-code">        {</p><p class="source-code">            _dbConnection.Open();</p><p class="source-code">            var parameters = new DynamicParameters();</p><p class="source-code">                parameters.Add(</p><p class="source-code">                model.CommandParameters[0]</p><p class="source-code">                 .ParameterName,   </p><p class="source-code">             model.CommandParameters[0].Value</p><p class="source-code">         );</p><p class="source-code">            return _dbConnection.Query&lt;Product&gt;(</p><p class="source-code">             model.CommandText, </p><p class="source-code">             parameters, </p><p class="source-code">             commandType: CommandType.StoredProcedure</p><p class="source-code">         ).First().ProductName;</p><p class="source-code">     }</p><p class="source-code">        finally</p><p class="source-code">        {</p><p class="source-code">            if (</p><p class="source-code">             _dbConnection != null </p><p class="source-code">             &amp;&amp; _dbConnection.State </p><p class="source-code">                 == ConnectionState.Open)</p><p class="source-code">             _dbConnection.Close();</p><p class="source-code">     }</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes a <strong class="source-inline">SqlCommandModel</strong> instance and uses it to execute a stored <a id="_idIndexMarker1079"/>procedure. Remember to add the missing <strong class="source-inline">using</strong> statements for <strong class="source-inline">SqlCommandModel</strong> to the class. The stored procedure execution returns a type of <strong class="source-inline">IEnumerable&lt;Product&gt;</strong>. So, we obtain the first product in the list and return its <strong class="source-inline">ProductName</strong>.</p>
			<ol>
				<li value="6">Add the following method, which executes raw SQL and returns a type of <strong class="source-inline">IEnumerator&lt;T&gt;</strong>:<p class="source-code">public IEnumerator&lt;T&gt; ExecuteReader&lt;T&gt;(string sql) </p><p class="source-code">    where T : class</p><p class="source-code">{</p><p class="source-code">         try</p><p class="source-code">        {</p><p class="source-code">            _dbConnection.Open();</p><p class="source-code">            return _dbConnection.Query&lt;T&gt;(sql)</p><p class="source-code">             .GetEnumerator();</p><p class="source-code">    }</p><p class="source-code">        finally</p><p class="source-code">        {</p><p class="source-code">            if (_dbConnection != null </p><p class="source-code">             &amp;&amp; _dbConnection.State </p><p class="source-code">                 == ConnectionState.Open)</p><p class="source-code">             _dbConnection.Close();</p><p class="source-code">    }</p><p class="source-code">}</p></li>
			</ol>
			<p>This method executes a raw SQL string and returns a type of <strong class="source-inline">IEnumerable&lt;T&gt;</strong>.</p>
			<ol>
				<li value="7">Add the <a id="_idIndexMarker1080"/>following method, which executes a stored procedure and returns a type of <strong class="source-inline">IEnumerator&lt;Product&gt;</strong>:<p class="source-code">    public IEnumerator&lt;Product&gt; ExecuteReaderSP</p><p class="source-code">        &lt;Product&gt;(</p><p class="source-code">    SqlCommandModel model</p><p class="source-code">)</p><p class="source-code">    {</p><p class="source-code">        try</p><p class="source-code">        { </p><p class="source-code">            _dbConnection.Open();</p><p class="source-code">            var parameters = new DynamicParameters();</p><p class="source-code">            foreach (SqlCommandParameterModel </p><p class="source-code">                parameter in model.CommandParameters)</p><p class="source-code">             parameters.Add(</p><p class="source-code">                 parameter.ParameterName, </p><p class="source-code">                 parameter.Value</p><p class="source-code">             );</p><p class="source-code">         return _dbConnection.Query&lt;Product&gt;(</p><p class="source-code">             model.CommandText, </p><p class="source-code">             parameters, </p><p class="source-code">             commandType: CommandType.StoredProcedure</p><p class="source-code">         ).GetEnumerator();</p><p class="source-code">     }</p><p class="source-code">        finally</p><p class="source-code">        {</p><p class="source-code">            if (_dbConnection != null </p><p class="source-code">             &amp;&amp; _dbConnection.State </p><p class="source-code">             == ConnectionState.Open)</p><p class="source-code">         _dbConnection.Close();</p><p class="source-code">     }</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes a <strong class="source-inline">SqlCommandModel</strong> instance and builds up a parameterized <a id="_idIndexMarker1081"/>stored procedure that is executed. A type of <strong class="source-inline">IEnumerator&lt;Product&gt;</strong> is returned.</p>
			<ol>
				<li value="8">Add our final dapper method, which will obtain the first product name that matches the <strong class="source-inline">productName</strong> parameter:<p class="source-code">public string GetProductNameSP(string productName)</p><p class="source-code">    {</p><p class="source-code">        try</p><p class="source-code">        {</p><p class="source-code">            _dbConnection.Open();</p><p class="source-code">            var parameters = new DynamicParameters();</p><p class="source-code">            parameters.Add("@ProductName", </p><p class="source-code">                productName);</p><p class="source-code">            return _dbConnection.Query&lt;Product&gt;(</p><p class="source-code">             $"GetProductName", parameters, </p><p class="source-code">             commandType: CommandType.StoredProcedure</p><p class="source-code">             ).First().ProductName;</p><p class="source-code">     }</p><p class="source-code">        finally</p><p class="source-code">        {</p><p class="source-code">            if (_dbConnection != null </p><p class="source-code">             &amp;&amp; _dbConnection.State </p><p class="source-code">             == ConnectionState.Open)</p><p class="source-code">             _dbConnection.Close();</p><p class="source-code">        }</p><p class="source-code">}</p></li>
			</ol>
			<p>This method takes a product name and executes the <strong class="source-inline">GetProductName</strong> stored procedure. The stored procedure matches all the products in the database <a id="_idIndexMarker1082"/>whose product names are like the product name argument. Then, it gets the first product in the returned list and returns its product name.</p>
			<p>That concludes our database and data access project setup in preparation for the benchmarking work we will be doing in the next chapter. Let's review what we have accomplished in this chapter.</p>
			<h1 id="_idParaDest-198"><a id="_idTextAnchor203"/>Summary</h1>
			<p>In this chapter, we downloaded the <strong class="bold">Northwind</strong> SQL Server database script. Then, we added some stored procedures to insert, update, select, and delete data from the <strong class="source-inline">Products</strong> table.</p>
			<p>After making sure that we have our database in place with the required stored procedures, we started a .NET 6.0 console application. We added our model class and data access classes for performing data access operations in Entity Framework, Dapper, and ADO.NET.</p>
			<p>In the next chapter, we will be benchmarking the data access methods for each of these frameworks. In the <em class="italic">Further reading</em> section, you can further your knowledge of Entity Framework, Dapper, and ADO.NET using the links provided.</p>
			<h1 id="_idParaDest-199"><a id="_idTextAnchor204"/>Further reading</h1>
			<p>To learn more about the topics that were covered in this chapter, take a look at the following resources:</p>
			<ul>
				<li>Entity Framework Core: <a href="https://docs.microsoft.com/ef/core/&#13;">https://docs.microsoft.com/ef/core/</a></li>
				<li>Dapper: <a href="https://dapper-tutorial.net/dapper&#13;">https://dapper-tutorial.net/dapper</a></li>
				<li>ADO.NET: <a href="https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/">https://dotnettutorials.net/course/ado-net-tutorial-for-beginners-and-professionals/</a></li>
			</ul>
		</div>
	</body></html>