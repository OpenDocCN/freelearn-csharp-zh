- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Building an Appointment Booking App with Entity Framework and Relational DB
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Entity Framework和关系型数据库构建预约预订应用
- en: In the previous chapter, we outlined the technical specifications and design
    decisions for building an appointment booking system for a barber’s salon called
    Heads Up Barbers. This chapter is a continuation of [*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209),
    *Designing an Appointment Booking App*, so I strongly advise you to be familiar
    with what was covered in that chapter first.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一章中，我们概述了为名为Heads Up Barbers的理发店构建预约预订系统的技术规范和设计决策。本章是[*第8章*](B18370_08_RN.xhtml#_idTextAnchor209)，*设计预约预订应用*的延续，因此我强烈建议您首先熟悉那章的内容。
- en: This chapter will implement the requirements in TDD style and will use **Entity
    Framework** (**EF**) and SQL Server. The implementation will be applicable to
    other **Relational Database Management Systems** (**RDBMSs**) such as Oracle DB,
    MySQL, PostgreSQL, and others.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将采用TDD风格实现需求，并使用**Entity Framework**（**EF**）和SQL Server。实现将适用于其他**关系型数据库管理系统**（**RDBMSs**）如Oracle
    DB、MySQL、PostgreSQL等。
- en: If you are a fan of relational DBs or you are using one at work, then this chapter
    is for you, whereas if you are using a document database, then you might want
    to skip this chapter and go to the next one. Both chapters, [*Chapter 9*](B18370_09.xhtml#_idTextAnchor226)
    and [*Chapter 10*](B18370_10.xhtml#_idTextAnchor245), have the same outcome, but
    they use different types of backend databases.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您是关系型数据库的粉丝或者在您的工作中使用关系型数据库，那么这一章就是为您准备的，而如果您使用的是文档数据库，那么您可能想要跳过这一章，直接进入下一章。第9章[*Chapter
    9*](B18370_09.xhtml#_idTextAnchor226)和第10章[*Chapter 10*](B18370_10.xhtml#_idTextAnchor245)都有相同的成果，但它们使用不同类型的后端数据库。
- en: I assume you are familiar with EF and how it is wired and used. However, if
    you are not, then I encourage you to familiarize yourself with it first.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 我假设您熟悉EF以及它的配置和使用。然而，如果您不熟悉，我鼓励您首先熟悉它。
- en: 'In this chapter, we will cover:'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Planning the code and the project structure
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 规划代码和项目结构
- en: Implementing the WebApis with TDD
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用TDD实现WebApis
- en: Answering frequently asked questions
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 回答常见问题
- en: By the end of the chapter, you will have experienced the implementation of an
    end-to-end app using TDD with mocks and fakes. Also, you will witness the analysis
    process that precedes writing unit tests.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将体验使用模拟和伪造进行TDD的端到端应用程序的实现。同时，您还将见证编写单元测试之前的分析过程。
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'The code for this chapter can be found in the following GitHub repository:'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码可以在以下GitHub仓库中找到：
- en: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch09](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch09)'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch09](https://github.com/PacktPublishing/Pragmatic-Test-Driven-Development-in-C-Sharp-and-.NET/tree/main/ch09)'
- en: To run the project, you will need to have a flavor of SQL Server installed.
    This can be, Azure SQL, SQL Server Express LocalDB or any other SQL Server flavor.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目，您需要安装SQL Server的一个版本。这可以是Azure SQL、SQL Server Express LocalDB或任何其他SQL
    Server版本。
- en: 'The implementation doesn’t use any advanced SQL Server features, so feel free
    to use any. I have tested the application with SQL Server Express LocalDB. You
    can find more about it here:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 实现过程中没有使用任何高级SQL Server功能，因此您可以自由使用任何功能。我已经使用SQL Server Express LocalDB测试了应用程序。您可以在以下链接中了解更多信息：
- en: '[https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb)'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb](https://docs.microsoft.com/en-us/sql/database-engine/configure-windows/sql-server-express-localdb)'
- en: You can also use any other RDBMS, but you will have to change the DB provider
    in the code to use the specific .NET DB provider.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 您也可以使用任何其他RDBMS，但您需要在代码中将数据库提供者更改为使用特定的.NET数据库提供者。
- en: 'To run the project, you have to modify the connection string to your specific
    DB instance in `Uqs.AppointmentBooking.WebApi/AppSettings.json`. Currently, it
    is set to:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 要运行项目，您必须修改`Uqs.AppointmentBooking.WebApi/AppSettings.json`中的连接字符串以指向您的特定数据库实例。目前，它设置为：
- en: '[PRE0]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The connection string is pointing to `LocalMachine` and will connect to a database
    called `AppointmentBooking`.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 连接字符串指向`LocalMachine`，并将连接到名为`AppointmentBooking`的数据库。
- en: 'If you decided to use an alternative RDBMS, then you will have to install the
    relevant NuGet packages in `Uqs.AppointmentBooking.WebApi` and change the following
    code in `Program.cs` of the same project to your specific RDBMS:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你决定使用替代的关系型数据库管理系统（RDBMS），那么你将不得不在`Uqs.AppointmentBooking.WebApi`中安装相关的NuGet包，并将同一项目中`Program.cs`的以下代码更改为你的特定RDBMS：
- en: '[PRE1]'
  id: totrans-22
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The previous DB configuration steps are optional. You can implement the requirements
    for this chapter without using a DB, but you won’t be able to run the project
    and interact with it in the browser.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的数据库配置步骤是可选的。你可以不使用数据库来实现本章的要求，但你将无法运行项目并在浏览器中与之交互。
- en: Planning your code and project structure
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 规划代码和项目结构
- en: In [*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209), *Designing an Appointment
    Booking App*, we planned our domain and analyzed what we needed to do. The project
    architecture will follow the classical three-tier applications of the client application
    (the website), business logic (the web APIs), and database (SQL Server). Let’s
    translate this into VS solutions and projects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 在[*第8章*](B18370_08_RN.xhtml#_idTextAnchor209)“设计预约预订应用”中，我们规划了领域并分析了我们需要做什么。项目架构将遵循客户端应用（网站）、业务逻辑（Web
    API）和数据库（SQL Server）的经典三层应用。让我们将其转换为VS解决方案和项目。
- en: In this section, we will create the solution, create the projects, and wire
    up the components.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将创建解决方案，创建项目，并连接组件。
- en: Analyzing the project’s structure
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 分析项目结构
- en: Ask a group of senior developers to come up with a project structure, and you
    will end up with multiple structures! In this section, we will discuss a way of
    organizing your project structure that I have developed over the years.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让一组资深开发者提出一个项目结构，你最终会得到多个结构！在本节中，我们将讨论一种我多年来开发的项目结构组织方法。
- en: Given that we are first going to build a website for the user and later a mobile
    app (not covered in this book), it makes sense to isolate the business logic to
    a WebApi project that can be shared by both the website and the mobile app. So,
    we will build a website project based on Blazor WebAssembly called `Uqs.AppointmentBooking.Website`.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们首先将构建一个面向用户的网站，然后是一个移动应用（本书未涵盖），因此将业务逻辑隔离到一个可以被网站和移动应用共享的WebApi项目中是有意义的。因此，我们将基于Blazor
    WebAssembly构建一个名为`Uqs.AppointmentBooking.Website`的网站项目。
- en: The domain logic will be exposed as APIs, so we will create an ASP.NET API project
    for the APIs called `Uqs.AppointmentBooking.WebApi`.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 领域逻辑将以API的形式公开，因此我们将创建一个名为`Uqs.AppointmentBooking.WebApi`的ASP.NET API项目用于API。
- en: The previous two projects need to exchange data in an agreed structure called
    `Uqs.AppointmentBooking.Contracts`. This project will be referenced by both the
    website and the WebApi projects.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个项目需要在一个称为`Uqs.AppointmentBooking.Contracts`的约定结构中交换数据。此项目将由网站和WebApi项目引用。
- en: The WebApi project translates web requests into something we can understand
    in C#. In technical terms, this will manage the HTTP communication layer with
    RESTful-style APIs. So, the WebApi project will not contain business logic. The
    business logic will be in our domain project. We will create a domain project
    called `Uqs.AppointmentBooking.Domain`.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: WebApi项目将网络请求转换为我们可以用C#理解的内容。从技术角度来说，这将管理基于RESTful风格的API的HTTP通信层。因此，WebApi项目将不包含业务逻辑。业务逻辑将位于我们的领域项目中。我们将创建一个名为`Uqs.AppointmentBooking.Domain`的领域项目。
- en: Your business logic will live in two places – the UI and the domain layer. The
    UI business logic will manage UI functionalities such as toggling dropdowns, blocking
    calendar days, responding to drag and drop, and disabling/enabling buttons, among
    others. This logic will live in the website project. The language used in writing
    the code depends on the UI framework in use, such as Angular, React, and Blazor.
    Usually, you do not implement the features of the UI project using TDD, but you
    can use unit tests. In our implementation, we will have little code in the UI
    layer, so we will not be doing any UI unit tests.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你的业务逻辑将存在于两个地方——UI和领域层。UI业务逻辑将管理UI功能，如切换下拉菜单、锁定日历日、响应拖放操作以及启用/禁用按钮等。这种逻辑将存在于网站项目中。编写代码使用的语言取决于所使用的UI框架，例如Angular、React和Blazor。通常，你不会使用TDD来实现UI项目的功能，但你可以使用单元测试。在我们的实现中，UI层将包含少量代码，因此我们不会进行任何UI单元测试。
- en: The sophisticated business logic will live in the domain layer, and we will
    be writing it following the concepts of TDD. So, we shall create a project that
    will hold our domain unit tests and call it `Uqs.AppointmentBooking.Domain.Tests.Unit`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 复杂的业务逻辑将存在于域层，我们将遵循 TDD 的概念来编写它。因此，我们将创建一个项目来保存我们的域单元测试，并将其命名为 `Uqs.AppointmentBooking.Domain.Tests.Unit`。
- en: 'To put these projects into perspective and map them to our 3-tier architecture,
    we can have the following diagram:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将这些项目置于正确的视角并将它们映射到我们的三层架构，我们可以有以下图示：
- en: '![Figure 9.1 – The relationship between the projects and the application design
    ](img/Figure_9.1_B18370.jpg)'
  id: totrans-36
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.1 – 项目与应用设计之间的关系](img/Figure_9.1_B18370.jpg)'
- en: Figure 9.1 – The relationship between the projects and the application design
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.1 – 项目与应用设计之间的关系
- en: The previous diagram shows the functionality that each project provides to form
    the 3-tier application. Let’s start by creating the VS solution structure.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图示显示了每个项目提供的功能，以形成三层应用程序。让我们首先创建 VS 解决方案结构。
- en: Creating projects and configuring dependencies
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建项目和配置依赖关系
- en: This is the unavoidable boring part, creating the solution and projects and
    linking them together. In the following section, we will take the command-line
    approach rather than the UI approach.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这是不可避免的枯燥部分，创建解决方案和项目并将它们链接在一起。在下一节中，我们将采用命令行方法而不是 UI 方法。
- en: Note
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I have added a text file called `create-projects.bat` to the project source
    control that contains all the command lines, so you don’t have to manually write
    them. You can copy and paste this file to your desired directory and then, from
    your command line, execute the file.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经将一个名为 `create-projects.bat` 的文本文件添加到项目源代码控制中，其中包含所有命令行，因此您不必手动编写它们。您可以将此文件复制并粘贴到您想要的目录中，然后从您的命令行执行该文件。
- en: 'The following is a list of the commands required to create your VS solution
    and its projects:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是需要创建您的 VS 解决方案及其项目的命令列表：
- en: 'From your OS console, navigate to the directory where you want to create your
    new solution and execute the following to create the solution file:'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从您的操作系统控制台导航到您想要创建新解决方案的目录，并执行以下命令以创建解决方案文件：
- en: '[PRE2]'
  id: totrans-45
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Execute this to create the projects and notice that we are using a different
    template for each project:'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 执行此操作以创建项目，并注意我们为每个项目使用不同的模板：
- en: '[PRE3]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Add the projects to the solution:'
  id: totrans-48
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将项目添加到解决方案中：
- en: '[PRE4]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now let’s set up dependencies between the projects:'
  id: totrans-50
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 现在，让我们设置项目之间的依赖关系：
- en: '[PRE5]'
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And the last bit is adding the required NuGet packages to the project. The
    domain project will communicate with the SQL Server database using EF. The `Microsoft.EntityFrameworkCore.SqlServer`
    package allows the required libraries to connect the project to SQL Server. To
    add this library to the `Domain` project, use the following:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一点是向项目添加所需的 NuGet 包。域项目将使用 EF 与 SQL Server 数据库通信。`Microsoft.EntityFrameworkCore.SqlServer`
    包允许所需的库连接到 SQL Server。要将此库添加到 `Domain` 项目中，请使用以下命令：
- en: '[PRE6]'
  id: totrans-53
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The unit testing project will require *NSubstitute* for mocking, so let’s add
    its NuGet:'
  id: totrans-54
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单元测试项目将需要 *NSubstitute* 进行模拟，因此让我们添加其 NuGet：
- en: '[PRE7]'
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'We will be using a fake to test double EF. This fake will create an in-memory
    database that will make our testing easier to write. We will discuss this in more
    detail later in this chapter, but for now, let’s add this fake library:'
  id: totrans-56
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们将使用模拟来测试 EF 的双倍。这个模拟将创建一个内存数据库，这将使我们的测试编写更容易。我们将在本章后面详细讨论这个问题，但现在，让我们添加这个模拟库：
- en: '[PRE8]'
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'For visual inspection, you can open the solution file with VS, and it should
    look as such:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 为了视觉检查，您可以使用 VS 打开解决方案文件，它应该看起来像这样：
- en: '![Figure 9.2 – A view of VS solution explorer ](img/Figure_9.2_B18370.jpg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.2 – VS 解决方案资源管理器视图](img/Figure_9.2_B18370.jpg)'
- en: Figure 9.2 – A view of VS solution explorer
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.2 – VS 解决方案资源管理器视图
- en: At this stage, your solution structure should look similar.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，您的解决方案结构应该看起来类似。
- en: Now that the project structure is in place, we will modify the code.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在项目结构已经就绪，我们将修改代码。
- en: Setting up the domain project
  id: totrans-63
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置域项目
- en: 'From the domain analysis in [*Chapter 8*](B18370_08_RN.xhtml#_idTextAnchor209),
    *Designing an Appointment Booking App*, we have created a list of the domain objects.
    I will not go through them again; I will just create and add them to the `Domain`
    project under `DomainObjects`:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 从 [*第 8 章*](B18370_08_RN.xhtml#_idTextAnchor209) 的域分析，*设计预约应用程序*，我们已经创建了一个域对象的列表。我将不会再次过目它们；我将在
    `Domain` 项目下的 `DomainObjects` 中创建并添加它们：
- en: '![Figure 9.3 – Added domain objects ](img/Figure_9.3_B18370.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3 – 添加了领域对象](img/Figure_9.3_B18370.jpg)'
- en: Figure 9.3 – Added domain objects
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3 – 添加了领域对象
- en: 'These are just data structures with no business logic. Here is the source code
    of one of them, the `Customer` domain object:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这些只是没有业务逻辑的数据结构。以下是其中之一，`Customer`领域对象的源代码：
- en: '[PRE9]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: You can view the rest of the files in the chapter’s GitHub repo online.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在线查看本章GitHub仓库中的其余文件。
- en: Next is wiring up the focus of this chapter, EF.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是连接本章的重点，EF。
- en: Wiring up Entity Framework
  id: totrans-71
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 连接Entity Framework
- en: We are going to use EF to store each domain object in a database table that
    bears the same name but in the plural, as this is the default behavior of EF.
    So, the `Customer` domain object will have a *Customers* table equivalent in the
    DB.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用EF将每个领域对象存储在具有相同名称但复数的数据库表中，这是EF的默认行为。因此，`Customer`领域对象在数据库中将有一个对应的`Customers`表。
- en: We will not be customizing much in EF as our intention in this chapter is to
    focus on TDD, as doing the little setups here and there are only chores and you
    can find them in the companion code.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们不会在EF中进行太多自定义，因为我们的目的是专注于TDD，在这里做的小设置只是琐事，你可以在配套代码中找到它们。
- en: 'Under the `Domain` project, I have added a directory called `Database` to contain
    our EF-related classes. We will need two classes, the `ApplicationContext` class
    and the `SeedData` class:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Domain`项目中，我添加了一个名为`Database`的目录来包含我们的EF相关类。我们需要两个类，`ApplicationContext`类和`SeedData`类：
- en: '![Figure 9.4 – Added EF files ](img/Figure_9.4_B18370.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图9.4 – 添加了EF文件](img/Figure_9.4_B18370.jpg)'
- en: Figure 9.4 – Added EF files
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.4 – 添加了EF文件
- en: In the next section, we will discuss their role.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将讨论它们的作用。
- en: Adding the context class
  id: totrans-78
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加上下文类
- en: 'With EF, you add a context class to reference all your domain objects. I called
    my context class `ApplicationContext`, and I followed basic EF practices. Here
    is my class:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 使用EF，您添加一个上下文类来引用所有领域对象。我把我上下文类命名为`ApplicationContext`，并遵循基本的EF实践。以下是我的类：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This is the most basic setup of EF with no customization, with every property
    mapped to a database table name.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这是EF的最基本设置，没有任何自定义，每个属性都映射到数据库表名。
- en: From this point onward, we will use `ApplicationContext` to execute operations
    on the DB.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，我们将使用`ApplicationContext`来执行对数据库的操作。
- en: Let’s continue with our process and set up EF within WebApi.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们继续我们的过程，在WebApi中设置EF。
- en: Wiring up EF with the WebApi project
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 将EF与WebApi项目连接起来
- en: The WebApi will wire EF to the right DB provider, which, in this case, is SQL
    Server, and will pass the connection string to EF at runtime.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: WebApi将EF连接到正确的数据库提供程序，在这种情况下是SQL Server，并在运行时将连接字符串传递给EF。
- en: 'So, the first step is to add the connection string to the WebApi’s `AppSettings.js`:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，第一步是将连接字符串添加到WebApi的`AppSettings.js`中：
- en: '[PRE11]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Obviously, the connection string may vary based on your DB location and setup.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，连接字符串可能根据您的数据库位置和配置而有所不同。
- en: Note
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this chapter, I am not concerned with setting multiple environments, but
    you may want to create multiple `AppSettings` for different environments and change
    the connection string accordingly.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我并不关心设置多个环境，但您可能希望为不同的环境创建多个`AppSettings`，并相应地更改连接字符串。
- en: 'The next step is to wire up the WebApi with EF and provide it with the connection
    string. This should be done in `Program.cs`, preferably directly after the first
    line, `var CreateBuilder(args)`:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是将WebApi与EF连接起来，并为其提供连接字符串。这应该在`Program.cs`中完成，最好是在第一行`var CreateBuilder(args)`之后：
- en: '[PRE12]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: This is what we need for wiring up EF. However, for development purposes, we
    might need some test data to fill the pages with some meaningful data. We shall
    do this next.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这是我们连接EF所需的内容。然而，出于开发目的，我们可能需要一些测试数据来填充页面，使其包含一些有意义的数据。我们将在下一步做这件事。
- en: Adding seed data
  id: totrans-94
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 添加种子数据
- en: Newly created DBs have empty tables, and the `seed` class is meant to pre-populate
    the tables with sample data.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 新创建的数据库具有空表，`seed`类旨在用示例数据预先填充表。
- en: I will not list the code here as it is outside the scope of the chapter, but
    you can look at the code in the `Domain` project in `Database/SeedData.cs`.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 我不会在这里列出代码，因为这不属于本章的范围，但您可以在`Domain`项目的`Database/SeedData.cs`中查看代码。
- en: We’ve just finished the setup for the WebApi project, which is going to be consumed
    by the website, so let’s create the website next.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 我们刚刚完成了WebApi项目的设置，该项目将被网站使用，所以让我们接下来创建网站。
- en: Setting up the website project
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 设置网站项目
- en: Phase one of this implementation includes creating a website to access the APIs
    to provide a UI for the user, which we did previously in this chapter by command
    line. However, website implementation is outside the scope of this chapter and
    the book in general, as it is not related to TDD, so I will not be going through
    the code.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 本实施的第一阶段包括创建一个网站来访问API，为用户提供UI，这是我们在这章之前通过命令行完成的。然而，网站实现超出了本章的范围，也超出了本书的范围，因为它与TDD无关，所以我不打算展示代码。
- en: Though, we are interested in one aspect – what does the website require from
    the web apis? We will need to understand this in order to build the required functionality
    in `WebApis` the TDD way.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然，我们只对一个方面感兴趣——网站对Web APIs有什么要求？我们需要理解这一点，以便以TDD的方式在`WebApis`中构建所需的功能。
- en: We will answer this question bit by bit in the next section of this chapter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在本章下一节逐步回答这个问题。
- en: In this section, we covered the setup and configuration aspect of the project,
    and we have not done anything that is affected by TDD. You may have noticed that
    I referred you to the companion source code on multiple occasions; otherwise,
    we would have no place left for the core of this chapter, the TDD part, which
    we will do next.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们涵盖了项目的设置和配置方面，我们没有做任何受TDD影响的事情。你可能已经注意到，我多次提到了配套源代码；否则，我们就没有地方放置本章的核心，即TDD部分，我们将在下一部分进行。
- en: Implementing the WebApis with TDD
  id: totrans-103
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 以TDD方式实现WebApis
- en: To build the WebApi project, we are going to look at each requirement from [*Chapter
    8*](B18370_08_RN.xhtml#_idTextAnchor209), *Designing an Appointment Booking App*,
    and provide the implementation that satisfies it using TDD style.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 要构建WebApi项目，我们将查看[第8章](B18370_08_RN.xhtml#_idTextAnchor209)中提到的每个要求，*设计一个预约预订应用*，并使用TDD风格提供满足这些要求的实现。
- en: The requirements are all stated in terms of the Website and its functionality,
    and they do not dictate how to build our APIs. The Website will have to call the
    WebApis for any business logic as it has no access to the DB and deals with UI-related
    business logic only.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的要求都是以网站及其功能为依据提出的，并且它们并没有规定我们如何构建我们的API。网站将不得不调用WebApis来执行任何业务逻辑，因为它无法访问数据库，并且只处理与UI相关的业务逻辑。
- en: This chapter is dedicated to EF for a good reason as we want you to appreciate
    *fakes*, which are not as popular as *mocks*, both from the test doubles family.
    Also, it will be a typical example of a .NET solution of an ASP.NET Core and a
    relational DB implementation.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 本章专门介绍EF，原因是我们希望你们欣赏*模拟*，它不像*模拟*那样受欢迎，它们都属于测试替身家族。它还将是一个典型的.NET解决方案示例，包括ASP.NET
    Core和关系型数据库实现。
- en: In this section, we will cover working in TDD mode, taking into consideration
    our persistence provider, EF.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 本节中，我们将涵盖在TDD模式下工作，同时考虑到我们的持久化提供者EF。
- en: Using the EF in-memory provider
  id: totrans-108
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用EF内存提供者
- en: To make our life easier when unit testing the system, we want to abstract the
    database in an elegant way. When I say elegant, I mean less code and more readability.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们在单元测试系统时生活更轻松，我们希望以优雅的方式抽象数据库。当我说优雅时，我的意思是代码更少，可读性更高。
- en: However, the challenge we face when testing a system that has a DB is that we
    do not want to hit the real DB in our unit tests as this would defeat the whole
    purpose of unit testing and make it a sort of integration or Sintegration testing.
    Instead, we use test doubles to abstract it. A fake is a test double that replaces
    a component during unit testing with an equivalent component more suitable for
    testing purposes, we will be employing a fake to replace our DB for unit testing
    purposes.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，当我们测试一个具有数据库的系统时，我们面临的挑战是我们不希望在单元测试中击中真实的数据库，因为这会违背单元测试的全部目的，使其成为一种集成或S集成测试。相反，我们使用测试替身来抽象它。模拟是一个测试替身，它在单元测试期间用一个更适合测试目的的等效组件替换组件，我们将使用模拟来替换我们的数据库进行单元测试。
- en: EF has a provider that accesses SQL server, which is what we want to use in
    production during the system run, but in unit testing, we can’t do this. Lucky
    for us, EF has what is called an in-memory provider, which can build and destroy
    an in-memory database during each unit test run.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: EF有一个提供者可以访问SQL服务器，这是我们希望在系统运行期间在生产中使用的东西，但在单元测试中，我们无法这样做。幸运的是，EF有一个称为内存提供者的东西，它可以在每次单元测试运行期间构建和销毁内存数据库。
- en: Building and destroying an in-memory DB during unit testing is cheap compared
    to doing the same for a physical DB, not to mention the cost and the possibility
    of random errors that are generated from trying to create and delete a real database
    so often (with each single unit test execution). As you might have already figured
    out, the EF in-memory provider acts as a fake.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在单元测试期间构建和销毁内存数据库的成本与对物理数据库进行相同操作的成本相比非常低，更不用说尝试频繁创建和删除真实数据库的成本和随机错误的可能性了（每个单元测试执行一次）。正如你可能已经猜到的，EF内存提供程序充当了一个模拟。
- en: 'During runtime, we use the SQL Server provider, and during unit testing, we
    use the in-memory provider, and we accomplish this switch via dependency injection:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 在运行时，我们使用SQL Server提供程序，而在单元测试时，我们使用内存提供程序，我们通过依赖注入来实现这种切换：
- en: '![Figure 9.5 – Runtime and test times with respect to EF providers ](img/Figure_9.5_B18370.jpg)'
  id: totrans-114
  prefs: []
  type: TYPE_IMG
  zh: '![图9.5 – 与EF提供程序相关的运行时间和测试时间](img/Figure_9.5_B18370.jpg)'
- en: Figure 9.5 – Runtime and test times with respect to EF providers
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.5 – 与EF提供程序相关的运行时间和测试时间
- en: The previous diagram illustrates injecting different providers in different
    project stages. The unit testing stage will use the EF in-memory provider and
    in the production run stage, the proper production provider, EF SQL Server Provider,
    will be used.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的图示说明了在不同项目阶段注入不同的提供程序。单元测试阶段将使用EF内存提供程序，而在生产运行阶段，将使用适当的实际生产提供程序，即EF SQL Server提供程序。
- en: Configuring the in-memory provider
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 配置内存提供程序
- en: 'To get the advantage of the in-memory provider, I have created a file in the
    unit tests project called `ApplicationContextFake.cs`, and here is the code:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 为了利用内存提供程序的优势，我在单元测试项目中创建了一个名为`ApplicationContextFake.cs`的文件，以下是代码：
- en: '[PRE13]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Note that we are inheriting the main EF object, `ApplicationContext`, and we
    configured the option to make it in-memory. `ApplicationContextFake` is meant
    to be injected whenever `ApplicationContext` is required in our unit tests.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们正在继承主要的EF对象`ApplicationContext`，并配置了使其成为内存选项。`ApplicationContextFake`旨在在需要`ApplicationContext`时注入到我们的单元测试中。
- en: We are creating a unique database name, `AppointmentBookingTest-{Guid.NewGuid()}`,
    by appending a GUID every time we instantiate the fake. The reason for this is
    that we don’t want the in-memory provider to have the same database name to avoid
    caching any data in between unit test calls.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过每次实例化模拟时附加一个GUID来创建一个唯一的数据库名称，`AppointmentBookingTest-{Guid.NewGuid()}`。这样做的原因是我们不希望内存提供程序具有相同的数据库名称，以避免在单元测试调用之间缓存任何数据。
- en: From this point onward, every time we need to inject `ApplicationContext` in
    our unit tests, we will inject `ApplicationContextFake` instead.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 从现在开始，每次我们需要在我们的单元测试中注入`ApplicationContext`时，我们将注入`ApplicationContextFake`。
- en: Adding sample test data using the builder pattern
  id: totrans-123
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用构建器模式添加样本测试数据
- en: Every test that we are going to implement will have a state. For example, we
    might have a single free barber or a group of barbers with different schedules,
    so creating sample data for each test might be a mess if we are not careful. There
    is a clever way to organize our sample data for testing.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要实现的每个测试都将有一个状态。例如，我们可能有一个单独的空闲理发师或一组具有不同日程的理发师，如果我们不小心，为每个测试创建样本数据可能会变得混乱。有一种巧妙的方式来组织我们的测试样本数据。
- en: 'We can do this in a pattern called the builder pattern (not to be confused
    with the GoF Builder design pattern). The builder pattern will allow us to *mix
    and match* sample data in a clean and readable way. I have added a file called
    `ApplicationContextFakeBuilder.cs` to contain the sample state data with the builder
    pattern. I have included a part of this class here for brevity but you can see
    the full class in the companion source code:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过一种称为构建器模式的模式来完成这项工作（不要与GoF构建器设计模式混淆）。构建器模式将允许我们以干净和可读的方式混合和匹配样本数据。我已经添加了一个名为`ApplicationContextFakeBuilder.cs`的文件来包含使用构建器模式的样本状态数据。为了简洁起见，我在这里包含了这个类的一部分，但你可以通过配套源代码查看完整的类：
- en: '[PRE14]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'This class will prepare in-memory sample data. The unit tests that will use
    this class will call different methods on it to set the right data state. What
    is interesting in this class is the following:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类将准备内存样本数据。将使用这个类的单元测试将调用它的不同方法来设置正确的数据状态。这个类中有趣的是以下内容：
- en: Using the `With` convention to indicate that we are adding sample data. You
    will see examples of how the `With` methods are used later on.
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用`With`约定来表示我们正在添加样本数据。你将在后面看到`With`方法的使用示例。
- en: 'The `With` methods return `this`, which at first instance looks weird. The
    idea here is to implement a coding convention called chaining so that you can
    write code like this: `_ctxBldr.WithSingleService(30).WithSingleEmpTom()`.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`With`方法返回`this`，乍一看可能有点奇怪。这里的想法是实现一种称为链式编写的编码约定，这样您就可以编写如下代码：`_ctxBldr.WithSingleService(30).WithSingleEmpTom()`。'
- en: The `Build()` method will save everything to the persisting media (the memory,
    in this case) and return the context.
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`Build()`方法将把一切保存到持久化媒体（在这种情况下是内存）并返回上下文。'
- en: The Builder pattern is heavily used when trying to set the state of a certain
    component. Feel free to look at the companion code for the full code. [*Chapter
    6*](B18370_06.xhtml#_idTextAnchor140), *The FIRSTHAND Guidelines of TDD*, has
    another example of a build class; you might want to have a look at it to strengthen
    your understanding.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 构建者模式在尝试设置某个组件的状态时被大量使用。您可以自由地查看配套代码以获取完整代码。[*第6章*](B18370_06.xhtml#_idTextAnchor140)，《TDD的FIRSTHAND指南》中有一个构建类的示例；您可能想看看它以加深您的理解。
- en: Implementing the first story
  id: totrans-132
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现第一个故事
- en: 'The first story in our requirement is very easy. The website is going to display
    all the available services that we have. Since the website will request this data
    from the WebApi through a RESTful API call, the domain layer will have a service
    that will return this list. Let’s assume this would be the UI output:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需求中的第一个故事非常简单。网站将显示我们拥有的所有可用服务。由于网站将通过RESTful API调用从WebApi请求这些数据，因此领域层将有一个返回此列表的服务。让我们假设这将是我们UI的输出：
- en: '![Figure 9.6 – A UI of the requirements of Story 1 ](img/Figure_9.6_B18370.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图9.6 – 故事1需求的一个UI](img/Figure_9.6_B18370.jpg)'
- en: Figure 9.6 – A UI of the requirements of Story 1
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.6 – 故事1需求的一个UI
- en: 'The UI layer, hosted in the browser, will need to issue a RESTful call to the
    WebApi, which can look as follows:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: UI层，托管在浏览器中，将需要向WebApi发出RESTful调用，这可能看起来如下：
- en: '[PRE15]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This UI will require a few data properties that should be returned by this
    API. So, the fetched JSON can look like an array of this:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这个UI将需要一些数据属性，这些属性应由这个API返回。因此，获取的JSON可以看起来像这样一个数组：
- en: '[PRE16]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'You can see where each part is used on the page, but maybe `ServiceId` is not
    very clear. It will be used to construct the URL of the `select` hyperlink. So,
    we can now design the contract type that will render this JSON, which could look
    like this:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以看到每个部分在页面上的使用位置，但也许`ServiceId`不是很清楚。它将被用来构造`select`超链接的URL。因此，我们现在可以设计一个合约类型来渲染这个JSON，它可能看起来像这样：
- en: '[PRE17]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'This `record` contract will render the previous JSON code. And the full returned
    array contract could look like this:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`record`合约将渲染之前的JSON代码。完整的返回数组合约可能看起来像这样：
- en: '[PRE18]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: You can find these contract types and all the other contracts in the `Contract`
    project.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在页面上找到这些合约类型和所有其他合约，在`Contract`项目中。
- en: Adding the first unit test via TDD
  id: totrans-145
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过TDD添加第一个单元测试
- en: 'Thinking along the lines of DDD, we will have a domain service called `ServicesService`,
    which will handle retrieving all the available services. So, let’s look at the
    structure of this service. We will create it in the `Domain` project under `Services`.
    Here is the code:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 沿着DDD的思路，我们将有一个名为`ServicesService`的领域服务，它将处理检索所有可用服务。因此，让我们看看这个服务的结构。我们将在`Domain`项目下的`Services`中创建它。以下是代码：
- en: '[PRE19]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: There is nothing special here. I have just helped VS understand that when I
    type `ServicesService`, it should guide me to this class.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这里没有什么特别之处。我只是帮助VS理解，当我输入`ServicesService`时，它应该引导我到这个类。
- en: Note
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I have added the previous `ServicesService` class manually. Some TDD practitioners
    like to code-generate this file while they are writing their unit test rather
    than writing it first. Any method is fine as long as you are more productive.
    I chose to create the file first because sometimes VS creates this file in a different
    directory from where I intend it to.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 我已经手动添加了之前的`ServicesService`类。一些TDD实践者喜欢在编写单元测试时进行代码生成，而不是先编写它。只要您更有效率，任何方法都可以。我选择先创建文件，因为有时VS会创建这个文件在我打算放置的不同目录中。
- en: 'I will create my unit tests class, which is called `ServicesServiceTests`,
    with the following code:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我将创建一个名为`ServicesServiceTests`的单元测试类，代码如下：
- en: '[PRE20]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: I have added `ApplicationContextFakeBuilder` immediately because I know that
    I am going to be dealing with sample data in my unit tests.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我立即添加了`ApplicationContextFakeBuilder`，因为我知道我将在单元测试中处理样本数据。
- en: 'Now, I need to think of what I need from my service and build a unit test accordingly.
    The straightforward way to start is to pick the easiest scenario. If we have no
    barber service, then no service is returned:'
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我需要考虑我需要从我的服务中得到什么，并据此构建一个单元测试。最直接的方法是选择最简单的情况。如果没有理发师服务，则不会返回任何服务：
- en: '[PRE21]'
  id: totrans-155
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: I have decided in the test that there will be a method named `GetActiveServices`,
    and when this method is called, it will return a collection of active services.
    At this stage, the code doesn’t compile; as such, a method doesn’t exist. We have
    got our TDD’s fail!
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 我在测试中决定将有一个名为`GetActiveServices`的方法，当调用此方法时，它将返回一个活跃服务的集合。在这个阶段，代码无法编译；因此，不存在该方法。我们已经得到了TDD的失败！
- en: 'Now, we can instruct VS to generate this method, and then we can write the
    implementation:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以指示VS生成这个方法，然后我们可以编写实现：
- en: '[PRE22]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: This is getting, through EF, all the available services, and since we did not
    store any service in the sample data, none will return.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 这是通过EF获取所有可用服务，因为我们没有在样本数据中存储任何服务，所以没有返回任何服务。
- en: If you run the test again, it will pass. This is our TDD’s test pass. There
    is no need for the refactor stage, as this is a simple implementation. Congratulations,
    you have finished your first test!
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你再次运行测试，它将通过。这是我们TDD的测试通过。由于这是一个简单的实现，不需要重构阶段。恭喜你，你已经完成了你的第一个测试！
- en: Note
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This test is simple, and it seems like a waste of time. However, this is a valid
    test case, and it also helps us create our domain class and inject the right dependencies.
    Starting with a simple test helps to progress in steady steps.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 这个测试很简单，看起来像是在浪费时间。然而，这是一个有效的测试用例，它还帮助我们创建我们的领域类并注入正确的依赖项。从一个简单的测试开始，有助于稳步推进。
- en: Adding the second unit test via TDD
  id: totrans-163
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 通过TDD添加第二个单元测试
- en: 'The second feature that we need to add is the ability to get the active services
    only, not the ones that are no longer active, as they are no longer provided by
    the barber. So, let’s start with this unit test:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要添加的第二个功能是只获取活跃的服务，而不是那些不再活跃的服务，因为理发师不再提供它们。所以，让我们从这个单元测试开始：
- en: '[PRE23]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Our `Arrange` will add three services – two active and one inactive. It is
    interesting to see the code of `WithSingleService`:'
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的`Arrange`将添加三个服务——两个活跃和一个不活跃。看看`WithSingleService`的代码很有趣：
- en: '[PRE24]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'If we run the test, of course, it will fail, as we have not added any filtration
    functionality to our service. Let’s go ahead and add filtration to the service:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们运行测试，当然会失败，因为我们没有为我们的服务添加任何过滤功能。让我们继续为服务添加过滤功能：
- en: '[PRE25]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We have added a `Where` LINQ statement, which will do the trick. Run the tests
    again, and this test shall pass.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 我们添加了一个`Where` LINQ语句，这将解决问题。再次运行测试，这个测试应该会通过。
- en: This was an easy requirement. In fact, all the stories are straightforward except
    story number 5\. We will not list the other stories here because they are similar,
    but you can find them in the companion source code. Instead, we will focus on
    story number 5 as its complexity matches real-life production code and reveals
    the main benefit of TDD.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的需求。实际上，所有故事都很直接，除了第5个故事。我们不会在这里列出其他故事，因为它们很相似，但你可以从配套源代码中找到它们。相反，我们将专注于第5个故事，因为它的复杂性符合现实生活中的生产代码，并揭示了TDD的主要好处。
- en: Implementing the fifth story (time management)
  id: totrans-172
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现第5个故事（时间管理）
- en: This story is about a time management system. It tries to manage barbers’ time
    fairly, taking rest time into consideration. If you take a moment to think about
    this story, it is a complex one with many edge cases.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事是关于一个时间管理系统。它试图公平地管理理发师的时间，考虑到休息时间。如果你花点时间思考这个故事，它很复杂，有很多边缘情况。
- en: This story reveals the power of TDD as it will help you find a starting point
    and adds little incremental steps to build the requirement. When you finish, you
    will notice that you have automatically documented the story in the unit tests.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事揭示了TDD的力量，因为它将帮助你找到一个起点，并添加少量增量步骤来构建需求。当你完成时，你会注意到你已经在单元测试中自动记录了故事。
- en: In the next sections, we will find a way to start from the easier-to-implement
    scenarios and climb up to more sophisticated test scenarios.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将找到一种从更容易实现的情况开始，逐步过渡到更复杂的测试情况的方法。
- en: Checking for records
  id: totrans-176
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 检查记录
- en: One gentle way to start our implementation that will make us think of the signature
    of the method is checking the parameters.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 一种温和的开始实现的方法是检查方法的签名，这会让我们思考。
- en: 'Logically, to determine an employee’s availability, we need to know who this
    employee is by using `employeeId` and the length of time required. The length
    can be acquired from the service by `serviceId`. A logical name for the method
    can be `GetAvailableSlotsForEmployee`. Our first unit test is this:'
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 从逻辑上讲，为了确定员工的可用性，我们需要通过使用`employeeId`和所需的时间长度来知道这位员工是谁。长度可以通过`serviceId`从服务中获取。方法的一个合理名称可以是`GetAvailableSlotsForEmployee`。我们的第一个单元测试就是这个：
- en: '[PRE26]'
  id: totrans-179
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'It doesn’t compile; it is a fail. So, create the method in `SlotsService`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 它无法编译；这是一个失败。因此，在`SlotsService`中创建方法：
- en: '[PRE27]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Now that you have the implementation in place, run the tests again, and they
    will pass. You can do the same for `employeeId` and do what we did for `serviceId`.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经有了实现，再次运行测试，它们将会通过。你也可以对`employeeId`做同样的事情，就像我们对`serviceId`所做的那样。
- en: Starting with the simplest scenario
  id: totrans-183
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 从最简单的场景开始
- en: 'Let’s add the simplest possible business logic to start with. Let’s assume
    that the system has one employee called Tom. Tom has no shifts available in the
    system. Also, the system has one service only:'
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从添加最简单的业务逻辑开始。假设系统有一个名叫Tom的员工。Tom在系统中没有可用的班次。此外，系统中只有一个服务：
- en: '[PRE28]'
  id: totrans-185
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This will fail, as we have `null` returned by the method, whatever the input
    is. We need to continue adding bits of code to the solution. We can start with
    the following code:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 这将失败，因为无论输入是什么，该方法都会返回`null`。我们需要继续向解决方案中添加代码片段。我们可以从以下代码开始：
- en: '[PRE29]'
  id: totrans-187
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The previous code is exactly what is required to pass the test. The test is
    green now.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的代码正是通过测试所必需的。现在测试是绿色的。
- en: Elevating scenarios’ complexity
  id: totrans-189
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 提高场景的复杂性
- en: 'The rest of the unit tests follow the same way of elevating test scenario complexity
    slightly. Here are other scenarios you might want to add:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 其余的单元测试遵循略微提高测试场景复杂性的相同方式。以下是一些你可能想要添加的其他场景：
- en: '[PRE30]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'The previous test is, in fact, multiple tests (because we are using `Theory`)
    with each `InlineData` elevating complexity. As usual, do the red then green to
    let it pass before adding another suite of tests:'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的测试实际上是多个测试（因为我们使用了`Theory`），每个`InlineData`都提高了复杂性。像往常一样，先做红色，再做绿色，以便在添加另一套测试之前通过：
- en: '[PRE31]'
  id: totrans-193
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: This is also a test with multiple `InlineData`. Obviously, we cannot fit all
    the code here, so please have a look in `SlotsServiceTests.cs` for the complete
    unit tests.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 这也是一个带有多个`InlineData`的测试。显然，我们无法在这里放入所有代码，所以请查看`SlotsServiceTests.cs`以获取完整的单元测试。
- en: As you start adding more test cases, whether by using `Theory` with `InlineData`
    or using `Fact`, you will notice that the code complexity in the implementation
    is going up. This is all right! But, do you feel the readability is suffering?
    Then it is time to refactor.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当你开始添加更多的测试用例时，无论是使用带有`InlineData`的`Theory`还是使用`Fact`，你都会注意到实现中的代码复杂性正在上升。这是完全可以的！但是，你是否觉得可读性正在下降？那么，是时候重构了。
- en: Now you have the advantage of unit tests protecting the code from being broken.
    Refactoring when the method is doing what you want it to do is part of the Red-Green-Refactor
    mantra. In fact, if you look at `SlotsService.cs`, I did refactor to improve readability
    by creating multiple private methods.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你有了单元测试的优势，它们可以保护代码不被破坏。当方法做你想让它做的事情时进行重构是红-绿-重构咒语的一部分。实际上，如果你查看`SlotsService.cs`，我确实重构了，通过创建多个私有方法来提高可读性。
- en: This story is complex, I will give you that. I could have picked an easier example,
    and everybody would be happy, but real-life code has ups and downs and varies
    in complexity, so I wanted to include one sophisticated scenario following the
    pragmatism theme of the book.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这个故事很复杂，我必须承认。我本可以选择一个更容易的例子，大家都会很高兴，但现实生活中的代码有起有落，复杂性各异，所以我想要包含一个符合书籍实用主义主题的复杂场景。
- en: After this section, you might have some questions. I hope I am able to answer
    some of them below.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节之后，你可能会有一些问题。我希望我能在下面回答一些。
- en: Answering frequently asked questions
  id: totrans-199
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 回答常见问题
- en: Now that we have written the unit tests and the associated implementation, let
    me explain the process.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经编写了单元测试和相关的实现，让我解释一下这个过程。
- en: Are these unit tests enough?
  id: totrans-201
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 这些单元测试足够吗？
- en: The answer to this question depends on your target coverage and your confidence
    that all cases are covered. Sometimes, adding more unit tests increases the future
    maintenance overhead, so with experience, you would strike the right balance.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这个问题的答案取决于你的目标覆盖率以及你对所有情况都被覆盖的信心。有时，添加更多的单元测试会增加未来的维护开销，所以随着经验的积累，你会找到正确的平衡点。
- en: Why didn’t we unit test the controllers?
  id: totrans-203
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 为什么我们没有对控制器进行单元测试？
- en: The controllers should not contain business logic. We pushed all the logic to
    the services, then tested the services. What is left in the controllers is minimal
    code concerned with mapping different types to each other. Have a look at the
    controllers in `Uqs.AppointmentBooking.WebApi/Controllers` to see what I mean.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器不应该包含业务逻辑。我们将所有逻辑推送到服务中，然后测试服务。控制器中剩下的只是将不同类型映射到彼此的最小代码。查看`Uqs.AppointmentBooking.WebApi/Controllers`中的控制器，以了解我的意思。
- en: Unit tests excel in testing business logic or areas where there are conditions
    and branching. The controllers in the coding style that we chose do not have that.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 单元测试在测试业务逻辑或存在条件和分支的区域方面表现出色。我们选择编码风格中的控制器没有这些。
- en: The controllers should be tested but through a different type of test.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 控制器应该被测试，但通过不同类型的测试。
- en: Did we test the system enough?
  id: totrans-207
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们测试系统足够了吗？
- en: No, we didn’t! We did the unit tests part. We have not tested the controllers
    or the boot of the system (the content of `Program.cs`) and other small bits of
    the code.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 不，我们没有！我们完成了单元测试部分。我们没有测试控制器或系统的启动（`Program.cs`的内容）以及其他一些小的代码。
- en: We did not test them via unit tests as they are not business logic. However,
    they need testing, but unit tests are not the best testing type to check for the
    quality of these areas. You can cover these areas by other types of testing such
    as integration, Sintegration, and system tests.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 我们没有通过单元测试测试它们，因为它们不是业务逻辑。然而，它们需要测试，但单元测试不是检查这些区域质量的最佳测试类型。你可以通过其他类型的测试来覆盖这些区域，例如集成测试、S集成测试和系统测试。
- en: We omitted testing some areas, how can we achieve high coverage?
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 我们省略了一些区域的测试，如何实现高覆盖率？
- en: Some areas of the code are not unit tested, such as `Program.cs` and the controllers.
    If you are aiming for high code coverage, such as 90%, you might not achieve it
    via unit testing alone, as there is a good amount of code that went here, in this
    chapter.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 代码的一些区域没有进行单元测试，例如`Program.cs`和控制器。如果你目标是实现高代码覆盖率，例如90%，你可能无法仅通过单元测试实现，因为这里有很多代码，在这一章中。
- en: Achieving coverage by unit tests alone is unfair as you need additional testing
    types to achieve more coverage, or the developers would start cheating by adding
    meaningless tests to boost coverage. These tests do more harm than good as they
    will create a maintenance overhead.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过单元测试实现覆盖率是不公平的，因为你需要额外的测试类型来实现更多的覆盖率，否则开发者可能会通过添加无意义的测试来提高覆盖率。这些测试弊大于利，因为它们将增加维护负担。
- en: Coverage calculation should include other types of tests, rather than relying
    on units alone. If this is the case, 90% is a realistic target and can lead to
    a high-quality product.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 覆盖率计算应包括其他类型的测试，而不仅仅是依赖单元测试。如果是这样，90%是一个现实的目标，并且可以导致高质量的产品。
- en: Sometimes it is hard to configure a coverage meter tool to measure the sum of
    multiple test types, so in this case, it makes sense to lower your coding coverage
    target to maybe 80% or so.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候很难配置覆盖率测量工具来测量多种测试类型的总和，因此在这种情况下，将你的代码覆盖率目标降低到大约80%左右是有意义的。
- en: Summary
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: We have seen implementing realistic stories by setting up the system with EF
    and SQL Server, then building it a bit at a time by incrementally adding unit
    tests and increasing the complexity with every additional unit test.
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过使用EF和SQL Server设置系统，然后通过逐步添加单元测试并随着每个额外单元测试的增加复杂性来逐步构建，实现了实现真实故事的实现。
- en: We have seen a realistic fake test double and a concrete builder to construct
    our sample data.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到了一个现实中的模拟测试双例和一个具体的构建器来构建我们的样本数据。
- en: We had to select multiple important scenarios to encourage you to examine the
    full source code, otherwise, the pages will be filled with code.
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不得不选择多个重要场景来鼓励你检查完整的源代码，否则页面将会充满代码。
- en: If you have read and understood the code, then I assure you that this is the
    peak of the complexity, as other chapters should be easier to read and follow.
    So congratulations, you have made it through the hard part of this book! I trust
    you can now go ahead and start your TDD-based project with EF and a relational
    DB.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你已经阅读并理解了代码，那么我向你保证，这是复杂性的顶峰，因为其他章节应该更容易阅读和遵循。所以恭喜你，你已经通过了这本书的难点部分！我相信你现在可以继续使用EF和关系型数据库开始你的基于TDD的项目。
- en: Hopefully, this chapter has given you a guide to starting your new EF and SQL
    Server-based project. The next chapter does the same implementation but focuses
    on document DB and has different patterns than this one.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 希望这一章能为你开启基于 EF 和 SQL Server 的新项目提供指导。下一章将进行相同的实现，但专注于文档数据库，并且与这一章的模式不同。
