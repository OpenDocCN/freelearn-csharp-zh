<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-34">
    <a id="_idTextAnchor033">
    </a>
    
     2
    
   </h1>
   <h1 id="_idParaDest-35">
    <a id="_idTextAnchor034">
    </a>
    
     Advanced Debugging Strategies
    
   </h1>
   <p>
    
     We explored unit testing
    
    <a id="_idIndexMarker077">
    </a>
    
     and
    
    <strong class="bold">
     
      Test-Driven Development
     
    </strong>
    
     (
    
    <strong class="bold">
     
      TDD
     
    </strong>
    
     ) in the last chapter, establishing a sturdy groundwork for crafting dependable code.
    
    
     Now, our focus shifts toward the realm of advanced debugging strategies within Visual Studio.
    
    
     The aim of this chapter is to equip ourselves with the requisite tools and methodologies to effectively
    
    
     
      tackle bugs.
     
    
   </p>
   <p>
    
     Throughout this chapter, we’ll cover the
    
    
     
      following topics:
     
    
   </p>
   <ul>
    <li>
     
      Mastering Visual
     
     
      
       Studio Debugger
      
     
    </li>
    <li>
     
      Advanced breakpoints and
     
     
      
       data inspections
      
     
    </li>
    <li>
     
      Elevating debugging with auto-decompilation and
     
     
      
       External Sources
      
     
    </li>
    <li>
     
      
       Remote debugging
      
     
    </li>
    <li>
     
      Extending debugging capabilities beyond
     
     
      
       our codebase
      
     
    </li>
    <li>
     
      Mastering
     
     
      
       remote debugging
      
     
    </li>
   </ul>
   <p>
    
     By the end of this chapter, we’ll be able to resolve complex bugs significantly faster, saving ourselves time and effort.
    
    
     We will also gain a deeper understanding of our code, leading to more robust and maintainable applications.
    
    
     Finally, we will understand how to work confidently in production environments, knowing we can handle unexpected issues
    
    
     
      with ease.
     
    
   </p>
   <p>
    
     So, let’s set off on this journey of advanced debugging mastery together.
    
    
     With the knowledge and skills we’ll gain, we’ll be able to face any debugging challenge head-on, ensuring quality and performance in
    
    
     
      our code.
     
    
   </p>
   <h1 id="_idParaDest-36">
    <a id="_idTextAnchor035">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     While writing this chapter, I used the following version of
    
    
     
      Visual Studio:
     
    
   </p>
   <ul>
    <li>
     
      Visual Studio Enterprise 2022
     
     
      
       Version
      
     
     
      
       17.12.0
      
     
    </li>
    <li>
     
      
       Preview 1.0
      
     
    </li>
   </ul>
   <h1 id="_idParaDest-37">
    <a id="_idTextAnchor036">
    </a>
    
     Mastering Visual Studio Debugger
    
   </h1>
   <p>
    
     Debugging is the
    
    <a id="_idIndexMarker078">
    </a>
    
     process of finding and fixing errors or bugs in the source code of any software.
    
    
     There are several steps to follow to correctly accomplish
    
    
     
      this task.
     
    
   </p>
   <p>
    
     The first step in debugging is defining the problem.
    
    
     This entails identifying its symptoms, comparing expected versus actual outcomes, determining its scope, assessing its severity and impact, and noting the steps to reproduce it.
    
    
     This clarity streamlines the
    
    
     
      troubleshooting process.
     
    
   </p>
   <p>
    
     Reproducing the bug is often the most effective way to pinpoint its cause.
    
    
     However, if this can’t be done, try checking the environment where it occurred, searching for the error message online, assessing the system’s state at the time, noting how often it happens, and identifying any recurring patterns.
    
    
     Effective debugging skills are crucial for improving software quality and
    
    
     
      developer productivity.
     
    
   </p>
   <h2 id="_idParaDest-38">
    <a id="_idTextAnchor037">
    </a>
    
     Entering debug mode
    
   </h2>
   <p>
    
     To aid us in these
    
    <a id="_idIndexMarker079">
    </a>
    
     debugging processes, modern
    
    <strong class="bold">
     
      Integrated Development Environments
     
    </strong>
    
     (
    
    <strong class="bold">
     
      IDEs
     
    </strong>
    
     ) provide
    
    <a id="_idIndexMarker080">
    </a>
    
     powerful debuggers.
    
    
     As a developer, if you have ever used Visual Studio, you should have already used the debugger available in Visual Studio.
    
    
     Now, let’s delve into its most
    
    
     
      valuable features.
     
    
   </p>
   <p>
    
     I’ve set up a project to walk through using the debugger functionality to analyze how the code is working, I’m sure you can play with what we will see in one of your
    
    
     
      current projects.
     
    
   </p>
   <p>
    
     There are two common options to launch
    
    
     
      the debugger:
     
    
   </p>
   <ul>
    <li>
     
      Launch the entire solution in
     
     
      
       debug mode
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 2.1 – Debug mode" src="img/B22218_02_1.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.1 – Debug mode
    
   </p>
   <ul>
    <li>
     
      Debug unit test for the debug-specific
     
     
      
       public method
      
     
    </li>
   </ul>
   <div><div><img alt="Figure 2.2 – Debugging a unit test" src="img/B22218_02_2.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.2 – Debugging a unit test
    
   </p>
   <p>
    
     The second option could be a good choice to save compile time in our development process.
    
    
     Regardless of our choice, the first thing to do is set a breakpoint by left-clicking on the left side of
    
    <a id="_idIndexMarker081">
    </a>
    
     our source file to navigate through the code.
    
    
     We will discuss the details of breakpoints later in
    
    
     
      this chapter.
     
    
   </p>
   <p>
    
     Simply put, a breakpoint is an intentional stopping or pausing place in
    
    
     
      a program.
     
    
   </p>
   <p>
    
     As we set the breakpoint and launch the debugger (
    
    <em class="italic">
     
      F5
     
    </em>
    
     ), we can observe the behavior of the method.
    
    
     Here’s a reminder of the three main options to navigate on
    
    
     
      our codebase:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Step Into
      
     </strong>
     
      (
     
     <em class="italic">
      
       F11
      
     </em>
     
      ): This command steps into the code, meaning it goes into the method or function that is being called on the current line.
     
     
      If there are nested calls, it steps into the most deeply
     
     
      
       nested one.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Step Over
      
     </strong>
     
      (
     
     <em class="italic">
      
       F10
      
     </em>
     
      ): This command steps over the current line of code, which means it executes the current line and then stops at the next line in the current method or function.
     
     
      It does not step into any methods
     
     
      
       or functions.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Step Out
      
     </strong>
     
      (
     
     <em class="italic">
      
       Shift
      
     </em>
     
      +
     
     <em class="italic">
      
       F11
      
     </em>
     
      ): This command steps out of the current method or function, which means that it will execute the rest of the method and then stop at the next line after the
     
     
      
       method cal
      
      <a id="_idTextAnchor038">
      </a>
      
       l.
      
     
    </li>
   </ul>
   <p>
    
     In debug
    
    <a id="_idIndexMarker082">
    </a>
    
     mode, Visual Studio 2022 provides several ways that help us navigate through our code application during
    
    
     
      debugging sessions.
     
    
   </p>
   <h2 id="_idParaDest-39">
    <a id="_idTextAnchor039">
    </a>
    
     Advanced debug navigation
    
   </h2>
   <p>
    
     Visual Studio 2022 allows
    
    <a id="_idIndexMarker083">
    </a>
    
     us to play with the debugger cursor to explore different areas of our codebase, with two features, described
    
    
     
      as follows.
     
    
   </p>
   <h3>
    
     Run To Cursor (Ctrl + F10)
    
   </h3>
   <p>
    
     The
    
    <strong class="bold">
     
      Run To Cursor
     
    </strong>
    
     feature
    
    <a id="_idIndexMarker084">
    </a>
    
     allows
    
    <a id="_idIndexMarker085">
    </a>
    
     us to quickly navigate to a specific location in our code and execute the code up to that point.
    
    
     To use
    
    <strong class="bold">
     
      Run To Cursor
     
    </strong>
    
     , we simply place the cursor on the line of code where we want execution to stop, then right-click and select
    
    <strong class="bold">
     
      Run To Cursor
     
    </strong>
    
     from the context menu.
    
    
     Alternatively, we can use the keyboard shortcut
    
    <em class="italic">
     
      Ctrl
     
    </em>
    
     +
    
    
     <em class="italic">
      
       F10
      
     </em>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 2.3 – Run to Cursor" src="img/B22218_02_3.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.3 – Run to Cursor
    
   </p>
   <p>
    
     It’s important to note that the line of code where we place the cursor must be reachable, meaning it should be part of the code that gets executed when the application runs.
    
    
     If the line is unreachable, the
    
    <strong class="bold">
     
      Run To Cursor
     
    </strong>
    
     command will
    
    
     
      not work.
     
    
   </p>
   <p>
    
     This command will run the code until it reaches the cursor’s position, but if there’s a breakpoint set at a location before the cursor, the debugger will stop at
    
    
     
      that breakpoint.
     
    
   </p>
   <p>
    
     If we want to
    
    <a id="_idIndexMarker086">
    </a>
    
     directly reach a line of
    
    <a id="_idIndexMarker087">
    </a>
    
     code with the debugger, since Visual Studio 2022, we have been able to use the
    
    <strong class="bold">
     
      Force and Run to
     
    </strong>
    
     <strong class="bold">
      
       Click
      
     </strong>
    
    
     
      feature.
     
    
   </p>
   <h3>
    
     Force And Run to Click
    
   </h3>
   <p>
    
     The
    
    <strong class="bold">
     
      Force Run to Click
     
    </strong>
    
     feature, available
    
    <a id="_idIndexMarker088">
    </a>
    
     from
    
    <a id="_idIndexMarker089">
    </a>
    
     Visual Studio 2022 onward, is a powerful tool that allows us to skip over breakpoints and any first-chance exceptions that occur during the execution of our code.
    
    
     This is particularly useful when we want to test updated code or focus on a specific area of our program without being interrupted
    
    
     
      by breakpoints.
     
    
   </p>
   <p>
    
     To use the
    
    <strong class="bold">
     
      Force Run to Click
     
    </strong>
    
     feature, we need to be in a paused state in the debugger.
    
    
     While the debugger is paused, we can hover over a statement in the source code, press the
    
    <em class="italic">
     
      Shift
     
    </em>
    
     key, and then select
    
    <strong class="bold">
     
      Run execution to here
     
    </strong>
    
     (represented by a green
    
    
     
      arrow icon).
     
    
   </p>
   <div><div><img alt="Figure 2.4 – Run execution to here" src="img/B22218_02_4.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.4 – Run execution to here
    
   </p>
   <p>
    
     When we choose this option, the application will continue to run until it reaches the cursor location, and any breakpoints and first-chance exceptions that occur during this process will be
    
    
     
      temporarily disabled.
     
    
   </p>
   <p>
    
     This feature is especially convenient when we have multiple breakpoints set in our application and we want to skip them all to quickly reach a specific point in our code for testing or
    
    
     
      debugging purposes.
     
    
   </p>
   <p>
    
     Now that we’ve
    
    <a id="_idIndexMarker090">
    </a>
    
     navigated through our
    
    <a id="_idIndexMarker091">
    </a>
    
     codebase using the debugger, we need to understand what’s happening at each step.
    
    
     Visual Studio provides several tools to help us examine the state of our application during
    
    
     
      debugging sessions.
     
    
   </p>
   <h2 id="_idParaDest-40">
    <a id="_idTextAnchor040">
    </a>
    
     Understanding debugger tools
    
   </h2>
   <p>
    
     The Visual Studio debugger
    
    <a id="_idIndexMarker092">
    </a>
    
     offers several windows, some more recent than others, to explore our variables and objects.
    
    
     Let’s explore these windows
    
    
     
      in detail.
     
    
   </p>
   <h3>
    
     Autos window
    
   </h3>
   <p>
    
     The
    
    <strong class="bold">
     
      Autos
     
    </strong>
    
     window displays
    
    <a id="_idIndexMarker093">
    </a>
    
     variables and
    
    <a id="_idIndexMarker094">
    </a>
    
     expressions that are automatically evaluated by the debugger.
    
    
     It shows the values of local variables and expressions that are currently in scope.
    
    
     The
    
    <strong class="bold">
     
      Autos
     
    </strong>
    
     window is useful when we have many variables and we don’t want to clutter the
    
    <strong class="bold">
     
      Locals
     
    </strong>
    
     window with all of them.
    
    
     It evaluates only the most relevant variables based on our current
    
    
     
      execution context.
     
    
   </p>
   <div><div><img alt="Figure 2.5 – The Autos window" src="img/B22218_02_5.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.5 – The Autos window
    
   </p>
   <p>
    
     In this example, we have a
    
    <strong class="source-inline">
     
      int apple.Id = 1;
     
    </strong>
    
     variable and the
    
    <strong class="source-inline">
     
      apple
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      stockManager
     
    </strong>
    
     objects in use; the
    
    <strong class="bold">
     
      Autos
     
    </strong>
    
     window might show just them along with their values, rather
    
    <a id="_idIndexMarker095">
    </a>
    
     than showing every single variable
    
    <a id="_idIndexMarker096">
    </a>
    
     in the
    
    
     
      current scope.
     
    
   </p>
   <p>
    
     Next, let’s take a look at the
    
    
     <strong class="bold">
      
       Locals
      
     </strong>
    
    
     
      window.
     
    
   </p>
   <h3>
    
     Locals window
    
   </h3>
   <p>
    
     The
    
    <strong class="bold">
     
      Locals
     
    </strong>
    
     window
    
    <a id="_idIndexMarker097">
    </a>
    
     shows all local variables in the
    
    <a id="_idIndexMarker098">
    </a>
    
     current scope.
    
    
     Unlike the
    
    <strong class="bold">
     
      Autos
     
    </strong>
    
     window, which only shows a subset of variables, the
    
    <strong class="bold">
     
      Locals
     
    </strong>
    
     window lists all local variables regardless of their relevance.
    
    
     This can be helpful when we need to see the exact state of all local variables at a
    
    
     
      particular breakpoint.
     
    
   </p>
   <div><div><img alt="Figure 2.6 – The Locals window" src="img/B22218_02_6.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.6 – The Locals window
    
   </p>
   <p>
    
     Here, the
    
    <strong class="bold">
     
      Locals
     
    </strong>
    
     window allows you to see the value of each variable at the time the code
    
    <a id="_idIndexMarker099">
    </a>
    
     execution
    
    <a id="_idIndexMarker100">
    </a>
    
     
      is paused.
     
    
   </p>
   <p>
    
     Next, we’ll look at the
    
    
     <strong class="bold">
      
       Watch
      
     </strong>
    
    
     
      window.
     
    
   </p>
   <h3>
    
     Watch window
    
   </h3>
   <p>
    
     We use the
    
    <strong class="bold">
     
      Watch
     
    </strong>
    
     window to
    
    <a id="_idIndexMarker101">
    </a>
    
     monitor specific
    
    <a id="_idIndexMarker102">
    </a>
    
     variables or expressions.
    
    
     We can manually add variables or expressions to the
    
    <strong class="bold">
     
      Watch
     
    </strong>
    
     window, and the debugger will evaluate them whenever the execution is paused.
    
    
     This is particularly useful when we want to keep track of the changes in the value of a variable over time or when we want to evaluate complex expressions that involve
    
    
     
      multiple variables.
     
    
   </p>
   <p>
    
     To add an expression to the
    
    <strong class="bold">
     
      Watch
     
    </strong>
    
     window, right-click on the code and select
    
    <strong class="bold">
     
      Add Watch
     
    </strong>
    
     .
    
    
     We can also type directly or code in the
    
    
     <strong class="bold">
      
       Watch
      
     </strong>
    
    
     
      window.
     
    
   </p>
   <div><div><img alt="Figure 2.7 – The Watch window" src="img/B22218_02_7.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.7 – The Watch window
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      Watch
     
    </strong>
    
     window can also be used to modify the value of a variable during debugging, which can be helpful for testing
    
    
     
      different scenarios.
     
    
   </p>
   <h3>
    
     Call Stack window
    
   </h3>
   <p>
    
     Now, if we
    
    <a id="_idIndexMarker103">
    </a>
    
     enter the
    
    <strong class="source-inline">
     
      UpdateProduct()
     
    </strong>
    
     method, we
    
    <a id="_idIndexMarker104">
    </a>
    
     can follow the sequence in the
    
    <strong class="bold">
     
      Call
     
    </strong>
    
     <strong class="bold">
      
       Stack
      
     </strong>
    
    
     
      window.
     
    
   </p>
   <div><div><img alt="Figure 2.8 – The Call Stack window" src="img/B22218_02_8.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.8 – The Call Stack window
    
   </p>
   <p>
    
     The
    
    <strong class="bold">
     
      Call Stack
     
    </strong>
    
     window in Visual Studio is a critical tool for debugging as it allows us to view the sequence of function or method calls that led to the current point of execution in our program.
    
    
     This window is essential for understanding the flow of execution and for diagnosing issues within
    
    
     
      our code.
     
    
   </p>
   <p>
    
     Here are some key functionalities of
    
    <a id="_idIndexMarker105">
    </a>
    
     the
    
    <strong class="bold">
     
      Call Stack
     
    </strong>
    
     window in
    
    
     
      Visual Studio:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Viewing Call Stack
      
     </strong>
     
      : We can see the sequence of method and function calls that led to the current point of execution in
     
     
      
       our program.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Switching stack frames
      
     </strong>
     
      : We can switch to a different stack frame by right-clicking a frame in the
     
     <strong class="bold">
      
       Call Stack
      
     </strong>
     
      window and selecting
     
     <strong class="bold">
      
       Switch to Frame
      
     </strong>
     
      , or by double-clicking the frame.
     
     
      This allows us to inspect the code and data within
     
     
      
       that frame.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Disassembly code view
      
     </strong>
     
      : To view the disassembly code for a function on the call stack, simply right-click the function and select
     
     <strong class="bold">
      
       Go
      
     </strong>
     
      <strong class="bold">
       
        To Disassembly
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Loading Symbols
      
     </strong>
     
      : The
     
     <strong class="bold">
      
       Call Stack
      
     </strong>
     
      window in Visual Studio has the capability to load debugging symbols for code that currently lacks them.
     
     
      These symbols may include .NET or system symbols obtained from Microsoft’s public symbol servers, or symbols located within a symbol path on
     
     
      
       our computer.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Code map integration
      
     </strong>
     
      : Visual Studio Enterprise provides the functionality to visually map the call stack during debugging.
     
     
      This feature enables us to observe the current call stack in a graphical format on a new code map, which updates automatically as debugging progresses.
     
     
      This visual representation facilitates a more intuitive understanding of the structure and flow of our code, aiding in the identification of potential issues or areas for optimization.
     
     
      Please note that adding
     
     <a id="_idIndexMarker106">
     </a>
     
      the
     
     <strong class="bold">
      
       CodeMap
      
     </strong>
     
      extension to
     
     <a id="_idIndexMarker107">
     </a>
     
      Visual Studio is necessary to utilize
     
     
      
       this feature.
      
     
    </li>
   </ul>
   <p>
    
     Finally, let us look
    
    <a id="_idIndexMarker108">
    </a>
    
     at the
    
    
     <strong class="bold">
      
       Immediate
      
     </strong>
    
    
     
      Window.
     
    
   </p>
   <h3>
    
     Immediate window
    
   </h3>
   <p>
    
     The
    
    <strong class="bold">
     
      Immediate
     
    </strong>
    
     window in
    
    <a id="_idIndexMarker109">
    </a>
    
     Visual Studio is
    
    <a id="_idIndexMarker110">
    </a>
    
     an old, little-known debugging tool that allows us to execute code, evaluate expressions, and print variable values on the fly during a
    
    
     
      debugging session.
     
    
   </p>
   <div><div><img alt="Figure 2.9 – The Immediate window" src="img/B22218_02_9.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.9 – The Immediate window
    
   </p>
   <p>
    
     It is designed to help with dynamic code evaluation and the quick testing of code snippets without having to stop the execution of the application.
    
    
     To use the
    
    <strong class="bold">
     
      Immediate
     
    </strong>
    
     window, open it by going to the
    
    <strong class="bold">
     
      Debug
     
    </strong>
    
     menu, selecting
    
    <strong class="bold">
     
      Windows
     
    </strong>
    
     , and then choosing the
    
    <strong class="bold">
     
      Immediate
     
    </strong>
    
     window, or by pressing
    
    <em class="italic">
     
      Ctrl
     
    </em>
    
     +
    
    <em class="italic">
     
      Alt
     
    </em>
    
     +
    
    <em class="italic">
     
      I
     
    </em>
    
     .
    
    
     This window is particularly useful when debugging an application, as it allows us to check the value of variables, call functions, and execute statements without stepping through the code line
    
    
     
      by line.
     
    
   </p>
   <p>
    
     Here are some valuable tricks for using the
    
    <strong class="bold">
     
      Immediate
     
    </strong>
    
     window effectively
    
    
     
      during debugging:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Debugging methods from the Immediate window
      
     </strong>
     
      : We can place breakpoints in methods and call them from the
     
     <strong class="bold">
      
       Immediate
      
     </strong>
     
      window to debug them, even if we’ve already passed that point in the code.
     
     
      Note that we can use the
     
     <strong class="bold">
      
       Run to a cursor location
      
     </strong>
     
      (
     
     <em class="italic">
      
       Ctrl
      
     </em>
     
      +
     
     <em class="italic">
      
       Shift
      
     </em>
     
      +
     
     <em class="italic">
      
       F10
      
     </em>
     
      ) feature to return to any line of code in the same scope and step into methods with
     
     <em class="italic">
      
       F11
      
     </em>
     
      to debug
     
     
      
       as usual.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Bypassing access rules
      
     </strong>
     
      : The
     
     <strong class="bold">
      
       Immediate
      
     </strong>
     
      window does not enforce class accessibility rules, allowing us to call private, protected, and internal members that would not be accessible in regular code.
     
     
      However, IntelliSense (the built-in autocompletion tool) will still show only the
     
     
      
       public methods.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Evaluating expressions without side effects
      
     </strong>
     
      : Evaluating expressions in the
     
     <strong class="bold">
      
       Immediate
      
     </strong>
     
      window can change variable values and call methods, potentially causing side
     
     <a id="_idIndexMarker111">
     </a>
     
      effects.
     
     
      To avoid this, append
     
     <strong class="bold">
      
       No Side Effects
      
     </strong>
     
      (
     
     <strong class="source-inline">
      
       nse
      
     </strong>
     
      ) to an
     
     <a id="_idIndexMarker112">
     </a>
     
      expression, which will evaluate it without altering the
     
     
      
       application state.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Accessing special debugging variables
      
     </strong>
     
      : The
     
     <strong class="bold">
      
       Immediate
      
     </strong>
     
      window can display values of special debugging variables such as
     
     <strong class="source-inline">
      
       $exception
      
     </strong>
     
      (the currently thrown exception),
     
     <strong class="source-inline">
      
       $returnvalue
      
     </strong>
     
      (the return value of the currently returned method), and
     
     <strong class="source-inline">
      
       $user
      
     </strong>
     
      (the current OS user and
     
     
      
       process information).
      
     
    </li>
    <li>
     <strong class="bold">
      
       Evaluating Make Object ID
      
     </strong>
     
      : When debugging, you can
     
     <strong class="bold">
      
       Make Object ID
      
     </strong>
     
      for a variable in
     
     <strong class="bold">
      
       DataTip
      
     </strong>
     
      , which creates a unique identifier for the object.
     
     
      This identifier can be evaluated in the
     
     <strong class="bold">
      
       Immediate
      
     </strong>
     
      window at any time to see changes in the object’s value or existence
     
     
      
       in memory.
      
     
    </li>
   </ul>
   <p>
    
     Identifying bugs is
    
    <a id="_idIndexMarker113">
    </a>
    
     an essential step in our debugging
    
    <a id="_idIndexMarker114">
    </a>
    
     process, but the goal is to fix them.
    
    
     Let’s explore how we can enhance productivity by fixing them on the fly with
    
    
     
      Visual Studio.
     
    
   </p>
   <h2 id="_idParaDest-41">
    <a id="_idTextAnchor041">
    </a>
    
     Fixing bugs on the fly
    
   </h2>
   <p>
    
     To enhance our
    
    <a id="_idIndexMarker115">
    </a>
    
     productivity during debugging and avoid the need to stop and start the debugger to fix a bug, Visual Studio 2022 allows us to do so on the fly with the
    
    
     
      following features.
     
    
   </p>
   <h3>
    
     Edit and Continue
    
   </h3>
   <p>
    <strong class="bold">
     
      Edit and Continue
     
    </strong>
    
     is a feature
    
    <a id="_idIndexMarker116">
    </a>
    
     that allows
    
    <a id="_idIndexMarker117">
    </a>
    
     you to modify your source code while your application is in break mode.
    
    
     When you apply the changes, Visual Studio attempts to recompile the modified code and apply those changes to the running application.
    
    
     This means that you can fix bugs, add features, or experiment with code changes without interrupting the flow of your
    
    
     
      debugging session.
     
    
   </p>
   <p>
    
     Here’s how
    
    
     
      it works:
     
    
   </p>
   <ol>
    <li>
     
      We start debugging
     
     
      
       your application.
      
     
    </li>
    <li>
     
      We hit a breakpoint and pause
     
     
      
       the execution.
      
     
    </li>
    <li>
     
      While paused, we can edit the code in
     
     
      
       the editor.
      
     
    </li>
    <li>
     
      After editing, we can choose to continue execution with the new
     
     
      
       changes applied.
      
     
    </li>
   </ol>
   <p>
    
     We can even move the yellow execution pointer back to change the execution flow and execute our
    
    
     
      edited code.
     
    
   </p>
   <p>
    
     This feature is particularly useful when we find a bug during a debugging session, and we immediately know how to fix it.
    
    
     Instead of stopping the debugger, making the change, and then restarting the app, you can simply edit the code
    
    
     
      and continue.
     
    
   </p>
   <h3>
    
     Hot Reload
    
   </h3>
   <p>
    <strong class="bold">
     
      Hot Reload
     
    </strong>
    
     is a
    
    <a id="_idIndexMarker118">
    </a>
    
     newer
    
    <a id="_idIndexMarker119">
    </a>
    
     feature
    
    <a id="_idIndexMarker120">
    </a>
    
     introduced in
    
    <strong class="bold">
     
      .NET 6
     
    </strong>
    
     and supported in Visual Studio 2022.
    
    
     It allows us to make changes to our code while our application is running, and those changes are reflected in the running application almost instantly.
    
    
     This is like Edit and Continue, but with a few
    
    
     
      key differences:
     
    
   </p>
   <ul>
    <li>
     
      Hot Reload supports UI updates, whereas Edit and Continue does not.
     
     
      If we change the layout or appearance of our UI, Hot Reload will update the running app to reflect
     
     
      
       those changes.
      
     
    </li>
    <li>
     
      Hot Reload is designed to work with .NET applications, including ASP.NET Core web apps and Blazor
     
     
      
       WebAssembly apps.
      
     
    </li>
    <li>
     
      Hot Reload requires a bit more setup compared to Edit and Continue.
     
     
      We need to enable it in our project settings and ensure that our app is compatible with the feature.
     
     
      We will delve deeper into it in the
     
     
      
       next chapter.
      
     
    </li>
    <li>
     
      With Hot Reload, we can see the effects of our changes immediately, which can speed up the development process, especially when working on UI or
     
     
      
       front-end code.
      
     
    </li>
   </ul>
   <p>
    
     Both Edit and Continue and Hot Reload are powerful tools that can save time and reduce the frustration associated with stopping and restarting our application during the debugging process.
    
    
     They allow us to maintain a smooth workflow and quickly iterate on our code, which can lead to more efficient problem-solving and faster
    
    
     
      development cycles.
     
    
   </p>
   <p>
    
     Now that we’ve conquered the art of navigating the debugger, taken an overview of their windows, and performed live fixes, let’s delve deeper into two powerful tools that elevate your debugging game: advanced breakpoints and data inspection.
    
    
     While we’ve already touched
    
    <a id="_idIndexMarker121">
    </a>
    
     upon them, consider this a deep dive, equipping
    
    <a id="_idIndexMarker122">
    </a>
    
     you to wield them with precision and unlock invaluable insights into your
    
    
     
      code’s behavior.
     
    
   </p>
   <h1 id="_idParaDest-42">
    <a id="_idTextAnchor042">
    </a>
    
     Advanced breakpoints and data inspections
    
   </h1>
   <p>
    
     Advanced breakpoints in Visual Studio 2022 are powerful tools that allow us to inspect and control the execution flow of their programs during
    
    
     
      debugging sessions.
     
    
   </p>
   <h2 id="_idParaDest-43">
    <a id="_idTextAnchor043">
    </a>
    
     Understanding the types of breakpoints
    
   </h2>
   <p>
    
     Breakpoints in
    
    <a id="_idIndexMarker123">
    </a>
    
     Visual Studio can be divided into several types.
    
    
     Those are
    
    
     
      as follows.
     
    
   </p>
   <h3>
    
     Conditional breakpoints
    
   </h3>
   <p>
    
     We can control when
    
    <a id="_idIndexMarker124">
    </a>
    
     a breakpoint executes by setting
    
    <a id="_idIndexMarker125">
    </a>
    
     conditions.
    
    
     That feature has been available since Visual Studio 2005.
    
    
     We can right-click the breakpoint symbol and select
    
    <strong class="bold">
     
      Conditions
     
    </strong>
    
     , or right-click in the margin next to a line of code and select
    
    <strong class="bold">
     
      Insert Conditional Breakpoint
     
    </strong>
    
     from the context menu.
    
    
     In the
    
    <strong class="bold">
     
      Breakpoint Settings
     
    </strong>
    
     window, select
    
    <strong class="bold">
     
      Conditional Expression
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Hit Count
     
    </strong>
    
     , or
    
    <strong class="bold">
     
      Filter
     
    </strong>
    
     , and set the conditional expression in the text
    
    
     
      box accordingly.
     
    
   </p>
   <div><div><img alt="Figure 2.10 – Conditional breakpoint" src="img/B22218_02_10.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.10 – Conditional breakpoint
    
   </p>
   <p>
    
     In this example, with our setup, the debugger will stop if
    
    <strong class="source-inline">
     
      newQuantiy
     
    </strong>
    
     is not equal
    
    
     
      to
     
    
    
     <strong class="source-inline">
      
       product.QuantityStock
      
     </strong>
    
   </p>
   <h3>
    
     Tracepoints
    
   </h3>
   <p>
    
     Introduced
    
    <a id="_idIndexMarker126">
    </a>
    
     with
    
    <a id="_idIndexMarker127">
    </a>
    
     Visual Studio 2005, a
    
    <strong class="bold">
     
      tracepoint
     
    </strong>
    
     serves as a breakpoint variant enabling users to log information to the
    
    <strong class="bold">
     
      Output
     
    </strong>
    
     window based on customizable conditions as conditional breakpoints without altering or pausing the code execution.
    
    
     Tracepoints are compatible with managed languages such as C#, Visual Basic, F#, and native code, as well as languages such as JavaScript
    
    
     
      and Python
     
    
   </p>
   <p>
    
     To set a tracepoint, simply click on the gutter located to the left of the desired line number.
    
    
     Hover over the ensuing red circle and click on the gear icon to unveil the
    
    <strong class="bold">
     
      Breakpoint Settings
     
    </strong>
    
     window.
    
    
     Proceed by selecting the
    
    <strong class="bold">
     
      Action
     
    </strong>
    
     checkbox.
    
    
     This action will transform the red circle into a diamond shape, signifying the transition from a traditional breakpoint to
    
    
     
      a tracepoint.
     
    
   </p>
   <div><div><img alt="Figure 2.11 – Tracepoint" src="img/B22218_02_11.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.11 – Tracepoint
    
   </p>
   <p>
    
     Enter the message
    
    <a id="_idIndexMarker128">
    </a>
    
     we
    
    <a id="_idIndexMarker129">
    </a>
    
     want to log into the
    
    <strong class="bold">
     
      Show a message in the Output Window
     
    </strong>
    
     text box.
    
    
     If we want to add conditions that determine whether our message is displayed, we could select the
    
    <strong class="bold">
     
      Conditions
     
    </strong>
    
     checkbox.
    
    
     As for conditional breakpoints, we have three choices for conditions:
    
    <strong class="bold">
     
      Conditional Expression
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Filter
     
    </strong>
    
     , and
    
    <strong class="bold">
     
      Hit Count
     
    </strong>
    
     .
    
    
     Tracepoints are useful for debugging because they allow us to log information without cluttering our code with print statements or functions such
    
    
     
      as
     
    
    
     <strong class="source-inline">
      
       Debug.WriteLine()
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h3>
    
     Data breakpoints
    
   </h3>
   <p>
    
     Data breakpoints
    
    <a id="_idIndexMarker130">
    </a>
    
     allow us, as developers, to pause execution
    
    <a id="_idIndexMarker131">
    </a>
    
     when the value of a specific object’s property changes.
    
    
     This feature is particularly useful for debugging scenarios where we want to monitor changes to data without having to manually step through code.
    
    
     Data breakpoints can be
    
    <a id="_idIndexMarker132">
    </a>
    
     set for
    
    <strong class="bold">
     
      .NET Core 3.x
     
    </strong>
    
     or
    
    <strong class="bold">
     
      .NET 5+
     
    </strong>
    
     projects, and they are
    
    <a id="_idIndexMarker133">
    </a>
    
     particularly useful for tracking changes in
    
    
     
      object properties.
     
    
   </p>
   <p>
    
     To set a data breakpoint in a .NET Core or .NET 5+ project, we start debugging and wait until a breakpoint is reached.
    
    
     Then, in the
    
    <strong class="bold">
     
      Autos
     
    </strong>
    
     ,
    
    <strong class="bold">
     
      Watch
     
    </strong>
    
     , or
    
    <strong class="bold">
     
      Locals
     
    </strong>
    
     window, we right-click a property and select
    
    <strong class="bold">
     
      Break when value changes
     
    </strong>
    
     from the
    
    
     
      context menu.
     
    
   </p>
   <div><div><img alt="Figure 2.12 – Break When Value Changes" src="img/B22218_02_12.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.12 – Break When Value Changes
    
   </p>
   <p>
    
     This will set a data breakpoint that triggers when the selected property’s
    
    
     
      value changes.
     
    
   </p>
   <p>
    
     Data breakpoints are subject to hardware and kernel limitations.
    
    
     The Windows kernel and the underlying
    
    <a id="_idIndexMarker134">
    </a>
    
     hardware impose a maximum number of
    
    <a id="_idIndexMarker135">
    </a>
    
     data breakpoints that can be set simultaneously.
    
    
     These limitations ensure that our debugging experience remains efficient
    
    
     
      and responsive.
     
    
   </p>
   <p>
    
     It’s important to note that data breakpoints depend on specific memory addresses, and that the address of a variable can change from one debugging session to the next.
    
    
     Therefore, data breakpoints are automatically disabled at the end of each debugging session.
    
    
     If we set a data breakpoint on a local variable, the breakpoint remains enabled when the function ends, but the memory address is no longer applicable, leading to unpredictable behavior.
    
    
     It’s recommended to delete or disable such breakpoints before the function ends to
    
    
     
      avoid confusion.
     
    
   </p>
   <p>
    
     The introduction of data breakpoints for .NET Core in Visual Studio 2019 marked the start of this
    
    <a id="_idIndexMarker136">
    </a>
    
     feature, making
    
    <a id="_idIndexMarker137">
    </a>
    
     it a valuable tool for us when working with .NET Core 3.x or .
    
    
     
      NET 5+.
     
    
   </p>
   <h3>
    
     Function breakpoints
    
   </h3>
   <p>
    
     Since Visual
    
    <a id="_idIndexMarker138">
    </a>
    
     Studio 2012, we have been able to set
    
    <a id="_idIndexMarker139">
    </a>
    
     breakpoints on functions, which is useful when we know the function name but not its location, or when we have overloaded functions.
    
    
     To set a function breakpoint, select
    
    <strong class="bold">
     
      Debug
     
    </strong>
    
     |
    
    <strong class="bold">
     
      New Breakpoint
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Function Breakpoint
     
    </strong>
    
     , or press
    
    <em class="italic">
     
      Ctrl
     
    </em>
    
     +
    
    <em class="italic">
     
      K
     
    </em>
    
     ,
    
    
     
      then
     
    
    
     <em class="italic">
      
       B
      
     </em>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 2.13 – Function breakpoints" src="img/B22218_02_13.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.13 – Function breakpoints
    
   </p>
   <p>
    
     Enter the fully qualified function name, including parameter types for overloaded functions, or use the
    
    <em class="italic">
     
      !
     
    </em>
    
     symbol to specify the module.
    
    
     Here, we set a breakpoint to the
    
    <strong class="source-inline">
     
      SearchProducts
     
    </strong>
    
     method of the
    
    
     <strong class="source-inline">
      
       StockManager
      
     </strong>
    
    
     
      class.
     
    
   </p>
   <h3>
    
     Dependant breakpoints
    
   </h3>
   <p>
    
     Visual Studio 2022 introduced
    
    <a id="_idIndexMarker140">
    </a>
    
     us to the possibility of
    
    <a id="_idIndexMarker141">
    </a>
    
     setting up a dependent breakpoint, which is a powerful debugging feature that allows us to pause the execution of our program only when another specific breakpoint has been hit first.
    
    
     This is particularly useful in complex debugging scenarios, such as when we are working with multi-threaded applications or when we want to focus on debugging code in specific parts of
    
    
     
      our application.
     
    
   </p>
   <p>
    
     To set up a dependent breakpoint, we first need to identify the breakpoint that our current breakpoint will depend on.
    
    
     Then, we hover over the breakpoint symbol, choose the settings icon, and select
    
    <strong class="bold">
     
      Only enable when the following breakpoint is hit
     
    </strong>
    
     in the
    
    <strong class="bold">
     
      Breakpoint
     
    </strong>
    
     <strong class="bold">
      
       Settings
      
     </strong>
    
    
     
      window.
     
    
   </p>
   <div><div><img alt="Figure 2.14 – The Only enable when the following breakpoint is hit checkbox" src="img/B22218_02_14.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.14 – The Only enable when the following breakpoint is hit checkbox
    
   </p>
   <p>
    
     From the
    
    <a id="_idIndexMarker142">
    </a>
    
     dropdown, we
    
    <a id="_idIndexMarker143">
    </a>
    
     select the prerequisite breakpoint that we want our current breakpoint to be dependent on.
    
    
     After setting this up, we can close
    
    
     
      the dialog.
     
    
   </p>
   <p>
    
     Another way to set a dependent breakpoint is by using the right-click context menu.
    
    
     We right-click in the far-left margin next to a line of code and select
    
    <strong class="bold">
     
      Insert Dependent Breakpoint
     
    </strong>
    
     from the
    
    
     
      context menu.
     
    
   </p>
   <div><div><img alt="Figure 2.15 – Insert Dependent Breakpoint" src="img/B22218_02_15.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.15 – Insert Dependent Breakpoint
    
   </p>
   <p>
    
     It’s important to note that dependent breakpoints do not work if there is only a single breakpoint in our application.
    
    
     If the prerequisite breakpoint is deleted, the dependent breakpoint will be converted to a normal
    
    
     
      line breakpoint.
     
    
   </p>
   <p>
    
     This feature is designed to streamline our debugging process by allowing us to focus on specific parts of
    
    <a id="_idIndexMarker144">
    </a>
    
     our code that are relevant to
    
    <a id="_idIndexMarker145">
    </a>
    
     the debugging task at hand, thereby potentially saving time and effort during the
    
    
     
      debugging process.
     
    
   </p>
   <h3>
    
     Temporary breakpoints
    
   </h3>
   <p>
    
     Temporary
    
    <a id="_idIndexMarker146">
    </a>
    
     breakpoints
    
    <a id="_idIndexMarker147">
    </a>
    
     in Visual Studio 2022 are a powerful debugging feature that allows us, as developers, to pause the execution of our code only once at a specific location.
    
    
     Once the breakpoint is hit during our debugging session, it automatically disables itself, making it ideal for scenarios wherein we want to inspect a specific condition or behavior without repeatedly hitting the
    
    
     
      same breakpoint.
     
    
   </p>
   <p>
    
     To set up a tempory breakpoint, we first need to identify the breakpoint that our current breakpoint will depend on.
    
    
     Then, we hover over the breakpoint symbol, choose the settings icon, and select
    
    <strong class="bold">
     
      Disable breakpoint once hit
     
    </strong>
    
     in the
    
    <strong class="bold">
     
      Breakpoint Settings
     
    </strong>
    
     window.
    
    
     This action configures the breakpoint to automatically disable itself after it’s hit during our
    
    
     
      debugging session.
     
    
   </p>
   <div><div><img alt="Figure 2.16 – Disable breakpoint once hit" src="img/B22218_02_16.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.16 – Disable breakpoint once hit
    
   </p>
   <p>
    
     Alternatively, we can directly set a temporary breakpoint by right-clicking in the breakpoint gutter and selecting
    
    <strong class="bold">
     
      Insert Temporary Breakpoint
     
    </strong>
    
     from the
    
    
     
      context menu.
     
    
   </p>
   <p>
    
     The introduction of temporary breakpoints in Visual Studio 2022 enhances our debugging experience by providing us with a tool to inspect specific points in the code without the need to manually remove or disable breakpoints after they have been hit.
    
    
     This feature is particularly useful for validating assumptions, checking the flow of execution, or
    
    <a id="_idIndexMarker148">
    </a>
    
     verifying
    
    <a id="_idIndexMarker149">
    </a>
    
     the state of variables at specific moments during our
    
    
     
      debugging process.
     
    
   </p>
   <p>
    
     Now that we’ve learned all about breakpoints, let’s learn how we can
    
    
     
      organize them.
     
    
   </p>
   <h2 id="_idParaDest-44">
    <a id="_idTextAnchor044">
    </a>
    
     Organizing our breakpoints
    
   </h2>
   <p>
    
     We can use labels
    
    <a id="_idIndexMarker150">
    </a>
    
     to sort and filter breakpoints in the
    
    <strong class="bold">
     
      Breakpoints
     
    </strong>
    
     window.
    
    
     Right-click a breakpoint and select
    
    <strong class="bold">
     
      Edit labels...
     
    </strong>
    
     to add or
    
    
     
      change labels.
     
    
   </p>
   <div><div><img alt="Figure 2.17 – Edit labels…" src="img/B22218_02_17.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.17 – Edit labels…
    
   </p>
   <p>
    
     Then, in the
    
    <strong class="bold">
     
      Breakpoints
     
    </strong>
    
     window, we can retrieve our settled labels to filter and
    
    
     
      organize them.
     
    
   </p>
   <div><div><img alt="Figure 2.18 – Breakpoints with labels" src="img/B22218_02_18.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.18 – Breakpoints with labels
    
   </p>
   <p>
    
     In this example, I labeled my conditional
    
    <a id="_idIndexMarker151">
    </a>
    
     
      breakpoint
     
    
    
     <strong class="bold">
      
       UpdateQuantity
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Now that we know
    
    <a id="_idIndexMarker152">
    </a>
    
     which breakpoints to use according to our needs, let’s see how to inspect the
    
    
     
      data efficiently.
     
    
   </p>
   <h2 id="_idParaDest-45">
    <a id="_idTextAnchor045">
    </a>
    
     Inspecting the data
    
   </h2>
   <p>
    
     As we have seen
    
    <a id="_idIndexMarker153">
    </a>
    
     before, the
    
    <strong class="bold">
     
      Watch
     
    </strong>
    
     window in Visual Studio is a powerful debugging tool that allows us to monitor the values of variables and expressions during the execution of our program.
    
    
     It is particularly useful when we want to keep an eye on the changes in variable values as your code executes, which can be especially helpful in debugging complex logic or
    
    
     
      performance issues.
     
    
   </p>
   <p>
    
     While the
    
    <strong class="bold">
     
      Watch
     
    </strong>
    
     window offers a dedicated space for monitoring variables, Visual Studio also empowers us with a more immediate option:
    
    <strong class="bold">
     
      DataTips
     
    </strong>
    
     .
    
    
     These handy popups appear right
    
    <a id="_idIndexMarker154">
    </a>
    
     within the code editor, revealing variable values directly where
    
    
     
      they’re used.
     
    
   </p>
   <p>
    
     To leverage DataTips, simply hover our mouse over any variable name in our code.
    
    
     Then, a tooltip emerges, displaying the current value of
    
    
     
      that variable.
     
    
   </p>
   <div><div><img alt="Figure 2.19 – Displaying the datatips" src="img/B22218_02_19.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.19 – Displaying the datatips
    
   </p>
   <p>
    
     In certain scenarios, such as the
    
    <a id="_idIndexMarker155">
    </a>
    
     one shown in
    
    
     <em class="italic">
      
       Figure 2
      
     </em>
    
    <em class="italic">
     
      .19
     
    </em>
    
     , it can be challenging to locate specific items of interest within a
    
    
     
      large list.
     
    
   </p>
   <h3>
    
     Pinning properties
    
   </h3>
   <p>
    
     When looking at a data
    
    <a id="_idIndexMarker156">
    </a>
    
     list with a huge list of complex data, it could be difficult to focus on the part of the data we need.
    
    
     The solution is to utilize the
    
    <strong class="bold">
     
      Pinnable Properties
     
    </strong>
    
     feature, also available in the
    
    <strong class="bold">
     
      Watch
     
    </strong>
    
     window.
    
    
     To accomplish this, we expand a variable and pin the property that interests us.
    
    
     For example, if we’re interested in the name of the product, we can pin it for
    
    
     
      easy reference.
     
    
   </p>
   <div><div><img alt="Figure 2.20 – Pinning the Name property" src="img/B22218_02_20.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.20 – Pinning the Name property
    
   </p>
   <div><div><img alt="Figure 2.21 – A list of products with pinned names" src="img/B22218_02_21.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.21 – A list of products with pinned names
    
   </p>
   <p>
    
     Now, whenever we inspect this object with DataTips, even in the
    
    <strong class="bold">
     
      Watch
     
    </strong>
    
     window, the pinned property replaces the name of the object until we
    
    
     
      unpin it.
     
    
   </p>
   <div><div><img alt="Figure 2.22 – Pinned properties in the Watch window" src="img/B22218_02_22.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.22 – Pinned properties in the Watch window
    
   </p>
   <p>
    
     Now, we can easily access the product we want to inspect.
    
    
     Additionally, we can use the pin icon located next to our product object to keep the
    
    
     
      popup visible.
     
    
   </p>
   <div><div><img alt="Figure 2.23 – The DataTip pin" src="img/B22218_02_23.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.23 – The DataTip pin
    
   </p>
   <p>
    
     In this example, I pin
    
    <a id="_idIndexMarker157">
    </a>
    
     the
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     properties of the product so we can monitor its behavior during the execution of
    
    
     
      our loop.
     
    
   </p>
   <h3>
    
     Editing value
    
   </h3>
   <p>
    
     DataTips enables us
    
    <a id="_idIndexMarker158">
    </a>
    
     to edit the values of non-read-only variables, which can be useful for validating certain scenarios.
    
    
     To do this, we simply click on the value of the properties to
    
    
     
      update it.
     
    
   </p>
   <div><div><img alt="Figure 2.24 – Editing value on DataTips" src="img/B22218_02_24.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.24 – Editing value on DataTips
    
   </p>
   <p>
    
     DataTips also allows us to edit the values of our non-read-only variables, which can be useful for validating certain scenarios.
    
    
     This feature is also available in the
    
    <strong class="bold">
     
      Watch
     
    </strong>
    
     window, although it is not present in the
    
    <strong class="bold">
     
      Local
     
    </strong>
    
     or
    
    
     <strong class="bold">
      
       Autos
      
     </strong>
    
    
     
      windows.
     
    
   </p>
   <p>
    
     While meticulous debugging practices within our own code are crucial, sometimes the true culprit lies hidden within external components.
    
    
     Understanding their behavior is the key to unlocking elusive
    
    <a id="_idIndexMarker159">
    </a>
    
     bugs and crafting truly robust solutions.
    
    
     Let’s explore how Visual Studio, starting from version 17.7, assists us in
    
    
     
      this endeavor.
     
    
   </p>
   <h1 id="_idParaDest-46">
    <a id="_idTextAnchor046">
    </a>
    
     Elevating debugging with auto-decomplication and External Sources
    
   </h1>
   <p>
    
     Visual Studio 2022 has significantly enhanced the debugging experience with the introduction of auto-decompilation and External Sources.
    
    
     These features allow developers to debug external code, such as .NET libraries
    
    <a id="_idIndexMarker160">
    </a>
    
     or
    
    <strong class="bold">
     
      NuGet
     
    </strong>
    
     packages, with the same ease as their
    
    
     
      own code.
     
    
   </p>
   <h2 id="_idParaDest-47">
    <a id="_idTextAnchor047">
    </a>
    
     Auto-decompilation
    
   </h2>
   <p>
    
     Auto-decompilation
    
    <a id="_idIndexMarker161">
    </a>
    
     is a feature that transforms compiled binary code into a higher-level programming language, such as C#, allowing us to examine, troubleshoot, and fix issues in external code as if they were working with their own code.
    
    
     This is particularly useful for debugging scenarios where the source code is not available or when we need to inspect code from a
    
    
     
      third-party library.
     
    
   </p>
   <h3>
    
     How auto-decompilation works
    
   </h3>
   <p>
    
     The debugger
    
    <a id="_idIndexMarker162">
    </a>
    
     uses
    
    <a id="_idIndexMarker163">
    </a>
    
     the
    
    <strong class="bold">
     
      ILspy
     
    </strong>
    
     decompiler engine to decompile external code in real time and incorporate it into the debugging session.
    
    
     The debugger first looks for local external sources on our machine, then uses
    
    <strong class="bold">
     
      Source Link
     
    </strong>
    
     or
    
    <strong class="bold">
     
      Source Server
     
    </strong>
    
     information
    
    <a id="_idIndexMarker164">
    </a>
    
     from
    
    <a id="_idIndexMarker165">
    </a>
    
     PDB files to load the source code.
    
    
     If these methods fail, the debugger falls back to decompiling
    
    
     
      the code.
     
    
   </p>
   <h3>
    
     Controlling auto-decompilation
    
   </h3>
   <p>
    
     .NET package
    
    <a id="_idIndexMarker166">
    </a>
    
     authors could, in the past, control whether their code could be decompiled by implementing the
    
    <strong class="source-inline">
     
      SuppressIldasmAttribute
     
    </strong>
    
     attribute.
    
    
     Although this attribute is obsolete as of .NET 6+, Visual Studio still
    
    
     
      honors it.
     
    
   </p>
   <h3>
    
     Limitations of auto-decompilation
    
   </h3>
   <p>
    
     There can be issues
    
    <a id="_idIndexMarker167">
    </a>
    
     when trying to decompile .NET assemblies, such as inaccurate variable names or unavailable variables for evaluation.
    
    
     These limitations can be more pronounced when debugging optimized or
    
    
     
      release assemblies.
     
    
   </p>
   <h2 id="_idParaDest-48">
    <a id="_idTextAnchor048">
    </a>
    
     External Sources
    
   </h2>
   <p>
    
     The External Sources feature in
    
    <a id="_idIndexMarker168">
    </a>
    
     Visual Studio allows us to debug and step into code from dependent NuGet or .NET libraries that are not part of our solution.
    
    
     This is facilitated by the addition of an External Sources node in
    
    <strong class="bold">
     
      Solution Explorer
     
    </strong>
    
     , which appears during debugging and shows sources for managed modules with loaded symbols containing Source Link or Source
    
    
     
      Server information.
     
    
   </p>
   <p>
    
     We can find them below the top node of our solution in
    
    
     <strong class="bold">
      
       Solution Explorer
      
     </strong>
    
    
     
      :
     
    
   </p>
   <div><div><img alt="Figure 2.25 – External Sources nodes" src="img/B22218_02_25.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.25 – External Sources nodes
    
   </p>
   <p>
    
     Here’s a comprehensive guide on utilizing
    
    
     
      this feature:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Using External Sources
      
     </strong>
     
      : The External
     
     <a id="_idIndexMarker169">
     </a>
     
      Sources node organizes decompiled external code modules from different call stacks, allowing us to navigate and set breakpoints within this external code.
     
     
      This makes debugging external code as seamless as debugging our
     
     
      
       own code.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Enabling External Sources
      
     </strong>
     
      : To debug external sources, we may need to enable
     
     <strong class="bold">
      
       Load All Modules
      
     </strong>
     
      to allow the debugger to load symbols for all modules.
     
     
      We can also manually load modules from the
     
     <strong class="bold">
      
       Modules
      
     </strong>
     
      window if necessary from the top bar menu by going to
     
     <strong class="bold">
      
       Debug
      
     </strong>
     
      |
     
     <strong class="bold">
      
       Window
      
     </strong>
     
      |
     
     
      <strong class="bold">
       
        Modules
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     <strong class="bold">
      
       Downloading source code
      
     </strong>
     
      : If we double-click an item in the External Sources node, we may be prompted to download the source from the server.
     
     
      After accepting, we
     
     <a id="_idIndexMarker170">
     </a>
     
      can view the source code in
     
     
      
       the editor.
      
     
    </li>
   </ul>
   <p>
    
     Auto-decompilation and External Sources make it easier for us to debug external code, which can be particularly beneficial when dealing with complex libraries or when trying to resolve issues in third-party code.
    
    
     These features streamline our debugging process, reducing the time we spend on understanding and navigating external code.
    
    
     Package authors can prevent their code from being decompiled by using the
    
    <strong class="source-inline">
     
      SuppressIldasmAttribute
     
    </strong>
    
     attribute, ensuring that they maintain control over their intellectual property.
    
    
     However, debugging decompiled code may not always be as accurate as debugging source code, with potential issues such as inaccurate variable names or unavailable variables.
    
    
     Additionally, stepping through decompiled code may not always align with the original
    
    
     
      source code.
     
    
   </p>
   <p>
    
     By leveraging these
    
    <a id="_idIndexMarker171">
    </a>
    
     features, Visual Studio 2022 offers a more comprehensive debugging experience, enabling us to diagnose and resolve issues in their applications
    
    
     
      more effectively.
     
    
   </p>
   <h1 id="_idParaDest-49">
    <a id="_idTextAnchor049">
    </a>
    
     Concurrency debugging
    
   </h1>
   <p>
    
     Multithreading is
    
    <a id="_idIndexMarker172">
    </a>
    
     a technique
    
    <a id="_idIndexMarker173">
    </a>
    
     whereby a process splits into multiple threads, allowing for better performance, especially on systems with multiple processors or cores.
    
    
     However, managing multiple threads can be challenging as they may need to access shared resources concurrently, leading to potential bugs such as deadlocks where threads are unable to progress.
    
    
     Debugging such issues can be difficult
    
    
     
      and time-consuming.
     
    
   </p>
   <p>
    
     In this section, we will learn how to tackle this by using the
    
    <strong class="bold">
     
      Threads
     
    </strong>
    
     window and handling
    
    
     
      parallel debugging.
     
    
   </p>
   <p>
    
     For this, we will create a simple console application calling ten simple threads.
    
    
     Here’s the code we will use for our
    
    
     
      example :
     
    
   </p>
   <pre class="source-code">
for (int i = 0; i &lt; 10; i++)
{
    CreateThreads();
}
static void CreateThreads()
{
    Dummy dummy = new Dummy();
    Thread dummyCaller = new Thread(
        new ThreadStart(dummy.Instance)
    );
    dummyCaller.Start();
    Console.WriteLine("New thread called "
        + "starting the new Dummy thread.");
}
public class Dummy
{
    static int count = 0;
    public void Instance()
    {
        Console.WriteLine(
            "Dummy.Instance is running on another
            thread.");
        int data = count++;
        Thread.Sleep(3000);
        Console.WriteLine(
            "The instance method called by the worker
            thread has ended. " + data);
    }
}</pre>
   <p>
    
     The code
    
    <a id="_idIndexMarker174">
    </a>
    
     demonstrates the creation and execution of multiple threads in C#, each running an instance of a
    
    <strong class="source-inline">
     
      Dummy
     
    </strong>
    
     class’s
    
    
     <strong class="source-inline">
      
       Instance
      
     </strong>
    
    
     
      method.
     
    
   </p>
   <p>
    
     First, we will set a breakpoint on
    
    <strong class="source-inline">
     
      Thread.Sleep(3000)
     
    </strong>
    
     on the
    
    <strong class="source-inline">
     
      Instance
     
    </strong>
    
     method and launch our project in
    
    
     
      debug mode.
     
    
   </p>
   <p>
    
     We can track the thread by activating the
    
    <strong class="bold">
     
      Show Threads in Source
     
    </strong>
    
     button on the
    
    
     
      debug toolbar.
     
    
   </p>
   <div><div><img alt="Figure 2.26 – Show Threads in Source" src="img/B22218_02_26.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.26 – Show Threads in Source
    
   </p>
   <p>
    
     That will
    
    <a id="_idIndexMarker175">
    </a>
    
     make
    
    <strong class="bold">
     
      thread maker icons
     
    </strong>
    
     appear on the left side of the window.
    
    
     When we hover over them, we can view the name and thread ID number for each
    
    
     
      stopped thread.
     
    
   </p>
   <div><div><img alt="Figure 2.27 – List of threads" src="img/B22218_02_27.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.27 – List of threads
    
   </p>
   <p>
    
     By right-clicking on one of the threads, we can access different types of action to navigate through the threads, such as
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     
      <strong class="bold">
       
        Flag
       
      </strong>
     
     
      
       /
      
     
     
      <strong class="bold">
       
        Unflag
       
      </strong>
     
    </li>
    <li>
     
      <strong class="bold">
       
        Freeze
       
      </strong>
     
     
      
       /
      
     
     
      <strong class="bold">
       
        Thraw
       
      </strong>
     
    </li>
    <li>
     <strong class="bold">
      
       Switch
      
     </strong>
     
      <strong class="bold">
       
        To Thread
       
      </strong>
     
    </li>
   </ul>
   <div><div><img alt="Figure 2.28 – Manipulating threads" src="img/B22218_02_28.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.28 – Manipulating threads
    
   </p>
   <p>
    
     When we flag threads, it
    
    <a id="_idIndexMarker176">
    </a>
    
     enables us to focus on one thread while ignoring
    
    
     
      the others.
     
    
   </p>
   <p>
    
     To resolve concurrency issues and control the order in which threads perform work, we must use the
    
    <strong class="bold">
     
      Freeze
     
    </strong>
    
     and
    
    <strong class="bold">
     
      Thraw
     
    </strong>
    
     features, allowing us to suspend and
    
    
     
      resume threads.
     
    
   </p>
   <p>
    
     Additionally,
    
    <strong class="bold">
     
      Switch To Thread
     
    </strong>
    
     allows us to jump from one thread to another for
    
    
     
      step-by-step debugging.
     
    
   </p>
   <p>
    
     Regarding the common debugging process, Visual Studio offers a
    
    <strong class="bold">
     
      Watch
     
    </strong>
    
     window named
    
    <strong class="bold">
     
      Parallel Watch
     
    </strong>
    
     .
    
    
     We access it from the top bar menu by clicking on
    
    <strong class="bold">
     
      Debug
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Window
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Parallel Watch
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Parallel
     
    </strong>
    
     <strong class="bold">
      
       Watch 1
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 2.29 – Parallel Watch" src="img/B22218_02_29.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.29 – Parallel Watch
    
   </p>
   <p>
    
     Here, we can add
    
    <a id="_idIndexMarker177">
    </a>
    
     data to watch by entering their names in the
    
    <strong class="bold">
     
      &lt;Add Watch&gt;
     
    </strong>
    
     cell.
    
    
     Additionally, we can easily switch to a thread by double-clicking on the thread line we are interested in.
    
    
     Right-clicking allows us to access the
    
    <strong class="bold">
     
      Flag
     
    </strong>
    
     and
    
    <strong class="bold">
     
      Freeze
     
    </strong>
    
     features.
    
    
     The flag button in the top left corner enables us to filter and display only the
    
    
     
      flagged threads.
     
    
   </p>
   <p>
    
     Another view offered by Visual Studio to efficiently track threads is the
    
    <strong class="bold">
     
      Parallel Stacks
     
    </strong>
    
     window.
    
    
     To access it, we use the debug menu, which you can reach by clicking
    
    <strong class="bold">
     
      Debug
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Window
     
    </strong>
    
     |
    
    
     <strong class="bold">
      
       Parallel Stacks
      
     </strong>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 2.30 – Parallel Stacks" src="img/B22218_02_30.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.30 – Parallel Stacks
    
   </p>
   <p>
    
     This window provides both a
    
    <strong class="bold">
     
      Thread
     
    </strong>
    
     and a
    
    <strong class="bold">
     
      Tasks
     
    </strong>
    
     view, showing the call stack information for each thread.
    
    
     The current thread is indicated by a yellow arrow, allowing us to easily follow the path of each thread.
    
    
     This information can also be viewed in a list format in the
    
    <strong class="bold">
     
      Threads
     
    </strong>
    
     window by going to
    
    <strong class="bold">
     
      Debug
     
    </strong>
    
     |
    
    <strong class="bold">
     
      Windows
     
    </strong>
    
     |
    
    
     <strong class="bold">
      
       Threads
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     Finally, we can utilize conditional breakpoints, which allow us to set breakpoints based on various conditions, such as the thread name or ID.
    
    
     This feature is particularly handy when setting conditions on data unique to each thread.
    
    
     It’s a common approach during debugging, especially when focusing on specific data values rather than
    
    
     
      individual threads.
     
    
   </p>
   <p>
    
     Now that we have gone
    
    <a id="_idIndexMarker178">
    </a>
    
     on a journey exploring the techniques and tools of Visual Studio 2022 concerning debugging, let’s see how we can resolve the famous “it works on my laptop” issues by leveraging the remote
    
    
     
      debugging feature.
     
    
   </p>
   <h1 id="_idParaDest-50">
    <a id="_idTextAnchor050">
    </a>
    
     Remote debugging
    
   </h1>
   <p>
    
     Remote debugging is
    
    <a id="_idIndexMarker179">
    </a>
    
     a powerful feature in Visual Studio that allows us to debug applications running on different machines, devices, or environments.
    
    
     This is particularly useful when we need to troubleshoot issues that occur in a production environment or on a different platform that we don’t have access
    
    
     
      to locally.
     
    
   </p>
   <p>
    
     To leverage this functionality effectively, we need to ensure that Visual Studio is installed on both the local and remote machines.
    
    
     We need to configure the remote machine by installing the compatible Visual Studio version and allowing remote connections via the
    
    
     
      firewall settings.
     
    
   </p>
   <p>
    
     On the local machine, we enable remote debugging in Visual Studio’s settings by specifying the remote machine’s address and credentials, if necessary.
    
    
     To do so, we go to the project properties of the application we want to debug and navigate to the
    
    
     <strong class="bold">
      
       Debug
      
     </strong>
    
    
     
      tab.
     
    
   </p>
   <div><div><img alt="Figure 2.31 – The Project properties | Debug tab" src="img/B22218_02_31.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.31 – The Project properties | Debug tab
    
   </p>
   <p>
    
     Here, we can click on
    
    <a id="_idIndexMarker180">
    </a>
    
     the
    
    <strong class="bold">
     
      Open debug launch profiles UI
     
    </strong>
    
     link.
    
    
     Once in the
    
    <strong class="bold">
     
      Launch Profiles
     
    </strong>
    
     window, we can check the
    
    <strong class="bold">
     
      Use remote machine
     
    </strong>
    
     checkbox that displays the two more fields that allow us to configure the
    
    
     
      remote connection:
     
    
   </p>
   <div><div><img alt="Figure 2.32 – The Use remote machine checkbox" src="img/B22218_02_32.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 2.32 – The Use remote machine checkbox
    
   </p>
   <p>
    
     In a critical situation wherein debugging a web application on a live production server, it’s becomes essential to be able to access to the debugger on
    
    
     
      production server.
     
    
   </p>
   <p>
    
     Deploy the application to the production server, ensuring that all necessary components are installed.
    
    
     After that, we need to configure Visual Studio on the server for remote debugging and adjust the firewall settings accordingly.
    
    
     In Visual Studio on the local machine, we attach
    
    <a id="_idIndexMarker181">
    </a>
    
     to the remote process by entering the remote machine’s address
    
    
     
      and credentials.
     
    
   </p>
   <p>
    
     Then we can debug the application, select the process for the web application, and debug as usual, including setting breakpoints and inspecting variables.
    
    
     Finally, we can reproduce the issue while debugging, fix it once it has been identified, and deploy the
    
    
     
      updated application.
     
    
   </p>
   <p>
    
     Remote debugging facilitates diagnosing issues in production-like environments without disrupting live traffic.
    
    
     Accessing production data aids in understanding the issue’s context.
    
    
     Security measures should be implemented to safeguard sensitive information.
    
    
     Be mindful of performance impacts, scheduling debugging during off-peak times or in staging environments.
    
    
     Utilizing remote debugging enhances application reliability by addressing issues in environments inaccessible through traditional means, bolstering overall quality
    
    
     
      and stability.
     
    
   </p>
   <p>
    
     By using remote debugging, we can effectively diagnose and fix issues that occur in environments where
    
    <a id="_idIndexMarker182">
    </a>
    
     we don’t have direct access to the code or data, thereby improving the reliability and quality of
    
    
     
      our applications.
     
    
   </p>
   <h1 id="_idParaDest-51">
    <a id="_idTextAnchor051">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     This chapter delved into the powerful world of advanced debugging strategies in Visual Studio 2022, equipping you with the skills to tackle even the most complex code effectively.
    
    
     We explored various debugging tools and techniques that are essential for identifying and resolving issues in
    
    
     
      your code.
     
    
   </p>
   <p>
    
     We began by mastering the art of navigating your code, where we focused on breakpoints, step execution modes, and the call stack, all of which are crucial for pinpointing the source of errors.
    
    
     The chapter also introduced the concept of live code modification, allowing you to dynamically fix bugs and experiment with code changes on the fly through features like Edit and Continue and Hot Reload.
    
    
     We didn’t stop at debugging your own code; we also explored the advantages of auto-decompilation and External Sources, which enable seamless debugging of external libraries and NuGet packages.
    
    
     Furthermore, the chapter covered remote debugging, a technique that allows you to diagnose and fix issues in production-like environments without impacting live traffic.
    
    
     By mastering these advanced debugging techniques, you can resolve complex bugs more quickly, thereby reducing development time
    
    
     
      and frustration.
     
    
   </p>
   <p>
    
     In the next chapter, we’ll continue our journey according to the TDD cycle seen in the first chapter.
    
    
     After fixing our code with debugging, we’ll delve into the art of shaping our code into its best form.
    
    
     We’ll be embarking on a journey of advanced code analysis and refactoring in Visual
    
    
     
      Studio 2022.
     
    
   </p>
  </div>
 </body></html>