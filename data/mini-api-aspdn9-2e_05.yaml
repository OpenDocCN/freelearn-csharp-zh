- en: '5'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '5'
- en: The Middleware Pipeline
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件管道
- en: APIs are collections of commands that can be triggered on request. When a request
    is received, we can execute logic that is bespoke to the use case of that request.
    However, a request does not instantly hit our endpoints as soon as it is received.
    There is a pipeline that is first traversed before our logic can be executed and
    the request is eventually returned to the client. This pipeline is called the
    middleware pipeline, and it is a feature set within ASP.NET that allows us to
    extend our APIs in a way that separates concerns, optimizes performance, and promotes
    reusability.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: API是一组可以在请求上触发的命令。当收到请求时，我们可以执行针对该请求用例定制的逻辑。然而，请求并不是在收到后立即击中我们的端点。在执行逻辑并将请求最终返回给客户端之前，必须首先遍历一个管道。这个管道被称为中间件管道，它是ASP.NET中的一个功能集，允许我们以分离关注点、优化性能和促进重用性的方式扩展我们的API。
- en: 'In this chapter, we are going to explore the following:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨以下内容：
- en: An introduction to middleware
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 中间件简介
- en: Configuring middleware pipelines
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 配置中间件管道
- en: Implementing custom middleware
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现自定义中间件
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You are encouraged to write and extend the code examples shown in this chapter
    to improve your practical understanding. However, if you wish to gain access to
    the source code, you can obtain it from the following GitHub link: [https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)
    .'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 鼓励您编写和扩展本章中展示的代码示例，以提高您的实际理解。然而，如果您希望获取源代码，可以从以下GitHub链接获取：[https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9](https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9)。
- en: An introduction to middleware
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 中间件简介
- en: '**Middleware** as a concept was introduced to ASP.NET in ASP.NET Core. Replacing
    the older HTTP pipeline model, which used HTTP modules and HTTP handlers, it offers
    a simpler and more flexible way to manage the way HTTP requests are handled by
    APIs.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: '**中间件**这一概念是在ASP.NET Core中引入到ASP.NET的。它取代了使用HTTP模块和HTTP处理程序的较老HTTP管道模型，提供了一种更简单、更灵活的方式来管理API处理HTTP请求的方式。'
- en: If you think of an API application as a pipeline with requests traveling through
    it, the concept becomes more straightforward.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将API应用程序想象为一个请求在其中传递的管道，那么这个概念就变得更加直接。
- en: Middleware is a component that sits on the pipeline before a request is handled
    by an endpoint. It is executed on every request and is part of a sequence, with
    components executing in the order in which they were registered.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是一个组件，它位于请求由端点处理之前的数据管道上。它会在每个请求上执行，并作为序列的一部分，组件按照它们注册的顺序执行。
- en: Each middleware component has a role to play, with the ability to affect the
    request irrespective of the endpoint it has requested. Each middleware component
    can be built in, such as routing, for example, or custom middleware, written for
    specific purposes such as logging or authentication, to name a couple.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 每个中间件组件都有其作用，能够影响请求，而不管它请求的是哪个端点。例如，中间件可以是内置的，如路由，或者为特定目的编写的自定义中间件，例如日志记录或身份验证，仅举几例。
- en: Once a middleware component has completed its work, it passes the request to
    the next middleware component in the pipeline, until all middleware components
    have been traversed. Then the request can hit the endpoint holding the code written,
    which has logic specific to that endpoint.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦中间件组件完成了其工作，它将请求传递给管道中的下一个中间件组件，直到所有中间件组件都被遍历。然后请求可以击中包含特定端点代码的端点，该端点具有针对该端点的特定逻辑。
- en: Middleware progression
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件进展
- en: It’s worth noting that while it is true that middleware components pass requests
    on to each other in a chain, they only do this unless there is a reason for the
    request to be terminated, with an exception being returned. Depending on the context,
    a middleware pipeline can end prematurely by design.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，虽然中间件组件确实以链的形式将请求传递给彼此，但只有在有理由终止请求并返回异常的情况下才会这样做。根据上下文，中间件管道可能会设计成提前结束。
- en: As you have seen in the previous chapters, endpoints must send some form of
    response to their clients. Once request handling has been completed, endpoints
    then send the response back to the client via the middleware pipeline, where it
    travels once again through each middleware component in reverse order.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 正如您在前几章中看到的，端点必须向其客户端发送某种形式的响应。一旦请求处理完成，端点随后通过中间件管道将响应发送回客户端，在这个过程中，它再次以相反的顺序通过每个中间件组件。
- en: 'Here is a visualization of an example request pipeline:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个示例请求管道的可视化：
- en: '![Figure 5.1: An example middleware pipeline flow](img/B20968_05_01.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图5.1：一个示例中间件管道流程](img/B20968_05_01.jpg)'
- en: 'Figure 5.1: An example middleware pipeline flow'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.1：一个示例中间件管道流程
- en: Middleware is a very important aspect of not just minimal APIs but ASP.NET in
    general, with widespread use in web API and MVC projects. It provides developers
    with a way of registering custom behavior at the application level, as a design
    pattern that decouples this behavior from endpoint-specific logic.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件不仅是最小API，而且是ASP.NET的一般重要方面，在Web API和MVC项目中得到广泛应用。它为开发者提供了一种在应用级别注册自定义行为的方式，作为一种将此行为与端点特定逻辑解耦的设计模式。
- en: For example, there are certain logs that might need to be captured every time
    a request is received. This could be a log stating that a resource such as a SQL
    database was accessed as part of a request, or an error log if the request should
    not have been made.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，可能需要捕获每次收到请求时的一些日志。这可能是一条日志，说明资源（如SQL数据库）作为请求的一部分被访问，或者是一条错误日志，如果请求本不应该被发起。
- en: It would be inefficient to include the logging code in every endpoint as they
    are written, and the developer would have to remember to include the logic to
    capture the log message. This is, as you can imagine, not sustainable and is a
    violation of the **don’t repeat yourself** ( **DRY** ) principle. Using a logging
    middleware component means that the required log messages will be captured every
    time a request is received, and it only has to be configured once.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 将日志代码包含在每个端点中，在它们被编写时，这将是低效的，并且开发者必须记住包含捕获日志消息的逻辑。正如你可以想象的那样，这是不可持续的，并且违反了**不要重复自己**（**DRY**）原则。使用日志中间件组件意味着所需的日志消息将在每次收到请求时被捕获，并且只需要配置一次。
- en: This is not to say that middleware components *must* be general in their execution.
    They are classes or methods like any other and have access to the incoming request
    in the form of an **HttpContext** object. As a result, they can scrutinize the
    request just like an endpoint can and execute any custom logic applicable to that
    request before the endpoint is reached.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这并不是说中间件组件在执行时*必须*是通用的。它们和其他类或方法一样，可以以**HttpContext**对象的形式访问传入的请求。因此，它们可以像端点一样审查请求，并在到达端点之前执行适用于该请求的任何自定义逻辑。
- en: 'Let’s look at a basic example of a middleware component that is created as
    a class. The component simply writes to the console before calling the next component
    in the sequence:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个作为类创建的中间件组件的基本示例。该组件在调用序列中的下一个组件之前简单地写入控制台：
- en: '[PRE0]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This middleware class has a constructor that receives an object of type **RequestDelegate**
    when the class is instantiated. This delegate is a representation of the next
    middleware component in the pipeline. The **_next()** delegate can be used to
    call the next middleware component and continue the sequence.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 当类被实例化时，这个中间件类有一个构造函数，它接收一个**RequestDelegate**类型的对象。这个委托代表了管道中的下一个中间件组件。可以使用**_next()**委托来调用下一个中间件组件并继续序列。
- en: Understanding how the pipeline passes control flow between each component is
    critical, but it’s worth nothing if we don’t know how to build our own components.
    We’ll now move on to explore how you can create and configure middleware within
    your pipeline.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 理解管道如何在每个组件之间传递控制流是至关重要的，但如果我们不知道如何构建自己的组件，那么这就没有意义。现在，我们将继续探讨如何在您的管道中创建和配置中间件。
- en: Configuring middleware pipelines
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 配置中间件管道
- en: You can structure a middleware component in different ways depending on its
    purpose. The previous example demonstrated the creation of a simple middleware
    component using a class. Let’s explore this type of component in more detail before
    looking at other ways of building and registering them.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 根据其目的，您可以用不同的方式来构建中间件组件。前面的例子展示了使用类创建一个简单的中间件组件。在查看其他构建和注册中间件的方法之前，让我们更详细地探讨这种类型的组件。
- en: Middleware classes
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 中间件类
- en: Middleware classes need to have an **Invoke** or **InvokeAsync** method so that
    they can be triggered when it is their turn. Notice how, in the example we saw
    in the previous section, we have a method called **_next()** , passing in the
    **HttpContext** object that the same method received. This is where the middleware
    component calls the next component in the pipeline.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件类需要有一个**Invoke**或**InvokeAsync**方法，以便在轮到它们时被触发。注意，在前一节中我们看到的示例中，有一个名为**_next()**的方法，传递了与同一方法接收到的相同的**HttpContext**对象。这就是中间件组件调用管道中下一个组件的地方。
- en: Once you’ve created a middleware component, you will need to add it to the pipeline.
    In a minimal API, the setup of the API takes place in **Program.cs** , with the
    creation of a **WebApplication** object.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建了中间件组件，就需要将其添加到管道中。在最小化API中，API的设置发生在**Program.cs**文件中，创建**WebApplication**对象。
- en: 'Remember in the previous chapters when we created an instance of **WebApplication**
    and called it **app** ? This **app** object has a method called **UseMiddleware<T>()**
    . This allows us to tell the **WebApplication** object that it should use a middleware
    component of a specific type. If we wanted to register our **MySuperSimpleMiddleware**
    class as middleware, we would do it before we start the **WebApplication** object
    with **app.Run()** :'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 记得在之前的章节中，当我们创建了一个名为**app**的**WebApplication**实例吗？这个**app**对象有一个名为**UseMiddleware<T>()**的方法。这允许我们告诉**WebApplication**对象它应该使用特定类型的中间件组件。如果我们想将我们的**MySuperSimpleMiddleware**类注册为中间件，我们会在使用**app.Run()**启动**WebApplication**对象之前完成它：
- en: '[PRE1]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that the middleware has been added to our **WebApplication** object. it
    will be invoked within the pipeline.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 现在中间件已经被添加到我们的**WebApplication**对象中，它将在管道中被调用。
- en: Writing middleware in a class has its advantages and disadvantages. On one hand,
    it might make sense to use a class to be keep middleware tidy and decoupled from
    the **WebApplication** object. You might also want to use a factory design pattern
    to produce and register appropriate middleware classes. On the other hand, the
    use of a class may be overkill. After all, we are building *minimal APIs* , where,
    most of the time, it is favorable to keep logic small and simple.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在类中编写中间件有其优点和缺点。一方面，使用类来保持中间件的整洁并使其与**WebApplication**对象解耦可能是有意义的。你也可能想使用工厂设计模式来生成和注册适当的中间件类。另一方面，使用类可能过于复杂。毕竟，我们正在构建*最小化API*，在这种情况下，大多数时候保持逻辑简单是有利的。
- en: In the spirit of minimalism, there is an alternative to middleware classes in
    the form of inline middleware.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在简约主义的精神下，存在一种替代中间件类的形式，即内联中间件。
- en: Inline middleware
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内联中间件
- en: This is a lot simpler than using classes. When creating middleware inline, we
    create and register the component with our **WebApplication** object in one block
    of code. Once again, considering our instance of **WebApplication** called **app**
    , we will still be passing in an **HTTPContext** object and **RequestDelegate**
    object, but instead of a constructor, private field, and **InvokeAsync()** method,
    everything will happen inside the body of the endpoint.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 这比使用类简单得多。当内联创建中间件时，我们将在一个代码块中创建并注册组件到我们的**WebApplication**对象。再次考虑到我们的**WebApplication**实例称为**app**，我们仍然会传递一个**HTTPContext**对象和一个**RequestDelegate**对象，但与构造函数、私有字段和**InvokeAsync()**方法不同，所有操作都将发生在端点的主体内部。
- en: 'Let’s look at how we could rewrite **MySuperSimpleMiddlewareClass** into an
    inline middleware component:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何将**MySuperSimpleMiddlewareClass**重写为内联中间件组件：
- en: '[PRE2]'
  id: totrans-42
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: In this example, we add **app.UseMiddleware<MySuperSimpleMiddlewareClass>()**
    with the much more generic **app.Use()** . Instead of specifying a type, we are
    now passing an asynchronous anonymous function that will be registered to the
    pipeline. The body of the lambda expression shown in the example is the equivalent
    of **InvokeAsync()** found within **MySuperSimpleMiddlewareClass** .
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们添加了**app.UseMiddleware<MySuperSimpleMiddlewareClass>()**，并用更通用的**app.Use()**代替。现在，我们不再指定类型，而是传递一个异步匿名函数，该函数将被注册到管道中。示例中展示的lambda表达式的主体相当于在**MySuperSimpleMiddlewareClass**中找到的**InvokeAsync()**方法。
- en: Just like before, we are writing a console message on the incoming request,
    followed by a call to the **RequestDelegate** , object which passes to the next
    component. We then have another console message, which will be executed on the
    request response as it travels back through the pipeline on its way to the client.
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 就像之前一样，我们在传入的请求上写入控制台消息，然后调用**RequestDelegate**对象，该对象将传递给下一个组件。然后我们又有另一个控制台消息，它将在请求响应作为它通过管道返回客户端的过程中执行。
- en: The beauty of registering middleware inline is its consistency with the endpoints
    you create. If you were to register small middleware components in this way, before
    constructing endpoints by mapping them onto the **WebApplication** object, your
    project would indeed be minimal in the way minimal APIs were designed to be.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 注册中间件的内联之美在于它与创建的端点的连贯性。如果你以这种方式注册小的中间件组件，在将它们映射到**WebApplication**对象之前构建端点，你的项目确实会是最小化API设计所期望的那样。
- en: We have covered the basics of configuring pipelines in the previous section,
    but there are some pitfalls that you should be aware of to ensure you are getting
    the benefits of middleware.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一节中介绍了配置管道的基本知识，但有一些陷阱你应该注意，以确保你能从中获得中间件的好处。
- en: Maintaining order
  id: totrans-47
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 维护顺序
- en: As we discussed in the first part of the chapter, middleware resides as a sequence
    of components within a pipeline in which a request travels between the client
    and server.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在本章的第一部分所讨论的，中间件作为请求在客户端和服务器之间传递的管道中的组件序列而存在。
- en: This sequence of components is linear, meaning that the order in which individual
    components are executed is critical, depending on their respective goals.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件的序列是线性的，这意味着各个组件执行顺序至关重要，这取决于它们各自的目标。
- en: The order of execution is determined by the order in which the components are
    registered, and how they are registered is determined by the way they are constructed
    – that is, class-based or as inline middleware.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 执行顺序由组件注册的顺序决定，以及它们是如何注册的——即基于类或内联中间件。
- en: Each of these components can modify the request and the response within the
    pipeline. As you can imagine, this makes it easy to produce unexpected results
    if caution is not taken. For example, as part of your pipeline, you may need to
    add a field to the payload. This is fine, but if you have another middleware component
    within the pipeline that references that new field, you have created a dependency
    between components.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件中的每一个都可以在管道中对请求和响应进行修改。正如你可以想象的那样，如果不小心谨慎，这会很容易产生意外的结果。例如，作为你的管道的一部分，你可能需要向有效载荷中添加一个字段。这是可以的，但如果管道中还有其他引用该新字段的中间件组件，你就已经在组件之间创建了一个依赖关系。
- en: If the component that references the new field was to be registered before the
    component that created it, the pipeline would hit an exception because a property
    that does not yet exist will have been referenced.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果引用新字段的组件在创建它的组件之前注册，管道将遇到异常，因为尚未存在的属性已被引用。
- en: Therefore, when writing middleware, it is essential that you verify that the
    request is hitting each component in the correct order.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在编写中间件时，验证请求是否按正确的顺序击中每个组件是至关重要的。
- en: Go ahead and run the project containing these middleware examples. You will
    see the order in which the middleware is executing in the logs shown in the **Output**
    tab accessible from the bottom left of the window in Visual Studio.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 前往运行包含这些中间件示例的项目。你将在从窗口左下角可访问的**输出**选项卡中看到的日志中看到中间件执行的顺序。
- en: Default middleware
  id: totrans-55
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 默认中间件
- en: There are built-in middleware components that ASP.NET automatically registers
    for minimal API projects depending on the way they have been configured.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 根据配置方式，ASP.NET会自动为最小API项目注册内置的中间件组件。
- en: If the hosting environment is set to **Development** , **UseDeveloperExceptionPage**
    middleware will be registered. This component displays a page showing error responses
    from the pipeline when they occur, which is very useful for debugging.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如果托管环境设置为**开发**，将注册**UseDeveloperExceptionPage**中间件。该组件在发生错误响应时显示一个页面，这对于调试非常有用。
- en: The routing that we depend on and worked with in the previous chapter is itself
    a middleware. It is added automatically by ASP.NET if endpoints exist. ASP.NET
    will not add it automatically if you add **UseRouting()** manually.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在上一章中依赖并使用的路由本身就是一个中间件。如果存在端点，ASP.NET 会自动添加它。如果你手动添加了 **UseRouting()**，ASP.NET
    不会自动添加它。
- en: After **UseRouting** , ASP.NET will also add **UseAuthentication** if **IAuthenticationSchemeProvider**
    is detected in the service provider. Like **UseRouting** , if you add the component
    manually, ASP.NET will skip adding **UseAuthentication** . The same is true for
    **UseAuthorization()** with **IAuthorizationSchemeProvider** . Most default middleware
    will not be noticed by the developer unless there is a need to override it.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **UseRouting** 之后，如果服务提供程序中检测到 **IAuthenticationSchemeProvider**，ASP.NET 也会添加
    **UseAuthentication**。与 **UseRouting** 类似，如果你手动添加组件，ASP.NET 将跳过添加 **UseAuthentication**。对于与
    **IAuthorizationSchemeProvider** 一起使用的 **UseAuthorization()** 也是如此。大多数默认中间件除非需要覆盖它，否则通常不会被开发者注意到。
- en: Now that we’ve explored middleware as a concept, we should move on to discuss
    how we can extend minimal APIs by writing our own custom middleware.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '现在我们已经探讨了中间件作为一个概念，我们应该继续讨论如何通过编写我们自己的自定义中间件来扩展最小 API。 '
- en: Implementing custom middleware
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现自定义中间件
- en: Custom middleware is any middleware component that either you have written yourself
    or is not part of the default middleware components registered by ASP.NET.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义中间件是指你自己编写的或不是由 ASP.NET 注册的默认中间件组件之一。
- en: Custom middleware affords us a lot of flexibility in the way we extend the functionality
    of our API outside of request endpoints.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义中间件为我们提供了很多灵活性，使我们能够在请求端点之外扩展 API 的功能。
- en: 'Some examples of custom middleware might be the following:'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 自定义中间件的几个示例可能如下：
- en: '**Logging middleware** : Capture events and store logs as requests are received'
  id: totrans-65
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**日志中间件**：在接收到请求时捕获事件并存储日志'
- en: '**Error-handling middleware** : Have specific ways that errors are treated
    within the pipeline'
  id: totrans-66
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**错误处理中间件**：在管道中有特定的错误处理方式'
- en: '**Validation middleware** : Check that data is in a specific state on receipt
    or response.'
  id: totrans-67
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**验证中间件**：检查数据在接收或响应时是否处于特定状态。'
- en: '**Request-timing middleware** : Record the time a request takes for the purposes
    of monitoring and telemetry'
  id: totrans-68
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**请求计时中间件**：记录请求的耗时，用于监控和遥测'
- en: '**IP-blocking middleware** : Check the IP address of the request’s remote host
    and check to see if it is in the ban list'
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**IP 阻止中间件**：检查请求的远程主机的 IP 地址，并检查它是否在禁止列表中'
- en: Let’s write some custom middleware using the example of logging. In this example,
    we’ll keep things simple and minimal by writing the middleware as an inline middleware
    component.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以日志为例编写一些自定义中间件。在这个例子中，我们将通过将中间件编写为内联中间件组件来保持简单和最小化。
- en: 'Open **Program.cs** and start by creating a new blank middleware component;
    that is to say, create a **Use()** method receiving an **HttpContext** object
    and a **RequestDelegate** object with nothing in the body of the accompanying
    lambda expression:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 打开 **Program.cs** 文件，首先创建一个新的空白中间件组件；也就是说，创建一个接收一个 **HttpContext** 对象和一个 **RequestDelegate**
    对象的 **Use()** 方法，并在伴随的 lambda 表达式的主体中不添加任何内容：
- en: '[PRE3]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Now we have a blank canvas for a simple middleware component, we can add some
    logic to log some content. In this example, we’re going to log the content to
    the console.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个简单的中间件组件的空白画布，我们可以添加一些逻辑来记录一些内容。在这个例子中，我们将记录内容到控制台。
- en: The question is, *what* do we want to log?
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 问题是，我们想要记录**什么**？
- en: The useful thing about having the request passed into the component as a **HttpContext**
    instance, is that we can access the individual properties of the request via this
    object. This means we can access the target HTTP method, the target route, and
    so on.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 将请求作为 **HttpContext** 实例传递到组件中的好处是，我们可以通过此对象访问请求的各个属性。这意味着我们可以访问目标 HTTP 方法、目标路由等。
- en: 'Let’s start by logging some content from the request as it is received, before
    passing the control flow on to the next component in the pipeline. To do this,
    update the body of the lambda expression so that it reflects this updated example
    here:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先记录一些从请求接收到的内容，然后再将控制流传递到管道中的下一个组件。为此，更新 lambda 表达式的主体，使其反映这里更新的示例：
- en: '[PRE4]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Now our middleware is accessing data from the request and using string interpolation,
    arranging the data into a string that can be logged to the console. This gives
    our API the benefit of being auditable (easy to track and review historical events)
    and easier to maintain. On top of this, because we’ve used a custom middleware,
    we’ve not had to repeat ourselves by writing the same log for each endpoint we
    create.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 现在中间件正在访问请求中的数据，并使用字符串插值，将数据排列成一个可以记录到控制台的字符串。这使得我们的API具有可审计性（易于跟踪和审查历史事件）并且更容易维护。除此之外，因为我们使用了自定义中间件，所以我们不需要为每个创建的端点重复编写相同的日志。
- en: Remember, the middleware components on the pipeline don’t just execute for the
    incoming request. The outgoing response also traverses the middleware pipeline
    in reverse on its way back to the client.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，管道上的中间件组件不仅为传入的请求执行。出站响应也会在返回客户端的过程中反向遍历中间件管道。
- en: 'If we wanted to log the contents of the response to the console as it travels
    back through the pipeline, we could simply add another **Console.WriteLine()**
    statement underneath our call to **next()** . The **Response** member of the **HttpContex**
    t object should provide us with up-to-date data for the outgoing response, which
    we can log, as in the example shown here:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们想在响应通过管道返回时将其内容记录到控制台，我们可以在调用 **next()** 下方简单地添加另一个 **Console.WriteLine()**
    语句。**HttpContex** t 对象的 **Response** 成员应为我们提供最新的出站响应数据，我们可以将其记录，如下例所示：
- en: '[PRE5]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'As a reminder, this was an inline middleware component, meaning that it was
    created using a lambda expression in **Program.cs** . For the sake of consistency,
    here is an example of how the same middleware component could be written in a
    class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 作为提醒，这是一个内联中间件组件，意味着它是使用 **Program.cs** 中的lambda表达式创建的。为了保持一致性，以下是如何以类的方式编写相同的中间件组件的示例：
- en: '[PRE6]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here is how the **Program** class would look after registering the class-based
    middleware:'
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 在注册基于类的中间件后，**Program** 类将呈现如下：
- en: '[PRE7]'
  id: totrans-85
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Logging is a straightforward example of middleware’s ability to take action
    before routes are hit. For more complex use cases, it might be necessary to **short-circuit**
    the pipeline. This would stop other components in the pipeline from executing
    and can be easily achieved by omitting the call to the **RequestDelegate** object.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是中间件在路由之前采取行动的简单示例。对于更复杂的使用案例，可能需要**短路**管道。这将阻止管道中的其他组件执行，可以通过省略对 **RequestDelegate**
    对象的调用轻松实现。
- en: Short-circuiting is simple enough, but what if our middleware has a level of
    complexity that means it might have to block routing from taking place? This would
    mean the middleware stops the request from reaching the intended endpoint, or
    any endpoints at all.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 短路操作足够简单，但如果我们的中间件具有复杂的程度，意味着它可能需要阻止路由发生，那会怎样？这意味着中间件会阻止请求到达目标端点，或者任何端点。
- en: To understand this concept further, we need to look at a style of middleware
    component called **terminal middleware** .
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 要进一步理解这个概念，我们需要查看一种名为**终端中间件**的中间件组件样式。
- en: Terminal middleware
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 终端中间件
- en: Classic middleware components such as the ones we have worked with in this chapter
    all have one thing in common – the requests that pass through them on the pipeline
    will eventually reach an endpoint, and then the endpoint will handle sending the
    requests back through the pipeline to the client.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中我们使用过的经典中间件组件都有一个共同点——在管道中通过它们的请求最终会到达一个端点，然后端点将处理将请求发送回管道到客户端。
- en: 'However, there are scenarios where we would not want a request to reach the
    endpoint. For example, if we had implemented a banned IP list, in which IP addresses
    for malicious or suspicious hosts were listed, we would want to achieve the following
    with middleware:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，有些情况下我们不想让请求到达端点。例如，如果我们实现了一个禁止IP列表，其中列出了恶意或可疑主机的IP地址，我们希望通过中间件实现以下目标：
- en: Identify the IP address of the remote host sending the request
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 识别发送请求的远程主机的IP地址
- en: Determine whether the IP address is on the list of banned IPs
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 确定IP地址是否在禁止IP列表中
- en: If it is a banned IP address, send a response back to the client from the middleware,
    stating that the host is forbidden from proceeding further
  id: totrans-94
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果是禁止的IP地址，从中间件向客户端发送响应，表明主机被禁止进一步操作
- en: Let’s write our own middleware component that checks incoming IP addresses and
    blocks the request from going any further if needed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们编写自己的中间件组件，该组件检查传入的IP地址，并在需要时阻止请求进一步进行。
- en: 'First, create a *scaffold* of a middleware class:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，创建一个中间件类的**scaffold**：
- en: '[PRE8]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: At the moment, our middleware doesn’t do anything, other than simply passing
    control to the next component in the pipeline.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，我们的中间件除了简单地传递控制权给管道中的下一个组件外，不做任何事情。
- en: 'Looking back at the three goals of our IP-blocking middleware, the first goal
    is to identify the IP address of the requesting host. This information can be
    retrieved from the **HttpContext** object as shown here:'
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 回顾我们IP阻止中间件的三个目标，第一个目标是识别请求主机的IP地址。此信息可以从**HttpContext**对象中检索，如下所示：
- en: '[PRE9]'
  id: totrans-100
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Next, we need to identify whether the requesting IP address is a banned IP.
    To do this, we need to add a collection to store the banned list, and then a check
    against the incoming IP address.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要确定请求的IP地址是否为被禁止的IP。为此，我们需要添加一个集合来存储禁止列表，然后对传入的IP地址进行检查。
- en: 'Add a private **HashSet<string>** field under the **RequestDelegate** field.
    We’ll use this as our banned list:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在**RequestDelegate**字段下添加一个私有的**HashSet<string>**字段。我们将使用这个作为我们的禁止列表：
- en: '[PRE10]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: This list can be passed to the middleware when it is registered via its constructor.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此列表可以在通过其构造函数注册时传递给中间件。
- en: 'Update the constructor to reflect this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 更新构造函数以反映这一点：
- en: '[PRE11]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Now all that remains is to act against the offending request. We can write
    messages into the response to the client via the **HttpContext** object. Here,
    we can include a message to inform the client that their IP address is blocked.
    Following this, we can use a **return** statement to stop the request in its tracks:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在剩下的只是对违规请求采取行动。我们可以通过**HttpContext**对象将消息写入客户端的响应。在这里，我们可以包括一条消息通知客户端他们的IP地址已被阻止。在此之后，我们可以使用**return**语句来阻止请求继续进行：
- en: '[PRE12]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Once all these changes have been added, we will have a fully functioning custom
    middleware class that is able to detect banned IP addresses for incoming requests
    and block them from reaching the endpoints we’ve configured.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦添加了所有这些更改，我们将拥有一个完全功能的自定义中间件类，能够检测到被禁止的IP地址，并阻止它们到达我们配置的端点。
- en: 'Your **IPBlockingMiddleware** class should now look like this:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 您的**IPBlockingMiddleware**类现在应该看起来像这样：
- en: '[PRE13]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'In the preceding middleware example, we have a constructor parameter in the
    form of a list of blocked IPs. This means that when registering the middleware
    in **Program.cs** , the list would have to be created beforehand, and then passed
    in during registration:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的中间件示例中，我们有一个以阻塞IP列表形式存在的构造函数参数。这意味着在**Program.cs**中注册中间件时，必须事先创建该列表，然后在注册时传递：
- en: '[PRE14]'
  id: totrans-113
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'You could test the **IPBlocking** functionality by adding the loopback address
    to the blacklist. This should return a response with a **403** status code:'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将回环地址添加到黑名单中来测试**IPBlocking**功能。这应该返回一个带有**403**状态码的响应：
- en: '[PRE15]'
  id: totrans-115
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Gradually, we’re starting to introduce more complex logic into our minimal API
    with custom and default middleware components. As complexity increases, so does
    the probability that errors will occur. As we know, all potential errors must
    be handled to maintain system continuity.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 逐渐地，我们开始在最小API中引入更多复杂的逻辑，使用自定义和默认中间件组件。随着复杂性的增加，错误发生的概率也在增加。正如我们所知，所有潜在的错误都必须得到处理，以保持系统连续性。
- en: Middleware can also be used to achieve this. Let’s explore how we can write
    a component that catches and handles unexpected behavior and errors that may occur
    within the pipeline.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件也可以用来实现这一点。让我们探索如何编写一个组件，它可以捕获和处理在管道中可能发生的意外行为和错误。
- en: Handling errors within the middleware pipeline
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在中间件管道中处理错误
- en: In this example, we will stick with a class-based middleware component structure,
    as it offers a clean structure with types that can be swapped out as needed. (This
    is more of a personal preference than good practice.)
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，我们将坚持使用基于类的中间件组件结构，因为它提供了一个干净的架构，其中的类型可以根据需要替换。（这更多的是个人偏好，而不是良好的实践。）
- en: A dedicated error handling component can be useful, as it ensures that you are
    always able to review and address errors as they occur, rather than facing the
    problematic and often embarrassing situation where an unhandled exception crashes
    the application completely.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 一个专门用于错误处理的组件可能很有用，因为它确保您始终能够审查和解决发生的错误，而不是面对问题重重且常常令人尴尬的情况，即未处理的异常导致应用程序完全崩溃。
- en: 'Here is an example of a basic exception-handling middleware component:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个基本的异常处理中间件组件的示例：
- en: '[PRE16]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Notice how, in this code, the **try catch** block in **InvokeAsync()** doesn’t
    do much at all in the **try** body. It simply passes execution to the next component.
    This is because this middleware will be the first component in the pipeline to
    be registered. It is the first because we are not interested in handling errors
    at the first component in the pipeline, but we are for all other components. By
    placing our logic in the **catch** body, any errors that happen later in the pipeline
    will *bubble up* to this component and be caught, allowing us to handle them and
    then update the response to the client accordingly.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这段代码中，**InvokeAsync()**中的**try catch**块在**try**主体中实际上并没有做很多事情。它只是将执行权传递给下一个组件。这是因为这个中间件将是管道中第一个注册的组件。它之所以是第一个，是因为我们对于管道中第一个组件不感兴趣处理错误，但我们对于所有其他组件都感兴趣。通过将我们的逻辑放在**catch**主体中，任何在管道中后来发生的错误都将*冒泡*到这个组件并被捕获，这样我们就可以处理它们，并相应地更新客户端的响应。
- en: It also covers us for the handling of any exceptions during the execution of
    middleware components on the return journey (the response) as the flow of execution
    is heading back toward this component. As the component was the first to be registered,
    it will be the last to execute on the return journey.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 它还涵盖了在返回旅程（响应）中执行中间件组件时出现的任何异常的处理。因为组件是第一个注册的，所以在返回旅程中将是最后一个执行的。
- en: In the **catch** statement, we can do whatever is needed to handle the exception.
    In this example, we simply write the value of the caught exception’s **Message**
    field to the console. Then we set the status code of the request to **500 INTERNAL
    SERVER ERROR** and write a message into the response. All of this happens via
    the **HttpContext** object that travels through the pipeline.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在**catch**语句中，我们可以执行任何必要的异常处理操作。在这个例子中，我们只是将捕获的异常的**Message**字段的值写入控制台。然后我们将请求的状态码设置为**500
    内部服务器错误**，并将消息写入响应。所有这些操作都是通过传递通过管道的**HttpContext**对象来完成的。
- en: 'If you wanted to force one of these exceptions to see an example of the output,
    you could create a dedicated example endpoint that simply throws an exception:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要强制其中一个异常以查看输出示例，你可以创建一个专门的示例端点，该端点简单地抛出一个异常：
- en: '[PRE17]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Calling this endpoint while in **Debug** mode will display the exception details
    in the browser.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在**调试**模式下调用此端点将在浏览器中显示异常详细信息。
- en: '![Figure 5.2: Exception details shown in the browser for debugging purposes](img/B20968_05_02.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_IMG
  zh: '![图5.2：浏览器中显示的异常详细信息，用于调试目的](img/B20968_05_02.jpg)'
- en: 'Figure 5.2: Exception details shown in the browser for debugging purposes'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 图5.2：浏览器中显示的异常详细信息，用于调试目的
- en: In this chapter, we’ve delved deep into the intricacies of middleware and pipeline
    customization in minimal APIs. By understanding the concepts and practical implementations
    of middleware, we’ve laid the groundwork for creating more robust, maintainable,
    and flexible API applications. Let’s summarize the key points and skills we’ve
    covered.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们深入探讨了中间件和管道定制在最小API中的复杂性。通过理解中间件的概念和实际实现，我们为创建更健壮、可维护和灵活的API应用程序奠定了基础。让我们总结一下我们覆盖的关键点和技能。
- en: Summary
  id: totrans-132
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we explored the essential role that middleware plays in the
    ASP.NET Core minimal APIs. Middleware components are pivotal in the request-response
    lifecycle, enabling developers to handle key areas of a system such as logging,
    authentication, error handling, and more.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这一章中，我们探讨了中间件在ASP.NET Core最小API中的基本作用。中间件组件在请求-响应生命周期中起着关键作用，使开发者能够处理系统的关键领域，如日志记录、身份验证、错误处理等。
- en: We started by introducing the concept of middleware and explaining how it fits
    into the overall architecture of minimal APIs. Middleware components act as intermediaries
    that can inspect, modify, or terminate HTTP requests and responses. This modular
    approach promotes a clean separation of concerns and enhances the maintainability
    of the application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先介绍了中间件的概念，并解释了它如何适应最小API的整体架构。中间件组件作为中介，可以检查、修改或终止HTTP请求和响应。这种模块化方法促进了关注点的清晰分离，并提高了应用程序的可维护性。
- en: Next, we delved into configuring middleware pipelines, illustrating how the
    order of middleware registration affects the processing of requests. Middleware
    components are executed in the order they are added to the pipeline, and the response
    travels back through the pipeline in reverse order. This sequential processing
    model is critical for ensuring that each middleware component functions correctly
    and efficiently.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们深入探讨了配置中间件管道，说明了中间件注册的顺序如何影响请求的处理。中间件组件按照它们被添加到管道中的顺序执行，响应则按照相反的顺序通过管道返回。这种顺序处理模型对于确保每个中间件组件正确且高效地运行至关重要。
- en: We then moved on to implementing custom middleware, providing examples such
    as logging and IP blocking. These examples demonstrated how custom middleware
    can be tailored to meet specific application requirements.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们转向了自定义中间件的实现，提供了例如日志记录和IP封禁的示例。这些示例展示了如何定制自定义中间件以满足特定的应用需求。
- en: We highlighted the importance of error-handling middleware, showing how it can
    be used to catch and manage exceptions centrally, thereby simplifying error management
    and improving application robustness.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 我们强调了错误处理中间件的重要性，展示了如何使用它来集中捕获和管理异常，从而简化错误管理并提高应用的健壮性。
- en: Middleware is a fantastic way of extending the functionality of minimal APIs,
    but they are useless if their requests don’t have data that can be reviewed, manipulated,
    and transformed. In the next chapter, we’ll explore how data traveling through
    an API can be mapped for it to be processed optimally and accurately.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 中间件是扩展最小API功能的一种绝佳方式，但如果它们的请求没有可以审查、操作和转换的数据，它们就毫无用处。在下一章中，我们将探讨如何将经过API传输的数据映射，以便最优和准确地处理。
