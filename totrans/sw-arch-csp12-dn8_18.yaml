- en: '18'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '18'
- en: Implementing Frontend Microservices with ASP.NET Core
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 ASP.NET Core 实现前端微服务
- en: '*Chapter 14*, *Implementing Microservices with .NET*, described general techniques
    for implementing microservices in .NET but focused mainly on worker microservices,
    that is, on microservices that perform background jobs without communicating with
    anything outside of the application.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: '*第14章，使用 .NET 实现微服务*描述了在 .NET 中实现微服务的一般技术，但主要关注工作微服务，即执行后台作业而不与应用程序外部的任何东西通信的微服务。'
- en: Microservices that communicate with the world outside of the application bring
    with them other problems and need further techniques.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 与应用程序外部世界通信的微服务带来了其他问题，需要进一步的技术。
- en: 'More specifically, microservices that communicate with a human user must implement
    a presentation layer, while microservices that expose APIs must conform to well-established
    standards and should preferably have documentation. Moreover, web APIs that target
    **single-page applications** (**SPAs**) must conform with browser policies; that
    is, either they are exposed on a single domain that is the same domain the SPA
    was downloaded from, or they must configure CORS policies. We will see how to
    address both CORS and issues due to browser policies in *Chapter 19*, *Client
    Frameworks: Blazor*.'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，与人类用户通信的微服务必须实现表示层，而公开 API 的微服务必须遵守既定的标准，并且最好有文档。此外，针对**单页应用**（**SPAs**）的
    Web API 必须符合浏览器策略；也就是说，它们必须位于与 SPA 下载相同的域上，或者它们必须配置 CORS 策略。我们将在*第19章，客户端框架：Blazor*中看到如何解决
    CORS 和浏览器策略引起的问题。
- en: 'Worth mentioning also are all the challenges brought by any presentation layer,
    that is, ensuring a fast and effective interaction with the user and managing
    the state of the interaction with the user with maintainable code without falling
    into spaghetti code. General usability problems and solutions were discussed in
    *Chapter 2, Non-Functional Requirements*. We will discuss more technology-specific
    usability and status management problems in this chapter and in *Chapter 19*,
    *Client Frameworks: Blazor*.'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的还有任何表示层带来的所有挑战，即确保与用户快速有效的交互，以及在不陷入面条代码的情况下，使用可维护的代码管理与用户的交互状态。在*第二章，非功能性需求*中讨论了通用可用性问题及其解决方案。我们将在本章和*第19章，客户端框架：Blazor*中讨论更多与技术相关的可用性和状态管理问题。
- en: Finally, all front end microservices must put solid security policies in place
    to defend the application from hackers. Some techniques are common to both front-ends
    and web APIs and are automatically handled by all major web servers, such as countermeasures
    against path-transversal attacks and denial of service. Others, instead, are specific
    to HTML pages, such as forgery. ASP.NET Core MVC defenses against forgery are
    discussed in the *Chapter 21,* *Case study*.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有前端微服务都必须实施坚实的安全策略，以防御黑客攻击。一些技术对前端和 Web API 都适用，并且由所有主要 Web 服务器自动处理，例如针对路径穿越攻击和拒绝服务的对策。而另一些技术则特定于
    HTML 页面，例如伪造。在*第21章，案例研究*中讨论了 ASP.NET Core MVC 对伪造的防御。
- en: 'Techniques for implementing public self-documented web APIs were described
    in *Chapter 15*, *Applying Service-Oriented Architectures with .NET*, while techniques
    for implementing server-based presentation layers were covered in *Chapter 17*,
    *Presenting ASP.NET Core*, and techniques for implementing client-based presentation
    layers will be covered in *Chapter 19*, *Client Frameworks: Blazor*. Moreover,
    general techniques for implementing microservices were covered in *Chapter 11*,
    *Applying a Microservice Architecture to Your Enterprise Application*, *Chapter
    7*, *Understanding the Different Domains in Software Solutions*, and *Chapter
    14*, *Implementing Microservices with .NET*.'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第15章，使用 .NET 应用服务导向架构*中描述了实现公开自文档化 Web API 的技术，而在*第17章，展示 ASP.NET Core*中涵盖了实现基于服务器的表示层的技术，而在*第19章，客户端框架：Blazor*中将介绍实现基于客户端的表示层的技术。此外，在*第11章，将微服务架构应用于您的企业应用*、*第7章，理解软件解决方案中的不同领域*和*第14章，使用
    .NET 实现微服务*中涵盖了实现微服务的通用技术。
- en: Therefore, in this chapter, after a short section about concepts and techniques
    specific to front-end microservices, we will show you how to put all these concepts
    and techniques together in the practical implementation of a front-end microservice.
    More specifically, we will discuss various implementation options and how to architect
    the whole layer structure of a front-end microservice. A complete example that
    shows how all layers of a front-end microservice work together, in practice, is
    described in the *A frontend microservice* section of *Chapter 21, Case Study*.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，在简短介绍前端微服务的特定概念和技术部分之后，我们将向您展示如何将这些概念和技术结合在一起，在前端微服务的实际实现中。更具体地说，我们将讨论各种实现选项以及如何构建前端微服务的整个层结构。一个完整的示例，展示了前端微服务的所有层在实际中是如何协同工作的，可以在第21章*案例研究*的*前端微服务*部分中找到。
- en: 'More specifically, this chapter covers the following topics:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，本章涵盖了以下主题：
- en: Front-ends and micro-frontends
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 前端和微前端
- en: Defining the domain layer interface
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义域层接口
- en: Defining the domain layer implementation
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义域层实现
- en: Defining the application layer
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义应用层
- en: Defining controllers
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 定义控制器
- en: We will use the onion architecture and the patterns described in *Chapter 7*,
    *Understanding the Different Domains in Software Solutions*.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用洋葱架构和第7章中描述的*理解软件解决方案中的不同域*的模式。
- en: Technical requirements
  id: totrans-16
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: This chapter requires the free Visual Studio 2022 Community edition or better
    with all database tools installed.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 本章需要免费Visual Studio 2022 Community版或更高版本，并安装所有数据库工具。
- en: The code samples necessary to clarify the concepts in this chapter will be taken
    from a practical example application based on the `WWTravelClub` book use case.
    The full example application is described in detail in the *A front end microservice*
    section of *Chapter 21, Case Study*. Its code is available at [https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E).
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 为了阐明本章中的概念，所需的代码示例将来自基于`WWTravelClub`用例的实际示例应用程序。完整的示例应用程序在第21章*案例研究*的*前端微服务*部分中详细描述。其代码可在[https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E](https://github.com/PacktPublishing/Software-Architecture-with-C-Sharp-12-and-.NET-8-4E)找到。
- en: Front-ends and micro-frontends
  id: totrans-19
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 前端和微前端
- en: The main peculiarity of front-end microservices is that they need a robust web
    server that is able to optimize all the request/response handling and ensure the
    needed level of security. Moreover, high-traffic applications also need a load
    balancer.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 前端微服务的主要特点是它们需要一个强大的Web服务器，能够优化所有请求/响应处理并确保所需的安全级别。此外，高流量应用程序还需要一个负载均衡器。
- en: 'Examples of services offered by robust web servers like IIS, Apache, and NGINX
    are:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 强大Web服务器（如IIS、Apache和NGINX）提供的服务示例：
- en: Limiting access to just some file types and directories to prevent access to
    private files and to prevent remote file execution; that is, execution of server
    commands/scripts through web requests.
  id: totrans-22
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 限制对某些文件类型和目录的访问，以防止访问私有文件和防止远程文件执行；即通过Web请求执行服务器命令/脚本。
- en: Blocking dangerous requests that might cause access to unwanted files or directories
    (path-traversal attacks).
  id: totrans-23
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止可能导致访问不受欢迎的文件或目录（路径遍历攻击）的危险请求。
- en: Blocking requests that exceed a customizable length since they might cause a
    denial of service.
  id: totrans-24
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 阻止超过可自定义长度的请求，因为它们可能造成服务拒绝。
- en: Logging and IP address blocking to discover and contrast hacker attacks.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 记录和IP地址阻止以发现和对比黑客攻击。
- en: Redirecting requests to the application associated with each URL.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将请求重定向到与每个URL关联的应用程序。
- en: Queueing requests and assigning them to available threads. This capability is
    fundamental for performance optimization since executing too many requests compared
    to the available processor cores might cause unacceptable performance.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 队列请求并将它们分配给可用的线程。这种能力对于性能优化是基本的，因为与可用的处理器核心相比执行过多的请求可能会导致不可接受的性能。
- en: Ensuring the isolation of applications running on the same process but in different
    threads and more.
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确保运行在相同进程但不同线程上的应用程序之间的隔离，以及更多。
- en: If the front-end service is hosted on a Kubernetes cluster, both an adequate
    web server and load balancing can be provided through an **Ingress**.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 如果前端服务托管在Kubernetes集群上，可以通过**Ingress**提供适当的Web服务器和负载均衡。
- en: Otherwise, **Azure App Service** (see the *Further reading* section) might be
    a good option since it offers a scalable level of load balancing, excellent security,
    monitoring services, and so on.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 否则，**Azure App Service**（请参阅*进一步阅读*部分）可能是一个不错的选择，因为它提供了可扩展的负载均衡级别、出色的安全性、监控服务等等。
- en: A front-end microservice doesn’t need to interface directly with anything outside
    of an application. In fact, in micro-frontend architectures, there is no unique
    front-end, but the role of the front-end is split among several microservices.
    In these architectures, typically, the role of directing traffic toward the right
    front-end and/or of combining several responses into a unique response is taken
    by an interface front-end that is load-balanced and carries the burden of ensuring
    the right level of security.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 前端微服务不需要直接与应用程序外部进行接口交互。实际上，在微前端架构中，没有唯一的客户端，但前端的作用被分散到几个微服务中。在这些架构中，通常，将流量引导到正确的客户端和/或合并多个响应为一个唯一响应的作用由一个负载均衡的接口前端承担，它承担着确保正确安全级别的负担。
- en: 'The reasons for using micro-frontends are the same as the ones for using other
    microservices. We discussed them in detail in *Chapter 11*, *Applying a Microservice
    Architecture to Your Enterprise Application*, but it is worth repeating the more
    important ones here:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 使用微前端的原因与其他微服务相同。我们已在*第11章*，*将微服务架构应用于您的企业应用程序*中详细讨论了它们，但在此重复一些更重要的事项：
- en: Optimizing the usage of hardware resources by scaling just the microservices
    that need more resources
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过仅扩展需要更多资源的微服务来优化硬件资源的利用率
- en: Having independent software lifecycles for each microservice, so each microservice
    can evolve independently from the others to match the user needs and so that each
    microservices developer team can work independently from the others
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 每个微服务都有独立的软件生命周期，因此每个微服务可以独立于其他微服务发展，以满足用户需求，并且每个微服务开发团队可以独立于其他团队工作。
- en: Micro-frontend architectures use quite different techniques for HTML websites,
    like ASP.NET Core MVC websites, and for web APIs. Actually, the word “micro-frontend”
    is used just with HTML websites/SPAs, while web APIs exposed to the outside world
    are referred to as public web APIs. We will describe public web APIs and HTML
    micro-frontends and the techniques they use in two dedicated subsections, starting
    with public web APIs.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端架构在HTML网站（如ASP.NET Core MVC网站）和Web API方面使用相当不同的技术。实际上，“微前端”一词仅用于HTML网站/单页应用，而面向外部的Web
    API被称为公共Web API。我们将在两个专门的子节中描述公共Web API和HTML微前端及其使用的技术，从公共Web API开始。
- en: Public web APIs
  id: totrans-36
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 公共Web API
- en: In the case of web APIs, all microservices are accessible through a unique load-balanced
    piece of software called an **API gateway** that sits in between the clients and
    the various API services. The basic role of an API gateway is to make the whole
    API accessible from a unique domain to both avoid problems with the browser’s
    unique domain policy and make the usage of all API services simpler.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在网络API的情况下，所有微服务都通过一个独特的负载均衡软件组件，称为**API网关**，在客户端和各个API服务之间进行访问。API网关的基本作用是从一个唯一的域名使整个API可访问，以避免浏览器独特的域名策略问题，并简化所有API服务的使用。
- en: '![](img/B19820_18_01.png)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_18_01.png)'
- en: 'Figure 18.1: API gateway'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.1：API网关
- en: 'However, the API gateway offers the opportunity to centralize other functions
    that are common to all API services, such as:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，API网关提供了集中其他对所有API服务都通用的功能的机会，例如：
- en: '**Authentication**, that is, validating and decoding the authentication token
    that comes with each request (please do not confuse authentication with login).'
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**身份验证**，即验证和解码每个请求附带的身份验证令牌（请勿将身份验证与登录混淆）。'
- en: '**Caching**, that is, caching responses according to configurable caching policies.'
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**缓存**，即根据可配置的缓存策略进行响应缓存。'
- en: '**Translation**, that is, adapting the interface, as seen by the client, to
    the actual signature of the various API methods. This way, each API can change
    its interface without affecting existing clients.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**翻译**，即调整客户端看到的界面以适应各种API方法的实际签名。这样，每个API可以更改其界面而不会影响现有客户端。'
- en: '**Versioning**, that is, directing each request toward a compatible version
    of each API service.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本控制**，即将每个请求定向到每个API服务的兼容版本。'
- en: '**Documentation**, that is, offering a unique documentation endpoint.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**文档**，即提供独特的文档端点。'
- en: API gateways have continued to evolve, absorbing and offering more and more
    functions, giving rise to the so-called **API management systems** that now automate
    and take care of most of the burden of handling public web APIs.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: API 网关一直在不断发展，吸收并提供越来越多的功能，从而产生了所谓的 **API 管理系统**，现在它们自动化并处理了处理公共 Web API 的大部分负担。
- en: 'Azure, like all clouds, offers a good API management service. You can find
    more information about it here: [https://azure.microsoft.com/en-us/services/api-management/#overview](https://azure.microsoft.com/en-us/services/api-management/#overview).'
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: Azure，像所有云服务一样，提供良好的 API 管理服务。你可以在这里找到更多关于它的信息：[https://azure.microsoft.com/en-us/services/api-management/#overview](https://azure.microsoft.com/en-us/services/api-management/#overview)。
- en: It is also worth mentioning **Ocelot** ([https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-ith-ocelot"](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-ith-ocelot)),
    a library for easily creating custom API gateways. You can either use it to fill
    in configuration files or as a base for a completely custom API gateway.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 值得一提的是 **Ocelot** ([https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-ith-ocelot](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-ith-ocelot))，这是一个用于轻松创建自定义
    API 网关的库。你可以用它来填写配置文件，或者作为完全自定义 API 网关的基础。
- en: Now, we are ready to discuss HTML micro-frontends, which also add the challenge
    of combining several HTML fragments into a unique HTML page.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们准备讨论 HTML 微前端，它也带来了将多个 HTML 片段组合成独特 HTML 页面的挑战。
- en: HTML micro-frontends
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: HTML 微前端
- en: Several HTML micro-frontends can cooperate on the same application by furnishing
    each with a different set of web pages. In this case, coordinating them requires
    nothing more than links pointing to the other micro-frontends and a common sign-in
    so that users don’t need to log in each time they move to a different micro-frontend.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 几个 HTML 微前端可以通过为每个提供不同的一组网页来在同一应用程序中协作。在这种情况下，协调它们只需要指向其他微前端的链接和一个共同的登录方式，这样用户在移动到不同的微前端时就不需要每次都登录。
- en: However, very often, several micro-frontends cooperate in the construction of
    the same page by supplying various page areas. In this case, a software component
    must take the burden of assembling the various parts into a unique page.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，非常常见的情况是，几个微前端通过提供各种页面区域来共同构建同一个页面。在这种情况下，一个软件组件必须承担将各个部分组装成独特页面的负担。
- en: The main difficulty of combining several HTML fragments into a single HTML page
    is offering a coherent experience to the user, thus avoiding assembling all page
    areas in a way that is hard to understand for the user. Another problem is avoiding
    the continuous page flipping and reorganization each time new content reaches
    the browser. In what follows, we will discuss how these problems are solved by
    different technologies.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 将多个 HTML 片段组合成单个 HTML 页面的主要困难是提供给用户一致的用户体验，从而避免以用户难以理解的方式组装所有页面区域。另一个问题是避免每次新内容到达浏览器时连续的页面翻页和重组。在接下来的内容中，我们将讨论这些问题的解决方案。
- en: In the case of classic web applications that build the HTML on the server side,
    an interface application furnishes the page layout and then calls the various
    micro-frontends to fill the various layout areas.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在经典 Web 应用程序构建服务器端 HTML 的情况下，界面应用程序提供页面布局，然后调用各种微前端来填充不同的布局区域。
- en: '![](img/B19820_18_02.png)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_18_02.png)'
- en: 'Figure 18.2: Server-side micro-frontend'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.2：服务器端微前端
- en: In this case, there is no browser page flipping and reorganization issue since
    the whole HTML page is assembled on the server side and sent to the browser only
    when it is ready. However, we pay for this advantage with the memory consumption
    for the whole time needed to assemble the whole page before sending it to the
    browser.
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，由于整个 HTML 页面是在服务器端组装的，并且只有在准备就绪时才发送到浏览器，因此不存在浏览器页面翻页和重组的问题。然而，我们为此优势付出了整个页面组装过程中所需的内存消耗的代价。
- en: Both the layout to use and which calls to make to the involved micro-frontends
    are obtained by processing the request URL according to rules that are either
    hardwired in the code or, better, stored in one or more configuration sources
    (in the simplest case, a unique configuration file). Using predefined page patterns
    ensures coherence and a good user experience, but we pay the cost in maintainability
    because we need to update and test the interface application at each non-trivial
    change of any single micro-frontend that furnishes page areas.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 要使用的布局以及需要调用哪些涉及到的微前端，都是通过根据规则处理请求 URL 来获得的，这些规则要么硬编码在代码中，要么更好，存储在一个或多个配置源中（在最简单的情况下，一个唯一的配置文件）。使用预定义的页面模式确保一致性和良好的用户体验，但我们在可维护性方面付出了代价，因为我们需要在提供页面区域的任何单个微前端发生任何非平凡变化时更新和测试接口应用程序。
- en: 'In the case of SPAs, the assembly process takes place on the client, that is,
    in the browser:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 在单页应用（SPA）的情况下，组装过程发生在客户端，即浏览器中：
- en: A kernel application furnishes the initial HTML page.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 核心应用程序提供初始 HTML 页面。
- en: The kernel application downloads a JavaScript file from each micro-frontend.
    Each of these JavaScript files is a micro-SPA that creates page areas.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 核心应用程序从每个微前端下载一个 JavaScript 文件。这些 JavaScript 文件中的每一个都是一个微 SPA，用于创建页面区域。
- en: The kernel application, based on the current URL, decides which URL to pass
    to each micro-SPA and then puts the HTML produced by each micro-SPA in the right
    place.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 核心应用程序基于当前 URL 决定传递给每个微 SPA 的 URL，然后将每个微 SPA 生成的 HTML 放置在正确的位置。
- en: '![](img/B19820_18_03.png)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/B19820_18_03.png)'
- en: 'Figure 18.3: Client-side micro-frontend'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 18.3：客户端微前端
- en: The various micro-SPAs do not interfere with each other because each of them
    runs in a separate JavaScript scope. Therefore, for instance, we can mix micro-SPAs
    implemented with different and incompatible versions of Angular and/or React.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 各种微 SPA 之间不会相互干扰，因为它们各自运行在独立的 JavaScript 范围内。因此，例如，我们可以混合使用不同和不兼容版本的 Angular
    和/或 React 实现的微 SPA。
- en: 'Micro-frontends can also be implemented using WebAssembly frameworks like Blazor
    (see *Chapter 19*, *Client Frameworks: Blazor*) that run .NET code. However, in
    this case, the various micro-SPAs do not run in separate environments, so they
    must be based on compatible .NET versions.'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 微前端也可以使用 WebAssembly 框架，如 Blazor（见第 19 章，客户端框架：Blazor）来实现，这些框架运行 .NET 代码。然而，在这种情况下，各种微
    SPA 并不在单独的环境中运行，因此它们必须基于兼容的 .NET 版本。
- en: SPA micro-frontends have the same maintainability costs as server-based micro-frontends
    and have browser page flipping and reorganization issues since the page is created
    dynamically as new content and/or data reach the browser. This problem can be
    solved by pre-allocating each content area of the browser page with fixed-size
    HTML tags. Thus, for instance, we may pre-allocate a 300 px X 300 px area to show
    weather forecasts and some pictures or animation while the actual content is loading.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: SPA 微前端与基于服务器的微前端具有相同的维护成本，并且由于页面是动态创建的，当新内容或数据到达浏览器时，存在浏览器页面翻页和重组问题。这个问题可以通过为浏览器页面的每个内容区域预分配固定大小的
    HTML 标签来解决。例如，我们可能预分配一个 300 像素 X 300 像素的区域来显示天气预报和一些图片或动画，而实际内容正在加载。
- en: In the next section, we will introduce the architectural schema for building
    a front-end microservice based on ASP.NET Core MVC.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将介绍基于 ASP.NET Core MVC 构建前端微服务的架构方案。
- en: Defining the application architecture
  id: totrans-69
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义应用程序架构
- en: The application will be implemented with the **Domain-Driven Design** (**DDD**)
    approach and associated patterns described in *Chapter 7*, *Understanding the
    Different Domains in Software Solutions*, and *Chapter 13*, *Interacting with
    Data in C# – Entity Framework Core*, so having a good understanding of the content
    covered in those chapters is a fundamental prerequisite to reading this chapter.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序将使用第 7 章“理解软件解决方案中的不同领域”和第 13 章“在 C# 中与数据交互 - Entity Framework Core”中描述的
    **领域驱动设计**（**DDD**）方法和相关模式来实现，因此对那些章节内容的良好理解是阅读本章的基本先决条件。
- en: 'The application is organized based on a DDD approach and uses SOLID principles
    to map your domain sections. That is, the application is organized into three
    layers, each implemented as a different project:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序基于 DDD 方法组织，并使用 SOLID 原则来映射您的领域部分。也就是说，应用程序被组织成三个层次，每个层次都作为不同的项目实现：
- en: There’s a domain layer, which contains the repository’s implementation and the
    classes describing database entities. It is a .NET library project. However, since
    it needs some interfaces, like `IServiceCollection`, which are defined in `Microsoft.NET.Sdk.web`,
    and since the `DBContext` layer must inherit from the identity framework in order
    to also handle the application authentication and authorization database tables,
    we must add a reference not only to the .NET SDK but also to the ASP.NET Core
    SDK. However, it is also common to implement custom user management.
  id: totrans-72
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 领域层包含存储库的实现和描述数据库实体的类。它是一个 .NET 库项目。然而，由于它需要一些接口，如 `IServiceCollection`，这些接口在
    `Microsoft.NET.Sdk.web` 中定义，并且由于 `DBContext` 层必须从身份框架继承，以便也能处理应用程序的认证和授权数据库表，我们必须添加对
    .NET SDK 的引用，同时也必须添加对 ASP.NET Core SDK 的引用。然而，实现自定义用户管理也是常见的。
- en: There’s also a domain layer abstraction, which contains repository specifications;
    that is, interfaces that describe repository implementations and DDD aggregates.
    In our implementation, we decided to implement aggregates by hiding the forbidden
    operations/properties of root data entities behind interfaces, as discussed in
    the *How data and domain layers communicate with other layers* section of *Chapter
    13, Interacting with Data in C# – Entity Framework Core*. Hence, for instance,
    the `Package` data layer class, which is an aggregate root, has a corresponding
    `IPackage` interface in the domain layer abstraction that hides all the property
    setters of the `Package` entity. The domain layer abstraction also contains the
    definitions of all the domain events, while the event handlers that will subscribe
    to these events are defined in the application layer.
  id: totrans-73
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，还有一个领域层抽象，它包含存储库规范；即描述存储库实现和 DDD 聚合的接口。在我们的实现中，我们决定通过隐藏根数据实体的禁止操作/属性来实施聚合，正如在
    *第 13 章，与 C# 中的数据交互* 部分的 *如何数据层和领域层与其他层通信* 节中讨论的那样。因此，例如，`Package` 数据层类，它是一个聚合根，在领域层抽象中有一个相应的
    `IPackage` 接口，隐藏了 `Package` 实体的所有属性设置器。领域层抽象还包含所有领域事件的定义，而将订阅这些事件的处理器定义在应用层。
- en: Finally, there’s the application layer – that is, the ASP.NET Core MVC application
    (ASP.NET Core MVC is discussed in *Chapter 17*, *Presenting ASP.NET Core*) – where
    we define DDD queries, commands, command handlers, and event handlers. Controllers
    fill query objects and execute them to get ViewModels they can pass to Views.
    They update storage by filling command objects and executing their associated
    command handlers. In turn, command handlers use `IRepository` interfaces and `IUnitOfWork`
    instances coming from the domain layer to manage and coordinate transactions.
  id: totrans-74
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，是应用层——即 ASP.NET Core MVC 应用程序（ASP.NET Core MVC 在 *第 17 章*，*展示 ASP.NET Core*
    中进行了讨论）——在这里我们定义 DDD 查询、命令、命令处理器和事件处理器。控制器填充查询对象并执行它们以获取可以传递给视图的 ViewModels。它们通过填充命令对象并执行相关的命令处理器来更新存储。反过来，命令处理器使用来自领域层的
    `IRepository` 接口和 `IUnitOfWork` 实例来管理和协调事务。
- en: The application uses the **Command Query Responsibility Segregation** (**CQRS**)
    pattern; therefore, it uses command objects to modify the storage and the query
    object to query it. CQRS was described in the *Command Query Responsibility Segregation
    (CQRS) pattern* subsection of *Chapter 7, Understanding the Different Domains
    in Software Solutions.*
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序使用 **命令查询责任分离**（**CQRS**）模式；因此，它使用命令对象来修改存储，并使用查询对象来查询它。CQRS 在 *第 7 章，理解软件解决方案中的不同领域*
    的 *命令查询责任分离（CQRS）模式* 子节中进行了描述。
- en: 'The query is simple to use and implement: controllers fill their parameters
    and then call their execution methods. In turn, query objects have direct LINQ
    implementations that project results directly onto the ViewModels used by the
    controller Views with `Select` LINQ methods. You may also decide to hide the LINQ
    implementation behind the same repository classes used for the storage update
    operations, but this would turn the definition and modification of simple queries
    into very time-consuming tasks.'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 查询的使用和实现都很简单：控制器填充它们的参数，然后调用它们的执行方法。反过来，查询对象有直接的 LINQ 实现，使用 `Select` LINQ 方法直接将结果投影到控制器视图使用的
    ViewModels 上。你也可以决定在用于存储更新操作的相同存储库类后面隐藏 LINQ 实现，但这样会将简单查询的定义和修改变成非常耗时的工作。
- en: In any case, it could be beneficial to encapsulate query objects behind interfaces
    so that their implementations can be replaced by fake implementations when you
    test controllers.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 在任何情况下，将查询对象封装在接口之后可能是有益的，这样在测试控制器时可以替换它们的实现为模拟实现。
- en: However, the chain of objects and calls involved in the execution of commands
    is more complex. This is because it requires the construction and modification
    of aggregates, as well as a definition of the interaction between several aggregates
    and between aggregates and other applications through domain events to be provided.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，涉及命令执行的物体和调用链更为复杂。这是因为它需要构建和修改聚合体，以及定义多个聚合体之间以及聚合体与其他应用程序之间的交互，这需要通过领域事件提供。
- en: 'The following diagram is a sketch of how storage update operations are performed.
    The circles are data being exchanged between the various layers, while the rectangles
    are the procedures that process them. Moreover, dotted arrows connect interfaces
    with the types that implement them:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的图示是存储更新操作执行过程的草图。圆圈表示在各个层之间交换的数据，而矩形表示处理这些数据的程序。此外，虚线箭头连接接口及其实现类型：
- en: '![](img/B19820_18_04.png)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![](img/B19820_18_04.png)'
- en: 'Figure 18.4: Diagram of command execution'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图18.4：命令执行的示意图
- en: 'Here’s the flow of action through *Figure 18.4* as a list of steps:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是动作通过 *图18.4* 的步骤列表：
- en: A controller’s action method receives one or more ViewModels and performs validation.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 控制器的动作方法接收一个或多个 ViewModels 并执行验证。
- en: One or more ViewModels containing changes to apply are hidden behind interfaces
    (`IMyUpdate`) defined in the domain layer. They are used to fill the properties
    of a command object. These interfaces must be defined in the domain layer since
    they will be used as arguments of the repository aggregate methods defined there.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一个或多个包含要应用更改的 ViewModels 被隐藏在领域层中定义的接口 (`IMyUpdate`) 之后。它们用于填充命令对象的属性。这些接口必须在领域层中定义，因为它们将被用作在那里定义的仓库聚合方法中的参数。
- en: A command handler matching the previous command is retrieved via **Dependency
    Injection** (**DI**) in the controller action method. Then, the handler is executed.
    During its execution, the handler interacts with various repository interface
    methods and with the aggregates they return.
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在控制器动作方法中通过 **依赖注入** (**DI**) 获取与先前命令匹配的命令处理器。然后执行处理器。在其执行过程中，处理器与各种仓库接口方法和它们返回的聚合体进行交互。
- en: When creating the command handler discussed in *step 3*, the ASP.NET Core DI
    engine automatically injects all parameters declared in its constructor. In particular,
    it injects all `IRepository` implementations needed to perform all command handler
    transactions. The command handler performs its job by calling the methods of these
    `IRepository` implementations received in its constructor to build aggregates
    and modify the built aggregates. Aggregates either represent already-existing
    entities or newly created ones. Handlers use the `IUnitOfWork` interface contained
    in each `IRepository`, as well as the concurrency exceptions returned by the data
    layer, to organize their operations as transactions. It is worth pointing out
    that each aggregate has its own `IRepository` and that the whole logic for updating
    each aggregate is defined in the aggregate itself, not in its associated `IRepository`,
    to keep the code more modular.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在创建第3步中讨论的命令处理器时，ASP.NET Core DI 引擎会自动注入其构造函数中声明的所有参数。特别是，它会注入执行所有命令处理器事务所需的全部
    `IRepository` 实现。命令处理器通过调用其构造函数中接收到的这些 `IRepository` 实现的方法来构建聚合体并修改已构建的聚合体来完成其工作。聚合体要么代表已存在的实体，要么代表新创建的实体。处理器使用包含在每个
    `IRepository` 中的 `IUnitOfWork` 接口以及数据层返回的并发异常来组织其操作为事务。值得注意的是，每个聚合体都有自己的 `IRepository`，并且更新每个聚合体的全部逻辑都定义在聚合体本身中，而不是其关联的
    `IRepository` 中，以保持代码更加模块化。
- en: Behind the scenes, in the data layer, `IRepository` implementations use Entity
    Framework to perform their job. Aggregates are implemented by root data entities
    hidden behind interfaces defined in the domain layer, while `IUnitOfWork` methods,
    which handle transactions and pass changes to the database, are implemented with
    `DbContext` methods. In other words, `IUnitOfWork` is implemented with the application’s
    `DbContext`.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在幕后，在数据层中，`IRepository` 实现使用 Entity Framework 来执行其工作。聚合体由领域层中定义的接口背后的根数据实体实现，而处理事务并将更改传递到数据库的
    `IUnitOfWork` 方法是用 `DbContext` 方法实现的。换句话说，`IUnitOfWork` 是用应用程序的 `DbContext` 实现的。
- en: Domain events are generated during each aggregate processing and are added to
    the aggregates themselves by calling their `AddDomainEvent` methods. However,
    they are not triggered immediately. Usually, they are triggered at the end of
    all the aggregates’ processing and before changes are passed to the database;
    however, this is not a general rule.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 领域事件在每个聚合处理过程中生成，并通过调用其`AddDomainEvent`方法将其添加到聚合本身中。然而，它们不会立即触发。通常，它们会在所有聚合的处理结束时触发，并在更改传递到数据库之前；然而，这并不是一个普遍的规则。
- en: The application handles errors by throwing exceptions. A more efficient approach
    would be to define a request-scoped object in the dependency engine, where each
    application subpart may add its errors as domain events. However, while this approach
    is more efficient, it increases the complexity of the code and the application
    development time.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应用程序通过抛出异常来处理错误。一个更有效的方法是在依赖引擎中定义一个请求作用域对象，其中每个应用程序子部分都可以将其错误添加为领域事件。然而，虽然这种方法更有效，但它增加了代码和应用程序开发时间的复杂性。
- en: 'The Visual Studio solution is composed of three projects:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: Visual Studio解决方案由三个项目组成：
- en: There’s a project containing the domain layer abstraction, which is a .NET Standard
    2.1 library. When a library doesn’t use features or NuGet packages that are specific
    to a .NET version, it is a good practice to implement it as a .NET Standard library
    because this way, it doesn’t need modifications when the application is moved
    to a newer .NET version.
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个包含领域层抽象的项目，这是一个.NET Standard 2.1库。当一个库不使用特定于.NET版本的特性和NuGet包时，将其实现为.NET Standard库是一个好的实践，因为这样，当应用程序移动到新的.NET版本时，它不需要修改。
- en: There’s a project containing the whole data layer, which is a .NET 8.0 library
    based on Entity Framework.
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 有一个包含整个数据层的项目，这是一个基于Entity Framework的.NET 8.0库。
- en: Finally, there’s an ASP.NET Core MVC 8.0 project that contains both the application
    and presentation layers. When you define this project, select **No Authentication**;
    otherwise, the user database will be added directly to the ASP.NET Core MVC project
    instead of to the database layer. We will add the user database manually in the
    data layer.
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，还有一个包含应用程序和表示层的ASP.NET Core MVC 8.0项目。当你定义此项目时，选择**无身份验证**；否则，用户数据库将直接添加到ASP.NET
    Core MVC项目中，而不是数据层。我们将手动在数据层中添加用户数据库。
- en: In the remaining sections, we will describe the implementation of each layer
    that composes the architecture described so far, starting with domain layer abstraction.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的部分中，我们将描述构成迄今为止所描述架构的每一层的实现，首先是领域层抽象。
- en: Defining the domain layer interface
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义领域层接口
- en: Once the `PackagesManagementDomain` Standard 2.1 library project has been added
    to the solution, we’ll add a `Tools` folder to the project root. Then, we’ll place
    all the `DomainLayer` tools contained in the code associated with `ch7`. Since
    the code contained in this folder uses data annotations and defines DI extension
    methods, we must also add references to the `System.ComponentModel.Annotations`
    and `Microsoft.Extensions.DependencyInjection.Abstration` NuGet packages.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦将`PackagesManagementDomain` Standard 2.1库项目添加到解决方案中，我们将在项目根目录中添加一个`Tools`文件夹。然后，我们将所有与`ch7`相关的代码中包含的`DomainLayer`工具放置到该文件夹中。由于该文件夹中的代码使用数据注释并定义了DI扩展方法，我们还必须添加对`System.ComponentModel.Annotations`和`Microsoft.Extensions.DependencyInjection.Abstration`
    NuGet包的引用。
- en: Then, we need an `Aggregates` folder containing all the aggregate definitions
    (which, as already said, we will implement as interfaces).
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要一个包含所有聚合定义的`Aggregates`文件夹（正如已经说过的，我们将实现为接口）。
- en: 'Below is an example of an aggregate definition:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个聚合定义的示例：
- en: '[PRE0]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'It contains the same properties as the `Package` entity, which we saw in *Chapter
    13*, *Interacting with Data in C# – Entity Framework Core*. The only differences
    are the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含与我们在第13章中看到的`Package`实体相同的属性，即*交互式数据在C# – Entity Framework Core*。唯一的区别如下：
- en: It inherits from `IEntity<int>`, which furnishes all basic functionalities of
    aggregates
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它继承自`IEntity<int>`，这为聚合提供了所有基本功能。
- en: It has no `Id` property since it is inherited from `IEntity<int>`
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它没有`Id`属性，因为它继承自`IEntity<int>`。
- en: All properties are read-only, and it has a `FullUpdate` method since all aggregates
    can only be modified through update operations defined in the user domain (in
    our case, the `FullUpdate` method)
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 所有属性都是只读的，并且它有一个`FullUpdate`方法，因为所有聚合只能通过用户领域（在我们的情况下，是`FullUpdate`方法）中定义的更新操作进行修改。
- en: Now, let’s also add a `DTOs` folder. Here, we place all interfaces used to pass
    updates to the aggregates. Such interfaces are implemented by the application
    layer ViewModels used to define such updates. In our case, it contains `IPackageFullEditDTO`,
    which we can use to update existing packages.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们也添加一个`DTOs`文件夹。在这里，我们放置所有用于将更新传递给聚合的接口。这些接口由用于定义此类更新的应用层ViewModel实现。在我们的案例中，它包含`IPackageFullEditDTO`，我们可以用它来更新现有包。
- en: 'An `IRepositories` folder contains all repository specifications; the following
    is an example repository interface:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`IRepositories`文件夹包含所有存储库规范；以下是一个示例存储库接口：
- en: '[PRE1]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Repositories always contain just a few methods since all business logic should
    be represented as aggregate methods – in our case, just the methods to create
    a new package, retrieve an existing package, and delete an existing package. The
    logic to modify an existing package is included in the `FullUpdate` method of
    `IPackage`.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 存储库总是只包含几个方法，因为所有业务逻辑都应该表示为聚合方法——在我们的案例中，只是创建新包、检索现有包和删除现有包的方法。修改现有包的逻辑包含在`IPackage`的`FullUpdate`方法中。
- en: Finally, we also have an event folder containing all domain event definitions.
    We can name this folder `Events`. Events are triggered whenever a change to an
    aggregate has consequences either on other aggregates or on other microservices.
    They are a way to implement weak interactions between aggregates and microservices
    while keeping the code of aggregates independent of each other.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们还有一个包含所有域事件定义的事件文件夹。我们可以将此文件夹命名为`Events`。每当聚合的更改对其他聚合或微服务有影响时，都会触发事件。它们是实现聚合和微服务之间弱交互的一种方式，同时保持聚合代码相互独立。
- en: 'By using events, we may keep the code of each aggregate substantially independent
    of the code of other aggregates that are involved in the same database transactions:
    each aggregate generates events that might interest other aggregates, such as
    a price change in a touristic package aggregate, and all other aggregates that
    depend on this price subscribe to that event, so they can update their data coherently.
    This way, when a new aggregate that depends on the tourist package price is added
    during system maintenance, we don’t need to modify the tourist package aggregate.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 通过使用事件，我们可以使每个聚合的代码在涉及相同数据库事务的其他聚合的代码中保持高度独立：每个聚合生成可能引起其他聚合兴趣的事件，例如旅游包聚合中的价格变化，所有依赖于这个价格的其他聚合都订阅了这个事件，以便它们可以一致地更新它们的数据。这样，当在系统维护期间添加一个依赖于旅游包价格的新聚合时，我们不需要修改旅游包聚合。
- en: When the event might also interest other microservices, the event is also passed
    to a message broker, which makes the event also available for subscription to
    code in other microservices. Message brokers were discussed in *Chapter 14*, *Implementing
    Microservices with .NET*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 当事件可能也引起其他微服务的兴趣时，该事件也会传递给消息代理，这使得事件也对其他微服务中的代码可用进行订阅。消息代理在*第14章*，*使用.NET实现微服务*中进行了讨论。
- en: 'Below is an example event definition:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个事件定义的示例：
- en: '[PRE2]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When an aggregate sends all its changes to another microservice, it should have
    a version property. The microservice that receives the changes uses this version
    property to apply all changes in the right order. An explicit version number is
    necessary because changes are sent asynchronously, so the order in which they
    are received may differ from the order in which they were sent. For this purpose,
    events that are used to publish changes outside of the application have both `OldVersion`
    (the version before the change) and `NewVersion` (the version after the change)
    properties. Events associated with delete events have no `NewVersion` since, after
    being deleted, an entity can’t store any versions.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个聚合将所有更改发送到另一个微服务时，它应该有一个版本属性。接收更改的微服务使用这个版本属性来按正确顺序应用所有更改。显式的版本号是必要的，因为更改是异步发送的，所以它们接收的顺序可能与发送的顺序不同。为此，用于在应用程序外部发布更改的事件具有`OldVersion`（更改前的版本）和`NewVersion`（更改后的版本）属性。与删除事件相关的事件没有`NewVersion`属性，因为实体在被删除后无法存储任何版本。
- en: The next subsection explains how all interfaces defined in the domain layer
    are implemented in the data layer.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个子节解释了在域层定义的所有接口如何在数据层实现。
- en: Defining the domain layer implementation
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义域层实现
- en: The domain layer implementation contains the implementation of all repository
    interfaces and aggregate interfaces defined in the domain layer interface. In
    the case of .NET 8, it uses Entity Framework Core entities to implement aggregates.
    Adding a domain layer interface in between the domain layer’s actual implementation
    and the application layer decouples the application layer from EF and entity-specific
    details. Moreover, it conforms with the onion architecture, which, in turn, is
    an advised way to architect microservices.
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 领域层实现包含了在领域层接口中定义的所有仓储接口和聚合接口的实现。在 .NET 8 的情况下，它使用 Entity Framework Core 实体来实现聚合。在领域层的实际实现和应用层之间添加领域层接口可以将应用层从
    EF 和实体特定细节中解耦。此外，它符合洋葱架构，而洋葱架构反过来又是构建微服务的一个建议方式。
- en: The domain layer implementation project should contain references to `Microsoft.AspNetCore.Identity.EntityFrameworkCore`
    and `Microsoft.EntityFrameworkCore.SqlServer` NuGet packages, since we are using
    Entity Framework Core with SQL Server. It references `Microsoft.EntityFrameworkCore.Tools`
    and `Microsoft.EntityFrameworkCore.Design`, which is needed to generate database
    migrations, as explained in the *Entity Framework Core migrations* section of
    *Chapter 13*, *Interacting with Data in C# – Entity Framework Core*.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 领域层实现项目应包含对 `Microsoft.AspNetCore.Identity.EntityFrameworkCore` 和 `Microsoft.EntityFrameworkCore.SqlServer`
    NuGet 包的引用，因为我们正在使用与 SQL Server 的 Entity Framework Core。它引用了 `Microsoft.EntityFrameworkCore.Tools`
    和 `Microsoft.EntityFrameworkCore.Design`，这是在 *第 13 章* 的 *Entity Framework Core
    迁移* 部分中解释的，*在 C# 中与数据交互 – Entity Framework Core*。
- en: 'We should have a `Models` folder that contains all database entities. They
    are similar to the ones in *Chapter 13*. The only differences are as follows:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 我们应该有一个包含所有数据库实体的 `Models` 文件夹。它们与 *第 13 章* 中的类似。唯一的区别如下：
- en: They inherit from `Entity<T>`, which contains all the basic features of aggregates.
    Please note that inheriting from `Entity<T>` is only needed for aggregate roots;
    all other entities must be defined as explained in *Chapter 13*.
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 它们继承自 `Entity<T>`，其中包含所有聚合的基本功能。请注意，从 `Entity<T>` 继承仅适用于聚合根；所有其他实体都必须按照 *第 13
    章* 中所述的方式定义。
- en: They have no `Id` since it is inherited from `Entity<T>`.
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于它继承自 `Entity<T>`，它们没有 `Id` 属性。
- en: Some of them might have an `EntityVersion` property decorated with the `[ConcurrencyCheck]`
    attribute. It contains the entity version that is needed to send changes to other
    microservices. The `ConcurrencyCheck` attribute is needed to prevent concurrency
    errors while updating the entity version. This prevents suffering the performance
    penalty implied by a transaction.
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 其中一些可能具有用 `[ConcurrencyCheck]` 属性装饰的 `EntityVersion` 属性。它包含发送更改到其他微服务所需的实体版本。`ConcurrencyCheck`
    属性用于防止在更新实体版本时发生并发错误。这防止了因事务而导致的性能惩罚。
- en: More specifically, when saving entity changes, if the value of a field marked
    with the `ConcurrencyCheck` attribute is different from the one that was read
    when the entity was loaded in memory, a concurrency exception is thrown to inform
    the calling method that someone else modified this value after the entity was
    read, but before we attempted to save its changes. This way, the calling method
    can repeat the whole operation with the hope that this time, no one will write
    the same entity in the database during its execution.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，当保存实体更改时，如果带有 `ConcurrencyCheck` 属性的字段值与实体在内存中加载时读取的值不同，则会抛出一个并发异常，以通知调用方法，在读取实体之后但在我们尝试保存其更改之前，有人修改了此值。这样，调用方法可以重复整个操作，希望这次在执行过程中没有人会在数据库中写入相同的实体。
- en: 'It is worth analyzing an example entity:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 值得分析一个示例实体：
- en: '[PRE3]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `FullUpdate` method is the only way to update the `IPackage` aggregate.
    When the price changes, it adds a `PackagePriceChangedEvent` to the entity list
    of events.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: '`FullUpdate` 方法是更新 `IPackage` 聚合的唯一方式。当价格发生变化时，它会向事件列表中添加一个 `PackagePriceChangedEvent`。'
- en: '`MainDBContext` implements `IUnitOfWork`. The following code shows the implementation
    of all methods that start, rollback, and commit a transaction:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: '`MainDBContext` 实现了 `IUnitOfWork` 接口。以下代码展示了开始、回滚和提交事务的所有方法的实现：'
- en: '[PRE4]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: However, they are rarely used by command classes in a distributed environment.
    In fact, like distributed transactions, local database-blocking transactions are
    also avoided because they might block database resources for too much time, which
    is incompatible with the maximization of traffic typical of microservices-based
    applications.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在分布式环境中，命令类很少使用它们。事实上，就像分布式事务一样，本地数据库阻塞事务也被避免，因为它们可能会长时间阻塞数据库资源，这与基于微服务应用程序典型的高流量最大化不相符。
- en: Likely, as already mentioned, all databases support tagging some row fields
    as **concurrency checks**. In Entity Framework Core, this is done by decorating
    the entity property corresponding to the field with the `ConcurrencyCheck` attribute.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 很可能，如前所述，所有数据库都支持将某些行字段标记为 **并发检查**。在 Entity Framework Core 中，这是通过用 `ConcurrencyCheck`
    属性装饰对应字段的实体属性来完成的。
- en: Concurrency checks detect interferences of another transaction, B, on a record
    while performing transaction A. This way, we can perform transaction A without
    blocking any database record or table, and if we detect interference, we abort
    transaction A and retry it till it succeeds without interference. This technique
    works well if transactions are very quick and, consequently, interferences are
    rare.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 并发检查检测在执行事务 A 时，另一个事务 B 对记录的干扰。这样，我们可以在不阻塞任何数据库记录或表的情况下执行事务 A，并且如果检测到干扰，我们将终止事务
    A 并重试，直到在没有干扰的情况下成功为止。如果事务非常快，这种技术效果很好，因此干扰也很少。
- en: More specifically, if during transaction A, the value of the concurrency checks
    specified by an update operation differs from the one stored in the record being
    updated, the update is aborted, and a concurrency exception is thrown. The rationale
    is that another transaction, B, modified the concurrency check, thus interfering
    with the operation being performed by A.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 更具体地说，如果在事务 A 中，更新操作指定的并发检查值与正在更新的记录中存储的值不同，则更新将被终止，并抛出并发异常。其理由是另一个事务 B 修改了并发检查，从而干扰了
    A 正在执行的操作。
- en: 'Accordingly, the method that passes all changes applied to `DbContext` to the
    database performs a check for concurrency exceptions:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，将所有应用于 `DbContext` 的更改传递到数据库的方法会检查并发异常：
- en: '[PRE5]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The preceding implementation just calls the `SaveChangesAsync DbContext` context
    method, which saves all changes to the database, but then it intercepts all concurrency
    exceptions and detaches all the entities involved in the concurrency error from
    the context. This way, the next time a command retries the whole failed operation,
    their updated versions will be reloaded from the database.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的实现只是调用 `SaveChangesAsync DbContext` 上下文方法，将所有更改保存到数据库中，然后拦截所有并发异常，并将所有涉及并发错误的实体从上下文中分离。这样，下次命令重试整个失败的操作时，它们的更新版本将重新从数据库中加载。
- en: In other words, when the update fails because of the interference of transaction
    B, we allow the interfering transaction B to complete its process. Then, EF automatically
    reloads all entities modified by B that contain the value of the concurrency check
    modified by B. This way, when the operation is retried, if no other transaction
    interferes, there will be no conflict on the concurrency check.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 换句话说，当更新失败是因为事务 B 的干扰时，我们允许干扰事务 B 完成其过程。然后，EF 自动重新加载所有由 B 修改且包含 B 修改的并发检查值的实体。这样，当操作重试时，如果没有其他事务干扰，则并发检查将不会出现冲突。
- en: The practical usage of concurrency checks is detailed in the *A frontend microservice*
    example of *Chapter 21*, *Case Study*.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 并发检查的实际用法在 *第 21 章* 的 *案例研究* 中的 *前端微服务* 示例中详细说明。
- en: All repository implementations are defined in a `Repositories` folder to ensure
    better maintainability.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 所有仓储实现都定义在 `Repositories` 文件夹中，以确保更好的可维护性。
- en: Finally, all repositories are automatically discovered and added to the application
    DI engine, calling the `AddAllRepositories` method, which is defined in the DDD
    tools we added to the domain layer project. More details on how to ensure this
    method is called when the application starts are given in the example detailed
    description in the *A frontend microservice* section of *Chapter 21, Case Study*.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，所有仓储都被自动发现并添加到应用程序 DI 引擎中，调用定义在域层项目中添加的 DDD 工具中的 `AddAllRepositories` 方法。有关如何在应用程序启动时确保调用此方法的更多详细信息，请参阅
    *第 21 章，案例研究* 中 *前端微服务* 部分的详细描述。
- en: Defining the application layer
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义应用层
- en: The application layer contains the definition of all business operations. These
    business operations use data provided by the user to modify domain layer abstraction
    aggregates, such as touristic packages. When all business operations involved
    in the current user request have been performed, an `IUnitOfWork.SaveEntitiesAsync()`
    operation is performed to save all changes to the database.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 应用层包含所有业务操作的定义。这些业务操作使用用户提供的数据来修改领域层抽象聚合，例如旅游套餐。当当前用户请求中涉及的所有业务操作都已执行完毕后，执行`IUnitOfWork.SaveEntitiesAsync()`操作以将所有更改保存到数据库。
- en: 'As a first step, for simplicity, let’s freeze the application culture to `en-US`
    by adding the following code to the ASP.NET Core pipeline:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第一步，为了简单起见，让我们通过向ASP.NET Core管道添加以下代码将应用程序文化冻结为`en-US`：
- en: '[PRE6]'
  id: totrans-142
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'As a second step, we can create a `Tools` folder to place the `ApplicationLayer`
    code, which you can find in the `ch7` code of the GitHub repository associated
    with this book. With these tools in place, in `Program.cs`, we can add the code
    that automatically discovers and adds all queries, command handlers, and event
    handlers to the DI engine, as shown here:'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 作为第二步，我们可以创建一个`Tools`文件夹来放置`ApplicationLayer`代码，这些代码可以在与本书相关的GitHub仓库的`ch7`代码中找到。有了这些工具，我们可以在`Program.cs`中添加代码，自动发现并添加所有查询、命令处理器和事件处理器到DI引擎，如下所示：
- en: '[PRE7]'
  id: totrans-144
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Then, we must add a `Queries` folder to place all queries and their associated
    interfaces. As an example, let’s have a look at the query that lists all packages:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们必须添加一个`Queries`文件夹来放置所有查询及其相关接口。作为一个例子，让我们看看列出所有包的查询：
- en: '[PRE8]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: The query object is automatically injected into the application DB context.
    The `GetAllPackages` method uses LINQ to project all of the required information
    into `PackageInfosViewModel` and sorts all results in descending order on the
    `EndValidityDate` property.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 查询对象会自动注入到应用数据库上下文中。`GetAllPackages`方法使用LINQ将所有所需信息投影到`PackageInfosViewModel`中，并按`EndValidityDate`属性降序排序所有结果。
- en: 'The `Commands` folder contains all commands. As an example, let’s have a look
    at the command used to modify packages:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '`Commands`文件夹包含所有命令。作为一个例子，让我们看看用于修改包的命令：'
- en: '[PRE9]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Command handlers can be placed in the `Handlers` folder. It is worth analyzing
    the command that updates packages:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 命令处理器可以放置在`Handlers`文件夹中。分析更新包的命令是很有价值的：
- en: '[PRE10]'
  id: totrans-151
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Its constructor has automatically injected the `IPackageRepository` repository
    and an `IEventMediator` instance needed to trigger event handlers. The following
    code also shows the implementation of the standard `HandleAsync` command handler
    method:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数已自动注入了`IPackageRepository`仓库和一个`IEventMediator`实例，用于触发事件处理器。以下代码还展示了标准`HandleAsync`命令处理器方法的实现：
- en: '[PRE11]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Command operations are repeated until no concurrency exception is returned.
    `HandleAsync` uses the repository to get an instance of the entity to modify.
    If the entity is not found (it has been deleted), the commands stop its execution.
    Otherwise, all changes are passed to the retrieved aggregate. Immediately after
    the update, all events contained in the aggregate are triggered. In particular,
    if the price has changed, the event handler associated with the price change is
    executed. The concurrency check declared with the `[ConcurrencyCheck]` attribute
    on the `EntityVersion` property of the `Package` entity ensures that the package
    version is updated properly (by incrementing its previous version number by 1),
    as well as that the price-changed event is passed the right version numbers.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 命令操作会重复执行，直到没有并发异常返回。`HandleAsync`使用仓库获取要修改的实体实例。如果实体未找到（已被删除），则命令停止其执行。否则，所有更改都传递给检索到的聚合。更新后，立即触发聚合中包含的所有事件。特别是，如果价格已更改，则执行与价格变更相关的事件处理器。在`Package`实体的`EntityVersion`属性上使用`[ConcurrencyCheck]`属性声明并发检查确保包版本正确更新（通过将其前一个版本号增加1），以及将正确的版本号传递给价格变更事件。
- en: 'Also, event handlers are placed in the `Handlers` folder. As an example, let’s
    have a look at the price-changed event handler:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，事件处理器也放置在`Handlers`文件夹中。作为一个例子，让我们看看价格变更事件处理器：
- en: '[PRE12]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: The constructor has automatically injected the `IPackageEventRepository` repository,
    which handles the database table and all the events to send to other applications.
    The `HandleAsync` implementation simply calls the repository method that adds
    a new record to this table.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数已自动注入了`IPackageEventRepository`仓库，该仓库处理数据库表以及发送到其他应用的所有事件。`HandleAsync`的实现简单调用仓库方法，向该表添加新记录。
- en: All records in the table are handled by `IPackageEventRepository`, which can
    be retrieved and sent to all interested microservices by a parallel task defined
    in the DI engine with a call such as `builder.Services.AddHostedService<MyHostedService>();`,
    as detailed in the *Using generic hosts* subsection of *Chapter 11*, *Applying
    a Microservice Architecture to Your Enterprise Application*. However, this parallel
    task is not implemented in the GitHub code associated with this chapter.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 表中的所有记录都由`IPackageEventRepository`处理，可以通过DI引擎中定义的并行任务（例如`builder.Services.AddHostedService<MyHostedService>();`）检索并发送到所有感兴趣的微服务，如第11章中“使用通用宿主”小节中详细说明的。然而，这个并行任务并未在本书的GitHub代码中实现。
- en: It is worth recalling that the usage of events promotes code decoupling, and
    when events cross the microservice boundary, they implement efficient asynchronous
    communication between microservices, which improves performance and maximizes
    hardware resource usage.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 值得回忆的是，事件的使用促进了代码解耦，当事件跨越微服务边界时，它们实现了微服务之间的高效异步通信，这提高了性能并最大化了硬件资源的使用。
- en: The next subsection describes how to define controllers.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 下一小节将描述如何定义控制器。
- en: Defining controllers
  id: totrans-161
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定义控制器
- en: Each controller interacts with a use case that emerged in the analysis stage
    with its action methods. Action methods do their job by requiring command handlers
    and query interfaces from the dependency injection engine.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 每个控制器都通过其操作方法与在分析阶段出现的用例进行交互。操作方法通过从依赖注入引擎中要求命令处理程序和查询接口来完成其工作。
- en: 'Below is an example of how query objects are required and used:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个如何要求和使用查询对象的示例：
- en: '[PRE13]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Below, instead, is an example of the usage of command handlers:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是一个命令处理程序使用的示例：
- en: '[PRE14]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: '`ICommandHandler<UpdatePackageCommand>` retrieves the command handler associated
    with the `UpdatePackageCommand` command from DI.'
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: '`ICommandHandler<UpdatePackageCommand>`从DI中检索与`UpdatePackageCommand`命令关联的命令处理程序。'
- en: If `ModelState` is valid, `UpdatePackageCommand` is created, and its associated
    handler is invoked; otherwise, the View is displayed again to the user to enable
    them to correct all the errors.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如果`ModelState`有效，则创建`UpdatePackageCommand`，并调用其关联的处理程序；否则，将视图再次显示给用户，以便他们纠正所有错误。
- en: Summary
  id: totrans-169
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we analyzed the peculiarities of front-end microservices and
    the techniques used to implement them.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们分析了前端微服务的特性以及实现它们的技巧。
- en: Then, we put together the techniques learned in this chapter and in previous
    chapters in the complete implementation of a front-end microservice.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将本章和前几章学到的技术结合起来，在完整的前端微服务实现中应用。
- en: We used an onion architecture with a data layer and a domain layer abstraction,
    and we implemented each as a separate project. The application layer and the presentation
    layer were implemented together in the same ASP.NET Core MVC project.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 我们使用了一个洋葱架构，其中包含数据层和领域层抽象，并将每个实现作为一个独立的项目。应用层和表示层在同一个ASP.NET Core MVC项目中实现。
- en: The microservice used the CQRS pattern and used a queue implemented with a database
    table to store the events to send to other microservices.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 该微服务使用了CQRS模式，并使用一个基于数据库表的队列来存储发送给其他微服务的事件。
- en: The next chapter explains how to implement a presentation layer with client-based
    techniques. We will use Blazor as an example client framework.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 下一章将解释如何使用基于客户端的技术实现表示层。我们将使用Blazor作为示例客户端框架。
- en: Questions
  id: totrans-175
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 问题
- en: What is the difference between a front-end and an API gateway?
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前端和API网关之间的区别是什么？
- en: Why should all front-ends and API gateways use a robust web server?
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么所有前端和API网关都应该使用一个健壮的Web服务器？
- en: Why should complex blocking database transactions be avoided?
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么应该避免复杂的阻塞数据库事务？
- en: When does the concurrency technique ensure a better performance?
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 并发技术何时能确保更好的性能？
- en: What is the advantage of using domain events to implement interactions between
    different aggregates?
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用领域事件实现不同聚合之间的交互有什么优势？
- en: Further reading
  id: totrans-181
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Since this chapter just put into practice concepts explained in other chapters
    (mainly *Chapter 7*, *Understanding the Different Domains in Software Solutions*,
    *Chapter 11*, *Applying a Microservice Architecture to Your Enterprise Application*,
    and *Chapter 13*, *Interacting with Data in C# – Entity Framework Core*), here
    we will include just a few links on how to use API gateways and further information
    on the MediatR library, which was mentioned in the example:'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 由于本章只是将其他章节（主要是 *第 7 章*，*理解软件解决方案中的不同领域*，*第 11 章*，*将微服务架构应用于您的企业应用*，以及 *第 13
    章*，*在 C# 中与数据交互 – Entity Framework Core*）中解释的概念付诸实践，因此这里我们将仅包括一些关于如何使用 API 网关的链接以及关于在示例中提到的
    MediatR 库的更多信息：
- en: 'Ocelot GitHub repository: [https://github.com/ThreeMammals/Ocelot](https://github.com/ThreeMammals/Ocelot)'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Ocelot GitHub 仓库：[https://github.com/ThreeMammals/Ocelot](https://github.com/ThreeMammals/Ocelot)
- en: 'How to implement your API gateway with Ocelot: [https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-with-ocelot](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-with-ocelot)'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何使用 Ocelot 实现您的 API 网关：[https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-with-ocelot](https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-with-ocelot)
- en: 'Azure API Management: [https://azure.microsoft.com/en-us/services/api-management/#overview](https://azure.microsoft.com/en-us/services/api-management/#overview
    )'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure API 管理：[https://azure.microsoft.com/en-us/services/api-management/#overview](https://azure.microsoft.com/en-us/services/api-management/#overview)
- en: 'Azure App Service: [https://azure.microsoft.com/en-us/services/app-service/](https://azure.microsoft.com/en-us/services/app-service/)'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Azure 应用服务：[https://azure.microsoft.com/en-us/services/app-service/](https://azure.microsoft.com/en-us/services/app-service/)
- en: 'More information on MediatR can be found on MediatR’s GitHub repository: [https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 更多关于 MediatR 的信息可以在 MediatR 的 GitHub 仓库中找到：[https://github.com/jbogard/MediatR](https://github.com/jbogard/MediatR)
- en: Leave a review!
  id: totrans-188
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 留下评价！
- en: Enjoying this book? Help readers like you by leaving an Amazon review. Scan
    the QR code below for a 20% discount code.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 喜欢这本书吗？通过留下亚马逊评价来帮助像你这样的读者。扫描下面的二维码以获取 20% 的折扣码。
- en: '![](img/Leave_a_review_QR.png)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![留下评价的二维码](img/Leave_a_review_QR.png)'
- en: '**Limited Offer*'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: '**限时优惠**'
