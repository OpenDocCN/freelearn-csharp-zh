- en: Chapter 3. Learning Concurrency with Parallel Loops
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第 3 章. 使用并行循环学习并发
- en: 'In this chapter, we will cover:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖：
- en: Creating a basic parallel for loop
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的并行 for 循环
- en: Creating a basic parallel foreach loop
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 创建基本的并行 foreach 循环
- en: Breaking a parallel loop
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 打破并行循环
- en: Stopping a parallel loop
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 停止并行循环
- en: Cancelling a parallel loop
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 取消并行循环
- en: Handling exceptions in a parallel loop
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并行循环中处理异常
- en: Controlling the degree of parallelism in a loop
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 控制循环中的并行度
- en: Partitioning data in a parallel loop
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在并行循环中划分数据
- en: Using Thread Local Storage
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用线程局部存储
- en: Introduction
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: Most developers frequently write sequential code in the form of loops where
    they are doing something to each of the items in a collection of data. Loops are
    often an ideal place to introduce parallelism, because most of the time, the items
    in the collections are not related to each other, and we usually want to perform
    the same independent operation on all the items in a collection. However, parallelism
    comes with overhead. The individual loop iterations must perform enough work to
    justify the overhead of parallelism.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数开发者经常以循环的形式编写顺序代码，他们在数据集合中的每个项目上执行某些操作。循环通常是引入并行性的理想位置，因为大多数情况下，集合中的项目之间没有关系，我们通常希望对集合中的所有项目执行相同的独立操作。然而，并行性伴随着开销。单个循环迭代必须执行足够的工作以证明并行性的开销是合理的。
- en: The **.NET 4.5 Parallel Extensions** includes methods that simulate both parallel
    `For` and parallel `ForEach` loops, and both look very much like the loop syntax
    you already use for sequential loops. In fact, it is quite easy to change a sequential
    loop into a parallel loop which can complete faster on a computer with multiple
    cores.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: '**.NET 4.5 并行扩展** 包含模拟并行 `For` 和并行 `ForEach` 循环的方法，它们看起来非常像你已用于顺序循环的循环语法。事实上，将顺序循环更改为并行循环以在具有多个核心的计算机上更快完成相当容易。'
- en: In this chapter, we will be taking a look at how to use parallel `For` and parallel
    `ForEach` loops in your programs.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨如何在程序中使用并行 `For` 和并行 `ForEach` 循环。
- en: Creating a basic parallel for loop
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的并行 for 循环
- en: In this recipe, we will take a look at the syntax of a basic parallel `for`
    loop and compare its performance against a sequential `for` loop.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将查看基本并行 `for` 循环的语法，并将其性能与顺序 `for` 循环进行比较。
- en: For our comparison we will create a console application with two methods. Both
    methods will loop over a very large array of numbers and use the `Math.Sqrt()`
    method to calculate the square root of each number in the array. One of our methods
    will use a sequential `for` loop to process the array, the other will use a parallel
    `for` loop.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 对于我们的比较，我们将创建一个控制台应用程序，包含两个方法。这两个方法都将遍历一个非常大的数字数组，并使用 `Math.Sqrt()` 方法计算数组中每个数字的平方根。我们的一个方法将使用顺序
    `for` 循环来处理数组，另一个将使用并行 `for` 循环。
- en: Our program will time both operations and will display the results to the console
    when both loops finish.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 我们程序将计时这两个操作，并在两个循环都完成后在控制台显示结果。
- en: How to do it…
  id: totrans-19
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Now, let''s open up Visual Studio and create some parallel loops. The steps
    for creating the parallel `for` loops are as follows:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们打开 Visual Studio 并创建一些并行循环。创建并行 `for` 循环的步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `ParallelFor` as the **Solution name**.
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板创建一个新的项目，并将 `ParallelFor` 作为 **解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到程序类的顶部：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: First, let's implement the `Main` method of the program class. We are going
    to create a `StopWatch` object to perform the timing, create a large array of
    random numbers, and then call the methods to run the loops.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们实现程序类的 `Main` 方法。我们将创建一个 `StopWatch` 对象来执行计时，创建一个包含随机数字的大数组，然后调用方法来运行循环。
- en: '[PRE1]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Next let's create our `SequentialLoop` method which, as you might have guessed,
    executes a sequential `for` loop that calculates the square root of each number
    in the array.
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的 `SequentialLoop` 方法，正如你可能猜到的，它执行一个顺序 `for` 循环，计算数组中每个数字的平方根。
- en: '[PRE2]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Now we just need to create our `ParallelLoop` method which uses a parallel `for`
    loop to calculate the square root of each number in the array.
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们只需要创建我们的 `ParallelLoop` 方法，它使用并行 `for` 循环来计算数组中每个数字的平方根。
- en: '[PRE3]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_03_01.jpg)
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到类似于以下截图的输出：![如何实现…](img/0225OT_03_01.jpg)
- en: How it works…
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As you can see from the preceding results, on my quad-core machine there were
    some performance improvements with the parallel loop, but not as much as you might
    have expected. It is possible that on your machine the sequential loop might have
    even outperformed the parallel loop. If this is the case, it probably means that
    the overhead of creating the threads and performing the context switches to execute
    the threads on the CPU outweighed the benefits of parallelizing the loop. As the
    chapter continues, we will look at how we can improve the performance of our loops
    a bit more. For now, we are just focusing on the basics of the parallel for loop
    syntax.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的结果所示，在我的四核机器上，并行循环有一些性能提升，但并没有你预期的那么多。可能在你机器上，顺序循环甚至可能比并行循环表现更好。如果是这种情况，这可能意味着创建线程和执行线程在
    CPU 上的上下文切换的开销超过了并行化循环的好处。随着章节的继续，我们将探讨如何进一步提高我们循环的性能。现在，我们只是关注并行 for 循环语法的基础知识。
- en: In this recipe, we used the basic overload of the static `For` method of the
    `Parallel` class to create our loop. At this level the syntax looks very much
    like that of a sequential for loop.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们使用了 `Parallel` 类的静态 `For` 方法的基本重载来创建我们的循环。在这个级别上，语法看起来非常类似于顺序 for 循环。
- en: '[PRE4]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: The first two parameters forms the range the loop will iterate over. Note that
    `from` is an inclusive parameter and `to` is exclusive. So, if our first parameter
    is 0 and our second parameter is 10, our loop will iterate from 0 to 9.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 前两个参数构成了循环迭代的范围。请注意，`from` 是一个包含参数，而 `to` 是一个排除参数。因此，如果我们的第一个参数是 0，第二个参数是 10，我们的循环将从
    0 迭代到 9。
- en: The third parameter is a delegate of type `Action<int>` which always returns
    `void`. In this recipe, we use a Lambda expression for the delegate.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 第三个参数是一个返回 `void` 的 `Action<int>` 类型的委托。在本食谱中，我们使用 Lambda 表达式作为委托。
- en: '[PRE5]'
  id: totrans-37
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Creating a basic parallel foreach loop
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建基本的并行 foreach 循环
- en: In this recipe we will take a look at the syntax of a basic parallel foreach
    loop and compare its performance against that of a sequential foreach loop.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在本食谱中，我们将查看基本并行 foreach 循环的语法，并将其性能与顺序 foreach 循环的性能进行比较。
- en: For our comparison, like the previous recipe, we will create a Console Application
    with two methods which both loop over a very large array of numbers and use the
    `Math.Sqrt()` method to calculate the square root of each number in the array.
    One of our methods will use a sequential foreach loop to process the array, the
    other will use a parallel foreach loop.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 对于比较，就像之前的食谱一样，我们将创建一个控制台应用程序，其中包含两个方法，这两个方法都会遍历一个非常大的数字数组，并使用 `Math.Sqrt()`
    方法计算数组中每个数字的平方根。我们的一个方法将使用顺序 foreach 循环来处理数组，另一个将使用并行 foreach 循环。
- en: Our program will time both operations and we will display the results to the
    console when both loops finish.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将记录这两个操作的时间，并在两个循环完成后将结果显示到控制台。
- en: How to do it…
  id: totrans-42
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现…
- en: 'Now, let''s go to Visual Studio and see how to create parallel for loops. The
    steps to create parallel ForEach loops are as follows:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们转到 Visual Studio，看看如何创建并行 for 循环。创建并行 ForEach 循环的步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `ParallelForEach` as the **Solution name**.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板创建一个新的项目，并将 `ParallelForEach` 作为 **解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到程序类的顶部：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Let's start off by putting some code in the `Main` method of the program class
    to create a `StopWatch` object to perform the timing, create a large array of
    random numbers, and then call the two methods to run the loops.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从在程序类的 `Main` 方法中添加一些代码开始，创建一个 `StopWatch` 对象以执行计时，创建一个包含随机数字的大数组，然后调用两个方法来运行循环。
- en: '[PRE7]'
  id: totrans-48
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Next we need to create our `SequentialLoop` method to execute a sequential `foreach`
    loop that calculates the square root of each number in the array.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建我们的 `SequentialLoop` 方法来执行一个顺序 `foreach` 循环，该循环计算数组中每个数字的平方根。
- en: '[PRE8]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Now let's create our `ParallelLoop` method which uses a parallel `ForEach` loop
    to calculate the square root of each number in the array.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建我们的 `ParallelLoop` 方法，它使用并行 `ForEach` 循环来计算数组中每个数字的平方根。
- en: '[PRE9]'
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_03_02.jpg)
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到类似于以下截图的输出：![如何操作…](img/0225OT_03_02.jpg)
- en: How it works…
  id: totrans-54
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This time the sequential loop outperformed the parallel loop by a bit, at least
    on my machine.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，顺序循环在性能上略优于并行循环，至少在我的机器上是如此。
- en: 'In this recipe, we used the basic overload of the static `ForEach` method of
    the `Parallel` class to create our loop:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了 `Parallel` 类的静态 `ForEach` 方法的标准重载来创建我们的循环：
- en: '[PRE10]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: Basically, this is just a source that implements `IEnumerable<T>` and a delegate.
    In our case we used a Lambda expression for the delegate.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，这只是一个实现了 `IEnumerable<T>` 和委托的源。在我们的案例中，我们使用了 Lambda 表达式作为委托。
- en: '[PRE11]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Other than the type of loop we used and the parameter types, the code in this
    project is very much like that of our parallel for loop recipe.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们使用的循环类型和参数类型外，本项目中的代码与我们的并行 for 循环配方非常相似。
- en: Breaking a parallel loop
  id: totrans-61
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 跳出并行循环
- en: Occasionally when writing loops, we will want to break out of the loop under
    certain conditions. In a sequential loop we would accomplish this breakout with
    a C# `break` statement. However, a break statement is only valid when enclosed
    within an iteration statement like a foreach loop. When we run a parallel foreach,
    we are not running an iteration statement. It is actually a delegate running in
    a method.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 在编写循环时，我们有时会在特定条件下想要跳出循环。在顺序循环中，我们会使用 C# 的 `break` 语句来实现跳出。然而，`break` 语句仅在包含迭代语句（如
    foreach 循环）内有效。当我们运行并行 foreach 时，我们并没有运行迭代语句。实际上，这是一个在方法中运行的委托。
- en: In this recipe we will we learn how to use a TPL class called `ParallelLoopState`
    to break out of a parallel ForEach loop. `ParallelLoopState` is a class that allows
    concurrently running loop bodies to interact with each other. It also provides
    us with a way to break out of a loop. When the loop breaks or completes, we will
    check the completion status of our loop using the `ParallelLoopResult` structure.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们将学习如何使用名为 `ParallelLoopState` 的 TPL 类来跳出并行 ForEach 循环。`ParallelLoopState`
    是一个允许并发运行的循环体相互交互的类。它还为我们提供了跳出循环的方法。当循环跳出或完成时，我们将使用 `ParallelLoopResult` 结构来检查循环的完成状态。
- en: We are going to create a Console Application to download the contents of a book
    and split the individual words into a list of strings. We will then loop through
    the list of strings looking for a specific word. When we find the word we are
    looking for, we will use `ParallelLoopState` to break out of the loop.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将创建一个控制台应用程序来下载书籍内容并将单个单词拆分到一个字符串列表中。然后我们将遍历字符串列表以查找特定的单词。当我们找到我们正在寻找的单词时，我们将使用
    `ParallelLoopState` 来跳出循环。
- en: How to do it…
  id: totrans-65
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Now let''s take a look at how to cancel a parallel loop. The steps to cancel
    a parallel loop are as follows:'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何取消并行循环。取消并行循环的步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `BreakALoop` as the **Solution name**.
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板创建一个新的项目，并将 `Solution name` 设置为 `BreakALoop`。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到程序类顶部：
- en: '[PRE12]'
  id: totrans-69
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, let's add some code to the `Main` method of our program class to use
    a `WebClient` to download the contents of the book and split the words of the
    book into a string array.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们向程序类的 `Main` 方法添加一些代码，使用 `WebClient` 下载书籍内容并将书籍的单词拆分到一个字符串数组中。
- en: '[PRE13]'
  id: totrans-71
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Next, let's create our loop. The loop needs to process the list of strings looking
    for the word "immutability". When we find it, use `ParallelLoopState.Break` to
    break out of the loop.
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的循环。循环需要处理字符串列表以查找单词 "immutability"。当我们找到它时，使用 `ParallelLoopState.Break`
    来跳出循环。
- en: '[PRE14]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: We will finish adding a couple of lines to display the loop iteration we broke
    on, the completion status of the loop, and wait for the user to exit.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将完成添加几行代码以显示我们跳出循环的迭代次数、循环的完成状态，并等待用户退出。
- en: '[PRE15]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_03_03.jpg)
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到类似于以下截图的输出：![如何操作…](img/0225OT_03_03.jpg)
- en: How it works…
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, we used a different overload of `Parallel.ForEach`. This overload
    takes an `Action` delegate with the source and a loop state parameter.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个配方中，我们使用了 `Parallel.ForEach` 的不同重载。这个重载接受一个带有源和循环状态参数的 `Action` 委托。
- en: '[PRE16]'
  id: totrans-79
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: In the body of our loop, we used the loop state parameter to cancel the loop.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环体中，我们使用了循环状态参数来取消循环。
- en: '[PRE17]'
  id: totrans-81
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Note that we didn't instantiate the `ParallelLoopState` parameter that we passed
    into the loop. It was created and provided to us by the `Parallel` class. We just
    have to change our Lambda expression to indicate that we want to use the loop
    state parameter.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们没有实例化传递给循环的 `ParallelLoopState` 参数。它是通过 `Parallel` 类创建并提供的。我们只需更改我们的 Lambda
    表达式，以表明我们想要使用循环状态参数。
- en: The `Parallel.ForEach` method returns a `ParallelLoopResult` structure (`var
    loopResult`). This structure has a couple of very useful properties. One of which
    is `IsCompleted` that gets the loop completion status. A value of true indicates
    that all iterations of the loop were executed and the loop didn't receive a request
    to end prematurely. `LowestBreakIteration` gets the index of the lowest iteration
    from which `Break` was called.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel.ForEach` 方法返回一个 `ParallelLoopResult` 结构（`var loopResult`）。这个结构有几个非常实用的属性。其中之一是
    `IsCompleted`，它获取循环完成状态。值为 true 表示循环的所有迭代都已执行，并且循环没有收到提前结束的请求。`LowestBreakIteration`
    获取从哪个迭代开始调用 `Break` 的索引。'
- en: There is an important difference between breaking from a parallel loop and a
    sequential loop. When breaking a sequential loop, the break statement will immediately
    terminate the loop. `ParallelLoopState.Break` has a different behavior. What we
    are actually doing is signaling that we would like the loop terminated at the
    system's earliest convenience. The issue is that we are not processing a single
    element at a time. If we call `ParallelLoopState.Break` in one of our threads,
    other threads are likely to still be executing. Some code will continue to run
    for a short time after you request to terminate the loop.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 从并行循环跳出和从顺序循环跳出之间存在一个重要的区别。当跳出顺序循环时，break 语句将立即终止循环。`ParallelLoopState.Break`
    有不同的行为。我们实际上是在发出信号，表示我们希望系统在最早方便的时候终止循环。问题是我们在一次处理一个元素。如果我们在一个线程中调用 `ParallelLoopState.Break`，其他线程可能仍在执行。在你请求终止循环后，一些代码可能会继续运行一段时间。
- en: Stopping a parallel loop
  id: totrans-85
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 停止并行循环
- en: When you break from a parallel loop, the application will actually continue
    to process any elements of the collection that were found prior to the element
    that was being processed when the `ParallelLoopState.Break` method was called.
    Sometimes this behavior is not desirable and we want to end the loop immediately,
    without processing any loop iterations that are currently running.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 当你从并行循环中跳出时，应用程序实际上会继续处理在调用 `ParallelLoopState.Break` 方法时正在处理的元素之前找到的集合中的任何元素。有时这种行为是不希望的，我们希望立即结束循环，而不处理任何当前正在运行的循环迭代。
- en: In this recipe, we will look at how to use the `ParallelLoopState.Stop` method
    to request that the processing of elements terminate as soon as possible without
    guaranteeing that any other elements will be processed. We will again be using
    `WebClient` to download the contents of a book, and splitting the words into a
    sorted list of strings. We will loop through the list looking for the word "immutability".
    When we find it, we will stop the loop.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将探讨如何使用 `ParallelLoopState.Stop` 方法请求尽快终止元素的处理，而不保证处理任何其他元素。我们再次将使用
    `WebClient` 下载书籍的内容，并将单词拆分到一个排序后的字符串列表中。我们将遍历列表寻找单词 "immutability"。当我们找到它时，我们将停止循环。
- en: How to do it…
  id: totrans-88
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Now, let''s start Visual Studio and see how to stop a parallel loop. The steps
    to stop a parallel loop are as follows:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们启动 Visual Studio，看看如何停止并行循环。停止并行循环的步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `StopALoop` as the **Solution name**.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板创建一个新的项目，并将 `StopALoop` 作为 **解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到程序类顶部：
- en: '[PRE18]'
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: First, let's add some code to the `Main` method of our program class to use
    a `WebClient` to download the contents of the book, and split the words of the
    book into a string array.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们向程序类的 `Main` 方法添加一些代码，使用 `WebClient` 下载书籍的内容，并将书籍中的单词拆分到一个字符串数组中。
- en: '[PRE19]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: Next, let's create our loop. The loop needs to process the list of strings looking
    for the word "immutability". When we find it, use `ParallelLoopState.Stop` to
    stop the loop.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建我们的循环。循环需要处理字符串列表，寻找单词 "immutability"。当我们找到它时，使用 `ParallelLoopState.Stop`
    来停止循环。
- en: '[PRE20]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: We will finish adding a couple of lines to display the loops' completion status
    and wait for user's input to exit.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将完成添加几行以显示循环的完成状态，并等待用户输入以退出。
- en: '[PRE21]'
  id: totrans-98
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_03_04.jpg)
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该看到类似于以下截图的输出：![如何做…](img/0225OT_03_04.jpg)
- en: How it works…
  id: totrans-100
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: As in the previous recipe, we used the overload of `Parallel.ForEach` that takes
    an `Action` delegate with the source and a loop state parameter.
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 与前一个配方一样，我们使用了`Parallel.ForEach`的重载版本，它接受一个带有源和循环状态参数的`Action`委托。
- en: '[PRE22]'
  id: totrans-102
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: In the body of our loop, we used the loop state parameter to stop the loop.
    We also used the `ParallelLoopState.IsStopped` property to display the status
    of our loop.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环体中，我们使用了循环状态参数来停止循环。我们还使用了`ParallelLoopState.IsStopped`属性来显示循环的状态。
- en: '[PRE23]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: As you can see from the preceding results, the elements of the list that were
    currently in process when we stopped the loop, still get written to the console.
    However, `ParallelLoopState.Stop` does stop the loop more quickly than `ParallelLoopState.Break`
    and is better to use in a situation where you are searching for an element of
    a condition in the collection.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的结果所示，当我们停止循环时，列表中当前正在处理的项目仍然被写入控制台。然而，`ParallelLoopState.Stop`比`ParallelLoopState.Break`更快地停止循环，并且在搜索集合中条件元素的情况下更适合使用。
- en: Both `ParallelLoopState.Break` and `ParallelLoopState.Stop` behave differently
    from a break statement in a sequential loop. We are asking the application to
    process more than one thing at a time and we can no longer count on the sequence.
    It is easy to parallelize loops with the TPL, but it should be approached with
    caution because we can no longer rely on the order of the results.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParallelLoopState.Break`和`ParallelLoopState.Stop`的行为与顺序循环中的`break`语句不同。我们要求应用程序一次处理多个任务，并且我们不能再依赖序列。使用TPL（Task
    Parallel Library）并行化循环很容易，但应该谨慎处理，因为我们不能再依赖结果的顺序。'
- en: Cancelling a parallel loop
  id: totrans-107
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 取消并行循环
- en: As we've seen in previous recipes, to create a task that can be cancelled, you
    pass in a cancellation token from a `CancellationTokenSource` object. If you then
    make a call to the `CancellationTokenSource.Cancel` method, the token signals
    all of the tasks that use it should terminate. The linked tasks detect this signal
    via the token and stop their activity in a safe manner.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述的配方中看到的，要创建一个可取消的任务，你需要从一个`CancellationTokenSource`对象传递一个取消标记。如果你随后调用`CancellationTokenSource.Cancel`方法，该标记会向使用它的所有任务发出终止信号。链接的任务通过该标记检测到这个信号，并以安全的方式停止其活动。
- en: Parallel loops support the same cancellation token mechanism as parallel tasks.
    In a parallel loop, you supply the `CancellationToken` to the method in the `ParallelOptions`
    parameter.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 并行循环支持与并行任务相同的取消标记机制。在一个并行循环中，你将`CancellationToken`提供给`ParallelOptions`参数中的方法。
- en: This recipe will download the contents of a book and split the words into a
    list of strings. We will then use a parallel loop to iterate through the words
    writing each to the console. However, we will create a separate task that sleeps
    for a few seconds and then calls the `CancellationTokenSource.Cancel` method which
    will cancel the loop.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 本配方将下载一本书的内容，并将单词分割成字符串列表。然后我们将使用并行循环遍历单词，并将每个单词写入控制台。然而，我们将创建一个单独的任务，该任务暂停几秒钟，然后调用`CancellationTokenSource.Cancel`方法，这将取消循环。
- en: How to do it…
  id: totrans-111
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做…
- en: 'Let''s create a Console Application in Visual Studio so that we can see how
    to break a loop. The steps are as follows:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在Visual Studio中创建一个控制台应用程序，以便我们可以看到如何中断循环。步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `BreakALoop` as the **Solution name**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新的项目，并将`BreakALoop`作为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到程序类的顶部：
- en: '[PRE24]'
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: First, in the `Main` method of the program class, let's create a `CancellationTokenSource`
    and then add the `CancellationToken` to a `ParallelOptions` object.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在程序类的`Main`方法中，让我们创建一个`CancellationTokenSource`，然后将`CancellationToken`添加到`ParallelOptions`对象中。
- en: '[PRE25]'
  id: totrans-117
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: Next, just below the previous lines, create a simple task that sleeps for a
    few seconds and then calls the `Cancel` method on the `CancellationTokenSource`.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，在上一行文本的下方，创建一个简单的任务，该任务暂停几秒钟，然后调用`CancellationTokenSource`的`Cancel`方法。
- en: '[PRE26]'
  id: totrans-119
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Now create a `WebClient` to download the text of a book, and split the words
    from the book into a list of strings.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个`WebClient`来下载一本书的文本，并将书中的单词拆分到一个字符串列表中。
- en: '[PRE27]'
  id: totrans-121
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: Finally, let's create a simple parallel `foreach` loop that writes the strings
    to the console. The loop should be in a try/catch and we should be catching `OperationCancelledException`
    and `AggregateException`.
  id: totrans-122
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个简单的并行`foreach`循环，将字符串写入控制台。循环应该包含在`try/catch`块中，我们应该捕获`OperationCancelledException`和`AggregateException`。
- en: '[PRE28]'
  id: totrans-123
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_03_05.jpg)
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*键运行项目。你应该看到类似于以下截图的输出：![如何做到这一点…](img/0225OT_03_05.jpg)
- en: How it works…
  id: totrans-125
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: In this recipe we are using another overload of the `Parallel.ForEach` method
    that accepts an `IEnumerable` source, a `ParallelOptions` object, and an `Action`
    delegate.
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们使用`Parallel.ForEach`方法的另一个重载，它接受一个`IEnumerable`源、一个`ParallelOptions`对象和一个`Action`委托。
- en: '[PRE29]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: The difference between cancelling a task and cancelling a parallel loop is how
    we pass in the `CancellationToken`. With a task, a `CancellationToken` is passed
    directly into the constructor of the task. For a parallel loop, we set the `CancellationToken`
    property of a `ParallelOptions` object with our `CancellationToken`, and then
    pass the `ParallelOptions` object into the parallel loop method.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 取消任务和取消并行循环之间的区别在于我们如何传递`CancellationToken`。对于任务，`CancellationToken`直接传递到任务的构造函数中。对于并行循环，我们使用我们的`CancellationToken`设置`ParallelOptions`对象的`CancellationToken`属性，然后将`ParallelOptions`对象传递给并行循环方法。
- en: If the token that signals the cancellation is the same token that is set on
    the `ParallelOptions` instance, then the parallel loop will throw an `OperationCanceledException`
    on cancellation. If a different token causes cancellation, the loop will throw
    an `AggregateException` with an `OperationCanceledException` as an `InnerException`.
    Both should be handled in your `catch` blocks.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 如果表示取消的令牌与设置在`ParallelOptions`实例上的令牌相同，那么在取消时并行循环将抛出`OperationCanceledException`。如果不同的令牌导致取消，循环将抛出一个包含`OperationCanceledException`作为`InnerException`的`AggregateException`。这两个都应该在您的`catch`块中处理。
- en: Handling exceptions in a parallel loop
  id: totrans-130
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在并行循环中处理异常
- en: When a sequential loop throws an exception, the normal flow of the loop is interrupted.
    Control will be passed to a `catch` block or, if left unhandled, the exception
    is passed to the .NET runtime, and the process is aborted.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当一个顺序循环抛出异常时，循环的正常流程将被中断。控制权将传递给一个`catch`块，或者如果未处理，异常将被传递给.NET运行时，并终止进程。
- en: Parallel `For` and `ForEach` loops are similar in that they do not have any
    special mechanism to handle exceptions that might be thrown. It is up to us to
    handle any exceptions which might be thrown on one or multiple threads by wrapping
    all exceptions from the loop in an `AggregateException`.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parallel For`和`ForEach`循环在它们都不具有处理可能抛出的异常的特殊机制方面相似。处理任何可能在一个或多个线程上抛出的异常的责任在我们身上，我们需要通过将循环中的所有异常包装在`AggregateException`中来处理这些异常。'
- en: In this recipe, we will create a simple parallel `For` loop that loops through
    a range of numbers, writing the values to the console. If the number being processed
    is higher than a set number, we will throw a new `ArgumentException` which we
    will then store in a queue and later throw as part of an `AggregateException`.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个简单的并行`For`循环，该循环遍历一系列数字，并将值写入控制台。如果正在处理的数字高于一个设定的数字，我们将抛出一个新的`ArgumentException`，然后将其存储在队列中，稍后作为`AggregateException`的一部分抛出。
- en: Getting ready…
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 准备中…
- en: For this recipe we need to turn off the Visual Studio 2012 Exception Assistant.
    The Exception Assistant appears whenever a runtime exception is thrown, and intercepts
    the exception before it gets to our handler.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个菜谱，我们需要关闭Visual Studio 2012的异常助手。异常助手会在抛出运行时异常时出现，并在它到达我们的处理器之前拦截异常。
- en: To turn off the Exception Assistant, go to the **Debug** menu and select **Exceptions**.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 要关闭异常助手，请转到**调试**菜单并选择**异常**。
- en: Uncheck the **User-unhandled** checkbox next to **Common Language Runtime Exceptions**.![Getting
    ready…](img/0225OT_03_10.jpg)
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 取消选中**公共语言运行时异常**旁边的**用户未处理**复选框。![准备中…](img/0225OT_03_10.jpg)
- en: How to do it…
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: 'Let''s take a look at how to handle exceptions in parallel loops. The steps
    are as follows:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何处理并行循环中的异常。步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `LoopExceptions` as the **Solution name**.
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新的项目，并将`LoopExceptions`分配为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到程序类的顶部：
- en: '[PRE30]'
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In the `Main` method of the program class, create a try/catch block. The `catch`
    block should have some code for looping through `AggregateException.InnerExceptions`
    and displaying the wrapped exception messages to the console.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在程序类的 `Main` 方法中，创建一个 try/catch 块。`catch` 块应该包含一些代码，用于遍历 `AggregateException.InnerExceptions`
    并将封装的异常消息显示到控制台。
- en: '[PRE31]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Inside the `try` block, define a variable of type `ConcurrentCollection<Exception>`.
    This will be the container to hold our exceptions until we are ready to wrap them
    in an `AggregateException`.
  id: totrans-145
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `try` 块内部，定义一个类型为 `ConcurrentCollection<Exception>` 的变量。这将是我们的异常容器，直到我们准备好将它们封装在
    `AggregateException` 中。
- en: '[PRE32]'
  id: totrans-146
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Finally, let's create a simple parallel `ForEach` loop that loops from 0 to
    100\. If the loop encounters a number greater than 95, it should throw an `ArgumentException`.
    The body of the loop needs a try/catch block to catch the argument exception to
    enqueue it.
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，让我们创建一个简单的并行 `ForEach` 循环，循环从 0 到 100。如果循环遇到大于 95 的数字，它应该抛出一个 `ArgumentException`。循环的主体需要一个
    try/catch 块来捕获参数异常并将其入队。
- en: '[PRE33]'
  id: totrans-148
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_03_06.jpg)
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到类似于以下截图的输出：![如何做到这一点…](img/0225OT_03_06.jpg)
- en: How it works…
  id: totrans-150
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: In this recipe, the outer `catch` block handles `AggregateException` which can
    wrap many individual exception objects. Any one or all the actual threads created
    by calling `Parallel.For` could throw an `AggregateException`. In our `catch`
    block, we need to loop through `AggregateException.InnerExceptions` to process
    individual exceptions that occurred.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，外部的 `catch` 块处理 `AggregateException`，它可以封装多个单独的异常对象。调用 `Parallel.For`
    时创建的任何或所有实际线程都可能抛出 `AggregateException`。在我们的 `catch` 块中，我们需要遍历 `AggregateException.InnerExceptions`
    来处理发生的单个异常。
- en: '[PRE34]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: We have also created a try/catch block in the body of the parallel loop. This
    `catch` block catches any type of exception thrown in the loop and simply enqueues
    it in a `ConcurrentQueue<Exception>`. `ConcurrentQueue<T>` is a thread-safe first-in-first-out
    collection that implements `IEnumerable<T>`. `AggregateException` has a constructor
    overload that accepts `IEnumerable<Exception>`, so we can wrap our exception collection
    in `AggregateException` by passing the `ConcurrentCollection` to the constructor.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还在并行循环的主体中创建了一个 try/catch 块。这个 `catch` 块捕获循环中抛出的任何类型的异常，并将其简单地入队到 `ConcurrentQueue<Exception>`
    中。`ConcurrentQueue<T>` 是一个线程安全的先进先出集合，实现了 `IEnumerable<T>`。`AggregateException`
    有一个构造函数重载，可以接受 `IEnumerable<Exception>`，因此我们可以通过将 `ConcurrentCollection` 传递给构造函数来将我们的异常集合封装在
    `AggregateException` 中。
- en: '[PRE35]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: Controlling the degree of parallelism in a loop
  id: totrans-155
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 控制循环中的并行度
- en: By default, `Parallel.For` and `Parallel.ForEach` utilize as many threads as
    the underlying thread scheduler will provide. Usually it is good enough to let
    the system manage how iterations of a parallel loop are mapped to your computer's
    cores. Sometimes, however, you might want more control over the maximum number
    of threads that are used. For example, if you know that an algorithm you are using
    won't scale beyond a certain number of cores; you might want to limit the cores
    used in order to avoid wasting cycles.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`Parallel.For` 和 `Parallel.ForEach` 会使用底层线程调度器提供的线程数。通常，让系统管理并行循环的迭代如何映射到你的计算机核心上是足够的。有时，你可能想要对使用的最大线程数有更多的控制。例如，如果你知道你使用的算法不会扩展到一定数量的核心；你可能想要限制使用的核心数，以避免浪费周期。
- en: The number of tasks created by `Parallel.For` and `Parallel.ForEach` is often
    greater than the number of available cores. However, you can limit the maximum
    number of tasks used concurrently by specifying the `MaxDegreeOfParallelism` property
    of a `ParallelOptions` object.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `Parallel.For` 和 `Parallel.ForEach` 创建的任务数量通常大于可用的核心数。然而，你可以通过指定 `ParallelOptions`
    对象的 `MaxDegreeOfParallelism` 属性来限制同时使用的最大任务数。
- en: In this recipe, we are going to create a large array of integers. We will then
    pass this array to a couple of parallel `For` loops. One loop will run with the
    default degree of parallelism, and the other will be limited to four threads.
    We will display the time it takes to run each loop to see if there is any performance
    difference between the two.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建一个大型整数数组。然后，我们将此数组传递给几个并行 `For` 循环。一个循环将以默认的并行度运行，另一个将被限制为四个线程。我们将显示每个循环的运行时间，以查看两个之间是否存在任何性能差异。
- en: How to do it…
  id: totrans-159
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点…
- en: 'Let''s take a look at how we can control the degree of parallelism in a parallel
    loop. The steps are as follows:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何控制并行循环中的并行度。步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `DegreeOfParallelism` as the **Solution name**.
  id: totrans-161
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板创建一个新的项目，并将`DegreeOfParallelism`作为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到程序类的顶部：
- en: '[PRE36]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: First, in the program class, let's create a method named `DefaultParallelism`
    that takes an array of `Int32` as a parameter. The method calls `Parallel.For`
    and loops through the array calculating the square root of each element.
  id: totrans-164
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在程序类中，让我们创建一个名为`DefaultParallelism`的方法，该方法接受一个`Int32`数组作为参数。该方法调用`Parallel.For`并遍历数组计算每个元素的平方根。
- en: '[PRE37]'
  id: totrans-165
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Next, let's create another method named `LimitedParallelism` that takes the
    same type of parameter. This method will also call `Parallel.For` and loop through
    the array calculating the square root of each element. The only difference is
    that this method will also create a `ParallelOptions` object with the `MaxDegreeOfParallelism`
    property set to `4`.
  id: totrans-166
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建另一个名为`LimitedParallelism`的方法，该方法接受相同类型的参数。此方法也将调用`Parallel.For`并遍历数组计算每个元素的平方根。唯一的区别是，此方法还将创建一个具有`MaxDegreeOfParallelism`属性设置为`4`的`ParallelOptions`对象。
- en: '[PRE38]'
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Finally, in the `Main` method, we need to create a large array of `Int32` and
    initialize the array elements to random numbers. We also need to set up a `StopWatch`
    object so we can capture some time and call the two methods.
  id: totrans-168
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Main`方法中，我们需要创建一个大的`Int32`数组并将数组元素初始化为随机数。我们还需要设置一个`StopWatch`对象，以便我们可以捕获一些时间并调用这两个方法。
- en: '[PRE39]'
  id: totrans-169
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_03_07.jpg)
  id: totrans-170
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*键运行项目。你应该会看到类似于以下截图的输出：![如何做…](img/0225OT_03_07.jpg)
- en: How it works…
  id: totrans-171
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: This recipe doesn't have an algorithm that benefits from controlling the degree
    of parallelism, but in certain long running loop bodies, the ThreadPool's heuristics
    will be unable to determine the right number of threads to utilize, and could
    end up injecting many more than is appropriate.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这个菜谱没有算法可以从控制并行度中受益，但在某些长时间运行的循环体中，ThreadPool的启发式算法将无法确定要利用的正确线程数，并可能导致注入比适当数量更多的线程。
- en: The degree of parallelism is controlled by creating a `ParallelOptions` object
    and setting the `MaxDegreeOfParallelism` property.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 通过创建一个`ParallelOptions`对象并设置`MaxDegreeOfParallelism`属性来控制并行度。
- en: '[PRE40]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: Once created, the `ParallelOptions` object can be passed into one of the many
    overloads of `Parallel.For` or `Parallel.ForEach` that accept `ParallelOptions`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦创建，`ParallelOptions`对象可以传递给接受`ParallelOptions`的`Parallel.For`或`Parallel.ForEach`的许多重载之一。
- en: '[PRE41]'
  id: totrans-176
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: Partitioning data in a parallel loop
  id: totrans-177
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在并行循环中划分数据
- en: When creating a `Parallel.For` or `Parallel.ForEach` loops, we are effectively
    queuing up a delegate of work that will eventually be run on a ThreadPool worker
    thread. The amount of time taken to create and swap out these delegate payloads
    can have a very adverse effect on performance, especially when we create loops
    with small delegate bodies.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 当创建`Parallel.For`或`Parallel.ForEach`循环时，我们实际上是在为最终将在ThreadPool工作线程上运行的委托工作排队。创建和交换这些委托负载所需的时间可能会对性能产生非常不利的影响，尤其是在我们创建具有小委托体的循环时。
- en: There is a default `Partitioner<T>` class that uses a default partitioning algorithm
    that takes into account the number of cores on your system and other factors,
    but default portioning may or may not yield the best results.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个默认的`Partitioner<T>`类，它使用默认的分区算法，该算法考虑了系统上的核心数和其他因素，但默认分区可能或可能不会产生最佳结果。
- en: The .NET 4.5 Parallel Extensions also allows us to create our own custom partitioning
    chunks so that the workload of a `Parallel.For` or `Parallel.ForEach` is broken
    up into of a size that we specify in our code. We are effectively creating a custom
    partitioning algorithm.
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 4.5并行扩展还允许我们创建自己的自定义分区块，以便将`Parallel.For`或`Parallel.ForEach`的工作负载划分为我们代码中指定的尺寸。我们实际上正在创建一个自定义分区算法。
- en: In this recipe we are going to create three parallel loops that each iterate
    over a large array of integers. One of the loops will use no data partitioning,
    one will use the default partitioner, and one will use a custom partition. We
    will capture the time it takes each loop to iterate over the array and display
    the results.
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将创建三个并行循环，每个循环遍历一个大的整数数组。其中一个循环将不使用数据分区，一个将使用默认分区器，另一个将使用自定义分区。我们将捕获每个循环遍历数组所需的时间并显示结果。
- en: How to do it…
  id: totrans-182
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何实现...
- en: 'Now, let''s see how we can partition data for a parallel loop. The steps are
    as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看如何为并行循环分区数据。步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `PartitionData` as the **Solution name**.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用**C#控制台应用程序**项目模板启动一个新的项目，并将`PartitionData`作为**解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下`using`指令添加到程序类的顶部：
- en: '[PRE42]'
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: First, in the program class, let's create a method called `NoPartitioning` that
    takes an array of integers as a parameter. As the name indicates, this method
    will use no partitioning and will just iterate over the elements in the array
    calculating the square root of each element.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，在程序类中，让我们创建一个名为`NoPartitioning`的方法，它接受一个整数数组作为参数。正如其名称所示，这个方法将不使用分区，并且将遍历数组中的元素，计算每个元素的平方根。
- en: '[PRE43]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: Next, we need to create a method called `DefaultPartition`. Like the other method,
    this one will take an array of integers as its parameter and will iterate over
    the array calculating the square root of each element in the array. This method
    will use the `Partitioner.Create` method to create a partition for the data.
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要创建一个名为`DefaultPartition`的方法。像其他方法一样，这个方法将接受一个整数数组作为其参数，并将遍历数组，计算数组中每个元素的平方根。这个方法将使用`Partitioner.Create`方法为数据创建分区。
- en: '[PRE44]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: Now let's create a method called `CustomPartitioning`. This method will use
    a different overload of `Partitioner.Create` which allows us to specify the range
    size we want to use.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们创建一个名为`CustomPartitioning`的方法。这个方法将使用`Partitioner.Create`的不同重载，允许我们指定我们想要使用的范围大小。
- en: '[PRE45]'
  id: totrans-192
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Finally, in the `Main` method, we need to create a large array of `Int32` and
    initialize the array elements to random numbers. We also need to set up a `StopWatch`
    object so we can capture some time and call the three methods.
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在`Main`方法中，我们需要创建一个大的`Int32`数组，并将数组元素初始化为随机数。我们还需要设置一个`StopWatch`对象，以便我们可以捕获一些时间并调用三个方法。
- en: '[PRE46]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_03_08.jpg)
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在Visual Studio 2012中，按*F5*运行项目。你应该看到类似于以下屏幕截图的输出：![如何实现…](img/0225OT_03_08.jpg)
- en: How it works…
  id: totrans-196
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: As you can see from the preceding screenshot, there was quite a performance
    improvement realized from using custom partitioning.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 如前一个屏幕截图所示，使用自定义分区实现了相当大的性能提升。
- en: In this recipe, the `NoPartitioning` method iterates through the array performing
    the `Math.Sqrt` operation on each element with no partitioning of the array at
    all. The body of the loop is handed to the `Parallel.ForEach` method as a delegate,
    and the body of a parallel loop is so small that the cost of the delegate invocation
    on each loop's iteration is very significant. As a result, the performance is
    not very good.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，`NoPartitioning`方法遍历数组，对每个元素执行`Math.Sqrt`操作，而根本不进行数组分区。循环体被传递给`Parallel.ForEach`方法作为代理，而并行循环的体非常小，因此每个循环迭代的代理调用成本非常显著。因此，性能不是很好。
- en: In the `DefaultPartitioning` method, we used one of the `Create` method overloads
    of the `Partitioner` class to create an `IEnumerable<T>` of range partitions over
    the source array. The benefit of doing this is that the delegate invocation cost
    is incurred only once per range, rather than once per element. As you can see,
    that resulted in a pretty nice performance improvement.
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
  zh: 在`DefaultPartitioning`方法中，我们使用了`Partitioner`类的`Create`方法的重载之一，以在源数组上创建范围分区的`IEnumerable<T>`。这样做的好处是，代理调用成本仅在每个范围内发生一次，而不是在每个元素上发生一次。正如你所看到的，这导致了相当不错的性能提升。
- en: '[PRE47]'
  id: totrans-200
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: In the `CustomPartitioning` method, we use a different overload of `Partitioner.Create`
    to create a custom partition that chunks a range that we specified.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 在`CustomPartitioning`方法中，我们使用`Partitioner.Create`的不同重载来创建一个自定义分区，该分区将我们指定的范围分成块。
- en: '[PRE48]'
  id: totrans-202
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: Basically we told the partitioner to create a partition from 0 to `numbers.Count()`
    with a chunk size of 1,00,000\. In other words, we partitioned the array into
    ten equal parts. The performance improvement was pretty substantial.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 基本上，我们告诉分区器从 0 到 `numbers.Count()` 创建一个分区，分区大小为 1,00,000。换句话说，我们将数组分成了十等份。性能提升相当显著。
- en: The key lesson here is that the overhead of delegate invocation, particularly
    in loops with small bodies, can be very significant. Consider using either the
    default partitioning scheme, or a custom chunk partitioner to improve the performance
    of your parallel loops.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的关键教训是，委托调用的开销，尤其是在小体循环中，可能非常显著。考虑使用默认的分区方案，或者自定义块分区器来提高并行循环的性能。
- en: Using Thread Local Storage
  id: totrans-205
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用线程局部存储
- en: Computers are pretty good at counting. Sometimes we need to create loops that
    accumulate a running count of the occurrence of some piece data. How would we
    manage something like that when using `Parallel.For` or `Parallel.Foreach` loops?
    We could have any number of threads counting at the same time.
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 计算机在计数方面相当擅长。有时我们需要创建循环来累积某些数据的出现次数的运行计数。当使用 `Parallel.For` 或 `Parallel.Foreach`
    循环时，我们如何管理类似的事情？我们可以同时拥有任意数量的线程进行计数。
- en: What we need to accomplish this is **Thread Local Storage**. Thread Local Storage
    gives us the ability to store and retrieve states in each separate task that is
    created by a `Parallel.For` or `Parallel.ForEach` loop, and avoid the overhead
    of synchronizing accesses to a shared state variable.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要完成这项工作的是 **线程局部存储**。线程局部存储使我们能够在由 `Parallel.For` 或 `Parallel.ForEach` 循环创建的每个单独的任务中存储和检索状态，并避免同步访问共享状态变量的开销。
- en: Thread Local Storage is a programming method that uses static memory local to
    a thread. This is sometimes needed because normally all threads in a process share
    the same address space. In other words, data in a static or global variable is
    normally always located at the same memory location, when referred to from the
    same process. TLS variables are on the call and are local to threads, because
    each thread has its own stack.
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 线程局部存储是一种编程方法，它使用线程的静态内存。这有时是必要的，因为通常进程中的所有线程共享相同的地址空间。换句话说，从同一进程引用时，静态或全局变量中的数据通常总是位于相同的内存位置。TLS
    变量在调用时是局部的，因为每个线程都有自己的堆栈。
- en: In this recipe, we are going to see how we can use the thread-local variables
    to store the value of a word count in each thread created by `Parallel.ForEach`
    loop. After the loops finish, we will then write the final result only once to
    a shared variable.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们将看到如何使用线程局部变量在由 `Parallel.ForEach` 循环创建的每个线程中存储单词计数的值。循环完成后，我们只将最终结果写入一次共享变量。
- en: How to do it…
  id: totrans-210
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何操作…
- en: 'Ok, let''s take a look at how we can use the Thread Local Storage in our parallel
    loops. The steps are as follows:'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们看看我们如何在并行循环中使用线程局部存储。步骤如下：
- en: Start a new project using the **C# Console Application** project template and
    assign `ThreadLocalStorage` as the **Solution name**.
  id: totrans-212
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用 **C# 控制台应用程序** 项目模板创建一个新的项目，并将 `ThreadLocalStorage` 作为 **解决方案名称**。
- en: 'Add the following `using` directives to the top of your program class:'
  id: totrans-213
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下 `using` 指令添加到程序类顶部：
- en: '[PRE49]'
  id: totrans-214
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: First, let's add some code to the `Main` method of the program class to use
    `WebClient` to download the text of a book, and split the words of the book into
    an array of strings. Also, we will create an `integer` variable which will hold
    our word count.
  id: totrans-215
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们向程序类的 `Main` 方法添加一些代码，使用 `WebClient` 下载一本书的文本，并将书的单词拆分到一个字符串数组中。此外，我们还将创建一个
    `integer` 变量，它将保存我们的单词计数。
- en: '[PRE50]'
  id: totrans-216
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Next, let's create a parallel `ForEach` loop that takes an array of `String`,
    has an `Int32` thread-local variable, and passes its `Int32` result to an `Interlocked.Add`
    method.
  id: totrans-217
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们创建一个并行 `ForEach` 循环，它接受一个 `String` 数组，有一个 `Int32` 线程局部变量，并将它的 `Int32`
    结果传递给 `Interlocked.Add` 方法。
- en: '[PRE51]'
  id: totrans-218
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE51]'
- en: Let's finish up by displaying the result and waiting for user input.
  id: totrans-219
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们通过显示结果并等待用户输入来完成。
- en: '[PRE52]'
  id: totrans-220
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: In Visual Studio 2012, press *F5* to run the project. You should see output
    similar to the following screenshot:![How to do it…](img/0225OT_03_09.jpg)
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 Visual Studio 2012 中，按 *F5* 运行项目。你应该会看到类似于以下截图的输出：![如何操作…](img/0225OT_03_09.jpg)
- en: How it works…
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的…
- en: Using a thread-local variable in a parallel `ForEach` loop means that we have
    to use the `Parallel.ForEach` method overload that takes two type parameters and
    two function parameters. Our first parameter is the type of the elements in our
    source (`String`). The second parameter specifies the type of our thread-local
    variable (`Int32`). The third parameter is a `Func<TSource, ParallelLoopState,
    TLocal, TLocal>` delegate that is invoked on each loop iteration. The fourth parameter
    is an `Action<T>` delegate that the method will invoke when all loops are finished.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 在并行`ForEach`循环中使用线程局部变量意味着我们必须使用接受两个类型参数和两个函数参数的`Parallel.ForEach`方法重载。我们的第一个参数是我们源中元素的类型（`String`）。第二个参数指定我们的线程局部变量的类型（`Int32`）。第三个参数是一个在每次循环迭代时被调用的`Func<TSource,
    ParallelLoopState, TLocal, TLocal>`委托。第四个参数是一个当所有循环完成后方法将调用的`Action<T>`委托。
- en: '[PRE53]'
  id: totrans-224
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In the body of our loop, the loop passes our input parameters to our function
    delegate. The parameters are the current element, a `ParallelLoopState` variable
    and the thread local variable.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 在循环体中，循环将我们的输入参数传递给我们的函数委托。这些参数是当前元素、一个`ParallelLoopState`变量以及线程局部变量。
- en: '[PRE54]'
  id: totrans-226
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: 'After the loop completes, we return our thread-local variable and it gets passed
    to the `Action<T>` delegate where we add it to our shared state variable using
    `Interlocked.Add()`:'
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
  zh: 循环完成后，我们返回我们的线程局部变量，并将其传递给`Action<T>`委托，在那里我们使用`Interlocked.Add()`将其添加到我们的共享状态变量中：
- en: '[PRE55]'
  id: totrans-228
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
