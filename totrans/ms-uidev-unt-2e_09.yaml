- en: '7'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Exploring Automatic Layouts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have the basics of manually positioning, scaling, and aligning UI
    elements with the Rect Transform and anchors, we can explore how to use automatic
    layouts. Automatic layouts allow you to group your UI elements so that they will
    position automatically relative to each other.
  prefs: []
  type: TYPE_NORMAL
- en: There are quite a few scenarios in which you will want Unity to automatically
    control the layout of your UI objects. If you are generating UI items via code
    and the number of items may change, but you still want them to line up, scale,
    and position properly, you can use automatic layouts. Also, if you want perfectly
    spaced UI objects, automatic layouts will help you create this perfect spacing
    without having to do any position calculating yourself. These automatic layouts
    work well for things like inventory systems aligned in a grid or list.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will discuss the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Layout Group components to automatically space, position, and align a
    group of UI objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the Layout Element component, the Content Size Fitter component, and the
    Aspect Ratio Fitter component to resize UI elements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a horizontal HUD selection menu
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to set up a grid inventory
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: All the examples shown in this section can be found within the Unity package
    named **Chapter 07****.unitypackage**, within the code bundle. Each example image
    has a caption stating the example number within the scene. In the scene, each
    example is on its own Canvas, and some of the Canvases are deactivated. To view
    an example on a deactivated Canvas, simply select the checkbox next to the Canvas’
    name in the **Inspector**.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_07.01_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: The checkbox to enable or disable a Canvas example'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore the different types of Automatic Layout Groups.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'You can find the relevant codes and asset files of this chapter here: [https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2007](https://github.com/PacktPublishing/Mastering-UI-Development-with-Unity-2nd-Edition/tree/main/Chapter%2007)'
  prefs: []
  type: TYPE_NORMAL
- en: Types of automatic layout groups
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When a UI object has an automatic layout group component attached to it, all
    of its children will be aligned, resized, and positioned based on the parameters
    of the layout component. There are three automatic layout group options: **Horizontal
    Layout Group**, **Vertical Layout Group**, and **Grid** **Layout Group**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows three Panels (represented by gray rectangles),
    each with six UI Image children (represented by the black rectangles); the first
    Panel has a Horizontal Layout Group component, the second Panel has a Vertical
    Layout Group component, and the third Panel has a Grid Layout Group component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.2: Automatic Layout Groups Example 1 in the Chapter7 scene](img/Figure_07.02_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Automatic Layout Groups Example 1 in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding screenshot, you can see clearly what the three types of
    automatic layout groups accomplish. You can use any combination of the three to
    create nested, perfectly spaced layouts, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.3: Automatic Layout Groups Example 2 in the Chapter7 scene](img/Figure_07.03_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Automatic Layout Groups Example 2 in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s look at each of these layout groups individually and explore their various
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: Horizontal Layout Group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: All the children of a UI object with a **Horizontal Layout Group** component
    will be automatically placed side by side. If you allow the Horizontal Layout
    Group to resize the children, they will be positioned and scaled so that they
    are fully within the bounds of the parent object’s Rect Transform. Padding properties
    can be adjusted, however, if you’d like them to go outside the bounds of the parent’s
    Rect Transform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The order in which the children appear in the **Hierarchy** determines the
    order in which they will be laid out by the Horizontal Layout Group. The children
    will be laid out from left to right. The topmost child in the Hierarchy will be
    placed in the leftmost position, and the bottommost child in the Hierarchy will
    be placed in the rightmost position:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.4: Horizontal Layout Groups Example 1 in the Chapter7 scene](img/Figure_07.04_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: Horizontal Layout Groups Example 1 in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a Horizontal Layout Group component to a UI object, select **Add Component**
    | **Layout** | **Horizontal Layout Group** from within the object’s **Inspector**.
    If you click on the arrow next to the **Padding** property, you should see the
    following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.5: The Horizontal Layout Group component](img/Figure_07.05_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: The Horizontal Layout Group component'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore each of the properties of the Horizontal Layout Group component
    further.
  prefs: []
  type: TYPE_NORMAL
- en: Padding
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Padding** property represents the padding around the edges of the parent
    object’s Rect Transform. Positive numbers will move the child objects inward,
    and negative numbers will move the child objects outward.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.6: Horizontal Layout Groups Example 2 in the Chapter7 scene](img/Figure_07.06_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Horizontal Layout Groups Example 2 in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: As an example, the previous screenshot shows three Panels with various padding
    values applied. The first Panel has no padding, the second Panel has positive
    padding on all four sides, and the third Panel has positive padding on the left,
    right, and bottom but negative padding on the top.
  prefs: []
  type: TYPE_NORMAL
- en: Spacing
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Spacing** property determines the horizontal spacing between the child
    objects. This may be overridden if you use the **Child Force Expand** property
    without the **Control Child Size** property, and the children may have larger
    spacing.
  prefs: []
  type: TYPE_NORMAL
- en: Child Alignment
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Child Alignment** property determines where the group of children will
    be aligned. There are nine options for this property, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.7: The Child Alignment options of the Horizontal Layout Group](img/Figure_07.07_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: The Child Alignment options of the Horizontal Layout Group'
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, the following diagram shows three overlapping Panels that fill
    the screen. The Rect Transform area for these parent Panels is represented by
    the selected Rect Transform. The first Panel has an **Upper Left** Child Alignment.
    Its children are represented by the white squares. The second Panel has a **Middle
    Center** Child Alignment, and its children are represented by gray squares. The
    third Panel has a **Lower Right** Child Alignment, and its children are represented
    by black squares:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.8: Horizontal Layout Group Example 3 in the Chapter7 scene](img/Figure_07.08_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Horizontal Layout Group Example 3 in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that the **Child Alignment** property only shows an
    effect if the children (along with spacing) don’t completely fill in the Rect
    Transform, as shown in the preceding diagram.
  prefs: []
  type: TYPE_NORMAL
- en: Reverse Arrangement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Reverse Arrangement** property is a toggle. Selecting the toggle will
    cause the elements to arrange in the reverse order than they appear in the Hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Control Child Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Control Child Size** options allow the automatic layout to override the
    current **Width** or **Height** of the child objects. If you select these checkboxes
    without selecting the corresponding **Child Force Expand** checkboxes, your child
    objects will no longer be visible (unless the children have Layout Element components
    with **Preferred** **Width** specified).
  prefs: []
  type: TYPE_NORMAL
- en: If you do not set this property, it is possible that the children will draw
    outside of the parent’s Rect Transform – that is, if too many children exist.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: This property changes the width and height property of the child objects’ Rect
    Transforms. So, if you select and then deselect it, the children will not go back
    to their original sizes. You will have to either use **Edit** | **Undo** (*Ctrl*
    + *Z*) or manually reset the size of the children via their Rect Transform components.
  prefs: []
  type: TYPE_NORMAL
- en: Since this property depends on the **Child Force Expand** property, examples
    of the **Control Child Size** property are presented in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Child Force Expand
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Child Force Expand** property will cause the children to fill the available
    space. If the corresponding **Control Child Size** is not selected, this property
    will shift the children so that they and their spacing fill the space. This may
    override the **Spacing** property. If the corresponding **Control Child Size**
    is selected, it will stretch the children in the selected direction so that they
    and their spacing completely fill the space. This will maintain the **Spacing**
    property.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following screenshot, all three Panels have a Horizontal Layout Group
    component with a **Middle Left** **Child Alignment** and different combinations
    of **Child Control Size** and **Child Force Expand** selected. The top Panel has
    only **Child Force Expand Width** selected, the middle Panel has **Control Child
    Size Width** and **Child Force Expand Width** selected, and the last Panel has
    both **Control Child Size** properties selected and both **Child Force Expand**
    properties selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.9: Horizontal Layout Group Example 4 in the Chapter7 scene](img/Figure_07.09_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Horizontal Layout Group Example 4 in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: Next, let’s look at the **Use Child** **Scale** properties.
  prefs: []
  type: TYPE_NORMAL
- en: Use Child Scale
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Use Child Scale** properties are only available in recent versions of
    Unity. Checking this property will tell the Layout Group whether it should consider
    the scale of the children when automating the layout.
  prefs: []
  type: TYPE_NORMAL
- en: Vertical Layout Group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Vertical Layout Group** component works very similarly to the Horizontal
    Layout Group and has all the same properties, except children of a UI object with
    a Vertical Layout Group component will be automatically placed on top of each
    other, rather than side by side.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with the Horizontal Layout Group, the order in which the children appear
    in the Hierarchy determines the order in which they will be laid out by the Vertical
    Layout Group. The children will be laid out from top to bottom in the same order
    in which they appear in the Hierarchy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.10: Vertical Layout Group Example in the Chapter7 scene](img/Figure_07.10_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: Vertical Layout Group Example in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a Vertical Layout Group component to a UI object, select **Add Component**
    | **Layout** | **Vertical Layout Group** from within the object’s Inspector. If
    you click on the arrow next to the **Padding** property, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.11: The Vertical Layout Group component](img/Figure_07.11_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: The Vertical Layout Group component'
  prefs: []
  type: TYPE_NORMAL
- en: Since the properties of the Vertical Layout Group component are identical to
    those of the Horizontal Layout Group, we won’t explore each of the properties
    further. For an explanation of each of the properties, refer to the *Horizontal
    Layout* *Group* section.
  prefs: []
  type: TYPE_NORMAL
- en: Grid Layout Group
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Grid Layout Group** component allows you to organize child objects in
    columns and rows in (you guessed it) a grid layout. It works similarly to Horizontal
    and Vertical Layout Groups but has a few more properties that can be manipulated.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a Grid Layout Group component to a UI object, select **Add Component**
    | **Layout** | **Grid Layout Group** from within the object’s Inspector. If you
    click on the arrow next to the **Padding** property, you should see the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.12: The Grid Layout Group component](img/Figure_07.12_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: The Grid Layout Group component'
  prefs: []
  type: TYPE_NORMAL
- en: A few of the properties of the Grid Layout Group are the same as the other two
    Layout Groups, but let’s look more closely at the properties unique to the Grid
    Layout Group component.
  prefs: []
  type: TYPE_NORMAL
- en: Cell Size
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Unlike the Horizontal and Vertical Layout Groups, which determine the size of
    the children either by their Rect Transform component or by scaling them to fit
    inside the parent’s Rect Transform, the Grid Layout Group requires you to specify
    the width and height of the child objects. You accomplish this by setting the
    **X** and **Y** properties of the **Cell Size** property. This will automatically
    apply the specified **X** and **Y** sizes to each of the children’s **Width**
    and **Height** properties of their Rect Transform, respectively.
  prefs: []
  type: TYPE_NORMAL
- en: Due to the **Cell Size** property and the lack of a **Control Child** size property,
    the children are not guaranteed to fit within the parent’s Rect Transform. If
    too many children exist, it is possible they will be drawn outside the parent’s
    Rect Transform. So, if you have a grid filling up dynamically that can change
    throughout the gameplay and want the grid to always fit within a specific area,
    you will have to prepare for that overflow scenario.
  prefs: []
  type: TYPE_NORMAL
- en: The Grid Layout Group allows you to specify both an **X Spacing** and **Y Spacing**.
    The **X Spacing** is the horizontal spacing, and the **Y Spacing** is the vertical
    spacing. These values will not be overridden by further property choices as they
    can be with the Horizontal and Vertical Layout Groups.
  prefs: []
  type: TYPE_NORMAL
- en: Start Corner and Start Axis
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Start Corner** property determines where the very first child in the
    Hierarchy will be placed. There are four choices for the **Start Corner** property,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.13: The Start Corner options of a Grid Layout Group component](img/Figure_07.13_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: The Start Corner options of a Grid Layout Group component'
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Start Axis** property determines where all the other children will be
    placed relative to the first child. There are two options, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.14: The Start Axis options of a Grid Layout Group component](img/Figure_07.14_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: The Start Axis options of a Grid Layout Group component'
  prefs: []
  type: TYPE_NORMAL
- en: A **Start Axis** property set to **Horizontal** means that the children will
    be laid out, starting with the first child, in a horizontal fashion. If the **Start
    Corner** is assigned to one of the **Left** options, the children will be placed
    from left to right. If the **Start Corner** is assigned to one of the **Right**
    options, the children will be placed from right to left. Once the new row is filled,
    it will continue to the next row and will restart on the same side as the **Start
    Corner**. If the **Start Corner** is one of the Upper options, the rows will continue
    downward. If the **Start Corner** is one of the Lower options, the rows will continue
    upward.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates the flow of the children, with a **Horizontal
    Start Axis** based on the different **Start** **Corner** options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.15: Grid Layout Group Example 1 in the Chapter7 scene](img/Figure_07.15_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: Grid Layout Group Example 1 in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: A **Start Axis** property set to **Vertical** means that the children will be
    laid out starting with the first child, and then in a vertical fashion. Whether
    the children will be placed from top to bottom or from bottom to top is determined
    in the same way as it is when this property is set to **Horizontal**, based on
    the position of the **Start Corner**. Then, when a column is filled, the children
    will be placed from left to right or from right to left, based on the position
    of the **Start Corner**.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot demonstrates the flow of the children, with a **Vertical
    Start Axis** based on the different **Start** **Corner** options:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.16: Grid Layout Group Example 2 in the Chapter7 scene](img/Figure_07.16_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: Grid Layout Group Example 2 in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, the **Start Corner** and **Start Axis** options can greatly
    change the order in which your child objects are displayed.
  prefs: []
  type: TYPE_NORMAL
- en: Constraint
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The **Constraint** property allows you to specify the number of rows or columns
    the grid will have. There are three options, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.17: The Constraint options of a Grid Layout Group component](img/Figure_07.17_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17: The Constraint options of a Grid Layout Group component'
  prefs: []
  type: TYPE_NORMAL
- en: The **Fixed Column Count** and **Fixed Row Count** properties allow you to specify
    a number of columns or rows, respectively. If you select either of these options,
    a new property, **Constraint Count**, will become available. You then specify
    how many columns or rows you want. When you select **Fixed Column Count**, the
    number of rows will be variable. When you select **Fixed Row Count**, the number
    of columns will be variable.
  prefs: []
  type: TYPE_NORMAL
- en: The **Flexible** option automatically calculates the number of rows and columns
    for you, based on the **Cell Size** and the **Start Axis** options chosen. It
    will begin laying out the children in the defined pattern until there is no space
    left on the chosen axis. It will then continue. Whichever axis is specified in
    **Start Axis** will have a fixed amount of children, and the other axis will be
    variable. So, for example, if **Start Axis** is set to **Horizontal** and three
    children can fit horizontally within the defined space, there will be three columns,
    and the number of rows will be determined by how many total children there are.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve explored the three Automatic Layout Groups, let’s look at a component
    that will let us change the way the children within these layout groups will be
    sized or positioned.
  prefs: []
  type: TYPE_NORMAL
- en: Layout Element
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The **Layout Element** component allows us to specify a range of size values
    of an object if it is being sized with an automatic layout. If the parent object
    tries to size it outside of these preferences, the Layout Element will override
    any sizing information being sent from the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a **Layout Element** component to a UI object, select **Add Component**
    | **Layout** | **Layout Element** from within the object’s **Inspector**. The
    **Layout Element** has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.18: The Layout Element component](img/Figure_07.18_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: The Layout Element component'
  prefs: []
  type: TYPE_NORMAL
- en: 'To use these properties, you first select their checkboxes to enable them;
    boxes will become available so that you can enter your desired values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.19: Setting the properties of the Layout Element component](img/Figure_07.19_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.19: Setting the properties of the Layout Element component'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s review how the individual properties of the Layout Element component will
    affect the elements to which they are added.
  prefs: []
  type: TYPE_NORMAL
- en: Ignore Layout
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Ignore Layout** property can be used to make child objects ignore any
    automatic layout component of its parent object. A child with this property selected
    can be moved and resized freely, and all other children will be laid out without
    regard for the ignored child.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following example, the Panel has a **Horizontal Layout Group** component
    and five child objects. The first child, labeled with a 1, has a **Layout Element**
    component with the **Ignore Layout** property selected:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.20: Layout Element Example 1 in the Chapter7 scene](img/Figure_07.20_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.20: Layout Element Example 1 in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that since the **Ignore Layout** property is selected for the first
    child; it can be moved around outside of the parent Panel, and it was ignored
    when the position and scale of the other children were determined. It also maintained
    its original Rect Transform scale.
  prefs: []
  type: TYPE_NORMAL
- en: If the **Ignore Layout** property is deselected, the first child will be added
    to the Horizontal Layout Group with the other children.
  prefs: []
  type: TYPE_NORMAL
- en: The Width and Height properties
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Layout Element** component has three sets of properties that can be used
    to specify the way you want an object to resize. These properties will override
    the size being assigned to the child by the parent object if the assigned size
    is outside of the provided values.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: It is important to note that these properties will not override the **Cell Size**
    settings of the Grid Layout Group component. *They will have no effect on a child
    within a Grid* *Layout Group.*
  prefs: []
  type: TYPE_NORMAL
- en: Min Width and Height
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Min Width** and **Min Height** properties are the minimum width and height
    a child object can achieve. If the parent object is scaled down, the child will
    scale down until it meets its **Min Width** or **Min Height**. Once it does so,
    it will no longer scale in that direction.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the following diagram, the Panel has a **Horizontal Layout Group** component
    and five child objects. The first child, labeled with a 1, has a **Layout Element**
    component with the **Min Width** and **Min Height** properties set:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.21: Layout Element Example 2 in the Chapter7 scene](img/Figure_07.21_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.21: Layout Element Example 2 in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: You can see that the parent object’s **Horizontal Layout Group** tried to scale
    all the children down with it as it scaled down itself. The other four children
    scaled, but since the first child had a **Min Width** and **Min Height** properties
    set, it refused to scale down any further.
  prefs: []
  type: TYPE_NORMAL
- en: Preferred Width and Preferred Height
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Preferred Width** and **Preferred Height** properties are a little confusing
    because they perform differently, depending on the settings you have for the parent’s
    layout group. There is no official **Max Width** and **Max Height** setting, despite
    there being a **Min Width** and **Min Height** setting. The **Preferred Width**
    and **Preferred Height** properties, however, can be used to specify the maximum
    size the child object will achieve, but only if the correct settings on the parent’s
    layout group are selected.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following diagram contains three Panels with **Vertical Layout Group**
    components and various settings. Their children also have various settings for
    **Preferred Height** within a **Layout** **Element** component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.22: Layout Element Example 3 in the Chapter7 scene](img/Figure_07.22_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.22: Layout Element Example 3 in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: The first parent Panel has a **Vertical Layout Group** component with **Control
    Child Size Width** and **Height** selected, as well as **Child Force Expand**’s
    **Width** and **Height**. None of its children have a **Preferred Width** or **Preferred
    Height** setting within a **Layout Element** component. The first Panel will act
    as the default for reference when comparing the others.
  prefs: []
  type: TYPE_NORMAL
- en: The second parent Panel has the same properties as the first – a `100` within
    a **Layout** **Element** component.
  prefs: []
  type: TYPE_NORMAL
- en: You can see that because the second parent Panel has `100` in the `100` units
    taller than the other four children. So, when the **Child Force Expand** property
    is selected on the parent, the child with the **Preferred Height** will not use
    **Preferred Height** as its maximum possible height; it will add that value to
    the height assigned by the parent’s layout group component.
  prefs: []
  type: TYPE_NORMAL
- en: The third Panel has a `100` within a **Layout** **Element** component.
  prefs: []
  type: TYPE_NORMAL
- en: If you compare the children in the third Panel to the children in the first
    Panel (the default), you can see that the children are shorter. This is because
    their **Preferred Height** is set to a smaller number than the height that the
    Vertical Layout Group component attempts to assign to them. So, when the **Child
    Force Expand**’s **Height** property is deselected, the children will use their
    **Preferred Height** setting in the expected way – making it the maximum size
    the children should attain.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, if you want the **Preferred Width** or **Preferred Height** settings
    to work as a maximum attainable width or height, you will need to deselect the
    corresponding **Child Force Expand** property on the parent object.
  prefs: []
  type: TYPE_NORMAL
- en: Flexible Width and Flexible Height
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The **Flexible Width** and **Flexible Height** properties represent a percentage,
    where the percentage is the size of the child relative to the other children.
    Since these values are percentages, a value of 0 would represent 0% and a value
    of 1 would represent 100%.
  prefs: []
  type: TYPE_NORMAL
- en: 'As with **Preferred Width** and **Preferred Height**, this setting doesn’t
    work as expected unless the **Child Force Expand** property is deselected. In
    the following example, the two Panels and children have nearly identical settings.
    The only difference between the two is that the top parent Panel has **Child Force
    Expand**’s **Width** property selected and the bottom parent Panel does not. So,
    you can see that the values set for **Flexible Width** of the children are ignored
    if **Child Force Expand**’s **Width** is selected on the parent:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.23: Layout Element Example 4 in the Chapter7 scene](img/Figure_07.23_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.23: Layout Element Example 4 in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: The children in the second row of the preceding figure have the following `0`,
    `0.5`, `0.75`, `1`, and `1.5`. You can see that the children have scaled relative
    to each other based on the percentages. The first child is not visible because
    it has a `0`.
  prefs: []
  type: TYPE_NORMAL
- en: The Layout Element component essentially lets us override the automatic size
    and position of an element. Now, let’s review some components that will allow
    us to automatically size UI elements.
  prefs: []
  type: TYPE_NORMAL
- en: Fitters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: There are two fitter layout components. These components make the Rect Transform
    of the object on which they are attached fit within a specified area.
  prefs: []
  type: TYPE_NORMAL
- en: Content Size Fitter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Content Size Fitter** component allows you to force the size of the parent
    to fit around the size of its children. This fitting can be based on the minimum
    or preferred size of the children.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add a **Content Size Fitter** component to a UI object, select **Add Component**
    | **Layout** | **Content Size Fitter** from within the object’s **Inspector**.
    The **Content Size Fitter** component has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.24: The Content Size Fitter component](img/Figure_07.24_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.24: The Content Size Fitter component'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose the following properties for the **Horizontal Fit** and the
    **Vertical Fit**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.25: The possible fit options of the Content Size Fitter component](img/Figure_07.25_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.25: The possible fit options of the Content Size Fitter component'
  prefs: []
  type: TYPE_NORMAL
- en: If the **Unconstrained** property is selected, **Content Size Fitter** will
    not adjust the size of the object along that axis.
  prefs: []
  type: TYPE_NORMAL
- en: If the **Min Size** property is selected, the **Content Size Fitter** will adjust
    the size of the object based on the minimum size of the children. This minimum
    size is determined by the **Min Width** and **Min Height** properties of the **Layout
    Element** component of the children.
  prefs: []
  type: TYPE_NORMAL
- en: 'The children do not have to have a **Layout Element** component if the parent
    has a **Grid Layout Group** component for this property to work. If this property
    is selected for an object with a **Grid Layout Group** component, the Rect Transform
    of the parent will hug the children based on the **Cell Size** and **Padding**
    properties, as shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.26: The Content Size Fitter Example in the Chapter7 scene](img/Figure_07.26_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.26: The Content Size Fitter Example in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: If the **Preferred Size** property is selected, the **Content Size Fitter**
    will adjust the size of the object based on the preferred size of the children.
    This preferred size is determined by the **Preferred Width** and **Preferred Height**
    properties of the **Layout Element** component of the children. If the object
    has a **Grid Layout Group** component, this setting will perform in the exact
    same way as **Min Size**.
  prefs: []
  type: TYPE_NORMAL
- en: Aspect Ratio Fitter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Aspect Ratio Fitter** component works similarly to the **Layout Element**
    component, as it allows you to override the size constraints being sent to it.
    It will force the UI object on which it is attached to resize based on an aspect
    ratio.
  prefs: []
  type: TYPE_NORMAL
- en: 'To add an **Aspect Ratio Fitter** component to a UI object, select **Add Component**
    | **Layout** | **Aspect Ratio Fitter (Script)** from within the object’s **Inspector**.
    The **Aspect Ratio Fitter** component has the following properties:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.27: The Aspect Ratio Fitter component](img/Figure_07.27_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.27: The Aspect Ratio Fitter component'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you select an **Aspect Mode** option, the **Aspect Ratio** property will
    be editable. The **Aspect Ratio** property defines the aspect ratio that the Rect
    Transform will maintain. For example, if you want an aspect ratio of 4:3, you
    can simply enter 4/3 in the box, and it will convert it to the decimal value:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.28: Entering fractions into an Aspect Ratio Fitter Component](img/Figure_07.28_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.28: Entering fractions into an Aspect Ratio Fitter Component'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can choose the following properties for the **Aspect** **Mode** property:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.29: The Aspect Mode options for the Aspect Ratio Fitter component](img/Figure_07.29_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.29: The Aspect Mode options for the Aspect Ratio Fitter component'
  prefs: []
  type: TYPE_NORMAL
- en: If the **None** property is selected, the **Aspect Ratio Fitter** will not adjust
    the size to fit within the **Aspect Ratio**.
  prefs: []
  type: TYPE_NORMAL
- en: If the **Width Controls Height** property is selected, the **Aspect Ratio Fitter**
    will adjust the size of the height based on the width of the object.
  prefs: []
  type: TYPE_NORMAL
- en: If the **Height Controls Width** property is selected, the **Aspect Ratio Fitter**
    will adjust the size of the width based on the height of the object.
  prefs: []
  type: TYPE_NORMAL
- en: If the **Fit In Parent** property is selected, the **Aspect Ratio Fitter** will
    adjust the size of the object to fit within its parent object but will maintain
    the **Aspect Ratio**. This will make the child object stay within the bounds of
    the parent.
  prefs: []
  type: TYPE_NORMAL
- en: If the **Envelope Parent** property is selected, the **Aspect Ratio Fitter**
    will adjust the size of the object to cover its parent object but will maintain
    the **Aspect Ratio**. This is similar to the **Fit In Parent** property, except
    that instead of staying within the bounds of the parent, it can go outside the
    bounds.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you try to add an **Aspect Ratio Fitter** component to a child with a parent
    that has a layout group component, you’ll see the following message on the child:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.30: The Aspect Ratio Fitter warning message](img/B18327_07_30.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.30: The Aspect Ratio Fitter warning message'
  prefs: []
  type: TYPE_NORMAL
- en: 'While you can ignore this message and do it anyway, it doesn’t work entirely
    as expected. The recommended workaround is to add the **Aspect Ratio Fitter**
    component to a child of the child within the group. For example, in the following
    diagram, a Panel was added as a child of the **Horizontal Layout Group**. Then,
    a child with an **Aspect Ratio Fitter** component was added to the Panel so that
    the child could have the 4:3 **Aspect Ratio**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.31: Aspect Ratio Fitter Example in the Chapter7 scene](img/Figure_07.31_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.31: Aspect Ratio Fitter Example in the Chapter7 scene'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve looked at all the properties of the various automatic layout
    components, let’s look at some examples of how to use them!
  prefs: []
  type: TYPE_NORMAL
- en: Examples
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We’ll continue working on the scene created in [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085)
    and use the art assets imported for them.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: If you did not follow along with the examples in [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085)
    but would like to follow along with these, you can download the unity package
    named **Chapter 07** **- Examples – Start.unitypackage** from the code bundle.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the art already added to our project, we’ll be using art assets
    that I’ve modified from free art assets found at [https://opengameart.org/content/platformer-pickups-pack](https://opengameart.org/content/platformer-pickups-pack).
  prefs: []
  type: TYPE_NORMAL
- en: The download from the previous link provides many individual images. I could
    have used those, but for performance reasons, it is best to use sprite sheets
    whenever possible. So, you can find the sprite sheet labeled `foodSpriteSheet.png`
    in the code bundle. To combine all the images into a sprite sheet, I used the
    program Texture Packer, which can be found at [https://www.codeandweb.com/texturepacker](https://www.codeandweb.com/texturepacker).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before you begin with the following examples, complete the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Import the `foodSpriteSheet.png` sprite sheet into your project’s `Asset/Sprites`
    folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Change the `foodSpriteSheet.png` to **Multiple**. Use the **Sprite Editor**
    to automatically slice the sprite sheet.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Automatic slicing results in a blank image being created in the sprite sheet.
    Find the rectangle shown in the following screenshot within the **Sprite Editor**,
    and then select and delete it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.32: An empty sprite that needs removing](img/Figure_07.32_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.32: An empty sprite that needs removing'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you apply your changes, you should have the following in your `Sprites`
    folder:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.33: All sprites currently in the project](img/Figure_07.33_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.33: All sprites currently in the project'
  prefs: []
  type: TYPE_NORMAL
- en: Duplicate your scene named `Chapter6` by pressing *Ctrl* + *D*, and name it
    `Chapter7`. Open the `Chapter7` scene and complete the following examples within
    that scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that you have the scene duplicated and the art imported, let’s look at applying
    some automatic layouts.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out a HUD selection menu
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first example we will cover in this chapter is a HUD selection menu in
    the lower-right corner of the screen that uses the **Horizontal Layout Group**
    component. When we are done, it will look like the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.34: The HUD selection menu we will build in this example](img/Figure_07.34_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.34: The HUD selection menu we will build in this example'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the HUD group shown in the preceding screenshot, complete the following
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Currently, we have a Panel in the upper-left corner of the screen named `HUD
    Panel`. For clarity’s sake, rename this Panel `Top` `Left Panel`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will create a new HUD Panel to hold our fruity inventory. We want to put
    our new HUD Panel in the HUD Canvas. Right-click on the Canvas named `HUD Canvas`
    in the **Hierarchy** and select **UI** | **Panel**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Rename the new Panel `Bottom` `Right Panel`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.35: The Panels in the Hierarchy](img/Figure_07.35_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.35: The Panels in the Hierarchy'
  prefs: []
  type: TYPE_NORMAL
- en: 'Change the Rect Transform properties of the `Bottom Right Panel` so that the
    Panel is anchored in the lower-right corner, has a `500`, and has a `100`. Remember
    to hold down *Shift* + *Alt* when selecting the lower-right anchor preset:![Figure
    7.36: The Rect Transform of the Bottom Right Panel](img/Figure_07.36_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.36: The Rect Transform of the Bottom Right Panel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following in your Game view:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.37: The resulting Panel](img/Figure_07.37_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.37: The resulting Panel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, we will replace the image with one of the `uiElements.png` sprites. Drag
    `uiElements_1` into the **Source Image** property of the **Image** component.
    Change the **Color** property so that it has full opacity:![Figure 7.38: The Image
    component properties of the Panel](img/Figure_07.38_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.38: The Image component properties of the Panel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should now see the following in your **Game view**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.39: The resulting Panel](img/Figure_07.39_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.39: The resulting Panel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To create the layout we want, we need to add a `Bottom Right Panel`. Select
    **Add Component** | **Layout** | **Horizontal Layout Group**. We will adjust its
    properties momentarily. First, let’s give this Panel some children so that we
    can see the effects of the properties take place.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `Bottom Right Panel` in the Hierarchy and select `Item Holder`.
    We won’t be changing the **Rect Transform** component of this Image because we
    will allow the **Horizontal Layout Group** of its parent to control its size,
    position, and anchor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This Image will be the background holder for the item. So, drag `uiElement_6`
    into its **Image** component’s **Source Image**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let’s add the Image for the fruit. Right-click on `Item Holder` in the
    `Food`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.40: The Hierarchy of UI elements](img/Figure_07.40_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.40: The Hierarchy of UI elements'
  prefs: []
  type: TYPE_NORMAL
- en: 'To ensure that we aren’t just looking at a white block, let’s replace the `foodSpriteSheet.png`.
    I’ve used `foodSpriteSheet_18`, which is a full orange:![Figure 7.41: The Image
    component of the Food element](img/Figure_07.41_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.41: The Image component of the Food element'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see something that looks like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.42: The resulting Panel with an orange](img/Figure_07.42_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.42: The resulting Panel with an orange'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: If your orange and its holder are in a different place than mine, don’t worry.
    When we start adding more children and adjusting the **Horizontal Group Layout**,
    everything should pop into its proper place.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We don’t want our orange Image to have its aspect ratio distorted, and we also
    want to ensure that it always fills the `Item Holder` image without expanding
    past it. So, let’s adjust a few properties on the `5`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, select `Food` Image should now have the following properties:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.43: The Rect Transform and Image components of the Food UI Image](img/Figure_07.43_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.43: The Rect Transform and Image components of the Food UI Image'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we’re ready to start adding some more children. Select the `Item Holder`
    Image in the `Item` `Holder` GameObjects:![Figure 7.44: The Hierarchy of UI elements](img/Figure_07.44_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.44: The Hierarchy of UI elements'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should see the following in the **Game view**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.45: The resulting Panel with five oranges](img/Figure_07.45_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.45: The resulting Panel with five oranges'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'I don’t like my objects to have names with numbered parentheses in them, so
    I’ll rename all the duplicated Images `Item Holder` without the number. Select
    `Item Holder (1)`, hold *Shift*, and select `Item Holder (4)` so that you have
    all of them selected. Now, in the `Item Holder` in the name slot and press *Enter*.
    They should all be renamed `Item` `Holder` now:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.46: The Hierarchy of renamed elements](img/Figure_07.46_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.46: The Hierarchy of renamed elements'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s adjust the properties on the `Bottom Right Panel`. To do that, select
    the `Bottom Right Panel`, and in its **Horizontal Layout Group** component, give
    it the following properties:![Figure 7.47: The Horizontal Layout Group component
    of the Bottom Right Panel](img/Figure_07.47_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.47: The Horizontal Layout Group component of the Bottom Right Panel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You will now be able to see the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.48: The resulting Panel of oranges](img/Figure_07.48_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.48: The resulting Panel of oranges'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: By adjusting the `Item Holder` images were adjusted to fit onto the parent Panel
    by enabling **Control Child Size Width** and **Height**.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, all that’s left to do is swap out the orange images for four other items.
    Select the `Food` image of the second through fourth `Item Holder` GameObjects
    and change their `foodSpriteSheet_13`, `foodSpriteSheet_22`, `foodSpriteSheet_34`,
    and `foodSpriteSheet_45` to get the following results:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.49: The resulting Panel of a variety of fruit](img/Figure_07.49_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.49: The resulting Panel of a variety of fruit'
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from this example, **Horizontal Layout Group** components and
    (similarly) **Vertical Layout Group** components aren’t too difficult to set up
    and are extremely useful for creating well-organized lists.
  prefs: []
  type: TYPE_NORMAL
- en: Laying out a grid inventory
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The last example we’ll cover in this chapter is the creation of a gridded inventory
    system using a **Grid Layout Group** component and the **Content Fitter** component.
    We’ll continue to work on this Panel in later chapters:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 7.50: The grid inventory we will build in this example](img/Figure_07.50_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.50: The grid inventory we will build in this example'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the gridded inventory system shown in the preceding screenshot, complete
    the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The shell that holds this inventory system looks remarkably similar to our
    `Pause Panel` (see *Figure 7**.49*). Since they are so similar, and there is no
    reason to reinvent the wheel, we will just duplicate the `Pause Panel` we created
    in [*Chapter 6*](B18327_06.xhtml#_idTextAnchor085), and adjust some of its settings
    to get the square shape. Select `Pause Panel` in the Hierarchy and press *Ctrl*
    + *D* to duplicate it. Now, rename the duplicate `Inventory Panel`. Rename its
    child Image `Inventory Banner`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.51: The resulting Hierarchy after duplicating and renaming](img/Figure_07.51_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.51: The resulting Hierarchy after duplicating and renaming'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: Remember that we added a Canvas Group component to the **Pause Panel** in [*Chapter
    6*](B18327_06.xhtml#_idTextAnchor085). By duplicating it to create the **Inventory
    Panel**, the **Inventory Panel** has a **Canvas Group** component as well. This
    component will allow us to easily hide and show the two Panels, which we will
    do in the next chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get the square look of the `Inventory Panel` in the example screenshot,
    we need to deselect the `500`:![Figure 7.52: The Rect Transform and Image components
    of the Inventory Panel](img/Figure_07.52_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.52: The Rect Transform and Image components of the Inventory Panel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should now see the following in your **Game view**:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.53: The resulting Inventory Panel](img/Figure_07.53_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.53: The resulting Inventory Panel'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'If you look at *Figure 7**.50*, you will see that the group of inventory items
    has an sprite that outlines it. This will act as the parent object of our grid.
    Create this parent object by right-clicking on the `Inventory Holder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.54: The Hierarchy of items](img/Figure_07.54_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.54: The Hierarchy of items'
  prefs: []
  type: TYPE_NORMAL
- en: Change the `uiElement_38` and use the **Color** property to make the Image fully
    opaque.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right now, the `Inventory Holder` is completely covering the `Inventory Panel`.
    However, we don’t need to change any of the `Inventory Holder` by selecting `Inventory
    Holder` has no children, adjusting the **Horizontal Fit** and **Vertical Fit**
    settings now will cause it to “disappear.”
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `Inventory Holder` by selecting **Add Component** | **Layout** | **Grid
    Layout Group**. Once again, don’t adjust the settings yet. We’ll do this once
    we add the children.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note from *Figure 7**.50* that the children of the inventory are set up just
    like the children in the horizontal HUD we created in the previous example. So,
    we’ll duplicate the children of the `Bottom Right Panel` and move the duplicates
    so that they are children of the `Inventory Holder`. Select the first `Item Holder`
    child of the `Bottom Right Panel`, hold down *Shift*, and select the last `Item
    Holder` child of the `Bottom Right Panel`. This will select all the children.
    Now, with all the children selected, press *Ctrl* + *D* to duplicate them.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click and drag the duplicated `Item Holder` GameObjects in the `Bottom Right
    Panel` to the `Inventory Holder`, making them children of `Inventory Holder`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.55: The Hierarchy of items](img/Figure_07.55_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.55: The Hierarchy of items'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select one of the `Item Holder` GameObjects and duplicate it four times so
    that there is a total of nine `Item Holder` children. Select all the `Item Holder`
    children and rename them `Item Holder` so that they no longer have a number in
    the name:![Figure 7.56: The Hierarchy of items](img/Figure_07.56_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.56: The Hierarchy of items'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: You should now see something similar to *Figure 7**.57* in your Game view. Depending
    on what you duplicated or the order in which you did it, the fruit may be in a
    slightly different order. That’s fine, though!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.57: The grid of fruit](img/Figure_07.57_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.57: The grid of fruit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now, let’s adjust the properties on the `Inventory Holder Panel` so that the
    children will be laid out in a 3x3 grid. Adjust the properties to match those
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.58: The Grid Layout Group component of Inventory Holder](img/Figure_07.58_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.58: The Grid Layout Group component of Inventory Holder'
  prefs: []
  type: TYPE_NORMAL
- en: 'You should now see the following in your Game view:![Figure 7.59: The Grid
    Layout Group component of Inventory Holder](img/Figure_07.59_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.59: The Grid Layout Group component of Inventory Holder'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: We put spacing between each of the cells using the `3`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Now that `Inventory Holder` has children, we can change the settings of its
    **Content Size Fitter**. Set **Horizontal Fit** and **Vertical Fit** to **Min
    Size**:![Figure 7.60: The Content Size Fitter component of Inventory Holder](img/Figure_07.60_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.60: The Content Size Fitter component of Inventory Holder'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You should now see the following in your Game view:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.61: The fitted grid of fruit](img/Figure_07.61_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.61: The fitted grid of fruit'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It’s a little hard to see, but the Image of `Inventory Holder` now fits snuggly
    around the grid of `Item Holder` Images. We want a bit of padding, though.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add padding to the sides of the `Item Holder` GameObjects by adjusting the
    **Padding** properties in the **Grid Layout Group**, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 7.62: The padded grid of fruit](img/Figure_07.62_B18327.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.62: The padded grid of fruit'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that everything is lined up and positioned properly, the only thing left
    to do is change the order of the images and change the images of the last four
    slots. To change the order of the images, simply change their order in the `Food`
    items to `foodSpriteSheet_41`, `foodSpriteSheet_52`, `foodSpriteSheet_55`, and
    `foodSpriteSheet_53`. These changes result in the following completed Inventory
    Panel:![Figure 7.63: The grid of various foods](img/Figure_07.63_B18327.jpg)'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Figure 7.63: The grid of various foods'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: That’s it. You should now have a perfectly laid out inventory grid.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'With the `Inventory Holder` will automatically resize to fit all the items,
    as you can see here:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.64: The smaller grid of various foods](img/Figure_07.64_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.64: The smaller grid of various foods'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This actually works really well, until we try to add more items to the inventory.
    You’ll see that once we have 10 items, everything looks pretty bad:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.65: The expanded grid of various foods](img/Figure_07.65_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.65: The expanded grid of various foods'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: There are a few things we can do to handle this, including changing the cell
    size and using a mask along with a **Scroll Rect**. We’ll discuss how to make
    those changes in a later chapter. For now, though, just leave your inventory at
    nine items so that everything looks nice.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'After completing all the examples in the last two chapters, you should have
    the following:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 7.66: The result of all examples from Chapters 6 and 7](img/Figure_07.66_B18327.jpg)'
  prefs:
  - PREF_IND
  type: TYPE_IMG
- en: 'Figure 7.66: The result of all examples from Chapters 6 and 7'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: And that’s in for adding automatic layouts to our scene. We’ll continue to improve
    upon it in future chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, we know all sorts of techniques to lay out our UI elements. The information
    covered in this chapter, and the last one, has provided enough tools to create
    almost any UI layout that you can imagine.
  prefs: []
  type: TYPE_NORMAL
- en: The automatic layouts discussed in this chapter aren’t just helpful when you
    want to manually add UI items, as we did in this chapter. These automatic layouts
    are particularly helpful if you want to dynamically create and add your UI items
    based on specific conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn how to access UI components via code and
    how to use the Event System to allow the player to interact with the UI objects.
  prefs: []
  type: TYPE_NORMAL
