- en: '*Chapter 5*: Working with the Unity Physics System'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A physics simulation in a game is not only an indispensable function for implementing
    the realism in the game. Adding a physics simulation to your game can usually
    improve the fun and playability of the game. Generally speaking, it determines
    how objects move and how they collide with one another, such as the collision
    between a player and a wall and the effect of gravity. As a popular game engine,
    Unity provides developers with a variety of tools, allowing developers to integrate
    physics simulation functions in their games.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Concepts in the Unity Physics system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scripting with the Physics system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a simple game based on the Physics system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Increasing the performance of the Physics system
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will be able to apply the physics simulation
    correctly and efficiently in Unity to add more realism or fun to your game.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's get started!
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find complete code examples on GitHub under the following repository: 
    [https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers](https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers).
  prefs: []
  type: TYPE_NORMAL
- en: Concepts in the Unity Physics system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A simulation is a useful function of a game. Unity provides different tools
    for different purposes. For example, if we want to develop a 3D game, then we
    can use the built-in 3D physics integrated with the **Nvidia PhysX engine**. If
    we want to add a physics simulation to a 2D game, then we can choose the built-in
    2D physics integrated with the **Box2D engine**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**PhysX** is an open source, real-time physics engine middleware SDK developed
    by Nvidia as a part of the Nvidia GameWorks software suite. **Box2D** is a free,
    open source 2D physics simulator engine.'
  prefs: []
  type: TYPE_NORMAL
- en: In addition to these built-in Physics solutions, Unity also provides Physics
    engine packages. These are the `Unity Physics` package and the `Havok Physics
    for Unity``Unity's Package Manager`, and they are used in projects with Unity's
    **Data-Oriented Technology Stack (DOTS)**. We will introduce DOTS in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: '**Havok Physics** is designed primarily for video games and allows for the
    real-time collision and dynamics of Rigidbodies in 3D.'
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will focus on the built-in physics and will first learn
    the basic concepts of the Unity Physics system.
  prefs: []
  type: TYPE_NORMAL
- en: Collider
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Similar to the rendering function, a physics engine also needs to understand
    the shape of `GameObjects` in a game scene in order to perform physics simulation
    correctly. When developing a Unity project, we can use the **Collider** component
    to define the shape of a GameObject for physical collision calculations.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that the shape defined by a collider does not have to be
    exactly the same as the shape of the model. We can even create a collider without
    a model display. For example, we can create a new cube in the scene, and a collider
    component will be created and attached to this cube automatically. Then, the shape
    of the collider can be modified from the Inspector window, as shown in the following
    image; its shape is different from the shape of the model.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.1 – Modifying the shape of the Collider (green frame)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.01_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.1 – Modifying the shape of the Collider (green frame)
  prefs: []
  type: TYPE_NORMAL
- en: In order to reduce the complexity of physics simulation and improve the performance
    of the game, we often use some rough shapes, such as the **Box Collider** and
    the **Sphere Collider**. Next, we will explore one of the most commonly used colliders,
    namely, the Box Collider.
  prefs: []
  type: TYPE_NORMAL
- en: Primitive colliders
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unity provides a set of primitive colliders for game developers, including
    the Sphere Collider and the Box Collider. The Box Collider is one of the most
    commonly used colliders in Unity. It will be automatically created and assigned
    to the Cube object in a scene, as we see in *Figure 5.1*. We can also add a new
    Box Collider to a GameObject manually, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new GameObject in the scene by clicking the **Create Empty** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.2 – Creating a new GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.02_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.2 – Creating a new GameObject
  prefs: []
  type: TYPE_NORMAL
- en: Select this newly created GameObject and click the **Add Component** button
    in the Inspector window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.3 – Add Component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.03_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.3 – Add Component
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can select the `Box Collider` in the search box to add the Box Collider
    component to this GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.4 – Adding the Box Collider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.04_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.4 – Adding the Box Collider
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have added a new **Box Collider** component, and the properties of this
    Box Collider are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.5 – Properties of the Box Collider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.05_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.5 – Properties of the Box Collider
  prefs: []
  type: TYPE_NORMAL
- en: The **Edit Collider** button at the top allows us to edit the shape of this
    box in the scene. Below this button, there is an **Is Trigger** checkbox which,
    if enabled, means this collider will be used as a trigger. We will introduce more
    details about triggers later. The third property of this collider is the **Material**
    property, for referring to a **Physics Material** instance. The default value
    of the **Material** property is null, and we can assign an instance of Physics
    Material to adjust the friction and bouncing effects of colliding objects. The
    last two properties, **Center** and **Size**, are used to modify the position
    and size of this box.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, similar to the Box Collider, Unity also provides other
    colliders with primitive shapes, such as the Sphere Collider.
  prefs: []
  type: TYPE_NORMAL
- en: We use them in cases where the accuracy of physical collision simulations is
    not high, but if the game requires accurate physical collision simulations, then
    we can also use another collider, namely, **Mesh Collider**.
  prefs: []
  type: TYPE_NORMAL
- en: Mesh Collider
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we need to develop some game projects that require high physical
    simulation accuracy. In this case, the physical shape of the GameObject is often
    required to be consistent with the shape of the model mesh of the GameObject.
    This is why we need a Mesh Collider.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are different ways to create and add a Mesh Collider to a GameObject.
    Because the Mesh Collider needs the information of the mesh, so, the first way
    to create a Mesh Collider is by importing the model into the Unity Editor. You
    can check the **Generate Colliders** checkbox to import the mesh that automatically
    attaches mesh colliders, as shown in *Figure 5.6*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.6 – Generate Colliders'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.06_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.6 – Generate Colliders
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity also allows us to add a **Mesh Collider** component to a GameObject manually.
    The steps for adding a Mesh Collider are similar to the steps for adding a Box
    Collider in the previous section. After selecting the target GameObject, click
    the **Add Component** button, and then select **Physics > Mesh Collider** to add
    it to the GameObject, as shown in *Figure 5.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.7 – Adding a Mesh Collider to a GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.07_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.7 – Adding a Mesh Collider to a GameObject
  prefs: []
  type: TYPE_NORMAL
- en: Since the mesh of a model may consist of many vertices and triangles, and the
    Mesh Collider will be generated based on the mesh, the computational cost of a
    Mesh Collider is much larger than that of the colliders introduced before. Even
    by default, Unity does not calculate the collision between mesh colliders, but
    only calculates the collision between a Mesh Collider and primitive colliders,
    such as a Box Collider and a Sphere Collider.
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to enable collision detection between mesh colliders, we need to reduce
    their complexity by checking the **Convex** checkbox of the Mesh Collider component,
    as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.8 – Properties of a Mesh Collider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.08_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.8 – Properties of a Mesh Collider
  prefs: []
  type: TYPE_NORMAL
- en: By enabling this checkbox, **Mesh Collider** is limited to 255 triangles. If
    we look at the GameObject in the scene at the same time, we can see that the Mesh
    Collider is only roughly consistent with the model's mesh, and that the complexity
    has been greatly reduced.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.9 – A convex Mesh Collider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.09_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.9 – A convex Mesh Collider
  prefs: []
  type: TYPE_NORMAL
- en: However, if we run the game now, we will find that no physical effects are applied
    to the game; for example, objects will not fall due to gravity. This is because
    our game still lacks an important component. Let's explore this next!
  prefs: []
  type: TYPE_NORMAL
- en: Rigidbody
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Rigidbody** component is an indispensable component for applying physical
    effects in Unity. By adding Rigidbody to a GameObject, physics will control the
    GameObject, such as applying gravity to it. Rigidbodies are usually used with
    colliders; if two Rigidbodies collide with one another, unless the two GameObjects
    have colliders attached, they will not have a collision effect between them but
    will pass through each other.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s add a **Rigidbody** component to a GameObject in the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new cube in the scene by clicking the **3D Object > Cube** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.10 – Creating a new cube'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.10_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.10 – Creating a new cube
  prefs: []
  type: TYPE_NORMAL
- en: 'Select this newly created cube and click the **Add Component** button in the
    Inspector window. And as you can see in *Figure 5.11*, a Box Collider has been
    attached to the cube:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.11 – Add Component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.11_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.11 – Add Component
  prefs: []
  type: TYPE_NORMAL
- en: Here, we can select the **Physics > Rigidbody** button to add a **Rigidbody**
    component to this cube.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.12 – Adding the Box Collider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.12_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.12 – Adding the Box Collider
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have added a new **Rigidbody** component, and the properties of this
    Rigidbody are shown in *Figure 5.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.13 – Properties of a Rigidbody'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.13_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.13 – Properties of a Rigidbody
  prefs: []
  type: TYPE_NORMAL
- en: As we can see in *Figure 5.13*, the **Use Gravity** property of the Rigidbody
    is checked by default, which means that this Rigidbody will apply gravity to the
    cube. If we run the game at this time, we will find that the cube will fall down
    under the influence of gravity.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to the **Use Gravity** property, the Rigidbody has other properties,
    and we will introduce these properties below.
  prefs: []
  type: TYPE_NORMAL
- en: The first property of a Rigidbody component is **Mass**, which determines how
    Rigidbodies react when they collide with each other. Next is the **Drag** property,
    which determines how much air resistance the object is affected by when it is
    moving under force. By default, the value is **zero**, which means there is no
    air resistance when the cube is moving by force. The **Angular Drag** property
    is similar to the **Drag** property, the difference being that it determines how
    much air resistance affects the object when rotating from torque.
  prefs: []
  type: TYPE_NORMAL
- en: 'The **Is Kinematic** property is important because it determines whether this
    GameObject will be controlled by the Physics system in Unity. By default, it''s
    disabled. If we enable it, this GameObject will no longer be driven by physics.
    The **Interpolate** property is useful when you find that the Rigidbody''s movement
    is jerky. The default value of **Interpolate** is **None**, but Unity allows us
    to select different options for this property, such as **Interpolate** or **Extrapolate**,
    which, respectively, indicate that the transform is based on the transform of
    the previous frame for smoothing, or that the transform is smoothed based on the
    estimated transform of the next frame, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.14 – Options of the Interpolate property'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.14_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.14 – Options of the Interpolate property
  prefs: []
  type: TYPE_NORMAL
- en: Next is the **Collision Detection** property. Sometimes, if a Rigidbody is moving
    too fast, causing the physics engine to not detect the collision in time, then
    maybe adjusting this property is a good idea. Unity also provides us with different
    options for **Collision****Detection**; these are **Discrete**, **Continuous**,
    **Continuous Dynamic**, and **Continuous Speculative**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.15 – Options of the Collision Detection property'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.15_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.15 – Options of the Collision Detection property
  prefs: []
  type: TYPE_NORMAL
- en: The **Discrete** option is the default value and is used for detecting normal
    collisions. If you encountered issues with fast object collisions, then **Continuous**
    is a good choice, but you should remember that **Continuous** will impact performance
    compared to **Discrete**.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to restrict a Rigidbody's motion, such as restricting the Rigidbody
    from moving in a certain direction or not being able to rotate on a certain axis,
    then you can do so by modifying the **Constraints** property.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.16 – The Constraints property'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.16_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.16 – The Constraints property
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 5.16*, you can select an axis to prevent the Rigidbody from
    moving along it.
  prefs: []
  type: TYPE_NORMAL
- en: Through a Rigidbody component, we add physical effects to a GameObject, but
    sometimes we don't want the GameObject to move according to the results of the
    physics simulation, but just want to be able to detect the collision between two
    objects and trigger some events. This is a common function in games; for example,
    the player triggers the corresponding logic after entering a certain area. Next,
    we will introduce another feature provided by Unity to implement such requirements.
  prefs: []
  type: TYPE_NORMAL
- en: Trigger
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In addition to providing collision effects, colliders can also be used as triggers.
    However, unlike being used as a normal collider, when a trigger is enabled, there
    is no collision effect when Rigidbodies collide. However, the physical effect
    will still take effect; for example, a trigger can still fall under the influence
    of gravity, but it will not collide with other Rigidbodies.
  prefs: []
  type: TYPE_NORMAL
- en: 'When developing a Unity project, triggers are used to detect external interactions
    from other GameObjects and execute the code in the `OnTriggerEnter`, `OnTriggerStay`,
    or `OnTriggerExit` functions in the script. These three functions represent three
    different stages of interactions, namely, entering, staying, and exiting. We will
    introduce more details about those functions in the next section. For the moment,
    let''s create a trigger by performing the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the Cube object we created earlier to open Inspector window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Enable the **Is Trigger** property of the Box Collider component attached to
    this Cube object, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.17 – Enabling the Is Trigger property'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.17_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.17 – Enabling the Is Trigger property
  prefs: []
  type: TYPE_NORMAL
- en: Now, this cube is set as a trigger, and it will no longer block other Rigidbodies.
    Since it is now a trigger, we can use it to create game levels. For example, when
    the player touches this cube, it will trigger a trap.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, Unity also provides physical components used for 2D. If you want
    to develop a 2D game and need to apply physical effects to your game, then you
    can easily add 2D versions of these physical components in the same way.
  prefs: []
  type: TYPE_NORMAL
- en: By reading this section, we have learned some concepts of Unity's Physics system,
    such as colliders, Rigidbodies, and triggers. Next, we will continue to explore
    how to use C# scripts to interact with the Physics system.
  prefs: []
  type: TYPE_NORMAL
- en: Scripting with the Physics system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will explore how to interact with the Physics system via
    C# scripts. Similar to the previous section, we will also introduce the C# methods
    for colliders, triggers, and Rigidbodies, respectively. We will start with the
    C# methods for colliders.
  prefs: []
  type: TYPE_NORMAL
- en: Collision methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When a collider is not used as a trigger, collisions between Rigidbodies still
    occur. These three methods are called when a collision occurs, and the parameter
    type is the **Collision** class, which provides some information to describe the
    collision, such as the contact point and the impact velocity of the collision.
  prefs: []
  type: TYPE_NORMAL
- en: OnCollisionEnter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The first method is `OnCollisionEnter`, which is called when this collider
    begins to touch another collider. It is useful when you want to make this object
    be affected by a physical collision, but also want to perform some game logic
    when the collision occurs. For example, when a bullet hits the target in a game,
    a corresponding explosion effect can be generated for it, as the following C#
    code snippet demonstrates:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In the code snippet, we accessed the contact point data provided by the collision
    object and instantiated the explosion asset at that point.
  prefs: []
  type: TYPE_NORMAL
- en: OnCollisionStay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`OnCollisionStay` is the second method we will explore here. As long as two
    objects collide, `OnCollisionStay` will be called once per frame. Since this method
    will be called during the collision of objects, it is suitable to be used to implement
    some logic that will last for a period of time. An interesting example of this
    is as follows: Suppose you are developing a helicopter game, and you want the
    helicopter''s engine to run at 60% of its maximum strength when the skid touches
    the ground. In this case, we can use the following code snippet to implement this
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: OnCollisionExit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last method I want to introduce here is `OnCollisionExit`. As the name
    of this method implies, it will be called when this collider stops touching another
    collider. If some content is generated at the beginning of the object collision
    via `OnCollisionEnter`, and you want to destroy them when the object collision
    ends, then you should consider using `OnCollisionExit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code snippet demonstrates how to use `OnCollisionExit` to reset
    the `_isGrounded` field.
  prefs: []
  type: TYPE_NORMAL
- en: We have covered typical methods used in colliders. Now, we'll look at how to
    use triggers in a Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: Trigger methods
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In fact, we still use colliders to implement triggers, and just need to check
    the **Is Trigger** option of the **Collider** component. At this time, the collider
    will no longer produce the physical collision effect, but activate trigger events.
  prefs: []
  type: TYPE_NORMAL
- en: There are three events commonly used to implement a trigger, namely, `OnTriggerEnter`,
    `OnTriggerStay`, and `OnTriggerExit`. These three methods are called when two
    GameObjects collide, and the parameter type is the `Collider` class, which provides
    information about other colliders involved in this collision.
  prefs: []
  type: TYPE_NORMAL
- en: OnTriggerEnter
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first method is `OnTriggerEnter`, which is called when this collider begins
    touching another collider. The **Is Trigger** option should be enabled in this
    case. This method is useful when you want to trigger some operations on surrounding
    elements but don't want to produce physical collision effects. For example, you
    could use this to implement a trap in your game.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also very simple to use. We only need to include the game logic that
    will be triggered in the definition of this method, as shown in the following
    code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: When this GameObject collides with another GameObject, the string by means of
    which this GameObject enters the other GameObject will be printed in the Console
    window.
  prefs: []
  type: TYPE_NORMAL
- en: OnTriggerStay
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`OnTriggerStay` is the second method we will explore here. Similar to the `OnCollisionStay`
    method we discussed before, `OnTriggerStay` will be called in all frames when
    other colliders touch this trigger. This method is also suitable for implementing
    trap-like gameplay in a game; for example, the player enters a poisonous fog and
    will continue to be hurt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Here, we also only need to put the game logic that will be triggered in the
    definition of the `OnTriggerStay` method, as shown in the preceding code snippet.
  prefs: []
  type: TYPE_NORMAL
- en: OnTriggerExit
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The last method I want to introduce here is `OnTriggerExit`. This method will
    be called when other colliders leave the trigger. This method is suitable for
    some tasks, such as destroying the GameObjects created when other colliders enter
    this trigger, resetting the state, and so on. The following code snippet shows
    how to destroy a GameObject in `OnTriggerExit`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Methods of Rigidbody
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Rigidbody** component provides us with the ability to directly interact
    with the Physics system in Unity. We can use the methods provided by the **Rigidbody**
    component in the C# script to apply a force to this Rigidbody, and we can also
    apply a force to a Rigidbody that simulates explosion effects.
  prefs: []
  type: TYPE_NORMAL
- en: It should be noted that, as we mentioned in [*Chapter 2*](B17146_02_Final_ASB_ePub.xhtml#_idTextAnchor025),
    *Scripting Concepts in Unity*, in a script, it is recommended to use the `FixedUpdate`
    function for a physical update, so we should call Rigidbody methods in the `FixedUpdate`
    function to apply the physical effect. Now, let's explore some commonly used methods.
  prefs: []
  type: TYPE_NORMAL
- en: AddForce
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The `AddForce` method is one of the most commonly used methods related to physics.
    As its name implies, we can call this method to apply a force to the Rigidbody.
    The function signature of `AddForce` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, this method requires two parameters, namely, the force vector
    in world coordinates and the type of force to apply. `AddForce` allows us to define
    a force vector and choose how to apply this force to the GameObject to affect
    how our GameObject moves.
  prefs: []
  type: TYPE_NORMAL
- en: The first parameter, `force`, is a vector type that specifies the direction
    in which the force is applied to this object.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, the `ForceMode` type parameter, `mode`, determines the type
    of force applied. `ForceMode` is an `enum` type, which defines four different
    types of force. By default, the `AddForce` method will add a continuous force
    to the Rigidbody, using its mass. In the following section, I will introduce the
    different types of force modes in detail.
  prefs: []
  type: TYPE_NORMAL
- en: ForceMode
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
- en: '`ForceMode` is defined in the `UnityEngine` namespace, and we can see its definition
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: As the preceding code snippet shows, there are four types of force mode, namely,
    `Force`, `Impulse`, `VelocityChange`, and `Acceleration`.
  prefs: []
  type: TYPE_NORMAL
- en: '`Force` is the default mode and in this mode, more force must be applied to
    push or distort objects with larger masses because it depends on the mass of the
    Rigidbody. It will add a continuous force to the Rigidbody.'
  prefs: []
  type: TYPE_NORMAL
- en: If we choose `Impulse` mode as the argument, then the `AddForce` method will
    apply an instant force impulse to the Rigidbody. This mode is suitable for simulating
    forces from explosions or collisions. As with the `Force` mode, the `Impulse`
    mode also depends on the mass of the Rigidbody.
  prefs: []
  type: TYPE_NORMAL
- en: '`VelocityChange` is the third mode here. If we select this mode, then Unity
    will apply the velocity change instantly with a single function call. It should
    be noted that the `VelocityChange` mode is different from the `Impulse` mode and
    the `Force` mode. The `VelocityChange` mode does not depend on the mass of the
    Rigidbody, which means that `VelocityChange` will change the velocity of each
    Rigidbody in the same way.'
  prefs: []
  type: TYPE_NORMAL
- en: The last mode is `Acceleration` mode. If this mode is selected, then Unity will
    add a continuous acceleration to the Rigidbody. Like the `VelocityChange` mode,
    `Acceleration` mode also ignores the mass of the Rigidbody, which means `AddForce`
    will move every Rigidbody the same way.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have learned the different force modes available for the `AddForce`
    method. Next, let''s create a new C# script and apply a force to the cube by calling
    `AddForce`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the code, we can apply a continuous force to the Rigidbody by pressing
    the *F* key on the keyboard and applying a continuous acceleration to the Rigidbody
    by pressing the *A* key on the keyboard.
  prefs: []
  type: TYPE_NORMAL
- en: MovePosition
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Sometimes, we just want to move our GameObjects and don't want to deal with
    forces. The `MovePosition` method of Rigidbody can help us to achieve this goal.
  prefs: []
  type: TYPE_NORMAL
- en: 'The function signature of `MovePosition` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we need a parameter position to provide the new position for the Rigidbody
    object to move to. To make the Rigidbody move smoothly, we often use interpolation
    to achieve a smooth transition between frames. Since `MovePosition` is still a
    method of Rigidbody, we still call it in the `FixedUpdate` function, as shown
    in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Here, we get user input as the direction of movement and apply the movement
    to the current position. You can also see that the movement vector is multiplied
    by `deltaTime` and `speed`, which is for smooth movement.
  prefs: []
  type: TYPE_NORMAL
- en: After reading this section, we learned how to interact with the Physics system
    through C# scripts. But it's best if we implement a simple game ourselves using
    the physics system, and that's what we'll do in the next section! Let's move on.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a simple game based on the Physics system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have learned the concepts of Unity's Physics system and discussed how to
    use C# code to interact with the Physics system. Next, we will use the knowledge
    we have learned to create a simple physics-based ping-pong game in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s perform the following steps to create a **Plane** object as a
    ping-pong table:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the **Hierarchy** window to open the menu.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **3D Object > Plane** to create a new **Plane** object in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.18 – Creating a Plane object'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.18_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.18 – Creating a Plane object
  prefs: []
  type: TYPE_NORMAL
- en: Rename the `Table`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `2`, and we can see that a Mesh Collider has been added to this object
    by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.19 – The Inspector window of "Table"'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.19_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.19 – The Inspector window of "Table"
  prefs: []
  type: TYPE_NORMAL
- en: Let's create four Cube objects as walls on the table by selecting **3D Object
    > Cube**, which is similar to the process of creating a **Plane** object. By default,
    a Box Collider has been added to every Cube object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can easily adjust the position, size, and rotation of these four Cube objects
    by using the tools in the editor to create the walls on the table.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.20 – Creating walls on the table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.20_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.20 – Creating walls on the table
  prefs: []
  type: TYPE_NORMAL
- en: 'In order to make the table look less boring, we can apply different materials
    to the walls and the table. Now we have set up the ping-pong table, as shown in
    the following image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.21 – The ping-pong table'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.21_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.21 – The ping-pong table
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to create two players, namely, **Player1** and **Player2**. To
    keep it simple, we still use two Cube objects as players:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **3D Object > Cube** to create a new Cube object in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the Cube object to `Player1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the position and size of `3`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.22 – The Inspector window of Player1'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.22_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.22 – The Inspector window of Player1
  prefs: []
  type: TYPE_NORMAL
- en: Let's repeat the preceding steps to create another player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We can use different colors to identify **Player1** and **Player2** to distinguish
    them, as the following figure shows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.23 – Player1 and Player2'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.23_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.23 – Player1 and Player2
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have the **Player** objects in our simple game. Next, we will add a
    ping-pong ball to our game:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **3D Object > Sphere** to create a new **Sphere** object in the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Rename the `Ball`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Ball** to open its Inspector window. We can see that a Sphere Collider
    has been added to the ball by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.24 – The Sphere Collider component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.24_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.24 – The Sphere Collider component
  prefs: []
  type: TYPE_NORMAL
- en: Then, we need to add a **Rigidbody** component to this ball by clicking the
    **Add Component** button and selecting **Physics > Rigidbody**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.25 – Adding a Rigidbody component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.25_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.25 – Adding a Rigidbody component
  prefs: []
  type: TYPE_NORMAL
- en: Then, we change the **Interpolate** option of this **Rigidbody** component from
    **None** to **Interpolate** to make the transformation smooth based on the transformation
    of the previous frame.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.26 – Changing the Interpolate option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.26_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.26 – Changing the Interpolate option
  prefs: []
  type: TYPE_NORMAL
- en: Then, we also change the **Collision Detection** option of this **Rigidbody**
    component from **Discrete** to **Continuous Dynamic** so that we can handle the
    fast-moving ping-pong ball correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.27 – Changing the Collision Detection option'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.27_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.27 – Changing the Collision Detection option
  prefs: []
  type: TYPE_NORMAL
- en: Since the real-world ping-pong ball will bounce back when it hits an obstacle,
    in order to simulate this bounce effect, we need to create a physic material by
    clicking **Create > Physic Material** in the Project window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.28 – Creating a physic material'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.28_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.28 – Creating a physic material
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s select the newly created physic material to open the Inspector window
    and change both `0.4` to `0`, and `0` to `1`. Also, set the `Multiply` and the
    `Maximum`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.29 – Physic Material settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.29_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.29 – Physic Material settings
  prefs: []
  type: TYPE_NORMAL
- en: Then, assign this physic material to the **Material** option of the Sphere Collider.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.30 – Assigning the physic material to the Sphere Collider'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.30_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.30 – Assigning the physic material to the Sphere Collider
  prefs: []
  type: TYPE_NORMAL
- en: 'Now we have set up the ping-pong ball that will be used in our game. Next,
    let''s create a new C# script to apply force to the ball to move it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: In this script, we are using the `AddForce` method and `Impulse` force mode
    that we learned about previously to apply an impulse force to the ball. The direction
    and magnitude of the force are provided by the `_initialImpulse` variable. This
    can be set in the editor.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now attach this script to the ball and provide a value for the `_initialImpulse`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.31 – Ping Pong Ball (Script)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.31_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.31 – Ping Pong Ball (Script)
  prefs: []
  type: TYPE_NORMAL
- en: As the preceding screenshot demonstrates, the value of the `_initialImpulse`
    variable is (`8`, `0`, `8`), which means we add an instant force impulse pointing
    to the lower-right corner of the table to the Rigidbody.
  prefs: []
  type: TYPE_NORMAL
- en: Let's play the game and see what happens.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.32 – The ball is bounced'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.32_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.32 – The ball is bounced
  prefs: []
  type: TYPE_NORMAL
- en: From the picture, we can see that the ping-pong ball in the game hit the wall
    and bounced. Next, we will add more logic to the player objects so that we can
    control them in the game.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, before we start to write C# code for our player objects, we should
    first add a **Rigidbody** component to each of them, and set the **Rigidbody**
    component settings as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.33 – Settings of the player''s Rigidbody component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.33_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.33 – Settings of the player's Rigidbody component
  prefs: []
  type: TYPE_NORMAL
- en: As you can see from the screenshot, we first set the mass of the `1000` and
    disabled the effect of gravity by unchecking the **Use Gravity** option.
  prefs: []
  type: TYPE_NORMAL
- en: Then, it is worth your attention that we have restricted the movement of the
    Rigidbody. Since the player object will only move along the x axis and will not
    rotate, we only keep the Rigidbody moving along the x axis without constraint.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we also need to configure the controls for these two different players,
    as shown in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Project Settings** window by selecting **Edit > Project Settings**
    in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.34 – Opening the Project Settings window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.34_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.34 – Opening the Project Settings window
  prefs: []
  type: TYPE_NORMAL
- en: Select **Input Manager** from the navigation on the left to open the **Input
    Manager** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.35 – Opening the Input Manager window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.35_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.35 – Opening the Input Manager window
  prefs: []
  type: TYPE_NORMAL
- en: 'We will define the input axis and related actions of player 1 and player 2
    in this window to allow us to use the up and down arrow keys and the w and s keys
    to control the movement of these two player objects, respectively, as shown in
    the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.36 – Setting up the input controls for players'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.36_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.36 – Setting up the input controls for players
  prefs: []
  type: TYPE_NORMAL
- en: So far, we have set up the Rigidbody components and the input control needed
    by the player objects, and then we can write a C# script to control the player
    objects in our game.
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember the `MovePosition` method we introduced before? Here, we will use
    this method to move the player objects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, this script will first determine which player
    the object is, get the corresponding input settings, and then determine the direction
    of the object's movement based on the player's input.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's attach this script to these two player objects and start the game!
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.37 – The ping-pong game'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.37_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.37 – The ping-pong game
  prefs: []
  type: TYPE_NORMAL
- en: As shown in the preceding image, we can now use the *w* and *s* keys and the
    *up* and *down* keys to control the movement of player 1 and player 2 and, as
    expected, the ping-pong ball will bounce when it hits the players.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we made a simple physics-based game, and now we will introduce
    how to optimize the performance of the Physics system when developing a game in
    Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the performance of the Physics system
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Physical simulation requires a lot of calculations, especially in the case of
    high physical accuracy requirements. Therefore, it is very important to understand
    how to use Unity's Physics system correctly and reduce unnecessary computing overhead.
  prefs: []
  type: TYPE_NORMAL
- en: The Unity Profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First, we should learn how to use tools to view and locate performance bottlenecks
    caused by the Physics system in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: The **Profiler** tool in the Unity Editor is our recommended tool, which allows
    us to easily view various performance data and locate performance issues related
    to the Physics system.
  prefs: []
  type: TYPE_NORMAL
- en: 'Taking the ping-pong game we just made as an example, we can perform the following
    steps to view the performance data of this game:'
  prefs: []
  type: TYPE_NORMAL
- en: Start the game in the editor by clicking the **Play** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.38 – Playing the game in the editor'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.38_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.38 – Playing the game in the editor
  prefs: []
  type: TYPE_NORMAL
- en: Click **Window > Analysis > Profiler** or use the keyboard shortcut *Ctrl +
    7* (*Command + 7* on macOS) to open the **Profiler** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **CPU Usage** module area in the **Profiler** window to view the
    performance data of CPU overheads, such as the CPU time consumed by **FixedUpdate.PhysicsFixedUpdate**,
    as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.39 – The Unity Profiler'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.39_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.39 – The Unity Profiler
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to the **CPU Usage** module, we can also view the detailed information
    of the Physics system, such as the number of Rigidbodies and the number of contacts
    at a specific moment, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 5.40 – The Physics data in the profiler'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.40_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.40 – The Physics data in the profiler
  prefs: []
  type: TYPE_NORMAL
- en: Next, we will introduce some tips for improving the performance of the Physics
    system.
  prefs: []
  type: TYPE_NORMAL
- en: Increasing the fixed timestep
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'One idea to reduce the cost of physics computing is to reduce the number of
    updates per second of the Physics system. We can perform the following steps to
    increase this **Fixed Timestep** setting to achieve this goal:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Project Settings** window by selecting **Edit > Project Settings**
    in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Time** from the navigation on the left to open the **Time** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.41 – Time settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.41_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.41 – Time settings
  prefs: []
  type: TYPE_NORMAL
- en: The default value of **Fixed Timestep** is **0.02**, which means the Physics
    system will be updated 50 times per second. To reduce the number of updates per
    second, we can increase this value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reducing unnecessary layer-based collision detections
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unity uses a rather inefficient physical collision detection mode by default;
    that is, collision detection is performed on all GameObjects. We can reduce the
    number of collision detections by modifying the **Layer Collision Matrix** field
    in the **Physics** settings of Unity and setting different layers for different
    GameObjects. The following steps demonstrate how to modify it:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Project Settings** window by selecting **Edit > Project Settings**
    in the editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Physics** from the navigation on the left to open the **Physics** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You can find **Layer Collision Matrix** at the bottom of the **Physics** window,
    and you can see in *Figure 5.42* that everything collides with everything by default.
    We should only enable the layers that require collision detection in this matrix.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 5.42 – Layer Collision Matrix'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_5.42_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 5.42 – Layer Collision Matrix
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we introduced how to use Unity's Profiler tool to view the
    performance data of the Physics system and explored how to optimize the performance
    of the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by introducing the physics solutions provided by
    Unity, including two built-in physics solutions, **Nvidia PhysX engine** and **Box2D
    engine**, and Unity also provides Physics engine packages, namely, the **Unity
    Physics package** and the **Havok Physics for Unity package**. Then, we explored
    some of the most important concepts in Unity's Physics system, such as the **Collider**
    component, the **Rigidbody** component, and **Triggers**. We also discussed how
    to create a new script in Unity to interact with Unity's Physics system.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we demonstrated how to implement a physics-based ping-pong game in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored some best practices for applying a physics simulation in
    Unity to optimize the performance problems caused by the Physics system.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be discussing how to implement video and audio
    features in Unity.
  prefs: []
  type: TYPE_NORMAL
