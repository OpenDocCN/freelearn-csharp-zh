- en: Challenges of Applying CI Scenarios in DevOps
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Continuous Integration **(**CI**) is a step ahead of DevOps. In the previous
    chapter, we discussed the basics of CI and how DevOps depends on it. Its implementation
    was presented in [Chapter 18](94c84805-6921-4b9b-9f11-745dce643f53.xhtml), *Understanding
    DevOps Principles*, too, but differently from the other practical chapters, the
    purpose of this chapter is discussing how to enable CI in a real scenario, considering
    the challenges that you, as a software architect, will need to deal with.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The topics covered in this chapter are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the risks and challenges when using CI
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the WWTravelClub project approach for this chapter
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Like in the previous chapter, the sample of the WWTravelClub will be presented
    during the explanation of the chapter, since all the screens captured to exemplify
    CI came from it. Besides this, we will offer a conclusion at the end of the chapter so
    you can understand CI principles easily.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you will be able to decide whether or not to use
    CI in your project environment. Additionally, you will be able to define the tools
    needed for the successful use of this approach.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter requires Visual Studio 2019 Community Edition or better. You may
    also need an Azure DevOps account, as described in [Chapter 3](bc26065f-b001-4123-9524-3bbfa87bfadd.xhtml),
    *Documenting Requirements with Azure DevOps*.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As soon as you start working with a platform such as Azure DevOps, enabling
    CI will definitely be easy when it comes to clicking on the options for doing
    so, as we saw in [Chapter 18](94c84805-6921-4b9b-9f11-745dce643f53.xhtml), *Understanding
    DevOps Principles*. So, technology is not the Achilles' heel for implementing
    this process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows an example of how easy it is to turn on CI using
    Azure DevOps. By clicking in the build pipeline and editing it, you will be able
    to set a trigger that enables CI after some clicks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f57caac3-6103-4833-a17e-082a6c739f89.png)'
  prefs: []
  type: TYPE_IMG
- en: The truth is that CI will help you solve some problems. For instance, it will
    force you to test your code, since you will need to commit the changes faster,
    so other developers can make use of the code you are programming.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you will not enable CI just by clicking on the preceding
    screenshot. For sure, you will turn on the possibility of starting a build as
    soon as you get a commit done and the code is done, but this is far from saying
    you have CI available in your solution.
  prefs: []
  type: TYPE_NORMAL
- en: The reason why you as a software architect need to worry a bit more about it
    is related to the real understanding of what DevOps is. As discussed in [Chapter
    18](94c84805-6921-4b9b-9f11-745dce643f53.xhtml), *Understanding DevOps Principles*,
    the need to deliver value to the end user will always be a good way to decide
    and draw the development life cycle. So, even if turning on CI is easy, what is
    the impact of this feature being enabled for your end user? Once you have all
    the answers to this question and you know how to reduce the risks of its implementation,
    then you will be able to say that you have a CI process implemented.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth mentioning that CI is a principle that will make DevOps work better
    and faster, as was discussed in [Chapter 18](94c84805-6921-4b9b-9f11-745dce643f53.xhtml),
    *Understanding DevOps Principles*. However, DevOps surely can live without it,
    once you are not sure if your process is mature enough to enable code being continuously
    delivered. More than that, if you turn on CI in a team that is not mature enough
    to deal with its complexity, you will probably cause a bad understanding of DevOps,
    since you will start incurring some risks while deploying your solution.
  prefs: []
  type: TYPE_NORMAL
- en: This is the reason why we are dedicating an extra chapter on CI. You need to
    understand the risks and challenges you will have as a software architect once
    you turn CI on.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the risks and challenges when using CI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now, you may be thinking about the risks and challenges as a way for you to
    avoid using CI. But why should we avoid using it if it will help you do a better
    DevOps process? This is not the purpose of the chapter. The idea of this section
    is to help you, as a software architect, to mitigate the risks and find a better
    way to pass through the challenges using good processes and techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'The list of risks and challenges that will be discussed in the chapter are
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Continuous production deployment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Incomplete features in the production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unstable solutions for testing
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Once you have the techniques and the processes defined to deal with them, there
    is no reason to not use CI. It is worth mentioning that DevOps does not depend
    on CI. However, it does make DevOps work more softly. Now, let's have a look at
    them.
  prefs: []
  type: TYPE_NORMAL
- en: Disabling continuous production deployment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuous production deployment is a process where, after a commit of a new
    piece of code and some pipeline steps, you will have this code in the production
    environment. This is not impossible but is really hard and expensive to do. Besides,
    you need to have a really mature team. The problem is that most of the demos and
    samples you will find on the internet presenting CI will show you a fast-track
    to deploy the code. The demonstrations of CI/CD look so simple and easy to do!
    This *simplicity* can suggest you work as soon as possible on its implementation. However,
    if you think a little more, this scenario can be dangerous if you deploy directly
    in production! In a solution that needs to be available 24 hours a day, 7 days
    a week, this is impractical. So, you will need to worry about that and think of
    different solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'The first one is the use of a multi-stage scenario, as described in [Chapter
    18](94c84805-6921-4b9b-9f11-745dce643f53.xhtml), *Understanding DevOps Principles*.
    The multi-stage scenario can bring more security to the ecosystem of the deployment
    you are building. Besides, you will get more options to avoid wrong deployments
    into production, such as pre-deployment approvals:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a694759e-0730-4a80-96c0-78b22dfd6f82.png)'
  prefs: []
  type: TYPE_IMG
- en: It is worth mentioning, too, that you can build a deployment pipeline where
    all your code and software structure will be updated by this tool. However, if
    you have something out of this scenario, such as database scripts and environment
    configurations, a wrong publication into production may cause damage to end users.
    Besides, the decision of when the production will be updated needs to be planned
    and, in many scenarios, all the platform users need. Use a *change management*
    procedure in these cases needs to be decided.
  prefs: []
  type: TYPE_NORMAL
- en: So, the challenge of delivering code to production will make you think about
    a schedule to do so. It does not matter if your cycle is monthly, daily, or even
    at each commit. The key point here is that you need to create a process and a
    pipeline that guarantees that only good and approved software is in the production
    stage.
  prefs: []
  type: TYPE_NORMAL
- en: Incomplete features
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'While a developer of your team is creating a new feature or fixing a bug, you
    will probably consider generating a branch that can avoid the use of the branch
    designed for continuous delivery. A branch can be considered a feature available
    in code repositories to enable the creation of an independent line of development
    since it isolates the code. As you can see in the following screenshot, creating
    a branch using Visual Studio is quite simple:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6a9163cb-9564-4941-a9fd-323d86ec3eb7.png)'
  prefs: []
  type: TYPE_IMG
- en: This seems to be a good approach, but let's suppose that the developer has considered
    the implementation ready for deploying and has just merged the code into the master
    branch. What if this feature is not ready yet, just because a requirement was
    omitted? What if the bug has caused an incorrect behavior? The result can be a
    release with an incomplete feature or an incorrect fix.
  prefs: []
  type: TYPE_NORMAL
- en: 'A good practice to avoid broken features and even wrong fixes in the master
    branch is the use of pull requests. Pull requests will let other team developers
    know that the code you developed is ready to be merged. The following screenshot
    shows how you can use Azure DevOps to create a New Pull Request for a change you
    have made:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1da2c9b5-89d2-4b5e-b666-bc26a3f505e4.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the pull request is created and the reviewers are defined, each reviewer
    will be able to analyze the code and decide whether this code is healthy enough
    to be in the master branch. The following screenshot shows a way to check it by
    using the compare tool to analyze the change:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3738a72b-ec3a-469f-a1d5-4bc0103878f7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once all approvals are done, you will be able to safely merge the code to the
    master branch, as you can see in the following screenshot. To merge the code,
    you will need to click on Complete merge. If the CI trigger is enabled, as shown
    earlier in the chapter, Azure DevOps will start a build pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/66fdc5c1-d45a-4c71-b95d-3746b6f34019.png)'
  prefs: []
  type: TYPE_IMG
- en: There is no way to argue that without a process like this, the master branch
    will suffer from many bad code being deployed that can cause damage together with
    CD. It is worth mentioning that the code review is an excellent practice in CI/CD
    scenarios, and it is considered a wonderful practice for creating good quality
    in any software as well.
  prefs: []
  type: TYPE_NORMAL
- en: The challenge that you need to focus on here is guaranteeing that only entire
    features will appear to your end users. You may use for solving it the feature
    flag principle, which is a technique that makes sure only features that are ready
    are presented to end users. Again, we are not talking about CI as a tool, but
    as a process to be defined and used every single time you need to deliver code
    for production.
  prefs: []
  type: TYPE_NORMAL
- en: Unstable solution for testing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Considering that you have already mitigated the two other risks presented in
    this topic, you may find it pretty hard to have bad code after CI. It is true
    that the worries presented earlier will certainly be lower considering the fact
    that you are working with a multi-stage scenario and pull requests before pushing
    to the first stage.
  prefs: []
  type: TYPE_NORMAL
- en: But is there a way to accelerate the evaluation of release, being sure that
    this new release is ready for your stakeholder's tests? Yes, there is! Technically,
    the way you can do so is described in the use cases of [Chapter 15](c707cf13-3616-4788-8f39-687bd1cb7c7b.xhtml),
    *Testing Your Code with Unit Test Cases a**nd TDD*, and [Chapter 20](e61b3c5d-3abd-4442-9c9c-e12fd3acedcc.xhtml),
    *Automation for Software Testing*.
  prefs: []
  type: TYPE_NORMAL
- en: As discussed in both those chapters, it is impracticable to automate every single
    part of the software, considering the efforts needed to do so. Besides, the maintenance
    of automation can be more expensive in scenarios where the user interface or the
    business rules change a lot.
  prefs: []
  type: TYPE_NORMAL
- en: 'To exemplify it, let''s have a look at the following screenshot, which shows
    the unit and functional tests created by Azure DevOps when the WWTravelClub project
    is started:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b21f9b1-ac3f-4d12-a1f1-89a463ed44d9.png)'
  prefs: []
  type: TYPE_IMG
- en: There are some architectural patterns, such as SOLID, presented in [Chapter
    9](a2d50e08-6698-47f6-a9b5-188de08134c0.xhtml), *Design Patterns and .NET Core
    Implementation*, and quality assurance approaches, such as peer review, that will
    give you better results than software testing.
  prefs: []
  type: TYPE_NORMAL
- en: However, these approaches do not invalidate automation practice. The truth is
    that all of them will be useful for getting a stable solution, especially when
    you are running a CI scenario. In this environment, the best thing you can do
    is to detect errors and wrong behaviors as fast as you can. Both unit and functional
    tests, as shown earlier, will help you with this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unit tests will help you a lot while discovering business logic errors before
    deployment, during the building pipeline. For instance, in the following screenshot,
    you will find a simulated error that canceled the build since the unit test did
    not pass:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4d978df6-4805-403c-8c8c-ad58718c16b7.png)'
  prefs: []
  type: TYPE_IMG
- en: The way to get this error is quite simple. You need to code something that does
    not respond according to what the unit tests are checking. Once you commit it,
    considering you have the trigger of continuous deployment on, you will have the
    code building in the pipeline. One of the last steps provided by the Azure DevOps
    Project Wizard we have created is the execution of the unit tests. So, after the
    build of the code, the unit tests will run. If the code does not match the tests
    anymore, you will get the error.
  prefs: []
  type: TYPE_NORMAL
- en: 'Meanwhile, the following screenshot shows an error during the functional tests
    in the Development/Tests stage. At this moment, the Development/Tests environment
    has a bug that was rapidly detected by functional tests:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f192881d-5f7d-4a01-9c6c-ce5cc904cced.png)'
  prefs: []
  type: TYPE_IMG
- en: 'But this is not the only good thing about applying functional tests in the
    process of CI/CD, once you have protected other deployment stages with this approach.
    For instance, let''s take a look at the following screenshot from the Release
    pipeline interface in Azure DevOps. If you look at Release-9, you will realize
    that since this error happened after the publication in the Development/Tests
    environment, the multi-staged environment will protect the other stages of the
    deployment:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/acf1c1ea-946e-4322-bd1b-b5937476833e.png)'
  prefs: []
  type: TYPE_IMG
- en: The key point to success in the CI process is to think about it as a useful
    tool for accelerating the delivery of software and to not forget that a team always
    needs to deliver value to their end users. With this approach, the techniques
    presented earlier will provide incredible ways to achieve the results that your
    team aims for.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the WWTravelClub project approach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'During the chapter, WWTravelClub project screenshots were present, exemplifying
    the steps for getting a safer approach while enabling CI. Even considering WWTravelClub
    as a hypothetical scenario, some concerns were taken into account while building
    it:'
  prefs: []
  type: TYPE_NORMAL
- en: CI is enabled, but a multi-stage scenario is enabled too.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even with a multi-stage scenario, the pull request is a way to guarantee that
    only code with good quality will be presented in the first stage.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To do a good job in the pull request, peer reviews are undertaken.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peer reviews check, for instance, the presence of a feature flag while creating
    a new feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The peer reviews check both unit and functional tests developed during the creation
    of the new feature.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The preceding steps are not exclusively for WWTravelClub. You as a software
    architect will need to define the approach to guarantee a safe CI scenario. You
    may use this as a starting point.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter covered the importance of understanding when you can enable CI
    in the software development life cycle, considering the risks and challenges you
    will take as a software architect once you decide to have it done in your solution.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the chapter introduced some solutions and concepts that can make
    this process easier, such as multi-stage environments, pull request reviews, feature
    flags, peer reviews, and automated tests. Understanding these techniques and processes
    will enable you to guide your project to a safer behavior when it comes to CI
    in a DevOps scenario.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how automation for software testing works.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: What is CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Can you have DevOps without CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: What are the risks of enabling CI in a non-mature team?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can a multi-stage environment help CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can automated tests help CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: How can pull requests help CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Do pull requests only work with CI?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'These are some websites where you will find more information on the topics
    covered in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://azure.microsoft.com/en-us/solutions/architecture/azure-devops-continuous-integration-and-continuous-deployment-for-azure-web-apps/](https://azure.microsoft.com/en-us/solutions/architecture/azure-devops-continuous-integration-and-continuous-deployment-for-azure-web-apps/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/devops-project/azure-devops-project-github](https://docs.microsoft.com/en-us/azure/devops-project/azure-devops-project-github)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/azure/devops/cicd](https://docs.microsoft.com/en-us/aspnet/core/azure/devops/cicd)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/virtualization-and-cloud/professional-microsoft-azure-devops-engineering](https://www.packtpub.com/virtualization-and-cloud/professional-microsoft-azure-devops-engineering)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/virtualization-and-cloud/hands-devops-azure-video](https://www.packtpub.com/virtualization-and-cloud/hands-devops-azure-video)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/networking-and-servers/implementing-devops-microsoft-azure](https://www.packtpub.com/networking-and-servers/implementing-devops-microsoft-azure)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/azure/devops/repos/git/pullrequest](https://docs.microsoft.com/en-us/azure/devops/repos/git/pullrequest)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/](https://devblogs.microsoft.com/devops/whats-new-with-azure-pipelines/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://martinfowler.com/bliki/FeatureToggle.html](https://martinfowler.com/bliki/FeatureToggle.html)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
