- en: Chapter 7. Project D – Intelligent Enemies
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this chapter, we''ll start the final project, which will cover extensive
    ground. This project, unlike the previous three, will not be a fully completed
    game with a clear win and loss condition but will be a functional prototype and
    *proof of concept* style project that highlights a range of important coding techniques
    and ideas prevalent in games. Specifically, we''ll create a world with a terrain,
    first-person character, and some enemies. The enemies will have **Artificial Intelligence**
    (**AI**), patrol the level searching for the player, and attack the player when
    found. In this chapter, we will explore the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: How to build levels and landscapes with the Terrain tools
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to generate and use navigation meshes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: How to prepare for Artificial Intelligence development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: The starting project and assets can be found in the book companion files in
    the `Chapter07/Start` folder. You can start here and follow along with this chapter
    if you do not have your own project already.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: An overview of the project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The project to be created is a first-person prototype in which the player character
    can wander and explore a terrain environment. The terrain features hills, valleys,
    and varied terrain elements. Among the terrain will be scattered several enemy
    characters (NPCs). Each character features artificial intelligence. Specifically,
    each character will wander around (Patrol mode) searching for the player. If the
    player is sighted, the NPC will chase and pursue the player (Chase mode). If,
    during the chase, the enemy loses sight of the player, they will return to patrolling.
    On the other hand, if the enemy approaches the player during the chase, the enemy
    will attack the player (Attack mode). In short, therefore, the AI features three
    main states: Patrol, Chase, and Attack. This, in short, constitutes the enemy
    AI and represents the main challenge for the player on this project. See *Figure
    7.1* for the completed project:'
  prefs: []
  type: TYPE_NORMAL
- en: '![An overview of the project](img/B05118_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.1: Building a world of intelligent NPCs'
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To get started from the beginning, create a new project. The details on this
    are covered amply in all previous chapters. Throughout this project, we''ll be
    using three main asset packages included with Unity. Specifically, these are Characters,
    Effects, and Environment. These can be imported via the application menu, through
    **Assets** | **Import Packages**. See *Figure 7.2*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/B05118_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.2: Importing asset packages'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start, we''ll need to create the game world itself (the terra firma), which
    will be an outdoor (exterior) environment. In other words, we''ll create a game
    world with grassy plains, hills, and mountains. Such a landscape can be made in
    3D modeling software, such as 3DS Max, Maya, or Blender, and then imported to
    Unity. However, Unity features native terrain design tools that, though limited
    in important ways (as we''ll see), are still powerful and versatile. To create
    a new terrain, navigate to **GameObject** | **3D Object** | **Terrain** from the
    application menu. See *Figure 7.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/B05118_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.3: Creating a new terrain'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once created, a terrain object is added to the scene at the world origin (0,0,0).
    It may not immediately appear in the viewport due to its size. To address this,
    select the terrain in the **Hierarchy** panel and then press *F* on the keyboard
    to center it in the view. It initially looks like a flat plane object but, unlike
    planes, it can be reshaped and sculpted, as we''ll see soon. *See Figure 7.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/B05118_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.4: A terrain is added to the scene'
  prefs: []
  type: TYPE_NORMAL
- en: 'Before sculpting and shaping the terrain, you should first set some initial
    topological settings from the **Object Inspector** in order to ensure that terrain
    topology is appropriate and sized to support the kind of terrain you need. To
    do this, select the terrain in the viewport, and then click on the cog icon from
    the **Object Inspector** to display the terrain settings. See *Figure 7.5*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/B05118_07_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.5: Viewing and editing the terrain settings'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the terrain is too large for most purposes (500 x 500 meters). Let's
    shrink this to 256 x 256, or even smaller, if you prefer! Simply enter `256` in
    the **Width** and **Length** fields. The **Height** field represents the maximum
    height that any terrain peak or mountain can possibly reach. For optimization
    reasons, the terrain should be no larger than needed, as terrain objects are highly
    tessellated and performance-intensive. See *Figure 7.6*. Be sure to set the terrain
    dimensions before sculpting as resizing afterward can invalidate or erase sculpting
    work.
  prefs: []
  type: TYPE_NORMAL
- en: '![Getting started](img/B05118_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.6: Setting terrain resolution in width and length'
  prefs: []
  type: TYPE_NORMAL
- en: Terrain construction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now let's start sculpting the terrain. With the terrain object selected, click
    the leftmost palette icon from the **Object Inspector** (the Raise/Lower terrain
    tool), available from the Terrain component. This lets you select brush shapes
    to paint terrain details. Select a soft, round brush and use a large brush size
    (using the **Brush Size** slider), along with the **Opacity** setting to set brush
    strength. Click and drag over the terrain to paint landscape details. Create some
    hills and mountains for the landscape. See *Figure 7.7*. Remember, you can hold
    down the *Shift* key while clicking to reverse (or lower) the terrain painting,
    if needed.
  prefs: []
  type: TYPE_NORMAL
- en: '![Terrain construction](img/B05118_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.7: Viewing and editing the terrain settings'
  prefs: []
  type: TYPE_NORMAL
- en: If the terrain appears too rough to be natural, you can easily smooth out details
    by switching to the **Smooth Height** tool. To do this, click on the third button
    in the **Terrain** component. See *Figure 7.8*. When you select this tool, you
    can choose the **Brush Shape**, **Brush Size**, and **Opacity** as before, but
    clicking over the terrain will smooth out variations in terrain height.
  prefs: []
  type: TYPE_NORMAL
- en: '![Terrain construction](img/B05118_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.8: Accessing the Smooth Height tool'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that the terrain is sculpted, shaped, and smooth as needed, we''re ready
    to start painting it. As it stands, the terrain is grey, dull, and under-defined.
    It has no clear texture or *look*, such as grass or rock. We''ll fix this using
    the **Paint Texture** tool. To access this, click on the **Paint Texture** button
    (fourth button) in the **Terrain** component from the **Object Inspector**. When
    you do this for the first time, you''ll need to load in and prepare a set of textures
    for the painting. See *Figure 7.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Terrain construction](img/B05118_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.9: Preparing textures for terrain painting'
  prefs: []
  type: TYPE_NORMAL
- en: 'Click on the **Edit Textures** button, and then select **Add Texture…** from
    the context menu that appears. Afterward, a texture configuration dialog appears,
    allowing you to add new textures to a palette. See *Figure 7.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Terrain construction](img/B05118_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.10: Adding textures to the Texture Paint palette'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **Texture Selection** dialog open and ready to load our first texture,
    use the **Project** panel to find the native terrain textures included with the
    Unity Environment asset package. These can be found in the **Standard Assets**
    | **Environment** | **TerrainAssets** | **SurfaceTextures** folder. For this example,
    I''ll select a grassy texture. This texture will be used as a base texture to
    flood-fill the terrain. Click and drag the grass texture from the **Project**
    panel to the Albedo slot of the **Texture Selection** dialog. The normal channel
    can be left empty. See *Figure 7.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Terrain construction](img/B05118_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.11: Selecting a base texture'
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the first texture to the **Texture Selection** dialog, be sure
    to set the texture size. This refers to the size (in meters) that a single tile
    of the texture should cover. Smaller values decrease texture tiling but make each
    tile seem larger. Larger values increase texture tiling but each tile seems smaller.
    Getting the tiling values correct is a process of trial and error—tweaking values
    until it looks correct on the terrain. For this example, I''ve used the values
    75 x 75\. Then, click on the **Add** button. See *Figure 7.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Terrain construction](img/B05118_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.12: Setting texture tile Size'
  prefs: []
  type: TYPE_NORMAL
- en: After clicking on the **Add** button, the base texture will be tiled across
    the terrain. From a distance, the tiling may look obvious and unpleasant in the
    scene viewport. You may be tempted, on the basis of this, to adjust the tiling
    settings. However, from a first-person perspective, the terrain will look very
    different. For this reason, use a First-person Controller prefab (from the native
    assets) to preview the terrain in first-person mode, seeing how texture tiling
    appears at ground-level.
  prefs: []
  type: TYPE_NORMAL
- en: '![Terrain construction](img/B05118_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.13: Previewing texture tiling on a terrain'
  prefs: []
  type: TYPE_NORMAL
- en: If you need to edit the existing texture tiling, simply select the texture thumbnail
    from the **Textures** palette in the **Terrain** component of the **Object Inspector**,
    and then choose the **Edit Textures** button. Refer to the preceding *Figure 7.10*.
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, the terrain object features a grass texture, tiled seamlessly
    across the surface, which is the base texture. While this looks acceptable, it''d
    be great to include greater texture variety in the terrain, including some grassy,
    rocky, and maybe even desert style terrain. This is achieved by adding more textures
    via the **Terrain Selection** dialog. Just click on the **Edit Textures** button,
    and then choose **Add Texture** from the context menu. Then, drag and drop a new
    and different texture to the Albedo slot of the texture selection dialog, and
    finally repeat this process to add as many textures as needed. On closing the
    dialog, all added textures will appear in the **Textures Palette** from the **Object
    Inspector**. See *Figure 7.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Terrain construction](img/B05118_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.14: Adding textures to the Texture Palette'
  prefs: []
  type: TYPE_NORMAL
- en: 'The active texture assigned to the painter brush is highlighted with a blue
    border in the **Inspector**. You can click on a texture thumbnail to select a
    different texture. When you do this, the selected texture is assigned to the painter
    brush and can be applied to the terrain just by clicking on it. Clicking and dragging
    on the terrain will paint the texture to the terrain. You can also use the **Brush
    Shape**, **Brush Size**, **Opacity**, and **Target Strength** values to control
    how strongly the texture is applied and how it is blended into the terrain beneath.
    See *Figure 7.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Terrain construction](img/B05118_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.15: Layered painting and blended textures'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, go ahead and complete terrain painting, creating a look and feel that
    you like. Once completed, select the scene **Directional Light** from the **Hierarchy**
    panel and change its rotation to position the sun wherever it looks good. As an
    aside, notice that you can control a complete day and night cycle (in terms of
    lighting and appearance) by rotating the light a complete 360 degrees. Therefore,
    you can create an easy day and night cycle for games just by animating a directional
    light using the **Animation** window, seen in earlier chapters. See *Figure 7.16*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Terrain construction](img/B05118_07_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.16: Completed terrain'
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, take a tour of the terrain using a first-person controller asset.
    Press the play icon on the toolbar and explore around the level! Congratulations,
    you now have a game world with a terrain included. See *Figure 7.17*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Terrain construction](img/B05118_07_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.17: First-person terrain exploration'
  prefs: []
  type: TYPE_NORMAL
- en: Before moving forward, let's consider the technical limitations of Unity terrains
    and the impact that this can potentially have for your games. Specifically, the
    Unity terrain is height map-based. This means that the elevation (ups and downs)
    of the terrain are generated internally based on grayscale pixels in an image
    file (the height map). When painting the terrain using the brushes from the **Inspector**,
    you are (under the hood) painting pixels onto the height map, which is used to
    deform the terrain. This is a clever and fascinating process, but it comes with
    an important limitation. Namely, a height map is a 2D topographical texture. The
    result is that Unity terrains are not truly 3D at a procedural level; they cannot
    contain caves, crevices, caverns, or any inward cutouts. The player cannot *go
    under* anything. Rather, it consists simply of up and down sections, none of which
    may have interior spaces. Now, in many cases, this won't be a problem. However,
    sometimes you'll need these internal spaces, and when you do, you'll want to consider
    alternatives to the native terrain system. Alternatives include Asset Store plugins,
    but also manual terrains in 3D modeling software such as 3DS Max, Maya, and Blender.
  prefs: []
  type: TYPE_NORMAL
- en: Navigation and navigation meshes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The world terrain is now fully created. In reaching this stage, we must now
    start thinking about the main aims of our project. Specifically, the level should
    be an AI experiment: we want to create enemy NPC characters that can wander freely
    around the terrain and will chase and attack the player whenever the player enters
    their field of view. To achieve this, the level must be properly configured for
    path-finding, which is considered here.'
  prefs: []
  type: TYPE_NORMAL
- en: On thinking about NPC AI and NPC movement around the level, it's clear that
    the terrain is bumpy and features many hills, mountains, dips, and inclines. For
    an NPC character to navigate this terrain successfully, many complexities are
    involved. For example, an NPC cannot simply travel in only straight lines from
    point A to point B because doing so would cause the NPC to pass through solid
    objects and terrain. The NPC needs to maneuver intelligently around, under, and
    over appropriate parts of the terrain, just as human intelligence would. This
    is important to create believable characters. The computational processes involved
    in calculating appropriate paths for NPCs is called **Path-Finding**, and the
    processes to make a character travel those paths is termed **Navigation**. Unity
    comes with path-finding and navigation features built-in, making it easy for NPCs
    to calculate and travel paths.
  prefs: []
  type: TYPE_NORMAL
- en: 'To prepare for this, a Navigation Mesh must be generated. This is a special
    mesh asset included in the scene, which uses non-rendered geometry to approximate
    the total walkable surface of a scene. This is used by the path-finding and navigation
    processes to move a character around. To get started with generating a navigation
    mesh, select **Window** | **Navigation** from the application menu. See *Figure
    7.18*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation and navigation meshes](img/B05118_07_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.18: Accessing the Navigation window'
  prefs: []
  type: TYPE_NORMAL
- en: 'The purpose of the **Navigation** window is to generate a low-fidelity terrain
    mesh that actually approximates the level floor. For this process to work effectively,
    all non-movable floor meshes in the scene must be marked as **Navigation Static**.
    To do this, select the terrain in the **Hierarchy** panel and, from the **Inspector**,
    click on the **Static** drop-down and enable the **Navigation Static** option.
    See *Figure 7.19*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation and navigation meshes](img/B05118_07_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.19: Marking non-movable floor objects as Static'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now access the **Navigation** window (which I typically dock into the **Inspector**).
    From here, click on the **Bake** tab to access the main **Navigation** settings.
    From this panel, you can control a range of settings to influence Navigation Mesh
    (NavMesh) generation. See *Figure 7.20*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation and navigation meshes](img/B05118_07_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.20: The Bake contains the main settings for Navigation Mesh generation'
  prefs: []
  type: TYPE_NORMAL
- en: 'To get started, let''s just generate an initial Navigation Mesh to see how
    the default settings look. We can easily erase and regenerate the mesh under new
    settings if needed. To do this, click on the **Bake** button from the **Inspector**.
    When you do this, a default Navigation Mesh is generated and appears in blue above
    the terrain from the **Scene** viewport. See *Figure 7.21*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation and navigation meshes](img/B05118_07_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.21: A default Navigation Mesh'
  prefs: []
  type: TYPE_NORMAL
- en: 'The default navigation mesh is problematic. It should represent the entire
    walkable regions of the level. It is, essentially, the area to which NPCs will
    be restricted when they move around. You''ll see from the navigation mesh in the
    preceding image that it''s fractured and broken in many places—some areas are
    totally isolated and disconnected from others. This is often undesirable because
    it means that any NPC walking within one isolated region cannot access or move
    to another as there is no connection between the two areas and the NPC can only
    move on the navigation mesh. To fix this properly, two settings must be adjusted.
    First, adjust the **Agent Radius** setting. This controls how large an average
    agent (NPC) is, and it affects how close the Navigation Mesh can expand toward
    the surrounding mesh floor and its edges. Lower (smaller) settings allow the mesh
    to encroach nearer to the mesh edges, resulting in an expanded navigation mesh.
    Try reducing **Agent Radius** and then clicking on **Bake** again to observe the
    result. See *Figure 7.22*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation and navigation meshes](img/B05118_07_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.22: Refining the mesh via Agent Radius'
  prefs: []
  type: TYPE_NORMAL
- en: 'This improves the meshes but we still have broken or fractured areas. This
    is also because of the **Max Slope** setting, which controls how steep a surface
    should be (such as the incline of a mountain) before it becomes unwalkable for
    an NPC. Increase this setting to expand the navigation mesh further, and click
    on **Bake**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation and navigation meshes](img/B05118_07_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.23: Increasing Max Slope to expand the navigation mesh over the terrain'
  prefs: []
  type: TYPE_NORMAL
- en: 'Congratulations. You have now constructed a Navigation Mesh for the level.
    The NavMesh asset itself is stored in a folder matching the scene name. When selected
    in the **Project** panel, you can preview various read-only properties describing
    the Navigation Mesh, such as **Height** and **Walkable Radius** settings. See
    *Figure 7.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Navigation and navigation meshes](img/B05118_07_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.24: Previewing Navigation Mesh properties from the Project panel'
  prefs: []
  type: TYPE_NORMAL
- en: Building an NPC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Now we''ll build an NPC character that''ll display artificial intelligence.
    To get started, we''ll use the Ethan mesh included in the Unity native companion
    assets. This can be found in the **Project** panel under the **Standard Assets**
    | **Characters** | **ThirdPersonCharacter** | **Models** folder. From here, drag
    and drop the Ethan model to the scene and position it on the terrain. We''ll refine
    and edit this model and, eventually, create a prefab from it to represent an NPC
    character. See *Figure 7.25*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an NPC](img/B05118_07_25.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.25: Starting an NPC character'
  prefs: []
  type: TYPE_NORMAL
- en: 'When adding the Ethan model to the level, ensure that the blue forward vector
    of the character is pointing forward, facing the direction in which the character
    is actually looking. If the forward vector is not front-aligned, then create an
    empty object and align the character model to that as a child object so that the
    forward vector of the parent is pointing straight ahead, along the character''s
    line of sight. That is, the blue forward vector should align with the character''s
    eye (be looking in the same direction). This is highly important to make your
    character move around believably. See *Figure 7.26*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an NPC](img/B05118_07_26.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.26: Forward vector (blue arrow) pointing forward at the character''s
    feet'
  prefs: []
  type: TYPE_NORMAL
- en: 'The NPC should navigate and walk around the terrain intelligently using the
    Navigation Mesh generated for the level. For this, a NavMesh agent component should
    be attached to the character. Select the Ethan model in the level and, from the
    application menu, choose **Component** | **Navigation NavMesh Agent**. The NavMesh
    Agent component contains both Path-Finding and Steering (Navigation) behaviors
    that allow a GameObject to move around a Navigation Mesh. See *Figure 7.27*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an NPC](img/B05118_07_27.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.27: Attaching a NavMeshAgent component to an NPC'
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, the Navigation Mesh assigns a Cylinder Collision volume to the
    Agent—the object that will navigate and move around. This is not a true collider
    that acts with the physics system but a pseudo-collider used to determine when
    the character nears the edge of a navigation mesh. Select the Ethan NPC and, from
    the **Inspector** in the NavMesh Agent component, set the **Height** to `1.66`
    and **Radius** to `0.22`. This approximates the mesh more closely. See *Figure
    7.28*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an NPC](img/B05118_07_28.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.28: Sizing the Agent Collider'
  prefs: []
  type: TYPE_NORMAL
- en: For test purposes, let's make the mesh move; just to see that everything is
    working as it should be. To do this, we'll need to make a new script. First, create
    a new empty object, which will act as a *Destination*, that is, a target object
    that the NPC should reach, wherever it is. Select **GameObject** | **Create Empty**
    from the application menu. Name it `Destination`, and then assign it a Gizmo icon
    to make it visible in the viewport. See *Figure 7.29*. Simply click on the cube
    icon at the top left of the **Object Inspector** with the object selected, and
    then choose an icon representation.
  prefs: []
  type: TYPE_NORMAL
- en: '![Building an NPC](img/B05118_07_29.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.29: Creating a Destination object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create a new C# script file (`FollowDestination.cs`) and attach it to
    the NPC object in the scene. The code is included in *Code Sample 7.1*, and comments,
    which is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Code Sample 7.1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The following points summarize the code sample:'
  prefs: []
  type: TYPE_NORMAL
- en: The `FollowDestination` class can be attached to any object with a NavMeshAgent.
    This object should follow the destination object as it moves.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Destination` variable maintains the destination object to follow.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Once attached to the NPC object, drag and drop the destination empty object
    to the **Destination** slot for the FollowDestination component in the **Inspector**.
    This assigns a destination for the script. See *Figure 7.30*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 7.1](img/B05118_07_30.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.30: Configuring a FollowDestination object'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now give the game a test run. During gameplay, move the destination object
    around via the **Scene** tab and see how the NPC responds. The NPC should continually
    chase the destination object. In addition, if you play the game with the **Navigation**
    window open in the **Inspector** and with the NPC selected in the **Hierarchy**
    panel, the **Scene** view will display diagnostic information and gizmos, allowing
    you to preview and visualize the route calculated by the NPC. See *Figure 7.31*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Code Sample 7.1](img/B05118_07_31.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.31: Testing NPC Navigation'
  prefs: []
  type: TYPE_NORMAL
- en: Creating patrolling NPCs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have an NPC that follows a destination object, which is valuable in itself
    as an exercise, but we'll need more sophisticated behavior than this. Specifically,
    we'll need the NPC to patrol, that is, move across multiple destinations in order
    via a waypoint system, moving from one destination to the next in sequence. There
    are multiple approaches that could be taken to achieve this. One method is through
    script. Through this method, we'd create an array of different waypoint objects
    and iterate through them on a loop such that when the NPC reaches one destination,
    they'll move on to the next one. Now, this approach can be very efficient and
    effective, but there's another method. Specifically, instead of using script,
    we can create an animation to move a single destination object to different waypoint
    locations over time, and because the NPC continually follows the destination wherever
    it moves, it will continually patrol.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take this second approach. Start by opening the **Animation** window by
    selecting **Window** | **Animation** from the application menu. See *Figure 7.32*.
    Dock the **Animation** window into a horizontal view in the **Project** panel,
    if you prefer, for ease of viewing.
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating patrolling NPCs](img/B05118_07_32.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.32: Accessing the Animation window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, select the object to animate (the destination object) from the **Hierarchy**
    panel and, from the **Animation** window, click on the **Create** button. From
    here, you will be asked to name and save the animation. I''ve called the animation
    `anim_DestPatrol`. See *Figure 7.33*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating patrolling NPCs](img/B05118_07_33.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.33: Creating a new Animation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the animation is created you can proceed to define animation channels.
    For the destination object, we''ll need a channel for the position field as the
    object should change position around the scene. Click on the **Add Property**
    button from the **Animation** window, and then choose **Transform** | **Position**
    to add a new position channel. This will automatically create starting and ending
    key frames in the timeline, which are identical and hold the object position.
    See *Figure 7.34*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating patrolling NPCs](img/B05118_07_34.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.34: Creating a new Animation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, simply click and drag the vertical, red time slider across the timeline
    in the **Animation** window, between the 0-1 range, and then change the position
    of the destination object in the **Scene** tab to a new position. When you do
    this, Unity records the object position for that key frame. Repeat this process
    across the timeline, moving the destination object to different positions each
    time, and this creates a complete patrol animation. See *Figure 7.35*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating patrolling NPCs](img/B05118_07_35.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.35: Building a Patrol Animation..'
  prefs: []
  type: TYPE_NORMAL
- en: 'Play the animation back by pressing play from either the **Animation** window
    or via the toolbar. By default, the animation will probably play back too fast
    (that''s an easy fix, as we''ll see), but notice also that, as expected, the destination
    object is *tweened*. That is, the Unity Animation interpolates between the key
    frames in the timeline, causing the destination object to slide or move smoothly
    between waypoints. For animation like this, however, we just want the destination
    to teleport or snap between waypoints immediately without any transition. To achieve
    this, we need to adjust the interpolation mode of the animation curves. Click
    on the **Curves** button at the bottom left corner of the **Animation** window.
    By default, the **Animation** window is in the **DopeSheet** mode, allowing us
    to see key frames easily and reposition them. The Curve mode, however, lets us
    adjust the interpolation between key frames. See *Figure 7.36*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating patrolling NPCs](img/B05118_07_36.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.36: Accessing Animation Curves'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, box-select (click and drag a selection box) across all key frames in the
    graph view to select them all. Then, right-click to display the key frame context
    menu and, from the menu, choose **Right Tangent** | **Constant** to change all
    handles to a flat constant shape, meaning all key frames retain their values over
    the destination object until the next key frame only. See *Figure 7.37*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating patrolling NPCs](img/B05118_07_37.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.37: Changing Key Frame handles for interpolation'
  prefs: []
  type: TYPE_NORMAL
- en: 'When the **Constant** option is chosen from the menu, the curves between key
    frames will look very different in the graph—a straight line joining them. See
    *Figure 7.38*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating patrolling NPCs](img/B05118_07_38.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.38: Constant interpolation'
  prefs: []
  type: TYPE_NORMAL
- en: 'Now test this by pressing play on the toolbar. When you do this, the Destination
    should jump between waypoints as the animation progresses, and the NPC will continually
    move and travel towards the destination. Due to the default speed of the animation,
    the NPC may seem confused or crazed as he is torn between rapidly changing destinations.
    To fix this, select the Destination object in the **Hierarchy** panel and, from
    the **Object Inspector**, double-click on the **Controller** field of the Animator
    component to open the animator graph attached to the object, which controls when
    specific animations should play. See *Figure 7.39*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating patrolling NPCs](img/B05118_07_39.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.39: Accessing the Animator asset'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also show the **Animator** window manually by choosing **Window** |
    **Animator** from the application menu. In the **Animator** window, the default
    node is highlighted in orange. This node (animation) will play when the object
    is first activated in the level, which is normally on level startup. See *Figure
    7.40*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating patrolling NPCs](img/B05118_07_40.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.40: The orange DestPatrol animation is the default in the Animator
    window'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the **DestPatrol** node in the graph and reduce its **Speed** from the
    **Object Inspector**. In my case, I''ve used a value of `0.2`, which works well.
    Once the speed is changed, replay your game to observe the effect. See *Figure
    7.41*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating patrolling NPCs](img/B05118_07_41.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.41: Reducing animation speed'
  prefs: []
  type: TYPE_NORMAL
- en: 'On pressing play, the NPC should now move between destinations at a believable
    speed, moving from one waypoint to the next. If the NPC moves too fast or too
    slow between waypoints, increase or decrease the animation speed further to get
    the result you need. Congratulations! You now have a complete, animated waypoint
    system. See *Figure 7.42*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Creating patrolling NPCs](img/B05118_07_42.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7.42: Waypoint system in action'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Great work! We''ve now completed the first part of the AI project: building
    a terrain, generating a navigation mesh, and creating a basic waypoint system
    in which the character can move between destinations. This is a good beginning
    to simulate intelligence, but there is a lot more code to work on to achieve the
    intended effect. We''ll be focusing on that in the next and final chapter.'
  prefs: []
  type: TYPE_NORMAL
