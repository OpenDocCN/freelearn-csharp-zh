- en: 1 Introduction
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 1 引言
- en: 'Before you begin: Join our book community on Discord'
  id: totrans-1
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 在你开始之前：加入我们的Discord书社区
- en: Give your feedback straight to the author himself and chat to other early readers
    on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under
    EARLY ACCESS SUBSCRIPTION).
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 直接向作者本人提供反馈，并在我们的Discord服务器上与其他早期读者聊天（在“architecting-aspnet-core-apps-3e”频道下找到，位于“EARLY
    ACCESS SUBSCRIPTION”下）。
- en: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '[https://packt.link/EarlyAccess](https://packt.link/EarlyAccess)'
- en: '![Qr code Description automatically generated](img/file0.png)'
  id: totrans-4
  prefs: []
  type: TYPE_IMG
  zh: '![二维码描述自动生成](img/file0.png)'
- en: 'The goal of this book is not to create yet another design pattern book; instead,
    the chapters are organized according to scale and topic, allowing you to start
    small with a solid foundation and build slowly upon it, just like you would build
    a program.Instead of a guide covering a few ways of applying a design pattern,
    we will explore the thought processes behind the systems we are designing from
    a software engineer’s point of view.This is not a magic recipe book; from experience,
    there is no magical recipe when designing software; there are only your logic,
    knowledge, experience, and analytical skills. Let’s define “experience” as *your
    past successes and failures*. And don’t worry, you will fail during your career,
    but don’t get discouraged by it. The faster you fail, the faster you can recover
    and learn, leading to successful products. Many techniques covered in this book
    should help you achieve success. Everyone has failed and made mistakes; you aren’t
    the first and certainly won’t be the last. To paraphrase a well-known saying by
    Roosevelt: *the people that never fail are the ones who never do anything*.At
    a high level:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 这本书的目标不是再创作一本设计模式的书；相反，章节是按照规模和主题组织的，让你可以从一个坚实的基础开始，逐步构建，就像你构建一个程序一样。我们不会提供关于应用设计模式的一些方法的指南，而是从软件工程师的角度探索我们正在设计的系统背后的思维过程。这不是一本魔法食谱书；从经验来看，在软件设计时没有魔法食谱；只有你的逻辑、知识、经验和分析技能。让我们把“经验”定义为*你过去的成功和失败*。而且不用担心，你在职业生涯中会失败，但不要因此气馁。你失败得越快，你恢复和学习得就越快，最终导致成功的产品。这本书中涵盖的许多技术应该能帮助你取得成功。每个人都会失败和犯错误；你不是第一个，也绝对不会是最后一个。用罗斯福的一句名言来概括：*从未失败的人是那些从未做过任何事情的人*。在更高层次上：
- en: This book explores basic patterns, unit testing, architectural principles, and
    some ASP.NET Core mechanisms.
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这本书探讨了基本模式、单元测试、架构原则和一些ASP.NET Core机制。
- en: Then, we move up to the component scale, exploring patterns oriented toward
    small chunks of software and individual units.
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 然后，我们转向组件规模，探索面向小块软件和单个单元的模式。
- en: After that, we move to application-scale patterns and techniques, exploring
    ways to structure an application.
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 之后，我们将转向应用规模的模式和技术，探索如何构建应用程序。
- en: Some subjects covered throughout the book could have a book of their own, so
    after this book, you should have plenty of ideas about where to continue your
    journey into software architecture.
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 书中涵盖的一些主题可能足以写一本书，所以在这本书之后，你应该有很多关于继续你的软件架构之旅的想法。
- en: 'Here are a few pointers about this book that are worth mentioning:'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 下面是关于这本书的一些值得注意的要点：
- en: The chapters are organized to start with small-scale patterns and then progress
    to higher-level ones, making the learning curve easier.
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 章节的组织是从小规模模式开始，然后逐步过渡到更高级的模式，使学习曲线更容易。
- en: Instead of giving you a recipe, the book focuses on the thinking behind things
    and shows the evolution of some techniques to help you understand why the shift
    happened.
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这本书不是提供食谱，而是关注事物背后的思考，并展示一些技术的演变，帮助你理解为什么发生了转变。
- en: Many use cases combine more than one design pattern to illustrate alternate
    usage so you can understand and use the patterns efficiently. This also shows
    that design patterns are not beasts to tame but tools to use, manipulate, and
    bend to your will.
  id: totrans-13
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 许多用例结合了多个设计模式来展示不同的用法，这样你可以有效地理解和使用这些模式。这也表明，设计模式不是需要驯服的野兽，而是可以用来使用、操纵和按照你的意愿弯曲的工具。
- en: As in real life, no textbook solution can solve all our problems; real problems
    are always more complicated than what’s explained in textbooks. In this book,
    I aim to show you how to mix and match patterns to think “architecture” instead
    of giving you step-by-step instructions to reproduce.
  id: totrans-14
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 就像现实生活中一样，没有教科书上的解决方案可以解决我们所有的问题；现实问题总是比教科书上解释的更复杂。在这本书中，我旨在向你展示如何混合和匹配模式来思考“架构”，而不是给你一步一步的指令来复制。
- en: 'The rest of the introduction chapter introduces the concepts we explore throughout
    the book, including refreshers on a few notions. We also touch on .NET, its tooling,
    and some technical requirements.In this chapter, we cover the following topics:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 引言章节的其余部分介绍了本书中探讨的概念，包括对一些观念的复习。我们还涉及了 .NET、其工具和一些技术要求。在本章中，我们涵盖了以下主题：
- en: What is a design pattern?
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: Anti-patterns and code smell.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 反模式与代码异味。
- en: Understanding the web – request/response.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解网络 – 请求/响应。
- en: Getting started with .NET.
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 开始使用 .NET。
- en: What is a design pattern?
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 什么是设计模式？
- en: 'Since you just purchased a book about design patterns, I guess you have some
    idea of what design patterns are, but let’s make sure that we are on the same
    page.**Abstract definition**: A design pattern is a proven technique that we can
    use to solve a specific problem.In this book, we apply different patterns to solve
    various problems and leverage some open-source tools to go further, faster! Abstract
    definitions make people sound smart, but understanding concepts requires more
    practice, and there is no better way to learn than by experimenting with something,
    and design patterns are no different.If that definition does not make sense to
    you yet, don’t worry. You should have enough information by the end of the book
    to correlate the multiple practical examples and explanations with that definition,
    making it crystal clear.I like to compare programming to playing with LEGO® because
    what you have to do is very similar: put small pieces together to create something
    bigger. Therefore, if you lack imagination or skills, possibly because you are
    too young, your castle might not look as good as someone with more experience.
    With that analogy in mind, a design pattern is a plan to assemble a solution that
    fits one or more scenarios, like the tower of a castle. Once you designed a single
    tower, you can build multiple by following the same steps. Design patterns act
    as that tower plan and give you the tools to assemble reliable pieces to improve
    your masterpiece (program).However, instead of snapping LEGO® blocks together,
    you nest code blocks and interweave objects in a virtual environment!Before going
    into more detail, well-thought-out applications of design patterns should improve
    your application designs. That is true whether designing a small component or
    a whole system. However, be careful: throwing patterns into the mix just to use
    them can lead to the opposite result: over-engineering. Instead, aim to write
    the least amount of readable code that solves your issue or automates your process.As
    we have briefly mentioned, design patterns apply to different software engineering
    levels, and in this book, we start small and grow to a cloud-scale! We follow
    a smooth learning curve, starting with simpler patterns and code samples that
    bend good practices to focus on the patterns—finally ending with more advanced
    topics and good practices.Of course, some subjects are overviews more than deep
    dives, like automated testing, because no one can fit it all in a single book.
    Nonetheless, I’ve done my best to give you as much information about architecture-related
    subjects as possible to ensure the proper foundations are in place for you to
    get as much as possible out of the more advanced topics, and I sincerely hope
    you’ll find this book a helpful and enjoyable read.Let’s start with the opposite
    of design patterns because it is essential to identify wrong ways of doing things
    to avoid making those mistakes or to correct them when you see them. Of course,
    knowing the right way to overcome specific problems using design patterns is also
    crucial.'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 由于你刚刚购买了一本关于设计模式的书籍，我猜你对设计模式有一定的了解，但让我们确保我们处于同一页面上。**抽象定义**：设计模式是一种经过验证的技术，我们可以用它来解决特定的问题。在这本书中，我们应用不同的模式来解决各种问题，并利用一些开源工具来更快地前进！抽象定义让人听起来很聪明，但理解概念需要更多的实践，而通过实验来学习是最好的方法，设计模式也不例外。如果那个定义对你来说还不清楚，不要担心。到书的结尾，你应该有足够的信息将多个实际例子和解释与那个定义联系起来，使其变得非常清晰。我喜欢将编程比作玩LEGO®，因为你要做的事情非常相似：把小部件放在一起，创造出更大的东西。因此，如果你缺乏想象力或技能，可能是因为你还太小，你的城堡可能看起来不如有更多经验的人那么好。带着这个类比，设计模式是一个组装解决方案的计划，该方案适合一个或多个场景，就像城堡的塔楼一样。一旦你设计了一个单独的塔楼，你就可以通过遵循相同的步骤来建造多个。设计模式充当那个塔楼计划，并为你提供组装可靠部件的工具，以改善你的杰作（程序）。然而，你并不是简单地拼接LEGO®积木，而是在虚拟环境中嵌套代码块和交织对象！在更详细地介绍之前，精心设计的应用设计模式应该会改善你的应用程序设计。这无论是在设计一个小组件还是整个系统时都是正确的。然而，请注意：只是为了使用而将模式混合在一起可能会导致相反的结果：过度设计。相反，目标是编写尽可能少的可读代码来解决你的问题或自动化你的流程。正如我们简要提到的，设计模式适用于不同的软件工程级别，在这本书中，我们从小的开始，逐渐扩展到云规模！我们遵循一个平稳的学习曲线，从更简单的模式和代码示例开始，这些示例将良好的实践弯曲以关注模式——最后以更高级的主题和良好的实践结束。当然，有些主题是概述而不是深入探讨，比如自动化测试，因为没有人能在一本书中涵盖所有内容。尽管如此，我已经尽我所能提供尽可能多的关于架构相关主题的信息，以确保为你打下坚实的基础，以便你能从更高级的主题中获得尽可能多的东西，并且我真诚地希望你会觉得这本书是一本有帮助且有趣的读物。让我们从设计模式的反面开始，因为识别做事的错误方式对于避免犯这些错误或在你看到它们时纠正它们是至关重要的。当然，知道如何使用设计模式克服特定问题也是至关重要的。
- en: Anti-patterns and code smells
  id: totrans-22
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 反模式和代码异味
- en: Anti-patterns and code smells are bad architectural practices or tips about
    possible bad design. Learning about best practices is as important as learning
    about bad ones, which is where we start. The book highlights multiple anti-patterns
    and code smells to help you get started. Next, we briefly explore the first few.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 反模式和代码异味是糟糕的架构实践或关于可能不良设计的提示。了解最佳实践与了解不良实践同样重要，这正是我们开始的地方。本书突出了多个反模式和代码异味，以帮助您入门。接下来，我们将简要探讨前几个。
- en: Anti-patterns
  id: totrans-24
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 反模式
- en: 'An **anti-pattern** is the opposite of a design pattern: it is a proven flawed
    technique that will most likely cause you trouble and cost you time and money
    (and probably give you headaches).An anti-pattern is a pattern that seems a good
    idea and seems to be the solution you were looking for, but it causes more harm
    than good. Some anti-patterns started as legitimate design patterns and were labelled
    anti-patterns later. Sometimes, it is a matter of opinion, and sometimes the classification
    can be influenced by the programming language or technologies.Let’s look at an
    example next. We will explore some other anti-patterns throughout the book.'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: '**反模式**是与设计模式相反的概念：它是一种已被证明有缺陷的技术，很可能会给您带来麻烦，浪费您的时间和金钱（可能还会让您头疼）。反模式是一种看似不错且似乎就是您所寻找的解决方案的模式，但它带来的危害大于好处。一些反模式最初是合法的设计模式，后来被标记为反模式。有时，这取决于个人观点，有时分类可能受到编程语言或技术的影響。接下来，让我们看一个例子。本书中还将探讨其他一些反模式。'
- en: Anti-pattern – God Class
  id: totrans-26
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 反模式 – 上帝类
- en: 'A **God class** is a class that handles too many things. Typically, this class
    serves as a central entity which many other classes inherit or use within the
    application it is the class that knows and manages everything in the system; it
    is *the* class. On the other hand, it is also the class that nobody wants to update,
    which breaks the application every time somebody touches it: **it is an evil class**!The
    best way to fix this is to segregate responsibilities and allocate them to multiple
    classes rather than concentrating them in a single class. We look at how to split
    responsibilities throughout the book, which helps create more robust software.If
    you have a personal project with a *God class* at its core, start by reading the
    book and then try to apply the principles and patterns you learn to divide that
    class into multiple smaller classes that interact together. Try to organize those
    new classes into cohesive units, modules, or assemblies.To help fix God classes,
    we dive into architectural principles in *Chapter 3*, *Architectural Principles*,
    opening the way to concepts such as responsibility segregation.'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: '**上帝类**是一个处理太多事物的类。通常，这个类充当一个中心实体，许多其他类在应用程序中继承或使用它；它是系统中知道和管理一切的那个类；它是**那个**类。另一方面，它也是没有人愿意更新的类，每次有人触摸它时都会破坏应用程序：**它是一个邪恶的类**！修复这个问题的最佳方法是分离责任并将它们分配给多个类，而不是将它们集中在单个类中。本书将探讨如何在全书中划分责任，这有助于创建更健壮的软件。如果您有一个以**上帝类**为核心的个人项目，请先阅读本书，然后尝试将您学到的原则和模式应用到将那个类划分为多个较小的类，这些类可以相互交互。尝试将这些新类组织成统一的单元、模块或组件。为了帮助修复上帝类，我们在**第3章**“架构原则”中深入探讨了架构原则，为责任分离等概念打开了道路。'
- en: Code smells
  id: totrans-28
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 代码异味
- en: A **code smell** is an indicator of a possible problem. It points to areas of
    your design that could benefit from a redesign. By “code smell,” we mean “code
    that stinks” or “code that does not smell right.”It is important to note that
    a code smell only indicates the possibility of a problem; it does not mean a problem
    exists. Code smells are usually good indicators, so it is worth analyzing your
    software’s “smelly” parts.An excellent example is when a method requires many
    comments to explain its logic. That often means that the code could be split into
    smaller methods with proper names, leading to more readable code and allowing
    you to get rid of those pesky comments.Another note about comments is that they
    don’t evolve, so what often happens is that the code described by a comment changes,
    but the comment remains the same. That leaves a false or obsolete description
    of a block of code that can lead a developer astray.The same is also true with
    method names. Sometimes, the method’s name and body tell a different story, leading
    to the same issues. Nevertheless, this happens less often than orphan or obsolete
    comments since programmers tend to read and write code better than spoken language
    comments. Nonetheless, keep that in mind when reading, writing, or reviewing code.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '**代码异味**是一个可能存在问题的指示器。它指向你的设计中可能需要重新设计的区域。当我们说“代码异味”时，我们指的是“有臭味的代码”或“看起来不对劲的代码”。需要注意的是，代码异味仅表明可能存在问题；并不意味着问题确实存在。代码异味通常是很好的指示器，因此分析你软件的“有异味”部分是值得的。一个很好的例子是，当一个方法需要许多注释来解释其逻辑时。这通常意味着代码可以被拆分成具有适当名称的小方法，从而产生更易读的代码，并允许你摆脱那些讨厌的注释。关于注释的另一个注意事项是，它们不会演变，所以经常发生的情况是，注释所描述的代码发生了变化，但注释保持不变。这会导致一个错误的或过时的代码块描述，可能会误导开发者。同样，这也适用于方法名称。有时，方法的名字和主体讲述的是不同的故事，导致相同的问题。尽管如此，这种情况比孤儿或过时的注释发生的频率要低，因为程序员在阅读和编写代码方面通常比口头注释做得更好。然而，在阅读、编写或审查代码时，请记住这一点。'
- en: Code smell – Control Freak
  id: totrans-30
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码异味 – 控制狂
- en: An excellent example of a code smell is using the `new` keyword. This indicates
    a hardcoded dependency where the creator controls the new object and its lifetime.
    This is also known as the **Control Freak anti-pattern**, but I prefer to box
    it as a code smell instead of an anti-pattern since the `new` keyword is not intrinsically
    wrong.At this point, you may be wondering how it is possible not to use the `new`
    keyword in object-oriented programming, but rest assured, we will cover that and
    expand on the control freak code smell in *Chapter 7*, *Deep Dive into Dependency
    Injection*.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 代码异味的绝佳例子是使用`new`关键字。这表明存在硬编码的依赖关系，其中创建者控制新对象及其生命周期。这也被称为**控制狂反模式**，但我更喜欢将其视为代码异味而不是反模式，因为`new`关键字本身并不是错误的。在这个时候，你可能想知道在面向对象编程中如何不使用`new`关键字，但请放心，我们将在第7章“深入依赖注入”中介绍这一点，并扩展控制狂代码异味。
- en: Code smell – Long Methods
  id: totrans-32
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 代码异味 – 长方法
- en: 'The **long methods** code smell is when a method extends to more than 10 to
    15 lines of code. That is a good indicator that you should think about that method
    differently. Having comments that separate multiple code blocks is a good indicator
    of a method that may be too long.Here are a few examples of what the case might
    be:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: '**长方法**代码异味是指方法扩展到10到15行代码以上。这是一个很好的迹象，表明你应该以不同的方式考虑该方法。具有分隔多个代码块的注释是方法可能太长的良好指标。以下是一些可能的情况示例：'
- en: The method contains complex logic intertwined in multiple conditional statements.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法包含在多个条件语句中交织的复杂逻辑。
- en: The method contains a big `switch` block.
  id: totrans-35
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法包含一个大的`switch`块。
- en: The method does too many things.
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法做了太多事情。
- en: The method contains duplications of code.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 该方法包含代码重复。
- en: 'To fix this, you could do the following:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，你可以做以下几件事：
- en: Extract one or more private methods.
  id: totrans-39
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提取一个或多个私有方法。
- en: Extract some code to new classes.
  id: totrans-40
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将一些代码提取到新的类中。
- en: Reuse the code from external classes.
  id: totrans-41
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 重复使用外部类中的代码。
- en: If you have a lot of conditional statements or a huge `switch` block, you could
    leverage a design pattern such as the Chain of Responsibility, or CQRS, which
    you will learn about in *Chapter 10*, *Behavioral Patterns*, and *Chapter 14*,
    *Mediator and CQRS Design Patterns*.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果你有很多条件语句或巨大的`switch`块，你可以利用设计模式，如责任链模式或CQRS，你将在第10章“行为模式”和第14章“中介和CQRS设计模式”中了解到这些。
- en: 'Usually, each problem has one or more solutions; you need to spot the problem
    and then find, choose, and implement one of the solutions. Let’s be clear: a method
    containing 16 lines does not necessarily need refactoring; it could be OK. Remember
    that a code smell indicates that there *might* be a problem, not that there necessarily
    *is* one—apply common sense.'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，每个问题都有一个或多个解决方案；你需要找出问题，然后找到、选择并实现其中一个解决方案。让我们明确一点：包含16行的方法不一定需要重构；它可能是可以接受的。记住，代码异味表明*可能*存在问题，并不一定意味着必然存在问题——运用常识。
- en: Understanding the web – request/response
  id: totrans-44
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 理解Web – 请求/响应
- en: 'Before going any further, it is imperative to understand the basic concept
    of the web. The idea behind HTTP 1.X is that a client sends an HTTP request to
    a server, and then the server responds to that client. That can sound trivial
    if you have web development experience. However, it is one of the most important
    web programming concepts, irrespective of whether you are building web APIs, websites,
    or complex cloud applications.Let’s reduce an HTTP request lifetime to the following:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在继续之前，理解Web的基本概念是至关重要的。HTTP 1.X背后的想法是客户端向服务器发送HTTP请求，然后服务器响应该客户端。如果你有Web开发经验，这听起来可能很平凡。然而，无论你是构建Web
    API、网站还是复杂的云应用，这都是最重要的Web编程概念之一。让我们将HTTP请求的生命周期简化为以下：
- en: The communication starts.
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通信开始。
- en: The client sends a request to the server.
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 客户端向服务器发送请求。
- en: The server receives the request.
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器接收请求。
- en: The server does something with the request, like executing code/logic.
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器对请求进行一些操作，比如执行代码/逻辑。
- en: The server responds to the client.
  id: totrans-50
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 服务器响应客户端。
- en: The communication ends.
  id: totrans-51
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通信结束。
- en: 'After that cycle, the server is no longer aware of the client. Moreover, if
    the client sends another request, the server is unaware that it responded to a
    request earlier for that same client because **HTTP is stateless**.There are mechanisms
    for creating a sense of persistence between requests for the server to be “aware”
    of its clients. The most well-known of these is cookies.If we dig deeper, an HTTP
    request comprises a header and an optional body. Then, requests are sent using
    a specific method. The most common HTTP methods are `GET` and `POST`. On top of
    those, extensively used by web APIs, we can add `PUT`, `DELETE`, and `PATCH` to
    that list.Although not every HTTP method accepts a body, can respond with a body,
    or should be idempotent, here is a quick reference table:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在那个周期之后，服务器不再知道客户端的存在。此外，如果客户端发送另一个请求，服务器也不会意识到它之前已经对同一个客户端的请求做出了响应，因为**HTTP是无状态的**。有机制可以在服务器之间创建请求的持久感，使其“知道”其客户端。其中最著名的是cookies。如果我们深入挖掘，一个HTTP请求由一个头部和一个可选的正文组成。然后，使用特定的方法发送请求。最常见的HTTP方法有`GET`和`POST`。在此基础上，广泛用于Web
    API的，我们还可以添加`PUT`、`DELETE`和`PATCH`到这个列表中。尽管不是每个HTTP方法都接受正文，可以响应正文，或者应该是幂等的，这里有一个快速参考表：
- en: '| **Method** | **Request has body** | **Response has body** | **Idempotent**
    |'
  id: totrans-53
  prefs: []
  type: TYPE_TB
  zh: '| **方法** | **请求有正文** | **响应有正文** | **幂等** |'
- en: '| `GET` | No* | Yes | Yes |'
  id: totrans-54
  prefs: []
  type: TYPE_TB
  zh: '| `GET` | 否* | 是 | 是 |'
- en: '| `POST` | Yes | Yes | No |'
  id: totrans-55
  prefs: []
  type: TYPE_TB
  zh: '| `POST` | 是 | 是 | 否 |'
- en: '| `PUT` | Yes | No | Yes |'
  id: totrans-56
  prefs: []
  type: TYPE_TB
  zh: '| `PUT` | 是 | 否 | 是 |'
- en: '| `PATCH` | Yes | Yes | No |'
  id: totrans-57
  prefs: []
  type: TYPE_TB
  zh: '| `PATCH` | 是 | 是 | 否 |'
- en: '| `DELETE` | May | May | Yes |'
  id: totrans-58
  prefs: []
  type: TYPE_TB
  zh: '| `DELETE` | 可能 | 可能 | 是 |'
- en: '* Sending a body with a `GET` request is not forbidden by the HTTP specifications,
    but the semantics of such a request are not defined either. It is best to avoid
    sending `GET` requests with a body.'
  id: totrans-59
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '* 使用`GET`请求发送正文并不是HTTP规范所禁止的，但这种请求的语义也没有定义。最好避免发送带有正文的`GET`请求。'
- en: 'An **idempotent** request is a request that always yields the same result,
    whether it is sent once or multiple times. For example, sending the same `POST`
    request multiple times should create multiple similar entities, while sending
    the same `DELETE` request multiple times should delete a single entity. The status
    code of an idempotent request may vary, but the server state should remain the
    same. We explore those concepts in more depth in *Chapter 4*, *Model-View-Controller*.Here
    is an example of a `GET` request:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 一个**幂等**请求是一个无论发送一次还是多次都会产生相同结果的请求。例如，发送相同的`POST`请求多次应该创建多个类似的实体，而发送相同的`DELETE`请求多次应该删除单个实体。幂等请求的状态码可能不同，但服务器状态应该保持不变。我们在*第4章*，*模型-视图-控制器*中更深入地探讨了这些概念。以下是一个`GET`请求的示例：
- en: '[PRE0]'
  id: totrans-61
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The HTTP header comprises a list of key/value pairs representing metadata that
    a client wants to send to the server. In this case, I queried my blog using the
    `GET` method and Google Chrome attached some additional information to the request.
    I replaced the `Cookie` header’s value with `...` because it can be pretty large
    and that information is irrelevant to this sample. Nonetheless, cookies are passed
    back and forth like any other HTTP header.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: HTTP头部包含一个键/值对的列表，表示客户端想要发送给服务器的元数据。在这种情况下，我使用`GET`方法查询我的博客，Google Chrome附加了一些额外的信息到请求中。我将`Cookie`头部的值替换为`...`，因为它可能相当大，而且这些信息与这个示例无关。尽管如此，cookie就像任何其他HTTP头部一样被来回传递。
- en: '**Important note about cookies**'
  id: totrans-63
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**关于cookie的重要说明**'
- en: ''
  id: totrans-64
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: The client sends cookies, and the server returns them for every request-response
    cycle. This could kill your bandwidth or slow down your application if you pass
    too much information back and forth (cookies or otherwise). One good example would
    be a serialized identity cookie that is very large.
  id: totrans-65
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 客户端发送cookie，服务器在每次请求-响应周期中返回它们。如果您在来回传递太多信息（cookie或其他）时，这可能会杀死您的带宽或减慢您的应用程序。一个很好的例子是序列化的身份cookie非常大。
- en: ''
  id: totrans-66
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Another example, unrelated to cookies but that created such a back-and-forth,
    was the good old Web Forms `ViewState`. This was a hidden field sent with every
    request. That field could become very large when left unchecked.
  id: totrans-67
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 另一个例子，与cookie无关，但造成了这样的来回，是那个古老的Web Forms `ViewState`。这是一个与每个请求一起发送的隐藏字段。如果未经检查，该字段可能会变得非常大。
- en: ''
  id: totrans-68
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: Nowadays, with high-speed internet, it is easy to forget about those issues,
    but they can significantly impact the user experience of someone on a slow network.
  id: totrans-69
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 现在，随着高速互联网的出现，很容易忘记这些问题，但它们可以显著影响慢速网络上的用户体验。
- en: 'When the server decides to respond to the request, it returns a header and
    an optional body, following the same principles as the request. The first line
    indicates the request’s status: whether it was successful. In our case, the status
    code was `200`, which indicates success. Each server can add more or less information
    to its response. You can also customize the response with code.Here is the response
    to the previous request:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 当服务器决定响应请求时，它会返回一个头部和一个可选的正文，遵循与请求相同的原理。第一行指示请求的状态：是否成功。在我们的例子中，状态码是`200`，表示成功。每个服务器都可以向其响应添加更多或更少的信息。您也可以使用代码自定义响应。以下是之前请求的响应：
- en: '[PRE1]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: Now that the browser has received the server’s response, it renders the HTML
    webpage. Then, for each resource, it sends another HTTP call to its URI and loads
    it. A resource is an external asset, such as an image, a JavaScript file, a CSS
    file, or a font.After the response, the server is no longer aware of the client;
    the communication has ended. It is essential to understand that to create a pseudo-state
    between each request, we need to use an external mechanism. That mechanism could
    be the *session-state* leveraging cookies, simply using cookies, or some other
    ASP.NET Core mechanisms, or we could create a stateless application. I recommend
    going stateless whenever possible. We write primarily stateless applications in
    the book.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 现在浏览器已经收到服务器的响应，它会渲染HTML网页。然后，对于每个资源，它会向其URI发送另一个HTTP请求并加载它。资源是一个外部资产，例如图片、JavaScript文件、CSS文件或字体。在响应之后，服务器就不再知道客户端了；通信已经结束。理解这一点很重要，为了在每次请求之间创建一个伪状态，我们需要使用外部机制。这种机制可以是利用cookie的*会话状态*，简单地使用cookie，或者某些其他ASP.NET
    Core机制，或者我们可以创建一个无状态应用程序。我建议尽可能使用无状态应用程序。我们在书中主要编写无状态应用程序。
- en: '**Note**'
  id: totrans-73
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-74
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: If you want to learn more about session and state management, I left a link
    in the *Further reading* section at the end of the chapter.
  id: totrans-75
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 如果你想了解更多关于会话和状态管理的信息，我在章节末尾的*进一步阅读*部分留下了一个链接。
- en: As you can imagine, the backbone of the internet is its networking stack. The
    **Hypertext Transfer Protocol** (**HTTP**) is the highest layer of that stack
    (layer 7). HTTP is an application layer built on the **Transmission Control Protocol**
    (**TCP**). TCP (layer 4) is the transport layer, which defines how data is moved
    over the network (for instance, the transmission of data, the amount of transmitted
    data, and error checking). TCP uses the **Internet Protocol** (**IP**) layer to
    reach the computer it tries to talk to. IP (layer 3) represents the network layer,
    which handles packet IP addressing.A packet is a chunk of data that is transmitted
    over the wire. We could send a large file directly from a source to a destination
    machine, but that is not practical, so the network stack breaks down large items
    into smaller packets. For example, the source machine breaks a file into multiple
    packets, sends them to the target machine, and then the target reassembles them
    back into the source file. This process allows numerous senders to use the same
    wire instead of waiting for the first transmission to be done. If a packet gets
    lost in transit, the source machine can also send only that packet back to the
    target machine.Rest assured, you don’t need to understand every detail behind
    networking to program web applications, but it is always good to know that HTTP
    uses TCP/IP and chunks big payloads into smaller packets. Moreover, HTTP/1 limits
    the number of parallel requests a browser can open simultaneously. This knowledge
    can help you optimize your apps. For example, a high number of assets to load,
    their size, and the order in which they are sent to the browser can increase the
    page load time, the perceived page load time, or the paint time.To conclude this
    subject and not dig too deep into networking, HTTP/1 is older but foundational.
    HTTP/2 is more efficient and supports streaming multiple assets using the same
    TCP connection. It also allows the server to send assets to the client before
    it requests the resources, called a server push.If you find HTTP interesting,
    HTTP/2 is an excellent place to start digging deeper, as well as the HTTP/3 proposed
    standard that uses the QUIC transport protocol instead of HTTP (RFC 9114). ASP.NET
    Core 7.0+ supports HTTP/3, which is enabled by default in ASP.NET Core 8.0.Next,
    let’s quickly explore .NET.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所想，互联网的骨架是其网络栈。**超文本传输协议**（**HTTP**）是该栈的最高层（第7层）。HTTP 是建立在**传输控制协议**（**TCP**）之上的应用层。TCP（第4层）是传输层，它定义了数据如何在网络上传输（例如，数据的传输、传输的数据量以及错误检查）。TCP
    使用 **互联网协议**（**IP**）层来到达它试图与之通信的计算机。IP（第3层）代表网络层，它处理数据包的IP寻址。数据包是传输线上传输的数据块。我们可以直接从源机器向目标机器发送大文件，但这并不实用，因此网络栈将大项目分解成更小的数据包。例如，源机器将文件分解成多个数据包，将它们发送到目标机器，然后目标机器将它们重新组装成源文件。这个过程允许多个发送者使用相同的线路，而不是等待第一次传输完成。如果一个数据包在传输过程中丢失，源机器也可以只将那个数据包发送回目标机器。放心，你不需要理解网络背后的每一个细节来编写网络应用程序，但了解HTTP使用TCP/IP并将大负载分成小数据包总是好的。此外，HTTP/1限制了浏览器可以同时打开的并行请求数量。这些知识可以帮助你优化你的应用程序。例如，要加载的资产数量、它们的大小以及它们发送到浏览器的顺序可能会增加页面加载时间、感知的页面加载时间或绘制时间。为了总结这个主题，而不深入探讨网络，HTTP/1虽然较旧，但却是基础性的。HTTP/2更高效，并支持使用相同的TCP连接流式传输多个资产。它还允许服务器在客户端请求资源之前向客户端发送资产，这被称为服务器推送。如果你对HTTP感兴趣，HTTP/2是一个很好的开始深入研究的地方，以及使用QUIC传输协议而不是HTTP的HTTP/3提议标准（RFC
    9114）。ASP.NET Core 7.0+支持HTTP/3，这在ASP.NET Core 8.0中默认启用。接下来，让我们快速探索.NET。
- en: Getting started with .NET
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开始使用 .NET
- en: 'A bit of history: .NET Framework 1.0 was first released in 2002\. .NET is a
    managed framework that compiles your code into an **Intermediate Language** (**IL**)
    named **Microsoft Intermediate Language** (**MSIL**). That IL code is then compiled
    into native code and executed by the **Common Language Runtime** (**CLR**). The
    CLR is now known simply as the **.NET runtime**. After releasing several versions
    of .NET Framework, Microsoft never delivered on the promise of an interoperable
    stack. Moreover, many flaws were built into the core of .NET Framework, tying
    it to Windows.Mono, an open-source project, was developed by the community to
    enable .NET code to run on non-Windows OSes. Mono was used and supported by Xamarin,
    acquired by Microsoft in 2016\. Mono enabled .NET code to run on other OSes like
    Android and iOS. Later, Microsoft started to develop an official cross-platform
    .NET SDK and runtime they named .NET Core.The .NET team did a magnificent job
    building ASP.NET Core from the ground up, cutting out compatibility with the older
    .NET Framework versions. That brought its share of problems at first, but .NET
    Standard alleviated the interoperability issues between the old .NET and the new
    .NET.After years of improvements and two major versions in parallel (Core and
    Framework), Microsoft reunified most .NET technologies into .NET 5+ and the promise
    of a shared **Base Class Library** (**BCL**). With .NET 5, .NET Core simply became
    .NET while ASP.NET Core remained ASP.NET Core. There is no .NET “Core” 4, to avoid
    any potential confusion with .NET Framework 4.X.New major versions of .NET release
    every year now. Even-number releases are **Long-Term Support** (**LTS**) releases
    with free support for 3 years, and odd-number releases (Current) have free support
    for only 18 months.The good thing behind this book is that the architectural principles
    and design patterns covered should remain relevant in the future and are not tightly
    coupled with the versions of .NET you are using. Minor changes to the code samples
    should be enough to migrate your knowledge and code to new versions.Next, let’s
    cover some key information about the .NET ecosystem.'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 一点历史：.NET Framework 1.0 首次于 2002 年发布。.NET 是一个托管框架，将您的代码编译成名为 **中间语言**（**IL**）的
    **Microsoft 中间语言**（**MSIL**）。然后，该 IL 代码被编译成本地代码，并由 **公共语言运行时**（**CLR**）执行。现在，CLR
    简单地被称为 **.NET 运行时**。在发布了几个版本的 .NET Framework 之后，微软从未兑现过可互操作堆栈的承诺。此外，许多缺陷被构建到 .NET
    Framework 的核心中，使其与 Windows 紧密绑定。Mono，一个开源项目，由社区开发，以使 .NET 代码能够在非 Windows 操作系统上运行。Mono
    被用于并由微软在 2016 年收购的 Xamarin 支持。Mono 使 .NET 代码能够在 Android 和 iOS 等其他操作系统上运行。后来，微软开始开发官方的跨平台
    .NET SDK 和运行时，它们将其命名为 .NET Core。.NET 团队从零开始构建了 ASP.NET Core，完全切断了与旧版 .NET Framework
    版本的兼容性。这最初带来了一些问题，但 .NET Standard 缓解了旧 .NET 和新 .NET 之间的互操作性难题。经过多年的改进和两个并行的主要版本（Core
    和 Framework），微软将大多数 .NET 技术统一到了 .NET 5+，并实现了共享的 **基类库**（**BCL**）的承诺。随着 .NET 5
    的发布，.NET Core 简单地成为了 .NET，而 ASP.NET Core 仍然是 ASP.NET Core。没有 .NET “Core” 4，以避免与
    .NET Framework 4.X 产生任何潜在的混淆。现在，.NET 每年都会发布新的主要版本。偶数版本是 **长期支持**（**LTS**）版本，提供
    3 年的免费支持，而奇数版本（当前版本）仅提供 18 个月的免费支持。这本书的亮点在于，涵盖的架构原则和设计模式在未来应该仍然相关，并且与您使用的 .NET
    版本没有紧密耦合。代码示例的微小更改应该足以将您的知识和代码迁移到新版本。接下来，我们将介绍一些关于 .NET 生态系统的关键信息。
- en: .NET SDK versus runtime
  id: totrans-79
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET SDK 与运行时对比
- en: You can install different binaries grouped under SDKs and runtimes. The SDK
    allows you to build and run .NET programs, while the runtime only allows you to
    run .NET programs.As a developer, you want to install the SDK on your deployment
    environment. On the server, you want to install the runtime. The runtime is lighter,
    while the SDK contains more tools, including the runtime.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以安装属于 SDK 和运行时分组的不同二进制文件。SDK 允许您构建和运行 .NET 程序，而运行时仅允许您运行 .NET 程序。作为一名开发者，您希望在您的部署环境中安装
    SDK。在服务器上，您希望安装运行时。运行时更轻量，而 SDK 包含更多工具，包括运行时。
- en: .NET 5+ versus .NET Standard
  id: totrans-81
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: .NET 5+ 与 .NET Standard 对比
- en: 'When building .NET projects, there are multiple types of projects, but basically,
    we can separate them into two categories:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 当构建 .NET 项目时，有多种项目类型，但基本上，我们可以将它们分为两大类：
- en: Applications
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 应用程序
- en: Libraries
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 库
- en: Applications target a version of .NET, such as `net5.0` and `net6.0`. Examples
    of that would be an ASP.NET application or a console application.Libraries are
    bundles of code compiled together, often distributed as a NuGet package. .NET
    Standard class library projects allow sharing code between .NET 5+, and .NET Framework
    projects. .NET Standard came into play to bridge the compatibility gap between
    .NET Core and .NET Framework, which eased the transition. Things were not easy
    when .NET Core 1.0 first came out.With .NET 5 unifying all the platforms and becoming
    the future of the unified .NET ecosystem, .NET Standard is no longer needed. Moreover,
    app and library authors should target the base **Target Framework Moniker** (**TFM**),
    for example, `net8.0`. You can also target `netstandard2.0` or `netstandard2.1`
    when needed, for example, to share code with .NET Framework. Microsoft also introduced
    OS-specific TFMs with .NET 5+, allowing code to use OS-specific APIs like `net8.0-android`
    and `net8.0-tvos`. You can also target multiple TFMs when needed.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 应用程序针对.NET的一个版本，例如`net5.0`和`net6.0`。例如，ASP.NET应用程序或控制台应用程序就是这样的例子。库是一组编译在一起的代码包，通常以NuGet包的形式分发。.NET
    Standard类库项目允许在.NET 5+和.NET Framework项目之间共享代码。.NET Standard的出现是为了弥合.NET Core和.NET
    Framework之间的兼容性差距，这简化了过渡过程。当.NET Core 1.0首次发布时，事情并不容易。随着.NET 5统一所有平台并成为统一.NET生态系统的未来，.NET
    Standard就不再需要了。此外，应用程序和库的作者应该针对基础**目标框架标识符**（**TFM**），例如，`net8.0`。在需要时，您也可以针对`netstandard2.0`或`netstandard2.1`，例如，与.NET
    Framework共享代码。Microsoft还引入了与.NET 5+相关的特定于操作系统的TFM，允许代码使用特定于操作系统的API，如`net8.0-android`和`net8.0-tvos`。在需要时，您也可以针对多个TFM。
- en: '**Note**'
  id: totrans-86
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '**注意**'
- en: ''
  id: totrans-87
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: I’m sure we will see .NET Standard libraries stick around for a while. All projects
    will not just migrate from .NET Framework to .NET 5+ magically, and people will
    want to continue sharing code between the two.
  id: totrans-88
  prefs:
  - PREF_BQ
  - PREF_BQ
  type: TYPE_NORMAL
  zh: 我相信我们还将看到.NET Standard库存在一段时间。并非所有项目都能神奇地从.NET Framework迁移到.NET 5+，人们将希望继续在这两个之间共享代码。
- en: The next versions of .NET are built over .NET 5+, while .NET Framework 4.X will
    stay where it is today, receiving only security patches and minor updates. For
    example, .NET 8 is built over .NET 7, iterating over .NET 6 and 5.Next, let’s
    look at some tools and code editors.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: .NET的下一个版本是在.NET 5+之上构建的，而.NET Framework 4.X将保持现状，只接收安全补丁和较小更新。例如，.NET 8是在.NET
    7之上构建的，迭代.NET 6和5。接下来，让我们看看一些工具和代码编辑器。
- en: Visual Studio Code versus Visual Studio versus the command-line interface
  id: totrans-90
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Visual Studio Code与Visual Studio以及命令行界面
- en: 'How can one of these projects be created? .NET Core comes with the `dotnet`
    **command-line interface** (**CLI**), which exposes multiple commands, including
    `new`. Running the `dotnet new` command in a terminal generates a new project.To
    create an empty class library, we can run the following commands:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 如何创建这样的项目？.NET Core附带`dotnet`**命令行界面**（**CLI**），它公开了多个命令，包括`new`。在终端中运行`dotnet
    new`命令将生成一个新的项目。要创建一个空的类库，我们可以运行以下命令：
- en: '[PRE2]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: That would generate an empty class library in the newly created `MyProject`
    directory.The `-h` option helps discover available commands and their options.
    For example, you can use `dotnet -h` to find the available SDK commands or `dotnet
    new -h` to find out about options and available templates.It is fantastic that
    .NET now has the `dotnet` CLI. The CLI enables us to automate our workflows in
    **continuous integration** (**CI**) pipelines while developing locally or through
    any other process.The CLI also makes it easier to write documentation that anyone
    can follow; writing a few commands in a terminal is way easier and faster than
    installing programs like Visual Studio and emulators.**Visual Studio Code** is
    my favourite text editor. I don’t use it much for .NET coding, but I still do
    to reorganize projects, when it’s CLI time, or for any other task that is easier
    to complete using a text editor, such as writing documentation using Markdown,
    writing JavaScript or TypeScript, or managing JSON, YAML, or XML files. To create
    a C# project, a Visual Studio solution, or to add a NuGet package using Visual
    Studio Code, open a terminal and use the CLI.As for **Visual Studio**, my favourite
    C# IDE, it uses the CLI under the hood to create the same projects, making it
    consistent between tools and just adding a user interface on top of the `dotnet
    new` CLI command.You can create and install additional `dotnet` `new` project
    templates in the CLI or even create global tools. You can also use another code
    editor or IDE if you prefer. Those topics are beyond the scope of this book.
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在新创建的 `MyProject` 目录中生成一个空白的类库。`-h` 选项有助于发现可用的命令及其选项。例如，你可以使用 `dotnet -h`
    来查找可用的 SDK 命令，或者使用 `dotnet new -h` 来了解选项和可用的模板。.NET 现在拥有 `dotnet` CLI 真是太棒了。CLI
    允许我们在本地开发或通过任何其他过程时，在持续集成（**CI**）管道中自动化我们的工作流程。CLI 还使得编写任何人都可以遵循的文档变得更加容易；在终端中输入几个命令要比安装像
    Visual Studio 和模拟器这样的程序要容易和快得多。**Visual Studio Code** 是我最喜欢的文本编辑器。我并不经常用它来编写 .NET
    代码，但我在需要重新组织项目时，或者在 CLI 时间，或者完成任何其他更适合使用文本编辑器完成的任务时，比如使用 Markdown 编写文档、编写 JavaScript
    或 TypeScript，或者管理 JSON、YAML 或 XML 文件时，还是会使用它。要创建 C# 项目、Visual Studio 解决方案或使用 Visual
    Studio Code 添加 NuGet 包，请打开终端并使用 CLI。至于 **Visual Studio**，我最喜欢的 C# 集成开发环境，它使用 CLI
    在底层创建相同的项目，使得工具之间保持一致，只是在 `dotnet new` CLI 命令之上添加了用户界面。你可以在 CLI 中创建和安装额外的 `dotnet`
    `new` 项目模板，甚至创建全局工具。你也可以使用你更喜欢的其他代码编辑器或 IDE。这些主题超出了本书的范围。
- en: An overview of project templates
  id: totrans-94
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 项目模板概述
- en: 'Here is an example of the templates that are installed (`dotnet` `new --list`):'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是已安装的模板示例（`dotnet` `new --list`）：
- en: '![Figure 1.1: Project templates](img/file1.png)'
  id: totrans-96
  prefs: []
  type: TYPE_IMG
  zh: '![图 1.1：项目模板](img/file1.png)'
- en: 'Figure 1.1: Project templates'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 图 1.1：项目模板
- en: 'A study of all the templates is beyond the scope of this book, but I’d like
    to visit the few that are worth mentioning, some of which we will use later:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 对所有模板的研究超出了本书的范围，但我想要简要介绍一些值得注意的模板，其中一些我们将在后面使用：
- en: '`dotnet new console` creates a console application'
  id: totrans-99
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet new console` 创建一个控制台应用程序'
- en: '`dotnet new classlib` creates a class library'
  id: totrans-100
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet new classlib` 创建一个类库'
- en: '`dotnet new xunit` creates an xUnit test project'
  id: totrans-101
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet new xunit` 创建一个 xUnit 测试项目'
- en: '`dotnet new web` creates an empty web project'
  id: totrans-102
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet new web` 创建一个空白的 Web 项目'
- en: '`dotnet new mvc` scaffolds an MVC application'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet new mvc` 搭建一个 MVC 应用程序'
- en: '`dotnet new webapi` scaffolds a web API application'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet new webapi` 搭建一个 Web API 应用程序'
- en: Running and building your program
  id: totrans-105
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 运行和构建你的程序
- en: 'If you are using Visual Studio, you can always hit the play button, or *F5*,
    and run your app. If you are using the CLI, you can use one of the following commands
    (and more). Each of them also offers different options to control their behaviour.
    Add the `-h` flag with any command to get help on that command, such as `dotnet
    build -h`:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用的是 Visual Studio，你可以始终点击播放按钮，或 *F5*，来运行你的应用程序。如果你使用的是 CLI，你可以使用以下命令（以及更多）。每个命令都提供了不同的选项来控制其行为。在任意命令中添加
    `-h` 标志可以获取该命令的帮助信息，例如 `dotnet build -h`：
- en: '| **Command** | **Description** |'
  id: totrans-107
  prefs: []
  type: TYPE_TB
  zh: '| **命令** | **描述** |'
- en: '| `dotnet restore` | Restore the dependencies (a.k.a. NuGet packages) based
    on the `.csproj` or `.sln` file present in the current dictionary. |'
  id: totrans-108
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet restore` | 基于当前目录中存在的 `.csproj` 或 `.sln` 文件恢复依赖项（即 NuGet 包）。 |'
- en: '| `dotnet build` | Build the application based on the `.csproj` or `.sln` file
    present in the current dictionary. It implicitly runs the `restore` command first.
    |'
  id: totrans-109
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet build` | 基于当前目录中存在的 `.csproj` 或 `.sln` 文件构建应用程序。它隐式地首先运行 `restore`
    命令。 |'
- en: '| `dotnet run` | Run the current application based on the `.csproj` file present
    in the current dictionary. It implicitly runs the `build` and `restore` commands
    first. |'
  id: totrans-110
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet run` | 基于当前目录中存在的 `.csproj` 文件运行当前应用程序。它隐式地首先运行 `build` 和 `restore`
    命令。 |'
- en: '| `dotnet watch run` | Watch for file changes. When a file has changed, the
    CLI updates the code from that file using the hot-reload feature. When that is
    impossible, it rebuilds the application and then reruns it (equivalent to executing
    the `run` command again). If it is a web application, the page should refresh
    automatically. |'
  id: totrans-111
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet watch run` | 监视文件更改。当文件发生更改时，CLI 使用热重载功能更新该文件的代码。如果无法这样做，它将重新构建应用程序然后重新运行（相当于再次执行
    `run` 命令）。如果是 Web 应用程序，页面应自动刷新。 |'
- en: '| `dotnet test` | Run the tests based on the `.csproj` or `.sln` file present
    in the current directory. It implicitly runs the `build` and `restore` commands
    first. We cover testing in the next chapter. |'
  id: totrans-112
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet test` | 基于当前目录中存在的 `.csproj` 或 `.sln` 文件运行测试。它隐式地首先运行 `build` 和 `restore`
    命令。我们将在下一章介绍测试。 |'
- en: '| `dotnet watch test` | Watch for file changes. When a file has changed, the
    CLI reruns the tests (equivalent to executing the `test` command again). |'
  id: totrans-113
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet watch test` | 监视文件更改。当文件发生更改时，CLI 重新运行测试（相当于再次执行 `test` 命令）。 |'
- en: '| `dotnet publish` | Publish the current application, based on the `.csproj`
    or `.sln` file present in the current directory, to a directory or remote location,
    such as a hosting provider. It implicitly runs the `build` and `restore` commands
    first. |'
  id: totrans-114
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet publish` | 基于当前目录中存在的 `.csproj` 或 `.sln` 文件将当前应用程序发布到目录或远程位置，例如托管提供商。它隐式地首先运行
    `build` 和 `restore` 命令。 |'
- en: '| `dotnet pack` | Create a NuGet package based on the `.csproj` or `.sln` file
    present in the current directory. It implicitly runs the `build` and `restore`
    commands first. You don’t need a `.nuspec` file. |'
  id: totrans-115
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet pack` | 基于当前目录中存在的 `.csproj` 或 `.sln` 文件创建一个 NuGet 包。它隐式地首先运行 `build`
    和 `restore` 命令。您不需要 `.nuspec` 文件。 |'
- en: '| `dotnet clean` | Clean the build(s) output of a project or solution based
    on the `.csproj` or `.sln` file present in the current directory. |'
  id: totrans-116
  prefs: []
  type: TYPE_TB
  zh: '| `dotnet clean` | 根据当前目录中存在的 `.csproj` 或 `.sln` 文件清理项目或解决方案的构建输出。 |'
- en: Technical requirements
  id: totrans-117
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'Throughout the book, we will explore and write code. I recommend installing
    Visual Studio, Visual Studio Code, or both to help with that. I use Visual Studio
    and Visual Studio Code. Other alternatives are Visual Studio for Mac, Riders,
    or any other text editor you choose.Unless you install Visual Studio, which comes
    with the .NET SDK, you may need to install it. The SDK comes with the CLI we explored
    earlier and the build tools for running and testing your programs. Look at the
    `README.md` file in the GitHub repository for more information and links to those
    resources.The source code of all chapters is available for download on GitHub
    at the following address: [https://adpg.link/net6](https://adpg.link/net6).'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在整本书中，我们将探索并编写代码。我建议安装 Visual Studio、Visual Studio Code 或两者都安装，以帮助完成这项工作。我使用
    Visual Studio 和 Visual Studio Code。其他替代方案包括 Visual Studio for Mac、Riders 或您选择的任何其他文本编辑器。除非您安装了包含
    .NET SDK 的 Visual Studio，否则可能需要单独安装 SDK。SDK 包含我们之前探索的 CLI 以及运行和测试您的程序所需的构建工具。有关更多信息以及这些资源的链接，请查看
    GitHub 仓库中的 `README.md` 文件。所有章节的源代码都可以在以下地址下载：[https://adpg.link/net6](https://adpg.link/net6)。
- en: Summary
  id: totrans-119
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 摘要
- en: This chapter looked at design patterns, anti-patterns, and code smells. We also
    explored a few of them. We then moved on to a recap of a typical web application’s
    request/response cycle.We continued by exploring .NET essentials, such as SDK
    versus runtime and app targets versus .NET Standard. We then dug a little more
    into the .NET CLI, where I laid down a list of essential commands, including `dotnet
    build` and `dotnet watch run`. We also covered how to create new projects. This
    has set us up to explore the different possibilities we have when building our
    .NET applications.In the next two chapters, we explore automated testing and architectural
    principles. These are foundational chapters for building robust, flexible, and
    maintainable applications.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 本章探讨了设计模式、反模式和代码异味。我们还探索了其中的一些。然后，我们回顾了典型 Web 应用程序的请求/响应周期。接着，我们继续探索 .NET 的基本知识，例如
    SDK 与运行时以及应用程序目标与 .NET Standard。然后，我们更深入地研究了 .NET CLI，其中我列出了一些基本命令，包括 `dotnet
    build` 和 `dotnet watch run`。我们还介绍了如何创建新项目。这使我们能够探索在构建我们的 .NET 应用程序时具有的不同可能性。在接下来的两章中，我们将探讨自动化测试和架构原则。这些是构建健壮、灵活和可维护应用程序的基础章节。
- en: Questions
  id: totrans-121
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 问题
- en: 'Let’s take a look at a few practice questions:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一些练习题：
- en: Can we add a body to a `GET` request?
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们能否给一个`GET`请求添加一个主体？
- en: Why are long methods a code smell?
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为什么长方法是代码异味？
- en: Is it true that .NET Standard should be your default target when creating libraries?
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建库时，.NET Standard是否应该是你的默认目标？
- en: What is a code smell?
  id: totrans-126
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 代码异味是什么？
- en: Further reading
  id: totrans-127
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'Here are some links to consolidate what has been learned in the chapter:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 这里有一些链接，可以帮助巩固本章学到的内容：
- en: 'Overview of how .NET is versioned: [https://adpg.link/n52L](https://adpg.link/n52L)'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET版本概述：[https://adpg.link/n52L](https://adpg.link/n52L)
- en: '.NET CLI overview: [https://adpg.link/Lzx3](https://adpg.link/Lzx3)'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET CLI概述：[https://adpg.link/Lzx3](https://adpg.link/Lzx3)
- en: 'Custom templates for `dotnet` `new`: [https://adpg.link/74i2](https://adpg.link/74i2)'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`dotnet` `new`的定制模板：[https://adpg.link/74i2](https://adpg.link/74i2)'
- en: 'Session and state management in ASP.NET Core: [https://adpg.link/Xzgf](https://adpg.link/Xzgf)'
  id: totrans-132
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core中的会话和状态管理：[https://adpg.link/Xzgf](https://adpg.link/Xzgf)
