<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-28">
    <a id="_idTextAnchor033">
    </a>
    
     2
    
   </h1>
   <h1 id="_idParaDest-29">
    <a id="_idTextAnchor034">
    </a>
    
     Creating Your First Minimal API
    
   </h1>
   <p>
    
     The convenience of the .NET ecosystem could not be more evident by the steps you took in the last chapter.
    
    
     Minimal APIs in .NET live up to their name by having not only minimal logic and dependencies but also minimal
    
    
     
      setup requirements.
     
    
   </p>
   <p>
    
     Just by creating your first project, you have technically already created your first minimal API.
    
    <a id="_idTextAnchor035">
    </a>
    
     It’s functional out of the box, with a
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     endpoint that returns
    
    
     
      a response.
     
    
   </p>
   <p>
    
     Obviously, there is more to minimal APIs than what we saw in the
    
    <strong class="source-inline">
     
      Hello World
     
    </strong>
    
     example.
    
    
     There are different HTTP request methods, varying endpoints, and more advanced response generation to consider as part of a
    
    
     
      straightforward API.
     
    
   </p>
   <p>
    
     In this chapter,
    
    <a id="_idTextAnchor036">
    </a>
    
     we’re going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Project structure
     
     
      
       and organization
      
     
    </li>
    <li>
     
      Defining endpoints
     
     
      
       and routes
      
     
    </li>
    <li>
     
      Building the employee
     
     
      
       management API
      
     
    </li>
    <li>
     
      Handling
     
     
      
       HTTP requests
      
     
    </li>
   </ul>
   <p>
    
     By the end of the chapter, you’ll have gained experience in defining endpoints for handling HTTP requests.
    
    
     You’ll also be able to implement basic HTTP request handling and
    
    
     
      response generation.
     
    
   </p>
   <h1 id="_idParaDest-30">
    <a id="_idTextAnchor037">
    </a>
    
     Technical requirements
    
   </h1>
   <p>
    
     To follow the directions in this chapter, you’ll need to have the following installed on your Windows, macOS, or
    
    
     
      Linux machine:
     
    
   </p>
   <ul>
    <li>
     
      .NET 9.0
     
     <strong class="bold">
      
       Software Development
      
     </strong>
     
      <strong class="bold">
       
        Kit
       
      </strong>
     
     
      
       (
      
     
     
      <strong class="bold">
       
        SDK
       
      </strong>
     
     
      
       )
      
     
    </li>
    <li>
     
      Visual Studio or Visual
     
     
      
       Studio Code
      
     
    </li>
    <li>
     
      C# Extension for Visual Studio Code (if you are using Visual
     
     
      
       Studio Code)
      
     
    </li>
   </ul>
   <p>
    
     If you followed the setup guidance in
    
    <a href="B20968_01.xhtml#_idTextAnchor014">
     
      <em class="italic">
       
        Chapter 1
       
      </em>
     
    </a>
    
     , then you are ready to follow the directions in this chapter.
    
    
     However, if you still need to configure the preceding tools, then please follow the
    
    <a href="B20968_01.xhtml#_idTextAnchor014">
     
      <em class="italic">
       
        Chapter 1
       
      </em>
     
    </a>
    
     setup instructions under the
    
    <em class="italic">
     
      Installing required tools and dependencies
     
    </em>
    
     section.
    
    
     The code for this chapter is available in the GitHub repository
    
    
     
      at:
     
    
    
    
    <a href="https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET-9">
     
      
       https://github.com/PacktPublishing/Minimal-APIs-in-ASP.NET
      
     
     
      
       -9
      
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-31">
    <a id="_idTextAnchor038">
    </a>
    
     Project structure and organization
    
   </h1>
   <p>
    
     The rules around how a project is structured and organized are not exactly rigid, but it is important to ensure that you are organizing your projects in a cohesive and accessible manner.
    
    
     With minimal APIs in general, we are aiming for simplicity.
    
    
     Project structure and organization in minimal APIs specifically are no different.
    
    
     Therefore, it may not come as a shock that the project structure for minimal APIs outlined in the following examples will be
    
    
     
      extremely basic.
     
    
   </p>
   <p>
    
     In the following three subsections, we look at the elements needed to simplify our
    
    
     
      project structure.
     
    
   </p>
   <h2 id="_idParaDest-32">
    <a id="_idTextAnchor039">
    </a>
    
     Endpoints
    
   </h2>
   <p>
    <strong class="bold">
     
      Endpoints
     
    </strong>
    
     are
    
    <a id="_idIndexMarker038">
    </a>
    
     the
    
    <em class="italic">
     
      open doors
     
    </em>
    
     to your API.
    
    
     Each endpoint sits within an area of your domain (e.g., employees or inventory) and is responsible for specific actions within that domain, such as adding, updating, or removing an
    
    
     
      inventory item.
     
    
   </p>
   <p>
    
     In ASP.NET
    
    <strong class="source-inline">
     
      Controller
     
    </strong>
    
     -based projects, you would usually distribute endpoints for each area of the domain into logical groups
    
    <a id="_idIndexMarker039">
    </a>
    
     called
    
    <strong class="bold">
     
      Controllers
     
    </strong>
    
     .
    
    
     Each
    
    <strong class="source-inline">
     
      Controller
     
    </strong>
    
     is a class containing endpoints that are relevant to that
    
    <strong class="source-inline">
     
      Controller’s
     
    </strong>
    
     
      domain area.
     
    
   </p>
   <p>
    
     However, in minimal APIs, it is normal for endpoints to simply be defined in the app’s entry-point,
    
    
     
      within
     
    
    
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-33">
    <a id="_idTextAnchor040">
    </a>
    
     Models
    
   </h2>
   <p>
    
     Just like
    
    <a id="_idIndexMarker040">
    </a>
    
     in
    
    <strong class="bold">
     
      Model-View-Controller
     
    </strong>
    
     (
    
    <strong class="bold">
     
      MVC
     
    </strong>
    
     ) projects, a model
    
    <a id="_idIndexMarker041">
    </a>
    
     in minimal APIs can be used to encapsulate domain objects.
    
    
     Models are usually created as their own classes.
    
    
     In the upcoming examples, which demonstrate API endpoint mappings, I will be creating logic for an API that manages employees.
    
    
     Therefore, I will use a model in the form of an
    
    
     <strong class="source-inline">
      
       Employee
      
     </strong>
    
    
     
      class.
     
    
   </p>
   <p>
    
     Using a
    
    <a id="_idIndexMarker042">
    </a>
    
     class to represent domain objects brings many benefits, including
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Separation of concerns
      
     </strong>
     
      : Models encapsulate the data for the application, separating it from the business logic, which will be found within the API layer in
     
     
      
       our case.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Reusability
      
     </strong>
     
      : Model objects can be reused by business logic across
     
     
      
       the application.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Loose coupling
      
     </strong>
     
      : Thanks to the separation of concerns between data and business logic, changes to the API need not affect the structure of the data inadvertently.
     
     
      This is particularly important in common cases where models mirror a database table’s structure through an ORM such as Entity Framework or Dapper (See
     
     <a href="B20968_08.xhtml#_idTextAnchor132">
      
       <em class="italic">
        
         Chapter 8
        
       </em>
      
     </a>
     
      
       ).
      
     
    </li>
   </ul>
   <p class="callout-heading">
    
     Staying organized
    
   </p>
   <p class="callout">
    
     While minimal API project structures can afford to stay very simple, it’s still important to keep them organized.
    
    
     It is good practice to keep all models in a dedicated
    
    <strong class="source-inline">
     
      Models
     
    </strong>
    
     folder and all endpoints in their own
    
    
     <strong class="source-inline">
      
       Endpoints
      
     </strong>
    
    
     
      folder.
     
    
   </p>
   <p>
    
     For the final piece in the project structure puzzle, we
    
    
     
      have routes.
     
    
   </p>
   <h2 id="_idParaDest-34">
    <a id="_idTextAnchor041">
    </a>
    
     Routes
    
   </h2>
   <p>
    
     If endpoints are the open door
    
    <a id="_idIndexMarker043">
    </a>
    
     into the API,
    
    <strong class="bold">
     
      routes
     
    </strong>
    
     are the address of each door.
    
    
     By creating a route, you are defining the URLs that your API will respond to, and which piece of logic will be executed as
    
    
     
      a result.
     
    
   </p>
   <p>
    
     Routes can be standalone or contain parameters that will be passed through to the resulting
    
    
     
      API logic.
     
    
   </p>
   <p>
    
     In the endpoint on the following pages, you will see routes defined in the form of strings, indicating the text that should be appended onto the application’s base URL to access
    
    
     
      specific endpoints.
     
    
   </p>
   <p>
    
     For example, if our application is hosted at
    
    <strong class="source-inline">
     
      getInventoryItem
     
    </strong>
    
     , the full URL for that endpoint would
    
    
     
      become
     
    
    <a href="https://adventureworks.com/getInventoryItem">
     
      
       https://adventureworks.com/getInventoryItem
      
     
    </a>
    
     
      .
     
    
   </p>
   <p>
    
     We can, however, make our routes more generic.
    
    <strong class="source-inline">
     
      getInventoryItem
     
    </strong>
    
     is certainly clear, but it is better practice to, where possible, send different kinds of requests to a generic route, with different logic firing depending on the HTTP method
    
    
     
      in use.
     
    
   </p>
   <p>
    
     For example, instead of naming our route
    
    <strong class="source-inline">
     
      getinventoryitem
     
    </strong>
    
     , we could apply the generic name
    
    <strong class="source-inline">
     
      inventoryitems
     
    </strong>
    
     to as many HTTP methods as is relevant.
    
    
     This means that a
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     request (we will learn about these methods in the next section) to this route will get an inventory item, but a
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     to the same route will
    
    
     
      create one.
     
    
   </p>
   <p>
    
     This is deemed to be a best
    
    <a id="_idIndexMarker044">
    </a>
    
     practice for naming routes, for
    
    
     
      several reasons:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Consistency
      
     </strong>
     
      : Since having a generic endpoint has become an API convention, it allows your API to conform to an
     
     
      
       agreed standard.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Intuitiveness
      
     </strong>
     
      : Most developers consuming an API will work to the same standard.
     
     
      This means that they will be more quickly able to pick up
     
     
      
       your API.
      
     
    </li>
    <li>
     <strong class="bold">
      
       RESTful principles
      
     </strong>
     
      : Allowing the HTTP method to identify the function of an endpoint rather than the route allows us to conform to RESTful principles, which encourage good
     
     <a id="_idIndexMarker045">
     </a>
     
      use of
     
     <strong class="bold">
      
       CREATE, READ, UPDATE, DELETE
      
     </strong>
     
      (
     
     <strong class="bold">
      
       CRUD
      
     </strong>
     
      ) operations, idempotency (during multiple identical requests, the server’s state is never changed, and it returns the same results for the same request each time), and the need for full coverage of the standard HTTP methods (
     
     <strong class="source-inline">
      
       GET
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       POST
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       PUT
      
     </strong>
     
      ,
     
     
      <strong class="source-inline">
       
        PATCH
       
      </strong>
     
     
      
       ,
      
     
     
      <strong class="source-inline">
       
        DELETE
       
      </strong>
     
     
      
       ).
      
     
    </li>
   </ul>
   <p>
    
     In contrast to the list, if you have API endpoints that support an HTTP method in a very bespoke use case, you can still create routes that are more specific.
    
    
     However, the customary practice is to use the generic route naming convention that
    
    
     
      we outlined.
     
    
   </p>
   <p>
    
     Understanding routes is critical to minimal API development in addition to most API fram
    
    <a id="_idTextAnchor042">
    </a>
    
     eworks.
    
    
     Let’s turn our attention to the way in which routes and their endpoints
    
    
     
      are defined.
     
    
   </p>
   <h1 id="_idParaDest-35">
    <a id="_idTextAnchor043">
    </a>
    
     Defining endpoints and routes
    
   </h1>
   <p>
    
     Like any other RESTful API framework, minimal API endpoints are accessed using different HTTP methods.
    
    
     Depending on the HTTP method used to contact the API endpoint, a different result will be produced, or an action will
    
    
     
      be executed.
     
    
   </p>
   <p>
    
     In the next few sections, we will look at some examples of endpoints being mapped with different
    
    
     
      HTTP methods.
     
    
   </p>
   <h2 id="_idParaDest-36">
    <a id="_idTextAnchor044">
    </a>
    
     GET methods
    
   </h2>
   <p>
    
     An HTTP
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     method is a
    
    <a id="_idIndexMarker046">
    </a>
    
     request for information.
    
    
     On successful retrieval, the API endpoint
    
    <a id="_idIndexMarker047">
    </a>
    
     returns a
    
    <strong class="source-inline">
     
      200 OK
     
    </strong>
    
     status code, along with the
    
    
     
      requested data.
     
    
   </p>
   <p>
    
     The example shows a
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     endpoint mapped to the
    
    <strong class="source-inline">
     
      "/employees"
     
    </strong>
    
     route.
    
    
     It gets the employee ID contained within the URL and uses this to find the relevant employee data before
    
    
     
      returning it.
     
    
   </p>
   <p>
    
     For example, if this API were hosted at constoso.com, a
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     call to
    
    <a href="https://contoso.com/employees/24">
     
      contoso.com/employees/24
     
    </a>
    
     would retrieve the employee whose ID
    
    
     
      is
     
    
    
     <strong class="source-inline">
      
       24
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
app.MapGet("/employees/{id}", (int id) =&gt;
{
    var employee = EmployeeManager.Get(id);
    return Results.Ok(employee);
});</pre>
   <p>
    
     Let’s look at
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     
      methods now.
     
    
   </p>
   <h2 id="_idParaDest-37">
    <a id="_idTextAnchor045">
    </a>
    
     POST methods
    
   </h2>
   <p>
    
     An HTTP
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     method is a
    
    <a id="_idIndexMarker048">
    </a>
    
     request to create something.
    
    
     On successful execution, the API
    
    <a id="_idIndexMarker049">
    </a>
    
     endpoint usually returns a
    
    <strong class="source-inline">
     
      201 Created
     
    </strong>
    
     status code (this is best practice, although some APIs return the standard
    
    <strong class="source-inline">
     
      200 OK
     
    </strong>
    
     code), along with any
    
    
     
      relevant data.
     
    
   </p>
   <p>
    
     The following example shows a
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     method mapped to the
    
    <strong class="source-inline">
     
      "/employees"
     
    </strong>
    
     endpoint.
    
    
     It expects to receive an employee payload in JSON format.
    
    
     The endpoint then converts the payload into an object of the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     type, before calling some other back-end code to create an
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     , using this object as
    
    
     
      a parameter.
     
    
   </p>
   <p>
    
     If everything worked as expected, the endpoint returns a
    
    <strong class="source-inline">
     
      201 Created
     
    </strong>
    
     status code, along with the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     <strong class="source-inline">
      
       Created
      
     </strong>
    
    
     
      message.
     
    
   </p>
   <p>
    
     For example, if this API were hosted at
    
    <strong class="source-inline">
     
      constoso.com
     
    </strong>
    
     , a
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     call would execute the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
app.MapPost("/employees", (Employee employee) =&gt;
{
    EmployeeManager.Create(employee);
    return Results.Created();
});</pre>
   <p>
    
     Up next, we look at
    
    
     <strong class="source-inline">
      
       PUT
      
     </strong>
    
    
     
      methods.
     
    
   </p>
   <h2 id="_idParaDest-38">
    <a id="_idTextAnchor046">
    </a>
    
     PUT methods
    
   </h2>
   <p>
    
     An HTTP
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     method is a request
    
    <a id="_idIndexMarker050">
    </a>
    
     to update something.
    
    
     It’s important to remember that
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     updates
    
    <a id="_idIndexMarker051">
    </a>
    
     a resource in a particular way compared to the
    
    <strong class="source-inline">
     
      PATCH
     
    </strong>
    
     method, which has its own way
    
    
     
      of updating.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     methods require a payload that represents the entire resource being updated.
    
    
     So, in the case of our
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     API, if you were to use a
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     endpoint to update an existing employee, the API endpoint would expect a full
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     object to be sent in the request.
    
    
     It would then find the existing employee and replace it with the one sent in
    
    
     
      the request.
     
    
   </p>
   <p>
    
     On successful execution, the API endpoint returns the standard
    
    <strong class="source-inline">
     
      200 OK
     
    </strong>
    
     
      status code.
     
    
   </p>
   <p>
    
     The example shows a
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     method mapped to the
    
    <strong class="source-inline">
     
      "/employees"
     
    </strong>
    
     route.
    
    
     It expects to receive an employee payload in JSON format.
    
    
     Like in the preceding
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     example, the endpoint converts this JSON payload into an object of the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     type, before finding the original employee and calling a method to replace it with the
    
    
     
      updated one
     
    
   </p>
   <p>
    
     For example, if this
    
    <a id="_idIndexMarker052">
    </a>
    
     API was hosted at constoso.com, a
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     call
    
    <a id="_idIndexMarker053">
    </a>
    
     would execute the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
app.MapPut("/employees", (Employee employee) =&gt;
{
    EmployeeManager.Update(employee);
    return Results.Ok();
});</pre>
   <h2 id="_idParaDest-39">
    <a id="_idTextAnchor047">
    </a>
    
     PATCH methods
    
   </h2>
   <p>
    
     Like a
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     method, an HTTP
    
    <strong class="source-inline">
     
      PATCH
     
    </strong>
    
     method is also a request to update something.
    
    
     However, the way it does its
    
    <a id="_idIndexMarker054">
    </a>
    
     update is different.
    
    
     Instead of requiring a payload containing a
    
    <a id="_idIndexMarker055">
    </a>
    
     representation of the entire object, a
    
    <strong class="source-inline">
     
      PATCH
     
    </strong>
    
     method only requires that the individual values that need to be changed are sent as part of the request.
    
    
     The API can then take care of updating the relevant properties on the
    
    
     
      existing object.
     
    
   </p>
   <p>
    
     On successful execution, the API endpoint usually returns the standard
    
    <strong class="source-inline">
     
      200 OK
     
    </strong>
    
     
      status code.
     
    
   </p>
   <p>
    
     The example shows a
    
    <strong class="source-inline">
     
      PATCH
     
    </strong>
    
     method mapped to the
    
    <strong class="source-inline">
     
      "/updateEmployeeName"
     
    </strong>
    
     route.
    
    
     It expects to receive an
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     object like
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     .
    
    
     However, it is only interested in the
    
    <strong class="source-inline">
     
      Name
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     properties.
    
    
     This means that as long as a JSON payload is sent and it contains these properties, it will work.
    
    
     Using these properties, the code fetches the right object of the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     type based on the given Id.
    
    
     It then updates the name property on the retrieved employee only, without overwriting the
    
    
     
      whole object.
     
    
   </p>
   <p>
    
     For example, if this API was hosted at constoso.com, a
    
    <strong class="source-inline">
     
      P
     
    </strong>
    <strong class="source-inline">
     
      ATCH
     
    </strong>
    
     call would execute the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
app.MapPatch("/updateEmployeeName", (Employee employee) =&gt;
{
    EmployeeManager.ChangeName(employee.Id, employee.Name);
    return Results.Ok();
});</pre>
   <p>
    
     The final method we will look at
    
    
     
      is
     
    
    
     <strong class="source-inline">
      
       DELETE
      
     </strong>
    
    
     
      .
     
    
   </p>
   <h2 id="_idParaDest-40">
    <a id="_idTextAnchor048">
    </a>
    
     DELETE method
    
   </h2>
   <p>
    
     A
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     method is
    
    <a id="_idIndexMarker056">
    </a>
    
     self-explanatory in terms of what it does.
    
    
     Sending an ID for a
    
    <a id="_idIndexMarker057">
    </a>
    
     resource as a parameter in the same way we did for the
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     endpoint, the API can locate that specific resource and then
    
    
     
      remove it.
     
    
   </p>
   <p>
    
     In most cases, on success, a
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     method will usually return the standard
    
    <strong class="source-inline">
     
      200 OK
     
    </strong>
    
     status code, but it may instead return
    
    <strong class="source-inline">
     
      204 No Content
     
    </strong>
    
     , which is
    
    
     
      also fine.
     
    
   </p>
   <p>
    
     The following example shows a
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     method mapped to the
    
    <strong class="source-inline">
     
      "/employees"
     
    </strong>
    
     route.
    
    
     The endpoint will use the
    
    <strong class="source-inline">
     
      Id
     
    </strong>
    
     parameter to find the corresponding object of the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     type as the target for deletion.
    
    
     After removing the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     object, it returns a
    
    <strong class="source-inline">
     
      204 No Content
     
    </strong>
    
     status code to
    
    
     
      the client.
     
    
   </p>
   <p>
    
     If this API was hosted at constoso.com, a
    
    <strong class="source-inline">
     
      DELETE
     
    </strong>
    
     call to
    
    <a href="https://contoso.com/employees">
     
      https://contoso.com/employees
     
    </a>
    
     would execute
    
    <a id="_idTextAnchor049">
    </a>
    
     the
    
    
     
      following code:
     
    
   </p>
   <pre class="source-code">
app.MapDelete("/deleteEmployee/{id}", (int id) =&gt;
{
    EmployeeManager.Delete(id);
    return Results.Ok();
});</pre>
   <p>
    
     Once you feel you’ve understood the different HTTP methods available to our API, turn to the next section to start building a basic minimal API based on a simple, real-world
    
    
     
      use case.
     
    
   </p>
   <h1 id="_idParaDest-41">
    <a id="_idTextAnchor050">
    </a>
    
     Building the employee management API
    
   </h1>
   <p>
    
     Now that we have
    
    <a id="_idIndexMarker058">
    </a>
    
     covered an overview of routing and endpoints, along with the ways in which they support the various HTTP methods, let’s start building a new minimal API project, with the use case of
    
    
     
      employee management.
     
    
   </p>
   <p>
    
     Our goal in this section will be to create a repository of employees on which our API can operate.
    
    
     The API will then be able to get, create, update, and
    
    
     
      delete employees.
     
    
   </p>
   <h2 id="_idParaDest-42">
    <a id="_idTextAnchor051">
    </a>
    
     Creating the API
    
   </h2>
   <p>
    
     Follow the next few steps to
    
    <a id="_idIndexMarker059">
    </a>
    
     create the employee
    
    
     
      management API.
     
    
   </p>
   <p>
    
     If you haven’t followed the steps in
    
    <a href="B20968_01.xhtml#_idTextAnchor014">
     
      <em class="italic">
       
        Chapter 1
       
      </em>
     
    </a>
    
     to create your ASP.NET project in Visual Studio or Visual Studio Code, follow them first, and then continue with the
    
    
     
      next steps:
     
    
   </p>
   <ol>
    <li>
     
      You may already have this in your project, but if not, ensure that it is present at the top of
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      .
     
     
      This will build the
     
     <strong class="source-inline">
      
       WebApplication
      
     </strong>
     
      instance that hosts the
     
     
      
       minimal API:
      
     
     <pre class="source-code">
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();</pre>
    </li>
    <li>
     
      The two lines in the previous step are enough to build the
     
     <strong class="source-inline">
      
       WebApplication
      
     </strong>
     
      instance, but it still needs to be started.
     
     
      Add this line to the bottom of your class to start
     
     
      
       the instance:
      
     
     <pre class="source-code">
app.Run();</pre>
    </li>
   </ol>
   <p>
    
     Now you have a runnable app, but no endpoints.
    
    
     Before we define those endpoints, we need some data to work with.
    
    
     We’ll come back to
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     to define the endpoints shortly.
    
    
     But before that, let’s create a model of the
    
    
     <strong class="source-inline">
      
       Employee
      
     </strong>
    
    
     
      type:
     
    
   </p>
   <ol>
    <li>
     
      In the folder structure of the project, create a new folder
     
     
      
       called
      
     
     
      <strong class="source-inline">
       
        Models
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Inside the new folder, create a new class
     
     
      
       called
      
     
     
      <strong class="source-inline">
       
        Employee
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      Create these properties in the
     
     
      <strong class="source-inline">
       
        Employee
       
      </strong>
     
     
      
       class:
      
     
     <pre class="source-code">
    public class Employee
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public decimal Salary { get; set; }
        public string Address { get; set; }
        public <a id="_idTextAnchor052"/>string City { get; set; }
        public st<a id="_idTextAnchor053"/>ring Region { get; set; }
        public string<a id="_idTextAnchor054"/> PostalCode { get; set; }
        <a id="_idTextAnchor055"/>public str<a id="_idTextAnchor056"/>ing Country { get; set; }
      <a id="_idTextAnchor057"/>  public s<a id="_idTextAnchor058"/>tring Phone { get; set; }
    }</pre>
     <p class="list-inset">
      
       This model can be
      
      <a id="_idTextAnchor059">
      </a>
      
       used to represent an
      
      <strong class="source-inline">
       
        Employee
       
      </strong>
      
       resource, on which the API can perform various CRUD operations.
      
      
       Ordinarily, we would keep this data in a database, such as SQL, but for now, we’re going to keep it simple and store the employees in a collection.
      
      
       To do this, the collection needs to be situated somewhere in which it can be accessed by the endpoints we’re about
      
      
       
        to create.
       
      
     </p>
    </li>
    <li>
     
      At the top
     
     <a id="_idIndexMarker060">
     </a>
     
      level of the project, (the same level as
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      ), create a new class
     
     
      
       called
      
     
     
      <strong class="source-inline">
       
        EmployeeManager
       
      </strong>
     
     
      
       .
      
     
    </li>
    <li>
     
      We want this class to be available at any time, without the need to instantiate it, so make it a
     
     
      
       static class.
      
     
    </li>
    <li>
     
      Add a private
     
     <strong class="source-inline">
      
       List
      
     </strong>
     
      of the
     
     <strong class="source-inline">
      
       Employee
      
     </strong>
     
      type at the top of the class.
     
     
      Your class should look
     
     
      
       like this:
      
     
     <pre class="source-code">
public static class EmployeeManager
{
    private static List&lt;Employee&gt; _employees =
  <a id="_idTextAnchor060"/>      new List&lt;Employee&gt;();
}</pre>
    </li>
   </ol>
   <p>
    
     Now we have an easily accessible class that can store the employees.
    
    
     As the collection is private, we can now add a set of methods that can be publicly exposed to the endpoints to
    
    
     
      perform operations.
     
    
   </p>
   <p>
    
     We’re about to
    
    <a id="_idIndexMarker061">
    </a>
    
     create logic for the CRUD actions to be performed on each
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     in the collection.
    
    
     As part of this, it will be necessary to look up each employee object in the list.
    
    
     Let’s add a private function that will find this for us, for reuse on each CRUD operation.
    
    
     With the private function added, the class now looks
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
public static class EmployeeManager
{
    private static List&lt;Employee&gt; _employees =
        new List&lt;Employee&gt;();
    private static int getEmployeeIndex(int id)
    {
        var employeeIndex =
            _employees.FindIndex(x =&gt; x.Id == id);
        if (employeeIndex == -1)
        {
            throw new ArgumentException(
                $"Employee with Id {id} does not exist");
        }
        return employeeIndex;
    }
}</pre>
   <p>
    
     Finally, update the
    
    <a id="_idIndexMarker062">
    </a>
    
     class so that it contains the  CRUD methods and functions shown in this
    
    
     
      code sni
     
     <a id="_idTextAnchor061">
     </a>
     
      ppet:
     
    
   </p>
   <pre class="source-code">
public static void Create(Employee employee)
{
    _employees.Add(employe<a id="_idTextAnchor062"/>e);
}
public static void Update(Employee employee)
{
    _employees[_getEmployeeIndex(employee.Id)] =
        employee;
}
public static void ChangeName(int id, string name)
{
    _employ<a id="_idTextAnchor063"/>ees[_getEmployeeIndex(id)].Name = nam<a id="_idTextAnchor064"/>e;
}
public static void Delete(int id)
{
    _employees.RemoveAt(_getEmployeeIndex(id));
<a id="_idTextAnchor065"/>}
public static Employee Get(int id)
{
    var employee =
        _employees.FirstOrDefault(x =&gt; x.Id == id);
    if (employee == null)
    {
        throw new ArgumentException("Employee Id invalid");
    }
    return employee;
}</pre>
   <p>
    
     The
    
    <strong class="source-inline">
     
      EmployeeManager
     
    </strong>
    
     class will
    
    <a id="_idIndexMarker063">
    </a>
    
     now enable our API endpoints to perform specific CRUD actions on employees in
    
    
     
      the collection.
     
    
   </p>
   <h2 id="_idParaDest-43">
    <a id="_idTextAnchor066">
    </a>
    
     Creating the first endpoint
    
   </h2>
   <p>
    
     The first endpoint to
    
    <a id="_idIndexMarker064">
    </a>
    
     add will be the
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     endpoint for retrieving a specific
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     object by
    
    
     
      its ID.
     
    
   </p>
   <p>
    
     Create the following
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     endpoint in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     right above the final
    
    <strong class="source-inline">
     
      app.Run()
     
    </strong>
    
     line you added earlier in
    
    
     
      the chapter:
     
    
   </p>
   <pre class="source-code">
app.MapGet("/employees/{id}", (int id) =&gt;
{
    var employee = EmployeeManager.Get(id);
    return Results.Ok(employee);
});</pre>
   <p>
    
     This code starts by referencing the
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     instance known as
    
    <strong class="source-inline">
     
      app
     
    </strong>
    
     , calling the
    
    <strong class="source-inline">
     
      MapGet
     
    </strong>
    
     method.
    
    
     There are equivalent mapping methods in
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     named based on the type of HTTP method.
    
    
     Examples include
    
    <strong class="source-inline">
     
      MapPut
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      MapPost
     
    </strong>
    
     , and
    
    
     
      so on.
     
    
   </p>
   <p>
    
     The first parameter expected on the mapping method will be the route you wish to listen to.
    
    
     In this case, we are mapping to the
    
    <strong class="source-inline">
     
      "/employees/{id}"
     
    </strong>
    
     route, which uses a routing parame
    
    <a id="_idTextAnchor067">
    </a>
    
     ter (more on this in
    
    <a href="B20968_04.xhtml#_idTextAnchor081">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     ) to capture an
    
    
     
      employee ID.
     
    
   </p>
   <p>
    
     This is then followed by a second parameter in the form of a lambda expression, which uses the passed-in ID to execute the intended logic.
    
    
     At this
    
    <a id="_idTextAnchor068">
    </a>
    
     point, the code calls the
    
    <strong class="source-inline">
     
      Create()
     
    </strong>
    
     function defined in the
    
    <strong class="source-inline">
     
      EmployeeManager
     
    </strong>
    
     class before finally returning the result to
    
    
     
      the client.
     
    
   </p>
   <p>
    
     Add the
    
    <a id="_idIndexMarker065">
    </a>
    
     remaining endpoints to
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     below the
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     endpoint we just created and above the
    
    <strong class="source-inline">
     
      app.Run()
     
    </strong>
    
     method.
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     should now look
    
    
     
      like this:
     
    
   </p>
   <pre class="source-code">
using System.Text.Json;
using WebApplication2;
var builder = WebApplication.CreateBuilder(args);
var app = builder.Build();
app.MapGet("/employees/{id}", (int id) =&gt;
{
    var employee = EmployeeManager.Get(id);
    return Results.Ok(employee);
});
app.MapPost("/employees", (Employee employee) =&gt;
{
    EmployeeManager.Create(employee);
    return Results.Created();
});
app.MapPut("/employees", (Employee employee) =&gt;
{
    EmployeeManager.Update(employee);
    return Results.Ok();
});
app.MapPatch("/updateEmployeeName", (Employee employee) =&gt;
{
    EmployeeManager.ChangeName(employee.Id, employee.Name);
    return Results.Ok();
});
app.MapDelete("/employees/{id}", (int id) =&gt;
{
    EmployeeManager.Delete(id);
    return Results.Ok();
});
app.Run();</pre>
   <p>
    
     You’ll notice that all of the
    
    <a id="_idIndexMarker066">
    </a>
    
     subsequent endpoints you’ve mapped follow a similar pattern to the first
    
    <strong class="source-inline">
     
      GET
     
    </strong>
    
     endpoint you added.
    
    
     Each of them specifies the HTTP method type that is being used, followed by the route, then by any parameters.
    
    
     There is then a body that executes relevant logic before a result
    
    
     
      is returned.
     
    
   </p>
   <p>
    
     At
    
    <a id="_idTextAnchor069">
    </a>
    
     this point, the
    
    <a id="_idIndexMarker067">
    </a>
    
     code should compile.
    
    
     (If it does not, check that everything has been typed in correctly.) So, run the application (click the play button in Visual Studio or use the
    
    <strong class="source-inline">
     
      dotnet run
     
    </strong>
    
     terminal command in Visual Studio Code) and make some test requests to each of the created endpoints.
    
    
     The
    
    <strong class="source-inline">
     
      POST
     
    </strong>
    
     ,
    
    <strong class="source-inline">
     
      PUT
     
    </strong>
    
     ,
    
    <a id="_idTextAnchor070">
    </a>
    
     and
    
    <strong class="source-inline">
     
      PATCH
     
    </strong>
    
     endpoints expect an
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     object as a parameter, so ensure that you have sent JSON that mirrors the structure of the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     model.
    
    
     Look at
    
    
     
      this example:
     
    
   </p>
   <pre class="source-code">
{
  "Id": 3,
  "Name": "Happy McHappyson",
  "Salary": 100000.00,
  "Address": "1 Sunny Lane",
  "City": "Happyville",
  "Region": "The Joyful Mountains",
  "PostalCode": "1234565",
  "Country": "Laughland",
  "Phone": "876542-2345-3242-234"
}</pre>
   <p>
    
     Having created an endpoint, it is time we
    
    
     
      test it.
     
    
   </p>
   <h3>
    
     Testing your endpoint using OpenAPI
    
   </h3>
   <p>
    
     .NET 9 introduces
    
    <a id="_idIndexMarker068">
    </a>
    
     OpenAPI integration, meaning that you can simply install a package and change the configuration of your API in
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     to generate a JSON representation of your API and its endpoints.
    
    
     This is useful because you can import it into API tools such as Postman, from which you can then easily test
    
    
     
      your APIs.
     
    
   </p>
   <p>
    
     If you wish to test in this manner, follow
    
    
     
      these steps:
     
    
   </p>
   <ol>
    <li>
     
      Install the
     
     <strong class="source-inline">
      
       Microsoft.AspNetCore.OpenApi
      
     </strong>
     
      package
     
     
      
       via NuGet.
      
     
    </li>
    <li>
     
      Update
     
     <strong class="source-inline">
      
       Program.cs
      
     </strong>
     
      so that it
     
     
      
       uses OpenApi:
      
     
     <pre class="source-code">
<strong class="bold">builder.Services.AddOpenApi();</strong>
<strong class="bold">var app = builder.Build();</strong>
<strong class="bold">app.MapOpenApi();</strong></pre>
    </li>
   </ol>
   <p>
    
     Run the API and
    
    <a id="_idIndexMarker069">
    </a>
    
     navigate to the
    
    <strong class="source-inline">
     
      openAPI/v1.json
     
    </strong>
    
     route.
    
    
     This will provide you with a representation of your API schema, which can be imported into API clients such as Postman
    
    
     
      for testing.
     
    
   </p>
   <p>
    
     At this point in the chapter, you’ve now mapped endpoints with varying HTTP methods, provided them with routes and parameters, created models, and added logic to be executed.
    
    
     The goal of the endpoint is to return a response to the client.
    
    
     We now need to handle the requests by returning
    
    
     
      a response.
     
    
   </p>
   <h1 id="_idParaDest-44">
    <a id="_idTextAnchor071">
    </a>
    
     Handling HTTP requests
    
   </h1>
   <p>
    
     ASP.NET provides a handy
    
    <a id="_idIndexMarker070">
    </a>
    
     helper object for sending responses back to clients,
    
    
     
      called
     
    
    
     <strong class="source-inline">
      
       IResult
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    
     An
    
    <strong class="source-inline">
     
      IResult
     
    </strong>
    
     contains properties that can be used to represent standard HTTP responses for many different scenarios.
    
    
     For example, we could use IResult to return a specific status code, return JSON data, or even
    
    <a id="_idIndexMarker071">
    </a>
    
     trigger
    
    <strong class="bold">
     
      ASP.NET Identity
     
    </strong>
    
     provider functionality such as challenges
    
    
     
      and sign-in/out.
     
    
   </p>
   <p>
    
     We can create a new IResult easily using ASP.NET’s
    
    <strong class="source-inline">
     
      Results
     
    </strong>
    
     factory class.
    
    
     In the preceding examples, you will have seen references to this factory class, where the API has returned status codes by calling
    
    <strong class="source-inline">
     
      Results.OK()
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Results.Created()
     
    </strong>
    
     , to name
    
    
     
      a few.
     
    
   </p>
   <p>
    
     Some of these simple HTTP status code methods have optional parameters that allow you to return strongly typed objects as JSON.
    
    
     For example, while you can simply return a
    
    <strong class="source-inline">
     
      200
     
    </strong>
    
     result by omitting any parameters in
    
    <strong class="source-inline">
     
      Results.OK()
     
    </strong>
    
     , you can also pass an object argument, and it will be sent back to the client.
    
    
     This was done in our Employee API endpoints for the
    
    
     <strong class="source-inline">
      
       GET
      
     </strong>
    
    
     
      endpoint:
     
    
   </p>
   <pre class="source-code">
app.MapGet("/employees/{id}", (int id) =&gt;
{
    var employee = EmployeeManager.Get(id);
    //RETURN 200 OK RESULT WITH THE EMPLOYEE OBJECT
    return Results.Ok(employee);
});</pre>
   <p>
    
     The ability to pass strongly typed .NET objects such as
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     back to the client in a helper method is one of the most powerful aspects of
    
    
     
      minimal APIs.
     
    
   </p>
   <p>
    
     There’ll be more detailed
    
    <a id="_idIndexMarker072">
    </a>
    
     examples of handling HTTP requests in
    
    <a href="B20968_04.xhtml#_idTextAnchor081">
     
      <em class="italic">
       
        Chapter 4
       
      </em>
     
    </a>
    
     .
    
    
     For now, here are some examples of how
    
    <strong class="source-inline">
     
      Results
     
    </strong>
    
     can be used to return common
    
    
     
      HTTP responses:
     
    
   </p>
   <pre class="source-code">
    //200 OK
    return Results.Ok();
    //201 CREATED
    return Results.Created();
    //202 ACCEPTED
    return Results.Accepted();
    //204 NO CONTENT
    return Results.NoContent();
    //400 BAD REQUEST
    return Results.BadRequest();
    //401 UNAUTHORIZED
    return Results.Unauthorized();
    //403 FORBIDDEN
    return Results.Forbid();
    //404 NOT FOUND
    return Results.NotFound();
    //409 CONFLICT
    return Results.Conflict();</pre>
   <p>
    
     After exploring
    
    <strong class="source-inline">
     
      Results
     
    </strong>
    
     , let’s take
    
    <a id="_idIndexMarker073">
    </a>
    
     a look at one of
    
    
     
      its alternatives.
     
    
   </p>
   <h3>
    
     Typed Results
    
   </h3>
   <p>
    
     An
    
    <a id="_idIndexMarker074">
    </a>
    
     alternative to using
    
    <strong class="source-inline">
     
      Results
     
    </strong>
    
     to return specific HTTP status codes is
    
    <strong class="source-inline">
     
      TypedResults
     
    </strong>
    
     , which is similar to
    
    <strong class="source-inline">
     
      Results
     
    </strong>
    
     but where the example responses using
    
    <strong class="source-inline">
     
      Results
     
    </strong>
    
     return an
    
    <strong class="source-inline">
     
      IResult
     
    </strong>
    
     each time,
    
    <strong class="source-inline">
     
      TypedResults
     
    </strong>
    
     returns a strongly typed object representing the
    
    
     
      status code.
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      TypedResults
     
    </strong>
    
     implements a factory returning the appropriate strongly typed object that implements
    
    <strong class="source-inline">
     
      IResult
     
    </strong>
    
     for the specified status (e.g., returning
    
    <strong class="source-inline">
     
      OK&lt;string&gt;
     
    </strong>
    
     for a
    
    <strong class="source-inline">
     
      200
     
    </strong>
    
     <strong class="source-inline">
      
       OK
      
     </strong>
    
    
     
      result).
     
    
   </p>
   <p>
    
     You can use
    
    <strong class="source-inline">
     
      TypedResults
     
    </strong>
    
     in virtually the same way you use
    
    <strong class="source-inline">
     
      Results
     
    </strong>
    
     .
    
    
     Here’s
    
    
     
      an example:
     
    
   </p>
   <pre class="source-code">
    //200 OK
    return TypedResults.Ok();
    //201 CREATED
    return TypedResults.Created();
    //202 ACCEPTED
    return TypedResults.Accepted();
    //204 NO CONTENT
    return TypedResults.NoContent();</pre>
   <p>
    
     NET 9 also introduces support for
    
    <strong class="source-inline">
     
      500 INTERNAL SERVER ERROR
     
    </strong>
    
     responses
    
    
     
      in
     
    
    
     <strong class="source-inline">
      
       TypedResults
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
    //204 NO CONTENT
    return TypedResults.InternalServerError();</pre>
   <p>
    
     At this point, you should now have a decent understanding of how to handle HTTP requests, returning the relevant HTTP status codes and strongly typed objects back to the client.
    
    
     Let us sum up everything we have covered in
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-45">
    <a id="_idTextAnchor072">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     In this chapter, we covered most of the introductory aspects of creating simple minimal APIs, and you created your first minimal
    
    
     
      API project.
     
    
   </p>
   <p>
    
     You learned how to define endpoints, and how they act as doors into the API, each of them sitting on their respective routes.
    
    
     Using the example of the
    
    <strong class="source-inline">
     
      Employee
     
    </strong>
    
     API, you gained insight into how to structure your project, splitting endpoints and data to achieve the benefits of loose coupling
    
    
     
      and reusability.
     
    
   </p>
   <p>
    
     You explored the concept of models as data structures that describe the domain objects in use by the API, and you built a simple CRUD system for manipulating data
    
    
     
      during requests.
     
    
   </p>
   <p>
    
     Finally, you gained a basic understanding of how to handle HTTP requests in a minimal API, using ASP.NET helper logic to compose and return responses
    
    
     
      to clients.
     
    
   </p>
   <p>
    
     Armed with your foundational knowledge, turn to the next chapter, where we will explore the anatomy of a minimal API.
    
    
     We’ll delve deeper and more scientifically into the key components that make up minimal APIs, and you’ll be introduced to some of the various architectural and design patterns that can be adopted to fully realise
    
    
     
      their potential.
     
    
   </p>
  </div>
 </body></html>