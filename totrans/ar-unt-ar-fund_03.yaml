- en: '*Chapter 2*: Your First AR Scene'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Creating a simple Augmented Reality (AR) scene is quite simple with Unity AR
    Foundation. The steps involved might only take a page or two. However, when we
    create a scene together in this chapter, each step will be explained in context
    so that you can gain a full understanding of what comprises an AR scene using
    AR Foundation.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
- en: But before we do that, we'll take a look at some AR examples provided by Unity,
    including the AR Foundation Samples project, and build their example scenes for
    your device. And because that project contains some useful assets, we'll export
    those as an asset package for reuse in our own projects.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the AR Foundation Samples project
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Exporting and importing sample assets
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Constructing a new Unity AR scene
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to C# programming and the MonoBehaviour class
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using AR raycast to place an object on a plane
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Instantiating a GameObject
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating and editing prefabs
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To implement the project provided in this chapter, you will need Unity installed
    on your development computer, connected to a mobile device that supports augmented
    reality applications (see [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*,
    Setting Up for AR Development*, for instructions). The completed project can be
    found in this book's GitHub repository at [https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation](https://github.com/PacktPublishing/Augmented-Reality-with-Unity-AR-Foundation).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the AR Foundation example projects from Unity
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A great way to learn about how to create AR projects with Unity AR Foundation
    is to explore the various example projects from Unity. These projects include
    example scenes, scripts, prefabs, and other assets. By cloning a project and opening
    an example scene, you can learn how to use AR Foundation, experiment with features,
    and see some best practices. In particular, consider these projects:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
- en: '*AR Foundation Samples*: [https://github.com/Unity-Technologies/arfoundation-samples](https://github.com/Unity-Technologies/arfoundation-samples).'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*AR Foundation Demos*: [https://github.com/Unity-Technologies/arfoundation-demos](https://github.com/Unity-Technologies/arfoundation-demos).'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*XR Interaction Toolkit Examples*: [https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/tree/master/AR](https://github.com/Unity-Technologies/XR-Interaction-Toolkit-Examples/tree/master/AR).'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For more advanced work, I'm also a fan of several individual contributors, including
    Dan Miller, a senior XR developer at Unity. See [https://github.com/DanMillerDev](https://github.com/DanMillerDev)
    for more information.
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Please look through the **README** file for each of these projects (found on
    the GitHub project's home page) to gain an understanding of what the project does,
    any dependencies it has, and other useful information about the project.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
- en: Each of these repositories contains a full Unity project. That is, they are
    not simply Unity asset packages you can import into an existing project. Rather,
    you'll clone the entire repository and open it as its own project. This is typical
    for demo projects that may have other package dependencies and require preset
    settings to build and run properly.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
- en: The *AR Foundation Samples* project is my *go-to project* for learning various
    AR Foundation features. It contains many example scenes demoing individual features,
    often in place of detailed documentation elsewhere (see [https://github.com/Unity-Technologies/arfoundation-samples/tree/main/Assets/Scenes](https://github.com/Unity-Technologies/arfoundation-samples/tree/main/Assets/Scenes)).
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
- en: Each scene is extremely simple (almost to a fault) as it has the atomic purpose
    of illustrating a single feature. For example, there are separate scenes for plane
    detection, plane occlusion, and feathered planes. Notably, the project also contains
    a main menu scene (`Assets/Scenes/ARFoundationMenu/Menu`) that launches the other
    scenes when you build them all into a single executable. I recommend starting
    with the scene named **SimpleAR**, which we'll review in a moment.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
- en: Another is the *AR Foundation Demos* project, which contains some more complex
    user scenarios and features not covered in the Samples project. For example, it
    demonstrates the Unity **Onboarding UX** assets, which we'll introduce you to
    in [*Chapter 4*](B15145_04_Final_SB_epub.xhtml#_idTextAnchor077)*, Creating an
    AR User Framework*. It also covers image tracking, mesh placement, language localization,
    and some useful shaders (for example, wireframe, shadows, and fog).
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
- en: 'The *XR Interaction Toolkit Examples* repository contains two separate Unity
    projects: one for VR and another for AR. It is largely a placeholder (in my opinion)
    for things to come.'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
- en: Information – XR Interaction Toolkit
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
- en: The XR Interaction Toolkit from Unity is not covered in this book. It provides
    components and other assets for developing interactive scenes using hand controllers
    and device-supported hand gestures. At the time of writing, XR Interaction Toolkit
    is focused on **Virtual Reality** (**VR**) applications (evidenced by its Examples
    project, which contains seven scenes for VR and just one for AR, which only supports
    mobile AR) but I believe it is a key part of Unity's XR strategy and architecture
    for the future. If you are interested in XR Interaction Toolkit for VR, check
    out my other book, *Unity 2020 Virtual Reality Projects – Third Edition*, from
    Packt Publishing.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
- en: Let's get a copy of the AR Foundation Samples project and take a look at the
    **SimpleAR** scene.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the Samples project
  id: totrans-28
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In this section, you are going to build the *AR Foundation Samples* project
    and run it on your device. First, please clone the project from its GitHub repository
    and open it in Unity, as follows:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
- en: Clone a copy of the project from GitHub to your local machine. The project can
    be found at [https://github.com/Unity-Technologies/arfoundation-samples](https://github.com/Unity-Technologies/arfoundation-samples).
    Please use whatever cloning method you prefer; for example, GitHub Desktop ([https://desktop.github.com/](https://desktop.github.com/))
    or the command line ([https://git-scm.com/download/](https://git-scm.com/download/)).
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the project to **Unity Hub** by selecting **Projects | Add**, navigating
    to the cloned project's root folder, and pressing **Select Folder**.
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the project in Unity. In the **Unity Hub** projects list, if you see a
    yellow warning icon, then the cloned project's Unity version is not currently
    installed on your system. Use the **Unity Version** selection to choose a newer
    version of the editor that you have, preferably of the same major release (for
    example, 20XX).
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the project by selecting it from the Unity Hub projects list.
  id: totrans-33
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If your version of Unity is newer than the project from when it was last saved,
    you will see a prompt asking, "**Do you want to upgrade your project to a newer
    version of Unity?**." Press **Confirm**.
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'One of the scenes, **SimpleAR**, is a basic AR example scene. When run, the
    user will scan their room with their device''s camera and the app will detect
    any horizontal planes that are rendered on the screen. When your user taps on
    one of these planes, a small red cube will be placed in the environment. You can
    walk around the room and the cube will remain where it was placed. If you tap
    again on another location, the cube will be moved there. Let''s briefly review
    this **SimpleAR** scene''s GameObjects:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Scenes/SimpleAR/` folder and double-clicking the `SimpleAR` scene
    file.
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the **Hierarchy** window, you will find two GameObjects of particular interest:
    **AR Session** and **AR Session Origin**.'
  id: totrans-37
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **AR Session Origin** object and examine its components in the **Inspector**
    window. These include **AR Plane Manager**, **AR Point Cloud Manager**, **AR Raycast
    Manager**, and a **Place On Plane** script. We'll explain all of this later in
    this chapter.
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, let''s try to build and run the project:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
- en: Switch to your target platform if necessary. To do this, go to **File | Build
    Settings**, choose your device's platform from the **Platform** list (for example,
    Android or iOS), and click **Switch Platform**.
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most likely, the cloned project's settings have already been configured, but
    let's make sure. From the **Build Settings** window, click the **Player Settings**
    button to open that window and confirm the necessary settings mentioned in [*Chapter
    1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*, Setting Up for AR Development*.
    For example, Android ARCore does not support Vulcan graphics and needs **Nougat
    (API Level 24)** as a minimum requirement.
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Build Settings** window again, notice that the list of scenes in **Scenes
    in Build** starts with the **Menu** scene and contains all the demo scenes from
    this project (the first in the list will be the first scene to load when the app
    loads). You can leave these alone or just pick the one you want in the build.
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure your mobile device is plugged into a USB port on your computer.
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the `Builds/`. Give it a filename (if required) and press **Save**. It
    may take a while to complete this task.
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If all goes well, the project will build, be installed on your device, and launch.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
- en: If you encounter errors while building the project, look at the **Console**
    window in the Unity Editor for messages (in the default layout, it's a tab behind
    the **Project** window). Read the messages carefully, generally starting from
    the top. If the fix is not obvious, do an internet search for the message's text,
    as you can be certain you're probably not the first person to have a similar question!
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
- en: Tip – "Failed to generate ARCore reference image library" error
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
- en: If you receive an error when attempting to build the project that says something
    like **Failed to generate ARCore reference image library**, please make sure there
    are no spaces in the pathname of your project folder! See [https://github.com/Unity-Technologies/arfoundation-samples/issues/119](https://github.com/Unity-Technologies/arfoundation-samples/issues/119)
    for more information.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
- en: 'The main menu will be displayed, as shown in the following screen capture (left
    panel):'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – Screenshot of my phone running the arfoundation-samples app
    and SimpleAR scene'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.01-arf-samples-screenshot-twin.jpg.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – Screenshot of my phone running the arfoundation-samples app and
    SimpleAR scene
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
- en: A cool thing about AR Foundation (and this project) is that it can detect the
    capabilities of the device it is running on at runtime. This means that the buttons
    in the main menu will be disabled when AR Foundation detects that the features
    demoed in that scene are not supported on the device. (The device I'm using in
    the preceding screen capture is an Android phone, so some iOS-only feature scenes
    are disabled).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
- en: Click the **Simple AR** button to open that scene. You should see a camera video
    feed on your device's screen. Move your phone slowly in different directions and
    closer/away. As it scans the environment, feature points and planes will be detected
    and rendered on the screen. Tap one of the planes to place a cube on the scene,
    as shown in the right-hand panel of the preceding screen capture.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
- en: Some of the assets and scripts in the Samples project can be useful for building
    our own projects. I'll show you how to export them now.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
- en: Exporting the sample assets for reuse
  id: totrans-56
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Unity offers the ability to share assets between projects using `.unitypackage`
    files. Let''s export the assets from the AR Foundation Samples project for reuse.
    One trick I like to do is move all the sample folders into a root folder first.
    With the *arfoundation-samples* project open in Unity, please perform the following
    steps:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets` named `ARF-samples` by clicking the **+** icon (top left of
    the window) and selecting **Folder**.
  id: totrans-58
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the following folders into the `ARF-samples` one: `Materials`, `Meshes`,
    `Prefabs`, `Scenes`, `Scripts`, `Shaders`, and `Textures`. That is, move all of
    them but leave the `XR` folder at the root.'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click on the `ARF-samples` folder and select **Export Package**.
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Exporting Package** window will open. Click **Export**.
  id: totrans-61
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Choose a directory outside this project's root, name the file (for example,
    `arf-samples`), and click **Save**.
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Assets/ARF-samples/` folder in the **Project** window is shown in the
    following screenshot:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – The Samples assets folder being exported to a .unitypackage
    file'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.02-arf-samples-folders.jpg)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – The Samples assets folder being exported to a .unitypackage file
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
- en: You can close the `arfoundation-samples` project now if you want. You now have
    an asset package you can use in other projects.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
- en: Tip – Starting a New Project by Copying the Samples Project
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
- en: An alternative to starting a new Unity AR project from scratch is to duplicate
    the *arfoundation-samples* project as the starting point for new AR projects.
    To do that, from your Windows Explorer (or macOS Finder), duplicate the entire
    project folder and then add it to Unity Hub. This way, you get all the example
    assets and demo scenes in one place, and it's set up with reasonable default project
    settings. I often do this, especially for quick demos and small projects.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
- en: Next, we are going to import the Samples assets into your Unity project and
    build the given SimpleAR scene.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
- en: Building the SimpleAR scene in your own project
  id: totrans-71
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As you will see later in this chapter, the Samples project includes some assets
    we can use in your own projects, saving you time and effort, especially at the
    start. We will import `unitypackage`, which we just exported, and then build the
    given SimpleAR scene as another test to verify that you're set up to build and
    run AR applications.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
- en: Creating a new project
  id: totrans-73
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you already have a Unity project set up for AR development, as detailed in
    [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*, Setting Up for
    AR Development*, you can open it in Unity and skip this section. If not, perform
    the following steps, which have been streamlined for your convenience. If you
    require more details or explanations, please revisit [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*,
    Setting Up for AR Development*.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
- en: 'To create and set up a new Unity project with AR Foundation, Universal Render
    Pipeline, and the new Input System, here are the abbreviated steps:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
- en: '*Create a new project* by opening `MyARProject`, and clicking **Create**.'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Open your project* in the Unity Editor by selecting it from Unity Hub''s **Projects**
    list.'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Set your target platform* by going to **File | Build Settings**, choosing
    **Android** or **iOS** from the **Platform** list, and clicking **Switch Platform**.'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Set up the Player Settings* according to [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*,
    Setting Up for AR Development*, and/or your device''s documentation by going to
    the **Edit | Project Settings | Player** window. For example, Android ARCore does
    not support Vulcan graphics and needs **Nougat (API Level 24)** as a minimum requirement.'
  id: totrans-79
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Install an XR plugin* by going to **Edit | Project Settings | XR Plugins Manager
    | Install XR Plugin Management**. Then, check the checkbox for your device''s
    **Plug-in Provider**.'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Install AR Foundation* by going to `ar` using the search input field, selecting
    the **AR Foundation** package, and clicking **Install**.'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Install the Input System package* by going to `input` using the search input
    field, selecting the **Input System** package, and clicking **Install**.'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When prompted to enable the input backend, you can say **Yes**, but we'll actually
    change this setting to **Both** in the next topic when we import the Sample assets
    into the project.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Add the AR Background Renderer* to the URP Forward renderer by locating the
    `Assets/Settings/` folder. In its **Inspector** window, click **Add Renderer Feature**
    and select **AR Background Renderer Feature**.'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You might want to bookmark these steps for future reference. Next, we'll import
    the Sample assets we exported from the AR Foundation Samples project.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
- en: Importing the Sample assets into your own project
  id: totrans-86
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now that you have a Unity project set up for AR development, you can import
    the sample assets into your project. With your project open in Unity, perform
    the following steps:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
- en: Import the package from the main menu by selecting **Assets | Import Package
    | Custom Package**.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Locate the `arf-samples.unitypackage` file on your system and click **Open**.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The **Import Unity Package** window will open. Click **Import**.
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you created your project using the *Universal Render Pipeline* (or HDRP),
    rather than using the built-in render pipeline like we did, you need to convert
    the imported materials. Select **Edit | Render Pipeline | URP | Upgrade Project
    Materials to URP Materials**. Then, when prompted, click **Proceed**.
  id: totrans-91
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Then, go to **Player Settings** using **Edit | Project Settings | Player**,
    select **Configuration | Active Input Handling**, and choose **Both**. Then, when
    prompted, click **Apply**.
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We will use the new Input System for projects in this book. However, some demo
    scenes in the Samples project use the old Input Manager. If you choose **Input
    System Package (New)** for **Active Input Handling**, then those demo scenes may
    not run.
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Hopefully, all the assets will import without any issues. However, there may
    be some errors while compiling the Samples scripts. This could happen if the Samples
    project is using a newer version of AR Foundation than your project and it is
    referencing API functions for features your project does not have installed. The
    simplest solution is to upgrade the version of AR Foundation to the same or later
    version as the Samples project. To do so, perform the following steps:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
- en: To see error messages, open the **Console** window using its tab or selecting
    **Window | General | Console**.
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Suppose that, in my project, I have additional errors because I have installed
    *AR Foundation 4.0.12* but the Samples project uses *version 4.1.3* features,
    which are not available in my version. Here, I'll go to **Window | Package Manager**,
    select the **AR Foundation** package, click **See Other Versions**, select the
    4.1.3 version, and then click the **Update to 4.1.3** button.
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The project also might be using preview versions of packages. Enable preview
    packages by selecting **Edit | Project Settings | Package Manager | Enable preview
    packages**.
  id: totrans-97
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure the ARCore XR plugin and/or AR Kit XR plugin version matches the version
    of the AR Foundation package the project is using.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Another message you might see is that some Samples scripts require that you
    enable "unsafe" code in the project. Go to **Project Settings | Player | Script
    Compilation | Allow 'unsafe' code** and check the checkbox.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This is not as threatening as it may sound. "Unsafe" code usually means that
    something you installed is calling C++ code from the project that is *potentially*
    unsafe from the compiler's point of view. Enabling unsafe code in Unity is usually
    not a problem unless, for example, you are publishing WebGL to a WebPlayer, which
    we are not.
  id: totrans-100
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Finally, you can verify your setup by building and running the SimpleAR scene,
    this time from your own project. Perform the following steps:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
- en: Open the `ARF-samples/Scenes/SimpleAR/` folder and double-clicking the **SimpleAR**
    scene file.
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Build Settings** window by going to **File | Build Settings**.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Scenes in Build** list, click the **Add Open Scenes** button and uncheck
    all the scenes in the list other than the SimpleAR one.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure your device is connected via USB.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the `Builds/`. Give it a filename (if required) and press **Save**. It
    may take a while to complete this task.
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The app should successfully build and run on your device. If you encounter any
    errors, please review each of the steps detailed in this chapter and [*Chapter
    1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*, Setting Up for AR Development*.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
- en: When the app launches, as described earlier, you should see a camera video feed
    on your screen. Move your phone slowly in different directions and closer/away.
    As it scans the environment, feature points and planes will be detected and rendered
    on the screen. Tap one of these planes to place a cube on the scene.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
- en: Your project is now ready for AR development!
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
- en: Starting a new, basic AR scene
  id: totrans-110
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we'll create a scene very similar to `SimpleAR` (actually,
    more like the Samples scene named `InputSystem_PlaceOnPlane`) but we will start
    with a new empty scene. We'll add AR Session and AR Session Origin objects provided
    by AR Foundation to the scene hierarchy, and then add trackable feature managers
    for planes and point clouds. In the subsequent sections of this chapter, we'll
    set up an Input System action controller, write a C# script to handle any user
    interaction, and create a prefab 3D graphic to place in the scene.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
- en: 'So, start the new scene by performing the following steps:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene by going to **File | New Scene**.
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If prompted, choose the **Basic (Built-in)** template. Then, click **Create**.
  id: totrans-114
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unity allows you to use a Scene template when creating a new scene. The one
    named **Basic (Built-in)** is comparable to the default new scene in previous
    versions of Unity.
  id: totrans-115
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Delete **Main Camera** from the **Hierarchy** window by using *right-click*
    | **Delete** (or the *Del* key on your keyboard).
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an AR Session by selecting **GameObject** from the main menu, then **XR
    | AR Session**.
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add an AR Session Origin by selecting **GameObject** from the main menu, then
    **XR | AR Session Origin**.
  id: totrans-118
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Unfold **AR Session Origin** and select its child; that is, **AR Camera**. In
    the **Inspector** window, use the **Tag** selector at the top left to set it as
    our **MainCamera**. (This is not required but it is a good practice to have one
    camera in the scene tagged as **MainCamera**.)
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene using `Assets/Scenes/` folder, name it `BasicARScene`, and click
    **Save**.
  id: totrans-120
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Your scene Hierarchy should now look as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Starting a scene Hierarchy'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.03-starting-hierarchy.jpg)'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Starting a scene Hierarchy
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
- en: We can now take a closer look at the objects we just added, beginning with the
    AR Session object.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: Using AR Session
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **AR Session** object is responsible for enabling and disabling augmented
    reality features on the target platform. When you select the **AR Session** object
    in your scene **Hierarchy**, you can see its components in the **Inspector** window,
    as shown in the following screenshot:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The AR Session object''s Inspector window'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.04-arsession-inspector.jpg)'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – The AR Session object's Inspector window
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
- en: Each AR scene must include one (and only one) AR Session. It provides several
    options. Generally, you can leave these as their default values.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
- en: The **Attempt Update** option instructs the AR Session to try and install the
    underlying AR support software on the device if it is missing. This is not required
    for all devices. iOS, for example, does not require any additional updates if
    the device supports AR. On the other hand, to run AR apps on Android, the device
    must have the ARCore services installed. Most AR apps will do this for you if
    they are missing, and that is what the **Attempt Update** feature of **AR Session**
    does. If necessary, when your app launches and support is missing or needs an
    update, AR Session will attempt to install *Google Play Services for AR* (see
    [https://play.google.com/store/apps/details?id=com.google.ar.core](https://play.google.com/store/apps/details?id=com.google.ar.core)).
    If the required software is not installed, then AR will not be available on the
    device. You could choose to disable automatic updates and implement them yourself
    to customize the user onboarding experience.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
- en: Note
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
- en: The **Match Frame Rate** option in the **Inspector** window is obsolete. Ordinarily,
    you would want the frame updates of your apps to match the frame rate of the physical
    device, and generally, there is no need to tinker with this. If you need to tune
    it, you should control it via scripting (see [https://docs.unity3d.com/ScriptReference/Application-targetFrameRate.html](https://docs.unity3d.com/ScriptReference/Application-targetFrameRate.html)).
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
- en: 'Regarding **Tracking Mode**, you will generally leave it set to **Position
    and Rotation**, as this specifies that your VR device is tracking in the physical
    world 3D space using both its XYZ position and its rotation around each axis.
    This is referred to as *6DOF*, for six-degrees-of-freedom tracking, and is probably
    the behavior that you expect. But for face tracking, for example, we should set
    it to **Rotation Only**, as you''ll see in [*Chapter 9*](B15145_09_Final_SB_epub.xhtml#_idTextAnchor224)*,
    Selfies: Making Funny Faces*.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
- en: The **AR Session** GameObject also has an **AR Input Manager** component that
    manages our **XR Input Subsystem** for tracking the device's pose in a physical
    3D space. It reads input from the AR Camera's **AR Pose Driver** (discussed shortly).
    There are no options for the component, but this is required for device tracking.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
- en: We also added an AR Session Origin GameObject to the Hierarchy. Let's look at
    that next.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
- en: Using AR Session Origin
  id: totrans-138
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **AR Session Origin** will be the root object of all trackable objects.
    Having a root origin keeps the Camera and any trackable objects in the same space
    and their positions relative to each other. This *session* (or *device) space*
    includes the AR Camera and any *trackable* features that have been detected in
    the real-world environment by the AR software. Otherwise, detected features, such
    as planes, won't appear in the correct place relative to the Camera.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
- en: Tip – Scaling Virtual Scenes in AR
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: If you plan to scale your AR scene, place your game objects as children of AR
    Session Origin and then scale the parent AR Session Origin transform, rather than
    the child objects themselves. For example, consider a world-scale city map or
    game court resized to fit on a tabletop. Don't scale the individual objects in
    the scene; instead, scale everything by resizing the root session origin object.
    This will ensure the other Unity systems, especially physics and particles, retain
    their scale relative to the camera space. Otherwise, things such as gravity, calculated
    as meters per second, and particle rendering could mess up.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
- en: 'When you select the **AR Session Origin** object in your scene **Hierarchy**,
    you can see its components in the **Inspector** window, as shown in the following
    screenshot:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – The AR Session object''s Inspector window'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.05-arsessionorigin-inspector.jpg)'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – The AR Session object's Inspector window
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: 'At the time of writing, the default AR Session Origin object simply has an
    **AR Session Origin**     component. We''ll want to build out its behavior by adding more components in
    a moment.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
- en: The Session Origin's **Camera** property references its own child **AR Camera**
    GameObject, which we'll look at next.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
- en: Using the AR Camera
  id: totrans-148
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The **AR Camera** object is a child of AR Session Origin. Its **Inspector**
    window is shown in the following screenshot:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – The AR Camera object''s Inspector window'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.06-arcamera-inspector.jpg)'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – The AR Camera object's Inspector window
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
- en: During setup, we tagged the AR Camera as our `Camera.main`, which is a shortcut
    for the find by tag name.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
- en: As its name implies, the AR Camera object includes a `0.1, 20`) meters. In AR
    apps, it's not unusual to place the device within inches of a virtual object,
    so we wouldn't want it to be clipped. Conversely, in an AR app, if you walk more
    than 20 meters away from an object that you've placed in the scene, you probably
    don't need it to be rendered at all.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
- en: Importantly, rather than using a Skybox, as you'd expect in non-AR scenes, the
    camera's **Background** is set to a **Solid** black color. This means the background
    will be rendered using the camera's video feed. This is controlled using the **AR
    Camera Background** component of the AR Camera. In an advanced application, you
    can even customize how the video feed is rendered, using a custom video *material*
    (this topic is outside the scope of this book). Similarly, on a wearable AR device,
    a black camera background is required, but with no video feed, to mix your virtual
    3D graphics atop the visual see-through view.
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
- en: 'The video feed source is controlled using the AR Camera Manager component.
    You can see, for example, that **Facing Direction** can be changed from **World**
    to **User** for a selfie face tracking app (see [*Chapter 9*](B15145_09_Final_SB_epub.xhtml#_idTextAnchor224)*,
    Selfies: Making Funny Faces*).'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
- en: The **Light Estimation** options are used when you want to emulate real-world
    lighting when rendering your virtual objects. We'll make use of this feature later
    in this chapter.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
- en: You also have the option to disable **Auto Focus** if you find that the camera
    feature is inappropriate for your AR application.
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
- en: Tip – When to Disable Camera Auto Focus for AR
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
- en: Ordinarily, I disable Auto Focus for AR applications. When the software uses
    the video feed to help detect planes and other features in the environment, it
    needs a clear, consistent, and detailed video feed, not one that may be continually
    changing for Auto Focus. That would make it difficult to process AR-related algorithms
    accurately to decode their tracking. On the other hand, a selfie face tracking
    app may be fine with Auto Focus enabled and could improve the user experience
    when the area behind the user loses focus due to depth of field.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
- en: The **AR Pose Driver** component is responsible for updating the AR Camera's
    transform as it tracks the device in the real world. (There are similar components
    for VR headsets and hand controllers, for instance.) This component relies on
    the XR plugin and the Input XR Subsystem to supply the positional tracking data
    (see [https://docs.unity3d.com/Manual/XRPluginArchitecture.html](https://docs.unity3d.com/Manual/XRPluginArchitecture.html)).
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
- en: Our next step is to add Plane and Point Cloud visualizers to the scene.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
- en: Adding Plane and Point Cloud managers
  id: totrans-163
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When your application runs, you'll ask the user to scan the room for the AR
    software to detect features in the environment, such as depth points and flat
    planes. Usually, you'll want to show these to the user as they're detected. We
    do this by adding the corresponding feature managers to the AR Session Origin
    game object. For example, to visualize planes, you'll add an **AR Plane Manager**
    to the AR Session Origin object, while to visualize point clouds, you'll add an
    **AR Point Cloud Manager**.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
- en: 'AR Foundation supports detecting and tracking the following features:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
- en: '*Anchor*: A fixed pose (consisting of location and rotation) in the physical
    environment (controlled by the AR Anchor Manager component). This is also known
    as a Reference Point.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Reflection Probe*: Environment reflection probes for rendering shiny surface
    materials (controlled by the AR Environment Probe Manager component).'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Face*: A human face detected by the AR device (controlled by the AR Face Manager
    component).'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Human Body*: A trackable human body and the body''s skeleton (controlled by
    the AR Human Body Manager component).'
  id: totrans-169
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Image*: A 2D image that has been detected and tracked in the environment''s
    AR Tracked Image Manager component.'
  id: totrans-170
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Participant*: Another user (device) in a collaborative session.'
  id: totrans-171
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Plane*: A flat plane, usually horizontally or vertically inferred from the
    point cloud (controlled by the AR Plane Manager component).'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Point Cloud*: A set of depth points detected by the AR device (controlled
    by the AR Point Cloud Manager component).'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Object*: A 3D object detected and tracked in the environment (controlled by
    the AR Tracked Object Manager component).'
  id: totrans-174
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Not all of these are supported on every platform. See the documentation for
    your current version of AR Foundation (for example, visit [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/index.html#platform-support](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/index.html#platform-support)
    and select your version at the top left). We will be using many of these in various
    projects throughout this book. Here, we will use the Plane and Point Cloud trackables.
    Please perform the following steps to add them:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
- en: Select the **AR Session Origin** object from the **Hierarchy** window.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Point Cloud Manager by selecting `ar` in the search input field, then
    clicking **AR Point Cloud Manager**.
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a Plane Manager by selecting `ar` in the search input field, and clicking
    **AR Plane Manager**.
  id: totrans-178
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the AR Plane Manager, change **Detection Mode** to only horizontal planes
    by selecting **Nothing** (to clear the list), then selecting **Horizontal**.
  id: totrans-179
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You''ll notice that the Point Cloud Manager has an empty slot for the Point
    Cloud Prefab visualizer and that the Plane Manager has an empty slot for the Plane
    Prefab visualizer. We''ll use prefabs from the Samples project, as follows:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: In the **Inspector** window, go to **AR Point Cloud Manager | Point Cloud Prefab**
    and press the *doughnut* icon on the right-hand side of the field to open the
    **Select GameObject** dialog box.
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Assets** tab and double-click the **AR Point Cloud Visualizer**
    prefab.
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are alternative point cloud visualizer prefabs you might like to try out
    also, such as **AR Point Cloud Debug Visualizer** and **AllPointCloudPointsPrefab**.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Likewise, for **AR Plane Manager | Plane Prefab**, press the *doughnut* icon
    on the right-hand side of the field to open the **Select GameObject** dialog box.
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Assets** tab and double-click **AR Feathered Plane**.
  id: totrans-185
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: There are alternative plane visualizer prefabs to try out also, such as **AR
    Plane Debug Visualizer**, **AR Feathered Plane Fade**, and **CheckeredPlane**.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Save the scene by going to **File | Save**.
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We're using the visualizer prefabs we got from the Samples project. Later in
    this chapter, we'll talk more about prefabs, take a closer look at the visualizer
    ones, and learn how to edit them to make our own custom visualizers. First, we'll
    add the AR Raycast Manager to the scene.
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
- en: Adding AR Raycast Manager
  id: totrans-189
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There''s another component I know we''re going to need soon, known as **AR
    Raycast Manager**. This will be used by our scripts to determine if a user''s
    screen touch corresponds to a 3D trackable feature detected by the AR software.
    We''re going to use it in our script to place an object on a plane. Perform the
    following steps to add it to the scene:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
- en: Select the **AR Session Origin** object from the **Hierarchy** window.
  id: totrans-191
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select `ar` in the search input field, and click **AR Raycast Manager**.
  id: totrans-192
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The **AR Session Origin** GameObject with the manager components we added now
    looks like this in the **Inspector** window:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/Figure_2.07-arorigin-withmanagers.jpg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
- en: Figure 2.7 – AR Session Origin with various manager components
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
- en: One more thing that's handy to include is light estimation, which helps with
    rendering your virtual objects more realistically.
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
- en: Adding Light Estimation
  id: totrans-197
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By adding a Light Estimation component to your Directional Light source, the
    AR camera can use this information when rendering your scene to try and match
    the scene's lighting more closely to the real-world environment.
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
- en: 'To add light estimation, perform the following steps:'
  id: totrans-199
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select the **Directional Light** object.
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `light estimation`, and add the **Basic Light Estimation** component.
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, find **AR Camera** (child of AR Session Origin),
    drag it into the **Inspector** window, and drop it onto the **Light Estimation
    | Camera Manager** slot.
  id: totrans-202
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select **AR Camera**, then set **AR Camera Manager
    | Light Estimation** to **Everything**. Note that not all platforms support all
    light estimation capabilities, but using the **Everything** flags will have them
    use all of the ones that are available at runtime.
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save your work by going to **File | Save**.
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Good! I think we should try to build and run what we have done so far and make
    sure it's working.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the scene
  id: totrans-206
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Currently, the scene initializes an AR Session, enables the AR camera to scan
    the environment, detects points and horizontal planes, and renders these on the
    screen using visualizers. Let''s build the scene and make sure it runs:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Build Settings** window by going to **File | Build Settings**.
  id: totrans-208
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Scenes in Build** list, click the **Add Open Scenes** button and uncheck
    all the scenes in the list other than this current scene (mine is named **BasicARScene**).
  id: totrans-209
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure your device is connected to your computer via USB.
  id: totrans-210
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the `Builds/`. Give it a filename (if required) and press **Save**. It
    may take a while to complete this task.
  id: totrans-211
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The app should successfully build and run on your device. If you encounter any
    errors, please read the error messages carefully in the **Console** window. Then,
    review each of the setup steps detailed in this chapter and [*Chapter 1*](B15145_01_Final_SB_epub.xhtml#_idTextAnchor013)*,
    Setting Up for AR Development*.
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
- en: When the app launches, you should see a video feed on your screen. Move the
    device slowly in different directions and closer/away. As it scans the environment,
    feature points and planes will be detected and rendered on the screen using the
    visualizers you chose.
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's add the ability to tap on one of the planes to instantiate a 3D
    object there.
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
- en: Placing an object on a plane
  id: totrans-215
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We will now add the ability for the user to tap on a plane and place a 3D virtual
    object in the scene. There are several parts to implementing this:'
  id: totrans-216
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a Place Object input action when the user taps the screen.
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing a PlaceObjectOnPlane script that responds to the input action and places
    an object on the plane.
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Determining which plane and where to place the object using AR Raycast Manager.
  id: totrans-219
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Importing a 3D model and making it a prefab for placing in this scene.
  id: totrans-220
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's begin by creating an input action for a screen tap.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
- en: Setting up a PlaceObject input action
  id: totrans-222
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We are going to use the Unity Input System package for user input. If the Input
    System is new to you, the steps in this section may seem complicated, but only
    because of its great versatility.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
- en: The Input System lets you define **Actions** that separate the logical meaning
    of the input from the physical means of the input. Using named actions is more
    meaningful to the application and programmers.
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
- en: Note – Input System Tutorial
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
- en: For a more complete tutorial on using the Input System package, see [https://learn.unity.com/project/using-the-input-system-in-unity](https://learn.unity.com/project/using-the-input-system-in-unity).
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
- en: Here, we will define a **PlaceObject** action that is bound to screen tap input
    data. We'll set this up now, and then use this input action in the next section
    to find the AR plane that was tapped and place a virtual object there.
  id: totrans-227
  prefs: []
  type: TYPE_NORMAL
- en: 'Before we begin, I will assume you have already imported the **Input System**
    package via **Package Manager** and set **Active Input Handing** to **Input System
    Package** (or **Both**) in **Player Settings**. Now, follow these steps:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
- en: In the `Inputs` using *right-click* `_App/` folder.
  id: totrans-229
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create an input action controller asset by *right-clicking* inside the `Inputs`
    folder, then selecting `AR Input Actions`.
  id: totrans-230
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click **Edit Asset** to open its editor window.
  id: totrans-231
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the leftmost `ARTouchActions`.
  id: totrans-232
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the middle `PlaceObject` using *right-click* | **Rename**.
  id: totrans-233
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the right-hand side **Properties** panel, set **Action Type** to **Value**.
  id: totrans-234
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set its **Control Type** to **Vector 2**.
  id: totrans-235
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the middle **Actions** panel, click the child **<No Binding>** item to add
    a binding.
  id: totrans-236
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the right-hand side **Properties** panel, under **Binding**, using the **Path**
    select list, choose **TouchScreen | Primary Touch | Position**.
  id: totrans-237
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: At the top of the window, click **Save Asset** (unless the **Auto-Save** checkbox
    is checked).
  id: totrans-238
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With that, we''ve created a data asset named `Vector2`) with the X, Y values
    in pixel coordinates. The input action asset is shown in the following screenshot:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – Our AR Input Actions set up for screen taps'
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.08-ar-input-action.jpg)'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – Our AR Input Actions set up for screen taps
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the input actions to the scene. This can be done via a Player
    Input component. For our AR scene, we''ll add a Player Input component to the
    AR Session Origin, as follows:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select the **AR Session Origin** object.
  id: totrans-244
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In its **Inspector** window, click **Add Component | Input | Player Input**.
  id: totrans-245
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Inputs/` folder into the **Player Input | Actions** slot in the **Inspector**
    window.
  id: totrans-246
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Leave `On`" prefix (for example, `OnPlaceObject`) and receives an `InputValue`
    argument ([https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputValue.html](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputValue.html)).
  id: totrans-247
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Broadcast Messages*: Like Send Messages, Broadcast Messages will send messages
    to components on this GameObject *and all its children* ([https://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html](https://docs.unity3d.com/ScriptReference/Component.BroadcastMessage.html)).'
  id: totrans-248
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Invoke Unity Events*: You can set event callback functions using the Inspector
    or in scripts ([https://docs.unity3d.com/Manual/UnityEvents.html](https://docs.unity3d.com/Manual/UnityEvents.html)).
    The callback function receives an `InputAction.CallbackContext` argument ([https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputAction.CallbackContext.html)](https://docs.unity3d.com/Packages/com.unity.inputsystem@1.1/api/UnityEngine.InputSystem.InputAction.CallbackContext.html)).'
  id: totrans-249
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '*Invoke C# Events*: You can set event listeners in scripts ([https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/](https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/events/)).'
  id: totrans-250
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: To learn more about the Player Input component, see [https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/api/UnityEngine.InputSystem.PlayerInput.html](mailto:https://docs.unity3d.com/Packages/com.unity.inputsystem@1.0/api/UnityEngine.InputSystem.PlayerInput.html).
  id: totrans-251
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: I've decided to use `OnPlaceObject` function, which we'll do next. But first,
    I'll provide a quick introduction to Unity C# programming.
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Unity C# programming and the MonoBehaviour class
  id: totrans-253
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Writing C# scripts is an essential skill for every Unity developer. You don''t
    need to be an expert programmer, but you cannot avoid writing some code to make
    your projects work. If you are new to coding, you can simply follow the instructions
    provided here, and over time, you''ll get more comfortable and proficient. I also
    encourage you to go through some of the great beginner tutorials provided by Unity
    ([https://learn.unity.com/](https://learn.unity.com/)) and others, including the
    following:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
- en: '**Coding in C# in Unity for Beginners**: https://unity3d.com/learning-c-sharp-in-unity-for-beginners'
  id: totrans-255
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Working with Scripts**: [https://learn.unity.com/tutorial/working-with-scripts](https://learn.unity.com/tutorial/working-with-scripts)'
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Beginner Scripting**: https://learn.unity.com/project/beginner-gameplay-scripting'
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Given that, I will offer some brief explanations as we work through this section.
    But I'll assume that you have at least a basic understanding of C# language syntax,
    common programming vocabulary (for example, *class*, *variable*, and *function*),
    using an editor such as Visual Studio, and how to read error messages that may
    appear in your **Console** window due to typos or other common coding mistakes.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
- en: 'We''re going to create a new script named `PlaceObjectOnPlane`. Then, we can
    attach this script as a component to a GameObject in the scene. It will then appear
    in the object''s **Inspector** window. Let''s begin by performing the following
    steps:'
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
- en: In the `Scripts/` folder (mine is `Assets/_App/Scripts/`), *right-click* it,
    and select **Create | C# Script**.
  id: totrans-260
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the file `PlaceObjectOnPlane` (no spaces nor other special characters are
    allowed in the name, and it should start with a capital letter).
  id: totrans-261
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This creates a new C# script with the `.cs` file extension (although you don't
    see the extension in the **Project** window).
  id: totrans-262
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Double-click the **PlaceObjectOnPlane** file to open it in your code editor.
    By default, my system uses Microsoft Visual Studio.
  id: totrans-263
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As you can see in the following initial script content of the template, the
    `PlaceObjectOnPlane.cs` file declares a C# class, `PlaceObjectsOnPlane`, that
    has the same name as the `.cs` file (the names *must* match; otherwise, it will
    cause compile errors in Unity):'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first three lines in this script have a `using` directive, which declares
    an SDK library, or namespace, that will be used in the script. When a script references
    external symbols, the compiler needs to know where to find them. In this case,
    we're saying that we'll potentially be using standard .NET system libraries for
    managing sets of objects (*collections*). And here, we are using the UnityEngine
    API.
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
- en: One of the symbols defined by *UnityEngine* is the `PlaceObjectsOnPlane` class
    is declared as a subclass of `MonoBehaviour`. (Beware its British spelling, "iour").
    Scripts attached to a GameObject in your scene must be a subclass of `MonoBehaviour`,
    which provides a litany of features and services related to the GameObject where
    it is attached.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
- en: For one, `MonoBehaviour` provides hooks into the GameObject life cycle and the
    Unity `Start()` function will automatically be called. This is a good place to
    add some initialization code.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
- en: The Unity game engine's main purpose is to render the current scene view every
    frame, perhaps 60 times per second or more. Each time the frame is updated, your
    `Update()` function will automatically be called. This is where you put any runtime
    code that needs to be run every frame. Try to keep the amount of work that's done
    in `Update()` to a minimum; otherwise, your app may feel slow and sluggish.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
- en: 'You can learn more about the MonoBehaviour class here: [https://docs.unity3d.com/ScriptReference/MonoBehaviour.html](https://docs.unity3d.com/ScriptReference/MonoBehaviour.html).
    To get a complete picture of the GameObject and MonoBehaviour scripts'' life cycles,
    take a look at this flowchart here: [https://docs.unity3d.com/Manual/ExecutionOrder.html](https://docs.unity3d.com/Manual/ExecutionOrder.html).'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
- en: We can now write our script. Since this is the first script in this book, I'll
    present it slowly.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
- en: Writing the PlaceObjectOnPlane script
  id: totrans-272
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The purpose of the `PlaceObjectOnPlane` script is to place a virtual object
    on the AR plane when and where the user taps. We''ll outline the logic first (in
    C#, any text after `//` on the same line is a comment):'
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  id: totrans-274
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As it turns out, in this script, there is no need for an `Update` function as
    it is only used for frame updates, which this script can ignore.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
- en: This script implements `OnPlaceObject`, which is called when the user taps the
    screen. As we mentioned previously, the Player Input component we added to the
    AR Session Origin uses the `OnPlacedObject` for the `InputValue`. Notice that
    I also added a line using `UnityEngine.InputSystem;`, which defines the `InputValue`
    class.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to get the screen touch position from the input value we passed
    in. Add the following code, which declares and assigns it to the `touchPosition`
    local variable:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The next step is to figure out if the screen touch corresponds to a plane that
    was detected in the AR scene. AR Foundation provides a solution by using the AR
    Raycast Manager component that we added to the AR Session Origin GameObject earlier.
    We''ll use it in our script now. Add these lines to the top of your script:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, inside the `OnPlaceObject` function, add the following code:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  id: totrans-282
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Firstly, we get a reference to the `raycaster`. We declare and initialize a
    list of `ARRaycastHit`, which will be populated when the raycast finds something.
    Then, we call `raycaster.Raycast()`, passing in the screen's `touchPosition`,
    and a reference to the `hits` list. If it finds a plane, it'll return `true` and
    populate the `hits` list with details. The third argument instructs `raycaster.Raycast`
    on what kinds of trackables can be hit. In this case, `PlaneWithinPolygon` filters
    for 2D convex-shaped planes.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
- en: Information – For More Information on AR Raycasting
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
- en: For more information on using ARRaycastManager, see [https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/raycast-manager.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arfoundation@4.1/manual/raycast-manager.html).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
- en: For a list of trackable types you can pass in, see [https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.1/api/UnityEngine.XR.ARSubsystems.TrackableType.html](mailto:https://docs.unity3d.com/Packages/com.unity.xr.arsubsystems@4.1/api/UnityEngine.XR.ARSubsystems.TrackableType.html).
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
- en: 'The code inside the `if` statement will only be executed if `raycaster.Raycast`
    returns `true`; that is, if the user had tapped a location on the screen that
    casts to a trackable plane in the scene. In that case, we must create a 3D GameObject
    there. In Unity, creating a new GameObject is referred to as **instantiating**
    the object. You can read more about it here: [https://docs.unity3d.com/Manual/InstantiatingPrefabs.html](https://docs.unity3d.com/Manual/InstantiatingPrefabs.html).'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s declare a variable, `placedPrefab`, to hold a reference to the
    prefab that we want to instantiate on the selected plane. Using the `[SerializedField]`
    directive permits the property to be visible and settable in the Unity Inspector.
    We''ll also declare a `private` variable, `spawnedObject`, that holds a reference
    to the instantiated object. Add the following code to the top of the class:'
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  id: totrans-289
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now, inside the `if` statement, we will instantiate a new object if this is
    the first time the user has tapped the screen, and then assign it to `spawnedObject`.
    If the object had already been spawned and the user taps the screen again, we''ll
    move the object to the new location instead. Add the following highlighted code:'
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  id: totrans-291
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: '`Raycast` populates a list of hit points, as there could be multiple trackable
    planes in line where the user has tapped the screen. They''re sorted closest to
    furthest, so in our case, we''re only interested in the first one, `hits[0]`.
    From there, we get the point''s `Pose`, a simple structure that includes 3D position
    and rotation values. These, in turn, are used when placing the object.'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
- en: After that, save the script file.
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, back in Unity, we''ll attach our script as a component to **AR Session
    Origin** by performing the following steps:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
- en: First, check the **Console** window (using the **Console** tab or **Window |
    General | Console**) and ensure there are no compile errors from the script. If
    there are, go back to your code editor and fix them.
  id: totrans-295
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the **Hierarchy** window, select the **AR Session Origin** object.
  id: totrans-296
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `placedPrefab` variable we declared in the script. Let's populate it
    with the red cube prefab provided by the Samples assets.
  id: totrans-297
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `ARF-samples/Prefabs/` folder.
  id: totrans-298
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **AR Placed Cube** prefab into the **Inspector** window, on the **Place
    Object On Plane | Placed Prefab** slot.
  id: totrans-299
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene by going to **File | Save**.
  id: totrans-300
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Our script, as a component on the AR Session Origin GameObject, should now
    look as follows:'
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – PlaceObjectOnPlane as a component with its Placed Prefab slot
    populated'
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.09-placeobjectonplane-inspector.jpg)'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – PlaceObjectOnPlane as a component with its Placed Prefab slot populated
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
- en: Let's try it! We're now ready to build and run the scene.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
- en: Building and running the scene
  id: totrans-306
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''ve built the scene before, in the previous section, you can go to **File
    | Build And Run** to start the process. Otherwise, perform the following steps
    to build and run the scene:'
  id: totrans-307
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Build Settings** window by going to **File | Build Settings**.
  id: totrans-308
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For the **Scenes in Build** list, click the **Add Open Scenes** button and uncheck
    all the scenes in the list other than this one (mine is named **BasicARScene**).
  id: totrans-309
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure your device is connected via USB.
  id: totrans-310
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Press the `Builds/`. Give it a filename (if required) and press `Update()` into
    `Start()` (for example, initialize the `raycaster` variable).
  id: totrans-311
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Avoid allocating new memory in `Update()` to avoid memory fragmentation and
    garbage collection (for example, initialize the `hits` list as a class variable).
  id: totrans-312
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The modified script is shown in the following code block. The changed code
    is highlighted, beginning with the top part, which contains the new class variables
    and the `Start()` function:'
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  id: totrans-314
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now, add the `OnPlacedObject` function, as follows:'
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  id: totrans-316
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: if (raycaster.Raycast(touchPosition, hits, TrackableType.PlaneWithinPolygon))
  id: totrans-317
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  id: totrans-318
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Please save the script, then build and run it one more time to verify it still
    works.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
- en: Information – Public versus Private and Object Encapsulation
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
- en: One of the driving principles of object-oriented programming is `private` and
    `public` declarations for this purpose. And in C#, any symbol not declared public
    is assumed to be private. In Unity, any public variables are also visible (serialized)
    in the Inspector window when the script is attached to a GameObject as a component.
    Ordinarily, private variables are not visible. Using the `[SerializeField]` directive
    enables a private variable to also be visible and modifiable in the Inspector
    window.
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
- en: Congratulations! It's not necessarily a brilliant app, and it's modeled after
    the example scenes found in the Samples projects, but you started from **File
    | New Scene** and built it up all on your own. Now, let's have a little fun with
    it and find a 3D model that's a little more interesting than a little red cube.
  id: totrans-322
  prefs: []
  type: TYPE_NORMAL
- en: Creating a prefab for placing
  id: totrans-323
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The prefab object we've been placing on the planes in this chapter is the one
    named *AR Placed Cube*, which we imported from the AR Foundation Samples project.
    Let's find a different, more interesting, model to use instead. In the process,
    we'll learn a bit more about GameObjects, Transforms, and prefabs.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
- en: Understanding GameObjects and Transforms
  id: totrans-325
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'I think a good place to start is by taking a closer look at the *AR Placed
    Cube* prefab we''ve been using. Let''s open it in the Editor by performing the
    following steps:'
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
- en: In the `ARF-samples/Prefabs/` folder.
  id: totrans-327
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the **AR Placed Cube** prefab.
  id: totrans-328
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'We are now editing the prefab, as shown in the following screenshot (I have
    rearranged my windows differently from the default layout):'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – Editing the AR Placed Cube prefab'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10-arplacedcube-edit.jpg)'
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – Editing the AR Placed Cube prefab
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
- en: The `0, 0, 0`), `0, 0, 0`), and `1, 1, 1`).
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
- en: Beneath the AR Placed Cube is a child `0.05, 0.05, 0.05`). These units are in
    meters (0.05 meters is about 2 inches per side). And that's its size when it's
    placed in the physical environment with our app.
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
- en: You'll also notice that the child Cube's X-Y-Z `0, 0.025, 0`), where Y in Unity
    is the up-axis. As 0.025 is half of 0.05, we've raised the cube half its height
    above the zero X-Z plane.
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
- en: The origin of a Cube is its center. So, the origin of the AR Placed Cube is
    the bottom of the child Cube. In other words, when we place this prefab in the
    scene, the cube's bottom side rests on the pose position, as determined by the
    *hit* raycast.
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
- en: Parenting a model with an empty GameObject to normalize its scale and adjust
    its origin is a common pattern in Unity development.
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's find a different model for our app and normalize its Transform as
    we make it a prefab.
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
- en: Finding a 3D model
  id: totrans-339
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To find a 3D model, feel free to search the internet for a 3D model you like.
    If you're a 3D artist, you may already have ones of your own. You will want a
    relatively simple, low-poly model (that is, with not many polygons). Look for
    files in `.FBX` or `.OBJ` format, as they will import into Unity without conversion.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
- en: 'I found a model of a virus microbe on `cgtrader.com` here: [https://www.cgtrader.com/free-3d-models/science/medical/microbe](https://www.cgtrader.com/free-3d-models/science/medical/microbe).
    It is a free download and royalty-free, has 960 polygons, and is available in
    FBX format. My file is named `uploads_files_745381_Microbe.fbx`.'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you''ve found a file and downloaded it to your computer, perform the following
    steps to import it into Unity:'
  id: totrans-342
  prefs: []
  type: TYPE_NORMAL
- en: In the `Models` under your `_App` folder (this step is optional).
  id: totrans-343
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the model from your Windows File Explorer or macOS Finder into the `Models`
    folder to import it into the project. Alternatively, you can use the main menu
    by clicking **Assets | Import New Asset**.
  id: totrans-344
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you select the model in the **Project** window, you can review it in the
    **Inspector** window. While there, take a look at the many **Import Settings**.
    Generally, you can keep their default values.
  id: totrans-345
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we''ll make a prefab of the model and make sure it''s been scaled to a
    usable size. I like to use a temporary Cube object to measure it:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
- en: In the `Prefabs` under your `_App` folder (this step is optional).
  id: totrans-347
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click inside the `Prefabs` folder, select `Virus`).
  id: totrans-348
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Double-click the new prefab, or click its **Open Prefab** button in the **Inspector**
    window.
  id: totrans-349
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For measurement purposes, add a temporary Cube by selecting **GameObject | 3D
    Object | Cube** from the main menu (or use the **+** button at the top left, or
    right-click directly in the **Hierarchy** window).
  id: totrans-350
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Assuming I want my model to appear in the scene as the same size as the red
    cube we had been using, set this measuring cube `0.05, 0.05, 0.05`) and its `0,
    0.025, 0`).
  id: totrans-351
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the 3D model you imported from your `Models` folder into the **Hierarchy**
    window as a child of the root object.
  id: totrans-352
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use the `0.5, 0.05, 0.05`), `0, 0.04, 0`), `0, 0, 0`).
  id: totrans-353
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Delete or disable the Cube. With **Cube** selected, in its **Inspector** window,
    uncheck the **Enable** checkbox at the top left.
  id: totrans-354
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the prefab by clicking the **Save** button at the top of the **Scene**
    window.
  id: totrans-355
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The model I found did not come with a material, so let''s create one for it
    now. With the prefab we''re working on still open for editing, perform the following
    additional steps:'
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
- en: In the `Materials` under your `_App` folder (this step is optional).
  id: totrans-357
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Right-click inside the `Materials` folder, select `Virus Material`.
  id: totrans-358
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag **Virus Material** onto the model object (**uploads_files_745381_Microbe**)
    in the **Hierarchy** window.
  id: totrans-359
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the microbe model selected in the `0.5`.
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Again, **Save** your prefab.
  id: totrans-361
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Exit back to scene editing by clicking the **<** button at the top left of the
    **Hierarchy** window.
  id: totrans-362
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'My prefab now looks like this while open for editing (I have rearranged my
    windows so that they''re different from the default layout):'
  id: totrans-363
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.11 – Editing my Virus prefab'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.11-virus-edit.jpg)'
  id: totrans-365
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – Editing my Virus prefab
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
- en: We're now ready to add this prefab to the scene. After, we will build and run
    the finished project.
  id: totrans-367
  prefs: []
  type: TYPE_NORMAL
- en: Completing the scene
  id: totrans-368
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We now have our own prefab to place in the AR scene. Let''s add it to the **Place
    Object On Plane** component, as follows:'
  id: totrans-369
  prefs: []
  type: TYPE_NORMAL
- en: Ensure you've exited the prefab edit mode and are now editing BasicARScene.
  id: totrans-370
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **AR Session Origin** object in the **Hierarchy** window.
  id: totrans-371
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `_App/Prefabs/Virus`) into the **Inspector** window, onto the **Place
    Object On Plane | Placed Prefab** slot.
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the scene with **File | Save**.
  id: totrans-373
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build and run the scene by going to **File | Build And Run**.
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As shown in the following screenshot, I have infected my desk with a virus!
  id: totrans-375
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.12 – Running the project shows a virus on my keyboard'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.12-virus-keyboard.jpg)'
  id: totrans-377
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – Running the project shows a virus on my keyboard
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
- en: There it is. You've successfully created an augmented reality scene that places
    a virtual 3D model in the real world. Perhaps you wouldn't have chosen a virus,
    but it's a sign of the times!
  id: totrans-379
  prefs: []
  type: TYPE_NORMAL
- en: You're now ready to proceed with creating your own AR projects in Unity.
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  id: totrans-381
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we examined the core structure of an augmented reality scene
    using AR Foundation. We started with the AR Foundation Samples project from Unity,
    building it to run on your device, and then exported its assets into an asset
    package for reuse. Then, we imported these sample assets into our own project,
    took a closer look at the `SimpleAR` scene, and built that to run on your device.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
- en: Then, starting from a new empty scene, we built our own basic AR demo from scratch
    that lets the user place a virtual 3D object in the physical world environment.
    For this, we added `OnPlaceObject` action message. This function performs a raycast
    from the screen touch position to find a pose point on a trackable horizontal
    plane. It then instantiates an object on the plane at that location. We concluded
    this chapter by finding a 3D model on the internet, importing it into the project,
    creating a scaled prefab from the model, and using it as the virtual object placed
    into the scene. Several times along the way, we did a **Build And Run** of the
    project to verify that our work at that point runs as expected on the target device.
  id: totrans-383
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，从一个全新的空白场景开始，我们从头开始构建了自己的基本AR演示，允许用户在物理世界环境中放置一个虚拟3D对象。为此，我们添加了`OnPlaceObject`动作消息。这个函数从屏幕触摸位置进行射线投射，以在可追踪的水平平面上找到一个姿态点。然后，它在该位置平面上实例化一个对象。我们通过在互联网上找到一个3D模型，将其导入到项目中，从模型创建一个缩放预制件，并将其用作场景中放置的虚拟对象来结束这一章节。在过程中，我们多次进行了**构建和运行**项目，以验证我们在此阶段的工作在目标设备上是否按预期运行。
- en: In the next chapter, we will look at tools and practices to facilitate developing
    and troubleshooting AR projects, which will help improve the developer workflow,
    before moving on to creating more complete projects in subsequent chapters.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨工具和实践，以促进AR项目的开发和故障排除，这将有助于提高开发者的工作流程，然后再继续在后续章节中创建更完整的项目。
