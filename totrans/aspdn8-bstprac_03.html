<html><head></head><body>
<div id="_idContainer027">
<h1 class="chapter-number" id="_idParaDest-69"><a id="_idTextAnchor070"/><span class="koboSpan" id="kobo.1.1">3</span></h1>
<h1 id="_idParaDest-70"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.2.1">Best Approaches for Middleware</span></h1>
<p><span class="koboSpan" id="kobo.3.1">Middleware is</span><a id="_idIndexMarker116"/><span class="koboSpan" id="kobo.4.1"> one of the most powerful concepts in ASP.NET Core. </span><span class="koboSpan" id="kobo.4.2">For legacy ASP.NET developers, </span><em class="italic"><span class="koboSpan" id="kobo.5.1">Middleware</span></em><span class="koboSpan" id="kobo.6.1"> is a relatively new term. </span><span class="koboSpan" id="kobo.6.2">Before middleware, there were HTTP handlers and modules, which required separate code to configure through a </span><strong class="source-inline"><span class="koboSpan" id="kobo.7.1">web.config</span></strong><span class="koboSpan" id="kobo.8.1">. </span><span class="koboSpan" id="kobo.8.2">Middleware is now considered a first-class citizen in an ASP.NET application, making it easier to maintain in a single code base. </span><span class="koboSpan" id="kobo.8.3">First introduced in ASP.NET Core 1.0, the common request and response concepts are considered pipelines for your applications with the ability to control a request and response’s body. </span><span class="koboSpan" id="kobo.8.4">This opens up a number of possibilities to create amazing features for your ASP.NET Core </span><span class="No-Break"><span class="koboSpan" id="kobo.9.1">web applications.</span></span></p>
<p><span class="koboSpan" id="kobo.10.1">At the beginning of this chapter, we’ll examine how to use Middleware and some common built-in Middleware components found in almost every ASP.NET Core application. </span><span class="koboSpan" id="kobo.10.2">Next, we’ll examine the three request delegates (</span><strong class="source-inline"><span class="koboSpan" id="kobo.11.1">Run</span></strong><span class="koboSpan" id="kobo.12.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.13.1">Map</span></strong><span class="koboSpan" id="kobo.14.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.15.1">Use</span></strong><span class="koboSpan" id="kobo.16.1">) and explain what each is used for in the pipeline. </span><span class="koboSpan" id="kobo.16.2">We’ll also cover some ways to clean up your middleware and, finally, apply those concepts to building a simple </span><span class="No-Break"><span class="koboSpan" id="kobo.17.1">middleware example.</span></span></p>
<p><span class="koboSpan" id="kobo.18.1">In this chapter, we’ll cover the following </span><span class="No-Break"><span class="koboSpan" id="kobo.19.1">main topics:</span></span></p>
<ul>
<li><span class="No-Break"><span class="koboSpan" id="kobo.20.1">Using Middleware</span></span></li>
<li><span class="koboSpan" id="kobo.21.1">Common Practices </span><span class="No-Break"><span class="koboSpan" id="kobo.22.1">for Middleware</span></span></li>
<li><span class="koboSpan" id="kobo.23.1">Creating an Emoji </span><span class="No-Break"><span class="koboSpan" id="kobo.24.1">Middleware </span></span><span class="No-Break"><span class="koboSpan" id="kobo.25.1">C</span></span><span class="No-Break"><span class="koboSpan" id="kobo.26.1">omponent</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.27.1">By the end of this chapter, you’ll have learned how Middleware works, how to use request delegates and standards when writing your own Middleware, and understand how to create your own </span><span class="No-Break"><span class="koboSpan" id="kobo.28.1">Middleware components.</span></span></p>
<h1 id="_idParaDest-71"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.29.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.30.1">Since this is the first chapter (one of many to come since we’re in coding territory now) containing technical requirements, selecting your favorite editor that supports ASP.NET Core 7.0 or higher and C# code would be ideal. </span><span class="koboSpan" id="kobo.30.2">My top three editors are </span><span class="No-Break"><span class="koboSpan" id="kobo.31.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.32.1">Visual Studio (preferably 2022 </span><span class="No-Break"><span class="koboSpan" id="kobo.33.1">or newer)</span></span></li>
<li><span class="koboSpan" id="kobo.34.1">Visual </span><span class="No-Break"><span class="koboSpan" id="kobo.35.1">Studio Code</span></span></li>
<li><span class="No-Break"><span class="koboSpan" id="kobo.36.1">JetBrains Rider</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.37.1">The editor we’ll be using is Visual Studio 2022 Enterprise, but any version (Community or Professional) will work for </span><span class="No-Break"><span class="koboSpan" id="kobo.38.1">this chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.39.1">The code for this chapter is located at Packt Publishing’s GitHub repository located </span><span class="No-Break"><span class="koboSpan" id="kobo.40.1">here: </span></span><a href="https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices"><span class="No-Break"><span class="koboSpan" id="kobo.41.1">https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices</span></span></a><span class="No-Break"><span class="koboSpan" id="kobo.42.1">.</span></span></p>
<h1 id="_idParaDest-72"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.43.1">Using Middleware</span></h1>
<p><span class="koboSpan" id="kobo.44.1">Middleware is </span><a id="_idIndexMarker117"/><span class="koboSpan" id="kobo.45.1">software you configure at the beginning of your application when the application starts.  </span><span class="koboSpan" id="kobo.45.2">It’s important to note that the Middleware you add should be based on your application’s requirements. </span><span class="koboSpan" id="kobo.45.3">It’s not necessary to add every single component. </span><span class="koboSpan" id="kobo.45.4">Streamlining your Middleware pipeline is important, which we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.46.1">discuss shortly.</span></span></p>
<p><span class="koboSpan" id="kobo.47.1">It’s been said that the difference between a library and a framework is that a library is the code you call from your application, whereas a framework is structured a certain way to call your code. </span><span class="koboSpan" id="kobo.47.2">This is what Middleware has evolved into from earlier versions </span><span class="No-Break"><span class="koboSpan" id="kobo.48.1">of ASP.NET.</span></span></p>
<p><span class="koboSpan" id="kobo.49.1">In this section, we’ll present the common flow of a Middleware pipeline and how to control what happens in a middleware component. </span><span class="koboSpan" id="kobo.49.2">By the end of this section, you’ll understand how a middleware </span><span class="No-Break"><span class="koboSpan" id="kobo.50.1">pipeline works.</span></span></p>
<h2 id="_idParaDest-73"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.51.1">Understanding the Middleware Pipeline</span></h2>
<p><span class="koboSpan" id="kobo.52.1">When your </span><a id="_idIndexMarker118"/><span class="koboSpan" id="kobo.53.1">web application starts, Middleware is called and constructed once per </span><em class="italic"><span class="koboSpan" id="kobo.54.1">application lifetime</span></em><span class="koboSpan" id="kobo.55.1">. </span><span class="koboSpan" id="kobo.55.2">Once the Middleware components are registered, they execute in a certain order. </span><span class="koboSpan" id="kobo.55.3">This order is important throughout the pipeline since each middleware component can rely on previously </span><span class="No-Break"><span class="koboSpan" id="kobo.56.1">registered components.</span></span></p>
<p><span class="koboSpan" id="kobo.57.1">For example, the Authentication component is important to configure before the Authorization component </span><a id="_idIndexMarker119"/><span class="koboSpan" id="kobo.58.1">since we need to know who someone is before we can determine what they </span><span class="No-Break"><span class="koboSpan" id="kobo.59.1">can do.</span></span></p>
<p><span class="koboSpan" id="kobo.60.1">In </span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.61.1">Figure 3</span></em></span><em class="italic"><span class="koboSpan" id="kobo.62.1">.1</span></em><span class="koboSpan" id="kobo.63.1">, we can see what a standard Middleware pipeline consists of in a web application, which we’ll </span><span class="No-Break"><span class="koboSpan" id="kobo.64.1">address next:</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer024">
<span class="koboSpan" id="kobo.65.1"><img alt="Figure 3.1 – Standard Middleware pipeline for an ASP.NET 8 Web Application" src="image/Figure_3.01_B19493.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.66.1">Figure 3.1 – Standard Middleware pipeline for an ASP.NET 8 Web Application</span></p>
<p><span class="koboSpan" id="kobo.67.1">Each one of these </span><a id="_idIndexMarker120"/><span class="koboSpan" id="kobo.68.1">components is optional, but some Middleware components are dependent on others. </span><span class="koboSpan" id="kobo.68.2">When a URL is requested by the user, the first Middleware component is hit. </span><span class="koboSpan" id="kobo.68.3">In this case, it’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.69.1">ExceptionHandler</span></strong><span class="koboSpan" id="kobo.70.1">. </span><span class="koboSpan" id="kobo.70.2">Once </span><strong class="source-inline"><span class="koboSpan" id="kobo.71.1">ExceptionHandler</span></strong><span class="koboSpan" id="kobo.72.1"> is done, the pipeline moves on to the next component, which is the HSTS component. </span><span class="koboSpan" id="kobo.72.2">As we move through each Middleware component, we eventually reach</span><a id="_idIndexMarker121"/><span class="koboSpan" id="kobo.73.1"> the endpoint. </span><span class="koboSpan" id="kobo.73.2">Once the endpoint is processed, the response is sent back through the Middleware pipeline in </span><span class="No-Break"><span class="koboSpan" id="kobo.74.1">reverse order.</span></span></p>
<p><span class="koboSpan" id="kobo.75.1">As mentioned at the start of this section, your Middleware depends on what your application requires when adding additional components. </span><span class="koboSpan" id="kobo.75.2">If your application is a </span><strong class="bold"><span class="koboSpan" id="kobo.76.1">Single-Page Application</span></strong><span class="koboSpan" id="kobo.77.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.78.1">SPA</span></strong><span class="koboSpan" id="kobo.79.1">), the</span><a id="_idIndexMarker122"/><span class="koboSpan" id="kobo.80.1"> inclusion of the CORS, Static Files, and Routing Middleware would </span><span class="No-Break"><span class="koboSpan" id="kobo.81.1">be important.</span></span></p>
<p><span class="koboSpan" id="kobo.82.1">Each middleware component is responsible for either passing information on to the next component in line based on your configuration or terminating the process. </span><span class="koboSpan" id="kobo.82.2">If they decide to terminate the pipeline, they are called </span><em class="italic"><span class="koboSpan" id="kobo.83.1">terminal Middleware</span></em><span class="koboSpan" id="kobo.84.1"> components. </span><span class="koboSpan" id="kobo.84.2">They purposefully stop the middleware from processing any other requests and exit </span><span class="No-Break"><span class="koboSpan" id="kobo.85.1">the pipeline.</span></span></p>
<h2 id="_idParaDest-74"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.86.1">Using Request Delegates – Run, Use, and Map</span></h2>
<p><span class="koboSpan" id="kobo.87.1">With </span><a id="_idIndexMarker123"/><span class="koboSpan" id="kobo.88.1">everything we’ve discussed so far, you’re probably wondering how we create </span><span class="No-Break"><span class="koboSpan" id="kobo.89.1">a pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.90.1">The </span><a id="_idIndexMarker124"/><span class="koboSpan" id="kobo.91.1">three request delegates available are the </span><strong class="source-inline"><span class="koboSpan" id="kobo.92.1">Run</span></strong><span class="koboSpan" id="kobo.93.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.94.1">Use</span></strong><span class="koboSpan" id="kobo.95.1">, and </span><strong class="source-inline"><span class="koboSpan" id="kobo.96.1">Map</span></strong><span class="koboSpan" id="kobo.97.1"> extension methods. </span><span class="koboSpan" id="kobo.97.2">You’ve no doubt used them in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.98.1">Program.cs</span></strong><span class="koboSpan" id="kobo.99.1"> code numerous times, but what’s the difference between the three </span><span class="No-Break"><span class="koboSpan" id="kobo.100.1">of them?</span></span></p>
<h3><span class="koboSpan" id="kobo.101.1">Run</span></h3>
<p><span class="koboSpan" id="kobo.102.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.103.1">Run()</span></strong><span class="koboSpan" id="kobo.104.1"> request </span><a id="_idIndexMarker125"/><span class="koboSpan" id="kobo.105.1">delegate is</span><a id="_idIndexMarker126"/><span class="koboSpan" id="kobo.106.1"> strictly terminal middleware, meaning it will run and immediately quit the pipeline. </span><span class="koboSpan" id="kobo.106.2">It doesn’t contain a </span><strong class="source-inline"><span class="koboSpan" id="kobo.107.1">next</span></strong><span class="koboSpan" id="kobo.108.1"> parameter. </span><span class="koboSpan" id="kobo.108.2">It simply runs and immediately terminates </span><span class="No-Break"><span class="koboSpan" id="kobo.109.1">the pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.110.1">If we look at the following code, this will immediately terminate the pipeline </span><span class="No-Break"><span class="koboSpan" id="kobo.111.1">from executing:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.112.1">
app.Run(async context =&gt;
{
    await context.Response.WriteAsync("This will terminate the web         app.");
});</span></pre> <p><span class="koboSpan" id="kobo.113.1">Notice </span><a id="_idIndexMarker127"/><span class="koboSpan" id="kobo.114.1">there isn’t a </span><strong class="source-inline"><span class="koboSpan" id="kobo.115.1">next</span></strong><span class="koboSpan" id="kobo.116.1"> parameter introduced in the delegate. </span><span class="koboSpan" id="kobo.116.2">The preceding code will write</span><a id="_idIndexMarker128"/><span class="koboSpan" id="kobo.117.1"> the message </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">"This will terminate the web app."</span></strong><span class="koboSpan" id="kobo.119.1"> to the browser and immediately terminate </span><span class="No-Break"><span class="koboSpan" id="kobo.120.1">the pipeline.</span></span></p>
<h3><span class="koboSpan" id="kobo.121.1">Use</span></h3>
<p><span class="koboSpan" id="kobo.122.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">Use()</span></strong><span class="koboSpan" id="kobo.124.1"> request delegate is</span><a id="_idIndexMarker129"/><span class="koboSpan" id="kobo.125.1"> used to chain multiple </span><a id="_idIndexMarker130"/><span class="koboSpan" id="kobo.126.1">request delegates together in </span><span class="No-Break"><span class="koboSpan" id="kobo.127.1">the pipeline.</span></span></p>
<p><span class="koboSpan" id="kobo.128.1">The key to implementing a proper </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">Use</span></strong><span class="koboSpan" id="kobo.130.1"> request delegate is the use of </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">await next.Invoke()</span></strong><span class="koboSpan" id="kobo.132.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.133.1">next.Invoke()</span></strong><span class="koboSpan" id="kobo.134.1"> will execute the next middleware component in sequential order. </span><span class="koboSpan" id="kobo.134.2">Anything before this line will be processed on the request, and anything after this line will be processed on the response back to </span><span class="No-Break"><span class="koboSpan" id="kobo.135.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.136.1">Let’s look at a code sample of two anonymous Middleware components in the following </span><span class="No-Break"><span class="koboSpan" id="kobo.137.1">code snippet:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.138.1">
app.Use(async (context, next) =&gt;
{
    await context.Response.WriteAsync("In the first middleware call.\        r\n");
    await context.Response.WriteAsync("Executing the next         Middleware...\r\n");
    await next();
    await context.Response.WriteAsync("In the first middleware call…on the return trip.\r\n");
});
app.Use(async (context, next) =&gt;
{
    await context.Response.WriteAsync("We're in the second middleware         call\r\n");
    await next();
    await context.Response.WriteAsync("On our way back from the second         middleware call\r\n");
});</span></pre> <p><span class="koboSpan" id="kobo.139.1">This </span><a id="_idIndexMarker131"/><span class="koboSpan" id="kobo.140.1">code</span><a id="_idIndexMarker132"/><span class="koboSpan" id="kobo.141.1"> creates the </span><span class="No-Break"><span class="koboSpan" id="kobo.142.1">following output:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.143.1">
In the first middleware call.
</span><span class="koboSpan" id="kobo.143.2">Executing the next Middleware...
</span><span class="koboSpan" id="kobo.143.3">We're in the second middleware call
On our way back from the second middleware call
In the first middleware call…on the return trip.</span></pre> <p><span class="koboSpan" id="kobo.144.1">You’ll notice</span><a id="_idIndexMarker133"/><span class="koboSpan" id="kobo.145.1"> anything before the </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">next.invoke()</span></strong><span class="koboSpan" id="kobo.147.1"> line of code is executed and then the execution moves on to the next Middleware in the order. </span><span class="koboSpan" id="kobo.147.2">Once we get to the end of the Middleware pipeline, we make the return trip back, which executes all of the code </span><em class="italic"><span class="koboSpan" id="kobo.148.1">after</span></em><span class="koboSpan" id="kobo.149.1"> each Middleware’s </span><strong class="source-inline"><span class="koboSpan" id="kobo.150.1">await </span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.151.1">next();</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.152.1"> statement.</span></span></p>
<p><span class="koboSpan" id="kobo.153.1">After each Middleware component is executed, the application runs and then returns in </span><span class="No-Break"><span class="koboSpan" id="kobo.154.1">reverse order.</span></span></p>
<h3><span class="koboSpan" id="kobo.155.1">Map</span></h3>
<p><span class="koboSpan" id="kobo.156.1">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">Map()</span></strong><span class="koboSpan" id="kobo.158.1"> request delegate</span><a id="_idIndexMarker134"/><span class="koboSpan" id="kobo.159.1"> is meant for branching the </span><a id="_idIndexMarker135"/><span class="koboSpan" id="kobo.160.1">pipeline based on a certain request path or route. </span><span class="koboSpan" id="kobo.160.2">While this is for specific Middleware conditions, creating a new map is highly unlikely. </span><span class="koboSpan" id="kobo.160.3">It’s usually best to use pre-built Middleware components such as </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">.MapRazorPages()</span></strong><span class="koboSpan" id="kobo.162.1">, </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">.MapControllers()</span></strong><span class="koboSpan" id="kobo.164.1">, or any of the other </span><strong class="source-inline"><span class="koboSpan" id="kobo.165.1">.MapXxxx()</span></strong><span class="koboSpan" id="kobo.166.1"> methods. </span><span class="koboSpan" id="kobo.166.2">These methods already have pre-defined routes in place. </span><span class="koboSpan" id="kobo.166.3">Most routing occurs inside other extensions like the previously mentioned </span><span class="No-Break"><span class="koboSpan" id="kobo.167.1">Middleware methods.</span></span></p>
<p><span class="koboSpan" id="kobo.168.1">There is also a </span><strong class="source-inline"><span class="koboSpan" id="kobo.169.1">MapWhen()</span></strong><span class="koboSpan" id="kobo.170.1"> extension method for conditional middleware branching based </span><a id="_idIndexMarker136"/><span class="koboSpan" id="kobo.171.1">on the result of a given predicate. </span><span class="koboSpan" id="kobo.171.2">For example, if you want to create a controlled maintenance page for your site, you could use a </span><a id="_idIndexMarker137"/><span class="koboSpan" id="kobo.172.1">simple Boolean called </span><strong class="source-inline"><span class="koboSpan" id="kobo.173.1">underMaintenance</span></strong><span class="koboSpan" id="kobo.174.1"> and use it to display a simple message until your site is </span><span class="No-Break"><span class="koboSpan" id="kobo.175.1">available again:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.176.1">
app.MapWhen(_ =&gt; underMaintenance, ctx =&gt;
    ctx.Run(async context =&gt;
    {
        await context.Response
            .WriteAsync("We are currently under maintenance.");
    })
);</span></pre> <p><span class="koboSpan" id="kobo.177.1">In the preceding code, we add our </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">.MapWhen()</span></strong><span class="koboSpan" id="kobo.179.1"> delegate to use a specific Boolean to identify whether we are under maintenance or not. </span><span class="koboSpan" id="kobo.179.2">Notice we’re using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">.Run</span></strong><span class="koboSpan" id="kobo.181.1"> delegate because we don’t want to continue any further down the Middleware pipeline. </span><span class="koboSpan" id="kobo.181.2">This approach is just one example of </span><span class="No-Break"><span class="koboSpan" id="kobo.182.1">Middleware’s flexibility.</span></span></p>
<p class="callout-heading"><span class="koboSpan" id="kobo.183.1">Using Built-in Middleware Components</span></p>
<p class="callout"><span class="koboSpan" id="kobo.184.1">While </span><a id="_idIndexMarker138"/><span class="koboSpan" id="kobo.185.1">you can create your own Middleware components, the best approach is to see whether a Middleware component exists from the large number of built-in components already available to you. </span><span class="koboSpan" id="kobo.185.2">The entire list is located at </span><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0#built-in-middleware"><span class="koboSpan" id="kobo.186.1">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/?view=aspnetcore-7.0#built-in-middleware</span></a><span class="koboSpan" id="kobo.187.1">. </span><span class="koboSpan" id="kobo.187.2">This chart provides a description of each Middleware component and the location of where to place it in the Middleware pipeline. </span><span class="koboSpan" id="kobo.187.3">In addition to the built-in components, use NuGet to find innovative Middleware components </span><span class="No-Break"><span class="koboSpan" id="kobo.188.1">as well.</span></span></p>
<p><span class="koboSpan" id="kobo.189.1">In this section, we covered the middleware pipeline, learned how to use the request delegates and what each request delegate can do, and learned about all of the built-in middleware components available for ASP.NET web applications. </span><span class="koboSpan" id="kobo.189.2">In the next section, we’ll examine the common practices for </span><span class="No-Break"><span class="koboSpan" id="kobo.190.1">using Middleware.</span></span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.191.1">Common Practices for Middleware</span></h1>
<p><span class="koboSpan" id="kobo.192.1">In this section, we’ll </span><a id="_idIndexMarker139"/><span class="koboSpan" id="kobo.193.1">review a number of common practices when writing your own middleware to keep everything running optimally in your web application. </span><span class="koboSpan" id="kobo.193.2">Let’s </span><span class="No-Break"><span class="koboSpan" id="kobo.194.1">get started!</span></span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.195.1">Defer to Asynchronous</span></h2>
<p><span class="koboSpan" id="kobo.196.1">When working with </span><a id="_idIndexMarker140"/><span class="koboSpan" id="kobo.197.1">Middleware, we want to get the best performance possible so our users can begin working in the application. </span><span class="koboSpan" id="kobo.197.2">As more users continue to use the application, performance </span><span class="No-Break"><span class="koboSpan" id="kobo.198.1">may suffer.</span></span></p>
<p><span class="koboSpan" id="kobo.199.1">A synchronous operation is where code is executed and the application has to wait for it to finish, meaning it’s single-threaded and runs on the application’s main thread, but when an asynchronous operation is executed, it creates a new thread and lets the framework know what to call when it’s finished processing. </span><span class="koboSpan" id="kobo.199.2">This is signified through the </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">async</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.201.1">/</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.202.1">await</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.203.1"> keywords.</span></span></p>
<p><span class="koboSpan" id="kobo.204.1">For the majority of Middleware operations, it’s best to use asynchronous calls when applicable. </span><span class="koboSpan" id="kobo.204.2">This will increase Middleware (and application) performance along with better scalability </span><span class="No-Break"><span class="koboSpan" id="kobo.205.1">and responsiveness.</span></span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.206.1">Prioritizing the Order</span></h2>
<p><span class="koboSpan" id="kobo.207.1">One of the more</span><a id="_idIndexMarker141"/><span class="koboSpan" id="kobo.208.1"> important points of setting up your Middleware is to confirm everything is in the </span><span class="No-Break"><span class="koboSpan" id="kobo.209.1">right order.</span></span></p>
<p><span class="koboSpan" id="kobo.210.1">Compare your application’s requirements with the previous chart to identify what middleware components you need and what their correct order is for your </span><span class="No-Break"><span class="koboSpan" id="kobo.211.1">web application.</span></span></p>
<p><span class="koboSpan" id="kobo.212.1">For example, if you want to include a W3C Logging Middleware component (which is included in the built-in Middleware components from Microsoft), it has to be at the beginning of the pipeline to log any subsequent requests made throughout the application. </span><span class="koboSpan" id="kobo.212.2">Each component has its place in </span><span class="No-Break"><span class="koboSpan" id="kobo.213.1">the pipeline.</span></span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.214.1">Consolidating existing Middleware</span></h2>
<p><span class="koboSpan" id="kobo.215.1">When you </span><a id="_idIndexMarker142"/><span class="koboSpan" id="kobo.216.1">create a new ASP.NET project, you’ll notice the collection of </span><strong class="source-inline"><span class="koboSpan" id="kobo.217.1">app.UseXxx()</span></strong><span class="koboSpan" id="kobo.218.1"> listed in </span><strong class="source-inline"><span class="koboSpan" id="kobo.219.1">Program.cs</span></strong><span class="koboSpan" id="kobo.220.1">. </span><span class="koboSpan" id="kobo.220.2">While this is the “out-of-the-box” approach for preparing your pipeline, there are other ways to organize and register components for </span><span class="No-Break"><span class="koboSpan" id="kobo.221.1">your application.</span></span></p>
<p><span class="koboSpan" id="kobo.222.1">One approach is to use extension methods based on how you logically partition your uses into similar groupings while keeping the components in the </span><span class="No-Break"><span class="koboSpan" id="kobo.223.1">same order.</span></span></p>
<p><span class="koboSpan" id="kobo.224.1">One example would be to move all client Middleware into its own extension method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">.</span></strong><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.226.1">UseClientOptions()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.227.1">:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.228.1">
public static class WebApplicationExtensions
{
    public static void UseClientOptions(this WebApplication app)
    {
        app.UseHttpsRedirection();
        app.UseStaticFiles();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.229.1">Now, the code in your </span><strong class="source-inline"><span class="koboSpan" id="kobo.230.1">Program.cs</span></strong><span class="koboSpan" id="kobo.231.1"> file contains one line, and you know exactly what the extension </span><span class="No-Break"><span class="koboSpan" id="kobo.232.1">method does:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.233.1">
app.UseClientOptions();</span></pre> <p><span class="koboSpan" id="kobo.234.1">When using this approach, your </span><strong class="source-inline"><span class="koboSpan" id="kobo.235.1">Program.cs</span></strong><span class="koboSpan" id="kobo.236.1"> file is cleaner, well maintained, and contains fewer lines </span><span class="No-Break"><span class="koboSpan" id="kobo.237.1">of code.</span></span></p>
<p><span class="koboSpan" id="kobo.238.1">Other possible areas to partition are </span><span class="No-Break"><span class="koboSpan" id="kobo.239.1">as follows:</span></span></p>
<ul>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.240.1">UseDataXxxxx()</span></strong><span class="koboSpan" id="kobo.241.1"> – Centralized location for connection strings for </span><span class="No-Break"><span class="koboSpan" id="kobo.242.1">your application</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.243.1">UseMapping()/UseRouting()</span></strong><span class="koboSpan" id="kobo.244.1"> – Create a collection of routes for your application </span><span class="No-Break"><span class="koboSpan" id="kobo.245.1">and APIs</span></span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.246.1">RegisterDependencyInjection()</span></strong><span class="koboSpan" id="kobo.247.1"> – Centralize the classes in a number of extension methods similar to this grouping approach, but partitioned by sections in your application – for example, </span><strong class="source-inline"><span class="koboSpan" id="kobo.248.1">RegisterDIPayroll()</span></strong><span class="koboSpan" id="kobo.249.1"> for registering classes pertaining to the Payroll section of </span><span class="No-Break"><span class="koboSpan" id="kobo.250.1">the application</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.251.1">While</span><a id="_idIndexMarker143"/><span class="koboSpan" id="kobo.252.1"> these are merely suggestions, the concept is to trim the size of the </span><strong class="source-inline"><span class="koboSpan" id="kobo.253.1">Program.cs</span></strong><span class="koboSpan" id="kobo.254.1"> file so other developers understand the approach with fewer lines of code, and it provides enough clarity for other developers to extend the </span><span class="No-Break"><span class="koboSpan" id="kobo.255.1">technique further.</span></span></p>
<p><span class="koboSpan" id="kobo.256.1">As a recommendation, include all of the important Middleware components upfront and confirm the application runs as expected, </span><em class="italic"><span class="koboSpan" id="kobo.257.1">then</span></em><span class="koboSpan" id="kobo.258.1"> perform your refactoring by creating your groups for consolidation. </span><span class="koboSpan" id="kobo.258.2">Remember, the order of Middleware </span><span class="No-Break"><span class="koboSpan" id="kobo.259.1">components matters.</span></span></p>
<h2 id="_idParaDest-79"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.260.1">Encapsulating your Middleware</span></h2>
<p><span class="koboSpan" id="kobo.261.1">When creating </span><a id="_idIndexMarker144"/><span class="koboSpan" id="kobo.262.1">your first middleware component, you may be tempted to create it and use it in </span><span class="No-Break"><span class="koboSpan" id="kobo.263.1">this fashion:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.264.1">
app.Use(async (context, next) =&gt;
{
    app.Logger.LogInformation("In our custom Middleware...");
    // Prepare work for when we write to the Response
    await next();
    // work that happens when we DO write to the response.
</span><span class="koboSpan" id="kobo.264.2">});</span></pre> <p><span class="koboSpan" id="kobo.265.1">One problem with this approach is the preceding code can make your </span><strong class="source-inline"><span class="koboSpan" id="kobo.266.1">Program.cs</span></strong><span class="koboSpan" id="kobo.267.1"> file look a little messy if you have a large number of custom </span><span class="No-Break"><span class="koboSpan" id="kobo.268.1">middleware components.</span></span></p>
<p><span class="koboSpan" id="kobo.269.1">Once you have your custom component working, it’s better to encapsulate it into its own class for increased reusability. </span><span class="koboSpan" id="kobo.269.2">If we use our previous example, our new class would look </span><span class="No-Break"><span class="koboSpan" id="kobo.270.1">like</span></span><span class="No-Break"><a id="_idIndexMarker145"/></span><span class="No-Break"><span class="koboSpan" id="kobo.271.1"> this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.272.1">
public class MyFirstMiddleware
{
    private readonly ILogger _logger;
    private readonly RequestDelegate _next;
    public MyFirstMiddleware(ILogger logger, RequestDelegate next)
    {
        _logger = logger;
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        _logger.LogInformation("In our custom Middleware...");
        // Prepare work for when we write to the Response
        await _next(context);
        // work that happens when we DO write to the response.
</span><span class="koboSpan" id="kobo.272.2">    }
}</span></pre> <p><span class="koboSpan" id="kobo.273.1">In this example, the </span><strong class="source-inline"><span class="koboSpan" id="kobo.274.1">MyFirstMiddleware</span></strong><span class="koboSpan" id="kobo.275.1"> component is a simple class that can contain only one method of </span><strong class="source-inline"><span class="koboSpan" id="kobo.276.1">Invoke</span></strong><span class="koboSpan" id="kobo.277.1"> or </span><strong class="source-inline"><span class="koboSpan" id="kobo.278.1">InvokeAsync</span></strong><span class="koboSpan" id="kobo.279.1">. </span><span class="koboSpan" id="kobo.279.2">As mentioned before, we’ll use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">InvokeAsync</span></strong> <span class="No-Break"><span class="koboSpan" id="kobo.281.1">asynchronous method.</span></span></p>
<p><span class="koboSpan" id="kobo.282.1">If you’re </span><a id="_idIndexMarker146"/><span class="koboSpan" id="kobo.283.1">wondering how </span><strong class="source-inline"><span class="koboSpan" id="kobo.284.1">ILogger</span></strong><span class="koboSpan" id="kobo.285.1"> is passed in, ASP.NET Core has a number of classes automatically registered with its out-of-the-box dependency injection library. </span><strong class="source-inline"><span class="koboSpan" id="kobo.286.1">ILogger</span></strong><span class="koboSpan" id="kobo.287.1"> is one of those classes, so we don’t need to worry about passing it through to our </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.288.1">MyFirstMiddleware</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.289.1"> component.</span></span></p>
<p><span class="koboSpan" id="kobo.290.1">We can use our class in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.291.1">Program.cs</span></strong><span class="koboSpan" id="kobo.292.1"> file </span><span class="No-Break"><span class="koboSpan" id="kobo.293.1">like this:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.294.1">
app.UseMiddleware&lt;MyFirstMiddleware&gt;();</span></pre> <p><span class="koboSpan" id="kobo.295.1">However, since we’re good ASP.NET developers, we can definitely improve the code. </span><span class="koboSpan" id="kobo.295.2">Most middleware components have extension methods attached to them to make them easier to use (which we’ll add </span><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.296.1">now with the </span><span class="No-Break"><span class="koboSpan" id="kobo.297.1">following code):</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.298.1">
public static class MyFirstMiddlewareExtensions
{
    public static IApplicationBuilder UseMyFirstMiddleware(
        this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;MyFirstMiddleware&gt;();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.299.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">Program.cs</span></strong><span class="koboSpan" id="kobo.301.1"> file is much simpler and </span><span class="No-Break"><span class="koboSpan" id="kobo.302.1">cleaner now:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.303.1">
app.UseMyFirstMiddleware();</span></pre> <p><span class="koboSpan" id="kobo.304.1">These simple practices make a developer’s life easier for reusability </span><span class="No-Break"><span class="koboSpan" id="kobo.305.1">and encapsulation.</span></span></p>
<p><span class="koboSpan" id="kobo.306.1">In this section, we covered a number of standard methods for writing maintainable and efficient Middleware by using asynchronous calls, prioritizing the order of your components, and consolidating the existing Middleware into extension methods. </span><span class="koboSpan" id="kobo.306.2">We also examined how to encapsulate components by creating classes and extension methods to make the code easier </span><span class="No-Break"><span class="koboSpan" id="kobo.307.1">to read.</span></span></p>
<h1 id="_idParaDest-80"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.308.1">Creating an Emoji Middleware Component</span></h1>
<p><span class="koboSpan" id="kobo.309.1">With the rise</span><a id="_idIndexMarker147"/><span class="koboSpan" id="kobo.310.1"> of emoticons…sorry, emojis…in the 2000s, a number of legacy websites use the old-style of text-based emoticons instead of the more modern emojis. </span><span class="koboSpan" id="kobo.310.2">Legacy </span><strong class="bold"><span class="koboSpan" id="kobo.311.1">Content Management Systems</span></strong><span class="koboSpan" id="kobo.312.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.313.1">CMSs</span></strong><span class="koboSpan" id="kobo.314.1">) must </span><a id="_idIndexMarker148"/><span class="koboSpan" id="kobo.315.1">have a lot of these text-based characters in their content. </span><span class="koboSpan" id="kobo.315.2">To update a website’s content to replace all of these emoticons with proper emojis sounds </span><span class="No-Break"><span class="koboSpan" id="kobo.316.1">extremely time-consuming.</span></span></p>
<p><span class="koboSpan" id="kobo.317.1">In this section, we’ll apply our standards in creating an emoji Middleware component where, if it detects a text-based emoticon, it’ll convert it to a more </span><span class="No-Break"><span class="koboSpan" id="kobo.318.1">modern emoji.</span></span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.319.1">Encapsulating the Middleware</span></h2>
<p><span class="koboSpan" id="kobo.320.1">With this</span><a id="_idIndexMarker149"/><span class="koboSpan" id="kobo.321.1"> new Middleware component, we want to create it in its own class </span><span class="No-Break"><span class="koboSpan" id="kobo.322.1">in </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.323.1">EmojiMiddleware.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.324.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.325.1">Here is the first draft of </span><span class="No-Break"><span class="koboSpan" id="kobo.326.1">our component:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.327.1">
public class EmojiMiddleware
{
    private readonly ILogger _logger;
    private readonly RequestDelegate _next;
    public EmojiMiddleware(ILogger logger, RequestDelegate next)
    {
        _logger = logger;
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        await _next(context);
    }
}
public static class EmojiMiddlewareExtensions
{
    public static IApplicationBuilder UseEmojiMiddleware(
        this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;EmojiMiddleware&gt;();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.328.1">While</span><a id="_idIndexMarker150"/><span class="koboSpan" id="kobo.329.1"> this isn’t very exciting, this boilerplate meets all of the previously-mentioned standards for building Middleware components, which include </span><span class="No-Break"><span class="koboSpan" id="kobo.330.1">the following:</span></span></p>
<ul>
<li><span class="koboSpan" id="kobo.331.1">An encapsulated </span><span class="No-Break"><span class="koboSpan" id="kobo.332.1">Middleware component</span></span></li>
<li><span class="koboSpan" id="kobo.333.1">Using Asynchronous </span><span class="No-Break"><span class="koboSpan" id="kobo.334.1">methods (</span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.335.1">InvokeAsync()</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.336.1">)</span></span></li>
<li><span class="koboSpan" id="kobo.337.1">An extension method for reuse </span><span class="No-Break"><span class="koboSpan" id="kobo.338.1">and readability</span></span></li>
</ul>
<p><span class="koboSpan" id="kobo.339.1">We can now focus on the </span><span class="No-Break"><span class="koboSpan" id="kobo.340.1">conversion process.</span></span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.341.1">Examining the Component’s Pipeline</span></h2>
<p><span class="koboSpan" id="kobo.342.1">In </span><a id="_idIndexMarker151"/><span class="koboSpan" id="kobo.343.1">Middleware, there are two ways to process a request and response: by using either streams or pipelines. </span><span class="koboSpan" id="kobo.343.2">While pipelines are the better option for high performance, we’ll focus on streams for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.344.1">EmojiMiddleware</span></strong><span class="koboSpan" id="kobo.345.1">. </span><span class="koboSpan" id="kobo.345.2">We’ll examine pipelines in a </span><span class="No-Break"><span class="koboSpan" id="kobo.346.1">later chapter.</span></span></p>
<p><span class="koboSpan" id="kobo.347.1">Our middleware stream is located in </span><strong class="source-inline"><span class="koboSpan" id="kobo.348.1">HttpContext</span></strong><span class="koboSpan" id="kobo.349.1"> through </span><strong class="source-inline"><span class="koboSpan" id="kobo.350.1">HttpRequest.Body</span></strong><span class="koboSpan" id="kobo.351.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.352.1">HttpResponse.Body</span></strong><span class="koboSpan" id="kobo.353.1">. </span><span class="koboSpan" id="kobo.353.2">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.354.1">Invoke</span></strong><span class="koboSpan" id="kobo.355.1"> method, we conveniently pass in </span><span class="No-Break"><span class="koboSpan" id="kobo.356.1">an </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.357.1">HttpContext</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.358.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.359.1">Our first order of business is to create the </span><strong class="source-inline"><span class="koboSpan" id="kobo.360.1">EmojiStream</span></strong><span class="koboSpan" id="kobo.361.1">. </span><span class="koboSpan" id="kobo.361.2">This will accept a simple response stream and read it into memory. </span><span class="koboSpan" id="kobo.361.3">Once we have our HTML, we can search and replace our emoticons. </span><span class="koboSpan" id="kobo.361.4">We need a map to identify the text-based characters and what image to replace them in </span><span class="No-Break"><span class="koboSpan" id="kobo.362.1">our HTML.</span></span></p>
<p><span class="koboSpan" id="kobo.363.1">To make </span><a id="_idIndexMarker152"/><span class="koboSpan" id="kobo.364.1">our life a little easier, we’ll inherit from the </span><strong class="source-inline"><span class="koboSpan" id="kobo.365.1">Stream</span></strong><span class="koboSpan" id="kobo.366.1"> base class and simply override specific methods to fit our needs. </span><span class="koboSpan" id="kobo.366.2">The only implementation our </span><strong class="source-inline"><span class="koboSpan" id="kobo.367.1">EmojiStream</span></strong><span class="koboSpan" id="kobo.368.1"> class needs is our text-based emoticons-to-emojis mapping and the </span><strong class="source-inline"><span class="koboSpan" id="kobo.369.1">.Write()</span></strong><span class="koboSpan" id="kobo.370.1"> method, as shown with the </span><span class="No-Break"><span class="koboSpan" id="kobo.371.1">following code:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.372.1">
public class EmojiStream: Stream
{
    private readonly Stream _responseStream;
    private readonly Dictionary&lt;string, string&gt; _map = new()
    {
        { ":-)", " :) " },
        { ":)", " :) " },
        { ";-)", " ;) " }
    };
    public EmojiStream(Stream responseStream)
    {
        ArgumentNullException.ThrowIfNull(responseStream);
        _responseStream = responseStream;
    }
    public override bool CanRead =&gt; _responseStream.CanRead;
    public override bool CanSeek =&gt; _responseStream.CanSeek;
    public override bool CanWrite =&gt; _responseStream.CanWrite;
    public override long Length =&gt; _responseStream.Length;
    public override long Position
    {
        get =&gt; _responseStream.Position;
        set =&gt; _responseStream.Position = value;
    }
    public override void Flush()
    {
        _responseStream.Flush();
    }
    public override int Read(byte[] buffer, int offset, int count)
    {
        return _responseStream.Read(buffer, offset, count);
    }
    public override long Seek(long offset, SeekOrigin origin)
    {
        return _responseStream.Seek(offset, origin);
    }
    public override void SetLength(long value)
    {
        _responseStream.SetLength(value);
    }
    public override void Write(byte[] buffer, int offset, int count)
    {
        var html = Encoding.UTF8.GetString(buffer, offset, count);
        foreach (var emoticon in _map)
        {
            if (!html.Contains(emoticon.Key)) continue;
            html = html.Replace(emoticon.Key, emoticon.Value);
        }
        buffer = Encoding.UTF8.GetBytes(html);
        _responseStream.WriteAsync(buffer, 0, buffer.Length);
    }
}</span></pre> <p><span class="koboSpan" id="kobo.373.1">At the beginning of the code, we create our map of emoticons to look for in the HTML. </span><span class="koboSpan" id="kobo.373.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.374.1">EmojiStream</span></strong><span class="koboSpan" id="kobo.375.1"> class is fairly common, except for the </span><strong class="source-inline"><span class="koboSpan" id="kobo.376.1">WriteAsync()</span></strong><span class="koboSpan" id="kobo.377.1"> method. </span><span class="koboSpan" id="kobo.377.2">We’ll grab the HTML using the </span><strong class="source-inline"><span class="koboSpan" id="kobo.378.1">GetString()</span></strong><span class="koboSpan" id="kobo.379.1"> method and search for each emoticon in the response. </span><span class="koboSpan" id="kobo.379.2">If we find one, we’ll replace it with an image tag and, finally, write the bytes back into </span><span class="No-Break"><span class="koboSpan" id="kobo.380.1">the stream.</span></span></p>
<p><span class="koboSpan" id="kobo.381.1">Since we’re focused on using streams in the Middleware, we’ll pass a stream into the constructor instead of creating a </span><span class="No-Break"><span class="koboSpan" id="kobo.382.1">new instance.</span></span></p>
<p><span class="koboSpan" id="kobo.383.1">With the </span><a id="_idIndexMarker153"/><span class="koboSpan" id="kobo.384.1">middleware piece left, we can use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.385.1">EmojiStream</span></strong><span class="koboSpan" id="kobo.386.1"> in </span><span class="No-Break"><span class="koboSpan" id="kobo.387.1">our class:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.388.1">
public class EmojiMiddleware
{
    private readonly RequestDelegate _next;
    public EmojiMiddleware(RequestDelegate next)
    {
        _next = next;
    }
    public async Task InvokeAsync(HttpContext context)
    {
        using var buffer = new MemoryStream();
        // Replace the context response with our buffer
        var stream = context.Response.Body;
        context.Response.Body = buffer;
        // Invoke the rest of the pipeline
        // if there are any other middleware components
        await _next(context);
        // Reset and read out the contents
        buffer.Seek(0, SeekOrigin.Begin);
        // Adjust the response stream to include our images.
</span><span class="koboSpan" id="kobo.388.2">        var emojiStream = new EmojiStream(stream);
        // Reset the stream again
        buffer.Seek(0, SeekOrigin.Begin);
        // Copy our content to the original stream and put it back
        await buffer.CopyToAsync(emojiStream);
        context.Response.Body = emojiStream;
    }
}</span></pre> <p><span class="koboSpan" id="kobo.389.1">While our </span><a id="_idIndexMarker154"/><span class="koboSpan" id="kobo.390.1">Middleware component takes a simple </span><strong class="source-inline"><span class="koboSpan" id="kobo.391.1">RequestDelegate</span></strong><span class="koboSpan" id="kobo.392.1">, the majority of the component is in the </span><strong class="source-inline"><span class="koboSpan" id="kobo.393.1">InvokeAsync()</span></strong><span class="koboSpan" id="kobo.394.1"> method. </span><span class="koboSpan" id="kobo.394.2">First, we create a new stream for our response. </span><span class="koboSpan" id="kobo.394.3">Next, we replace the standard response with our own stream. </span><span class="koboSpan" id="kobo.394.4">When we are coming back from our endpoint, we create our </span><strong class="source-inline"><span class="koboSpan" id="kobo.395.1">EmojiStream</span></strong><span class="koboSpan" id="kobo.396.1"> instance and pass in our custom stream to </span><span class="No-Break"><span class="koboSpan" id="kobo.397.1">the </span></span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.398.1">Response.Body</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.399.1">.</span></span></p>
<p><span class="koboSpan" id="kobo.400.1">Since </span><strong class="source-inline"><span class="koboSpan" id="kobo.401.1">HttpContext</span></strong><span class="koboSpan" id="kobo.402.1"> exposes </span><strong class="source-inline"><span class="koboSpan" id="kobo.403.1">HttpRequest.Body</span></strong><span class="koboSpan" id="kobo.404.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.405.1">HttpResponse.Body</span></strong><span class="koboSpan" id="kobo.406.1"> as streams, it’s easier to pass </span><strong class="source-inline"><span class="koboSpan" id="kobo.407.1">HttpContext</span></strong><span class="koboSpan" id="kobo.408.1"> into custom </span><span class="No-Break"><span class="koboSpan" id="kobo.409.1">middleware components.</span></span></p>
<p><span class="koboSpan" id="kobo.410.1">Of course, we can’t forget our extension method, which is </span><span class="No-Break"><span class="koboSpan" id="kobo.411.1">shown here:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.412.1">
public static class EmojiMiddlewareExtensions
{
    public static IApplicationBuilder UseEmojiMiddleware(
        this IApplicationBuilder builder)
    {
        return builder.UseMiddleware&lt;EmojiMiddleware&gt;();
    }
}</span></pre> <p><span class="koboSpan" id="kobo.413.1">This extension method is considered a façade to hide the details of what our </span><strong class="source-inline"><span class="koboSpan" id="kobo.414.1">EmojiStream</span></strong><span class="koboSpan" id="kobo.415.1"> is doing behind the scenes. </span><span class="koboSpan" id="kobo.415.2">While we could use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.416.1">builder.UseMiddleware&lt;EmojiMiddleware&gt;()</span></strong><span class="koboSpan" id="kobo.417.1"> syntax in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.418.1">Program.cs</span></strong><span class="koboSpan" id="kobo.419.1"> file, the extension method cleans it up a bit, giving it a </span><span class="No-Break"><span class="koboSpan" id="kobo.420.1">professional look.</span></span></p>
<p><span class="koboSpan" id="kobo.421.1">The last thing </span><a id="_idIndexMarker155"/><span class="koboSpan" id="kobo.422.1">required is to add the </span><strong class="source-inline"><span class="koboSpan" id="kobo.423.1">EmojiMiddleware</span></strong><span class="koboSpan" id="kobo.424.1"> to the pipeline in your </span><span class="No-Break"><strong class="source-inline"><span class="koboSpan" id="kobo.425.1">Program.cs</span></strong></span><span class="No-Break"><span class="koboSpan" id="kobo.426.1"> file:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.427.1">
app.UseEmojiMiddleware();</span></pre> <p><span class="koboSpan" id="kobo.428.1">After creating a brand new ASP.NET Core website, we’ll add the following HTML to the bottom of our </span><span class="No-Break"><span class="koboSpan" id="kobo.429.1">Index page:</span></span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.430.1">
&lt;div class="text-center"&gt;
    &lt;h2&gt;Smile, you're on candid camera. </span><span class="koboSpan" id="kobo.430.2">:-) :)&lt;/h2&gt;
    &lt;p&gt;It even works inside ;-) a paragraph.&lt;/p&gt;
&lt;/div&gt;</span></pre> <p><span class="koboSpan" id="kobo.431.1">When we run the application without our middleware component, we have the following output (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.432.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.433.1">.2</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.434.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.435.1"><img alt=" Figure 3.2 – Before our EmojiMiddleware is added to the pipeline" src="image/Figure_3.02_B19493.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.436.1"> Figure 3.2 – Before our EmojiMiddleware is added to the pipeline</span></p>
<p><span class="koboSpan" id="kobo.437.1">When we add our Emoji Middleware to our pipeline and run our application again, we receive the following output (</span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.438.1">Figure 3</span></em></span><span class="No-Break"><em class="italic"><span class="koboSpan" id="kobo.439.1">.3</span></em></span><span class="No-Break"><span class="koboSpan" id="kobo.440.1">):</span></span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<span class="koboSpan" id="kobo.441.1"><img alt="Figure 3.3 – After our EmojiMiddleware is added to the pipeline" src="image/Figure_3.03_B19493.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.442.1">Figure 3.3 – After our EmojiMiddleware is added to the pipeline</span></p>
<p><span class="koboSpan" id="kobo.443.1">In this section, we built our first Middleware component by encapsulating the logic in a class, examined the </span><a id="_idIndexMarker156"/><span class="koboSpan" id="kobo.444.1">components pipeline using streams, and used the Middleware component in a </span><span class="No-Break"><span class="koboSpan" id="kobo.445.1">web application.</span></span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.446.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.447.1">In this chapter, we have gained a solid understanding of the Middleware pipeline, its components, and best practices for using Middleware in ASP.NET Core. </span><span class="koboSpan" id="kobo.447.2">We also learned about common practices when using Middleware, such as always using asynchronous methods, prioritizing the order, consolidating your Middleware components into groups, and encapsulating your Middleware into classes. </span><span class="koboSpan" id="kobo.447.3">Knowing these Middleware concepts is key to creating maintainable and </span><span class="No-Break"><span class="koboSpan" id="kobo.448.1">readable code.</span></span></p>
<p><span class="koboSpan" id="kobo.449.1">Finally, we finished the chapter by creating a simple component to replace text with an image in a stream for </span><span class="No-Break"><span class="koboSpan" id="kobo.450.1">the user.</span></span></p>
<p><span class="koboSpan" id="kobo.451.1">In the next chapter, we’ll begin looking at applying security to new and </span><span class="No-Break"><span class="koboSpan" id="kobo.452.1">existing applications.</span></span></p>
</div>
</body></html>