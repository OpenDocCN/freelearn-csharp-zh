- en: Movie Booking Web App
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'So far, we have been exploring the features and fundamentals of ASP.NET Core
    2.0\. The applications we have developed are good examples to learn the concepts
    but do not make use of data persistence. In this chapter, we will learn to do
    read, write, update, and delete data operations, making use of Entity Framework
    Core. We will also learn how to deploy a web app in Azure and monitor its health.
    We will demonstrate this by developing a simple movie booking web app, where a
    user can book a ticket for a movie. So, in this chapter, we will cover the following
    topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Entity Framework and Entity Framework Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started with Entity Framework Core
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Movie booking app requirements
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Designing the movie booking app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coding the movie booking app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying the movie booking app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Monitoring the movie booking app
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with an introduction to Entity Framework.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Entity Framework
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: So what is **Entity Framework** (**EF**)? Is it some other fancy framework that
    I need to learn? If these thoughts are coming to mind, get rid of them, as EF
    is just a set of .NET APIs for accessing data. EF is the official data access
    tool from Microsoft. Like most Microsoft products, it originated from Microsoft
    Research, and later it was adopted by the ADO.NET team as the next innovation
    in Microsoft's data access technology. EF has evolved over time. It had a sluggish
    start in 2008 when developers found it hard to digest a new way of accessing data.
    But with EF4 (yes, the second version of EF was 4, as it was aligned with .NET
    4), it had become the norm to use EF for data accessing with .NET. Continuing
    the journey, it became open source in version EF6 and moved to CodePlex ([http://www.codeplex.com](http://www.codeplex.com)).
    This opened up new avenues for EF. As it became open source, the community could
    make contributions as well. Now that CodePlex is archived, EF6 has moved to GitHub
    and is actively being developed.
  prefs: []
  type: TYPE_NORMAL
- en: EF is also referred to as an ORM. What is an ORM? An **ORM** stands for **object-relational
    mapping**, which broadly means mapping objects to relational tables. An ORM refers
    to the technique for converting data between two incompatible type systems. For
    example, let us consider a C# **plain old CLR object** (**POCO**) of a `Person`
    class. An instance of the `Person` class has the `Name`, `Id`, and `Age` properties
    of `string`, `int` and `int` types, respectively. In the SQL database, this data
    would be persisted in a table named `Person` with the columns `Name`, `Id`, `Age`,
    and so on. An ORM maps the `Person` POCO to the `Person` database table. The primary
    intent of an ORM is to try and shield the developer from having to write optimized
    SQL code for this inter-conversion. An ORMs are designed to reduce the friction
    between how data is structured in a relational database and how the classes are
    defined. Without an ORM, we typically need to write a lot of code to transform
    database results into instances of the classes. An ORM allows us to express our
    queries using our classes, and then an ORM builds and executes the relevant SQL
    for us, as well as materializing objects from the data that came back from the
    database. What I say here is an oversimplification and there's a lot more to an
    ORMs and to Entity Framework than this. Entity Framework can really enhance developer
    productivity and we will see this while developing the movie booking app. EF has
    a dedicated team at Microsoft. It has been around for almost a decade now. Rather
    than writing the relevant SQL to target whatever relational database you're working
    with, Entity Framework uses the **Language-Integrated Query** (**LINQ**) syntax
    that's part of the .NET framework. LINQ to Entities allows developers to use a
    consistent and strongly-typed query language irrespective of what database they're
    targeting. Additionally, LINQ to Objects is used for querying other elements of
    .NET, even `InMemory` objects, so developers benefit from their knowledge of LINQ.
  prefs: []
  type: TYPE_NORMAL
- en: Since we are working with .NET Core and want to make a cross-platform app, we
    cannot use Entity Framework, as it's not compatible with ASP.NET Core. Don't worry!
    We have solutions. Either we can compile our project against the full .NET Framework
    or we can use the latest and greatest version of Entity Framework called Entity
    Framework Core, which is a lightweight and cross-platform version of Entity Framework,
    rewritten from scratch to support a variety of platforms. Let's discuss Entity
    Framework Core.
  prefs: []
  type: TYPE_NORMAL
- en: Presenting Entity Framework Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: EF Core was released in June 2016 after more than 2 years of dedicated effort
    and following numerous alpha, beta, and even a few release candidate versions.
    It was originally named Entity Framework 7, but later its name was changed to
    Entity Framework Core. So what exactly is Entity Framework Core? The official
    Microsoft documentation ([https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/))
    describes Entity Framework Core as a lightweight and extensible version of Entity
    Framework. In other words, this is not simply an update from EF6; it's a brand
    new Entity Framework altogether. EF6 is still actively supported and will continue
    to have tweaks and fixes made to it, though for many reasons, all of the true
    innovation has gone into Entity Framework Core. Apart from new features that the
    team wanted to add to Entity Framework, there are also some critical and comprehensive
    themes for developing EF Core which align with ASP.NET Core and the underlying
    .NET Core. The idea behind developing EF Core is that it should be built from
    lightweight composable APIs; that is, it should be able to run on different operating
    systems that can host native implementations of the CoreCLR and, equally important,
    use modern software practices in the design, coding, and delivery of Entity Framework
    Core. Like EF6, EF Core is open source and available on GitHub. The source code
    of EF Core can be seen at [https://github.com/aspnet/EntityFrameworkCore](https://github.com/aspnet/EntityFrameworkCore).
    The EF team has a road map for the features that they are prioritizing and the
    order in which they will be shipped in the upcoming releases. The road map for
    EF Core can be seen at [https://github.com/aspnet/EntityFrameworkCore/wiki/roadmap](https://github.com/aspnet/EntityFrameworkCore/wiki/roadmap).
  prefs: []
  type: TYPE_NORMAL
- en: EF Core runs on .NET Core, and .NET Core runs in a lot of places, such as Windows
    and Linux-based systems, as we have seen in earlier chapters. It runs inside the
    full .NET Framework, so any version that is 4.5.1 or newer. .NET Core itself can
    run on the CoreCLR; that's the runtime. CoreCLR can run natively, not only on
    Windows, but also on Macintosh and Linux. EF Core can also be used with the **Universal
    Windows Platform** (**UWP**) for Windows 10, so it runs on any device or PC that
    can run on Windows 10\. So one may be tempted to think, should I use EF Core anywhere
    and everywhere, just because it is supported? The answer is *no*. This is a really
    important point to keep in mind. EF Core is a brand new set of APIs, and so it
    doesn't have all of the features that you might be used to with EF 6, and while
    some of those features will be coming in future versions of EF Core, there are
    a few that will never be part of EF Core, so it's important to understand this,
    and hence you may not want to start every single new project with EF Core. Before
    using EF Core, ensure that EF Core has all the features that you need. For a comprehensive
    list of features that are available in EF and EF Core and for a comparison, I
    would highly recommend that you visit the official Microsoft documentation describing
    the feature comparison between EF and EF Core in depth at [https://docs.microsoft.com/en-us/ef/efcore-and-ef6/features](https://docs.microsoft.com/en-us/ef/efcore-and-ef6/features).
  prefs: []
  type: TYPE_NORMAL
- en: 'For the sake of completeness, the subset of the feature comparison containing
    the important features are listed in the following table:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name of feature** | **EF6** | **EF Core** |'
  prefs: []
  type: TYPE_TB
- en: '| **Entity Data Model Extension** (**EDMX**) designer support | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Entity Data Model Wizard (for database first approach) | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Automatic migration | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Lazy loading of data | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Stored procedure mapping with DbContext | Yes | No |'
  prefs: []
  type: TYPE_TB
- en: '| Batch `Insert`, `Update`, `Delete` operations | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| In-memory provider for testing | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Support for **Inversion of Control** (**IoC**) | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| Field mapping | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: '| DbContext pooling | No | Yes |'
  prefs: []
  type: TYPE_TB
- en: If you are overwhelmed with this comparison and feel out of place with the listed
    features, do not worry. EF is indeed a huge topic to learn. However, we will learn
    to use it from scratch to have the basic fundamentals in place. To do so, we will
    learn to create a simple data access console application. Once we know how to
    use EF Core, we can then use it in our movie booking app.
  prefs: []
  type: TYPE_NORMAL
- en: Getting started with Entity Framework Core
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will create a simple console application to perform CRUD
    operations using Entity Framework Core. The intent is to get started with EF Core
    and understand how to use it. Before we dive into coding, let us see the two development
    approaches that EF Core supports:'
  prefs: []
  type: TYPE_NORMAL
- en: Code-first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Database-first
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These two paradigms have been supported for a very long time and therefore we
    will just look at them at a very high level. EF Core mainly targets the code-first
    approach and has limited support for the database-first approach, as there is
    no support for the visual designer or wizard for the database model out of the
    box. However, there are third-party tools and extensions that support this. The
    list of third-party tools and extensions can be seen at [https://docs.microsoft.com/en-us/ef/core/extensions/](https://docs.microsoft.com/en-us/ef/core/extensions/).
  prefs: []
  type: TYPE_NORMAL
- en: 'In the code-first approach, we first write the code; that is, we first create
    the domain model classes and then, using these classes, EF Core APIs create the
    database and tables, using migration based on the convention and configuration
    provided. We will look at conventions and configurations a little later in this
    section. The following diagram illustrates the code-first approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fec0da35-b58c-4829-a27d-92378b1fe6df.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In the database-first approach, as the name suggests, we have an existing database
    or we create a database first and then use EF Core APIs to create the domain and
    context classes. As mentioned, currently EF Core has limited support for it due
    to a lack of tooling. So, our preference will be for the code-first approach throughout
    our examples. The reader can discover the third-party tools mentioned previously
    to learn more about the EF Core database-first approach as well. The following
    image illustrates the database-first approach:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07b99ff7-0e84-471c-bcf9-f631183b3754.png)'
  prefs: []
  type: TYPE_IMG
- en: We will refer to properties as scalar properties and navigation properties.
    Although it's an old concept, it's worth revisiting it again to gain a better
    understanding. A property can contain primitive data (such as a string, an integer,
    or a Boolean value), or structured data (such as a complex type). Properties that
    are of a primitive type are also called **scalar** properties. The complex properties
    or properties of another non-simple type are referred to as **complex** or **navigation**
    properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we understand the approaches and know that we will be using the code-first
    approach, let''s dive into coding our getting started with EF Core console app.
    Before we do so, we need to have SQL Express installed in our development machine.
    If SQL Express is not installed, download the SQL Express 2017 edition from [https://www.microsoft.com/en-IN/sql-server/sql-server-downloads](https://www.microsoft.com/en-IN/sql-server/sql-server-downloads)
    and run the setup wizard. We will do the Basic installation of SQL Express 2017
    for our learning purposes, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/e7c5ae8b-25d4-423d-81e2-230772f4f052.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Our objective is to learn how to use EF Core and so we will not do anything
    fancy in our console app. We will just do simple **Create Read Update Delete**
    (**CRUD**) operations of a simple class called `Person`, as defined here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see in the preceding code, the class has simple properties. To perform
    the CRUD operations on this class, let''s create a console app by performing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new .NET Core console project named `GettingStartedWithEFCore`, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/35f82b30-fd0d-44d1-94b8-29bf7d83d6d7.png)'
  prefs: []
  type: TYPE_IMG
- en: Create a new folder named `Models` in the project node and add the `Person`
    class to this newly created folder. This will be our model entity class, which
    we will use for CRUD operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to install the EF Core package. Before we do that, it''s important
    to know that EF Core provides support for a variety of databases. A few of the
    important ones are:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: SQL Server
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: SQLite
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: InMemory (for testing)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The complete and comprehensive list can be seen at [https://docs.microsoft.com/en-us/ef/core/providers/](https://docs.microsoft.com/en-us/ef/core/providers/).
    We will be working with SQL Server on Windows for our learning purposes, so let''s
    install the SQL Server package for Entity Framework Core. To do so, let''s install
    the **`Microsoft.EntityFrameworkCore.SqlServer`** package from the NuGet Package
    Manager in Visual Studio 2017\. Right-click on the project. Select Manage Nuget
    Packages and then search for `Microsoft.EntityFrameworkCore.SqlServer`. Select
    the matching result and click Install:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/6e166ab1-fc79-462f-a408-58e7131240bc.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Next, we will create a class called `Context`, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The class looks quite simple, but it has the following subtle and important
    things to make note of:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Context` class derives from `DbContext`, which resides in the `Microsoft.EntityFrameworkCore`
    namespace. `DbContext` is an integral part of EF Core and if you have worked with
    EF, you will already be aware of it. An instance of `DbContext` represents a session
    with the database and can be used to query and save instances of your entities.
    `DbContext` is a combination of the Unit Of Work and Repository Patterns. Typically,
    you create a class that derives from `DbContext` and contains `Microsoft.EntityFrameworkCore.DbSet` properties
    for each entity in the model.
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: If properties have a `public` setter, they are automatically initialized when
    the instance of the derived context is created.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It contains a property named `Persons` (plural of the model class `Person`)
    of type `DbSet<Person&gt;`. This will map to the `Persons` table in the underlying
    database.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The class overrides the `OnConfiguring` method of `DbContext` and specifies
    the connection string to be used with the SQL Server database. The connection
    string should be read from the configuration file, `appSettings.json`, but for
    the sake of brevity and simplicity, it's hardcoded in the preceding code. The
    `OnConfiguring` method allows us to select and configure the data source to be
    used with a context using `DbContextOptionsBuilder`. Let's look at the connection
    string. `Server=` specifies the server. It can be `.\SQLEXPRESS`, `.\SQLSERVER`,
    `.\LOCALDB`, or any other instance name based on the installation you have done.
    `Database=` specifies the database name that will be created. `Trusted_Connection=True`
    specifies that we are using integrated security or Windows authentication. An
    enthusiastic reader should read the official Microsoft Entity framework documentation
    on configuring the context at [https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext](https://docs.microsoft.com/en-us/ef/core/miscellaneous/configuring-dbcontext).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `OnModelCreating` method allows us to configure the model using the `ModelBuilder`
    Fluent API. This is the most powerful method of configuration and allows configuration
    to be specified without modifying the entity classes. The Fluent API configuration
    has the highest precedence and will override conventions and data annotations.
    The preceding code has same effect as the following data annotation has on the
    `Name` property in the `Person` class:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding point highlights the flexibility and configuration that EF Core
    brings to the table. EF Core uses a combination of conventions, attributes, and
    Fluent API statements to build a database model at runtime. All we have to do
    is to perform actions on the model classes using a combination of these and they
    will automatically be translated to appropriate changes in the database. Before
    we conclude this point, let''s have a quick look at each of the different ways
    to configure a database model:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**EF Core conventions**: The conventions in EF Core are comprehensive. They
    are the default rules by which EF Core builds a database model based on classes.
    A few of the simpler yet important default conventions are listed here:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: EF Core creates database tables for all `DbSet<TEntity&gt;` properties in a
    `Context` class with the same name as that of the property. In the preceding example,
    the table name would be `Persons` based on this convention.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: EF Core creates tables for entities that are not included as `DbSet` properties
    but are reachable through reference properties in the other `DbSet` entities.
    If the `Person` class had a complex/navigation property, EF Core would have created
    a table for it as well.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: EF Core creates columns for all the scalar read-write properties of a class
    with the same name as the property by default. It uses the reference and collection
    properties for building relationships among corresponding tables in the database.
    In the preceding example, the scalar properties of `Person` correspond to a column
    in the `Persons` table.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: EF Core assumes a property named `ID` or one that is suffixed with `ID` as a
    primary key. If the property is an `integer` type or `Guid` type, then EF Core
    also assumes it to be `IDENTITY` and automatically assigns a value when inserting
    the data. This is precisely what we will make use of in our example while inserting
    or creating a new `Person`.
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'EF Core maps the data type of a database column based on the data type of the
    property defined in the C# class. A few of the mappings between the C# data type
    to the SQL Server column data type are listed in the following table:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '| **C# data type** | **SQL server data type** |'
  prefs: []
  type: TYPE_TB
- en: '| `int` | `int` |'
  prefs: []
  type: TYPE_TB
- en: '| `string` | `nvarchar(Max)` |'
  prefs: []
  type: TYPE_TB
- en: '| `decimal` | `decimal(18,2)` |'
  prefs: []
  type: TYPE_TB
- en: '| `float` | `real` |'
  prefs: []
  type: TYPE_TB
- en: '| `byte[]` | `varbinary(Max)` |'
  prefs: []
  type: TYPE_TB
- en: '| `datetime` | `datetime` |'
  prefs: []
  type: TYPE_TB
- en: '| `bool` | `bit` |'
  prefs: []
  type: TYPE_TB
- en: '| `byte` | `tinyint` |'
  prefs: []
  type: TYPE_TB
- en: '| `short` | `smallint` |'
  prefs: []
  type: TYPE_TB
- en: '| `long` | `bigint` |'
  prefs: []
  type: TYPE_TB
- en: '| `double` | `float` |'
  prefs: []
  type: TYPE_TB
- en: There are many other conventions, and we can define custom conventions as well.
    For more details, please read the official Microsoft documentation at [https://docs.microsoft.com/en-us/ef/core/modeling/](https://docs.microsoft.com/en-us/ef/core/modeling/).
  prefs: []
  type: TYPE_NORMAL
- en: '**Attributes**: Conventions are often not enough to map the class to database
    objects. In such scenarios, we can use attributes called data annotation attributes
    to get the desired results. The `[Required]` attribute that we have just seen
    is an example of a data annotation attribute.'
  prefs:
  - PREF_UL
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Fluent API**: This is the most powerful way of configuring the model and
    can be used in addition to or in place of attributes. The code written in the
    `OnModelConfiguring` method is an example of a Fluent API statement.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'If we check now, there is no `PersonDatabase` database. So, we need to create
    the database from the model by adding a migration. EF Core includes different
    migration commands to create or update the database based on the model. To do
    so in Visual Studio 2017, go to Tools | Nuget Package Manager | Package Manager
    Console, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/6d137a6b-e4fc-44b4-b98e-690d5f6be93a.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This will open the Package Manager Console window. Select the Default Project
    as `GettingStartedWithEFCore` and type the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'If you are not using Visual Studio 2017 and you are dependent on .NET Core
    CLI tooling, you can use the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We have not installed the `Microsoft.EntityFrameworkCore.Design` package, so
    it will give an error:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'So let''s first go to the NuGet Package Manager and install this package. After
    successful installation of this package, if we run the preceding command again,
    we should be able to run the migrations successfully. It will also tell us the
    command to undo the migration by displaying the message `To undo this action,
    use Remove-Migration`. We should see the new files added in the Solution Explorer
    in the `Migrations` folder, as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3dc76353-f5e6-4551-9329-0c3f916d9afc.png)'
  prefs: []
  type: TYPE_IMG
- en: Although we have migrations applied, we have still not created a database. To
    create the database, we need to run the following commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In Visual Studio 2017:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'In .NET Core CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: If all goes well, we should have the database created with the `Persons` table
    (property of type `DbSet<Person&gt;`) in the database. Let's validate the table
    and database by using **SQL Server Management Studio** (**SSMS**). If SSMS is
    not installed in your machine, you can also use Visual Studio 2017 to view the
    database and table.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s check the created database. In Visual Studio 2017, click on the View
    menu and select Server Explorer, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/d55398f1-a213-44cd-a87e-95351d283d60.png)'
  prefs: []
  type: TYPE_IMG
- en: 'In Server Explorer, right-click on Data Connections and then select Add Connection.
    The Add Connection dialog will show up. Enter `.\SQLEXPRESS` in the Server name
    (since we installed SQL EXPRESS 2017) and select `PersonDatabase` as the database,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7ed2a195-3cc8-47fb-838e-6aab77eaf8bd.png)'
  prefs: []
  type: TYPE_IMG
- en: 'On clicking OK, we will see the database named `PersonDatabase` and if we expand
    the tables, we can see the `Persons` table as well as the `_EFMigrationsHistory`
    table. Notice that the properties in the `Person` class that had setters are the
    only properties that get transformed into table columns in the `Persons` table.
    Notice that the `Age` property is read-only in the class we created and therefore
    we do not see an age column in the database table, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/14616bd5-4e82-40e5-b72d-44a1d60243f2.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This is the first migration to create a database. Whenever we add or update
    the model classes or configurations, we need to sync the database with the model
    using the `add-migration` and `update-database` commands. With this, we have our
    model class ready and the corresponding database created. The following image
    summarizes how the properties have been mapped from the C# class to the database
    table columns:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/897622d5-4096-4df1-9e21-f5dc1cab8a04.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we will use the `Context` class to perform CRUD operations.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s go back to our `Main.cs` and write the following code. The code is well
    commented, so please go through the comments to understand the flow:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: With this, we have completed our sample app to get started with EF Core. I hope
    this simple example will set you up to start using EF Core with confidence and
    encourage you to start exploring it further. The detailed features of EF Core
    can be learned from the official Microsoft documentation available at[ https://docs.microsoft.com/en-us/ef/core/](https://docs.microsoft.com/en-us/ef/core/).
    Now that we have an understanding of EF Core, we are ready to use it in our movie
    booking app. Let's check out the requirements for the movie booking app.
  prefs: []
  type: TYPE_NORMAL
- en: Movie booking app requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will discuss the requirements for developing our movie booking
    web app in ASP.NET Core 2.0\. To keep things simple and understandable, we will
    create a single-screen cinema hall and not a multiplex. The requirements for our
    sample movie booking app are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: 'As a user or a movie buff, I should be able to:'
  prefs: []
  type: TYPE_NORMAL
- en: See the list of movies showing in the cinema hall with timings
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: See the short description and star cast of the movie before booking
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select seats from the available seats
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Book the selected seats
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Optionally log in to the seat with Facebook/Google credentials or continue as
    a guest.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now that we have the requirement specifications in place, let''s see the activity
    flow of the app and come up with a flowchart. The following is the rough flowchart
    of the app workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/930aeded-ad9b-4930-8e75-1a8ac90dfaa0.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s discuss this flowchart in detail:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Start**: This is the start of the flow. The user browses the movie booking
    app.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Now Showing Movie Listing**: The user can see the the list of movies with
    timings that are shown in the cinema hall.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Movie description**: The user can optionally check out the movie description
    by clicking on the selected movie in the list.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Select movie and show**: The user can select an available show.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Choose Seat**: The user can choose a seat from the available seats for the
    chosen show.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Optional Login**: The user can optionally log in to the web app or continue
    as a guest.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Finish**: We will not be implementing a payment interface, as we only intend
    to learn ASP.NET Core and EF Core. Upon choosing the seat and navigating ahead,
    we finish the flow.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have an understanding of the requirements and a fair idea of what
    we wish to achieve, let's design the movie booking app.
  prefs: []
  type: TYPE_NORMAL
- en: Designing the movie booking app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will do a high-level design of our movie booking web app
    using ASP.NET Core 2.0\. The high-level design of the app is pretty simple, as
    shown in the following diagram:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/97ecfe77-cb6e-44b7-a385-ac870819e1af.png)'
  prefs: []
  type: TYPE_IMG
- en: We can see that an **Online user** browses the **Movie Booking Web app**, which
    is an Azure web app. Ideally, there should be a service layer in between the **Movie
    Booking Web app** and the **Database**, to allow for a neat, extensible, modular,
    and layered architecture. However, for the purpose of learning, we will keep things
    simple and eliminate the service layer for now. The web app gets data and stores
    the data in the SQL Azure database. If you are worrying about the Azure web app
    or SQL Azure, stop doing so. We will develop the app locally development machine
    and deploy it in Azure, and at that time we will take care of the Azure web app
    and SQL Azure.
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the requirements, we need to design the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A user interface of the movie booking web app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A page to list all the movies currently being shown. We will need to design
    the database model to show the list of the movies currently being shown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A page to display the details of the selected movie.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A page to display the available seats to choose from.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A login/authentication module using Facebook or Gmail.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'For *Steps 2* to *4*, we need to do database modeling. We will use SQL Express
    on Windows and use EF Core, which we discussed earlier. Let''s do the class design
    to fulfill the requirements and create the database following the code-first approach.
    A movie booking system is a complicated and time-consuming system to make. However,
    what we will make here is a very simple and limited version of a movie booking
    system, so that we can focus on learning fundamentals rather than on the design
    of the system. From the requirements, it is clear that we need to have a `Movie`
    class to contain the movie information and an `Auditorium` class where the movie
    will be shown. The information about which movie is being shown in the auditorium
    should be stored in a `Show` class. The auditorium has seats, so we will need
    a `Seat` class so that the user can choose a seat and book it using a `Booking`
    class to get a ticket through the `Ticket` class. It''s worth reiterating that
    this is a an over-simplistic design to enable an easy grasp of the system the
    actual system; may be more complex. The following diagram shows how our classes
    will be designed as per the preceding analysis:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/731a4066-a800-4215-b694-17ab4db637cc.png)'
  prefs: []
  type: TYPE_IMG
- en: Since we are using EF Core, our database model will be a replica of these classes,
    as we saw in the earlier section on getting started with EF Core. Once we are
    done with these, we will have to develop a simple application that will just do
    CRUD operations. Now that we have a high-level architecture and class diagrams
    in place, let's start the coding of the web app.
  prefs: []
  type: TYPE_NORMAL
- en: Coding the movie booking app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will code the movie booking app, according to the requirements
    and design we put together in the preceding sections. We will be using the EF
    Core code-first approach with SQL Express. To make the coding easy to understand,
    we will code in a step-by-step manner. The steps are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new ASP.NET Core 2.0 MVC app named `MovieBooking`, as we did in the
    *Creating a simple running code* section of [Chapter 1](ch01.html), *Getting Started*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'If you wish to add authentication in your web app, you can click on the Change
    Authentication button at the time of selecting the template, as shown in the following
    screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/76ff1b1c-02f3-4add-bb9b-7700825780fc.png)'
  prefs: []
  type: TYPE_IMG
- en: A new dialog will display, as shown in the following screenshot, which will
    offer multiple authentication options to us, as we discussed in [Chapter 3](ch03.html),
    *Building Our First .NET Core Game – Tic-Tac-Toe*. To keep things simple, you
    can select Individual User Accounts and then choose Store user accounts in-app.
    This will do all the boilerplate code needed to enable the app-level user registration,
    sign-in, and sign-out functionality. Since we have already seen how to use OpenID
    Connect using the Facebook authentication provider in the Let's Chat web application,
    we will not go deep into this part and we encourage the reader to reuse the same
    code and explore and extend it further.
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/3d191f83-e423-46ff-8855-36168eb41901.png)'
  prefs: []
  type: TYPE_IMG
- en: Next, we will add the `Models` folder in the project and add the classes for
    `Auditorium`, `Movie`, `Show`, `Seat`, `Booking`, and `Ticket` that we designed
    in the preceding section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The code for the classes is listed next. Since the properties are self-explanatory
    by virtue of their naming, comments are not explicitly added, to maintain brevity:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: With this, the models are ready.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to install EF Core packages to make use of all the EF Core benefits,
    so let's install the `Microsoft.EntityFrameworkCore.SqlServer` and `Microsoft.EntityFrameworkCore.Design` NuGet
    packages in our project from the NuGet Package Manager. We have already done this
    while making the `GettingStartedWithEFCore` app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Now, we need to create the context class to create the database based on this
    model. We will create the model named `MovieBookingContext`, as shown in the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'Notice that `MovieBookingContext` doesn''t have the `OnConfiguring` method
    call that we used to configure the SQL database in our last EF Core sample. This
    is to show a different way of configuring the database. We will read the connection
    string from the `appsettings.json` configuration file, which has the following
    configuration entry:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we will configure the database through the context by reading the configuration
    in the `ConfigureServices` method of `Startup.cs`, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'After developing the context, we need to create the database. To do so, we
    we need to run the following commands in order. The first command will add the
    migration and the second command will actually create the database:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Now we have the database, but we do not have the necessary data in the tables
    to list the movie information. To do so, we can either write a script, a small
    EF Core-based program, or enter it manually in the table. Since this is SQL stuff,
    we will not go into great detail, but an aware reader should be able to insert
    this data in the corresponding tables correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Next, we need to create controllers and views for the screens and wire up the
    data access layer. At the outset, the user should be able to see the list of shows
    in the home screen, so we will develop the home screen first. To do so, we will
    reuse the `Index` action of `HomeController.cs` as it is and modify the `Index`
    view to display the user interface, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/f0f66a26-3414-4da4-85fa-b82dc1db8889.png)'
  prefs: []
  type: TYPE_IMG
- en: There is nothing fancy here. The user interface has an image carousel, which
    displays the posters of the movies and the quick booking section, which lists
    the movies and show times. Just replace the URLs of the default carousel (which
    comes out of the box in the default template) with the image URLs of movie posters
    by searching them online through Bing.
  prefs: []
  type: TYPE_NORMAL
- en: To show the list of movies, we need an API returning the list of movies called
    as `GetMovies` API. Recall that we have added the movie data in the database already,
    so we have movies to be fetched. On selecting a movie, we need to fetch the available
    show times for the movie, so we need another API to fetch the show time based
    on the movie called `GetShowTimesForMovie` API. We have seen how to create APIs
    using the `Context` object in the *Getting started with Entity Framework Core* section.
    We then wire up the APIs to the controller to populate data in the view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On clicking the Book button, the user is navigated to the seat selection page.
    To display the seats, we again need an API to get the available seats for a show
    named `GetAvailableSeatsForShow` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On clicking a movie, we can view the selected movie details. The data for this
    comes through the `GetMovieDetails` API.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Similarly, the UI and corresponding APIs are developed, as now it's just a simple
    app, that fetches the data from the database and displays it in the user interface.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The complete source code can be seen at [https://github.com/PacktPublishing/.NET-Core-2.0-By-Example](https://github.com/PacktPublishing/.NET-Core-2.0-By-Example),
    which lists all the APIs and the view code that we discussed previously. It also
    has a script, that can be executed to insert the sample data into the application.
  prefs: []
  type: TYPE_NORMAL
- en: We will next look at deploying this app.
  prefs: []
  type: TYPE_NORMAL
- en: Deploying the movie booking app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We have already deployed one of our sample web apps in Azure and this is no
    different. The assumption here is that the reader already has an Azure subscription
    and is logged in with the email ID used for the subscription. If this is not the
    case, please go through the previous chapters where we have discussed Azure subscription
    at length. Let''s have a look at steps to deploy our movie booking app on the
    cloud:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Visual Studio Solution Explorer window, right-click on the `MovieBooking`
    project and then click Publish. It will open a Publish dialog.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Select Create New and then click OK. It will open the Create App Service dialog.
    Enter the required fields, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/13ff8b9c-0e4b-4d90-a1f6-9f57f96447d8.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After filling in all the required input, click on Services on the left panel.
    It will display the following dialog:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/bc5bb555-6f17-48ef-a20e-f53e94187209.png)'
  prefs: []
  type: TYPE_IMG
- en: 'We need a database for our app to function and the dialog shows the SQL Database
    as the additional Azure resource that we need to deploy. Click on the + icon on
    the right-hand side. It will open a new dialog Configure SQL Database, as shown
    in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/26ae03e3-88c9-4c55-9713-2c834700654b.png)'
  prefs: []
  type: TYPE_IMG
- en: Enter the required details. Make a note of the username and password as well
    as the database name and connection string name, as these will be used in the
    code. Click OK and then click Create. This will create the publish profile and
    deploy the app.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'However, we need to ensure that our database gets created, our intended connection
    string is used, and migrations are applied. To do so, in the Publish window, click
    on the Settings link, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/1cf37f5d-47f9-4ad8-af3e-abc60e26fc78.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The Publish dialog will open. On the Settings tab, ensure that for DefaultConnection,
    under the Databases section, the Use this connection string at runtime checkbox
    is checked, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7edf2b7b-7c35-4751-a62f-9460078bc74e.png)'
  prefs: []
  type: TYPE_IMG
- en: If you deploy for the first time, you may also see Entity Framework Migrations,
    just like the Databases section shown in the preceding screenshot. If so, please
    check Apply this migration on publish. Since I have already applied the migrations,
    I don't have it in in preceding screenshot.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click Save and then click Publish. This will publish the web app as well as
    the database and migrations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With this, our web app is deployed and after successful deployment, the app
    will automatically be launched in the browser. The sample app can be seen at [http://packtmoviebookingapp.azurewebsites.net/](http://packtmoviebookingapp.azurewebsites.net/).
  prefs: []
  type: TYPE_NORMAL
- en: Monitoring the movie booking app
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Coding and deploying an app is fine, but it's equally important to ensure that
    the app keeps running fine once it's deployed in production and end users start
    using it. So monitoring an app is quite important. In this section, we will learn
    to add Application Insights in our web app and also touch upon various out-of-the
    box monitoring options provided by Azure. We will start with Application Insights.
  prefs: []
  type: TYPE_NORMAL
- en: Application Insights
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Application Insights is an extensible **Application Performance Management**
    (**APM**) service for web developers on multiple platforms to monitor web applications
    for performance, usability, and availability. It automatically detects performance
    issues. It includes powerful analytics tools to help us diagnose issues and to
    understand what users actually do with our app. How cool is that? We can find
    out about the most and least used features of our web app using Application Insights.
    We can use the actionable insights from Application Insights to continuously improve
    the performance and usability of the app. I have personally found Application
    Insights very useful in diagnosing and fixing performance issues. This is a proactive
    way of identifying the issue, rather than waiting for the end user to experience
    an issue and then reporting it. Let''s start with enabling Application Insights
    in our movie booking web app. To do so, we need to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Visual Studio 2017 Solution Explorer, expand the `MovieBooking` project
    and click on Connected Services. This will display the Connected Services page,
    as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/4681682e-ae87-4bc9-ba98-0f1ba9f23f1b.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Monitoring with Application Insights. This will open the Application
    Insights configuration screen, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/0222fc40-c975-49c2-a38d-d822610e96db.png)'
  prefs: []
  type: TYPE_IMG
- en: 'This same screen can be reached by right-clicking on the `MovieBooking` project
    in Solution Explorer and then clicking Add | Application Insights Telemetry, as
    shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9e32d207-0007-44d7-8222-8be27f93367e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on the Start Free button. This will take us to the registration screen,
    shown in the following screenshot. Choose the Subscription and Resource based
    on your requirements. Here, I have created a new resource but you may want to
    reuse an existing resource. We will go with the free variant, so choose the option
    in which Application Insights will remain free and halt data collection after
    the quota of 1 GB / Month is exhausted:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/7efba094-9332-4890-beb9-7b22f357900c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Click on Register. This may take a while and hence show a progress bar, shown
    in the following screenshot. Look at the screenshot and we can see how powerful
    Application Insights is. It has Smart Detection, App Map, Analytics, and CodeLens,
    among other great features:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/92992cb8-e8c8-4c5d-aed7-342110055388.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Once the configuration is done, the progress bar will disappear. Application
    Insights telemetry should now be enabled in the selected project. The configuration
    will add the instrumentation key in `appsettings.json` as well and so, after successfully
    enabling Application Insights, you may get a prompt that the file has been modified.
    This is fine and expected, so click OK:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![](img/fb6c148e-0080-4300-b593-542a5f24e119.png)'
  prefs: []
  type: TYPE_IMG
- en: We are now ready to monitor the web app after publishing it to remain in sync
    with the instrumentation key changes and Application Insight SDK changes that
    we have just done. With this, we are done with setting up Application Insights.
    Now, we will see how we can monitor the web app and leverage the benefits of Application
    Insights. We can see the telemetry data of our local debugging setup in Visual
    Studio itself, while the Azure portal is where we can see the insights of our
    deployed application.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Visual Studio Solution Explorer, we will now have the `Application Insights`
    folder inside Connected Services for our movie booking project, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/07a76aa4-a605-46cb-a5fd-70842687218f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Right-click on the Application Insights folder and we will get a number of
    options. A few of the important ones are shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1c8b7ec0-0542-4d8d-b399-f1b7e8e72307.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Here are the explanations of these options:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open Application Insights Portal: This will directly open Application Insights
    in the Azure web portal.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application Analytics: This will open the application analytics portal, where
    we can perform detailed analytics and filtering of data.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Application Map: This will open the application map for the project in the
    Azure portal. The application map helps us to spot performance bottlenecks or
    failure hotspots across all components of the distributed application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configure Application Insights: This can be used to configure Application Insights.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Choose Telemetry Source: This configures the app that will be used as the telemetry
    source. By default, the current web app will be the telemetry source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Search Live Telemetry: This searches the data in the telemetry from Visual
    Studio or in the Azure web portal. Using this, we can also see debug telemetry
    data from the Visual Studio debugging.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To conclude this discussion, let us see the Application Insights data that
    was collected while I wrote this section. The following screenshot shows what
    it looks like for the movie booking app that we developed:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/9d1a814a-402e-47a4-a5f0-bcf70a63cd92.png)'
  prefs: []
  type: TYPE_IMG
- en: Application Insights is a huge topic and one section of a chapter doesn't do
    justice to this great and important feature. For a thorough and detailed coverage
    Application Insights, I would highly recommend readers to read the wonderful documentation
    on Application Insights at [https://docs.microsoft.com/en-us/azure/application-insights/](https://docs.microsoft.com/en-us/azure/application-insights/).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we have looked at Application Insights, which is a great monitoring
    tool in the developer's repertoire. However, Azure has much more to offer in terms
    of monitoring options and we will explore these in the next chapter, where I will
    also discuss how to use Application Insights telemetry data to investigate issues.
    With this note, we conclude this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned about Entity Framework and Entity Framework Core,
    and understood the features of each and the differences between the two. We also
    learned that we should use EF Core only if EF cannot be used or there is a pressing
    cross-platform requirement to use EF Core. We learned how to do CRUD operations
    using EF Core by creating a simple app. We then developed a simple movie booking
    app and learned how to deploy it using Visual Studio. We also saw how we can monitor
    our web app by enabling Application Insights. So far, we have only seen monolithic
    apps where all the APIs reside in one web app. If that one web app goes down,
    our entire app can come to a standstill. There is a way to circumvent this by
    deploying the app in smaller, independent modules, called microservices. In the
    next chapter, we will explore microservices.
  prefs: []
  type: TYPE_NORMAL
