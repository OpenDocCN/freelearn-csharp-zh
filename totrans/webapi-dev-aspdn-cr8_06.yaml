- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data Access in ASP.NET Core (Part 2 – Entity Relationships)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 5*](B18971_05.xhtml#_idTextAnchor198), we introduced the fundamentals
    of `DbContext` class and how to use it to access data.
  prefs: []
  type: TYPE_NORMAL
- en: You can recap the basic concepts of relationships in [*Chapter 1*](B18971_01.xhtml#_idTextAnchor012),
    in the *Defining the Relationships between Resources* section, where we introduced
    relationships between resources. For example, in a blog system, a post has a collection
    of comments, and a user has a collection of posts. In an invoice system, an invoice
    has a collection of invoice items, and an invoice item belongs to an invoice.
    An invoice also has a contact, which can have one or more contact persons and
    can have one address.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will continue to explore the features of EF Core. We will
    learn how to manage relationships between entities using Fluent APIs. Finally,
    we will discuss how to implement CRUD operations for entities with relationships.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding one-to-many relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding one-to-one relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding many-to-many relationships
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding owned entities
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: After reading this chapter, you should be able to configure relationships between
    entities using Fluent APIs in EF Core and implement CRUD operations for entities
    with relationships in your ASP.NET Core applications.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The code examples in this chapter can be found at [https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter6](https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter6).
    You can use VS 2022 or VS Code to open the solutions.
  prefs: []
  type: TYPE_NORMAL
- en: 'You are expected to have basic knowledge of **Structured Query Language** (**SQL**)
    queries and **Language-Integrated Query** (**LINQ**). If you are not familiar
    with them, you can refer to the following resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SQL** **queries**: [https://www.w3schools.com/sql/](https://www.w3schools.com/sql/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**LINQ**: [https://learn.microsoft.com/en-us/dotnet/csharp/linq/](https://learn.microsoft.com/en-us/dotnet/csharp/linq/)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding one-to-many relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One-to-many relationships are the most common relationships in a relational
    database. They are also called **parent-child (children)** relationships. For
    example, an invoice has a collection of invoice items. In this section, we will
    learn how to configure a one-to-many relationship in EF Core and how to implement
    CRUD operations for entities with a one-to-many relationship.
  prefs: []
  type: TYPE_NORMAL
- en: Let us continue to use the invoice sample application. You can find the sample
    code of the `EfCoreRelationshipsDemo` project in the `chapter6` folder. If you
    would like to test the code following the book, you can continue to work on the
    `BasicEfCoreDemo` project. Note that the `InvoiceDbContext` class has been renamed
    `SampleDbContext` in the sample code.
  prefs: []
  type: TYPE_NORMAL
- en: Next, let us update the `Invoice` class and create an `InvoiceItem` class, then
    define the one-to-many relationship between them.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To demonstrate a one-to-many relationship, we need to add a new class named
    `InvoiceItem` in the `Models` folder and add some additional properties to the
    `Invoice` class to represent the relationship between them.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code of the `InvoiceItem` class is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The `InvoiceItem` class has a set of properties to store the invoice item data,
    such as `Name`, `Description`, `UnitPrice`, and so on. It also has an `InvoiceId`
    property to store the ID of the invoice that the invoice item belongs to, and
    an `Invoice` property to reference the invoice. To get started with the configuration
    process, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Update the `Invoice` class as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In the preceding code, we defined a relationship between `Invoice` and `InvoiceItem`.
    An invoice has a collection of invoice items, and an invoice item belongs to an
    invoice. It is a one-to-many relationship, where we can identify these terms:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '`Invoice` is the principal entity.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvoiceItem` is the dependent entity. It has an `InvoiceId` foreign key property
    to identify the parent entity.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Id` property of the `Invoice` class is the principal key.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvoiceId` property of the `InvoiceItem` class is the foreign key, which is
    used to store the principal key value of the parent entity.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`InvoiceItems` property of the `Invoice` class is a collection navigation property.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Invoice` property of the `InvoiceItem` class is a reference navigation property.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Because we added a new model, we need to update the `DbContext` class. Open
    the `SampleDbContext` class and add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, it is a good practice to configure the mapping for the new model. Add
    a new class in the `Data` folder and name it `InvoiceItemConfiguration`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Once we define navigation properties for `Invoice` and `InvoiceItem`, EF Core
    can discover the relationship between these two entities. Let us create a migration
    using the `dotnet ef migrations add AddInvoiceItem` command. Then, check the generated
    migration file. You will find that EF Core has added the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: EF Core will create a new `InvoiceItems` table and add a foreign key constraint
    to the `InvoiceId` column. The name of the foreign key constraint is `FK_<dependent
    type name>_<principal type name>_<foreign key property name>`. It will also create
    an index on the `InvoiceId` column.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Another thing you need to be aware of is that the `onDelete` action is set to
    `ReferentialAction.Cascade`, which means that if the parent entity is deleted,
    all related child entities will also be deleted.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s think about a question – what if we do not have the `InvoiceId` property
    in the `InvoiceItem` class? Can EF Core still discover the relationship between
    these two entities? You can use the `dotnet ef migrations remove` command to remove
    the last migration, delete the `InvoiceId` property in the `InvoiceItem` class,
    and then add a migration again. You will see that EF Core can still create a column
    named `InvoiceId` in the `InvoiceItems` table, and apply the foreign key constraint
    to it, which is called **shadow foreign key** property. This is because EF Core
    has its built-in convention to do this. There are a few scenarios where EF Core
    can discover one-to-many relationships between entities:'
  prefs: []
  type: TYPE_NORMAL
- en: The dependent entity has a reference navigation property to the principal entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The principal entity has a collection navigation property to the dependent entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reference navigation property and the collection navigation property are
    included at both ends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The reference navigation property and the collection navigation property are
    included at both ends, and the foreign key property is included in the dependent
    entity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can explicitly configure the relationship between entities to change the
    default behavior of EF Core if the convention does not work for us. Follow these
    steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To explicitly configure the one-to-many relationship between entities, we can
    use the `HasOne()`, `WithMany()`, and `HasMany()`, `WithOne()` methods. Add the
    following code to the `InvoiceConfiguration` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `HasMany()` method is used to configure the collection navigation property,
    and the `WithOne()` method is used to configure the reference navigation property.
    The `HasForeignKey()` method is used to configure the foreign key property. So,
    the preceding code explicitly configures that one invoice can have many invoice
    items, and the `InvoiceId` property of the `InvoiceItem` class is the foreign
    key. If you add a migration now, you will find that EF Core will generate the
    same code as that generated by the convention.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'A relationship can be also defined for the `InvoiceItem` class. Remove the
    preceding configuration code for the `Invoice` class, and add the following code
    to the `InvoiceItemConfiguration` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: It should be easy to understand now. The `HasOne()` method is used to configure
    the reference navigation property, and the `WithMany` method is used to configure
    the collection navigation property.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Note that we also explicitly configured the `OnDelete()` action to `Cascade`,
    which is the same as the one generated by the convention. But we can change it
    to other options if needed. That said, the Fluent API is more flexible than the
    convention.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We just need to configure the relationship on one side of the relationship.
    So, please clean up the test code before you add the migration file and apply
    the migration to the database. After the migration is applied, you can check the
    database schema to see if the foreign key constraint is created, as shown in the
    following figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.1 – A foreign key constraint is created in the database](img/B18971_06_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – A foreign key constraint is created in the database
  prefs: []
  type: TYPE_NORMAL
- en: As a one-to-many relationship can be defined in either direction, which side
    should we configure the relationship on? It depends on the scenario. If the two
    entities have a strong one-to-many relationship, it does not really matter which
    side we configure the relationship on. But if the two entities are loosely coupled,
    we had better configure the relationship on the dependent entity.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a `User` entity is shared by many other entities, such as `Post`,
    `Comment`, `Invoice`, and so on. Each `Post` entity can have an `Author` property
    that is a reference navigation property to the `User` entity, and `Comment` and
    `Invoice` also do the same. However, the `User` entity does not need to have the
    collection navigation properties to the `Post`, `Comment`, and `Invoice` entities.
    In this case, we should configure the relationship on the `Post`, `Comment`, and
    `Invoice` entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure this kind of relationship, we can ignore the parameter for the
    `WithMany` method, because the `User` entity does not have the collection navigation
    property to the `Post` entity, as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Next, let's see how we implement CRUD operations for entities with a one-to-many
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-many CRUD operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: CRUD operations for entities with a one-to-many relationship differ from those
    without a relationship. For example, when retrieving an invoice, we may need to
    query both the `Invoices` table and the `InvoiceItems` table in order to also
    retrieve the associated invoice items. Additionally, when deleting an invoice,
    we must consider whether to delete the related invoice items as well.
  prefs: []
  type: TYPE_NORMAL
- en: EF Core can assist us in managing various scenarios. For instance, when we need
    to retrieve an invoice and its invoice items, EF Core can generate a `LEFT JOIN`
    query to join the two tables. To implement CRUD operations for entities with a
    one-to-many relationship, let us explore the following sections.
  prefs: []
  type: TYPE_NORMAL
- en: Creating data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, let us create a new invoice with a few invoice items. You do not need
    to update the code of the `PostInvoice` action:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application using `dotnet run`. Send a `POST` request to the `/api/Invoices`
    endpoint. The JSON body is like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The exception is thrown because the `Invoice` class has a collection navigation
    property to the `InvoiceItem` class, and the `InvoiceItem` class has a reference
    navigation property to the `Invoice` class. So, there is a cycle in the JSON serialization.
    Some serialization frameworks, such as `Newtonsoft.Json`, `System.Text.Json`,
    do not allow such cycles. ASP.NET Core uses `System.Text.Json` for JSON serialization
    by default. So, we need to configure the `System.Text.Json` framework to ignore
    the cycle.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Open the `Program.cs` file and add the following code to `builder.Services.AddControllers()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Another way to fix the exception is to use the `[JsonIgnore]` attribute to decorate
    the `Invoice` property in the `InvoiceItem` class. But if you have many entities
    with such a relationship, it is tedious to decorate all of them. Choose the way
    you prefer.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'This exception occurs after data is saved to the database. So, if you check
    the database, you will find that the invoice and the invoice items are saved to
    the database:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '![Figure 6.2 – The invoice items are saved to the database with the invoice
    ID](img/B18971_06_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – The invoice items are saved to the database with the invoice ID
  prefs: []
  type: TYPE_NORMAL
- en: What is System.Text.Json?
  prefs: []
  type: TYPE_NORMAL
- en: '`System.Text.Json` is a new JSON serialization framework provided since .NET
    Core 3.0\. It is faster and more efficient than `Newtonsoft.Json`. It is also
    the default JSON serialization framework in ASP.NET Core 3.0 and later versions.
    It is recommended to use `System.Text.Json` instead of `Newtonsoft.Json` in new
    projects.'
  prefs: []
  type: TYPE_NORMAL
- en: 'From the preceding example, you can see these points:'
  prefs: []
  type: TYPE_NORMAL
- en: EF Core generates an `Id` property of the principal entity if it is not defined
    in the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EF Core generates an `Id` property of the dependent entity if it is not defined
    in the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: EF Core generates a foreign key property of the dependent entity, which is `InvoiceId`
    in this case, if it is not defined in the model.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the principal entity is added to the database, dependent entities are also
    added to the database automatically. You do not need to add dependent entities
    explicitly.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, what if you want to add a new invoice item to an existing invoice? You
    can do it in two ways:'
  prefs: []
  type: TYPE_NORMAL
- en: Get the invoice first, then add the new invoice item to the `InvoiceItems` collection
    of the invoice, and then call the `SaveChanges()` method to save the changes to
    the database. This is an `Update` operation for the invoice, which means it should
    be a `PUT` action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Create a new invoice item, set the `InvoiceId` property to the `Id` property
    of the invoice, and then call the `SaveChanges()` method to save the changes to
    the database. This is a `Create` operation for the invoice item, which means it
    should be a `POST` action. Also, you need to provide an endpoint for the invoice
    item separately.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An invoice item cannot exist without an invoice. So, typically, you interact
    with the invoice item through the invoice. From a practical point of view, the
    first way is more common if the dependent entity count is not large. However,
    it depends on your scenario. If the principal entity has a large number of dependent
    entities, updating the entire principal entity may be inefficient and expensive.
    In this case, you can expose a separate endpoint to operate the dependent entity.
    For example, one blog post may have a large number of comments. It is common to
    add a new comment to a blog post, but it is not necessary to update the entire
    blog post and other comments. This is related to another concept, **domain-driven
    design** (**DDD**), which is to model domain objects and their relationships.
    We will talk about it in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Querying data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Now we have an invoice and some invoice items in the database, we can send
    a `GET` request to the `/api/Invoices` endpoint. You can see the following response:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The response contains a list of invoices. But the `InvoiceItems` property is
    empty. This is because the `InvoiceItems` property is a collection navigation
    property. By default, EF Core does not include dependent entities in the query
    result, so you need to explicitly include these in the query result. Follow these
    steps to query the invoice and invoice items from the database:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the `InvoicesController.cs` file, and update the code of the `GetInvoices()`
    method to this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the preceding code, we use the `Include` method to include dependent entities
    in the query result.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Restart the application and send the same request again. Now, you will see
    the result includes invoice items, as shown here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: As you see, when the LINQ query uses the `Include()` method to include dependent
    entities, EF Core will generate a `LEFT` `JOIN` query.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: The `Include()` method is a convenient way to include dependent entities. However,
    it may cause performance issues when the collection of dependent entities is large.
    For example, a post may have hundreds or thousands of comments. It is not a good
    idea to include all comments in the query result for a list page. In this case,
    it is not necessary to include dependent entities in the query.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the query includes `Invoice` data in each row of the result. For
    some scenarios, it may cause a so-called `AsSplitQuery()` method as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The query contains two `SELECT` statements. The first `SELECT` statement is
    used to query the invoices. The second `SELECT` statement is used to query the
    invoice items. The `INNER JOIN` query is used to join the two queries.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'You can also configure the default query-splitting behavior globally by using
    the `UseQuerySplittingBehavior()` method in the `OnConfiguring()` method of your
    `DbContext` class. The following code shows how to configure the default query
    splitting behavior to `SplitQuery` in the `SampleDbContext` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'In this case, you don’t need to use the `AsSplitQuery()` method in your LINQ
    queries. If you want to execute a specific query in a single query, you can use
    the `AsSingleQuery()` method like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: However, split queries may cause other issues. For example, multiple queries
    increase the number of round trips to the database. In addition, if another thread
    modifies the data between the two queries, the result may be inconsistent. Therefore,
    you should consider the pros and cons of split queries to fit your scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Retrieving data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Next, let''s see how to retrieve data by ID. In the `GetInvoice` action, we
    use `await _context.Invoices.FindAsync(id)` to find the invoice by its ID. Send
    a `Get` request to the `/api/Invoices/{id}` endpoint with a valid ID. You will
    see the response contains an empty `InvoiceItems` array. This is because the `InvoiceItems`
    property is not included in the query. To include the `InvoiceItems` property
    in the query, you can use the `Include` method in the LINQ query. The following
    code shows how to use the `Include` method to include the `InvoiceItems` property
    in the query:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The generated SQL query is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The query contains two `SELECT` statements, and the `INNER JOIN` query is used
    to join the two statements. In this way, you can retrieve the invoice and invoice
    items in a single query.
  prefs: []
  type: TYPE_NORMAL
- en: Deleting data
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In the *One-to-many configuration* section, we introduced how to configure
    the `OnDelete` action to set the `DeleteBehavior` enum to `Cascade`. There are
    other options for the `DeleteBehavior` enum. Think about the following scenario
    in a one-to-many relationship:'
  prefs: []
  type: TYPE_NORMAL
- en: An invoice has a list of invoice items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A user deletes an invoice
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In this case, you may want to delete the related invoice items when the invoice
    is deleted because an invoice item cannot exist without an invoice. This behavior
    is called **cascade delete**. To delete the data, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the application and send a `Delete` request to the `/api/Invoices/{id}`
    endpoint with a valid ID. You will see the invoice and the related invoice items
    are deleted from the database. Note that if the `OnDelete()` method is configured
    as `Cascade` or `ClientCascade`, loading related entities using the `Include()`
    method in the LINQ query is not required. The cascade delete behavior is applied
    at the database level. You can see the generated SQL query, which just deletes
    the `Invoice` entity, here:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'However, in some scenarios, you may want to keep dependent entities when the
    principal entity is deleted, for example:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: A category has a list of blog posts
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: A user deletes a category
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: It is not necessary to delete blog posts when a category is deleted, because
    the blog posts can still exist without a category and can be assigned to another
    category. However, if a category is deleted, the `CategoryId` property of a blog
    post, which is a foreign key, will no longer match the primary key of any category.
    Therefore, you may want to set the `CategoryId` property to `null` when a category
    is deleted. This behavior is called `CategoryId` property is nullable. If the
    `CategoryId` property of a blog post entity is not nullable, EF Core will throw
    an exception when you try to delete a category because it will violate the foreign
    key constraint.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: In the sample code, there is an example of this case. You can find the `Category`
    and `Post` classes in the `Models` folder. Similar to the `Invoice` and `InvoiceItem`
    classes, they have a one-to-many relationship. However, the `CategoryId` property
    in the `Post` class is nullable. Therefore, you can set `DeleteBehavior` to `ClientSetNull`
    to nullify the `CategoryId` property when a category is deleted.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The following code shows how to configure `DeleteBehavior` to `ClientSetNull`:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `OnDelete()` method, you can pass the `DeleteBehavior` enum to set `DeleteBehavior`
    to `ClientSetNull`. The `ClientSetNull` value means that the foreign key property
    will be set to `null` when the principal entity is deleted.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'In the `CategoriesController` class, you can find the `DeleteCategory()` method.
    It is similar to the `DeleteInvoice()` method in the `InvoicesController` class.
    The only difference is that we need to remove the relationship between the category
    and the blog posts before deleting the category. The following code shows how
    to remove the relationship between the category and the blog posts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can clear the `Posts` property of the category entity, or you can update
    the `Category` property of the blog posts to set it to `null`. In this way, the
    `CategoryId` property of the blog posts will be set to `null` when the category
    is deleted. Also, it is required to load related entities using the `Include`
    method, because EF Core needs to track the changes of related entities as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Run the application and send a `Delete` request to the `/api/Categories/{id}`
    endpoint with a valid ID. Check the database, and you will see the category is
    deleted, but the blog posts are not deleted. Instead, the **CategoryId** property
    of the blog posts is set to **NULL**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.3 – The CategoryId property of the blog posts is set to NULL when
    the category is deleted](img/B18971_06_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – The CategoryId property of the blog posts is set to NULL when the
    category is deleted
  prefs: []
  type: TYPE_NORMAL
- en: 'Check the generated SQL query, and you will see that EF Core executes two SQL
    queries. The first query is to update the `CategoryId` property of the blog posts
    to `null`. The second query is to delete the category. The generated SQL query
    is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That says the posts now have no category, which means the relationship between
    the category and the blog posts is removed. You can assign the blog posts to another
    category to recreate the relationship following your business logic.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: It is important to understand the consequences of deleting an entity when it
    has relationships. Keep in mind that some databases may not support cascading
    deletes. So, the `DeleteBehavior` enum contains quite a few values to allow you
    to fine-tune the behavior when deleting an entity. Generally, it is recommended
    to use `ClientCascade` or `ClientSetNull` because EF Core can perform cascading
    deletes or nullification if the database does not support cascading deletes.
  prefs: []
  type: TYPE_NORMAL
- en: 'So far, we have learned how to configure a one-to-many relationship and how
    to implement CRUD operations for entities with a one-to-many relationship. Next,
    let''s move on to another type of relationship: a one-to-one relationship.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding one-to-one relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A one-to-one relationship means that one entity has a relationship with only
    one entity of another type. For example, a bicycle requires one lock, which can
    only be used for that particular bicycle. Similarly, a person is only allowed
    to possess one driver’s license, which is designated for their use only. In our
    sample code, a `Contact` entity has only one `Address` entity, and an `Address`
    entity belongs to only one `Contact` entity. In the previous section, you learned
    how to configure a one-to-many relationship using the `HasOne()/WithMany()` and
    `HasMany()/WithOne()` methods. In this section, you will learn how to configure
    a one-to-one relationship using the `HasOne()` and `WithOne()` methods.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a one-to-one relationship, both sides have a reference navigation property.
    Technically, both sides have equal positions. However, to explicitly configure
    the relationship, we need to specify which side is the dependent side and which
    side is the principal side. The foreign key property is normally defined on the
    dependent side. In the following example, we will configure a one-to-one relationship
    between the `Contact` class and the `Address` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, a `ContactId` foreign key is defined in the `Address`
    class, which implies that the `Address` class is the dependent entity, and the
    `Contact` class is the principal entity. If you do not define a foreign key property
    here, EF Core will automatically choose one of the entities to be the dependent
    entity. However, because `Contact` and `Address` are equal in a one-to-one relationship,
    EF Core may not choose the correct entity as we expect. So, we need to explicitly
    define a foreign key property in the dependent entity.
  prefs: []
  type: TYPE_NORMAL
- en: 'The configuration of a one-to-one relationship is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code uses `HasOne`/`WithOne` to define the one-to-one relationship.
    This can be defined in either the `Contact` configuration or `Address` configuration.
    The `HasForeignKey` method is used to specify the foreign key property. If you
    want to define the relationship in the `Contact` configuration, the code may look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Run the following code to add the migration and update the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following code creates a `ContactId` foreign key on the `Addresses`
    table:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'After the migration is applied, the relationship between **Contacts** and **Addresses**
    is configured successfully, as shown in *Figure 6**.4*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.4 – A ContactId foreign key is created on the Addresses table](img/B18971_06_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – A ContactId foreign key is created on the Addresses table
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's see how to implement CRUD operations for entities with a one-to-one
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: One-to-one CRUD operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The CRUD operations of a one-to-one relationship are similar to those of a one-to-many
    relationship. EF Core can simplify CRUD operations for you. So, in this section,
    we will not explain all CRUD operations in detail. You will find a controller
    named `ContactsController.cs` in the sample repo, which implements CRUD operations
    for the `Contact` entity. You can check the code for the details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Contact` and `Address` entities have a one-to-one relationship, meaning
    each `Contact` entity has one `Address` property and each `Address` entity belongs
    to only one `Contact` property. To illustrate how to query a contact with its
    address, we will use this example:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new contact with its address, you can send a `POST` request to
    the `api/contacts` endpoint. The request body is as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the JSON request body, the `address` object is a property of the `Contact`
    object. It is not required to send the `ContactId` property in the request body.
    EF Core will automatically set the `ContactId` property to the `Id` property of
    the `Contact` object.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Similarly, when you query the contacts through the `api/contacts` endpoint,
    the `Address` object will not be included in the response body by default. You
    need to explicitly use the `Include` method to include the `Address` object in
    the query, as shown in the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can check the `ContactsController.cs` file for other CRUD operations and
    test them in Postman or any other REST client you like.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have explored two types of relationships: one-to-many and one-to-one. Now,
    let us delve into another type of relationship: many-to-many.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding many-to-many relationships
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: A many-to-many relationship is when an entity can be associated with multiple
    entities and vice versa. For example, a movie can have many actors, and an actor
    can act in many movies; a post can have many tags, and a tag can have many posts;
    a student can enroll in many courses, and a course can have many students, and
    so on. In this section, we will introduce how to configure a many-to-many relationship
    in EF Core.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many configuration
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a many-to-many relationship, we need to define a collection navigation property
    on both sides. Here is an example of a many-to-many relationship between a `Movie`
    entity and an `Actor` entity:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'EF Core can detect the many-to-many relationship automatically following the
    convention. If you run the `dotnet ef migrations add AddMovieAndActor` command
    to add a migration, you will see the following code in the migration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Besides the code that creates `Movies` and `Actors` tables, the migration file
    also creates a join table named `ActorMovie` to store the foreign keys for both
    sides. The `ActorMovie` table has two foreign key properties, `ActorsId` and `MoviesId`,
    to associate the `Actor` entity and the `Movie` entity.
  prefs: []
  type: TYPE_NORMAL
- en: However, sometimes the automatic detection of the many-to-many relationship
    may not meet our requirements. For example, we may want to call the table `MovieActor`
    instead of `ActorMovie`, we may want to specify the foreign key properties as
    `ActorId` and `MovieId` instead of `ActorsId` and `MoviesId`, or we may even want
    to add some additional properties to the join table. In these cases, we can explicitly
    configure the many-to-many relationship.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need to define a join entity to store the foreign keys for both sides.
    Here is an example of a join entity named `MovieActor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: 'Also, we need to add a collection navigation property to the `Movie` and `Actor`
    entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, we configure the many-to-many relationship in the `Movie` configuration
    using the `HasMany()/WithMany()` methods, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Similarly, the configuration can be added to the `Actor` configuration as well.
    After adding the configuration, run the `dotnet ef migrations add AddMovieAndActor`
    command to add a migration; you will see the following code in the migration file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: You can see that the join table is renamed `MovieActor`, and the foreign key
    properties are renamed `MovieId` and `ActorId`. Also, the `UpdateTime` property
    is added to the join table.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the migration is applied, you can see the join table in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.5 – The join table in the database](img/B18971_06_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.5 – The join table in the database
  prefs: []
  type: TYPE_NORMAL
- en: 'Another way (before EF Core 5.0) to configure a many-to-many relationship is
    to use the join entity to represent two separate one-to-many relationships. Here
    is an example of configuring a many-to-many relationship for the `Movie` and `Actor`
    entities:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code, we configured two one-to-many relationships for the `Movie`
    and `Actor` entities on the `MovieActor` join entity. Each one-to-many relationship
    uses the `HasMany(), WithMany()`, and `HasForeignKey()` methods to configure the
    relationship. This combination of one-to-one relationships creates a many-to-many
    relationship.
  prefs: []
  type: TYPE_NORMAL
- en: You can use either way to configure a many-to-many relationship. The `HasMany()/WithMany()`
    methods is more convenient and easier to use.
  prefs: []
  type: TYPE_NORMAL
- en: Many-to-many CRUD operations
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In a many-to-many relationship, such as `Movie` and `Actor`, we may need to
    get the actors of a movie or get the movies of an actor. So, we need to expose
    both entities through the REST API. You can create two controllers using the following
    commands:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: Run the application and create some movies and actors.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can include the actors of a movie when creating a movie. For example, we
    can create a movie with a couple of actors using the following JSON payload format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: 'You will see the following result in the database:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.6 – The join table has been populated](img/B18971_06_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.6 – The join table has been populated
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, you can also include the movies of an actor when creating an actor.
    However, if we include related entities arbitrarily, we may end up with duplicate
    entities. For example, we create an actor with a couple of movies using the following
    JSON payload format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'As a result, you will have two movies with the same title in the database.
    To avoid this, there are some options:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a unique index to the `Title` property of the `Movie` entity to ensure that
    the title is unique. This is the simplest solution and can prevent duplicate entities
    from being added to the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Check if the entity already exists in the database before adding it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add movies and actors separately, and then update either the movie or the actor
    to include the other entity using the IDs of the other entity, instead of the
    whole entity.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You can use a combination of the preceding options to improve the implementation.
    To add a unique index to the `Title` property of the `Movie` entity, you can update
    the following code of the `MovieConfiguration` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: You can make the same change to the `Name` property of the `Actor` entity. After
    the change, you need to create a new migration and apply it to the database. This
    helps to prevent duplicate entities on the database level. If a request contains
    duplicate entities, the database will throw an exception.
  prefs: []
  type: TYPE_NORMAL
- en: It is possible to add or update related entities in the same request as the
    main entity. But sometimes, it might not be necessary. For example, an actor just
    acts in a new movie, and you want to create a new movie and add the actor to the
    movie. You can update the actor to include the new movie, but you have to send
    the whole actor entity in the request, including existing movies. It causes unnecessary
    data transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'To make the API easy to use, it is pragmatic to expose an additional API endpoint
    to update a collection of related entities only, rather than updating the whole
    entity. For example, we can create an `/api/actors/{id}/movies` endpoint to update
    the movies of an actor. It is a good practice to avoid updating a collection of
    related entities in the same request. We can just send the IDs of the related
    entities to the API endpoint. From the perspective of the API, the relationship
    is treated as a resource. In the `ActorsController.cs` file, you will find the
    following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code exposes a few endpoints to add, get, and delete the movies
    of an actor. You can test the endpoints using the JSON payload format, as shown
    in the preceding code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: To add a movie to an actor, send a `POST` request to the `/api/actors/{id}/movies/{movieId}`
    endpoint. The `AddMovie` action will check if the movie already exists in the
    database. If it does, it will then check if the movie already exists in the movies
    of the actor. If not, it adds the movie to the collection and then saves the changes
    to the database.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To get the movies of an actor, send a `GET` request to the `/api/actors/{id}/movies`
    endpoint. The `GetMovies` action will return the movies of the actor. This endpoint
    can be updated to support pagination, sorting, and filtering.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To delete a movie from an actor, send a `DELETE` request to the `/api/actors/{id}/movies/{movieId}`
    endpoint. The `DeleteMovie` action will remove the movie from the collection and
    then save the changes to the database. Note that it does not delete the movie
    from the database; it just deletes the relationship between the movie and the
    actor.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It is also possible to add a similar endpoint to the `MoviesController.cs` file
    to update the actors of a movie. You can use the same approach to implement endpoints.
    Try it yourself!
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: When you call the `/api/actors` endpoint, you may find that the response contains
    `MovieActors` as well. This is not useful for the client. You can use the `JsonIgnore`
    attribute to ignore the property when serializing the response.
  prefs: []
  type: TYPE_NORMAL
- en: 'We have now discussed three common types of relationships: one-to-many, one-to-one,
    and many-to-many. You should now have a good understanding of how to configure
    relationships and implement CRUD operations for entities with relationships. Let''s
    move on to our next topic: owned entity types.'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding owned entities
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous sections, we have learned some relationships are optional, but
    some are required. For example, a post can exist without a category, but a student
    ID card cannot exist without a student. For the latter, we can say a student owns
    an ID card. Similarly, a contact owns an address. We can also find some examples
    of one-to-many relationships. For example, an invoice owns many invoice items
    because an invoice item cannot exist without an invoice. In this section, we will
    introduce the concept of owned entities.
  prefs: []
  type: TYPE_NORMAL
- en: 'Owned entity types are entity types that are part of the owner and cannot exist
    without the owner. You can use common one-to-one or one-to-many relationships
    to model the owned entities, but EF Core provides a more convenient way called
    owned entity types. You can use the `OwnsOne()` or `OwnsMany()` method to define
    owned entity types, instead of using the `HasOne()` or `HasMany()` method. For
    example, to configure the `InvoiceItem` entity as an owned entity type of the
    `Invoice` entity, you can use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: As shown in the preceding code, you can use the `OwnsMany()/WithOwner()` methods
    to configure the owned entity type. The `OwnsMany()/WithOwner()` method specifies
    the owner of the owned entity type. The `HasForeignKey()` method specifies the
    foreign key property of the owned entity type. The configuration of the `InvoiceItem`
    entity is stored in the `InvoiceConfiguration` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Similarly, the configuration of the `Address` entity could be stored in the
    `ContactConfiguration` class like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: When you use the `OwnsOne()/WithOwner()` methods, you do not need to specify
    the foreign key property because the owned entity type will be stored in the same
    table as the owner by default. You can use the `ToTable` method to specify the
    table name of the owned entity type.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, what is the difference between normal one-to-one or one-to-many and owned
    entity types? There are some differences:'
  prefs: []
  type: TYPE_NORMAL
- en: You cannot create a `DbSet<T>` property for an owned entity type. You can only
    use the `DbSet<T>` property for the owner. That means you do not have any way
    to access the owned entity type directly. You must access the owned entity type
    through the owner.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you query the owner, the owned entity type will be included automatically.
    You do not need to use the `Include()` method to include the owned entity type
    explicitly. So, please be careful if the owner has many owned entities. It may
    cause performance issues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If your entities have a simple one-to-one or one-to-many relationship and the
    data is not large, you can use owned entity types to simplify the configuration.
    However, if the relationship is complex and the data size is large, you would
    be better off using normal one-to-one or one-to-many relationships because you
    can decide which related entities to include explicitly.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this comprehensive chapter, we delved into modeling relationships between
    entities in EF Core. We explored various common relationship types, including
    one-to-one, one-to-many, and many-to-many relationships. We learned how to configure
    these relationships using essential methods such as `HasOne()/WithMany()`, `HasMany()/WithOne()`,
    and `HasMany()/WithMany()`. To broaden our understanding, we also explored configuring
    owned entity types using the `OwnsOne()/WithOwner()` and `OwnsMany/WithOwner()`
    methods.
  prefs: []
  type: TYPE_NORMAL
- en: To effectively operate on entities with relationships, we explained how to implement
    CRUD operations for each type of relationship. Particularly, we explained cascading
    delete operations, ensuring data integrity and efficient management of related
    entities.
  prefs: []
  type: TYPE_NORMAL
- en: The concepts learned in this chapter will help you model relationships between
    entities in your ASP.NET Core applications. In the next chapter, we will learn
    about some advanced topics of EF Core, such as concurrency control, performance
    tuning, and more.
  prefs: []
  type: TYPE_NORMAL
