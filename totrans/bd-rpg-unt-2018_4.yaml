- en: The Game Mechanics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 3](part0074.html#26I9K0-7a1ef7ae3ef249cdb149f8344d2e8e79), *RPG
    Character Design,* we covered a wide range of topics to prepare your character
    model for the game. We looked at how to import and set up our character model,
    created the `BaseCharacter` class, used the Animator Controller to set up the
    state diagram, created the initial character controller to handle the motion and
    behavior of our character model, and finally, looked at some basic inverse kinematics
    for the foot.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will expand on the character player and also the non-character
    player, covering the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Customizing the player character:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizable parts (model)
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: C# code for customization
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Preserving character state
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Non-player characters:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Non-player character basics
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Setting up the non-player character
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Navmesh setup
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: NPC Animator Controller
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: NPC Attack
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: NPC AI
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: PC and NPC interaction
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Customizing the player character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the key features of an RPG is to be able to customize your character
    player. In this section, we will take a look at how we can provide a means to
    achieve this.
  prefs: []
  type: TYPE_NORMAL
- en: Once again, the approach and concept are universal, but the actual implementation
    might be a little different based on your model structure.
  prefs: []
  type: TYPE_NORMAL
- en: Create a new scene and name it `CharacterCustomization`. Create a Cube prefab
    and set it to the origin. Change the Scale of the cube to `<5, 0.1, 5>`. You can
    also change the name of the GameObject to Base. This will be the platform that
    our character model stands on while the player customizes his/her character before
    game play.
  prefs: []
  type: TYPE_NORMAL
- en: I used my environment assets to create the stage. This takes more time, but
    it is more attractive. This is totally up to you, the creator and designer of
    the game, and the sky is the limit!
  prefs: []
  type: TYPE_NORMAL
- en: Drag and the drop the prefab representing your character model into the Scene
    View. The next few steps will entirely depend on your model hierarchy and structure
    as designed.
  prefs: []
  type: TYPE_NORMAL
- en: I am using the Barbarian model to illustrate the structure.
  prefs: []
  type: TYPE_NORMAL
- en: 'To illustrate the point, I have placed the same model in the scene twice. The
    one on the left is the model that has been configured to display only the basics,
    and the model on the right is the model in its original state, as shown in the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00075.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Barbarian model: simple and fully geared'
  prefs: []
  type: TYPE_NORMAL
- en: 'Notice that the particular model I am using has everything attached. This includes
    the different types of weapons, shoes, helmets, armor, and skins. The instantiated
    prefab on the left-hand side has turned off all of the extras from the model''s
    hierarchy. Here is how the hierarchy looks in `Hierarchy View`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00076.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Barbarian model structure
  prefs: []
  type: TYPE_NORMAL
- en: The model has a very extensive hierarchy in its structure. The preceding screenshot
    is a small snippet to demonstrate that you will need to navigate the structure
    and manually identify and enable or disable the mesh representing a particular
    part of the model.
  prefs: []
  type: TYPE_NORMAL
- en: 'Model root:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Pelvis:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Left thigh:'
  prefs: []
  type: TYPE_NORMAL
- en: Left calf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Right thigh:'
  prefs: []
  type: TYPE_NORMAL
- en: Right calf
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Spine:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Ribcage:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Left collarbone:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Left upper arm:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Left forearm
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Neck:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Head
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Right collarbone:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Right upper arm:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Right forearm:'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Right palm
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Each one of your character models will have their own unique hierarchy and bone
    structure. You will need to study this, as mentioned previously, to understand
    and plan how you will configure and program them during game play.
  prefs: []
  type: TYPE_NORMAL
- en: Customizable parts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Using my Barbarian model, I can customize a few items with it. I can customize
    the shoulder pads, the body type, the weapons, the armor, the helmets, the shoes,
    and, finally, the texture or skin of the model to give it different and unique
    looks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s get a list of all the different customizable items we have for our character:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Shields**: There are two types'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Body Type**: There are three body types: skinny, buff, and chubby'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Armor**: knee pad, leg plate'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Boots**: There are two types of boots'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Helmet**: There are four types of helmets'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weapons**: There are 13 different types of weapons'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Skins**: There are 13 different types of skins'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![](img/00077.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Model assets 1
  prefs: []
  type: TYPE_NORMAL
- en: 'You can easily extract each accessory from the main model and create a prefab
    of the individual weapon, armor, and clothing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00078.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Model assets 2
  prefs: []
  type: TYPE_NORMAL
- en: 'We are separating the items in such a way to give the player the ability to
    level-up or find the required weapon or armor during game play:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00079.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Model assets 3
  prefs: []
  type: TYPE_NORMAL
- en: Once an item is picked up, we would have it in our inventory and the player
    can easily access it.
  prefs: []
  type: TYPE_NORMAL
- en: User interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know what our options are for customizing our player character,
    we can start thinking about the **User Interface** (**UI**). The UI will be used
    for the customization of the character.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a sketch of an idea for the UI. As we start implementing the
    UI, we might have to make some adjustments to accommodate the usability of the
    original concept:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00080.gif)'
  prefs: []
  type: TYPE_IMG
- en: To design our UI, we will need to create a Canvas GameObject. This is done by
    right-clicking in the **Hierarchy View** and selecting Create *|* UI *|* Canvas.
    This will place a Canvas GameObject and an `EventSystem` GameObject in the Hierarchy
    View.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is assumed that you already know how to create a UI in Unity. If you do
    not, please refer to *Introduction to Game Programming: Using C# and Unity 3D,*
    [Chapter 5](part0109.html#37UDA0-7a1ef7ae3ef249cdb149f8344d2e8e79), *GameMaster
    and Game Mechanics,* at [https://www.amazon.com/Introduction-Game-Programming-Using-Unity-ebook/dp/B01BCPRRCU/](https://www.amazon.com/Introduction-Game-Programming-Using-Unity-ebook/dp/B01BCPRRCU/).'
  prefs: []
  type: TYPE_NORMAL
- en: 'I am going to use panels to group the customizable items. For the moment, I
    will be using checkboxes for some items and scroll bars for the weapons and skin
    texture. The following screenshot illustrates how my UI for customization looks:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00081.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Character customization UI
  prefs: []
  type: TYPE_NORMAL
- en: These UI elements will need to be integrated with event handlers that will perform
    the necessary actions for enabling or disabling certain parts of the character
    model.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, using the UI, I can select Shoulder Pad 4, use the scroll bar
    to increase or decrease the chubbiness of the body, and move the weapons type
    scroll bar until the Hammer weapon shows up. Selecting the second Helmet checkbox,
    selecting Shield 1, and Boot 2, my character will look the like following screenshot.
  prefs: []
  type: TYPE_NORMAL
- en: We need a way to refer to each one of the meshes representing the different
    types of customizable objects on the model. This will be done through a C# script.
    The script will need to keep track of all the parts we are going to be managing
    for customization.
  prefs: []
  type: TYPE_NORMAL
- en: Some models will not have the extra meshes attached. You can always create empty
    GameObjects at a particular location on the model, and you can dynamically instantiate
    the prefab representing your custom object at the given point. This can also be
    done for our current model. For instance, if we have a special space weapon that
    somehow gets dropped by aliens in the game world, we can attach the weapon to
    our model through C# code. The important thing is to understand the concept, and
    the rest is up to you!
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00082.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Character customization in action
  prefs: []
  type: TYPE_NORMAL
- en: The code for character customization
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Things don't happen automatically. We need to create some C# code that will
    handle the customization of our character model. The script we create here will
    handle the UI events that will drive the enabling and disabling of different parts
    of the model mesh.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new C# script and call it `BarbarianCharacterCustomization.cs`. Create
    an empty GameObject called `__Base` and attach the script to `__Base GameObject`
    in the scene. Here is a listing of the script:'
  prefs: []
  type: TYPE_NORMAL
- en: '`path of the code`'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'This is a long script but it is straightforward. At the top of the script,
    we have defined all of the variables that will be referencing the different meshes
    in the model character. All variables are of type GameObject with the exception
    of the `PLAYER_SKIN` variable, which is an array of `Material` data type. The
    array is used to store the different types of texture created for the character
    model:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'There are a few functions defined that are called by the UI event handler.
    These functions are: `SetShoulderPad(Toggle id)`, `SetBodyType(Toggle id)`, `SetKneePad(Toggle
    id)`, `SetLegPlate(Toggle id)`, `SetWeaponType(Slider id)`, `SetHelmetType(Toggle
    id)`, `SetShieldType(Toggle id)`, `SetSkinType(Slider id)`, `SetBodyFat(Slider
    id)`, and `SetBodySkinny(Slider id)`;'
  prefs: []
  type: TYPE_NORMAL
- en: All of the functions take a parameter that identifies which specific type should
    enable or disable.
  prefs: []
  type: TYPE_NORMAL
- en: We have just created a tool that will enable you quickly visualize character
    customization.
  prefs: []
  type: TYPE_NORMAL
- en: You can also use the system we just built to create all of the different variations
    of your player character or non-character player models and store them as prefabs!
    Wow! This will save you so much time and effort in creating your characters representing
    different barbarians!
  prefs: []
  type: TYPE_NORMAL
- en: Preserving our character state
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have spent the time to customize our character, we need to preserve
    our character and use it in our game. In Unity, there is a function called `DontDestroyOnLoad()`.
  prefs: []
  type: TYPE_NORMAL
- en: This is a great function that can be utilized at this time. What does it do?
    It keeps the specified GameObject in memory going from one scene to the next.
    We can use these mechanisms for now. Eventually, though, you will want to create
    a system that you can save and load your user data.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and create a new C# script and call it `DoNotDestroy.cs`. This script
    is going to be very simple. Here is the listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: After you create the script, go ahead and attach it to your character model
    prefab in the scene. Not bad; let's do a quick recap of what we have done so far.
  prefs: []
  type: TYPE_NORMAL
- en: Recap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'By now you should have three scenes that are functional. We have our scene
    that represents the main menu, we have our scene that represents our initial level,
    and we just created a scene that is used for character customization. Here is
    the flow of our game thus far:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00083.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: We start the game, see the main menu, select the Start Game button to enter
    the character customization scene, do our customization, and when we click the
    Save button, we load level 1.
  prefs: []
  type: TYPE_NORMAL
- en: 'For this to work, we have created the following C# scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`GameMaster.cs`: This is used as the main script to keep track of our game
    state'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BarbarianCharacterCustomization.cs`: This is used exclusively for customizing
    our character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DoNotDestroy.cs`: This is used to save the state of a given object'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`BarbarianCharacterController.cs`: This is used to control the motion of our
    character'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IKHandle.cs`: This is used to implement inverse kinematics for the foot'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you combine all of this together, you now have a good framework and flow
    that can be used to extend and improve as we go along.
  prefs: []
  type: TYPE_NORMAL
- en: Non-player characters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Until now, we have concentrated on the player character. In this section, we
    will start thinking about our non-player characters. Let's start with our Barbarians.
    We can use our Character Customization scene to quickly create a few prefabs that
    will represent our unique Barbarians.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using the tool we have just developed, you can make your adjustments, and when
    satisfied with your model, drag and drop the GameObject representing your character
    player into the `Prefabs` folder. This will create a copy of the instance of the
    GameObject as you see it and save it into a prefab. The following screenshot demonstrates
    the two characters I have created and stored as a prefab:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00084.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Creating unique characters using the tool
  prefs: []
  type: TYPE_NORMAL
- en: What I have shown you, if done properly, could save you hours of tedious work
    to manually go down the model structure and individually enable and disable the
    different meshes. In other words, we not only create a scene that allows us to
    customize the in-game player character, we have also created a tool that can help
    us customize our own character models quickly for use within the game!
  prefs: []
  type: TYPE_NORMAL
- en: Another point to emphasize here is the power of prefabs. Think of a prefab as
    a storage that can be used to save the state of a given GameObject and used over
    and over again within your game environment. When you update your prefab, all
    instances of the prefab will automatically get updated! This is great, but at
    the same time you have to be careful not to break anything for the same reason.
    When you update a code logic on a script that is attached to a prefab, all instances
    of the prefab will use the updated script, so a bit of planning on your part can
    save a lot of time and headache in the long run.
  prefs: []
  type: TYPE_NORMAL
- en: Non-player character basics
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We are going to be using the newly created prefabs to implement our non-player
    characters. Since there are some similarities in the character models, we can
    re-use some of the assets that we have created so far.
  prefs: []
  type: TYPE_NORMAL
- en: For instance, all character will be inheriting the BaseCharacte*r* class defined
    in [Chapter 3](part0074.html#26I9K0-7a1ef7ae3ef249cdb149f8344d2e8e79), *RPG Character
    Design*. They will also incorporate the same states we have already created for
    the player character and extend a few more states specifically for the NPC, such
    as searching and seeking.
  prefs: []
  type: TYPE_NORMAL
- en: We have used our character customization tool to create and save our non-player
    character; hence, we are OK with the modeling part. What we need to concentrate
    on is the motion of our non-player characters. We would need to create a new Animator
    Controller that will handle the states of our NPCs.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the non-player character
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the main difficulties for implementing an NPC is the ability to give
    it realistic intelligence. This can be achieved easily by identifying and implementing
    several key areas for our NPCs.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few new components we would need to attach to our NPCs. Using the
    prefab we have saved, we will need to add the following components:'
  prefs: []
  type: TYPE_NORMAL
- en: New Sphere Collider, this will be used to implement the range of sight for our
    NPC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We already have an Animator component attached, but we will need to create a
    new Animator Controller to capture new states for the NPC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We also need to add a Nav Mesh Agent component. We are going to use the built-in
    navigation and pathfinding system for our NPC.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add the Sphere Collider, you will need to select the prefab defined for the
    NCP, and in the **Inspector** Window. Select Add Component *|* Physics *|* Sphere
    Collider. This will attach a Sphere Collider to our prefab.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to add Nav Mesh Agent*.* Again, from the Inspector Window, select
    Add Component *|* Navigation | Nav Mesh Agent. OK, so now we have set up our main
    built-in components that are going to be used for the NPC.
  prefs: []
  type: TYPE_NORMAL
- en: Since our prefab is an instance of our player character, we will need to remove
    some of the script components that have been carried over. If your NPC prefab
    contains any scripts attached to it, go ahead and remove them now.
  prefs: []
  type: TYPE_NORMAL
- en: Make sure you also change the `Tag` property to `Untagged`, if you have not
    done so already.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot illustrates the components that we have so far on
    the NPC. This will include both the existing components, including the scripts
    we have brought over from the player character, and the newly added components
    that will be used for the NPC:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00085.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Before you perform the next step, make sure you are in one of the level scenes.
    I am going to use the Awakening scene.
  prefs: []
  type: TYPE_NORMAL
- en: Switch to one of your playable game scenes.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step is to set up our Navmesh. To create a Navmesh, we need to get
    into the Navigation window, by selecting Window *|* Navigation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00086.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In order for the navmesh to work properly, we will need to mark all GameObjects
    that are going to be static in the scene as Navigation Static. This wkill create
    a navmesh based on the static objects in the scene; that is, GameObjects that
    are not going to be moving throughout the lifespan on the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00087.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In your active scene, select the GameObjects that are going to be set as Navigation
    Static, as shown in the preceding screenshot (1), use the Static drop-down menu
    (2), and select the Navigation Static option (3). If your GameObject is a parent
    GameObject with children, Unity will ask if you want to apply the property change
    to all children.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that I have placed all of my environment GameObjecst under a GameObject
    called `__Structure`*,* `_RootRockCollection` and a few others that have been
    added at a later time. This way, if I have many static objects, I can apply the
    property change to the parent and the children will automatically inherit the
    change as well. But make sure everything in the group will be static!
  prefs: []
  type: TYPE_NORMAL
- en: 'Once this is complete, we need to go back to the Navigation window and make
    some adjustments. In the Navigation tab, select Terrains and make sure it is set
    to Navigation Static, and the *Navigation Area* is set to Walkable:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00088.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'In the Bake tab, change the Agent Radius to 0.3 and Agent Height to 1\. Keep
    the rest of the properties the same. This will give the NPC more freedom to pass
    through tight corners:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00089.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: When you are ready, you can select the Bake button at the bottom of the Navigation
    window.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity will take some time to generate the Navmesh for your scene. This will
    depend on the complexity of your level. If all is done correctly, you will see
    something similar to the following screenshot displaying your Navmesh:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00090.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Navmesh generation
  prefs: []
  type: TYPE_NORMAL
- en: 'The blue areas you see are all the regions that the NPC can actually navigate
    to:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00091.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: NPC Animator Controller
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'We now need to create the **Animator Controller** (**AC**) for our NPC. The
    Animator Controller will use input from the `MeshAgent` to control and change
    the state of our NPC. We also need to define a few parameters for our NPC AC.
    These are going to be:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AngularSpeed`: This will be used for directional movement'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Speed`: This will be used to determine how fast the NPC will be moving'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Attack`: This will be used to determine if it needs to attack'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AttackWeight`: This might be used'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerInSight`: This will be used to determine if the PC is in sight'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Go ahead and create a new Animator Controller in your project and name it `NPC_BarbarianAnimatorController`.
    Open the Animator Window. Create a new Blend Tree by right-clicking in the Animator
    Window and selecting Create State | From New Blend Tree. Change the name to `NPC_Locomotion`.
    Double-click it so that you can edit the Blend Tree. Change the node name to `NPC_Locomotion`
    as well:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00092.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: From the Inspector Window, change the *Blend Type* to *2D Freeform Cartesian:*
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00093.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The *x*-axis will be represented by the *AngularSpeed*, and the *y*-axis will
    be represented by the *Speed* parameters.
  prefs: []
  type: TYPE_NORMAL
- en: The Blend Tree is going to hold all of the different locomotion animation states.
    These are going to be the idle, walking, and running states.
  prefs: []
  type: TYPE_NORMAL
- en: 'I have set up 11 different animation states for the locomotion of my NPC. The
    following screenshot will give you and overview of the Blend Tree:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00094.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: NPC Blend Tree
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you include all of the animations states in the Blend Tree, you will need
    to compute the positions of your animations. An easy way to do this, is to select
    the *Compute Positions* dropdown and select *AngularSpeed and Speed*. This will
    place the animation position based on the root motion, as illustrated in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00095.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: You can use your mouse to drag the red point shown in the screenshot to preview
    your animation states in action.
  prefs: []
  type: TYPE_NORMAL
- en: NPC Attack
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to implement our attack mode, we will need to create a new layer in
    the Animator Controller. Go ahead and create a new layer and call it `NPC_Attack`.
    This layer will be responsible for animating our character when we enter the attack
    mode.
  prefs: []
  type: TYPE_NORMAL
- en: 'We need to create a new mask for the layer. The mask will be used to determine
    which parts of the humanoid body will be affected by the layer animation. To create
    a mask, right-click in your Project Window and select Create *|* Avatar Mask.
    Name the new mask `NPC_BarbarianAttackMask`. Use the Inspector Window to disable
    the body parts that we don''t want to be affected by the layer animation, as illustrated
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00096.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Your layer setup should look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00097.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Make sure you change the Weight property to *1*, the Mask property assigned
    to the Avatar Mask we created, and also that the IK property is checked. Now we
    are ready to create our attack state machine.
  prefs: []
  type: TYPE_NORMAL
- en: Right-click in the Animator Window and select Create State *|* Empty. Drag and
    drop your attack animation(s). The empty state is used to have a nice transition
    between the main layer and back.
  prefs: []
  type: TYPE_NORMAL
- en: After you have dropped your attack animation(s) into the Animator, you will
    need to connect them using the transition conditions. I have added three more
    parameters to the parameter list named attack1, attack2, and attack3\. These parameters,
    in connection with the Attack parameter, will determine which attack state our
    NPC will transition to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `NPC_Attack` layer as configured up to this
    point:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00098.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: New parameters
  prefs: []
  type: TYPE_NORMAL
- en: Finally, you want to assign the new `NPC_BarbarianAnimatorController` to the
    NPC prefab(s).
  prefs: []
  type: TYPE_NORMAL
- en: NPC AI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now it is time to give some intelligence to our NPCs. One of the scripts we
    will need to create is to give the NPC the ability to detect the player. This
    script will be called `NPC_BarbarianMovement.cs`. The script will be used to detect
    if the player is in-sight, calculate the field of view for the NPC, and calculate
    the path from the NPC to the player character.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a listing of the source code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'OK, so let''s actually take a look and see what this code is trying to do.
    In the `Awake()` function we are initializing our variables that will be used
    in the script. We have a reference to the `NavMeshAgent`, the `SphereCollider`,
    and the `Animator` components attached to the NPC. These are stored in the `nav`, `col`, and `anim` variables,
    respectively:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'We also need to get a reference to the player and the player animator component.
    These is done through the `player` variable. We are also setting the `playerInSight` variable
    to false by default:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `Update()` function is not performing anything major at this point. It is
    just checking to see if the player character is in sight, and, if so, it makes
    sure that the NPC is orienting itself to look at the player.
  prefs: []
  type: TYPE_NORMAL
- en: Most of the meat of our code is in the `OnTriggerStay()` function. The first
    things we need to do is make sure the object that has entered our collider is
    the player object. This is done by checking the tag attribute on the other collider.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the player is within our collider, then we go ahead and calculate the direction,
    the distance, and the angle of the player relative to the NPC. This is done with
    the following lines:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, if the angle is smaller than the `fieldOfViewAngle` variable, we can
    use ray casting to determine if we can hit the player. If that is the case, the
    player is in NPC''s sight:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00099.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Debug rays
  prefs: []
  type: TYPE_NORMAL
- en: There is one more critical calculation the NPC needs to perform. That is how
    to get to the player once it is in range. Once we have established that the player
    is in range and that we are facing the player, we need to make the NPC find its
    way to the player. This is where the `NavMesh` and the `NavMeshAgent` come into
    play.
  prefs: []
  type: TYPE_NORMAL
- en: The `CalculatePathLength()` is a function that takes the position of the player
    and, using the mesh data, it calculates the best path to navigate from the NPCs
    location to the player's location.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, there is one more additional calculation we are performing, and that
    is, we are calculating the length of the path between the two points. This length
    calculation will be used in the future to perform the following:'
  prefs: []
  type: TYPE_NORMAL
- en: If the length of the path is larger than a threshold we have set, then we won't
    make the NPC attack. If it is within mean, then we can make the NPC move towards
    the player to engage in battle.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the last function `OnTriggerExit()`, we set the `playerInSight` variable
    to false. This will stop the NPC from pursuing the player:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00100.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Navmesh path
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot illustrates the path between the NPC and the player
    based on real-time calculation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Go ahead and attach the script to the NPC prefab if you have not done so already,
    and run the application to test it out. If all things are good, then you will
    be able to move the player character around the level, and once the player character
    enters the NPC field of view, the NPC will start moving towards the player and
    when close enough, it will attack:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00101.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'At this point, your NPC should have the following components attached to its
    prefab:'
  prefs: []
  type: TYPE_NORMAL
- en: Animator
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rigidbody
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Capsule and sphere colliders
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NavMesh Agent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NPC_BarbarianMovement` script'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We have covered a lot of information. I would encourage you to take the time
    to read through it one more time and understand the concepts before moving forward.
  prefs: []
  type: TYPE_NORMAL
- en: PC and NPC interaction
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Thus far, we have created the basics movement for both our PC and NPC. The next
    item I would like to complete is the attack mechanism for the PC and the NPC characters.
    Let's start by implementing the hit for the NPC.
  prefs: []
  type: TYPE_NORMAL
- en: Our NPC detects the player character based on the code we just created in the
    previous section. When the player character is in sight, the NPC will find the
    shortest path to the player character, and at a given range, it will attack the
    player character. We have the movement and animation mechanics completed. The
    next objective is to keep track of the hit points when the NPC is attacking.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a few adjustments we need to make in `NPC_Animator_Controller`. Open
    the Animator window, and select the `NPC_Attack` layer:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00102.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: NPC attack layer
  prefs: []
  type: TYPE_NORMAL
- en: Double-click on the *attack1* state, or the attack state you have defined in
    your state machine. This will open the related animation in the Inspector window.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Inspector window, scroll down to the *Curves* section. We are going
    to create a new curve by selecting the (+) sign under the *Curves* section. We
    are also going to create a new parameter called *Attack1C* to represent the value
    of the curve. This parameter should of type float:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00103.gif)'
  prefs: []
  type: TYPE_IMG
- en: 'The curve displayed in the preceding screenshot will be based on your animation:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00104.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, I have marked the important parts of the interface
    that you will need to work with to configure the curve of an animation. The first
    step would be to actually preview your animation and get a feeling for it.
  prefs: []
  type: TYPE_NORMAL
- en: The next step for my particular animation sequence was determining when the
    right arm of the model is coming along and I set a marker in the curve. I make
    another marker a bit more into the animation where the right arm has crossed a
    good deal from the right side to the left side.
  prefs: []
  type: TYPE_NORMAL
- en: 'These markers will indicate a hit point during the animation when the NPC is
    in attack mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00105.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: OK, why do we do this? Simple. This will help us only generate a hit based on
    the curve of the animation. This way, we don't hit the player and reduce the health
    of the player while the weapon is away from the player's body.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we need to update out `NPC_BarbarianMovement.cs` code to program the NPC
    attack.
  prefs: []
  type: TYPE_NORMAL
- en: 'Note: I have only listed the portions that have been updated.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an updated listing of the code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: The new addition to the code checks to see if the player is in sight, and if
    that is the case, we check to see if we are in range to be able to attack. If
    that is the case, we get into the attack mode. If we are in the attack mode, the
    attack animation is played.
  prefs: []
  type: TYPE_NORMAL
- en: In the code, we check to get the value of the newly created parameter called
    Attack1, and if it happens to be of value 1.0, then we go ahead and reduce the
    health of the player character.
  prefs: []
  type: TYPE_NORMAL
- en: If the player dies while the NPC is attacking, it will stop attacking and go
    back into the idle state.
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, you might be wondering how did we get the ability to get the information
    from the player character. This is because we need to make some more additional
    C# scripts. Let''s go ahead and do so now. Create the following C# scripts:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PlayerCharacter.cs`: This is going to be our player character class, which
    inherits from the `BaseCharacter` class we have defined previously'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PlayerAgent.cs`: This is going to be used to store the PC data and also inherit
    `MonoBehaviour`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NPC.cs`: This is going to be our non-player character class, which inherits
    from the `BaseCharacter` class as well'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`NPC_Agent.cs`: This is going to be used to store the NPC data and also inherit
    `MonoBehaviour`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'I have made some modification to the `BaseCharacter.cs` script to make it more
    accessible through the editor. Here is the new listing:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: I have gone ahead and made the class and the fields serializable.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at the listing for `PlayerCharacter.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'There is nothing much going on there at this point. Now let''s take a look
    at the `PlayerAgent.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: In the player agent code, we are initializing some default values for our PC
    data in the `Awake()` function. Since the class has been serialized, we can actually
    see the data during runtime for debugging purposes.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Update()` function, we check to see if the health of our PC is less
    than 0.0f, and if it is, then this indicates the player has died. Then we use
    the `CharacterController` component we have created to set the *die* property
    to true. The `CharacterController` then will use the new value and communicate
    with the Animator Controller for the player character to get into the die state.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that our `NPC_BarbarianMovement.cs` script is accessing the exact same
    PC data through the reference we have created in the script.
  prefs: []
  type: TYPE_NORMAL
- en: 'You will need to attach the `PlayerAgent.cs` script to your player character
    in the scene:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/00106.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Player character data
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, you can see the additions we have done to the scripts
    and how they look during runtime. We will have a listing for the `NPC.cs` and
    `NPC_Agent.cs` in future chapters. At this point, they are not used.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was a very involved one. We covered some very important topics
    and concepts in the chapter that can be used and enhanced for your games. We started
    the chapter by looking into how to customize your player character. The concepts
    you take away from the section can be applied to a wide variety of scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at how to understand the structure of your character model so that
    you can better determine the customization methods. These are the different types
    of weapons, clothing, armor, shields, and on.
  prefs: []
  type: TYPE_NORMAL
- en: We then looked at how to create a user interface to help enable us with the
    customization of our player character during game play. We also learned that the
    tool we developed can be used to quickly create several different character models
    (customized) and store them as prefabs for later use. Great time saver! We also
    learned how to preserve the state of our player character after customization
    for game play.
  prefs: []
  type: TYPE_NORMAL
- en: We looked at the non-player characters next. We went through the basics of setting
    up the NPC with the different necessary components. We then looked at how to create
    a Navmesh and how to work with Navmesh Agent and Pathfinding using the Navmesh.
  prefs: []
  type: TYPE_NORMAL
- en: We created a new Animator Controller for the NPC. We created a 2D Freeform Cartesian
    Blend Tree that was used for the animation of the NPC. We looked at how to create
    multiple layers in the Animation Controller and enable IK for different regions
    of the humanoid skeleton. We created the initial NPC AI script to detect and determine
    if the player is close enough for it to make a move and attack. Finally, we created
    new scripts to make interaction between the NPC and the player character possible.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of the chapter, you should have a good grasp of how everything is
    interrelated and have an idea of how to approach your project.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will create a better way to manage our game state.
  prefs: []
  type: TYPE_NORMAL
