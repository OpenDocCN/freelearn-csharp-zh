<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch03"/>Chapter 3. Demystifying Xamarin.Android</h1></div></div></div><p>It's now time to take a deeper dive into Xamarin.Android to see how it pulls off the same magic as Xamarin.iOS. In this chapter, we will see that Xamarin.iOS and Xamarin.Android share many of the same design goals. However, Xamarin.Android does not rely on static compilation. Many of the goals are achieved through completely different methods. This chapter covers the following topics:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Mono CLR and Dalvik VM—working side by side</li><li class="listitem" style="list-style-type: disc">Application packaging</li><li class="listitem" style="list-style-type: disc">Mono assemblies</li><li class="listitem" style="list-style-type: disc">Xamarin.Android bindings</li><li class="listitem" style="list-style-type: disc">Attributes for the <code class="literal">ApplicationManifest.xml</code> file</li><li class="listitem" style="list-style-type: disc">Garbage collection</li></ul></div><div><div><div><div><h1 class="title"><a id="ch03lvl1sec24"/>Mono CLR and Dalvik VM – working side by side</h1></div></div></div><p>Android<a class="indexterm" id="id127"/> apps <a class="indexterm" id="id128"/>run within the <strong>Dalvik Virtual Machine</strong> (<strong>Dalvik VM</strong>), which is somewhat similar to a Java VM, but optimized for devices with limited resources. As we discussed in <a class="link" href="ch01.html" title="Chapter 1. Xamarin and Mono – a Pathway to the Unnatural">Chapter 1</a>, <em>Xamarin and Mono – a Pathway to the Unnatural</em>, Xamarin <a class="indexterm" id="id129"/>products are based on the Mono platform that has its own VM called the <strong>Common Language Runtime</strong> (<strong>CLR</strong>). The key question to ask here is, "In which environment does a Xamarin.Android app run?" The answer is both. If you take a look at the next diagram, you will see for yourself how these two runtimes coexist:</p><div><img alt="Mono CLR and Dalvik VM – working side by side" src="img/0838OT_03_01.jpg"/></div><p>Both<a class="indexterm" id="id130"/> environments seem quite different from each other, so how does an app run in both? Xamarin.Android's <a class="indexterm" id="id131"/>power is achieved through a concept called peer objects and a Java framework <a class="indexterm" id="id132"/>called <strong>Java Native Interface</strong> (<strong>JNI</strong>).</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec23"/>Introducing the Java Native Interface</h2></div></div></div><p>Let's start with JNI. This is a framework that allows non-Java code with languages such as C++ or C#, as an example, to call or be called by Java code running inside a JVM. As you can see from the previous diagram, JNI is a critical component in the overall Xamarin.Android architecture.</p><div><div><h3 class="title"><a id="tip09"/>Tip</h3><p>You can find some supporting information on JNI, particularly on peer objects, in <a class="link" href="ch02.html" title="Chapter 2. Demystifying Xamarin.iOS">Chapter 2</a>, <em>Xamarin.Android Architecture</em> in Packt Publishing's <em>Xamarin Mobile Application Development for Android</em>, <em>Mark Reynolds</em>.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec24"/>Peer objects</h2></div></div></div><p>Peer objects<a class="indexterm" id="id133"/> are a pair of objects that work together to carry out the<a class="indexterm" id="id134"/> functionality of an Android app. One of these is a managed object residing in the Mono CLR, while the other is a Java object residing in the Dalvik VM.</p><p>Xamarin.Android is delivered with a set of assemblies called the Android binding libraries. Classes in the Android binding libraries correspond to the Java classes in the Android application framework, and the methods on the binding classes act as wrappers, to call corresponding methods on Java classes. These binding classes are commonly known <a class="indexterm" id="id135"/>as <strong>Managed Callable Wrappers</strong> (<strong>MCW</strong>). Because whenever you create a C# class that inherits from one of these binding classes, a corresponding Java proxy class is generated at build time. The Java proxy contains a generated override for each overridden method in your C# class and acts as a wrapper to call the corresponding method on the C# class.</p><p>Peer objects can be created from within the Dalvik VM by the Android application framework or from within the Mono CLR by the code you write in the overridden methods. A reference between the two peer objects is kept by each instance of a MCW and can be accessed through the <code class="literal">Android.Runtime.IJavaObject.Handle</code> property.</p><p>You can see for yourself how peer objects collaborate together here:</p><div><img alt="Peer objects" src="img/0838OT_03_02.jpg"/></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec25"/>Xamarin.Android application packaging</h1></div></div></div><p>Android applications are delivered for installation in an Android package format, which is an archive <a class="indexterm" id="id136"/>file with a <code class="literal">.apk</code> extension. An Android package contains the apps code and all of the supporting files required to run the app that includes the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Dalvik executables (<code class="literal">*.dex</code> files)</li><li class="listitem" style="list-style-type: disc">Resources</li><li class="listitem" style="list-style-type: disc">Native libraries</li><li class="listitem" style="list-style-type: disc">The application manifest</li></ul></div><p>Xamarin.Android apps follow the same standard with the following additions:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">C# code is compiled into assemblies and stored in a top-level folder named <code class="literal">assemblies</code></li><li class="listitem" style="list-style-type: disc">Mono<a class="indexterm" id="id137"/> runtime libraries are stored along with other native libraries in the <code class="literal">lib</code> folder</li></ul></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec26"/>Understanding Mono assemblies</h1></div></div></div><p>Like <a class="indexterm" id="id138"/>Xamarin.iOS, Xamarin.Android ships with an extended subset of Silverlight and desktop .NET assemblies. Together, these libraries provide the .NET runtime library support for developers, including namespaces such as <code class="literal">System.IO</code> and <code class="literal">System.Threading</code>.</p><p>Xamarin.Android is not binary compatible with assemblies compiled for a different profile, meaning your code must be recompiled to generate assemblies, specifically targeting the Xamarin.Android profile. This is essentially the same thing you have to do if you're targeting other profiles such as Silverlight or .NET 4.5.</p><div><div><h3 class="title"><a id="tip10"/>Tip</h3><p>For a <a class="indexterm" id="id139"/>complete list of assemblies that ship with Xamarin.Android, you can refer to <a class="ulink" href="http://docs.xamarin.com/guides/android/under_the_hood/assemblies">http://docs.xamarin.com/guides/android/under_the_hood/assemblies</a>.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec27"/>Xamarin.Android bindings</h1></div></div></div><p>Xamarin.Android <a class="indexterm" id="id140"/>also ships with a set of binding libraries that provide the support for Android development. The binding libraries form the second big part of the magic behind Xamarin.Android similar to the way in which the Mono CLR and Dalvik VM function. The following sections delve into the details of these bindings.</p><div><div><div><div><h2 class="title"><a id="ch03lvl2sec25"/>The design principles</h2></div></div></div><p>A number<a class="indexterm" id="id141"/> of goals or design principles guided the development of the binding libraries. These principles are critical to make C# developers productive in an Android development. The following represents a summary of the design principles, where you will notice some similarities with the Xamarin.iOS bindings:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Allow developers to subclass Java classes in the same way they subclass other .NET classes</li><li class="listitem" style="list-style-type: disc">Make common Java tasks easy, and tough Java tasks possible</li><li class="listitem" style="list-style-type: disc">Expose<a class="indexterm" id="id142"/> JavaBean properties as C# properties</li><li class="listitem" style="list-style-type: disc">Expose a strongly typed API</li><li class="listitem" style="list-style-type: disc">Expose C# delegates (lambdas, anonymous methods, and <code class="literal">System.Delegate</code>) instead of single-method interfaces when appropriate and applicable</li><li class="listitem" style="list-style-type: disc">Provide a mechanism to call arbitrary Java libraries (<code class="literal">Android.Runtime.JNIEnv</code>)<div><div><h3 class="title"><a id="tip11"/>Tip</h3><p>A complete discussion around these principles can be found at <a class="ulink" href="http://docs.xamarin.com/guides/android/advanced_topics/api_design">http://docs.xamarin.com/guides/android/advanced_topics/api_design</a>.</p></div></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec26"/>Properties</h2></div></div></div><p>To the<a class="indexterm" id="id143"/> greatest extent possible, JavaBean properties in the Android framework classes are transformed into C# properties. The following rules are always followed whenever this takes place:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Firstly, read/write properties are created for both the getter and setter method pairs</li><li class="listitem" style="list-style-type: disc">Read-only properties are created for getters without the corresponding setter methods</li><li class="listitem" style="list-style-type: disc">In the rare case that only a setter exists, no write-only properties are created</li><li class="listitem" style="list-style-type: disc">Finally, no properties are created when the type will be an array</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec27"/>Events versus listeners</h2></div></div></div><p>Android APIs<a class="indexterm" id="id144"/> follow the Java pattern in <a class="indexterm" id="id145"/>order to define and hook up event listeners. C# developers<a class="indexterm" id="id146"/> should be more familiar with the similar concepts of delegates and events.</p><p>The following is an example of Java event listeners:</p><div><pre class="programlisting">addTicketButton.setOnClickListener (
new View.OnClickListener() {
    public void onClick (View v) {
_ticketCount++;
updateLineItemCost();
    }
});</pre></div><p>This<a class="indexterm" id="id147"/> following is the equivalent <a class="indexterm" id="id148"/>code that uses C# events:</p><div><pre class="programlisting">addTicketButton.Click += (sender, e) =&gt; {
    _ticketCount++;
     UpdateLineItemCost();
};</pre></div><p>The <a class="indexterm" id="id149"/>Android bindings provide events when possible. The following rules are followed:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">When the listener has a set prefix such as <code class="literal">setOnClickListener</code></li><li class="listitem" style="list-style-type: disc">When the listener callback has a void return</li><li class="listitem" style="list-style-type: disc">When the listener accepts only a single parameter, the interface has only a single method, and the interface name ends with <code class="literal">Listener</code></li></ul></div><p>When an event is not created due to one of the rules enlisted here, a specific delegate is generated that supports the appropriate signature.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec28"/>Special help with collections</h2></div></div></div><p>The native <a class="indexterm" id="id150"/>Android APIs uses list, set, and map <a class="indexterm" id="id151"/>collections extensively from <code class="literal">java.util</code>. The Android bindings expose these collections using interfaces from <code class="literal">System.Collections.Generic</code>. In addition, Xamarin.Android provides a set of helper classes that implement each corresponding .NET collection and provides faster marshaling because they do not actually perform a copy. The following table shows how these classes map:</p><div><table border="1"><colgroup><col style="text-align: left"/><col style="text-align: left"/><col style="text-align: left"/></colgroup><thead><tr><th style="text-align: left" valign="bottom">
<p>Java type</p>
</th><th style="text-align: left" valign="bottom">
<p>.NET interface</p>
</th><th style="text-align: left" valign="bottom">
<p>Helper class</p>
</th></tr></thead><tbody><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">java.util.Set&lt;E&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ICollection&lt;T&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Android.Runtime.JavaSet&lt;T&gt;</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">java.util.List&lt;E&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">IList&lt;T&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Android.Runtime.JavaList&lt;T&gt;</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">java.util.Map&lt;K,V&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">IDictionary&lt;TKey,TValue&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Android.Runtime.JavaDictionary&lt;K,V&gt;</code>
</p>
</td></tr><tr><td style="text-align: left" valign="top">
<p>
<code class="literal">java.util.Collection&lt;E&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">ICollection&lt;T&gt;</code>
</p>
</td><td style="text-align: left" valign="top">
<p>
<code class="literal">Android.Runtime.JavaCollection&lt;T&gt;</code>
</p>
</td></tr></tbody></table></div><p>Xamarin.Android allows you to pass any collection (which implements the correct interface) into the Android API methods. For example, <code class="literal">List</code> implements <code class="literal">IList</code> and can be used <a class="indexterm" id="id152"/>when an <code class="literal">IList</code> entity is required. However, for<a class="indexterm" id="id153"/> performance reasons, it is recommended that you use the helper classes anytime you need to pass any of these collection types into an Android API method.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec29"/>Interfaces</h2></div></div></div><p>Java and C# both <a class="indexterm" id="id154"/>support interfaces; however, Java <a class="indexterm" id="id155"/>supports additional capabilities. Also, both support the ability to define a set of method names and signatures. In addition, Java supports the following:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Nested interface definitions</li><li class="listitem" style="list-style-type: disc">Fields (<code class="literal">public final static</code> only)</li></ul></div><p>In general, the following items describe how the Android bindings provide the following Java interfaces:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A C# interface with the same name but prefixed by <code class="literal">I</code> and containing method declarations is created. For example, <code class="literal">android.view.Menu</code> is created as <code class="literal">Android.Views.IMenu</code>.</li><li class="listitem" style="list-style-type: disc">An abstract class with the same name as the Java interface is generated, which contains definitions for the constants from the Android interface. For example, the constants from <code class="literal">android.view.Menu</code> are placed in the generated abstract class <code class="literal">Android.Views.Menu</code>.</li><li class="listitem" style="list-style-type: disc">A C# interface is generated for each nested interface and is given a name prefixed by <code class="literal">I</code>, the name of the parent Java interface, followed by the name of the nested Java interface.</li><li class="listitem" style="list-style-type: disc">Classes in the Android bindings that implement an Android interface containing constants get a nested <code class="literal">InterfaceConsts</code> type generated that also contains definitions.</li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec30"/>Mapping nested classes</h2></div></div></div><p>Java and C# both <a class="indexterm" id="id156"/>support the definition of<a class="indexterm" id="id157"/> nested classes. However, Java supports two types of nested classes: static and non-static. The following points clarify how it does this:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Java static nested classes are the same as C# nested classes and are translated directly</li><li class="listitem" style="list-style-type: disc">Non-static nested classes, also known as inner classes, are somewhat different; additional rules apply:<div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">A reference to an instance of the containing type must be provided as a parameter in the constructor to the inner class.</li><li class="listitem" style="list-style-type: disc">In the case of inheriting from an inner class, the derived class must be nested within a type. This type inherits properties from the class that contains the base inner class, and the derived class must provide a constructor of the same type as the C# containing type.</li></ul></div></li></ul></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec31"/>Mapping the Runnable interface</h2></div></div></div><p>Java <a class="indexterm" id="id158"/>provides the <code class="literal">java.lang.Runnable</code> interface with a single method, <code class="literal">run()</code>, in order to implement delegation. The <a class="indexterm" id="id159"/>Android platform makes use of this interface in a number of places such as <code class="literal">Activity.runOnUIThread()</code> and <code class="literal">View.post()</code>.</p><p>C# provides the <code class="literal">System.Action</code> delegate for a method with a void return and no parameters; thus, it maps very nicely to the <code class="literal">Runnable</code> interface. The Android bindings provide overloads that accept an <code class="literal">Action</code> parameter for all API members that accept a <code class="literal">Runnable</code> interface in the native API.</p><p>The <code class="literal">IRunnable</code> overloads were also left in place so that types that are returned from other API calls can be used.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec32"/>Enumerations</h2></div></div></div><p>In many <a class="indexterm" id="id160"/>places, the Android APIs uses <code class="literal">int</code> constants <a class="indexterm" id="id161"/>as parameters to specify processing options. To increase type safety, the Android bindings create enumerations to replace <code class="literal">int</code> constants <a class="indexterm" id="id162"/>when possible. The following example shows the use of the <code class="literal">ActivityFlags.NewTaskenum</code> value rather than the <a class="indexterm" id="id163"/>native <code class="literal">FLAG_ACTIVITY_NEW_TASK</code> constant:</p><div><pre class="programlisting">myIntent.SetFlags (ActivityFlags.NewTask);</pre></div><p>Another great advantage of using an <code class="literal">enum</code> class is the enhanced support that you get with code completion in IDEs such as Xamarin Studio and Visual Studio.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec33"/>Resources</h2></div></div></div><p>Xamarin.Android <a class="indexterm" id="id164"/>generates a file named <code class="literal">Resource.Designer.cs</code> in the <code class="literal">Resources</code> folder of your project. This file contains constants <a class="indexterm" id="id165"/>for all of the resources referenced in your app and serves the same purpose as the <code class="literal">R.java</code> file generated for traditional Android apps.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec28"/>Attributes for the ApplicationManifest.xml file</h1></div></div></div><p>Android <a class="indexterm" id="id166"/>applications have a manifest file (<code class="literal">AndroidManifest.xml</code>) that tells the Android platform everything it needs to know to successfully <a class="indexterm" id="id167"/>run the application, including the following features:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">The minimum API level required by the application</li><li class="listitem" style="list-style-type: disc">Hardware/software features used or required by the application</li><li class="listitem" style="list-style-type: disc">Permissions required by the application</li><li class="listitem" style="list-style-type: disc">The initial activity to start when the application is launched</li><li class="listitem" style="list-style-type: disc">Libraries required by the application</li></ul></div><p>Xamarin.Android provides a robust set of .NET attributes that can be used to adorn your C# classes so that much of the information required in <code class="literal">ApplicationManifest.xml</code> will be automatically generated at compile time. Use of these attributes simplifies the task of keeping the manifest in sync with your code. For example, if you rename an <code class="literal">Activity</code> class, the next time you compile, the corresponding <code class="literal">&lt;Activity/&gt;</code> element in the manifest is automatically updated.</p><p>The following example demonstrates the use of the <code class="literal">Activity</code> attribute to specify the launch activity for an app:</p><div><pre class="programlisting">[Activity (Label = "My Accounts", MainLauncher = true)]
public class MyAccountsActivity : Activity
{
    ...
}</pre></div><p>This will <a class="indexterm" id="id168"/>result in the following entry in the <code class="literal">ApplicationManifest.xml</code> file:</p><div><pre class="programlisting">&lt;activity android:label="My Accounts"
android:name="myaoo.MyActivity"&gt;
&lt;intent-filter&gt;
&lt;action android:name="android.intent.action.MAIN" /&gt;
&lt;category
android:name="android.intent.category.LAUNCHER" /&gt;
&lt;/intent-filter&gt;
&lt;/activity&gt;</pre></div><p>Although .NET <a class="indexterm" id="id169"/>attributes are a convenient way to keep your code and manifest file in sync, the use of these attributes is not required.</p></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec29"/>Editor for the ApplicationManifest.xml file</h1></div></div></div><p>Xamarin Studio<a class="indexterm" id="id170"/> also provides an editor for <code class="literal">ApplicationManifest.xml</code>. This can be used instead of attributes or to edit content that cannot be set <a class="indexterm" id="id171"/>through the use of attributes such as the hardware/software features required and permissions. The following screenshot depicts the editor:</p><div><img alt="Editor for the ApplicationManifest.xml file" src="img/0838OT_03_03.jpg"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec30"/>Garbage collection</h1></div></div></div><p>Since Xamarin.Android apps run in two different VMs, garbage collection is somewhat complex <a class="indexterm" id="id172"/>and creates some interesting challenges. Therefore, we have devoted significant time to discuss this process. Xamarin.Android uses Mono's simple generational garbage collector, which supports two types of collections called minor and major:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Minor collections</strong>: These collections are cheap and thus invoked frequently. Minor <a class="indexterm" id="id173"/>collections collect recently allocated and dead objects and are invoked<a class="indexterm" id="id174"/> after every few MB of allocations. You can manually invoke a minor collection with the following code:<div><pre class="programlisting">GC.Collect(0)</pre></div></li><li class="listitem" style="list-style-type: disc"><strong>Major collections</strong>: These collections are expensive and are thus invoked less frequently. Major collections reclaim all dead objects and are only invoked when <a class="indexterm" id="id175"/>memory <a class="indexterm" id="id176"/>is exhausted for the current heap size. You can manually invoke a major collection with the following code:<div><pre class="programlisting">GC.Collect() or GC.Collect(GC.MaxGeneration).</pre></div><div><div><h3 class="title"><a id="note07"/>Note</h3><p>You can review a more detailed discussion on Mono's simple generational garbage <a class="indexterm" id="id177"/>collector at <a class="ulink" href="http://www.mono-project.com/Compacting_GC">http://www.mono-project.com/Compacting_GC</a>.</p></div></div></li></ul></div><p>Before we <a class="indexterm" id="id178"/>continue with the discussion, it will help us if we group objects in an app into the following categories:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Managed objects</strong>: These are any C# objects you create from standard libraries<a class="indexterm" id="id179"/> such as the Mono runtime libraries. They<a class="indexterm" id="id180"/> are garbage collected like any other C# object and have no special connection to any classes from the Android bindings.</li><li class="listitem" style="list-style-type: disc"><strong>Java objects</strong>: These <a class="indexterm" id="id181"/>are Java objects that reside in the Dalvik VM<a class="indexterm" id="id182"/> that were created as a part of some process, but not exposed to a managed object through JNI. These objects are collected as any other Java object, and there is little that we need to discuss about them.</li><li class="listitem" style="list-style-type: disc"><strong>Peer objects</strong>: As <a class="indexterm" id="id183"/>we mentioned earlier, peer objects are <a class="indexterm" id="id184"/>a managed object and Java object pair that <a class="indexterm" id="id185"/>communicates via JNI. It works together to carry out the functionality of an Android app.</li></ul></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec34"/>JNI global and weak references</h2></div></div></div><p>JNI references<a class="indexterm" id="id186"/> come in a couple of different types and they have a big impact on when objects can be collected. Specifically, we will discuss two types of JNI references, which are global and weak references:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Global reference</strong>: A JNI global reference is a reference from "native", or in our case<a class="indexterm" id="id187"/> managed code, to a Java object<a class="indexterm" id="id188"/> managed by the Dalvik VM. A JNI global reference is established between peer objects when they are initially created. A JNI global reference will prevent the Dalvik garbage collector from performing the required action as it indicates the object is still in use.</li><li class="listitem" style="list-style-type: disc"><strong>Weak reference</strong>: A JNI weak reference also allows a managed object to reference <a class="indexterm" id="id189"/>a Java object, but the difference<a class="indexterm" id="id190"/> is that a weak reference will <em>not</em> prevent the Dalvik VM GC from collecting it.</li></ul></div><p>We <a class="indexterm" id="id191"/>will see how these differ later on in this chapter.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec35"/>Mono collections</h2></div></div></div><p>Mono collections <a class="indexterm" id="id192"/>are where the fun happens. As <a class="indexterm" id="id193"/>mentioned earlier, simple managed objects are collected normally, but peer objects are collected by performing the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">All managed peers are eligible for Mono collection, meaning they are not referenced by any other managed objects. They have their JNI global reference replaced with a JNI weak reference. This allows the Dalvik VM to collect the Java peer if no other Java objects in the VM reference them.</li><li class="listitem">A Dalvik VM GC is invoked that allows the Java peers with weak global references to be collected.</li><li class="listitem">Managed peers with a JNI weak reference, as created in step 1, are evaluated. If the Java peer has been collected, then the managed peer is also collected. If the Java peer has not been collected, then it is replaced with a JNI global reference and the managed peer is not collected until a future GC.</li></ol></div><p>The end result is that an instance of a managed peer will live as long as it's referenced by a managed code or its corresponding Java peer is referenced by a Java code. To shorten the lifetime of peers, dispose of peer objects when they are no longer needed.</p><div><div><h3 class="title"><a id="note08"/>Note</h3><p>
<strong>Best practice</strong>
</p><p>Calling the <code class="literal">Dispose()</code> method manually severs the connection between the peers by freeing the JNI global reference, thus allowing each VM to collect the objects as soon as possible.</p></div></div></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec36"/>Automatic collections</h2></div></div></div><p>From <a class="indexterm" id="id194"/>Xamarin.Android 4.1.0 version onwards, a full <a class="indexterm" id="id195"/>garbage collection is performed automatically when a <code class="literal">gref</code> threshold has crossed 90 percent of the known maximum <code class="literal">gref</code> values for the platform.</p><p>When you perform an automatic collection, a message similar to the following is displayed in the debug log:</p><div><pre class="programlisting">I/monodroid-gc(PID): 46800 outstanding GREFs. Performing a full GC!</pre></div><p>Invocations of the automatic GC are nondeterministic and might not happen at best times. If you<a class="indexterm" id="id196"/> are experiencing a pause in processing, look<a class="indexterm" id="id197"/> for messages in the logcat that might indicate that an automatic GC occurred. When this scenario occurs, you can consider when you can use <code class="literal">Dispose()</code> to reduce the lifetime of the peer.</p></div><div><div><div><div><h2 class="title"><a id="ch03lvl2sec37"/>Helping the GC</h2></div></div></div><p>There are a <a class="indexterm" id="id198"/>number of ways in which you can help the GC with the collection process. The following sections provide some additional thoughts:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><strong>Disposing of peer objects</strong>: Get rid of managed peers when they are no longer<a class="indexterm" id="id199"/> needed and consider invoking a minor GC. As<a class="indexterm" id="id200"/> we mentioned earlier, the Mono GC does not have a complete picture of the memory situation. To Mono, peer objects appear to take up only 20 bytes because the MCWs don't add instance variables. Hence, all of the memory is associated with the corresponding Java object and allocated to the Dalvik VM. If you have an instance of <code class="literal">Android.Graphics.Bitmap</code> loaded with a 2 MB image, the Mono GC only sees the 20 bytes and thus disposing of the object will be a low priority to the GC.</li><li class="listitem" style="list-style-type: disc"><strong>Reduce direct references in peer objects</strong>: Whenever a managed peer is scanned<a class="indexterm" id="id201"/> during GC, the entire <a class="indexterm" id="id202"/>object graph is scanned, meaning every object it directly references is scanned as well. Objects with a significant number of direct references can cause a pause when the GC runs.</li><li class="listitem" style="list-style-type: disc"><strong>Minor collections</strong>: Minor collections are relatively cheap. You can consider invoking <a class="indexterm" id="id203"/>minor collections at the end of an activity or <a class="indexterm" id="id204"/>after completing a significant set of service calls or background processing.</li><li class="listitem" style="list-style-type: disc"><strong>Major collections</strong>: Major collections are expensive and should rarely be performed <a class="indexterm" id="id205"/>manually. Only consider manually invoking a<a class="indexterm" id="id206"/> major collection after a significant processing cycle when a large amount of resource has been freed and you can live with a pause in the app's responsiveness.</li></ul></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec31"/>Xamarin.Android Designer</h1></div></div></div><p>Xamarin <a class="indexterm" id="id207"/>provides a plugin for Xamarin Studio that can be used to design layout files for Xamarin.Android apps. The designer supports a <strong>Content</strong> mode for visual drag-and-drop and a <strong>Source</strong> mode for XML-based editing. The following screenshot depicts the designer opened in the <strong>Content</strong> mode:</p><div><img alt="Xamarin.Android Designer" src="img/0838OT_03_04.jpg"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch03lvl1sec32"/>Summary</h1></div></div></div><p>In this chapter, we reviewed the architecture of Xamarin.Android, discussed the design goals, and looked at some of the details of its implementation. We also looked at how memory management works with a Xamarin.Android app. In the next chapter, we will start developing a Xamarin.iOS app.</p></div></body></html>