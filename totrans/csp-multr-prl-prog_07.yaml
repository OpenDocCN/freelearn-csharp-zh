- en: Chapter 7. Data Parallelism
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Concurrently performing a task or a set of operations on a collection of data
    is referred to as data parallelism. For example, if we have a list of files in
    a folder and we want to rename them all, we can create a `For` loop that goes
    through the collection and, during each iteration, the loop performs a rename
    command. We can also iterate through a collection datatype such as a `List` or
    `DataView` using a `foreach` statement. These are specialized `For` and `ForEach`
    statements that are part of the **Task Parallel Library** (**TPL**) in the `System.Threading.Tasks.Parallel`
    namespace.
  prefs: []
  type: TYPE_NORMAL
- en: The TPL provides the `Parallel` library to make it easy to perform concurrent
    operations on a dataset or data collection using the different overloads of the
    `Parallel.For` and `Parallel.ForEach` methods.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will learn how to process items of a data source in parallel
    using the `Parallel.For` and `Parallel.ForEach` methods. We will also examine
    the `ParallelLoopState` class, which allows us to examine the results of a concurrent
    loop and perform actions with the results. Finally, we will learn how to cancel
    a concurrent loop before it has completed. In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Parallel data processing with `Parallel.For`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel data processing of `IEnumerable` collections
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using the results of concurrent data loops
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Canceling a parallel loop operation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parallel loop processing
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this first section, we will examine the `Parallel.For` method and several
    variations of it. The most basic overload to this method takes a starting index,
    an ending index, and an `Action` delegate. In the `Parallel` method, the `Action`
    delegate can be implemented with a named method, anonymous method, or a lambda
    expression. The following is the basic syntax for each method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In each example, the method or lambda expression takes a single parameter that
    is the iteration value. If you need more control over the execution of the concurrent
    loop, there are overload methods that take a `ParallelLoopState` parameter that
    is internally generated by .NET. We will talk about this later in the chapter,
    but it allows us to do things such as canceling a parallel loop or performing
    an action for each iteration of the loop once it is completed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a list of all of the overloads of the `Parallel.For` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parallel loop processing](img/8321EN_07_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: MSDN reference—http://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.for(v=vs.110).aspx
  prefs: []
  type: TYPE_NORMAL
- en: Also, as well as a `ParallelLoopState` parameter, some overloads allow the method
    to return a thread-safe local variable.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's take a look at an example. We will build a simple **Windows Presentation
    Foundation** (**WPF**) application that takes an array of integer numbers, performs
    a calculation on them, and then updates the item in the array. This will be done
    concurrently instead of sequentially.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For this example, we will create a WPF application that allows the user to
    enter numbers in 10 boxes and click on a button. Once the button is clicked, it
    will concurrently take each number and multiply it by the numbers 1 through 10
    and sum the results. The result of each calculation will be placed back in each
    box. Perform the following steps to do so:'
  prefs: []
  type: TYPE_NORMAL
- en: Open Visual Studio and create a WPF application named `ParallelMath1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MainWindow.xaml` design view, change the page title to `ParallelMath`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, create 10 textbox controls and place them in the `MainWindow.xaml` file
    with the names, `tb1`, `tb2`, `tb3`, `tb4`, `tb5`, `tb6`, `tb7`, `tb8`, `tb9`,
    and `tb10` respectively. Also, set their `Text` properties to `0`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, place a button control on the `MainWindow.xaml` file and set the `Content`
    property to `Calculate` and the `Name` property to `btnCalculate`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Next, create an event handler for the button's click event named `btnCalculate_Click`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Inside the class definition, place a line of code to create an array of 10
    integers:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, put the following code inside the `btnCalculate_Click` event handler:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, create a method named `CalculateNumbers` and put the following code
    into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That should be all. Now, let's run our application and see what happens. Remember
    we have not put in any error handling. The application expects a number and only
    a number in each textbox when the **Calculate** button is clicked. If it is not
    there, the application will throw an argument out of range exception.
  prefs: []
  type: TYPE_NORMAL
- en: 'You should see results similar to this before you click on the button:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_07_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, let''s enter 10 numbers into our textboxes so that the application looks
    something like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_07_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the **Calculate** button and you should see the following results
    very quickly since we are doing these calculations concurrently:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_07_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the preceding exercise, we entered 10 numbers into 10 textboxes and then
    clicked on **Calculate**. The program then took each number, multiplied it by
    the numbers 1 through 10, and summed them together. It then placed the result
    back in the textbox it came from.
  prefs: []
  type: TYPE_NORMAL
- en: This was all done concurrently. Each textbox was processed in parallel. This
    may have been on 10 separate threads or fewer, depending on the hardware we run
    the program on. Unlike using threads directly by using the `Parallel` class and
    TPL, .NET manages the threadpool and maximizes how many threads to perform the
    concurrent operation on, using the processing cores available on the machine.
  prefs: []
  type: TYPE_NORMAL
- en: Let's look at how the concurrent loop is executed. It is the single command
    `Parallel.For(0, 9, CalculateNumbers);`. This command queues 10 tasks to the threadpool
    and each task will execute the `CalculateNumbers` method with an integer parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's look at the `Parallel.ForEach` command.
  prefs: []
  type: TYPE_NORMAL
- en: Data parallelism on collections using Parallel.ForEach
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The form of data parallelism that I find most helpful is performing concurrent
    operations on collections of data. This allows us to take data collections such
    as lists, dataviews, dictionaries, and so on and perform a task on each item in
    the collection in parallel with a single line of code! This makes using data parallelism
    simpler; you have to do nothing more than normal data processing. This is one
    of the reasons why the TPL is such a wonderful enhancement to .NET.
  prefs: []
  type: TYPE_NORMAL
- en: 'Much like the `Parallel.For` method, the structure of `Parallel.ForEach` looks
    like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: There are two parameters in the most basic version of this method. There is
    a data collection and an `Action` delegate to perform a task on an item of the
    `dataCollection`. The `Action` delegate takes a single parameter that is an item
    in the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are all of the different overloads of the `ForEach` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Data parallelism on collections using Parallel.ForEach](img/8321EN_07_05.jpg)![Data
    parallelism on collections using Parallel.ForEach](img/8321EN_07_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Reference—http://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.foreach(v=vs.110).aspx
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there are many different overloads to this method. They allow
    us to use a `ParallelLoopState` object or a thread-safe local variable.
  prefs: []
  type: TYPE_NORMAL
- en: We will focus on the simple form of just performing concurrent processing on
    a data collection. To further reiterate this point, let's revisit a project we
    worked on earlier in the book. In [Chapter 4](ch04.html "Chapter 4. Advanced Thread
    Processing"), *Advanced Thread Processing*, we wrote an application that took
    a JPG image, divided it into separate bitmaps, and then performed parallel functions
    on each bitmap to find old stars. It then reassembled the individual bitmaps back
    into a single image.
  prefs: []
  type: TYPE_NORMAL
- en: We will rewrite this application using data parallelism and the TPL instead
    of threads directly. This will demonstrate how TPL can simplify multithreaded
    code development
  prefs: []
  type: TYPE_NORMAL
- en: No longer do we have to manage threads (start them, wait on them to complete,
    or track them). We no longer have to manage the number of processing cores our
    machine has to maximize performance without starting too many individual threads.
    All we have to do is separate our large image into a collection of smaller bitmaps
    and use a `Parallel.ForEach` concurrent loop to process each bitmap. That's it.
    Let's get started.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We will take our original `OldStarsFinder` Windows Form application and change
    it. To do this let''s perform the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, let's open our `OldStarsFinder` application in Visual Studio.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add a new `using` statement so we can access the `Parallel` library:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At the beginning of the class definition, remove all of the old variable declarations
    and replace them with just these:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Replace the `CropBitmap` method with this method definition:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: You can leave the `IsOldStar` method as is.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Change the `ThreadOldStarsFinder` method to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then change the `ShowBitmapWithOldStars` method to look like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, change the `butFindOldStars_Click` event handler to have the following
    code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Then add a label control with the text, `Number of bitmaps to divide into for
    processing:`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also, add a textbox control and set its `Name` property to `tbTasks`. This will
    be used to allow you to designate the number of sections you want the bitmap divided
    into.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, we remove the `butFindOldStarsBatch` button because we do not need
    it in this application.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: That should be all you need to do to run this application using data parallelism
    with the Task Parallel Library.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s compile and run our application. You should get something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_07_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, enter the number of bitmaps to divide the image into and click on the
    **Old Star Finder** button. The application will now look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_07_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What just happened? We entered `8` for the number of bitmaps to divide into.
    The application splits the JPG image into 8 equal-sized bitmaps and then into
    a list collection of bitmaps. Then it concurrently processes each bitmap looking
    for old stars. Finally, it reassembles the bitmaps into one image and redisplays
    it.
  prefs: []
  type: TYPE_NORMAL
- en: Let's take a closer look at what just happened.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you compare the two versions of the program, you will see that the second
    version is much simpler with less code. If we examine the `butOldStarsFinder_Click`
    event handler method, we will see most of the work. First, we divide our image
    up into a `List` collection of smaller bitmaps based on the number we entered.
    Here is the code that does this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we take our list collection, `BitmapList`, and use it in a parallel `ForEach`
    command in this line of code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, when this loop has completed, we display the image with the old stars
    with this method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: That is it. We no longer have to find out how many cores the processor has and
    create that many threads. No matter how many items there are in our collection,
    .NET maximizes the threads in the threadpool to achieve optimal performance. It
    will create threads if needed or reuse existing threads if possible. This saves
    on the overhead of starting more threads than can be effectively used by the number
    of cores in the machine.
  prefs: []
  type: TYPE_NORMAL
- en: You can now see why writing multithreaded code using TPL is called lightweight
    concurrency. This version of the Old Stars Finder is definitely "lighter" on the
    code and logic than the previous version written directly with threads or heavyweight
    concurrency.
  prefs: []
  type: TYPE_NORMAL
- en: Canceling a parallel loop
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we have learned how to execute a parallel loop using a `Parallel` class
    library, let's take a look at how we can stop or break a loop if needed. With
    a normal `For` or `ForEach` loop we can use a `Continue` command to break from
    a loop.
  prefs: []
  type: TYPE_NORMAL
- en: If we break from a parallel loop, then we complete all iterations on the threads
    that are currently executing and then stop. If we `Stop` a parallel loop, then
    we stop all currently running iterations of the loop as soon as possible, but
    we do not run them to completion. In either case, we will not schedule tasks on
    the threadpool for the rest of the iterations of the parallel loop that we are
    yet to get started with.
  prefs: []
  type: TYPE_NORMAL
- en: To perform a break or a stop of a parallel loop, we need to use the `ParallelLoopState`
    object. This means that we have to use one of the overloads or the `Parallel.For`
    or `Parallel.ForEach` method that takes a `ParallelLoopState` parameter.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: What is the `ParallelLoopState` class? This class cannot be instantiated in
    your user code. It is provided by the TPL and .NET and hence is a special class.
    This object provides your parallel loop with a mechanism to interact with other
    iterations in the loop.
  prefs: []
  type: TYPE_NORMAL
- en: The `break` and `stop` methods are the methods you will use most often, as well
    as the `IsStopped` and `IsExceptional` properties. These properties allow you
    to check whether any iteration of the loop has called `Stop` or thrown an exception.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we will take our `ParallelMath1` example and change it to stop the loop
    after seven iterations. This is arbitrary, for example purposes. But in a real
    example, there are many conditions where you will want to break or stop from a
    parallel loop.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We just need to make a few adjustments to our previous program. Let''s start
    by opening the `ParallelMath1` WPF application in Visual Studio and making the
    following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new method called `CalculateNumbers2` and place the following code
    into it:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then change our `Parallel.For` command to call this new method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'That''s it. Now, let''s run our application and put numbers in each of the
    boxes so that it looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_07_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the **Calculate** button and your results should look like the
    following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_07_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: What do you see? Yes, after seven iterations of the parallel loop, the loop
    is stopped and the last three iterations are not finished. Let's examine why.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'By adding the `ParallelLoopState` parameter to the method called by the parallel
    `For` method, we actually change the overload of the method that is called. We
    are now calling this overload:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How it works](img/8321EN_07_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: You will notice that we do not create this `ParallelLoopState` variable and
    pass it into the `CalculateNumbers2` method. It is done by .NET and we can just
    use it. Pretty handy!
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, in our `Action` delegate, `CalculateNumbers2`, we call the `Stop` method
    of this object using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Once this method is called, the rest of the iterations of the loop are not performed
    and the loop completes with the iterations it has already completed.
  prefs: []
  type: TYPE_NORMAL
- en: This is not a very practical example—why execute the loop for 10 iterations
    and just stop after seven? Why not execute the parallel for seven iterations in
    the first place? This is just an example for demonstration purposes. In your applications,
    you will find many conditions by which you will want to exit a parallel loop before
    completing all iterations, just like with a normal `For` loop.
  prefs: []
  type: TYPE_NORMAL
- en: Handling exceptions in parallel loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, no matter how hard we try to write error-free code, the real world intervenes
    and inevitably there are exceptions that our code will encounter, for example,
    file not found, argument out or range, and so on. When we are processing a parallel
    loop command, since all of the iterations are running on potentially different
    threads, we need a way to gather all of the exceptions that any of the iterations
    of the loop may produce.
  prefs: []
  type: TYPE_NORMAL
- en: .NET provides the `AggregateException` class for just this purpose. This allows
    us to collect all of the exceptions into the `AggregateException` object and then
    "catch" it once the loop has completed.
  prefs: []
  type: TYPE_NORMAL
- en: Think of this like you would a normal error-handling situation. Typically, you
    put a `try` block around a section of the code and then a `catch` block after
    it to process any exceptions that occurred in the `try` block of the code. This
    will behave the same way. We will put a `try` block around our parallel loop command
    and then catch the exceptions that occur in all of the iterations of the loop.
    Only in this case, our `catch` block will catch the `AggregateException`, which
    is just a collection of exceptions.
  prefs: []
  type: TYPE_NORMAL
- en: Also, in our `Action` delegate, we will catch any exceptions that occur and
    add them to the `AggregateException` object.
  prefs: []
  type: TYPE_NORMAL
- en: That is all there is to it! Let's try this for ourselves by modifying our `ParallelMath1`
    project to generate an exception if any of the iterations produce a sum of over
    5 million.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To start, let''s open the `ParallelMath1` project in Visual Studio and make
    the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: 'We will be using a `Concurrent` queue to collect the exceptions, so add this
    `using` statement:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we need to declare our `ConcurrentQueue` instance where it is visible
    to the entire class. Add the following line right after the declaration on the
    number''s integer array:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, we will add a new method to be called by the `Action` delegate of our
    parallel loop command. We will call this method `CalculateNumbers3`. Add the following
    code to this method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, let''s alter our `btnCalculate_Click` event handler. Change the code
    between the population of the numbers array and the population of the textboxes
    to include the following lines of code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Finally, in the `MainWindow.xaml` designer view, add a textblock control; set
    its `Name` property to `tbMessages` and its `Text` property to an empty string.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now our changes are complete. When any of the iterations of the parallel loop
    reach above 5 million, we will throw an exception. All of the exceptions will
    be collected into a `ConcurrentQueue` and added to the `AggregateException` object.
    Once the parallel loop execution has completed, we will process the `AggregateException`,
    if there are any, and write their exception messages to the `Messages` textblock.
  prefs: []
  type: TYPE_NORMAL
- en: 'Build and run your application. Now, enter numbers in each of the boxes. You
    should have a screen that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_07_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the **Calculate** button and you should see results that look
    like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_07_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the output, every box that has a total that goes over 5
    million has a line printed in our **Messages** textblock. In this example, any
    number that goes over 5 million throws an exception. Once all of the iterations
    of the parallel loop have completed, we process these exceptions and print their
    messages to the `tbMessages` textblock.
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first thing we changed was adding an object that is in a concurrent queue,
    to hold all of our exceptions. This is done with this command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, in our `Action` delegate of the parallel `for` command, which in this
    version executes `CalculateNumbers3`, we check for numbers greater than 5 million
    through an exception using the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'We then catch this exception within the delegate and add it to our concurrent
    queue of exception objects using these statements:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: We do this because we do not want to interrupt other iterations of the parallel
    loop running on different threads. We want the loop to finish processing and then
    handle the exceptions. Since each iteration of the loop is running concurrently
    and is designed not to affect other iterations, we should not interrupt all of
    the iterations because one has an issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once the loop has completed, we want to check for any exceptions and process
    them. Here is the code that handles this functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: If we see any exceptions in our `ConcurrentQueue` object, we throw an `AggregateException`
    and give it the whole queue of exceptions. Then we catch this `AggregateException`
    and process all of the exceptions it contains.
  prefs: []
  type: TYPE_NORMAL
- en: We could have also performed different actions based on the exception type of
    each exception. You can play with your code and try this.
  prefs: []
  type: TYPE_NORMAL
- en: Using thread-local variables in parallel loops
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you are comfortable using parallel loops, stopping them, and performing
    exception handling with them, let's talk about how we can use thread-local variables
    to better coordinate results. If we want to sum the results of all the iterations
    of a parallel loop, how would we do that?
  prefs: []
  type: TYPE_NORMAL
- en: From what we have learned so far, we would create a class variable before the
    loop and access it by each iteration of the loop using a `lock` statement so that
    it remains thread-safe. This takes overhead and coordination time. To improve
    performance, we can implement our parallel loop using a thread-local variable.
  prefs: []
  type: TYPE_NORMAL
- en: The `Parallel.For` and `Parallel.ForEach` loops both have overloads that implement
    a thread-local variable. What do we mean by a thread-local variable? This is a
    variable whose scope lasts the duration of the parallel loop, from just before
    the first iteration starts to the completion of the last iteration. Each iteration
    of the loop gets its own copy of the thread-local variable.
  prefs: []
  type: TYPE_NORMAL
- en: In these overloads of the parallel loop methods, there are three functions that
    get passed to the loop as well as the iteration parameters. For a `For` loop,
    the iteration parameters are the starting and ending values of the loop index,
    and for the `ForEach` loop, it is the source collection.
  prefs: []
  type: TYPE_NORMAL
- en: The first function will initialize the thread-local variable. The second function
    is the `Action` delegate that the loop performs. The third function is the `Action`
    delegate that gets executed when all iterations of the loop have completed, and
    it receives the thread-local variable for each loop iteration. It can then process
    the results, which usually means combining the results.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s examine one of the `ForEach` overloads:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s dissect this for a minute. We will take each piece of the method definition
    and explain its role:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ForEach<TSource, TLocal>`: `TSource` is the datatype of the source collection,
    and `TLocal` is the datatype of the thread-local variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`IEnumerable<TSource>`: This is the source collection. Since we are using a
    `ForEach` example, the source collection has to be `IEnumerable`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Func<TLocal>`: This is the first function; it initializes the thread-local
    variable.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Func<TSource, ParallelLoopState, TLocal, TLocal>`: This is the second function;
    it is the `Action` delegate that is performed by each iteration of the loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Action<TLocal>`: This is the third function; it is the `Action` delegate that
    is performed on the local state of each iteration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Even though this is a fairly straightforward concept, it leads itself to a method
    overload that looks very complicated. To make sure we understand, let's go to
    our `ParallelMath1` project and see how it works in the sample application we
    have been building.
  prefs: []
  type: TYPE_NORMAL
- en: How to do it
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use a thread-local variable to sum up our textboxes once we have performed
    our parallel loop on them, let''s open our `ParallelMath1` project and make a
    few changes:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `MainWindow.xaml` file in the designer view, let's add a label control
    and set the `Content` property to `Sum:`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, let's add a textbox control beside it and set the `Name` property to `tbSum`
    and make the `Text` property empty.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In the `MainWindow.xaml.cs` file, add the following `using` statement so that
    we can use the `Interlocked.Add` method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Also, add a class variable below our `ConcurrentQueue` declaration for a sum
    variable we will call `total`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, comment out our current `Parallel.For` command because we are going to
    use the new overloaded version needed for thread-local variables:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'It is easier for this version of a `Parallel.For` to use a lambda expression
    instead of the named methods for the `Action` delegates. So, use the following
    `Parallel.For` command:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, right after this statement, add the following statement so that we
    can see the total on the user interface:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: That is all the changes we need to make so that we can use our thread-local
    variable with the `Parallel.For` loop to calculate the sum of our textbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once these changes have been made, build and run the application. Enter numbers
    in the textboxes and you should have a screen that looks like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_07_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, click on the **Calculate** button and see what happens. The results should
    look like the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![How to do it](img/8321EN_07_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: As you can see from the example, we now have a sum of all of the boxes once
    the parallel loop has processed them. We are able to do this without having to
    continually lock the class variable in each iteration when it wants to update
    the loop. We can do the summing once at the end of the parallel loop using the
    thread-local value from each iteration of the loop.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's examine what just happened
  prefs: []
  type: TYPE_NORMAL
- en: How it works
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Just like in the previous versions of this project, we take the numbers in 10
    different textboxes and multiply them by the numbers 1 through 10 and sum them.
    The result is then put back in the textbox. But this time, we take the new results
    in the 10 text boxes and sum them, and the final total is displayed in the `tbSum`
    textbox.
  prefs: []
  type: TYPE_NORMAL
- en: 'The only real difference in this version is the `Parallel.For` command. Let''s
    take a deeper look at it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: 'First, we now have a `TResult` parameter that is a long `Parallel.For<long>`.
    This tells us that the `Action` delegate that each iteration of the loop executes
    will return a value with the datatype `long`. This `Action` delegate is implemented
    as a lambda expression this time and is the fourth parameter of our `Parallel.For`
    method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s create a back up; the first two parameters are the starting and ending
    indices of our iteration, 0 and 10\. The third parameter is our `Action` delegate
    that initializes the thread-local variable. It is implemented with a lambda expression:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, our final parameter to the `Parallel.For` method is the `Action` delegate
    that is executed on each iteration''s thread-local variable:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: We chose to use lambda expression for the three `Action` delegates in this example
    instead of named or anonymous methods because it is easier for us to see what
    is going on and what is being passed to what. However, we can use named methods
    to achieve the same results.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered all aspects of imperative data parallelism. In [Chapter
    10](ch10.html "Chapter 10. Parallel LINQ – PLINQ"), *Parallel LINQ – PLINQ*, we
    will cover declarative data parallelism with PLINQ discussion. Data parallelism
    using TPL in .NET really comes down to performing parallel loops using the `Parallel.For`
    and `Parallel.ForEach` methods. These parallel loops allow us to iterate through
    a set or collection of data and perform the same function on each member of the
    set concurrently.
  prefs: []
  type: TYPE_NORMAL
- en: We learned how to perform a parallel loop on a set of data using `Parallel.For`
    and a collection of data using `Parallel.ForEach`. We then saw how to stop or
    break from a loop when a particular condition was reached; for this we used the
    `ParallelLoopState` object that .NET can generate.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we explored error handling with parallel loops and the `AggregateException`
    object. We learned how to process all of the exceptions that might occur during
    the different iterations of the loop without affecting the other iterations.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we saw how to use thread-local variables in our loops to
    have a thread-safe local copy of a variable and then use the results from all
    of these local copies at the end of the loop processing.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will take some time and explore the Visual Studio Debugger
    and the features it provides for debugging a parallel application that has multiple
    threads running at once.
  prefs: []
  type: TYPE_NORMAL
