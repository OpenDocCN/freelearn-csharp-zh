- en: Chapter 3. Communicating with the Player – the User Interface
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第3章. 与玩家沟通 - 用户界面
- en: User interfaces, often referred to as UIs for short, play a vital role in a
    game, since it's one of the main way to exchange information with the player.
    Usually, the game provides information, status, or stats of the game and the player
    interacts with the game with input through the UI.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面，通常简称为UI，在游戏中扮演着至关重要的角色，因为它是与玩家交换信息的主要方式之一。通常，游戏提供有关游戏和玩家的信息，玩家通过UI进行输入与游戏互动。
- en: This chapter will explain why UIs play such an important role in games and about
    the different things that we need to take into consideration when we design and/or
    implement UIs. Of course, this chapter will focus on the Unity framework to build
    UIs, and explains how to use it.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将解释为什么UI在游戏中扮演如此重要的角色，以及我们在设计和/或实现UI时需要考虑的不同事项。当然，本章将专注于Unity框架来构建UI，并解释如何使用它。
- en: In the last part of the chapter, we will see how to start with UI programming
    from a practical point of view by implementing two important game play elements
    within the UI of our game. However, we will see more about UI programming in [Chapter
    5](part0062.xhtml#aid-1R42S1 "Chapter 5. The Secret Ingredient Is a Dash of Physics"),
    *The Secret Ingredient Is a Dash of Physics*, where we will polish the game and
    implement the whole gameplay based on the elements built in the previous chapters.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的最后部分，我们将从实际的角度出发，通过在我们的游戏UI中实现两个重要的游戏元素来了解如何开始UI编程。然而，我们将在第5章[“The Secret
    Ingredient Is a Dash of Physics”](part0062.xhtml#aid-1R42S1 "第5章. 物理的神秘成分")中看到更多关于UI编程的内容，我们将对游戏进行润色，并基于前几章构建的元素实现整个游戏玩法。
- en: 'Lastly, you should definitely consider buying a book that is specifically about
    UI. Before writing this book, I wrote another book year: *Unity UI Cookbook*,
    *Packt publishing*. It has a perfect set of recipes ready to use. There you will
    find all the concepts mentioned here and much more, such as different tips and
    tricks. You can find it at [https://www.packtpub.com/game-development/unity-ui-cookbook](https://www.packtpub.com/game-development/unity-ui-cookbook).'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你绝对应该考虑购买一本专门关于UI的书籍。在撰写这本书之前，我写了一本名为《Unity UI食谱》的书，由Packt出版。它提供了一套现成的完美食谱。在那里，你可以找到这里提到的所有概念以及更多内容，例如不同的技巧和窍门。你可以在[https://www.packtpub.com/game-development/unity-ui-cookbook](https://www.packtpub.com/game-development/unity-ui-cookbook)找到它。
- en: 'Therefore, in this chapter, we will learn how the UIs are designed and how
    to implement them in Unity:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在本章中，我们将学习如何设计和在Unity中实现UI：
- en: Designing UIs
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 设计用户界面
- en: Understanding the Unity framework to build UIs by looking in detail at each
    of its components
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过详细查看每个组件来理解Unity框架以构建UI
- en: Manipulating and placing UI elements
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 操作和放置UI元素
- en: Designing the UI for our tower defense game
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 为我们的塔防游戏设计UI
- en: Implementing a health bar within our game
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的游戏中实现一个生命值条
- en: Implementing a sugar meter within our game
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在我们的游戏中实现一个糖量计
- en: Like all the other chapters of this book, you will find the *Homework* section
    at the end. It has a range of different exercises for you to do to improve your
    skills and implement a range of different functionalities into your game. So,
    let's get ready to learn a lot about UIs.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 就像本书的所有其他章节一样，你将在结尾找到“作业”部分。它包含一系列不同的练习，以提高你的技能并将各种不同的功能实现到你的游戏中。所以，让我们准备好学习很多关于UI的知识。
- en: Getting ready
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备工作
- en: We will use the graphics from the same package of the previous chapter to build
    our UI as well. Therefore, be sure to have it imported and have the images imported
    as Sprites in order to use them in the UI.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用上一章相同包中的图形来构建我们的UI。因此，请确保已将其导入，并将图像作为精灵导入，以便在UI中使用。
- en: Designing the user interface
  id: totrans-15
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计用户界面
- en: Think about when you are reading a book, the text or images are on the center
    of the page, the page number is located, usually, in a corner, and the pages are
    numbered consecutively. The whole process is pretty straightforward and hassle
    free. Players expect the same experience, not only with gameplay, but also with
    other on-screen elements such as the UI. The design of a UI requires considerations
    of a number of things. For example, the platform that you are designing for has
    limitations, such as screen size, and the types of interaction that it can afford
    (does it use touch or a mouse pointer?). But physiological reactions that the
    interface might give to the player need to be considered, since he or she will
    be the final consumer. In fact, another thing to keep in mind is that some people
    read from right to left in their native languages, and the UI should reflect this
    as well.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 当你阅读一本书时，文本或图像通常位于页面中央，页码通常位于角落，并且页面是连续编号的。整个过程相当直接且无烦恼。玩家期望获得相同体验，不仅是在游戏玩法上，还包括其他屏幕元素，如用户界面（UI）。设计UI需要考虑许多因素。例如，你正在为的平台有局限性，比如屏幕尺寸，以及它能支持哪些类型的交互（是否使用触摸或鼠标指针？）。但界面可能给玩家带来的生理反应也需要考虑，因为玩家将是最终消费者。实际上，还有另一件事需要记住，有些人用母语从右到左阅读，UI也应该反映这一点。
- en: Another thing to keep in mind is that if you are designing for multiple devices,
    try to keep the experience the same. With many applications being multi-platform,
    you don't want the user getting used to an experience on a mobile that is presented
    in one way, and then to log on to the computer version, and it's completely different.
    Therefore, while you are designing the UI, determine how it will look on each
    device. Is the home icon too small on a mobile to understand what it is? Is the
    navigation menu too large for a desktop version? Making sure that the UI is optimized
    will ensure that users who use your application across multiple devices will have
    a seamless transition and won't have to try to figure out how to access features
    all over again.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 另一件事需要记住的是，如果你为多个设备设计，尽量保持相同的体验。随着许多应用成为多平台，你不想用户在手机上习惯了某种体验，然后登录到电脑版本，却发现完全不同。因此，在设计UI时，确定它在每个设备上的外观。是否在手机上主图标太小，以至于无法理解它是什么？是否导航菜单在桌面版本中太大？确保UI优化将确保使用你应用的多设备用户能够无缝过渡，无需再次尝试弄清楚如何访问功能。
- en: Just like our book example, players or users of applications are used to certain
    conventions and formats. For example, a house icon usually indicates home or the
    main screen, an e-mail icon usually indicates contact, and an arrow pointing right,
    usually indicates that it will continue to the next item in the list, or the next
    question, and so on. Therefore, to improve ease of use and navigation, it is ideal
    to stick to these or to at least keep these in mind during the design process.
    In addition to this, how the user navigates through the application is important.
    If there is only way to get from the home screen to an option, and it's via a
    whole bunch of screens, the whole experience is going to be tiresome. Therefore,
    be sure to create navigation maps early on to determine the route for each part
    of the experience. If a user has to navigate through six screens before they can
    reach a certain page, then they won't be doing it for very long.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 就像我们的书籍示例一样，玩家或应用用户习惯于某些约定和格式。例如，房屋图标通常表示主页或主屏幕，电子邮件图标通常表示联系，而指向右方的箭头通常表示将继续到列表中的下一项，或下一个问题，等等。因此，为了提高易用性和导航性，最好坚持这些或至少在设计过程中牢记这些。除此之外，用户如何导航应用也很重要。如果从主页到某个选项只有一种方式，而且需要通过一大堆屏幕，整个体验将会很累人。因此，务必尽早创建导航图，以确定体验各部分的路线。如果一个用户必须通过六个屏幕才能到达某个页面，那么他们不太可能长时间这样做。
- en: Loud noises can immediately get people's attention. So can UI elements. Therefore,
    you want to make you more important elements the focal point. The key here is
    to have fewer elements, if not only a single element, the focal point to reduce
    the player from feeling overwhelmed. For example, in a game, you may want the
    health bar to be the main item of focus. Therefore, place it somewhere where it
    will be noticed and not in the corner in the player's peripheral view. One way
    to achieve this is to have the UI elements contrast the environment, ideally within
    the same color palette so that they stand out, but not draw so much attention
    that they are distracting.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 响亮的声音可以立即吸引人们的注意。UI元素也是如此。因此，你想要使更重要的元素成为焦点。关键是要有更少的元素，如果不是只有一个元素，以减少玩家感到不知所措。例如，在游戏中，你可能希望生命条是主要关注的对象。因此，把它放在一个容易被注意到的地方，而不是在玩家的视野角落里。实现这一目标的一种方法是将UI元素与环境形成对比，理想情况下是在同一色系内，这样它们就会突出，但不会引起太多的注意而分散玩家的注意力。
- en: 'A great website to create great color schemes is Adobe Color ([https://color.adobe.com/](https://color.adobe.com/)).
    An example of it can be seen in the following screenshot:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 一个创建出色配色方案的优秀网站是Adobe Color ([https://color.adobe.com/](https://color.adobe.com/))。以下截图展示了它的一个例子：
- en: '![Designing the user interface](img/image00385.jpeg)'
  id: totrans-21
  prefs: []
  type: TYPE_IMG
  zh: '![设计用户界面](img/image00385.jpeg)'
- en: In saying all of this, don't let the design over take the practicality of the
    user's experience. For example, you may have a beautiful UI but it makes it really
    hard to play the game or it causes too much confusion. Particularly during fast-paced
    gameplay, you don't want the player to have to sift through twenty different on-screen
    elements to find what they are looking for. You want the level mastery focused
    on the gameplay rather than understanding the UI. One way to also limit the amount
    of UI elements present at any one time is to have sliding windows or pop-up windows
    that have other UI elements present. For example, if your player has the option
    to unlock many different types of ability but they are only able to use one or
    two of them at any single moment during gameplay, there is no point in displaying
    them all. Therefore, having a UI element for them to click that then displays
    all of the other abilities, which they can swap for the existing ones, is one
    way to minimize the UI design. Of course, you don't want to have multiple pop-up
    windows, otherwise it becomes a quest in itself to change settings in-game.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在说所有这些的时候，不要让设计超过用户体验的实用性。例如，你可能有一个漂亮的用户界面，但它确实使得玩游戏变得非常困难，或者它造成了太多的困惑。尤其是在快节奏的游戏过程中，你不想让玩家不得不筛选二十个不同的屏幕元素来找到他们想要的东西。你希望关卡掌握集中在游戏玩法上，而不是理解用户界面。限制任何时刻存在的UI元素数量的另一种方法是有滑动窗口或弹出窗口，其中包含其他UI元素。例如，如果你的玩家可以选择解锁许多不同类型的技能，但在游戏过程中任何时刻只能使用其中的一到两个，那么显示所有这些技能是没有意义的。因此，有一个UI元素供他们点击，然后显示所有其他技能，他们可以用来替换现有的技能，这是最小化UI设计的一种方法。当然，你不想有多个弹出窗口，否则改变游戏中的设置本身就成了一个任务。
- en: One thing that a UI can offer is feedback. Feedback is not necessarily a pop-up
    screen that is displayed in the center of the screen; it can be something as simple
    as a meter increasing/decreasing, such as a health bar, or a player's avatar changing
    over time; for example, they begin to age as the player progresses through the
    game. The next thing about adding feedback is how you are going to alert the player
    to changes in the UI. In some instances, it is not necessarily to alert the player,
    it's just a natural part of the process; in others, they need to know that changes
    have occurred or are occurring. One way to indicate changes to a player is to
    animate the UI element in question. This can be as simple as a glowing effect;
    for example, each time the player is attacked their health meter glows or pulsates
    as it decreases. Another option is to indicate that changes are occurring in the
    UI with sound; for example, each time the player's currency increases, a soft
    chime sound plays. Audio can be just as effective as an animation, but also keep
    in mind that feedback that is based on audio won't always be heard. For example,
    sometimes, players opt to disable the sound if they are in a public place and
    do not have headphones, so keep this in mind if you are using sound as the only
    way to indicate a change in the UI to the player. In addition to the types of
    feedback, each action needs a reaction, and if the player does something that
    they are not supposed to do, they need to be notified. So each time that a player
    provides input, clicks a button, or interacts with the UI, something should happen.
    How prominent it is is up to you; just make sure that it is clear and not over
    the top.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 用户界面可以提供的一种东西是反馈。反馈不一定是显示在屏幕中央的弹出窗口；它可能只是像仪表增加/减少那样简单，例如健康条，或者玩家的头像随时间变化；例如，随着玩家在游戏中的进展，他们开始变老。关于添加反馈的下一件事是如何让玩家意识到用户界面的变化。在某些情况下，并不一定是要提醒玩家，它只是过程的一个自然部分；在另一些情况下，他们需要知道已经发生或正在发生的变化。向玩家指示变化的一种方式是动画化相关的用户界面元素。这可以像发光效果一样简单；例如，每次玩家被攻击时，他们的健康条都会随着减少而发光或脉动。另一种选择是用声音来指示用户界面中的变化；例如，每次玩家的货币增加时，都会播放一个柔和的铃声。音频可以和动画一样有效，但也要记住，基于音频的反馈并不总是会被听到。例如，有时，如果玩家在公共场所且没有耳机，他们可能会选择禁用声音，所以如果您将声音作为唯一指示玩家用户界面变化的方式，请记住这一点。除了反馈类型之外，每个动作都需要有反应，如果玩家做了他们不应该做的事情，他们需要被告知。所以每次玩家提供输入、点击按钮或与用户界面交互时，都应该发生一些事情。它有多突出取决于您；只需确保它清晰且不过分即可。
- en: This section gave you an introduction into the issues behind designing a good
    UI. There are so many other factors to take into account that specific books just
    about UIs have been written. For instance, one of these is localization, which
    is so vast that a whole chapter is needed to describe it (you can find a brief
    introduction to Localization in [Chapter 8](part0100.xhtml#aid-2VBO82 "Chapter 8. What
    Is beyond the Cake?"), *What Is beyond the Cake?*).
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 本节为您介绍了设计良好用户界面背后的问题。有许多其他因素需要考虑，以至于专门关于用户界面的书籍都已被撰写。例如，其中之一就是本地化，这是一个如此庞大的概念，以至于需要整整一章来描述它（您可以在[第8章](part0100.xhtml#aid-2VBO82
    "第8章。蛋糕之外是什么？")中找到关于本地化的简要介绍，“蛋糕之外是什么？”）。
- en: 'However, before moving on, I just want to point out a technical term about
    UIs, since it also appears in the official documentation of Unity. Some UIs are
    not fixed on the screen, but actually have a physical space within the game environment.
    Some designers call these UIs *diegetic*, as opposed to classical interfaces that
    are *non-diegetic*. It is a term that has been borrowed from other disciplines,
    and therefore is not unanimously accepted for UIs. In fact, it might even cause
    a little confusion. Just to provide you with a bit more of a historical background,
    the term derives from the word *diegesis*. We can see its definition in the Merriam-Webster
    dictionary:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在继续之前，我想指出一个关于用户界面的技术术语，因为它也出现在Unity的官方文档中。有些用户界面并不是固定在屏幕上的，而是在游戏环境中有一个实际的空间。一些设计师将这些用户界面称为“diegetic”，与传统的“non-diegetic”界面相对。这是一个从其他学科借用的术语，因此并不是所有关于用户界面的说法都被普遍接受。事实上，它甚至可能引起一些混淆。为了给您提供更多历史背景，这个术语来源于单词“diegesis”。我们可以在Merriam-Webster词典中看到它的定义：
- en: '*"the telling of a story by a narrator who summarizes events in the plot and
    comments on the conversations, thoughts, etc., of the characters."*'
  id: totrans-26
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: “由叙述者讲述的故事，叙述者总结情节事件并对角色的对话、思想等进行评论。”
- en: 'An example of a diegetic interface, or just for simplicity an UI placed within
    the game word, is the minimap of the game *Dead Space* (Visceral Games, former
    EA Redwood Shores), which we can see in the following screenshot:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 一个叙事界面或简化地说，放置在游戏世界中的UI的例子是游戏《死亡空间》（Visceral Games，前EA Redwood Shores）中的小地图，我们可以在下面的屏幕截图中看到：
- en: '![Designing the user interface](img/image00386.jpeg)'
  id: totrans-28
  prefs: []
  type: TYPE_IMG
  zh: '![设计用户界面](img/image00386.jpeg)'
- en: Programming the user interface
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 编程用户界面
- en: As we have seen in the previous section, designing UI can be tough, and requires
    experience to get into, especially if you take into consideration all the elements
    you should, such as the psychology of your audience. However, this is just half
    way through. In fact, designing is one thing, making it work is another. Usually,
    in large teams, there are artists who design the UI and programmers who implement
    it.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 如前文所述，设计用户界面可能是一项艰巨的任务，需要经验才能掌握，尤其是当你考虑到所有应该考虑的元素时，例如受众的心理。然而，这仅仅是开始的一半。实际上，设计是一回事，让它有效运行则是另一回事。通常，在大团队中，有艺术家负责设计UI，而程序员则负责实现它。
- en: Is UI programming that different? Well, the answer is no, programming is still
    programming; however, it's quite an interesting branch of the field of programming.
    If you are building your game engine from scratch, implementing an entire system
    that handles input is not something you can create just with a couple of hours
    of work. Catching all of the events that the player does in the game and in the
    UI is not easy to implement, and requires a lot of practice. Luckily, in the context
    of Unity, most of this backend for UIs is already done. Furthermore, as we will
    see in the next section, Unity provides a solid framework to work also on the
    frontend for UIs. This framework includes different components that can be easily
    used without knowing anything about programming. But if we are really interested
    in unlocking the potentiality of Unity framework for the UIs, we not only need
    to understand it, but also program within it.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: UI编程真的有那么不同吗？答案是：不，编程还是编程；然而，它是编程领域中的一个相当有趣的分支。如果你是从零开始构建你的游戏引擎，实现一个处理输入的整个系统并不是几个小时就能完成的。捕捉玩家在游戏和UI中进行的所有事件并不容易实现，需要大量的实践。幸运的是，在Unity的背景下，大多数UI的后端工作已经完成。此外，正如我们将在下一节中看到的，Unity提供了一个稳固的框架，用于处理UI的前端工作。这个框架包括不同的组件，可以很容易地使用，无需了解任何编程知识。但如果我们真的对解锁Unity框架在UI方面的潜力感兴趣，我们不仅需要理解它，还需要在其中进行编程。
- en: Even with a solid framework, such as the one in Unity, UI programming still
    needs to take into consideration many factors, enough to have a specific role
    for this in large teams. Achieving exactly what designers have in mind, and possible
    without hitting the performances too much, is most of the job of an UI programmer
    (at least using Unity).
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 即使有一个稳固的框架，比如Unity中的那个，UI编程仍然需要考虑许多因素，足以在大型团队中为这个角色设定一个特定的位置。精确地实现设计师的意图，同时尽可能不牺牲性能，是UI程序员（至少在使用Unity时）的主要工作。
- en: Mastering these skills requires time and patience, and this chapter is just
    an introduction to this world. I hope you will enjoy reading this chapter.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 掌握这些技能需要时间和耐心，而本章只是对这个领域的入门介绍。希望你会喜欢阅读这一章。
- en: User interface system
  id: totrans-34
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用户界面系统
- en: Now that we have acquired a basic knowledge about how to design UIs, it's time
    to learn how Unity handles all of this. From Unity 4.6, it is possible to use
    a dedicated UI system called UI. The goal of this section is understand how it
    works.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对如何设计UI有了基本的了解，是时候学习Unity如何处理所有这些内容了。从Unity 4.6版本开始，可以使用一个专门的UI系统，称为UI。本节的目标是理解它是如何工作的。
- en: Note
  id: totrans-36
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'It is worth mentioning that, before version 4.6, Unity used an old system called
    GUI. Recently, Unity developer didn''t completely dismiss the system, but slightly
    changed it and renamed it **IMGUI**, which stands for **Immediate Mode GUI**.
    As we can see in the official documentation, it is not intended to be used in
    game, but rather for programmers to quickly debug. Moreover, it is also used to
    create windows or a custom Inspector when Unity is extended through scripts, a
    topic that is definitely out of the scope of this introductory book. However,
    if you are interested in learning more, I invite you to read the official documentation:
    [https://docs.unity3d.com/Manual/ExtendingTheEditor.html](https://docs.unity3d.com/Manual/ExtendingTheEditor.html)
    Also, follow this video tutorial: [https://unity3d.com/learn/tutorials/topics/interface-essentials/building-custom-inspector?playlist=17090](https://unity3d.com/learn/tutorials/topics/interface-essentials/building-custom-inspector?playlist=17090).'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在版本4.6之前，Unity使用了一个名为GUI的旧系统。最近，Unity开发者并没有完全摒弃这个系统，而是稍作修改并将其更名为**IMGUI**，即**Immediate
    Mode GUI**。正如我们可以在官方文档中看到的那样，它并不打算用于游戏，而是供程序员快速调试使用。此外，它还用于在通过脚本扩展Unity时创建窗口或自定义检查器，这是一个肯定超出了本书介绍范围的话题。然而，如果你对了解更多内容感兴趣，我邀请你阅读官方文档：[https://docs.unity3d.com/Manual/ExtendingTheEditor.html](https://docs.unity3d.com/Manual/ExtendingTheEditor.html)。同时，也可以观看这个视频教程：[https://unity3d.com/learn/tutorials/topics/interface-essentials/building-custom-inspector?playlist=17090](https://unity3d.com/learn/tutorials/topics/interface-essentials/building-custom-inspector?playlist=17090)。
- en: However, you might find this section a little bit encyclopedic. In fact, you
    can use this section as a quick reference to the UI elements you need. Therefore,
    feel free to skip part of it, if you already have a certain knowledge about Unity
    UIs.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，你可能觉得这一部分有点像百科全书。实际上，你可以将这一部分作为所需UI元素的快速参考。因此，如果你已经对Unity UI有一定的了解，可以自由地跳过其中的一部分。
- en: Moreover, this section is structured in such a way that the fundamental things
    are at the beginning, and progressively deals with more complicated topics, up
    to arrive out of the scope of this book. In fact, we you have reached this level,
    where it is really just matter of fine tuning, or achieving a really specific
    effect, this section will give you a general idea of how it works, so to have
    a ground from which to further extend your knowledge, especially with the official
    documentation.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，这一部分的结构是这样的，基本内容在开头，然后逐渐处理更复杂的话题，直到超出本书的范围。实际上，当你达到这个水平，真正的问题只是微调或实现一个非常具体的效果时，这一部分将给你一个如何工作的总体概念，以便从那里进一步扩展你的知识，特别是通过官方文档。
- en: Canvas
  id: totrans-40
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 画布
- en: 'If you are wondering what a Canvas is, let''s begin with some background information.
    From the Merriam -Webster dictionary, a canvas is considered to be the following:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道什么是画布，让我们先从一些背景信息开始。根据Merriam-Webster词典，画布被认为是以下内容：
- en: '*"A firm closely woven cloth usually of linen, hemp, or cotton used for clothing
    and formerly much used for tents and sails."*'
  id: totrans-42
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"一种紧密编织的布料，通常由亚麻、大麻或棉花制成，用于服装，以前常用于帐篷和帆布。"*'
- en: 'But probably the definition that is closer to what Unity means is this, also
    from the Merriam-Webster dictionary:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 但可能最接近Unity所定义的画布定义是这样的，同样来自Merriam-Webster词典：
- en: '*"A piece of cloth backed or framed as a surface for a painting; also: the
    painting on such a surface."*'
  id: totrans-44
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"一块背面或框架作为绘画表面的布料；也指这样的表面上的绘画。"*'
- en: 'In computer graphics, a canvas is something slightly different, and we can
    see its definition on Wikipedia:'
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在计算机图形学中，画布的含义略有不同，我们可以在维基百科上看到其定义：
- en: '*"In computer science and visualization, a canvas is a container that holds
    various drawing elements (lines, shapes, text, frames containing other elements,
    etc.). It takes its name from the canvas used in visual arts. It is sometimes
    called a scene graph because it arranges the logical representation of a user
    interface or graphical scene. Some implementations also define the spatial representation
    and allow the user to interact with the elements via a graphical user interface."*'
  id: totrans-46
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
  zh: '*"在计算机科学和可视化中，画布是一个容器，包含各种绘图元素（线条、形状、文本、包含其他元素的框架等）。它得名于视觉艺术中使用的画布。有时也称为场景图，因为它安排用户界面或图形场景的逻辑表示。某些实现还定义了空间表示，并允许用户通过图形用户界面与元素交互。"*'
- en: In Unity, a Canvas is an important component of the UI system. Since the UI
    is internally rendered by Unity in a different way than the rest of the scene,
    we need to specify which elements within our scene belong to the UI. In particular,
    all the UI elements should be children of a Canvas, which is a Game Object with
    a Canvas component attached on it. We can create a Canvas by right-clicking on
    the **Hierarchy** panel and then navigate to **UI | Canvas**.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在Unity中，画布是UI系统的一个重要组件。由于UI在Unity中内部渲染的方式与场景中的其他部分不同，我们需要指定场景中哪些元素属于UI。特别是，所有UI元素都应该是一个带有画布组件的游戏对象的子元素。我们可以通过在**层次结构**面板上右键单击并导航到**UI
    | 画布**来创建一个画布。
- en: 'As a result, two objects will be created in our scene, as we can see in the
    following screenshot:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在我们的场景中将会创建两个对象，如下面的截图所示：
- en: '![Canvas](img/image00387.jpeg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![画布](img/image00387.jpeg)'
- en: However, at the moment let's just focus on the Canvas, leaving the **EventSystem**
    for later.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，现在让我们只关注画布，将**事件系统**留到以后再讨论。
- en: Note
  id: totrans-51
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Creating a new UI element, such as an image, for instance by right-clicking
    on the **Hierarchy** and then **UI** | **Image**, automatically creates a Canvas
    (and an EventSystem as well), if there isn't already a **Canvas** in the scene.
    The UI element is created as a child of this Canvas.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个新的UI元素，例如一个图像，可以通过在**层次结构**上右键单击然后选择**UI** | **图像**来实现，如果场景中还没有**画布**，则会自动创建一个画布（以及一个事件系统）。这个UI元素被创建为该画布的子元素。
- en: The Canvas is represented in the scene as a white rectangular. This helps us
    to edit the UI without switching back and forth from the Game View.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 场景中的画布以白色矩形的形式呈现。这有助于我们在不切换到游戏视图的情况下编辑UI。
- en: 'If the **Scene** view is not set in 2D, for instance we are working in on a
    3D game, the Canvas appears distorted, as shown here:'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 如果**场景**视图未设置为2D，例如我们在3D游戏中工作，画布将出现扭曲，如下所示：
- en: '![Canvas](img/image00388.jpeg)'
  id: totrans-55
  prefs: []
  type: TYPE_IMG
  zh: '![画布](img/image00388.jpeg)'
- en: 'Since UI will be rendered orthographically, a rule of thumb of working with
    UIs is to switch the Scene View to 2D (as we learnt in [Chapter 1](part0016.xhtml#aid-F8901
    "Chapter 1. A Flat World in Unity"), *A Flat World in Unity*), to have something
    like the following:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UI将以正交方式渲染，处理UI的一个经验法则是将场景视图切换到2D（如我们在[第1章](part0016.xhtml#aid-F8901 "第1章。Unity中的平面世界")中学习的），如下所示：
- en: '![Canvas](img/image00389.jpeg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![画布](img/image00389.jpeg)'
- en: 'If we select the Canvas, we should be able to see the following in the **Inspector**:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们选择画布，我们应该能在**检查器**中看到以下内容：
- en: '![Canvas](img/image00390.jpeg)'
  id: totrans-59
  prefs: []
  type: TYPE_IMG
  zh: '![画布](img/image00390.jpeg)'
- en: The main setting is the **Render Mode**, which allows us to specify how we intend
    to use our UI. Let's take a closer look at these options.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 主要设置是**渲染模式**，它允许我们指定我们打算如何使用我们的UI。让我们更仔细地看看这些选项。
- en: Screen space – Overlay
  id: totrans-61
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕空间 - 覆盖
- en: This render mode is the most used. In fact, it places UI elements on the screen
    by rendering them on top of the scene, as in many games. This means that UI elements
    are rendered perfectly orthographically.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 这种渲染模式是最常用的。实际上，它通过在场景上渲染UI元素来将UI元素放置在屏幕上，就像许多游戏一样。这意味着UI元素被完美地正交渲染。
- en: Furthermore, if the screen changes resolution or is resized, the Canvas will
    change size to automatically fit the new ratio.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果屏幕分辨率改变或被调整大小，画布也会改变大小以自动适应新的比例。
- en: Screen space – Camera
  id: totrans-64
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 屏幕空间 - 相机
- en: This render mode, instead, is linked to a specific Camera where the UI will
    be render on top of it. This means that the Canvas is placed at a given distance
    in front of the selected Camera. As a result, the UI elements will be affected
    by all the camera parameters and effects. This includes the perspective distortion,
    if the **Camera** is set to **Perspective**, which is regulated by the **Camera
    Field of View** parameter.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，这种渲染模式与一个特定的相机相关联，UI将渲染在这个相机之上。这意味着画布被放置在所选相机前方的一个给定距离处。因此，UI元素将受到所有相机参数和效果的影响。这包括如果**相机**设置为**透视**时的透视失真，这是由**相机视野**参数控制的。
- en: Like previously, the Canvas may change size based on the resolution of the screen
    as well as the camera frustum.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前一样，画布的大小可能会根据屏幕分辨率和相机视锥体进行调整。
- en: 'If you are wondering what the camera frustum is, keep reading this info box.
    When you select a camera, you will see a trunked pyramid (if the camera is in
    perspective mode, otherwise it has a Parallelepiped as shape), like the one in
    the following screenshot:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道相机视锥体是什么，请继续阅读这个信息框。当你选择一个相机时，你会看到一个截顶的棱锥体（如果相机处于透视模式，否则它具有平行六面体的形状），就像下面截图中的那样：
- en: '![Screen space – Camera](img/image00391.jpeg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![屏幕空间 – 相机](img/image00391.jpeg)'
- en: 'This is the camera frustum, and everything that is inside it will be rendered
    by the camera. The plane that is closer to the camera is called **near clipping
    plane**, whereas the far one is called the **far clipping plane**. Understanding
    why a perspective camera has this shape is not hard, but it''s out of the scope
    of this book. However, in the documentation, you can find two interesting pages
    that talk about this. They are easy to understand, and as for your convenience,
    here are the links: [https://docs.unity3d.com/Manual/UnderstandingFrustum.html](https://docs.unity3d.com/Manual/UnderstandingFrustum.html)
    and [https://docs.unity3d.com/Manual/FrustumSizeAtDistance.html](https://docs.unity3d.com/Manual/FrustumSizeAtDistance.html).'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是相机视锥体，其中所有内容都将由相机渲染。离相机较近的平面称为**近裁剪面**，而较远的称为**远裁剪面**。理解透视相机为什么有这种形状并不难，但这超出了本书的范围。然而，在文档中，你可以找到两个有趣的页面，讨论了这一点。它们很容易理解，为了你的方便，这里提供了链接：[https://docs.unity3d.com/Manual/UnderstandingFrustum.html](https://docs.unity3d.com/Manual/UnderstandingFrustum.html)
    和 [https://docs.unity3d.com/Manual/FrustumSizeAtDistance.html](https://docs.unity3d.com/Manual/FrustumSizeAtDistance.html)。
- en: World space
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 世界空间
- en: This render mode will make the Canvas behave like any other game object in the
    scene. This means that the Canvas has a precise position in the world (from here
    the name, since it is placed in the world space). As a result, the UI can be occluded
    by other objects in the scene. Its dimensions are set manually using the Rect
    Transform component (see some paragraphs ahead). This mode is useful for UIs that
    are meant to be a part of the world. As we have discussed previously, this is
    also known as a **diegetic interface**.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 这种渲染模式将使画布表现得像场景中的任何其他游戏对象。这意味着画布在世界上有一个精确的位置（因此得名，因为它放置在世界空间中）。因此，UI可能会被场景中的其他对象遮挡。其尺寸是通过Rect
    Transform组件手动设置的（见下文的一些段落）。这种模式对于打算成为世界一部分的UI很有用。正如我们之前讨论的，这也被称为**叙事界面**。
- en: Draw order of UI elements
  id: totrans-72
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: UI元素的绘制顺序
- en: As we will see in the next paragraphs, UI elements will be images or text that
    is rendered on the screen. However, what happens when two of these components
    overlap? There is an order, so that the UI elements in the Canvas are drawn in
    the same order they appear in the hierarchy. This means that the first child is
    drawn first, the second child next, and so on. Therefore, when two UI elements
    overlap, the later one, in the Hierarchy, will appear on top of the earlier one.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们将在下一段落中看到的，UI元素将是屏幕上渲染的图像或文本。然而，当两个这些组件重叠时会发生什么？有一个顺序，所以画布中的UI元素将以它们在层次结构中出现的顺序绘制。这意味着第一个子元素首先绘制，然后是第二个子元素，依此类推。因此，当两个UI元素重叠时，在层次结构中较晚的那个将出现在较早的那个之上。
- en: To change which element appear on top of other elements, it's just matter of
    reordering the elements in the **Hierarchy** by dragging them.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 要改变哪个元素显示在其他元素之上，只需通过拖动它们在**层次结构**中重新排序元素即可。
- en: To better understand this, look at the following screenshot, which represents
    two different situations with two images. For your convenience, the respective
    **Hierarchy** panel has been superimposed next to the images.
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 为了更好地理解这一点，请看下面的截图，它代表了两种不同情况下的两个图像。为了你的方便，相应的**层次结构**面板被叠加在图像旁边。
- en: '![Draw order of UI elements](img/image00392.jpeg)'
  id: totrans-76
  prefs: []
  type: TYPE_IMG
  zh: '![UI元素的绘制顺序](img/image00392.jpeg)'
- en: The Lemon Cupcake is rendered on top of the chocolate one because the Lemon
    Cupcake is the last child of the Canvas
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 柠檬纸杯蛋糕被渲染在巧克力纸杯蛋糕之上，因为柠檬纸杯蛋糕是画布的最后一个子元素
- en: 'The order can also be controlled from scripting by using these methods on the
    Transform component:'
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 顺序也可以通过在变换组件上使用这些方法从脚本中控制：
- en: '**SetAsFirstSibling()**: Place the game object as the first child of its parent.
    As a result, it will be rendered for first (with respect to its siblings), and
    therefore sent to the back (all other UI elements will be on top of it).'
  id: totrans-79
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SetAsFirstSibling()**: 将游戏对象放置为其父对象的第一个子元素。因此，它将首先渲染（相对于其兄弟），因此将被发送到后面（所有其他UI元素都将位于其上方）。'
- en: '**SetAsLastSibling()**: Place the game object as the last child of its parent.
    As a result, it will be rendered last (with respect to its siblings), and therefore
    brought to the front (all other UI elements will be behind it).'
  id: totrans-80
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SetAsLastSibling()**：将游戏对象放置为其父对象的最后一个子对象。因此，它将在渲染时最后（相对于其兄弟），因此被带到前面（所有其他UI元素都将位于其后）。'
- en: '**SetSiblingIndex()**: Place the game object to a specific index, allowing
    to decide at which point of the rendering hierarchy this game object will be.'
  id: totrans-81
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**SetSiblingIndex()**：将游戏对象放置到特定索引，允许决定该游戏对象将在渲染层次结构中的哪个位置。'
- en: Visual components
  id: totrans-82
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 视觉组件
- en: The Unity UI comes with different premade components to build our UI. The most
    commonly used are the visual components, which allow rendering custom content
    on the screen.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: Unity UI自带不同的预置组件来构建我们的UI。最常用的组件是视觉组件，它允许在屏幕上渲染自定义内容。
- en: The Image component
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 图像组件
- en: 'The Image component, as the name suggests, allows us to render an image on
    the screen. In fact, we need to specify a **Source Image**, which is the image
    we want to render. An example of this can be seen in the following screenshot:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图像组件，正如其名所示，允许我们在屏幕上渲染图像。实际上，我们需要指定一个**源图像**，这是我们想要渲染的图像。以下截图是一个例子：
- en: '![The Image component](img/image00393.jpeg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图像组件](img/image00393.jpeg)'
- en: Note
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As for Sprites, the image assets we intend to use for the UI in our project
    must be set to Sprite (2D and UI), as [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. A
    Flat World in Unity"), *A Flat World in Unity* explained.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 至于精灵，我们打算在项目中用于UI的图像资源必须设置为精灵（2D和UI），正如[第1章](part0016.xhtml#aid-F8901 "第1章。Unity中的平面世界")
    *Unity中的平面世界* 所解释的。
- en: Then, we can adjust the color, which is a multiplier of the Sprite, as well
    as assign a material, if we need to.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们可以调整颜色，这是精灵的乘数，以及如果我们需要的话，分配一个材质。
- en: 'Once a **Source Image** has been set, we can define how the Sprite will appear
    by selecting the **Image Type**. The options are as follows:'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦设置了**源图像**，我们可以通过选择**图像类型**来定义精灵的外观。选项如下：
- en: '**Simple**: just scales the image or Sprite equally.'
  id: totrans-91
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**简单**：只是均匀地缩放图像或精灵。'
- en: '**Sliced**: if the Sprite has been 9-sliced (as [Chapter 1](part0016.xhtml#aid-F8901
    "Chapter 1. A Flat World in Unity"), *A Flat World in Unity* explained), the nine
    different parts of the image will be scaled differently.'
  id: totrans-92
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**切片**：如果精灵已经被9切片（正如[第1章](part0016.xhtml#aid-F8901 "第1章。Unity中的平面世界") *Unity中的平面世界*
    所解释），图像的九个不同部分将被不同地缩放。'
- en: '**Tiled**: this is similar to the previous one, but the central part of the
    9-slicing is tiled instead of stretched.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**平铺**：这与上一个类似，但9宫格的中心部分是平铺而不是拉伸。'
- en: '**Filled**: this is similar to Simple, but allows us to show part of the image
    as it would be filled. This is controlled by parameters such as the Origin of
    the Filling, as well as the method and the amount. We will use this feature later
    in the chapter, and we will find out that is really useful for creating bars in
    video games:'
  id: totrans-94
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**填充**：这与简单类似，但允许我们显示图像的一部分，就像它被填充一样。这由填充的起点、方法和数量等参数控制。我们将在本章后面使用这个功能，并会发现它对于创建视频游戏中的条形图非常有用：'
- en: '![The Image component](img/image00394.jpeg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图像组件](img/image00394.jpeg)'
- en: Note
  id: totrans-96
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Some advanced bars, such as the health bar in Kingdom Hearts style, can be
    found in the book pointed out previously: *Unity UI Cookbook*, *Packt publishing*
    towards the end of *Chapter 2*, *Implementing Counters and Health Bars*.'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 一些高级条形图，如《王国之心》风格的血量条，可以在之前提到的书中找到：*Unity UI CookBook*，*Packt publishing* 在第2章末尾的
    *Implementing Counters and Health Bars*。
- en: Furthermore, when the image is **Simple** or **Filled**, the button **Set Native
    Size** is visible. It just restores the original size of the image. This is really
    useful when you assign a new **Source Image**, and you can restore the original
    ratio by using this button as well, before scaling to the right size for your
    UI.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当图像是**简单**或**填充**时，**设置原生大小**按钮可见。它只是恢复图像的原始大小。当你分配一个新的**源图像**时，这非常有用，你可以使用此按钮恢复原始比例，然后再将其缩放到适合UI的正确大小。
- en: The Text component
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 文本组件
- en: 'The Text component, as the name suggests, allows us to render any text on the
    screen. Sometimes, in some books, it is referred to as label, since usually it
    is used to give a label to other UI components. An example of this can be seen
    in the following screenshot:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 文本组件，正如其名所示，允许我们在屏幕上渲染任何文本。有时，在某些书中，它被称为标签，因为它通常用于给其他UI组件添加标签。以下截图是一个例子：
- en: '![The Text component](img/image00395.jpeg)'
  id: totrans-101
  prefs: []
  type: TYPE_IMG
  zh: '![文本组件](img/image00395.jpeg)'
- en: It contains a text area, which can be extended using the Rect Tool (see the
    next paragraph). Within the component, you can find all the basic **Text** transformations,
    such as setting the font, the font style, and the font size. Furthermore, it is
    possible to enable or disable the rich text capability, which is enabled by default.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 它包含一个文本区域，可以使用矩形工具（见下一段）进行扩展。在组件中，你可以找到所有基本的**文本**转换，例如设置字体、字体样式和字体大小。此外，你可以启用或禁用富文本功能，默认情况下是启用的。
- en: Note
  id: totrans-103
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you a wondering what rich text capability is, keep reading this info box.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想知道什么是富文本功能，请继续阅读这个信息框。
- en: Rich text capability allows us to place some HTML tags within the text to change
    only specific part of the text. In non-technical terms, you can change the color
    of a single word or change its font style to italic. For instance, you can have
    something like *This book is really amazing* in the **Text** area, but in the
    text component, it is written as `This book <b>is really</b> amazing`.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 富文本功能允许我们在文本中放置一些HTML标签，以仅更改文本的特定部分。用非技术术语来说，你可以改变单个单词的颜色或将其字体样式改为斜体。例如，你可以在**文本**区域中看到像*这本书真的很棒*这样的内容，但在文本组件中，它被写成`This
    book <b>is really</b> amazing`。
- en: Since they are HTML tags, they must be placed at the beginning, specifying the
    settings, and at the end of the part of text where you want to apply the change.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 由于它们是HTML标签，它们必须放置在开始处，指定设置，并在你想要应用更改的文本部分的末尾。
- en: 'These are the main tags supported from unity:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是Unity支持的主要标签：
- en: '`<b>The text between these tags will be in bold</b>`'
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: '`<b>这些标签之间的文本将显示为粗体</b>`'
- en: '`<i>The text between these tags will be in italic</i>`'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: '`<i>这些标签之间的文本将显示为斜体</i>`'
- en: '`<size=50>The text between these tags will have a size of 50, and you can change
    the number to any number</size>`'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: '`<size=50>这些标签之间的文本大小将为50，你可以将数字更改为任何数字</size>`'
- en: '`<color= #rrggbbaa>This text between these tags will be colored with the hex
    color specified at the beginning</color>`'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: '`<color= #rrggbbaa>这些标签之间的文本将使用开头指定的十六进制颜色进行着色</color>`'
- en: 'If you don''t know what a hex color is, it is just a hex number (therefore,
    it contains also some letters) that represents a color; you can learn more about
    them on the Wikipedia page here: [https://en.wikipedia.org/wiki/Web_colors](https://en.wikipedia.org/wiki/Web_colors).'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道什么是十六进制颜色，它只是一个十六进制数值（因此，它还包含一些字母），代表一种颜色；你可以在维基百科页面这里了解更多：[https://en.wikipedia.org/wiki/Web_colors](https://en.wikipedia.org/wiki/Web_colors)。
- en: 'However, keep in mind that you don''t need to know all the detailed theory
    behind the Wikipedia page to use these colors. In fact, there are plenty of online
    color pickers that give you the hex number of a specific color. Then, you just
    need to copy and paste the code into your text in Unity. Furthermore, you don''t
    need necessarily to use the hex code for the color, but there are some presets
    in Unity. In fact, you can just use This `<color=red>word</color>` is red to make
    the word red, without specifying the whole hex code. The list of all these color
    shortcuts can be found by following the link at the end of this info box. Alternative,
    you could also select hex colors from online tools, such as: [http://www.w3schools.com/colors/colors_picker.asp](http://www.w3schools.com/colors/colors_picker.asp)
    or [http://htmlcolorcodes.com](http://htmlcolorcodes.com).'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请记住，你不需要了解所有这些颜色背后的详细理论就可以使用这些颜色。实际上，有很多在线颜色选择器可以为你提供特定颜色的十六进制数值。然后，你只需将代码复制并粘贴到Unity中的文本中即可。此外，你不必一定使用十六进制代码来指定颜色，Unity中还有一些预设。实际上，你只需使用`<color=red>word</color>`这样的代码来使单词变红，而不必指定整个十六进制代码。所有这些颜色快捷方式的列表可以通过点击此信息框末尾的链接找到。另外，你也可以从在线工具中选择十六进制颜色，例如：[http://www.w3schools.com/colors/colors_picker.asp](http://www.w3schools.com/colors/colors_picker.asp)
    或 [http://htmlcolorcodes.com](http://htmlcolorcodes.com)。
- en: There are a couple of special tags, material and quad, which have a really specific
    use. If you want to learn more, follow the link at the end of this info box.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 有一些特殊的标签，如材质和四边形，它们有非常特定的用途。如果你想了解更多，请点击此信息框末尾的链接。
- en: Another cool feature of these tags is that you can nest them! This means you
    can use more than one at the same time. For instance, you can have part of the
    text that is blue, bold, and italic. However, they must be closed in reverse order,
    otherwise they won't work.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 这些标签的另一个酷炫功能是你可以嵌套它们！这意味着你可以同时使用多个标签。例如，你可以有部分文本是蓝色、粗体和斜体的。然而，它们必须以相反的顺序关闭，否则它们将不起作用。
- en: 'If you want to learn more, follow this link: [https://docs.unity3d.com/Manual/StyledText.html](https://docs.unity3d.com/Manual/StyledText.html).'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想了解更多信息，请点击此链接：[https://docs.unity3d.com/Manual/StyledText.html](https://docs.unity3d.com/Manual/StyledText.html)。
- en: In addition, you can find options to change the alignment of the text as well
    as for vertical and horizontal overflow, which means to control what happens when
    the text is larger than the text area. The **Best Fit** option rescales the text
    to fit the available space of the text area.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，您还可以找到更改文本对齐方式以及垂直和水平溢出的选项，这意味着控制当文本大于文本区域时会发生什么。**最佳拟合**选项将文本缩放以适应文本区域的可用空间。
- en: Basic transformations
  id: totrans-118
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 基本变换
- en: We have seen some basic UI elements, but how can we place and manipulate them? We
    will learn various different forms of implementing transformations in the next
    sections.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了一些基本的UI元素，但我们如何放置和操作它们？在下一节中，我们将学习各种不同的实现变换的形式。
- en: The Rect Tool
  id: totrans-120
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形工具
- en: Since UI elements are similar to Sprites (both are 2D), the best way to quickly
    manipulate them is by using the Rect Tool.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 由于UI元素类似于精灵（两者都是2D），快速操作它们最好的方式是使用矩形工具。
- en: 'A fast recap, you can find the Rect Tool in the top-left corner of the Unity
    Editor, and it is the last one on the right, as shown here:'
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 快速回顾，您可以在Unity编辑器的左上角找到矩形工具，它是右侧的最后一个，如下所示：
- en: '![The Rect Tool](img/image00396.jpeg)'
  id: totrans-123
  prefs: []
  type: TYPE_IMG
  zh: '![矩形工具](img/image00396.jpeg)'
- en: 'A border around our Sprite or UI elements should appear. As a result, we can
    transform it in the following ways:'
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的精灵或UI元素周围应该出现一个边框。因此，我们可以以下列方式对其进行转换：
- en: 'If we click and drag within the rectangle, we can move the object, as in the
    following picture (for learning purposes, a tasty cupcake has been used in an
    Image component):'
  id: totrans-125
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们在矩形内点击并拖动，我们可以移动对象，如下面的图片所示（为了学习目的，在图像组件中使用了一个美味的纸杯蛋糕）：
- en: '![The Rect Tool](img/image00397.jpeg)'
  id: totrans-126
  prefs: []
  type: TYPE_IMG
  zh: '![矩形工具](img/image00397.jpeg)'
- en: 'If we click on the blue dot in the middle, which is the pivot point, we can
    change its position (in this book we will not change any pivot points, since we
    won''t need this):'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们点击中间的蓝色点，即旋转点，我们可以改变其位置（在这本书中，我们不会改变任何旋转点，因为我们不需要这样做）：
- en: '![The Rect Tool](img/image00398.jpeg)'
  id: totrans-128
  prefs: []
  type: TYPE_IMG
  zh: '![矩形工具](img/image00398.jpeg)'
- en: 'If we click and drag an edge we can scale along that direction, as we can see
    here:'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们点击并拖动一个边缘，我们可以沿该方向缩放，就像我们在这里看到的那样：
- en: '![The Rect Tool](img/image00399.jpeg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![矩形工具](img/image00399.jpeg)'
- en: 'If we click and drag a corner, instead, we can scale freely along both directions.
    Furthermore, if you press **Shift** while dragging, the scale will be uniform,
    which means it will increase in size by the same quantity on both axes by keeping
    the ratio of the object constant:'
  id: totrans-131
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如果我们点击并拖动一个角，则可以沿两个方向自由缩放。此外，如果您在拖动时按住**Shift**键，则缩放将是均匀的，这意味着它将在两个轴上以相同的数量增加大小，同时保持对象的比率不变：
- en: '![The Rect Tool](img/image00400.jpeg)'
  id: totrans-132
  prefs: []
  type: TYPE_IMG
  zh: '![矩形工具](img/image00400.jpeg)'
- en: 'Finally, if we place the cursor next to a corner that is, outside of the rectangle,
    a little rotation icon appears. By clicking and dragging it is possible to rotate
    the object around its pivot point:'
  id: totrans-133
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 最后，如果我们把光标放在矩形外的角上，即矩形外面，会出现一个小旋转图标。通过点击并拖动它，可以绕旋转点旋转对象：
- en: '![The Rect Tool](img/image00401.jpeg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![矩形工具](img/image00401.jpeg)'
- en: And this is all for the Rect Tool.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是关于矩形工具的所有内容。
- en: The Rect Transform
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 矩形变换
- en: 'There is a major difference in how Unity handles Sprites and UI elements. In
    fact, Sprites have the usual Transform component, to indicate position, rotation,
    and Scale. UI elements, instead, have a Rect Transform (the 2D layout counterpart),
    which is much more complex and store more information. In fact, the Transform
    represents a single point in the space, whereas the Rect Transform represent a
    rectangle in which a UI element can be placed. An example of this can be seen
    in the following screenshot:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: Unity处理精灵和UI元素的方式有很大的不同。实际上，精灵有通常的变换组件，用来表示位置、旋转和缩放。相反，UI元素有一个矩形变换（2D布局的对应物），它更复杂并存储更多信息。实际上，变换表示空间中的一个点，而矩形变换表示一个UI元素可以放置的矩形。以下截图显示了这一点：
- en: '![The Rect Transform](img/image00402.jpeg)'
  id: totrans-138
  prefs: []
  type: TYPE_IMG
  zh: '![矩形变换](img/image00402.jpeg)'
- en: Tip
  id: totrans-139
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Unity performs all the calculations of the positions of the different Rect Transform
    at the end of the frame to ensure having up-to-date values with respect to the
    rest of the frame. As a result, these values of the Rect Transform might not be
    correct when you use the `Start()` function. To overcome this problem, you can
    force the update of the canvas by calling the `Canvas.ForceUpdateCanvases()` function.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 在每一帧结束时执行所有不同矩形变换位置的计算，以确保相对于帧的其余部分具有最新的值。因此，当您使用 `Start()` 函数时，矩形变换的这些值可能不正确。为了解决这个问题，您可以通过调用
    `Canvas.ForceUpdateCanvases()` 函数强制更新画布。
- en: Furthermore, if the parent of a Rect Transform is also a Rect Transform, the
    child Rect Transform can also specify how it should be positioned and sized relative
    to the parent rectangle. This hierarchical structure is what makes Rect Transform
    so powerful, especially when you need to design for multiple resolutions.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果矩形变换的父元素也是一个矩形变换，子矩形变换也可以指定它相对于父矩形的定位和大小。这种层次结构使得矩形变换非常强大，尤其是在您需要为多个分辨率设计时。
- en: Other than scaling, a Rect Transform can be resized. They are similar operations,
    but the difference lies that resizing leaves invariant the local scale, and change
    the height and the width. As a result, font sizes, borders on sliced images, and
    so on, won't be affected from resizing, whereas they are in the case of scaling.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 除了缩放，矩形变换还可以调整大小。这些操作类似，但区别在于调整大小保持局部缩放不变，并改变高度和宽度。因此，字体大小、切片图像的边框等不会受到调整大小的影响，而在缩放的情况下则会受到影响。
- en: Similar to 2D Sprites, the Rect transform applies scaling, rotation, and resizing
    by the pivot point of the UI element. However, it is possible to change it directly
    inside the Scene View, by dragging it (the little blue circle) within the UI element.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 与 2D 精灵类似，矩形变换通过 UI 元素的锚点应用缩放、旋转和调整大小。然而，您可以直接在场景视图中通过拖动它（小蓝色圆圈）在 UI 元素内直接更改它。
- en: One of the most import concepts about this component is the Anchors, which allow
    us to specify the relation of the UI element with respect to the Canvas and its
    parent. They are displayed as four small triangular handles in the Scene View.
    The information related to these anchors is shown in the Rect Transform component
    in the Inspector.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 关于这个组件最重要的概念之一是锚点，它允许我们指定 UI 元素相对于画布及其父元素的关系。它们在场景视图中显示为四个小三角形手柄。与这些锚点相关的信息在检查器中的矩形变换组件中显示。
- en: 'Unfortunately, there is no a simple way to explain Anchors without seeing the
    effects in motion, such as in a video or in an animated gif. Since this is a book,
    it cannot contain such animated media, which would clarify the concept immediately
    to you. Therefore, instead of losing time in a complicated explanation of anchors,
    which may not be fully understandable, I invite you to visit the official documentation
    here, in the anchors section: [https://docs.unity3d.com/Manual/UIBasicLayout.html](https://docs.unity3d.com/Manual/UIBasicLayout.html).
    Don''t worry, I''ll still be here when you come back from the webpage.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，没有简单的方法可以解释锚点，除非看到它们在动态中的效果，比如在视频或动画 gif 中。由于这是一本书，它无法包含这样的动画媒体，这会立即向您阐明这个概念。因此，为了避免在复杂的锚点解释上浪费时间，这些解释可能并不完全理解，我邀请您访问官方文档，在这里的锚点部分：[https://docs.unity3d.com/Manual/UIBasicLayout.html](https://docs.unity3d.com/Manual/UIBasicLayout.html)。不用担心，您从网页回来时我还在这里。
- en: 'If you have read the webpages, other than seeing the animated gif, you also
    have seen the Anchor presets, which are shown in the following screenshot:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您已经阅读了网页，除了看到动画 gif，您还看到了锚点预设，如下面的截图所示：
- en: '![The Rect Transform](img/image00403.jpeg)'
  id: totrans-147
  prefs: []
  type: TYPE_IMG
  zh: '![矩形变换](img/image00403.jpeg)'
- en: These are useful shortcuts to quickly correctly anchor UI elements. Of course,
    I invite you to manually change this configuration in your game, when needed.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 这些是快速正确锚定 UI 元素的快捷方式。当然，我邀请您在需要时手动更改游戏中此配置。
- en: Layout components
  id: totrans-149
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 布局组件
- en: In the previous section we saw how it is possible to place UI elements in the
    screen. However, sometimes, it's really useful to automatically place them in
    the screen within a certain criteria, especially when the number of UI elements
    is not known a priori, and changes at runtime. This can be manually scripted,
    but Unity comes with a series of layout components that helps with basic layout
    placement.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在上一节中，我们看到了如何将UI元素放置在屏幕上。然而，有时，在满足一定标准的情况下自动将它们放置在屏幕上非常有用，尤其是在不知道UI元素的数量，并且运行时发生变化的情况下。这可以通过手动脚本实现，但Unity提供了一系列布局组件，有助于基本的布局定位。
- en: 'The auto-layout system is composed of two different kinds of elements: layout
    elements and layout controllers. To understand the former, note that every game
    object that has a Rect Transform, and eventually other components, is a layout
    element. These types have certain knowledge about what size they should be of,
    but they do not control it directly. Layout controllers, instead, are components
    that control sizes and also positions of one or more layout elements. They can
    control their own layout element or child Layout Elements of the game object to
    which they are attached.'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 自动布局系统由两种不同类型的元素组成：布局元素和布局控制器。为了理解前者，请注意，每个具有Rect Transform的游戏对象，以及最终的其他组件，都是一个布局元素。这些类型对它们应该有多大有一定的了解，但它们并不直接控制它。相反，布局控制器是控制一个或多个布局元素的大小和位置的组件。它们可以控制自己的布局元素或它们附加的游戏对象的子布局元素。
- en: Tip
  id: totrans-152
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: Layout controllers change the Rect transforms in such a way that it's hard to
    restore the previous status. Therefore, before to even add a layout controllers
    and/or modify one, be sure to be in Play mode in order to make changes without
    causing any unwanted layout change to your UI. Once you are happy with the changes,
    stop Play mode, and insert the values that you have found that fit your needs.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 布局控制器以难以恢复先前状态的方式更改Rect Transform。因此，在添加布局控制器和/或修改之前，请确保处于播放模式，以便在不造成任何不希望的布局更改的情况下进行更改。一旦您对更改满意，停止播放模式，并插入您找到的适合您需求的值。
- en: The layout controllers are divided into Fitters and layout groups.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 布局控制器分为适配器和布局组。
- en: Fitters
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Fitters
- en: The Fitters only control the size of its own layout element. When resizing UI
    elements, keep in mind that it happens around the pivot point, as we discussed
    in the previous section. Therefore, you can use it also to align UI elements.
    For instance, if the pivot is in the center, the element will scale equally in
    all the directions, whereas if it is placed in a corner, such as the top-left,
    the element will scale down and to the right. All other positions will give different
    weighs along the four directions where the element will scale.
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: Fitters只控制其自身布局元素的大小。在调整UI元素大小时，请记住，这是围绕我们之前讨论的枢轴点发生的。因此，您也可以使用它来对齐UI元素。例如，如果枢轴点位于中心，则元素将在所有方向上均匀缩放，而如果它放置在角落，例如左上角，则元素将向右下方缩放。所有其他位置都会在元素缩放的四条方向上给出不同的权重。
- en: 'With this said, let''s take a look at the Fitters controllers:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 说到这里，让我们来看看Fitters控制器：
- en: '**Content Size Fitter**: controls the size of its own layout element. The size
    is determined by the minimum or preferred sizes provided by layout element components
    on the Game Object. Such layout elements can be Image or Text components, layout
    groups, or a Layout Element component:'
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**内容大小适配器**：控制其自身布局元素的大小。大小由游戏对象上的布局元素组件提供的最小大小或首选大小确定。这样的布局元素可以是图像或文本组件、布局组或布局元素组件：'
- en: '![Fitters](img/image00404.jpeg)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![Fitters](img/image00404.jpeg)'
- en: '**Aspect Ratio Fitter**: can adjust the height to fit the width or vice versa,
    or it can make the element fit inside its parent or envelope its parent. The Aspect
    Ratio Fitter does not take layout information into account, such as minimum size
    and preferred size:'
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**宽高比适配器**：可以调整高度以适应宽度或反之亦然，或者它可以使元素适应其父元素或包围其父元素。宽高比适配器不考虑布局信息，例如最小大小和首选大小：'
- en: '![Fitters](img/image00405.jpeg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![Fitters](img/image00405.jpeg)'
- en: Layout groups
  id: totrans-162
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布局组
- en: 'The layout groups, instead, control the layout elements of their children,
    and not their own. They are used to orderly place the UI elements. They have different
    options to control the spacing between the children and define the preferred heights
    and/or widths. Other options include the possibility to force the expansion of
    the children so to fit the space available or to decide what happens when they
    are bigger than the space available. They are as follows:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，布局组控制其子元素的布局元素，而不是它们自己的。它们用于有序地放置 UI 元素。它们有不同的选项来控制子元素之间的间距，并定义首选的高度和/或宽度。其他选项包括强制子元素扩展以适应可用空间的可能性，或者决定当它们大于可用空间时会发生什么。它们如下所示：
- en: '**Vertical Layout Group**: allows us to stack the children along a vertical
    axis, and place them on top of each other:'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**垂直布局组**：允许我们将子元素沿着垂直轴堆叠，并将它们堆叠在一起：'
- en: '![Layout groups](img/image00406.jpeg)'
  id: totrans-165
  prefs: []
  type: TYPE_IMG
  zh: '![布局组](img/image00406.jpeg)'
- en: '**Horizontal Layout Group**: allows us to stack the children along a horizontal
    axis, and place them next to each other:'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**水平布局组**：允许我们将子元素沿着水平轴堆叠，并将它们并排放置：'
- en: '![Layout groups](img/image00407.jpeg)'
  id: totrans-167
  prefs: []
  type: TYPE_IMG
  zh: '![布局组](img/image00407.jpeg)'
- en: '**Grid Layout Group**: this allows us to stack the children in a grid, both
    vertically and horizontally:'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**网格布局组**：这允许我们将子元素在网格中堆叠，垂直和水平都可以：'
- en: '![Layout groups](img/image00408.jpeg)'
  id: totrans-169
  prefs: []
  type: TYPE_IMG
  zh: '![布局组](img/image00408.jpeg)'
- en: The layout element component
  id: totrans-170
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 布局元素组件
- en: There is one more component, which is the **Layout Element** component. As the
    name suggests, it is not a controller, but rather allows us to change the layout
    element settings from the Rect Transform. In fact, when placed on a layout element,
    it allows us to override the settings, such as min, preferred, and flexible both
    for height and width. Furthermore, it has a flag to ignore the controllers. So,
    imagine having a label inside a grid layout component, you don't want the label
    to be stacked in the grid along all the other elements, but rather on the top,
    defining what the grid is about. In this case, ignoring the controller is useful
    to place the label outside the grid, and yet be a children of the grid, so to
    move it as a unique block, without replacing the label every time.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 还有一个组件，即 **布局元素** 组件。正如其名所示，它不是一个控制器，而是允许我们从 Rect Transform 中更改布局元素设置。实际上，当放置在布局元素上时，它允许我们覆盖设置，例如最小值、首选值和弹性，对于高度和宽度都是如此。此外，它有一个标志来忽略控制器。所以，想象一下在网格布局组件内部有一个标签，你不想让标签与其他所有元素一起堆叠在网格中，而是放在顶部，定义网格的内容。在这种情况下，忽略控制器对于将标签放置在网格外部，同时仍然是网格的子元素非常有用，这样就可以作为一个独特的块移动它，而无需每次都替换标签。
- en: 'Here is a picture of what this component looks like:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 这就是该组件的外观：
- en: '![The layout element component](img/image00409.jpeg)'
  id: totrans-173
  prefs: []
  type: TYPE_IMG
  zh: '![布局元素组件](img/image00409.jpeg)'
- en: Interaction components
  id: totrans-174
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 交互组件
- en: Unity UI comes with more powerful premade components than the one seen in the
    visual components section. In fact, there are many components with which the user
    can interact. These interaction can be mouse or touch/tap events as well as keyboard
    or controller events.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: Unity UI 比视觉组件部分提供了更强大的预制组件。实际上，有许多用户可以与之交互的组件。这些交互可以是鼠标或触摸/点击事件，也可以是键盘或控制器事件。
- en: However, this components are not visible on their own, and must be combined
    with one or more visual components in order to work correctly.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，这些组件本身是不可见的，并且必须与一个或多个视觉组件结合使用才能正确工作。
- en: The selectable base class
  id: totrans-177
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 可选择基类
- en: Before seeing how the single interaction components work, we need to understand
    some basic settings shared among all of them. In particular, these settings derive
    from the Selectable base class, which has transition and navigation options.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
  zh: 在了解单个交互组件的工作方式之前，我们需要了解一些所有这些组件共有的基本设置。特别是，这些设置来自 Selectable 基类，它具有过渡和导航选项。
- en: Interactable option
  id: totrans-179
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 交互选项
- en: This is just a flag that determines if an interaction component is enable for
    interaction or not. When checked, the interaction component will be in the **Disable**
    state (see the next section).
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: 这只是一个标志，用于确定交互组件是否启用交互。当勾选时，交互组件将处于 **禁用** 状态（见下一节）。
- en: Transition options
  id: totrans-181
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 过渡选项
- en: Usually, interaction components needs to send some feedback to the player, so
    he or she can understand if the action has been performed.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，交互组件需要向玩家发送一些反馈，以便他们可以理解动作是否已执行。
- en: 'In this implementation of Unity, there are four states in which an interaction
    component could be. They are as follows:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个Unity实现中，交互组件可能有四种状态。它们如下：
- en: '**Normal**: the interaction component is untouched'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Normal**: 交互组件未被触摸'
- en: '**Highlighted**: when the pointer is on the interaction component, but a click
    (or a touch/tap in the case of touch-screens) hasn''t been performed yet'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Highlighted**: 当指针在交互组件上，但尚未执行点击（或触摸屏上的触摸/轻触）时'
- en: '**Pressed**: when the click (or touch/tap) is happening on the interaction
    component'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Pressed**: 当点击（或触摸/轻触）发生在交互组件上时'
- en: '**Disable**: when the interaction component is not interactable'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Disable**: 当交互组件不可交互时'
- en: 'They transitions and the specifications of these states can happen in four
    different ways:'
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 这些过渡和这些状态的规定可以通过四种不同的方式发生：
- en: '**None**: The interaction component doesn''t change state. This is really useful
    when we want to implement the kind of interaction with the component in a custom
    way:'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**None**: 交互组件不会改变状态。当我们需要以自定义方式实现与组件的交互时，这非常有用：'
- en: '![Transition options](img/image00410.jpeg)'
  id: totrans-190
  prefs: []
  type: TYPE_IMG
  zh: '![过渡选项](img/image00410.jpeg)'
- en: '**Color Tint**: this option is selected by default and defines a color tint
    for each of the preceding states. Furthermore, it contains a **Fade Duration**
    to regulate how fast the component should change from one color to another, and
    a **Color Multiplier**. As a result, the interaction component will smoothly change
    color for each of the four states:'
  id: totrans-191
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Color Tint**: 此选项默认选中，并为前面的每个状态定义了一种颜色色调。此外，它包含一个**淡入淡出持续时间**来调节组件从一种颜色变为另一种颜色的速度，以及一个**颜色乘数**。因此，交互组件将为每个状态平滑地改变颜色：'
- en: '![Transition options](img/image00411.jpeg)'
  id: totrans-192
  prefs: []
  type: TYPE_IMG
  zh: '![过渡选项](img/image00411.jpeg)'
- en: '**Sprite Swap**: Usually, the interaction components have also an Image component
    attached to them, which defines the basic graphics. In this transition mode, instead
    of changing color, there is a different Sprite for each one of the four states.
    This is useful when you have custom graphics for each one of the states:'
  id: totrans-193
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Sprite Swap**: 通常，交互组件还附有一个图像组件，它定义了基本图形。在此过渡模式中，不是改变颜色，而是每个状态都有一个不同的Sprite。当您为每个状态都有自定义图形时，这非常有用：'
- en: '![Transition options](img/image00412.jpeg)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![过渡选项](img/image00412.jpeg)'
- en: '**Animation**: This is the most versatile transition mode, since it allows
    you to have a custom animation for each one of the states (we will talk more about
    animations in the upcoming chapters):'
  id: totrans-195
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Animation**: 这是最高效的过渡模式，因为它允许您为每个状态自定义动画（我们将在接下来的章节中更多地讨论动画）：'
- en: '![Transition options](img/image00413.jpeg)'
  id: totrans-196
  prefs: []
  type: TYPE_IMG
  zh: '![过渡选项](img/image00413.jpeg)'
- en: Navigation options
  id: totrans-197
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 导航选项
- en: 'The navigation options determine how the player can navigate through the UI
    elements during play mode. These are the different options available:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 导航选项决定了玩家在游戏模式期间如何导航UI元素。以下是可用的不同选项：
- en: '**None**: No keyboard navigation. This is useful when you want to implement
    your own navigation system within the game. Furthermore, the interaction component
    that is set in this mode will not receive focus from clicking (or tapping) on
    it.'
  id: totrans-199
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**None**: 无键盘导航。这在您想在游戏中实现自己的导航系统时非常有用。此外，在此模式下设置的交互组件不会因点击（或轻触）而获得焦点。'
- en: '**Horizontal**: navigates horizontally.'
  id: totrans-200
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Horizontal**: 水平导航。'
- en: '**Vertical**: navigates vertically.'
  id: totrans-201
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Vertical**: 垂直导航。'
- en: '**Automatic**: Unity will try to guess which is the right navigation based
    on the positions of the UI elements.'
  id: totrans-202
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Automatic**: Unity将尝试根据UI元素的位置猜测正确的导航。'
- en: '**Explicit**: In this mode, you can specify the next UI element to select for
    each arrow key. This allows fine navigation control:'
  id: totrans-203
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Explicit**: 在此模式下，您可以指定每个箭头键要选择的下一个UI元素。这允许精细的导航控制：'
- en: '![Navigation options](img/image00414.jpeg)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![导航选项](img/image00414.jpeg)'
- en: 'Furthermore, the **Visualize** button allows to visualize the navigation scheme
    within the **Scene View**. An example of this visualization is presented in the
    following screenshot:'
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**可视化**按钮允许在**场景视图**中可视化导航方案。以下截图展示了这种可视化的一个例子：
- en: '![Navigation options](img/image00415.jpeg)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![导航选项](img/image00415.jpeg)'
- en: Button
  id: totrans-207
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 按钮图
- en: 'This is the classical interaction component that can be found in any game.
    It contains only one event, `OnClick()`, which is triggered when the button is
    clicked/tapped. Of course, you can link any action to the event. An example of
    this can be seen in the following screenshot:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 这是任何游戏中都可以找到的经典交互组件。它只包含一个事件，`OnClick()`，当按钮被点击/轻触时触发。当然，您可以将任何动作链接到事件。以下截图是一个示例：
- en: '![Button](img/image00416.jpeg)'
  id: totrans-209
  prefs: []
  type: TYPE_IMG
  zh: '![按钮](img/image00416.jpeg)'
- en: Note
  id: totrans-210
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Keep in mind that if the pointer is moved away from the button before the click/tap
    is released, the action doesn't take place. You can find an exercise on this in
    the *Homework* section.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，如果指针在点击/轻触释放之前移离按钮，则动作不会执行。您可以在*作业*部分找到一个关于这个的练习。
- en: Toggle and Toggle Group
  id: totrans-212
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 切换和切换组
- en: 'The Toggle component allows the player to turn off and on an option. An example
    of this can be seen in the following screenshot:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 切换组件允许玩家关闭或打开一个选项。以下截图是一个示例：
- en: '![Toggle and Toggle Group](img/image00417.jpeg)'
  id: totrans-214
  prefs: []
  type: TYPE_IMG
  zh: '![切换和切换组](img/image00417.jpeg)'
- en: 'As the button, the toggle has a single event `OnValueChanged()`, which is called
    every time that the toggle changes its state; the value of the new state is passed
    as a Boolean parameter within the event data (see next paragraph). This component
    works well with another component, called Toggle Group, which controls whether
    there is only one option among a group of toggles to be turned on, as shown in
    the following screenshot:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 如按钮一样，切换有一个单一的事件`OnValueChanged()`，每次切换改变其状态时都会调用；新状态值作为事件数据中的布尔参数传递（见下一段）。此组件与另一个称为切换组的组件配合良好，该组件控制是否只有一个选项在切换组中被打开，如下面的截图所示：
- en: '![Toggle and Toggle Group](img/image00418.jpeg)'
  id: totrans-216
  prefs: []
  type: TYPE_IMG
  zh: '![切换和切换组](img/image00418.jpeg)'
- en: You can set up a toggle group by just add it to the **Group** property of all
    the toggles you wish in to be in the group. This is, for instance, really useful
    for mutually exclusive choices, such as character or class selection. Other common
    use is tuning the game settings, such as game speed, difficulty, or color scheme.
    Of course, you can use more than one toggle group per time within your scenes;
    however, a toggle can only belong to one group.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过将其添加到所有希望加入组的切换的**组**属性中，来设置一个切换组。例如，这对于互斥选择非常有用，如角色或职业选择。其他常见用途是调整游戏设置，如游戏速度、难度或配色方案。当然，您可以在场景中同时使用多个切换组；然而，一个切换只能属于一个组。
- en: Slider
  id: totrans-218
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滑块
- en: 'As the name suggests, a slider is a bar with a handle along it, which can slide
    from the beginning, which is considered the **Min Value**, to the end, which is
    considered the **Max Value**. All the values in between are in proportion to the
    position of the handle along the bar. By default, the handle increases its value
    from left to right, but by tweaking the **Direction** property, it''s possible
    to change in other directions, so not only from right to left but also along the
    vertical axis. An example of this can be seen in the following screenshot:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名所示，滑块是一个带有手柄的条，手柄可以从条的开始处滑动，即被认为是**最小值**，到条尾，即被认为是**最大值**。条中间的所有值都与手柄在条上的位置成比例。默认情况下，手柄从左到右增加其值，但通过调整**方向**属性，可以改变其他方向，不仅可以从右到左，还可以沿垂直轴。以下截图是一个示例：
- en: '![Slider](img/image00419.jpeg)'
  id: totrans-220
  prefs: []
  type: TYPE_IMG
  zh: '![滑块](img/image00419.jpeg)'
- en: The slider has a single event, `OnValueChanged()`, which is triggered when the
    handle is dragged, and the new value of the slider is passed as a float to the
    triggered action.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 滑块有一个单一的事件，`OnValueChanged()`，当滑块的手柄被拖动时触发，并将滑块的新值作为浮点数传递给触发动作。
- en: Scrollbar
  id: totrans-222
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 滚动条
- en: 'This component is very similar to a slider, since it has a handle along a bar,
    and the minimum value is always 0.0 and the maximum is 1.0\. All the values in
    between represents the different percentage of where the handle will be. Again,
    the scrollbar can be orientated by tweaking the **Direction** property. An example
    of this can be seen in the following screenshot:'
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件与滑块非常相似，因为它在一条条上有一个手柄，最小值始终是0.0，最大值是1.0。所有介于两者之间的值代表手柄将所在的不同百分比。同样，滚动条可以通过调整**方向**属性来定位。以下截图是一个示例：
- en: '![Scrollbar](img/image00420.jpeg)'
  id: totrans-224
  prefs: []
  type: TYPE_IMG
  zh: '![滚动条](img/image00420.jpeg)'
- en: The difference between this and the slider is the possibility to stretch the
    handle of the scrollbar depending on some content, such as text areas. When the
    text increases, the handle becomes smaller to slide among more content, which
    represents the amount of scrolling available. On the other hand, when the content
    is not large, the handle increases its dimensions to completely fill the bar and
    not allow scrolling.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 与滑块的区别在于，根据某些内容（如文本区域）可以拉伸滚动条的把手。当文本增加时，把手会变小，以便在更多内容之间滑动，这代表了可滚动的量。另一方面，当内容不大时，把手会增加其尺寸以完全填充条形，不允许滚动。
- en: The scrollbar has a single event, called `OnValueChanged()`, and it works exactly
    the same way as the homonymous event on the slider.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 滚动条有一个单独的事件，称为`OnValueChanged()`，它的工作方式与滑块上的同名列事件完全相同。
- en: Dropdown
  id: totrans-227
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 下拉菜单
- en: 'The **Dropdown** is a relatively new component in the Unity UI, since it has
    been released/implemented since Unity 5.2\. This component allows the player to
    select among a list of options. The component shows the current selected option
    only, and when the player clicks/taps on it, the full list appears. Once another
    item from the list is selected, the list closes and the new item is picked. Furthermore,
    the player can close the list without changing the item if he or she clicks somewhere
    else outside the component. An example of this can be seen in the following screenshot:'
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: '**下拉菜单**是Unity UI中相对较新的组件，因为它自Unity 5.2以来就已经发布/实现了。这个组件允许玩家从一系列选项中选择。组件只显示当前选中的选项，当玩家点击/轻触它时，完整的列表出现。一旦从列表中选择了另一个项目，列表就会关闭，新项目被选中。此外，如果玩家在其他组件外部点击，他或她可以关闭列表而不更改项目。以下截图是一个例子：'
- en: '![Dropdown](img/image00421.jpeg)'
  id: totrans-229
  prefs: []
  type: TYPE_IMG
  zh: '![下拉菜单](img/image00421.jpeg)'
- en: 'Using the dropdown in the inspector is quite intuitive, even if you need to
    get used to the template in the hierarchy if you want to change its appearance.
    Unfortunately, we don''t have time to go into detail about how this component
    works, but I''m sure you can easily understand it by visiting the official documentation
    here: [https://docs.unity3d.com/Manual/script-Dropdown.html](https://docs.unity3d.com/Manual/script-Dropdown.html).'
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 使用检查器中的下拉菜单非常直观，即使你需要熟悉层次结构中的模板才能改变其外观。不幸的是，我们没有时间详细说明这个组件的工作原理，但我相信通过访问官方文档你可以轻松理解它：[https://docs.unity3d.com/Manual/script-Dropdown.html](https://docs.unity3d.com/Manual/script-Dropdown.html)。
- en: In any case, we won't use this component for our game, but in the *Homework*
    section you can challenge yourself to understand this component better.
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 无论如何，我们不会在我们的游戏中使用这个组件，但在*作业*部分，你可以挑战自己更好地理解这个组件。
- en: Input Field
  id: totrans-232
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 输入字段
- en: 'The **Input Field** component allows the player to type text in the game, specifically
    within a text area. Of course, you need to use it in conjunction with a Text component,
    and/or other visual elements. An example of this can be seen in the following
    screenshot:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入字段**组件允许玩家在游戏中输入文本，具体来说是在文本区域内。当然，你需要与文本组件或其他视觉元素一起使用它。以下截图是一个例子：'
- en: '![Input Field](img/image00422.jpeg)'
  id: totrans-234
  prefs: []
  type: TYPE_IMG
  zh: '![输入字段](img/image00422.jpeg)'
- en: Note
  id: totrans-235
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: The **Input Field** can be added also to an already existing **Text** component
    to make it editable. In order to do so, select the **Text** component in the **Hierarchy**
    panel and navigate to **Add Component** | **UI** | **Input Field** in the **Inspector**.
    Then, drag the **Text** component (also the game object itself will work) inside
    the **Text** component variable of the **Input Field**. Furthermore, you may want
    to add a placeholder as well. As such, I suggest that you create an **Input Field**
    and study how it works with its original structure, and then add existing text
    areas.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入字段**也可以添加到已经存在的**文本**组件中，使其可编辑。为此，在**层次结构**面板中选择**文本**组件，然后在**检查器**中导航到**添加组件**
    | **UI** | **输入字段**。然后，将**文本**组件（游戏对象本身也可以）拖放到**输入字段**的**文本**组件变量中。此外，你可能还想添加一个占位符。因此，我建议你创建一个**输入字段**并研究它与其原始结构一起如何工作，然后添加现有的文本区域。'
- en: When the player is typing, the **Text** property of the **Text** component will
    change, and it can be retrieved from the script.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 当玩家在输入时，**文本**组件的**文本**属性将改变，并且可以从脚本中检索。
- en: 'Moreover, the **Input Field** has different options to define the kind of characters
    that are allowed, whether they should be masked (for instance, if it is a password
    or a pin), whether there is a limit to the number, or whether multi-line editing
    is allowed. You can learn more about these additional features in the official
    documentation: [https://docs.unity3d.com/Manual/script-InputField.html](https://docs.unity3d.com/Manual/script-InputField.html).'
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，**输入字段**有不同的选项来定义允许的字符类型，是否应该被屏蔽（例如，如果是一个密码或PIN），是否有数量限制，或者是否允许多行编辑。你可以在官方文档中了解更多关于这些附加功能的信息：[https://docs.unity3d.com/Manual/script-InputField.html](https://docs.unity3d.com/Manual/script-InputField.html)。
- en: 'The **Input Field** component has two events: `OnValueChanged()`, which is
    triggered every time the player types something, and `OnEndEdit()`, which is triggered
    only when the player has stopped typing. In both the cases, the whole text in
    the **Text** component is passed to the action function through a string parameter.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: '**输入字段**组件有两个事件：`OnValueChanged()`，每次玩家输入时都会触发，以及`OnEndEdit()`，只有当玩家停止输入时才会触发。在这两种情况下，整个**文本**组件中的文本都会通过字符串参数传递给动作函数。'
- en: Keep in mind that **Rich Text** is turned off by default. You can enable it,
    but it is not well supported for the **Input Field** because the navigation in
    the text includes markup, whereas the visual doesn't. As a result, it is really
    confusing for whoever is going to type there. Usually, you don't need **Rich Text**
    capability for editable texts; therefore, as a rule of thumb, just keep **Rich
    Text** turned off.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，**富文本**默认是关闭的。你可以启用它，但对于**输入字段**来说，它并不很好地支持，因为文本中的导航包括标记，而视觉上没有。因此，对于将要输入的人来说，这真的很令人困惑。通常，你不需要**富文本**功能来编辑文本；因此，作为一个经验法则，只需保持**富文本**关闭。
- en: Scroll Rect
  id: totrans-241
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Scroll Rect
- en: 'This component is used when your content is larger than the area it should
    occupy. Scroll Rect allows us to make a content scrollable inside a rectangle,
    and display all the content in a relatively small area. Usually, this component
    is used with the **Mask** component; in this way all the content outside the rectangle
    will not be visible, and you will have achieved a scroll view. An example of this
    can be seen in the following screenshot:'
  id: totrans-242
  prefs: []
  type: TYPE_NORMAL
  zh: 当你的内容比它应该占据的区域大时，这个组件会被使用。Scroll Rect 允许我们在一个矩形内使内容可滚动，并在相对较小的区域内显示所有内容。通常，这个组件会与**遮罩**组件一起使用；这样，矩形外的所有内容都将不可见，你将实现一个滚动视图。以下截图是一个示例：
- en: '![Scroll Rect](img/image00423.jpeg)'
  id: totrans-243
  prefs: []
  type: TYPE_IMG
  zh: '![Scroll Rect](img/image00423.jpeg)'
- en: 'Furthermore, you can assign scrollbars (both on the horizontal and the vertical
    axes) to easily scroll through the content. You can find more options to tweak
    in the component, and if you really want to understand them, I invite you to consult
    the official documentation: [https://docs.unity3d.com/Manual/script-ScrollRect.html](https://docs.unity3d.com/Manual/script-ScrollRect.html).'
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，你可以分配滚动条（水平和垂直轴上的滚动条）以轻松滚动内容。你可以在组件中找到更多可调整的选项，如果你真的想了解它们，我邀请你查阅官方文档：[https://docs.unity3d.com/Manual/script-ScrollRect.html](https://docs.unity3d.com/Manual/script-ScrollRect.html)。
- en: Finally, the Scroll Rect has only one event, `OnValueChanged()`, which is triggered
    when the position of the Scroll Rect is changed, signifying that the player scrolled.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，Scroll Rect 只有一个事件，`OnValueChanged()`，当 Scroll Rect 的位置改变时触发，这表示玩家已经滚动。
- en: More about UI rendering
  id: totrans-246
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 更多关于 UI 渲染的信息
- en: We have seen a lot about UI, yet it's not everything. This section presents
    some relative advanced topics in the UI of Unity. Feel free to skip this section,
    or read without focus to completely understand what's written, You can always
    come back here later.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经看到了很多关于 UI 的内容，但这并不是全部。本节介绍了 Unity UI 中的一些相对高级主题。你可以自由地跳过这一节，或者在不集中注意力的情况下阅读，以便完全理解所写的内容，你总是可以稍后回来。
- en: The canvas renderer
  id: totrans-248
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 画布渲染器
- en: 'The careful reader has noticed that in all the UI elements there is always
    attached a Canvas Renderer, such as the one in the following screenshot:'
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 仔细的读者已经注意到，在所有 UI 元素中，总是附有一个 Canvas Renderer，如下面的截图所示：
- en: '![The canvas renderer](img/image00424.jpeg)'
  id: totrans-250
  prefs: []
  type: TYPE_IMG
  zh: '![画布渲染器](img/image00424.jpeg)'
- en: What is this component that doesn't allow us to change any options? It allows
    Unity to know that that specific UI element should be rendered in a Canvas. In
    very particular cases, when an UI element is built from scratch, we need to manually
    add this component. However, if you are not planning to build custom UI elements
    from scratch, but just using the ones that Unity provides (which are more than
    enough to build really complex UIs), you can forget about this component. In fact,
    it is automatically created every time we create an UI element.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 这个组件为什么不允许我们更改任何选项呢？它允许Unity知道特定的UI元素应该在Canvas中渲染。在非常特殊的情况下，当UI元素是从头开始构建时，我们需要手动添加这个组件。然而，如果您不打算从头开始构建自定义UI元素，只是使用Unity提供的那些（这些足以构建非常复杂的UI），您可以忽略这个组件。实际上，每次我们创建一个UI元素时，它都会自动创建。
- en: 'Even if the **Canvas Renderer** doesn''t have any options in the inspector,
    it has some properties that can be accessed through script. For such functions
    and variables, you can find details here: [https://docs.unity3d.com/ScriptReference/CanvasRenderer.html](https://docs.unity3d.com/ScriptReference/CanvasRenderer.html).'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 即使**Canvas Renderer**在检查器中没有选项，它也有一些可以通过脚本访问的属性。对于这些函数和变量，您可以在以下位置找到详细信息：[https://docs.unity3d.com/ScriptReference/CanvasRenderer.html](https://docs.unity3d.com/ScriptReference/CanvasRenderer.html)。
- en: More visual components
  id: totrans-253
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更多视觉组件
- en: 'We have analyzed the main visual components; however, there are more visual
    components, which are used rarely in special situations:'
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经分析了主要视觉组件；然而，还有更多视觉组件，它们在特殊情况下很少使用：
- en: '![More visual components](img/image00425.jpeg)'
  id: totrans-255
  prefs: []
  type: TYPE_IMG
  zh: '![更多视觉组件](img/image00425.jpeg)'
- en: The most common is the **Mask** component. It is used to create a scroll view
    in conjunction with the **Scroll Rect**. It forces the children to have the shape
    of the parent. However, it doesn't support alpha channels. This means that part
    of the children will be either visible or not, without having any kind of opacity
    specified in the mask.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 最常见的是**遮罩**组件。它与**Scroll Rect**一起用于创建滚动视图。它强制子元素具有父元素的形状。然而，它不支持alpha通道。这意味着子元素的一部分将是可见的或不可见的，而无需在遮罩中指定任何类型的透明度。
- en: Note
  id: totrans-257
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: If you are interested in knowing why the alpha channel is not supported, we
    need to mention implementation of Mask beneath Unity.
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您想知道为什么不支持alpha通道，我们需要提及Unity下面遮罩的实现。
- en: When you program with a GPU, you are constrained to use certain buffers to render
    things. Modern GPUs have a buffer called Stencil Buffer, used together with the
    **Color Buffer** and the **Depth Buffer**, which can only assume integer values
    and work on a pixel base. Usually, it is used to avoid rendering certain parts
    of the screen, and improve performance overall, and this is the case with Unity.
    Advanced uses of this may include changing it dynamically based on the Depth Buffer.
    However, Unity just uses this buffer to not render the part of the screen not
    covered by the mask, in particular, assigning the value of 1 to the pixel that
    should be rendered.
  id: totrans-259
  prefs: []
  type: TYPE_NORMAL
  zh: 当您使用GPU编程时，您被限制只能使用某些缓冲区来渲染事物。现代GPU有一个名为Stencil Buffer的缓冲区，它与**Color Buffer**和**Depth
    Buffer**一起使用，它只能假设整数值并在像素级别上工作。通常，它用于避免渲染屏幕的某些部分，并提高整体性能，Unity也是如此。这种高级使用可能包括根据深度缓冲区动态更改它。然而，Unity只是使用这个缓冲区来不渲染遮罩未覆盖的屏幕部分，特别是将值1分配给应该渲染的像素。
- en: Furthermore, Unity allows nested masks, in particular, using the AND (`&`) operation
    on them. As a result, a pixel will be rendered if and only if it is within all
    the nested masks. You can easily imagine this by overlapping different paper masks
    to a drawing, which is visible only in the parts that all the paper masks overlap.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，Unity允许嵌套遮罩，特别是使用AND（`&`）操作符对它们进行操作。结果，只有当像素位于所有嵌套遮罩内时，像素才会被渲染。您可以通过将不同的纸张遮罩重叠到绘图上来轻松想象这一点，只有当所有纸张遮罩重叠的部分才是可见的。
- en: 'Recently, Unity has introduced also another kind of Mask, **Rect Mask 2D**:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 最近，Unity还引入了另一种类型的遮罩，**Rect Mask 2D**：
- en: '![More visual components](img/image00426.jpeg)'
  id: totrans-262
  prefs: []
  type: TYPE_IMG
  zh: '![更多视觉组件](img/image00426.jpeg)'
- en: It has some limitations with respect of the previous mask component, such as
    the fact that it only works in a 2D environment and with coplanar elements (non-coplanar
    is still possible, but the component might not work as it should). However, this
    approach brings some advantages, such as not needing to use the Stencil Buffer
    (see the preceding info box) with consequent performance improvements since there
    are no extra draw calls.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 与之前的遮罩组件相比，它有一些限制，例如它仅在2D环境和共面元素（非共面仍然可能，但组件可能无法按预期工作）。然而，这种方法带来了一些优点，例如不需要使用模板缓冲区（参见前面的信息框），从而带来性能提升，因为没有额外的绘制调用。
- en: '![More visual components](img/image00427.jpeg)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![更多视觉组件](img/image00427.jpeg)'
- en: 'Another very special visual component is the **Raw Image**. It has some limitations
    with respect to the **Image** component, but has other features. In fact, the
    **Raw Image** doesn''t have the option to animate an image. However, it works
    directly with bytes, as the name suggests. As a result, it is able to display
    not only Sprites as the image, but also textures. To understand why this is useful,
    imagine that a texture is just an array of bytes, and as such, they can change
    at runtime. This means that you may download a texture from a URL during runtime,
    and show it on within a **Raw Image**. Other uses might be the use of **Render
    Textures** (from Unity 5.x, they are also available in the personal edition, and
    not only in the Pro version), and stream what another camera in the game world
    is seeing. This might be used, for instance, to quickly create a minimap in the
    game. You can find this process described in detail in the last chapter of the
    *Unity UI Cookbook* suggested at the beginning of this chapter. One more thing
    about raw images: they have a **UV Rect** option. This means you can scale and
    zoom the image/texture they have as you like, without changing the texture itself.'
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个非常特殊的视觉组件是**原始图像**。它在某些方面与**图像**组件有限制，但也有一些其他功能。实际上，**原始图像**没有动画图像的选项。然而，它直接与字节工作，正如其名称所暗示的。因此，它不仅能够显示图像作为精灵，还能显示纹理。为了理解这有什么用，想象一下纹理只是一个字节数组，并且它们可以在运行时更改。这意味着你可以在运行时从URL下载纹理，并在**原始图像**中显示它。其他用途可能包括使用**渲染纹理**（从Unity
    5.x开始，它们也适用于个人版，而不仅仅是专业版），并流式传输游戏世界中另一个相机所看到的画面。这可能被用来快速创建游戏中的小地图。你可以在本章开头建议的*Unity
    UI食谱*的最后一章中找到此过程的详细描述。关于原始图像还有一点：它们有一个**UV矩形**选项。这意味着你可以按需缩放和缩放图像/纹理，而不会改变纹理本身。
- en: UI effect components
  id: totrans-266
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI效果组件
- en: In addition to the visual components and the interaction ones, Unity has special
    classes of components called effect components. In some books, and in the documentation
    itself, you might find them as a subclass of the visual components.
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 除了视觉组件和交互组件之外，Unity还有一类特殊的组件，称为效果组件。在一些书籍和文档中，你可能将它们视为视觉组件的子类。
- en: 'These components are as follows:'
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 这些组件如下：
- en: '**Shadow**: This allows us to add a shadow effect to an image or text component.
    It must be attached to the same game object of the text or image component. Its
    options change the distance of the shadow and the color. Furthermore, in the case
    of an image, a Boolean controls if the component in creating the shadow should
    use also the alpha channel of image:'
  id: totrans-269
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**阴影**：这允许我们为图像或文本组件添加阴影效果。它必须附加到文本或图像组件相同的游戏对象上。其选项改变阴影的距离和颜色。此外，在图像的情况下，一个布尔值控制创建阴影的组件是否也应该使用图像的alpha通道：'
- en: '![UI effect components](img/image00428.jpeg)'
  id: totrans-270
  prefs: []
  type: TYPE_IMG
  zh: '![UI效果组件](img/image00428.jpeg)'
- en: '**Outline**: This works similarly to the shadow component, but instead of a
    shadow, it adds an outline. The control options are the same as the shadow component:'
  id: totrans-271
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轮廓**：这与阴影组件的工作方式类似，但不是添加阴影，而是添加轮廓。控制选项与阴影组件相同：'
- en: '![UI effect components](img/image00429.jpeg)'
  id: totrans-272
  prefs: []
  type: TYPE_IMG
  zh: '![UI效果组件](img/image00429.jpeg)'
- en: '**Position as UV1**: When this is on an Image component, Unity passes the canvas
    position through to the first UV channel. This means that if you have a custom
    shader, you can use this to create refraction or an UV offset sampling.'
  id: totrans-273
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作为UV1的位置**：当这个选项在图像组件上时，Unity会将画布位置传递到第一个UV通道。这意味着如果你有一个自定义着色器，你可以使用这个功能来创建折射或UV偏移采样。'
- en: UI and lights
  id: totrans-274
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: UI和灯光
- en: In addition to all that we have discovered about UI, you can use lights on the
    UI. They are used to make them feel more realistic, especially when the UI is
    place within the 3D world, or when it has a kind of perspective. However, keep
    in mind that adding a light might decrease performance.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已经发现的关于 UI 的所有内容之外，您还可以在 UI 上使用灯光。它们用于使 UI 感觉更真实，尤其是在 UI 放置在 3D 世界中，或者当它具有某种透视效果时。然而，请记住，添加灯光可能会降低性能。
- en: If the UI is in a 3D world, you may want it to be affected by the world lights,
    but if it has a perspective, such as in the case of the **Screen Space - Camera**
    of the Canvas, you may want it to just be affected by certain lights. As such,
    you need to create some layers to filter which lights will affect the UI.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 UI 在 3D 世界中，你可能希望它受到世界光线的影响，但如果它有透视效果，比如画布的 **Screen Space - Camera** 的情况，你可能只想让它受到某些光线的影响。因此，你需要创建一些图层来过滤哪些光线会影响
    UI。
- en: However, it is not so simple as placing a light in the scene to make a UI component
    affected by light, since you need a material that responds to light. In this case,
    Unity provides specific shaders for UIs. In any case, this is out of the scope
    of the book, since it deals more with 3D game development, rather than 2D. But
    if you are interested in knowing more, in the *Unity UI cookbook*, in *Chapter
    2*, *Creating Panels for Menus*, you'll find a recipe that deals with lights in
    the UI. That is a good start to play with lights within the UI.
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，将灯光放置在场景中以使 UI 组件受到光照影响并不那么简单，因为您需要一个对光照有响应的材料。在这种情况下，Unity 为 UI 提供了特定的着色器。无论如何，这超出了本书的范围，因为它更多地涉及
    3D 游戏开发，而不是 2D。但如果您想了解更多，在 *Unity UI 烹饪书* 的 *第 2 章*，*为菜单创建面板* 中，您会找到一个处理 UI 中灯光的食谱。这是在
    UI 中玩灯光的好起点。
- en: The canvas components
  id: totrans-278
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 画布组件
- en: 'At the beginning of the chapter, we talked about the Canvas, and its main property
    about the **Render Mode**. However, if we look at the Canvas in the Inspector,
    we can see that it actually has three different components, which usually are
    used all together to make a Canvas. For your convenience, the following screenshot
    shows them in the Inspector:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的开头，我们讨论了画布及其主要属性 **渲染模式**。然而，如果我们查看检查器中的画布，我们可以看到它实际上有三个不同的组件，通常它们一起使用来创建一个画布。为了您的方便，以下截图显示了它们在检查器中的样子：
- en: '![The canvas components](img/image00430.jpeg)'
  id: totrans-280
  prefs: []
  type: TYPE_IMG
  zh: '![画布组件](img/image00430.jpeg)'
- en: 'Let''s take a general look at their functionalities:'
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们简要看看它们的职能：
- en: '**Canvas**: This is main component, which actually create the canvas, so Unity
    knows that everything inside it should be rendered as UI.'
  id: totrans-282
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**画布**：这是主要组件，它实际上创建画布，因此 Unity 知道其中的一切都应该作为 UI 渲染。'
- en: '**Canvas Scaler**: This controls the overall scale and pixel density of UI
    elements within the Canvas. This scaling affects everything on the Canvas, including
    font sizes and image borders. There''s more information in the official documentation
    here: [https://docs.unity3d.com/Manual/script-CanvasScaler.html](https://docs.unity3d.com/Manual/script-CanvasScaler.html).'
  id: totrans-283
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**画布缩放器**：这个组件控制画布内 UI 元素的整体缩放和像素密度。这种缩放会影响画布上的所有内容，包括字体大小和图像边框。更多详细信息请参阅官方文档：[https://docs.unity3d.com/Manual/script-CanvasScaler.html](https://docs.unity3d.com/Manual/script-CanvasScaler.html)。'
- en: '**Graphic Raycaster**: This component belongs to the event system and allows
    us to detect mouse or touch events with respect to graphics. For more information
    about this component, you can look at the official documentation here: [https://docs.unity3d.com/Manual/script-GraphicRaycaster.html](https://docs.unity3d.com/Manual/script-GraphicRaycaster.html).'
  id: totrans-284
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**图形射线投射器**：这个组件属于事件系统，允许我们根据图形检测鼠标或触摸事件。有关此组件的更多信息，您可以查看官方文档：[https://docs.unity3d.com/Manual/script-GraphicRaycaster.html](https://docs.unity3d.com/Manual/script-GraphicRaycaster.html)。'
- en: If you are going to face this topic, I suggest that you study the whole Event
    System framework that Unity provides (see the next section).
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 如果您将要面对这个话题，我建议您研究 Unity 提供的整个事件系统框架（参见下一节）。
- en: Canvas group
  id: totrans-286
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 画布组
- en: 'In addition to the UI components we already have seen, there is another one
    called **Canvas Group**. It allows us to define a group, or if you prefer, a subset
    of the UI elements within a Canvas. This is what it looks like in the Inspector:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 除了我们已经看到的 UI 组件之外，还有一个叫做 **Canvas Group** 的组件。它允许我们在画布内定义一个组，或者如果你更喜欢，是 UI 元素的子集。这就是在检查器中的样子：
- en: '![Canvas group](img/image00431.jpeg)'
  id: totrans-288
  prefs: []
  type: TYPE_IMG
  zh: '![画布组](img/image00431.jpeg)'
- en: Furthermore, it provides some general functions to apply to all the elements
    belonging to the group. These may include alpha, if, for instance, you want to
    smoothly make part of the interface appear or disappear, or if it is interactable
    (or disabled).
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还提供了一些通用的功能，可以应用于属于该组的所有元素。这些可能包括alpha，例如，如果您想平滑地使界面的一部分出现或消失，或者如果它是可交互的（或禁用的）。
- en: Another common use for **Canvas Group** is to not block mouse events in certain
    areas of the UI, which means the player can click on a button that lies under
    an Image belonging to a **Canvas Group** with the **Blocks Raycast**s property
    set to false.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: '**Canvas Group**的另一个常见用途是在UI的某些区域不阻止鼠标事件，这意味着玩家可以点击一个位于**Canvas Group**下的按钮，该**Canvas
    Group**的**Blocks Raycast**属性设置为false。'
- en: Event system
  id: totrans-291
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 事件系统
- en: 'As we pointed out in the *Canvas* section, every time we create a Canvas in
    new scene, an even system is also created. In fact, game objects contain a series
    of components that allow us to exchange messages between different parts of your
    game. In the case of the UI, the messages that are exchanged are the inputs from
    the user and the UI itself. Without this event system, the interaction components
    will not work. This is what the event system looks like in the **Inspector**:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在*Canvas*部分所指出的，每次我们在新场景中创建Canvas时，也会创建一个事件系统。实际上，游戏对象包含一系列组件，允许我们在游戏的各个部分之间交换消息。在UI的情况下，交换的消息是用户的输入和UI本身。没有这个事件系统，交互组件将无法工作。这就是事件系统在**检查器**中的样子：
- en: '![Event system](img/image00432.jpeg)'
  id: totrans-293
  prefs: []
  type: TYPE_IMG
  zh: '![事件系统](img/image00432.jpeg)'
- en: As you can see, it is divided into modules (this might change with respect to
    the platform your game is addressed; there's more about this in [Chapter 6](part0077.xhtml#aid-29DRA1
    "Chapter 6. Through a Sea of Sprinkles – Navigation in Artificial Intelligence"),
    *Through a Sea of Sprinkles – Navigation in Artificial Intelligence*). The basic
    functionalities exposed here allow you, for instance, to define which ones are
    the main interaction buttons/events (in the case of a standalone game).
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，它被分为模块（这可能会根据您的游戏针对的平台而有所不同；有关更多信息，请参阅[第6章](part0077.xhtml#aid-29DRA1 "第6章。在糖果雨中穿梭——人工智能导航")，“在糖果雨中穿梭——人工智能导航”）。这里公开的基本功能允许您定义哪些是主要的交互按钮/事件（在独立游戏的情况下）。
- en: 'However, for our purposes, we don''t need to extensively know how the Even
    System works, how to change its settings, or how to set up a custom message. For
    that, I suggest you read the official documentation here: [https://docs.unity3d.com/Manual/EventSystem.html](https://docs.unity3d.com/Manual/EventSystem.html).'
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，就我们的目的而言，我们不需要深入了解事件系统的工作原理，如何更改其设置，或者如何设置自定义消息。为此，我建议您在此处阅读官方文档：[https://docs.unity3d.com/Manual/EventSystem.html](https://docs.unity3d.com/Manual/EventSystem.html)。
- en: As far as we're concerned, we just leave the default settings, and every time
    we use the event system in our scripts, we will just use its basic functionalities,
    and will be explained when we encounter them.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 就我们而言，我们只保留默认设置，每次我们在脚本中使用事件系统时，我们只会使用其基本功能，这些功能将在我们遇到它们时进行解释。
- en: With this said, we have covered a lot about UI, especially if you have been
    reading this whole section in one go. If so, I suggest you to take a little break
    before moving on to the next sections, which will guide us through practically
    using the UI interface in our game.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: 如此一来，我们已经了解了关于UI的很多内容，尤其是如果您是一口气阅读这一整节的话。如果是这样，我建议您在继续下一节之前稍作休息，下一节将指导我们如何在游戏中实际使用UI界面。
- en: Scripting user interfaces
  id: totrans-298
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 脚本化用户界面
- en: 'Before moving into our game, let''s mention general UI programming in Unity.
    Each of the elements we have met in the previous section has a class that exposes
    some variables and some functions that we can use within our scripts. However,
    all of these classes are in a different namespace. As such, every time we want
    to use these classes, we need to add the following line of code at the beginning
    of our script:'
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 在进入我们的游戏之前，让我们谈谈Unity中的通用UI编程。我们在上一节中遇到的每个元素都有一个类，该类公开了一些变量和一些我们可以在脚本中使用的功能。然而，所有这些类都在不同的命名空间中。因此，每次我们想要使用这些类时，我们都需要在脚本的开头添加以下代码行：
- en: '[PRE0]'
  id: totrans-300
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: Note
  id: totrans-301
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: Actually, we can still use the classes without the `using` statement by explicitly
    call the namespace every time. However, this approach is fine only if we need
    to use the namespace few times. Since we are programming with UI, it is good practice
    to import the namespace by adding the line of code shown previously.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，我们可以通过每次显式调用命名空间来使用类而不使用`using`语句。然而，这种方法只有在我们需要很少次使用命名空间时才适用。由于我们正在用UI编程，因此添加之前显示的代码行来导入命名空间是一种良好的实践。
- en: Designing the interface for our game
  id: totrans-303
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计我们游戏的界面
- en: The next step is to begin designing the layout for our game. You can do this
    on paper or on the computer; it depends on how you feel most comfortable.
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是开始设计我们游戏的布局。您可以在纸上或电脑上完成这项工作；这取决于您最舒适的方式。
- en: In tower defense games, the UI often provides the way to interact with the game.
    Through the UI it is possible to build towers, sell them, or upgrade them. Furthermore,
    the UI is also used to visualize stats such as money and lives.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 在塔防游戏中，UI通常提供了与游戏交互的方式。通过UI，可以建造塔、出售它们或升级它们。此外，UI还用于可视化统计数据，如金钱和生命值。
- en: 'Here is a preliminary sketch for designing the UI for our cupcakes tower defense
    game:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是为我们的纸杯塔防御游戏设计UI的初步草图：
- en: '![Designing the interface for our game](img/image00433.jpeg)'
  id: totrans-307
  prefs: []
  type: TYPE_IMG
  zh: '![设计我们游戏的界面](img/image00433.jpeg)'
- en: As you can see, a number of key components have been mapped out. These are primarily
    around the player's interaction, as well as the way that their opponents, the
    pandas, will move and be targeted on the map. For example, areas where players
    can place towers are roughly indicated, and the direction that the player can
    head in is also displayed. The UI elements, such as health, points, and tower
    upgrades, are also included.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，已经绘制出了一些关键组件。这些主要围绕玩家的交互，以及他们的对手——熊猫在地图上的移动和被攻击的方式。例如，玩家可以放置塔的地方大致标示出来，玩家可以前进的方向也显示了出来。UI元素，如健康、分数和塔升级，也包括在内。
- en: Of course, at this stage, it is all about experimenting with what feels better
    from an interactive point of view and what looks better. By *feels better*, it
    is not directly referring to the aesthetics but also the layout of the UI. Too
    many UI elements in one place can make the screen feel overwhelming, especially
    if they aren't explained properly. Now, this is not to say that you cannot have
    a lot of UI elements. In some instances, games (such as *MMORPG*s) can have a
    large amount of UI elements, but they need to be placed in a way that is meaningful
    and logical. There is no sense in having a purchase tower button on one side,
    then an upgrade button on the other side. The simplest way to consider UI is based
    on routine. If first you buy a tower and then upgrade it, then you need to follow
    that process in the UI.
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，在这个阶段，一切都是关于从交互角度和外观上尝试什么感觉更好。通过“感觉更好”，并不是直接指美学，而是UI的布局。一个地方有太多UI元素可能会让屏幕显得拥挤，尤其是如果它们没有被正确解释的话。现在，这并不是说您不能有很多UI元素。在某些情况下，游戏（如*MMORPG*）可以有大量的UI元素，但它们需要以有意义和逻辑的方式放置。在一边放购买塔按钮，在另一边放升级按钮是没有意义的。考虑UI最简单的方式是基于常规。如果您首先购买一个塔，然后升级它，那么您需要在UI中遵循这个过程。
- en: 'As you can see, we have placed all of the key components at the top of the
    screen. That way, the focus is on the map. The health is indicated with large
    hearts, the score is indicated with large text, and the cupcake towers are in
    the center of the screen. However, what is missing is some labels about what is
    what, such as the score and buy options for the towers. In the following screenshot,
    you can see the final version, where these, as well as few UI adjustments, have
    been made:'
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们已经将所有关键组件放置在屏幕顶部。这样，焦点就在地图上。健康状态用大心脏表示，分数用大字体表示，纸杯塔位于屏幕中央。然而，缺少的是一些关于什么是什么的标签，比如分数和购买塔的选项。在下面的截图中，您可以看到最终版本，其中对这些以及一些UI调整已经完成：
- en: '![Designing the interface for our game](img/image00434.jpeg)'
  id: totrans-311
  prefs: []
  type: TYPE_IMG
  zh: '![设计我们游戏的界面](img/image00434.jpeg)'
- en: As you can see, the lives became a health bar, since it does make more sense
    for a strategy game (whereas for a platform, maybe lives could have suited better).
    Since we are targeting an occidental audience, we started to place the important
    elements on the left. (I apologize to readers who read from right to left, but
    for learning purposes I had to pick one choice. On the other hand, if you are
    reading this book, that means your understanding of English and languages that
    read from left to right is high enough to justify this interface we are developing).
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，生命值变成了健康条，这在策略游戏中确实更有意义（而对于平台游戏，可能生命值更适合）。由于我们针对的是西方受众，我们开始将重要元素放在左侧。（对于从右到左阅读的读者，我表示歉意，但出于学习目的，我不得不做出选择。另一方面，如果你正在阅读这本书，这意味着你对英语和从左到右阅读的语言的理解已经足够高，可以证明我们正在开发的这个界面是合理的）。
- en: Furthermore, the amount of sugar is the currency with which the player can upgrade
    and buy new towers. It is another important resource, and therefore has been placed
    below the health bar.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，糖的量是玩家可以用来升级和购买新塔楼的货币。它也是另一个重要的资源，因此被放置在健康条下方。
- en: Next, you can find a section of the UI where the player is able to buy a tower
    from the three available. The following box, instead, is specific to a single
    tower, and it appears when the player selects a tower. It allows the player to
    sell and upgrade the cupcake tower.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你可以找到一个UI部分，玩家可以从三个可用的塔楼中选择一个购买。而下面的框则是针对单个塔楼的，当玩家选择一个塔楼时会出现。它允许玩家出售和升级纸杯蛋糕塔。
- en: Finally, on the right, there is the level name, which is information that the
    player will want to take into consideration, but not as often as health and sugar.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在右侧是关卡名称，这是玩家会想要考虑的信息，但不如健康和糖那么频繁。
- en: With this said, we have a UI design for our game, so let's start to implement
    it in the next sections.
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 话虽如此，我们为游戏设计了UI，接下来让我们在下一节开始实现它。
- en: Preparing the scene for the UI
  id: totrans-317
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 准备UI场景
- en: Now that we have a good understanding of the UI system, it's time to implement
    something within our game to practice a little bit. But the most important outcome
    from the rest of the chapter is to understand how to program UI within the framework
    of Unity.
  id: totrans-318
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经对UI系统有了很好的理解，是时候在我们的游戏中实现一些内容来练习一下了。但本章最重要的成果是理解如何在Unity框架内编程UI。
- en: First of all, we need to create a Canvas in our scene, and as a consequence,
    an event system will also be created. You can do it by right-clicking on the **Hierarchy**
    panel and then navigating to **UI** | **Canvas**. Select the **Canvas** object
    from the **Inspector** and tweak the options in the Inspector based on your needs.
    This really depends on your target platform (more on this in the last chapter
    of this book), and the best way to understand which of these options suit your
    needs is to test and test and test again.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们需要在我们的场景中创建一个Canvas，因此，一个事件系统也会被创建。你可以通过在**层次**面板上右键点击，然后导航到**UI** | **Canvas**来实现。从**检查器**中选择**Canvas**对象，并根据你的需求调整检查器中的选项。这完全取决于你的目标平台（关于这一点，本书的最后一章有更多介绍），了解哪些选项适合你的需求最好的方式是测试，测试，再测试。
- en: The next step is to have a nice background for our interface. We got a really
    nice blue bar in our package that you can find in the `Graphics/UI` folder. In
    order to place it within our interface, let's create a new image.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 下一步是为我们的界面添加一个漂亮的背景。在我们的包中有一个非常漂亮的蓝色条，你可以在`Graphics/UI`文件夹中找到它。为了将其放置在我们的界面中，让我们创建一个新的图像。
- en: 'Right-click on the **Hierarchy** panel and navigate to **UI** | **Image**.
    We can rename the object `UI_Background`. Drag and drop `ui_blue_top_with_text`
    from the project panel into the Sprite variable of the Image component. Since
    our package is already in proportion with respect to the resolution we decided
    in [Chapter 1](part0016.xhtml#aid-F8901 "Chapter 1. A Flat World in Unity"), *A
    Flat World in Unity*, we can just press the **Set Native Size** button to restore
    the original ratio. Then, scale the bar and place it as shown in the following
    screenshot:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: 在**层次**面板上右键点击，然后导航到**UI** | **Image**。我们可以将对象重命名为`UI_Background`。从项目面板中将`ui_blue_top_with_text`拖放到图像组件的Sprite变量中。由于我们的包已经与我们在[第1章](part0016.xhtml#aid-F8901
    "第1章. Unity中的平面世界")中决定的分辨率成比例，*Unity中的平面世界*，我们可以直接按下**设置原生大小**按钮来恢复原始比例。然后，调整条形的大小，并按照以下截图所示放置：
- en: '![Preparing the scene for the UI](img/image00435.jpeg)'
  id: totrans-322
  prefs: []
  type: TYPE_IMG
  zh: '![准备UI场景](img/image00435.jpeg)'
- en: 'In the game view, it will look like this:'
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏视图中，它看起来会是这样：
- en: '![Preparing the scene for the UI](img/image00436.jpeg)'
  id: totrans-324
  prefs: []
  type: TYPE_IMG
  zh: '![为UI准备场景](img/image00436.jpeg)'
- en: Note
  id: totrans-325
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: As for your convenience, the package contains an instance of the UI, which has
    already placed labels on it. This will allow us to save some time. However, if
    you want to create your UI, remember to place labels and format them with the
    right font.
  id: totrans-326
  prefs: []
  type: TYPE_NORMAL
  zh: 为了您的方便，这个包包含了一个已经放置了标签的UI实例。这将使我们节省一些时间。然而，如果您想创建自己的UI，请记住放置标签并使用正确的字体格式化它们。
- en: As a result, we have got a place to start developing our UI as we designed it
    in the previous section.
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们得到了一个地方来开始开发我们在上一节中设计的UI。
- en: Creating a health bar
  id: totrans-328
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建生命条
- en: In our game world, the terrible sweet-tooth pandas make a lot of trouble for
    our player, especially when they reach the longed-awaited cake. As such, with
    every bite they take, the player will lose some life. However, the player needs
    a way, and so does the game, to keep track of his or her life. In our design,
    we chose a health bar, which we are going to implement in this section.
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的游戏世界中，可怕的甜食爱好者熊猫给我们的玩家带来了很多麻烦，尤其是在他们到达渴望已久的蛋糕时。因此，每当它们咬一口，玩家就会失去一些生命。然而，玩家需要一种方式，游戏也需要，来跟踪他的或她的生命。在我们的设计中，我们选择了一个生命条，我们将在本节中实现它。
- en: Creating and placing the health bar
  id: totrans-330
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和放置生命条
- en: Within the `UI_Background` we created before, let's create another image by
    selecting **UI** | **Image** (you can right-click directly on `UI_Background`
    to parent already the new image to it). Then, rename it `Health_Bar`.
  id: totrans-331
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们之前创建的`UI_Background`中，让我们通过选择**UI** | **Image**（您可以直接右键单击`UI_Background`以将新图像作为其子项）来创建另一个图像。然后，将其重命名为`Health_Bar`。
- en: 'Assign `ui_health_bar_frame` as a Sprite in the `Graphics/UI` folder. Again,
    scale it properly (and if you wish use also the **Set Native Size** button, like
    we did for the bar) and place it as in the following screenshot:'
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 将`ui_health_bar_frame`作为`Graphics/UI`文件夹中的Sprite。再次，适当地缩放（如果您愿意，也可以使用**设置原生大小**按钮，就像我们对条形图所做的那样）并将其放置如下截图所示：
- en: '![Creating and placing the health bar](img/image00437.jpeg)'
  id: totrans-333
  prefs: []
  type: TYPE_IMG
  zh: '![创建和放置生命条](img/image00437.jpeg)'
- en: 'Now, we need to create the health bar filling. Create a new image and name
    it `Health_Bar_Filling`. Assign `ui_health_bar_filling` to the image Sprite, and
    place in the scene as follows:'
  id: totrans-334
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要创建生命条填充。创建一个新的图像并将其命名为`Health_Bar_Filling`。将`ui_health_bar_filling`分配给图像Sprite，并按照以下方式将其放置在场景中：
- en: '![Creating and placing the health bar](img/image00438.jpeg)'
  id: totrans-335
  prefs: []
  type: TYPE_IMG
  zh: '![创建和放置生命条](img/image00438.jpeg)'
- en: 'At the end, you should have the following in the **Hierarchy** panel:'
  id: totrans-336
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，您应该在**层次结构**面板中看到以下内容：
- en: '![Creating and placing the health bar](img/image00439.jpeg)'
  id: totrans-337
  prefs: []
  type: TYPE_IMG
  zh: '![创建和放置生命条](img/image00439.jpeg)'
- en: 'Now, in the **Inspector**, we need to set the **Image Type** of `Health_Bar_Filling`
    to **Filled**. Then, set **Fill** Method to **Horizontal** and **Fill Origin**
    to **Left**, as shown here:'
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，在**检查器**中，我们需要将`Health_Bar_Filling`的**图像类型**设置为**填充**。然后，将**填充方法**设置为**水平**和**填充原点**设置为**左**，如图所示：
- en: '![Creating and placing the health bar](img/image00440.jpeg)'
  id: totrans-339
  prefs: []
  type: TYPE_IMG
  zh: '![创建和放置生命条](img/image00440.jpeg)'
- en: As a result, if we change the amount variable (you can play with in in the Inspector
    with the slider), the bar will be more or less filled, as a health bar should
    be.
  id: totrans-340
  prefs: []
  type: TYPE_NORMAL
  zh: 结果，如果我们改变数量变量（您可以在检查器中使用滑块进行操作），条将根据生命条应有的方式或多或少地填充。
- en: Now we are ready to actual make the health bar work by using a specific script.
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经准备好通过使用特定的脚本来使生命条实际工作。
- en: Scripting the health bar
  id: totrans-342
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 编写生命条脚本
- en: Finally, after many pages about UI, we start to see some code in this chapter.
    Again, as we said in the last chapter, don't be afraid of code, but try hard to
    understand why it works in that specific way, and you will be rewarded with the
    ability to program a game, which in my opinion is not bad.
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在许多关于UI的页面之后，我们开始在本章中看到一些代码。再次，正如我们在上一章所说，不要害怕代码，但努力理解为什么它以这种方式工作，这样您将获得编程游戏的能力，在我看来这并不坏。
- en: Okay, let's start to create a new Script within the Script folder. If you prefer,
    you can also create a sub-folder named `UI_Scripts`, but this is up to you. We
    can name the script `HealthbarScript`.
  id: totrans-344
  prefs: []
  type: TYPE_NORMAL
  zh: 好的，让我们在脚本文件夹中创建一个新的脚本。如果您愿意，您也可以创建一个名为`UI_Scripts`的子文件夹，但这取决于您。我们可以将脚本命名为`HealthbarScript`。
- en: 'Let''s open the script by double-clicking on it. In order to use the UI classes,
    we need to import the namespace. This can be done by adding the following line
    at the beginning of our code, as we already pointed out:'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: 双击脚本以打开它。为了使用UI类，我们需要导入命名空间。这可以通过在代码开头添加以下行来完成，正如我们之前所指出的：
- en: '[PRE1]'
  id: totrans-346
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now that we can use also the UI classes, we need three variables. One is a
    public variable that allows us to decide the maximum amount of health that the
    player can have. The other two are private to keep track of the Image component
    attached to `Health_Bar_Filling`, in order to change the bar filling, and the
    current amount of health that the player possesses:'
  id: totrans-347
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们也可以使用UI类了，我们需要三个变量。一个是公共变量，允许我们决定玩家可以拥有的最大生命值。另外两个是私有的，用于跟踪附加到`Health_Bar_Filling`的图像组件，以便更改条形填充，以及玩家拥有的当前生命值：
- en: '[PRE2]'
  id: totrans-348
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we have to set a couple of variables in our `Start()` function, in particular,
    the reference to the UI Image of `Health_Bar_Filling` by using the `GetComponentInChildren()`
    function. We also need to set the current amount of health to the maximum. In
    this way, the player will start with the maximum amount of health, and this makes
    sense. Finally, we call a function to update the graphic of the health bar, which
    we will implement in a few steps:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们必须在`Start()`函数中设置一些变量，特别是使用`GetComponentInChildren()`函数引用`Health_Bar_Filling`的UI
    Image。我们还需要将当前生命值设置为最大值。这样，玩家将以最大生命值开始，这很有意义。最后，我们调用一个函数来更新生命条的图形，我们将在接下来的几个步骤中实现它：
- en: '[PRE3]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Then, we need to expose a public method to reduce the amount of health the
    player possesses, based on an integer parameter we pass to it. This function will
    be called when one of the sweet-tooth pandas bites the cake, or in the worst-case
    scenario, it will dive into the cake. At the same time, the function should also
    check if the amount of health has reached zero. In this case, for the player,
    the game is over. As such, this function will return a Boolean value, which if
    true, means there is no more cake: the sweet-tooth pandas have eaten it all! Of
    course, we also need to update the graphic of the health bar when we change the
    health amount. Furthermore, to make the code slightly more robust. When the amount
    of health reaches zero or below, the current health is just set to zero and not
    to negative values. Therefore, we can write the following:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要公开一个方法来减少玩家拥有的生命值，基于我们传递给它的整数参数。当甜食熊猫咬蛋糕时，或者在最坏的情况下，它会跳进蛋糕里，这个函数将被调用。同时，该函数还应检查生命值是否已达到零。在这种情况下，对于玩家来说，游戏就结束了。因此，这个函数将返回一个布尔值，如果为真，则表示没有更多的蛋糕：甜食熊猫已经吃完了！当然，我们还需要在更改生命值时更新生命条的图形。此外，为了使代码稍微更健壮，当生命值达到零或以下时，当前的生命值将设置为零，而不是负值。因此，我们可以编写以下代码：
- en: '[PRE4]'
  id: totrans-352
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Finally, we need to write the function to update the Health Bar graphic, the
    one we have called in the previous functions. First, based on the current amount
    of health and the maximum available, the function computes the percentage (from
    0% to 100%) of the amount of health of the player as a float between `0.0` and
    `1.0`. Note that `*1f` is a fast way to convert the number into a float, and therefore
    make a division between floats, instead of integers. Then, the function assigns
    this percentage to the `fillingAmount` of the image component:'
  id: totrans-353
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要编写一个函数来更新生命值条图形，这是我们之前函数中调用过的那个。首先，基于当前的生命值和最大可用值，该函数计算玩家生命值的百分比（从0%到100%），并以浮点数形式在`0.0`和`1.0`之间表示。请注意，`*1f`是将数字转换为浮点数的一种快速方法，因此可以在浮点数之间进行除法，而不是在整数之间。然后，该函数将这个百分比赋值给图像组件的`fillingAmount`：
- en: '[PRE5]'
  id: totrans-354
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'After we have saved the script, it is ready to go. Also, remember to assign
    the maximum amount of health in the Inspector. For the purpose of our game, we
    set it to `100`. At the end, our script will be like the following in the **Inspector**:'
  id: totrans-355
  prefs: []
  type: TYPE_NORMAL
  zh: 保存脚本后，它就准备好了。记住在检查器中分配最大生命值。为了我们游戏的目的，我们将其设置为`100`。最后，我们的脚本在**检查器**中将如下所示：
- en: '![Scripting the health bar](img/image00441.jpeg)'
  id: totrans-356
  prefs: []
  type: TYPE_IMG
  zh: '![编写生命值脚本](img/image00441.jpeg)'
- en: Now that the player has a health, we need to focus on storing and displaying
    the amount of sugar that the player collects.
  id: totrans-357
  prefs: []
  type: TYPE_NORMAL
  zh: 现在玩家有了生命值，我们需要关注存储和显示玩家收集的糖量。
- en: Implementing the sugar meter
  id: totrans-358
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现糖量计
- en: If in the previous section we have seen how the sweet-tooth pandas can defeat
    the player, now it's time to give the player a way to stop them. The first step
    is to have enough sugar to build cupcakes towers. As such, we need a sugar meter
    to keep track of the amount of sugar that the player possesses.
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 如果在前一节中我们看到了甜食熊猫如何击败玩家，那么现在是时候给玩家一个阻止它们的方法了。第一步是拥有足够的糖来建造纸杯蛋糕塔。因此，我们需要一个糖量计来跟踪玩家拥有的糖量。
- en: As we have seen in our design, this will be a number, and not a bar like the
    health. Therefore, even if the concepts are similar, the implementation is slightly
    different.
  id: totrans-360
  prefs: []
  type: TYPE_NORMAL
  zh: 正如我们在设计中看到的，这将是一个数字，而不是像健康那样是一个条形。因此，即使概念相似，实现上略有不同。
- en: Creating and place
  id: totrans-361
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 创建和放置
- en: 'The process for creating the sugar meter is similar to the health bar, so let''s
    start to create a new Image, parented with the Canvas, named `Sugar_Meter`. As
    a Sprite, you can use the `ui_sugar_meter` file in the `Graphic/UI` folder. Place
    it, and scale it if necessary, in the scene to match the following screenshot:'
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 创建糖量计的过程与健康条相似，所以让我们开始创建一个新的Image，将其作为Canvas的父级，命名为`Sugar_Meter`。作为一个Sprite，你可以使用`Graphic/UI`文件夹中的`ui_sugar_meter`文件。将其放置在场景中，并在必要时调整其大小以匹配以下截图：
- en: '![Creating and place](img/image00442.jpeg)'
  id: totrans-363
  prefs: []
  type: TYPE_IMG
  zh: '![创建和放置](img/image00442.jpeg)'
- en: 'Next, create a Text component, parent it to `Sugar_Meter`, and name it `Sugar_Meter_Text`.
    You can set the font and the color that you prefer. At the end you should have
    something similar to this:'
  id: totrans-364
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个Text组件，将其作为`Sugar_Meter`的父级，并命名为`Sugar_Meter_Text`。你可以设置你喜欢的字体和颜色。最后，你应该有类似以下的内容：
- en: '![Creating and place](img/image00443.jpeg)'
  id: totrans-365
  prefs: []
  type: TYPE_IMG
  zh: '![创建和放置](img/image00443.jpeg)'
- en: 'At the end, we should have the following in the **Hierarchy** panel:'
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们应该在**层次结构**面板中看到以下内容：
- en: '![Creating and place](img/image00444.jpeg)'
  id: totrans-367
  prefs: []
  type: TYPE_IMG
  zh: '![创建和放置](img/image00444.jpeg)'
- en: Now, let's make it work with a script.
  id: totrans-368
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们通过脚本让它工作。
- en: Scripting the sugar meter
  id: totrans-369
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 糖量计的脚本编写
- en: 'The script for the sugar meter works similarly to the script for the health
    bar. Let''s import the namespace in order to use UI classes by adding the following
    line at the beginning of our script:'
  id: totrans-370
  prefs: []
  type: TYPE_NORMAL
  zh: 糖量计的脚本与健康条脚本的工作方式相似。为了使用UI类，让我们在脚本开头添加以下行来导入命名空间：
- en: '[PRE6]'
  id: totrans-371
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'We need two private variables to store the reference to `Sugar_Meter_Text`
    and the actual amount of sugar possessed by the player. As you can see, we don''t
    have a maximum, because in theory the player can accumulate an infinite amount
    of sugar:'
  id: totrans-372
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要两个私有变量来存储对`Sugar_Meter_Text`的引用以及玩家拥有的实际糖量。正如你所看到的，我们没有最大值，因为在理论上玩家可以累积无限的糖量：
- en: '[PRE7]'
  id: totrans-373
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'In the `Start()` function, just get the reference to the UI text and update
    the graphic through a function, which we will implement in few steps:'
  id: totrans-374
  prefs: []
  type: TYPE_NORMAL
  zh: 在`Start()`函数中，只需获取UI文本的引用并通过一个函数更新图形，这个函数我们将分几步实现：
- en: '[PRE8]'
  id: totrans-375
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now we need a generic function to increase or decrease player''s sugar by an
    arbitrary amount the. We also need to take into account that it is not possible
    to have a negative amount of sugar. This is more for code robustness rather than
    a real need for the game. In fact, the only way to decrease the sugar is if the
    player buys cupcake towers (or upgrades their towers), but he or she won''t if
    he or she doesn''t have enough sugar. One last thing to do is to update the graphic
    of the Sugar Meter as well:'
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们需要一个通用函数来增加或减少玩家任意数量的糖。我们还需要考虑不可能有负数的糖量。这更多的是为了代码的稳健性，而不是游戏的真实需求。事实上，唯一减少糖量的方式是如果玩家购买了纸杯蛋糕塔（或升级他们的塔），但如果没有足够的糖，他们不会这样做。最后一件要做的事情是更新糖量计的图形：
- en: '[PRE9]'
  id: totrans-377
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Since we will need to retrieve the amount of the sugar that the player has
    in the upcoming chapters, mainly to check if he or she has enough to buy an upgrade
    or a tower, we need a function to retrieve this value. The reason to create this
    function is that the sugar amount is a private variable, and we don''t want to
    make it public, since for robustness we want it to change only with the `ChangeSugar()`
    function, which updates the graphic too:'
  id: totrans-378
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们将在接下来的章节中需要检索玩家拥有的糖量，主要是为了检查他或她是否有足够的糖来购买升级或塔，我们需要一个函数来检索这个值。创建这个函数的原因是糖量是一个私有变量，我们不希望将其公开，因为为了稳健性，我们希望它只通过`ChangeSugar()`函数来改变，该函数也会更新图形：
- en: '[PRE10]'
  id: totrans-379
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Finally, we need the function to update the graphic. This function converts
    the amount of sugar possessed by the player into a string, and assigns the string
    to the **Text** component of `Sugar_Meter_Text`:'
  id: totrans-380
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要一个函数来更新图形。这个函数将玩家拥有的糖量转换为字符串，并将字符串分配给`Sugar_Meter_Text`的**文本**组件：
- en: '[PRE11]'
  id: totrans-381
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: Once the script is saved, we don't have any parameters to set in the **Inspector**.
    Therefore, our sugar meter is ready to measure the amount of sugar.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦脚本保存，我们就不需要在**检查器**中设置任何参数。因此，我们的糖量计已经准备好测量糖的量。
- en: More about UI scripting – handlers
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 关于UI脚本编写的更多内容——处理程序
- en: There is one last topic that we need to cover, since we will be using this technique
    later on in [Chapter 7](part0088.xhtml#aid-2JTHG1 "Chapter 7. Trading Cupcakes
    and the Ultimate Battle for the Cake – Gameplay Programming"), *Trading Cupcakes
    and the Ultimate Battle for the Cake – Gameplay Programming* .
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要讨论最后一个话题，因为我们将在[第7章](part0088.xhtml#aid-2JTHG1 "第7章。交易纸杯蛋糕和终极蛋糕之战 – 游戏玩法编程")中使用这项技术，*交易纸杯蛋糕和终极蛋糕之战
    – 游戏玩法编程*。
- en: Imagine that you want to create an UI component that does something when it
    is clicked. We could create a script with a public function, then attach a button
    component to the game object. Finally, we should create a new `OnClick()` event
    on the button component to trigger the function we have written before. It's fine,
    but isn't a bit laborious?
  id: totrans-385
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你想创建一个UI组件，当它被点击时执行某些操作。我们可以创建一个带有公共函数的脚本，然后将按钮组件附加到游戏对象上。最后，我们应该在按钮组件上创建一个新的`OnClick()`事件，以触发我们之前编写的函数。这没问题，但似乎有点繁琐？
- en: Another example is, suppose you need to drag a UI component around because it
    is a floating window. How are you going to do it? For what we have seen so far,
    this appears to be an hard task; but there is an easy solution.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个例子是，假设你需要拖动一个UI组件，因为它是一个浮动窗口。你将如何做？根据我们迄今为止所看到的，这似乎是一个艰巨的任务；但有一个简单的解决方案。
- en: 'In fact, in our scripts, we can directly include directly the event systems,
    by using this line of code:'
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 实际上，在我们的脚本中，我们可以直接包含事件系统，通过使用以下代码行：
- en: '[PRE12]'
  id: totrans-388
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: As a result, you will be able to extend your script with some (C#) interfaces.
  id: totrans-389
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，你将能够通过一些（C#）接口扩展你的脚本。
- en: Note
  id: totrans-390
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'In case you don''t know what a C# interface is or don''t know how to use it,
    you can check any C# manual. However, I recommend this video from the official
    Documentation of Unity, since it applies interfaces directly to Unity: [https://unity3d.com/learn/tutorials/topics/scripting/interfaces](https://unity3d.com/learn/tutorials/topics/scripting/interfaces).'
  id: totrans-391
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不了解C#接口或者不知道如何使用它，你可以查阅任何C#手册。然而，我推荐观看Unity官方文档中的这个视频，因为它直接将接口应用于Unity：[https://unity3d.com/learn/tutorials/topics/scripting/interfaces](https://unity3d.com/learn/tutorials/topics/scripting/interfaces)。
- en: 'These interfaces allow you to create a function within your script that is
    triggered whenever the specific event you chose occurs. Moreover, this function
    provides some information about that specific event as a parameter within the
    `PointerEventData` class. For instance, to implement our dragging behavior from
    before, we need to add a handler/interface for the drag event next to the class
    declaration, like as follows:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 这些接口允许你在脚本中创建一个函数，每当特定事件发生时，该函数就会被触发。此外，该函数在`PointerEventData`类中作为参数提供了关于该特定事件的一些信息。例如，要实现我们之前的拖拽行为，我们需要在类声明旁边添加一个处理程序/接口，如下所示：
- en: '[PRE13]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Then, you need to implement the interface with its specific function. In this
    case we have:'
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你需要实现具有特定功能的接口。在这种情况下，我们有：
- en: '[PRE14]'
  id: totrans-395
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: Tip
  id: totrans-396
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: In case you are using Visual Studio as your code editor, you can right-click
    on the name of the interface and from the quick action menu select **Implement
    interface** to automatically create that the function we need to implement.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你使用Visual Studio作为代码编辑器，你可以右键单击接口的名称，然后从快速操作菜单中选择**实现接口**来自动创建我们需要实现的函数。
- en: 'At this stage, implementing the drag behavior is simple, since within the `eventData`
    variable, we have all the data regarding the event, such as the mouse position.
    Therefore, we can write the following line of code:'
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个阶段，实现拖拽行为很简单，因为`eventData`变量中包含了关于事件的全部数据，例如鼠标位置。因此，我们可以编写以下代码行：
- en: '[PRE15]'
  id: totrans-399
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: Note
  id: totrans-400
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注意
- en: 'Alternatively, you can also use the `Input` class, as shown here: `transform.position
    = Input.mousePosition;`'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 或者，你也可以使用`Input`类，如下所示：`transform.position = Input.mousePosition;`
- en: 'For a complete list of events you can consult the official documentation here:
    [https://docs.unity3d.com/ScriptReference/EventSystems.EventTrigger.html](https://docs.unity3d.com/ScriptReference/EventSystems.EventTrigger.html).'
  id: totrans-402
  prefs: []
  type: TYPE_NORMAL
  zh: 要获取事件列表的完整列表，您可以在此处查阅官方文档：[https://docs.unity3d.com/ScriptReference/EventSystems.EventTrigger.html](https://docs.unity3d.com/ScriptReference/EventSystems.EventTrigger.html)。
- en: 'For details about the `PointerEventData` class and which kind of information
    of an event it holds, here is the link to the official documentation: [https://docs.unity3d.com/ScriptReference/EventSystems.PointerEventData.html](https://docs.unity3d.com/ScriptReference/EventSystems.PointerEventData.html).'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 关于`PointerEventData`类及其包含的事件信息的详细信息，这里有一个链接到官方文档：[https://docs.unity3d.com/ScriptReference/EventSystems.PointerEventData.html](https://docs.unity3d.com/ScriptReference/EventSystems.PointerEventData.html)。
- en: What about all the rest?
  id: totrans-404
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 那么，其他所有内容呢？
- en: What about all the cool menu interfaces, and all the gameplay interface to buy/sell
    towers that the book promised? Well, don't you think we have learned a lot in
    this chapter?
  id: totrans-405
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，书中承诺的所有酷炫菜单界面，以及所有用于购买/出售塔的游戏玩法界面呢？嗯，您不觉得我们在本章中学到了很多吗？
- en: In fact, this chapter provided a lot of information about UIs, and I suggest
    you take your time to get familiar with all the concepts, as well as doing the
    exercises in the next section. Then, we will come back to implementing all of
    this when we will build the gameplay in [Chapter 5](part0062.xhtml#aid-1R42S1
    "Chapter 5. The Secret Ingredient Is a Dash of Physics"), *The Secret Ingredient
    Is a Dash of Physics*.
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，本章提供了大量关于用户界面的信息，我建议您花些时间熟悉所有这些概念，以及完成下一节中的练习。然后，当我们构建[第5章](part0062.xhtml#aid-1R42S1
    "第5章。秘密成分是物理学的一点点")中的游戏玩法时，我们将回到实现所有这些内容，“秘密成分是物理学的一点点”。
- en: Homework
  id: totrans-407
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 作业
- en: 'In this chapter, we looked at many aspects of UIs in the first part, whereas
    we got handy with it in the second part, by implementing a UI within our game.
    However, before going on to the next chapter, I invite you to take a look at these
    exercises to improve your UI designing/programming skills. They are divided, for
    your convenience, into two parts: the first to improve your designing skills,
    and the second to improve your programming skills.'
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们首先在第一部分探讨了用户界面的许多方面，而在第二部分，通过在我们的游戏中实现用户界面，我们变得得心应手。然而，在进入下一章之前，我邀请您查看这些练习，以提高您的用户界面设计/编程技能。为了您的方便，它们被分为两部分：第一部分用于提高设计技能，第二部分用于提高编程技能。
- en: 'Improving UI designing skills:'
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 提高用户界面设计技能：
- en: '**A great exercise**: A great exercise is to find around three examples of
    games that you like, which are all different. For example, choose a strategy,
    adventure, and puzzle game. Next, for each of them, write down, or draw and annotate,
    each of the UI elements, what their function is, and what happens when a user
    interacts with it. For example, if the user presses the next button, what happens?
    Do they go to a new screen, or does a pop-up appear? You don''t have to do this
    for the entire game, but enough to get a feel for how the UI works, and to understand
    how the placement of icons impact the user''s experience. Next, try to experiment
    with changing the way that the UI is positioned and even the types of UI element.
    For example, if there is a health bar on the left, move it to the right or substitute
    the bar with text and see how it changes the feel. The main purpose of this exercise
    is to keep experimenting with different approaches to the UI. This is especially
    useful when you may have too many elements on screen, and as a result you need
    to remove some. In this way, you will have begun to develop different ideas and
    approaches to modifying the UI to achieve different types of interaction. Finally,
    document what you have done, and feel gratified by what you have accomplished
    and learned.'
  id: totrans-410
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个很好的练习**：一个很好的练习是找到三款您喜欢的不同类型的游戏，例如策略、冒险和解谜游戏。接下来，对于每一款游戏，写下或绘制并标注每个用户界面元素的功能，以及当用户与之交互时会发生什么。例如，如果用户按下下一个按钮，会发生什么？他们会转到新屏幕，还是会出现一个弹出窗口？您不需要为整个游戏都这样做，但足以了解用户界面是如何工作的，以及图标的位置如何影响用户体验。接下来，尝试实验改变用户界面的位置，甚至用户界面元素的类型。例如，如果左侧有一个生命条，将其移到右侧，或者用文本替换条，看看这会如何改变感觉。这个练习的主要目的是不断尝试不同的用户界面方法。当您屏幕上元素过多，需要删除一些元素时，这特别有用。这样，您就开始发展不同的想法和方法来修改用户界面，以实现不同类型的交互。最后，记录您所做的一切，并为您的成就和学习感到自豪。'
- en: '**A frame interface (part I)**: Take the map provided in the package of this
    book (or the one you are currently using). Now imagine that, instead of having
    only a bar at the top for the UI, you have also a right lateral bar. Furthermore,
    imagine to have more than 20 kinds of cupcakes tower, two kinds of sugar that
    the player can collect, brown and white, and that for each tower the player can
    decide two different upgrades other than selling. In this scenario, design an
    interface that easily display to the player all what he or she needs. In particular,
    ensure that the interface is intuitive, and could be used even without an explanation.
    At the end, ask to your friends to take a look at the paper prototype of your
    interface and check if it really achieves what you had in mind. Little tip: it''s
    impossible to fit 20 kinds of tower all at once in the interface; therefore, you
    may want to divide them into categories, or have a scrollable area with all the
    towers.'
  id: totrans-411
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**框架界面（第一部分）**：使用这本书的包中提供的地图（或你目前正在使用的地图）。现在想象一下，除了顶部有一个用于UI的条形栏之外，你还有一个右侧的栏。此外，想象一下有20多种蛋糕塔，两种玩家可以收集的糖，棕色和白色，以及玩家可以为每个塔选择两种不同的升级，除了出售之外。在这种情况下，设计一个界面，可以轻松地向玩家展示他们所需的所有内容。特别是要确保界面直观，即使没有解释也可以使用。最后，请你的朋友看看你界面的纸模型原型，并检查它是否真的实现了你的想法。小贴士：不可能一次在界面上放入20种塔；因此，你可能想要将它们分成类别，或者有一个可以滚动显示所有塔的区域。'
- en: '**A frame interface (part II)**: Once you have designed the interface of the
    previous exercise, look carefully at the colors of the map provided into our package
    (or the one you are currently using). Now, choose the color palette carefully
    for your UI so that there is enough contrast to be able to read the interface
    without much effort, but at the same time it is pleasant to look at, since it
    is in harmony with the colors of the map.'
  id: totrans-412
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**框架界面（第二部分）**：一旦你设计了上一练习的界面，仔细观察我们包中提供的地图颜色（或你目前正在使用的地图）。现在，仔细选择你的UI的颜色调色板，以便在不需要太多努力的情况下能够阅读界面，同时它看起来也很愉快，因为它与地图的颜色相协调。'
- en: '**A frame interface (part III)**: Now it''s time to create all the graphics
    necessary for the design you have created in the last two exercise. You can create
    the graphics from scratch, or take part of the graphics from the package of this
    book. Once created, import them into Unity, including slicing, dividing into Sprites,
    and so on.'
  id: totrans-413
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**框架界面（第三部分）**：现在是你创建在上一两个练习中创建的设计所需的所有图形的时候了。你可以从头开始创建图形，或者从这本书的图形包中取一部分。一旦创建，将它们导入Unity中，包括切片、分割成精灵等。'
- en: 'Improving your UI programming skills:'
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 提高你的UI编程技能：
- en: '**An evil button**: We have seen that the event on the button is triggered
    only when the pointer is released and still within the button. In fact, if the
    player moves the pointer out the component, the event won''t be triggered. In
    the case of an evil button, once the player has clicked it, it''s done, the action
    will be executed. However, in the case of the button, the action is not executed
    when the player clicks, but when released. Implement an evil button so that even
    if the player moves the pointer away from the button and release, the button will
    still trigger the action.'
  id: totrans-415
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**一个邪恶的按钮**：我们已经看到，按钮上的事件只有在指针释放且仍在按钮内时才会触发。实际上，如果玩家将指针移出组件，事件将不会触发。在邪恶按钮的情况下，一旦玩家点击它，就完成了，动作将被执行。然而，在普通按钮的情况下，动作不是在玩家点击时执行，而是在释放时执行。实现一个邪恶按钮，即使玩家将指针从按钮移开并释放，按钮仍然会触发动作。'
- en: '**The selected toggle**: Unfortunately, at the moment, Unity doesn''t have
    any functions to retrieve the toggle that is selected from a toggle group. If
    by the time you are reading this book, a new version of Unity releases this function,
    you can still improve your skills by doing this exercise and ignoring the new
    pre-made function of Unity. In fact, having the ability to retrieve the active
    toggle is really handy in many situations and in many of your games. As such,
    implement a script that given a toggle group with an arbitrary number of toggles
    is able to retrieve and return the selected one (if any; in fact, there might
    be none).'
  id: totrans-416
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**选中的切换**：不幸的是，目前Unity没有函数可以检索从切换组中选中的切换。如果你在阅读这本书的时候，Unity发布了新版本并添加了这个函数，你仍然可以通过完成这个练习并忽略Unity的新预置函数来提高你的技能。实际上，能够检索活动切换在许多情况下以及在你的许多游戏中都非常实用。因此，实现一个脚本，该脚本能够根据任意数量的切换的切换组检索并返回选中的切换（如果有；实际上，可能没有）。'
- en: '**Runtime dropdown (part I)**: Read the official documentation of the drop-down
    component carefully, and implement one that can change the number of options at
    runtime. In particular, place a toggle group that allows the player to pick a
    set. Every set contains different options for the drop-down menu. Once the player
    choses a set, the options of the set are loaded into the drop-down menu (there
    should be only one drop-down menu in the scene, and you need to dynamically load
    the new options). Little tip: since the number of options in each set is variable,
    the easiest way to do this is to clear all the previous options of the drop-down
    menu and load the new ones.'
  id: totrans-417
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行时下拉菜单（第一部分）**：仔细阅读下拉组件的官方文档，并实现一个可以在运行时更改选项数量的下拉菜单。特别是放置一个切换组，允许玩家选择一组。每组都包含下拉菜单的不同选项。一旦玩家选择了一组，该组的选项就会被加载到下拉菜单中（场景中应该只有一个下拉菜单，你需要动态加载新的选项）。小贴士：由于每组的选项数量是可变的，最简单的方法是清除下拉菜单中所有之前的选项，然后加载新的选项。'
- en: '**Runtime dropdown (part II)**: If you want to go further, take the previous
    exercise and through a Input Field and a button allow the player to add an option
    to the current selected set.'
  id: totrans-418
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行时下拉菜单（第二部分）**：如果你想更进一步，将之前的练习与输入字段和按钮结合起来，允许玩家向当前选定的组添加选项。'
- en: '**Runtime dropdown (part III)**: If you felt confident doing the previous exercise,
    keep going by implementing the possibility to remove an option from the set.'
  id: totrans-419
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**运行时下拉菜单（第三部分）**：如果你对完成之前的练习感到自信，继续通过实现从组中删除选项的可能性来推进。'
- en: '**The lighting pointer**: If you have read the UI effect component section,
    you will know about the existence of a special component that creates shadows.
    Place a text in the middle of your scene and apply the shadow component. Play
    a little bit with its values to understand how they work, and how to simulate
    the light coming from different directions. Now, implement a script that, based
    on the pointer positions, changes the shadow component so that it seems that the
    pointer has a kind of light on the text. Therefore, if the pointer is above the
    text, the shadow will be below, whereas if the pointer is on the left, the shadow
    will be on the right. By the way, I warn you that a possible consequence of doing
    this exercise is to create something that you will spend a fairly large amount
    of time to play with, because playing with it can become addictive!'
  id: totrans-420
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**光照指针**：如果你已经阅读了UI效果组件部分，你会知道存在一个可以创建阴影的特殊组件。在你的场景中间放置一个文本，并应用阴影组件。稍微调整其值，以了解它们是如何工作的，以及如何模拟来自不同方向的光线。现在，实现一个脚本，根据指针位置改变阴影组件，使得指针似乎在文本上有某种光线。因此，如果指针在文本上方，阴影将在下方；如果指针在左侧，阴影将在右侧。顺便说一下，我警告你，完成这个练习的可能后果是创建一些你可能需要花费相当多的时间去玩弄的东西，因为玩弄它可能会变得上瘾！'
- en: '**Again Prefabs**: We faced prefabs in the previous section, in game development
    they are always really useful, particularly when you have multiple scenes and
    we don''t want to implement the whole UI again for each level. Since we are going
    to create different levels in the last chapter, it''s a good idea and good practice
    to create a prefab for each of the main UI functionalities. As such, create a
    prefab for the health bar, one for the sugar meter, one for the buy section of
    the UI and another one for the upgrade/selling section of the UI. Furthermore,
    create one last prefab containing all the UI (basically the canvas along with
    all its children). In this way, we can just place this last prefab in the scene
    in the next levels. However, remember to then add an Event System manually in
    the new scene.'
  id: totrans-421
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**再次预制**：我们在上一节中遇到了预制，在游戏开发中它们总是非常有用，尤其是当你有多个场景，我们不想为每个级别再次实现整个UI时。由于我们将在最后一章创建不同的级别，因此为每个主要UI功能创建预制是一个好主意和好习惯。因此，为生命条创建一个预制，为糖量计创建一个，为UI的购买部分创建一个，为UI的升级/出售部分创建一个。此外，创建一个包含所有UI（基本上是画布及其所有子项）的最后一个预制。这样，我们就可以在下一级别的场景中放置这个最后一个预制。然而，请记住，然后在新的场景中手动添加一个事件系统。'
- en: '**A frame interface (part IV)**: If you have done at least the part 1 of this
    exercise, you have designed an interface. Scale the map so that you can create
    the frame described in part 1\. Then, implement the interface. Afterwards, test
    the interface again with your friends to check if it feels right now that it is
    digital. Eventually, modify it based on the suggestions of your friends, and don''t
    forget to share your work, also with me if you want. If you also quote the book,
    I''d be pleased.'
  id: totrans-422
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**帧界面（第四部分）**：如果你至少完成了这个练习的第1部分，你已经设计了一个界面。调整地图的大小，以便你可以创建第1部分中描述的框架。然后，实现这个界面。之后，再次与你的朋友一起测试这个界面，以检查它现在是否感觉数字化。最终，根据朋友的建议进行修改，并且不要忘记分享你的工作，如果你愿意的话，也可以与我分享。如果你还引用了这本书，我会很高兴。'
- en: '**A negative damage**: When we created our health bar script, we wrote a function
    to apply damage, and it checks if the health has reached zero. However, what about
    a negative damage? In that case, the health of the player increases, and it shouldn''t.
    Therefore, add a control to avoid a negative damage, such as setting the damage
    to zero if it''s below zero.'
  id: totrans-423
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**负伤害**：当我们创建我们的生命条脚本时，我们编写了一个函数来应用伤害，并检查生命值是否达到零。然而，负伤害怎么办？在这种情况下，玩家的生命值会增加，这是不应该发生的。因此，添加一个控制来避免负伤害，例如，如果伤害值低于零，则将其设置为零。'
- en: '**Healing the player**: If you have done the previous exercise, it''s not because
    we are sadistic against the player, but because that function should only apply
    damage. To heal the player instead, create another function that takes as a parameter
    an amount to cure the player, and checks if the health is no more than the maximum
    amount. If so, it just caps the health to the maximum.'
  id: totrans-424
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**治疗玩家**：如果你已经完成了之前的练习，那并不是因为我们虐待玩家，而是因为这个功能应该只应用于造成伤害。要治疗玩家，请创建另一个函数，该函数接受一个参数来治疗玩家，并检查生命值是否不超过最大值。如果是这样，它就只将生命值限制在最大值。'
- en: '**Warning the player I**: When the health goes below 30% means that the sweet-tooth
    pandas are devouring the cake, and the player should be warned. Warn the player
    by showing a pop-up that appears on the screen only once, when the health is below
    30%.'
  id: totrans-425
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**警告玩家 I**：当生命值低于30%时，意味着甜食熊猫正在吞噬蛋糕，玩家应该收到警告。当生命值低于30%时，通过在屏幕上仅出现一次的弹出窗口来警告玩家。'
- en: '**Warning the Player II**: In the same vein as the previous exercise, a pop
    up menu could disturb the gameplay. Therefore, warn the player in this way: change
    the color of the health bar to yellow when the health is between 20% and 40%,
    and to red when it is below 20%. Of course, restore the green color once the health
    is above 40%.'
  id: totrans-426
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '**警告玩家 II**：与之前的练习类似，弹出菜单可能会打扰游戏体验。因此，以这种方式警告玩家：当生命值在20%到40%之间时，将生命条的颜色变为黄色；当生命值低于20%时，变为红色。当然，一旦生命值超过40%，恢复绿色颜色。'
- en: Summary
  id: totrans-427
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: The chapter began with an introduction to UI designing and programming, in order
    to understand the main complications behind UIs and why they are so important.
    Then, in the first part of the chapter, we saw in detail how the Unity UI system
    works. In particular, we analyzed every component of the Unity framework and learned
    their use and functionality. In addition, a section explained some special components
    present in the framework, but that we won't need for this book.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: 本章从UI设计和编程的介绍开始，以便理解UI背后的主要复杂性以及为什么它们如此重要。然后，在本章的第一部分，我们详细了解了Unity UI系统的工作原理。特别是，我们分析了Unity框架的每个组件，并学习了它们的使用和功能。此外，一个部分解释了框架中存在的一些特殊组件，但我们在本书中不需要它们。
- en: 'You can find more about UI designing and programming (although with a major
    focus on gamification), including also how to use Illustrator to create your own
    graphic, in *Gamification with Unity 5.x* by *Lauren S. Ferro*, *Packt publishing*.
    You can find the book here: [https://www.packtpub.com/game-development/gamification-unity-5x](https://www.packtpub.com/game-development/gamification-unity-5x).'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在《*Unity 5.x 游戏化*》这本书中找到更多关于UI设计和编程的信息（尽管主要关注游戏化），包括如何使用Illustrator创建自己的图形。这本书由*劳伦·S·费罗*编写，由*Packt出版公司*出版。你可以在这里找到这本书：[https://www.packtpub.com/game-development/gamification-unity-5x](https://www.packtpub.com/game-development/gamification-unity-5x)。
- en: In the second part, we started to create the UI for the tower defense game.
    In particular, we implemented the logic for a health bar as well as for a sugar
    meter. However, we will implement more in [Chapter 5](part0062.xhtml#aid-1R42S1
    "Chapter 5. The Secret Ingredient Is a Dash of Physics"), *The Secret Ingredient
    Is a Dash of Physics*.
  id: totrans-430
  prefs: []
  type: TYPE_NORMAL
  zh: 在第二部分，我们开始创建塔防游戏的UI。特别是，我们实现了健康条和糖量计的逻辑。然而，我们将在[第5章](part0062.xhtml#aid-1R42S1
    "第5章。秘密成分是一点物理学") *《秘密成分是一点物理学》* 中实现更多内容。
- en: In the next chapter, we are not going to be alone anymore. In fact, we will
    finally meet the terrible sweet-tooth pandas we have so anticipated.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将不再孤单。事实上，我们终于要见到我们一直期待着的可怕的甜食爱好者熊猫了。
