- en: Chapter 6. Working with Mono
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Unity supports two main scripting languages, namely, C# and JavaScript. Developers
    should select one of these two from the outset and apply it consistently throughout
    their project; this writes all scripts in the selected language. Failure to do
    so (by mixing script files in different languages) typically causes unnecessary
    headache and confusion. However, once you've settled on a language, such as C#,
    it usually won't offer everything you need it to do to create games. C#, on its
    own, can neither load and parse XML files to support save-game data, nor can it
    create window objects and GUI widgets to perform advanced search and query behaviors
    on complex data sets and collections. To achieve these additional behaviors and
    lots more, we must turn to external libraries. Some libraries can be purchased
    directly from the Unity's Asset Store, and these are typically used for a specific
    and dedicated purpose. However, Unity ships with the Mono Framework, which is
    a free, cross-platform, and open source implementation of the Microsoft .NET Framework
    (a programming library), and it offers most classes available in this library.
    The .NET Framework features classes to handle strings, file input-output, search
    and sort data, keep track of dynamic lists, parse XML, and more. This means that
    through Mono an extensive toolkit is open to you to effectively and efficiently
    manage data in your application. This chapter explores some of the many ways in
    which Mono can be deployed in a Unity application by considering lists, stacks,
    **Language Integrated Query** (**Linq**), regular expressions, enumerators, and
    so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following screenshot shows the Mono Framework interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Working with Mono](img/0655OT_06_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The Mono Framework ships with the Unity engine
  prefs: []
  type: TYPE_NORMAL
- en: Lists and collections
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Perhaps, the most common task when programming games is to store lists of data.
    The nature of this data varies tremendously: high scores, player stats, enemy
    stats, inventory items, weapons, power-ups, level lists, and more. Wherever possible,
    choose static arrays to hold data due to their speed and efficiency. Static arrays
    were considered in detail in [Chapter 1](ch01.html "Chapter 1. Unity C# Refresher"),
    *Unity C# Refresher*. In short, static arrays are created ahead of time, and their
    maximum capacity is fixed from the outset. Items can be added and removed from
    them at runtime, but their total size can never change. If their maximum capacity
    is not utilized, then space would be wasted. Static arrays, as their name implies,
    are an excellent choice for storing lists of data that remain constant, such as
    all levels in the game, all weapons that can possibly be collected, all power-ups
    that can possibly be collected, and so on.'
  prefs: []
  type: TYPE_NORMAL
- en: However, you'll often need dynamic arrays, which can grow and shrink in capacity
    to exactly accommodate the data you need as it changes, such as when enemies are
    spawned and destroyed, inventory items come and go, weapons are collected and
    discarded, and so on. The Mono Framework offers many classes to maintain lists
    of data. The three main classes are `List`, `Stack`, and `Dictionary`. Each of
    these is useful for a specific purpose.
  prefs: []
  type: TYPE_NORMAL
- en: The List class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you need an unordered, sequential list of items of any single data type,
    that is, a list that grows and shrinks to match the size of the stored data, then
    the `List` class is ideal. `List` is especially good to add and remove items and
    sequentially iterating through all stored items. In addition, the `List` objects
    are editable from the Unity Object Inspector. The following code sample 6-1 uses
    a sample C# file `Using_List.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More details on using `List` can be found in the book's companion files (code
    bundle) at `Chapter06\Collections`. You can also see the `List` class reference
    documentation in the MSDN at [http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/6sh2ey19%28v=vs.110%29.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the comments for code sample 6-1:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 03**: To use the `List` class, you must include the `System.Collections.Generic`
    namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 06**: If your list data type is declared as a `System.Serializable`
    class, then the list would be shown in the Object Inspector.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 20**: You can declare and initialize a new list instance in just one
    statement inside the class members'' declaration.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 27**: New objects are immediately added to the end of the list using
    the `Add` method.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 30**: Items can be removed using several methods. `RemoveRange` lets
    you delete several consecutive items from the list. Other removal methods include
    `Remove`, `RemoveAll`, and `RemoveAt`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 33**: You can cycle through all items in a list using a `foreach` loop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 27-33**: Generally, don''t add or remove items to or from a list while
    looping through it.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following screenshot shows the `List` class in the Object Inspector:'
  prefs: []
  type: TYPE_NORMAL
- en: '![The List class](img/0655OT_06_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Viewing the List class in the Object Inspector
  prefs: []
  type: TYPE_NORMAL
- en: 'The `List` class supports several methods to remove items either individually
    or collectively, and these are intended to be used outside list iterations (loops).
    However, there are times when it''s convenient, or seems simplest, to remove items
    while iterating through a loop, such as when you need to remove each item after
    processing it. A classic case is when you need to delete all reference type objects
    in the scene, such as enemies, while also removing their entry in the array to
    avoid null references. Item removal in a loop, however, can cause problems, because
    it''s easy for an iterator to lose track of where it is and where it should go
    within the array as the total item count changes during the loop. To loop and
    remove in one process, you should traverse the array backwards from the end to
    the start, as opposed to forwards, as shown in the following code sample 6-2:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The Dictionary class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `List` class is, perhaps, one of the most useful classes in the Mono Framework
    for in-memory data storage. However, let's not forget the `Dictionary` class (similar
    to the `std::map` class in C++). This class is especially useful when you need
    more than just a simple list of items. If you need to search for and get instant
    access to specific elements based on a key value, then the `Dictionary` class
    is essential. For each item in the list, you must save a corresponding key or
    ID that uniquely identifies the item from all others. The `Dictionary` class then
    allows you to get instant access to this item, based solely on its key. This makes
    the `Dictionary` class useful as a true dictionary for word games, for example,
    if you need to look up the meaning or score-value of specific words in a large
    dictionary or database of words. The word itself would be the key, and the word
    definition would be the value.
  prefs: []
  type: TYPE_NORMAL
- en: Now, of course, you can replicate this kind of behavior using multiple `List`
    objects instead of the `Dictionary` class. However, the `Dictionary` class is
    extremely fast in terms of performance, almost lightning fast. You can store vast
    quantities of data inside the dictionary at very little performance cost. This
    makes them highly valuable for a quick data lookup from key values, as shown in
    the following code sample 6-3;
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 6-3:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 03**: As with the `List` class, you must include the `System.Collections.Generic`
    namespace'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 08**: Here, the dictionary is declared and created in one line; unlike
    the `List` class, `Dictionary` does not appear in the Unity Object Inspector'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 13-23**: The `Dictionary` class is populated using the `Add` method'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 27**: Elements in the `Dictionary` class are accessed much like arrays,
    except by specifying each element using its key data instead of an array index'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: More details on using `Dictionary` can be found in [Chapter 4](ch04.html "Chapter 4. Event-driven
    Programming"), *Event-driven Programming*, when considering event-driven programming
    with an `EventManager`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The Stack class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you're making a card game where players should pick the top card from a deck,
    if you need an undo history, if you're coding customized path finding, or if you're
    creating a complex spell-casting system or even a Tower of a Hanoi puzzle game
    ([http://en.wikipedia.org/wiki/Tower_of_Hanoi](http://en.wikipedia.org/wiki/Tower_of_Hanoi)),
    the chances are high that you'll need a stack somewhere along the line. A stack
    is a special kind of list based on the **Last in, first out** (**LIFO**) model.
    The concept is about stacking. You can push items into the list, and these stack
    up one atop the other in a vertical tower, with the most recently pushed item
    always at the top. Then, you can pop items from the top of the stack (remove them
    from the array) one by one. The order in which you pop items is always the inverse
    of the order in which they were pushed.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is why `Stack` is especially useful for the undo or rewind functionality.
    Refer to the following code sample 6-4 for an example on how to use `Stack`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: IEnumerable and IEnumerator
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'When you''re working with collections of data, whether `List`, `Dictionary`,
    `Stack`, or others, you''ll typically want to iterate (or traverse) all items
    in the list or at least some items, based on a specific criteria. In some cases,
    you''ll want to loop through all items in sequence or some items. Most often,
    you''ll want to traverse the items forwards in sequence, but as we''ve seen, there
    are times when reverse traversing is also suitable. You can loop through items
    using a standard for loop. However, this raises some annoyances that the interfaces
    of `IEnumerable` and `IEnumerator` can help us solve. Let''s see what the annoyances
    are. Consider the `for` loop in the following code sample 6-5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: There are three main annoyances while using a `for` loop. Let's start with the
    first two. The first is that the syntax is not especially inviting for a loop
    that just cycles from left to right, from beginning to end, and we must always
    use an integer iterator variable (`i`) to access each array element as the loop
    proceeds. The second is that the iterator itself is not truly "bounds safe". It
    can, in fact, be incremented or decremented either above or below the array limits
    and cause an out-of-bounds error.
  prefs: []
  type: TYPE_NORMAL
- en: 'These issues can, to some extent, be fixed using the neater `foreach` loop,
    which is bounds safe and uses a simpler syntax, as shown in following code sample
    6-6:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: The `foreach` loop is simpler and is to be preferred for readability, but there's
    more going on here than first meets the eye. The `foreach` loop works only for
    classes that implement the `IEnumerable` interface. Objects that implement `IEnumerable`
    must return a valid instance to an `IEnumerator` interface. So, for an object
    to work in a `foreach` loop, it must depend on two other interfaces. The question
    that then arises is why is there all this internal complexity for simple looping
    or traversal behavior. The answer is, not only do the `IEnumerable` and `IEnumerator`
    solve the first two problems of simpler syntax and bounds-safe iteration by way
    of the `foreach` loop, but they also solve a third problem. Specifically, they
    allow us to loop through or iterate groups of objects that are not even truly
    array types; that is, they let us iterate through many different types of objects,
    whether or not they're in an array, as though they were in an array. This can
    be very powerful. Let's see this in action in a practical example.
  prefs: []
  type: TYPE_NORMAL
- en: Iterating through enemies with IEnumerator
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Take, for example, an RPG game that features a medieval world inhabited by many
    different and evil wizard characters (coded in class `Wizard`). For the sake of
    example, these wizards will spawn into the level at random places and random intervals,
    potentially causing untold trouble for the gamer, casting spells, and performing
    evil deeds. The result of such random spawning is that, by default, we cannot
    know in advance how many wizards there will be in the scene at any one time, nor
    can we know where they've been spawned, because it's random. However, there are
    still legitimate reasons why we'd need to find all the wizards; perhaps, all the
    wizards must be disabled, hidden, paused, or killed, or, perhaps, we need a head
    count to prevent overspawning. So, regardless of the wizard spawning and its randomness,
    there are still good justifications for being able to access all the wizards in
    the level on demand.
  prefs: []
  type: TYPE_NORMAL
- en: 'We''ve seen already, in [Chapter 2](ch02.html "Chapter 2. Debugging"), *Debugging*,
    one way in which we can retrieve a traversable list of all wizards, as shown in
    the following code sample 6-7:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The problem with the `FindObjectsOfType` function is that it's slow and performance
    prohibitive when used frequently. Even the Unity documentation at [http://docs.unity3d.com/ScriptReference/Object.FindObjectsOfType.html](http://docs.unity3d.com/ScriptReference/Object.FindObjectsOfType.html)
    recommends against its repeated use.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A sample Unity project using the `IEnumerator` and `IEnumerable` interfaces
    can be found in the book's companion files (code bundle) at `Chapter06\Enumerators`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, instead, we can achieve similar behavior using `IEnumerable` and `IEnumerator`,
    and this avoids significant performance penalties. Using these two interfaces,
    we''ll be able to efficiently iterate through all the wizards in the scene, using
    a `foreach` loop, as though they were in an array, as shown in the following code
    sample 6-8:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 6-8:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 07 and 39**: Two classes are created here: the first is `WizardEnumerator`,
    which implements `IEnumerator`, and the second is `Wizard`, which implements `IEnumerable`.
    The `WizardEnumerator` class is instantiated simply to iterate over a collection
    of wizards that keeps track of the current wizard in the iteration process. To
    loop through or iterate over all wizards in the scene, it relies on member variables
    for the `Wizard` class, as we''ll see in the upcoming sections.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 13, 23, and 29**: The `WizardEnumerator` class implements the methods
    and properties of `IEnumerator`, specifically, `MoveNext` (which iterates over
    to the next wizard in the cycle), `Reset` (which resets the iterator back to the
    first wizard), and `Current` (which returns the active wizard in the cycle).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 39**: The `Wizard` class encapsulates a wizard character in the scene
    and inherits from two classes: `MonoBehaviour` and `IEnumerable`. This means that
    all the features of both classes come together in this derived class. It internally
    maintains several variables that allow the enumerator to loop through all the
    wizard instances in the scene at any time. First, `Wizard` holds the `FirstCreated`
    and `LastCreated` static members (which are global to all the wizard instances).
    These variables are set when objects are created (see the `Awake` function in
    line 58). `FirstCreated` always refers to the instance of a wizard that was created
    first, and `LastCreated` always to the most recently created instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 48 and 52**: The `Wizard` class also maintains the instance variables,
    `NextWizard` and `PrevWizard`. This implements a doubly-linked list; that is,
    each instance of the wizard points to the previously and subsequently created
    instance, which allows a chain-like connection between all wizards. The first
    wizard will have `PrevWizard` or `null`, and the last wizard will have `NextWizard`
    or `null`. These variables make it possible for the iterator to cycle through
    all wizard instances even when none of them are in an array.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 86**: The `GetEnumerator` method returns an instance to an `Enumerator`
    object. This is required by the `IEnumerable` interface and allows a `foreach`
    loop across all wizards.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Together, the `Wizard` and `WizardEnumerator` classes offer fast, direct, and
    efficient `Wizard` object cycling, even though no array of wizards need to truly
    exist. To see this in practice, in a scene of wizards, the following code sample
    6-9 can enumerate all wizards:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'You can also enumerate through all wizards outside a `foreach` loop by accessing
    the `Enumerator` object directly, as shown in the following code sample 6-10:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Strings and regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Working with text data is critical and for many reasons. If you need to display
    subtitles, show in-game text, and implement localization functionality (supporting
    multiple languages), then you would be working with text, specifically with Text
    Assets. In Unity, Text Assets refer to any text files included in the Unity project,
    and each asset is treated as one long string even when multiple lines are involved
    (each line is separated by a `\n` escape character). Once your code is presented
    with a string like this, however, there're typically many ways in which you'll
    want to process it. Let's see some common but important string operations.
  prefs: []
  type: TYPE_NORMAL
- en: Null, empty strings, and white space
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When processing strings, you can't always guarantee validity; sometimes, strings
    are badly formed and don't make sense. For this reason, you'll frequently need
    to validate them before processing. A common way to validate them initially is
    to see whether a string is null, and then (if not null) check the string's length,
    because if the length is `0`, then the string is empty and, therefore, invalid,
    even though it's not `null`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Again, you''ll probably also want to eliminate the possibility that a string
    consists entirely of spaces, because a string that is not `null` and features
    only white space characters will not, in fact, be of `0` length, even though it
    usually means there''s nothing to process. You can validate a string for each
    of these states individually, but the string class in .NET offers a compound or
    all-in-one convenience check for you, specifically the method `IsNullOrWhiteSpace`.
    However, this method was introduced in .NET 4.5, and Mono does not support this
    version. This means a manual implementation is required for equivalent behavior,
    as shown in the following code sample 6-11:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: String comparison
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'You''ll frequently need to compare two separate strings, typically, for equality
    to determine whether two strings are identical. You can do this using the `==`
    operator such as `string1 == string2`, but for best performance, use the `theString.Equals`
    method. This method has several versions, all of varying computational expense.
    In general, you should prefer any version that contains an argument of type `StringComparison`.
    When the comparison type is explicitly stated, the operation will perform best,
    as shown in the following code sample 6-12:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the `String.Compare` method can be found online in MSDN
    at [http://msdn.microsoft.com/en-us/library/system.string.compare%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.string.compare%28v=vs.110%29.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'Another method to quickly and regularly compare the same two strings for equality
    is to use string hashes, that is, to convert each string into a unique integer
    and then to compare the integers instead, as shown in the following code sample
    6-13:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You can also use the `String.GetHashCode` function from the Mono library to
    retrieve a string's hash code. For more information, visit [http://msdn.microsoft.com/en-us/library/system.string.gethashcode%28v=vs.110%29.aspx](http://msdn.microsoft.com/en-us/library/system.string.gethashcode%28v=vs.110%29.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: 'Sometimes, however, you don''t want to compare for equality. Your intention
    might be to determine which string takes more priority alphabetically, that is,
    whether one string would appear before the other if they were both listed alphabetically
    in a dictionary. You can achieve this using the `String.Compare` function. However,
    again, be sure to use a version that features a `StringComparison` type in the
    arguments, as shown in the following code sample 6-14\. With this version, `-1`
    would be returned if `Str1` comes before `Str2`, `1` would be returned if `Str2`
    comes before `Str1`, and `0` would be returned if the two strings are equal:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although `String.Compare` returns `0` to indicate that two strings are equal,
    never use this function for equality testing. For equality testing, use `String.Equals`
    or hashes, as both perform much faster than `String.Compare`.
  prefs: []
  type: TYPE_NORMAL
- en: String formatting
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''re creating GUI elements, such as high-score HUDs, player names, cash
    counters, or resources indicators, you''ll not only need to show literal text
    but also numerical values inside the strings, for example, by combing the word
    `Score:` with a string representation of the actual score, which will change over
    time depending on player performance. One way to achieve this is the `String.Format`
    method, as shown in the following code sample 6-15:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: String looping
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'So far, we''ve seen `IEnumerable` and `IEnumerator`. Thankfully, these interfaces
    apply to strings and can be used to loop or cycle through every letter in a string.
    This can be achieved using either the `IEnumerator` interface itself or via a
    `foreach` loop. Let''s see both ways, as shown in the following code sample 6-16
    and 6-17:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: Creating strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To make your code read better, work in a cleaner way, and generally, be more
    consistent with .NET and the way it''s intended to be used. It''s a good practice
    to avoid initializing string variables as: `string MyString = "";`. Instead, try
    the following code for string declaration and assignment using `String.empty`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Searching strings
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''re dealing with multiple lines of text read from a file, such as a
    Text Asset, you might need to find the first occurrence of a smaller string inside
    the larger one, for example, finding a smaller and separate word within the larger
    string. You can achieve this using the `String.IndexOf` method. If a match is
    found, the function would return a positive integer that indicates the position
    in the larger string of the first character of the found word as a measured offset
    from the first letter. If no match is found, the function returns `-1`, as shown
    in the following code sample 6-18:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Regular expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Occasionally, you might need to perform more complex searches on very large
    strings, such as finding all words in a string beginning with a specific letter,
    all words starting with `a` and ending in `t`, and so on. In these cases, you
    would want the results available in an array if there are any. You can achieve
    this effectively using regular expressions (`Regex`). Regular expressions let
    you define a string value using a conventional and specialized syntax, specifying
    a search pattern. For example, the string `[dw]ay` means "find all words that
    end with `ay` and that also begin with either `d` or `w`. Thus, find all occurrences
    of either day or way". The regular expression can then be applied to a larger
    string to perform a search using the `Regex` class. The .NET framework provides
    access to regular expression searches through the `RegularExpressions` namespace,
    as shown in the following code sample 6-19:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 6-19:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 05**: The `RegularExpressions` namespace must be included in all source
    files using regular expression searches.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 09 and 13**: The string `Search` defines the regular expression itself.
    The string `txt` defines the larger string to be searched by the regular expression.
    The string `Search` searches for all occurrences of the words, `day` and `way`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 19**: The method `Regex.Match` is called to apply a regular expression
    search on the string `txt`. The results are stored in the local variable `m`.
    This variable can be iterated to scan for all results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 25**: The results in `m` will include three matches (not two) based
    on the string `txt`. These will include *day* as found in to*day* as well as *day*
    and *way* by themselves.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on regular expressions can be found online at [http://en.wikipedia.org/wiki/Regular_expression](http://en.wikipedia.org/wiki/Regular_expression).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Infinite arguments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Though not technically a part of .NET or Mono, our exploration of both these
    libraries has touched several times on functions that accept seemingly an endless
    chain of arguments, such as the `String.Format` function. With `String.Format`,
    it''s possible to plug in as many object arguments as you need for inclusion into
    a formatted string. In this section, I want to take a small (and very quick) diversion
    to show that you can code your own functions that accept and process limitless
    arguments; they''re simple to create. Refer to the following code sample 6-20
    for a function that can sum a potentially limitless array of integers:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 6-20:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 01**: To accept a potentially infinite number of arguments, use the
    `params` keyword and declare the argument as an array type'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 05**: The `params` argument can be accessed like a regular array'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Language Integrated Query
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Obviously, games work with lots of data. They work with not just strings but
    also with objects, databases, tables, documents, and plenty more, too many to
    list here. However, despite the extensiveness and variety of data, there's always
    a common need to filter it, viewing smaller subsets of it as is relevant to our
    needs at the time. For example, given a complete array (or enumerated list) of
    all wizard objects in the scene, we might want to restrict the results even further,
    viewing only wizards whose health is less than 50 percent and whose defense points
    are less than 5\. The purpose is, perhaps, to initiate a mass flee behavior on
    the wizards to find a nearby potion and restore their health before resuming an
    attack on the player. Let's now consider the implementation of this scenario and
    how a technology, Linq, can help us.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: A complete Linq sample project can be found in the book's companion files (code
    bundle) at `Chapter06\Linq\`.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, a very basic and sample definition of a wizard enemy class can be given,
    as shown in the following code sample 6-21\. This class includes both the `Health`
    and `Defense` member variables that are critical to our behavior logic:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Now, given a collection of all enemy objects in the scene, we could filter the
    data into a smaller array according to our criteria with the code, as shown in
    the following code sample 6-22.
  prefs: []
  type: TYPE_NORMAL
- en: 'This code effectively loops through all members, runs them through a conditional
    `if` statement, and then, finally adds the enemy to a results array if it passes
    the condition. The condition, in this case, is whether an enemy''s health is less
    than 50 percent and their defense is less than 5:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: This code works insofar as it restricts a larger data set into a smaller one
    on the basis of a specific criterion. However, Linq lets us achieve the same results
    with less code and often greater performance. Linq is a high-level and specialized
    language to run queries on data sets, including arrays and objects, as well as
    on databases and XML documents. The queries are translated automatically by Linq,
    under the hood, into an appropriate language for the data set used (for example,
    SQL for databases). The aim is to extract the results we need into a regular array.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code sample 6-23 demonstrates an alternative approach to the
    preceding code sample 6-22 using Linq:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 6-23:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lines 03-04**: To use Linq, you must include the `System.Collections.Linq`
    namespace, and to use `List` objects, you must include the `System.Collections.Generic`
    namespace.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 12-14**: The main body of Linq code occurs here. It consists of three
    main parts. First, we indicated the items to pick from the source data, specifically,
    enemy objects from the data set `Enemies`. Second, we defined the criteria to
    search for, specifically where `EnemyChar.Health <= 50 && EnemyChar.Defense <
    5`. Then, when the criterion is met, we selected that object to add to the results;
    we selected `EnemyChar`. Finally, we converted the results to an array with the
    `ToArray` function.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on Linq can be found online in MSDN at [http://msdn.microsoft.com/en-gb/library/bb397926.aspx](http://msdn.microsoft.com/en-gb/library/bb397926.aspx).
  prefs: []
  type: TYPE_NORMAL
- en: Linq and regular expressions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Linq, of course, need not work in isolation. It can, for example, be combined
    with regular expressions to extract specific string patterns from a larger string
    that converts the matched results into a traversable array. This can be especially
    useful in processing comma-separated value files (CSV files), for example, where
    data is formatted inside a text file, each entry being separated by a comma character.
    Both Linq and regular expressions can be used to read each value into a unique
    array element very quickly and easily. For example, consider an RTS game where
    human names must be generated for new units. The names themselves are stored in
    a CSV format and are divided into two groups: male and female. On generating a
    character, it can be either male or female, and an appropriate name must be assigned
    to them from the CSV data, as shown in the following code sample 6-24:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the comments for code sample 6-24:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Line 04**: The member variable `Search` defines a regular expression search
    pattern. The `Search` variable, in this case, is for all words prefixed with `female:`.
    More than this, however, the prefix itself should not be included in the resultant
    strings.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Line 07**: The member variable `CSVData` defines a complete CSV string with
    both male and female names that are structured in the expected format. This string
    essentially represents the database or data source.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lines 10-11**: Here, Linq is used in conjunction with a regular expression
    search to retrieve all female names from the CSV, minus the prefixes. This list
    is then converted into a string array `FemaleNames`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Strings and the @ symbol**'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Notice from line 04 of the code sample 6-24 that the regular expression string
    is prefixed with the symbol `@`. This is a C# convention that allows you to write
    a string literal in a source file; this string literal can contain escape sequences
    (such as `\`) without breaking or invalidating the string itself.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Working with Text Data Assets
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Throughout all examples so far, we've considered text directly stored in string
    objects, but you can also work with text files in Unity. Specifically, you can
    load in text from external sources. Here, I will demonstrate how.
  prefs: []
  type: TYPE_NORMAL
- en: Text Assets – static loading
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The first method is to drag-and-drop a text file into a Unity project that
    imports the text asset. The file is imported as a **TextAssets** type, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text Assets – static loading](img/0655OT_06_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Importing text files into Unity as TextAssets
  prefs: []
  type: TYPE_NORMAL
- en: 'You can access the file and its text data from any script file by exposing
    a `TextAsset` public member, as shown in the following code sample 6-25:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'This code means you just need to drag-and-drop the `TextAsset` file onto the
    **Text Data** slot in the Object Inspector, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Text Assets – static loading](img/0655OT_06_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Accessing text file assets from script
  prefs: []
  type: TYPE_NORMAL
- en: Text Assets – loading from the local files
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Another method to load in text data is externally from the project, that is,
    from files on the local hard drive. Text Data loaded in this way is read into
    the project dynamically from script, not necessarily at scene startup, but whenever
    you execute the necessary code. This means that for longer text files that involve
    heavy processing, lag becomes a serious consideration. In general, therefore,
    it is best to prefer statically loaded Text Assets to dynamic forms. For any dynamic
    assets, I recommend that you load and process them at scene startup to avoid in-game
    lagging, as shown in the following code sample 6-26:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'The code sample 6-26 loads a complete text file into one string object. You
    might, however, prefer to process a text file line by line instead, especially
    if the file is a configuration file where values are specified in separate lines.
    For this, see the following code sample 6-27:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: Text Assets – loading from the INI files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Among the many text file types, you can load a common format is the INI file.
    It''s, perhaps, not as common with Unity games, because many developers use the
    `PlayerPreferences` class instead to store application settings. Even so, the
    INI files offer the advantage of storing application configuration data in only
    one place and in the same format across many different platforms. For this reason,
    there are strong reasons to use INI files. Refer to the code sample 6-28 for an
    example INI that uses a key-value pairing format:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: An ideal data structure to load INI files is the dictionary that mirrors a key-value
    pair structure. For this reason, it'd be great to load an INI file into a dictionary.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, neither Unity nor Mono offers native support for this, which means
    we have to code the functionality ourselves, as shown in the following code sample
    6-29:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'A dictionary returned from this function will match the structure of the INI
    file. Therefore, values can be accessed in the form string `Value = MyDictionary["Key"];`.
    You can also enumerate through all key and value members of a dictionary inside
    a `foreach`, as shown in the following code sample 6-30:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: Text Assets – loading from the CSV files
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we saw how to process a CSV file that features character
    names, both male and female. Let''s now see some source code to load CSV from
    a file on disk into an array of strings, with each string separated by a comma,
    as shown in the following code sample 6-31:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: Text Assets – loading from the Web
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If you''re making multiplayer games and need to access player or game data
    across the Web, if you need to verify passwords with hashes online, or if you
    need to access a web page to process its elements, then you will need the `WWW`
    class to retrieve text data online, as shown in the following code sample 6-32:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: Tip
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: More information on the `WWW` class can be found in the online Unity documentation
    at [http://docs.unity3d.com/ScriptReference/WWW.html](http://docs.unity3d.com/ScriptReference/WWW.html).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter considered a wide range of applications for the Mono Framework
    in practical contexts. It took a three-part structure. First, we explored common
    data structures used in C#, including `List`, `Dictionary`, and `Stack`. From
    there, we moved on to investigate their common usages in storing and searching
    data and in organizing and processing strings. We also explored regular expressions
    for searching strings for patterns of data and the Linq language for filtering
    not only strings but all the collection-type objects available in Mono. Then,
    finally, we examined various methods to import text data, both internally to the
    project and from local files, as well as text data streamed across the Web. The
    next chapter moves into the world of artificial intelligence; it considers path-finding,
    finite state machines, line of sight, decision making, ray casting, and more.
  prefs: []
  type: TYPE_NORMAL
