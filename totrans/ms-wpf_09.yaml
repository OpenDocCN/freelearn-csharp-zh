- en: Implementing Responsive Data Validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Data validation goes hand in hand with data input forms and is essential for
    promoting clean, usable data. While the UI controls in WPF can automatically corroborate
    the fact that values entered match the type of their data bound properties, they
    cannot validate the correctness of the data entered.
  prefs: []
  type: TYPE_NORMAL
- en: For example, a `TextBox` control that is data bound to an integer may highlight
    an error if a user entered a non-numeric value, but it wouldn't validate the fact
    that the number entered had the correct number of digits, or that the first four
    digits were appropriate for the type of credit card specified.
  prefs: []
  type: TYPE_NORMAL
- en: In order to validate these types of data correctness when using MVVM, we'll
    need to implement one of the .NET validation interfaces. In this chapter, we'll
    examine in detail the available interfaces, looking at a number of implementations
    and explore the other validation-related features that WPF provides us with. Let's
    start by looking at the validation system.
  prefs: []
  type: TYPE_NORMAL
- en: In WPF, the validation system very much revolves around the static `Validation`
    class. This class has several Attached Properties, methods, and an Attached Event
    that support data validation. Each binding instance has a `ValidationRules` collection
    that can contain `ValidationRule` elements.
  prefs: []
  type: TYPE_NORMAL
- en: 'WPF provides three built-in rules:'
  prefs: []
  type: TYPE_NORMAL
- en: The `ExceptionValidationRule` object checks for any exceptions thrown as the
    binding source property is updated.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `DataErrorValidationRule` class checks for errors that may be raised by
    classes that implement the `IDataErrorInfo` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `NotifyDataErrorValidationRule` class checks for errors raised by classes
    that implement the `INotifyDataErrorInfo` interface.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Each time an attempt is made to update a data source property, the binding engine
    first clears the `Validation.Errors` collection and then checks the binding's
    `ValidationRules` collection to see whether it contains any `ValidationRule` elements.
    If it does, it calls each rule's `Validate` method in turn until they all pass,
    or one returns an error.
  prefs: []
  type: TYPE_NORMAL
- en: When a data bound value fails the condition in the `Validation` method of a
    `ValidationRule` element, the binding engine adds a new `ValidationError` object
    to the `Validation.Errors` collection of the data binding target control.
  prefs: []
  type: TYPE_NORMAL
- en: This, in turn, will set the `Validation.HasError` Attached Property of the element
    to `true` and, if the `NotifyOnValidationError` property of the binding is set
    to `true`, the binding engine will also raise the `Validation.Error` Attached
    Event on the data binding target.
  prefs: []
  type: TYPE_NORMAL
- en: Using validation rules – to do or not to do?
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WPF, there are two different approaches for dealing with data validation.
    On the one hand, we have the UI-based `ValidationRule` classes, the `Validation.Error` Attached
    Event, and the `Binding.NotifyOnValidationError` and `UpdateSourceExceptionFilter`
    properties, and, on the other, we have two code-based validation interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: While the `ValidationRule` classes and their related validation approach work
    perfectly well, they are specified in the XAML and, as such, are tied to the UI.
    Furthermore, when using the `ValidationRule` classes, we are effectively separating
    the validation logic from the data Models that they are validating and storing
    it in a completely different assembly.
  prefs: []
  type: TYPE_NORMAL
- en: When developing a WPF application using the MVVM methodology, we work with data,
    rather than UI elements, and so we tend to shy away from using the `ValidationRule`
    classes and their related validation strategy directly.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, the `NotifyOnValidationError` and `UpdateSourceExceptionFilter`
    properties of the `Binding` class also require event or delegate handlers, respectively,
    and, as we have discovered, we prefer to avoid doing this when using MVVM. Therefore,
    we will not be looking at this UI-based validation approach in this book, instead
    focusing on the two code-based validation interfaces.
  prefs: []
  type: TYPE_NORMAL
- en: Getting to grips with validation interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In WPF, we have access to two main validation interfaces; the original one is
    the `IDataErrorInfo` interface, and, in .NET 4.5, the `INotifyDataErrorInfo` interface
    was added. In this section, we'll first investigate the original validation interface
    and its shortcomings and see how we can make it more usable, before examining
    the latter.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing the IDataErrorInfo interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `IDataErrorInfo` interface is a very simple affair, with only two required
    properties to implement. The `Error` property returns the error message that describes
    the validation error, and the `Item[string]` indexer returns the error message
    for the specified property.
  prefs: []
  type: TYPE_NORMAL
- en: 'It certainly seems straightforward enough, so let''s take a look at a basic
    implementation of this interface. Let''s create another base class to implement
    this in and, for now, omit all other unrelated base class members so that we can
    concentrate on this interface:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: In this simplest of implementations, we have declared a protected `error` field,
    which will be accessible to derived classes. Note that the `Error` property that
    returns it uses the C# 6.0 expression-bodied property syntax. This syntax is a
    shorthand notation for methods, properties, indexers, constructors, and destructors,
    where the member body is replaced by an inline expression.
  prefs: []
  type: TYPE_NORMAL
- en: We have declared the class indexer (the `this` property) as `virtual`, so that
    we can override it in the derived classes. Another option would be to declare
    it as `abstract`, so that derived classes were forced to override it. Whether
    you prefer to use `virtual` or `abstract` will depend on your particular circumstances,
    such as whether you expect every derived class to require validation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at an example of a class that derives from our new base
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: Here, we have a basic `Product` class that extends our new base class. The only
    job that each derived class that wants to participate in the validation process
    needs to do is to override the class indexer and supply details regarding their
    relevant validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: In the indexer, we first set the `error` field to an empty string. Note that
    this is an essential part of this implementation, as without it, any triggered
    validation errors would never be cleared. There are a number of ways to implement
    this method, with several different abstractions being possible. However, all
    implementations require validation logic to be run when this property is called.
  prefs: []
  type: TYPE_NORMAL
- en: In our particular example, we simply use an `if` statement to check for errors
    in each property, although a `switch` statement works just as well here. The first
    condition checks the value of the `propertyName` input parameter, while multiple
    validation rules per property can be handled with inner `if` statements.
  prefs: []
  type: TYPE_NORMAL
- en: If the `propertyName` input parameter equals `Name`, then we first check to
    ensure that it has some value and provide an error message in case of failure.
    If the property value is not `null` or empty, then a second validation condition
    checks that the length is no longer than 25 characters, which simulates a particular
    database constraint that we may have.
  prefs: []
  type: TYPE_NORMAL
- en: If the `propertyName` input parameter equals `Price`, then we simply check that
    a valid, positive value has been entered and provide another error message in
    case of failure. If we had further properties in this class, then we would simply
    add further `if` conditions, checking their property names, and further relevant
    validation checks.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have our validatable class, let''s add a new View and View Model
    and the `DataTemplate` in the `App.xaml` file that connects the two, to demonstrate
    what else we need to do to get our validation logic connected to the data in the
    UI. Let''s first see the `ProductViewModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'The `ProductViewModel` class simply defines a single `Product` object and exposes
    it via the `Product` property. Let''s now add some basic styles to the application
    resources file, which we''ll use in the related View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'And now, let''s see the View:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: In the XAML, we have a typical two column `Grid` panel, with two rows. The two
    `TextBlock` labels have the `LabelStyle` style applied, and the two `TextBox`
    input controls have the `FieldStyle` style applied. The binding applied to each
    `TextBox.Text` property has two important properties set on it.
  prefs: []
  type: TYPE_NORMAL
- en: The first is the `UpdateSourceTrigger` property, and this controls when the
    data source is updated and therefore, also when validation occurs. If you remember,
    a value of `PropertyChanged` causes updates to occur as soon as the data bound
    property value changes. An alternative value would be `LostFocus`, which causes
    updates to occur when the UI control loses focus, for example, when tabbing to
    the next control.
  prefs: []
  type: TYPE_NORMAL
- en: The other important property here is the `ValidatesOnDataErrors` property, without
    which our current example would not work. Setting this property to `True` on a
    binding causes a built-in `DataErrorValidationRule` element to be implicitly added
    to the `Binding.ValidationRules` collection.
  prefs: []
  type: TYPE_NORMAL
- en: As the data bound value changes, this element will check for errors raised by
    the `IDataErrorInfo` interface. It does this by calling the indexer in our data
    Model, with the name of the data bound property each time the data source is updated.
    Therefore, in this basic example, developers would be responsible for setting
    this property to `True` on each binding to make the validation work.
  prefs: []
  type: TYPE_NORMAL
- en: In .NET 4.5, Microsoft introduced a breaking change to the way that numeric
    data is entered in the `TextBox` control when the `UpdateSourceTrigger` binding is
    set to `PropertyChanged`. Their change stops users from entering numerical separators.
    Refer to the *Keeping Synchronized with Legacy Behavior* section later in this
    chapter to find out why and how to work around this issue.
  prefs: []
  type: TYPE_NORMAL
- en: 'When using a value of `PropertyChanged` for the `UpdateSourceTrigger` property,
    along with the fact that we validate each time the properties change, we have
    the benefit of immediate updates of errors. However, this method of validation
    works in a pre-emptive manner, with all validation errors being shown *b**efore*
    the user has a chance to enter any data. This can be somewhat off-putting to a
    user, so let''s take a quick look at our example when it first starts:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1bc6e515-3321-4282-9ea5-0f37aff5e791.png)'
  prefs: []
  type: TYPE_IMG
- en: As you can see, it's clear that there are some problems, but it's unclear as
    to what they are. So far, we have no output for our error messages. One common
    output that we could use would be the tooltips of the various form controls.
  prefs: []
  type: TYPE_NORMAL
- en: 'We could add a trigger to our `FieldStyle` style, which listened to the `Validation.HasError` Attached
    Property and set the `TextBox` control''s tooltip to the `ErrorContent` property
    of the error whenever one was present. This is how Microsoft has traditionally
    demonstrated how to do this on their website:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Note that we use brackets in the binding path for the `Validation.Errors` collection
    because it is an Attached Property, and that we use the `RelativeSource.Self`
    instance because we want to target the `Errors` collection of the `TextBox` control
    itself. Also note that this example only displays the first `ValidationError`
    object in the `Errors` collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using this style on our data bound `TextBox` controls helps to provide the
    user with further information when they position their mouse cursor over the relevant
    control(s):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bab6015a-c774-409b-9b26-68a4c7ba4e4c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'However, when there are no validation errors to display, an error will be seen
    in the Output window of Visual Studio, because we are attempting to view the first
    error from the `Validation.Errors` Attached Property collection, but none exist:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: There are a number of ways to avoid this error, such as simply displaying the
    whole collection, and we'll see an example of this later in the chapter. However,
    the simplest way is to make use of the `CurrentItem` property of the `ICollectionView`
    object that is implicitly used to wrap `IEnumerable` data collections, which are
    data bound to `ItemsControl` elements.
  prefs: []
  type: TYPE_NORMAL
- en: This is similar to the way that a `ListBox` will implicitly wrap our data bound
    data items in `ListBoxItem` elements. The implementation of the `ICollectionView`
    interface that wraps our data collection is primarily used to enable sorting,
    filtering, and grouping of the data, without affecting the actual data, but its
    `CurrentItem` property is a bonus in this situation.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this, we can replace the indexer that was causing us a problem when there
    were no validation errors. Now, when there are no errors, the `CurrentItem` property
    will return `null`, rather than throwing an Exception and so, despite Microsoft''s
    own example showing the use of the indexer, this is a far better solution:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Nevertheless, if an end user is not aware of having to place their mouse cursor
    over the control to see the tooltip, then the situation is still not improved.
    Therefore, this initial implementation still has room for improvement. Another
    shortcoming of this interface is that it was designed to be atomic, so it only
    deals with a single error per property at a time.
  prefs: []
  type: TYPE_NORMAL
- en: In our `Product` class example, we want to validate the fact that the `Name`
    property is not only entered, but also has a valid length. In the order that we
    declared our two validation conditions for this property, the first error will
    be raised when the field in the UI is empty, and the second will be raised if
    the entered value is too long. As the entered value cannot be both non-existent
    and too long at the same time, having only a single reported error at one time
    is not a problem in this particular example.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, if we had a property that had multiple validation conditions, such
    as a maximum length and a particular format, then with the usual `IDataErrorInfo`
    interface implementation, we''d only be able to view one of these errors at once.
    However, despite this limitation, we can still improve this basic implementation.
    Let''s see how we can do this with a new base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we add two collections to hold error messages; the `Errors`
    collection property contains validation errors that are generated within the derived
    class, and the `ExternalErrors` collection property holds externally generated
    validation errors, typically from a parent View Model.
  prefs: []
  type: TYPE_NORMAL
- en: In the constructor, we attach the `ExternalErrors_CollectionChanged` event handler
    to the `CollectionChanged` event of the `ExternalErrors` collection property so
    that it is notified whenever items are added or removed from it.
  prefs: []
  type: TYPE_NORMAL
- en: After the declaration of the error collection properties, we see the `HasError`
    expression-bodied property, which checks whether the `Errors` collection contains
    any errors. Note that we check the `errors` field for `null`, rather than the
    `Errors` property, because calling the `Errors` property regenerates the error
    messages and we do not want to regenerate them all twice each time the `HasError` property
    is called.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the new implementation of the `IDataErrorInfo` interface. The class
    indexer remains the same as the one from the previous implementation, but we see
    a difference in the definition of the `Error` property, which now compiles a complete
    list of all errors, rather than returning a single error message at a time.
  prefs: []
  type: TYPE_NORMAL
- en: 'In it, we first check whether any errors exist, and return an empty string
    if not. If errors do exist, we initialize a `StringBuilder` object and use our
    `ForEach` Extension Method to iterate through the `Errors` collection and append
    each of them to it, if they haven''t already been included. We do this using another
    Extension Method before returning the output, so let''s see what that looks like
    now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: In our `AppendUniqueOnNewLineIfNotEmpty` Extension Method, we first check that
    the input value is not an empty string and that it is not already present in the
    `StringBuilder` object. If the `text` input parameter is valid, we use the ternary
    operator to determine whether it is the first value to be added and whether we
    need to precede it with a new line or not, before adding the new, unique value.
  prefs: []
  type: TYPE_NORMAL
- en: Returning to our validation base class now, we see the new implementation of
    the `INotifyPropertyChanged` interface. Note that we repeat our earlier `BaseSynchronizableDataModel`
    class example by raising the `PropertyChanged` event each time changes are registered
    for any other properties, but, unlike the previous example, we raise the `HasError`
    property here, rather than the `HasChanges` property.
  prefs: []
  type: TYPE_NORMAL
- en: We can combine both of these and raise the `PropertyChanged` event for both
    properties each time we receive notification of changes to other properties if
    we so desire. In this case, the purpose is to call the `HasError` property, which
    will be used in the UI to display or hide the control that displays the error
    messages, and so it will be updated after every validatable property change.
  prefs: []
  type: TYPE_NORMAL
- en: At the bottom of our class, we see the expression-bodied `ExternalErrors_CollectionChanged`
    method, which calls the `NotifyPropertyChanged` method for the `Errors` collection
    property. This notifies controls that are data bound to this property that its
    value has changed and that they should retrieve that new value.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see an example implementation of this now, using an extended version
    of our `Product` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Therefore, when an error is externally added to the `ExternalErrors` collection,
    the `ExternalErrors_CollectionChanged` method will be called and this notifies
    changes to the `Errors` property. This results in the property being called and
    the external error(s) being added to the internal `errors` collection, along with
    any internal errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'To get this particular implementation of the `IDataErrorInfo` interface to
    work, each data Model class will need to override this `Errors` property to add
    error messages from each validated property. We provide a few Extension Methods
    to make this task easier. As its name implies, the `AddUniqueIfNotEmpty` method
    adds strings to the collection if they do not already exist in it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'The `AddRange` method is another useful Extension Method that simply iterates
    through the `range` collection input parameter and adds them to the `collection`
    parameter one by one:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: 'In addition to implementing this new `Errors` collection property in their
    derived classes, developers will also need to ensure that they notify changes
    to it each time a validatable property value is changed. We can do this using
    our overload of the `NotifyPropertyChanged` method that takes multiple values:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: The `Errors` property is responsible for calling the class indexer with the
    name of each of the properties that we want to validate. Any error messages that
    are returned, including those from the `ExternalErrors` collection property, are
    then added to the internal `errors` collection.
  prefs: []
  type: TYPE_NORMAL
- en: In effect, we have replicated what the `Validation` class and the `DataErrorValidationRule`
    element does in the UI, but in our data Model instead. This means that we no longer
    have to set the `ValidatesOnDataErrors` property to `True` on each binding. This
    is a better solution when using MVVM, as we prefer to work with data, rather than
    UI elements, and now also have full access to all of the data validation errors
    in our View Models.
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, we now have the ability to manually feed in error messages from
    our View Models to our data Models via the `ExternalErrors` collection property.
    This can be very useful when we need to validate across a collection of data Model
    objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, if we need to ensure that the name of each data Model object is
    unique within a collection of related objects, we can use this feature. Let''s
    now create a new `ProductViewModelExtended` class to see how we can accomplish
    this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Like the `ProductViewModel` class, our `ProductViewModelExtended` class also
    extends the `BaseViewModel` class, but it declares a `ProductsExtended` collection
    and adds two `ProductExtended` objects to it in the constructor, instead of the
    single `Product` instance used previously. The `ProductsExtended` class simply
    extends our `BaseCollection` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: In the class constructor, we first add a couple of test products to the `ProductsExtended` collection
    and then attach the `Products_CurrentItemChanged` method to its `CurrentItemChanged`
    delegate. In order to set the second item as the current item, we call the `Last`
    method on the `ProductsExtended` collection and set that to its `CurrentItem`
    property.
  prefs: []
  type: TYPE_NORMAL
- en: This ensures that the `Products_CurrentItemChanged` method is called when setting
    the second item as the current item and the `Product_PropertyChanged` handler
    is attached to it. After this, we then call the `ValidateUniqueName` method that
    is described shortly, passing in the current item.
  prefs: []
  type: TYPE_NORMAL
- en: After the declaration of the `Products` property, we see the `Products_CurrentItemChanged`
    method, which will be called each time the value of the `CurrentItem` property
    is changed. In it, we attach the `Product_PropertyChanged` method to the `PropertyChanged`
    event of the new, current `ProductExtended` object and detach it from the previous
    one.
  prefs: []
  type: TYPE_NORMAL
- en: The `Product_PropertyChanged` method will be called each time any property of
    the related `ProductExtended` object changes. If the property that changed was
    the `Name` property, we call the `ValidateUniqueName` method, as that is the property
    that we need to validate for uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: The `ValidateUniqueName` method is responsible for adding or removing the error
    from the `ExternalErrors` collection property of the `product` input parameter.
    It does this by checking the result of the `IsProductNameUnique` method, which
    does the actual check for uniqueness.
  prefs: []
  type: TYPE_NORMAL
- en: In the expression-bodied `IsProductNameUnique` method, we use LINQ to query
    the `Products` collection and find out whether an existing item shares the same
    name. It does this by checking that each item does not have the same identification
    number, or, in other words, is not the object being edited, but does have the
    same name, and that the name is not an empty string.
  prefs: []
  type: TYPE_NORMAL
- en: If any other products that have the same name are found, then the method returns
    `false` and an error is added to the product's `ExternalErrors` collection in
    the `ValidateUniqueName` method. Note that we must manually remove this error
    if the name is found to be unique.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a new `ProductViewExtended` class, to display these errors
    better. First, let''s add another reusable resource to the application resources
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'This `DataTemplate` simply displays a `TextBlock` control, with its `Text`
    property data bound to the data context of the `DataTemplate`, and its `TextWrapping`
    property set to `Wrap`, which has the effect of wrapping text that does not fit
    into the width provided. Now, let''s look at the new `ProductViewExtended` class
    that uses this template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we now have a `Grid` panel with two columns. In the left column,
    we have a `ListBox` control, and, in the right column, we have another `Grid`
    panel containing our form fields. The `ItemsSource` property of the `ListBox`
    control is data bound to the `Products` collection property from our View Model,
    and the `SelectedItem` property is data bound to its `CurrentItem` property.
  prefs: []
  type: TYPE_NORMAL
- en: We set the `DisplayMemberPath` property to `Name`, to output the name of each
    product, as a shortcut for creating a `DataTemplate` for our `Product` class.
    Alternatively, we could have returned the value of the `Name` property from the
    `ToString` method in our `Product` class to achieve the same visual result, although
    that would not update in the UI when the property value changed.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Grid` panel on the right, we declare three rows and, in the top one,
    we define a `Border` element containing an `ItemsControl` object. Its `ItemsSource`
    property is data bound to the `Errors` collection property of the item that is
    set to the `CurrentItem` property of the `Products` collection, and its `ItemTemplate`
    property is set to our new `WrapTemplate` data template. The `Visibility` property
    of the border is data bound to the item's `HasError` property using the `BoolToVisibilityConverter`
    instance from the application resources.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, when a change is made to a validated property of the item and an
    error is raised in our validation base class, the `PropertyChanged` event is raised
    for the `HasError` property and this alerts this binding to check the latest value
    and update its visibility value via the applied `BoolToVisibilityConverter` instance
    accordingly.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we use `ItemsControl` here, because with this collection, we have
    no need for the extra features that the `ListBox` control provides us with, such
    as a border, or the notion of a selected item. The two rows underneath the error
    output contain the form fields from the `ProductView` example.
  prefs: []
  type: TYPE_NORMAL
- en: When this example is run, we'll see two items that have the same name in our
    `ListBox` control. As such, there will already be a validation error displayed
    that highlights this fact and that was added through the `ExternalErrors` collection
    in the View Model.
  prefs: []
  type: TYPE_NORMAL
- en: 'In addition to this, we''ll see another error, highlighting the fact that a
    valid price needs to be entered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a201f297-20ff-44d8-b547-58b55ccb45c2.png)'
  prefs: []
  type: TYPE_IMG
- en: As the `UpdateSourceTrigger` property of the field bindings have been set to
    `PropertyChanged` and the data bound properties are validated straight away, the
    errors will immediately disappear and/or reappear as soon as we type in the relevant
    form fields. This setting, along with the fact that we validate each time the
    properties change, makes our validation work in a pre-emptive manner.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can also change this to work only when a user presses a submit button by
    setting the `UpdateSourceTrigger` property to the `Explicit` value. However, this
    requires that we access the data bound controls in the code behind files and so
    we tend to avoid this approach when using the MVVM methodology:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Alternatively, if we wanted to validate in this way when using MVVM, we could
    simply call the validation code when the command that is data bound to the submit
    or save button is executed instead. Let's now take a look at the `INotifyDataErrorInfo`
    interface to see how it differs from the `IDataErrorInfo` interface.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing the INotifyDataErrorInfo interface
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The `INotifyDataErrorInfo` interface was added to the .NET Framework in .NET
    4.5 to address concerns over the previous `IDataErrorInfo` interface. Like the
    `IDataErrorInfo` interface, the `INotifyDataErrorInfo` interface is also a simple
    affair, with only three members for us to implement.
  prefs: []
  type: TYPE_NORMAL
- en: 'With this interface, we now have a `HasErrors` property, which indicates whether
    the relevant data Model instance has any errors, a `GetErrors` method that retrieves
    the object''s error collection, and an `ErrorsChanged` event to raise when the
    entity''s errors change. We can see straight away that this interface was designed
    to work with multiple errors, unlike the `IDataErrorInfo` interface. Now, let''s
    take a look at an implementation of this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: In our first implementation, we see the declaration of the read-only `AllPropertyErrors`
    auto property, initialized to a new instance. For this collection, we use the
    `Dictionary<string, List<string>>` type, where the name of each property in error
    is used as the dictionary key, and multiple errors for that property can be stored
    in the related `string` list.
  prefs: []
  type: TYPE_NORMAL
- en: We then see the read-only, expression-bodied `Errors` property, which will hold
    the `string` collection of errors to be displayed in the UI. It is set to return
    a compilation of unique errors from the `AllPropertyErrors` collection. Next,
    we find an abstract `string` indexer that returns an `IEnumerable` of the `string` type,
    which is responsible for returning multiple validation errors from derived classes
    that relate to the property specified by the `propertyName` input parameter. We'll
    see how we can implement this property in a derived class shortly.
  prefs: []
  type: TYPE_NORMAL
- en: After that, we add two convenient `NotifyPropertyChangedAndValidate` methods,
    which we can use to both provide notification of changes to our property and to
    validate it in a single operation. In these methods, we call our implementation
    of the `NotifyPropertyChanged` method and then our `Validate` method, passing
    the relevant property name to each of them.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Validate` method, we call the `UpdateErrors` method, passing in the
    `propertyName` input parameter and the related errors for the specified property,
    returned from the `this` indexer property. In the `UpdateErrors` method, we begin
    by checking whether there are any errors in the collection specified by the `errors`
    input parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If there are, and it does contain some, we clear the errors for the relevant
    property from the `AllPropertyErrors` collection, or initialize a new entry for
    the property, with an empty collection otherwise. We then add the incoming errors
    to the `AllPropertyErrors` collection for the relevant property and call the `OnErrorsChanged` method
    to raise the `ErrorsChanged` event.
  prefs: []
  type: TYPE_NORMAL
- en: If there are no errors in the collection specified by the `errors` input parameter,
    we remove all previous entries from the `AllPropertyErrors` collection for the
    relevant property, after first validating that some exist, so as to avoid an Exception
    being thrown. We then call the `OnErrorsChanged` method to raise the `ErrorsChanged`
    event to notify changes to the collection.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the required `INotifyDataErrorInfo` interface members. We declare
    the `ErrorsChanged` event for internal use only and the related `OnErrorsChanged`
    method that raises it using the null conditional operator, although this method
    is not technically part of the interface and we are free to raise the event as
    we see fit. After raising the event, we notify the system of changes to the `Errors` and `HasErrors`
    properties, to refresh the error collection, and to update the UI of any changes.
  prefs: []
  type: TYPE_NORMAL
- en: In the `GetErrors` method, we are required to return the errors for the `propertyName`
    input parameter. We start by initializing the `propertyErrors` collection, which
    we return immediately if the `propertyName` input parameter is `null`, or empty. Otherwise,
    we use the `TryGetValue` method to populate the `propertyErrors` collection with
    the errors that relate to the `propertyName` input parameter from the `AllPropertyErrors`
    collection. We then return the `propertyErrors` collection.
  prefs: []
  type: TYPE_NORMAL
- en: The simplified `HasErrors` expression-bodied property follows and simply returns
    `true` if the `AllPropertyErrors` collection property contains any errors, or
    `false` otherwise. We complete the class with our default implementation of the
    `INotifyPropertyChanged` interface. Note that we can simply omit this if we intend
    this base class to extend another with its own implementation of this interface.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s copy our earlier `Product` class so as to create a new `ProductNotify`
    class that extends our new base class. Apart from the class name and the collection
    of errors, we need to make a number of changes. Let''s look at these now:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The main differences between the `ProductNotify` and `Product` classes relate
    to the base class, the notification method used, and the handling of multiple
    concurrent errors. We start by extending our new `BaseNotifyValidationModel` base
    class. Each property, with the Exception of the `Id` property, which requires
    no validation, now calls the `NotifyPropertyChangedAndValidate` method from the
    new base class, instead of the `NotifyPropertyChanged` method from the `BaseValidationModel`
    class.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to that, the `this` indexer property can now report multiple errors
    simultaneously, rather than the single error that the `BaseValidationModel` class
    could work with. As such, it now declares a `string` list to hold the errors,
    with each valid error being added to it in turn. The final difference is that
    we have also added a new error, which validates the fact that the first letter
    of the product name should start with a capital letter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see our `ProductNotifyViewModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: We start our `ProductNotifyViewModel` View Model by extending our usual `BaseViewModel`
    base class. We declare a `ProductsNotify` collection and, in the constructor,
    we populate it with two `ProductNotify` objects, with the same property values
    that were used in the `ProductViewModelExtended` class example. We again call
    the `Last` method on the `ProductsNotify` collection and set that last element
    to its `CurrentItem` property to pre-select the second item in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then call the `Validate` method twice on the object set to the `CurrentItem`
    property, passing in the `Name` and `Price` properties, using the `nameof` operator
    for correctness. The class ends with the standard declaration of the `Products`
    property. Note that the `ProductsNotify` class simply extends our `BaseCollection`
    class, just like our `Products` class did:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Also note that if we removed the call to the `Validate` method from the constructor,
    this implementation would no longer work in a pre-emptive manner. It would instead
    initially hide any pre-existing validation errors, such as empty required values,
    until the user makes changes and there is a problem. Therefore, empty required
    values would never cause an error to be raised, unless a value was entered and
    then deleted, to once again be empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'To address this, we could instead declare a `ValidateAllProperties` method
    that our View Models can call to force a new validation pass, either pre-emptively,
    before the user has a chance to enter any data, or on the click of a save button,
    once all fields have been filled. We''ll see an example of this later in this
    chapter, but for now, let''s see the XAML of our `ProductNotifyView` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In the `Resources` section, we have declared a new `DataTemplate` element, named
    `ProductTemplate`. This just displays the value of the `Name` property, but importantly,
    with the binding’s `ValidatesOnNotifyDataErrors` property set to `False`, so that
    no error template is displayed within the `ListBoxItem` elements.
  prefs: []
  type: TYPE_NORMAL
- en: Another point to note is that the `Visibility` property of the global error
    display's border has now been updated to work with the new `HasErrors` property from
    the `INotifyDataErrorInfo` interface, rather than the `HasError` property from
    our previous `BaseValidationModelExtended` class.
  prefs: []
  type: TYPE_NORMAL
- en: The only other change was made to the `Text` property binding of the two `TextBox`
    controls; when using the `INotifyDataErrorInfo` interface, instead of setting
    the `ValidatesOnDataErrors` property to `True` as before, we now need to set the
    `ValidatesOnNotifyDataErrors` property to `True`.
  prefs: []
  type: TYPE_NORMAL
- en: We'll update this example again shortly, but before that, let's explore another
    method of providing validation logic.
  prefs: []
  type: TYPE_NORMAL
- en: Annotating data
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The .NET Framework also provides us with an alternative, attribute-based validation
    system in the `System.ComponentModel.DataAnnotations` namespace. It is mostly
    comprised of a wide range of attribute classes that we can decorate our data Model
    properties with so as to specify our validation rules. In addition to these attributes,
    it also includes a few validation classes, which we will investigate later.
  prefs: []
  type: TYPE_NORMAL
- en: 'As an example, let''s look at replicating the current validation rules from
    our `ProductNotify` class with these data annotation attributes. We need to corroborate
    the fact that the `Name` property is entered and has a length of 25 characters
    or less, and that the `Price` property is more than zero. For the `Name` property,
    we can use the `RequiredAttribute` and the `MaxLengthAttribute` attributes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: As with all attributes, we can omit the word `Attribute` when using them to
    decorate properties. Most of these data annotation attributes declare one or more
    constructors with a number of optional parameters. The `ErrorMessage` input parameter
    is used in each to set the message to output when the specified condition is not
    met.
  prefs: []
  type: TYPE_NORMAL
- en: The `RequiredAttribute` constructor has no input parameters and simply checks
    that the data bound value is not `null` or empty. The constructor of the `MaxLengthAttribute`
    class takes an integer that specifies the maximum allowable length of the data
    bound value and it will raise a `ValidationError` instance if the input value
    is longer.
  prefs: []
  type: TYPE_NORMAL
- en: 'For the `Price` property, we can make use of the `RangeAttribute` with a really
    high maximum value, as there is no `MinimumAttribute` class available:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The constructor of the `RangeAttribute` class takes two `double` values, which
    specify the minimum and maximum valid values, and, in this example, we set the
    minimum to one penny and the maximum to the maximum `decimal` value, as our `Price`
    property is of the `decimal` type. Note that we could not use the `RequiredAttribute`
    class here, as numeric data bound values will never be `null` or empty.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are a large number of these data annotation attribute classes, covering
    the most common validation situations, but when we have a requirement that does
    not have a pre-existing attribute to help us, we can create our own custom attribute
    by extending the `ValidationAttribute` class. Let''s create an attribute that
    only validates a minimum value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: When we extend the `ValidationAttribute` class, we only need to override the
    `IsValid` method to return `true` or `false`, depending on our input value, which
    is specified by the `value` input parameter. In our simple example, we first declare
    the `minimumValue` field to store the target minimum allowable value to use during
    validation.
  prefs: []
  type: TYPE_NORMAL
- en: We populate this field in the class constructor, with the value that users of
    our class provide. Next, we override the `IsValid` method that returns a `ValidationResult`
    instance. In this method, we first check the type of the `value` input parameter
    and then cast it to `decimal`, in order to compare it with the value of our `minimumValue`
    field.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have hardcoded this `double` type as the type of our minimum value,
    because although our `Price` property is `decimal`, the `decimal` type is not
    considered primitive and therefore cannot be used in an attribute. A better, more
    reusable solution, would be to declare a number of constructors that accept different
    numerical types that could be used in a wider range of situations and to update
    our `IsValid` method to be able to compare the different types with the input
    value.
  prefs: []
  type: TYPE_NORMAL
- en: In our example, if the input value is either the incorrect type, or the cast
    value is less than the value of the `minimumValue` field, we first create the
    `memberNames` variable and insert the value of the `MemberName` property from
    the `validationContext` input parameter. We then return a new instance of the
    `ValidationResult` class, inputting the used error message and our `memberNames`
    collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'If the input value is valid according to our particular validation logic, then
    we simply return the `ValidationResult.Success` field to signify successful validation.
    Let''s now look at our new attribute being used on the `Price` property of our
    `ProductNotify` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'In effect, our new attribute will work exactly as the previously used `RangeAttribute`
    instance, but it clearly demonstrates how we can create our own custom validation
    attributes. Before we move on to see how we can read these errors with our code,
    let''s first see how we can access the value of a second property from the data
    Model in our attribute, as this is a common requirement when validating:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: This example assumes that we have added a reference to the `System` and `System.Reflection`
    namespaces and declared a `string` field named `otherPropertyName`, which is populated
    with the name of the other property name in the constructor. Using reflection,
    we attempt to access the `PropertyInfo` object that relates to the specified property
    name.
  prefs: []
  type: TYPE_NORMAL
- en: If the `PropertyInfo` object is `null`, we throw an `ArgumentNullException`
    object, alerting the developer that they have used a non-existent property name.
    Otherwise, we use the `GetValue` method of the `PropertyInfo` object to retrieve
    the value from the other property.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we''ve seen how to use and create our own custom validation attributes,
    let''s see how we can use them to validate our data Model instances from one of
    their base classes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: We start by initializing a `ValidationContext` object, passing in the data Model
    instance from the base class. The context object is then passed to the `TryValidateObject`
    method of the `Validator` class, in order to retrieve any validation errors from
    any of the data annotation attributes.
  prefs: []
  type: TYPE_NORMAL
- en: We also initialize and pass a list of the `ValidationResult` type to the `TryValidateObject`
    method, which will get filled with errors for the current data object. Note that
    the fourth `bool` input parameter of this method specifies whether it will return
    errors for all properties, or just for those that have been decorated with `RequiredAttribute`
    from the data annotations namespace.
  prefs: []
  type: TYPE_NORMAL
- en: Later, we'll see how we can incorporate this into our application framework's
    validation base class, but now let's investigate how we can perform different
    levels of validation in different scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: Varying levels of validation
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One thing that is not addressed by either of the .NET validation interfaces
    is the ability to either turn validation on or off, or to set varying levels of
    validation. This can be useful in several different scenarios, such as having
    different Views to edit different properties of a data Model object.
  prefs: []
  type: TYPE_NORMAL
- en: An example of this might be having a View that enables users to update the security
    settings of a `User` object, where we want to validate that each property has
    a value, but only for the properties that are currently displayed in the View.
    After all, there is no point in informing the user that a certain field must be
    entered if they can't do that in their current View.
  prefs: []
  type: TYPE_NORMAL
- en: 'The solution is to define a number of levels of validation, in addition to
    the levels that represent full and no validation. Let''s take a look at a simple
    `ValidationLevel` enumeration that could fulfill this requirement:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'As we can see, in this simple example, we just have the three levels of validation,
    although we could have added many more. However, in practice, we could still manage
    with this simple enumeration. Let''s see how we could use it to implement multi-level
    validation in our validation base class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: We add a `ValidationLevel` property, with its `validationLevel` backing field
    that defaults to the `Full` enumeration member, as that is the normal action.
    Then, in the `Validate` method, we add a new line that simply exits the method
    if the `ValidationLevel` property is set to the `None` enumeration member.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, the developers that use our application framework need to use the
    `ValidationLevel` property when validating their properties in the data Model
    classes. Imagine a scenario where users could edit the names of our products directly
    in a collection control, or edit all of the product''s properties in a separate
    View. Let''s see what our `ProductNotify` class indexer property would need to
    look like to demonstrate this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: Using our implementation of the `INotifyDataErrorInfo` interface, we first initialize
    a `string` list named `errors` and then we check the value of the `propertyName`
    input parameter. As this implementation enables us to return multiple validation
    errors per property, we need to take care with our `if` and `else` statements.
  prefs: []
  type: TYPE_NORMAL
- en: For example, when the `propertyName` input parameter equals `Name`, we have
    two `if` statements and one `else` statement. The first `if` statement verifies
    that the `Name` property has a value, while the `else` statement checks that its
    value is no longer than 25 characters.
  prefs: []
  type: TYPE_NORMAL
- en: As these two conditions cannot possibly both be true at the same time, we tie
    them together with the `if...else` statement. On the other hand, the product name
    could be longer than 25 characters and start with a lowercase letter and so, the
    next condition has its own `if` statement. In this example, the `Name` property
    will be validated when the `ValidationLevel` property is set to either the `Partial`
    or `Full` members.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the remaining condition for the `Price` property is only to be validated
    when the `ValidationLevel` property is set to the `Full` member and so, that is
    simply added as a further condition. To trigger partial validation on a data Model
    variable, we can simply set its `ValidationLevel` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: Let's now investigate how we can combine the different techniques that we have
    viewed so far.
  prefs: []
  type: TYPE_NORMAL
- en: Incorporating multiple validation techniques
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we've had a good look at the two validation interfaces, the data annotation
    attributes and the ability to validate with different levels, let's take a look
    at how we can amalgamate these different techniques.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s create a `BaseNotifyValidationModelExtended` class by copying what we
    have in our `BaseNotifyValidationModel` class, and incorporating these following
    new additions. First, we need to add some extra using directives to the ones used
    in the previous implementation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: 'Next, we need to add our `validationLevel` field:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We need to add a constructor, in which we attach the `ExternalErrors_CollectionChanged`
    event handler to the `CollectionChanged` event of the `ExternalErrors` collection
    property, as we did earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s add the familiar `ValidationLevel`, `Errors`, and `ExternalErrors`
    properties, along with the abstract `ValidateAllProperties` method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Note that in this implementation, users of our framework will no longer need
    to override the `Errors` property in order to ensure that their validatable properties
    are validated. While we still declare this property as virtual, so that it can
    be overridden if necessary, this base class implementation already compiles all
    validation errors into the internal collection, ready for display, and should
    replace the one that we copied from the previous base class.
  prefs: []
  type: TYPE_NORMAL
- en: This time, we initialize a new local `errors` collection with all of the unique
    errors from each property error collection in the `AllPropertyErrors` property
    `Dictionary` object. We then add any errors from the `ExternalErrors` collection,
    if they do not already exist in the `errors` collection. This string `Errors`
    collection is primarily used because it is convenient to data bind to in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: After the new `Errors` property, we see the `ExternalErrors` auto property with
    its initializer and the abstract `ValidateAllProperties` method that needs to
    be implemented in the derived classes and can be called to force a new validation
    pass, either pre-emptively, or on the click of a save button, once all fields
    have been filled. We'll see an example implementation of this shortly.
  prefs: []
  type: TYPE_NORMAL
- en: 'Returning to our base class now, after the `ValidateAllProperties` method,
    we need to declare a couple of `Validate` methods, to replace the one from the `BaseNotifyValidationModel` class. The
    first of these is a convenience method that accepts any number of property name
    input parameters and simply calls the second method once for each property name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: In the `Validate` method, if the `ValidationLevel` property is set to the `None` member,
    we perform no validation and return from the method immediately. Otherwise, we
    retrieve the data annotation-related validation errors, as described earlier, in
    the *Annotating data* section.
  prefs: []
  type: TYPE_NORMAL
- en: We then filter just the errors that relate to the property that is specified
    by the `propertyName` input parameter and concatenate them with the collection
    of errors returned from the `this` indexer property. We end by passing the compiled
    collection, containing all of the errors, along with the `propertyName` input
    parameter, to the unchanged `UpdateErrors` method from our `BaseNotifyValidationModel` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to add the `ExternalErrors_CollectionChanged` method, that is
    now referenced in the constructor. It simply notifies changes to the `Errors`
    collection property and the `HasError` property, so that they will be updated
    in the UI each time an external error is added or removed:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'The `HasErrors` property can be used to set the visibility of a collection
    control in the UI so that it can display the complete collection of errors, whenever
    any exist, and hide it when there are none. The last change that we need to make
    is to add an additional condition to the `HasErrors` property, which listens out
    for external errors, as well the internally generated ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: Now, our base validation class will manage errors that are defined in the indexer
    of each derived class, along with those defined in any data annotation attributes that
    may decorate the class properties and also those generated by external View Models.
    Let's now see how we can use this.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s first duplicate our `ProductNotify` class, rename it to `ProductNotifyExtended`,
    and make it extend our new `BaseNotifyValidationModelExtended` base class. We''ll
    then need to make these following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: This new data Model is the same as the duplicated one, other than the name,
    the base class, the `ValidateAllProperties` method, and the addition of the extra
    condition to the `this` indexer, which was discussed in the previous section.
  prefs: []
  type: TYPE_NORMAL
- en: The `ValidateAllProperties` method calls the `Validate` method of the base class,
    passing in the names of the `Name` and `Price` properties, and can be called from
    a View Model to validate those two properties at any time. The `this` indexer
    has been updated according to the example from the previous section, to enable
    the `ValidationLevel` property to play its part in the validation process.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s create a `ProductNotifyViewModelExtended` class by duplicating
    and renaming the `ProductNotifyViewModel` class and making the following changes:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: First, we replace all instances of the `ProductNotify` class with the `ProductNotifyExtended` class,
    and all instances of the `ProductsNotify` class with the `ProductsNotifyExtended` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ProductsNotifyExtended` class is the standard wrapper for encapsulating
    our `BaseCollection` class'' functionality:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The final change in the `ProductNotifyViewModelExtended` class is to alter the
    values of the second data item in the constructor to those shown in the new example. Let's
    also create a new `ProductNotifyViewExtended` class from our `ProductNotifyView` class
    by simply duplicating and renaming it. No other changes to it are required at
    this point.
  prefs: []
  type: TYPE_NORMAL
- en: 'After wiring up the View and View Model in the `App.xaml` file and running
    this example, we can see that, like our `BaseValidationModelExtended` example,
    this implementation also enables us to display multiple validation errors per
    property in our global error output collection control:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ef2fd29-6b5b-4d52-8ea0-2fe4a8eac54d.png)'
  prefs: []
  type: TYPE_IMG
- en: Let's now examine how we can customize the way in which we highlight these validation
    errors to users.
  prefs: []
  type: TYPE_NORMAL
- en: Customizing the error template
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to the essential `Errors` and `HasError` properties, the `Validation`
    class also declares an `ErrorTemplate` Attached Property of the `ControlTemplate` type. The
    default template assigned to this property is responsible for defining the red
    rectangle that surrounds UI fields that have validation errors associated with
    them.
  prefs: []
  type: TYPE_NORMAL
- en: However, this property enables us to change this template and so, we are able
    to define how validation errors are highlighted to the application users. As this
    property is an Attached Property, this effectively means that we could apply a
    different template to be displayed for each control in the UI. However, this cannot
    be recommended because it could make the application look less consistent.
  prefs: []
  type: TYPE_NORMAL
- en: This template actually uses an `Adorner` element to render its graphics in the
    adorner layer, on top of the related control in error. Therefore, in order to
    specify where our error visual(s) should be rendered in relation to the related
    control, we need to declare an `AdornedElementPlaceholder` element in the error
    template.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s take a look at a simple example, where we define a slightly thicker,
    non-blurry border, unlike the default one, and paint over the background of the
    related control with feint red for added emphasis. We first need to define a `ControlTemplate`
    object in a suitable resource section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we declare the `AdornedElementPlaceholder` element inside a
    `Border` element, so that the border will be rendered around the outside of the
    related control. Note that without declaring this `AdornedElementPlaceholder`
    element, our border would resemble a tiny red dot in the top left of the related
    control when an error occurred.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let''s see how we apply this template, using our earlier example of the
    control that was data bound to the `Product.Price` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let''s see what it looks like when rendered:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/a7dad1ca-1f85-42a2-96ae-e9a1971b7f20.png)'
  prefs: []
  type: TYPE_IMG
- en: 'If we wanted to position our error highlighting elements in a different position
    with relation to the related control in error, we could use one of the panels
    to position them. Let''s take a look at a slightly more advanced error template
    that we could use. Let''s begin by declaring some resources in a suitable resource
    section:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we declare a `ToolTip` resource named `ValidationErrorsToolTip`.
    In it, we declare an `ItemsControl` element to display all of the validation errors
    together. We define a `DataTemplate` element in the `ItemTemplate` property, which
    will output the value of the `ErrorContent` property of each `ValidationError`
    object in the `Validation.Errors` collection. This collection will be implicitly
    set as the data context of the control template.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we declare a `ControlTemplate` element to set to the `ErrorTemplate` property,
    with the `WarningErrorTemplate` key. In it, we define a horizontal `StackPanel`
    control and, within that, we declare the required `AdornedElementPlaceholder`
    element. This is followed by the warning icon, taken from the Visual Studio icon
    set, that was discussed in [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml), *Creating
    Visually Appealing User Interfaces*, with the `ValidationErrorsToolTip` resource
    applied to its `ToolTip` property.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply this template using the `ErrorTemplate` property as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: 'When a validation error now occurs on this `TextBox` control, it will look
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/62127b07-35d2-4b77-a551-486c2eace818.png)'
  prefs: []
  type: TYPE_IMG
- en: Now that we've investigated a variety of ways to display our validation errors,
    let's move on to explore how we can avoid UI-based validation errors altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Avoiding UI-based validation errors
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the last example from the previous section, we data bound the entire `Validation.Errors`
    collection to a tooltip in the error template for our `TextBox` control. We also
    data bound our own `Errors` collection from our base class to the `ItemsControl`
    element above the form fields.
  prefs: []
  type: TYPE_NORMAL
- en: 'Our `Errors` collection can display all of the errors for all of the properties
    in each data Model. However, the `Validation.Errors` collection has access to
    UI-based validation errors that never make it back to the View Models. Take a
    look at the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/5c519c13-cfcf-4ea7-8e84-df346068215d.png)'
  prefs: []
  type: TYPE_IMG
- en: The UI-based validation error says Value '0t' could not be converted, and that
    explains why the View Models never see this error. The type of value expected
    in the data bound property is `decimal`, but an unconvertible value has been entered.
    Therefore, the input value cannot be converted to a valid `decimal` number and
    so, the data bound value is never updated.
  prefs: []
  type: TYPE_NORMAL
- en: However, the `Validation.Errors` collection is a UI element, and each data bound
    control has its own collection, and so we have no simple way to access them all
    from our View Model classes. Furthermore, the `ValidationError` class is in the
    `System.Windows.Controls` UI assembly, so we don't want to add a reference of
    that to our `ViewModels` project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of trying to control the UI-based validation errors from the View Models,
    we can alternatively extend controls, or define Attached Properties that restrict
    the ability of the users to enter invalid data in the first place, thereby avoiding
    the need for UI-based validation. Let''s take a look at one way in which we can
    modify a standard `TextBox` control, so that it will only accept numerical input,
    using our `TextBoxProperties` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: Excluding the other, existing members from our `TextBoxProperties` class, we
    first declare the `IsNumericOnly` Attached Property and its related getter and
    setter methods and attach the `OnIsNumericOnlyChanged` handler.
  prefs: []
  type: TYPE_NORMAL
- en: In the `OnIsNumericOnlyChanged` method, we first cast the `dependencyObject`
    input parameter to a `TextBox` element and then cast the `NewValue` property of
    the `DependencyPropertyChangedEventArgs` class to the `bool` `newIsNumericOnlyValue`
    variable.
  prefs: []
  type: TYPE_NORMAL
- en: If the `newIsNumericOnlyValue` variable is `true`, we attach our event handlers
    for the `PreviewTextInput`, `PreviewKeyDown`, and `DataObject.Pasting` events.
    If the `newIsNumericOnlyValue` variable is `false`, we detach the handlers.
  prefs: []
  type: TYPE_NORMAL
- en: We need to handle all of these events in order to create a `TextBox` control
    that can only enter numerical values. The `UIElement.PreviewTextInput` event is
    raised when a `TextBox` element receives a text input from any device, the `Keyboard.PreviewKeyDown`
    event occurs specifically when a keyboard key is pressed, and the `DataObject.Pasting`
    event is raised when we paste from the clipboard.
  prefs: []
  type: TYPE_NORMAL
- en: The `TextCompositionEventArgs` object in the `TextBox_PreviewTextInput` handler
    method only provides us with the last typed character through its `Text` property,
    along with `TextComposition` details. At the stage that this tunneling event is
    called, the `Text` property of the relevant `TextBox` control is not yet aware
    of this latest character.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, in order to correctly validate the whole entered text value, we need
    to combine the existing value with this new character. We do that in the `GetFullText`
    method and pass the returned value to the `IsTextValid` method.
  prefs: []
  type: TYPE_NORMAL
- en: We then set the inverted return value of the `IsTextValid` method to the `Handled`
    property of the `TextCompositionEventArgs` input parameter. Note that we invert
    this `bool` value, because setting the `Handled` property to `true` will stop
    the event from being routed any further and result in the latest character not
    being accepted. Therefore, we do this when the input value is invalid.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we see the `TextBox_PreviewKeyDown` event handler method, and in it, we
    again start by casting the `sender` input parameter to a `TextBox` instance. We
    specifically need to handle this event, because the `PreviewTextInput` event does
    not get raised when the *Space bar*, *Delete*, or *Backspace* keys on the keyboard
    are pressed.
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, we stop the event being routed any further by setting the `Handled`
    property of the `KeyEventArgs` input parameter to `true` if the pressed key is
    the *Space bar* key, or if the length of the entered text is a single character
    and the *Delete* or *Backspace* key is pressed; this stops the user from deleting
    the last character from the `TextBox` control, which would result in a UI-based
    validation error.
  prefs: []
  type: TYPE_NORMAL
- en: However, if the user was trying to delete the last character because it was
    incorrect and they wanted to replace it with a different value, this could be
    awkward. Therefore, in this situation, we replace the last character with a zero
    and place the caret position after it, which then enables the user to type a different
    value. Note our extra condition that clears the text if the input is `0`, so that
    it will be replaced with the typed character.
  prefs: []
  type: TYPE_NORMAL
- en: In the `TextBox_Pasting` handler method, we check whether the `DataObject` property
    that is accessed from the `DataObjectPastingEventArgs` input parameter has any
    `string` data available, and call its `CancelCommand` method to cancel the paste
    operation if not.
  prefs: []
  type: TYPE_NORMAL
- en: If `string` data is present, we cast the `sender` input parameter to a `TextBox`
    instance and then pass the data from the `DataObject` property to the `GetFullText`
    method to reconstruct the whole entered string. We pass the reconstructed text
    to the `IsTextValid` method and, if it is invalid, then we call the `CancelCommand`
    method to cancel the paste operation.
  prefs: []
  type: TYPE_NORMAL
- en: Next is the `GetFullText` method, where the entered text from the `TextBox` element is
    reconstructed. In this method, if any text is selected in the `TextBox` control,
    we rebuild the string by concatenating the portion of text before the selection
    with the newly entered or pasted text and the portion of text after the selection.
    Otherwise, we use the `Insert` method of the `String` class, along with the `TextBox` control's
    `SelectionStart` property, to insert the new character into the appropriate place
    in the string.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the end of the class, we see the `IsTextValid` method, which simply returns
    the `Success` property value of the `Regex.Match` method. The regular expression
    that we validate with is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: The ampersand (`@`)marks the string as a Verbatim String Literal, which is useful
    when using characters that normally need to be escaped, the caret (`^`) signifies
    the start of the input line, `\d*` indicates that we can have zero or more numerical
    digits, `\.?` specifies that zero or one periods are then valid, `\d*` again indicates
    that we can then have zero or more numerical digits, and finally, `$` signifies
    the end of the input line.
  prefs: []
  type: TYPE_NORMAL
- en: 'When attached to an ordinary `TextBox` control, we can now only enter numeric
    values, but both integer and decimal values are allowed. Note that this particular
    implementation does not accept the minus sign, as we don’t want to allow negative
    prices, but that could be easily changed. Using our earlier `ProductNotifyViewExtended`
    example, we can attach our new property like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: Keeping Synchronized with Legacy Behavior
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Those of you who have been experimenting with our various `Product`-related
    examples may have noticed something peculiar occurring when attempting to enter
    a price. In .NET 4.5, Microsoft decided to introduce a breaking change to the
    way that data is entered in the `TextBox` control, when the binding `UpdateSourceTrigger`
    value is set to `PropertyChanged`.
  prefs: []
  type: TYPE_NORMAL
- en: From .NET 4.5, we can no longer enter a numerical separator, neither a period
    nor a comma, when we have data bound the `TextBox.Text` property to a `float`,
    `double`, or `decimal` data type. The reason why they did this was because previously,
    the value displayed in the `TextBox` control would get out of sync with the data
    bound value, at the moment when the user types a non-numerical character.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s investigate this situation; A user wants to enter `0.99` and, after the
    second character, the input value of `0.` is sent back to the data bound View
    Model. But as it is not a valid decimal value, it is therefore parsed to `0` and
    that value is sent back to the data bound `Textbox` element to be displayed. Therefore,
    the second character, the decimal point, is removed from the `Text` field.
  prefs: []
  type: TYPE_NORMAL
- en: Unfortunately, this change means that users can no longer directly type decimal
    places into a `TextBox` control when the `UpdateSourceTrigger` property is set
    to `PropertyChanged`. This can be seen in our `ProductView` example, where there
    is simply no way to enter a valid value with decimal places in the `TextBox` control
    labeled `Price`.
  prefs: []
  type: TYPE_NORMAL
- en: There are a number of ways to get around this issue, but none of them are perfect.
    One simple way is to set the `Mode` property on the `Binding` element to the `OneWayToSource`
    member, to stop the value being returned from the View Model, although this will
    also stop any initial default values being sent as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'When this breaking change was announced in .NET 4.5, a new property was introduced
    along with the change; The `KeepTextBoxDisplaySynchronizedWithTextProperty` property
    was added to the `FrameworkCompatibilityPreferences` class and specifies whether
    a `TextBox` control should display the same as its data bound property value.
    If we set this to `false`, it should return the previous behavior:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'Note that we need to set this property very early in the application lifetime,
    such as in the constructor of the `App.xaml.cs` file. Once set, it cannot be changed.
    Another way to avoid this problem is to set the `UpdateSourceTrigger` property
    to any value other than `PropertyChanged`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: However, this is no use if we want to validate pre-emptively, or want our data
    source to update with each key press. Alternatively, we could simply data bind
    a `string` property to our `TextBox` control and perform our own number parsing
    in our View Model. This is perhaps the best solution from a user’s point of view,
    as it would enable them to type their values with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option would be to utilize the `Delay` property of the `Binding` class,
    that we discussed in [Chapter 4](2eb41601-2339-4ac5-96bc-b87aa99eb157.xhtml),
    *Becoming Proficient with Data Binding*. If we set this to a figure of just a
    few hundred milliseconds, this would give the user enough time to enter their
    number, including the decimal point and the following digit(s), before the value
    is parsed to the data bound type:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs: []
  type: TYPE_PRE
- en: This is the option that we used in our examples, primarily because it is a quick
    and easy fix for this problem. However, care should be taken when using this method
    with actual monetary properties, as mistakes can easily be made if the user types
    slowly and does not pay attention to the entered value.
  prefs: []
  type: TYPE_NORMAL
- en: As always with WPF, there are a number of different ways to implement any solution.
    As we just saw in the previous section, there are also other ways to stop users
    from entering invalid data in the first place; we could build, or make use of
    a third-party numeric up/down control, enable users to enter time values using
    a custom clock control, or even use combo boxes to restrict the values that users
    can select to a set of allowable values.
  prefs: []
  type: TYPE_NORMAL
- en: Amalgamating validation and visuals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's now utilize some of the techniques that we discussed in [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml), *Creating
    Visually Appealing User Interfaces*, to design a visually appealing user interface
    that highlights validation errors in a novel way, using our glowing example. For
    this example, we want the ability to know when the data has changed, so we'll
    need to extend our earlier `BaseSynchronizableDataModel` class in another new
    base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s duplicate our `BaseNotifyValidationModelExtended` class so as to create
    a new `BaseNotifyValidationModelGeneric` class, and make it extend our synchronizable
    base class. In doing so, we will also need to make it generic and add the same
    generic constraints for the `T` generic type parameter from the base class to
    its declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs: []
  type: TYPE_PRE
- en: 'We''ll need to remove the copied implementation of the `INotifyPropertyChanged` interface
    and make use of the existing implementation from the `BaseSynchronizableDataModel` class
    instead. We''ll also need to implement the new base class'' required members in
    a new `ProductNotifyGeneric` class. Let''s start by duplicating the `ProductNotifyExtended` class,
    renaming it to `ProductNotifyGeneric`, and then adding these methods to the end
    of it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: First, we extend from our new generic `BaseNotifyValidationModelGeneric` class
    and implement all required members of the base class; the `CopyValuesFrom` method
    is used to make cloned copies of the data object, the `PropertiesEqual` method
    is used to compare its property values with other `ProductNotifyGeneric` instances,
    and the `ToString` method provides a useful textual output for the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have extended our `BaseNotifyValidationModelGeneric` class from
    our earlier `BaseSynchronizableDataModel` class and extended from this, in turn,
    in our `ProductNotifyGeneric` class, we can now create a new `ProductsNotifyGeneric` collection
    class to extend our earlier `BaseSynchronizableCollection` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: Let's now create a View Model for this new example, where we will use these
    new Models. We can start by duplicating the `ProductViewModelExtended` View Model
    and renaming it to `ProductNotifyViewModelGeneric`. We will need to replace all
    instances of the `ProductExtended` class with our new `ProductNotifyGeneric` class,
    and all instances of the `ProductsExtended` collection class with the new `ProductsNotifyGeneric` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'After adding the two unchanged products from the previous View Model to it, we
    can now call the `Synchronize` method on our new `ProductsNotifyGeneric` collection
    in the constructor, in order to set the unchanged state of all of the contained
    data items:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: The only other change in the constructor is that we now call the base class
    `Validate` method on the current item, passing in the names of the `Name` and
    `Price` properties, which validates these fields in a pre-emptive manner, before
    the user has a chance to enter any data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The final thing that we need to add to this class is a number of methods that
    handle a command from the UI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: Here, we use our `ActionCommand` class to create an `ICommand` instance, which
    users can use to delete the selected item from the product collection in the UI.
    In the `CanDelete` method, we verify that the item to delete actually exists in
    the collection, but this can be replaced with your own condition. For example,
    you could check whether the item has any changes, or whether the current user
    has the correct security permission to delete objects. In the `Delete` method,
    we simply remove the selected item from the collection.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that our View Model is ready, let''s turn our attention to the accompanying
    View. For this, let''s create a new View and name it `ProductNotifyViewGeneric`. We''ll
    then need to supply some more resources to use in this example. Let''s start by
    adding two further glow brush resources to the application resources file, with
    the `GreenGlow` brush resource from [C*hapter 8*](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml),
    *Creating Visually Appealing User Interfaces*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now see the styles that use these brush resources:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: 'This first style is reusable and can be declared in the global application
    resources, while the following styles extend the first, are data Model-specific,
    and could be declared locally in our new `ProductNotifyViewGeneric` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: We declare the `ProductGlowStyle` style for our form rectangle, and the `ProductItemGlowStyle`
    style for our data items in the `Products` collection. The only differences can
    be found in the binding paths of the two data triggers.
  prefs: []
  type: TYPE_NORMAL
- en: In these styles, we add a `DataTrigger` element that sets the rectangle `Fill`
    property to the `GreenGlow` resource when the `HasChanges` property of the current
    item in the `Products` collection is `True`, and another that sets it to the `RedGlow`
    resource when the `HasErrors` property of the current item is `True`. As the trigger
    that highlights errors is declared after the one that highlights valid changes,
    this will override the first if both conditions are `True`, which is essential
    for this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we need to alter our default styles, which we added to the application
    resources for our first product example. Let''s add these new styles that are
    based on the original ones to our `ProductNotifyViewGeneric` class, so that they
    override the default ones:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: As these new styles are based on the previous ones, we keep the same attribute
    values, but add a further one to each style. The `WhiteLabelStyle` style sets
    the `Foreground` property to `White`, and the `ErrorFreeFieldStyle` style sets
    the `Validation.ErrorTemplate` Attached Property to `null`, as we will have other
    ways to highlight validation errors in this example.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now see the data template resource for the new `ProductNotifyGeneric` class,
    which makes use of our new `ProductItemGlowStyle` style, first ensuring that we
    have added a couple of XML namespace prefixes for our `DataModels` and `Views`
    projects:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: In this example, we reuse our double border technique from [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml),* Creating
    Visually Appealing User Interfaces*, so there's no need to examine that code again.
    Inside the borders, we declare a `Grid` panel, which contains a `Rectangle` element,
    that has our new `ProductItemGlowStyle` style applied to it, and another `Grid`
    panel to display each user's name and a couple of images.
  prefs: []
  type: TYPE_NORMAL
- en: These images are from the Visual Studio Image Library, which we discussed earlier,
    and we use the first to signify that these objects are products. The `VerticalAlignment`
    property of each of the three elements is set to `Center`, to ensure that they
    are all aligned vertically, and the `TextWrapping` property of the `TextBlock`
    element is set to `Wrap` in case any products have a long name.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the `ErrorTemplate` property of the `Validation` class has been set
    to `null` here in order to remove the default error template, which usually shows
    up as an unappealing red rectangle. As we make the entire object glow red when
    it has an error, there is no need for the default template to be displayed as
    well.
  prefs: []
  type: TYPE_NORMAL
- en: The second image specifies that each of these items can be deleted. Note that
    it is declared within a `Button` control, and while we have not attempted to style
    that button, it could also be given the double border treatment, or any other
    custom style. This button is optional, but has been included merely as an example
    of linking a command from the View Model to each data object.
  prefs: []
  type: TYPE_NORMAL
- en: Note that the binding path in the button's `Command` property uses a `RelativeSource`
    binding to reference the ancestor of the `ProductNotifyViewGeneric` type. In particular,
    it references the `DeleteCommand` property of the `DataContext` of the View, which,
    in our case, is an instance of our `ProductNotifyViewModelGeneric` class.
  prefs: []
  type: TYPE_NORMAL
- en: The `CommandParameter` property is then data bound to the entire data context
    of each data template, which means that the whole `ProductNotifyGeneric` data
    Model object will be passed through as the command parameter. Using our `ActionCommand`
    class, this is specified by the `action` and `canExecute` fields in the earlier
    example from our `ProductNotifyViewModelGeneric` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now that we have styled our `ProductNotifyGeneric` items in the `ListBox` control
    with this data template, there is something else that we can do to improve the
    look further; we can remove the default selection rectangle of the `ListBoxItem`
    elements that wrap our data Models. In .NET 3.5 and before, we could simply add
    some resources to a style for the `ListBoxItem` class that would do the job for
    us:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: 'However, from .NET 4.0 onward, this will no longer work. Instead, we now need
    to define a new `ControlTemplate` object for the `ListBoxItem` class that does
    not highlight its background when selected, or when the user''s mouse cursor is
    over it:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: To create the `ControlTemplate` element in this style, we first accessed the
    default template of the `ListBoxItem` class, as described in the *Modifying Existing
    Controls* section of [Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    *Using the Right Controls for the Job*, and then simply removed the triggers that
    colored the background. We then added it to a style with no `x:Key` directive,
    so that it will be implicitly applied to all `ListBoxItem` elements within scope.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we have the `ErrorBorderStyle` style, which styles the border of our
    global validation error display and uses our `BoolToVisibilityConverter` class
    to set the `Visibility` property to show the control when the `HasErrors` property
    of the current item in the `Products` collection is `True`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: 'Now that we''ve added all of the required resources for our View, let''s move
    on to see the XAML file in the `ProductNotifyViewGeneric` class that uses them:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: We use the same `Grid` panel as in the last example, with a `ListBox` control
    on the left and some form controls on the right. Note that we set the `HorizontalContentAlignment`
    property to `Stretch` on the `ListBox` control to ensure that its `ListBoxItem`
    elements stretch to fit its whole width.
  prefs: []
  type: TYPE_NORMAL
- en: On the right, we see the double borders and the `Rectangle` element that is
    painted with the glow color resource that we created in [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml),
    *Creating Visually Appealing User Interfaces*. Rather than hardcoding one particular
    color resource, as we did earlier, we instead apply our new `ProductGlowStyle`
    style to it, which will change the color with its data triggers, according to
    the validity of the data.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we have added an outer `Grid` panel, that contains only the glow rectangle
    and the original `Grid` panel, which now adds an outer margin to our form. The
    original panel remains much unchanged from the previous example, although the
    error display border now uses our new `ErrorBorderStyle` style and is displayed
    underneath the form fields, in acknowledgment that some users don't like their
    fields moving as errors appear and disappear.
  prefs: []
  type: TYPE_NORMAL
- en: The form fields also mostly remain the same, although when using our new implementation,
    we no longer need to set the `ValidatesOnNotifyDataErrors` property to `True`
    on each binding. We also apply our new `WhiteLabelStyle` and `ErrorFreeFieldStyle` styles
    to the form labels and fields, to color the label foreground white and to hide
    the default red error border when there are validation errors.
  prefs: []
  type: TYPE_NORMAL
- en: 'When running this View now, it would render the following visual output, with
    a red glow on the form and the item in error:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/f39840c4-cf84-421b-9a63-a8a9e9f1e86c.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After correcting the errors, we''ll see a green glow on the form and the edited
    item:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/7a0f8496-2a6f-4462-81a6-dc6f34d41b8e.png)'
  prefs: []
  type: TYPE_IMG
- en: 'After saving the changes, we''d need to call the `Synchronize` method on the
    `Products` collection again and then we''d see the following screenshot, where
    all objects are now painted with the default blue glow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/422e278f-b0d5-4657-85bc-26e4e964d378.png)'
  prefs: []
  type: TYPE_IMG
- en: In this way, we are able to use the color of the glow to clearly inform users
    of the state of the control at any given time.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we had a thorough look at the data validation options that
    the .NET Framework offers us, primarily concentrating on a variety of ways to
    implement the two available validation interfaces. We investigated the use of
    the data annotation validation attributes, explored the provision of custom error
    templates, and aggregated our new found knowledge with that from [Chapter 8](181b5dfe-2caa-4bad-a01b-9b37bb97f772.xhtml), *Creating
    Visually Appealing User Interfaces,* in order to build up a visually pleasing
    validation example.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we'll look at a number of ways in which we can provide
    users of our applications with a great user experience, from asynchronous programming
    to feedback mechanisms. We will also examine how to make use of application settings
    to provide user preferences and explore a variety of ways of supplying in-application
    help to the application users. We will end with a further look into additional
    ways of improving the user experience for end users.
  prefs: []
  type: TYPE_NORMAL
