<html><head></head><body>
        

                            
                    <h1 class="header-title">Securing RESTful Web Services</h1>
                
            
            
                
<p class="mce-root">In the world of web applications, where there are numerous request and response exchanges over HTTP, security is one of the most important cross-cutting concerns. Any unsecured service or web application can face datatampering issues.<br/></p>
<div><p>"Whenever data is modified (destroyed, manipulated, or edited) by an unauthorized channel, it is generally called data tempering."</p>
</div>
<p>Data can be tampered with when it is in transit or in another place. There might be several reasons why data is tampered with—unprotected data is the most common reason in the industry. To prevent such issues, you can protect your environment and application systems. Generally, a firewall is the best way to protect your environment (server). You can protect an application by implementing an authorization mechanism.</p>
<p>Unfortunately, data breaches of well-known sites are commonplace these days. Taking this into account, information and application security has become critical to web applications. For the same reason, secure applications should no longer be an afterthought. Security is everyone's responsibility in an organization.</p>
<p>In this chapter, we will mainly be focused on security and the REST and OWASP security standards. By the end of this chapter, you will understand the concepts of authentication, single sign-on (SSO), token-based authentication, and authentication using a proxy server (such as Azure API Management). We will cover the following topics:</p>
<ul>
<li>OWASP standards for web security</li>
<li>Securing RESTful web services</li>
<li>Authentication and authorization</li>
<li>Validations </li>
<li>Data encryption and storing sensitive data</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">OWASP security standards</h1>
                
            
            
                
<p>The <strong>Open Web Application Security Project</strong> (<strong>OWASP</strong>) is an online community that mainly works on web application security problems by creating various studies and standards. In this chapter, we will follow the security standards of OWASP that were released in 2017 (<a href="https://www.owasp.org/index.php/Top_10-2017_Top_10">https://www.owasp.org/index.php/Top_10-2017_Top_10</a>):</p>
<div><img src="img/968d6f59-d1c6-4c36-a56d-25182e578d50.png" style="width:32.92em;height:26.58em;"/></div>
<p>Application security risks</p>
<p>The preceding diagram is a pictorial overview of an application's security risks. It depicts how an attacker might attack a weaker application. The attacker attacks application components by injecting scripts (mostly JavaScript) and impacting the system. In this image, you will notice that only an unsecured portion of the web application is under attack. A secure system is safe, even after it has been attacked.</p>
<p>The following are application security risks as defined by OWASP:</p>
<ul>
<li>Injection</li>
<li>Broken authentication</li>
<li>Sensitive data exposure</li>
<li>XML external entities (XXE)</li>
<li>Broken access control</li>
<li>Security misconfiguration</li>
<li>Cross-site scripting (XSS)</li>
<li>Insecure deserialization</li>
</ul>
<p>These are high-alarmed security risks that should be handled in every web application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title"> Securing RESTful web services</h1>
                
            
            
                
<p>Before you start with learning about securing RESTful web services, I would like to tell you about security in the world of the web. In general, the phrase <em>security</em> describes the measures that are taken to make sure that everything is secure. But what does <em>everything</em> include here? Let's elaborate: security is a way or a process that stops unauthenticated and unauthorized access to confidential data over web applications.</p>
<div><p>The type of confidential data depends upon the nature of the web application—for example, if the web application is for medical and clinical services, then the confidential information consists of all the patients' data related to their tests, medical history, and so on.</p>
</div>
<p>The first step towards the creation of a security process is to authenticate and authorize access to the web application. If the request is not authenticated, then it should not be accepted by the system. It should also not be accepted if the request is authenticated, but not authorized to access the data of the web application.</p>
<p>The following diagram shows an overview of the authentication process, using Auth services:</p>
<div><img src="img/5fd52e96-be02-4c61-aeca-ced31340e984.png" style="width:50.42em;height:30.33em;"/></div>
<p>In the preceding diagram, you can think about a typical ASP.NET Core API system that uses Auth services as a middleware server. There may be several clients or consumers who are using these services and can request access to the data. Here, Auth services play an important role in authenticating incoming requests from clients. If the Auth service identifies the request as authenticated, it generates a token and sends it to the API servers for further processing. If the request is not an authenticated request, then the Auth service notifies the client of the failed authentication. The preceding image is just an overview of a typical scenario. An actual scenario could be more complex, with the use of one or more middleware backend servers (typical API management servers).</p>
<p>In the following sections, you will get a better idea of the following two important security concepts:</p>
<ul>
<li><strong>Authentication</strong>: Authentication is nothing but a process where a system verifies or identifies the incoming requests by some sort of credentials (generally a user ID and password). If the system finds that the provided credentials are wrong, then it notifies the user (generally via a message on the GUI screen) and terminates the authorization process.</li>
<li><strong>Authorization</strong>: Authorization always comes after authentication. It is a process that allows the authenticated user who raised the request to access resources or data after verifying they have access to the specific resources or data.</li>
</ul>
<p>From this, you can conclude that the security of RESTful services is the most important feature of the application.</p>
<div><p>How can you maintain sessions in RESTful web services?<br/>
RESTful web services work with the HTTP protocol, which is a stateless protocol (<a href="https://stackoverflow.com/questions/13200152/why-say-that-http-is-a-stateless-protocol">https://stackoverflow.com/questions/13200152/why-say-that-http-is-a-stateless-protocol</a>), and treat every request as a new request. There is no way in which the HTPP protocol helps to maintain sessions in RESTful web services. But, we can achieve this programmatically with the help of authenticated tokens. This technique is known as token-based authorization (we will discuss it in detail in the coming sections). With the help of this technique, you can authorize an authenticated user to allow data or resources for a predefined period of time.</p>
</div>
<p>Every request that comes via services or any other mode should be authenticated and authorized before the system responds to the user or the client that made the call. This process mainly includes the following:</p>
<ul>
<li><strong>Confidentiality</strong>: The secured system makes sure that any sensitive data is not exposed to unauthenticated and unauthorized access requests</li>
<li><strong>Availability</strong>: The security measures in the system make sure that the system is available for users who are genuine, as confirmed through the system's authentication and authorization mechanism</li>
<li><strong>Integrity</strong>: In a secured system, data tampering is not possible, so the data is secure</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">The vulnerable areas of an unsecured web application</h1>
                
            
            
                
<p>In today’s web applications, the main vulnerable assets to protect from unauthorized access are the resources and data. If a site is unsecured, then the chances of vulnerability are high. According to the official website at<a href="https://docs.microsoft.com/en-us/aspnet/core/security/"> https://docs.microsoft.com/en-us/aspnet/core/security/</a>, the following areas are the main threats to any unsecured web application.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Cross-site scripting attacks</h1>
                
            
            
                
<p>Cross-site scripting attacks—or XSS attacks—typically happen as a result of bad input, where an attacker injects client scripts (JavaScript in most cases) into the web page. According to the official web page (<a href="https://docs.microsoft.com/en-us/aspnet/core/security/cross-site-scripting">https://docs.microsoft.com/en-us/aspnet/core/security/cross-site-scripting</a>):</p>
<p>"Cross-Site Scripting (XSS) is a security vulnerability which enables an attacker to place client-side scripts (usually JavaScript) into web pages."</p>
<p>Here, I am using the example of a web client that consumes web services. You will learn more about web clients in <a href="9fcac4d2-710a-48a2-98be-ed0034525cee.xhtml">Chapter 10</a>, <em>Building a Web Client (Consuming Web Services)</em>.</p>
<p>The following screenshot shows a scenario where the Create screen is under attack:</p>
<div><img class="aligncenter size-full wp-image-951 image-border" src="img/36cad43d-568a-4d96-b78c-540f91b92e34.png" style="width:23.25em;height:17.58em;"/></div>
<p>The preceding screenshot is a representation of an unsecure web application. Here, the user can inject the script tag, and when the user clicks on Create, it is posted back to the server.</p>
<p>The following screenshot shows the code's debug mode, where we can see that our system is accepting script data:</p>
<div><img src="img/a485f149-a9f6-46d9-ab47-4767482077c4.png"/></div>
<p>The preceding screenshot shows how it was posted to the server and was eventually saved in the database or any persistent repository.</p>
<p>The following screenshot shows the affected page:</p>
<div><img class="aligncenter size-full wp-image-952 image-border" src="img/a2f4336f-308f-4be5-97de-5cb9a92d72ab.png" style="width:41.17em;height:21.25em;"/></div>
<p>Whenever anyone accesses a page with affected data, it will show an alert, as shown in the preceding screenshot.</p>
<p>You can build a system that stops such attacks by applying a few code changes. I will cover this in the <em>Validations</em> section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">SQL injection attacks</h1>
                
            
            
                
<p>An SQL injection attack is one of the most severe attacks that directly target the database. This is first in the list of OWASP application security risks. Attackers can steal a system's secured data with the help of SQL injection.</p>
<p>The following diagram shows the process of SQL injection:</p>
<div><img src="img/38261ad4-2792-4435-90bd-476e9af7d479.png" style="width:45.67em;height:32.42em;"/></div>
<p>In the preceding diagram, you can see a typical SQL injection scenario where the attacker has injected an <kbd>or</kbd> clause to fetch all of the data of a particular table. The actual code instruction was to return a single record based on the <kbd>EmpId</kbd> from the employee table. But as it was injected with an extra phrase, it returns the complete records of the employee table. This is the biggest problem with an unsecured system. Here, the attacker injected a simple clause into the statement.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">What is cooking here?</h1>
                
            
            
                
<p>In the previous section, you saw an imaginary scenario and went through an SQL injection in action. Let’s look at an actual example by creating a RESTful product API using ASP.NET Core 2.0. Before you start building this application, bear in mind the following prerequisites for this application:</p>
<ul>
<li>Visual Studio 2017 update 3 or later</li>
<li>ASP.NET Core 2.0 or later</li>
<li>C#7.0 or later</li>
<li>Microsoft Entity Framework Core 2.0.0</li>
</ul>
<p>Go through the following steps to create our application:</p>
<ol>
<li>Open Visual Studio.</li>
<li>Select File | New | Project or press <em>Ctrl</em> + <em>Shift</em> + <em>F5</em>.</li>
<li>Select ASP.NET Core Web Application.</li>
<li>From the template window, select ASP.NET Core API. Make sure you select .NET Core 2.0.</li>
<li>Name the project, choose the path for the solution, and click OK.</li>
<li>Add the <kbd>Models</kbd> folder. In Solution Explore, right-click, select Add New Folder from the drop-down menu, and name it <kbd>Models</kbd>.</li>
<li>Add a new class under the <kbd>Models</kbd> folder. Right-click on the <kbd>Models</kbd> folder in Solution Explorer and select Add New Item | Class from the drop-down menu, or use <em>Shift</em> + <em>Alt</em> + <em>C</em>.</li>
</ol>
<div><p>Please note that the shortcut keys vary as per your settings for Visual Studio.</p>
</div>
<ol start="8">
<li>Name it <kbd>Product.cs</kbd>, and add the following code to this class:</li>
</ol>
<pre style="padding-left: 60px">namespace Chap08_02.Models<br/>{<br/>  public class Product<br/>  {<br/>    public Guid Id { get; set; }<br/>    public string Name { get; set; }<br/>    public string Description { get; set; }<br/>    public string Image { get; set; }<br/>    public decimal Price { get; set; }<br/>    public Guid CategoryId { get; set; }<br/>    public virtual Category Category { get; set; }<br/>  }<br/>}</pre>
<ol start="9">
<li>Repeat steps 7 and 8, adding <kbd>Category.cs</kbd> and <kbd>ProductViewModel.cs</kbd>.</li>
<li>Repeat step 6, adding the <kbd>Contexts</kbd> folder.</li>
<li>Add a new class under the <kbd>Contexts</kbd> folder. Right-click on the <kbd>Contexts</kbd> folder in Solution Explorer, select Add New Item, and in the dialog box, select Class, or use <em>Shift</em> + <em>Alt</em> + <em>C</em></li>
<li>Name it <kbd>ProductContext.cs</kbd>.</li>
<li>Now, open the <kbd>appsettings.json</kbd> file and add the following code:</li>
</ol>
<pre style="padding-left: 60px">"ConnectionStrings": <br/>{<br/>  "ProductConnection": "Data Source=.;Initial<br/>  Catalog=ProductsDB;Integrated  <br/>  Security=True;MultipleActiveResultSets=True"<br/>}</pre>
<ol start="14">
<li>Right-click on the project in Solution Explorer and select Manage NuGet Package.</li>
<li>Under NuGet Package Manager screen, search for <kbd>Swashbuckle.ASPNETCore</kbd> and install it.</li>
<li>Add a new folder called <kbd>Persistence</kbd>.</li>
<li>Add an <kbd>IProductRepository</kbd> interface under the <kbd>Persistence</kbd> folder.</li>
</ol>
<p> </p>
<ol start="18">
<li>Add the following code to the <kbd>IProductRepository</kbd> interface:</li>
</ol>
<pre style="padding-left: 60px">namespace Chap08_02.Persistence<br/>{<br/>  public interface IProductRepository<br/>  {<br/>    void Add(Product product);<br/>    IEnumerable&lt;Product&gt; GetAll();<br/>    IEnumerable&lt;Product&gt; GetByProduct(string id);<br/>    IEnumerable&lt;Product&gt; GetBy(string productName);<br/>    void Remove(string id);<br/>    void Update(Product product);<br/>  }<br/>}</pre>
<div><p>Refer to the GitHub repository link at <a href="https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core">https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core</a> for the complete source code.</p>
</div>
<ol start="19">
<li>Add the <kbd>ProductRepository.cs</kbd> class under the <kbd>Persistence</kbd> folder.</li>
<li>Add the following code to <kbd>ProductRepository.cs</kbd>:</li>
</ol>
<pre style="padding-left: 60px">public IEnumerable&lt;Product&gt; GetByProduct(string id) =&gt; _context.Products.FromSql("SELECT * FROM dbo.Products WHERE id="+ id).Include(p =&gt; p.Category)<br/>    .ToList();</pre>
<ol start="21">
<li>Open the <kbd>Startup.cs</kbd> file and add the following code:</li>
</ol>
<pre style="padding-left: 60px">services.AddScoped&lt;IProductRepository, ProductRepository&gt;();<br/>services.AddDbContext&lt;ProductContext&gt;<br/>(<br/>  o =&gt; o.UseSqlServer<br/>  (<br/>    Configuration.GetConnectionString("ProductConnection")<br/>  )<br/>);<br/>services.AddSwaggerGen<br/>(<br/>  swagger =&gt;<br/>  {<br/>    swagger.SwaggerDoc("v1", new Info { Title = "Product APIs",  <br/>    Version = "v1" <br/>  });<br/>});</pre>
<ol start="22">
<li>Now, you are ready to play with the application. Run the application from the menu or hit <em>F5</em>. In the web browser, add the <kbd>/swagger</kbd> suffix to the URL in the address bar, as shown in the following screenshot:</li>
</ol>
<div><img class="aligncenter size-full wp-image-953 image-border" src="img/f302dc09-ab8e-4e5d-ad35-c2c073964838.png" style="width:18.67em;height:2.83em;"/></div>
<p style="padding-left: 60px">It will show the Swagger API documentation, as shown in the following screenshot:</p>
<div><img class="aligncenter size-full wp-image-954 image-border" src="img/54ba2a0c-fe5e-482b-853b-fad4f7aab778.png" style="width:83.50em;height:44.25em;"/></div>
<p>Swagger documentation for the Product APIs</p>
<p>I used Swagger for the documentation and to test API calls. You can use other API test clients, such as Advanced Rest Client and PostMan.</p>
<ol start="23">
<li>To test our unsecured code, click on the <kbd>GET</kbd> <kbd>/api/product/{productid}</kbd> resource and pass the product ID, as shown in the following screenshot:</li>
</ol>
<div><img class="aligncenter size-full wp-image-955 image-border" src="img/5b575d5b-c23a-4634-8eaf-0c4080a53e49.png" style="width:80.92em;height:26.83em;"/></div>
<ol start="24">
<li>Click Execute. You should see the following expected output:</li>
</ol>
<div><img class="aligncenter size-full wp-image-957 image-border" src="img/5dc3b253-3137-4adf-91e4-28b1ee7ab72f.png" style="width:57.08em;height:32.42em;"/></div>
<p>Now, let's try to add the <kbd>OR</kbd> clause and see what happens. Here, I am entering the <kbd>productid</kbd> value as <kbd>4D261E4A-A657-4ADD-A0F6-DDE6E1464D55</kbd> or <kbd>1=1</kbd>. Execute it and look at the result:</p>
<div><img class="aligncenter size-full wp-image-958 image-border" src="img/acaaa4aa-09b4-45c1-8e0e-b4a20bf55a14.png" style="width:29.67em;height:23.33em;"/></div>
<p>Here, we can see that our application is affected by SQL injection. You are seeing all the records from the table. It happened because of the raw SQL query (refer to <a href="https://docs.microsoft.com/en-us/ef/core/querying/raw-sql">https://docs.microsoft.com/en-us/ef/core/querying/raw-sql</a> for more information) that we are using. You can find the reason for the earlier results after looking closer at the code. The following screenshot will remind you what the request URL was:</p>
<div><img class="aligncenter size-full wp-image-959 image-border" src="img/793b6f47-ed4b-4448-9a62-4ea52998664a.png" style="width:48.58em;height:5.25em;"/></div>
<p>This is the injected URL. When our repository's <kbd>GetByProduct(string id)</kbd> method executed, it created the following raw SQL query:</p>
<pre>SELECT [p].[Id], [p].[CategoryId], [p].[Description], [p].[Image], [p].[Name],<br/> [p].[Price],[p.Category].[Id],[p.Category].[Description], [p.Category].[Name]<br/>FROM (SELECT * FROM dbo.Products WHERE id='4D261E4A-A657-4ADD-A0F6-DDE6E1464D55' or 1=1) AS [p] <br/>INNER JOIN [Categories] AS [p.Category] ON [p].[CategoryId] = [p.Category].[Id]</pre>
<p>This shows that the attacker did the job very smartly and quietly. Our unsecured code bled and returned the entirety of the data of the targeted table. I used the SQL profiler (<a href="https://docs.microsoft.com/en-us/sql/tools/sql-server-profiler/sql-server-profiler">https://docs.microsoft.com/en-us/sql/tools/sql-server-profiler/sql-server-profiler</a>) to trace the queries.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Fixing SQL injection attacks</h1>
                
            
            
                
<p>There is nothing more dangerous than unsecured code. With unsecured code, the application is always in danger. Attackers can steal data at any time, forcefully manipulating things by tampering with requests.</p>
<div><p>Saineshwar Bageri has written 10 tips for creating a secure ASP.NET web application. You can read them at <a href="https://www.codeproject.com/Articles/1116318/Points-to-Secure-Your-ASP-NET-MVC-Applications">https://www.codeproject.com/Articles/1116318/Points-to-Secure-Your-ASP-NET-MVC-Applications</a>.</p>
</div>
<p>You can stop an SQL injection attack with the following two techniques:</p>
<ul>
<li><strong>Validations</strong>: We will discuss these later in the chapter.</li>
<li><strong>Using parameters in raw SQL queries</strong>: This is in addition to using a raw SQL query directly by concatenating values (refer to our example of unsecured code). In this way, you can rewrite the <kbd>GetByProduct(string id)</kbd> method as the following:</li>
</ul>
<pre style="padding-left: 60px">public IEnumerable&lt;Product&gt; GetByProduct(string id) =&gt; _context.Products <br/>    .FromSql("SELECT * FROM dbo.Products WHERE id={0}", id)<br/>    .Include(p =&gt; p.Category)<br/>    .ToList();</pre>
<p style="padding-left: 60px">The preceding code still contains a raw SQL query, but it is secure enough to handle any injected code. If you try the same parameter value we used earlier, then the modified code will not accept it. It will throw an exception, as shown in the following screenshot:</p>
<div><img class="aligncenter size-full wp-image-960 image-border" src="img/3aec9d30-804a-4095-a26a-f83a942b95cd.png" style="width:59.75em;height:23.83em;"/></div>
<div><p>You can also use string the interpolation syntax with a raw SQL query if your EF Core version is 2.0.0 or above. With string interpolation, the code looks like the following:</p>
<p><kbd>public IEnumerable&lt;Product&gt; GetByProduct(string id) =&gt; _context.Products</kbd><br/>
<kbd>.FromSql($"SELECT * FROM dbo.Products WHERE id={id}")</kbd><br/>
<kbd>.Include(p =&gt; p.Category)</kbd><br/>
<kbd>.ToList();</kbd></p>
</div>
<ul>
<li><strong>Data encryption</strong>: We will discuss this later in the chapter.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Cross-site request forgery</h1>
                
            
            
                
<p><strong>Cross-site request forgery</strong> (<strong>CRSF</strong>) can also be shortened to <strong>XSRF</strong>. This is a common attack where the attacker infuses an unwanted action while the client is interacting (request/response) with the hosted application. Generally, attackers use malicious code to influence the interaction.</p>
<div><p>Malicious code is scripting code that downloads onto a web browser and executes, even without the knowledge of the authenticated user. For details, refer to <a href="https://www.techopedia.com/definition/4013/malicious-active-content">https://www.techopedia.com/definition/4013/malicious-active-content</a>.</p>
</div>
<p>Attackers are very smart, and they use different platforms to provide spurious links to malicious code. These links are very similar to the domain (website) that is under attack. Financial websites are the main targets.</p>
<p>The following diagram depicts an XSRF attack:</p>
<div><img src="img/255cc01d-e689-42fc-a8d3-f7c365e5c71b.png" style="width:43.75em;height:24.50em;"/></div>
<p>Attackers could send a link via email, social media, or any other medium. When the user clicks on the link, he or she will be in the world of the attacker without knowing that it's a spurious site and not their intended site.</p>
<div><p>You can find the official web page at <a href="https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery">https://docs.microsoft.com/en-us/aspnet/core/security/anti-request-forgery</a>.</p>
<p>CSRF vulnerabilities are fundamentally a problem with the web app, not the end user.</p>
</div>
<p>To handle this kind of attack, you need to build a system that is secure and properly authenticated. I will walk you through the details in the coming section focusing on authentication.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Authentication and authorization in action</h1>
                
            
            
                
<p>Up until now, you have learned about the basics of authentication and authorization. In this section, you will see these two most important ways of securing an application in action.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic authentication, token-based authorization, and other authentications</h1>
                
            
            
                
<p>Whenever you’re talking about secured web services/web applications, you should think about the all the points I mentioned regarding authentication and authorization in the previous sections.</p>
<p>In this section, I’m going to discuss authentication and authorization at the implementation stage.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Basic authentication</h1>
                
            
            
                
<p>As is evident from the word <em>basic</em>, basic authentication involves a mechanism where the system asks for simple credentials (username and password) to authenticate or validate the user via incoming requests from the client to the web or application servers via RESTful web services (in our case, ASP.NET Core web APIs).</p>
<p>Consider the following diagram, which showcases basic authentication:</p>
<div><img src="img/56f71166-ffe5-435d-adff-942f05565884.png" style="width:53.67em;height:26.08em;"/></div>
<p>The preceding diagram is of the basic HTTP authentication that I'm going to implement in our code. Here, the request comes from the client to access resources that are protected (resources that are kept from public access). The request contains a username and password in its header at the service end, and the service checks whether it is a validate request or not by validating the username and password from its repository, usually a database store. The service returns the data in its response to the client if the user is validated; otherwise, it returns invalid credentials with HTTP status code 401.</p>
<div><p>You can find a complete list of HTTP status codes, along with their definitions, at <a href="https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html</a>.</p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">The security concerns of basic authentication</h1>
                
            
            
                
<p>Basic authentication, as its name suggests, is a very basic authentication mechanism, and is not too secure when it comes to stopping attackers. Here, I have jotted down the following security vulnerabilities in the authentication process:</p>
<ul>
<li><strong>Credentials</strong>: The required credentials are the most important security concern that could lead to security breaches, which could in turn further exploit the system's weak security.</li>
<li><strong>Request</strong>: Requests can be tampered with, and could lead to a big security breach; with basic authentication, every request carries the credentials (username and password), which can be tampered with and used to further exploit the system.</li>
<li><strong>Closing the browser session</strong>: There is a concern that should be high priority—there is no ability to log out from an application using the basic authentication method, unless the user closes the browser to destroy the browser session themselves.</li>
</ul>
<p class="mce-root">You can look at the official web page at <a href="https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/basic-authentication">https://docs.microsoft.com/en-us/aspnet/web-api/overview/security/basic-authentication</a> for more information.</p>
<p>"Basic authentication is also vulnerable to CSRF attacks. After the user enters credentials, the browser automatically sends them on subsequent requests to the same domain, for the duration of the session."</p>
<p>There might be more security concerns that make the basic authentication mechanism the weakest with respect to web application security.</p>
<div><p>Basic authentication leads to various security concerns. I am not going to showcase these using code examples of basic authentication, but if you still want to test the basic authentication mechanism, then I suggest that you extract the code from the forked GitHub repository at <a href="https://github.com/garora/Bazinga.AspNetCore.Authentication.Basic">https://github.com/garora/Bazinga.AspNetCore.Authentication.Basic</a>. </p>
</div>


            

            
        
    

        

                            
                    <h1 class="header-title">Token-based authorization</h1>
                
            
            
                
<p>I explained authorization in the earlier sections of this chapter, where you saw that authorization is the next step after authentication to access restricted resources.</p>
<p>Let's consider the following diagram, which depicts token-based authentication:</p>
<div><img src="img/7da675a0-34dc-4b93-a420-7ec91e588173.png" style="width:35.67em;height:45.67em;"/></div>
<p>The preceding diagram shows a token-based authentication. If the request is verified (depending upon the identification of the credentials), then the client sends a request with the credentials and the returned token. The client then stores this token. It then sends these tokens with the headers in every request until the token is valid. If it is authorized to access the secure resource, the server verifies the request check and responds with the data. In some cases, the client may request a new token or call a refresh token if the existing token expires.</p>
<p>Let’s add an <kbd>AuthRequet</kbd> model, as shown in our API project created in the previous sections:</p>
<pre>public class AuthRequest<br/>{<br/>  public string UserName { get; set; }<br/>  public string Password { get; set; }<br/>}</pre>
<p>Add a new <kbd>GenerateTokenController.cs</kbd> controller in the <kbd>Controller</kbd> folder. Here is our <kbd>GetToken</kbd> POST resource:</p>
<pre>[AllowAnonymous]<br/>[HttpPost]<br/>public IActionResult RequestToken([FromBody] AuthRequest request)<br/>{<br/>  //Kept it simple for demo purpose<br/>  var user = _loginRepository.GetBy(request.UserName, <br/>  request.Password);<br/>  if (user == null) return BadRequest("Invalid credentials.");<br/>  var token = new TokenUtility().GenerateToken<br/>  (<br/>    user.UserName, <br/>    user.Id.ToString());<br/>    return Ok(new<br/>    {<br/>      token = new JwtSecurityTokenHandler().WriteToken(token)<br/>    }<br/>  );<br/>}</pre>
<p>Did you notice the <kbd>[AllowAnonymous]</kbd>attribute in the preceding code? You will see it in later sections. In the preceding code, I simply validate the credentials, and if the credentials are valid, the <kbd>TokenUtility </kbd>middleware generates the token.</p>
<p>Here is the <kbd>TokenUtility</kbd> code:</p>
<pre>public JwtSecurityToken GenerateToken(string userName, string userId)<br/>{<br/>  var claims = new[]<br/>  {<br/>    new Claim(JwtRegisteredClaimNames.Sub, userName),<br/>    new Claim(JwtRegisteredClaimNames.Jti, userId)<br/>  };<br/>  var key = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(JwtKey));<br/>  var creds = new SigningCredentials(key, <br/>  SecurityAlgorithms.HmacSha256);<br/>  var token = new JwtSecurityToken(TokenIssuer,<br/>  TokenIssuer,<br/>  claims,<br/>  expires: DateTime.Now.AddMinutes(30),<br/>  signingCredentials: creds);<br/>  return token;<br/>}</pre>
<p>The preceding code is self-explanatory: it generates the token. In this code, I put <kbd>JwtKey</kbd> as a constant (for demonstration purposes only).</p>
<div><p>In production, <kbd>JwtKey</kbd> should be kept in the environment variable (for security reasons) and can be easily accessible, as in, for example, <kbd>string jwtKey = Environment.GetEnvironmentVariable("JwtKey");</kbd>.</p>
</div>
<p>I am not going to discuss the repository model and other such approaches as these are self-explanatory. You can extract the entire source code from the GitHub repository at <a href="https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core">https://github.com/PacktPublishing/Building-RESTful-Web-Services-with-DotNET-Core</a>.</p>
<p>To enable token-based authentication, you need to make a few changes in the <kbd>startup.cs</kbd> file by inserting <kbd>Add app.UseAuthentication();</kbd> in the <kbd>Configure</kbd> method before <kbd>app.UseMvc();</kbd>.</p>
<p>In the <kbd>ConfigureService</kbd> method, add the following code:</p>
<pre>services.AddAuthentication()<br/>.AddJwtBearer(cfg =&gt;<br/>{<br/>  cfg.RequireHttpsMetadata = false;<br/>  cfg.SaveToken = true;<br/>  cfg.TokenValidationParameters = new TokenValidationParameters()<br/>  {<br/>    ValidIssuer = "gaurav-arora.com",<br/>    ValidAudience = "gaurav-arora.com",<br/>    IssuerSigningKey = new <br/>    SymmetricSecurityKey<br/>    (<br/>      Encoding.UTF8.GetBytes("abcdefghijklmnopqrstuvwxyz")<br/>    )<br/>  };<br/>});</pre>
<p>Build and run the project. Let's do a simple test using the Swagger documentation, as shown in the following screenshot:</p>
<div><img class="aligncenter size-full wp-image-961 image-border" src="img/3bc17fec-d7e0-4571-8c5f-c54336168189.png" style="width:62.42em;height:51.08em;"/></div>
<p>This will give the token upon a valid request:</p>
<div><img class="aligncenter size-full wp-image-962 image-border" src="img/c572606c-1b51-4994-9717-94586ec3144d.png" style="width:97.92em;height:7.42em;"/></div>
<p>We will make a complex authorization process to access resources depending on the roles and access levels of the users in the coming sections.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Other authentication methods</h1>
                
            
            
                
<p>Apart from basic and token-based authentications, you can also go with other available authentication mechanisms (we will not discuss these in detail, as they are beyond the scope of this book). IdentityServer4 is one of the most famous authentication servers and enables authentication as a service, single sign-in/sign-out, and many more options (refer to <a href="https://identityserver4.readthedocs.io/en/release/">https://identityserver4.readthedocs.io/en/release/</a> for more information).</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Securing services using annotations</h1>
                
            
            
                
<p>ASP.NET Core provides various ways to make secure application annotations (data annotations). This option is one of the ways in which we can secure our models for a web application. Data annotations provide a way to validate the inputs at the client end or the server end.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Validations</h1>
                
            
            
                
<p>It is self-explanatory from the name <em>validations</em> that they are nothing but validators of user/client inputs. The user input can be validated at the client end or at the API end (server side). In RESTful services, you can validate the input using model validations with the help of data annotations.</p>
<div><p>If the model is validated, this does not guarantee that data that comes with the request is safe.</p>
</div>
<p>In this section, we will rewrite our model used in the code example of the previous section.</p>
<p>Here is the modified <kbd>ProductViewModel</kbd> code:</p>
<pre>public class ProductViewModel<br/>{<br/>  public Guid ProductId { get; set; }<br/>  [Required]<br/>  public string ProductName { get; set; }<br/>  [Required]<br/>  public string ProductDescription { get; set; }<br/>  public string ProductImage { get; set; }<br/>  [Required]<br/>  public decimal ProductPrice { get; set; }<br/>  [Required]<br/>  public Guid CategoryId { get; set; }<br/>  public string CategoryName { get; set; }<br/>  public string CategoryDescription { get; set; }<br/>}</pre>
<div><p>Do not forget to include the <kbd>System.ComponentModel.DataAnnotations</kbd> namespace while using annotations.</p>
</div>
<p>In the preceding code, I used a very simple annotation, the <kbd>required</kbd> attribute. This makes sure that our model has the required properties.</p>
<p>Here is our <kbd>Post</kbd> resource to add a new product item:</p>
<pre>[HttpPost]<br/>[Route("addproduct")]<br/>public IActionResult Post([FromBody] ProductViewModel productvm)<br/>{<br/>  if (productvm == null)<br/>  return BadRequest();<br/>  var productModel = ToProductModel(productvm);<br/>  _productRepository.Add(productModel);<br/>  return StatusCode(201, Json(true));<br/>}</pre>
<p>Compile the application and run it to test the impact of the data annotation on our model. This time, you can try this using PostMan (<a href="https://getpostman.com/">https://getpostman.com/</a>) to test the API.</p>
<p>The following screenshot shows the <kbd>addproduct POST</kbd> resource; the <kbd>/api/product/addproduct</kbd> API is used to save the product:</p>
<div><img src="img/082343cc-d355-40bb-bb86-3629f41e0058.png"/></div>
<p>POST request using Swagger</p>
<p>The preceding input is valid; you have supplied all the required values. Let’s remove <kbd>Price</kbd> and <kbd>ProductName</kbd>. You will see that there is no change while you execute the request, even without supplying the required values. Here, the validation failed. The reason why these data annotations did not affect the process is that you did not direct the system to validate the input. To validate the input, you should tell the system explicitly what you want to validate, for example, the model state. We will fix this with the help of filters in the coming section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Securing context</h1>
                
            
            
                
<p>With the help of the <kbd>filter</kbd> attribute, you can implement security at the context level. In this section, we will rewrite our model and API resources to implement filters/attributes.</p>
<p>In the previous section, we used the <kbd>Required</kbd> attribute with our <kbd>Product</kbd> model, and this did not work for us. In this section, we will fix the problem with the help of filters (for more information on filters, go to <a href="https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters">https://docs.microsoft.com/en-us/aspnet/core/mvc/controllers/filters</a>).</p>
<p>Lets add a custom filter that validates the input, detecting whether any of the required fields are missing. If they are, it will just throw an exception. You need to modify the previous code, changing the <kbd>Product</kbd> model to the following:</p>
<pre>[Required(ErrorMessage = "Product Name shoud not be empty.")]<br/>public string ProductName { get; set; }</pre>
<p>Simply add <kbd>ErrorMessage</kbd> in the required <kbd>ProductName </kbd>field; the rest of the properties of the model remain unchanged.</p>
<p>Now, add a new <kbd>Filters </kbd>folder in the project from Solution Explorer. To do this, go through the steps we followed in the previous section on <em>SQL injections </em>and add a new class in this folder named <kbd>ValidateInputAttribute.cs</kbd> using the following code:</p>
<pre>namespace Chap08_04.Filters<br/>{<br/>  public class ValidateInputAttribute : ActionFilterAttribute<br/>  {<br/>    public override void OnActionExecuting(ActionExecutingContext <br/>    context)<br/>    {<br/>      if (!context.ModelState.IsValid)<br/>      context.Result = new BadRequestObjectResult<br/>      (context.ModelState);<br/>    }<br/>  }<br/>}</pre>
<p>Apply this filter as an attribute to the <kbd>Post</kbd> resource to add the product. Our code should look like the following:</p>
<pre>[HttpPost]<br/>[Route("addproduct")]<br/>[ValidateInput]<br/>public IActionResult Post([FromBody] ProductViewModel productvm)<br/>{<br/>  if (productvm == null)<br/>  return BadRequest();<br/>  var productModel = ToProductModel(productvm);<br/>  _productRepository.Add(productModel);<br/>  return StatusCode(201, Json(true));<br/>}</pre>
<p>Run the application and enter the new product values without the product name, as shown in the following screenshot:                             </p>
<div><img class="aligncenter size-full wp-image-964 image-border" src="img/cf7edee1-eb93-4c37-a418-d3be5841ce85.png" style="width:85.33em;height:42.67em;"/></div>
<p>Process the request and look at the response from the server, shown in the preceding screenshot. The request will not be processed, and a response will come from the server notifying you of a bad request with the relevant error message.</p>
<p>The following screenshot shows the Bad Request response (HttpStatus Code 400):</p>
<div><img class="aligncenter size-full wp-image-965 image-border" src="img/2562185d-2e4d-4ffd-ba0e-c17d820d147d.png" style="width:46.67em;height:18.92em;"/></div>
<p>To make any filter available anywhere, you should add the following code in the <kbd>startup.cs</kbd> configure method, like this:</p>
<pre>services.AddMvc(option =&gt;<br/>{<br/>  option.Filters.Add(typeof(ValidateInputAttribute));<br/>});</pre>
<p>Now, let's come back to our token-based authorization method. In the previous application, you saw how we can build an API to validate the credentials. Now, let's make a policy to restrict a resource. A detailed explanation of this topic is beyond the scope of this book; I suggest that you refer to the official documentation at <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies">https://docs.microsoft.com/en-us/aspnet/core/security/authorization/policies</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Data encryption and storing sensitive data</h1>
                
            
            
                
<p>Data security is always a big concern in any application, and it is a high priority while writing or designing applications. You can use any hashing algorithm to protect the data by encryption and decryption, but it would lead to a performance hit. ASP.NET Core provides a way to protect data with the help of the ASP.NET DataProtection (<a href="https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/">https://www.nuget.org/packages/Microsoft.AspNetCore.DataProtection.Abstractions/</a>) NuGet package.</p>
<p>A complete explanation of this topic is beyond the scope of this book. You can refer to <a href="https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/">https://docs.microsoft.com/en-us/aspnet/core/security/data-protection/</a> for further information.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Sensitive data</h1>
                
            
            
                
<p>While you work with APIs, you have to store sensitive data: the API key, secret key, username, password, and so on. The following are a few recommendations for you to take into consideration while you’re working with this data in the ASP.NET Core application:</p>
<ul>
<li>You should separate the configuration files from code.</li>
<li>You should avoid storing this data in plain text files.</li>
<li>You can use a separate class file where you can store these data values in the form of constants.</li>
<li>You should store confidential data in environment variables. For more information, refer to <a href="http://www.dowdandassociates.com/blog/content/howto-set-an-environment-variable-in-windows-command-line-and-registry/">http://www.dowdandassociates.com/blog/content/howto-set-an-environment-variable-in-windows-command-line-and-registry/</a>.</li>
<li>You can also use a secret manager to store your confidential data (<a href="https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?tabs=visual-studio#secret-manager">https://docs.microsoft.com/en-us/aspnet/core/security/app-secrets?tabs=visual-studio#secret-manager</a>).</li>
</ul>
<p>Sensitive data varies from application to application and requirement to requirement. For more details, you can refer to <a href="https://stormpath.com/blog/store-protect-sensitive-data-dotnet-core">https://stormpath.com/blog/store-protect-sensitive-data-dotnet-core</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Summary</h1>
                
            
            
                
<p>In this chapter, we have discussed data security, following the OWASP security standard, and looking at JWT authentication. We also discussed custom filters and input validations using a code example. Data protection is always a high priority for any web application. We discussed data protection methods when storing sensitive data in an ASP.NET Core application.</p>
<p>In the next chapter, we will discuss the performance of web services by looking at the scale-in, scale-out methodology and the implementation of a few caching mechanisms.</p>


            

            
        
    </body></html>