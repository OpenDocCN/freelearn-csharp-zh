- en: '6'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Best Practices with Web User Interfaces
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When creating a **user interface** (**UI**) with ASP.NET 8, it can be intimidating
    since most developers are so used to working with C#. There are a lot of factors
    to consider when creating a web application, such as avoiding duplication, recognizing
    similar interfaces for reusable components, creating a structured website, and
    making it easier for search engines to index the site—a process known as **search
    engine** **optimization** (**SEO**).
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using a task runner
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Applying standards to UIs
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introducing Buck’s coffee shop project
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the first section, we’ll examine why a task runner is so important to developers,
    how to set it up and run it automatically, and how to bundle and minify scripts.
    Then, in the next section, we’ll review a number of common standards with ASP.NET
    8 sites, including centralizing links, keeping controllers and Razor Pages small,
    why `ViewComponent` classes are better than the `HTMLHelper` class or partials,
    replacing HTML helpers with tag helpers, and why creating SEO-friendly URLs are
    important.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ll create a new project called *Buck’s Coffee Shop*, applying everything
    we’ve covered.
  prefs: []
  type: TYPE_NORMAL
- en: By the end of this chapter, we’ll know how to include client-side resources
    into a task runner, implement common practices for UIs, understand how to build
    additional functionality into an existing web application using the Task Runner
    tool, consolidate links using extension methods, and extend HTML by creating our
    own HTML Tags.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Even with a simple web UI, the Visual Studio family of products creates an
    easy way to build web applications using IntelliSense. We recommend using your
    favorite editor to view the GitHub repository. We recommend the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio (latest version)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: JetBrains Rider
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The editor we’ll be using is Visual Studio 2022 Enterprise, but any version
    (Community or Professional) will work with the code.
  prefs: []
  type: TYPE_NORMAL
- en: The code for [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137) is located in Packt
    Publishing’s GitHub repository, found at [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).
  prefs: []
  type: TYPE_NORMAL
- en: Using a task runner
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we’ll explain what a task runner is, what its responsibilities
    are, how to automatically execute it when building the solution, and provide some
    examples of how to use it.
  prefs: []
  type: TYPE_NORMAL
- en: As developers, we are always looking for better ways to quickly automate tasks.
    With JavaScript frameworks, this task is essential, especially when building the
    solution in a **Continuous Integration/Continuous Delivery** (**CI/CD**) pipeline.
    The consistent repetition of certain tasks becomes monotonous and takes away from
    development time. Why not have a computer process the work?
  prefs: []
  type: TYPE_NORMAL
- en: As developers, the need to include a task runner section in this chapter is
    meant to show developers how to automate tasks to make client-side endeavors more
    efficient. In recent years, I’ve experienced developers who’ve never used a task
    runner for client-side tasks or even know what it is. A task runner is a tremendous
    benefit to all developers.
  prefs: []
  type: TYPE_NORMAL
- en: What is a task runner?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As JavaScript became popular, developers wanted a way to build their JavaScript
    as well as build their solutions. In addition to using JavaScript, TypeScript
    was created to give JavaScript more of a strong-typed feel and required a compilation
    step as well.
  prefs: []
  type: TYPE_NORMAL
- en: Along with “compiling” TypeScript, most websites require additional tasks such
    as minifying and bundling JavaScript and optimizing. There was a need for a tool
    to make the developer’s experience seamless when working with C# and JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: This is why the Task Runner tool was created and integrated into Visual Studio.
    Its primary responsibility is to automate tasks using either Grunt or Gulp with
    build scripts.
  prefs: []
  type: TYPE_NORMAL
- en: Gulp and Grunt are also task runners, but each one has a different file format
    in JavaScript when defining tasks. While we can use either Grunt or Gulp scripts
    in the Visual Studio Task Runner, we’ll be using the Gulp format.
  prefs: []
  type: TYPE_NORMAL
- en: The Task Runner in Visual Studio is what I would consider a “mini-pipeline for
    the client side.” A task runner is a great introduction for developers learning
    to create a CI/CD pipeline for an application.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up the Task Runner
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The Task Runner relies heavily on Node.js for running scripts. By default, Node.js
    should already be installed through Visual Studio.
  prefs: []
  type: TYPE_NORMAL
- en: 'To find out whether Node.js is installed on your machine, do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Select **Package Manager Console** from **View |** **Other Windows**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When a prompt appears, type `npm --version`. If it displays a version number,
    we can proceed with the next step. If not, a repair of Visual Studio through the
    Visual Studio Installer may be required.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Type `npm install -g gulp --save-dev`. The `-g` option is to install Gulp globally,
    and `--save-dev` is there to save the dependency in the `package.json` file. With
    that said, there should be a `package.json` file added to the solution.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a new JavaScript file to the root of the project, called `gulpfile.js`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Depending on whether we’re using Grunt or Gulp, the Task Runner requires a specific
    file. In the examples (as I mentioned before), we’ll be using the Gulp format.
  prefs: []
  type: TYPE_NORMAL
- en: Structure of a gulpfile
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When creating a gulpfile, it should be named `gulpfile.js`. The file should
    be placed into the root of the solution.
  prefs: []
  type: TYPE_NORMAL
- en: 'The structure of a gulpfile contains the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Defined packages**—These are the modules used throughout the gulpfile.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Processing and cleanup tasks**—Each task will contain a process task along
    with a cleanup task.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Export groupings**—This provides a list of tasks to execute in a specific
    order. Usually, cleanup procedures are used first, followed by regular processing
    tasks.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Gulp requires a `gulpfile.js` file to be located in the root of the solution.
    The standard layout of a gulpfile is usually segmented using the following structure:'
  prefs: []
  type: TYPE_NORMAL
- en: '`npm` installs.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`gulpfile.js` file, there should be two tasks: a processing task and a cleanup
    task. The processing task is meant to achieve what we want to automate, whereas
    the cleanup task is meant to delete created or processed files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Global default and cleanup tasks**—Segment the processing and cleanup tasks
    into logical groupings when building the scripts.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Since we already have our file, we’ll create a simple task for our solution.
    Copy the following JavaScript code into the new `gulpfile.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Since this is a build script, we’ll be using the `series()` function from the
    Gulp package, which defines sequential processes. This is represented through
    the first line. The second line creates a `const` instance representing the Gulp
    package, making the Gulp functions available to us.
  prefs: []
  type: TYPE_NORMAL
- en: Our simple task for the Task Runner is the world-famous “Hello World!” task
    defined through the `testTask` function while passing in the `done` function,
    which Gulp handles for us.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we attach a `build` property to our exports that defines a series of
    tasks from the preceding code. The `series` function is defined in the Gulp package.
    The name following the `exports` namespace can be named anything which appears
    in the Task Runner. If the build task isn’t displaying in the Task Runner, click
    the `gulpfile.js` file.
  prefs: []
  type: TYPE_NORMAL
- en: 'When right-clicking on the **build** option (or double-click), the build will
    execute showing the results, as displayed in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.1 – Results from our first Task Runner process](img/Figure_6.01_B19493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.1 – Results from our first Task Runner process
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll learn how to run our gulpfile automatically when
    we build our solution.
  prefs: []
  type: TYPE_NORMAL
- en: Running automatically
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To assist in automatically running our `gulpfile.js` file, we have the ability
    to bind certain tasks to events when building the solution. Right-click on the
    task in the Task Runner to select the appropriate action for the builds, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Before Build**—Execute a task before compiling the solution'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**After Build**—Execute a task after the solution compiled'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Clean Build**—Execute a task on a “Clean Solution” or “Clean <Project>” action'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Project Open**—Execute a task after the project opens'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When we select `gulpfile.js` file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'When we build the application, the Task Runner executes the build task and,
    if successful, it proceeds to compile the application, as shown in the following
    screenshot. If not, the Task Runner will display an error message in the results
    pane:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.2 – A successful build of client-side tasks and solution](img/Figure_6.02_B19493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.2 – A successful build of client-side tasks and solution
  prefs: []
  type: TYPE_NORMAL
- en: While this provides a basic foundation for our application, we need to define
    our client-side directory structure so that when adding resources such as images,
    scripts, and styles, our tasks know where to find the resources.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll look at how to set up the structure for our client-side
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a workflow structure
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we write scripts for our `gulpfile.js` file, we need to define a simple
    workflow for our Task Runner. Generally, our gulpfile contains, at the very least,
    a JavaScript and CSS bundler and minifier. It doesn’t matter which one is executed
    first, but they could even be candidates for a collection of parallel tasks. While
    Visual Studio created our server-side application, the client-side structure requires
    a little more attention in regard to where to place files throughout our application.
  prefs: []
  type: TYPE_NORMAL
- en: In every ASP.NET 8 application, we have a `wwwroot` folder that contains our
    client-side scripts, styles, and static content (such as images). This is considered
    the root path to our application for our static content, so if we have a website
    called [https://www.mywebsite.com/](https://www.mywebsite.com/), the wwwroot folder
    will be our root. For example, if we want to access our CSS folder, we’d access
    it via `https://www.mywebsite.com/css/`. While every resource (such as scripts
    and styles) has its own way of processing and creating production-ready output
    files, there needs to be a workflow on how each task in our Task Runner will perform.
  prefs: []
  type: TYPE_NORMAL
- en: 'The current directory structure looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 6.3 – A common ASP.NET 8 structure](img/Figure_6.03_B19493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.3 – A common ASP.NET 8 structure
  prefs: []
  type: TYPE_NORMAL
- en: The preceding structure is meant for a production-level application. The `css`
    directory doesn’t contain any SASS or LESS files for processing, and the `js`
    directory has only simple JavaScript files. We need additional directories for
    our workflow to function properly.
  prefs: []
  type: TYPE_NORMAL
- en: For our application, we’ll be using TypeScript and SASS. SASS is a preprocessor
    for CSS files and requires a directory for our source files (with an extension
    of `.scss`). TypeScript also requires transpilation into JavaScript files, so
    we’ll create a `scss` directory for our SASS files and a `src` directory for our
    TypeScript files.
  prefs: []
  type: TYPE_NORMAL
- en: Create a `src` folder and a `scss` folder under the `wwwroot` folder. These
    folders will contain the source code for our application. The `src` folder will
    contain all TypeScript files for the application, whereas the `scss` folder will
    contain all of the styles ready for compilation into production-ready CSS files.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following steps show a common workflow for a task runner:'
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Transpile the TypeScript files in the `src` folder into JavaScript files. The
    output files will reside in the `src` folder. The output files are JavaScript
    files.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'JavaScript files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a bundler to process the `.js` files. The bundler should automatically know
    how to include all files based on the JavaScript module pattern.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Use a minifier to process the bundled JavaScript files. The output files are
    copied from the `src` folder over to the `js` folders. These files are also renamed
    to have a `.min.js` suffix added to them to identify them as minified files.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Styles:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Use a “styler compiler” such as LESS or SASS. We’ll be using SASS to precompile
    our styles. These files will reside in the `scss` folder. Once compiled, the folder
    will contain `.css` files and be inevitably moved to the `css` folder.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: The workflow structure of our application implies the `js` and `css` folders
    are production-level folders while making our `src` and `scss` folders specific
    to developer modifications.
  prefs: []
  type: TYPE_NORMAL
- en: Defining our workflow paths
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we created our workflow structure, we need to tell Gulp where our source
    and destination folders reside in our application. The `path` module contains
    a `resolve` function to concatenate folder names as we go, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: '`__dirname` is a reserved word and is based on the current directory (in our
    case, this is the root of our application). `basePath` is used to operate solely
    in the `wwwroot` folder and below and won’t interfere with our ASP.NET 8 application.'
  prefs: []
  type: TYPE_NORMAL
- en: Transpiling TypeScript
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Our first order of business is to transpile our TypeScript files into JavaScript
    files. Transpiling is the process of converting TypeScript into JavaScript. With
    most of our TypeScript projects, we almost always have a `tsconfig.json` configuration
    file, and this will reside in the root of the `wwwroot` folder. However, we need
    a special package for reading the configuration file specifically for Gulp.
  prefs: []
  type: TYPE_NORMAL
- en: 'To include the package, proceed as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `npm install -g gulp-cli`. It should then be added to your `package.json`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `npm install gulp@4` to install Gulp as a project dependency.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: One last time in the `npm install gulp-typescript typescript gulp-clean --save-dev`
    to install TypeScript, the `gulp-typescript`, and the ability to remove files
    (`gulp-clean`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Define the module at the top of the `gulpfile.js` file, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Load the configuration using the `createProject` function referencing the path
    to the `tsconfig.json` file, as follows:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the TypeScript source folder, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We’ll keep track of paths through a source object. Our `srcPaths` object will
    contain a `js` path pointing to our source code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to create process (`ts_transpile`) and cleanup (`ts_cleanup`) functions
    for our TypeScript. Here’s the code to achieve that:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `ts_transpile` function uses the `tsProject` configuration to locate the
    source files (through the `include` property near the end of the `tsconfig.json`
    file) and convert all of the TypeScript files into JavaScript files in the same
    directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Our `ts_clean` function will simply remove all JavaScript (*NOT* TypeScript)
    files from every directory.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once we have our TypeScript tasks defined, we simply add them to our build
    process at the bottom of our `gulpfile.js` file, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: First, we delete all of the JavaScript files with `ts_clean`, then perform the
    transpiling with `ts_transpile`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As shown in the example, our workflow structure locates all of the TypeScript
    files and transpiles them into JavaScript files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 6.4 – TypeScript files in src folders converted to JavaScript](img/Figure_6.04_B19493.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 6.4 – TypeScript files in src folders converted to JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: Since our TypeScript is now transpiled down to JavaScript, we can focus on bundling
    and minifying the files.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling and minifying
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: By nature, JavaScript takes a while to load in the browser. To make matters
    worse, if a JavaScript file is formatted for readability, the file takes even
    longer to load, therefore making it slower to download. A minification process
    is necessary to shorten the loading process as much as possible to give the user
    a better experience.
  prefs: []
  type: TYPE_NORMAL
- en: Bundling is the concept of taking an application’s scripts and styles and combining
    them into one script or style instead of loading multiple files.
  prefs: []
  type: TYPE_NORMAL
- en: Since spaces and tabs take up…well, space, minifying the scripts and styles
    is the process of shrinking client-side files down to a smaller size for faster
    delivery to the browser.
  prefs: []
  type: TYPE_NORMAL
- en: 'To bundle our scripts, we need a module called Browserify for our Gulp script.
    Let’s start adding the bundling functionality to the `gulpfile.js` file. Here
    are the steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `npm install -g browserify gulp-rename vinyl-source-stream vinyl-buffer
    vinyl-transform gulp-uglify-es`. We should see these modules added to the `package.json`
    file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once these are installed in the `package.json` file, we need to include another
    `srcPath` object containing all of the files we want bundled/minified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll call the property `jsBundles`. Since every TypeScript file was transpiled
    into a JavaScript file, we have to identify which files to load. A good practice
    to follow is to name the file the same as the actual page. The good news is the
    Browserify module will follow the imports in each file and include it in the bundling.
    As we add more TypeScript to the project, add the primary script to the list for
    automatic compilation.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new variable where the scripts will reside for the web application:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’ll call the variable `destPaths`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we create our processing and cleanup for bundling and minifying the scripts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: In the `js_bundle_min` function shown in the preceding snippet, we loop through
    all of the files we want bundled. We create a `browserify` object with options
    set and start the bundling process per file.
  prefs: []
  type: TYPE_NORMAL
- en: The first process is getting the base name of the file we’re currently processing.
    Once we have the filename, we can rename the base from `site` to `site.min` and
    then add a `.js` extension to the end of the file. We then buffer the file and
    perform an `uglify` operation on it, meaning we minify it. After it’s bundled
    and minified, we write the file out to the destination folder, which is `wwwroot/js`.
  prefs: []
  type: TYPE_NORMAL
- en: The `js_clean` function removes all of the `.js` files from the `wwwroot/js`
    folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we can add the `js_bundle_min` and `js_clean` functions to our build
    exports at the bottom of the file:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Once the gulpfile is saved, double-click on the build, and the files should
    appear in the `wwwroot/js` folder. If we double-click the JavaScript file, we’ll
    see it’s been bundled and minified.
  prefs: []
  type: TYPE_NORMAL
- en: Implementing additional tasks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'While bundling and minifying scripts is a big deal, there are other tasks we
    can add to a task runner. Such tasks can include the following:'
  prefs: []
  type: TYPE_NORMAL
- en: SCSS/LESS precompiling
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Image optimization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Release notes
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Copying `dist` folders from `node_modules` to a `lib` folder on build
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: These are just a few of the simple tasks available when preparing the web application.
    For additional tasks, refer to the source code for [*Chapter 6*](B19493_06.xhtml#_idTextAnchor137)
    on GitHub in the `TaskRunner` project at [https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices](https://github.com/PacktPublishing/ASP.NET-Core-8-Best-Practices).
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we reviewed what a task runner is and what it can do for developers
    and showed how to automatically execute it when building the solution. We also
    demonstrated the power of the Task Runner by creating a workflow structure and
    defining our workflow paths, how to transpile TypeScript, and how to minify and
    bundle scripts. As we can see, this simplifies the developer experience by automating
    client-side tasks and building the solution using one build.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll examine more UI standards and what is considered
    common knowledge when it comes to ASP.NET 8 web applications.
  prefs: []
  type: TYPE_NORMAL
- en: Applying standards to UIs
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: ASP.NET’s web page model has evolved over the years. With Web Forms, it was
    `ViewState` and components. With MVC, it had partials and HTML Helpers. Now, ASP.NET
    8 provides more advanced techniques using `ViewComponent` classes and `TagHelper`
    classes.
  prefs: []
  type: TYPE_NORMAL
- en: For this section, we’ll examine how ASP.NET 8 uses its language-specific features
    to build quicker and more flexible UIs. We’ll see how to consolidate links across
    a site, why it’s important to keep controllers/pages small, how `ViewComponent`
    classes are better than partials and `HTMLHelper` classes, and look at how to
    create SEO-friendly routes.
  prefs: []
  type: TYPE_NORMAL
- en: Centralizing your site links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we have a large site with hundreds of links, developers understand what it
    means when a page is renamed, moved, or (gasp) deleted. It’s definitely a time-consuming
    effort to change every link on a large site. While `TagHelper` classes are…well,
    helpful, one common practice is to use `UrlHelper` classes to consolidate the
    links.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s examine a website with the following ASP.NET 8 `TagHelper` class shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: Imagine all of these on secondary pages pointing to the main page, `Index.cshtml`,
    and we receive a request to change the name of the page to `Index2`.
  prefs: []
  type: TYPE_NORMAL
- en: 'With extension methods, we can create custom site-specific `UrlHelper` class
    URLs for each page, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'Extension methods require three things: a static class, a static method, and
    the method’s first parameter in the signature must have `this` declared.'
  prefs: []
  type: TYPE_NORMAL
- en: What is an extension method?
  prefs: []
  type: TYPE_NORMAL
- en: For more details on using extension methods, navigate to [https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods](https://learn.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/extension-methods).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can apply this technique to Razor Pages as well using the `PageLink` method,
    as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The only difference between the two methods is the extension method attaches
    to an `IurlHelper` class instead of a `UrlHelper` class and, for Razor Pages,
    we use the `.PageLink` method instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'If using the `TagHelper` anchor with the `asp-page` attribute, this approach
    limits our flexibility because we are defining a page in multiple places. By adding
    an extension method to the `UrlHelper` class, we can simplify it by using the
    HTML `href` attribute, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: With `UrlHelper` extension methods, all of the links across the site are easier
    to integrate and more efficient to update.
  prefs: []
  type: TYPE_NORMAL
- en: Keeping controllers/pages small
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When ASP.NET MVC was introduced, controllers were often the dumping ground for
    most code, making calls to the database, creating models, and validating the model.
  prefs: []
  type: TYPE_NORMAL
- en: MVC controllers (and now Razor Pages) should be “traffic cops,” directing the
    logic to certain parts of the application based on the page’s function.
  prefs: []
  type: TYPE_NORMAL
- en: 'While the following list is far from complete, certain aspects can be offloaded
    to other parts of ASP.NET 8 to put controllers and pages on a diet:'
  prefs: []
  type: TYPE_NORMAL
- en: '`[Required]` and `[Email]`.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DbContext` instance and use Entity Framework. If Entity Framework isn’t a
    viable solution, offload the database processing to `Service` classes (see [*Chapter
    5*](B19493_05.xhtml#_idTextAnchor114) on Entity Framework Core).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Secondary processes**—If the application contains code to send emails, process
    records, or build an object, refactor the process out to its own class and inject
    it into the controller/Razor page, making it cleaner and easier to test.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Large methods in controllers or Razor Pages can complicate matters further when
    trying to test or debug code. Smaller code, in this instance, is the better approach.
  prefs: []
  type: TYPE_NORMAL
- en: Using ViewComponents
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When HTML Helpers and Partial views were introduced with MVC, the ability to
    pass an object into a small section and have it create a snippet of HTML for the
    View was a great feature for developers. However, there were a few downsides to
    using these two features.
  prefs: []
  type: TYPE_NORMAL
- en: The downside of using HTML Helpers was the ability to create new HTML snippets
    through code and render that back to the View. If the HTML changed, it would require
    updating and recompiling of the code violating **separation of concerns** (**SoC**)
    (“You’ve got your C# in my HTML”). There wasn’t any HTML associated with the Helper;
    it had to be created using code.
  prefs: []
  type: TYPE_NORMAL
- en: Swinging the pendulum the other way, Partials introduced the ability to have
    HTML with no code with the ability to pass objects into the partial. The issue
    with this approach was the ability to place `if`…`then` statements inside the
    HTML. When an `if`…`then` statement was introduced in HTML, this was considered
    a code smell (which is code looking like it doesn’t belong or looks suspicious)
    and was meant to be a business rule. HTML should be declarative—almost template-like
    with no branching involved.
  prefs: []
  type: TYPE_NORMAL
- en: 'With ASP.NET Core, `ViewComponent` classes were introduced and, while not meant
    to replace `HTMLHelper` classes or Partials, fulfilled a larger need for building
    modular web applications. Considered to be “mini-controllers,” `ViewComponent`
    classes provide ASP.NET developers with a better approach for the following reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: '**SoC**—With an HTML and C# combination, this allows a better way of writing
    modular components.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewComponent` classes only render a chunk of the view instead of the entire
    response. This makes the component independently render faster.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewComponent` classes are isolated by nature, making them extremely easy
    to test. Create a new `ViewComponent` class, pass in arguments, and test to see
    if it returned what was expected.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ViewComponent` classes give us the best of both worlds, rendering HTML while
    using C# for applying business rules in a single component.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional ViewComponent material
  prefs: []
  type: TYPE_NORMAL
- en: For more details on the `ViewComponent` class, navigate to [https://learn.microsoft.com/en-us/aspnet/core/mvc/views/view-components](https://learn.microsoft.com/en-us/aspnet/core/mvc/views/view-components).
  prefs: []
  type: TYPE_NORMAL
- en: Using Tag Helpers instead of HTML Helpers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While HTML Helpers provide the ability to create small snippets of HTML (just
    don’t go overboard), the `TagHelper` class take it a step further.
  prefs: []
  type: TYPE_NORMAL
- en: The difference between Tag Helpers and HTML Helpers is `TagHelper` classes allow
    us to build our own tag elements through code and `HTMLHelper` classes are directly
    called as methods in the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: For example, if we were building a hotel application, some `TagHelper` classes
    would include `<calendar>`, `<availability>`, and `<room-gallery>` tags. These
    would look like brand new tags in HTML, but ASP.NET would render them on the server
    and create HTML based on the data model fed to them.
  prefs: []
  type: TYPE_NORMAL
- en: Tag Helpers are an extremely powerful feature for developers wanting to create
    their own custom library of domain-specific HTML tags.
  prefs: []
  type: TYPE_NORMAL
- en: Creating SEO-friendly URLs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Site architecture is important when building websites. If it’s a public-facing
    website, the site should be easy to crawl with simple URLs.
  prefs: []
  type: TYPE_NORMAL
- en: 'To look at this another way, examine the following two URLs:'
  prefs: []
  type: TYPE_NORMAL
- en: '`https://www.mysite.com/Blog/my-first-blog-post`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`https://www.mysite.com/?blogpost=E1FCFB35-87C7-442F-9516-7C8585E8CD49`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we found these links and we were talking with someone on the phone, which
    one would we tell them to follow?
  prefs: []
  type: TYPE_NORMAL
- en: 'Creating friendly URLs provides the following benefits:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Easier to identify the page**—We know the first URL is someone’s first blog
    post. The second URL is…well, we don’t know what kind of page it is.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Easy to repeat**—It’s easier to say the first URL over the phone as opposed
    to the GUID.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Better SEO**—If we have the opportunity, it’s always good to help search
    engines identify what kind of page created.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Best practices of Google’s URL structure
  prefs: []
  type: TYPE_NORMAL
- en: For better naming of URLs and what Google recommends, navigate to [https://developers.google.com/search/docs/crawling-indexing/url-structure](https://developers.google.com/search/docs/crawling-indexing/url-structure).
  prefs: []
  type: TYPE_NORMAL
- en: Creating these SEO-friendly URLs requires a site-wide link strategy using mapping
    methods such as `.MapRoute()` and, if using Razor Pages, naming pages related
    to the content.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to catalog our links using extension methods,
    how controllers and pages should be made as small as possible, how `ViewComponent`
    classes can improve the efforts of writing modular code, why `TagHelper` classes
    can propel HTML to new heights, and why creating SEO-friendly URLs is so important.
  prefs: []
  type: TYPE_NORMAL
- en: In the last section, we’ll apply our knowledge of implementing these concepts
    into an application.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing Buck’s coffee shop project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We covered a lot in the last section, with various concepts explained. It’s
    one thing to explain `ViewComponent` and `TagHelper` classes, but where do we
    apply these concepts on a website?
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we’ll apply those concepts to a brand-new project. Our friend
    wanted a new website for his coffee shop, so we used the ASP.NET 8 Web Application
    template as a starting point for the site.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up Buck’s website
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since we have a new website, we want to create the client-side pipeline so that
    we can focus on the site’s functionality.
  prefs: []
  type: TYPE_NORMAL
- en: This sounds like a job for…the Task Runner.
  prefs: []
  type: TYPE_NORMAL
- en: While we’ve included the transpiling of TypeScript and bundling/minifying JavaScript
    in the project, we can add additional tasks to make our lives even easier.
  prefs: []
  type: TYPE_NORMAL
- en: 'One easy task is to bundle and minify our styles using SASS, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `npm install --save-dev sass gulp-sass`. These modules should be added
    to the `package.json` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once these are installed in the `package.json` file, we include the module
    as required at the top of our `gulpfile.js` file, like so:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a variable containing the path to the SCSS files:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the style file to the `srcPaths` object (in the `sassSrc` property):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the style path to the `destPaths` object (with the `cssFolder` property):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the processing and cleaning functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add the functions to the build process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: What about those JavaScript libraries? They’re in the dreaded `node_modules`
    folder. Most JavaScript libraries have a `dist` folder for distribution. This
    was the case when we installed the Bootstrap and Font Awesome libraries. Why not
    copy that into our `/lib` folder for our local purposes?
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a variable in the `gulpfile.js` file containing the path to the `node_modules`
    folder. This should be in the root of the solution:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create a new variable containing the destination of where to place our `dist`
    packages (our `/``lib` folder):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Define the copy details in a property called `lib`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the processing and cleaning functions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Finally, add our library copy to the build process:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: This gives us the ability to automatically receive the latest versions of packages
    for our application. When updating our `package.json` file, we’ll benefit from
    the latest versions in `node_modules` delivered right to our `/``lib` folder.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the links
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Since we have a new application, we’ll create `Url` Helpers to help catalog
    the site. Based on the template, we have two links: `Home` and `Privacy`. Let’s
    create those `Url` Helpers, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: 'This makes our HTML easier to read. Instead of the Anchor Tag Helpers, we can
    substitute them with a Url Helper. Here is the result of replacing the Privacy
    Anchor Tag Helper:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: While this is one instance on this page, we can already see the dividends of
    our efforts. Notice the navigation bar?
  prefs: []
  type: TYPE_NORMAL
- en: 'In the navigation bar, there’s another location where we can remove the hardcoded
    URL and use a strongly typed `UrlHelper` class, as illustrated here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: There are `Privacy` and `Home` links we replaced.
  prefs: []
  type: TYPE_NORMAL
- en: 'The technique also works with controllers or Razor Pages. If we need to redirect
    to another page, there is a `UrlHelper` class available to us by default, as shown
    here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: It removes the need for hardcoded URLs, providing a more efficient way of referencing
    links across a large website.
  prefs: []
  type: TYPE_NORMAL
- en: Creating an OffCanvas Tag Helper
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Since responsive websites are important, we need to have an `OffCanvas` menu
    for when users see the site with a mobile device.
  prefs: []
  type: TYPE_NORMAL
- en: '`OffCanvas` menus are activated on mobile devices when clicking on a hamburger
    menu (shown as three lines on top of each other). `OffCanvas` menus are hidden
    from the main content on a web page, hence the name. They’re only necessary to
    hide navigational items until they’re actually needed.'
  prefs: []
  type: TYPE_NORMAL
- en: We’re creating an `OffCanvas` menu for Buck’s website. However, we want to use
    this on multiple sites, so there is a requirement to create a reusable component.
  prefs: []
  type: TYPE_NORMAL
- en: Bootstrap has an `OffCanvas` component and, while it’s simple HTML, we can turn
    this into a reusable component with Tag Helpers.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, we need the structure of a Tag Helper. Here’s the code we need to execute:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: At the beginning of the code, we need to identify which HTML Tag we want to
    use for our Tag Helper. In this case, it’s a simple `offcanvas` tag. Since HTML
    tags, attributes, and CSS classes are all lowercase by default, every reference
    to the `OffCanvas` class should contain a lowercase string of the tag.
  prefs: []
  type: TYPE_NORMAL
- en: We want to include an ID and a tab index based on the examples, so we need two
    properties called `Id` and `TabIndex`, with `[HtmlAttributeName]` data annotations
    applied to each property.
  prefs: []
  type: TYPE_NORMAL
- en: The primary method is the `ProcessAsync` (or `Process`) method. We immediately
    grab any children inside the `offcanvas` tag and process the child tags, which
    we’ll get to later in this section.
  prefs: []
  type: TYPE_NORMAL
- en: We set `tagname` to `DIV`, set `classname` to `offcanvas`, set the attributes,
    and finally, set `innerHTML` to the child data retrieved from the beginning of
    the `ProcessAsync` method.
  prefs: []
  type: TYPE_NORMAL
- en: 'According to the Bootstrap `OffCanvas` documentation, we need a header and
    a body. We can easily duplicate this code to create a `header` and `body` tag
    for `offcanvasTagHelper`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: The `HTMLTargetElement` data annotation is a little bit different. We called
    this tag `header`. Won’t this interfere with the regular HTML header tag? Not
    so long as we include `ParentTag` as a second parameter, saying this element is
    only valid within an `offcanvas` element.
  prefs: []
  type: TYPE_NORMAL
- en: In this `Process` method, we create a header and button and append the HTML
    to the output’s content at the bottom. This content is sent back to the parent
    `offcanvasTagHelper` instance as the child data.
  prefs: []
  type: TYPE_NORMAL
- en: 'We only need to create the body with `OffCanvasBodyTagHelper`, as shown in
    the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: This will contain the same `HTMLTargetElement` data annotation as our header,
    but we’ll call this the `body` tag. Again, it won’t interfere with the standard
    body HTML tag since we’re inside an `<offcanvas>` element. We get the child data
    (which should be a lot of HTML), we set the class and the `TagName` property,
    and finally set the content to what was inside the body tag.
  prefs: []
  type: TYPE_NORMAL
- en: 'One last thing required for our tag helper to work is to include all `TagHelper`
    instances in the project through the `_ViewImports.cshtml` file, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: 'We can add a button to our HTML to trigger `offcanvas`, like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'We can now create a simple `offcanvas` component in our HTML, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Once this is rendered, it will produce the Bootstrap result of an `OffCanvas`
    component with valid HTML.
  prefs: []
  type: TYPE_NORMAL
- en: This powerful technique can be applied to create a simplified HTML language
    for any domain where even non-developers can understand web pages.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we took a sample website and optimized our client-side scripts
    and styles, centralized our links by creating URL Helper extension methods, and
    finally, built an `OffCanvas` Tag Helper to showcase how we can create our own
    HTML library of powerful elements.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we began with how important a task runner is for client-side
    tasks and how to set up a task runner, then understood the structure of a gulpfile
    and how to create a workflow structure. Once we had our task runner working, we
    put it to work by focusing on transpiling TypeScript into JavaScript and bundling
    and minifying it into something for a production website.
  prefs: []
  type: TYPE_NORMAL
- en: We proceeded with looking at what’s considered a standard in the industry when
    it comes to UIs in ASP.NET 8\. We learned about how to save time by centralizing
    all links in one place, why it’s important to keep controllers and Razor Pages
    small, and the key reasons why `ViewComponent` classes should be used. We learned
    why `TagHelper` classes are better than `HTMLHelper` classes and why a site should
    use SEO-friendly URLs.
  prefs: []
  type: TYPE_NORMAL
- en: To finalize this chapter, we looked at an example website and had a task runner
    bundle and minify our styles along with updating libraries automatically on build.
    We also applied URL Helper extension methods to the site, making it easier to
    change site-wide links. Finally, we took a Bootstrap `offcanvas` HTML component
    and converted it into a reusable `TagHelper` class to showcase the power of Tag
    Helpers.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll look at the different types of testing and what are
    the best ways to unit test our code.
  prefs: []
  type: TYPE_NORMAL
