- en: '*Chapter 2*: Scripting Concepts in Unity'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In the previous chapter, we discussed **scripting** in Unity at a high level.
    In this chapter, we will introduce this topic in detail. We already know that
    Unity is internally written in C/C++, but it provides many C# APIs for game developers
    and allows us to implement game logic in C#. This means that not only can we write
    our own classes but also many built-in classes are available to us. So, before
    creating our own C# class, let's learn a bit about Unity's built-in classes first.
    The life cycle of Unity scripts is another important topic because we need to
    use different event functions provided by Unity to implement game logic. Then,
    we will introduce how to create a script in the Unity Editor and use it as a component.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will cover the following key topics in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the concepts of scripting in Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The life cycle of a script instance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a script and using it as a component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Packages and the Unity Package Manager
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can find complete code examples on GitHub under the following repository: 
    [https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers](https://github.com/PacktPublishing/Game-Development-with-Unity-for-.NET-Developers).
  prefs: []
  type: TYPE_NORMAL
- en: 'Before starting, I want to mention that the following software will be used
    in this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: Visual Studio 2019
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Visual Studio Tools for Unity
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Unity 2020.3+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding the concepts of scripting in Unity
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Let''s get started with understanding the concepts of scripting in Unity. We
    know that Unity is not an open source engine; except for enterprise users and
    users who subscribe to the Pro plan, no one else can access Unity''s source code.
    However, Unity''s C# API is open source. Because the C# API is just a wrapper,
    it does not include the internal logic of the engine. But Unity''s open source
    C# API is also a good reference for us to understand script programming in Unity.
    You can access it on GitHub: [https://github.com/Unity-Technologies/UnityCsReference](https://github.com/Unity-Technologies/UnityCsReference).'
  prefs: []
  type: TYPE_NORMAL
- en: GameObject-components architecture
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: First of all, I want to let you know that Unity is a **component-based system**.
    So, the two terms you often hear in Unity game development are **GameObject**
    and **component**. A GameObject is nothing more than a container for components.
    It represents an object in the game world, but it does not have any function itself.
    On the other hand, a component implements the real functionality and can be attached
    to a GameObject to provide the function for a specific object.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.1 – A Main Camera GameObject with a Camera component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.01_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.1 – A Main Camera GameObject with a Camera component
  prefs: []
  type: TYPE_NORMAL
- en: For example, you can find a **Main Camera** object in a default Scene in the
    Unity Editor. It is created by attaching a **Camera** component to a GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: You can enable or disable a set of functions attached to this object by enabling
    or disabling the GameObject, or enabling or disabling a specific component to
    enable or disable a specific function.
  prefs: []
  type: TYPE_NORMAL
- en: This way is different from traditional object-oriented programming. It is a
    bit like LEGO blocks; when an object needs a certain type of function, you only
    need to add related components to it.
  prefs: []
  type: TYPE_NORMAL
- en: Common classes in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity provides a lot of built-in C# classes, so I will introduce some of the
    classes we often use in Unity development.
  prefs: []
  type: TYPE_NORMAL
- en: The MonoBehaviour class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In Unity development, the class you most often encounter is the `MonoBehaviour`
    class. This is because it is the base class from which every Unity script is derived.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a new script file in the Unity Editor and name it `ChapterTwo.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.2 – A default script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.02_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.2 – A default script
  prefs: []
  type: TYPE_NORMAL
- en: Then, we open it in Visual Studio by double-clicking it. You can see our new
    `ChapterTwo` class derives from `MonoBehaviour`.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, why is `MonoBehaviour` so important? Because it provides a framework for
    game developers to interact with the Unity engine. For example, if you want to
    attach a script to a GameObject in the Scene, the class must inherit from the
    `MonoBehaviour` class; otherwise, the script cannot be added to the GameObject.
    When you try to attach a class that does not inherit from `MonoBehaviour` to a
    GameObject, the Unity Editor will pop up the following error message:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.3 – Can''t add script error'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.03_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.3 – Can't add script error
  prefs: []
  type: TYPE_NORMAL
- en: Without the `MonoBehaviour` class, your code will not be able to access Unity's
    built-in methods and events, such as the `Start` and `Update` functions that will
    be created by default in each of your new script files.
  prefs: []
  type: TYPE_NORMAL
- en: '`MonoBehaviour` is the most important class in Unity. `Start` and `Update`
    are the most common built-in functions in Unity. Every time you create a new script
    file, they will appear in this new file. But if you want to modify the template
    that creates the script, it is also possible; you only need to modify the script
    template stored here:'
  prefs: []
  type: TYPE_NORMAL
- en: '`%EDITOR_PATH%\Data\Resources\ScriptTemplates`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`%EDITOR_PATH%/Data/Resources/ScriptTemplates`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.4 – The ScriptTemplates folder'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.04_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.4 – The ScriptTemplates folder
  prefs: []
  type: TYPE_NORMAL
- en: The GameObject class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We already know that objects in a Scene are called `GameObject` class to represent
    it.
  prefs: []
  type: TYPE_NORMAL
- en: When you create a new empty GameObject in a Scene, you'll find this new GameObject
    contains a name, a tag, a layer, and a **Transform** component.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.5 – A GameObject'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.05_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.5 – A GameObject
  prefs: []
  type: TYPE_NORMAL
- en: You can modify whether it is a *static* object from the **Inspector** window
    as well. If the GameObject does not move during runtime, you should check the
    **Static** property checkbox in the upper-right corner of the **Inspector** window.
    This is because many systems in Unity can precalculate information about static
    GameObjects in the Editor to improve performance at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: As we mentioned earlier, a GameObject is a container that can contain various
    components. Therefore, in scripting, the `GameObject` class mainly provides a
    set of methods for managing components, such as the `AddComponent` method to add
    a new component to a GameObject and `GetComponent` to access a component attached
    to a GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: Let's create a built-in 3D Cube object in the Scene and look at the **Inspector**
    window of this cube.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.6 – Cube object in the Scene'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.06_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.6 – Cube object in the Scene
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, this GameObject is called **Cube**,
    and there are four components that are attached to this Cube object, namely, **Transform**,
    **Cube (Mesh Filter)**, **Mesh Renderer**, and **Box Collider**. These components
    provide rendering and physical simulation functions for this object. Therefore,
    a GameObject is just a container for components, and specific functions come from
    specific components. You can add a new component by clicking the **Add Component**
    button in the **Inspector** window, or you can add a component at runtime via
    code.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to components, the `GameObject` class also offers a collection of
    methods to find other GameObjects, send messages between GameObjects, or create
    and destroy a GameObject. For example, you can find GameObjects by using the `GameObject.Find`
    method, to find a GameObject by name and return it, or the `GameObject.FindWithTag`
    method, to find a GameObject by tag. You can also use the `Instantiate` method
    to create a new instance of a `GameObject`, and the `Destroy` method to destroy
    an instance of a `GameObject`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.7 – [SerializeField] attribute in a class'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.07_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.7 – [SerializeField] attribute in a class
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that using certain methods to dynamically find a specific
    GameObject instance at runtime will bring additional overhead, so the easiest
    way to obtain a reference to another GameObject instance is to declare a public
    `GameObject` field or use the `[SerializeField]` attribute and declare a private
    field to maintain the encapsulation of the class. As shown in the previous screenshot,
    I prefer the second way. We will cover serialization in Unity further in later
    chapters.
  prefs: []
  type: TYPE_NORMAL
- en: Now, you will find the `GameObject` field is visible in the **Inspector**. You
    can just drag a GameObject from the Scene or **Hierarchy** panel onto this variable
    to assign it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.8 – A GameObject variable'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.08_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.8 – A GameObject variable
  prefs: []
  type: TYPE_NORMAL
- en: The Transform class
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An instance of the `Transform` class will be created automatically when you
    create a new GameObject in the Scene. This is because every GameObject in the
    Scene has position, rotation, and scale properties and the `Transform` class is
    used to store and manipulate the position, rotation, and scale of the GameObject
    in Unity. So, it is impossible to create a GameObject in Unity without a `Transform`
    component and you cannot remove it from a GameObject as well.
  prefs: []
  type: TYPE_NORMAL
- en: You can move, rotate, or scale a GameObject by modifying the properties of the
    `Transform` component in the Unity Editor directly, or you can modify them at
    runtime by accessing the instance of the `Transform` class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.9 – The Transform component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.09_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.9 – The Transform component
  prefs: []
  type: TYPE_NORMAL
- en: Prefabs in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Prefab** is an important concept in Unity. Game developers can use a Prefab
    to save GameObjects, components, and properties to reuse these resources when
    developing games with Unity. When instantiating a Prefab, the Prefab acts as a
    resource template. Next, let''s see how to create a new Prefab in Unity.'
  prefs: []
  type: TYPE_NORMAL
- en: How to create a Prefab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, let's talk about how to create a Prefab. Take a "barbell" as an example.
    It consists of a **Cube** and two **Sphere** objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.10 – How to create a Prefab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.10_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.10 – How to create a Prefab
  prefs: []
  type: TYPE_NORMAL
- en: 'We can create a Prefab of this barbell object by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: First, find the target GameObject named **BarbellObject** in the **Hierarchy**
    panel, as shown in *Figure 2.10*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the target GameObject from the **Hierarchy** panel to the **Project** panel
    to create a Prefab of it. The newly created Prefab file is shown as a blue cube
    icon in the Unity Editor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.11 – A Prefab file'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.11_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.11 – A Prefab file
  prefs: []
  type: TYPE_NORMAL
- en: At this point, if we look at the **Hierarchy** panel again, we can find that
    the name text of **BarbellObject** and the small cube icon on the left of it have
    changed from white to blue because it is now a Prefab instance. In this way, we
    can distinguish whether an object is a Prefab instance on the **Hierarchy** panel.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.12 – A Prefab instance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.12_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.12 – A Prefab instance
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, creating a new Prefab is not complicated. Next, let's explore
    how to edit an already-created Prefab.
  prefs: []
  type: TYPE_NORMAL
- en: How to edit a Prefab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Unity provides two ways for developers to edit a Prefab, as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The first way is to edit a Prefab in Prefab Mode.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The second way is to edit a Prefab via its instance.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's start with Prefab Mode first.
  prefs: []
  type: TYPE_NORMAL
- en: 'Prefab Mode is a mode specially designed to support editing Prefabs individually.
    Prefab Mode allows the content of the Prefab to be viewed and edited in a separate
    Scene. You can enter Prefab Mode in the following ways:'
  prefs: []
  type: TYPE_NORMAL
- en: The first way is to click the arrow button of the Prefab instance in the **Hierarchy**
    view.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.13 – Entering Prefab Mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.13_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.13 – Entering Prefab Mode
  prefs: []
  type: TYPE_NORMAL
- en: The second way is to select the Prefab file in the **Project** panel. A button
    with the words **Open Prefab** will be displayed in the **Inspector** panel. Click
    it to enter Prefab Mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.14 – Entering Prefab Mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.14_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.14 – Entering Prefab Mode
  prefs: []
  type: TYPE_NORMAL
- en: You can also double-click the Prefab file in the **Project** panel to enter
    Prefab Mode.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'After entering Prefab Mode, you can modify the Prefab here and you can also
    find that a navigation bar will be displayed above the Scene view, as shown in
    the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.15 – Prefab Mode'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.15_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.15 – Prefab Mode
  prefs: []
  type: TYPE_NORMAL
- en: Use the navigation buttons to switch between the game Scene and Prefab Mode.
    In addition, at the top of the **Hierarchy** view, a title bar is also displayed
    that displays the name of the currently opened Prefab. Clicking the left arrow
    button in the title bar can also be used to return to the game Scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'In addition to Prefab Mode, we can also modify a Prefab by modifying the instance
    of the Prefab in the **Hierarchy** panel. Let''s follow these steps to modify
    the **BarbellObject** Prefab:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Select one of the spheres in the `1` to `2`, as shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.16 – Modifying the Prefab instance'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.16_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.16 – Modifying the Prefab instance
  prefs: []
  type: TYPE_NORMAL
- en: When the root node of the Prefab instance is selected, three buttons will appear
    in the **Inspector** panel, namely **Open**, **Select**, and **Overrides**. Click
    the **Overrides** drop-down window to view all modified data items, such as properties
    and components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.17 – Opening the Overrides drop-down window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.17_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.17 – Opening the Overrides drop-down window
  prefs: []
  type: TYPE_NORMAL
- en: In this drop-down window, we can discard or apply all modifications. Here, we
    should click the **Apply All** button to apply this modification to the Prefab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.18 – Clicking the Apply All button'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.18_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.18 – Clicking the Apply All button
  prefs: []
  type: TYPE_NORMAL
- en: Through the two methods described previously, we can easily modify a Prefab
    in Unity. Next, let's talk about how to instantiate a Prefab at runtime using
    C# code.
  prefs: []
  type: TYPE_NORMAL
- en: How to instantiate a Prefab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'In Unity development, we can use the `Instantiate` method to create an instance
    of a Prefab at runtime. There are several variants of the `Instantiate` method.
    The commonly used Instantiate method variants are shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: We instantiate a Prefab using these two variants of the `Instantiate` method,
    both of which can be used to specify the instance's position and orientation,
    and the latter can also specify the instance's parent.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s use the following example to learn how to instantiate a Prefab by calling
    the `Instantiate` method:'
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let''s create a new script called `TestInstantiatePrefab`. In this script,
    we will assign a reference to a Prefab in the script and call `Instantiate` to
    create a new instance of this Prefab and assign a parent to the new object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Then, we also need to attach this script to a GameObject in the Scene, assign
    the Prefab to the `_prefab` field of this script, and assign this GameObject as
    the parent object of the instance of the Prefab that will be created later, as
    shown in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.19 – Setting up the component and properties'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.19_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.19 – Setting up the component and properties
  prefs: []
  type: TYPE_NORMAL
- en: 'Click the `InstantiatePrefab` object:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.20 – Creating a new instance of a Prefab'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.20_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.20 – Creating a new instance of a Prefab
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed an important concept in Unity, namely, Prefabs.
    By reading this section, you should understand what a Prefab is, how to create
    a Prefab, how to edit a Prefab, and how to instantiate a Prefab at runtime using
    C# code.
  prefs: []
  type: TYPE_NORMAL
- en: Special folders in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In addition to the commonly used classes and concepts introduced in the previous
    sections, there are also some special folders for different purposes in Unity.
    Some of these folders are related to scripting in Unity. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Assets` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Editor` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Plugins` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Resources` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `StreamingAssets` folder
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's look at each one.
  prefs: []
  type: TYPE_NORMAL
- en: The Assets folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: When a Unity project is created, an `Assets` folder is created to store various
    resources from models and textures to script files that will be used in this Unity
    project. This is also the folder you will mainly use when developing a Unity project.
  prefs: []
  type: TYPE_NORMAL
- en: The Editor folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The `Editor` folder is used to store script files for the Editor. For example,
    you can add more functionality to the default Unity Editor by creating some Editor
    scripts in an Editor folder. Unity compiles the scripts in four independent stages
    according to the location of the script files. At each stage, Unity will create
    a separate C# project file (`.csproj`) for this stage. The scripts in the Editor
    folder will not be available at runtime. If the Editor folder is located in a
    `Plugins` folder, then a CSharp project file named `Assembly-CSharp-Editor-firstpass`
    will be created; otherwise, a CSharp project file named `Assembly-CSharp-Editor`
    will be created.
  prefs: []
  type: TYPE_NORMAL
- en: The Plugins folder
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should put the plugins or the code that needs to be compiled first in the
    `Plugins` folder, and Unity will compile the code in this folder first. A CSharp
    project file named `Assembly-CSharp-firstpass` will be created for the scripts
    located in this folder. Unity will create a CSharp project file named `Assembly-CSharp`
    for all other scripts that are in the `Assets` folder but not in the `Plugins`
    folder and the `Editor` folder.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.21 – CSharp project file for different stages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.21_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.21 – CSharp project file for different stages
  prefs: []
  type: TYPE_NORMAL
- en: There are some other special folders, such as the `Resources` folder and the
    `StreamingAssets` folder. We will introduce them in later chapters.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we discussed the GameObject components architecture of Unity
    and introduced some of the most common built-in classes in Unity and some special
    folders related to scripts in Unity. Next, we will learn about another important
    topic related to scripting in Unity, that is, the life cycle of a script instance.
  prefs: []
  type: TYPE_NORMAL
- en: The life cycle of a script instance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In the previous section, we introduced basic concepts of scripting in Unity.
    Now, we will explain another important topic regarding scripting in Unity: the
    life cycle of a script instance.'
  prefs: []
  type: TYPE_NORMAL
- en: We already know that the Unity C# API does not include the internal logic of
    the engine and the event functions on the script are triggered by the engine's
    C/C++ code. Therefore, in order to use the Unity engine correctly, it is very
    important to understand the order of execution for event functions and the life
    cycle of a C# script in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can divide the Unity event functions into the following categories depending
    on their purpose :'
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Rendering
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let's discuss them next.
  prefs: []
  type: TYPE_NORMAL
- en: Initialization
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If you are familiar with developing .NET applications, you may be surprised
    by script initialization in Unity because Unity scripts do not use constructors
    for initialization. Instead, Unity provides some engine event functions to initialize
    a script instance.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, we have already seen a Unity event function for initialization purposes.
    Yes, it is the `Start()` function created by default when creating a new script
    in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the `Start()` function is not the first event function that will be
    triggered when a new instance of the script is created. When a Scene starts, the
    `Awake()` event function in each object in the Scene is always called before any
    `Start()` functions. Except for the fact that `Awake()` will be called first,
    `Start()` and `Awake()` work similarly. Both of them are called once during initialization.
    Now, you may have a question: since we already have the `Start` function, why
    do we still need the `Awake` function?'
  prefs: []
  type: TYPE_NORMAL
- en: This is because the Awake function is useful for separating initialization.
    For example, it is a good idea to use `Awake` to initialize an object's own references
    and variables before the game starts. This means that you should not access references
    to other objects in the Awake function, but should use `Start` to pass reference
    information of different objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You may be confused, so let me show you some code. Let''s consider a case where
    there are two classes, namely, `AwakeAndStartA` and `AwakeAndStartB`. In the first
    class, there is a `List<int>` variable and a `List<int>` property, and the `List`
    variable is set up in the Awake function of `AwakeAndStartA`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, we get the second class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `AwakeAndStartB` class tries to get the reference of the `AwakeAndStartA`class
    and also access the `ListRef` property of `AwakeAndStartA` in its Awake function.
  prefs: []
  type: TYPE_NORMAL
- en: If we run the code, we will get the following output; that is, object B can
    access object A, but not the variables or properties of object A in the Awake
    function. This is because we should not assume that a reference set up by one
    GameObject's Awake will be usable in another GameObject's Awake.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.22 – Null reference exceptions'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.22_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.22 – Null reference exceptions
  prefs: []
  type: TYPE_NORMAL
- en: 'Therefore, in order to use `ListRef` in object B, we can get the reference
    in the Start function. Let''s move the code for printing the number of elements
    contained in the list from the Awake function to the Start function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'This time, the code will print the correct number, as shown in *Figure 2.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.23 – The number of elements contained in the list is 0'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.23_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.23 – The number of elements contained in the list is 0
  prefs: []
  type: TYPE_NORMAL
- en: 'Another difference between the Start and Awake functions is that if a script
    component is not enabled in the Scene, its Start function will not be called but
    the Awake function will always be called, as you can see in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.24 – The Awake function is always called'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.24_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.24 – The Awake function is always called
  prefs: []
  type: TYPE_NORMAL
- en: There is a third event function for initialization, which is the `OnEnable`
    function. If the script component is enabled in the Scene, then this function
    will be called after the Awake function and before the Start function. However,
    there is a big difference between the `OnEnable` function and the Awake/Start
    function; that is, the `OnEnable` function could be called multiple times. This
    function is called when the component becomes enabled.
  prefs: []
  type: TYPE_NORMAL
- en: Update
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a game, `Update` is a very important function because the gameplay logic
    is driven by `Update`. Unity offers three different `Update` functions for different
    purposes. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`FixedUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Update`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`LateUpdate`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FixedUpdate` is used for physics simulations. So, you should not use this
    function if your game does not include physics simulations. The `FixedUpdate`
    function is called at every fixed framerate frame and it could be called multiple
    times in a single frame. This is because it is very important to ensure a fixed
    incremental time in a physical simulation. Now, you may be confused again. Let
    me explain it to you.'
  prefs: []
  type: TYPE_NORMAL
- en: By default, the physics simulation needs to be updated every 0.02 seconds. You
    can change this value in **Project Settings** | **Time** | **Fixed Timestep**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.25 – Fixed Timestep setting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.25_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.25 – Fixed Timestep setting
  prefs: []
  type: TYPE_NORMAL
- en: Let's consider a case where the framerate of the game itself is low, for example,
    25 FPS. This means that the game will take 0.04 seconds to update one frame. Then,
    the question is, how do we ensure a fixed incremental time for physics simulations?
  prefs: []
  type: TYPE_NORMAL
- en: 'The answer is not complicated. Unity only needs to call `FixedUpdate` twice
    in each frame before calling the `Update` function, and in this example, `FixedUpdate`
    is called every 0.02 seconds. The following screenshot shows the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.26 – FixedUpdate is called twice in a frame'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.26_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.26 – FixedUpdate is called twice in a frame
  prefs: []
  type: TYPE_NORMAL
- en: Therefore, only use the `FixedUpdate` function when using a physics simulation
    in your project. If your project does not include a physics simulation, then you
    should not use it.
  prefs: []
  type: TYPE_NORMAL
- en: The `Update` function is another function that will be created by default when
    you are creating a new script. It is the most commonly used and most important
    function to implement any type of game logic in Unity. If the script component
    is enabled in a Scene, then `Update` will be called once per frame.
  prefs: []
  type: TYPE_NORMAL
- en: The third function used to update is the `LateUpdate` function. As its name
    indicates, `LateUpdate` will be called after the `Update` function. So, we can
    use it to implement a two-step update in every frame. For example, you have a
    bunch of GameObjects in the Scene that need to be moved and rotated in the `Update`
    function, and you will use a camera in the Scene to track the movement of these
    GameObjects. In order to ensure that all GameObjects have moved completely, you
    can implement a smooth camera follow in the `LateUpdate` function.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'For a game, in addition to the game logic, another important aspect is the
    game''s graphics and rendering. Here, I will introduce three commonly used event
    functions of rendering. They are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnBecameVisible`/`OnBecameInvisible`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnRenderImage`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnGUI`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnBecameVisible` will be called when the renderer is visible to any camera,
    while `OnBecameInvisible` is the opposite.'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.27 – OnBecameVisible/OnBecameInvisible'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.27_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.27 – OnBecameVisible/OnBecameInvisible
  prefs: []
  type: TYPE_NORMAL
- en: As you can see in the previous screenshot, when the Cube object moves out of
    the camera's field of view, `OnBecameInvisible` will be called, and if it enters
    the camera's field of view, `OnBecameVisible` will be called.
  prefs: []
  type: TYPE_NORMAL
- en: If your game logic is very complex, then you can use `OnBecameVisible`/`OnBecameInvisible`
    to avoid unnecessary performance overhead. For example, when a GameObject moves
    out of view, the functions of the GameObject can be suspended.
  prefs: []
  type: TYPE_NORMAL
- en: '`OnRenderImage` is useful for implementing **postprocessing** effects in Unity.
    This function will be called after the Scene is completely rendered, and then
    you can apply a fullscreen effect to the image, which can greatly improve the
    appearance of your game. The following screenshots show the difference between
    an image with postprocessing and an image without postprocessing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.28 – Scene with no postprocessing (Unity)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.28_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.28 – Scene with no postprocessing (Unity)
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 2.29*, applying postprocessing enhances the overall look
    of the Scene and delivers stunning effects:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.29 – Scene with postprocessing (Unity)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.29_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.29 – Scene with postprocessing (Unity)
  prefs: []
  type: TYPE_NORMAL
- en: 'It is worth noting that in order to use `OnRenderImage` correctly, you need
    to attach the script that implements this function to the GameObject that the
    Camera component is attached to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: 'Sometimes, you may need to create some UI to do some prototypes or conduct
    some tests. Then, `OnGUI` is an ideal option for you. You can create an `OnGUI`
    function:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: The GUI line is a `if` statement. This is because the code in the `if` block
    needs to be executed when the button is clicked. Specifically, taking the preceding
    code as an example, when the game is running and the button is clicked, this `if`
    statement returns `true` and executes the `Debug.Log("Hello World")` line in the
    `if` block to print out **Hello World** in the **Console** window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.30 – IMGUI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.30_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.30 – IMGUI
  prefs: []
  type: TYPE_NORMAL
- en: The preceding screenshot shows an IMGUI button and the message printed in the
    Console window by clicking this button.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we explained the life cycle of a script instance and some commonly
    used event functions offered by the Unity engine. In the next section, we will
    explore how to create a script file that will interact with the engine and add
    it as a component to a GameObject in the Scene.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a script and using it as a component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In addition to Unity's built-in components, we can also create script components.
    When you create a script and attach it to a GameObject, you can see the component
    you created in the GameObject's **Inspector** window, just like Unity's built-in
    components.
  prefs: []
  type: TYPE_NORMAL
- en: How to create a new script in Unity
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It is very easy to create a new C# script in Unity. I will introduce two different
    ways to do it.
  prefs: []
  type: TYPE_NORMAL
- en: Firstly, you can right-click the **Project** panel in the Unity Editor, and
    then a menu will pop up. You only need to select **Create** | **C# Script**, then
    the Unity Editor will create a C# file in the folder identified in the **Project**
    panel.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.31 – Creating a new C# script from the Create menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.31_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.31 – Creating a new C# script from the Create menu
  prefs: []
  type: TYPE_NORMAL
- en: The filename of the new script is `NewBehaviourScript.cs` by default. You can
    change the name when creating it.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.32 – Changing the name of the script when creating it'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.32_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.32 – Changing the name of the script when creating it
  prefs: []
  type: TYPE_NORMAL
- en: For example, in the previous screenshot, the new C# file will be created in
    the `Assets/Chapter 2/Scripts` folder. In this way, the newly created script will
    not be automatically attached to a GameObject in the Scene. You need to manually
    add it to a GameObject later.
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, you can also create a script and attach this script to a
    GameObject directly. What you need to do is to select a GameObject in the Scene
    and click `Assets` folder of your project.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.33 – Creating a new script from the Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.33_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.33 – Creating a new script from the Inspector window
  prefs: []
  type: TYPE_NORMAL
- en: Similar to creating a new script in the `NewBehaviourScript.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.34 – Changing the name of the script when creating it'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.34_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.34 – Changing the name of the script when creating it
  prefs: []
  type: TYPE_NORMAL
- en: If you want to open the script in the IDE, we have set Visual Studio 2019 as
    the IDE for the Unity project; you can double-click the script file to open it
    in Visual Studio 2019\. You will find the name of the C# class is the same as
    the name of the script file.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.35 – C# class name and the filename of the script'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.35_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.35 – C# class name and the filename of the script
  prefs: []
  type: TYPE_NORMAL
- en: Adding a script as a component to a GameObject in the Scene
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In the previous section, we introduced how to create a new script and attach
    it to a GameObject automatically. But we still need to learn how to add a script
    to a GameObject manually in the Editor and add a script component to a GameObject
    through C# code at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a script component to a GameObject in the Editor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The easiest way to add a script as a component to a GameObject in the Unity
    Editor is to drag the script file to the GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: 'However, the following two situations may cause the script to not be added
    to the GameObject:'
  prefs: []
  type: TYPE_NORMAL
- en: The filename and the class name are different. This is why the name of the script
    is the same as the class name when the script is created. However, you may change
    one of them by mistake. So, if you cannot add a script to a GameObject, check
    the filename and the class name first.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The second reason is relatively obvious: there are compile errors in the script.
    In this situation, the **Console** window will print out the compile errors. You
    need to fix all of these errors so that you can add them to a GameObject.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 2.36 – Can''t add script message'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.36_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.36 – Can't add script message
  prefs: []
  type: TYPE_NORMAL
- en: 'You can also add a script component to the GameObject from the **Inspector**
    window. The following steps demonstrate how to do it:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the GameObject that you want to attach the script to.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Add Component** button in the **Inspector** window. Not only will
    the scripts we created be added, but also lots of built-in components can be added
    to the GameObject.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In order to quickly find the script that needs to be added, we can enter the
    name of the script in the search box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Finally, select the target script in the drop-down box.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.37 – Adding a component from the Inspector window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.37_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.37 – Adding a component from the Inspector window
  prefs: []
  type: TYPE_NORMAL
- en: Adding a script component to a GameObject at runtime
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In addition to manually adding script components to a GameObject in the Editor,
    we can also add components to a GameObject through C# code at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s open the `Test.cs` file we just created in Visual Studio 2019 and add
    a new field, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A field is a variable of any type that is declared directly in a class or struct.
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that the name of the private field of the `HelloWorld` type
    is `_helloWorld`, and you will also find that a `[SerializeField]` attribute is
    placed on the declaration of `_helloWorld`. This is to allow Unity to serialize
    this private field. We will discuss the serialization system in Unity in later
    chapters, but you should understand that when Unity serializes a script, it only
    serializes public fields by default. If a variable can be serialized by Unity,
    then it can be displayed and modified in the Unity Editor. So, you can use a public
    field here. However, generally, it is a good idea to use fields only for variables
    that have private or protected accessibility. This is why Unity provides developers
    with the `[SerializeField]` attribute, which will force Unity to serialize private
    fields.
  prefs: []
  type: TYPE_NORMAL
- en: Then, we add the Test script component to a GameObject in the Scene by dragging
    it to the GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.38 – A GameObject with a Test component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.38_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.38 – A GameObject with a Test component
  prefs: []
  type: TYPE_NORMAL
- en: You can see that there is the serialized field of the Test script component
    attached to the GameObject in the previous screenshot. The value of this field
    is `Test.cs` script to attach the `HelloWorld` script component to the same GameObject
    and assign a reference to this new `HelloWorld` component to this field.
  prefs: []
  type: TYPE_NORMAL
- en: 'Because we only want the code to run once, we can modify the `Start` function,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are calling the `AddComponent<T>` method, which is a generic method
    to add the `HelloWorld` component to this GameObject, and it will return the reference
    to the attached component, so we can assign this value to the `_helloWorld` field.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: A generic method is a method that is declared with type parameters. The preceding
    code shows how to call the `AddComponent<T>` method by using `HelloWorld` for
    the type argument.
  prefs: []
  type: TYPE_NORMAL
- en: It is worth noting that in addition to the generic method, there is also a version
    of `AddComponent`, which is `AddComponent(string className)`, a method with a
    string argument. It has been deprecated, so you should no longer use this method,
    but instead use the generic version.
  prefs: []
  type: TYPE_NORMAL
- en: Play the game by clicking the **Play** button in the Unity Editor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.39 – Attaching the HelloWorld component at runtime'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.39_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.39 – Attaching the HelloWorld component at runtime
  prefs: []
  type: TYPE_NORMAL
- en: Looking at the `HelloWorld` component attached to the GameObject, and the reference
    to this component is assigned to the field of the Test component.
  prefs: []
  type: TYPE_NORMAL
- en: Well done. Now we have learned how to add components to the GameObjects in the
    Scene. Next, let's explore how to access components on the same GameObject or
    different GameObjects through C# code.
  prefs: []
  type: TYPE_NORMAL
- en: Accessing a component attached to a GameObject
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we develop a Unity project, we often need to access other components, because
    we can reuse the functions defined by different components.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here, let''s add some code to the `HelloWorld.cs` script to print a **Hello
    World!** message to the Console window in the Editor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The `Debug.Log` line in the `SayHi` method is a commonly used method to print
    messages that can help you debug your game to the Console window. The `Debug`
    class also offers many other methods, such as `LogError`, `LogWarning`, and `Assert`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can think of this as a feature that we want to reuse in different scripts.
    Then, we also need to create a new script called `TestGetComponent.cs`. This is
    the script where we will place the code to access the `HelloWorld` component at
    runtime:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: As we already know that the `Update` function runs at every frame of the game,
    in order to demonstrate how to access a component, we can put the code in the
    `Update` function, as shown in the code of the `TestGetComponent` class.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.40 – A GameObject with the TestGetComponent component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.40_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.40 – A GameObject with the TestGetComponent component
  prefs: []
  type: TYPE_NORMAL
- en: Then, we attach the `TestGetComponent` script to the same GameObject as a component,
    play the game, and look at the Console window. The **Hello World!** message appears
    there.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.41 – Hello World! appears in the Console window'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.41_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.41 – Hello World! appears in the Console window
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: For performance reasons, it is recommended to not use this function in every
    frame.
  prefs: []
  type: TYPE_NORMAL
- en: In this case, we accessed other components attached to the same GameObject.
    Additionally, we can also access other components on different GameObjects.
  prefs: []
  type: TYPE_NORMAL
- en: 'Firstly, we need to get the reference of the target GameObject. Here, we can
    either assign the referenced object to this script in the Editor or use the `GameObject.Find`
    method to find the target object at runtime. From the perspective of game performance,
    don''t call the `GameObject.Find` method to find the target object in a method
    such as `Update` that is called at every frame. If you can''t assign a reference
    to your script in the Editor, for example, the referenced object is dynamically
    created at runtime, then you can use this method to find the target object and
    cache the target object instead of finding the target object at every frame. In
    this example, we can find the target object and cache it in the `Start` method,
    as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, let''s change the `Update` function of the `TestGetComponent` class,
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, we are using the `GameObject.Find(string name)` function to find a GameObject
    by name and return it. The name of the target GameObject is `GameObjectTest`.
  prefs: []
  type: TYPE_NORMAL
- en: There are other functions that can be used to look for a GameObject at runtime,
    such as `GameObject.FindWithTag(string tag)`, which returns one active GameObject
    tagged `tag`. However, in order to use this function correctly, the tag must first
    be declared in the tag manager. You can manage these tags from **Project Settings**
    | **Tags and Layers**.
  prefs: []
  type: TYPE_NORMAL
- en: However, as we mentioned earlier, the `Find` method and its variants are not
    recommended to find GameObjects. This example is just to demonstrate how to call
    the method at runtime to find the target object if you need to find dynamically
    created objects at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we create a new GameObject and attach the `TestGetComponent` script to
    it. At the same time, remove the `TestGetComponent` script from the target GameObject
    named `GameObjectTest`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.42 – A GameObject with the TestGetComponent component'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.42_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.42 – A GameObject with the TestGetComponent component
  prefs: []
  type: TYPE_NORMAL
- en: Play the game and look at the Console window. The same **Hello World!** message
    appears there again.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to create a new script in Unity and how to attach
    a script as a component to a GameObject, and also discussed how to access a component
    through code at runtime to reuse functions. Next, let's explore the Unity Package
    Manager and packages in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: Packages and the Unity Package Manager
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: If you are a .NET developer, then I believe that you must know the **NuGet**
    package manager. The Package Manager in Unity is very similar to NuGet, which
    enables game developers to share and consume useful code. But they are different.
    In Unity, you can reuse not only useful code but also digital assets, Shaders,
    plugins, and icons. A package in Unity is a container that includes the contents
    mentioned earlier.
  prefs: []
  type: TYPE_NORMAL
- en: In this section, I will introduce packages and Package Manager in Unity so that
    you can understand the package mechanism in Unity and how to use the Unity Package
    Manager to manage packages.
  prefs: []
  type: TYPE_NORMAL
- en: Unity Package Manager
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity provides game developers with a tool called the Unity Package Manager
    to manage the packages in a project and add new packages to the project. We can
    open the Package Manager window by clicking **Window** | **Package Manager**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.43 – Opening the Package Manager window from the Window menu'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.43_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.43 – Opening the Package Manager window from the Window menu
  prefs: []
  type: TYPE_NORMAL
- en: By default, this window shows the installed packages in your project and the
    version of each package. If a new version of a package is available, there will
    be an **upgrade** icon beside the version number. You can also sort these packages,
    for example, in ascending order by name or descending order by release date.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.44 – Unity Package Manager'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.44_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.44 – Unity Package Manager
  prefs: []
  type: TYPE_NORMAL
- en: On the right side of the window, detailed information on the currently selected
    package will be displayed, such as the package name, publisher, release date,
    version number, document link, and description. You can also remove a package
    from your project by clicking the **Remove** button in the lower-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.45 – Switching package lists'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.45_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.45 – Switching package lists
  prefs: []
  type: TYPE_NORMAL
- en: This window can also display different lists. For example, you can view, download,
    and import assets purchased from the Unity Asset Store ([https://assetstore.unity.com/](https://assetstore.unity.com/))
    by selecting the **My Assets** option from the drop-down menu.
  prefs: []
  type: TYPE_NORMAL
- en: The assets purchased from the Asset Store may be free or paid. The Asset Store
    provides a variety of assets, covering everything from textures, models, and animations
    to entire project examples.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.46 – Packages in Unity Registry'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.46_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.46 – Packages in Unity Registry
  prefs: []
  type: TYPE_NORMAL
- en: You can also install a package from Unity Registry. By selecting the **Unity
    Registry** option from the drop-down menu, you can browse all packages registered
    in Unity Registry. If you want to install a package, you need to select it and
    click the **Install** button in the lower-right corner.
  prefs: []
  type: TYPE_NORMAL
- en: In addition to installing a package from Unity Registry, the Unity Package Manager
    also provides other ways to install a package, that is, installing a new package
    from a local folder, installing a new package from a local tarball file, and installing
    a new package using a Git URL.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.47 – Installing a new package'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.47_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.47 – Installing a new package
  prefs: []
  type: TYPE_NORMAL
- en: You can use these three different ways to add a new package by clicking the
    **+** button in the upper-left corner of the Package Manager window.
  prefs: []
  type: TYPE_NORMAL
- en: Some of the built-in features of the Unity game engine are also provided as
    packages. You can view the list of all built-in packages by selecting the **Built-in**
    option from the drop-down menu. Here, you can manage these built-in features.
    You can reduce the runtime build size of your game by disabling packages that
    you do not need. For example, if you develop a game without VR or AR functionality,
    you can disable XR-related packages by clicking the **Disable** button in the
    lower-right corner of the **Package Manager** window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.48 – Built-in packages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.48_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.48 – Built-in packages
  prefs: []
  type: TYPE_NORMAL
- en: Package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A package is a container that contains features to meet various needs of a project.
    You can add a new feature to your game by adding a package. For example, the **AR
    Foundation** package will provide AR functionality. You can also remove a package
    to reduce the size of your game. Therefore, the use of packages makes Unity game
    development more flexible and decoupled.
  prefs: []
  type: TYPE_NORMAL
- en: However, if you are not careful, using a package may also make your game full
    of bugs. This is because different packages may be in different states.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.49 – Package life cycle with Unity Package Manager (Unity)'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.49_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.49 – Package life cycle with Unity Package Manager (Unity)
  prefs: []
  type: TYPE_NORMAL
- en: 'A package developed and maintained by Unity may be in one of the following
    two states:'
  prefs: []
  type: TYPE_NORMAL
- en: Preview packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Verified packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A package in preview means that it is currently ready for testing, and it may
    go through many changes in later versions. Unity cannot guarantee future support
    for preview packages, so you should not use them in production.
  prefs: []
  type: TYPE_NORMAL
- en: 'By default, you cannot find packages in the preview state in the Package Manager
    window. If you really need to use the preview packages, for example, to test new
    features for future projects, you can follow these steps to allow the Package
    Manager window to display the packages in the preview state:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Project Settings** window for the Package Manager by clicking the
    gear icon and then clicking the **Advanced Project Settings** item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.50 – Advanced Project Settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.50_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.50 – Advanced Project Settings
  prefs: []
  type: TYPE_NORMAL
- en: Check the **Enable Preview Packages** option.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.51 – Package Manager settings'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.51_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.51 – Package Manager settings
  prefs: []
  type: TYPE_NORMAL
- en: Then, look at the Package Manager window. You will see that the preview packages
    appear in the package list. In the package list, all packages in the preview state
    are marked with **Preview**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 2.52 – Preview packages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.52_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.52 – Preview packages
  prefs: []
  type: TYPE_NORMAL
- en: On the other hand, a package in the verified state means it can be used in production.
    A package will only be considered a verified package if it has been rigorously
    tested and Unity guarantees supporting that verified package.
  prefs: []
  type: TYPE_NORMAL
- en: The Package Manager window displays the verified packages list by default. Packages
    in the verified state are marked with **Verified**.
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 2.53 – Verified packages'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_2.53_B17146.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 2.53 – Verified packages
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we started by introducing some of the most commonly used classes
    in Unity script programming, and then explained the life cycle and important event
    functions of a script instance, as well as discussing how Unity initializes a
    script and how the game logic is updated in a script.
  prefs: []
  type: TYPE_NORMAL
- en: We also discussed how to create a new script in Unity and how to attach a script
    as a component to a GameObject. In addition to manually adding components in the
    Editor, we can also use C# code to dynamically add a component or access a component
    at runtime.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we demonstrated how to add or remove a package through the Unity Package
    Manager to provide a feature or reduce the size of the game. At the same time,
    we also explained the difference between preview packages and verified packages.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will learn about the UI system in Unity and, at the
    same time, we will also introduce how to optimize UI performance in Unity.
  prefs: []
  type: TYPE_NORMAL
