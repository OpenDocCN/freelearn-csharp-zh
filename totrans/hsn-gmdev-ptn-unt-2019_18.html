<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">Adapter</h1>
                </header>
            
            <article>
                
<p>In a world full of different types of cables and plugs, we have all become accustomed to the concept of adapters. The Adapter pattern will be one of those patterns that will be easy for you to grasp, because it correlates so perfectly with our real-world experiences with technology. The Adapter pattern's name perfectly reveals its core purpose; it offers us a way to seamlessly use old code with new code by adding an interface between the code that will act as an Adapter.</p>
<p>The following topics will be covered in this chapter:</p>
<ul>
<li>We will review the basics of the Adapter pattern.</li>
<li>We will use the Adapter pattern to adjust an online user management system without modifying any code.</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Technical requirements</h1>
                </header>
            
            <article>
                
<p class="mce-root">This chapter is a hands-on chapter; you will need to have a basic understanding of Unity and C#.<br/></p>
<p>We will be using the following specific Unity engine and C# language concept:</p>
<ul>
<li>Sealed class</li>
</ul>
<p>If you are unfamiliar with this concept, please review it before starting this chapter.</p>
<p>The code files of this chapter can be found on GitHub:</p>
<p><a href="https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018">https://github.com/PacktPublishing/Hands-On-Game-Development-Patterns-with-Unity-2018</a></p>
<p class="mce-root">Check out the following video to see the code in action:</p>
<p><a href="http://bit.ly/2UieM9v">http://bit.ly/2UieM9v</a></p>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">An overview of the Adapter pattern</h1>
                </header>
            
            <article>
                
<p class="mce-root">As its name implies, the Adapter pattern adapts two incompatible interfaces; like a plug adapter, it doesn't modify what it adjusts, but bridges one interface with another. This approach can be beneficial when you are dealing with legacy code that you cannot refactor due to its fragility.</p>
<p class="mce-root">They are two main approaches to implementing the Adapter pattern; here's a quick breakdown:</p>
<ul>
<li class="mce-root"><strong>Object adapter</strong>: A simple approach that uses composition</li>
<li class="mce-root"><strong>Class adapter</strong>: A more advanced approach that uses inheritance</li>
</ul>
<p>Trying to learn both at the same time can get confusing, so in this chapter, we will try to focus on the core purpose of the Adapter pattern by implementing an object adapter and briefly reviewing the class adapter afterward.</p>
<p>Let's take a look at a side-by-side diagram of the Object and Class adapters; the core differences can be subtle, but the similarities are apparent:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/98b3339b-57b7-4db4-ac53-d2e0a72eaf80.png" style="width:36.08em;height:30.67em;"/></p>
<p>As you can see, in both cases, the <strong>Adapter</strong> class is positioned between the <strong>Client</strong> and the class that's being adapted (<strong>Adaptee</strong>). They only differ through their relationship to the <strong>Adaptee</strong>.</p>
<p>So, the core differences between the <strong>Object</strong> and <strong>Class</strong> adapters are as follows:</p>
<ul>
<li>The <strong>Object Adapter</strong> usually contains an instance of the <strong>Adaptee</strong> and translates the calls from the <strong>Client</strong> to the <strong>Adaptee</strong>; in other words, it acts slightly like a wrapper.</li>
<li>The <strong>Class Adapter</strong> implements the expected interface while inheriting the <strong>Adaptee</strong>; it's a more advanced approach to adaption.</li>
</ul>
<p>From experience, I have found that the Adapter pattern can sometimes be confused with the Facade pattern. It's essential we understand that the core difference between them is that the Facade pattern offers a simple interface to a complicated collection of interdependent sub-systems, while the Adapter pattern adapts an interface of another class so that it's consistent with the expectations of a client.</p>
<p>So, if you're attempting to adapt access to multiple classes with a singular interface, then you are probably implementing a Facade and not an Adapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Benefits and drawbacks</h1>
                </header>
            
            <article>
                
<p>I don't consider the Adapter pattern a long-term solution to architecture issues; even though it offers some benefits, its long-term drawbacks should always be taken into consideration.</p>
<p>The following are the benefits:</p>
<ul>
<li><strong>Adapting without modifying</strong>: The main benefit of the Adapter pattern is that it offers a standard approach to adapting code without modifying it.</li>
<li><strong>Reusability and flexibility</strong>: This pattern permits continuing to use legacy code with new systems with a minimal amount of changes; this has an immediate return on investment.</li>
</ul>
<p class="mce-root"/>
<p class="mce-root"/>
<p><span>The following are the </span>drawbacks:</p>
<ul>
<li><strong>Persisting legacy</strong>: The ability to use legacy code with new systems is cost-effective, but in the long term, it can become an issue, because the old code might limit your upgrading options as it becomes deprecated and incompatible with new versions of Unity or third-party libraries.</li>
<li><strong>Slight overhead</strong>: Because you are redirecting calls between objects, there might be a slight performance hit.</li>
</ul>
<div class="packt_tip">From experience, migrating code bases from one version of Unity to another can be quite time-consuming. So, don't be surprised if you end up having multiple versions of Unity installed on your computer so that you can maintain legacy code that's too expensive to upgrade.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Use case example</h1>
                </header>
            
            <article>
                
<p class="mce-root">Let's suppose that we are dealing with a typical real-world game development scenario. Our lead online programmer is on vacation and has left explicit instructions that we should not make any modifications to his online player management system during his absence. However, our producer needs a change to our online components because he wants to showcase our live streaming service to a new investor.</p>
<p>To accomplish this in time, we will need to make changes; so, we have two choices:</p>
<ul>
<li>Modify the online player management system directly, even if we are not the owner of this section of the code base and don't understand it well.</li>
<li>Find a way to extend the current system and implement the requested changes using a temporary adapter, which will limit the direct modification of our colleague's code.</li>
</ul>
<p>With the Adapter pattern, we can implement the second option in a structured and consistent manner. In the next section, we will apply this use case with a straightforward example, which will undoubtedly showcase the usefulness of this pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Code example</h1>
                </header>
            
            <article>
                
<p>As we have mentioned, we are going to implement a change to our online player management system by adapting the <kbd>OnlinePlayer</kbd> class, without modifying it directly. The example is straightforward, but from experience, it's always better to learn a new pattern by implementing the simplest systems first.</p>
<p class="mce-root"/>
<p>For reasons of brevity, we are going to adapt the way the following <kbd>OnlinePlayer</kbd> class returns the full name of a specific player. Let's keep in mind that we can't refactor or extend this class; we can only adapt it. We will do this by using these two primary forms of the Adapter pattern:</p>
<ul>
<li>Object adapter</li>
<li>Class adapter</li>
</ul>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Object adapter</h1>
                </header>
            
            <article>
                
<p>The following <kbd>OnlinePlayer</kbd> class can return the first and last name of an online player, as well as their full name. However, the programmer that implemented the class decided to return the string in a formal naming structure. We need to have the full name in a standard sequence, which is the first then the last name.</p>
<p>Of course, we could call the first and last name <kbd>GET</kbd> functions individually, and then concatenate them together in our client, but this means that we will have to do it everywhere that we might need to get a user's full name. In other words, we lose consistency and localized control of how the full name is returned. You can imagine how this could become risky if we were to adapt something more complex, such as an in-game currency transaction system:</p>
<pre>public sealed class OnlinePlayer : ScriptableObject<br/>{<br/>    public string GetFirstName(int id)<br/>    {<br/>        // Lookup online database.<br/>        return "John"; // Retun a placeholder name.<br/>    }<br/><br/>    public string GetLastName(int id)<br/>    {<br/>        // Lookup online database.<br/>        return "Doe"; // Return a placeholder last name.<br/>    }<br/><br/>    public string GetFullName(int id)<br/>    {<br/>        // Lookup online database and get full name <br/>        return "Doe Jonn";<br/>    }<br/>}</pre>
<p>There's something else important to note in the <kbd>OnlinePlayer</kbd> class; it's <kbd>sealed</kbd>, which means that we can't use it as a base class. As a consequence, we can't extend it directly, so adapting it is our only option:</p>
<ol>
<li>Let's build an adapter class that will fix our issue with the <kbd>GetFullName()</kbd> function:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class OnlinePlayerObjectAdapter : ScriptableObject<br/>{<br/>    public string GetFullName(OnlinePlayer onlinePlayer, int userId)<br/>    {<br/>        return onlinePlayer.GetFirstName(userId) + " " + onlinePlayer.GetLastName(userId);<br/>    }<br/>}</pre>
<p style="padding-left: 60px">As you can see, the <kbd>OnlinePlayerObjectAdapter</kbd> class receives an instance of the <kbd>OnlinePlayer</kbd> class and wraps the <kbd>GetFullName()</kbd> method, so it returns the expected full name format. So, we are not modifying or extending the behavior of the class that's being adapted, but are merely adjusting it to the client's expectations.</p>
<ol start="2">
<li>Let's implement a <kbd>Client</kbd> class in order to test our implementation:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Client : MonoBehaviour<br/>{<br/>    private OnlinePlayer m_OnlinePlayer;<br/>    private OnlinePlayerObjectAdapter m_OnlinePlayerAdapter;<br/><br/>    void Update()<br/>    {<br/>        if (Input.GetKeyDown(KeyCode.U))<br/>        {<br/>            m_OnlinePlayer = ScriptableObject.CreateInstance&lt;OnlinePlayer&gt;();<br/>            m_OnlinePlayerAdapter = ScriptableObject.CreateInstance&lt;OnlinePlayerObjectAdapter&gt;();<br/><br/>            string FirstName = m_OnlinePlayer.GetFirstName(79);<br/>            string LastName = m_OnlinePlayer.GetLastName(79);<br/><br/>            string FullNameLastFirst = m_OnlinePlayer.GetFullName(79);<br/>            string FullNameFirstLast = m_OnlinePlayerAdapter.GetFullName(m_OnlinePlayer, 79);<br/><br/>            Debug.Log(FirstName);<br/>            Debug.Log(LastName);<br/>            Debug.Log(FullNameLastFirst);<br/>            Debug.Log(FullNameFirstLast);<br/>        }<br/>    }<br/>}</pre>
<p>Now that we have an adapter, we have access to the <kbd>OnlinePlayer</kbd> class's original implementation of the <kbd>GetFullName()</kbd> function, and also an adapted version of it. This approach offers us a lot of flexibility with minimal risk, because we are not modifying anything, but are merely adapting.</p>
<p>In this section, we implemented a simple example of the object adapter. In the next section, we will review a sophisticated approach to the adapter by implementing a class adapter.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Class adapter</h1>
                </header>
            
            <article>
                
<p>There's one detail that we are going to modify in our <kbd>OnlinePlayer</kbd> class for this section; we are going to remove the sealed modifier, because we want to be able to inherit the <kbd>OnlinePlayer</kbd> class. So, let's pretend that it was never there in the first place:</p>
<pre>public class OnlinePlayer : ScriptableObject<br/>{<br/>    public string GetFirstName(int id)<br/>    {<br/>        // Lookup online database.<br/>        return "John"; // Retun a placeholder name.<br/>    }<br/><br/>    public string GetLastName(int id)<br/>    {<br/>        // Lookup online database.<br/>        return "Doe"; // Return a placeholder last name.<br/>    }<br/><br/>    public string GetFullName(int id)<br/>    {<br/>        // Lookup online database and pull the full name in this sequence [Last Name &amp; First Name].<br/>        return "Doe Jonn";<br/>    }<br/>}</pre>
<p><span>To implement the class adapter approach, let's follow a step-by-step procedure:</span></p>
<ol>
<li><span>Let's start by implementing a target interface for our clients; we are going to call it <kbd>IOnlinePlayer</kbd>:</span></li>
</ol>
<pre style="padding-left: 60px">public interface iOnlinePlayer<br/>{<br/>    string GetFirstName(int userID);<br/>    string GetLastName(int userID);<br/>    string GetFullNameLastFirst(int userID);<br/>    string GetFullNameFirstLast(int userID);<br/>}</pre>
<p style="padding-left: 60px">You should notice that we are adapting the <kbd>OnlinePlayer</kbd> <span>class </span>by adding a new interface that will expose the new functionality for the class that we are improving. This approach is flexible, as you will see in the following steps.</p>
<ol start="2">
<li>Now, in our adapter class, we are going to implement the <kbd>IOnliePlayer</kbd> interface:</li>
</ol>
<pre style="padding-left: 60px">public class OnlinePlayerClassAdapter : OnlinePlayer, iOnlinePlayer<br/>{<br/>    public string GetFullNameLastFirst(int userId)<br/>    {<br/>        return GetFullName(userId);<br/>    }<br/><br/>    public string GetFullNameFirstLast(int userId)<br/>    {<br/>        return GetFirstName(userId) + " " + GetLastName(userId);<br/>    }<br/>}</pre>
<p style="padding-left: 60px">It looks simple, but there are a lot of things going on. Let's try to unwrap this:</p>
<ul>
<li style="padding-left: 30px"><kbd>OnlinePlayerClassAdapter</kbd> is implementing the <kbd>IOnlinePlayer</kbd> interface.</li>
<li style="padding-left: 30px"><kbd>OnlinePlayerClassAdapter</kbd> is also inheriting the <kbd>OnlinePlayer</kbd> class.</li>
<li style="padding-left: 30px">Because we are inheriting the <kbd>OnlinePlayer</kbd> class, <kbd>GetFirstName()</kbd> and <kbd>GetLastName()</kbd> are implemented by default.</li>
<li style="padding-left: 30px"><kbd>OnlinePlayerClassAdapter</kbd> only needs to explicitly implement <kbd>GetFullNameLastFirst()</kbd> and <kbd>GetFullNameFirstLast()</kbd>.</li>
<li style="padding-left: 30px"><kbd>GetFullNameLastFirst()</kbd> redirects the call to <kbd>GetFullName()</kbd>, implemented inside the <kbd>OnlinePlayer</kbd> parent class.</li>
<li style="padding-left: 30px"><kbd>GetFullNameFirstLast()</kbd> actually adapts the way that we return a full name to a client.</li>
</ul>
<ol start="3">
<li>Let's look at how we can use this to our advantage with a <kbd>Client</kbd> class:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>public class Client : MonoBehaviour<br/>{<br/>    private iOnlinePlayer m_OnlinePlayer;<br/><br/>    void Update()<br/>    {<br/>        if (Input.GetKeyDown(KeyCode.U))<br/>        {<br/>            m_OnlinePlayer = ScriptableObject.CreateInstance&lt;OnlinePlayerClassAdapter&gt;();<br/><br/>            string FirstName = m_OnlinePlayer.GetFirstName(79);<br/>            string LastName = m_OnlinePlayer.GetLastName(79);<br/><br/>            string FullNameLastFirst = m_OnlinePlayer.GetFullNameLastFirst(79);<br/>            string FullNameFirstLast= m_OnlinePlayer.GetFullNameFirstLast(79);<br/><br/>            Debug.Log(FirstName);<br/>            Debug.Log(LastName);<br/>            Debug.Log(FullNameLastFirst);<br/>            Debug.Log(FullNameFirstLast);<br/>        }<br/>    }<br/>}</pre>
<p>We have decoupled the client from the adapted class because we only need to point it towards the adapter during the assignment of the <kbd>m_OnlinePlayer</kbd> member variable. For the client, the interaction with the adapted <kbd>OnlinePlayer</kbd> class is relatively transparent and is consistent with the previous implementations.</p>
<p>In other words, we were able to adapt the <kbd>OnlinePlayer</kbd> class without modifying it while maintaining a consistent interface. That's the core purpose of the Adapter pattern.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>In this chapter, we added the Adapter pattern to our toolbox. It's a type of pattern that's very useful in the field, because one of the biggest challenges for a professional programmer is dealing with legacy code, which is often maintained by people you don't know. So, having a consistent approach to adapting other peoples' code without causing regression with unnecessary changes is the secret to a long career and a good reputation.</p>
<p>In the next chapter, we will review the decorator, a more complex and advanced structural pattern.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Exercises</h1>
                </header>
            
            <article>
                
<p class="mce-root">In this chapter, we implemented a straightforward use case of the Adapter pattern, but its return on investment is in adapting legacy code into a new context. As an exercise, I recommend looking into your Unity projects and finding components or systems that you could adapt from one project to another without modifying them.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Further reading</h1>
                </header>
            
            <article>
                
<ul>
<li><span><em>Game Programming Patterns</em> by Robert Nystrom: <a href="http://gameprogrammingpatterns.com/">http://gameprogrammingpatterns.com</a><a href="http://gameprogrammingpatterns.com/"/></span></li>
</ul>


            </article>

            
        </section>
    </body></html>