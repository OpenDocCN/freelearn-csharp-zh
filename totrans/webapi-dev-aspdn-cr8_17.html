<html><head></head><body>
<div><h1 class="chapter-number" id="_idParaDest-363"><a id="_idTextAnchor698"/>17</h1>
<h1 id="_idParaDest-364"><a id="_idTextAnchor699"/>Cloud-Native Patterns</h1>
<p>In the preceding chapters, we have covered a range of fundamental skills for web API development using ASP.NET Core. We discussed different styles of API development, such as REST, gRPC, and GraphQL, and how to implement the data access layer using Entity Framework Core. We also introduced how to secure a web API using the ASP.NET Core Identity framework. Additionally, we learned how to write unit tests and integration tests for web API applications, as well as common practices for API development, such as testing, caching, observability, and more. We also discussed how to deploy the containerized web API application to the cloud by using CI/CD pipelines. These are all essential skills for web API development.</p>
<p>However, this is just the beginning of the journey. As we wrap up our exploration of the fundamental concepts of web API development using ASP.NET Core, it is time to embark on a journey to explore more advanced topics. In this chapter, we will transition from the basics to delve into topics that are important for developers aspiring to master web API development. Now, let us elevate our skills to the next level.</p>
<p>We will delve into the following topics in this chapter:</p>
<ul>
<li>Domain-driven design</li>
<li>Clean architecture</li>
<li>Microservices</li>
<li>Web API design patterns</li>
</ul>
<p>By the end of this chapter, you will have a high-level understanding of these topics and be able to explore them further on your own.</p>
<h1 id="_idParaDest-365"><a id="_idTextAnchor700"/>Technical requirements</h1>
<p>The code example in this chapter can be found at <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter17">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter17</a>.</p>
<h1 id="_idParaDest-366"><a id="_idTextAnchor701"/>Domain-driven design</h1>
<p>The<a id="_idIndexMarker1929"/> term <strong class="bold">domain-driven design</strong>, also known as <strong class="bold">DDD</strong>, was coined by Eric Evans in his book <em class="italic">Domain-Driven Design: Tackling Complexity in the Heart of Software</em>, published in 2003. DDD consists of a set of <a id="_idIndexMarker1930"/>principles and practices that focus on the domain model and domain logic, which help developers manage the complexity and build flexible and maintainable software. DDD is not bound to any particular technology or framework. You can use it in any software project, including web API development.</p>
<p>In Eric Evans’ book, he <a id="_idIndexMarker1931"/>defines three important principles of DDD:</p>
<ul>
<li>Focusing on the core domain and domain logic</li>
<li>Basing complex designs on the domain models</li>
<li>Collaborating with technical and domain experts to iteratively refine the model that solves domain problems</li>
</ul>
<p>A domain <a id="_idIndexMarker1932"/>is a subject area that the software system is built for. The domain model is a conceptual model of the domain, which incorporates both data and behavior. Developers build the domain model based on the domain knowledge from domain experts. The domain model is the core of the software system that can be used to solve domain problems.</p>
<p>In the following subsections, we will introduce the basic concepts of DDD and how to apply them to web API development. Note that domain-driven design is a comprehensive topic that cannot be covered in a single chapter. So, the subsections are not intended to be a complete guide to DDD. Instead, it will provide a high-level overview of DDD and explain some of the key concepts of DDD. If you want to learn more about DDD, you can refer to other resources, such as Eric Evans’ DDD bo<a id="_idTextAnchor702"/>ok.</p>
<h2 id="_idParaDest-367"><a id="_idTextAnchor703"/>Ubiquitous language</h2>
<p>One of<a id="_idIndexMarker1933"/> the core concepts of DDD is that to build a software system for a complex business domain, we need to build ubiquitous language and a domain model that reflects the business domain. Under domain-driven design, the software structure and code, such as class names, class methods, and so on, should match the business domain. The domain terms should be embedded in the code. When developers talk to domain experts, they should use the same terms. For example, if we are building a web API for a banking system, we may have a <code>Banking</code> domain. When we discuss the requirements with domain experts, we may hear terms such as <code>Account</code>, <code>Transaction</code>, <code>Deposit</code>, <code>Withdrawal</code>, and so on. In a banking system, an <code>Account</code> object can have different types, such as <code>SavingAccount</code>, <code>LoanAccount</code>, <code>CreditCardAccount</code>, and so on. A <code>SavingAccount</code> may have a <code>Deposit()</code> method and a <code>Withdrawal()</code> method. In the code of the system, we should use the same terms as the domain experts.</p>
<p>The use of <a id="_idIndexMarker1934"/>a ubiquitous language is an essential pillar of DDD. This language provides a common understanding between domain experts, developers, and users, allowing them to effectively communicate system requirements, design, and implementation. By consciously using the ubiquitous language in the code, developers can build a domain model that accurately reflects the business domain. Without this, the code may become disconnected from the business domain and become difficult to ma<a id="_idTextAnchor704"/>nage.</p>
<h2 id="_idParaDest-368"><a id="_idTextAnchor705"/>Bounded context</h2>
<p>In the realm<a id="_idIndexMarker1935"/> of DDD, the concept of a bounded context is essential. A bounded context is a boundary that defines a domain model and serves as a delineated area of responsibility within a software system. It is like a linguistic territory in which a specific model holds meaning and relevance. By encapsulating a distinct understanding of the domain, bounded contexts promote clarity and precision in communication between domain experts and developers.</p>
<p>Consider a scenario where we are building a web API for a banking system. Without bounded contexts, the term <code>Account</code> could be interpreted differently in the <code>Banking </code>domain and the <code>customer relationship management</code> (CRM) domain. This ambiguity can lead to confusion, misaligned expectations, and ultimately, a fragmented understanding of the entire system. To avoid this, bounded contexts should be used to clearly define the scope of the domain model.</p>
<p>In many cases, a domain consists of several subdomains, each of which may refer to a distinct part of the business domain, thus creating different bounded contexts. These bounded contexts communicate with each other through programmatic interfaces, such as web APIs and message q<a id="_idTextAnchor706"/>ueues.</p>
<h2 id="_idParaDest-369"><a id="_idTextAnchor707"/>DDD layers</h2>
<p>A DDD solution<a id="_idIndexMarker1936"/> is often represented as a layered<a id="_idIndexMarker1937"/> architecture. Each layer has a specific responsibility. The following diagram shows the typical layers of a DDD application:</p>
<div><div><img alt="Figure 17.1 – Typical layers of a DDD application" src="img/B18971_17_01.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.1 – Typical layers of a DDD application</p>
<p>In the preceding diagram, there are four layers:</p>
<ul>
<li><strong class="bold">Presentation layer</strong>: This <a id="_idIndexMarker1938"/>layer is responsible for presenting the data to the user and receiving user input. Normally, this layer is implemented as a user interface, such as a web application, a mobile application, or a desktop application. In this book, we mainly focus on web API applications that do not have a user interface. In this case, the presentation layer can be a client application that consumes the web API.</li>
<li><strong class="bold">Application layer</strong>: This <a id="_idIndexMarker1939"/>layer is responsible for coordinating the application’s activity. It receives user input from the presentation layer, invokes the domain layer to perform business logic, and returns the results to the presentation layer. In our case, the application layer is the web API application, which receives HTTP requests from the client<a id="_idIndexMarker1940"/> application, invokes the domain layer to execute business logic, and returns the results to the client application.</li>
<li><code>Deposit</code> method for the <code>SavingAccount</code> class, the logic in the domain layer does not have any knowledge of how to save data to the database. Instead, it only focuses on the business logic of the <code>Deposit</code> method using abstractions and interfaces. This layer often contains entities, value objects, aggregates, repositories, and domain services.</li>
<li><strong class="bold">Infrastructure layer</strong>: This layer implements the application infrastructure, such as <a id="_idIndexMarker1942"/>data access, caching, logging, messaging, and so on. It often integrates with external systems as dependencies, such as database, message queues, and so on. In our case, the infrastructure layer can include the data access layer, which uses EF Core to access the database.</li>
</ul>
<p>DDD focuses primarily on the domain and application layers. This is because the UI layer and the infrastructure layer are not specific to DDD and can be implemented with any technology <a id="_idIndexMarker1943"/>or framework. For example, the UI layer can be implemented using <strong class="bold">ASP.NET Core MVC</strong>, <strong class="bold">Blazor</strong>, <strong class="bold">React</strong>, <strong class="bold">WPF</strong>, or any other UI framework <a id="_idIndexMarker1944"/>on various <a id="_idIndexMarker1945"/>platforms, while<a id="_idIndexMarker1946"/> the core domain logic remains the same. Similarly, DDD does not dictate data storage, which can be a relational database, a NoSQL database, or any other data storage. The domain layer uses the repository pattern to access the data, which is independent of data storage. Another example is the logging mechanism, which is also not specific to DDD, as the domain layer needs to log the business events but does not care about the logg<a id="_idTextAnchor708"/>ing system used.</p>
<h3>DDD building blocks</h3>
<p>DDD <a id="_idIndexMarker1947"/>has a set of building blocks that can be <a id="_idIndexMarker1948"/>used to build the domain model. These building blocks include entities, value objects, aggregates, repositories, and domain services. In the following subsections, we will introduce these building blocks and how to use them to build<a id="_idTextAnchor709"/> the domain model:</p>
<h4>Entity</h4>
<p>You may have essential knowledge of <strong class="bold">object-oriented programming</strong> (<strong class="bold">OOP</strong>) and <strong class="bold">object-relational mapping</strong> (<strong class="bold">ORM</strong>) if you<a id="_idIndexMarker1949"/> have read the previous chapters. In OOP, an object is <a id="_idIndexMarker1950"/>an instance of a class. An object has a state and behavior. The <a id="_idIndexMarker1951"/>state is represented by the properties of the object, while the behavior is represented by the methods of the object.</p>
<p>In DDD, the entity is similar to an object in OOP, but it is more than that. An <strong class="bold">entity</strong> is an object that has a unique identity and is defined by its identity, not its attributes. Normally, an entity is mapped to a table in the database.</p>
<p>The identity of an entity is normally represented by an ID property. The ID property is immutable, which means that once it is set, it cannot be changed. The ID property can be a primitive type, such as an integer, a string, or a GUID. It can also be composite keys.</p>
<p>If two entities have the same properties but different identities, they are considered different entities.</p>
<p>For example, in a banking system, <code>Account</code> is an entity. It has a unique identity that can be represented by an <code>Id</code> property. Two accounts cannot have <a id="_idTextAnchor710"/>the same <code>Id</code> property.</p>
<h4>Value object</h4>
<p>A <strong class="bold">value object</strong> is <a id="_idIndexMarker1952"/>another type of object in DDD. It is identified by its properties, rather than a unique identity. Normally, a value object is immutable, which means that its properties cannot be changed once it is created. If two value objects have the same properties, they are considered the same value object.</p>
<p>For example, <code>Address</code> is a value object. It is identified by its properties, such as <code>Street</code>, <code>City</code>, <code>State</code>, and <code>ZipCode</code>. If two addresses have the same <code>Street</code>, <code>City</code>, <code>State</code>, and <code>ZipCode</code>, they are consid<a id="_idTextAnchor711"/>ered the same address.</p>
<h4>Aggregate</h4>
<p>An <strong class="bold">aggregate</strong> is a <a id="_idIndexMarker1953"/>cluster of associated objects, including entities and value objects, which are treated as a unit for data changes. An aggregate has a root entity, which is the only object that can be accessed from outside the aggregate. The root entity is responsible for maintaining the consistency and integrity of the aggregate. It is important to note that if the external objects need to access the objects inside the aggregate or modify the objects inside the aggregate, they must go through the root entity.</p>
<p>For example, in an invoicing system, an <code>Invoice</code> entity is an aggregate root. It contains a list of <code>InvoiceItem</code> entities, which are the items of the invoice. To add an item to the invoice, the external objects must go through the <code>Invoice</code> entity, as shown in the following code:</p>
<pre class="source-code">
public class Invoice{
    public int Id { get; private set; } // Aggregate root Id, which should not be changed once it is set
    public DateTime Date { get; set; }
    public InvoiceStatus Status { get; private set; }
    public decimal Total { get; private set; } // The total amount of the invoice, which should be updated when an item is added or removed, but cannot be changed directly
    // Other properties
    public List&lt;InvoiceItem&gt; Items { get; private set; }
    public void AddItem(InvoiceItem item)
    {
        // Add the item to the invoice
        Items.Add(item);
        // Update the invoice total, etc.
        // ...
    }
    public void RemoveItem(InvoiceItem item)
    {
        // Remove the item from the invoice
        Items.Remove(item);
        // Update the invoice total, etc.
        // ...
    }
    public void Close()
    {
        // Close the invoice
        Status = InvoiceStatus.Closed;
    }
}</pre>
<p>In the <a id="_idIndexMarker1954"/>preceding example, if we need to add or remove an item from the invoice, we must get the <code>Invoice</code> entity first, and then call the <code>AddItem()</code> or <code>RemoveItem()</code> method to add or remove the item. We cannot directly add or remove an item from the <code>Items</code> property because the <code>Items</code> property is private and can only be accessed from inside the <code>Invoice</code> entity. In this way, the domain logic is encapsulated inside the <code>Invoice</code> entity, and the consistency and integrity of the invoice are maintained. Similarly, we cannot change the <code>Total</code> property directly. Instead, the <code>AddItem</code> or <code>RemoveItem</code> method can up<a id="_idTextAnchor712"/>date the <code>Total</code> property.</p>
<h4>Repository</h4>
<p>A <strong class="bold">repository</strong> <a id="_idIndexMarker1955"/>is an abstraction layer used to access the data persistence layer. It encapsulates the data access logic and provides a way to query and save data. To ensure the domain layer does not depend on any specific data access technology, a repository is typically implemented as an interface. The infrastructure layer can then use a specific data access technology, such as EF Core<a id="_idIndexMarker1956"/> or Dapper, to implement the repository interface and access different data sources, such as relational databases or NoSQL databases. This decouples the domain layer from the data access technology and data storage.</p>
<p>An example of a repository interface is shown in the following code:</p>
<pre class="source-code">
public interface IInvoiceRepository{
    Task&lt;Invoice&gt; GetByIdAsync(Guid id);
    Task&lt;List&lt;Invoice&gt;&gt; GetByCustomerIdAsync(Guid customerId);
    Task AddAsync(Invoice invoice);
    Task UpdateAsync(Invoice invoice);
    Task DeleteAsync(Invoice invoice);
}</pre>
<p>We introduced the repository pattern in <a href="B18971_09.xhtml#_idTextAnchor371"><em class="italic">Chapter 9</em></a>. It is not a specific DDD pattern. However, it is often used in DDD to decouple the domain layer f<a id="_idTextAnchor713"/>rom the data access layer.</p>
<h4>Domain service</h4>
<p>A <strong class="bold">domain service</strong> is a <a id="_idIndexMarker1957"/>stateless service that contains domain logic that does not belong to any specific entity or value object. It is often used to implement complex domain logic that involves multiple entities or value objects. To access the data persistence layer, a domain service may depend on one or more repositories. Additionally, it may also depend on other external services. These dependencies are injected into the domain service through the dependency injection mechanism.</p>
<p>For example, in a <a id="_idIndexMarker1958"/>banking system, the <code>TransferService</code> domain service is responsible for the logic of transferring money from one account to another. To do this, it relies on the <code>AccountRepository</code> to access the <code>Account</code> entity. Additionally, it may need to use an external service to send a notification to the account holder after the transfer is complete. If the accounts are in different banks, the <code>TransferService</code> domain service may also need to use an external service to transfer money between them.</p>
<p>The following code shows an example of a domain service:</p>
<pre class="source-code">
public class TransferService{
    private readonly IAccountRepository _accountRepository;
    private readonly ITransactionRepository _transactionRepository;
    private readonly INotificationService _notificationService;
    private readonly IBankTransferService _bankTransferService;
    public TransferService(IAccountRepository accountRepository, ITransactionRepository transactionRepository, INotificationService notificationService, IBankTransferService bankTransferService)
    {
        _accountRepository = accountRepository;
        _transactionRepository = transactionRepository;
        _notificationService = notificationService;
        _bankTransferService = bankTransferService;
    }
    public async Task TransferAsync(Guid fromAccountId, Guid toAccountId, decimal amount)
    {
        // Get the account from the repository
        var fromAccount = await _accountRepository.GetByIdAsync(fromAccountId);
        var toAccount = await _accountRepository.GetByIdAsync(toAccountId);
        // Transfer money between the accounts
        fromAccount.Withdraw(amount);
        toAccount.Deposit(amount);
        // Save the changes to the repository
        await _accountRepository.UpdateAsync(fromAccount);
        await _accountRepository.UpdateAsync(toAccount);
        // Create transaction records
        await _transactionRepository.AddAsync(new Transaction
        {
            FromAccountId = fromAccountId,
            ToAccountId = toAccountId,
            Amount = amount,
            Date = DateTime.UtcNow
        });
        await _transactionRepository.AddAsync(new Transaction
        {
            FromAccountId = toAccountId,
            ToAccountId = fromAccountId,
            Amount = -amount,
            Date = DateTime.UtcNow
        });
        // Send a notification to the account holder
        await _notificationService.SendAsync(fromAccount.HolderId, $"You have transferred {amount}to {toAccount.HolderId}");
        await _notificationService.SendAsync(toAccount.HolderId, $"You have received {amount} from{fromAccount.HolderId}");
        // Transfer money between the banks
        // await _bankTransferService.TransferAsync(fromAccount.BankId, toAccount.BankId, amount);
    }
}</pre>
<p>The <a id="_idIndexMarker1959"/>preceding code shows a <code>TransferService</code> domain service. It has four dependencies: <code>IAccountRepository</code>, <code>ITransactionRepository</code>, <code>INotificationService</code>, and <code>IBankTransferService</code>. The <code>TransferAsync</code> method transfers money from one account to another. It first obtains the accounts from <code>IAccountRepository</code>, and then transfers money between the accounts. After that, it saves the changes to <code>IAccountRepository</code> and creates transaction records in <code>ITransactionRepository</code>. Finally, it sends a notification to the account holders using <code>INotificationService</code>.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The preceding example is simplified for demonstration purposes. The actual implementation to transfer money between two accounts is much more complicated. For example, it may need to check the balance of the accounts, check the daily transfer limit, and so on. It may also need to transfer money between different banks, which involves a lot of complex logic to handle any errors that may occur during the transfer. If any error occurs, it may need to roll back the transaction. This is a typical example of a domain service that im<a id="_idTextAnchor714"/>plements complex domain logic.</p>
<h4>Unit of work</h4>
<p>In the preceding example, when transferring money between two accounts, the process involves multiple steps. What if an error occurs during the process? In order to prevent any money from being lost during the process of transferring funds between two accounts, it is necessary to wrap the process in a transaction. This will ensure that in the event of an error occurring, the transaction will be rolled back, and the funds will remain secure. For example, if the <code>TransferAsync()</code> method throws an exception after the money has been withdrawn from <code>fromAccount</code> but before it is deposited to <code>toAccount</code>, the transaction will be rolled back, and the money will not be lost.</p>
<p>The term <strong class="bold">transaction</strong> is often<a id="_idIndexMarker1960"/> used in the context of databases. This kind of transaction is called a <strong class="bold">unit of work</strong> in DDD. A unit of work is a sequence of operations that must be performed as a whole. All the steps in a unit of work must succeed or fail together. If any step fails, the entire unit of work must be rolled back. This prevents the data from being left in an inconsistent state.</p>
<p>A unit of work can <a id="_idIndexMarker1961"/>be implemented in various ways. In many scenarios, a unit of work is implemented as a database transaction. Another example is a message queue. When a message is received, it is processed as a unit of work. If the process is successful, the message is removed from the queue. Otherwise, the message remains in the queue and will be p<a id="_idTextAnchor715"/>rocessed again at a later time.</p>
<h4>Application service</h4>
<p>The application service <a id="_idIndexMarker1962"/>is responsible for managing the application process. It receives user input from the presentation layer, invokes the domain service to execute business logic, and returns the results to the Presentation Layer. In a web API application, the Application Service can be implemented as a web API controller or a separate service that is invoked by the web API controller.</p>
<p>The <a id="_idIndexMarker1963"/>application service should be thin and delegate most of the work to the domain service. Typically, the application service uses <code>AutoMapper</code>. For example, an <code>InvoiceDto</code> class may contain the properties of an invoice, such as <code>Id</code>, <code>Date</code>, <code>Status</code>, <code>Total</code>, and so on. It does not have any method to add or remove an invoice item or close the invoice. It is purely a data container. If a property of the <code>Invoice</code> entity is not needed in the presentation layer, it should not be included in <code>InvoiceDto</code>.</p>
<p>The presentation layer can send a DTO to the application service when it needs to create or update an entity. The application service will then map the DTO to the entity and invoke the domain service to execute the necessary business logic. Finally, the application service will map the entity back to the DTO and return it to the presentation layer.</p>
<p>Here is a simple example of an application service:</p>
<pre class="source-code">
[Route("api/[controller]")][ApiController]
public class InvoicesController : ControllerBase
{
    private readonly IInvoiceService _invoiceService;
    public InvoicesController(IInvoiceService invoiceService)
    {
        _invoiceService = invoiceService;
    }
    [HttpPost]
    public async Task&lt;IActionResult&gt; CreateAsync(InvoiceDto invoiceDto)
    {
        var invoice = await _invoiceService.CreateAsync(invoiceDto);
        return Ok(invoice);
    }
    // Omitted other methods
}
public interface IInvoiceService
{
    Task&lt;InvoiceDto&gt; CreateAsync(InvoiceDto invoiceDto);
    // Omitted other methods
}
public class InvoiceService : IInvoiceService
{
    private readonly IInvoiceRepository _invoiceRepository;
    private readonly IMapper _mapper;
    public InvoiceService(IInvoiceRepository invoiceRepository, IMapper mapper)
    {
        _invoiceRepository = invoiceRepository;
        _mapper = mapper;
    }
    public async Task&lt;InvoiceDto&gt; CreateAsync(InvoiceDto invoiceDto)
    {
        var invoice = _mapper.Map&lt;Invoice&gt;(invoiceDto);
        await _invoiceRepository.AddAsync(invoice);
        return _mapper.Map&lt;InvoiceDto&gt;(invoice);
    }
    // Omitted other methods
}</pre>
<p>In the<a id="_idIndexMarker1965"/> preceding example, the <code>IInvoiceService</code> interface defines the methods of the application service. The <code>InvoiceService</code> class implements the <code>IInvoiceService</code> interface. It has two dependencies: <code>IInvoiceRepository</code> and <code>IMapper</code>. <code>IInvoiceRepository</code> is used to access the <code>Invoice</code> entity, while <code>IMapper</code> is used to map <code>InvoiceDto</code> to the <code>Invoice</code> entity and vice versa. The <code>CreateAsync()</code> method receives <code>InvoiceDto</code> from the presentation layer via the controller, maps it to the <code>Invoice</code> entity, and then invokes the <code>AddAsync()</code> method of <code>IInvoiceRepository</code> to add the <code>Invoice</code> entity to the database. Finally, it maps the <code>Invoice</code> entity back to <code>InvoiceDto</code> and returns it to the presentation layer.</p>
<p class="callout-heading">Important note</p>
<p class="callout">In the preceding example, there is no domain service. This is because the logic to create an invoice is simple. In this case, the application service layer can directly invoke the repository to add the invoice to the database. However, if the logic is more complex, involving multiple entities or aggregates, it is better to use a domain service to implement the logic.</p>
<p>DDD focuses on how to build a domain model that reflects the business domain and how to maintain the consistency and integrity of the domain model. It is not used to produce reports or user interfaces. Reports may need complex queries that are not suitable for the domain model. For this case, you may need to use a separate reporting database or reporting service. Similarly, the user interface may need to display data in a different way than the domain model. However, the domain model should remain the same no matter how the data are displayed.</p>
<p>DDD can <a id="_idIndexMarker1966"/>help you to manage the complexity and build a flexible and maintainable software system. But keep in mind that DDD is not a silver bullet. Typically, DDD is used for complex business domains. Developers must implement a lot of isolation, abstraction, and encapsulation to maintain the model. This may lead to a lot of effort and complexity. If your project is simple, DDD may be a bit overkill. In this case, a simple layered <a id="_idTextAnchor716"/>architecture may be a better choice.</p>
<h1 id="_idParaDest-370"><a id="_idTextAnchor717"/>Clean architecture</h1>
<p>Clean architecture<a id="_idIndexMarker1967"/> is a software architecture that was proposed by Robert C. Martin (also known as Uncle Bob) in his book <em class="italic">Clean Architecture: A Craftsman’s Guide to Software Structure and Design</em>, published in 2017. It is a layered architecture that focuses on the separation of concerns. Similar to DDD, clean architecture is not a specific technology or framework. It is a set of principles and practices that can be applied to any software project.</p>
<p>Clean architecture is also called onion architecture because the layers are arranged in a circular shape, like an onion. The following diagram shows the typical layers of clean architecture:</p>
<div><div><img alt="Figure 17.2 – Typical layers of clean architecture" src="img/B18971_17_02.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.2 – Typical layers of clean architecture</p>
<p>The preceding diagram illustrates the dependencies flowing from the outer layers to the inner layers. At the center of the architecture lies the application core layer, which contains the entities and interfaces for business logic. Additionally, this layer contains domain services that implement the interfaces. It does not depend on any other layers. Surrounding the application core layer is the Infrastructure Layer and UI layer, both of which depend on the application core layer. This architecture ensures that the application core layer is unaware of how the data are stored or presented to the user. In addition, the Infrastructure Layer and UI layer can be replaced without impacting the application core layer.</p>
<p>Clean architecture<a id="_idIndexMarker1968"/> shares some similarities with DDD. Both of them are layered architectures that focus on the separation of concerns. They both use dependency injection (or inversion of control) to decouple the layers. DDD focuses on the domain layer, while clean architecture prioritizes the importance of isolating the core business logic from the external dependencies. The separation of concerns allows for modifications to external components without affecting the core business logic, making it easier to adapt to evolving requirements.</p>
<p>DDD and clean architecture complement each other and can be used together. While DDD guides how to build a domain model and understand the business domain, clean architecture <a id="_idIndexMarker1969"/>offers a blueprint for organizing and structuring the codebase. Combining these approaches can lead to a flexible and maintainable software system.</p>
<p>DDD and clean architecture are both layered architectures that focus on a business domain. Next, let us discuss the architecture of the entire software system. In the next section, we will introduce microservices, which is a popular architecture for building scala<a id="_idTextAnchor718"/>ble and maintainable software systems.</p>
<h1 id="_idParaDest-371"><a id="_idTextAnchor719"/>Microservices</h1>
<p>Many traditional<a id="_idIndexMarker1970"/> applications are built as a monolith. A monolithic application is deployed as a single unit on a single server. The monolithic application is easy to develop and deploy. However, as the application grows, it becomes more and more difficult to maintain and scale. A small change in the application may require the entire application to be rebuilt, retested, and redeployed. Moreover, if one part of the application needs to be scaled, the application must be scaled as a whole, which is not cost-effective. In addition, if one part of the application fails, it may affect the entire application.</p>
<p>This is where <a id="_idIndexMarker1971"/>microservices come in. A microservice is a small, independent service that is responsible for a specific business domain. Each microservice has its own database and dependencies. It can be developed, deployed, and scaled independently. These microservices communicate with each other through programmatic interfaces, such as web APIs or message queues.</p>
<p>Microservices <a id="_idIndexMarker1972"/>provide several benefits:</p>
<ul>
<li><strong class="bold">Single responsibility</strong>: Each microservice is responsible for a specific business domain. It has its own dependencies and database.</li>
<li><strong class="bold">Resilience and fault tolerance</strong>: Microservices are designed to be resilient and fault tolerant. If one microservice fails, it does not affect other microservices.</li>
<li><strong class="bold">Scalability</strong>: Microservices can be scaled independently based on demand. If one microservice <a id="_idIndexMarker1973"/>has a high workload, we can increase the number of instances of that microservice to handle the workload.</li>
<li><strong class="bold">Technology diversity</strong>: Each microservice can be built using different technologies and frameworks as long as they communicate with each other through standard interfaces, such as HTTP APIs or gRPC.</li>
<li><strong class="bold">CI/CD</strong>: Microservices facilitate CI/CD by allowing individual microservices to be built, tested, and deployed independently, minimizing disruption to the entire system.</li>
</ul>
<p>Microservices is not a new concept; it has been around for decades. However, it has become more popular in recent years, especially with the rise in cloud computing. Cloud computing provides a scalable and cost-effective infrastructure for microservices. In addition, the emergence of container technology, such as Docker, makes it easier to build and deploy microservices. By using containers and container orchestration tools, such as <strong class="bold">Kubernetes</strong>, developers <a id="_idIndexMarker1974"/>can easily build and deploy microservices to the cloud. The orchestration tools can automatically scale the microservices based on the workload. This makes it easier to build a scalable and cost-effective software system.</p>
<p>Microservices do not have to be exclusive to other architectures. In fact, they can be used in conjunction with other architectures to create a more robust and efficient system. You can use layers, such as DDD and clean architecture, to build each microservice. By leveraging the benefits of both architectures, organizations can create a powerful and reliable system that meets their needs. This approach can be especially beneficial for organizations that require a high degree of scalability and flexibility.</p>
<p>For example, in an <a id="_idIndexMarker1975"/>online shopping system, we may have the following microservices:</p>
<ul>
<li><strong class="bold">Product service</strong>: This <a id="_idIndexMarker1976"/>service is responsible for managing the products, such as adding a new product, updating a product, deleting a product, and so on. It has its own database to store the product data.</li>
<li><strong class="bold">Order service</strong>: This <a id="_idIndexMarker1977"/>service is responsible for managing the orders, such as creating a new order, updating an order, deleting an order, and so on. It also has its own database to store the order data.</li>
<li><strong class="bold">Payment service</strong>: This <a id="_idIndexMarker1978"/>service is responsible for processing payments, such as credit card payments, PayPal payments, and so on. It has its own database to store the <a id="_idIndexMarker1979"/>payment data. It may also need to integrate with external payment services, such as PayPal, Stripe, online banking services, and so on.</li>
<li><strong class="bold">Shipping service</strong>: This <a id="_idIndexMarker1980"/>service is responsible for shipping the products, such as shipping a product to a customer and tracking the shipment. It needs to integrate with external shipping services, such as FedEx, UPS, and so on.</li>
<li><strong class="bold">Notification service</strong>: This <a id="_idIndexMarker1981"/>service is responsible for sending notifications to the customers, such as sending an email or a text message notification, and so on. It needs to integrate with external notification services, such as SendGrid, Twilio, and so on.</li>
<li><strong class="bold">Identity service</strong>: This<a id="_idIndexMarker1982"/> service is responsible for managing users, such as creating a new user, updating a user, deleting a user, and so on. It may provide third-party authentication, such as from Microsoft, Google, Facebook, and so on.</li>
<li><strong class="bold">Gateway service</strong>: This <a id="_idIndexMarker1983"/>service is responsible for routing the requests to the appropriate microservices. It is the entry point of the system. It does not have its own database. Instead, it routes the requests to the appropriate microservices based on the request URL. It can also implement rate-limiting, authentication, authorization, and so on.</li>
<li><strong class="bold">Client applications</strong>: These <a id="_idIndexMarker1984"/>are the client applications that consume the microservices. They can be web applications, mobile applications, or desktop applications.</li>
</ul>
<p>Each service is responsible for a specific business domain and has its own dependencies. Developers can use different technologies and frameworks to build the services because they communicate with each other through standard HTTP APIs or gRPC. If one service needs to be scaled, it can be scaled independently. For example, if the <code>Order</code> service has a high workload, we can increase the number of instances of the <code>Order</code> service to handle the workload. This is much more cost-effective than scaling the entire application. Moreover, if one service fails, it does not affect other services. For example, if the <code>Payment</code> service fails, the <code>Order</code> service and <code>Product</code> service can still work. It can still receive orders and allow users to view products. When the <code>Payment</code> service is back online, it can process the orders that have not been processed.</p>
<p>Microservices have become more and more popular in recent years. However, it increases the complexity of the system. Before adopting microservices, you should carefully consider whether it is suitable for your project. Consider the following challenges to <a id="_idIndexMarker1985"/>microservices:</p>
<ul>
<li><strong class="bold">Distributed system complexity</strong>: Microservices are distributed systems. They are more complex than monolithic applications. For example, if one service needs to call another service, you need to consider how to handle the communication between the services and how to maintain the consistency of the data. In addition, you need to handle network failures, partial failures, cascading failures, and so on.</li>
<li><strong class="bold">Data management</strong>: Each microservice has its own database. This makes it difficult to maintain data consistency, as transactions that span multiple microservices are not supported. To query data from multiple microservices, a distributed query mechanism must be implemented, which can be a complex process.</li>
<li><strong class="bold">Service discovery</strong>: In a microservice architecture, each service has its own URL. They need to know the URLs of other services in order to communicate with them. This is called service discovery. There are many ways to implement service discovery, such as using a service registry, using a service mesh, and so on. The container orchestration tools, such as Kubernetes, can also be used to implement service discovery, as they can maintain the internal service URLs of the microservices.</li>
<li><strong class="bold">Testing</strong>: Testing a microservice architecture is more complex than testing a monolithic application. In addition to unit testing, integration testing, and end-to-end testing, you also need to test the communication between the microservices.</li>
<li><strong class="bold">Monitoring</strong>: Monitoring<a id="_idIndexMarker1986"/> a microservice architecture requires a well-designed monitoring system. You need to monitor the health of each microservice, as well as the communication between the microservices. The tracing mechanism can be used to trace the requests between the microservices.</li>
</ul>
<p>In summary, if your application is simple, do not overcomplicate it by using microservices. As your application grows, you can consider refactoring it into microservice architecture step by step.</p>
<p>Next, let us discus<a id="_idTextAnchor720"/>s some common design patterns for web API applications.</p>
<h1 id="_idParaDest-372"><a id="_idTextAnchor721"/>Web API design patterns</h1>
<p>To build a<a id="_idIndexMarker1987"/> flexible, scalable, and maintainable <a id="_idIndexMarker1988"/>web API application, leveraging well-established design patterns is essential. These patterns address common challenges encountered in web API development, providing effective solutions. Microsoft’s comprehensive guide offers insights into these design patterns, and you can find more details at the following link: <a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/">https://learn.microsoft.com/en-us/azure/architecture/patterns/</a>.</p>
<p>These design patterns are not exclusive to ASP.NET Core; they can be applied to any web API, regardless of the underlying technology or framework. In the following sub-sections, we will introduce some key design patterns, outlining the problems they solve, their implementation details, and considerations for their usage. These patterns cover solution design and implementation, messaging, reliability, and so on, including the following:</p>
<ul>
<li><strong class="bold">Command query responsibility </strong><strong class="bold">segregation</strong> (<strong class="bold">CQRS</strong>)</li>
<li><strong class="bold">Publish/subscribe</strong> (<strong class="bold">pub/sub</strong>)</li>
<li><strong class="bold">Backend for </strong><strong class="bold">fr<a id="_idTextAnchor722"/>ontend</strong> (<strong class="bold">BFF</strong>)</li>
<li>Timeout</li>
<li>Rate limiting</li>
<li>Retry</li>
<li>Circuit breaker</li>
</ul>
<h2 id="_idParaDest-373"><a id="_idTextAnchor723"/>CQRS</h2>
<p>CQRS is a <a id="_idIndexMarker1989"/>powerful tool for addressing the challenge <a id="_idIndexMarker1990"/>of scaling and optimizing read and write operations. By separating the responsibilities for handling commands (writes) and queries (reads), CQRS enables each operation to be optimized independently, resulting in improved scalability and efficiency.</p>
<p>Traditionally, the data model of an application is designed to support both read and write operations. However, the requirements for read and write operations are often different. The read operations may execute different queries, resulting in different DTO models. The write operations may need to update multiple tables in the database. This may lead to a complex data model that is difficult to maintain. In addition, the read operations and write operations may have different performance requirements.</p>
<p>CQRS divides the application’s data model into separate models for reading and writing. This enables the use of different storage mechanisms and optimizations tailored to the specific needs of each operation. CQRS uses queries to read data and commands to update data. Queries do not change the state of the system, while commands do.</p>
<p>To better separate the read and write operations, CQRS can also use different data stores for reading and writing. For example, the read store can use multiple read-only replicas of the write store, which can improve the performance of the read operations. The replicas must be kept in sync with the write store, which can be done by using built-in database replication features or an event-driven mechanism.</p>
<p>The following<a id="_idIndexMarker1991"/> diagram shows a typical CQRS architecture:</p>
<div><div><img alt="Figure 17.3 – Typical CQRS architecture" src="img/B18971_17_03.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.3 – Typical CQRS architecture</p>
<p>To <a id="_idIndexMarker1992"/>implement CQRS in ASP.NET Core web API applications, you can use the <code>MediatR</code> library, which is a simple mediator implementation in .NET. This library is a simple mediator implementation in .NET that enables the use of the mediator pattern. The mediator pattern is a behavioral design pattern that enables objects to interact without having to refer to each other explicitly. Instead, they communicate through the mediator, which decouples the objects and allows for greater flexibility.</p>
<p>The following diagram shows a typical CQRS architecture using the <code>MediatR</code> library:</p>
<div><div><img alt="Figure 17.4 – Typical CQRS architecture using the MediatR library" src="img/B18971_17_04.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.4 – Typical CQRS architecture using the MediatR library</p>
<p>In the preceding <a id="_idIndexMarker1993"/>diagram, the mediator is responsible for receiving the commands and queries from the business logic layer and then invoking the corresponding handlers to execute the commands and queries. Then, the handlers can use the repositories to access the data persistence layer for reading and writing data. The business logic layer does not need to know how the mediator invokes the handlers. It only needs to send the commands and queries to the mediator. This decouples the business logic layer from the data persistence layer. This pattern also makes it easier to send commands and queries to multiple handlers. For example, if we have a command to send an email notification to the customer and we need to add a text message notification, we can simply add a new handler to handle the command without changing the client code.</p>
<p>You can find a sample application that demonstrates how to implement CQRS in ASP.NET Core web API applications in the <code>/chapter17/CqrsDemo</code> folder of the source code.</p>
<p class="callout-heading">Important note</p>
<p class="callout">The sample project has a separate infrastructure project to implement the data persistence layer by following clean architecture. When you run the <code>dotnet ef</code> command to add a migration or update the database, you need to specify the startup project. For example, to add a migration, you need to navigate to the <code>CqrsDemo.Infrastructure</code> project and run the following command:</p>
<p class="callout"><strong class="bold">dotnet ef migrations add InitialCreate --</strong><strong class="bold">startup-project ../CqrsDemo.WebApi</strong></p>
<p>To learn more about the <code>dotnet ef</code> command, you can refer to the following link: <a href="https://learn.microsoft.com/en-us/ef/core/cli/dotnet#target-project-and-startup-project">https://learn.microsoft.com/en-us/ef/core/cli/dotnet#target-project-and-startup-project</a>.</p>
<p>To follow the next steps, you can use the project in the <code>/chapter17/CqrsDemo/start</code> folder of the source code. This project contains a basic ASP.NET Core web API application to manage the invoices. It contains the following projects:</p>
<ul>
<li><code>CqrsDemo.WebApi</code>: This is the ASP.NET Core web API project. It contains the controllers and application configurations.</li>
<li><code>CqrsDemo.Core</code>: This is the core project that contains the domain models, interfaces of repositories, services, and so on.</li>
<li><code>CqrsDemo.Infrastructure</code>: This project contains the implementation of the repositories.</li>
</ul>
<h3>Implementing the model mapping</h3>
<p>In the <a id="_idIndexMarker1994"/>core project, note that the service layer uses DTOs, as shown in the following:</p>
<pre class="source-code">
public interface IInvoiceService{
    Task&lt;InvoiceDto?&gt; GetAsync(Guid id, CancellationToken cancellationToken = default);
    Task&lt;List&lt;InvoiceWithoutItemsDto&gt;&gt; GetPagedListAsync(int pageIndex, int pageSize, CancellationToken cancellationToken = default);
    Task&lt;InvoiceDto&gt; AddAsync(CreateOrUpdateInvoiceDto invoice, CancellationToken cancellationToken = default);
    Task&lt;InvoiceDto?&gt; UpdateAsync(Guid id, CreateOrUpdateInvoiceDto invoice, CancellationToken cancellationToken = default);
    // Omitted
}</pre>
<p>These methods <a id="_idIndexMarker1995"/>use different DTO types for reading and writing. To map the entities to DTOs and vice versa, we can use <code>AutoMapper</code>, which is a popular <code>object-to-object mapper</code> library. The following code shows how to configure <code>AutoMapper</code> in the <code>InvoiceProfile.cs</code> file:</p>
<pre class="source-code">
public InvoiceProfile(){
    CreateMap&lt;CreateOrUpdateInvoiceItemDto, InvoiceItem&gt;();
    CreateMap&lt;InvoiceItem, InvoiceItemDto&gt;();
    CreateMap&lt;CreateOrUpdateInvoiceDto, Invoice&gt;();
    CreateMap&lt;Invoice, InvoiceWithoutItemsDto&gt;();
    CreateMap&lt;Invoice, InvoiceDto&gt;();
}</pre>
<p>Then, we can register <code>AutoMapper</code> in the <code>Program.cs</code> file as follows:</p>
<pre class="source-code">
builder.Services.AddAutoMapper(typeof(InvoiceProfile));</pre> <p>To use the mapper, just simply inject the <code>IMapper</code> interface into the service layer, as shown in the following:</p>
<pre class="source-code">
public class InvoiceService(IInvoiceRepository invoiceRepository, IMapper mapper) : IInvoiceService{
    public async Task&lt;InvoiceDto?&gt; GetAsync(Guid id, CancellationToken cancellationToken = default)
    {
        var invoice = await invoiceRepository.GetAsync(id, cancellationToken);
        return invoice == null ? null : mapper.Map&lt;InvoiceDto&gt;(invoice);
    }
    // Omitted
}</pre>
<p>Using <code>AutoMapper</code> can <a id="_idIndexMarker1996"/>save us a lot of time for mapping the entities to DTOs and vice versa. Next, we can implement the queries and commands using the <code>MediatR</code> library.</p>
<h3>Implementing queries</h3>
<p>Next, we will<a id="_idIndexMarker1997"/> implement the CQRS pattern using the <code>MediatR</code> library. Follow these steps:</p>
<ol>
<li>First, we need to install the <code>MediatR</code> NuGet package. Run the following command in the terminal window to install the <code>MediatR</code> package:<pre class="source-code">
<code>MediatR</code> package to the <code>CqrsDemo.Core</code> project and the <code>CqrsDemo.WebApi</code> project.</p><p class="list-inset"><code>MediatR</code> provides the following interfaces:</p><ul><li><code>IMediator</code>: This is the main interface of the <code>MediatR</code> library. It can be used to send requests to the handlers. It can also be used to publish events to multiple handlers.</li><li><code>ISender</code>: This interface is used to send a request through the mediator pipeline to be handled by a single handler.</li><li><code>IPublisher</code>: This interface is used to publish a notification or event through the mediator pipeline to be handled by multiple handlers.</li></ul><p class="list-inset">The <code>IMediator</code> interface can be used to send all requests or events. For a clearer indication of the purpose of the request or event, it is recommended to use the <code>ISender</code> interface for requests handled by a single handler and the <code>IPublisher</code> interface for notifications or events that require multiple handlers.</p></li> <li>Create<a id="_idIndexMarker1998"/> a <code>Queries</code> folder in the <code>CqrsDemo.Core</code> project. Then, create a <code>GetInvoiceByIdQuery.cs</code> file in the <code>Queries</code> folder with the following code:<pre class="source-code">
public class GetInvoiceByIdQuery(Guid id) : IRequest&lt;InvoiceDto?&gt;{    public Guid Id { get; set; } = id;}</pre><p class="list-inset">The preceding code defines a <code>GetInvoiceByIdQuery</code> class that implements the <code>IRequest&lt;InvoiceDto?&gt;</code> interface. This interface is used to indicate that this is a query that returns an <code>InvoiceDto</code> object. The <code>Id</code> property is used to specify the ID of the invoice to be retrieved.</p></li> <li>Similarly, create a <code>GetInvoiceListQuery.cs</code> file in the <code>Queries</code> folder with the following code:<pre class="source-code">
public class GetInvoiceListQuery(int pageIndex, int pageSize) : IRequest&lt;List&lt;InvoiceWithoutItemsDto&gt;&gt;{    public int PageIndex { get; set; } = pageIndex;    public int PageSize { get; set; } = pageSize;}</pre><p class="list-inset">Note that the <code>GetInvoiceListQuery</code> query returns a list of <code>InvoiceWithoutItemsDto</code> objects. This is because we do not need the invoice items when listing the invoices. This is an example to show how to use different DTOs for reading and writing.</p></li> <li>Next, create<a id="_idIndexMarker1999"/> a <code>Handlers</code> folder in the <code>Queries</code> folder. Then, create a <code>GetInvoiceByIdQueryHandler.cs</code> file in the <code>Handlers</code> folder with the following code:<pre class="source-code">
public class GetInvoiceByIdQueryHandler(IInvoiceService invoiceService) : IRequestHandler&lt;GetInvoiceByIdQuery, InvoiceDto?&gt;{    public Task&lt;InvoiceDto?&gt; Handle(GetInvoiceByIdQuery request, CancellationToken cancellationToken)    {        return invoiceService.GetAsync(request.Id, cancellationToken);    }}</pre><p class="list-inset">The <code>GetInvoiceByIdQueryHandler</code> class implements the <code>IRequestHandler&lt;GetInvoiceByIdQuery, InvoiceDto?&gt;</code> interface. This interface is used to indicate that this handler handles the <code>GetInvoiceByIdQuery</code> query and returns an <code>InvoiceDto</code> object. The <code>Handle()</code> method receives the <code>GetInvoiceByIdQuery</code> query and invokes the <code>GetAsync()</code> method of <code>IInvoiceService</code> to get the invoice by using the ID.</p><p class="list-inset">The <code>IInvoiceService</code> interface can be injected into the handler. Alternatively, you may choose to inject the <code>IInvoiceRepository</code> interface directly into the handler and implement business logic there. Ultimately, it is your decision where to store the logic. It is important to keep in mind that the goal is to separate business logic from the data persistence layer.</p></li> <li>Similarly, create a <code>GetInvoiceListQueryHandler.cs</code> file in the <code>Handlers</code> folder <a id="_idIndexMarker2000"/>with the following code:<pre class="source-code">
public class GetInvoiceListQueryHandler(IInvoiceService invoiceService) : IRequestHandler&lt;GetInvoiceListQuery, List&lt;InvoiceWithoutItemsDto&gt;&gt;{    public Task&lt;List&lt;InvoiceWithoutItemsDto&gt;&gt; Handle(GetInvoiceListQuery request, CancellationToken cancellationToken)    {        return invoiceService.GetPagedListAsync(request.PageIndex, request.PageSize, cancellationToken);    }}</pre><p class="list-inset">Now, we have two handlers to handle the <code>GetInvoiceByIdQuery</code> query and the <code>GetInvoiceListQuery</code> query. Next, we need to update the controllers to use the <code>MediatR</code> library.</p></li> <li>Update the <code>InvoicesController.cs</code> file in the <code>CqrsDemo.WebApi</code> project with the following code:<pre class="source-code">
[Route("api/[controller]")][ApiController]public class InvoicesController(IInvoiceService invoiceService, ISender mediatorSender) : ControllerBase{    // Omitted}</pre><p class="list-inset">The <a id="_idIndexMarker2001"/>preceding code injects the <code>ISender()</code> interface into the controller. You can also inject the <code>IMediator</code> interface instead. In this example, we will use the <code>ISender</code> interface to send the requests to the handlers.</p></li> <li>Update the <code>GetInvoice()</code> method of the <code>InvoicesController</code> class with the following code:<pre class="source-code">
[HttpGet("{id}")]public async Task&lt;ActionResult&lt;InvoiceDto&gt;&gt; GetInvoice(Guid id){    var invoice = await mediatorSender.Send(new GetInvoiceByIdQuery(id));    return invoice == null ? NotFound() : Ok(invoice);}</pre><p class="list-inset">The preceding code creates a <code>GetInvoiceByIdQuery</code> object that contains the <code>id</code> parameter. The <code>ISender</code> interface will invoke the <code>GetInvoiceByIdQueryHandler</code> handler to handle the query. Then, the handler will invoke the <code>GetAsync</code> method of the <code>IInvoiceService</code> to get the invoice via the ID. So, the controller is decoupled from the service layer.</p></li> <li>Similarly, update the <code>GetInvoices</code> method of the <code>InvoicesController</code> class with the following code:<pre class="source-code">
[HttpGet][Route("paged")]public async Task&lt;ActionResultIEnumerableInvoiceWithoutItemsDto&gt;&gt;&gt; GetInvoices(int pageIndex, int pageSize){    var invoices = await mediatorSender.Send(new GetInvoiceListQuery(pageIndex, pageSize));    return Ok(invoices);}</pre><p class="list-inset">The <a id="_idIndexMarker2002"/>preceding code creates a <code>GetInvoiceListQuery</code> object that contains the <code>pageIndex</code> and <code>pageSize</code> parameters. The <code>ISender</code> interface will invoke the <code>GetInvoiceListQueryHandler</code> handler to handle the query. Then, the handler will invoke the <code>GetPagedListAsync()</code> method of the <code>IInvoiceService</code> to get the list of invoices.</p></li> <li>Next, we need to register the <code>MediatR</code> in the <code>Program.cs</code> file as follows:<pre class="source-code">
builder.Services.AddMediatR(cfg =&gt; cfg.RegisterServicesFromAssembly(typeof(GetInvoiceByIdQueryHandler).Assembly));</pre><p class="list-inset">The preceding code registers all three <code>MediatR</code> interfaces and the handlers in the <code>CqrsDemo.Core</code> project.</p></li> </ol>
<p>Now, we use the queries to implement the read operations. You can run the application and test the endpoints, such as <code>/api/invoices/{id}</code> and <code>/api/invoices/paged</code>. These endpoints should work as before.</p>
<h3>Implementing commands</h3>
<p>Next, we<a id="_idIndexMarker2003"/> will implement the write operations using commands. Follow these steps:</p>
<ol>
<li>Create a <code>Commands</code> folder in the <code>CqrsDemo.Core</code> project. Then, create a <code>CreateInvoiceCommand.cs</code> file in the <code>Commands</code> folder with the following code:<pre class="source-code">
public class CreateInvoiceCommand(CreateOrUpdateInvoiceDto invoice) : IRequest&lt;InvoiceDto&gt;{    public CreateOrUpdateInvoiceDto Invoice { get; set; } = invoice;}</pre><p class="list-inset">The <a id="_idIndexMarker2004"/>preceding code defines a <code>CreateInvoiceCommand</code> class that implements the <code>IRequest&lt;InvoiceDto&gt;</code> interface.</p></li> <li>Create a <code>Handlers</code> folder in the <code>Commands</code> folder. Then, create a <code>CreateInvoiceCommandHandler.cs</code> file in the <code>Handlers</code> folder with the following code:<pre class="source-code">
public class CreateInvoiceCommandHandler(IInvoiceService invoiceService) : IRequestHandler&lt;CreateInvoiceCommand, InvoiceDto&gt;{    public Task&lt;InvoiceDto&gt; Handle(CreateInvoiceCommand request, CancellationToken cancellationToken)    {        return invoiceService.AddAsync(request.Invoice, cancellationToken);    }}</pre></li> <li>Update the <code>InvoicesController</code> class with the following code:<pre class="source-code">
[HttpPost]public async Task&lt;ActionResult&lt;InvoiceDto&gt;&gt; CreateInvoice(CreateOrUpdateInvoiceDto invoice){    var result = await mediatorSender.Send(new CreateInvoiceCommand(invoice));    return CreatedAtAction(nameof(GetInvoice), new { id = result.Id }, result);}</pre><p class="list-inset">Now, run<a id="_idIndexMarker2005"/> the application and send a <code>POST</code> request to the <code>/api/invoices</code> endpoint. You should be able to create a new invoice.</p><p class="list-inset">We will not implement all the commands and queries in this example. You can work on the remaining commands and queries as an exercise.</p></li> </ol>
<p><code>MediatR</code> makes it easy to implement the CQRS pattern in ASP.NET Core web API applications. However, it is not the only way to implement CQRS. You can also implement CQRS without using the <code>MediatR</code> library.</p>
<p>One benefit of using the <code>MediatR</code> library is that it can send requests to multiple handlers. For example, we can create a command to send an email notification and a text message notification to the customer. Then, we can create two handlers to handle the command. Follow these steps to implement this feature:</p>
<ol>
<li>Add the two properties to the invoice models, as shown in the following:<pre class="source-code">
public string ContactEmail { get; set; } = string.Empty;public string ContactPhone { get; set; } = string.Empty;</pre><p class="list-inset">You need to update the <code>Invoice</code> class, <code>CreateOrUpdateInvoiceDto</code> class, <code>InvoiceWithoutItemsDto</code> class, and <code>InvoiceDto</code> class. You can also define a <code>Contact</code> class for better encapsulation.</p></li> <li>Add the <a id="_idIndexMarker2006"/>database migration and update the database. You may also need to update the seed data. Note that you need to specify the startup project when running the <code>dotnet ef</code> command. For example, to add a migration, you need to navigate to the <code>CqrsDemo.Infrastructure</code> project and run the following command:<pre class="source-code">
<strong class="bold">dotnet ef migrations add AddContactInfo --startup-project ../CqrsDemo.WebApi</strong></pre></li> <li>Then, update the database:<pre class="source-code">
dotnet ef database update --startup-project ../CqrsDemo.WebApi</pre></li> <li>Create a <code>Notification</code> folder in the <code>CqrsDemo.Core</code> project. Then, create a <code>SendInvoiceNotification</code> class in the <code>Notification</code> folder with the following code:<pre class="source-code">
public class SendInvoiceNotification(Guid invoiceId) : INotification{    public Guid InvoiceId { get; set; } = invoiceId;}</pre><p class="list-inset">The preceding code defines a <code>SendInvoiceNotification</code> class that implements the <code>INotification</code> interface. This interface is used to indicate that this is a notification that does not return any result.</p></li> <li>Create a <code>Handlers</code> folder in the <code>Notification</code> folder. Then, create a <code>SendInvoiceEmailNotificationHandler</code> class in the <code>Handlers</code> folder with the following code:<pre class="source-code">
public class SendInvoiceEmailNotificationHandler(IInvoiceService invoiceService) : INotificationHandler&lt;SendInvoiceNotification&gt;{    public async Task Handle(SendInvoiceNotification notification, CancellationToken cancellationToken)    {        // Send email notification        var invoice = await invoiceService.GetAsync(notification.InvoiceId, cancellationToken);        if (invoice is null || string.IsNullOrWhiteSpace(invoice.ContactEmail))        {            return;        }        // Send email notification        Console.WriteLine($"Sending email notification to {invoice.ContactEmail} for invoice {invoice.Id}");    }}</pre><p class="list-inset">In the <a id="_idIndexMarker2007"/>preceding code, we use <code>IInvocieService</code> to obtain the invoice via the ID. Then, we check if the invoice exists and if the contact email is specified. If so, we send an email notification to the customer. For simplicity, we just print a message to the console.</p></li> <li>Similarly, create a <code>SendInvoiceTextMessageNotificationHandler</code> class in the <code>Handlers</code> folder with the following code:<pre class="source-code">
public class SendInvoiceTextMessageNotificationHandler(IInvoiceService invoiceService) : INotificationHandler&lt;SendInvoiceNotification&gt;{    public async Task Handle(SendInvoiceNotification notification, CancellationToken cancellationToken)    {        // Send text message notification        var invoice = await invoiceService.GetAsync(notification.InvoiceId, cancellationToken);        if (invoice is null || string.IsNullOrWhiteSpace(invoice.ContactPhone))        {            return;        }        // Send text message notification        Console.WriteLine($"Sending text message notification to {invoice.ContactPhone} for invoice {invoice.Id}");    }}</pre><p class="list-inset">The <a id="_idIndexMarker2008"/>preceding code is similar to the previous handler. It sends a text message notification to the customer.</p></li> <li>Inject the <code>IPublisher</code> interface into the <code>InvoicesController</code> class, as shown in the following:<pre class="source-code">
public class InvoicesController(IInvoiceService invoiceService, ISender mediatorSender, IPublisher mediatorPublisher) : ControllerBase{    // Omitted}</pre><p class="list-inset">The <code>IPublisher</code> interface <a id="_idIndexMarker2009"/>is used to publish a notification or event through the mediator pipeline to be handled by multiple handlers.</p></li> <li>Update the <code>CreateInvoice</code> method in the <code>InvoicesController</code> class with the following code:<pre class="source-code">
[HttpPost]public async Task&lt;ActionResult&lt;InvoiceDto&gt;&gt; CreateInvoice(CreateOrUpdateInvoiceDto invoiceDto){    //var invoice = await invoiceService.AddAsync(invoiceDto);    var invoice = await mediatorSender.Send(new CreateInvoiceCommand(invoiceDto));    await mediatorPublisher.Publish(new SendInvoiceNotification(invoice.Id));    return CreatedAtAction(nameof(GetInvoice), new { id = invoice.Id }, invoice);}</pre><p class="list-inset">In the preceding code, when creating a new invoice, we send a <code>SendInvoiceNotification</code> notification to the <code>IPublisher</code> interface. The <code>IPublisher</code> interface will invoke the <code>SendInvoiceEmailNotificationHandler</code> handler and the <code>SendInvoiceTextMessageNotificationHandler</code> handler to handle the notification. Then, they will send the email notification and text message notification to the customer. If we need more notifications, we can simply add more handlers to handle the notification without changing the controller code.</p><p class="list-inset">Run the <a id="_idIndexMarker2010"/>application and send a <code>POST</code> request to the <code>/api/invoices</code> endpoint to create a new invoice. You should be able to see the console messages for the email notification and text message notifications.</p></li> </ol>
<p>This is just a simple example to demonstrate how to use the <code>MediatR</code> library to implement the CQRS pattern. CQRS and <code>MediatR</code> allow us to separate the read and write concerns and decouple the business logic layer from the data persistence layer. You can also try to use different databases for reading and writing or even for different projects. However, note that using different databases may lead to data consistency issues. You can use the event-sourcing pattern with the CQRS pattern to maintain data consistency and full audit trails. We will not cover the event-sourcing pattern in this book. You can find more details about the event-sourcing pattern at the following link: <a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing">https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing</a>.</p>
<p>Next, we will introduce a popular patte<a id="_idTextAnchor724"/>rn for asynchronous communication between microservices: the pub/sub pattern.</p>
<h3>Pub/sub</h3>
<p>In a <a id="_idIndexMarker2011"/>microservice architecture, the microservices<a id="_idIndexMarker2012"/> communicate with each other through standard interfaces, such as HTTP APIs or gRPC. Sometimes, a microservice may need to communicate with other services in an asynchronous way. It may also need to broadcast an event to multiple services. The pub/sub pattern can be used to address the need for loosely coupled communication between microservices. It facilitates broadcasting events or messages to multiple subscribers without them being directly aware of each other.</p>
<p>The pub/sub pattern is a communication model that facilitates the exchange of messages between publishers and subscribers without requiring them to be aware of each other. It consists of three components: publishers, subscribers, and a message broker. Publishers are responsible for publishing events or messages to the message broker, which then distributes them to subscribers. Subscribers, in turn, subscribe to the message broker and receive the events or messages that have been published. This pattern allows for asynchronous communication between publishers and subscribers, enabling them to remain independent of each other.</p>
<p>Many <a id="_idIndexMarker2013"/>message brokers can be used to implement the<a id="_idIndexMarker2014"/> pub/sub pattern. Some popular message brokers include the following:</p>
<ul>
<li><strong class="bold">RabbitMQ</strong>: RabbitMQ is <a id="_idIndexMarker2015"/>an open-source, cross-platform <a id="_idIndexMarker2016"/>message broker that is widely used in microservice architectures. It is lightweight and easy to deploy on-premises and in the cloud. For more details, refer to the following link: <a href="https://rabbitmq.com/">https://rabbitmq.com/</a>.</li>
<li><strong class="bold">Redis</strong>: Redis <a id="_idIndexMarker2017"/>is an open-source in-memory data structure <a id="_idIndexMarker2018"/>store. It is versatile and has high performance. Redis is a popular choice for various use cases, such as key-value databases, caches, and message brokers. We learned how to use Redis as a cache in <a href="B18971_15.xhtml#_idTextAnchor632"><em class="italic">Chapter 15</em></a>. It can also be used as a message broker to implement the pub/sub pattern. For more details, refer to the following link: <a href="https://redis.io/">https://redis.io/</a>.</li>
<li><strong class="bold">Apache Kafka</strong>: Apache Kafka<a id="_idIndexMarker2019"/> is an open-source, distributed <a id="_idIndexMarker2020"/>event-streaming platform. It is a reliable and scalable message broker that can be used to implement the pub/sub pattern. It ensures the durable and reliable storage of event streams in a scalable, fault-tolerant, and secure manner. You can manage it yourself or use a managed service provided by a variety of cloud providers. For more details, refer to the following link: <a href="https://kafka.apache.org/">https://kafka.apache.org/</a>.</li>
<li><strong class="bold">Azure Service Bus</strong>: Azure Service Bus<a id="_idIndexMarker2021"/> is a fully managed <a id="_idIndexMarker2022"/>enterprise message broker provided by Microsoft Azure. It supports message queues and topics. For more details, refer to the following link: <a href="https://learn.microsoft.com/en-us/azure/service-bus-messaging/">https://learn.microsoft.com/en-us/azure/service-bus-messaging/</a>.</li>
</ul>
<p>The pub/sub pattern decouples the microservices from each other. It also improves the scalability and reliability. All the messages or events are handled in an asynchronous way. This helps the service continue to function even if the workload increases or one of the services fails. However, it also increases the complexity of the system. You need to manage the message ordering, message priority, message duplication, message expiration, dead-letter queues, and so on. To learn more about the pub/sub pattern, you can refer to the following <a id="_idTextAnchor725"/>link: <a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber">https://learn.microsoft.com/en-us/azure/architecture/patterns/publisher-subscriber</a>.</p>
<h3>Backends for frontends</h3>
<p><strong class="bold">Backends for frontends</strong> (<strong class="bold">BFFs</strong>) address<a id="_idIndexMarker2023"/> the challenge of efficiently serving diverse client<a id="_idIndexMarker2024"/> interfaces with distinct requirements. This is useful when applications need to serve multiple client types, such as web, mobile, and desktop. Each client type may need a different data format. In this case, a monolithic backend may struggle to cater to the unique needs of each client. Specifically, if the backend includes multiple microservices, each microservice may need to provide multiple endpoints to serve different client types. This can lead to a complex and inefficient system.</p>
<p>BFF architecture is a useful solution for applications that need to serve multiple client types, such as web, mobile, and desktop. Each client type may have distinct requirements for a data format, which can be difficult to manage with a monolithic backend. If the backend includes multiple microservices, each microservice may need to provide multiple endpoints to serve different client types, resulting in a complex and inefficient system. BFFs can help address this challenge by efficiently serving diverse client interfaces with distinct requirements.</p>
<p>BFF introduces dedicated backend services tailored for specific frontend clients. Each frontend client has its corresponding backend, enabling fine-grained control over data retrieval, processing, and presentation. This allows for a more efficient and flexible system that can better meet the needs of each client.</p>
<p>The following diagram shows a<a id="_idIndexMarker2025"/> typical BFF architecture:</p>
<div><div><img alt="Figure 17.5 – Typical BFF architecture" src="img/B18971_17_05.jpg"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 17.5 – Typical BFF architecture</p>
<p>In <em class="italic">Figure 17</em><em class="italic">.5</em>, each<a id="_idIndexMarker2026"/> BFF service is responsible for a specific frontend client. It can retrieve data from multiple microservices <a id="_idIndexMarker2027"/>and combine the data into a single response. Each BFF service is fine-tuned to meet the specific needs of the frontend client. It also illustrates how each BFF service is responsible for a particular frontend client. Each BFF service is tailored to meet the specific requirements of the frontend client. It can retrieve data from multiple microservices and combine them into a single response.</p>
<p>BFFs should be lightweight. They can contain client-specific logic but should not contain business logic. The main purpose of BFFs is to tailor the data for each frontend client. However, this may lead to code duplic<a id="_idTextAnchor726"/>ation. If the data format is similar for multiple frontend clients, BFFs may not be required.</p>
<h3>Resilience patterns</h3>
<p>In a <a id="_idIndexMarker2028"/>microservice architecture, resilience and <a id="_idIndexMarker2029"/>reliability are essential for a successful system. web APIs are often subject to unpredictable environments, such as network latency, transient failures, service unavailability, high traffic, and so on. To ensure that these APIs are <a id="_idIndexMarker2030"/>resilient and reliable, several patterns can be implemented. These include retry, rate-limiting, time out, circuit breaker, and so on. In this section, we will discuss how to use the <code>Polly</code> library to implement these patterns in ASP.NET Core web API applications.</p>
<p>You can<a id="_idIndexMarker2031"/> find a sample project in the <code>/chapter17/PollyDemo</code> folder. This project contains two basic ASP.NET Core web API applications:</p>
<ul>
<li><code>PollyServerWebApi</code>, which behaves as a server</li>
<li><code>PollyClientWebApi</code>, which is also a web API application but also behaves as a client</li>
</ul>
<p>We will use these two applications to demonstrate how to use the <code>Polly</code> library to implement the rate-limiting, retry, timeout, and circuit breaker. <code>Polly</code> is a popular .NET resilience and transient-fault-handling library. You can find more details about <code>Polly</code> at the following link: <a href="https://www.thepollyproject.org/">https://www.thepollyproject.org/</a>.</p>
<p>To use <code>Polly</code> in ASP.NET Core web API applications, you need to install the <code>Polly</code> NuGet package. Navigate to the <code>PollyClientWebApi</code> project and run the following command in the terminal window to install the <code>Polly</code> package:</p>
<pre class="console">
dotnet add package Polly.Core</pre> <p><code>Polly</code> provides a resilience pipeline builder to build a resilience pipeline. A resilience pipeline runs a series of resilience policies. Each policy is responsible for handling a specific type of issue. The following code shows how to create a resilience pipeline builder:</p>
<pre class="source-code">
var pipeline = new <a id="_idTextAnchor727"/>ResiliencePipelineBuilder();</pre> <p>Next, we will explore several resilience policies provided by <code>Polly</code>.</p>
<h4>Timeout</h4>
<p>The <strong class="bold">timeout</strong> pattern is a <a id="_idIndexMarker2032"/>common pattern used to<a id="_idIndexMarker2033"/> handle slow or unresponsive services. When a service is slow or unresponsive, the client may wait for an extended period before receiving a response. To avoid this, a timeout can be set for the service. If the service cannot respond within the given time frame, the client can return an error to the user, thus preventing them from waiting unnecessarily.</p>
<p>In <a href="B18971_04.xhtml#_idTextAnchor170"><em class="italic">Chapter 4</em></a>, we<a id="_idIndexMarker2034"/> introduced a <code>RequestTimeout</code> middleware to set the timeout for the ASP.NET Core web API application. The <code>RequestTimeout</code> middleware is applied to the endpoints or actions that need to be <a id="_idIndexMarker2035"/>timed out. Sometimes, we may need to set the timeout for a specific method call, such as calling a REST API or querying a database. Let us explore other ways to set the timeout.</p>
<p>The <code>HttpClient</code> class in .NET Core provides a timeout feature. You can set the timeout for the <code>HttpClient</code> object by setting the <code>Timeout</code> property. The following code shows how to set the timeout for the <code>HttpClient</code> object:</p>
<pre class="source-code">
var httpClient = httpClientFactory.CreateClient();httpClient.Timeout = TimeSpan.FromSeconds(10);</pre>
<p>The preceding code creates an <code>HttpClient</code> object and sets the timeout to 10 seconds. If the service does not respond within 10 seconds, the <code>HttpClient</code> object will throw an exception. You can catch the exception and return an error to the user.</p>
<p>Setting the timeout for the <code>HttpClient</code> object is useful for simple tasks, such as calling a REST API. However, it is not suitable for more complex tasks that do not use <code>HttpClient</code>, such as a database query. For other tasks, such as a database query, you can use the <code>CancellationToken</code> to set the timeout. The following code shows how to set the timeout for a database query:</p>
<pre class="source-code">
var cancellationToken = new CancellationTokenSource(TimeSpan.FromSeconds(10));var invoice = await invoiceRepository.GetAsync(id, cancellationToken.Token);</pre>
<p>The preceding code creates a <code>CancellationTokenSource</code> object and sets the timeout to 10 seconds. If the database query is not complete within 10 seconds, the <code>GetAsync()</code> method will throw an exception. This prevents the client from waiting for an extended period before receiving a response.</p>
<p>Sometimes, there may be multiple services that need to be called. Moreover, setting the timeout for each service call may be tedious. To simplify this, we can use the <code>Polly</code> library to implement the timeout policy.</p>
<p><code>Polly</code> provides<a id="_idIndexMarker2036"/> a timeout policy that can be used to set the <a id="_idIndexMarker2037"/>timeout for a service. Follow these steps to implement the timeout policy:</p>
<ol>
<li>Create an endpoint in the <code>PollyServerWebApi</code> application to simulate a slow service. Open the <code>Program.cs</code> file and add the following code:<pre class="source-code">
app.MapGet("/api/slow-response", async () =&gt;{    var random = new Random();    var delay = random.Next(1, 20);    await Task.Delay(delay * 1000);    return Results.Ok($"Response delayed by {delay} seconds");});</pre><p class="list-inset">The preceding code defines a minimal API endpoint that simulates a slow service. It generates a random delay between 1 and 20 seconds. This endpoint will return a response after the delay. This is just an example of simulating a slow service. In a real-world application, the service may be slow due to network latency, high traffic, and so on.</p></li> <li>Create a controller in the <code>PollyClientWebApi</code> application to call the slow service. Add a <code>PollyController</code> class in the <code>Controllers</code> folder with the following code:<pre class="source-code">
namespace PollyClientWebApi.Controllers;[Route("api/[controller]")][ApiController]public class PollyController(ILogger&lt;PollyController&gt; logger, IHttpClientFactory httpClientFactory) : ControllerBase{    [HttpGet("slow-response")]    public async Task&lt;IActionResult&gt; GetSlowResponse()    {        var client = httpClientFactory.CreateClient("PollyServerWebApi");        var response = await client.GetAsync("api/slow-response");        var content = await response.Content.ReadAsStringAsync();        return Ok(content);    }}</pre><p class="list-inset">This<a id="_idIndexMarker2038"/> controller uses the <code>IHttpClientFactory</code> to create an <code>HttpClient</code> object. Then, it calls the slow service and returns the response to the client.</p></li> <li>Run the<a id="_idIndexMarker2039"/> two applications and send a request to the <code>/api/polly/slow-response</code> endpoint of the <code>PollyClientWebApi</code> application. You should be able to see the response after a random delay between 1 and 20 seconds.</li>
<li>Next, we will implement the timeout policy using <code>Polly</code>. For example, we can set the timeout to 5 seconds, which means if the service does not respond within 5 seconds, the client will return an error to the user instead of waiting for a long time. Update the <code>GetSlowResponse()</code> method of the <code>PollyController</code> class as follows:<pre class="source-code">
[HttpGet("slow-response")]public async Task&lt;IActionResult&gt; GetSlowResponse(){    var pipeline = new ResiliencePipelineBuilder().AddTimeout(TimeSpan.FromSeconds(5)).Build();    try    {        var response = await pipeline.ExecuteAsync(async cancellationToken =&gt;            await client.GetAsync("api/slow-response", cancellationToken));        var content = await response.Content.ReadAsStringAsync();        return Ok(content);    }    catch (Exception e)    {        logger.LogError(e.Message);        return Problem(e.Message);    }}</pre><p class="list-inset">The <a id="_idIndexMarker2040"/>preceding code uses <code>Polly</code> to create a <code>ResiliencePipelineBuilder</code> object. Then, it adds a timeout policy with a<a id="_idIndexMarker2041"/> timeout of 5 seconds. The <code>ExecuteAsync()</code> method is used to execute the pipeline. If the service does not respond within 5 seconds, the <code>ExecuteAsync()</code> method will throw an exception. The <code>catch</code> block is used to catch the exception and return an error to the user.</p></li> <li>Note that in the <code>ExecuteAsync()</code> method, the cancellation token is passed to the <code>GetAsync()</code> method of the <code>HttpClient</code> object. If it does not, the <code>HttpClient</code> will <a id="_idIndexMarker2042"/>continue to wait even if the timeout occurs. It is important to respect the cancellation token from the <code>Polly</code> resilience pipeline.</li>
<li>Run the two applications and send a request to the <code>/api/polly/slow-response</code> endpoint of the <code>PollyClientWebApi</code> application. You should be able to see the error message after 5 seconds.</li>
</ol>
<p>In the preceding example, we <a id="_idIndexMarker2043"/>defined the timeout policy in the controller. To reuse the timeout policy, we can define a global timeout policy in the <code>Program.cs</code> file and then use dependency injection to inject the policy into the controller. Follow these steps to implement the global timeout policy:</p>
<ol>
<li>Install the <code>Polly.Extensions</code> NuGet package. Navigate to the <code>PollyClientWebApi</code> project and run the following command in the terminal window to install the <code>Polly.Extensions</code> package:<pre class="source-code">
<code>Program.cs</code> file of the <code>PollyClientWebApi</code> application and add the following code:<pre class="source-code">
builder.Services.AddResiliencePipeline("timeout-5s-pipeline", configure =&gt;{    configure.AddTimeout(TimeSpan.FromSeconds(5));});</pre><p class="list-inset">The preceding code defines a global timeout policy with a timeout of 5 seconds. The policy is named <code>timeout-5s-pipeline</code>. You can use any name you like. The <code>AddResiliencePipeline()</code> method is used to add the timeout policy to the pipeline.</p></li> <li>Inject the <code>ResiliencePipelineProvider&lt;string&gt;</code> class into the <code>PollyController</code> class, as shown in the following:<pre class="source-code">
public class PollyController(ILogger&lt;PollyController&gt; logger, IHttpClientFactory httpClientFactory, ResiliencePipelineProvider&lt;string&gt; resiliencePipelineProvider) : ControllerBase{    // Omitted}</pre><p class="list-inset">The <code>ResiliencePipelineProvider&lt;string&gt;</code> class is used to retrieve the global <a id="_idIndexMarker2044"/>timeout policy. The <code>string</code> type parameter specifies the type of the policy name.</p></li> <li>Update <a id="_idIndexMarker2045"/>the <code>GetSlowResponse()</code> method of the <code>PollyController</code> class as follows:<pre class="source-code">
var pipeline = resiliencePipelineProvider.GetPipeline("timeout-5s-pipeline");// Omitted</pre><p class="list-inset">In this way, we can reuse the global<a id="_idTextAnchor728"/> timeout policy by its name.</p></li> </ol>
<p><code>Polly</code> supports many other resilience patterns. Next, let us discuss rate-limiting.</p>
<h4>Rate-limiting</h4>
<p>The <strong class="bold">rate-limiting</strong> pattern is <a id="_idIndexMarker2046"/>a common pattern<a id="_idIndexMarker2047"/> used to limit the number of requests that can be made to a service. The rate should be set to a reasonable value to avoid overloading the service. You can run a performance test to determine the optimal rate limit. The performance of the service depends on many factors, such as the hardware, network, and the complexity of business logic. Once you have determined the optimal rate limit, you can apply it to the service to ensure that it can handle the workload.</p>
<p>For example, if a <a id="_idIndexMarker2048"/>service can handle 100 requests per second when the number of requests exceeds 100, the service may become slow or even unavailable. The client may encounter a timeout error. To avoid this, we can set the rate limit for the service. When the number of requests exceeds the rate limit, the service will reject the requests and return an error to the client. This can prevent the service from being overloaded.</p>
<p>ASP.NET Core<a id="_idIndexMarker2049"/> provides a rate-limiting middleware that can be used to configure rate-limiting in various policies, such as <code>fixed window</code>, <code>sliding window</code>, <code>token bucket</code>, and <code>concurrency</code>. We introduced rate-limiting middleware in <a href="B18971_04.xhtml#_idTextAnchor170"><em class="italic">Chapter 4</em></a>. You can find more details about rate-limiting middleware at the following link: <a href="https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit">https://learn.microsoft.com/en-us/aspnet/core/performance/rate-limit</a>.</p>
<p>You can open the <code>PollyDemo</code> solution in the <code>/chapter17/PollyDemo/end</code> folder. In the <code>Program.cs</code> file of the <code>PollyServerWebApi</code> project, you can find the following code:</p>
<pre class="source-code">
builder.Services.AddRateLimiter(options =&gt;{
    options.AddFixedWindowLimiter("FiveRequestsInThreeSeconds", limiterOptions =&gt;
    {
        limiterOptions.PermitLimit = 5;
        limiterOptions.Window = TimeSpan.FromSeconds(3);
    });
    options.RejectionStatusCode = StatusCodes.Status429TooManyRequests;
    options.OnRejected = async (context, _) =&gt;
    {
        await context.HttpContext.Response.WriteAsync("Too many requests. Please try later.", CancellationToken.None);
    };
});
// Omitted
app.UseRateLimiter();</pre>
<p>The rate-limiting policy<a id="_idIndexMarker2050"/> is applied to the <code>WeatherForecastController</code> class:</p>
<pre class="source-code">
[EnableRateLimiting("FiveRequestsInThreeSeconds")][ApiController]
[Route("[controller]")]
public class WeatherForecastController(ILogger&lt;WeatherForecastController&gt; logger) : ControllerBase
{
    // Omitted
}</pre>
<p>The <a id="_idIndexMarker2051"/>preceding code configures a fixed window rate limiter with a rate limit of five requests per 3 seconds. Of course, this is just an example for demonstration purposes. When the <code>PollyClientWebApi</code> application sends more than five requests per 3 seconds to the <code>PollyServerWebApi</code> application, the <code>PollyServerWebApi</code> application will return a <code>429 Too Many Requests</code> error to the client. The <code>OnRejected</code> callback is used to handle the rejected requests. In this example, we simply return a message to the client.</p>
<p>Use the <code>dotnet run</code> command to run the <code>PollyServerWebApi</code> application and the <code>PollyClientWebApi</code> application. Then, send more than five requests per 3 seconds to the <code>/weatherforecast</code> endpoint of the <code>PollyClientWebApi</code> application. You should be able to see the <code>429 Too Many Requests</code> error in the <code>PollyClientWebApi</code> application. In this way, we can limit the number of requests to the <code>PollyServerWebApi</code> service so that it can handle the workload without being overloaded.</p>
<p>We can also use <code>Polly</code> to implement the rate-limiting pattern. Follow these steps to implement the rate-limiting<a id="_idIndexMarker2052"/> pattern using <code>Polly</code>:</p>
<ol>
<li>Install the <code>Polly.RateLimiting</code> NuGet package for the <code>PollyClientWebApi</code> project by running the following command in the terminal window:<pre class="source-code">
<code>Polly.RateLimiting</code> package is a wrapper for the <code>System.Threading.RateLimiting</code> package provided by Microsoft. It also depends on the <code>Polly.Core</code> package. So, if you have not installed the <code>Polly.Core</code> package, it will be installed automatically.</p></li> <li>Create a <code>/api/normal-response</code> endpoint in the <code>PollyServerWebApi</code> application<a id="_idIndexMarker2053"/> to simulate a normal service. Open the <code>Program.cs</code> file and add the following code:<pre class="source-code">
app.MapGet("/api/normal-response", async () =&gt;{    var random = new Random();    var delay = random.Next(1, 1000);    await Task.Delay(delay);    return Results.Ok($"Response delayed by {delay} milliseconds");});</pre><p class="list-inset">This endpoint will return a response after a random delay between 1 and 1000 milliseconds, which means, in the worst case, it may take 1 second to return a response. To limit the number of requests to this endpoint, we can use the rate-limiting policy for the <code>PollyClientWebApi</code> application.</p></li> <li>We will use the dependency injection to inject the rate-limiting policy for convenience. Define a rate-limiting policy in the <code>Program.cs</code> as follows:<pre class="source-code">
builder.Services.AddResiliencePipeline("rate-limit-5-requests-in-3-seconds", configure =&gt;{    configure.AddRateLimiter(new FixedWindowRateLimiter(new FixedWindowRateLimiterOptions    { PermitLimit = 5, Window = TimeSpan.FromSeconds(3) }));});</pre><p class="list-inset">The preceding <a id="_idIndexMarker2054"/>code defines a fixed window rate limiter with a rate limit of 5 requests per 3 seconds. The policy is named <code>rate-limit-5-requests-in-3-seconds</code>. You can use any name you like.</p></li> <li>In this <a id="_idIndexMarker2055"/>example, we create a separate <code>Polly</code> pipeline for the rate-limiting policy. You can also combine multiple policies into a single pipeline. For example, you can combine the rate-limiting policy and the timeout policy into a single pipeline using the following code:<pre class="source-code">
builder.Services.AddResiliencePipeline("combined-resilience-policy", configure =&gt;{    configure.AddRateLimiter(        // Omitted    );    configure.AddTimeout(        // Omitted    );    // You can add more policies here});</pre></li> <li>Inject<a id="_idIndexMarker2056"/> the <code>ResiliencePipelineProvider&lt;string&gt;</code> class into the <code>PollyController</code> class <a id="_idIndexMarker2057"/>of the <code>PollyClientWebApi</code> project, as shown in the following:<pre class="source-code">
[HttpGet("rate-limit")]public async Task&lt;IActionResult&gt; GetNormalResponseWithRateLimiting(){    var client = httpClientFactory.CreateClient("PollyServerWebApi");    try    {        var pipeline = resiliencePipelineProvider.GetPipeline("rate-limit-5-requests-in-3-seconds");        var response = await pipeline.ExecuteAsync(async cancellationToken =&gt;            await client.GetAsync("api/normal-response", cancellationToken));        var content = await response.Content.ReadAsStringAsync();        return Ok(content);    }    catch (Exception e)    {        logger.LogError($"{e.GetType()} {e.Message}");        return Problem(e.Message);    }}</pre><p class="list-inset">You will find <a id="_idIndexMarker2058"/>that the code is quite similar to the timeout policy.</p></li> <li>Run the two applications and send more than 5 requests per 3 seconds to the <code>/api/polly/rate-limit</code> endpoint of the <code>PollyClientWebApi</code> application. Sometimes, you may see an error message in the console window of the <code>PollyClientWebApi</code> application as follows:<pre class="source-code">
Polly.RateLimiting.RateLimiterRejectedException The operation could not be executed because it was rejected by the rate limiter. It can be retried after '00:00:03'.</pre></li> <li>Similarly, you <a id="_idIndexMarker2059"/>can use <code>Polly</code> to implement other rate-limiting policies, such as <code>sliding window</code>, <code>concurrency</code>, and <code>token bucket</code>. Here is an example of the sliding window rate limiter:<pre class="source-code">
configure.AddRateLimiter(new SlidingWindowRateLimiter(new SlidingWindowRateLimiterOptions{ PermitLimit = 100, Window = TimeSpan.FromMinutes(1) }));</pre><p class="list-inset">The preceding code defines a sliding window rate limiter with a rate limit of 100 requests per minute.</p></li> <li>As the Polly <code>RateLimiter</code> is a disposable resource, it is a good practice to dispose of it when it is no longer needed. <code>Polly</code> provides an <code>OnPipelineDisposed</code> callback that can be used to dispose of the <code>RateLimiter</code> object. For example, we can dispose of the <code>RateLimiter</code> object in the <code>OnPipelineDisposed</code> callback as follows:<pre class="source-code">
builder.Services.AddResiliencePipeline("rate-limit-5-requests-in-3-seconds", (configure, context) =&gt;{    var rateLimiter = new FixedWindowRateLimiter(new FixedWindowRateLimiterOptions    { PermitLimit = 5, Window = TimeSpan.FromSeconds(3) });    configure.AddRateLimiter(rateLimiter);    // Dispose the rate limiter when the pipeline is disposed    context.OnPipelineDisposed(() =&gt; rateLimiter.Dispose());});</pre></li> </ol>
<p>In this way, w<a id="_idTextAnchor729"/>e <a id="_idIndexMarker2060"/>can dispose of the <code>RateLimiter</code> object <a id="_idIndexMarker2061"/>when the pipeline is disposed of so that it does not consume resources unnecessarily.</p>
<h4>Retry</h4>
<p>Next, let us<a id="_idIndexMarker2062"/> discuss <code>429 Too Many Requests</code> error, or a <code>500 Internal Server Error</code> error, it can retry the request after a delay because the error may be caused by a temporary issue, such as rate-limiting or a network glitch. The next time the client API sends the request, it may succeed. This is called retry.</p>
<p>The retry pattern<a id="_idIndexMarker2063"/> is a common approach to addressing transient failures in communication between microservices. This pattern is particularly useful in a microservice architecture, where network glitches or the temporary unavailability of a service can cause communication failures. By implementing retry mechanisms, these transient issues can be managed, and the overall reliability of the system can be improved.</p>
<p>Follow these steps to implement the retry pattern using <code>Polly</code>:</p>
<ol>
<li>Update the <code>Get()</code> method <a id="_idIndexMarker2064"/>of the <code>WeatherForecastController</code> class as follows:<pre class="source-code">
[HttpGet(Name = "GetWeatherForecast")]public async Task&lt;ActionResult&lt;IEnumerable&lt;WeatherForecast&gt;&gt;&gt; Get(){    var httpClient = httpClientFactory.CreateClient("PollyServerWebApi");    var pollyPipeline = new ResiliencePipelineBuilder()    .AddRetry(new Polly.Retry.RetryStrategyOptions()    {        ShouldHandle = new PredicateBuilder().Handle&lt;Exception&gt;(),        MaxRetryAttempts = 3,        Delay = TimeSpan.FromMilliseconds(500),        MaxDelay = TimeSpan.FromSeconds(5),        OnRetry = args =&gt;        {            logger.LogWarning($"Retry {args.AttemptNumber}, due to: {args.Outcome.Exception?.Message}.");            return default;        }    })    .Build();    HttpResponseMessage? response = null;    await pollyPipeline.ExecuteAsync(async _ =&gt;    {        response = await httpClient.GetAsync("/WeatherForecast");        response.EnsureSuccessStatusCode();    });    if (response != null &amp; response!.IsSuccessStatusCode)    {        var result = await response.Content.ReadFromJsonAsync&lt;IEnumerable&lt;WeatherForecast&gt;&gt;();        return Ok(result);    }    return StatusCode((int)response.StatusCode, response.ReasonPhrase);}</pre><p class="list-inset">The <a id="_idIndexMarker2065"/>preceding code creates a <code>ResiliencePipelineBuilder</code> object to build a resilience pipeline. Then, it adds a retry policy to the pipeline. The retry policy will retry the request three times if it fails. The <a id="_idIndexMarker2066"/>delay between retries is 500 milliseconds. The <code>MaxDelay</code> property is used to specify the maximum delay duration. The <code>OnRetry</code> callback is used to log the retry attempts. Finally, it executes the pipeline to send the request to the <code>PollyServerWebApi</code> application.</p></li> <li>Run the two applications and send more than five requests per 3 seconds to the <code>/weatherforecast</code> endpoint of the <code>PollyClientWebApi</code> application. Sometimes, you may see that the request takes a longer time to complete. This is because the request is retried if it fails. You should also be able to see the retry attempts in the console window of the <code>PollyClientWebApi</code> application, as shown in the following:<pre class="source-code">
warn: PollyClientWebApi.Controllers.WeatherForecastController[0]      Retry 2, due to: Response status code does not indicate success: 429 (Too Many Requests)..</pre><p class="list-inset">In this way, we can automatically retry the request if it fails. This can improve the reliability of the system.</p></li> <li>The <a id="_idIndexMarker2067"/>retry policy can be configured in various ways. For example, we can configure the retry policy to retry the request only when the response status code is <code>429</code> as follows:<pre class="source-code">
ShouldHandle = new PredicateBuilder().Handle&lt;Exception&gt;().Or&lt;HttpRequestException&gt;(ex =&gt; ex.StatusCode == HttpStatusCode.TooManyRequests),</pre><p class="list-inset">We can also delay the retry attempts with an exponential backoff strategy. This is because the service may be overloaded, and the retry attempts may fail again. In this case, we can delay the retry attempts to avoid overloading the service.</p></li> <li>To use<a id="_idIndexMarker2068"/> the exponential backoff strategy, we can specify the <code>BackoffType</code> property of the <code>RetryStrategyOptions</code> object as follows:<pre class="source-code">
BackoffType = DelayBackoffType.Exponential,</pre><p class="list-inset">The <code>BackoffType</code> property is a <code>DelayBackoffType</code> enum that can be set to <code>Constant</code>, <code>Linear</code>, or <code>Exponential</code>. The <code>Constant</code> strategy will delay the retry attempts with a constant delay. The <code>Linear</code> strategy will delay the retry attempts with a linear delay. The <code>Exponential</code> strategy will delay the retry attempts with an exponential delay. The default strategy is <code>Constant</code>.</p></li> </ol>
<p>There are a <a id="_idIndexMarker2069"/>few considerations when using the retry pattern:</p>
<ul>
<li>The retry pattern should only be used to handle transient failures. If you want to implement a repeatable operation, you should use some scheduling mechanism, such as a background service, or suitable tools, such <a id="_idIndexMarker2070"/>as <code>Polly</code> retry to implement a scheduled repeating operation.</li>
<li>Consider using different retry policies for different types of errors. For example, an API call may involve HTTP requests, database queries, and JSON deserialization. If the HTTP request fails due to a network glitch, you can retry the request. However, if the JSON deserialization fails, it is unlikely to succeed even if<a id="_idTextAnchor730"/> you retry the JSON deserialization method. In this case, you can use <code>ShouldHandle</code> to specify the types of errors that should be retried.</li>
</ul>
<h4>Circuit breaker</h4>
<p>The <strong class="bold">circuit breaker</strong> pattern<a id="_idIndexMarker2072"/> is a useful tool for<a id="_idIndexMarker2073"/> preventing service overload and failure. In the event that a service is becoming seriously overloaded, a client should stop sending requests for a period of time in order to allow the service to recover. This is known as the circuit breaker pattern and can help to avoid a service crash or total failure.</p>
<p>We can use <code>Polly</code> to implement the circuit breaker pattern. As we have already learned how to use Polly to implement the timeout pattern, the rate-limiting pattern, and the retry pattern, you should be able to understand the following steps:</p>
<ol>
<li>Create a new <code>/api/random-failure-response</code> endpoint in the <code>PollyServerWebApi</code> application to simulate an overloaded service. Open the <code>Program.cs</code> file and add the following code:<pre class="source-code">
app.MapGet("/api/random-failure-response", () =&gt;{    var random = new Random();    var delay = random.Next(1, 100);    return Task.FromResult(delay &gt; 20 ? Results.Ok($"Response is successful.") : Results.StatusCode(StatusCodes.Status500InternalServerError));});</pre><p class="list-inset">This <a id="_idIndexMarker2074"/>endpoint will return a <code>500 Internal Server Error</code> error with an 80% chance (approximately). This is just an example of simulating an overloaded service. In a real-world application, the service may be overloaded due to high traffic, network latency, and so on.</p></li> <li>Add the following code to the <code>Program.cs</code> file of the <code>PollyClientWebApi</code> application:<pre class="source-code">
builder.Services.AddResiliencePipeline("circuit-breaker-5-seconds", configure =&gt;{    configure.AddCircuitBreaker(new CircuitBreakerStrategyOptions    {        FailureRatio = 0.7,        SamplingDuration = TimeSpan.FromSeconds(10),        MinimumThroughput = 10,        BreakDuration = TimeSpan.FromSeconds(5),        ShouldHandle = new PredicateBuilder().Handle&lt;Exception&gt;()    });});</pre><p class="list-inset">The <a id="_idIndexMarker2075"/>preceding code defines a circuit breaker policy named <code>circuit-breaker-5-seconds</code> with a failure ratio of 0.7. This means if the failure ratio is greater than 0.7, the circuit breaker will open. The <code>SamplingDuration</code> property is used to specify the duration of the sampling over which the failure ratios are calculated. The <code>MinimumThroughput</code> property means that at least 10 requests must be made within the sampling duration. The <code>BreakDuration</code> property means that the circuit breaker will stay open for 5 seconds if it opens. The <code>ShouldHandle</code> property is used to specify the types of errors that should be handled by the circuit breaker.</p></li> <li>Create a new<a id="_idIndexMarker2076"/> action in the <code>PollyController</code> class of the <code>PollyClientWebApi</code> application to call the overloaded service. Add the following<a id="_idIndexMarker2077"/> code:<pre class="source-code">
[HttpGet("circuit-breaker")]public async Task&lt;IActionResult&gt; GetRandomFailureResponseWithCircuitBreaker(){    var client = httpClientFactory.CreateClient("PollyServerWebApi");    try    {        var pipeline = resiliencePipelineProvider.GetPipeline("circuit-breaker-5-seconds");        var response = await pipeline.ExecuteAsync(async cancellationToken =&gt;            {                var result = await client.GetAsync("api/random-failure-response", cancellationToken);                result.EnsureSuccessStatusCode();                return result;            });        var content = await response.Content.ReadAsStringAsync();        return Ok(content);    }    catch (Exception e)    {        logger.LogError($"{e.GetType()} {e.Message}");        return Problem(e.Message);    }}</pre><p class="list-inset">The <a id="_idIndexMarker2078"/>preceding code uses <code>result.EnsureSuccessStatusCode()</code> to throw an exception if the response status<a id="_idIndexMarker2079"/> code is not successful. As the overloaded service has an 80% chance of returning an error, the circuit breaker will open after a couple of requests. Then, the circuit breaker will stay open for 5 seconds. During this period, the client will not send any requests to the overloaded service. After 5 seconds, the circuit breaker will close, and the client will send requests to the overloaded service again.</p></li> <li>Run the two applications and send more than 10 requests to the <code>/api/polly/circuit-breaker</code> endpoint of the <code>PollyClientWebApi</code> application. Sometimes, you will see a <code>500 Internal Server Error</code> error as follows:<pre class="source-code">
{  "type": "https://tools.ietf.org/html/rfc9110#section-15.6.1",  "title": "An error occurred while processing your request.",  "status": 500,  "detail": "Response status code does not indicate success: 500 (Internal Server Error).",  "traceId": "00-c5982555dbf0e66d5ca79fd83aa3837c-46cd1cd7f6acb851-00"}</pre></li> <li>Send more<a id="_idIndexMarker2080"/> requests, and you will see that the circuit breaker opens and returns a different error message as follows:<pre class="source-code">
{  "type": "https://tools.ietf.org/html/rfc9110#section-15.6.1",  "title": "An error occurred while processing your request.",  "status": 500,  "detail": "The circuit is now open and is not allowing calls.",  "traceId": "00-1b6dc3f8912f5ebd4e67a39a89dd605a-495d67559eaf22b7-00"}</pre><p class="list-inset">You can see <a id="_idIndexMarker2081"/>that the error message is different from the previous one, which indicates that the circuit breaker is open, so any requests to the overloaded service will be rejected. You need to wait for 5 seconds before sending more requests to the overloaded service. During these 5 seconds, all the requests to the <code>/api/polly/circuit-breaker</code> endpoint will not be sent to the overloaded service and will return the same error message instead.</p></li> </ol>
<p>Circuit breakers are not the same as the retry pattern. The retry pattern expects the operation to succeed eventually. However, the circuit breaker pattern prevents the operation from being executed if it is likely to fail, which can save resources and allow the external service to recover. You can use these two patterns together. But note that the retry logic should check the exception type thrown by the circuit breaker. If the circuit breaker indicates that the operation failure is not a<a id="_idIndexMarker2082"/> transient issue, the retry logic should not retry the operation.</p>
<p><code>Polly</code> is a<a id="_idIndexMarker2083"/> powerful library that implements many resilience patterns. This section cannot cover all the patterns provided by <code>Polly</code>. You can find more examples<a id="_idIndexMarker2084"/> at the following link: <a href="https://www.pollydocs.org/index.html">https://www.pollydocs.org/index.html</a>.</p>
<p>In addition<a id="_idIndexMarker2085"/> to the design patterns discussed in this chapter, there are more patterns for microservice architecture. As many of these patterns are beyond the scope of this book, we will not discu<a id="_idTextAnchor731"/>ss them in detail. You can find more details about these patterns from Microsoft Learn: <a href="https://learn.microsoft.com/en-us/azure/architecture/patterns/">https://learn.microsoft.com/en-us/azure/architecture/patterns/</a>.</p>
<h1 id="_idParaDest-374"><a id="_idTextAnchor732"/>Summary</h1>
<p>In this chapter, we explored several concepts and patterns for microservice architecture, including domain drive design, clean architecture, CQRS, pub/sub, and BFF, and resilience patterns, such as timeout, rate-limiting, retry, and circuit breaker. These patterns can help us design and implement a maintainable, reliable, and scalable microservice architecture. Although this chapter does not cover all the patterns for microservice architecture, it should provide a basic understanding of what they are and how they can be used. These patterns are essential for developers who wish to progress beyond the basic knowledge of ASP.NET Core web API.</p>
<p>In the next chapter, we will discuss some open-source frameworks that can be used to build ASP.NET
Core web API applications. You can check the chapter out at the following link: <a href="https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter18">https://github.com/PacktPublishing/Web-API-Development-with-ASP.NET-Core-8/tree/main/samples/chapter18</a>.</p>
<h2 id="_idParaDest-375"><a id="_idTextAnchor733"/>Further reading</h2>
<p>To learn more about microservice architecture, the following resources from Microsoft Learn are highly recommended:</p>
<ul>
<li>Architectural principles: <a href="https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles">https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/architectural-principles</a>.</li>
<li>Common web application architectures: <a href="https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures">https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/common-web-application-architectures</a>.</li>
<li>.NET Microservices: Architecture for Containerized .NET Applications: <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/">https://docs.microsoft.com/en-us/dotnet/architecture/microservices/</a>.</li>
<li>Architect Modern Web Applications with ASP.NET Core and Azure: <a href="https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/">https://learn.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/</a>.</li>
<li>Architecting Cloud Native .NET Applications for Azure: <a href="https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/">https://learn.microsoft.com/en-us/dotnet/architecture/cloud-native/</a>.</li>
<li>Serverless apps: Architecture, patterns, and Azure implementation: <a href="https://learn.microsoft.com/en-us/dotnet/architecture/serverless/">https://learn.microsoft.com/en-us/dostnet/architecture/serverless/</a>.</li>
<li>Cloud Design Patterns: <a href="https://docs.microsoft.com/en-us/azure/architecture/patterns/">https://docs.microsoft.com/en-us/azure/architecture/patterns/</a>.</li>
</ul>
</div>
</body></html>