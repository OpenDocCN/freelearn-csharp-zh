- en: Chapter 2. Memory Management
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'This chapter investigates how memory is managed on iOS and Android with Xamarin
    runtime. Whilst drawing parallels to the .NET platform, it will provide examples
    of memory management problems and issues that can cause leaks, and also look at
    useful patterns that can help developers save valuable resources. This chapter
    is divided into the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Application Component lifecycle
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Platform-specific concepts
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Troubleshooting and diagnosis
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Patterns and best practices
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Application Component lifecycle
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Each platform in the Xamarin ecosystem has certain processes and states that
    the applications go through during their execution lifetime. Developers can implement
    certain methods and subscribe to lifecycle events such as application start, suspension,
    termination, and backgrounding to handle much needed application state and release
    resources which are no longer required.
  prefs: []
  type: TYPE_NORMAL
- en: Activity lifecycle (Android)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Android applications, contrary to the conventional application development
    model, any activity can be the access point to the application (as long as it
    is designated as such). Any activity in the application can be initialized at
    start-up or can be resumed directly when the application is resuming or restarting
    from a crash.
  prefs: []
  type: TYPE_NORMAL
- en: In order to manage the lifecycle of the activities, there are distinct states
    and events which help developers organize memory resources and program features.
  prefs: []
  type: TYPE_NORMAL
- en: Active/Running
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An activity is said to be in the active state when an application is the application
    in focus and the activity is in the foreground. At this state, unless extraordinary
    measures are required by the operating system (for example, in case of system
    out of memory or application becoming unresponsive), the developer does not need
    to worry about the memory and resources, as the application has the highest priority.
  prefs: []
  type: TYPE_NORMAL
- en: In a creation cycle, `OnCreate` is the first method that is called by the application.
    This is the initialization step where the views are created, the variables are
    introduced, and static data resources are loaded.
  prefs: []
  type: TYPE_NORMAL
- en: '`OnStart` or `OnRestart` (if the activity is restarting after it was backgrounded)
    is the second event method in a creation cycle. This method(s) can be overridden
    if specific data reload procedures need to be implemented. This is the last method
    called before the activity becomes visible.'
  prefs: []
  type: TYPE_NORMAL
- en: The `OnResume` method is called after a successful launch of the activity. This
    method is the indication that the application is ready for user interaction. It
    can be used to (re)subscribe to external events, display alerts/user messages,
    and communicate with device peripherals.
  prefs: []
  type: TYPE_NORMAL
- en: Paused
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An activity is paused when either the device goes to sleep having this activity
    in the foreground, or the activity is partially hidden by another dialog or activity.
    In this state, the activity is still "alive" but cannot interact with the user.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnPause` event method is called right before the activity goes into the
    Paused state. This event method is the ideal place to unsubscribe from any external
    event providers, commit any unsaved changes and clean up any objects consuming
    memory resources since the user interaction is not possible in the Paused state.
    The activity will call only the `OnResume` method when once again the activity
    has the highest priority, it will not go through the full creation cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Backgrounded
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An activity goes into the Backgrounded state when the user presses the home
    button or uses the app switcher. In this state, it is not guaranteed that the
    activity will stay alive until the user "restarts" the application.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnStop` method is called when the application is backgrounded or stopped.
    The difference between the Backgrounded and Stopped states is that the activity
    is in the Stopped state when it is being prepared for destruction and it will
    be followed by the `OnDestroy` method since the application is dismissed and will
    not be used by the user anymore. If the user resumes the application, the activity
    will call the `OnRestart` method and a full creation process will follow.
  prefs: []
  type: TYPE_NORMAL
- en: Stopped
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Stopped state represents the end of the lifecycle for the activity. The
    activity enters this state when the user presses the back button signifying that
    the application is not needed anymore. However, it is also possible that the activity
    is taken into this state because the system is starved of memory resources and
    it needs to take down activities that are on the lower priority states like paused
    or backgrounded.
  prefs: []
  type: TYPE_NORMAL
- en: The `OnDestroy` method follows the Stopped state and it is the last lifecycle
    event method that is called. It is the last chance for the application to stop
    long running processes that might cause leaks or clean up other persistent resources.
    It is advisable to implement most of the resource clean up in `OnPause` and `OnStop`
    methods, since `OnDestroy` can be called unexpectedly by the system contrary to
    the user initiated `OnPause` and `OnStop` methods.
  prefs: []
  type: TYPE_NORMAL
- en: Restarted
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: An activity is said to be "restarted" when it comes back to user interaction
    after it was backgrounded. Restarted activities can reload any saved state information
    and create an uninterrupted user experience. After going through the initialization
    steps, the application goes into the Running state again.
  prefs: []
  type: TYPE_NORMAL
- en: Application lifecycle (iOS)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: On iOS, the application lifecycle is handled through UI application delegates.
    Once the delegate methods are implemented and registered, the methods will be
    invoked by the execution context.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Application events on iOS are a little more complicated than the top-down execution
    of events on Android. Developers can insert their methods into transitive states
    using the state-related methods implemented in the `AppDelegate`.
  prefs: []
  type: TYPE_NORMAL
- en: '![Application lifecycle (iOS)](img/B04693_02_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 1: iOS Application State Transitions'
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important state-related methods are the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '`WillFinishLaunching` is the first chance of the application to execute code
    at launch time. It indicates the application has started to launch but the state
    has not yet been restored.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`FinishedLaunching` is called once the state restoration occurs after the `WillFinishLaunching`
    is completed.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OnActivated` and `OnResignActivation` are similar to `OnPause` and `OnResume`
    event methods on the Android platform.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DidEnterBackground` is called when the application enters the Backgrounded
    state. It is similar to the `OnStop` method on Android but there is a time constriction
    on this method; the method should execute in less than 5 seconds, and the method
    exits without notification after the allocated time. If more time is needed to
    execute certain methods in this delegate, applications can start a background
    task to complete the execution.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`WillEnterForeground` and `WillTerminate` can follow the `DidEnterBackground`
    execution. If the former method is called, the application is about to be brought
    back to foreground and active state, otherwise, the application is prepared to
    be terminated because the system needs more memory, or the user is closing a backgrounded
    application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Garbage collection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**Garbage collection** (**GC**) is one of the most effective automated memory
    management techniques on modern application development platforms. In simple terms,
    with automated garbage collection, memory resources are allocated for objects
    used by the application and reclaimed for resources no longer needed by the application.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: In spite of the fact that garbage collection, as an automated process, takes
    over the burden of managing memory allocations, it can have a significant impact
    on performance. This performance handicap is one of the main reasons why there
    is no garbage collection mechanism on the iOS platform.
  prefs: []
  type: TYPE_NORMAL
- en: In theory, GC is responsible for reclaiming memory resources occupied by runtime
    elements that cannot be reached by the current executing application. However,
    this mechanism cannot always identify these unreachable resources correctly and/or
    have unexpected results while purging the identified memory pointers.
  prefs: []
  type: TYPE_NORMAL
- en: Memory leaks occur when an application fails to identify and/or free the resources
    occupied by unreachable code elements, which can lead to memory exhaustion problems.
  prefs: []
  type: TYPE_NORMAL
- en: Dangling pointers happen when a memory region is freed while references still
    exist in the execution context. These references are then removed and memory can
    be re-allocated for another use.
  prefs: []
  type: TYPE_NORMAL
- en: Double free bugs occur when a memory region is already reclaimed and the application
    or garbage collector tries to free this region once more.
  prefs: []
  type: TYPE_NORMAL
- en: GC on Xamarin projects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Managed code, as defined by the Common Language Runtime in the .NET framework,
    is application code where the memory resources are managed by the native garbage
    collector. GC, on initialization, allocates a segment of the memory to store and
    manage memory resources, which is called the "managed heap". The garbage collection
    in CLR happens on three different generations where objects with different lifespans
    live in the heap. Promotion between the generation and survival of objects depend
    on which generation they are placed in and how they survived prior GC cycles.
  prefs: []
  type: TYPE_NORMAL
- en: SGen garbage collector
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: SGen garbage collector is the generational garbage collector used in most Xamarin
    projects (both Xamarin.iOS and Xamarin.Android). SGen performs more frequent garbage
    collections over smaller sets of objects which makes it more efficient over the
    conservative Boehm GC.
  prefs: []
  type: TYPE_NORMAL
- en: SGen utilizes three heaps, namely The Nursery, Major Heap, and Large Object
    Space, to allocate memory segments for objects according to their memory requirements,
    and objects are promoted between the heaps when they survive through GC cycles.
    In this setup, The Nursery, similar to Generation 0 in CLR on .NET, is where most
    objects are created and destroyed and most of the GC cycles occur to release memory
    resources. Objects surviving the minor GC cycles can be promoted to the major
    heap. The major heap only has major GC passes in case the heap itself is running
    out of memory. The last heap is only for larger objects that have higher memory
    requirements, and does not accept promotion from other heaps.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is important to remember that during a garbage collection cycle all the threads
    registered with the runtime, including the main run loop thread are paused. One
    exception to this execution pause is the separate process that continues to run
    the iOS animations.
  prefs: []
  type: TYPE_NORMAL
- en: Boehm garbage collector (iOS only)
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Boehm GC (aka Boehm-Demers-Weiser garbage collector) is an open-source garbage
    collector implementation that was initially created for C/C++ language implementations.
    As a conservative garbage collector, it still has procedures for leak detection,
    supports "finalized" semantics, and has limited support for generational implementations
    which makes it an attractive candidate for implementations and ports on various
    platforms.
  prefs: []
  type: TYPE_NORMAL
- en: An implementation of Boehm GC is only available for Xamarin.iOS applications
    using the Classic API, in which it is the default garbage collector.
  prefs: []
  type: TYPE_NORMAL
- en: Platform-specific concepts
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to understand the memory management techniques and pitfalls, one must
    understand some platform-related concepts. Even though Xamarin provides an almost
    platform agnostic development experience, iOS and Android platforms deal with
    memory allocations and references slightly differently from .NET CLR and each
    other.
  prefs: []
  type: TYPE_NORMAL
- en: Object reference types
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Referred objects can be classified according to application needs. This classification
    helps the garbage collector decide whether the memory allocation can be released
    for the referred objects.
  prefs: []
  type: TYPE_NORMAL
- en: A strong reference protects the object from being "garbage collected". A referred
    object is said to be strongly referenced/reachable when the class instance is
    directly used by the current execution context.
  prefs: []
  type: TYPE_NORMAL
- en: 'Weak references can be used for class instances when the need for the reference
    does not interfere with garbage collection. When the referred object is weakly
    reachable, the dependent section of code has to check whether the object is still
    alive before using the referenced object. Weak references have two types in CLR
    according to the dispose and finalization processes implemented by the declaring
    types: long and short weak references. Long weak references are types that can
    live on to be recreated and can be finalized by a destructor rather than being
    disposed or garbage collected.'
  prefs: []
  type: TYPE_NORMAL
- en: Soft and phantom references are specific to Android runtime. Soft references,
    in simple terms, are a little more persistent than the weak references, and would
    only be cleared up by the garbage collector under memory pressure even though
    the object is no longer strongly reachable. Phantom references are the weakest
    reference in Android runtime. They are only used to implement specialized object
    finalization methods and have to be associated with a reference queue for processing.
  prefs: []
  type: TYPE_NORMAL
- en: Automatic Reference Counting (ARC)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Automatic Reference Counting is a compiler feature that was introduced in iOS
    5\. It is referred to as a compiler feature since it cannot be classified as a
    garbage collection implementation. It is a static analysis implementation where
    the compiler analyses the code execution tree and inserts retain and release messages
    according to the object persistence requirements.
  prefs: []
  type: TYPE_NORMAL
- en: With ARC, traditional memory management calls are not allowed to be inserted
    in the application to allocate memory and release memory addresses.
  prefs: []
  type: TYPE_NORMAL
- en: Troubleshooting and diagnosis
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Profiling is the term used to describe the dynamic system analysis while the
    target application is running. Profilers generally collect data about metrics
    such as CPU utilization, framerate values, and most importantly data about memory
    allocations. Especially with Xamarin projects, since we are dealing with multiple
    platforms, profiling becomes an important part of testing and diagnostics.
  prefs: []
  type: TYPE_NORMAL
- en: There are numerous tools that one can use to profile memory usage on Xamarin
    projects, Xamarin Profiler being the only one that can be used both for Xamarin.iOS
    and Xamarin.Android applications.
  prefs: []
  type: TYPE_NORMAL
- en: Xamarin Profiler
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Xamarin Profiler is the newest addition to the Xamarin Suite. This profiler
    has the advantage over other platform-specific applications since it can be run
    either on OS X or Windows targeting Xamarin.Android or Xamarin.iOS applications.
  prefs: []
  type: TYPE_NORMAL
- en: '![Xamarin Profiler](img/B04693_02_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 2: Xamarin Profiler'
  prefs: []
  type: TYPE_NORMAL
- en: It was designed to give developers almost real time (depending on the sampling
    rate) information about the memory heaps for Xamarin applications. It can also
    save memory allocation snapshots which can later on be accessed and analyzed.
  prefs: []
  type: TYPE_NORMAL
- en: It can be started directly from Visual Studio or Xamarin Studio and can be used
    with both emulator and real device build/run configurations.
  prefs: []
  type: TYPE_NORMAL
- en: Currently there are two instruments you can select in the initial popup window.
  prefs: []
  type: TYPE_NORMAL
- en: Allocations instrument
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The first instrument is the Allocations template which provides detailed information
    on the memory segments and allocations. In this view, developers can see a generalized
    list of allocations grouped by the class name under the **Summary** tab. The **Call
    Tree** tab gives a list of threads in the application and how they relate to the
    memory objects. Allocation list provides live data about the object allocations,
    and the **Snapshots** tab gives information about the memory snapshots stored.
  prefs: []
  type: TYPE_NORMAL
- en: Time Profiler
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Time Profiler is the second instrument that can be used in Xamarin Profiler.
    It provides valuable information on how much time the application spent executing
    a certain method. Developers can see a whole stack trace on each method.
  prefs: []
  type: TYPE_NORMAL
- en: Device Monitor (Android only)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Android Device Monitor is hitherto the main diagnostic tool for Android development.
    And for Xamarin developers, when Android SDK is installed, device monitor can
    be accessed directly from a tool box item on Visual Studio and under the tools
    menu on Xamarin Studio.
  prefs: []
  type: TYPE_NORMAL
- en: On the main page of the device monitor there is a tree-view displaying each
    device or simulator that can be attached to with the device monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Only a single debugger can be attached to any device at a time, therefore other
    debuggers have to be detached before using the device monitor.
  prefs: []
  type: TYPE_NORMAL
- en: Once the device is selected, developers can get allocation information and the
    heap state using the graphical interface. It is also possible to trigger garbage
    collection cycles using the device monitor.
  prefs: []
  type: TYPE_NORMAL
- en: '![Device Monitor (Android only)](img/B04693_02_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 3: Android Device Monitor attached to Visual Studio Emulator'
  prefs: []
  type: TYPE_NORMAL
- en: Instruments (iOS only)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Instruments is a valuable application that is installed together with the Xcode
    toolset. In this application developers are provided with a big set of diagnostic
    tools varying from energy consumption, graphic resources, to memory allocations.
  prefs: []
  type: TYPE_NORMAL
- en: The allocations instrument has a very similar interface to Xamarin Profiler,
    and gives almost real-time data about memory objects.
  prefs: []
  type: TYPE_NORMAL
- en: '![Instruments (iOS only)](img/B04693_02_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4: Instruments Profiling Xamarin Application'
  prefs: []
  type: TYPE_NORMAL
- en: The Xcode Instruments tool can be used both together with an actual device or
    the iOS simulator. It can be started directly from Xamarin Studio. Once the application
    is started on the iOS simulator or on the actual device, it becomes available
    in the target selection window.
  prefs: []
  type: TYPE_NORMAL
- en: '![Instruments (iOS only)](img/B04693_02_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 5: Instruments with iOS Simulator set as target'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If you are developing Xamarin.iOS applications on Microsoft Windows with an
    OS X build machine, you will not be able to access the Instruments directly from
    the development station. Once the application is either on the test device or
    the simulator, you can start the instruments on the build machine and choose the
    correct target to analyze.
  prefs: []
  type: TYPE_NORMAL
- en: Monotouch Profiler (iOS only)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Monotouch Profiler was the Xamarin tool used to diagnose memory issues with
    Xamarin.iOS applications before it was superseded by Xamarin Profiler. It can
    still be accessed using the **Run with Mono HeapShot** menu item under the **Project**
    menu in Xamarin Studio. While providing useful information about memory allocations
    and the heap, it currently does not go further than being a lightweight application
    to take memory snapshots.
  prefs: []
  type: TYPE_NORMAL
- en: Patterns and best practices
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: While dealing with managed runtime and garbage collection, there are certain
    patterns and anti-patterns developers must be careful with. If not handled properly,
    both managed and native objects can produce noncollectable traces, which in turn
    can cause memory leaks and unnecessary resource consumption.
  prefs: []
  type: TYPE_NORMAL
- en: Disposable objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The resources managed by the garbage collector are generally limited to memory
    allocations. Other resources like network sockets, database handles, UI elements,
    and file/device descriptors need to have additional definitions or mechanisms.
  prefs: []
  type: TYPE_NORMAL
- en: In managed runtime, these object resources can be cleaned up in two different
    ways. The first, less efficient, unpredictable way is to implement a destructor/finalizer.
    With a finalizer implementation, once the garbage collector decides the object
    is no longer strongly reachable, the resources such as network sockets can be
    disposed. However, finalizable objects have to wait for the following GC cycle
    to be cleaned up and cannot be finalized with developers' initiatives.
  prefs: []
  type: TYPE_NORMAL
- en: Another way to clean-up application resources is to implement the `IDisposable`
    interface in the class that has the references to the resources. This interface
    requires only a single `Dispose` method implementation to get rid of managed resources.
    The garbage collector also offers a method (`GC.SuppressFinalize`) to avoid finalization
    since the object is going to be disposed using the `IDisposable` interface.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: The fact that disposable objects can be used together with `using` blocks, gives
    a deterministic way for developers to release associated resources as soon as
    the object is no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: The lapsed listener problem
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: One of the most common patterns used with UI elements or legacy API implementations
    is the observer pattern. As you might know, there are two stakeholders in this
    pattern, the observer and provider. The observer subscribes to the event provided
    by the provider to receive updates.
  prefs: []
  type: TYPE_NORMAL
- en: The lapsed listener problem occurs when the observer pattern is implemented
    incorrectly or better yet incompletely. In this pattern, after the subscription,
    the provider keeps a strong reference to the observer. If this subscription is
    not removed before the subscriber goes out of context, the application will leak
    the subscriber object since it cannot be garbage collected (for example, an Android
    activity, or a view model).
  prefs: []
  type: TYPE_NORMAL
- en: In order to demonstrate this problem, we will use a singleton implementation
    of Fibonacci sequence with asynchronous methods as the event provider.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: We will implement two separate view models using MvvmCross and use associated
    views to invoke the asynchronous methods, then navigate back to the main view
    using the `Close` method on the view models. In the constructor of each view model,
    we will be subscribing to the respective event on the `FibonacciSource`.
  prefs: []
  type: TYPE_NORMAL
- en: '![The lapsed listener problem](img/B04693_02_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 6: Fibonacci Calculator App'
  prefs: []
  type: TYPE_NORMAL
- en: In order to investigate any memory leaks, we navigate back and forth between
    the main and the calculation views. After a couple of iterations on both of the
    views (that is, single and range), we have the results shown below on the Xamarin
    Profiler (just using the "Allocations" template.)
  prefs: []
  type: TYPE_NORMAL
- en: '![The lapsed listener problem](img/B04693_02_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 7: Xamarin Profiler Results'
  prefs: []
  type: TYPE_NORMAL
- en: You will notice that none of the instances of `SingleCalculationViewModel` are
    alive after garbage collection (you can trigger a GC run with `GC.Collect()`),
    however `RangeCalculationViewModel` instances are persistent. The reason for this
    is the missing unsubscribe call in the close command of the `RangeCalculationViewModel`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: We could have also used the `OnPause` event on this Android application or any
    other relevant event on other platforms to get rid of the subscription before
    the subscriber or the view component that holds the subscriber goes out of context.
  prefs: []
  type: TYPE_NORMAL
- en: In this scenario, another solution would be to use a `TaskCompletionSource`
    to convert the observable pattern to an awaitable one. Wrapping up the observable
    Fibonacci source would give you a better control over the subscription and the
    resulting asynchronous task would be better suited for mobile development and
    MVVM pattern.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Finally, this async task would be called with a `ContinueWith` statement to
    set the result in the view model.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Weak references
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Weak references can be of great assistance while dealing with loosely coupled
    application layers. In these type of scenarios, where objects need to be managed
    outside the class domain, weak referencing can be used to remove these instances
    from the GC protection based on the notion of reachability because of the strong
    references they have to other layers of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Let us assume in the previous example that the Fibonacci sequence items are
    handled as reference values with a class called `FibonacciItem`. This class carries
    the value calculated and the time it was calculated.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: To decrease the processing time, we can now implement a caching mechanism which
    would force the source to recalculate the value according to the ordinal if it
    does not already exist in the cache or just does not sound right is disposed of
    in favor of memory resources. For this purpose we can use the `WeakReference`
    to cache Fibonacci items.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: Cross-domain objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: In Xamarin applications, one of the most common memory issues, cross-heap references,
    occur when there is a cross-over between the native runtime and mono runtime.
    This issue stems from the fact that mono runtime is almost handled as a separate
    domain and managed in a heap only with GC handles to the native domain.
  prefs: []
  type: TYPE_NORMAL
- en: In an Android scenario, where Java objects are referenced by managed C# objects
    or vice versa, the communication between the two runtimes becomes expensive. For
    instance, if we were implementing the Fibonacci calculator without using the ViewModel
    pattern, we would want to create a data adaptor to load the range calculation
    results into a list view.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: This implementation has a higher cost of being garbage collected. It also has
    performance penalties considering the language crossing, not to mention the fact
    that objects from each world are effectively mirrored increasing the memory allocation
    costs.
  prefs: []
  type: TYPE_NORMAL
- en: The solution here would be to do as much work as possible in the managed world
    and let the runtime take care of the rest. So instead of using the native `ArrayAdapter`,
    we could implement a base adapter that would feed the `FibonacciItem` instances
    to the `ListView`.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: By implementing the adapter we removed the usage of Java type `ArrayAdapter`,
    `ArrayList` and the Java references to the `FibonacciItem` instances.
  prefs: []
  type: TYPE_NORMAL
- en: The same applies to scenarios where native objects are being inherited in the
    managed domain. These, so-called, "special objects" are handled differently by
    the garbage collector. They have to be rescanned for all the references they carry
    with each garbage collection cycle.
  prefs: []
  type: TYPE_NORMAL
- en: Cyclic references (cycles)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Cyclic references occur, in general terms, when the underlying platform uses
    some type of reference counting as memory management strategy and the memory is
    cleaned up according to the number of references to that specific object instance.
  prefs: []
  type: TYPE_NORMAL
- en: Reference counting was abandoned by Microsoft with the release of .NET and the
    introduction of the generational tracing garbage collection. SGen in mono runtime
    on Android devices also uses some form of a mark and sweep algorithm. In both
    runtimes, the references are traced from so called "application roots". These
    objects are the ones that are "presumed" to be alive at the time of a garbage
    collection cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'The roots can be:'
  prefs: []
  type: TYPE_NORMAL
- en: References to global objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References to static objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References to static fields
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References on the stack to local objects
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References to objects waiting to be finalized
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: References in CPU registers to objects on the managed heap
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: However, as mentioned before, on iOS, garbage collection was abandoned in favor
    of performance and yet ARC (automatic reference counting) fails to deal with what
    is called a retain cycle. Retain cycle occurs when the lower elements (aka children)
    in the creation hierarchy require references to the parent items. In this scenario,
    when the child or the parent sends a `release`, the `dealloc` methods never get
    to run since there is an extra reference keeping each of the items alive.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cyclic references (cycles)](img/B04693_02_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 8: Retain Cycle'
  prefs: []
  type: TYPE_NORMAL
- en: This native iOS problem becomes a problem in Xamarin applications when managed
    objects derive from native objects (that is, any object deriving from `NSObect`)
    such as UI controls. When managed classes are inheriting from native objects,
    in order to keep them from getting garbage collected, Xamarin.iOS creates a GCHandle.
    These GCHandles, together with the managed references between the objects, create
    the described (indirect) retain cycle.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we were dealing with a parent `UIView` that holds an array of children and
    the child view objects that were retaining a reference to the parent object:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The following piece of code would create a retain cycle and would cause memory
    leaks in the application:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: If we were to execute this code in the constructor of a view, every time the
    application navigates to this view, we would be creating a new parent object,
    never to be garbage collected.
  prefs: []
  type: TYPE_NORMAL
- en: '![Cyclic references (cycles)](img/B04693_02_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 9: Instruments view for retained objects'
  prefs: []
  type: TYPE_NORMAL
- en: In this case, the easiest fix would be to use a `WeakReference` while we are
    creating a reference to the parent object from the child one. Using the weak reference
    avoids the retain cycle situations and does not interfere with the garbage collection.
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Another option would be to implement `IDisposable` interface to remove the strong
    link between the objects by setting the references to null before GC.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In order to manage application resources, one must have a deeper understanding
    of the application lifecycle. Application lifecycle events, outlined in this chapter,
    are the main access points to underlying platform runtime on both iOS and Android.
    If used properly, the event delegates and event methods on both platforms can
    help developers save valuable resources and avoid memory problems.
  prefs: []
  type: TYPE_NORMAL
- en: Other concepts discussed were garbage collection, object references, and automatic
    reference counting. These concepts make up the foundation of memory management
    on target Xamarin platforms.
  prefs: []
  type: TYPE_NORMAL
- en: We also had a closer look at the diagnostic and profiling tools for target platforms
    and how they can be used effectively. While iOS and Android platforms each have
    a native app to analyze memory allocations, Xamarin Profiler provides a unified
    solution for both platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, useful patterns were outlined for different memory related issues and
    pitfalls. To analyze these patterns, Xamarin Profiler and Instruments were used
    for Android and iOS applications respectively.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will be looking at asynchronous implementation techniques
    and investigate various patterns of multi-threading and background execution.
  prefs: []
  type: TYPE_NORMAL
