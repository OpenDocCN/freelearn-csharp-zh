- en: '3'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Completing the Collection Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 2*](B18347_02.xhtml#_idTextAnchor041), you were introduced to level
    design, adding different 2D assets, using assets with Tilemap to create a game
    environment, and creating scripts using the C# language and the **Visual Studio**
    (**VS**) IDE to add movement to the player character.
  prefs: []
  type: TYPE_NORMAL
- en: With the player moving around the environment, we’ll want a way to follow them
    visually around the level. This chapter will use Unity’s camera system called
    **Cinemachine** (**CM**) – a powerful camera control feature that makes polished
    camera movement easy to add and set up.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll finish the chapter with an introduction to adding a **user interface**
    (**UI**). You’ll learn how to add text to the screen to track gameplay progress
    with a timer and score. We’ll use Unity’s UI system, commonly called **uGUI**,
    to accomplish this task.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using CM to follow the Player and playtesting
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Game mechanics and how to create with code (components)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to uGUI, the timer, counting, and winning
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you’ll be able to code game mechanics with C# scripts
    by adding functionality to GameObjects and be comfortable with adding essential
    UI to your game.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You can download the complete project on GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  prefs: []
  type: TYPE_NORMAL
- en: Using CM to follow the Player and playtesting
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**CM** is expansive in its features – no wonder it’s an Emmy award-winning
    suite of codeless camera tools – but we’re only going to focus on one function:
    the ability to have a camera follow our ladybug around the 2D environment.'
  prefs: []
  type: TYPE_NORMAL
- en: First, we’ll need to ensure we have the CM package installed by going to **Windows**
    | **Package Manager**, selecting **Cinemachine**, and clicking the **Install**
    button. CM won’t help us much without a Player to follow around, so let’s get
    the Player we designed in the previous chapter and import it into our level scene.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a Player Prefab
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Unity’s **Prefab** system allows you to store configured GameObjects as reusable
    assets (files) in your project – complete with all its components, assigned values,
    and any child GameObjects. You can even have Prefabs as children of another Prefab;
    in this case, we call them **nested Prefabs**.
  prefs: []
  type: TYPE_NORMAL
- en: Additionally, new Prefab assets can be derived from an original Prefab as a
    **Prefab Variant** (the same base properties but unique variations – when the
    base Prefab is modified, so are all its derived variants).
  prefs: []
  type: TYPE_NORMAL
- en: One of the powers of Prefabs is the ability to spawn new instances of them into
    your scene at runtime (think swarms of enemy **non-player characters** (**NPCs**),
    projectiles, pick-up items, repeating parts of an environment, and so on).
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Prefabs**: [https://docs.unity3d.com/2022.3/Documentation/Manual/Prefabs.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Prefabs.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to create a Prefab of our player character:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the scene you previously saved with your player character design.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a `Prefabs` folder at `Assets/Prefabs` and make it the current folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click and drag the `Assets/Prefabs` folder. In *Figure 3**.1*, you can see our
    freshly created ladybug Player Prefab asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, go back to your game level scene and click and drag the `0`, `0`, `0`)
    in the scene).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You may not be able to see the player character in the scene View because we
    have not assigned any Sorting Layer for its sprites. Rather than assigning the
    Sorting Layer to all the sprites individually, we can simply use the `sorting`
    in the `1000`, to ensure that the player will always draw as the top-most sprite
    if we add any additional sprites to this Sorting Layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.1 – The Ladybug Player Prefab](img/B18347_03_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.1 – The Ladybug Player Prefab
  prefs: []
  type: TYPE_NORMAL
- en: Tip | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: To apply changes to a Prefab in the **Scene Hierarchy** – while the Prefab is
    not open in **Prefab Mode** (an isolated environment for directly editing the
    Prefab) – use the **Review**, **Revert**, or **Apply Override** drop-down at the
    top of the **Inspector** (simply shown as **Overrides**). Alternatively, the quickest
    way to enter **Prefab Mode** is by double-clicking on a Prefab in the Project
    window.
  prefs: []
  type: TYPE_NORMAL
- en: '*Editing a Prefab in Prefab Mode* | *Editing in* *Isolation*: [https://docs.unity3d.com/2022.3/Documentation/Manual/EditingInPrefabMode.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/EditingInPrefabMode.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a 2D follow camera
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'With CM, it’s trivial to create a follow camera for a 2D environment. Now that
    we have our player in the scene, we can add a CM camera that will follow the player
    around as it moves with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new CM **virtual camera** (**vcam**) from the **Hierarchy** window’s
    **Create** menu or the main **File** menu by going to **GameObject** | **Cinemachine**
    | **2D Camera** – for the first vcam added to the scene, this also adds a **Cinemachine
    Brain** component to **Main Camera** (CM controls **Main Camera** through one
    or many vcams).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With the new vcam selected, drag the **Player** object from the **Hierarchy**
    to the **Follow** field in the **CinemachineVirtualCamera** component (to assign
    its reference), as seen in the following screenshot:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.2 – The CM Follow Player Inspector assignment](img/B18347_03_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.2 – The CM Follow Player Inspector assignment
  prefs: []
  type: TYPE_NORMAL
- en: Within the **Body** section, expand the arrow to the left of **Body** if necessary;
    you can adjust XY damping, screen position, dead zones, and so on. Play around
    with these settings and fine-tune your camera to follow your preferences.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Cinemachine**: [https://docs.unity3d.com/Packages/com.unity.cinemachine%402.3/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.cinemachine%402.3/manual/index.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Cinemachine** **feature**: [https://unity.com/unity/features/editor/art-and-design/cinemachine](https://unity.com/unity/features/editor/art-and-design/cinemachine)'
  prefs: []
  type: TYPE_NORMAL
- en: '*Cinemachine for 2D Tips and* *Tricks*: [https://blog.unity.com/technology/cinemachine-for-2d-tips-and-tricks](https://blog.unity.com/technology/cinemachine-for-2d-tips-and-tricks)'
  prefs: []
  type: TYPE_NORMAL
- en: We can now explore the entire environment knowing that the camera will follow
    us around. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: Playtesting the level
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The last step to make our level playable is to add the necessary components
    (that is, **PlayerController** and physics), adjust the component values, and
    assign the component references.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s do this now with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Player** Prefab in **Prefab Mode** by selecting it in the **Hierarchy**
    or selecting the **Prefab** asset in the **Project** window, and then click **Open**
    at the top of the **Inspector**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `collider`, and selecting it in the results – this will provide physics
    interactions with other colliders in the environment via Unity’s built-in 2D physics
    engine (Box2D).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Adjust the collider to fit the graphics for your player using both the **Offset**
    and **Size** fields, then use the **Edit Collider** button to move it manually
    into position in the scene View.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add a `rigidbody`, and selecting it in the results – this will provide the physics
    properties to our player character, such as how it’s affected by gravity, its
    mass, drag, position/rotation constraints, and the type of `100`) and `1`) to
    refine the player movement (adjust to your preferences).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Most importantly, disable `0` – in a top-down environment, everything is already
    *sitting on the ground*, so we don’t assign any gravity (if we did, the object
    would fall toward the bottom of the screen since gravity is based on the *y* axis;
    this works well for a 2D side-on game view).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the **PlayerController** script by using the **Add Component** button in
    the **Inspector** or dragging the script from the **Project** window onto **Player**
    in the **Hierarchy** window or, with the **Player** object already selected, into
    the **Inspector**.*   Assign the `PlayerController` script uses.![Figure 3.3 –
    The Player Prefab components configuration](img/B18347_03_03.jpg)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figure 3.3 – The Player Prefab components configuration
  prefs: []
  type: TYPE_NORMAL
- en: That’s it! We can now press the **Play** button on the main toolbar to playtest
    our level design.
  prefs: []
  type: TYPE_NORMAL
- en: The ladybug will rotate to face the mouse pointer’s position and move in the
    direction it’s facing while the spacebar is being held down. Tiles on the **Tilemap**
    with **TilemapCollider2D** assigned will prevent the player from moving into those
    areas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now is an excellent time to adjust the values on the `PlayerController`. Here,
    you can see the default values we started with:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.4 – The PlayerController Inspector field values](img/B18347_03_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.4 – The PlayerController Inspector field values
  prefs: []
  type: TYPE_NORMAL
- en: Making these adjustments affects the game feel and the overall player experience,
    so spend time fine-tuning these values until it just *feels right* to you as the
    game designer. Have fun!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: 'When you find values that you like and want to quickly go back and forth between
    them during testing (without having to write them on a scratch pad somewhere),
    you can use **Presets** (the *slider icon* on the right side of the **Component**
    title bar): [https://docs.unity3d.com/2022.3/Documentation/Manual/Presets.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Presets.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, you learned how to read input directly from an input device
    to move the player character with a custom C# script while using physics, you
    explored the timesaving and powerful features adding a CM vcam provides, and you
    understood that playtesting is about refining values to get the right game feel
    for a good player experience.
  prefs: []
  type: TYPE_NORMAL
- en: Bonus activity
  prefs: []
  type: TYPE_NORMAL
- en: Make the ladybug player character move while also holding down the left mouse
    button.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll implement some interactions for the player by coding
    collecting pickups.
  prefs: []
  type: TYPE_NORMAL
- en: Game mechanics and how to create with code (components)
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This section will explore the concept of game mechanics and what that means
    for the gameplay in the *Outer World* collection game we’re making. We’ll define
    precisely the mechanic we’ll be using in a brief expansion on the **Game Design
    Document** (**GDD**) and finish with writing the code for the mechanic by adding
    a new Prefab with a custom component that uses a 2D physics interaction event.
  prefs: []
  type: TYPE_NORMAL
- en: What is a game mechanic?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A **game mechanic** can loosely be defined as the rules that dictate the gameplay
    and how the player is supposed to engage with the mechanics sufficiently to provide
    a joyful and entertaining experience. Examples of some popular types of gameplay
    mechanics include collecting, moving, shooting, and building things.
  prefs: []
  type: TYPE_NORMAL
- en: Some game mechanic rules that dictate gameplay are followed by the game and
    not the player, such as the game only unlocking a new level when the player completes
    the current level.
  prefs: []
  type: TYPE_NORMAL
- en: Buff & Nerf | game balance
  prefs: []
  type: TYPE_NORMAL
- en: 'Changing elements of mechanics to a player’s advantage is known as the **Buff**
    and to their disadvantage is the **Nerf**, keeping the game balanced: [https://www.inverse.com/gaming/nerf-buff-meaning-video-games-coined-series](https://www.inverse.com/gaming/nerf-buff-meaning-video-games-coined-series)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s explore adding our game’s primary mechanic now.
  prefs: []
  type: TYPE_NORMAL
- en: Adding to our GDD
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The game mechanic we’re going to add to our GDD and implement is the collection
    of pickup items in the environment. We can describe it as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** **of Game** | Outer World |'
  prefs: []
  type: TYPE_TB
- en: '| **What is the core game mechanic for the** **collection game?** | The player
    will find and collect “water diamonds” throughout the environment by touching
    them until all are collected, or the countdown timer expires. |'
  prefs: []
  type: TYPE_TB
- en: Table 3.1 – The GDD game mechanic addition
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Game mechanics
  prefs: []
  type: TYPE_NORMAL
- en: 'Will Wright (*The Sims* creator), *5 Tips for Writing Game* *Mechanics*: [https://www.masterclass.com/articles/will-wrights-tips-for-writing-game-mechanics#will-wrights-5-tips-for-writing-game-mechanics](https://www.masterclass.com/articles/will-wrights-tips-for-writing-game-mechanics#will-wrights-5-tips-for-writing-game-mechanics)'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our core game mechanic defined, let’s put the code together
    to make it work!
  prefs: []
  type: TYPE_NORMAL
- en: Bonus activity
  prefs: []
  type: TYPE_NORMAL
- en: By exploring the idea of adding additional physics-based objects to our level,
    design a game mechanic that involves the player pushing around tile blocks that
    we’ll call *toolboxes*. The toolboxes could inconvenience the player and slow
    them down in pursuit of collecting the *water diamonds* or provide additional
    gameplay by requiring them to be moved into specific locations.
  prefs: []
  type: TYPE_NORMAL
- en: Collecting pickups
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A lot of the basics for working within Unity and creating component-based scripts
    have been covered by this point, so we’re going to be moving a bit faster in putting
    things together – while not spending as much time explaining the small details.
  prefs: []
  type: TYPE_NORMAL
- en: The primary objective of our core mechanic is collecting objects. We’ll accomplish
    this by taking advantage of the interaction events the 2D physics engine provides.
    Here we go!
  prefs: []
  type: TYPE_NORMAL
- en: Creating a collectible item Prefab
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'First, we need a sprite for our collected object – the *water diamond*. You
    can either create your sprite art within Unity (as we did with the ladybug character)
    or import one (the suggested size is a 64 px square). Create a new Prefab for
    the collection object with the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Add your *water diamond* sprite to the scene.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Parent the **Graphics** object’s sprite to an empty GameObject (container).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the parent GameObject, add a primitive collider that best fits the shape
    of your *water diamond* sprite – I chose **CapsuleCollider2D**, as seen in *Figure
    3**.5*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Enable the **IsTrigger** field on the **CapsuleCollider2D** component since
    we don’t want any collision interactions to occur between the diamond and the
    Player; we just want to receive a message for the interaction event.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: The simple takeaway here is that when **IsTrigger** is enabled, no physical
    collisions between objects will occur – objects won’t move in response to forces
    applied.
  prefs: []
  type: TYPE_NORMAL
- en: '**Collider.isTrigger**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Collider-isTrigger.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Collider-isTrigger.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s not forget to ensure the sprite is drawn at the correct depth in our `Sprite
    Renderer`’s `100`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If you created your sprite within Unity using the Sprite Creator tool’s shapes,
    select the **Graphics** parent object and add a **Sorting Group** component to
    assign the Sorting Layer.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the root object the sprite was parented to into the `Assets/Prefabs` folder
    in the **Project** window.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Tip | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: Objects in the **Hierarchy** window turn blue and have the right caret (arrow)
    to their right when the GameObject is made into a Prefab. Clicking the caret will
    take you into **Prefab Mode** in the context of the scene (as shown in *Figure
    3**.5*).
  prefs: []
  type: TYPE_NORMAL
- en: '*Editing a Prefab in Prefab Mode* | *Editing in* *context*: [https://docs.unity3d.com/2022.3/Documentation/Manual/EditingInPrefabMode.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/EditingInPrefabMode.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can verify your collectible **Water Diamond** Prefab setup with the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.5 – Water Diamond Prefab with collider](img/B18347_03_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.5 – Water Diamond Prefab with collider
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Collider** **2D**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/CapsuleCollider2D.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/CapsuleCollider2D.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Optimizing Physics** **Performance**: [https://docs.unity3d.com/2022.3/Documentation/Manual/iphone-Optimizing-Physics.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/iphone-Optimizing-Physics.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Note that the performance order of 2D colliders, from the fastest to slowest,
    is: **Circle**, **Capsule**, **Box**, **Composite**, **Polygon**, and then **Edge**.'
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we have our Prefab for the collectible item’s sprite; now, let’s code
    the interaction.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the CollectItem component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Create a new script in the `Scripts` folder and name it `CollectItem`. Replace
    the generated code with the following template:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have a look at the code line by line:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Debug.Log()` line in `Start()` will just output a message to our `Start()`
    method was called on. We can use this to verify that all of the collectible item
    objects we’ll add to the scene are *registering* themselves. We’ll be using this
    to increment the count for total items needing to be collected in the level (the
    10 in *0 of 10*) when we add our UI in the next section.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: $ string interpolation | C#
  prefs: []
  type: TYPE_NORMAL
- en: The dollar sign (**$**) in **Debug.Log($"{gameObject.name}'s Start called");**
    is for identifying an interpolated string. The text within **{}** (open/close
    squiggly brackets) in the string literal (represented by two double quotes (**""**))
    is a string result of the inserted code (usually a variable or expression).
  prefs: []
  type: TYPE_NORMAL
- en: 'Refer to the C# language reference for additional reading: [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/tokens/interpolated)'
  prefs: []
  type: TYPE_NORMAL
- en: Because we’ve added a second parameter to the `Debug.Log()` call (`gameObject`),
    when the `gameObject` (camelCase) keyword refers to the current GameObject (PascalCase)
    the component is running on (also provided by the `MonoBehaviour` base class).
  prefs: []
  type: TYPE_NORMAL
- en: Optimization note | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: Note that you’ll want to comment out **Debug.Log()** statements for performance
    reasons once you’ve finished testing and they are no longer needed.
  prefs: []
  type: TYPE_NORMAL
- en: '**Debug**: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-Debug.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-Debug.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '`OnTriggerEnter2D(Collider2D collision)` is where the magic happens. This Unity
    message is called when a collision occurs between two physics objects where one
    of the objects has a collider `IsTrigger` value enabled. We receive a reference
    to the other object’s collider with the collision parameter value (we’ll be using
    `collision` to detect whether the other object is the Player in the next section).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`OnDestroy()` is another Unity message that is called when the GameObject in
    the scene is destroyed – by using the `Destroy()` method, as you can see in the
    `OnTriggerEnter2D()` method previously, when the Player collides with the collectible
    item, it will process the collection of the item in `OnTriggerEnter2D()` and then
    remove the item from the scene by calling `Destroy(gameObject)` (so items cannot
    be collected again).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Save the `CollectItem` script and add it as a component to your `Collider` components
    must be on the same GameObject as the collider – you can see in the `CollectItem`
    script is just below the `CapsuleCollider2D` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Have a look at the following screenshot displaying the `Debug.Log()` output
    in the **Console** while playtesting and running the ladybug character into the
    *water* *diamond* sprites:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.6 – Playtesting the collectible items](img/B18347_03_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.6 – Playtesting the collectible items
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: Two additional things worth mentioning in the previous screenshot are as follows.
  prefs: []
  type: TYPE_NORMAL
- en: The **Editor** is tinted orange because I’ve assigned a color to show when entering
    **Play Mode** – set colors in **Edit** | **Preferences** | **Colors** then **General**
    | **Playmode tint**. This tint *should* remind you that you are in **Play Mode**,
    and most changes you make to **Component** values will not be saved when stopping
    (changes in file-based assets will be saved, however).
  prefs: []
  type: TYPE_NORMAL
- en: I’ve added some empty GameObjects to the **Scene Hierarchy** to organize objects
    into logical groupings. For any object added for purely organizational purposes
    (that is, no child assets are being used in the game), you can assign it an **EditorOnly**
    tag so that it is not included in the final game build (saving some resources
    in the process).
  prefs: []
  type: TYPE_NORMAL
- en: You can go ahead and duplicate the **Water Diamond** Prefab by selecting one
    in the **Hierarchy** and pressing *Ctrl*/*Cmd* + *D* several times and repositioning
    it throughout the level. Playtest to get a feel for how well you can move around
    the level to reach each of the items!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You can organize all of the **Water Diamond** collectible items in the scene
    in an empty root GameObject – just make sure the root object is at (**0**, **0**,
    **0**) before dragging in the items.
  prefs: []
  type: TYPE_NORMAL
- en: You can quickly reset the **Transform** component of a GameObject in the **Inspector**
    by clicking the vertical ellipsis button (to the right of the **Help** and **Presets**
    buttons in the title bar) and choosing **Reset**.
  prefs: []
  type: TYPE_NORMAL
- en: With that, our game is shaping into something fun! But what about adding to
    the challenge? We’ll use hazards to slow the player when they touch one… look
    out!
  prefs: []
  type: TYPE_NORMAL
- en: Hitting hazards
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ve previously discussed hazards in the game, and level design, so now let’s
    look at implementing them before coming to a win/lose condition in the final section
    of this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, let’s define our nerf mechanic by adding it to our GDD document:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Name** **of game** | Outer World |'
  prefs: []
  type: TYPE_TB
- en: '| **What is a nerf mechanic for the player in the** **collection game?** |
    The player’s speed will be decreased when they touch a “toxic puddle” in the environment
    – increasing the challenge of collecting all “water diamonds” before the timer
    expires. |'
  prefs: []
  type: TYPE_TB
- en: Table 3.2 – The GDD nerf mechanic addition
  prefs: []
  type: TYPE_NORMAL
- en: Okay, we need to add *toxic puddles* to the level then! We could do these the
    same way we created the **Water Diamond** Prefabs and populate the level in that
    fashion, but let’s take a different approach here and revisit our tilemaps.
  prefs: []
  type: TYPE_NORMAL
- en: 'Add toxic puddles in challenging locations throughout the level by following
    these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Create a new `Tilemap - Hazards -` `Trigger`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open the **Tile Palette** (**Window** | **2D** | **Tile Palette**) and make
    sure the active tilemap is the tilemap we just created in the previous step.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **Environment Objects** from the available **Palettes** dropdown menu
    list.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the *black splotch/puddle* sprite from the available tiles and use the
    **Paintbrush** tool (shortcut key *B*) to scatter these tiles in strategic spots
    throughout your level (my suggestion would be to place them near water diamonds!).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Since we want to make the toxic puddles interactable (via the physics engine),
    add a `TilemapCollider2D` component to the **Tilemap** GameObject in the **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Compared to the previous collision objects’ `TileMapCollider2D.IsTrigger` value
    so that we can use the `OnTriggerEnter2D()` event to respond to the collision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Here is what the setup looks like with the new hazards tilemap, toxic puddles
    painted in the level (selected in the Tile Palette), and `TileMapCollider2D`’s
    **Is Trigger** box ticked:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.7 – The Hazards Tilemap trigger collider setup](img/B18347_03_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.7 – The Hazards Tilemap trigger collider setup
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 3**.7*, you can see that I’ve already added a `TouchHazard` component
    for the Player interaction with the hazard tilemap’s tiles.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at the `TouchHazard` script:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, let’s break it down point by point:'
  prefs: []
  type: TYPE_NORMAL
- en: The first new line you’ll notice here is we’ve added some *header information*.
    `[Header]` is an attribute that we can decorate the public field with to show
    some information to the developer – or designer - viewable in the **Inspector**
    along with a field. You can see this message in the **Inspector** in *Figure 3**.7*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Attribute**: [https://docs.unity3d.com/2022.3/Documentation/Manual/Attributes.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Attributes.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: The first public variable we’re declaring here – `Player` – is for the `PlayerController`
    reference. Instead of using a GameObject reference here – requiring an additional
    step to access a component added to the GameObject – we’re using the object type
    of the component to access its public members directly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can see here again that we’re using the `OnTriggerEnter2D` message called
    when the 2D collider on the tilemap reports a collision.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that we have a collision occurring, we will do a quick test with an `if`
    statement to see *who* collided with the hazard tiles by using the `collision.CompareTag()`
    method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**CompareTag**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.CompareTag.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/GameObject.CompareTag.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: We’re specifying which tag we want to detect by passing in the player’s tag
    assignment with `Player.tag`. So, let’s make sure the **Player** Prefab has the
    **Player** tag assigned to it now!
  prefs: []
  type: TYPE_NORMAL
- en: 'With the **Player** object selected in the **Hierarchy**, go to the top of
    the **Inspector** and, using the **Tag** drop-down (*A*), select the **Player**
    tag from the list and then apply the change to the **Player** Prefab by using
    the **Overrides** drop-down and clicking **Apply All** (*B*), as seen in the following
    figure:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.8 – Set Player tag in Inspector and apply override](img/B18347_03_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.8 – Set Player tag in Inspector and apply override
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Tags**: [https://docs.unity3d.com/2022.3/Documentation/Manual/Tags.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/Tags.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '**Tags and** **layers**: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-TagManager.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-TagManager.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: If the result of our `if` statement returns `true` (the tags matched), then
    the `Debug.Log()` statement to notify us in the `SlowPlayerSpeed()` on the `Player`
    object reference. Accessing public members of an object is performed with `Player.SlowPlayerSpeed()`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s have a look at the *additions* required for adding the `SlowPlayerSpeed()`
    public method to our `PlayerController` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'We can see a few new variables are required to support slowing the player character’s
    speed for a short duration. The public variables, assignable in the `SlowedSpeed`:
    A `float` variable to specify the new slower move speed of the player, with a
    default value of `2f`.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`SlowedTime`: A `float` variable to specify the duration (in seconds) to keep
    the speed at the `SlowedSpeed` value, with a default value of `5f` (5 seconds).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `Start()` method is used to cache (retain) the original `MoveSpeed` value
    of the player.*   The `SlowPlayerSpeed()` method has been added – called from
    the `TouchHazard` class – to set the current `MoveSpeed` of the player to the
    `SlowedSpeed` value to slow down movement.*   Following the `MoveSpeed` assignment,
    the `Invoke()` method (`MonoBehaviour`) is being used with a delay time value
    (the second parameter) to wait to call the new `RestoreSpeed()` method until the
    time specified by the `SlowedTime` variable has passed.*   We’re also using the
    C# `nameof()` expression with the `RestoreSpeed()` method here, so we aren’t using
    a string literal for the method name.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Invoke**: [https://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.xhtml](https://docs.unity3d.com/ScriptReference/MonoBehaviour.Invoke.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we’ve added the `RestoreSpeed()` method, which simply resets the `MoveSpeed`
    variable back to its original value – resetting player movement back to normal.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'With that, we can now enable the hazards interaction by referring to *Figure
    3**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: Add the **TouchHazard** component to the **Tilemap - Hazards -** **Trigger**
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Drag the **Player** object from the **Hierarchy** to the **Player** field in
    the **TouchHazard** component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Verify the **SlowedSpeed** and **SlowedTime** values in the **PlayerController**
    component on the **Player**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: You’ll now want to playtest your level and adjust the speed and duration of
    the hazard effect until it suits you (I’ve chosen a `2` and a `5`, as my initial
    values); move the hazards and diamonds around the level to make it more challenging
    or fun. Again, just have fun with this part!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we understood what a game mechanic is and how to define it
    in the GDD, and we learned how to implement a collection mechanic and hazard that
    affects gameplay at our level. Next, we’ll be applying the finishing touches to
    the collection game by adding a UI, countdown timer, and win condition.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to uGUI, the timer, counting, and winning
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The player needs to know what’s going on in the game, and the way we inform
    the player of this critical information is with a UI. Unity provides easy-to-use
    tooling for creating a UI, and it’s commonly referred to as **uGUI** (or **Unity
    Graphical User Interface**) – pronounced *You-gooey*. Formally, it’s just **Unity
    UI** (searching *ugui* in the documentation returns *No* *results found*).
  prefs: []
  type: TYPE_NORMAL
- en: Unity UI is a GameObject-based UI system, so you’ll already be familiar with
    adding UI components to display and interact with UI controls in different ways.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Unity** **UI**: [https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/index.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '*UI How* *Tos*: [https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/UIHowTos.xhtml?q=unity%20ui](https://docs.unity3d.com/Packages/com.unity.ugui%401.0/manual/UIHowTos.xhtml?q=unity%20ui)'
  prefs: []
  type: TYPE_NORMAL
- en: 'The three key pieces of information the player needs to see in the collection
    game are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The number of items collected versus the total number to collect
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The time remaining to collect all the items
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The winning state (win/lose) when the game ends
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The first UI object we’ll discuss adding is the Canvas because it’s what’s responsible
    for drawing our UI.
  prefs: []
  type: TYPE_NORMAL
- en: Canvas
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The **Canvas** is a defined area where all the UI widgets are contained – think
    of it as a piece of paper where everything to be drawn will be contained on the
    page. As mentioned previously, the Unity UI is GameObject based, so the Canvas
    is a GameObject with a Canvas component. All UI widgets added to the scene must
    be children of a Canvas.
  prefs: []
  type: TYPE_NORMAL
- en: 'Adding a UI Canvas to our scene is as simple as going to **UI** | **Canvas**
    in the **Create** menu. The first time a Canvas is added to the scene, it also
    adds an **EventSystem**. We’ll have to select the **EventSystem** and update it
    to use the new Input System. Click **Replace with InputSystemUIInputModule**,
    as seen in *Figure 3**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.9 – Update EventSystem for new Input System](img/B18347_03_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.9 – Update EventSystem for new Input System
  prefs: []
  type: TYPE_NORMAL
- en: 'With the `0.5`, as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.10 – Canvas Scaler](img/B18347_03_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.10 – Canvas Scaler
  prefs: []
  type: TYPE_NORMAL
- en: The Canvas is all set, so let’s add our first UI widget for displaying the current
    count of items collected!
  prefs: []
  type: TYPE_NORMAL
- en: TextMesh Pro
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**TextMesh Pro** (**TMP**) is a set of tools for creating highly customizable
    and high-quality 2D and 3D UI text in your projects. We’ll use TMP text widgets
    to display all gameplay information, including the items collected, the countdown
    timer, and the win/lose message.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**TextMeshPro**: [https://docs.unity3d.com/2022.3/Documentation/Manual/com.unity.textmeshpro.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/com.unity.textmeshpro.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '**TextMesh Pro** **documentation**: [https://docs.unity3d.com/Packages/com.unity.textmeshpro%404.0/manual/index.xhtml](https://docs.unity3d.com/Packages/com.unity.textmeshpro%404.0/manual/index.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'With the Canvas object selected in the **Hierarchy**, use the **Create** menu
    to add a **UI** | **Text – TextMeshPro** text widget to the scene. If this is
    the first time you’re adding a **TextMeshPro** widget to your project, you’ll
    be prompted to install the essential resources. Click **Import** **TMP Essentials**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.11 – The TMP Importer dialog](img/B18347_03_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.11 – The TMP Importer dialog
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following steps to make the collected item text shown in the bottom-left
    corner of the screen:'
  prefs: []
  type: TYPE_NORMAL
- en: Rename the newly added TMP text object `Collected` `Count Text`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To anchor the text to the bottom-left corner of the screen, use **Anchor Presets**
    (*A*), hold both the *Shift* (**Also set pivot**) and *Alt* (**Also set position**)
    keys down (*B*), then click the bottom-left anchor (*C*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 3.12 – TextMeshPro rect anchor setting](img/B18347_03_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.12 – TextMeshPro rect anchor setting
  prefs: []
  type: TYPE_NORMAL
- en: 'Use the following settings to provide default text to display and style the
    text (refer to *Figure 3**.12* as a reference):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`0` `of 0`'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Font** **Style**: **Bold**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Font** **Size**: **48**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: '**Extra Settings** | **Margin** | **Left**: **50**'
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
- en: With that, we’re ready to have the text updated every time an item is collected.
    Let’s see how to tie it all together in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the pickup count
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The problem we’re going to solve now is *how is UI text updated when an item
    is collected?* We can refer to design patterns for a solution! We previously covered
    both the Singleton and Observer patterns, and either one will suit our needs here.
  prefs: []
  type: TYPE_NORMAL
- en: To provide an example in practice, we will use both, starting with the Singleton.
  prefs: []
  type: TYPE_NORMAL
- en: The pickup count will be displayed as `GameManager`, will be responsible for
    holding the data (variables) for the collectibles, so this will become a Singleton
    instance.
  prefs: []
  type: TYPE_NORMAL
- en: The `Start()` method for each collectible item in the scene will be called when
    the game first runs, so we’ll use this to add each collectible item to the total
    items count.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s first create the `GameManager` script and make it a Singleton instance
    by adding the following lines to the variable declaration section (near the top
    of the class):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The `GameManager` class itself is declared a `public static` property – we want
    to directly access the class from another type using the `Instance` variable.
    We’ve let `get` remain public, while declaring `set` as private so external classes
    will only be able to read.
  prefs: []
  type: TYPE_NORMAL
- en: In the `Awake()` method, we’re setting the `Instance` variable to `this`, the
    current class instance. We’re using an expression body here (indicated by `=>`)
    instead of the usual `{}` squiggly brackets (block body) to keep the code concise,
    since it’s only a single expression that’s needed.
  prefs: []
  type: TYPE_NORMAL
- en: Property (C#)
  prefs: []
  type: TYPE_NORMAL
- en: A C# property is a class member that uses explicit accessors for the **get**
    and **set** methods to read or write data values.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we can add the variable for storing the total number of collectible items,
    the public method for incrementing the total, and the call to the incrementing
    method from the `CollectItem` class by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a private `_totalCollectibleItems` integer variable to the variable declaration
    section. Its accessor is private because it’s encapsulated only to change its
    value within the declaring class (with OOP encapsulation, it’s considered bad
    practice to modify variable values outside the class):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add a public `AddCollectibleItem()` method with no return type (`void`), as
    an expression body, to increment the `_totalCollectibleItems` current value. The
    `++` unary arithmetic operator increments the operand by 1\. The `public` accessor
    means that we can call this method outside the declaring class, which we will
    do next from the `CollectItem` class via the Singleton instance:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, in the `CollectItem` class, add the following to the bottom of the `Start()`
    method for calling the `GameManager` Singleton instance to add the collectible
    item to the total items count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: With that, we now know how many `Start()` will be called on every object instance
    in the scene. Easy-peasy!
  prefs: []
  type: TYPE_NORMAL
- en: 'The second part of the UI display for the collectible items requires the number
    of items currently collected. We’ll do that now with the second design pattern
    we’re covering in practice: Observer.'
  prefs: []
  type: TYPE_NORMAL
- en: Incrementing collected item count
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We’ve already seen how to access the `GameManager` Singleton instance via a
    static variable. We’re going to do something similar with the `CollectItem` class
    to know when any item has been collected.
  prefs: []
  type: TYPE_NORMAL
- en: Typically, every instance of an object in the scene is independent of one another
    – each with its independent members. We want `GameManager` to register and listen
    (that is, observe) for any one of the items being collected, so we’re going to
    accomplish this by invoking a static event – a static declaration will make it
    common across all class instances, so we won’t need a reference to any individual
    item’s instance.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s go ahead and add our static event to the `CollectItem` class, then register
    the listener from `GameManager` to take action when the event is invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following public static variable declaration to `CollectItem`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `event` keyword is added to the declaration to enforce invocation only from
    within the declaring class – we don’t want external classes to be able to trigger
    the event!
  prefs: []
  type: TYPE_NORMAL
- en: We’re using `UnityAction` here as a method delegate, so we can use it to refer
    to calling multiple methods through it or even pass it as a method argument. It’s
    also common practice to preface naming event delegates and methods with the word
    *On* (as in `OnItemCollected`).
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**UnityAction**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Events.UnityAction.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Events.UnityAction.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following line to the top of the `OnTriggerEnter2D()` method to invoke
    or *trigger* the event (also known as **event invocation**) when the item is collected:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The question mark and dot (`?.`) appended to `OnItemCollected` is a null-conditional
    operator – it will only perform the operation if the operand does not evaluate
    to `null`. In this case, it means if there are no registered listeners, we don’t
    want to throw a `NullReferenceException` error when calling `Invoke` (executing
    the event).
  prefs: []
  type: TYPE_NORMAL
- en: NullReferenceException (C#)
  prefs: []
  type: TYPE_NORMAL
- en: A **NullReferenceException** (**NRE**) is an error that can occur when trying
    to access a member of a **null** object (not assigned).
  prefs: []
  type: TYPE_NORMAL
- en: 'Moving into the `GameManager` class now, we add a private variable to track
    the number of items collected by the player:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The class encapsulates this variable – because its accessor is set to `private`
    – so, let’s add an `ItemCollected()` method that increments the count:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We’re simply incrementing the count by 1 every time an item is collected by
    using the ++ arithmetic operator after the variable (postfix).
  prefs: []
  type: TYPE_NORMAL
- en: 'What is the `ItemCollected()` method called now? Well, that’s where registering
    with the `CollectItem.OnItemCollected` event comes in. We’ll use the `OnEnable()`
    and `OnDisable()` Unity message events – these are called when the behavior is
    first enabled and active, then becomes disabled, respectively:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `+=` operator specifies adding an event handler method when subscribing
    to events. We’re registering the `ItemCollected` method to be called when the
    `CollectItem.ItemCollected` event is invoked (that is, registering a listener).
  prefs: []
  type: TYPE_NORMAL
- en: Important note
  prefs: []
  type: TYPE_NORMAL
- en: To avoid resource leaks, unsubscribing from events should always be performed!
  prefs: []
  type: TYPE_NORMAL
- en: The `-=` operator specifies removing an event handler method to stop subscribing
    to events. We’re unregistering the `ItemCollected` method so that it will no longer
    be called when the `CollectItem.ItemCollected` event is invoked. Suppose we don’t
    unregister the event handler, and the object holding the handler method is destroyed.
    In that case, it will throw an `null`) – and we quite certainly won’t be happy
    with that!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Don’t forget, if the handler method isn’t already created, you can have VS generate
    the method for you by clicking on the **ItemCollected** text, then using *Alt/Cmd*
    + *Enter* and selecting **Generate** **method ItemCollected**.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have our total and collected item values calculated, let’s update
    the UI display.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the UI
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The text component displaying the collected item progress has already been added
    to the scene as **Collected Count Text**. Now, we need a way to reference and
    update the text displayed every time a **Water Diamond** is collected by the player.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll create a new `UIManager` class to keep UI functionality separate from
    `GameManager` – following the single responsibility principle.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new script called `UIManager` and add the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here’s what we’ll do when writing the new `UIManager` script.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we’ll do is add a `using` statement for `TextMeshPro` (`TMPro`)
    so that we can reference the TMP text component’s properties.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ll then add a public variable for the **Collected Count Text** TMP object
    to be assigned to in the **Inspector** (for referencing).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When the game starts playing, we reset the `CollectedCountText` text to not
    display anything by using `string.Empty` (a zero-length string equivalent to `""`)
    – this will clear out any temporary display text we entered at design time for
    adjusting position and display values.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, the `UpdateCollectedItemsText()` method is added that sets the `CollectedCountText`
    text. It has two method parameters, one for the current item count and the other
    for the total collectible items in the scene. We’re again using string interpolation
    to combine the variables’ values with *of* for display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let’s return to the Unity Editor to complete the `UIManager` by adding it to
    the `CollectedCountText` field, as seen in the **Inspector** in the following
    figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 3.13 – The Manager Inspector assignments](img/B18347_03_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 3.13 – The Manager Inspector assignments
  prefs: []
  type: TYPE_NORMAL
- en: 'The last thing we have to do to get our text displayed when collecting an object
    is to wire up the `UI.UpdateCollectedItemsText()` call in `GameManager.ItemCollected()`:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `GameManger`, add a public variable to hold the reference to the `UIManager`
    component:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Change the `ItemCollected()` method to now call the `UI.UpdateCollectedItemsText()`
    method passing in an incremented `_collectedItemCount` and the `_totalCollectibleItems`
    values:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: The `++` operator in front of `_collectedItemCount` means that we will pre-increment
    its operand (prefix) and then read the value. We want the already incremented
    value to be passed to the method.
  prefs: []
  type: TYPE_NORMAL
- en: -- (C#)
  prefs: []
  type: TYPE_NORMAL
- en: Note that the **--** unary arithmetic operator is also available in C#, and
    instead of incrementing the operand by 1, it decrements it. The same rules apply
    to a pre- or post-decrementer assignment.
  prefs: []
  type: TYPE_NORMAL
- en: With that, the only remaining task is to drag `UIManager` to the `GameManager`
    component to assign its reference (refer to *Figure 3**.13*). Save your files
    and playtest!
  prefs: []
  type: TYPE_NORMAL
- en: We now have the game keeping track of the number of collected water diamonds
    and displaying progress to the player. It’s not quite a game yet, so we’ll add
    a simple countdown timer that we’ll later tie in to win/lose conditions in the
    next section.
  prefs: []
  type: TYPE_NORMAL
- en: The Timer script
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Referring to our GDD in *Table 3.1*, we know that the game will be lost if the
    countdown timer reaches 0 before the player collects all the water diamonds. For
    that, we’ll need a simple timer script that subtracts 1 second from the time every
    second. Let’s see how we can accomplish that and notify listeners of both time-changing
    and expiring events.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new script named `Timer` and refer to the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: 'Let’s have a look at the code and review what’s new:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OnTimeUpdate` event has a parameter added: `UnityAction<int>`. This allows
    passing an integer value to the listener when the event is invoked (you can add
    up to four types as parameters with `UnityAction`). We use the passed-in `int`
    value (seconds) for the displayed time remaining in the UI.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We’ve declared two `int` type variables in a single line, `_timeSeconds` and
    `_timeCurrent`, by separating the variable names with a comma.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`StartTimer()` is a public method that GameManager will call to start the timer
    countdown and begin the gameplay.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '`InvokeRepeating()` is similar to `Invoke()` except, you guessed it, with a
    repeating time specified. We use this to update the timer value every second.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**InvokeRepeating**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.InvokeRepeating.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/MonoBehaviour.InvokeRepeating.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: '`InvokeRepeating()` takes a string representation for the method’s name as
    a parameter, just as `Invoke()` does, and any time you’re typing a string literal
    into the code, it should raise a flag – hardcoded strings or *magic strings* are
    pure evil! So, instead of typing a string, we’ll use the `nameof` expression to
    return the method name as a string. Sweet!'
  prefs: []
  type: TYPE_NORMAL
- en: nameof (C#)
  prefs: []
  type: TYPE_NORMAL
- en: The **nameof** expression obtains a string constant from a variable, type, or
    member and is evaluated at compile time. This can be used instead of a string
    literal. It ensures no spelling errors and allows VS CodeLens to produce references.
  prefs: []
  type: TYPE_NORMAL
- en: The `StopTimer()` method calls `CancelInvoke()`, which will stop the timer counting
    down (by halting the `InvokeRepeating` process).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `UpdateTimer()` method is responsible for incrementing the timer and invoking
    the `OnTimeUpdate` event, passing the `_timeCurrent` value.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Finally, we test for a timer expired condition using the `>=` comparison operator:
    is `_timeCurrent` greater than or equal to `_timeSeconds`? We use `>=` instead
    of `==` for working with an edge case where the time incremented may skip a second,
    and we’d miss an equal condition. Also, the timer will be stopped, and the `OnTimeExpired`
    event will be triggered.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Whew! Not a long script, but several vital parts make it all function to work
    well with our other components. Speaking of, we can now integrate the `Timer`
    code with `GameManager` and `UIManager` to start the running of the timer and
    update the time remaining text in the UI.
  prefs: []
  type: TYPE_NORMAL
- en: Additions to GameManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the `Timer` script all ready, let’s connect the `Timer` script in the `GameManager`
    class to start running the timer and handling events for time updates and countdown
    expiration.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing we’ll tackle is starting the timer countdown when the game begins.
    The timer countdown starts by calling the `Timer.StartTimer()` public method through
    a direct reference assigned in the `Start()` method of the `GameManager` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'Follow these steps to see how it’s set up:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add a public variable, `GameTimer`, to reference the `Timer` component added
    to the **GameManager** GameObject in the **Hierarchy**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add a public int variable, `GameplayTime`, to specify the amount of time in
    seconds the game will count down from – this is the total time the player will
    have to collect all the water diamonds. The best way to know what value to set
    is to playtest the game!
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The timer is started from the `Start()` method when the game is run. We call
    `Invoke()` on the `StartTimer()` method with a 2-second delay – giving the players
    time to orient themselves a bit before gameplay starts:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the `StartTimer()` method, which performs the actual call to the `Timer`’s
    `StartTimer()` method, passing in the amount of time to count down from:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Lastly, back in the `Timer` component to the **GameManager** GameObject in the
    **Hierarchy** and assign the reference to it in the **GameTimer** field (refer
    to *Figure 3**.13*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The preceding steps have integrated `Timer` with our `GameManager` and start
    the time counting down when the game begins. But we still have to handle the Timer’s
    events, so let’s first add the listener for the time being updated:'
  prefs: []
  type: TYPE_NORMAL
- en: 'In the `OnEnable()` method, add the listener for the `OnTimeUpdate` event with
    the handler method specified:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Remember, when we subscribe to an event, we should also unsubscribe from it
    to prevent memory leaks, so add the following code to `OnDisable()`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Create the `TimeUpdated()` method (*Alt/Cmd* + *Enter*), where we’ll execute
    the code for handling when the timer is updated with a new time:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Same as before, we’re calling a public method on our UI reference for updating
    the countdown timer text while adding the values for the seconds passed in from
    `Timer` and the total gameplay time.
  prefs: []
  type: TYPE_NORMAL
- en: Note on code architecture
  prefs: []
  type: TYPE_NORMAL
- en: We could have added a listener to the **Timer.OnTimeUpdate** event right within
    **UIManager** to update the countdown timer text, but I decided to only have one
    reference to the **Timer** in the project and handle all timer events in **GameManager**.
    This will keep things cleaner, and it is more straightforward to troubleshoot
    any issues since the timer-related code is all within one class.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll add the `UpdateTimerText()` method in the next section, where we’ll update
    `UIManager`.
  prefs: []
  type: TYPE_NORMAL
- en: Additions to UIManager
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Let’s get right to adding the additional variables and methods to support updating
    the timer text and the game over messages we’ll finish in the next section:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open up the `UIManager` script and make the following revisions:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Add the two `TextMeshProUGUI` public fields for the text displayed in the UI
    for the timer and game over text.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In `Start()`, we’ll clear out any placeholder text used during design time,
    so no text will be displayed until it’s updated.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `UpdateTimerText()` method with the current and total seconds parameters
    to calculate the time remaining in the countdown to display.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that we’re using `System.TimeSpan` to make things easy. We can then use
    the `ts` variable when displaying the text, formatting it to show minutes and
    seconds, where seconds will always be displayed with two digits (`00` being specified).
  prefs: []
  type: TYPE_NORMAL
- en: Finally, add the `SetGameOverText()` method for, you guessed it, updating the
    `GameOverText` text for displaying the game over message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To finish up the revisions, we’ll go back into the **Editor** and create two
    new **Text - TextMeshPro** UI widgets as children of **Canvas** in the **Scene
    Hierarchy** (refer to *Figure 3**.13*):'
  prefs: []
  type: TYPE_NORMAL
- en: To display the timer in the UI, name it *Countdown Timer Text* and anchor it
    to the top center of the screen. Size the text to something easily visible to
    the player.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To display the game over text in the UI, name it *Game Over Text* and anchor
    it to the center of the screen. Give the text a large size, covering most of the
    screen, so there is no mistaking when the game is over and the player has either
    won or lost.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When you’ve finished the UI design for these text widgets, drag them to the
    `UIManager` component.
  prefs: []
  type: TYPE_NORMAL
- en: A game just isn’t a game unless you can win or lose playing it! So, let’s finish
    up the collection game in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Winning the game
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Everything we require to determine a win-and-lose condition is already in place.
    Let’s start with the win condition: they win if the player collects all the water
    diamonds before the countdown timer expires.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a simple equality conditional statement: does the accumulated item
    count equal the total collectible items count? If we check this condition when
    an item is collected, and it equates to `true`, we know we’ve won the game.'
  prefs: []
  type: TYPE_NORMAL
- en: In `GameManager`, revise the `ItemCollected()` method to include this check,
    and we’ll call a `Win()` method if `true`.
  prefs: []
  type: TYPE_NORMAL
- en: 'You’ll first have to refactor the expression body to a block body to include
    additional lines of code in the method (hint: VS can refactor this for you and
    add the squiggly brackets). It will now look as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'That was easy! Now, let’s state the losing condition: they lose if the countdown
    timer runs out before the player collects all the water diamonds. This requires
    just a bit more work, but we’re just going to use what we’ve already implemented,
    specifically, the `Timer.OnTimeExpired` event.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In `GameManager`, again, let’s add a listener to `OnEnable()` for the time
    expiring and assign a handler method:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, unsubscribe:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: 'Create the `TimeExpired()` method as an expression body where we’ll just call
    `Lose()` – the time has expired; if the player had already collected all the items
    – and won – this method would never be reached:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: 'Finally, as the very last steps for completing the collection game, referring
    to the additions to the following `GameManager` script, we’ll add both the `WinText`
    and `LoseText` public fields that hold the messages to be displayed when the game
    ends (as seen in *Figure 3**.13*):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: If you don’t assign some default text values to the variable declarations here,
    then don’t forget to assign them in the **Inspector**!
  prefs: []
  type: TYPE_NORMAL
- en: 'We’ll also add the `Win()` and `Lose()` methods:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: 'A quick breakdown of these two new methods is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Win()` method starts off by stopping the timer by calling `GameTimer.StopTimer()`.
    This will cancel invoking the update timer method since our game is over now.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both of these methods call `UI.SetGameOverText()` but with the corresponding
    argument to display the correct message, `WinText` and `LoseText` respectively.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: They each set the `timeScale` variable of the running game `Time` to `0`, which
    has the effect of pausing the game (with some exceptions; see the following callout
    block on `Time.timeScale` for more information).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that setting `timeScale` to zero will technically have the same result
    as calling `GameTimer.StopTimer()` here, since the only option at this point,
    is to restart the game. Still, I like to be explicit with some statements so that
    the intent is clearly visible in the code (so long as it’s not something that
    would otherwise negatively impact things, of course, heh).
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: '**Time.timeScale**: [https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-timeScale.xhtml](https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Time-timeScale.xhtml)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Since we broke things up into smaller chunks of code quite a bit in this section,
    you may want to refer to the completed `GameManager` script, which can be found
    in the GitHub repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch3](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch3)'
  prefs: []
  type: TYPE_NORMAL
- en: With that, our game is complete. Yay! However, one more crucial step is needed
    before we can share our game with the world… and that is making sure others find
    the game challenging and fun to play.
  prefs: []
  type: TYPE_NORMAL
- en: Playtesting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now is the time to playtest and change the parameters of your level design,
    change the paths where the player can go, move objects and hazards, move the collectibles,
    and tweak the gameplay time to make the game challenging and fun for players.
  prefs: []
  type: TYPE_NORMAL
- en: Have other people play your game – watch them play, if you can, to get an idea
    of how they play your game and get their feedback. Implement and iterate on changes
    in response to playtesting to improve your game!
  prefs: []
  type: TYPE_NORMAL
- en: Downloading the completed game code
  prefs: []
  type: TYPE_NORMAL
- en: 'Remember, the example code for this book can be downloaded from the GitHub
    repo here: [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: This chapter was an introduction to the power of the CM camera system for quickly
    adding a Player follow camera, implementing game mechanics for collecting items
    that engage the player, displaying key game progression elements to the player
    with Unity UI, and how to finish and balance our collection game with both win
    and lose conditions.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’ll introduce the next project in the book by defining
    the GDD for the *Outer World* 2D adventure game, learning how to import original
    artwork to use with additional Unity level building tooling, and exploring more
    aspects of level design and game polish.
  prefs: []
  type: TYPE_NORMAL
