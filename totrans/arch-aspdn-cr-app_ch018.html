<html xml:lang="en-US" xmlns="http://www.w3.org/1999/xhtml" xmlns:epub="http://www.idpf.org/2007/ops">
<head>
<meta charset="utf-8"/>
<meta content="packt" name="generator"/>
<title>17 Getting Started with Vertical Slice Architecture</title>


<!-- kobo-style -->
<style id="koboSpanStyle" type="text/css" xmlns="http://www.w3.org/1999/xhtml">.koboSpan { -webkit-text-combine: inherit; }</style>
</head>
<body>

<h1 data-number="18">17 Getting Started with Vertical Slice Architecture</h1>

<h2 data-number="18.1">Before you begin: Join our book community on Discord</h2>
<p>Give your feedback straight to the author himself and chat to other early readers on our Discord server (find the "architecting-aspnet-core-apps-3e" channel under EARLY ACCESS SUBSCRIPTION).</p>
<p><a href="https://packt.link/EarlyAccess">https://packt.link/EarlyAccess</a></p>
<p><img alt="Qr code Description automatically generated" src="img/file111.png" style="width:10em"/></p>
<p>This chapter introduces Vertical Slice Architecture, an effective way to organize our ASP.NET Core applications. Vertical Slice Architecture moves elements from multiple layers to a feature-oriented design, helping us maintain a clean, simple, cohesive, loosely-coupled, and manageable codebase.Vertical Slice Architecture flips our architectural perspective toward simplified architecture. Historically, we divided the logic of a feature across various layers like UI, business logic, and data access. However, we create independent slices of functionality with Vertical Slice Architecture instead. Think of your application as a cake; instead of cutting it horizontally (layers), we're cutting vertically (features), with each slice being fully functional on its own.This style changes how we design and organize our project, testing strategies, and coding approach. We don't have to worry about bloated controllers or overly complicated "God objects"; instead, making changes becomes more manageable because of the loose coupling between features.This chapter guides you through applying Vertical Slice Architecture to your ASP.NET Core applications, detailing how to handle commands, queries, validation, and entity mapping using CQS, MVC, MediatR, AutoMapper, and FluentValidation, which we explored in the previous chapters.</p>
<blockquote>
<p>We don’t have to use those tools to apply the architectural style and can replace those libraries with others or even code the whole stack ourselves.</p>
</blockquote>
<p>By the end of this chapter, you will understand Vertical Slice Architecture and its benefits, and should have the confidence to apply this style to your next project. In this chapter, we cover the following topics:</p>
<ul>
<li>Anti-pattern – Big Ball of Mud</li>
<li>Vertical Slice Architecture</li>
<li>Continuing your journey: A few tips and tricks</li>
</ul>
<p>Let's journey through the vertical slices and piece the architecture together, one slice at a time.</p>


<h2 data-number="18.2">Anti-pattern – Big Ball of Mud</h2>
<p>Let’s start with an anti-pattern. The <strong>Big Ball of Mud</strong> anti-pattern describes a system that ended badly or was never properly designed. Sometimes a system starts great but evolves into a Big Ball of Mud due to pressure, volatile requirements, impossible deadlines, bad practices, or other reasons. We often refer to the Big Ball of Mud as <strong>spaghetti code</strong>, which means the same thing.This anti-pattern means a very hard-to-maintain codebase, poorly written code that is difficult to read, lots of unwanted tight coupling, low cohesion, or worse: all that in the same codebase.Applying the techniques covered in this book should help you avoid this anti-pattern. Aim at small, well-designed components that are testable. Enforce that using automated testing. Refactor and improve your codebase whenever you can, iteratively (continuous improvement). Apply the SOLID principles. Define your application pattern before starting. Think of the best way to implement each component and feature; do research, and make one or more proof of concept or experiments if unsure of the best approach. Ensure you understand the business requirements of the program you are building (this is probably the best advice). Those tips should help you avoid creating a Big Ball of Mud.Building feature-oriented applications is one of the best ways to avoid creating a Big Ball of Mud. Let’s get started!</p>


<h2 data-number="18.3">Vertical Slice Architecture</h2>
<p>Instead of separating an application horizontally (layers), a vertical slice groups all horizontal concerns together to encapsulate a feature. Here is a diagram that illustrates that:</p>
<figure>
<img alt="Figure 17.1: Diagram representing a vertical slice crossing all layers" src="img/file112.png"/><figcaption aria-hidden="true">Figure 17.1: Diagram representing a vertical slice crossing all layers</figcaption>
</figure>
<p>Jimmy Bogard, who is a pioneer of this type of architecture, wrote the following:</p>
<blockquote>
<em>[The goal is to] minimize coupling between slices and maximize coupling within a slice.</em>
</blockquote>
<p>What does that mean? Let’s split that sentence into two distinct points:</p>
<ul>
<li>“minimize coupling between slices” (improved maintainability, loose coupling)</li>
<li>“maximize coupling within a slice” (cohesion)</li>
</ul>
<p>We could see the former as one vertical slice should not depend on another, so when you modify a vertical slice, you don’t have to worry about the impact on the other slices because the coupling is minimal.We could see the latter as: instead of spreading code around multiple layers, with potentially superfluous abstractions along the way, let’s regroup and simplify that code. That helps keep the tight coupling inside a vertical slice to create a cohesive unit of code that serves a single purpose: handling the feature end to end.Then we could wrap that to create software around the business problem we are trying to solve instead of the developer’s concerns, which your customers have no interest in (such as data access).Now, what is a slice in more generic terms? I see slices as composite hierarchies. For example, a shipping manager program has a multistep creation workflow, a list, and a details page. Each step of the creation flow would be a slice responsible for handling its respective logic. When put together, they compose the “create slice”, which is responsible for creating a shipment (a bigger slice). The list and details pages are two other slices. Then, all of those slices become another bigger slice, leading to something like this:</p>
<figure>
<img alt="Figure 17.2: A diagram displaying a top-down coupling structure where smaller parts (top) depend on bigger parts (middle) of complex features (bottom) based on their cohesion with one another (vertically)" src="img/file113.png"/><figcaption aria-hidden="true">Figure 17.2: A diagram displaying a top-down coupling structure where smaller parts (top) depend on bigger parts (middle) of complex features (bottom) based on their cohesion with one another (vertically)</figcaption>
</figure>
<p>There is strong coupling inside <strong>Step 1</strong>, with limited coupling between the other steps; they share some creation code as part of the <strong>Create</strong> slice. <strong>Create</strong>, <strong>List</strong>, and <strong>Details</strong> also share some code, but in a limited way; they are all part of the <strong>Shipments</strong> slice and access or manipulate the same entity: one or more shipments. Finally, the <strong>Shipments</strong> slice shares no code (or very little) with <strong>Other features</strong>.</p>
<blockquote>
<p>Following the pattern I just described, we have limited coupling and maximum cohesion. The downside is that you must continuously design and refactor the application, which requires stronger design skills than a layered approach. Moreover, you must know how to build the feature end to end, limiting the division of tasks between people and centralizing them on each team member instead; each member becomes a full-stack developer. We revisit this example in the <em>Continuing your journey</em> section near the end of the chapter.</p>
</blockquote>
<p>We explore the advantages and disadvantages next.</p>

<h3 data-number="18.3.1">What are the advantages and disadvantages?</h3>
<p>Let’s explore some advantages and disadvantages of Vertical Slice Architecture.</p>

<h4 data-number="18.3.1.1">Advantages</h4>
<p>On the upside, we have the following:</p>
<ul>
<li>We reduce coupling between features, making working on such a project more manageable. We only need to think about a single vertical slice, not <em>N</em> layers, improving <strong>maintainability</strong> by centralizing the code around a shared concern.</li>
<li>We can choose how each vertical slice interacts with the external resources they require without considering the other slices. That adds <strong>flexibility</strong> since one slice can use T-SQL while another uses EF Core, for example.</li>
<li>We can start small with a few lines of code (described as <strong>Transaction Scripts</strong> in <em>Patterns of Enterprise Application Architecture,</em> by Martin Fowler) without extravagant design or over-engineering. Then we can refactor our way to a better design when the need arises and patterns emerge, leading to a <strong>faster time to market</strong>.</li>
<li>Each vertical slice should contain precisely the right amount of code needed to be correct—not more, not less. That leads to a <strong>more robust</strong> codebase (less code means less extraneous code and less code to maintain).</li>
<li>It is easier for newcomers to find their way around an existing system since each feature is near-independent, leading to a <strong>faster onboarding time</strong>.</li>
<li>All patterns and techniques you learned in previous chapters still apply.</li>
</ul>
<blockquote>
<p>From my experience, features tend to start small and grow over time. The users often find out what they need while using the software, changing the requirements over time, which leads to changes in the software. After the fact, I wish many projects I worked on were built using Vertical Slice Architecture instead of layering.</p>
</blockquote>


<h4 data-number="18.3.1.2">Disadvantages</h4>
<p>Of course, nothing is perfect, so here are some downsides:</p>
<ul>
<li>It may take time to wrap your head around Vertical Slice Architecture if you’re used to layering, leading to an adaptation period to learn a new way to think about your software.</li>
<li>It is a “newer” type of architecture, and people don’t like change.</li>
</ul>
<blockquote>
<p>Another thing that I learned the hard way is to embrace change. I don’t think I’ve seen one project end as it was supposed to. Everyone identifies the missing pieces of the business processes while using the software. That leads to the following advice: release the software as fast as possible and have your customers use the software as soon as possible. That advice can be easier to achieve with Vertical Slice Architecture because you build value for your customers instead of more or less valuable abstractions and layers. Having a customer try staged software is very hard; no customer has time to do such a thing; they are busy running their business. However, releasing production-ready slices may lead to faster adoption and feedback.</p>
<blockquote>
<p>At the beginning of my career, I was frustrated when specifications changed, and I thought that better planning would have fixed that. Sometimes better planning would have helped, but sometimes, the customer just did not know how to express their business processes or needs and had to try the application to figure it out. My advice here is don’t be frustrated when the specs change, even if that means rewriting a part of the software that took you days or more to code in the first place; that will happen all the time. Learn to accept that instead, and find ways to make this process easier and faster. If you are in contact with the customers, find ways to help them figure out their needs and reduce the number of changes.</p>
</blockquote>
</blockquote>


<h4 data-number="18.3.1.3">Downside or Upsides?</h4>
<p>The following points are downsides that we can tame as upsides:</p>
<ul>
<li>Suppose you are used to working in silos (such as the DBAs doing the data stuff). In that case, assigning tasks that touch the whole feature may be more challenging, but this can become an advantage since everyone in your team works more closely together, leading to more learning and collaboration and possibly a new cross-functional team—which is excellent. Having a data expert on the team is great; no one is an expert in all areas.</li>
<li>Refactoring: strong refactoring skills will go a long way. Over time, most systems need some refactoring, which is even more true for Vertical Slice Architecture. That can be caused by changes in the requirements or due to technical debt. No matter the reason, you may end up with a <strong>Big Ball of Mud</strong> if you don't. First, writing isolated code and then refactoring to patterns is a crucial part of Vertical Slice Architecture. That’s one of the best ways to keep cohesion high inside a slice and coupling as low as possible between slices. This tip applies to all types of architecture and is made easier with a robust test suite that validates your changes automatically.</li>
</ul>
<blockquote>
<p>A way to start refactoring that business logic would be to push the logic into the <strong>domain model</strong>, creating a <strong>rich domain model</strong>. You can also use other design patterns and techniques to fine-tune the code and make it more maintainable, such as creating services or layers. A layer does not have to cross all vertical slices; it can cross only a subset of them.</p>
<blockquote>
<p>Compared to other application-level patterns, such as layering, fewer rules lead to more choices (Vertical Slice Architecture). <em>You can use all design patterns, principles, and best practices inside a vertical slice without exporting those choices application-wide.</em></p>
</blockquote>
</blockquote>
<p>How do you organize a project into Vertical Slice Architecture? Unfortunately, there is no definitive answer to that, and it depends on the engineers working on the project. We explore one way in the next project, but you can organize your project as you see fit. Then we dig deeper into refactoring and organization.</p>



<h3 data-number="18.3.2">Project – Vertical Slice Architecture</h3>
<p><strong>Context</strong>: We are getting tired of layering, and we got asked to rebuild our small demo shop using Vertical Slice Architecture.Here is an updated diagram that shows how we conceptually organized the project:</p>
<figure>
<img alt="Figure 17.3: Diagram representing the organization of the demo shop project" src="img/file114.png"/><figcaption aria-hidden="true">Figure 17.3: Diagram representing the organization of the demo shop project</figcaption>
</figure>
<p>Each vertical box is a use case (or slice), while each horizontal box is a crosscutting concern or a shared component. This is a small project, so we share the data access code (<code>DbContext</code>) and the <code>Product</code> model between the three use cases. This sharing is unrelated to Vertical Slice Architecture, but splitting it more in a small project like this is hard and pointless.In this project, I decided to go with web API controllers instead of minimal APIs and an anemic product model instead of a rich one. We could have used minimal APIs, a rich model, or any combination. I chose this so you have a glimpse of using controllers, as this is something you might very well end up using. We go back to minimal APIs in the next chapter.Here are the actors:</p>
<ul>
<li><code>ProductsController</code> is the REST API to manage products.</li>
<li><code>StocksController</code> is the REST API to manage the inventory.</li>
<li><code>AddStocks</code>, <code>RemoveStocks</code>, and <code>ListAllProducts</code> are the same use cases we have copied in our project since <em>Chapter 14</em>, <em>Layering and Clean Architecture</em>.</li>
<li>The persistence “layer” consists of an EF Core <code>DbContext</code> that persists the <code>Product</code> model to an in-memory database.</li>
</ul>
<p>We could add other crosscutting concerns on top of our vertical slices, such as authorization, error management, and logging, to name a few.Next, let’s look at how we organized the project.</p>

<h4 data-number="18.3.2.1">Project organization</h4>
<p>Here is how we organized the project:</p>
<ul>
<li>The <code>Data</code> directory contains EF Core-related classes.</li>
<li>The <code>Features</code> directory contains the features. Each subfolder contains its underlying features (vertical slices), including controllers, exceptions, and other support classes required to implement the feature.</li>
<li>Each use case is self-contained and exposes the following classes:</li>
</ul>
<ol>
<li><code>Command</code> or <code>Query</code> representing the MediatR request.</li>
<li><code>Result</code> is the return value of that request.</li>
<li><code>MapperProfile</code> instructs AutoMapper on how to map the use case-related objects (if any).</li>
<li><code>Validator</code> contains the validation rules to validate the <code>Command</code> or <code>Query</code> objects (if any).</li>
<li><code>Handler</code> contains the use case logic: how to handle the request.</li>
</ol>
<ul>
<li>The <code>Models</code> directory contains the domain model.</li>
</ul>
<figure>
<img alt="Figure 17.4: Solution Explorer view of the file organization" src="img/file115.png"/><figcaption aria-hidden="true">Figure 17.4: Solution Explorer view of the file organization</figcaption>
</figure>
<p>In this project, we support request validation using <strong>FluentValidation</strong>, a third-party NuGet package. We can also use <code>System.ComponentModel.DataAnnotations</code> or any other validation library that we want.</p>
<blockquote>
<p>With FluentValidation, I find it easy to keep the validation within our vertical slice but outside the class we want to validate. The out-of-the-box .NET validation framework, <code>DataAnnotations</code>, does the opposite, forcing us to include the validation as metadata on the entities themselves. Both have pros and cons, but FluentValidation is easier to test and extend.</p>
</blockquote>
<p>The following code is the <code>Program.cs</code> file. The highlighted lines represent registering FluentValidation and scanning the assembly to find validators:</p>
<div><pre><code>var currentAssembly = typeof(Program).Assembly;
var builder = WebApplication.CreateBuilder(args);
builder.Services
    // Plumbing/Dependencies
    .AddAutoMapper(currentAssembly)
    .AddMediatR(o =&gt; o.RegisterServicesFromAssembly(currentAssembly))
    .AddSingleton(typeof(IPipelineBehavior&lt;,&gt;), typeof(ThrowFluentValidationExceptionBehavior&lt;,&gt;))
    // Data
    .AddDbContext&lt;ProductContext&gt;(options =&gt; options
        .UseInMemoryDatabase("ProductContextMemoryDB")
        .ConfigureWarnings(builder =&gt; builder.Ignore(InMemoryEventId.TransactionIgnoredWarning))
    )
    // Web/MVC
    .AddFluentValidationAutoValidation()
    .AddValidatorsFromAssembly(currentAssembly)
    .AddControllers()
;
var app = builder.Build();
app.MapControllers();
using (var seedScope = app.Services.CreateScope())
{
    var db = seedScope.ServiceProvider.GetRequiredService&lt;ProductContext&gt;();
    await ProductSeeder.SeedAsync(db);
}
app.Run();</code></pre>
</div>
<p>The preceding code adds the bindings we explored in previous chapters, FluentValidation, and the other pieces required to run the application. The highlighted lines register FluentValidation and scan the <code>currentAssembly</code> for validator classes. The validators themselves are part of each vertical slice. Now that we covered the organization of the project, let’s look at features.</p>


<h4 data-number="18.3.2.2">Exploring the RemoveStock feature</h4>
<p>In this subsection, we explore the <code>RemoveStocks</code> feature with the same logic as in previous samples but organized differently (a.k.a. the difference between architectural styles). Since we use an anemic product model, we moved the add and remove stocks logic from the <code>Product</code> class to the <code>Handler</code> class. Let’s look at the code next. I describe each nested class along the way.The sample starts with the <code>RemoveStocks</code> class that contains the feature’s nested classes. That helps organize the feature and saves us some headaches about naming collision.</p>
<blockquote>
<p>We could use namespaces instead, but tools like Visual Studio recommend adding a <code>using</code> statement and removing the inline namespace. Nowadays, it often automatically adds the using statement, like when pasting code, which is great for many scenarios but inconvenient for this specific one. So using nested classes fixes this.</p>
</blockquote>
<p>Here is the <code>RemoveStocks</code> class skeleton:</p>
<div><pre><code>using AutoMapper;
using FluentValidation;
using MediatR;
using VerticalApp.Data;
using VerticalApp.Models;
namespace VerticalApp.Features.Stocks;
public class RemoveStocks
{
    public class Command : IRequest&lt;Result&gt; {/*...*/}
    public class Result {/*...*/}
    public class MapperProfile : Profile {/*...*/}
    public class Validator : AbstractValidator&lt;Command&gt; {/*...*/}
    public class Handler : IRequestHandler&lt;Command, Result&gt; {/*...*/}
}</code></pre>
</div>
<p>The preceding code showcases that the <code>RemoveStocks</code> class contains all the required elements it needs for its specific use case:</p>
<ul>
<li><code>Command</code> is the input DTO.</li>
<li><code>Result</code> is the output DTO.</li>
<li><code>MapperProfile</code> is the AutoMapper profile that maps feature-specific classes to non-feature-specific classes and vice versa.</li>
<li><code>Validator</code> validates the input before an instance hits the <code>Handler</code> class (the <code>Command</code> class).</li>
<li><code>Handler</code> encapsulates the use case logic.</li>
</ul>
<p>Next, we explore those nested classes, starting with the <code>Command</code> class, which is the <strong>input of the use case</strong> (the request):</p>
<div><pre><code>public class Command : IRequest&lt;Result&gt;
{
    public int ProductId { get; set; }
    public int Amount { get; set; }
}</code></pre>
</div>
<p>The preceding request contains everything it needs to remove stocks from the inventory and fulfill the operation. The <code>IRequest&lt;TResult&gt;</code> interface tells MediatR that the <code>Command</code> class is a request and should be routed to its handler. The <code>Result</code> class is the return value of that handler and represents the <strong>output of the use case</strong>:</p>
<div><pre><code>public record class Result(int QuantityInStock);</code></pre>
</div>
<p>The mapper profile is optional and allows encapsulating AutoMapper <em>maps</em> related to the use case. The following <code>MapperProfile</code> class registers the mapping from a <code>Product</code> instance to a <code>Result</code> instance:</p>
<div><pre><code>public class MapperProfile : Profile
{
    public MapperProfile()
    {
        CreateMap&lt;Product, Result&gt;();
    }
}</code></pre>
</div>
<p>The <code>validator</code> class is also optional and allows validating the input (<code>Command</code>) before it hits the handler; in this case, it ensures the <code>Amount</code> value is greater than zero:</p>
<div><pre><code>public class Validator : AbstractValidator&lt;Command&gt;
{
    public Validator()
    {
        RuleFor(x =&gt; x.Amount).GreaterThan(0);
    }
}</code></pre>
</div>
<p>Finally, the most important piece is the <code>Handler</code> class, which implements the use case logic:</p>
<div><pre><code>public class Handler : IRequestHandler&lt;Command, Result&gt;
{
    private readonly ProductContext _db;
    private readonly IMapper _mapper;
    public Handler(ProductContext db, IMapper mapper)
    {
        _db = db ?? throw new ArgumentNullException(nameof(db));
        _mapper = mapper ?? throw new ArgumentNullException(nameof(mapper));
    }
    public async Task&lt;Result&gt; Handle(Command request, CancellationToken cancellationToken)
    {
        var product = await _db.Products.FindAsync(new object[] { request.ProductId }, cancellationToken);
        if (product == null)
        {
            throw new ProductNotFoundException(request.ProductId);
        }
        if (request.Amount &gt; product.QuantityInStock)
        {
            throw new NotEnoughStockException(product.QuantityInStock, request.Amount);
        }
        product.QuantityInStock -= request.Amount;
        await _db.SaveChangesAsync(cancellationToken);
        return _mapper.Map&lt;Result&gt;(product);
    }
}</code></pre>
</div>
<p>The <code>Handler</code> class implements the <code>IRequestHandler&lt;Command, Result&gt;</code> interface, which links the <code>Command</code>, the <code>Handler</code>, and the <code>Result</code> classes. The <code>Handle</code> method implements the same logic as the previous implementations from <em>Chapter 14</em>, <em>Layering</em> <em>and Clean Architecture</em>, onward.Now that we have a fully functional use case, let’s look at the skeleton of the <code>StocksController</code> class that translates the HTTP requests to the MediatR pipeline so our use case gets executed:</p>
<div><pre><code>using MediatR;
using Microsoft.AspNetCore.Mvc;
namespace VerticalApp.Features.Stocks;
[ApiController]
[Route("products/{productId}/")]
public class StocksController : ControllerBase
{
    private readonly IMediator _mediator;
    public StocksController(IMediator mediator)
    {
        _mediator = mediator ?? throw new ArgumentNullException(nameof(mediator));
    }
    [HttpPost("add-stocks")]
    public async Task&lt;ActionResult&lt;AddStocks.Result&gt;&gt; AddAsync(
        int productId,
        [FromBody] AddStocks.Command command
    ) {/*...*/}
    [HttpPost("remove-stocks")]
    public async Task&lt;ActionResult&lt;RemoveStocks.Result&gt;&gt; RemoveAsync(
        int productId,
        [FromBody] RemoveStocks.Command command
    ) {/*...*/}
}</code></pre>
</div>
<p>In the controller, we inject an <code>IMediator</code> into the constructor. We used constructor injection because all actions of this controller use the <code>IMediator</code> interface. We have two actions, add and remove stocks.The following code represents the remove stocks action method:</p>
<div><pre><code>[HttpPost("remove-stocks")]
public async Task&lt;ActionResult&lt;RemoveStocks.Result&gt;&gt; RemoveAsync(
    int productId,
    [FromBody] RemoveStocks.Command command
)
{
    try
    {
        command.ProductId = productId;
        var result = await _mediator.Send(command);
        return Ok(result);
    }
    catch (NotEnoughStockException ex)
    {
        return Conflict(new
        {
            ex.Message,
            ex.AmountToRemove,
            ex.QuantityInStock
        });
    }
    catch (ProductNotFoundException ex)
    {
        return NotFound(new
        {
            ex.Message,
            productId,
        });
    }
}</code></pre>
</div>
<p>In the preceding code, we read the content of the <code>RemoveStocks.Command</code> instance from the body, the action sets the <code>ProductId</code> property from the route value, and it sends the <code>command</code> object into the MediatR pipeline. From there, MediatR routes the request to its handler before returning the result of that operation with an HTTP <code>200 OK</code> status code. One of the differences between the preceding code and previous implementations is that we moved the DTOs to the vertical slice itself. Each vertical slice defines the input, the logic, and the output of its feature, as follows:</p>
<figure>
<img alt="Figure 17.5: Diagram representing the three primary pieces of a vertical slice" src="img/file116.png"/><figcaption aria-hidden="true">Figure 17.5: Diagram representing the three primary pieces of a vertical slice</figcaption>
</figure>
<p>When we add input validation, we have the following:</p>
<figure>
<img alt="Figure 17.6: Diagram representing the three primary pieces of a vertical slice, with added validation" src="img/file117.png"/><figcaption aria-hidden="true">Figure 17.6: Diagram representing the three primary pieces of a vertical slice, with added validation</figcaption>
</figure>
<p>The controller is a tiny layer between HTTP and our domain, guiding the HTTP requests to the MediatR pipeline and the responses back to HTTP. That thin piece represents the presentation of the API and allows access to the domain logic; the features. When controllers grow, it is often a sign that part of the feature logic is in the wrong place, most likely leading to code that is harder to test because the HTTP and other logic become intertwined.</p>
<blockquote>
<p>We still have the extra line for the <code>productId</code> and <code>try/catch</code> blocks in the controller’s code, but we could eliminate these using custom model binders and exception filters. I left additional resources at the end of the chapter, and we dig deeper into this in the next chapter.</p>
</blockquote>
<p>With that in place, it is now straightforward to add new features to the project. Visually, we end up with the following vertical slices (bold), possible vertical expansions (normal), and shared classes (italics):</p>
<figure>
<img alt="Figure 17.7: Diagram representing the project and possible extensions related to product management" src="img/file118.png"/><figcaption aria-hidden="true">Figure 17.7: Diagram representing the project and possible extensions related to product management</figcaption>
</figure>
<p>The diagram shows the grouping of the two main areas, products, and stocks. On the products side, I included an expansion that depicts a CRUD-like feature group.In our tiny application, it is tough to divide the data access part into more than one <code>DbContext</code>, so <code>ProductContext</code> is used by all slices, creating a shared data access layer.</p>
<blockquote>
<p>In other cases, create multiple <code>DbContext</code> when possible. This has nothing to do with Vertical Slice Archvaliitecture but is a good practice to divide your domain into smaller bounded contexts.</p>
</blockquote>
<p>Think about grouping features when they are cohesive and fit under the same part of the domain.Next, let’s test our application.</p>


<h4 data-number="18.3.2.3">Testing</h4>
<p>For this project, I wrote one integration test per use case outcome, which lowers the number of unit tests required while increasing the level of confidence in the system at the same time. Why? Because we are testing the features themselves instead of many abstracted parts independently. This is grey-box testing.We can also add as many unit tests as we need. This approach helps us write fewer but better feature-oriented tests, diminishing the need for mock-heavy unit tests. Unit tests are practical for validating complex use cases and algorithms faster than integration tests.Let’s look at the <code>StocksTest</code> class skeleton first:</p>
<div><pre><code>namespace VerticalApp.Features.Stocks;
public class StocksTest
{
    private static async Task SeederDelegate(ProductContext db)
    {
        db.Products.RemoveRange(db.Products.ToArray());
        await db.Products.AddAsync(new Product(
            id: 4,
            name: "Ghost Pepper",
            quantityInStock: 10
        ));
        await db.Products.AddAsync(new Product(
            id: 5,
            name: "Carolina Reaper",
            quantityInStock: 10
        ));
        await db.SaveChangesAsync();
    }
    public class AddStocksTest : StocksTest
    {
         // omitted test methods
    }
    public class RemoveStocksTest : StocksTest
    {
         // omitted test methods
    }
    public class StocksControllerTest : StocksTest
    {
         // omitted test methods
    }
}</code></pre>
</div>
<p>The <code>SeedAsync</code> method removes all products and inserts two new ones in the in-memory test database so the test methods can run using a predictable data set. The <code>AddStocksTest</code> and <code>RemoveStocksTest</code> classes contain the test methods for their respective use case. <code>StocksControllerTest</code> tests the MVC part. Let’s explore the happy path of the <code>AddStocksTest</code> class:</p>
<div><pre><code>[Fact]
public async Task Should_increment_QuantityInStock_by_the_specified_amount()
{
    // Arrange
    await using var application = new VerticalAppApplication();
    await application.SeedAsync(SeederDelegate);
    using var requestScope = application.Services.CreateScope();
    var mediator = requestScope.ServiceProvider
        .GetRequiredService&lt;IMediator&gt;();
    // Act
    var result = await mediator.Send(new AddStocks.Command
    {
        ProductId = 4,
        Amount = 10
    });
    // Assert
    using var assertScope = application.Services.CreateScope();
    var db = assertScope.ServiceProvider
        .GetRequiredService&lt;ProductContext&gt;();
    var peppers = await db.Products.FindAsync(4);
    Assert.NotNull(peppers);
    Assert.Equal(20, peppers!.QuantityInStock);
}</code></pre>
</div>
<p>In the <em>Arrange</em> section of the preceding test case, we create an instance of the application, create a scope to simulate an HTTP request, access the EF Core <code>DbContext</code>, and then get an <code>IMediator</code> instance to act on.In the <em>Act</em> block, we send a valid <code>AddStocks.Command</code> through the MediatR pipeline.We create a new scope in the <em>Assert</em> block then and get a <code>ProductContext</code> out of the container. With that <code>DbContext</code>, we find the product, ensure it’s not null, and validate that the quantity in stock is what we expect. Using a new <code>ProductContext</code> ensures we are not dealing with any cached items from the previous operations and the transaction has been saved as expected.With that test case, we know that if a valid command is issued to the mediator, that handler gets executed and successfully increments the stock property by the specified amount.</p>
<blockquote>
<p>The <code>VerticalAppApplication</code> class inherits from <code>WebApplicationFactory&lt;TEntryPoint&gt;</code>, creates a new <code>DbContextOptionsBuilder&lt;ProductContext&gt;</code> instance that has a configurable database name, implements a <code>SeedAsync</code> method that allows seeding the database, and allows altering the application services. I omitted the code for brevity reasons, but you can consult the complete source code in the GitHub repository (<a href="https://adpg.link/mWep">https://adpg.link/mWep</a>).</p>
</blockquote>
<p>Now, we can test the MVC part to ensure the controller is configured correctly. In the <code>StocksControllerTest</code> class, the <code>AddAsync</code> class contains the following test method:</p>
<div><pre><code>public class AddAsync : StocksControllerTest
{
    [Fact]
    public async Task Should_send_a_valid_AddStocks_Command_to_the_mediator()
    {
        // Arrange
        var mediatorMock = new Mock&lt;IMediator&gt;();
        AddStocks.Command? addStocksCommand = default;
        mediatorMock
            .Setup(x =&gt; x.Send(It.IsAny&lt;AddStocks.Command&gt;(), It.IsAny&lt;CancellationToken&gt;()))
            .Callback((IRequest&lt;AddStocks.Result&gt; request, CancellationToken cancellationToken) =&gt; addStocksCommand = request as AddStocks.Command)
        ;
        await using var application = new VerticalAppApplication(
            afterConfigureServices: services =&gt; services
                .AddSingleton(mediatorMock.Object)
        );
        var client = application.CreateClient();
        var httpContent = JsonContent.Create(
            new { amount = 1 },
            options: new JsonSerializerOptions(JsonSerializerDefaults.Web)
        );
        // Act
        var response = await client.PostAsync("/products/5/add-stocks", httpContent);
        // Assert
        Assert.NotNull(response);
        Assert.NotNull(addStocksCommand);
        response.EnsureSuccessStatusCode();
        mediatorMock.Verify(
            x =&gt; x.Send(It.IsAny&lt;AddStocks.Command&gt;(), It.IsAny&lt;CancellationToken&gt;()),
            Times.Once()
        );
        Assert.Equal(5, addStocksCommand!.ProductId);
        Assert.Equal(1, addStocksCommand!.Amount);
    }
}</code></pre>
</div>
<p>The highlighted code of the preceding test case <em>Arrange</em> block mocks the <code>IMediator</code> and saves what is passed to the <code>Send</code> method in the <code>addStocksCommand</code> variable. We are using that value in the highlighted code of the <em>Assert</em> block. When creating the <code>VerticalAppApplication</code> instance, we register the mock with the container to use it instead of the MediatR one, which bypasses the default behavior. We then create an <code>HttpClient</code> connected to our in-process application and craft a valid HTTP request to add the stocks we POST in the <em>Act</em> section.The <em>Assert</em> block code ensures the request was successful, verifies the mock method was hit once, and ensures <code>AddStocks.Command</code> was configured correctly.From the first test, we know the MediatR piece works. With this second test in place, we know the HTTP piece works. We are now almost certain that a valid add stocks request will hit the database with those two tests.</p>
<blockquote>
<p>I say “almost certain” because our tests run against an in-memory database, which is different from a real database engine (for example, it has no relational integrity and the like). In case of more complex database operations that affect more than one table or to ensure the correctness of the feature, you can run the tests against a database closer to the production database. For example, we can run the tests against a SQL Server container to spawn and tear down the databases in our CI/CD pipeline easily.</p>
</blockquote>
<p>In the test project, I added more tests covering the remove stocks and listing all products’ features, and ensuring AutoMapper configuration correctness. Feel free to browse the code. I omitted them here as they become redundant. The objective is to explore testing a feature almost end to end with very few tests (two for the happy path in this case), and I think we covered that.</p>



<h3 data-number="18.3.3">Conclusion</h3>
<p>The vertical slice project shows how we can remove abstractions while keeping the objects loosely coupled. We also organized the project into features (verticals) instead of layers (horizontals). We leveraged CQS, Mediator, and MVC patterns. Conceptually, the layers are still there; for example, the controllers are part of the presentation layer, but they are not organized that way, making them part of the feature. The sole dependency that crosses all our features is the <code>ProductContext</code> class, which makes sense since our model comprises a single class (<code>Product</code>). We could, for example, add a new feature that leverages minimal APIs instead of a controller, which would be okay because each slice is independent.We can significantly reduce the number of mocks required by testing each vertical slice with integration tests. That can also significantly lower the number of unit tests, testing features instead of mocked units of code. We should focus on producing features and business value, not the details behind querying the infrastructure or the code itself. We should not neglect the technical aspects either; performance and maintainability are also important characteristics, but reducing the number of abstractions can also make the application easier to maintain and for sure easier to understand.Overall, we explored a modern way to design an application that aligns well with Agile and helps generate value for our customers.Before moving to the summary, let’s see how Vertical Slice Architecture can help us follow the <strong>SOLID</strong> principles:</p>
<ul>
<li><strong>S</strong>: Each vertical slice (feature) becomes a cohesive unit that changes as a whole, leading to the segregation of responsibilities per feature. Based on a CQS-inspired approach, each feature splits the application’s complexity into commands and queries, leading to multiple small pieces. Each piece handles a part of the process. For example, we can define an input, a validator, a mapper profile, a handler, a result, an HTTP bridge (controller or endpoint), and as many more pieces as we need to craft the slice.</li>
<li><strong>O</strong>: We can enhance the system globally by extending the ASP.NET Core, MVC, or MediatR pipelines. We can design the features as we see fit, including respecting the OCP.</li>
<li><strong>L</strong>: N/A</li>
<li><strong>I</strong>: By organizing features by units of domain-centric use cases, we create many client-specific components instead of general-purpose elements, like layers.</li>
<li><strong>D</strong>: The slice pieces depend on interfaces and are tied together using dependency injection. Furthermore, by cutting the less useful abstractions out of the system, we simplify it, making it more maintainable and concise. Having that many pieces of a feature living close to each other makes the system easier to maintain and improves its discoverability.</li>
</ul>
<p>Next, we look at a few tricks and processes to get started with a bigger application. These are ways that I found work for me and will hopefully work for you too. Take what works for you and leave the rest; we are all different and work differently.</p>



<h2 data-number="18.4">Continuing your journey: A few tips and tricks</h2>
<p>The previous project was tiny. It had a shared model that served as the data layer because it was composed of a single class. When building real-world applications, you have more than one class, so I’ll give you a good starting point to tackle bigger apps. The idea is to create slices as small as possible, limit interactions with other slices as much as possible, and refactor that code into better code. We cannot remove coupling, so we need to organize it instead, and the key is to centralize that coupling inside a feature.Here is a workflow inspired by TDD, yet less rigid:</p>
<ol>
<li>Write the contracts that cover your feature (input and output).</li>
<li>Write one or more integration tests covering your feature, using those contracts; the <code>Query</code> or <code>Command</code> class (<code>IRequest</code>) as input and the <code>Result</code> class as output.</li>
<li>Implement your <code>Handler</code>, <code>Validator</code>, <code>MapperProfile</code>, and any other bit that needs to be coded. At this point, the code could be a giant <code>Handler</code>; it does not matter.</li>
<li>Once your integration tests pass, refactor that code by breaking down your giant <code>Handle</code> method as needed.</li>
<li>Make sure your tests still pass.</li>
</ol>
<p>During <em>step 2</em>, you may also test the validation rules with unit tests. It is way easier and faster to test multiple combinations and scenarios from unit tests, and you don’t need to access a database for that. The same also applies to any other parts of your system that are not tied to an external resource.During <em>step 4</em>, you may find duplicated logic between features. If that’s the case, it is time to encapsulate that logic elsewhere, in a shared place. That could be creating a method in the model, a service class, or any other pattern and technique you know might solve your duplication of logic problem. Working from isolated features and extracting shared logic will help you design the application. You want to push that shared logic outside of a handler, not the other way around (well, once you have that shared logic, you can use it as needed). Here, I want to emphasize <em>shared logic</em>, which means a business rule. When a business rule changes, all consumers of that business rule must also change their behavior. Avoid sharing <em>similar code</em> but do share business rules. Remember the DRY principle.What is very important when designing software is to focus on the functional needs, not the technical ones. Your customers and users don’t care about the technical stuff; they want results, new features, bug fixes, and improvements. Simultaneously, beware of the technical debt, so don’t skip the refactoring step, or your project may get in trouble. This advice applies to all types of architecture.Another advice is to keep all the code that makes a vertical slice as close as possible. You don’t have to keep all use case classes in a single file, but I find this helps. Partial classes are a way to split classes into multiple files. If named correctly, Visual Studio will nest them under the primary file. For example, Visual Studio will nest the <code>MyFeature.Hander.cs</code> file under the <code>MyFeature.cs</code> file, and so on.You can also create a folder hierarchy where the deeper levels share the previous levels. For example, the creation process of a workflow I implemented in an MVC application related to shipments had multiple steps. So I ended up with a hierarchy that looked like the following:</p>
<figure>
<img alt="Figure 17.12: The organizational hierarchy of directories and elements" src="img/file119.png"/><figcaption aria-hidden="true">Figure 17.12: The organizational hierarchy of directories and elements</figcaption>
</figure>
<p>Initially, I coded all the handlers individually. Then I saw patterns emerge, so I encapsulated that shared logic into shared classes. Then I reused some upper-level exceptions, so I moved those up from the <code>Features/Shipments/Create</code> folder to the <code>Features/Shipments</code> folder. I also extracted a service class to manage shared logic between multiple use cases. Ultimately, I have only the code I need, no duplicated logic, and the collaborators (classes, interfaces) are as close as possible. The coupling between features was minimal, while parts of the system work in synergy (cohesion). Moreover, there is very little to no coupling with other parts of the system. If we compare that result to another type of architecture, such as layering, I would most likely have needed more abstractions, such as repositories, services, and whatnot; the result with Vertical Slice Architecture was cleaner and simpler.The key point here is to code your handlers independently, organize them the best you can, keep an eye open for shared logic and emerging patterns, extract and encapsulate that logic, and try to limit interactions between use cases and slices.</p>


<h2 data-number="18.5">Summary</h2>
<p>This chapter overviewed Vertical Slice Architecture, which flips layers by 90°. Vertical Slice Architecture is about writing minimal code to generate maximum value by getting superfluous abstractions and rules out of the equation by relying on the developers’ skills and judgment instead.Refactoring is critical in a Vertical Slice Architecture project; success or failure will most likely depend on it. We can also use any patterns with Vertical Slice Architecture. It has lots of advantages over layering with only a few disadvantages. Teams who work in silos (horizontal teams) may need to rethink switching to Vertical Slice Architecture and first create or aim at creating multi-functional teams instead (vertical teams).We replaced the low-value abstraction with commands and queries (CQS-inspired). Those are then routed to their respective <code>Handler</code> using the Mediator pattern (helped by MediatR). That allows encapsulating the business logic and decoupling it from its callers. Those commands and queries ensure that each bit of domain logic is centralized in a single location.Of course, if you start with a strong analysis of your problem, you will most likely have a head start, like with any project. Nothing stops you from building and using a robust domain model in your slices. The more requirements you have, the easier the initial project organization will be. To reiterate, all engineering practices that you know still apply.The next chapter simplifies the concept of Vertical Slice Architecture even more by exploring the Request-EndPoint-Response (REPR) pattern using Minimal APIs.</p>


<h2 data-number="18.6">Questions</h2>
<p>Let’s take a look at a few practice questions:</p>
<ol>
<li>What design patterns can we use in a vertical slice?</li>
<li>When using Vertical Slice Architecture, is it true that you must pick a single ORM and stick with it, such as a data layer?</li>
<li>What will likely happen if you don’t refactor your code and pay the technical debt in the long run?</li>
<li>What does cohesion mean?</li>
<li>What does tight coupling mean?</li>
</ol>


<h2 data-number="18.7">Further reading</h2>
<p>Here are a few links to build upon what we learned in the chapter:</p>
<ul>
<li>For UI implementations, you can look at how Jimmy Bogard upgraded ContosoUniversity:</li>
</ul>
<ol>
<li>ContosoUniversity on ASP.NET Core with .NET Core: <a href="https://adpg.link/UXnr">https://adpg.link/UXnr</a></li>
<li>ContosoUniversity on ASP.NET Core with .NET Core and Razor Pages: <a href="https://adpg.link/6Lbo">https://adpg.link/6Lbo</a></li>
</ol>
<ul>
<li>FluentValidation: <a href="https://adpg.link/xXgp">https://adpg.link/xXgp</a></li>
<li>AutoMapper: <a href="https://adpg.link/5AUZ">https://adpg.link/5AUZ</a></li>
<li>MediatR: <a href="https://adpg.link/ZQap">https://adpg.link/ZQap</a></li>
</ul>


<h2 data-number="18.8">Answers</h2>
<ol>
<li>Any pattern and technique you know that can help you implement your feature. That’s the beauty of Vertical Slice Architecture; you are limited only by yourself.</li>
<li>No, you can pick the best tool for the job inside each vertical slice; you don’t even need layers.</li>
<li>The application will most likely become a Big Ball of Mud and be very hard to maintain, which is not good for your stress level, the product quality, time to market of changes, and so on.</li>
<li>Cohesion means elements that should work together as a united whole.</li>
<li>Tight coupling describes elements that cannot change independently; that directly depend on one another.</li>
</ol>


</body>
</html>
