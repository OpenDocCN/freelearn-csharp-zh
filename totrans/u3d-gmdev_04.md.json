["```cs\n[RequireComponent(typeof(CharacterController))] \n```", "```cs\nif (controller.isGrounded && playerVelocity.y < 0)\n        {\n            playerVelocity.y = 0f;\n        } \n```", "```cs\n// Check for water\nstandingInWater = Physics.Raycast(transform.position + Vector3.up, Vector3.down, out RaycastHit hit, 2f, waterLayer); \n```", "```cs\n// read in the values of the input action assigned to this script\nVector2 movement = movementControl.action.ReadValue<Vector2>(); \n```", "```cs\n// Use the values from the inputs and put them into a vector3, leaving up blank\nVector3 move = new Vector3(movement.x, 0, movement.y); \n```", "```cs\n// take into account the camera's forward as this needs to be relative to the view of the camera\nmove = cameraMainTransform.forward * move.z + cameraMainTransform.right * move.x; \n```", "```cs\n// zero out that y value just in case ;)\nmove.y = 0.0f; \n```", "```cs\nIf standingInWater is true, this value is whatever the value of waterSlowFactor is. Otherwise, this will be 1f.\n(standingInWater ? waterSlowFactor : 1f) \n```", "```cs\ncontroller.Move(move * Time.deltaTime * playerSpeed * (standingInWater ? waterSlowFactor : 1f)); \n```", "```cs\nplayerVelocity.y += gravityValue * Time.deltaTime;\ncontroller.Move(playerVelocity * Time.deltaTime); \n```", "```cs\nHandleRotation(movement);\nHandleAnimation(movement); \n```", "```cs\nvoid HandleAnimation(Vector2 movement)\n    {\n        bool isWalking = animator.GetBool(\"isWalking\");\n        if (movement != Vector2.zero && !isWalking)\n        {\n            animator.SetBool(\"isWalking\", true);\n        }\n        else if (!(movement != Vector2.zero) && isWalking)\n        {\n            animator.SetBool(\"isWalking\", false);\n        }\n    } \n```", "```cs\nVoid HandleRotation(Vector2 movement)\n    {\n        if (movement != Vector2.zero)\n        {\n            float targetAngle = Mathf.Atan2(movement.x, movement.y) *    Mathf.Rad2Deg + cameraMainTransform.eulerAngles.y;\n            Quaternion rotation = Quaternion.Euler(0.0f, targetAngle, 0.0f);\n            transform.rotation = Quaternion.Slerp(transform.rotation, rotation, rotFactorPerFrame * Time.deltaTime);\n        }\n    } \n```"]