- en: '4'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding Basic Blazor Components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we will look at the components that come with the Blazor template
    and start to build our own components. Knowing the different techniques used for
    creating Blazor websites will help us when we start building our components.
  prefs: []
  type: TYPE_NORMAL
- en: Blazor uses components for most things, so we will use the knowledge from this
    chapter throughout the book.
  prefs: []
  type: TYPE_NORMAL
- en: We will start this chapter with theory and end by creating a component to show
    some blog posts using the API we created previously, in *Chapter 3*, *Managing
    State – Part 1*.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Exploring components
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Learning Razor syntax
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding dependency injection
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Changing the Render mode
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Figuring out where to put the code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lifecycle events
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Writing our first component
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Make sure you have followed the previous chapters or use the `Chapter03` folder
    as the starting point.
  prefs: []
  type: TYPE_NORMAL
- en: You can find the source code for this chapter’s result at [https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter04](https://github.com/PacktPublishing/Web-Development-with-Blazor-Third-Edition/tree/main/Chapter04).
  prefs: []
  type: TYPE_NORMAL
- en: Exploring components
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In Blazor, a `component` is a `.razor` file containing a small, isolated functionality
    (code and markup), or it can be used as a page. A component can host other components
    as well. This chapter will show us how components work and how to use them.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are three different ways we can create a component:'
  prefs: []
  type: TYPE_NORMAL
- en: Using Razor syntax, with the code and HTML sharing the same file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using a code-behind file together with a `.razor` file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using only a code-behind file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In this chapter, we will go through the different options. First, we’ll go through
    the components in the template we used to create the project; these all use the
    first option, `.razor` files, where we have a mix of code and HTML in the same
    file.
  prefs: []
  type: TYPE_NORMAL
- en: 'The components in the template are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Counter**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Weather**'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Counter
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The `counter` page shows a button and a counter; if we click the button, the
    counter increases. We will now break the page apart, making it easier to understand.
    It is located in the `BlazorWebApp.Client` project, inside the `Pages` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the top of the page is the `@page` directive, which makes it possible to
    route to the component directly, as we can see in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: If we start the `BlazorWebApp` project and add `/counter` to the end of the
    URL, we see that we can directly access the component by using its route. We can
    also make the route take parameters, but we will return to that later.
  prefs: []
  type: TYPE_NORMAL
- en: 'Beneath that, we have the render mode:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: This is the way we can set the render mode on a specific component. This means
    that when we use this component, it will first render the page using Blazor Server
    (with SignalR) and, in the background, download the WebAssembly version so that
    the next time we load the page, it will then run the WebAssembly version instead.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s explore the code. To add code to the page, we use the `@code` statement,
    and within that statement, we can add ordinary C# code, as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: In the preceding code block, we have a private `currentCount` variable set to
    `0`. Then, we have a method called `IncrementCount()`, which increments the `currentCount`
    variable by `1`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We show the current value by using the `@` sign. In Razor, the `@` sign indicates
    that it is time for some code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As we can see, Razor is very smart because it understands when the code stops
    and the markup continues, so there is no need to add something extra to transition
    from the code to the markup (more on that in the next section).
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see in the preceding example, we are mixing HTML tags with `@currentCount`
    and Razor understands the difference. Next, we have a button that is the trigger
    for changing the value:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: This is an HTML button with a `Bootstrap` class (to make it look a bit nicer).
    `@onclick` binds the button’s `onclick` event to the `IncrementCount()` method.
    If we were to use `onclick` without the `@`, it would refer to the JavaScript
    event and not work.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, when we click the button, it will call the `IncrementCount()` method (depicted
    by `1` in *Figure 4.1*), the method increments the variable (depicted by `2`),
    and due to changing the variable, the UI will automatically be updated (depicted
    by `3`), as shown in *Figure 4.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 4.1 – The flow of the counter component ](img/B21849_04_01.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Figure 4.1: The flow of the counter component'
  prefs: []
  type: TYPE_NORMAL
- en: The `counter` component is implemented inside the `BlazorWebApp.Client` project,
    which is the WebAssembly project. In that project, we should put all the components
    that we want to run as WebAssembly. The `BlazorWebApp` project is then referencing
    the `BlazorWebApp.Client` project, so that it finds all the components and can
    run them as Blazor Server components if we want to.
  prefs: []
  type: TYPE_NORMAL
- en: Weather
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The next component we will take a look at is the `Weather` component. It’s located
    in the `Components/Pages/Weather.razor` folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Weather` components introduces the new streaming rendering functionality.
    The file initially looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Just as with the `Counter` component, we first define a route. There is no render
    mode attribute on this page. The component will be rendered using **Server-Side
    Rendering** (**SSR**). This is the default behavior for all the components unless
    specified, like the Counter component.
  prefs: []
  type: TYPE_NORMAL
- en: When we started the project, we set **Interactivity location** to **Per Page/Component**.
    This means that when we want interactivity, we need to specify that. But with
    the `[StreamRendering(true)]` attribute, we will get a feeling of interactivity.
    The page will first load, showing loading text. Then, using the same request,
    we get the rest of the data, like a `…` well, stream. So, we will get fast loading
    without waiting for the data, with no need to add interactivity using WebAssembly
    or SignalR, but still get some loading progress happening. We will dive into this
    some more in a later section.
  prefs: []
  type: TYPE_NORMAL
- en: 'The HTML part of the `Weather` component looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: If we don’t have any forecasts, it will show “Loading…” and as soon as we have
    some data, it will render a table showing the data.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code section that generates some mock data looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: When the page is initialized, the `WeatherForecast` array is filled with random
    data.
  prefs: []
  type: TYPE_NORMAL
- en: This reminds me that someone (as a joke) added a bug report to one of Dan Roth’s
    repos on GitHub, reporting “Weather forecast is unreliable.”
  prefs: []
  type: TYPE_NORMAL
- en: 'The conversation continued, “The weather forecast feature was completely accurate
    during my trip to London but has proven to be misleading in California. Counter
    and overall purpleness are great.” With Dan Roth replying: “Thanks for the feedback!
    I’ll get in touch with the folks on the .NET core framework team to make sure
    that `System.Random` does a better job of taking California weather patterns into
    account.”'
  prefs: []
  type: TYPE_NORMAL
- en: This is one of many reasons why I love the .NET community.
  prefs: []
  type: TYPE_NORMAL
- en: As we can see, by using the Razor syntax, we are seamlessly mixing code with
    HTML. The code checks whether there is any data – if so, it will render the table;
    if not, it will show a loading message. The component will update automatically
    once we have data. We have full control over the HTML, and Blazor will not add
    anything to the generated HTML.
  prefs: []
  type: TYPE_NORMAL
- en: There are component libraries that can make this process a bit simpler, which
    we will look at in the next chapter, *Chapter 5*, *Creating Advanced Blazor Components*.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how the sample template is implemented, it is time to dive
    deeper into the Razor syntax.
  prefs: []
  type: TYPE_NORMAL
- en: Learning Razor syntax
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the things I like about the Razor syntax is that it is easy to mix code
    and HTML tags. By having the code close to the markup, it is, in my opinion, easier
    to follow and understand. The syntax is very fluid; the razor parser understands
    when the code stops and markup begins, which means we don’t need to think about
    it that much. It is also not a new language; instead, we can leverage our existing
    C# and HTML knowledge to create our components. This section will contain a lot
    of theory to help us understand the Razor syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'To transition from HTML to code (C#), we use the `@` symbol. There are a handful
    of ways we can add code to our file, which we’ll explore in the following sections:'
  prefs: []
  type: TYPE_NORMAL
- en: Razor code blocks
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implicit Razor expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Explicit Razor expressions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Expression encoding
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Razor code blocks
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We have already seen some code blocks. A code block looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'If we wish, we can skip the `code` keyword like so:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'Inside those curly braces, we can mix HTML and code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: Notice how the `RenderName()` method transitions from code into the paragraph
    tags and back to code; this is an implicit transition.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we want to output text without having an HTML tag, we can use the `text`
    tag instead of using the paragraph tags, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: This would render the same result as the previous code but without the paragraph
    tags, and the `text` tag wouldn’t be rendered.
  prefs: []
  type: TYPE_NORMAL
- en: Implicit Razor expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Implicit Razor expressions** are when we add code inside HTML tags.'
  prefs: []
  type: TYPE_NORMAL
- en: 'We have already seen this in the `Weather` example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: We start with a `<td>` tag, then use the `@` symbol to switch to C#, and switch
    back to HTML with the end tag. We can use the `await` keyword together with a
    method call, but other than that, implicit Razor expressions cannot contain any
    spaces.
  prefs: []
  type: TYPE_NORMAL
- en: We cannot call a generic method using implicit expressions since `<>` would
    be interpreted as HTML. Hence, to solve this issue, we can use explicit expressions.
  prefs: []
  type: TYPE_NORMAL
- en: Explicit Razor expressions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We can use explicit Razor expressions if we want to use spaces in the code.
    Write the code with the `@` symbol followed by parentheses `( )`. So, it would
    look like this: `@()`.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In this sample, we subtract `7` days from the current date:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also use explicit Razor expressions to concatenate text; for example,
    we can concatenate text and code like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The output would then be `<td>Temp42</td>`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Using explicit expressions, we can easily call generic methods by using this
    syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The Razor engine knows whether we are using code or not. It also makes sure
    to encode strings to HTML when outputting it to the browser, called **expression
    encoding**.
  prefs: []
  type: TYPE_NORMAL
- en: Expression encoding
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'If we have HTML as a string, it will be escaped by default. Take this code,
    for example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: 'The rendered HTML would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'To output the actual HTML from a string (something we will do later, in *Chapter
    5*, *Creating Advanced Blazor Components*), you can use this syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: Using `MarkupString`, the output will be HTML, showing the HTML tag span. In
    some cases, one line of code isn’t enough; then, we can use code blocks.
  prefs: []
  type: TYPE_NORMAL
- en: Directives
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are a bunch of directives that change the way a component gets parsed
    or can enable functionality. These are reserved keywords that follow the `@` symbol.
    We will go through the most common and useful ones.
  prefs: []
  type: TYPE_NORMAL
- en: I find that it is pretty nice to have the layout and the code inside of the
    same `.razor` file.
  prefs: []
  type: TYPE_NORMAL
- en: Note that we can use code-behind to write our code to get a bit more separation
    between the code and layout. Later in this chapter, we will look at how to use
    code-behind instead of Razor syntax for everything. For now, the following examples
    will look at how we would do the same directives using both Razor syntax and code-behind.
  prefs: []
  type: TYPE_NORMAL
- en: Adding an attribute
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add an attribute to our page, we can use the `attribute` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'If we were using a code-behind file, we would use the following syntax instead:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Adding an interface
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To implement an interface (`IDisposable` in this case), we would use the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: Then, we would implement the methods the interface needs in a `@code{}` section.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do the same in a code-behind scenario, we would add the interface after
    the class name, as shown in the following example:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: Inheriting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To inherit another class, we should use the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'To do the same in a code-behind scenario, we would add the class we want to
    inherit from after the class name:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: Generics
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can define our component as a generic component.
  prefs: []
  type: TYPE_NORMAL
- en: Generics allow us to define the data type, so the component works with any data
    type.
  prefs: []
  type: TYPE_NORMAL
- en: 'To define a component as a generic component, we add the `@typeparam` directive;
    then, we can use the type in the code of the component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: Generics are super-powerful when creating reusable components; this will make
    our components reusable for different data types. We will return to generics in
    *Chapter 6*, *Building Forms with Validation*.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the layout
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'If we want to have a specific layout for a page (not the default one specified
    in the `Routes.razor` file), we can use the `@layout` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: This way, our component will use the specified layout (this only works for components
    with the `@page` directive).
  prefs: []
  type: TYPE_NORMAL
- en: Setting a namespace
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'By default, the component’s namespace will be the name of the default namespace
    of our project, plus the folder structure. If we want our component to be in a
    specific namespace, we can use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Setting a route
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'We have already touched on the `@page` directive. If we want our component
    to be directly accessed using a URL, we can use the `@page` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The URL can contain parameters, subfolders, and much more, which we will return
    to later in this chapter.
  prefs: []
  type: TYPE_NORMAL
- en: Adding a using statement
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a namespace to our component, we can use the `@using` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: If there are namespaces that we use in several of our components, then we can
    add them to the `_Imports.razor` file instead. This way, they will be available
    in all the components we create.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you want to dive further into directives, you can find more information
    here: [https://learn.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-8.0#directives](https://learn.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-8.0#directives)'
  prefs: []
  type: TYPE_NORMAL
- en: Now we know more about how Razor syntax works. Don’t worry; we will have plenty
    of time to practice it. There is one more directive that I haven’t covered in
    this section, and that is `inject`. We first need to understand what **Dependency
    Injection** (**DI**) is and how it works, which we will see in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding dependency injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: DI is a software pattern and a technique to implement **Inversion of Control**
    (**IoC**).
  prefs: []
  type: TYPE_NORMAL
- en: IoC is a generic term that means we can indicate that the class needs a class
    instance instead of letting our classes instantiate an object. We can say that
    our class wants either a specific class or a specific interface.
  prefs: []
  type: TYPE_NORMAL
- en: The creation of the class is somewhere else, and it is up to IoC what class
    it will create.
  prefs: []
  type: TYPE_NORMAL
- en: When it comes to DI, it is a form of IoC when an object (class instance) is
    passed through constructors, parameters, or service lookups.
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is a great resource if you want to dive deeper into DI in .NET: [https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection](https://learn.microsoft.com/en-us/dotnet/core/extensions/dependency-injection).'
  prefs: []
  type: TYPE_NORMAL
- en: 'In Blazor, we can configure DI by providing a way to instantiate an object;
    this is a key architecture pattern that we should use. We have already seen a
    couple of references to it, for example, in `Program.cs`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we say that if any class wants `IBlogApi`, the application should instantiate
    an object of the `BlogApiJsonDirectAccess` type. In this case, we are using an
    interface; instead, we could just say:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: In this case, when we ask for a `BlogApiJsonDirectAccess` object, it will return
    an object of that type. If there only is one implementation of the thing we are
    building, there is no reason to create an interface for it. In the previous chapter,
    *Chapter 3*, *Managing State – Part 1*. We created an `IBlogApi` interface that
    returned an instance of `BlogApiJsonDirectAccess`. When we implement the WebAssembly
    version, DI will return another class instead.
  prefs: []
  type: TYPE_NORMAL
- en: There are many advantages to using DI. Our dependencies are loosely coupled,
    so we don’t instantiate another class in our class. Instead, we ask for an instance,
    which makes it easier to write tests and change implementations depending on platforms.
  prefs: []
  type: TYPE_NORMAL
- en: Any external dependencies will be much more apparent since we must pass them
    into the class. We also can set the way we should instantiate the object in a
    central place. We configure the DI in `Program.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can configure the creation of objects in different ways, such as the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Scoped
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Transient
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Singleton
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we use a singleton, the object will be the same for all site users. The
    object will only be created once.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure a singleton service, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: We should use a singleton when we want to share our object with all the users
    of our site, but beware because since the state is shared, it can lead to issues
    if the object stores data specific to an individual user or a session because
    once this data is changed by one user, the change is reflected for all users who
    might be using the application simultaneously. It may also lead to data being
    shared unintentionally.
  prefs: []
  type: TYPE_NORMAL
- en: Scoped
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we use scoped, a new object will be created once for each connection, and
    since Blazor Server needs a connection to work, it will be the same object as
    long as the user has a connection. WebAssembly does not have the concept of scoped,
    since there is no connection, so all the code runs inside the user’s web browser.
    If we use scoped, it will work the same way as a singleton for Blazor WebAssembly,
    since we only have one user and everything is running inside the browser. The
    recommendation is still to use scoped if the idea is to scope a service to the
    current user. This makes it easier to move code between Blazor Server and Blazor
    WebAssembly and gives a bit more context on how the service is supposed to be
    used.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure a scoped service, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: We should use scoped if we have data that belongs to the user. We can keep the
    user’s state by using scoped objects. More on that in *Chapter 11*, *Managing
    State – Part 2*.
  prefs: []
  type: TYPE_NORMAL
- en: It’s worth mentioning here that the new “per component” model will create a
    SignalR connection if there is any component currently running in InteractiveServer
    mode. If we navigate to a new page without any `InteractiveServer` components,
    the connection will eventually be disconnected. This means that the state will
    also be removed. So, when using the “per component” model, we need to make sure
    not to save any important information in a scoped variable unless we persist it
    in some other way as well.
  prefs: []
  type: TYPE_NORMAL
- en: Transient
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: When we use transient, a new object will be created every time we ask for it.
  prefs: []
  type: TYPE_NORMAL
- en: 'To configure a transient service, use the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: We can use transient if we don’t need to keep any state, and we don’t mind the
    object being created every time we ask for it.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we know how to configure a service, we need to start using the service
    by injecting it.
  prefs: []
  type: TYPE_NORMAL
- en: Injecting the service
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are three ways to inject a service. We can use the `@inject` directive
    in the Razor file:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: This will make sure we have access to `WeatherForecastService` in our component.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second way is to create a property by adding the `Inject` attribute if
    we are using code-behind:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: 'The third way is for when we want to inject a service into another service
    – then, we need to inject the services using the constructor:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: Now we know how DI works and why we should use it. In .NET 7, using a scoped
    service meant that the data was accessible as long as the connection (or circuit)
    was active. But with .NET 8, it changes just slightly depending on the render
    mode. Let’s look at that next.
  prefs: []
  type: TYPE_NORMAL
- en: Changing the render mode
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The biggest change when it comes to .NET 8 is the ability to change render mode
    in the same app. In .NET 7, we had to choose one or the other, but with .NET 8,
    we can change it as we see fit. Perhaps if a specific page is not interactive,
    we can use the new **Server-Side Rendering** (**SSR**). This is very similar to
    WebForms or MVC. The page gets rendered on the server. No additional interactivity
    will work. We can set the render mode on each component, or we can do it when
    we use the component. When we create the project, we select what interactive render
    mode we want.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s take a look at the different options:'
  prefs: []
  type: TYPE_NORMAL
- en: '**None** – No interactivity, only static rendered files, no SignalR, and no
    WebAssembly. Using this option, we can use both static SSR and streaming server-side
    rendering.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Server** – This will give us access to interactivity using Blazor Server,
    not WebAssembly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**WebAssembly** – This will give us access to interactivity using Blazor WebAssembly,
    not Blazor Server.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Auto** (Server and WebAssembly) – Gives us the ability to use both Server
    and WebAssembly.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We also set **Interactivity location** to **Per page/component**, which means
    that the default behavior of the site is static, and we need to specify on each
    component if we want to use interactivity. We can also set it to **Global**, which
    will set the interactivity on the `Routes` component like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the render mode per component, we can use the syntax above or use
    the attribute we saw in the Counter component:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: 'By default, all components are rendered using server pre-rendering. This means
    that the component is first rendered on the server and then pushed to the web
    browser. SignalR or WebAssembly starts up, and the component is rendered again,
    making additional calls to the database, for example. I personally rarely use
    server pre-rendering. I like that the pages load by first sending what the server
    has ready and then, when database calls are done, sends the rest. We can also
    disable pre-rendering by doing it like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: We will have plenty of time to learn more about render modes during the course
    of the book. In .NET 7, we had more templates, but by using combinations of these
    settings, we can create the same scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: '| .NET 7 Template | .NET 8 Template | Interactive render mode | Interactivity
    location |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor Server App | Blazor Web App | Server | Global |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor WebAssembly App | Blazor WebAssembly Standalone App |  |  |'
  prefs: []
  type: TYPE_TB
- en: '| Blazor WebAssembly (ASP.NET Core Hosted) | Blazor Web App | WebAssembly |
    Global |'
  prefs: []
  type: TYPE_TB
- en: If you are new to Blazor, this table has no significance, but if you have worked
    with Blazor in .NET 7 and want to use a project template that you have used in
    .NET 7, this is how to do it. In this chapter, we have mentioned code-behind a
    couple of times. In the next section, we will look at how we can use code-behind
    with Razor files and skip the Razor files altogether.
  prefs: []
  type: TYPE_NORMAL
- en: Figuring out where to put the code
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have seen examples of writing code directly in the Razor file. I prefer doing
    that unless the code gets too long or too complicated. I always lean in favor
    of readability.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are four ways we can write our components:'
  prefs: []
  type: TYPE_NORMAL
- en: In the Razor file
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In a partial class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Inheriting a class
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Only code
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s go through each item on this list in more detail.
  prefs: []
  type: TYPE_NORMAL
- en: In the Razor file
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we are writing a file that is not that complex, it would be nice not to switch
    files when writing components. As we already covered in this chapter, we can use
    the `@code` directive to add code directly to our Razor file.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to move the code to a code-behind file, then it is only the directives
    that we need to change. For the rest of the code, we can just move to the code-behind
    class. When I started with Blazor, writing code and markup in the same file felt
    strange, coming from an MVC world where the separation between code and markup
    is a big part of the way to use MVC. But I suggest you try it out when developing
    your web apps.
  prefs: []
  type: TYPE_NORMAL
- en: At work, we started using code-behind but switched to writing code in the `.razor`
    file instead, and we haven’t looked back since.
  prefs: []
  type: TYPE_NORMAL
- en: However, many developers prefer code-behind, separating code from the layout.
    For that, we can use a partial class.
  prefs: []
  type: TYPE_NORMAL
- en: In a partial class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can create a partial class with the same filename as the Razor file and add
    `.cs`.
  prefs: []
  type: TYPE_NORMAL
- en: If you have downloaded the source code (or you can check the code on GitHub),
    you can look at `WeatherCodeBehind.razor.cs` in the `Examples` folder. I have
    moved all the code to the code-behind file; the result when compiling this will
    be the same as if we kept the code in the Razor file. It is just a matter of preference.
  prefs: []
  type: TYPE_NORMAL
- en: 'The code-behind looks like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: Since we are using a partial class, there is no need to connect the razor with
    the code-behind. If it has the same name, it will just work. We can mix where
    we put the code; in this case, we have the `StreamingRendering` attribute in the
    code-behind, and we can keep it in the `.razor` file if we want to. If you prefer
    using code-behind, this is the way you want to do it.
  prefs: []
  type: TYPE_NORMAL
- en: This is not the only way to use a code-behind file; we can also inherit from
    a code-behind file.
  prefs: []
  type: TYPE_NORMAL
- en: Inheriting a class
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We can also create a completely different class (the common pattern is to call
    it the same thing as the Razor file and add `Model` at the end) and inherit it
    in our Razor file. For that to work, we need to inherit from `ComponentBase`.
    In the case of a partial class, the class already inherits from `ComponentBase`,
    since the Razor file does that.
  prefs: []
  type: TYPE_NORMAL
- en: Fields must be protected or public (not private) for the page to access the
    fields. I recommend using the partial class if we don’t need to inherit from our
    base class.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a snippet of the code-behind class declaration:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: We’ll need to inherit from `ComponentBase` or from a class that inherits from
    `ComponentBase`.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the Razor file, we will use the `@inherits` directive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: The Razor file will now inherit from our code-behind class (this was the first
    way available to create code-behind classes).
  prefs: []
  type: TYPE_NORMAL
- en: Both the partial and inherit options are simple ways of moving the code to a
    code-behind file. Inheriting a model was the first available way, but as I mentioned,
    use partial classes instead if you prefer code-behind. But another option is to
    skip the Razor file and use only code entirely.
  prefs: []
  type: TYPE_NORMAL
- en: Only code
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Visual Studio will use source generators to convert the Razor code into C#.
    We will dig deeper into source generators in *Chapter 17*, *Examining Source Generators*.
    The Razor file will generate code at compile time. We can skip the Razor step
    if we want to and write our layout completely in code.
  prefs: []
  type: TYPE_NORMAL
- en: This file (`CounterWithoutRazor.cs`) is available on GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: 'The counter example would look like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: The Razor file will first be converted into something roughly the same as the
    previous code, and then the code is compiled. It adds the elements one by one,
    which, in the end, will render the HTML.
  prefs: []
  type: TYPE_NORMAL
- en: The numbers in the code are how Blazor keeps track of each element in the render
    tree. Some prefer to write the code as in the previous code block rather than
    using the Razor syntax; there are even efforts in the community to simplify the
    process of manually writing the `BuildRenderTree()` function.
  prefs: []
  type: TYPE_NORMAL
- en: Some of Microsoft’s built-in components are built in this way.
  prefs: []
  type: TYPE_NORMAL
- en: I recommend never writing this manually, but I’ve kept it in the book because
    it shows how Razor files get compiled. Now that we know how to use code-behind,
    let’s look at the lifecycle events of Blazor and when they get executed.
  prefs: []
  type: TYPE_NORMAL
- en: Lifecycle events
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We can use a couple of lifecycle events to run our code. In this section, we
    will go through them and see when we should use them. Most lifecycle events have
    two versions – synchronous and asynchronous.
  prefs: []
  type: TYPE_NORMAL
- en: OnInitialized and OnInitializedAsync
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first time the component is loaded, `OnInitialized()` is called, then `OnInitializedAsync()`.
    This is a great method to load any data, as the UI has not yet been rendered.
    If we are doing long-running tasks (such as getting data from a database), we
    should put that code in the `OnInitializedAsync()` method.
  prefs: []
  type: TYPE_NORMAL
- en: These methods will only run once. If you want to update the UI when a parameter
    changes, see `OnParametersSet()` and `OnParametersSetAsync()`.
  prefs: []
  type: TYPE_NORMAL
- en: OnParametersSet and OnParametersSetAsync
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`OnParametersSet()` and `OnParametersSetAsync()` are called when the component
    is initialized (after `OnInitialized()` and `OnInitializedAsync()`) and whenever
    we change the value of a parameter.'
  prefs: []
  type: TYPE_NORMAL
- en: If we, for example, load data in the `OnInitialized()` method but it uses a
    parameter, the data won’t be reloaded if the parameter is changed since `OnInitialized()`
    will only run once. We need to trigger a reload of the data in `OnParametersSet()`
    or `OnParametersSetAsync()` or move the loading to that method.
  prefs: []
  type: TYPE_NORMAL
- en: OnAfterRender and OnAfterRenderAsync
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: After the component renders, the `OnAfterRender()` and `OnAfterRenderAsync()`
    methods are called. When the methods are called, all the elements are rendered,
    so if we want/need to call any JavaScript code, we have to do that from these
    methods (we will get an error if we try to make a JavaScript interop from any
    of the other lifecycle event methods). This is a limitation of the prerendering.
    When the component prerenders, there is nothing connected to the web browser,
    and we will not be able to run any JavaScript. However, if we disable the prerendering,
    we can run JavaScript in the other lifecycle methods as well. We also have access
    to a `firstRender` parameter, so we can only run our code on the first render.
  prefs: []
  type: TYPE_NORMAL
- en: ShouldRender
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '`ShouldRender()` is called when our component is re-rendered; if it returns
    `false`, the component will not be rendered again. The component will always render
    once, even if this method returns `false`.'
  prefs: []
  type: TYPE_NORMAL
- en: '`ShouldRender()` does not have an asynchronous option.'
  prefs: []
  type: TYPE_NORMAL
- en: Now we know when the different lifecycle events happen and in what order. A
    component can also have parameters, and that way, we can reuse them but with different
    data.
  prefs: []
  type: TYPE_NORMAL
- en: Parameters
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'A parameter makes it possible to send a value to a component. To add a parameter
    to a component, we use the `[Parameter]` attribute on the `public` property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: 'The syntax for this is the same if we use a code-behind file. We can add a
    parameter to the route using the `@page` directive by specifying it in the route:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: In this case, we have to have a parameter specified with the same name as the
    name inside the curly braces. To set the parameter in the `@page` directive, we
    go to `/parameterdemo/THEVALUE`.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are cases where we want to specify another type instead of a string (string
    is the default). We can add the data type after the parameter name like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: This will match the route only if the data type is an integer. We can also pass
    parameters using cascading parameters. We can also have more than one page directive
    per component if we want to handle more than one route.
  prefs: []
  type: TYPE_NORMAL
- en: Cascading parameters
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: If we want to pass a value to multiple components, we can use a cascading parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'Instead of using `[Parameter]`, we can use `[CascadingParameter]` like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: 'To pass a value to the component, we surround it with a `CascadingValue` component
    like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: '`CascadingValue` is the value we pass to the component, and `CascadingParameter`
    is the property that receives the value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As we can see, we don’t pass any parameter values to the `ComponentWithCascadingParameter`
    component; the cascading value will match the parameter with the same data type.
    If we have multiple parameters of the same type, we can specify the name of the
    parameter in the component with the cascading parameter like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs: []
  type: TYPE_PRE
- en: 'We can also do so for the component that passes `CascadingValue`, like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs: []
  type: TYPE_PRE
- en: 'If we know that the value won’t change, we can specify that by using the `IsFixed`
    property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs: []
  type: TYPE_PRE
- en: This way, Blazor won’t look for changes, which is more efficient if we know
    the values won’t change. The cascading values/parameters cannot be updated upward
    but are updated only downward. This means that to update a cascading value, we
    need to implement it in another way; updating it from inside the component won’t
    change any components that are higher in the hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 5*, *Creating Advanced Blazor Components*, we will look at events,
    which are one way to solve the problem of updating a cascading value.
  prefs: []
  type: TYPE_NORMAL
- en: Phew! This has been an information-heavy chapter, but now we know the basics
    of Blazor components. Now, it is time to build one!
  prefs: []
  type: TYPE_NORMAL
- en: Writing our first component
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The first component we will build shows all the blog posts on a site. To be
    fair, we haven’t written any blog posts yet, but we will temporarily solve that
    so we can start doing something fun.
  prefs: []
  type: TYPE_NORMAL
- en: In *Chapter 3*, *Managing State – Part 1*, we created a JSON repository and
    an API (or interface); now, it is time to use them.
  prefs: []
  type: TYPE_NORMAL
- en: We will share the code between the `BlazorWebApp` project and the `BlazorWebApp.Client`
    project. We will even change the implementation of how they run depending on whether
    they run as WebAssembly or not.
  prefs: []
  type: TYPE_NORMAL
- en: There is a whole chapter on sharing (*Chapter 9*, *Sharing Code and Resources*),
    but let’s start now.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a components library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we need to do is to create a new project and then add our components
    to that project. We could have added the components to the `BlazorWebApp` or the
    `BlazorWebApp.Client` project directly, but this demonstrates how we can build
    reusable components and distribute them as packages later on.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create our first component, follow these instructions:'
  prefs: []
  type: TYPE_NORMAL
- en: Right-click on the **MyBlog** solution and select **Add** | **New Project**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find the template **Razor Class Library** and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the project `SharedComponents` and click **Next**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select **.NET 8.0** and click **Create**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We now have a project called `SharedComponents`, where we can add all the components
    we want to share. Remove `Component1.razor` and `ExampleJsInterop.cs` that are
    created by default.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, add a project reference to `Data.Models`
    and add the `Nuget` package reference to `Microsoft.AspNetCore.Components.Web`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have a new project. This is where we can share components. Right now, we
    don’t have any components to share, but that is what we will do next.
  prefs: []
  type: TYPE_NORMAL
- en: Using our components library
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We have a nice library, but for our project to trigger when we navigate to a
    route, we need to add additional assemblies to the router.
  prefs: []
  type: TYPE_NORMAL
- en: 'To do that, we need to follow a couple of steps:'
  prefs: []
  type: TYPE_NORMAL
- en: We already have a Home component in the `BlazorWebApp` project so let’s delete
    that one. In the `Components/Pages` folder, delete the `Home.razor` file.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We need a component to navigate to. In the `SharedComponents` project, in the
    Pages folder, we need to create a new component. You can select the folder or
    project node in the solution explorer and press *Shift* + *F2*, type `Home.razor`,
    and press *Enter*. This is the fastest way to create new components.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `BlazorWebApp` project, add a project reference to the `SharedComponents`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Also in the `BlazorWebApp.Client` project, add a project reference to the `SharedComponents`
    project.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, we have access to the shared components in both the WebAssembly project
    (`BlazorWebApp.Client`) and the `BlazorWebProject`. This means that we can run
    any component we put into the shared project (`SharedComponents`) as `InteractiveWebAssembly`
    or `InteractiveServer`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Open `Router.razor`. It looks like this:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'The router defines where to look for components. `AppAssembly` is where it
    will look first. We can also add additional assemblies, and as we can see, we
    already have an additional assembly. We are referencing the `BlazorWebbApp.Client`
    project so that we can pre - render and server render (SignalR) the Counter component.
    But now we want to add an additional assembly. Change the router to this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add the new assembly to additional assemblies. The router will now look for
    components in the `SharedComponents` assembly as well.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We also have to add a row in `Program.cs`. In the `BlazorWebApp` project, open
    `Program.cs`. There, you will find these lines:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'We need to add the new assembly there as well, like this:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE56]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We need to add additional assemblies in the `Program.cs` as well to get server-side
    rendering to work. Great! We have all components in a separate library and are
    sharing the components between the `BlazorWebApp` and the `BlazorWebApp.Client`
    projects.
  prefs: []
  type: TYPE_NORMAL
- en: Creating our own component
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now it’s time to start adding our own component!
  prefs: []
  type: TYPE_NORMAL
- en: 'OK, this is not completely true because we will continue working on `Home.razor`.
    Let’s start by creating a component that lists our blog posts:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `SharedComponents` project, open `Home.razor`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Replace the contents of that file with the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE57]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: If we start from the top, we can see a page directive. It will ensure that the
    component is shown when the route is “`/`". Then, we have three `@using` directives,
    bringing in the namespaces so we can use them in the Razor file.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Then we inject our API (using DI) and name the instance `_api`.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Add a variable that holds all our posts. In the `code` section, add the following:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE58]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, we need to load the data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'To load posts, add the following in the `code` section:'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: '[PRE59]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Now, when the page loads, the posts will be loaded as well: `10` posts and
    page `0` (the first page).'
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'Under the `@inject` row, add the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE60]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: We add an **Unordered List** (**UL**); inside that, we loop over blog posts
    and show the title.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can run the application by pressing *Ctrl* + *F5* (**Debug** | **Start
    Without Debugging**). Make sure you have the `BlazorWebApp` selected as the startup
    project.
  prefs: []
  type: TYPE_NORMAL
- en: Since we don’t have any blog posts, this would take us to an empty page. Luckily,
    there is a folder in the repo called `ExampleData`. If you download that, put
    those files in the `Data` folder that we created in *Chapter 3*, *Managing State
    – Part 1*, and reload the web, you should see a couple of posts.
  prefs: []
  type: TYPE_NORMAL
- en: Great job, we have created our first component!
  prefs: []
  type: TYPE_NORMAL
- en: There are a few noteworthy things. The `SharedComponents` project knows nothing
    about the JSON repository implementation and only knows about the `IBlogApi` interface.
  prefs: []
  type: TYPE_NORMAL
- en: The `Home` component asks for an instance of `IBlogApi`, and the `BlazorWebApp`
    project knows it should return an instance of `BlogApiJsonDirectAccess`. This
    is one of the things I love about Blazor; we can create components that only consume
    an interface and know nothing about the implementation.
  prefs: []
  type: TYPE_NORMAL
- en: We will return to this when we implement a web API for WebAssembly in *Chapter
    7*, *Creating an API*.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we learned a lot about Razor syntax – something we will use
    throughout the book. We learned about DI, directives, and parameters and, of course,
    created our first component. This knowledge will help us understand how to create
    and reuse components.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will look at more advanced component scenarios.
  prefs: []
  type: TYPE_NORMAL
