- en: '11'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Continuing the FPS Game
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187), we made some updates to
    our GDD for our new 3D FPS game. We added specific details about the level design,
    which helped us to create the habitat’s interior-level environment using a grayboxing
    kit of modular parts that *snap* together. We also used Unity **ProBuilder** to
    draw out a level map.
  prefs: []
  type: TYPE_NORMAL
- en: We finished by learning how to quickly add an FPS player character to our game
    by utilizing the **Unity Starter Assets First Person Character Controller**. We
    added the health system and healing pickups to engage the player’s abilities by
    reusing previous systems and code. We also refactored to 3D API method counterparts
    to make an animated door that opens when the player triggers it.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will update and finalize the 3D environment with polished
    assets, scatter objects to increase realism, and incorporate wear-and-tear effects.
    Additionally, we will improve the lighting to create an immersive experience for
    the player and ensure optimal game performance.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we’re going to cover the following main topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Decorating the 3D environment
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Immersing the player using Polybrush and Decals
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Lighting design – Probes, Decals, light baking, and performance
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: By the end of this chapter, you will have the skills to enhance a 3D environment
    by replacing **Prefabs** and materials, increase realism and immerse the player
    by decorating the environment using Unity artist tools such as **Polybrush** and
    **Decals**, and bake lighting along with techniques to overcome limitations for
    lighting and shadows of dynamic objects in the scene. Additionally, you will gain
    knowledge on performance considerations related to lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To follow along with the same artwork that was created for the project in this
    book, download the assets from GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets).
  prefs: []
  type: TYPE_NORMAL
- en: You can download the complete project from GitHub at [https://github.com/PacktPublishing/Unity-2022-by-Example](https://github.com/PacktPublishing/Unity-2022-by-Example).
  prefs: []
  type: TYPE_NORMAL
- en: To follow along with your own 3D artwork, you’ll need to create similar artwork
    using 3D modeling and texturing software (for example, Blender, Maya, 3ds Max,
    Cinema 4D, ZBrush, Silo, Substance 3D Painter, Quixel Mixer, or 3DCoat).
  prefs: []
  type: TYPE_NORMAL
- en: Decorating the 3D environment
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Our 3D FPS game is well on its way to becoming something of a real game, but
    it must graduate from its graybox environment first if we want it to be attractive
    to potential players. This section will explore Unity 2022 features for replacing
    the graybox kit module’s Prefabs with polished and textured 3D mesh Prefabs that
    properly represent our habitat’s interior environment.
  prefs: []
  type: TYPE_NORMAL
- en: We’ll not only replace the existing graybox Prefabs but also introduce new assets
    to decorate the environment to make it feel more complete and lived-in. This will
    be a combination of both 3D models and textures that we’ll apply in different
    ways, again, using Unity’s artist feature tooling (specific to **Universal RP**).
  prefs: []
  type: TYPE_NORMAL
- en: 'Here is an example of what our interior habitat environment – which has gone
    through the processes outlined in this chapter – will look like:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.1 – Habitat interior scene lighting](img/B18347_11_1.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.1 – Habitat interior scene lighting
  prefs: []
  type: TYPE_NORMAL
- en: Our first order of business is to replace those boring graybox Prefabs. Having
    the environment look correct will help with the following steps as we decorate
    and detail it.
  prefs: []
  type: TYPE_NORMAL
- en: Updating and replacing Prefabs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Replacing Prefabs is more of a structured approach to dealing with the art assets;
    since we’re working with fixed modular parts, the art is in creating polished
    3D assets. In this case, we’re going to be using 3D assets produced by my friends
    over at Polypix Studios ([https://polypixstudios.com/](https://polypixstudios.com/)).
  prefs: []
  type: TYPE_NORMAL
- en: Note of gratitude
  prefs: []
  type: TYPE_NORMAL
- en: Miguel Dumars was kind enough to provide select assets from their *Neon Street*
    and *Stylized Scifi Modular Corridor* Unreal kits for use in this Unity project,
    and I’m very excited to be working with these assets!
  prefs: []
  type: TYPE_NORMAL
- en: Polypix Studios has permitted the use of the provided game art for learning
    purposes only; commercial use is strictly prohibited. Polypix Studio’s portfolios
    can be viewed on ArtStation at [https://www.artstation.com/polypixcc](https://www.artstation.com/polypixcc)
    and Unreal Marketplace at [https://www.unrealengine.com/marketplace/en-US/profile/Polypix+Studios](https://www.unrealengine.com/marketplace/en-US/profile/Polypix+Studios).
  prefs: []
  type: TYPE_NORMAL
- en: To get started, let’s import the Polypix artwork.
  prefs: []
  type: TYPE_NORMAL
- en: Importing and reviewing the assets
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: You should be a pro in the process of importing assets into Unity projects by
    now, so we won’t waste any time detailing each little step. Download the 3D art
    assets file, `3DArtwork.zip`, from this book’s GitHub repository (link in the
    *Technical requirements* section) to a temporary directory, then import the `.unitypackage`
    files into your current 3D FPS project.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 11**.2*, we can see the new modular kit parts in the **Polypix Modular
    Kit** scene provided in the package:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Polypix Studios modular kit](img/B18347_11_2.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.2 – Polypix Studios modular kit
  prefs: []
  type: TYPE_NORMAL
- en: 'Since this is the first time we’re working with third-party 3D assets, let’s
    have a look at the files that were imported into the `Assets/Polypix 3D Assets/Modular
    Kit` folder (also shown in *Figure 11**.2*):'
  prefs: []
  type: TYPE_NORMAL
- en: '**Materials**: These materials are applied and shared across 3D models of the
    same category (walls, doorways, and so on). The same material is shared across
    several models to keep things more optimized as this reduces draw calls for the
    renderer (that is, it’s less work, resulting in higher FPS).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Models**: These are the optimized polygon meshes (vertices, edges, and faces)
    that make up the 3D geometry representing the shape of the objects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Prefabs** (yes, I know you know what Prefabs are): These are the Polypix
    models with the materials applied and colliders added as finished objects we can
    use directly in our game.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Textures**: Textures are the image files that are mapped onto the 3D geometry
    via assignment to the material that’s applied to 3D geometry to give it color
    and details.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We’ll mainly be concerned with the Prefabs since we’ll use them to replace the
    initial graybox kit modular parts we made to build the level. In the `/Prefabs`
    folder, we have the same graybox wall assets but all textured and fancy.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let’s see how we can rapidly replace the modular graybox kit Prefabs with
    this new artwork.
  prefs: []
  type: TYPE_NORMAL
- en: Replacing Prefab instances
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: With the replacement art assets imported into the project, we can go ahead and
    start replacing Prefabs. Unity 2022 has introduced some new Prefab workflow features
    and **Search**, which will greatly help us in this endeavor.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity Blog
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity’s new Prefab workflow features go far beyond simple Prefab replacement,
    transfer overrides, reconnecting Prefabs, and inspecting Prefab Variant relationships.
    You can read about these additional features in the following Unity Blog article:
    *What’s new for Prefabs in* *2022.2?* [https://blog.unity.com/engine-platform/prefabs-whats-new-2022-2](https://blog.unity.com/engine-platform/prefabs-whats-new-2022-2).'
  prefs: []
  type: TYPE_NORMAL
- en: Unity Blog is a fantastic resource for learning content! I highly recommend
    regularly consuming Unity’s blog articles to rapidly broaden your knowledge and
    elevate your understanding of what Unity is capable of.
  prefs: []
  type: TYPE_NORMAL
- en: We will use the following process as much as possible to mass-replace the Prefabs
    in our level. However, we’ll no doubt still have to make some manual adjustments
    to some of the layout’s finer details – due to some changes in the art direction
    (that may or may not have been my fault).
  prefs: []
  type: TYPE_NORMAL
- en: Some of the Prefabs that we’ve added behavior to already are examples of Prefabs
    that we must manually update and cannot simply replace in the scene with new art,
    but we’ll still be able to merely replace the art within the Prefab because we’ve
    maintained keeping the *graphics* as separate child objects in the Prefab (as
    you may recall, we’ve been using this practice throughout this book thus far,
    and this is just another example of the benefit of being consistent in terms of
    our approach).
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s get to it and make our first Prefab replacement. We’ll replace the `Wall
    1` graybox Prefab in the scene with the `Wall 1` Prefab from the Polypix `/Prefabs`
    folder. We’ll use both the new **Search** feature as well as the **Prefab Replace**
    workflow by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Search** by going to **Window** | **Search** | **New Window**, clicking
    the **Open in Search** button at the top of the **Hierarchy** window, or pressing
    *Ctrl*/*Cmd* + *K*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In the `Wall 1` with quotes to search explicitly for this string (removing the
    quotes will search for all occurrences; note that **Search** is not case sensitive).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Select the **Hierarchy** tab to filter the search to only objects in the open
    scene **Hierarchy**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now, select all the items in the results list by clicking on the first item,
    then scroll to the bottom and hold *Shift* and click the last item.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Right-click and click **Select** (or hit the *Enter* key):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.3 – Unity Search for easy scene Prefab selection](img/B18347_11_3.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.3 – Unity Search for easy scene Prefab selection
  prefs: []
  type: TYPE_NORMAL
- en: 'With all of the `Wall 1` Prefabs in the scene now selected, we can easily replace
    them with **Prefab Replace** – which is only a two-step process:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Right-click one of the selected `Wall 1` Prefabs in the **Hierarchy** area,
    then select **Prefab |** **Replace…**:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Prefab – replace instance selection](img/B18347_11_4.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.4 – Prefab – replace instance selection
  prefs: []
  type: TYPE_NORMAL
- en: 'Select the replacement Prefab in the `Assets/Polypix 3D Assets/Modular Kit/Prefabs`
    folder (using *Table 11.1* as a reference):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Selecting the replacement Prefab](img/B18347_11_5.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.5 – Selecting the replacement Prefab
  prefs: []
  type: TYPE_NORMAL
- en: 'You can use the replacements indicated in the following table for the graybox
    kit Prefab and corresponding Polypix imported Prefab as a guide:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Greybox Prefab** | **Polypix Prefab** |'
  prefs: []
  type: TYPE_TB
- en: '| --- | --- |'
  prefs: []
  type: TYPE_TB
- en: '| `Wall 1` | `Wall_01 Variant` |'
  prefs: []
  type: TYPE_TB
- en: '| `Wall 2` | `Wall_02 Variant` |'
  prefs: []
  type: TYPE_TB
- en: '| `Wall 4` | `Wall_04 Variant` |'
  prefs: []
  type: TYPE_TB
- en: '| `Doorway 1` | `Doorway_01 Variant` |'
  prefs: []
  type: TYPE_TB
- en: Table 11.1 – Replacement graybox Prefabs
  prefs: []
  type: TYPE_NORMAL
- en: New to Unity 2022 – 3D models are Prefabs
  prefs: []
  type: TYPE_NORMAL
- en: You might be wondering why the Polypix replacement Prefabs listed in *Table
    11.1* all have *Variant* in their naming. Well, that’s because you can no longer
    make original Prefabs from 3D models (for example, FBX files). Unity now imports
    3D models as **Model Prefabs**, so when you create a Prefab out of a 3D model,
    it must be a **Prefab Variant**. This change goes a long way to help ensure we
    don’t break Prefab content for our 3D model assets.
  prefs: []
  type: TYPE_NORMAL
- en: Since all of the Polypix assets have been pre-produced in Unity for immediate
    use in our scene with the proper materials, textures, scale, and so on and re-saved,
    they become variants of the original 3D Model Prefabs.
  prefs: []
  type: TYPE_NORMAL
- en: '*Figure 11**.6* shows the results of my efforts in doing these simple Prefab
    replacement steps for the walls and doorway listed in *Table 11.1*. The job of
    updating the artwork is already more than halfway done! Easy-peasy:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Wall Prefabs replaced in the scene](img/B18347_11_6.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.6 – Wall Prefabs replaced in the scene
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Note that in my level design, I found that I could not use all the replacements
    directly with the finished artwork and instead changed some of the wall modules
    out for different ones. So, your mileage may vary as well. It’s all part of the
    design process; much like coding, it’s an iterative process.
  prefs: []
  type: TYPE_NORMAL
- en: Just repeat the preceding steps to replace all the static graybox modular parts
    – *static* means these are structural and don’t contain any behavior, interactivity,
    or animation. We’ll address the `Door_Triggered` Prefab next since it has animation
    and won’t be directly replaced.
  prefs: []
  type: TYPE_NORMAL
- en: These additional updates on the graybox kit parts will occur in **Prefab Edit
    Mode**, but we’ll still simply replace the *graphics* with the updated artwork.
  prefs: []
  type: TYPE_NORMAL
- en: Updating the existing modular Prefabs
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Some Prefabs, such as `Doorway_Trigger`, cannot just be replaced because they
    have the behavior we added in the form of a collider-triggered animation. Using
    this as an example workflow, let’s update `Doorway_Trigger` by performing the
    following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `Door_Triggered` Prefab in **Prefab Edit Mode** for direct editing.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Add the `Door_Trigger` `/``Prefabs` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Reconnect the animation for the new `Sliding_Door_01` object that replaced the
    `Door` object’s animation – ensure you disable or delete the `Door` object since
    we’re replacing it and don’t need it anymore.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Update `TriggeredEvent.OnTriggered()` `Animator.Play(string)` to reference
    the new `Sliding_Door_01` object that replaced the `Door` object so that our `Door-open`
    animation will still be functional on the new door mesh. Remember that the string
    value for the `Animator.Play()` function is the same as the animation’s name:
    *Door-open*.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '*Figure 11**.7* illustrates the refactored setup:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Updating the door trigger Prefab](img/B18347_11_7.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.7 – Updating the door trigger Prefab
  prefs: []
  type: TYPE_NORMAL
- en: I believe this leaves only the **connector** Prefabs that need updating. The
    Polypix assets don’t include direct replacement Prefabs for connectors, so just
    make them yourself! You can create a new connector Prefab by duplicating the original
    graybox asset and then replacing the child graphics – as **nested Prefabs** –
    to create the replacement connector Prefabs.
  prefs: []
  type: TYPE_NORMAL
- en: I won’t provide the steps for this process since you have all the required knowledge
    to accomplish this now. Still, if you get stuck, you can always reference the
    new connector Prefabs in the completed project files in this book’s GitHub repository.
    You’ve got this!
  prefs: []
  type: TYPE_NORMAL
- en: With that, we have replacement Prefabs from Polypix and some new material textures
    we can apply.
  prefs: []
  type: TYPE_NORMAL
- en: Applying new materials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: While we’re doing some art updates, we also have some new materials we can use
    to update our floor planes’ appearance (our `/Materials` folder, we have a **FloorPlate**
    material, so let’s assign that to our map to have it become our textured floor.
  prefs: []
  type: TYPE_NORMAL
- en: 'In *Figure 11**.8*, you can see that I have renamed the **Map** root’s GameObject
    in the **Hierarchy** area to **Floors**. With **Floors** selected, pressing *Shift*
    + *H* will enter **Isolation View** (*A*) – temporarily hiding all the other objects
    in the **Hierarchy** area, which makes it easy for us to assign a new material
    to the selected object by clicking and dragging the **FloorPlate** material (*B*)
    onto a plane in the **Scene** view area:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Updating the floor material](img/B18347_11_8.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.8 – Updating the floor material
  prefs: []
  type: TYPE_NORMAL
- en: Toggle visibility shortcut
  prefs: []
  type: TYPE_NORMAL
- en: Note that you can also use *Alt/Option* + *Shift* + *A* to toggle the visibility
    of the currently selected object.
  prefs: []
  type: TYPE_NORMAL
- en: 'Alternatively, since these planes are ProBuilder objects, we can open the **ProBuilder
    Window** area (**Tools** | **ProBuilder** | **ProBuilder Window**), select **Material
    Editor** from the toolbar, and assign the **FloorPlate** material to the next
    available slot (see *Figure 11**.9*):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – ProBuilder Material Editor assignment](img/B18347_11_9.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.9 – ProBuilder Material Editor assignment
  prefs: []
  type: TYPE_NORMAL
- en: With the material assigned, you can now select all the floor planes in the **Hierarchy**
    area and press the shortcut key assigned to the **FloorPlate** material in one
    shot – in our case, that’s *Alt* + *3*. Simple!
  prefs: []
  type: TYPE_NORMAL
- en: 'While we’re at it with the floor, let’s add a ceiling to our habitat interior
    too! This is quite simple for us now:'
  prefs: []
  type: TYPE_NORMAL
- en: Use **ProBuilder** and create a new plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Scale it to contain all of the rooms in our level, then position its height
    at the top of the wall Prefabs – just where a ceiling should be (in my level,
    this comes out to a Y transform position value of `4`).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the Polypix `/Materials` folder, assign the **CeilingPlate** material to
    the ceiling plane.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Lastly, for the texture to be visible from the bottom of the plane, not the
    top, as is the default and not what we want since our player is below the ceiling
    and looking up at it, in the **ProBuilder** window, click **Flip Normals**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Surface normals
  prefs: []
  type: TYPE_NORMAL
- en: '**Normals** – or **surface normals** – depict the direction a polygon’s surface
    faces (that is, its visible side):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/B18347_11_Collout-Image.jpg)'
  prefs: []
  type: TYPE_IMG
- en: The surface on the left has its normals (the orange lines) pointing up, facing
    the camera so that we can see the texture. In contrast, the surface on the right
    has its normals pointing down and away from the camera, so we cannot see the texture.
  prefs: []
  type: TYPE_NORMAL
- en: And with that, we have our graybox level all updated with polished artwork!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we saw how to replace graybox assets used for prototyping with
    imported polished artwork using Unity’s new **Prefab Workflow** and **Search**.
    We then finished up the interior 3D habitat environment refresh by applying some
    new materials.
  prefs: []
  type: TYPE_NORMAL
- en: Next, since our 3D habitat environment still looks a bit boring, we can quickly
    fix that by scattering some Prefabs about the place.
  prefs: []
  type: TYPE_NORMAL
- en: Immersing the player using Polybrush and Decals
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In contrast to the previous structured method of using fixed, modular parts
    such as Prefab replacements, a more freeform method offers a different perspective
    to the artistic approach. So, instead of relying on prefabricated objects, we’ll
    create dynamic, spontaneous pieces from scratch (well, randomization) using Polybrush.
  prefs: []
  type: TYPE_NORMAL
- en: Painting objects with Polybrush
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: '**Polybrush** offers us an unconstrained way to decorate the environment and
    randomly scatter Prefabs for their placement – so, not modular at all. Considering
    this, we’re only going to cover the **Scatter Objects** feature of Polybrush,
    but know that it has more capabilities than that.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about Polybrush here: [https://unity.com/features/polybrush](https://unity.com/features/polybrush).'
  prefs: []
  type: TYPE_NORMAL
- en: While preparing for writing, I experienced some issues using Polybrush to paint
    objects onto ProBuilder’ized meshes, so while waiting for Unity to respond to
    my bug report concerning this, we’ll continue with a workaround, which is simply
    to enable **Use Additional Vertex Streams** in **Preferences** | **Polybrush**.
    Remember this should you run into any problems with ProBuilder objects! As an
    alternative, you can mesh’ify the ProBuilder objects by selecting them and going
    to **Tools** | **ProBuilder** | **Actions** | **Strip ProBuilder Scripts in Selection**,
    but this also means you will no longer be able to edit the mesh with ProBuilder.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve learned how to avoid issues while painting on specific object
    meshes, let’s paint!
  prefs: []
  type: TYPE_NORMAL
- en: Painting/scattering objects
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: We’ll need some objects to scatter throughout our environment, so if you haven’t
    already, import `Sci_Fi_Assets.unitypackage` from the GitHub artwork download.
    You’ll want to do it now, if not earlier.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, while referencing *Figure 11**.10*, follow these steps to set up the Prefab
    painting:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Polybrush** by going to **Tools** | **Polybrush** | **Polybrush Window**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Click the **Scatter Prefabs on meshes** button (*A* in *Figure 11**.10*).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Drag the `Barrels` and `Trashcan` Prefabs from the `Assets/Polypix 3D Assets/Prefabs`
    folder from the **Project** window to the **Current Palette** section (*B* in
    *Figure 11**.10*):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Polybrush Prefab painting setup](img/B18347_11_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.10 – Polybrush Prefab painting setup
  prefs: []
  type: TYPE_NORMAL
- en: By default, **Hit Surface is Parent** is enabled in the **Polybrush Window**
    area, making all the painted Prefabs a child of the mesh being painted on. In
    *Figure 11**.10*, you can see that I have disabled **Hit Surface is Parent** so
    that all the painted objects can be collected into a single parent **GameObject**
    in the **Hierarchy** area (this is my preference, but you may prefer to have the
    painted objects as children of the mesh they were painted on). If you’re keeping
    this option disabled, once you’ve painted objects throughout the environment,
    ensure you select all the painted objects from the root of the **Hierarchy** area
    and move them into a new, empty *Scattered Objects* root GameObject.
  prefs: []
  type: TYPE_NORMAL
- en: We can now proceed to decorate the environment by using the assets that were
    added to the **Current Palette** area (wearing our *interior designer* hat?).
    First, add the Prefabs for our brush from the **Current Palette** area to the
    **Brush Loadout** selection (as seen in *B* in *Figure 11**.10*) by checking off
    the item (selecting the item in the **Current Palette** area will also produce
    a drop-down section below it where you can adjust settings for how the item should
    be considered for painting).
  prefs: []
  type: TYPE_NORMAL
- en: Painting Prefab objects in the environment is now as simple as hovering the
    mouse cursor over the floor mesh in the **Scene** view and holding the left mouse
    button down while dragging in the area you want to have objects scattered – as
    seen in *C* in *Figure 11**.10*. Holding down *Ctrl*/*Cmd* while painting will
    work as an eraser and remove objects should you dislike any placements. Have fun!
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Polybrush works on vertical surfaces too, so you can scatter Prefabs on the
    walls (just know that you may need to re-orient or position the Prefab’s anchor
    for the objects to paint as intended; I have provided an example Prefab for this
    with **Exhaust_01 Pb**).
  prefs: []
  type: TYPE_NORMAL
- en: Scattering objects to break up the environment is one part of environment design
    that can lead to the better immersion of the player, while another is also breaking
    up visually repeating patterns. We can solve the latter with another Unity artist
    tool that recently got some love in version 2022.
  prefs: []
  type: TYPE_NORMAL
- en: Surface story with Decals
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As my friend Miguel, over at Polypix Studios, would say, *surface story matters*,
    and I wholeheartedly agree! Unless you’re going for a super-pristine futuristic-clean
    look, you’ll want to ensure your environments are grounded in the real world.
    This means that these environments will communicate their history of usage – wear
    and tear – through their texture details. Let’s say our habitat station’s maintenance
    robots are not very good at janitorial duties, so the environment should be indicated
    as such. Plus, you know that there should be some indication of the plant entity’s
    effect on the environment!
  prefs: []
  type: TYPE_NORMAL
- en: This is a great opportunity to either refer back to the GDD or expand upon the
    details that support the story we’re telling through the environmental design.
  prefs: []
  type: TYPE_NORMAL
- en: As designers (or developers wearing the hat of a designer), we don’t need much
    in the way of 3D artistic skills to leverage surface story in our environment
    design. We can use tooling that Unity provides (surprised?) to add surface details
    to the environment, and we do that with **Decals**.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'You can read more about the Decal renderer feature (URP) here: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Before we can use Decals in our project, we have to enable the feature.
  prefs: []
  type: TYPE_NORMAL
- en: Enabling the Decal feature in URP
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To enable **Decals** in the **Universal RP** settings, while referring to *Figure
    11**.11*, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Settings` folder, select the **URP-HighFidelity-Renderer** asset
    (*A* in *Figure 11**.11*). Note that this is the default setting unless you’ve
    changed the default **Quality** value in the **Project** **Settings** area.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Click the **Add Renderer Feature** button (*B* in *Figure 11**.11*) in the
    **Inspector** area, then select **Decal** from the list:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Enabling Decal for Universal RP](img/B18347_11_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.11 – Enabling Decal for Universal RP
  prefs: []
  type: TYPE_NORMAL
- en: Now, we need some decal textures to use for our Decals!
  prefs: []
  type: TYPE_NORMAL
- en: Decal textures
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: First, we’ll need to get some detailed textures into our environment via textures
    files. I’ve already sourced some royalty-free textures we can use in our project.
    Download the `cgtrader_2048986_Damage.zip` file from this chapter’s GitHub repository
    at [https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets](https://github.com/PacktPublishing/Unity-2022-by-Example/tree/main/ch11/Art-Assets).
  prefs: []
  type: TYPE_NORMAL
- en: Free decal textures | cgtrader
  prefs: []
  type: TYPE_NORMAL
- en: The decal textures we’re using in the project are from the *Decals Damage 48
    Texture* files (royalty-free license) at cgtrader, available at [https://www.cgtrader.com/free-3d-models/textures/decal/decals-damage-48-texture](https://www.cgtrader.com/free-3d-models/textures/decal/decals-damage-48-texture).
  prefs: []
  type: TYPE_NORMAL
- en: Unzip the file and import the images to a new `Assets/Textures/Decals` folder.
    While you’re creating folders, go ahead and create a new `Assets/Materials/Decals`
    folder too, since we’ll need that for creating decal materials in the next step.
  prefs: []
  type: TYPE_NORMAL
- en: Creating decal materials
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The Decal feature is based on materials that are assigned to a `Shader` `Graphs/Decal`
    shader.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s create our first Decal material by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Materials/Decals` folder in the **Project** window, create a
    new **Material** (by going to **Create** | **Material**).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Name the new material with the same name as the damage texture we’ll be using;
    for this first example, we’ll use `DecalsDamage0032_1_S`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: With the new material selected, in the `Shader Graphs/Decal` shader from the
    **Shader** drop-down list at the top.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the `Assets/Textures/Decals` folder, drag the `DecalsDamage0032_1_S` image
    to the **Base** **Map** field.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note that if we have a Normal Map image included with our damaged textures,
    then assign that to the **Normal Map** field (I suggest using normal maps for
    greater detail in your Decals; we just don’t, however, have one included in the
    provided textures).
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: With that, our first damage Decal material is ready to go! We’re almost ready
    to start applying damage to our environment with the Decal projector component.
  prefs: []
  type: TYPE_NORMAL
- en: Rendering Layers for Decals
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Decals are projectors! Due to the nature of a projection in the scene, some
    objects may pass between the projector and the target mesh(es) and get hit by
    the projection, producing an undesirable result. So, although we can take a more
    freeform approach to the art direction here – since we aren’t limited to where
    we can place Decals in the environment – we may still have to control how Decals
    are projected and protect some objects from receiving the decal texture. Fortunately,
    using **Rendering Layers**, we can limit what meshes the decal affects.
  prefs: []
  type: TYPE_NORMAL
- en: New to Unity 2022
  prefs: []
  type: TYPE_NORMAL
- en: 'Rendering Layers | How to use Rendering Layers with Decals: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/features/rendering-layers.xhtml#how-to-rendering-layers-decals](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/features/rendering-layers.xhtml#how-to-rendering-layers-decals).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we will want to have our Decals affect the walls but not the objects
    we’ve scattered throughout the environment from our painting with Polybrush! Let’s
    ensure we have Rendering Layers for Decals enabled now. So, let’s revisit the
    **URP-HighFidelity-Renderer** asset (refer to *Figure 11**.11*) and enable **Use
    Rendering Layers** (it’s turned off by default):'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Use Rendering Layers enabled](img/B18347_11_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.12 – Use Rendering Layers enabled
  prefs: []
  type: TYPE_NORMAL
- en: 'The next requirement for a functional Decals **Rendering Layers** setup is
    to ensure a layer is specified for our Decals case. We can do that by editing
    the **Rendering Layers (3D)** list of layers:'
  prefs: []
  type: TYPE_NORMAL
- en: Select the `Assets/` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'As shown in *Figure 11**.13*, we’ll create our Decal layer by renaming the
    `Receive Decals`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Decal Rendering Layers](img/B18347_11_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.13 – Decal Rendering Layers
  prefs: []
  type: TYPE_NORMAL
- en: Now that we have an assignable layer, we’ll go back and modify all of the Prefabs
    we want to be able to receive decal projections on – ensuring that only objects
    that have the *Receive Decals* layer selected will show our damage textures. Working
    with the setup is straightforward – that is, once you wrap your head around the
    layers being the glue that binds all the parts together.
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 11**.14*, we’ll modify the `Wall_02 Variant` Prefab (in
    `Assets/Polypix 3D Assets/Modular Kit/Prefabs` folder so that it includes the
    *Receive Decals* layer in the `Mesh` `Renderer` component:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – Assigning a decal rendering layer to Prefabs](img/B18347_11_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.14 – Assigning a decal rendering layer to Prefabs
  prefs: []
  type: TYPE_NORMAL
- en: You’ll want to update all the Prefabs you intend to project Decals onto with
    the *Receive Decals* layer. If your Decals aren’t showing where you believe they
    should be, you’ll want to double-check the layer assignments (and, of course,
    that Decals are enabled in the renderer settings).
  prefs: []
  type: TYPE_NORMAL
- en: Now, we can create our first **Decal Projector** in the scene and start fleshing
    out the environment’s story. Yay!
  prefs: []
  type: TYPE_NORMAL
- en: Using the Decal Projector component
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'To add a Decal, you can either create a new `Decal Projector` GameObject or
    add a `Decal Projector` component to an existing object in the scene. Since we
    don’t have any objects in the scene that are appropriate for adding a `Decal Projector`
    component, we’ll create a new one: in the **Hierarchy** window, go to **Create**
    | **Rendering** | **URP** **Decal Projector**.'
  prefs: []
  type: TYPE_NORMAL
- en: 'As shown in *Figure 11**.15*, we must assign the Decal material we previously
    made for the `DecalsDamage0032_1_S` texture to the **Material** field and select
    the *Receive Decals* layer in the **Rendering** **Layers** field:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.15 – Decal projected onto the wall Prefab](img/B18347_11_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.15 – Decal projected onto the wall Prefab
  prefs: []
  type: TYPE_NORMAL
- en: As shown in *Figure 11**.15*, I’ve positioned and rotated the **Decal Projector**
    *cube gizmo* (which shows its bounds) using the **Transform** tool. The base of
    the gizmo has a thicker line, and the projection direction is indicated by the
    white arrow emanating from the pivot point anchor (on the Z-axis).
  prefs: []
  type: TYPE_NORMAL
- en: You can get away with using the **Transform** tool for the initial positioning
    and rotation of the projection. Still, you’ll likely want to use the **Scene**
    view editing tools to fine-tune the decal further – this requires further exploration
    and experimentation on your part, so I recommend additional reading.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Decal Projector component: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#decal-projector-component](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#decal-projector-component).'
  prefs: []
  type: TYPE_NORMAL
- en: Continue to decorate – ah – design the level environment further and add *surface
    story* details to sell your environment to the player by utilizing the varying
    damage textures we have at our disposal. Again, playtesting and feedback are essential
    here to help guide the art direction.
  prefs: []
  type: TYPE_NORMAL
- en: As you start projecting textures everywhere, you may be thinking, what is this
    doing to my game’s performance?
  prefs: []
  type: TYPE_NORMAL
- en: Decal performance
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Well, Unity has got us covered for performance optimization too. If we ensure
    that the Decals in the scene with the same damage texture use the same *Material*,
    and if we turn on **Enable GPU Instancing** for the *Material*, Unity will use
    a technique called **instancing** to make rendering more efficient. Instancing
    on the GPU can minimize the work Unity has to do by reducing the number of draw
    calls (which is like drawing all the Decals at once instead of each decal individually).
  prefs: []
  type: TYPE_NORMAL
- en: Furthermore, to reduce the different number of materials we need for Decals
    (because, again, each *Material* is grouped to draw at once), we can put many
    damage texture images into one larger image (that is, a texture atlas). Then,
    the **Decal Projector** component allows us to use **UV offset** properties to
    select which part of the texture atlas we want to show – our selected individual
    texture image. This way, we can manage all the decal images more efficiently and
    keep our games running smoothly.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Decal Renderer Feature | Performance: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#performance](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/renderer-feature-decal.xhtml#performance).'
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to polish our 3D environment by replacing graybox
    Prefabs with finished art assets using Unity’s new Prefab workflow and manually
    updating Prefabs with new graphics while maintaining their existing behavior in
    Prefab Mode. We continued by polishing the environment design by painting scattered
    objects with Polybrush and immersing the player in *surface story* by adding Decal
    textures.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we’ll continue to add polish to the habitat’s interior
    environment with lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting design – Probes, Decals, light baking, and performance
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let me immediately set some expectations for this section – we won’t spend much
    time on lighting design. It’s a subject worthy of an entire book all on its own.
    So, what we will be covering are some basics any game developer should be familiar
    with when working with lighting 3D scenes in Unity.
  prefs: []
  type: TYPE_NORMAL
- en: The first thing I would like to address is that Unity has released a new rendering
    path for **Universal RP** (**URP**) with the 2022.3 LTS version called **Forward+
    Rending**.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Forward+ Rendering Path: [https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/rendering/forward-plus-rendering-path.xhtml](https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal%4014.0/manual/rendering/forward-plus-rendering-path.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: The **Forward+ Rendering Path** (Forward+) gives several advantages over the
    previous **Forward Rendering Path** (Forward), but it primarily overcomes the
    per-object limit on the number of lights that can affect GameObjects in the scene
    (note that the per-camera limitation does still apply). Let’s see how we can update
    our project URP settings to use **Forward+**.
  prefs: []
  type: TYPE_NORMAL
- en: Setting the URP Forward+ Rendering Path
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, let’s change our URP **Rendering Path** setting to use the **Forward+
    Rendering Path**. We can do that in the **Universal RP settings** area (the same
    asset we added to the **Decal** feature in *Figure 11**.11*):'
  prefs: []
  type: TYPE_NORMAL
- en: In the `Assets/Settings` folder, select the **URP-HighFidelity-Renderer** asset.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Under the **Rendering** section, select **Forward+** in the **Rendering** **Path**
    dropdown:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.16 – Setting the Forward+ Rendering Path](img/B18347_11_16.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.16 – Setting the Forward+ Rendering Path
  prefs: []
  type: TYPE_NORMAL
- en: As with most decisions about the tech stack that you’ll be making for your Unity
    projects, you’ll have to experiment and test to see what fits best for the project’s
    direction or target platform (mobile, we’re looking at you), and the renderer
    pipeline choice is no exception. It’s pretty important. So, we will be changing
    this project to the **Forward+ Rendering Path** now. Just know that we may end
    up reverting this decision in the future should we need to change our lighting
    approach (for example, from real time to baked lighting; more on this in the *Bake
    that* *lighting?* section).
  prefs: []
  type: TYPE_NORMAL
- en: The consensus with performance – concerning **Forward+** over **Forward** –
    is that gains are realized with greater than six real-time lights due to the overhead
    **Forward+** introduces when clustering lights (**Forward+** gathers light data
    into clusters computed in the fragment shader rather than individual light data).
    That’s excellent news for lighting designers because **Forward+ Rendering** gives
    us precisely what we may need – more real-time lights in a scene!
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of lights, we can get away with adding lighting effects to our scenes,
    and not touch a single light – this is accomplished with proxy lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Proxy lighting with Decals (yes, Decals)
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Decals here refer to *lighting decals* (that is, proxy lighting) and not *texture
    decals*, which we’re already familiar with. To accomplish this effect, **Decal
    Projector** uses a special shader to modify the emissive color of affected surfaces
    without any real-time lights being involved.
  prefs: []
  type: TYPE_NORMAL
- en: The *Material* we’ll be using for the proxy lighting **Decal Projector** in
    our scene is based on a **Shader Graph** shader, **Spotlight**, that comes from
    the **Universal** **RP** samples.
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity Blog
  prefs: []
  type: TYPE_NORMAL
- en: 'You can explore the latest package samples for the Universal Render Pipeline
    here: [https://blog.unity.com/engine-platform/explore-the-latest-package-samples-for-the-universal-render-pipeline](https://blog.unity.com/engine-platform/explore-the-latest-package-samples-for-the-universal-render-pipeline).'
  prefs: []
  type: TYPE_NORMAL
- en: These are not just for **Universal RP**! You should always check the Unity package
    content to see what samples are provided as examples that supplement the Unity
    documentation for learning the feature and can give a jump start on implementation.
  prefs: []
  type: TYPE_NORMAL
- en: 'To import the **Universal RP** samples, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open **Package Manager** by going to **Window** | **Package Manager**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Ensure you have **In Project** selected in the **Packages** dropdown.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Find and select **Universal RP** from the list (left-hand side).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: On the right-hand side of the window, click the **Samples** tab.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: For `Assets/Samples/Universal RP/14.x.x/URP Package` `Samples` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Once the samples have been imported, find and open the `/URP Package` `Samples/Decals/ProxyLighting`
    folder:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.17 – Unity Universal RP ProxyLighting sample](img/B18347_11_17.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.17 – Unity Universal RP ProxyLighting sample
  prefs: []
  type: TYPE_NORMAL
- en: Now, go ahead and find the `Assets/Prefabs` folder. Name it `Decal Spotlight`
    so that we can use it as a *lighting Decal spotlight* in our habitat interior
    scene. It’s already pre-configured with the **Spotlight** material (and the default
    **Rendering Layer** so that it will affect any object in the scene), so we’re
    all set!
  prefs: []
  type: TYPE_NORMAL
- en: Now, go back to our interior habitat scene and place a **Decal Spotlight** material
    into a wall overhang (as pictured in *Figure 11**.18*), adjust the **Decal Projector**
    component’s **Opacity** setting (refer to *Figure 11**.17*) to a lovely lighting
    value, then duplicate it several times (three times in this example; four in total).
    Don’t worry that they’re all sitting on top of each other at the moment.
  prefs: []
  type: TYPE_NORMAL
- en: We could manually place the spotlights further along the wall, or, to make things
    easier on ourselves, we can use a bit of math in the `cos(a)` and `sin(a)` too!
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Editing Properties | Numeric field expressions: [https://docs.unity3d.com/Manual/EditingValueProperties.xhtml](https://docs.unity3d.com/Manual/EditingValueProperties.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Select all the spotlights we just added to the `L(-5.4,-17.3)` in the `L(a,b)`
    is a linear ramp expression where the selected objects are distributed between
    the values.
  prefs: []
  type: TYPE_NORMAL
- en: While you have the expression in the field, you can play around with the values
    until you have the spotlights positioned where you want (your values may differ
    from mine based on your wall position and so on).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should end up with something like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.18 – Decal spotlights array on the wall](img/B18347_11_18.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.18 – Decal spotlights array on the wall
  prefs: []
  type: TYPE_NORMAL
- en: Pretty cool, right? And remember, no real-time lights are involved! We can save
    on lighting resources while still enjoying additional lighting effects in our
    environment design. Just note that **Decal Material** performance considerations
    are still applicable.
  prefs: []
  type: TYPE_NORMAL
- en: Speaking of performance, we have another approach to lighting that we can consider
    besides the use of real-time lighting, and that’s baked lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Bake that lighting?
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 350° F (175° C) for 45 minutes… sure!
  prefs: []
  type: TYPE_NORMAL
- en: 'Using baked lighting in Unity can have several benefits over real-time lighting
    in your game, but deciding to use one or the other depends greatly on the target
    platform and the target framerate you’ve determined the game needs to hit on specific
    hardware specs (you may have already been introduced to this type of information
    related to games you’d like to play on your PC or mobile device – system requirements:
    minimum and recommended).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s look at the three main benefits of baked lighting:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Performance**: Baking the lighting means all of the light interactions in
    the scene regarding objects’ surfaces are computed ahead of time (in the editor)
    and saved into lightmap textures files. During runtime, the lightmaps are used
    to determine the light that’s received by the objects’ surfaces in the scene,
    which is much faster than real-time calculations.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Quality**: Baked lighting usually produces better lighting fidelity, especially
    when it comes to indirect bounced light, soft shadows, and more complex light
    diffusion effects.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Lighting complexity**: Baked lighting can handle higher levels of lighting
    complexity with lots of lights and complex shadow interactions (just be prepared
    for longer bake times!).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, let’s consider some disadvantages of baked lighting:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Lightmaps**: The size of the generated lightmap texture files can be of concern
    for both memory usage at runtime and the size of the game on disk (that is, mobile
    and lower-end platforms). Optimizing lightmaps is generally a balancing act between
    performance and quality (which, of course, takes time; see *Long* *iteration time*).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Static**: The baked lightmaps only work for objects that don’t move in the
    scene (that is, static objects; they are assigned as such in the **Inspector**
    area). Dynamic lights and moving objects are more suitable for real-time lighting.
    Unity does, however, provide a solution for dynamic objects with baked lighting
    via **Light Probes**, but they come with their own limitations (such as area lights
    and volumetric lighting not being supported, not working well with some materials,
    and no real-time reflections), so often, a combination of techniques applied with
    real-time direct lighting and shadow casting is necessary to obtain the desired
    results.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Additional work**: Additional work must be done in the form of setting objects
    as static, setting up **Light Probes** for dynamic objects in the scene, a solution
    for basic shadow needs, and balancing the generated lightmap quality, for starters.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Long iteration time**: The process of baking lightmaps can be resource-intensive
    and, therefore, time-consuming on lower-end development system CPU/GPU hardware,
    which can cause a significant slowdown in the environment design iteration process.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: There’s no doubt that lighting an environment with real-time lighting is more
    accessible. Still, you may not have a choice if you’re going to target mobile
    or lower-end hardware specs (for example, the Nintendo Switch). Baked lighting
    is generally more performant across devices and platforms compared to real-time
    lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Our approach so far has been to use the default lighting setup with the **Directional
    Light** property provided by the **Standard (URP) Scene Template** and create
    additional lights in the scene – which are *Realtime* by default. Now, we must
    change our approach because we will target a lower-end platform but still want
    to target 60 FPS. So, we’re going to need baked lighting.
  prefs: []
  type: TYPE_NORMAL
- en: Setting up baked lighting
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: To set up our baked lighting, let’s duplicate our current habitat interior scene
    with real-time lighting so that we can non-destructively experiment with converting
    it into baked lighting.
  prefs: []
  type: TYPE_NORMAL
- en: 'Select your `Assets/Scenes` folder in the **Project** window, press *Ctrl*/*Cmd*
    + *D* to duplicate, and rename it with a (*baked*) suffix. Let’s open the duplicate
    scene and start the setup:'
  prefs: []
  type: TYPE_NORMAL
- en: Select `Light` component’s **General** section, select **Baked** in the **Mode**
    field dropdown instead of **Realtime**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Please do the same for any additional lights you may have added to the scene
    that we want Unity to include in the baking. Note that we won’t have to change
    the **Decal** spotlights we added in the *Proxy lighting with Decals (yes, Decals)*
    section – remember, these are not lights!
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'We need to let Unity know what objects won’t move so that their lighting can
    be baked. So, for all of the modular Prefabs that make up the walls, the floors,
    the doorway, and scattered Prefab objects in the scene, select them in the **Hierarchy**
    area. Then, in the **Inspector** area, enable **Static** (the top right of the
    window):'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.19 – Marking a GameObject as static](img/B18347_11_19.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.19 – Marking a GameObject as static
  prefs: []
  type: TYPE_NORMAL
- en: When you’re asked whether you want to mark the child objects as static too,
    click the **Yes, change** **children** button.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Now that the objects in the scene have been set up, we will configure **Lightmapping
    Settings** just before baking.
  prefs: []
  type: TYPE_NORMAL
- en: Lighting settings
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Lightmapping Settings** configure the light baking calculation and how it
    applies to the scene. We need to use the **Lighting** window to create a new **Lighting
    Settings Asset** to store our configuration. Unity will use default read-only
    light settings to bake the scene lighting until we create an asset.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'The Lighting window: [https://docs.unity3d.com/2022.3/Documentation/Manual/lighting-window.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/lighting-window.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new **Lighting Settings Asset**, follow these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the **Lighting** window by going to **Window** | **Rendering** | **Lighting**.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'At the top of the **Lighting** window, under the **Lighting Settings** section,
    click the **New** button to the right of the **Lighting Settings Asset** field
    to create a new **Lighting Settings Asset** in the **Project** window; it will
    be assigned immediately:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '![Figure 11.20 – New Lighting Settings Asset](img/B18347_11_20.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.20 – New Lighting Settings Asset
  prefs: []
  type: TYPE_NORMAL
- en: Name the asset the same as the scene name so that it’s easy to keep track of
    – for reference, in [*Chapter 10*](B18347_10.xhtml#_idTextAnchor187), we created
    a new scene named `Habitat Interior 1`; but use the current scene name you’re
    using here.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Lighting Settings Asset: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-LightingSettings.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-LightingSettings.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: We’ll work in the **Scene** tab to optimize our settings for the desired balance
    of quality, lightmap texture size, and bake time. Using the default values is
    a good starting baseline for your baking.
  prefs: []
  type: TYPE_NORMAL
- en: Okay, click that **Bake** button! Sadly, no. The actual button to click for
    baking the lighting is the **Generate Lighting** button, located at the bottom
    of the **Lighting** window. When started, the lighting process will display a
    progress indicator at the bottom right of the **Editor** window with an estimated
    time for completion.
  prefs: []
  type: TYPE_NORMAL
- en: After some time – depending on the power of your system hardware – the generated
    lighting process will finish, and the **Scene** view will update with the new
    baked lighting. Inspect the result of the baked lighting in your scene, and, if
    it’s not to your satisfaction, adjust **Lightmapping Settings** and/or both the
    settings and position or rotation of light sources in the scene and bake again;
    repeat as needed.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a gander at the results of our labor by comparing screenshots of
    the same view with baked and real-time lighting:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.21 – Baked versus Realtime renders](img/B18347_11_21.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.21 – Baked versus Realtime renders
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: You’ll also want to compare the results of the baked lighting to the real-time
    lighting. Analyze the quality of the light, the lighting features, memory usage,
    and, most importantly, the FPS the game is running at compared to your target
    framerate on the desired platform(s).
  prefs: []
  type: TYPE_NORMAL
- en: You can get some performance gauge while running in **Play** mode in **Unity
    Editor**, but you’ll want to build and test on the target device(s) for the best
    results. Graphy – Ultimate Stats Monitor & Debugger ([https://github.com/Tayx94/graphy](https://github.com/Tayx94/graphy))
    is a free tool that is greatly helpful in analyzing your game’s performance. Output
    from Graphy can be seen in the game screenshots in the top-right corner in *Figure
    11**.21*, where the baked lighting shows a slight FPS benefit over real time (this
    is in the **Editor** window, so I expect greater gains in a build).
  prefs: []
  type: TYPE_NORMAL
- en: You may not be happy at all with how long the baked lighting generation took
    with the default **Lightmapper** setting set to **Progressive CPU**. Fortunately,
    if your hardware supports it, we can improve the calculation time using the GPU-based
    lightmapper.
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: If you notice graphical artifacts appearing on models in your baked lighting,
    then imported model UVs for baked lightmaps may not be provided. In that case,
    you can tell Unity to generate them automatically to fix their appearance.
  prefs: []
  type: TYPE_NORMAL
- en: To have Unity generate lightmap UVs, select the offending model in the **Project**
    window to view **Model Import Settings** in the **Inspector** area. Once you’ve
    done this, ensure the **Model** tab is selected, and then, in the **Geometry**
    section, *enable* the **Generate Lightmap** **UVs** option.
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity Documentation | Generating lightmap UVs: [https://docs.unity3d.com/Manual/LightingGiUvs-GeneratingLightmappingUVs.xhtml](https://docs.unity3d.com/Manual/LightingGiUvs-GeneratingLightmappingUVs.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Now, about that iteration time.
  prefs: []
  type: TYPE_NORMAL
- en: Improving iteration time
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '**Lightmapping Settings** allows us to choose between the **Progressive CPU**
    and **Progressive GPU** lightmappers (the latter still being in preview for 2022.3.1f1).
    **Progressive GPU** may be much, much, quicker to generate lighting, but it all
    depends on what GPU (that is, what graphics card) you have installed in your system
    running Unity. In my example, **Progressive CPU** is estimated to take 3+ hours,
    whereas **Progressive GPU** (on modest GPU hardware) is estimated to take 40+
    minutes.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'The Progressive Lightmapper: [https://docs.unity3d.com/2022.3/Documentation/Manual/progressive-lightmapper.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/progressive-lightmapper.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve covered baked lighting for static objects in the scene (that
    is, objects we marked as *Static* because they don’t move), we just need to cover
    a bit about how dynamic or moving objects in the scene can be affected by light
    when there is no real-time lighting!
  prefs: []
  type: TYPE_NORMAL
- en: Light Probes
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Again, Unity has us covered for dynamic object lighting. We can use **Light
    Probes** to apply our baked lighting to moving objects – as mentioned previously;
    however, this is additional work compared to real-time lighting (as indicated
    in the *Additional work* bullet point in the *Bake that lighting?* section). Note
    that light probes will not affect the objects we marked as **Static** – moving
    objects should never be marked **Static**.
  prefs: []
  type: TYPE_NORMAL
- en: '**Light Probes** are placed throughout the environment, not only where the
    moving objects will be but also in areas where lighting changes (especially dramatic
    changes). The light probes we put in the scene will capture the light information
    when baking and then use that data to light the moving objects based on their
    relative position to the probes.'
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Light Probes: [https://docs.unity3d.com/2022.3/Documentation/Manual/LightProbes.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/LightProbes.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s place our first **Light Probe Group** in our scene by going to **Create**
    | **Light** | **Light Probe Group**. Then, using the **Transform** tool, move
    the new **Group** to the center of a room in the level. Light changes occur primarily
    along the walls in these rooms since the lighting is pretty uniform, so we’ll
    spread out the probes to cover a wider area.
  prefs: []
  type: TYPE_NORMAL
- en: In *Figure 11**.22*, you can see that I first used the toggle pickability feature
    (*A* in *Figure 11**.22*) in the **Hierarchy** area to turn off the selection
    of the wall, floor, and ceiling so that we can work with the probes and not accidentally
    select anything else in the scene (that would be not very pleasant, after all).
  prefs: []
  type: TYPE_NORMAL
- en: 'You can now enable **Light Probe Editing** (*B* in *Figure 11**.22*) and drag
    a selection window (*C* in *Figure 11**.22*) in the **Scene** view to select the
    probes on the right-hand side of the group. Use the **Duplicate Selected** button
    – or the tried-and-true *Ctrl*/*Cmd* + *D* shortcut – to duplicate the selected
    probes, then use the **transform move** tool to position the duplicated probes
    near the wall:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.22 – Editing Light Probes in the scene](img/B18347_11_22.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.22 – Editing Light Probes in the scene
  prefs: []
  type: TYPE_NORMAL
- en: Additional reading | Unity documentation
  prefs: []
  type: TYPE_NORMAL
- en: 'Pick and select GameObjects: [https://docs.unity3d.com/Manual/ScenePicking.xhtml](https://docs.unity3d.com/Manual/ScenePicking.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Scene visibility: [https://docs.unity3d.com/Manual/SceneVisibility.xhtml](https://docs.unity3d.com/Manual/SceneVisibility.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Repeat the process of selecting, duplicating, and positioning probes until
    you have something similar to the probe group setup shown in *Figure 11**.23*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.23 – Light Probes placement example](img/B18347_11_23.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.23 – Light Probes placement example
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Remember, in *Figure 11**.23*, as uniform as the probes grouping looks in this
    scene, you won’t always have it set up this way because you’ll want to position
    probes where the light changes (again, especially where the light changes dramatically)
    for the best results.
  prefs: []
  type: TYPE_NORMAL
- en: Once you have the **Light Probe Groups** set up in your level, you’ll have to
    bake (err, generate) the lighting again so that the probes have all the lighting
    information stored. The probe lighting data will then be used at runtime to light
    dynamic objects.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can visualize the effect light probes have on dynamic objects by using
    the **Light Probe Visualization** setting in the **Lighting** window. When you
    have a dynamic object selected in the scene, the probes that influence the object
    will be shown when set to **Only Probes Used By Selection**, with the selected
    **Sphere** (temporarily added to the scene for the sole purpose of visualizing
    the Light Probes), as shown in *Figure 11**.24*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.24 – Light Probes visualization selection](img/B18347_11_24.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 11.24 – Light Probes visualization selection
  prefs: []
  type: TYPE_NORMAL
- en: Tip
  prefs: []
  type: TYPE_NORMAL
- en: Unity has another useful lighting tool called **Reflection Probes**. Their use
    can significantly enhance the visual fidelity of scenes by contributing to the
    quality of both baked and real-time lighting – that is, these probes work with
    both static and dynamic objects.
  prefs: []
  type: TYPE_NORMAL
- en: As the name indicates, reflection probes add the effect of reflections of shiny
    things in the environment. I recommend exploring **Reflection Probes** further
    to enhance the quality of your game’s visuals!
  prefs: []
  type: TYPE_NORMAL
- en: 'Unity documentation | Reflection Probes: [https://docs.unity3d.com/2022.3/Documentation/Manual/class-ReflectionProbe.xhtml](https://docs.unity3d.com/2022.3/Documentation/Manual/class-ReflectionProbe.xhtml).'
  prefs: []
  type: TYPE_NORMAL
- en: There is one additional subject we need to cover regarding baked lighting, and
    that is shadows for dynamic objects. Baked shadows are a part of baked lighting
    for static objects – the shadows were baked into the lightmaps. Our lights in
    the scene were also set to *Baked*, so that doesn’t leave any means for providing
    shadows to our dynamic objects.
  prefs: []
  type: TYPE_NORMAL
- en: We can achieve a semi-dynamic shadow effect for baked lighting in a few different
    ways. We’ll cover two in the following section.
  prefs: []
  type: TYPE_NORMAL
- en: Baked lighting dynamic shadows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The first thing we can do for dynamic object shadows is use **Mixed** mode for
    lights. **Mixed** mode will bake shadows (just like the **Baked** mode setting)
    for static objects *and* compute real-time shadows for dynamic objects (just like
    the **Realtime** mode setting).
  prefs: []
  type: TYPE_NORMAL
- en: '**Light Probes** don’t solve this problem because they don’t represent any
    direct lighting and don’t produce shadows; they only influence the lighting applied
    to dynamic objects, so we’ll use them in combination with this mixed lighting
    mode technique.'
  prefs: []
  type: TYPE_NORMAL
- en: So, to implement it, simply set **Directional Light** to **Mixed** mode and
    bake. Done.
  prefs: []
  type: TYPE_NORMAL
- en: The second thing we can do is fake it (yes, fake it – often, the game developer
    must resort to creative techniques that produce the desired results visually or
    close to it, but in clever and creative ways behind the scenes). No worries –
    Unity still has us covered.
  prefs: []
  type: TYPE_NORMAL
- en: Blob shadows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: A shadow projector can be used as a more optimized way to represent a simple
    *blob* *shadow* on the ground under objects. This technique benefits performance-constrained
    platforms (for example, mobile games and low-end hardware) where real-time shadow
    casting can be too performance-heavy.
  prefs: []
  type: TYPE_NORMAL
- en: To use a blob shadow projector, we don’t need to look further than the `Assets/Samples/Universal
    RP/14.0.8/URP Package` `Samples/Decals/BlobShadow` folder.
  prefs: []
  type: TYPE_NORMAL
- en: With the scene open, find the **Capsule** object in the **Hierarchy** area.
    The **BlobShadow** child object contains the **URP Decal Projector** component
    (this should be familiar to you) with the provided **BlobShadow_Mat** material
    assigned.
  prefs: []
  type: TYPE_NORMAL
- en: Create a Prefab of it and use it for dynamic objects in your scene that require
    dynamic shadows in a baked lighting setup. It couldn’t be easier!
  prefs: []
  type: TYPE_NORMAL
- en: In this section, we learned how to light an interior environment scene with
    both real-time and baked lighting and weighed the visual differences and the performance
    tradeoffs between these approaches. We also learned some techniques to overcome
    lighting limitations.
  prefs: []
  type: TYPE_NORMAL
- en: With that and the knowledge and technique learned in this chapter, take the
    time to finish your level’s interior environment design to make it appear lived-in
    – immersive and engaging for the player. Tell a story. Iterate as necessary with
    feedback from your playtesting group. Most importantly, just have fun!
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we covered the process of transforming a grayboxed prototype
    environment by importing and replacing modular Prefabs with high-quality 3D model
    assets using Unity’s new 2022 Prefab workflow, preserved Prefabs with additional
    behavior using Prefab Mode, and applied new materials to finish up the level’s
    structural visuals.
  prefs: []
  type: TYPE_NORMAL
- en: We continued to decorate the environment by painting scattered Prefabs with
    **Polybrush**, strategically placing wear-and-tear **Decal** projectors for an
    additional layer of uniqueness and detail, and finalizing our artistic vision
    with technical implementations of both real-time and baked lighting setups, where
    we addressed additional considerations for lighting and shadows for dynamics objects
    while using baked lightmaps.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we’re going to continue enhancing the player experience
    by adding some much-needed sound design (so far, audio is something we haven’t
    spent any time on). We’ll code `AudioManager` and create reusable *audio* *player*
    components to make adding music, **sound effects** (**SFX**), and ambient sounds
    simple and straightforward (even for artists and designers).
  prefs: []
  type: TYPE_NORMAL
