<html><head></head><body>
  <div><h1 class="chapter-number" id="_idParaDest-46">
    <a id="_idTextAnchor073">
    </a>
    
     3
    
   </h1>
   <h1 id="_idParaDest-47">
    <a id="_idTextAnchor074">
    </a>
    
     The Anatomy of a Minimal API
    
   </h1>
   <p>
    
     To understand how minimal APIs work, it makes sense to learn how they are put together in the context of an ASP.NET application.
    
    
     In ASP.NET project types such as
    
    <strong class="bold">
     
      Model-View-Controller
     
    </strong>
    
     (
    
    <strong class="bold">
     
      MVC
     
    </strong>
    
     ) and
    
    <strong class="bold">
     
      Web API
     
    </strong>
    
     , various components are tied together to create the overall application, and minimal APIs are
    
    
     
      no different.
     
    
   </p>
   <p>
    
     By the end of this chapter, you will have learned how minimal APIs fit within the ASP.NET ecosystem and how the various components are combined to make
    
    
     
      them possible.
     
    
   </p>
   <p>
    
     The aim here is to ensure you have a deeper understanding of the wider context surrounding minimal APIs, which will inform the way you design and implement them in
    
    
     
      future projects.
     
    
   </p>
   <p>
    
     In this chapter, we are going to cover the following
    
    
     
      main topics:
     
    
   </p>
   <ul>
    <li>
     
      Anatomy of a
     
     
      
       minimal API
      
     
    </li>
    <li>
     
      Components of a minimal
     
     
      
       API Application
      
     
    </li>
    <li>
     
      The API
     
     
      
       request lifecycle
      
     
    </li>
   </ul>
   <p>
    
     Let’s get into
    
    
     
      the chapter!
     
    
   </p>
   <h1 id="_idParaDest-48">
    <a id="_idTextAnchor075">
    </a>
    
     Anatomy of a minimal API
    
   </h1>
   <p>
    
     When
    
    <a id="_idIndexMarker075">
    </a>
    
     referring to the
    
    <em class="italic">
     
      anatomy
     
    </em>
    
     of a minimal API, what we are really talking about is the pieces of the puzzle that fit together to bootstrap the application.
    
    
     Before ASP.NET Core, bootstrapping involved two classes:
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     and
    
    <strong class="source-inline">
     
      Startup.cs
     
    </strong>
    
     .
    
    
     The former stayed at the high level of the project, setting up an HTTP pipeline before calling the startup class to add components and features to
    
    
     
      the pipeline.
     
    
   </p>
   <p>
    
     ASP.NET Core majorly changed this by making it possible to configure the application in a single file.
    
    
     This simplified the process, paving the way for native support of minimal APIs.
    
    
     So, in the most recent iterations of .NET, we now only need
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     for bootstrapping an
    
    
     
      ASP.NET application.
     
    
   </p>
   <p>
    
     The
    
    <a id="_idIndexMarker076">
    </a>
    
     minimum that
    
    <strong class="source-inline">
     
      Program.cs
     
    </strong>
    
     does to create a minimal API is to build and run an instance of
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     .
    
    
     This
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     instance is built using another class, called
    
    <strong class="source-inline">
     
      WebApplicationBuilder
     
    </strong>
    
     .
    
    
     As you can see in the upcoming code,
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     uses a
    
    <em class="italic">
     
      factory
     
    </em>
    
     in the form of the
    
    <strong class="source-inline">
     
      CreateBuilder
     
    </strong>
    
     method to create an instance of
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     called
    
    <strong class="source-inline">
     
      app
     
    </strong>
    
     .
    
    
     You will have seen this code in code examples in the
    
    
     
      previous chapter:
     
    
   </p>
   <pre class="source-code">
WebApplicationBuilder builder =
    WebApplication.CreateBuilder(args);
var app = builder.Build();</pre>
   <p>
    
     The result of this code is an instance of
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     on which endpoints can be mapped, using functions such as
    
    <strong class="source-inline">
     
      MapGet
     
    </strong>
    
     
      and
     
    
    
     <strong class="source-inline">
      
       MapPost
      
     </strong>
    
    
     
      .
     
    
   </p>
   <p>
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     embodies the overall API and is created using a builder pattern implementation via a
    
    <strong class="source-inline">
     
      WebApplicationBuilder
     
    </strong>
    
     object.
    
    
     This object allows configuration to be specified while building the
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     instance.
    
    
     For example, services can be registered for dependency injection (we will learn about dependency injection in
    
    <a href="B20968_07.xhtml#_idTextAnchor119">
     
      <em class="italic">
       
        Chapter 7
       
      </em>
     
    </a>
    
     ) while the
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     is being built via the
    
    
     <strong class="source-inline">
      
       WebApplicationBuilder
      
     </strong>
    
    
     
      object.
     
    
   </p>
   <p>
    
     An example of this initial setup of dependencies can be seen in the next code, where we use
    
    <strong class="source-inline">
     
      AddScoped
     
    </strong>
    
     to register the
    
    <strong class="source-inline">
     
      PayrollRunner
     
    </strong>
    
     type for dependency injection before the line of code on which the app is finally built
    
    
     
      using
     
    
    
     <strong class="source-inline">
      
       builder.Build()
      
     </strong>
    
    
     
      :
     
    
   </p>
   <pre class="source-code">
WebApplicationBuilder builder =
    WebApplication.CreateBuilder(args);
builder.Services.AddScoped&lt;PayrollRunn<a id="_idTextAnchor076"/>er&gt;();
var app = builder.Build();</pre>
   <p>
    
     A minimal API does not have its own dedicated project template in Visual Studio.
    
    
     Think of a minimal API as an option within an ASP.NET project, rather than its own project type.
    
    
     The reason for this is that minimal APIs are more often than not a part of another kind of project, although it is certainly common to have small ASP.NET projects consisting exclusively of minimal
    
    
     
      API endpoints.
     
    
   </p>
   <p>
    
     By default, an ASP.NET project creates a set of minimal API endpoints.
    
    
     You can see this using the
    
    <strong class="source-inline">
     
      ASP.NET Core (Empty)
     
    </strong>
    
     project template in
    
    <a id="_idIndexMarker077">
    </a>
    
     Visual Studio.
    
    
     Despite the name, the template’s resulting project generates an example minimal API endpoint, as we saw in the
    
    <em class="italic">
     
      Hello World!
     
    </em>
    
     example in
    
    <a href="B20968_01.xhtml#_idTextAnchor014">
     
      <em class="italic">
       
        Chapter 1
       
      </em>
     
    </a>
    
     
      .
     
    
   </p>
   <h1 id="_idParaDest-49">
    <a id="_idTextAnchor077">
    </a>
    
     Components of a minimal API application
    
   </h1>
   <p>
    
     There are
    
    <a id="_idIndexMarker078">
    </a>
    
     several components that go together to create a minimal API project, most of which are applicable to any ASP.NET
    
    
     
      web application.
     
    
   </p>
   <p>
    
     At the top level, the application is represented by an instance of
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     .
    
    
     This class holds together all the pieces that form the API system.
    
    
     Think of it like the
    
    
     
      application’s body.
     
    
   </p>
   <p>
    
     Components that live inside
    
    <strong class="source-inline">
     
      WebApplication
     
    </strong>
    
     include
    
    
     
      the following:
     
    
   </p>
   <ul>
    <li>
     <strong class="bold">
      
       Application Lifecycle
      
     </strong>
     
      : As the
     
     <a id="_idIndexMarker079">
     </a>
     
      application runs, various events will occur, such as application startup and shutdown, and thrown exceptions.
     
     <strong class="source-inline">
      
       WebApplication
      
     </strong>
     
      contains several
     
     <strong class="bold">
      
       hooks
      
     </strong>
     
      that
     
     <a id="_idIndexMarker080">
     </a>
     
      can be used to handle these events.
     
     
      For example, you could execute specific functions or methods when the application starts up or change the way specific exception types are handled
     
     
      
       when caught.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Services
      
     </strong>
     
      : Your
     
     <a id="_idIndexMarker081">
     </a>
     
      APIs will no doubt have reusable aspects that could be used across multiple use cases and different areas of the application.
     
     
      Creating
     
     <em class="italic">
      
       services
      
     </em>
     
      allows you to package up these reusable aspects into components that can be passed to various parts of your API using dependency injection.
     
     
      For example, several of your endpoints may rely on retrieving data from a SQL database, so it would not be good practice to write the code to access the database multiple times.
     
     
      Instead, a service can be written once and then injected into any classes that need to communicate
     
     
      
       with SQL.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Routing
      
     </strong>
     
      : We talked
     
     <a id="_idIndexMarker082">
     </a>
     
      about routing in the previous chapter.
     
     
      In the context of a minimal API’s anatomy, routing is a key component; it is responsible for ensuring that traffic is sent to the appropriate destination based on the endpoint URL and the HTTP method
     
     
      
       being used.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Middleware
      
     </strong>
     
      : In ASP.NET, middleware
     
     <a id="_idIndexMarker083">
     </a>
     
      is a pipeline that allows developers to interrupt the API flow with code that is executed during requests.
     
     
      The middleware pipeline is a chain of components executing any required logic.
     
     
      Examples of common middleware use cases include handling or modifying requests, authenticating clients, caching, and logging.
     
     
      Middleware can be a reusable component that is added to the pipeline or
     
     
      
       custom code.
      
     
     <p class="list-inset">
      
       Once a middleware component has finished running, the next component in the pipeline executes, until all components are finished.
      
      
       This is particularly useful because it can be applied globally, running on all incoming requests.
      
      
       It’s important to note that the pipeline can run both when the request comes in and when the response is sent back to the client, the difference being that the order of the middleware components in the pipeline is reversed when the response makes its way back to
      
      
       
        the client.
       
      
     </p>
    </li>
    <li>
     <strong class="bold">
      
       Configuration
      
     </strong>
     
      : Most
     
     <a id="_idIndexMarker084">
     </a>
     
      applications, including minimal APIs, require configuration to be specified, through connection strings for databases, authentication tokens, a flag to indicate whether the API is in developer mode, and so on.
     
     
      Think of these like environment variables.
     
     
      These variables are stored in an accessible location for use throughout the application’s lifecycle.
     
     
      For example, if you have a SQL database that several of your API endpoints need to work with data, they will need the relevant connection string to initiate the SQL connection.
     
     
      This can be stored as a configuration setting for any of these endpoints to obtain when they
     
     
      
       need it.
      
     
    </li>
   </ul>
   <p>
    
     So far, we have covered, at a basic level, the various components within an ASP.NET web application, including ones set up to host minimal API endpoints.
    
    
     To better understand the anatomy of a minimal API, it helps to also understand how a request travels through an
    
    
     
      ASP.NET API.
     
    
   </p>
   <h1 id="_idParaDest-50">
    <a id="_idTextAnchor078">
    </a>
    
     The API request lifecycle
    
   </h1>
   <p>
    
     APIs share
    
    <a id="_idIndexMarker085">
    </a>
    
     one thing in common, irrespective of the underlying technology – the conversation between client and server.
    
    
     The lifecycle of this conversation is visualized in
    
    
     <em class="italic">
      
       Figure 3
      
     </em>
    
    
     <em class="italic">
      
       .1
      
     </em>
    
    
     
      .
     
    
   </p>
   <div><div><img alt="Figure 3.1: The journey of an HTTP request" src="img/B20968_03_01.jpg"/>
     
    </div>
   </div>
   <p class="IMG---Caption" lang="en-US" xml:lang="en-US">
    
     Figure 3.1: The journey of an HTTP request
    
   </p>
   <p>
    
     Let’s explore this lifecycle in more detail.
    
    
     Specifically, for ASP.NET, and therefore minimal APIs, the steps we outline next are taken from the point a client makes a request, to the point a
    
    <a id="_idIndexMarker086">
    </a>
    
     response
    
    
     
      is received:
     
    
   </p>
   <ol>
    <li>
     <strong class="bold">
      
       The request is parsed
      
     </strong>
     
      – On receipt of the request, ASP.NET takes the incoming data and extracts critical information, such as the HTTP method in use (GET, POST, PUT, etc.).
     
     
      The URL is extracted, along with the request’s headers
     
     
      
       and body.
      
     
    </li>
    <li>
     <strong class="bold">
      
       The middleware pipeline is executed
      
     </strong>
     
      – Middleware sitting in the chain is processed, with each middleware component operating on the request as configured.
     
     
      For example, authentication middleware could check that the sender of the request is authenticated, custom middleware could alter the structure of the request, and logging middleware could reference the request in logs that it writes to various
     
     
      
       data sources.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Routing
      
     </strong>
     
      – Now that the application has parsed the request and processed it through any relevant middleware, it can match the extracted URL and HTTP method against the routes configured in the API.
     
     
      This allows the request’s content to be routed to the appropriate endpoint for handling.
     
     
      Routing is just another example of a middleware component.
     
     
      As such, its order of execution can be altered within
     
     
      
       the pipeline.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Dependency injection
      
     </strong>
     
      – Once the request has been routed to the correct request, the dependency injection container will resolve any dependencies required to process the request and inject them into the components containing the endpoint, making them available
     
     
      
       during processing.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Request handling
      
     </strong>
     
      – The request is effectively now
     
     <em class="italic">
      
       inside the endpoint
      
     </em>
     
      , as in, it is being processed by the logic a developer has written inside the body of a minimal API endpoint they have written.
     
     
      Parameters passed in can be used within the endpoint body to process the
     
     
      
       required logic.
      
     
    </li>
    <li>
     <strong class="bold">
      
       Response generation
      
     </strong>
     
      – Once the logic defined within the body of the endpoint has finished executing (or if an exception is thrown), a response will be generated.
     
     
      The response contains any expected data for the HTTP method on the endpoint, such as JSON or a simple string.
     
     
      It also has a status code appropriate to the processing result, for example,
     
     <strong class="source-inline">
      
       200 OK
      
     </strong>
     
      ,
     
     <strong class="source-inline">
      
       400 Bad Request
      
     </strong>
     
      , or
     
     <strong class="source-inline">
      
       500 Internal Server Error
      
     </strong>
     
      .
     
     
      Once generated, the response is sent back to the client, and the HTTP conversation
     
     
      
       is over.
      
     
    </li>
   </ol>
   <p>
    
     Now that we
    
    <a id="_idIndexMarker087">
    </a>
    
     have explored the journey of a request, let’s review what we have covered in
    
    
     
      this chapter.
     
    
   </p>
   <h1 id="_idParaDest-51">
    <a id="_idTextAnchor079">
    </a>
    
     Summary
    
   </h1>
   <p>
    
     The chapter has detailed the different components that ASP.NET employs to construct an application capable of hosting minimal API endpoints.
    
    
     It explained how the
    
    <strong class="bold">
     
      WebApplication
     
    </strong>
    
     instance is configured using the
    
    <strong class="bold">
     
      WebApplicationBuilder
     
    </strong>
    
     .
    
    
     The chapter also described the integration of elements like routing, services, dependency injection, and middleware into the application.
    
    
     Additionally, it emphasized the importance of the application lifecycle and how lifecycle events can be managed through hooks.
    
    
     The journey of an HTTP request from the client to minimal API endpoints and back was also discussed.
    
    
     Finally, the chapter outlined the steps involved in matching incoming requests with the appropriate logic, and the process of handling the request in preparation for a
    
    
     
      client response.
     
    
   </p>
   <p>
    
     In the next chapter, we will move away from the conceptual and back to the practical with a more advanced guide on handling HTTP requests
    
    
     
      and routing.
     
    
   </p>
  </div>
 

  <div><h1 id="_idParaDest-52" lang="en-US" xml:lang="en-US">
    <a id="_idTextAnchor080">
    </a>
    
     Part 2 - Data and Execution Flow
    
   </h1>
   <p>
    
     This part delves into the crucial aspects of how data flows through minimal APIs.
    
    
     You’ll learn how to handle various HTTP methods, set up routing, customize middleware pipelines, and integrate with different data sources.
    
    
     These chapters cover everything from dependency injection to working with databases using
    
    <strong class="bold">
     
      Object-Relational Mapping
     
    </strong>
    
     (
    
    
     <strong class="bold">
      
       ORM
      
     </strong>
    
    
     
      ) tools.
     
    
   </p>
   <p>
    
     This part has the
    
    
     
      following chapters:
     
    
   </p>
   <ul>
    <li>
     <a href="B20968_04.xhtml#_idTextAnchor081">
      <em class="italic">
       
        Chapter 4
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Handling HTTP Methods and Routing
      
     </em>
    </li>
    <li>
     <a href="B20968_05.xhtml#_idTextAnchor094">
      <em class="italic">
       
        Chapter 5
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       The Middleware Pipeline
      
     </em>
    </li>
    <li>
     <a href="B20968_06.xhtml#_idTextAnchor105">
      <em class="italic">
       
        Chapter 6
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Parameter Binding
      
     </em>
    </li>
    <li>
     <a href="B20968_07.xhtml#_idTextAnchor119">
      <em class="italic">
       
        Chapter 7
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Dependency Injection in Minimal APIs
      
     </em>
    </li>
    <li>
     <a href="B20968_08.xhtml#_idTextAnchor132">
      <em class="italic">
       
        Chapter 8
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Integrating Minimal APIs with Data Sources
      
     </em>
    </li>
    <li>
     <a href="B20968_09.xhtml#_idTextAnchor143">
      <em class="italic">
       
        Chapter 9
       
      </em>
     </a>
     
      ,
     
     <em class="italic">
      
       Object Relational Mapping with Entity Framework Core and Dapper
      
     </em>
    </li>
   </ul>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
  <div><div></div>
  </div>
 </body></html>