- en: '9'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '9'
- en: Handling User Input and Validation
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 处理用户输入和验证
- en: User input forms the core of any interactive application. The way we manage
    this input, validate it, and respond to it directly influences the user experience
    of our application. While backend validation of user input is indispensable to
    maintaining data integrity, providing immediate and useful feedback on the frontend
    is equally important for a good user experience. In this chapter, we’re going
    to dig into the crucial topic of managing user input and validation within a .NET
    MAUI application utilizing the MVVM design pattern.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 用户输入是任何交互式应用程序的核心。我们管理、验证和响应用户输入的方式直接影响了我们应用程序的用户体验。虽然后端验证用户输入对于维护数据完整性是必不可少的，但在前端提供即时且有用的反馈对于良好的用户体验同样重要。在本章中，我们将深入探讨在.NET
    MAUI应用程序中利用MVVM设计模式管理用户输入和验证的关键主题。
- en: 'This chapter is organized into the following sections:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 本章分为以下几部分：
- en: Implementing input validation on ViewModels
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在ViewModel中实现输入验证
- en: Visualizing validation errors with triggers
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用触发器可视化验证错误
- en: Prompts and alerts
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 提示和警报
- en: Confirming or canceling navigation
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 确认或取消导航
- en: With the aim of making our application more dynamic and interactive, this chapter
    will focus on handling user input effectively – ensuring a smooth and seamless
    user experience. Let’s dive in!
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使我们的应用程序更加动态和交互式，本章将专注于有效地处理用户输入——确保流畅且无缝的用户体验。让我们开始吧！
- en: Technical requirements
  id: totrans-9
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'In this chapter, we’ll further enrich the *Recipes!* app with more features.
    To stay in sync, all the resources and code snippets are available on GitHub:
    [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter09](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter09).
    If you’re looking to actively code alongside the chapter, it’s best to kick off
    from the `Start` folder. The finalized version can be found in the `Finish` folder.'
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将进一步丰富 *Recipes!* 应用程序的功能。为了保持同步，所有资源和代码片段都可在GitHub上找到：[https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter09](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter09)。如果您想与本章一起积极编码，最好从
    `Start` 文件夹开始。最终版本可在 `Finish` 文件夹中找到。
- en: Implementing input validation on ViewModels
  id: totrans-11
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在ViewModel中实现输入验证
- en: Input validation can be implemented in various ways and at different points
    within the life cycle of user interaction. It could happen as soon as a user changes
    a property, providing immediate feedback on the validity of the data entered.
    On the other hand, it might be performed only when the user initiates a certain
    action, such as clicking a button, thereby offering a more cumulative validation
    experience. Deciding on when and how to implement validation often depends on
    the specific requirements of your project. It’s a balance between the need for
    immediate feedback and maintaining a smooth, uninterrupted user flow. There’s
    no one-size-fits-all solution, and the strategy can vary based on the complexity
    of the data, the form of user interaction, and the overall design of your application.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 输入验证可以在用户交互生命周期的不同阶段以各种方式实现。它可能发生在用户更改属性时，立即提供关于输入数据有效性的反馈。另一方面，它可能仅在用户启动某些操作时执行，例如点击按钮，从而提供更累积的验证体验。决定何时以及如何实现验证通常取决于您项目的具体要求。这是在即时反馈和保持流畅、不间断的用户流程之间的平衡。没有一种适合所有情况的解决方案，策略可以根据数据的复杂性、用户交互的形式以及您应用程序的整体设计而有所不同。
- en: 'Implementing validation on the frontend offers several advantages: it provides
    users with immediate feedback, ensuring a more responsive and intuitive experience.
    Moreover, by catching and rectifying issues right at the source, we can reduce
    the risk of sending incorrect data to the backend. However, it''s essential to
    note that frontend validation should complement, not replace, backend validation.
    The ViewModel is the ideal location for frontend validation as it serves as our
    first line of defense against potential data inconsistencies or errors before
    they reach backend systems.'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在前端实现验证具有几个优点：它为用户提供即时反馈，确保更响应和直观的体验。此外，通过在源头捕捉和纠正问题，我们可以降低将错误数据发送到后端的风险。然而，需要注意的是，前端验证应补充而非取代后端验证。ViewModel是前端验证的理想位置，因为它作为我们防止潜在数据不一致或错误在到达后端系统之前的第一道防线。
- en: In this section, we’ll be focusing on the implementation of input validation
    in ViewModels. We’ll specifically delve into the use of the `ObservableValidator`,
    a powerful tool that’s part of the MVVM Community Toolkit. This feature makes
    handling validation responses and displaying meaningful feedback to the user a
    breeze. Let’s move on to explore the `ObservableValidator` in detail, and how
    it can enhance our approach to input validation.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将专注于ViewModel中输入验证的实现。我们将特别深入探讨`ObservableValidator`的使用，它是MVVM社区工具包的一部分，是一个强大的工具。这个特性使得处理验证响应并向用户显示有意义的反馈变得轻而易举。让我们继续详细探索`ObservableValidator`，以及它是如何增强我们对输入验证方法的。
- en: Using the ObservableValidator
  id: totrans-15
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 使用`ObservableValidator`
- en: Validating user input is a cornerstone of robust applications. While it’s entirely
    possible to write our own validation logic – checking properties as they update
    or when commands are invoked and then populating validation properties that can
    be bound to the UI – it often involves reinventing common patterns. Instead of
    starting from scratch, why not leverage existing tools designed for this exact
    purpose? One of the best practices for user input validation in the MVVM pattern
    is the use of the `ObservableValidator`. This class, a part of the MVVM Community
    Toolkit, inherits from the `ObservableObject` class and implements the `System.ComponentModel.INotifyDataErrorInfo`
    interface. This interface, which isn’t specific to .NET MAUI, provides a robust
    system for reporting and managing errors in objects. It includes an `ErrorsChanged`
    event that you can subscribe to in order to be notified of changes in validation
    status and a `GetErrors` method that retrieves validation errors for a specified
    property or the entire object.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 验证用户输入是构建健壮应用程序的基础。虽然我们可以完全编写自己的验证逻辑——在属性更新或命令调用时检查属性，然后填充可以绑定到UI的验证属性——但这通常涉及重新发明常见的模式。为什么不利用为这一特定目的设计的现有工具呢？在MVVM模式中，用户输入验证的最佳实践之一是使用`ObservableValidator`。这个类是MVVM社区工具包的一部分，它继承自`ObservableObject`类并实现了`System.ComponentModel.INotifyDataErrorInfo`接口。这个接口并不特定于.NET
    MAUI，它提供了一个强大的系统来报告和管理对象中的错误。它包括一个`ErrorsChanged`事件，你可以订阅它以接收验证状态变化的通知，以及一个`GetErrors`方法，用于检索指定属性或整个对象的验证错误。
- en: When a property value is updated, the `ObservableValidator` has the ability
    to automatically validate it using its `SetProperty` method overloads. It also
    offers `TrySetProperty` overloads that update a property value only when validation
    is successful and can return any generated errors. For scenarios that require
    manual control over validation, the `ObservableValidator` provides `ValidateProperty`
    and `ValidateAllProperties` methods, which can be used to manually trigger validation
    for specific properties or all properties, respectively. Additionally, it offers
    a `ClearAllErrors` method, ideal for resetting a form for reuse.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 当属性值更新时，`ObservableValidator`能够使用其`SetProperty`方法的重载自动验证它。它还提供了`TrySetProperty`的重载，只有在验证成功时才会更新属性值，并且可以返回任何生成的错误。对于需要手动控制验证的场景，`ObservableValidator`提供了`ValidateProperty`和`ValidateAllProperties`方法，可以用来手动触发特定属性或所有属性的验证。此外，它还提供了一个`ClearAllErrors`方法，非常适合用于重置表单以便再次使用。
- en: The flexibility of `ObservableValidator` extends to compatibility with the wide
    range of validation attributes provided by the `System.ComponentModel.DataAnnotations`
    namespace. This means you can leverage a set of common validation rules that are
    essential in many scenarios, such as `[Required]`, `[StringLength]`, `[Range]`,
    `[Compare]`, `[RegularExpression]`, and many more. These attributes allow for
    an expressive way to define validation rules directly on your ViewModel’s properties,
    leading to a highly readable and maintainable code base. The `ObservableValidator`
    will pick up these attributes when validating a property, making the validation
    process seamless and straightforward. You can also define your own specific validation
    rules by encapsulating complex validation logic into dedicated validation methods
    or even in custom `ValidationAttribute` classes, which can be reused across your
    application.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`ObservableValidator` 的灵活性扩展到与 `System.ComponentModel.DataAnnotations` 命名空间提供的广泛验证属性兼容。这意味着您可以使用一组在许多场景中必不可少的常见验证规则，例如
    `[Required]`、`[StringLength]`、`[Range]`、`[Compare]`、`[RegularExpression]` 以及更多。这些属性允许以表达的方式直接在
    ViewModel 的属性上定义验证规则，从而实现高度可读性和可维护的代码库。当验证属性时，`ObservableValidator` 会拾取这些属性，使验证过程无缝且直接。您还可以通过将复杂的验证逻辑封装到专门的验证方法中，甚至是在自定义
    `ValidationAttribute` 类中定义自己的特定验证规则，这些类可以在您的应用程序中重用。'
- en: Let’s go ahead and see how we can add validation to `AddRatingViewModel` using
    the `ObservableValidator`.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 `ObservableValidator` 为 `AddRatingViewModel` 添加验证。
- en: Pre-configured validation rules
  id: totrans-20
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 预配置的验证规则
- en: 'As previously mentioned, the `ObservableValidator` class leverages the power
    of the validation attributes found within the `System.ComponentModel.DataAnnotations`
    namespace. These attributes can be easily applied to your properties and the `ObservableValidator`
    class will use them for validating the corresponding property values. This relationship
    between the `ObservableValidator` and the `DataAnnotations` namespace offers an
    array of pre-configured validation rules, simplifying the process of implementing
    input validation in your ViewModel. Let’s start by marking some properties as
    required:'
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，`ObservableValidator` 类利用了 `System.ComponentModel.DataAnnotations` 命名空间中找到的验证属性的力量。这些属性可以轻松地应用于您的属性，而
    `ObservableValidator` 类将使用它们来验证相应的属性值。`ObservableValidator` 与 `DataAnnotations`
    命名空间之间的关系提供了一系列预配置的验证规则，简化了在 ViewModel 中实现输入验证的过程。让我们首先将一些属性标记为必填项：
- en: 'Head over to `AddRatingViewModel` and instead of inheriting the `ObservableObject`
    class, make it inherit the `ObservableValidator` class, as shown here:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 `AddRatingViewModel`，而不是继承 `ObservableObject` 类，让它继承 `ObservableValidator`
    类，如下所示：
- en: '[PRE0]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: '[Required]'
  id: totrans-24
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Required]'
- en: public string EmailAddress { … }
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public string EmailAddress { … }
- en: '[Required]'
  id: totrans-26
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Required]'
- en: public string DisplayName { ... }
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public string DisplayName { … }
- en: '[Required]'
  id: totrans-28
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '[Required]'
- en: public string RatingInput { ... }
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: public string RatingInput { ... }
- en: '[PRE1]'
  id: totrans-30
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `AddRatingViewModel` class contains a `SubmitCommand`, which calls the
    `OnSubmit` method. Let’s update this method so it validates all the properties
    and writes the validation messages to the debug window:'
  id: totrans-31
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AddRatingViewModel` 类包含一个 `SubmitCommand`，它调用 `OnSubmit` 方法。让我们更新这个方法，以便它验证所有属性并将验证消息写入调试窗口：'
- en: '[PRE2]'
  id: totrans-32
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: With the `ValidateAllProperties` method, all properties of the current class
    are validated. After calling this method, we can check the `HasErrors` property
    to see if there are any violations. If so, the `GetErrors` method allows us to
    retrieve a list of `ValidationResult` objects. A `ValidationResult` object contains
    a list of member names affected by this result and an `ErrorMessage`.
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 使用 `ValidateAllProperties` 方法，验证当前类的所有属性。调用此方法后，我们可以检查 `HasErrors` 属性以查看是否存在违规行为。如果有，`GetErrors`
    方法允许我们检索 `ValidationResult` 对象的列表。`ValidationResult` 对象包含受此结果影响的成员名称列表和 `ErrorMessage`。
- en: Go ahead and debug the app! If you go to the `AddRatingPage`, leave everything
    empty and click the **Submit** button. You’ll see the error messages printed in
    the **Output** window in Visual Studio.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 继续调试应用程序！如果您转到 `AddRatingPage`，留空所有内容并点击 **提交** 按钮。您将在 Visual Studio 的 **输出**
    窗口中看到错误消息。
- en: Validating and errors
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 验证和错误
- en: 'The `ValidateAllProperties` method validates all properties in the ViewModel.
    The `ValidateProperty` method, which accepts a value and property name will check
    whether the given value is valid for the given property. This is an easy way to
    validate a single property. The `HasErrors` property will be set according to
    the properties that have been validated. The same thing goes for the `GetErrors`
    method: it returns `ValidationResult` objects for the properties that have been
    validated. This method also has an overload where you can pass in a property name
    to get back the errors for that specific property. The `GetErrors` method won’t
    do any validation by itself, trying to get the errors of a property that hasn’t
    been validated will yield no results. The `ClearErrors` method allows for removing
    all errors or only those of a particular property when a property name is provided.'
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidateAllProperties`方法验证ViewModel中的所有属性。`ValidateProperty`方法接受一个值和属性名，将检查给定值是否适用于给定属性。这是一种验证单个属性简单的方法。`HasErrors`属性将根据已验证的属性设置。对于`GetErrors`方法也是如此：它返回已验证属性的`ValidationResult`对象。此方法还有一个重载版本，您可以传递一个属性名以获取该特定属性的错误。`GetErrors`方法本身不会进行任何验证，尝试获取未验证属性的错误将不会产生任何结果。`ClearErrors`方法允许在提供属性名时移除所有错误或特定属性的错误。'
- en: Let’s enhance our validation by adding more validation rules and disabling the
    **Submit** button until all input is valid.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过添加更多的验证规则并禁用**提交**按钮直到所有输入有效来增强我们的验证。
- en: 'On the `EmailAddress` property, we should add an additional validation attribute.
    We can use the `RegularExpressionAttribute` to check whether a value matches a
    given regex expression:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 在`EmailAddress`属性上，我们应该添加一个额外的验证属性。我们可以使用`RegularExpressionAttribute`来检查一个值是否与给定的正则表达式匹配：
- en: 'The following snippet shows how we can add an extra validation attribute to
    the `EmailAddress` property using the `RegularExpressionAttribute` to ensure the
    value matches a specified regex pattern. This pattern will be used to validate
    whether the given value is an email address:'
  id: totrans-39
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何使用`RegularExpressionAttribute`将额外的验证属性添加到`EmailAddress`属性，以确保值匹配指定的正则表达式模式。此模式将用于验证给定值是否为电子邮件地址：
- en: '[PRE3]'
  id: totrans-40
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'To ensure the `DisplayName` property has a minimum and maximum length, we can
    use the `MinLength` and `MaxLength` attributes. Let’s add them:'
  id: totrans-41
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了确保`DisplayName`属性具有最小和最大长度，我们可以使用`MinLength`和`MaxLength`属性。让我们添加它们：
- en: '[PRE4]'
  id: totrans-42
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'To constrain the `RatingInput` property to a value between 0 and 4 with zero
    or one decimal point, we can use the `RangeAttribute` for the range constraint
    and `RegularExpressionAttribute` for the decimal limit:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了将`RatingInput`属性约束在0到4之间，带有零或一个十进制点，我们可以使用`RangeAttribute`进行范围约束和`RegularExpressionAttribute`进行十进制限制：
- en: '[PRE5]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'And finally, we want to validate each property when its value gets updated.
    The `ObservableValidator` class has an overloaded `SetProperty` method, which
    accepts a `bool` value indicating whether the provided value needs to be validated.
    This is how it looks for the `EmailAddress` property:'
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们希望在属性值更新时验证每个属性。`ObservableValidator`类有一个重载的`SetProperty`方法，它接受一个`bool`值，指示提供的值是否需要验证。这是`EmailAddress`属性的示例：
- en: '[PRE6]'
  id: totrans-46
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: SetProperty and TrySetProperty
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`SetProperty`和`TrySetProperty`'
- en: Note that this overloaded `SetProperty` will set the value of the backing field
    and trigger the `PropertyChanged` event, no matter whether the provided value
    is valid or not. There is also a `TrySetProperty` on the `ObservableValidator`
    class, which will not set the value on the property when it is invalid. It returns
    a `bool` value indicating whether the value was set or not and has an `out` parameter,
    which returns a collection of errors.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个重载的`SetProperty`方法无论提供的值是否有效，都会设置后备字段的值并触发`PropertyChanged`事件。在`ObservableValidator`类中还有一个`TrySetProperty`方法，当属性值无效时，它不会设置属性值。它返回一个`bool`值，指示值是否已设置，并且有一个`out`参数，返回错误集合。
- en: 'The `AddRatingViewModel` class contains a command `SubmitCommand`. This command
    should only be executable when the provided values of the properties are considered
    valid. For that, we can point the `canExecute` function of the `SubmitCommand`
    to the `HasErrors` property, as shown here:'
  id: totrans-49
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`AddRatingViewModel`类包含一个命令`SubmitCommand`。这个命令应该在提供的属性值被认为是有效的情况下才可执行。为此，我们可以将`SubmitCommand`的`canExecute`函数指向`HasErrors`属性，如下所示：'
- en: '[PRE7]'
  id: totrans-50
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: public AddRatingViewModel(
  id: totrans-51
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`public AddRatingViewModel(`'
- en: INavigationService navigationService)
  id: totrans-52
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`INavigationService navigationService)`'
- en: '{'
  id: totrans-53
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: '...'
  id: totrans-54
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '...'
- en: ErrorsChanged += AddRatingViewModel_ErrorsChanged;
  id: totrans-55
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ErrorsChanged += AddRatingViewModel_ErrorsChanged;
- en: '}'
  id: totrans-56
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: private void AddRatingViewModel_ErrorsChanged(
  id: totrans-57
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: private void AddRatingViewModel_ErrorsChanged(
- en: object? sender, DataErrorsChangedEventArgs e)
  id: totrans-58
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: object? sender, DataErrorsChangedEventArgs e)
- en: '{'
  id: totrans-59
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '{'
- en: SubmitCommand.NotifyCanExecuteChanged();
  id: totrans-60
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: SubmitCommand.NotifyCanExecuteChanged();
- en: '}'
  id: totrans-61
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '}'
- en: '[PRE8]'
  id: totrans-62
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Now, if you run the app and navigate to `AddRatingPage`, you’ll find the `CanExecute`
    method of `SubmitCommand` being based on the absence of validation errors. *Figure
    9**.1* shows what this looks like:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，如果你运行应用程序并导航到`AddRatingPage`，你会发现`SubmitCommand`的`CanExecute`方法基于验证错误的缺失。*图9.1*展示了这看起来是什么样子：
- en: '![Figure 9.1: Enabled Submit button when there are no errors (right)](img/B20941_09_01.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图9.1：没有错误时启用提交按钮（右）](img/B20941_09_01.jpg)'
- en: 'Figure 9.1: Enabled Submit button when there are no errors (right)'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.1：没有错误时启用提交按钮（右）
- en: The pre-configured validation attributes we’ve discussed so far can simplify
    the process of adding validation to your ViewModels. However, there will be scenarios
    where these built-in rules don’t meet your specific requirements, and you’ll need
    to create your own custom validation logic. Let’s explore how to implement that
    next.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论的预配置验证属性可以简化向ViewModel添加验证的过程。然而，在某些情况下，这些内置规则可能无法满足你的特定要求，你需要创建自己的自定义验证逻辑。让我们接下来探讨如何实现这一点。
- en: Creating custom validation rules
  id: totrans-67
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 创建自定义验证规则
- en: 'Often, the pre-configured validation rules just won’t cut it and you’ll need
    to add your own custom validation logic. When working with the `ObservableValidator`
    class, there are two options for implementing custom validation rules:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，预配置的验证规则可能不足以满足需求，你需要添加自己的自定义验证逻辑。当与`ObservableValidator`类一起工作时，实现自定义验证规则有两种选择：
- en: The first approach involves creating a completely new validation attribute by
    extending the base `ValidationAttribute` class. This allows you to encapsulate
    your own validation logic in a reusable component, keeping your ViewModel cleaner
    and more focused on its primary responsibility. You can then apply this custom
    attribute to any property in the same way you’d apply the built-in attributes.
  id: totrans-69
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第一种方法涉及通过扩展基类`ValidationAttribute`创建一个全新的验证属性。这允许你在可重用的组件中封装自己的验证逻辑，使你的ViewModel更干净，更专注于其主要职责。然后，你可以像应用内置属性一样将此自定义属性应用于任何属性。
- en: The second option involves using the `CustomValidation` attribute, which enables
    you to specify a static method to handle the validation right at the point of
    declaration. This method allows for more localized, context-specific validation
    scenarios where creating a separate attribute class might be overkill.
  id: totrans-70
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 第二种选择涉及使用`CustomValidation`属性，这允许你在声明点直接指定一个静态方法来处理验证。这种方法允许实现更本地化、上下文特定的验证场景，在这种情况下，创建一个单独的属性类可能就过于冗余了。
- en: Let’s examine both methods in more detail to see how they can be used to address
    custom validation requirements.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们更详细地检查这两种方法，看看它们如何被用来解决自定义验证需求。
- en: Create a custom attribute
  id: totrans-72
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 创建一个自定义属性
- en: 'Let’s add a validation rule that we want to use on the `Review` property. Although
    a review is optional, if provided, it must fall within a certain length range.
    Since such a rule could potentially be reused across different scenarios, it makes
    sense to put this validation logic in a custom attribute. Here’s how we can go
    about it:'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们添加一个我们想在`Review`属性上使用的验证规则。尽管评论是可选的，但如果提供了，它必须在一个特定的长度范围内。由于这样的规则可能在不同场景中被重复使用，因此将此验证逻辑放入自定义属性中是有意义的。下面是如何操作的：
- en: Right-click the `Recipes.Client.Core` project in the `Validation` as the name
    of the new folder.
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Validation`文件夹中，右键单击`Recipes.Client.Core`项目，将其命名为新的文件夹。
- en: Right-click the `Validation` folder, select `EmptyOrWithinRangeAttribute` as
    the class name.
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键单击`Validation`文件夹，选择`EmptyOrWithinRangeAttribute`作为类名。
- en: 'Make this class inherit the `ValidationAttribute` class like this:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让这个类继承`ValidationAttribute`类，如下所示：
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Next, add two properties, `MinLength` and `MaxLength`, of type `int`:'
  id: totrans-78
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加两个属性，`MinLength`和`MaxLength`，类型为`int`：
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: These properties allow an even wider usage of this attribute. They allow developers
    to customize the length constraints each time they apply this attribute to a property.
    This way, the exact minimum and maximum lengths required for validation can be
    tailored to fit each individual property’s needs as the developer can declare
    the desired minimum and maximum length.
  id: totrans-80
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些属性允许更广泛地使用此属性。它们允许开发者在将此属性应用于属性时自定义长度约束。这样，可以针对每个单独的属性定制所需的精确最小和最大长度，因为开发者可以声明所需的最低和最高长度。
- en: 'The next step is to override the `IsValid` method. This method gets invoked
    when the validation process begins for the property where the attribute is applied.
    Let’s see how we can implement it:'
  id: totrans-81
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一步是重写`IsValid`方法。当对应用了属性的属性开始验证过程时，该方法会被调用。让我们看看我们如何实现它：
- en: '[PRE11]'
  id: totrans-82
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The value parameter, of type `object`, represents the property value that needs
    to be validated. The second parameter, of type `ValidationContext`, provides further
    context, including the instance of the object being validated and the property.
    Returning `ValidationResult.Success` indicates that the given value is valid,
    else we return a descriptive error message.
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 值参数，类型为`object`，表示需要验证的属性值。第二个参数，类型为`ValidationContext`，提供了更多的上下文，包括正在验证的对象的实例和属性。返回`ValidationResult.Success`表示给定的值是有效的，否则我们返回一个描述性的错误消息。
- en: 'Finally, we can use this attribute on the `Review` property of the `AddRatingViewModel`
    like this:'
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以在`AddRatingViewModel`的`Review`属性上使用这个属性，如下所示：
- en: '[PRE12]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: With our custom validation attribute in place, the `Review` property can be
    validated so that it is empty or falls within the given length range. This attribute
    can easily be reused across the entire app.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的自定义验证属性就绪后，`Review`属性可以被验证，使其为空或位于给定的长度范围内。此属性可以轻松地在整个应用程序中重用。
- en: Using the CustomValidation attribute
  id: totrans-87
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 使用CustomValidation属性
- en: 'The `ValidationResult` object and take a parameter matching the type of the
    property being validated, along with a `ValidationContext` object. This is similar
    to the `IsValid` method we override when implementing our own `ValidationAttribute`.
    Let’s add an additional validation to the `Review` property so that it is required
    when the given rating is less than or equal to 2:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidationResult`对象，并接受一个与正在验证的属性类型匹配的参数，以及一个`ValidationContext`对象。这与我们在实现自己的`ValidationAttribute`时重写的`IsValid`方法类似。让我们给`Review`属性添加一个额外的验证，以便在给定的评分小于或等于2时是必需的：'
- en: 'In the `AddRatingViewModel`, add a new static method called `ValidateReview`
    with the following implementation:'
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AddRatingViewModel`中，添加一个名为`ValidateReview`的新静态方法，其实现如下：
- en: '[PRE13]'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This method accepts a parameter of type `string`, matching the type of the property
    we want to validate. The second parameter is of type `ValidationContext`, which
    we can use to access the instance of the object the property is defined on. This
    allows us to access other properties on the object that is being validated, such
    as the `RatingInput` property in our case. When we can parse the `RatingInput`
    value to `double`, we can check whether it is less than or equal to 2\. If that
    is the case and the given review value is empty, we return a validation error.
    Otherwise, `Success` is returned.
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法接受一个类型为`string`的参数，与我们要验证的属性类型匹配。第二个参数是类型为`ValidationContext`，我们可以使用它来访问属性定义的对象的实例。这允许我们访问正在验证的对象上的其他属性，例如我们案例中的`RatingInput`属性。当我们可以将`RatingInput`值解析为`double`时，我们可以检查它是否小于或等于2。如果是这种情况，并且给定的评论值为空，我们返回一个验证错误。否则，返回`Success`。
- en: 'Now, we need to add a `CustomValidation` attribute to the `Review` property
    and point this to the static `ValidateReview` method that we just created. Let’s
    see how that’s done:'
  id: totrans-92
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在`Review`属性上添加一个`CustomValidation`属性，并将其指向我们刚刚创建的静态`ValidateReview`方法。让我们看看这是如何完成的：
- en: '[PRE14]'
  id: totrans-93
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The first parameter the `CustomValidation` attribute requires is the type the
    static validation method is defined on. In our case, we defined it on `AddRatingViewModel`
    itself, so we pass that in as the type. This means it is possible to define your
    validation methods elsewhere, bundling them in separate classes, for example.
    The second parameter is the name of the validation method. We use the `nameof`
    keyword to avoid magic strings and add compile-time error checking.
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`CustomValidation` 属性需要的第一参数是静态验证方法定义的类型。在我们的例子中，我们是在 `AddRatingViewModel`
    本身上定义的，所以我们将其作为类型传递。这意味着你可以在其他地方定义你的验证方法，例如将它们捆绑在单独的类中。第二个参数是验证方法的名称。我们使用 `nameof`
    关键字来避免使用魔法字符串，并添加编译时错误检查。'
- en: 'As the validation of the `Review` property is also dependent on the entered
    `RatingInput` property, we must make sure the `Review` property is also validated
    when the `RatingInput` property changes. As the following snippet shows, we can
    easily do this by calling the `ValidateProperty` method for the `Review` property
    when the value on the `RatingInput` property is updated:'
  id: totrans-95
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 由于 `Review` 属性的验证也依赖于输入的 `RatingInput` 属性，我们必须确保在 `RatingInput` 属性更改时也验证 `Review`
    属性。如下面的代码片段所示，我们可以通过在 `RatingInput` 属性的值更新时调用 `Review` 属性的 `ValidateProperty`
    方法来轻松地做到这一点：
- en: '[PRE15]'
  id: totrans-96
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: That’s it! That is all that’s needed to add custom validation, leveraging the
    `CustomValidation` attribute. This approach typically is for validation checking
    that is to be reused on different objects less. In this particular case, we access
    the `ValidationContext` `ObjectInstance` and cast it to a certain type, which
    naturally makes it unusable on different types.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 就这些了！这就是添加自定义验证、利用 `CustomValidation` 属性所需的所有内容。这种方法通常用于在较少的不同对象上重复使用的验证检查。在这种情况下，我们访问
    `ValidationContext` 的 `ObjectInstance` 并将其转换为特定类型，这自然使其在不同类型上不可用。
- en: Run your application and notice how the **Submit** button gets disabled when
    a rating of less than 3 is given and the review is left empty. Our validation
    logic is operating as expected! However, the current implementation lacks user-friendliness
    because it does not provide any feedback regarding invalid entries. Let’s see
    how to display these validation errors to the user.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 运行你的应用程序，注意当给出的评分低于 3 且评论为空时，**提交**按钮会被禁用。我们的验证逻辑正在按预期运行！然而，当前的实现缺乏用户友好性，因为它没有提供关于无效输入的任何反馈。让我们看看如何向用户展示这些验证错误。
- en: Showing errors onscreen
  id: totrans-99
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在屏幕上显示错误
- en: There are basically two approaches to show validation errors to the user. The
    first method usually provides an overview of all issues at once, typically at
    the top or bottom of a form. The second approach gives feedback right on the input
    field where the error occurred. This can often help users to correct the error
    more directly and quickly. Both methods have their uses and are often combined
    in applications for the best user experience.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 向用户展示验证错误基本上有两种方法。第一种方法通常一次概述所有问题，通常在表单的顶部或底部。第二种方法在发生错误的输入字段上直接提供反馈。这通常可以帮助用户更直接、更快速地纠正错误。这两种方法都有其用途，并且通常在应用程序中结合使用以获得最佳用户体验。
- en: Showing all errors
  id: totrans-101
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示所有错误
- en: While `ObservableValidator` doesn’t provide a property that lists all validation
    errors directly, it does offer a `GetErrors` method to fetch them. Sadly, data
    binding to methods isn’t possible. To align better with MVVM practices and facilitate
    data binding, it would be beneficial to introduce an `Errors` property of type
    `ObservableCollection<ValidationResult>`. This way, we can bind to our validation
    errors in the UI.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `ObservableValidator` 没有提供直接列出所有验证错误的属性，但它确实提供了一个 `GetErrors` 方法来获取它们。遗憾的是，数据绑定到方法是不可能的。为了更好地与
    MVVM 实践相一致并促进数据绑定，引入一个类型为 `ObservableCollection<ValidationResult>` 的 `Errors`
    属性将会很有益。这样，我们就可以在 UI 中绑定到我们的验证错误。
- en: 'Let’s see how we can achieve this:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何实现这一点：
- en: 'Add a property called `Errors` of type `ObservableCollection<ValidationResult>`
    to `AddRatingViewModel`:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个类型为 `ObservableCollection<ValidationResult>` 的 `Errors` 属性添加到 `AddRatingViewModel`
    中：
- en: '[PRE16]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The `AddRatingViewModel_ErrorsChanged` method on `AddRatingViewModel` is invoked
    when the `ErrorsChanged` event of `ObservableValidator` is triggered. Currently,
    this calls the `NotifyCanExecuteChanged` method on the `SubmitCommand`, but let’s
    update it so that it also (re-)populates the `Errors` collection that we just
    defined. The following code block shows how we can do this:'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当`ObservableValidator`的`ErrorsChanged`事件被触发时，`AddRatingViewModel`上的`AddRatingViewModel_ErrorsChanged`方法会被调用。目前，这调用`SubmitCommand`上的`NotifyCanExecuteChanged`方法，但让我们更新它，使其也（重新）填充我们刚刚定义的`Errors`集合。下面的代码块显示了我们可以如何做到这一点：
- en: '[PRE17]'
  id: totrans-107
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: The preceding code first clears the `Errors` collection. Next, it calls the
    `GetErrors` method of `ObservableValidator` to get all the errors. With the `ForEach`
    method, we can loop over all the items and call the `Errors.Add` method to add
    the current item to the `Errors` collection.
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 前面的代码首先清除了`Errors`集合。接下来，它调用`ObservableValidator`的`GetErrors`方法来获取所有错误。使用`ForEach`方法，我们可以遍历所有项目并调用`Errors.Add`方法将当前项目添加到`Errors`集合中。
- en: 'The preceding code should add all the current validation errors to the `Errors`
    property. The only thing that is left to do is to bind this collection to our
    view, as shown here:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前面的代码应该将所有当前验证错误添加到`Errors`属性。剩下要做的只是将这个集合绑定到我们的视图中，如下所示：
- en: '[PRE18]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'At this point, you should find the XAML code familiar and straightforward:
    the `Errors` collection is bound to the `BindableLayout` `ItemsSource` property
    on a `VerticalStackLayout`. The `ItemTemplate` stipulates that for each item we
    want to render a `Label` that shows its `ErrorMessage` property. The `DataType`
    of the `DataTemplate` is a `ValidationResult`. The `annotations` XML namespace
    is defined at the top of the page: **.**'
  id: totrans-111
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 到目前为止，你应该会发现XAML代码熟悉且简单：`Errors`集合绑定到`VerticalStackLayout`上的`BindableLayout`
    `ItemsSource`属性。`ItemTemplate`规定对于每个项目，我们想要渲染一个显示其`ErrorMessage`属性的`Label`。`DataTemplate`的`DataType`是`ValidationResult`。`annotations`
    XML命名空间在页面顶部定义：**.**
- en: '**The preceding code will result in showing a list of all the validation errors
    onscreen. Run the application and you should see the validation errors appearing
    and disappearing as you enter values, as *Figure* *9**.2* demonstrates.'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: '**前面的代码将导致在屏幕上显示所有验证错误的列表。运行应用程序，你应该会看到随着你输入值，验证错误的出现和消失，如图** *9**.2* 所示。'
- en: '![Figure 9.2: Showing up-to-date validation errors](img/B20941_09_02.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图9.2：显示最新的验证错误](img/B20941_09_02.jpg)'
- en: 'Figure 9.2: Showing up-to-date validation errors'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.2：显示最新的验证错误
- en: Although this already should improve the user experience a lot, we can take
    this a step further. Let’s enhance the UX by showing error messages inline, directly
    adjacent to the relevant input fields.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这已经可以大大改善用户体验，但我们还可以更进一步。让我们通过显示内联错误消息来增强UX，直接相邻于相关的输入字段。
- en: Showing inline errors
  id: totrans-116
  prefs:
  - PREF_H4
  type: TYPE_NORMAL
  zh: 显示内联错误
- en: 'The main challenge when it comes to displaying individual errors is developing
    a mechanism that enables us to retrieve and display validation errors related
    to a single property, rather than all validation errors at once. There is a very
    simple approach to this: for each property, expose an additional property containing
    a collection of errors for that property. Take a look at the following example:'
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 显示单个错误时的主要挑战是开发一种机制，使我们能够检索和显示与单个属性相关的验证错误，而不是一次性显示所有验证错误。对此有一个非常简单的方法：对于每个属性，公开一个包含该属性错误集合的附加属性。看看以下示例：
- en: '[PRE19]'
  id: totrans-118
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This `EmailValidationErrors` property gives a list of only the validation errors
    related to the `EmailAddress` property. This `EmailValidationErrors` property
    can be bound to the UI so that we can display the errors only relevant to the
    `EmailAddress` property on the screen. In order to keep this bound list up-to-date,
    we need to make sure we trigger the `PropertyChanged` event of the `EmailValidationErrors`
    property each time the `EmailAddress` property is updated, as shown here:'
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 这个`EmailValidationErrors`属性只提供与`EmailAddress`属性相关的验证错误列表。这个`EmailValidationErrors`属性可以绑定到UI上，这样我们就可以在屏幕上只显示与`EmailAddress`属性相关的错误。为了保持这个绑定列表的更新，我们需要确保每次`EmailAddress`属性更新时，都触发`EmailValidationErrors`属性的`PropertyChanged`事件，如下所示：
- en: '[PRE20]'
  id: totrans-120
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'By creating a dedicated property for each input’s validation errors and ensuring
    it’s updated whenever the input value changes, we can effectively isolate and
    display validation errors for individual fields. However, it does come with a
    caveat: for forms with numerous input fields, this method can be somewhat labor-intensive
    and repetitive. Let me show you an alternative that automates this process and
    saves us some manual work. The end result will be that we are going to bind to
    a particular property called `ErrorExposer`. Then, using its **indexer**, we will
    specify which property’s validation errors we want to retrieve and display, something
    like this:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 通过为每个输入的验证错误创建一个专用属性并确保在输入值更改时更新它，我们可以有效地隔离和显示单个字段的验证错误。然而，这也带来了一些副作用：对于具有许多输入字段的表单，这种方法可能有些费时且重复。让我向您展示一个自动化此过程并节省我们一些手动工作的替代方案。最终结果是我们将绑定到一个特定的属性，称为
    `ErrorExposer`。然后，使用它的 **索引器**，我们将指定要检索和显示哪个属性的验证错误，类似于这样：
- en: '[PRE21]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Let’s see how we can implement this mechanism:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何实现这个机制：
- en: In the `Validation` folder that we created earlier, select `ValidationErrorExposer`
    as the class name.
  id: totrans-124
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在我们之前创建的 `Validation` 文件夹中，选择 `ValidationErrorExposer` 作为类名。
- en: 'The `ValidationErrorExposer` class should implement two interfaces: `INotifyPropertyChanged`
    and `IDisposable`, as shown in the following snippet:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '`ValidationErrorExposer` 类应该实现两个接口：`INotifyPropertyChanged` 和 `IDisposable`，如下面的代码片段所示：'
- en: '[PRE22]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Next, let’s introduce a `readonly` field `validator` of type `ObservableValidator`.
    The value for this field should be passed in through the class constructor, as
    shown here:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们介绍一个 `readonly` 字段 `validator`，其类型为 `ObservableValidator`。这个字段的值应该通过类构造函数传入，如下所示：
- en: '[PRE23]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: The passed-in `observableValidator` is the instance that we want to automatically
    expose per-property validation errors.
  id: totrans-129
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 传入的 `observableValidator` 是我们想要自动暴露每个属性验证错误的实例。
- en: 'It’s time to add the `ValidationErrorExposer` indexer. An indexer in .NET allows
    an instance of a class to be accessed using an index, similar to an array or dictionary.
    This index can be of any type, such as a string or an int, and it lets you retrieve
    or set values without explicitly calling a method or property. In this case, we
    set the index to be a string as it represents the name of the property we want
    to get the validation errors of. This is how we can do this:'
  id: totrans-130
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 是时候添加 `ValidationErrorExposer` 索引器了。在 .NET 中，索引器允许使用索引访问类的实例，类似于数组或字典。这个索引可以是任何类型，例如字符串或整数，它允许你检索或设置值，而无需显式调用方法或属性。在这种情况下，我们将索引设置为字符串，因为它代表我们想要获取验证错误的属性的名称。这就是我们如何做到这一点的：
- en: '[PRE24]'
  id: totrans-131
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'In the constructor of the `ValidationErrorExposer` class, we should also subscribe
    to the `ErrorsChanged` event of the `ObservableValidator` that is being passed
    in, like this:'
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ValidationErrorExposer` 类的构造函数中，我们还应该订阅传入的 `ObservableValidator` 的 `ErrorsChanged`
    事件，如下所示：
- en: '[PRE25]'
  id: totrans-133
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: While it might seem like there’s some magic happening, the concept is fairly
    straightforward. In .NET MAUI, if an object has an indexer, you can bind to that
    indexer property as demonstrated by `{Binding ErrorExposer[EmailAddress]}`, where
    `ErrorExposer` is an instance of a type that contains an indexer. To notify the
    UI of an updated value, we can invoke the `PropertyChanged` event from the `ErrorExposer`
    and pass `Item[EmailAddress]` as the property name. Doing so will prompt all bindings
    tied to `ErrorExposer[EmailAddress]` to re-evaluate. Alternatively, invoking the
    `PropertyChanged` event with `PropertyChangedEventArgs` having `Item` as the property
    name will trigger a re-evaluation of all bindings associated with the indexer.
  id: totrans-134
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 虽然这看起来可能像是有某种魔法在起作用，但这个概念相当直接。在 .NET MAUI 中，如果一个对象有一个索引器，你可以绑定到那个索引器属性，就像示例
    `{Binding ErrorExposer[EmailAddress]}` 所展示的那样，其中 `ErrorExposer` 是一个包含索引器的类型的实例。为了通知
    UI 更新后的值，我们可以从 `ErrorExposer` 中调用 `PropertyChanged` 事件，并传递 `Item[EmailAddress]`
    作为属性名。这样做将促使所有绑定到 `ErrorExposer[EmailAddress]` 的绑定重新评估。或者，使用具有 `Item` 作为属性名的 `PropertyChangedEventArgs`
    调用 `PropertyChanged` 事件将触发与索引器相关联的所有绑定的重新评估。
- en: 'Finally, in `ValidationErrorExposer`, we should update the `Dispose` method
    to the following:'
  id: totrans-135
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，在 `ValidationErrorExposer` 中，我们应该更新 `Dispose` 方法如下：
- en: '[PRE26]'
  id: totrans-136
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE26]'
- en: Because we have subscribed to the `ObservableValidator` `ErrorsChanged` method,
    we need to provide a mechanism to unhook from this event, preventing any memory
    leaks. For that, we can use the `Dispose` method.
  id: totrans-137
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 由于我们已订阅了 `ObservableValidator` 的 `ErrorsChanged` 方法，我们需要提供一个机制来取消订阅此事件，以防止内存泄漏。为此，我们可以使用
    `Dispose` 方法。
- en: 'Let’s head back to `AddRatingViewModel` and add a property of type `ValidationErrorExposer`,
    as shown here:'
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们回到`AddRatingViewModel`并添加一个类型为`ValidationErrorExposer`的属性，如下所示：
- en: '[PRE27]'
  id: totrans-139
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'In the constructor of `AddRatingViewModel`, assign a new instance to this property:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`AddRatingViewModel`的构造函数中，将新实例分配给此属性：
- en: '[PRE28]'
  id: totrans-141
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE28]'
- en: We pass in `this` to the constructor of the `ValidationErrorExposer` class because
    it is the instance of the `AddRatingViewModel` itself that inherits from `ObservableValidator`
    and thus holds all validation errors.
  id: totrans-142
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将`this`传递给`ValidationErrorExposer`类的构造函数，因为它本身就是继承自`ObservableValidator`的`AddRatingViewModel`实例，因此包含所有验证错误。
- en: 'In XAML, we can now bind to a list of validation errors, specific to a particular
    property using the indexer on the `ValidationErrorExposer` class. This allows
    us to show these errors close to the relevant input fields themselves, as shown
    in the following snippet:'
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在XAML中，我们现在可以通过`ValidationErrorExposer`类的索引器绑定到特定属性的验证错误列表。这允许我们将这些错误显示在相关的输入字段附近，如下面的代码片段所示：
- en: '[PRE29]'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE29]'
- en: '`ValidationErrorExposer` allows us to easily get validation errors from a specific
    property, without needing to do any manual work: once this is in place, we can
    bind to the errors of any specific property using its indexer property.'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: '`ValidationErrorExposer`允许我们轻松地从特定属性获取验证错误，而无需进行任何手动工作：一旦设置好，我们就可以使用其索引属性绑定任何特定属性的错误。'
- en: Displaying validation errors near user input further improves the user experience.
    Let’s explore how to visually indicate the validity of entered values, improving
    the experience even more.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在用户输入附近显示验证错误可以进一步提高用户体验。让我们探讨如何通过视觉指示输入值的有效性，从而进一步提升体验。
- en: Visualizing validation errors with triggers
  id: totrans-147
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用触发器可视化验证错误
- en: '**Triggers** help us customize how UI elements work and look without building
    new controls from scratch.'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: '**触发器**帮助我们自定义UI元素的工作方式和外观，而无需从头开始构建新的控件。'
- en: While there are different types of triggers, we’ll focus on **data triggers**.
    These kick in when a property (on the ViewModel) changes, allowing us to adjust
    elements of a UI control dynamically, based on what the user does.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管存在不同类型的触发器，但我们将重点关注**数据触发器**。当ViewModel上的属性发生变化时，这些触发器会启动，使我们能够根据用户的行为动态调整UI控件元素。
- en: Types of triggers
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 触发器类型
- en: 'There are different types of triggers in .NET MAUI: PropertyTrigger, DataTrigger,
    EventTrigger, and so on… They all allow you to change the appearance of a UI control
    declaratively in XAML based upon a trigger. They only differ in what triggers
    the change: a property value, a bound value, an event. You can learn more about
    them at [https://learn.microsoft.com/dotnet/maui/fundamentals/triggers](https://learn.microsoft.com/dotnet/maui/fundamentals/triggers).'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI中有不同类型的触发器：属性触发器、数据触发器、事件触发器等等……它们都允许你在XAML中声明性地更改UI控件的外观，基于触发器。它们之间的区别在于触发变化的是什么：属性值、绑定值、事件。你可以在[https://learn.microsoft.com/dotnet/maui/fundamentals/triggers](https://learn.microsoft.com/dotnet/maui/fundamentals/triggers)了解更多关于它们的信息。
- en: In essence, a DataTrigger provides a way to declaratively set up UI changes
    in response to data changes, directly within your XAML, without having to write
    procedural code in your code-behind, a custom ValueConverter, or ViewModel.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，数据触发器提供了一种在XAML中声明性地设置UI变化以响应数据变化的方法，无需在代码后编写过程式代码、自定义值转换器或ViewModel。
- en: 'DataTriggers are a fairly easy-to-understand concept. So, let’s just dive in
    and add a visual indicator right next to the different `Entry` controls, indicating
    with a symbol and a particular color whether the entered value is valid or not,
    as *Figure* *9**.3* shows:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 数据触发器是一个相对容易理解的概念。所以，让我们直接深入并添加一个视觉指示器，紧邻不同的`Entry`控件旁边，用符号和特定的颜色指示输入的值是否有效，如图*9**.3*所示：
- en: '![Figure 9.3: Indicating input is valid (right) or not (left)](img/B20941_09_03.jpg)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图9.3：指示输入有效（右）或无效（左）](img/B20941_09_03.jpg)'
- en: 'Figure 9.3: Indicating input is valid (right) or not (left)'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 图9.3：指示输入有效（右）或无效（左）
- en: What about ValueConverters?
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 那么，值转换器呢？
- en: In [*Chapter 4*](B20941_04.xhtml#_idTextAnchor069), *Databinding in .NET MAUI*,
    we discussed the usage of value converters. The things that you can do with DataTriggers
    are also achievable with value converters and vice versa. But, with a DataTrigger,
    it is very easy to implement these visual effects declaratively, without a single
    line of C# code, also making the XAML more readable.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 在 [*第 4 章*](B20941_04.xhtml#_idTextAnchor069) 中，我们讨论了 .NET MAUI 中的数据绑定使用。你可以使用
    DataTriggers 实现的事情也可以用值转换器实现，反之亦然。但是，使用 DataTrigger，可以非常容易地声明式地实现这些视觉效果，而不需要一行
    C# 代码，这也使得 XAML 更易于阅读。
- en: 'Let’s have a look at how we can implement these visual cues using DataTriggers:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用 DataTriggers 来实现这些视觉提示：
- en: 'First, add a `Grid` around the `Entry` for the `EmailAddress` property:'
  id: totrans-159
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，为 `EmailAddress` 属性的 `Entry` 添加一个 `Grid`：
- en: '[PRE30]'
  id: totrans-160
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This `Grid` has two columns, with the `Entry` in the first one, and we will
    be adding the validity indicator in the second one.
  id: totrans-161
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个 `Grid` 有两列，第一列是 `Entry`，我们将在第二列中添加有效性指示器。
- en: 'Inside this `Grid`, below the `Entry`, add the following `Label`, which will
    serve as the validity indicator:'
  id: totrans-162
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这个 `Grid` 中，在 `Entry` 下方添加以下 `Label`，它将作为有效性指示器：
- en: '[PRE31]'
  id: totrans-163
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'By default, this `Label` shows the invalid state: red text and an exclamation
    mark icon.'
  id: totrans-164
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 默认情况下，这个 `Label` 显示无效状态：红色文本和感叹号图标。
- en: 'Now, we can add the `DataTrigger` and define that the `Label` needs to show
    a blue checkmark when the provided email address is valid. The following snippet
    shows how we can do that:'
  id: totrans-165
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们可以添加 `DataTrigger` 并定义当提供的电子邮件地址有效时，`Label` 需要显示蓝色勾选标记。以下代码片段展示了我们如何做到这一点：
- en: '[PRE32]'
  id: totrans-166
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE32]'
- en: A `DataTrigger` has a `Binding` property that allows us to bind to a certain
    value. In this case, we bind to the `Count` property of the list of validation
    errors related to the `EmailAddress` property. With the `Value` property, we can
    set a condition for this bound property. We set the value to `"0"`, meaning that
    there are no validation errors associated with the `EmailAddress` property. When
    the value of the property meets this condition, the trigger activates. Once activated,
    the trigger can change one or more properties of the UI control. In this particular
    case, we’re updating the `Text` and `TextColor` properties by specifying a `Setter`
    for these properties and providing a certain `Value`.
  id: totrans-167
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: '`DataTrigger` 有一个 `Binding` 属性，允许我们绑定到某个值。在这种情况下，我们绑定到与 `EmailAddress` 属性相关的验证错误列表的
    `Count` 属性。通过 `Value` 属性，我们可以为这个绑定属性设置一个条件。我们将值设置为 `"0"`，这意味着没有与 `EmailAddress`
    属性相关的验证错误。当属性的值满足这个条件时，触发器被激活。一旦激活，触发器可以改变 UI 控件的属性之一或多个。在这个特定的情况下，我们通过指定这些属性的
    `Setter` 并提供一定的 `Value` 来更新 `Text` 和 `TextColor` 属性。'
- en: As said, this can also be achieved with custom `ValueConverter`s, but this declarative
    way of defining it in XAML is very readable, maintainable, and easy to use.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，这也可以通过自定义 `ValueConverter`s 实现，但这种方式在 XAML 中声明式地定义它非常易于阅读、维护和使用。
- en: Behaviors
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: Behaviors
- en: Another way to give the user visual cues about the validity of entered values
    is by using **Behaviors**. Behaviors are like little plugins you can add to your
    UI elements, enhancing their default behavior without having to subclass them.
    They’re particularly useful because they encapsulate logic in reusable pieces,
    allowing developers to apply the same functionality across different controls.
    For example, a Behavior might allow a text input field to only accept numerical
    input or change its color when certain conditions are met. The .NET MAUI Community
    Toolkit comes with a set of ready-to-use Behaviors! You can learn more about them
    at [https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors](https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors).
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 另一种给用户提供关于输入值有效性的视觉提示的方法是使用 **Behaviors**。Behaviors 就像你可以添加到你的 UI 元素中的小插件，增强它们的默认行为，而无需对它们进行子类化。它们特别有用，因为它们封装了可重用的逻辑片段，允许开发者将相同的功能应用于不同的控件。例如，一个
    Behavior 可能允许文本输入字段只接受数值输入或在满足某些条件时改变其颜色。.NET MAUI 社区工具包附带了一套现成的 Behaviors！你可以在
    [https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors](https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors)
    上了解更多信息。
- en: In the next section, we’ll have a look at how to display prompts and alerts,
    essential parts for providing user feedback and gathering input.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将探讨如何显示提示和警报，这是提供用户反馈和收集输入的基本部分。
- en: Prompts and alerts
  id: totrans-172
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 提示和警报
- en: Direct feedback and clear communication are paramount when it comes to a solid
    user experience. As users navigate your application and interact with various
    inputs, there are moments where a subtle notification or a direct prompt can make
    all the difference. Prompts and alerts serve as these essential tools, guiding
    users through their journey, ensuring they’re informed and make intentional decisions.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 直接反馈和清晰的沟通对于良好的用户体验至关重要。当用户在应用程序中导航并与各种输入交互时，会有一些时刻，微妙的提示或直接的提示可以产生巨大的差异。提示和警报是这些基本工具，引导用户完成旅程，确保他们获得信息并做出有意的决策。
- en: Showing prompts and alerts is something that is platform-specific. Luckily .NET
    MAUI has got us covered as they provide simple and intuitive APIs for this. On
    the other hand, in an MVVM scenario, displaying a prompt or alert is mostly triggered
    from a ViewModel, which should be framework-independent. The solution, of course,
    is creating an interface for this functionality that a ViewModel can talk to.
    On the MAUI side of things, we can easily implement this interface and register
    it in our DI container so the implementation gets injected into the ViewModels.
    Let’s go ahead and set this up!
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 显示提示和警报是特定于平台的。幸运的是，.NET MAUI 为我们提供了覆盖，它们提供了简单直观的 API 来实现这一点。另一方面，在 MVVM 场景中，显示提示或警报通常是从
    ViewModel 触发的，这应该是框架无关的。解决方案当然是创建一个接口来实现这个功能，ViewModel 可以与之通信。让我们继续设置这个接口！
- en: To begin with, let’s add an interface that defines some methods for displaying
    prompts and alerts. Right-click the `Recipes.Client.Core` project in the `Services`.
  id: totrans-175
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个定义显示提示和警报方法的接口。在 `Services` 中右键点击 `Recipes.Client.Core` 项目。
- en: Add a new interface to this folder and call it `IDialogService`.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在此文件夹中添加一个新的接口，命名为 `IDialogService`。
- en: 'The methods defined in an `IDialogService` can defer from project to project.
    The following code block shows some method declarations that are often present
    in an `IDialogService` interface:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `IDialogService` 中定义的方法可能因项目而异。以下代码块显示了在 `IDialogService` 接口中常见的某些方法声明：
- en: '[PRE33]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: As said, depending on your specific use case, this interface might be extended
    with some other concrete method definitions.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 正如所说，根据您的具体用例，这个接口可能会扩展一些其他具体的方法定义。
- en: Next, we need to add an implementation for this interface. Add a new folder
    called `Services` to the `Recipes.Mobile` project.
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要为这个接口添加一个实现。在 `Recipes.Mobile` 项目中添加一个名为 `Services` 的新文件夹。
- en: 'Right-click the new `Services` folder and select `DialogService` as the name
    of the new class and add the following code:'
  id: totrans-181
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 右键点击新的 `Services` 文件夹，选择 `DialogService` 作为新类的名称，并添加以下代码：
- en: '[PRE34]'
  id: totrans-182
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: In .NET MAUI, the `Page` class provides various methods for displaying alerts,
    prompts, and action sheets. Within the `DialogService` class, we can access these
    methods by referencing `MainPage` through the static `Current` property of the
    `Application` class.
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在 .NET MAUI 中，`Page` 类提供了显示警报、提示和操作表的各种方法。在 `DialogService` 类中，我们可以通过引用 `Application`
    类的静态 `Current` 属性来访问这些方法。
- en: 'The next thing we need to do is register `DialogService` in our DI container.
    Move over to `MauiProgram.cs` and add the following:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的依赖注入容器中注册 `DialogService`。转到 `MauiProgram.cs` 并添加以下内容：
- en: '[PRE35]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Finally, we can add the `IDialogService` as a dependency to our ViewModels.
    Let’s add it to `AddRatingViewModel` as shown here:'
  id: totrans-186
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以将 `IDialogService` 作为依赖项添加到我们的 ViewModels 中。让我们将其添加到 `AddRatingViewModel`
    中，如下所示：
- en: '[PRE36]'
  id: totrans-187
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'Move over to the `OnSubmit` method and update it as shown here:'
  id: totrans-188
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 `OnSubmit` 方法并更新如下所示：
- en: '[PRE37]'
  id: totrans-189
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE37]'
- en: In the updated `OnSubmit` method, we first ask for confirmation. If the user
    confirms, an alert will be shown saying the rating was sent (*Figure 9**.3*).
    After the user closes the alert, `GoBackCommand` is invoked, closing the `AddRatingPage`.
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在更新的 `OnSubmit` 方法中，我们首先请求确认。如果用户确认，将显示一个警报，说明评分已发送（*图 9**.3*）。在用户关闭警报后，将调用
    `GoBackCommand`，关闭 `AddRatingPage`。
- en: '![Figure 9.3: Showing alerts and prompts](img/B20941_09_04.jpg)'
  id: totrans-191
  prefs: []
  type: TYPE_IMG
  zh: '![图 9.3：显示警报和提示](img/B20941_09_04.jpg)'
- en: 'Figure 9.3: Showing alerts and prompts'
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 图 9.3：显示警报和提示
- en: With the `IDialogService` and its `DialogService` implementation in place, we
    have laid the foundation for basic popup interactions in our application. Next,
    we’ll explore how to leverage this to prompt users for confirmation when they
    attempt to leave a specific page.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `IDialogService` 和其 `DialogService` 实现到位后，我们已经为我们的应用程序中的基本弹出交互奠定了基础。接下来，我们将探讨如何利用这一点在用户尝试离开特定页面时提示用户确认。
- en: Confirming or canceling navigation
  id: totrans-194
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 确认或取消导航
- en: 'As users interact with our application, there may be moments when they’re about
    to navigate away from a page containing unsaved changes or important input. To
    prevent potential data loss, it’s essential to prompt for confirmation before
    allowing such navigation. Let’s see how we could build this by leveraging the
    `NavigationService` that we built in the previous chapter:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 当用户与我们的应用程序交互时，可能会有他们即将从包含未保存更改或重要输入的页面导航离开的时刻。为了防止潜在的数据丢失，在允许此类导航之前提示确认是至关重要的。让我们看看我们如何通过利用我们在上一章中构建的
    `NavigationService` 来构建它：
- en: 'Let’s start by adding the following interface called `INavigatable` to the
    `Navigation` folder of the `Recipes.Client.Core` project:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们从向 `Recipes.Client.Core` 项目的 `Navigation` 文件夹中添加以下名为 `INavigatable` 的接口开始：
- en: '[PRE38]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE38]'
- en: ViewModels that want to control whether the user is able to navigate can implement
    this interface. This is analogous to the other interfaces we introduced in the
    context of navigation, such as the `INavigatedFrom`, `INavigatedTo`, and `INavigationParameterReceiver`
    interfaces.
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 想要控制用户是否能够导航的 ViewModels 可以实现此接口。这与我们在导航上下文中引入的其他接口类似，例如 `INavigatedFrom`、`INavigatedTo`
    和 `INavigationParameterReceiver` 接口。
- en: 'Extend the `INavigationInterceptor` interface with the following method definition:'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 使用以下方法定义扩展 `INavigationInterceptor` 接口：
- en: '[PRE39]'
  id: totrans-200
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'The `NavigationService` class, which implements the `INavigationInterceptor`
    interface, now needs to implement this method. Here’s what it looks like:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 实现 `INavigationInterceptor` 接口的 `NavigationService` 类现在需要实现此方法。以下是它的样子：
- en: '[PRE40]'
  id: totrans-202
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE40]'
- en: This method checks whether the given `bindingContext` parameter implements the
    `INavigatable` interface. If that’s the case, it returns the result from its `CanNavigateFrom`
    method, passing in the `NavigationType`. If the `bindingContext` doesn’t implement
    the `INavigatable` interface, `true` is returned, indicating the navigation can
    be executed.
  id: totrans-203
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 此方法检查给定的 `bindingContext` 参数是否实现了 `INavigatable` 接口。如果是这样，它将返回其 `CanNavigateFrom`
    方法的结果，传递 `NavigationType`。如果 `bindingContext` 没有实现 `INavigatable` 接口，则返回 `true`，表示导航可以执行。
- en: 'In the `AppShell` class, we must now override the `OnNavigating` method. In
    this method, we can retrieve a `ShellNavigatingDeferral` from the passed-in `ShellNavigatingEventArgs`.
    This deferral token can be used to complete the navigation. Or, if the navigation
    should be canceled, the `Cancel` method on the `ShellNavigatingEventArgs` can
    be called. The next code block shows the overridden method:'
  id: totrans-204
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `AppShell` 类中，我们现在必须重写 `OnNavigating` 方法。在这个方法中，我们可以从传入的 `ShellNavigatingEventArgs`
    中检索一个 `ShellNavigatingDeferral`。这个延迟令牌可以用来完成导航。或者，如果导航应该被取消，可以在 `ShellNavigatingEventArgs`
    上调用 `Cancel` 方法。下一个代码块显示了重写的方法：
- en: '[PRE41]'
  id: totrans-205
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE41]'
- en: By calling the interceptor’s `CanNavigate` method, we can determine whether
    we must complete the navigation or not. Depending on the outcome, we can call
    the `Complete` method on the deferral token and complete the navigation or call
    the `Cancel` method on the passed-in `args` to cancel it.
  id: totrans-206
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过调用拦截器的 `CanNavigate` 方法，我们可以确定是否必须完成导航。根据结果，我们可以调用延迟令牌上的 `Complete` 方法来完成导航，或者调用传入的
    `args` 上的 `Cancel` 方法来取消它。
- en: 'Finally, we can go to `AddRatingViewModel`, make it implement the `INavigatable`
    interface, and add the following:'
  id: totrans-207
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们可以进入 `AddRatingViewModel`，使其实现 `INavigatable` 接口，并添加以下内容：
- en: '[PRE42]'
  id: totrans-208
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE42]'
- en: As a result, when navigating from the `AddRatingView`, the `OnNavigating` method
    on the `Shell` class will get called, which – via the `NavigationService` – will
    call the `CanNavigateFrom` method on the `AddRatingViewModel`. The ViewModel will
    present a dialog to the user and return the response. Depending on the response
    given by the user, the navigation will be completed or canceled. The `INavigatable`
    interface can be implemented by any ViewModel and can contain any business logic
    to determine whether navigation is allowed or not.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，当从 `AddRatingView` 导航时，`Shell` 类上的 `OnNavigating` 方法将被调用，通过 `NavigationService`
    将调用 `AddRatingViewModel` 上的 `CanNavigateFrom` 方法。ViewModel 将向用户显示对话框并返回响应。根据用户给出的响应，导航将被完成或取消。`INavigatable`
    接口可以由任何 ViewModel 实现，并可以包含任何业务逻辑以确定是否允许导航。
- en: Summary
  id: totrans-210
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we delved deep into enhancing user experience through effective
    validation, prompts, and alerts. We explored the power of `ObservableValidator`
    for validation logic and learned the nuances of showing errors both as a collective
    list and inline, right next to input fields. With triggers, we learned how to
    customize UI elements without reinventing the wheel. We also explored using an
    `IDialogService` leveraging alerts and prompts, which is essential in contexts
    where user feedback or confirmations, such as during critical actions or navigations,
    are required. As we move forward, we’ll pivot to a vital aspect of many modern
    apps: making remote API calls.'
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们深入探讨了通过有效的验证、提示和警报来增强用户体验。我们探索了`ObservableValidator`在验证逻辑方面的强大功能，并学习了如何以集体列表和内联方式显示错误，即紧挨着输入字段。通过触发器，我们学习了如何在不重新发明轮子的前提下自定义UI元素。我们还探讨了使用`IDialogService`利用警报和提示，这在需要用户反馈或确认的上下文中至关重要，例如在关键操作或导航期间。随着我们继续前进，我们将转向许多现代应用的一个关键方面：进行远程API调用。
- en: Further reading
  id: totrans-212
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: '`ObservableValidator`: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/observablevalidator](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/observablevalidator)'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ObservableValidator`：[https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/observablevalidator](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/observablevalidator)'
- en: 'Triggers: [https://learn.microsoft.com/dotnet/maui/fundamentals/triggers](https://learn.microsoft.com/dotnet/maui/fundamentals/triggers)'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 触发器：[https://learn.microsoft.com/dotnet/maui/fundamentals/triggers](https://learn.microsoft.com/dotnet/maui/fundamentals/triggers)
- en: 'Behaviors: [https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors](https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors)'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 行为：[https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors](https://learn.microsoft.com/dotnet/maui/fundamentals/behaviors)
- en: '.NET MAUI Community Toolkit Behaviors: [https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/](https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/)'
  id: totrans-217
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET MAUI 社区工具包行为：[https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/](https://learn.microsoft.com/dotnet/communitytoolkit/maui/behaviors/)
- en: '.NET MAUI popups: [https://learn.microsoft.com/dotnet/maui/user-interface/pop-ups](https://learn.microsoft.com/dotnet/maui/user-interface/pop-ups)**'
  id: totrans-218
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: .NET MAUI 弹出窗口：[https://learn.microsoft.com/dotnet/maui/user-interface/pop-ups](https://learn.microsoft.com/dotnet/maui/user-interface/pop-ups)**
