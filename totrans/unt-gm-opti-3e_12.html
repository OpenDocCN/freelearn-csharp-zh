<html><head></head><body>
        <section>

                            <header>
                    <h1 class="header-title">The Data-Oriented Technology Stack</h1>
                </header>
            
            <article>
                
<p>In recent years, we have seen a big push toward multithreading programming. The reason is obvious: while we have reached a technological limit on how fast a single core can go, we have discovered how to efficiently put thousands of cores into our hardware and run each piece of code in parallel to obtain a massive performance boost.</p>
<p>However, moving from single-thread programming to multithreading programming is not straightforward. Not every algorithm can easily be split into pieces and, even if it can, there are several details you need to take into account so as to avoid strange and unpredictable behaviors.</p>
<p>When the first version of Unity was released, back in 2005, massive multithreading was almost a futuristic scenario. However, fourteen years are the equivalent of a geological era in game development, and a game engine needs to adapt itself to stay on track with cutting-edge technology.</p>
<p>Unity is currently going through a massive effort to adapt its core design into a world dominated by massive multithreading. This effort takes the name of the <strong>Data-Oriented Technology Stack</strong> (<strong>DOTS</strong>).</p>
<p>In this chapter, we will explore the components of DOTS:</p>
<ul>
<li>The Job System</li>
<li>The <strong>Entity Component System</strong> (<strong>ECS</strong>)</li>
<li>The Burst Compiler</li>
</ul>
<div class="packt_infobox">The DOTS stack in Unity is exceptionally experimental and, while public, all its components are still in an early preview state, meaning that their use should be avoided for serious projects. They also change very fast. The official tutorial on ECS on <a href="https://learn.unity.com">https://learn.unity.com</a> is now unusable because it is out of date. I will not be surprised if even this chapter, some months from now, were to contain many deprecated functions and procedures. Do not worry; I will provide a link at the end for where to obtain fresh news on DOTS.</div>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The problem of multithreading</h1>
                </header>
            
            <article>
                
<p>Video games have great multithreading potential. In theory, every <kbd><span>GameObject</span></kbd> can be seen as a separate entity with its own life cycle and its own computation path. This would instantaneously increase your game performance with a lot of <kbd>GameObject</kbd> instances. Suppose that processing all the updates in the <kbd>GameObject</kbd> takes 1 ms. If you could have one thousand similar <kbd>GameObject</kbd> instances, that would take a full second but, if you can assign each update to a separate core, all the updates could run in parallel, and your total computation time would be exactly 1 ms. That represents a 100,000% speed boost!</p>
<p>Unfortunately, it is not so easy. As we said before, you cannot just assign a piece of code to a core and expect that everything keeps working. A big problem with writing multithreaded code is the risk of race conditions, deadlock, and bugs that are notoriously difficult to reproduce and debug.</p>
<div class="packt_infobox">Race conditions are where two or more calculations are racing toward completion, but the actual outcome depends on the order in which they finish. Imagine one thread trying to add three to a number, whereas another thread multiplies it by four. The result will be different, depending on which operation happens first. Deadlock is a problem where two or more threads are competing for shared resources, where each requires the full resource collection to complete its task, but each has reserved a separate small portion of resources and refuses to relinquish control of them to another thread, in which case, none of the threads can get any work done because neither has the complete set it needs.</div>
<p>For this reason, traditionally, Unity APIs are not thread-safe, meaning that they cannot be invoked by different threads running in parallel. As a consequence, almost all Unity code runs in the main thread, and that includes every <kbd>GameObject</kbd> and <kbd>MonoBehaviour</kbd> (and that's why if you block a single update, you may end up freezing the entire Unity Editor).</p>
<p>Because multithreading is a complex topic, we will go over an example step by step.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A small example</h1>
                </header>
            
            <article>
                
<p><span>Imagine you want to have thousands of similar items in your scene. This is not a strange request; there may be many valid reasons for that: you may wish to render thousands of ships in a gigantic galactic battle, or you may want to animate thousands of units for a <strong>Real-Time Strategy</strong> (<strong>RTS</strong>) game, or you may want to handle a massive number of particles.</span></p>
<p>For simplicity, in our demo, we want a scene with 10,000 spinning cubes. So let's begin:</p>
<ol>
<li>Each cube will have a single <kbd>MonoBehaviour</kbd> instance that executes a very simple rotation cube:</li>
</ol>
<pre style="padding-left: 60px">using UnityEngine;<br/><br/>namespace Classic<br/>{<br/>  public class Rotator : MonoBehaviour<br/>  {<br/><br/>    public float rotationSpeed;<br/><br/>    void Update()<br/>    {<br/>      transform.Rotate(0f, rotationSpeed * Time.deltaTime, 0f);<br/>    }<br/>  }<br/>}</pre>
<p style="padding-left: 60px">The script is self-explanatory: we have a public variable, <kbd>rotationSpeed</kbd>, storing the rotation speed of the cube. Then, in <kbd>Update</kbd>, we simply rotate the cube.</p>
<ol start="2">
<li>Now, we do not want to insert 10,000 cubes <span>into the scene </span>manually. So, we will create a <strong>game manager</strong> that will do the following:
<ol>
<li>Spawn 10,000 cubes in the scene</li>
<li>Set a random rotation speed for each one of them</li>
</ol>
</li>
</ol>
<ol start="3">
<li>So, we create an empty <kbd>GameObject</kbd>, and we attach to it a game manager script, as follows:</li>
</ol>
<pre style="padding-left: 60px"><span class="syntax-all syntax-keyword">using</span> UnityEngine;
<span class="syntax-all syntax-keyword">using</span> System;

<span class="syntax-all syntax-keyword">namespace</span> <span class="syntax-all syntax-entity">Classic</span> { 

    <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ClassicCubeManager</span> : <span class="syntax-all syntax-keyword">MonoBehaviour</span>
    {

        #region COMMON_GAME_MANAGER_DATA
        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">float</span> cubeSpacing = <span class="syntax-all syntax-constant">0.1f</span>;
        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">int</span> width = <span class="syntax-all syntax-constant">10</span>;
        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">int</span> height = <span class="syntax-all syntax-constant">10</span>;

        <span class="syntax-all syntax-keyword">public</span> GameObject cubePrefab;
        #endregion

        <span class="syntax-all syntax-keyword">void</span> <span class="syntax-all syntax-entity">Start</span>()
        {
            SpawnCubes();

        }

        <span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">void</span> <span class="syntax-all syntax-entity">SpawnCubes</span>()
        {
            Debug.Log(String.Format(<span class="syntax-all syntax-string">"Spawning {0} cubes"</span>, (width / cubeSpacing) * (height / cubeSpacing)));
            Vector3 position = <span class="syntax-all syntax-keyword">new</span> Vector3();
            <span class="syntax-all syntax-keyword">while</span> (position.x &lt; width)
            {
                <span class="syntax-all syntax-keyword">while</span> (position.y &lt; height) {
                    <span class="syntax-all syntax-keyword">var</span> newCube = GameObject.Instantiate(cubePrefab);
                    newCube.transform.position = position;
                    newCube.GetComponent&lt;Rotator&gt;().rotationSpeed = UnityEngine.Random.Range(<span class="syntax-all syntax-constant">25.0f</span>, <span class="syntax-all syntax-constant">50.0f</span>);
                    position = <span class="syntax-all syntax-keyword">new</span> Vector3(position.x, position.y + cubeSpacing, <span class="syntax-all syntax-constant">0f</span>);
                }
                position = <span class="syntax-all syntax-keyword">new</span> Vector3(position.x + cubeSpacing, <span class="syntax-all syntax-constant">0f</span>, <span class="syntax-all syntax-constant">0f</span>);
            }
        }

    }
} </pre>
<p style="padding-left: 60px">The script simply takes a <kbd>cubePrefab</kbd> and spawns a certain number of them into a <em>width x height</em> rectangle of space. The exciting part is the <kbd>SpawnCubes</kbd> function. The function starts with <kbd>position</kbd> in the origin and starts spawning cubes until we reach the opposite corner. This is a pretty standard script.</p>
<ol start="4">
<li>Now we can run it, and we should see something like this:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/70a260fc-2726-40fb-a7b6-88cda2e42076.png"/></p>
<p style="padding-left: 60px">As you can see, the frame rate is not optimal. Looking at the stats in the top-right corner, you can see that the game is running at ~22 FPS.</p>
<div class="packt_infobox">Note that these values are taken from my non-optimal machine. You may find different values. If your computer is so fast that the demo is running perfectly, try to increase the number of cubes to 20,000 or more.</div>
<ol start="5">
<li>This FPS value is not optimal. However, we can open the <span class="packt_screen">Profiler</span> window (<span class="packt_screen">Window</span> | <span class="packt_screen">Analysis</span> | <span class="packt_screen">Profiler</span>) and try to understand how the application behaves:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/b96698e0-3ea7-40dc-8506-e629cae0ed29.png"/></p>
<p>The image is clear: we are allocating almost 1 GB of RAM and spending 45 ms per frame, 10 ms of which are used just for the scripts. That's wrong. The update script is straightforward: we are just rotating a cube by a few degrees each frame.</p>
<p>We should do better. And we will.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The Unity Job System</h1>
                </header>
            
            <article>
                
<p>The big block in the DOTS that can provide us with a huge performance-enhancing feature is the <strong>C# Job System</strong>. Like all the other DOTS components, the feature is still in active development, but has been made public since Unity 2019.1, so it would be wise to start becoming familiar with it sooner rather than later, as it will introduce considerable changes to how Unity developers will be writing high-performance code:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/5b1ed060-e78b-4f34-9e21-7905b738bc6c.png" style="width:26.00em;height:8.17em;"/></p>
<p>As we will see, the difference in the quality of a game that uses this system versus one that doesn't might become very noticeable, which may cause some fragmentation within the Unity development community. It is in our best interests to understand and exploit the benefits of the new Job System so that our application will have the greatest potential for success.</p>
<p>The idea of the C# Job System is to be able to create simple tasks that run in background threads to offload work from the main thread. The C# Job System will be ideal for tasks that are embarrassingly parallel, such as having hundreds of thousands of simple AI agents operating in a scene simultaneously and any problem that can be boiled down to thousands of small, independent operations. Of course, it can also be used for typical multithreading behavior as well, where we perform a number of calculations in the background that are not needed immediately. The Job System also introduces some compiler technology improvements to get an even greater performance boost than just moving the tasks to separate threads.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A basic job</h1>
                </header>
            
            <article>
                
<p>In essence, a job is just a function running on a separate thread:</p>
<pre><span class="syntax-all syntax-keyword">using</span> Unity.Collections;
<span class="syntax-all syntax-keyword">using</span> Unity.Jobs;
<span class="syntax-all syntax-keyword">using</span> UnityEngine;

<span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">struct</span> <span class="syntax-all syntax-entity">SimpleJob</span> : <span class="syntax-all syntax-keyword">IJob</span>
{
    <span class="syntax-all syntax-comment">// Put here a bunch of data...
</span>    <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">float</span> number;

    <span class="syntax-all syntax-keyword">public</span> NativeArray&lt;<span class="syntax-all syntax-keyword">float</span>&gt; data;

    <span class="syntax-all syntax-comment">// Write your Execute() function.
</span>    <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">void</span> <span class="syntax-all syntax-entity">Execute</span>()
    {
        data[<span class="syntax-all syntax-constant">0</span>] += number;
    }
}</pre>
<p>Every job is a struct extending the <kbd>IJobinterface</kbd> interface. The struct contains any data we want for the job to use and a function named <kbd>Execute</kbd> for the operation we want to execute in the job. The previous example, for instance, just adds a certain number to the first element of an array.</p>
<p>Because, as we said before, multithreading is a very tricky business, Unity offers some limitations in terms of the way in which you can pass and receive data to a job (or a set of jobs). The primary constraint is that the <kbd>Execute</kbd> function does not accept any argument and cannot return any value. All the data that the job needs must be copied in the struct, and the result must be written in the struct as well.</p>
<p>The fact that we need to copy stuff into the struct seems a significant limitation: you cannot pass a reference to a <kbd><span>MonoBehaviour</span></kbd> instance or a reference to <kbd>List</kbd>. Luckily, Unity offers a way to access shared memory in a job using a set of thread-safe wrappers using native containers.</p>
<p>The native containers include the following:</p>
<ul>
<li><kbd>NativeArray</kbd>: A simple collection of data (the thread-safe equivalent of base C# arrays)</li>
<li><kbd>NativeList</kbd><span>:</span> Similar to <kbd>NativeArray</kbd>, but resizable (the thread-safe equivalent of <kbd>List</kbd>)</li>
<li><kbd>NativeHashMap</kbd>: The thread-safe version of <kbd>HashMap</kbd></li>
<li><kbd>NativeMultiHashMap</kbd>: Similar to <kbd>NativeHashMap</kbd>, but with multiple values per key</li>
<li><kbd>NativeQueue</kbd>: A thread-safe version of a <strong>First In, First Out</strong> (<strong>FIFO</strong>) queue</li>
</ul>
<p>So, in our job, we use a one-sized <kbd>NativeArray</kbd> variable to store input and output data.</p>
<p>Now, we want to run the job. To do that, we need to use <kbd>MonoBehaviour</kbd> to initialize and run it:</p>
<pre><span class="syntax-all syntax-keyword">using Unity.Collections;<br/>using Unity.Jobs;<br/>using UnityEngine;<br/><br/>public</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">SimpleJobRunner</span> : <span class="syntax-all syntax-keyword">MonoBehaviour</span>
{
<span class="syntax-all syntax-comment">
</span>    <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">float</span> numberToAdd = <span class="syntax-all syntax-constant">5</span>;
<span class="syntax-all syntax-comment">
</span>    <span class="syntax-all syntax-keyword">private</span> NativeArray&lt;<span class="syntax-all syntax-keyword">float</span>&gt; theData;
<span class="syntax-all syntax-comment">
</span>    <span class="syntax-all syntax-keyword">private</span> JobHandle simpleJobHandle;

    <span class="syntax-all syntax-keyword">void</span> <span class="syntax-all syntax-entity">Start</span>()
    {
        theData = <span class="syntax-all syntax-keyword">new</span> NativeArray&lt;<span class="syntax-all syntax-keyword">float</span>&gt;(<span class="syntax-all syntax-constant">1</span>, Allocator.Persistent);
        theData[<span class="syntax-all syntax-constant">0</span>] = <span class="syntax-all syntax-constant">2</span>;

<span class="syntax-all syntax-comment">
</span>        SimpleJob simpleJob = <span class="syntax-all syntax-keyword">new</span> SimpleJob
        {
            number = numberToAdd,
            data = theData
        };
<span class="syntax-all syntax-comment">
</span>        simpleJobHandle = simpleJob.Schedule();
<span class="syntax-all syntax-comment">
</span>        JobHandle.ScheduleBatchedJobs();
<span class="syntax-all syntax-comment">
</span>        simpleJobHandle.Complete();
<span class="syntax-all syntax-comment">
</span>        <span class="syntax-all syntax-keyword">if</span> (simpleJobHandle.IsCompleted)
        {
            Debug.Log(simpleJob.data[<span class="syntax-all syntax-constant">0</span>]);
        }

                theData.Dispose();
    }
}</pre>
<p>In <kbd>Start</kbd>, we first create an empty <kbd>NativeArray</kbd>. The first argument of <kbd>NativeArrayconstructor</kbd> is the size; the second argument is <kbd>Allocator</kbd>. There are actually three allocators:</p>
<ul>
<li><kbd>Allocator.Temp</kbd>: This is the fastest one, but its life span must be under a frame. In fact, Unity forces you to call <kbd>Dispose</kbd> on such an array before the function returns. For this reason, we cannot use <kbd>Allocator.Temp</kbd> for native containers passed as an argument to jobs. Jobs are not guaranteed to complete in the same frame in which they start.</li>
<li><kbd>Allocator.TempJob</kbd>: This is slower than <kbd>Allocator.Temp</kbd> and its lifetime is restricted to under four frames. This is the perfect type of <kbd>Allocator</kbd> for passing data to simple jobs that run and return quickly, such as the one in our example.</li>
<li><kbd>Allocator.Persistent</kbd>: This is the slower of the three, but its lifetime is unbounded. This is the type of <kbd>Allocator</kbd> where you want to store persistent data or data that jobs need to access for an extended period.</li>
</ul>
<p>After that, we create a new <kbd>SimpleJob</kbd> instance, passing <kbd>number</kbd> and <kbd>data</kbd> to it. Then, we schedule and run the job with the <kbd>Schedule</kbd> function. This will return a <kbd>jobHandle</kbd> instance, which we can use to control the job execution. Finally, we wait for the job to be completed and then print the result. Everything looks like standard C# code, but the job runs in a separate thread!</p>
<div class="packt_infobox">Remember to be nice C# citizens and always dispose of native containers <span>manually</span>! You do not want to pollute your memory in the same way that you do not want to pollute our world.</div>
<p>At this point, if you attach <kbd>SimpleJobRunner</kbd> to an empty object, you should see the result printed in the debug console. Everything is effected in a multithreading style.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">A more complex example</h1>
                </header>
            
            <article>
                
<p>Spawning a job just to sum two numbers is definitely not an example of optimal programming. Unity created jobs to run thousands of them to lift hard work into the multithreading domain.</p>
<p>Therefore, we will now modify our previous spinning cubes example so that the actual spinning is performed by jobs. The first thing we want to do is to create our job, as follows:</p>
<pre><span class="syntax-all syntax-keyword">using</span> System.Collections;
<span class="syntax-all syntax-keyword">using</span> System.Collections.Generic;
<span class="syntax-all syntax-keyword">using</span> Unity.Collections;
<span class="syntax-all syntax-keyword">using</span> UnityEngine;
<span class="syntax-all syntax-keyword">using</span> UnityEngine.Jobs;


<span class="syntax-all syntax-keyword">namespace</span> <span class="syntax-all syntax-entity">JobSystem</span>
{

    <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">struct</span> <span class="syntax-all syntax-entity">RotatorJob</span> : <span class="syntax-all syntax-keyword">IJobParallelForTransform</span>
    {

        [ReadOnly]
        <span class="syntax-all syntax-keyword">public</span> NativeList&lt;<span class="syntax-all syntax-keyword">float</span>&gt; speeds;

        [ReadOnly]
        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">float</span> deltaTime;

        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">void</span> <span class="syntax-all syntax-entity">Execute</span>(<span class="syntax-all syntax-keyword">int</span> <span class="syntax-all syntax-parameter">index</span>, <span class="syntax-all syntax-keyword">TransformAccess</span> <span class="syntax-all syntax-parameter">transform</span>)
        {
            Vector3 currentRotation = transform.rotation.eulerAngles;
            currentRotation.y += speeds[index] * deltaTime;
            transform.rotation = Quaternion.Euler(currentRotation);
        }
    }
}</pre>
<p>This job is a bit more complicated, but do not worry. First, it extends <kbd>IJobParallelForTransform</kbd>; this is a specialized job interface for running parallel transformations of <kbd>GameObject</kbd> instances. You can do the same by extending <kbd>IJob</kbd>, but, because this is a very common use case, Unity wrote most of the code for us. As you can see, the main difference is the fact that <kbd>Execute</kbd> now has two parameters. In our demo, we want to run the same job on every one of our 10,000 cubes. In this case, the parameters are as follows:</p>
<ul>
<li><kbd>index</kbd> represents the <kbd>index</kbd><sup>th</sup> cube in our scene</li>
<li><kbd>transform</kbd> is a reference to the <kbd>Transform</kbd> of the <kbd>index</kbd><sup>th</sup> cube</li>
</ul>
<p>Our job takes two inputs:</p>
<ul>
<li><kbd>speeds</kbd>: It is an array containing all the random speeds for every cube. Remember, we cannot get a reference to some data of a specific <kbd>GameObject</kbd>, so we need to write all the speeds into shared memory. Note that the field is <kbd>[ReadOnly]</kbd>; we do not want the <em>i</em><sup><em>th</em></sup> cube to be able to change the speed of another cube.</li>
</ul>
<ul>
<li><kbd>deltaTime</kbd>: Because a job is completely disconnected from the Unity engine, it cannot access <kbd>Time</kbd> and other thread-unsafe parts of Unity. Therefore, we need to pass <kbd>deltaTime</kbd> ourselves.</li>
</ul>
<p>The <kbd>Execute</kbd> function is straightforward; we just rotate the cube.</p>
<p>Now, we need to call these jobs on every cube, and we need to use a game manager for this:</p>
<pre><span class="syntax-all syntax-keyword">namespace</span> <span class="syntax-all syntax-entity">JobSystem</span>
{
    <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">JobCubeManager</span> : <span class="syntax-all syntax-keyword">MonoBehaviour</span>
    {

        #region COMMON_GAME_MANAGER_DATA
        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">float</span> cubeSpacing = <span class="syntax-all syntax-constant">0.1f</span>;
        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">int</span> width = <span class="syntax-all syntax-constant">10</span>;
        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">int</span> height = <span class="syntax-all syntax-constant">10</span>;

        <span class="syntax-all syntax-keyword">public</span> GameObject cubePrefab;
        #endregion

        TransformAccessArray transformAccessArray;
        Unity.Jobs.JobHandle jobHandle;
        NativeList&lt;<span class="syntax-all syntax-keyword">float</span>&gt; speeds;

                ...</pre>
<p>We start by defining the underlying data as in the classic example. The first attributes are the same; the interesting ones are the final three:</p>
<ul>
<li><kbd>transformAccessArray</kbd> is the array in which we will store <kbd>transform</kbd> instance references of all of our cubes. That's how our job can access them.</li>
<li><kbd>jobHandle</kbd> is the handle we will use to query the Job System for the state of the job.</li>
<li><kbd>speeds</kbd> is the list of random speeds as described before:</li>
</ul>
<pre>        <span class="syntax-all syntax-keyword">void</span> Start()
        {
            transformAccessArray = <span class="syntax-all syntax-keyword">new</span> TransformAccessArray(<span class="syntax-all syntax-constant">0</span>, -<span class="syntax-all syntax-constant">1</span>);
            speeds = <span class="syntax-all syntax-keyword">new</span> NativeList&lt;<span class="syntax-all syntax-keyword">float</span>&gt;(<span class="syntax-all syntax-constant">1</span>, Allocator.Persistent);
            SpawnCubes();
        }</pre>
<p>In <kbd>Start</kbd>, we just initialize all the native containers, and then we spawn the cubes. Note that we use the <kbd>Allocator.Persistent</kbd> allocator because we want to initialize the speed on <kbd>Start</kbd> and then use the same list for the application's entire lifetime:</p>
<pre>        <span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">void</span> SpawnCubes()
        {
            Debug.Log(String.Format(<span class="syntax-all syntax-string">"Spawning {0} cubes"</span>, (width / cubeSpacing) * (height / cubeSpacing)));
            Vector3 position = <span class="syntax-all syntax-keyword">new</span> Vector3();
            <span class="syntax-all syntax-keyword">while</span> (position.x &lt; width)
            {
                <span class="syntax-all syntax-keyword">while</span> (position.y &lt; height)
                {
                    <span class="syntax-all syntax-keyword">var</span> newCube = Instantiate(cubePrefab);
                    newCube.transform.position = position;
                    position = <span class="syntax-all syntax-keyword">new</span> Vector3(position.x, position.y + cubeSpacing, <span class="syntax-all syntax-constant">0f</span>);
                    transformAccessArray.Add(newCube.transform);
                    speeds.Add(UnityEngine.Random.Range(<span class="syntax-all syntax-constant">25.0f</span>, <span class="syntax-all syntax-constant">50.0f</span>));
                }
                position = <span class="syntax-all syntax-keyword">new</span> Vector3(position.x + cubeSpacing, <span class="syntax-all syntax-constant">0f</span>, <span class="syntax-all syntax-constant">0f</span>);
            }

        }</pre>
<p>The <kbd>SpawnCubes</kbd> function is very similar to the previous one. However, there are two crucial lines that differ:</p>
<ol>
<li>After we instantiate a cube, we add its <kbd>transform</kbd> to <kbd>transformAccessArray</kbd>.</li>
<li>Instead of setting the random speed in the <kbd>Rotator</kbd> <kbd>MonoBehaviour</kbd> of the cube, we set it in the speeds array. In fact, we should not have the <kbd>Rotator</kbd> component in the Prefab!</li>
</ol>
<p style="padding-left: 60px">Now, every frame, we need to run the job <span>in parallel </span>on every cube:</p>
<pre>        <span class="syntax-all syntax-keyword">void</span> Update()
        {
            jobHandle.Complete();

            <span class="syntax-all syntax-keyword">if</span> (jobHandle.IsCompleted)
            {
                <span class="syntax-all syntax-keyword">var</span> rotatorJob = <span class="syntax-all syntax-keyword">new</span> RotatorJob()
                {
                    deltaTime = Time.deltaTime,
                    speeds = speeds
                };

                jobHandle = rotatorJob.Schedule(transformAccessArray);
                JobHandle.ScheduleBatchedJobs();
            }

        }</pre>
<p>We use the same pattern as before. We check whether the previous jobs are now complete, we instantiate a new job, we set the data, and then we schedule the job over the entire <strong><kbd>transformAccessArray</kbd></strong>.</p>
<p>If everything is correct, we can run the game and see the same scene as before. Now, however, we can enjoy ~35 FPS:</p>
<p class="CDPAlignCenter CDPAlign"><img src="assets/21eab8f0-53da-45f9-bee2-62e2c9deb98d.png"/></p>
<p>Looking at <span class="packt_screen">Profiler</span>, we can see that, now, the time used by scripts (the lower blue one) is almost invisible. It dropped from 10 ms to 1 ms. That's a 90% improvement!</p>
<p>However, we still have a problem. Our scene is filled by 10,000 <kbd>GameObject</kbd> instances, 10,000 <kbd>Transforms</kbd>, 10,000 <kbd>MeshRenderers</kbd>, and another 10,000 copies of different components. <kbd>MonoBehaviour</kbd> and <kbd>GameObject</kbd> are heavy data structures, and they are consuming a sensible amount of memory and CPU cycles.</p>
<p>Can we do better? Yes, we can.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The new ECS</h1>
                </header>
            
            <article>
                
<p>The ECS is a brave and ambitious attempt to redesign the core foundation of Unity's design: the <kbd>GameObject</kbd>-<kbd>MonoBehaviour</kbd> paradigm. As you can imagine, changing the base design pattern of every object in the game is not an easy task. So you may ask: Why?</p>
<p>There are several reasons for that. Let's look at some of them objectively: </p>
<ul>
<li>First, as we said before, <kbd>GameObject</kbd> and <kbd>MonoBehaviour</kbd> are heavy objects; they carry a lot of internal code and data structures. The overhead introduced by <kbd>GameObject</kbd> instances and <kbd>MonoBehaviour</kbd> is large enough to limit the number of objects  you can have on the screen more than the resources needed to render them. That's not a good thing for an abstraction model.</li>
<li>Second, <kbd>MonoBehaviour</kbd> instances are scattered in memory. This means that <kbd>GameObject</kbd> needs to look around in memory to retrieve all the <kbd>MonoBehaviour</kbd> instances it is connected to, and that the system relies on references. This has two problems: it makes caches very inefficient and, more important, it is a problem when we want to use <kbd>GameObject</kbd> instances in a massive multithreading application, for instance, by using jobs (we have seen that jobs cannot use references safely).</li>
<li>Last, but not least, <kbd>MonoBehaviour</kbd> instances have a problem from a code design point of view: they store both data and behavior. This is not a huge problem. After all, a lot of amazing games have been shipped using this paradigm. However, it is common in software architecture to separate the data (often called the <strong>model</strong>) and the algorithm that uses the data (often called the<strong> controller</strong><em>). </em></li>
</ul>
<p>The ECS, on the other hand, goes in the direction of separating the data from the behavior. It is based on three different components:</p>
<ul>
<li>An <strong>entity</strong> is just defined by its set of components. There is literally zero abstraction here.</li>
</ul>
<ul>
<li>A <strong>component</strong> is purely data. A <kbd>Health</kbd> component contains only the life points; a <kbd>Shield</kbd> component contains only the number of shields; a <kbd>Rotation</kbd> component contains only the object orientation, and so on.</li>
<li>A <strong>system</strong> defines the behavior of entities. A system applies a specific behavior to every entity containing a particular set of components. For instance, <kbd>MoveAndRotateEnemy</kbd> may apply translation and rotation to every entity with the <kbd>Rotation</kbd>, <kbd>Translation</kbd>, and <kbd>Enemy</kbd> components.</li>
</ul>
<p>Everything is now in its own place.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Mixing ECS and jobs</h1>
                </header>
            
            <article>
                
<p>It is time to apply ECS to our 10,000 spinning cubes. Before we start, we need to install the packages:</p>
<ol>
<li>Open <span class="packt_screen">Window</span> | <span class="packt_screen">Package Manager</span>. Click on <span class="packt_screen">Advanced</span> and make sure that <span class="packt_screen">Show preview packages</span> is enabled.</li>
<li>Then, from the list, install the <span class="packt_screen">Entities</span> package and the <span class="packt_screen">Hybrid Renderer</span> package:</li>
</ol>
<p class="CDPAlignCenter CDPAlign"><img src="assets/fa81e2ff-4471-4b32-8ea7-ab842a4d82a0.png" style="width:19.92em;height:16.25em;"/></p>
<div class="packt_infobox">As mentioned previously, ECS is changing <span>rapidly</span>. We tested the code in this book with version 0.1.1-preview. If you, as a <span>future reader,</span> have a more recent version, there is a big chance that there will be some incompatibility. In that case, I encourage you to compare the code with the latest examples of ECS contained in this official repository: <a href="https://github.com/Unity-Technologies/EntityComponentSystemSamples">https://github.com/Unity-Technologies/EntityComponentSystemSamples</a>. I apologize for my lack of forecasting ability.</div>
<ol start="3">
<li>Now we are ready to write the first component. Our cube needs to spin, so we need to have a certain <kbd>RotationSpeed</kbd>. That will be the name of our component:</li>
</ol>
<pre>    [Serializable]
    <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">struct</span> <span class="syntax-all syntax-entity">RotationSpeed</span> : <span class="syntax-all syntax-keyword">IComponentData</span>
    {
        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">float</span> Value;
    }</pre>
<p style="padding-left: 60px">See how simple that is. As we have said before, a component is just data. The rotation speed is represented by a single float; therefore, we just need to store a simple float.</p>
<p style="padding-left: 60px">You may ask: how do I attach this component to an entity? Can I still use the inspector to set the values? How about all the goodies I love in Unity? Sadly, components cannot be attached to <kbd>GameObject</kbd> (after all, <kbd>GameObject</kbd> is not part of the ECS). Entities do not show up in the scene editor and components do not appear in the inspector.</p>
<p style="padding-left: 60px">Fortunately, there is a solution if we want to keep some functionality of the Editor, such as, for instance, defining a Prefab that we can spawn 10,000 times. Mixing the <kbd>GameObject</kbd>-<kbd>MonoBehaviour</kbd> paradigm with ECS is called <strong>hybrid ECS</strong> and is the perfect way to keep the best of both worlds.</p>
<ol start="4">
<li>To enable it for our component, we need to write an <kbd>IConvertGameObjectToEntity</kbd> implementation. <kbd>IConvertGameObjectToEntity</kbd> is a piece of code that automatically converts a standard <kbd>MonoBehaviour</kbd> to the correspondent component:</li>
</ol>
<pre style="padding-left: 60px">    using System.Collections;<br/>    using System.Collections.Generic;<br/>    using UnityEngine;<br/>    using Unity.Entities;<br/>    using System;<br/>    using Unity.Mathematics;    <br/><br/>    [RequiresEntityConversion]
    <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">RotationSpeedAuthoring</span> : <span class="syntax-all syntax-keyword">MonoBehaviour</span>, <span class="syntax-all syntax-keyword">IConvertGameObjectToEntity</span>
    {

        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">float</span> rotationSpeed = <span class="syntax-all syntax-constant">35f</span>;

        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">void</span> <span class="syntax-all syntax-entity">Convert</span>(<span class="syntax-all syntax-keyword">Entity</span> <span class="syntax-all syntax-parameter">entity</span>, <span class="syntax-all syntax-keyword">EntityManager</span> <span class="syntax-all syntax-parameter">dstManager</span>, <span class="syntax-all syntax-keyword">GameObjectConversionSystem</span> <span class="syntax-all syntax-parameter">conversionSystem</span>)
        {
            <span class="syntax-all syntax-keyword">var</span> data = <span class="syntax-all syntax-keyword">new</span> RotationSpeed { Value = math.radians(rotationSpeed) }; <span class="syntax-all syntax-comment">// Convert to speed in radians
</span>            dstManager.AddComponentData(entity, data);
        }
    }</pre>
<p style="padding-left: 60px">In the preceding code, <kbd>RotationSpeedAuthoring</kbd> is an <kbd>IConvertGameObjectToEntity</kbd> implementation and a <kbd>MonoBehaviour</kbd> (so that we can attach it to a <kbd>GameObject</kbd>). The core of the conversion lies in the <kbd>Convert</kbd> function. The signature is confusing; it changed a lot in the past, and it will probably change again in the future. What is important is the content: the function takes the data of the <kbd>MonoBehaviour</kbd>, adds it to a new component (in our case, <kbd>RotationSpeed</kbd>), applies some processing (in our case, we convert degrees per second into radians per second), and finally attaches the component to the entity.</p>
<ol start="5">
<li>We now create <kbd>cubePrefab</kbd> as before and add the <kbd>RotationSpeedAuthoring</kbd> <kbd>MonoBehaviour</kbd> to it and, at runtime, <kbd>GameObject</kbd> will be converted to an entity.</li>
<li>Now that we have everything we need, we just need to write our game controller:</li>
</ol>
<pre style="padding-left: 60px"><span class="syntax-all syntax-keyword">using</span> System;
<span class="syntax-all syntax-keyword">using</span> UnityEngine;
<span class="syntax-all syntax-keyword">using</span> Unity.Entities;
<span class="syntax-all syntax-keyword">using</span> Unity.Transforms;
<span class="syntax-all syntax-keyword">using</span> Unity.Mathematics;

<span class="syntax-all syntax-keyword">namespace</span> <span class="syntax-all syntax-entity">ECSJob</span>
{
    <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">ECSJobManager</span> : <span class="syntax-all syntax-keyword">MonoBehaviour</span>
    {

        #region COMMON_GAME_MANAGER_DATA
        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">float</span> cubeSpacing = <span class="syntax-all syntax-constant">0.1f</span>;
        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">int</span> width = <span class="syntax-all syntax-constant">10</span>;
        <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">int</span> height = <span class="syntax-all syntax-constant">10</span>;

        <span class="syntax-all syntax-keyword">public</span> GameObject cubePrefab;
        #endregion

        EntityManager entityManager;

        <span class="syntax-all syntax-keyword">void</span> <span class="syntax-all syntax-entity">Start</span>()
        {
            entityManager = World.Active.EntityManager;
            SpawnCubes();
        }

        <span class="syntax-all syntax-keyword">private</span> <span class="syntax-all syntax-keyword">void</span> <span class="syntax-all syntax-entity">SpawnCubes</span>()
        {
            <span class="syntax-all syntax-keyword">int</span> amount = Mathf.FloorToInt(width / cubeSpacing) * Mathf.FloorToInt(height / cubeSpacing);
            Debug.Log(String.Format(<span class="syntax-all syntax-string">"Spawning {0} cubes"</span>, amount));

            Vector3 position = <span class="syntax-all syntax-keyword">new</span> Vector3();

            <span class="syntax-all syntax-keyword">var</span> entityPrefab = GameObjectConversionUtility.ConvertGameObjectHierarchy(cubePrefab, World.Active);
           

            <span class="syntax-all syntax-keyword">while</span> (position.x &lt; width)
            {
                <span class="syntax-all syntax-keyword">while</span> (position.y &lt; height)
                {
                    <span class="syntax-all syntax-keyword">var</span> instance = entityManager.Instantiate(entityPrefab);

                    position = <span class="syntax-all syntax-keyword">new</span> Vector3(position.x, position.y + cubeSpacing, <span class="syntax-all syntax-constant">0f</span>);
                    entityManager.SetComponentData(instance, <span class="syntax-all syntax-keyword">new</span> Translation() { Value = position });
                    entityManager.SetComponentData(instance, <span class="syntax-all syntax-keyword">new</span> RotationSpeed() { Value = math.radians(UnityEngine.Random.Range(<span class="syntax-all syntax-constant">25.0f</span>, <span class="syntax-all syntax-constant">50.0f</span>)) });
                }
                position = <span class="syntax-all syntax-keyword">new</span> Vector3(position.x + cubeSpacing, <span class="syntax-all syntax-constant">0f</span>, <span class="syntax-all syntax-constant">0f</span>);
            }

        }


    }
}</pre>
<p style="padding-left: 60px">This is a pretty standard game manager, but let's go over the exciting parts. First, we have a new attribute: <kbd>entityManager</kbd>. This is just a reference to the primary entity manager. An entity manager, as the name suggests, is a data structure where you can perform basic operations on entities, such as checking whether an entity is still alive, or creating and editing entities.</p>
<p style="padding-left: 60px">You do not need to create an entity manager. Unity will provide one for you. As you can see in <kbd>Start</kbd>, you just need to reference the main <span>global </span>one.</p>
<ol start="7">
<li>It is now time to spawn the cubes. The first interesting line is this one:</li>
</ol>
<pre style="padding-left: 60px"><span class="syntax-all syntax-keyword">var</span> entityPrefab = GameObjectConversionUtility.ConvertGameObjectHierarchy(cubePrefab, World.Active);</pre>
<p style="padding-left: 60px">With this one, we take the Prefab we built, and we convert it to an entity. Every <kbd>MonoBehaviour</kbd> in the Prefab gets converted into a component and, sometimes, more than one. We already know that <kbd>RotationSpeedAuthoring</kbd> gets converted into <kbd>RotationSpeed</kbd>, but Unity provides conversions for many standard <kbd>MonoBehaviour</kbd> subclasses, such as the following:</p>
<ul>
<li style="padding-left: 30px">Each <kbd>Transform</kbd> is converted into <kbd>Translation</kbd><span>, </span><kbd>Rotation</kbd><span>, and </span><kbd>Scale</kbd> <span>components (and some less common ones, such as </span><kbd>NonLocalScale</kbd>)</li>
<li style="padding-left: 30px">Each <kbd>MeshRenderer</kbd> is converted into the <kbd>RenderMesh</kbd> component</li>
</ul>
<ol start="8">
<li>Now, for each cube position, we need to instantiate a new entity. This is similar to how we instantiate a <kbd>GameObject</kbd>, but we invoke <kbd>Instantiate</kbd> on <kbd>entityManager</kbd>, as shown in the following code block:</li>
</ol>
<pre style="padding-left: 60px"><span class="syntax-all syntax-keyword">var</span> instance = entityManager.Instantiate(entityPrefab);</pre>
<ol start="9">
<li>Then, we set the <kbd>Translation</kbd> and <kbd>RotationSpeed</kbd> components on the entity.</li>
</ol>
<p style="padding-left: 90px">The first is to set the cube position to the computed position, and the latter to set the random rotation speed. Note that the component uses radian per second, so we need to convert the value:</p>
<pre style="padding-left: 60px">entityManager.SetComponentData(instance, <span class="syntax-all syntax-keyword">new</span> Translation() { Value = position });
entityManager.SetComponentData(instance, <span class="syntax-all syntax-keyword">new</span> RotationSpeed() { Value = math.radians(UnityEngine.Random.Range(<span class="syntax-all syntax-constant">25.0f</span>, <span class="syntax-all syntax-constant">50.0f</span>)) });</pre>
<p>At this point, we have the components, and we have a way to instantiate the entities. We are still missing a system to actually move the cubes. We want to build a system that takes every entity with <kbd>RotationSpeed</kbd> and a <kbd>Rotation</kbd> component and make them spin. Not only this, but we also want to use C# jobs so that all 10,000 cubes spin in parallel. This is a typical pattern and, therefore, Unity has a class for us.</p>
<p>However, we first need to write our job:</p>
<pre><span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">struct</span> <span class="syntax-all syntax-entity">RotatorJob</span> : <span class="syntax-all syntax-keyword">IJobForEach</span>&lt;<span class="syntax-all syntax-keyword">Rotation</span>, <span class="syntax-all syntax-keyword">RotationSpeed</span>&gt;
        {

            [ReadOnly]
            <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">float</span> deltaTime;

            <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">void</span> <span class="syntax-all syntax-entity">Execute</span>(<span class="syntax-all syntax-keyword">ref</span> <span class="syntax-all syntax-keyword">Rotation</span> <span class="syntax-all syntax-parameter">rotation</span>, [<span class="syntax-all syntax-keyword">ReadOnly]</span> <span class="syntax-all syntax-parameter">ref</span> RotationSpeed rotationSpeed)
            {
                rotation.Value = math.mul(math.normalize(rotation.Value), quaternion.AxisAngle(math.up(), rotationSpeed.Value * deltaTime));
            }
        }</pre>
<p>This is similar to the previous job, but with a number of differences. First, we extend <kbd>IJobForEachinstead</kbd> of <kbd>IJobParallelForTransform</kbd> because entities have no <kbd>Transforms</kbd>. You may note that we pass two type parameters to the <kbd>IJobForEach</kbd> interface. These are the types of components we want to use in our job, namely, <kbd>Rotation</kbd> and <kbd>RotationSpeed</kbd>. We may put any number of components in there; the important thing is that we add the same component, in the same order, as the parameters of <kbd>Execute</kbd>.</p>
<p>For example, if we extend <kbd>IJobForEach&lt;Rotation, RotationSpeed&gt;</kbd>, then <kbd>Execute</kbd> will take as parameters a reference to a <kbd>Rotation</kbd> and a <kbd>RotationSpeed</kbd> component. However, if we extend <kbd>IJobForEach&lt;Scale&gt;</kbd>, then <kbd>Execute</kbd> will only take as a parameter a reference to a <kbd>Scale</kbd> component; and so on. This acts as a filter over all the entities and makes sure that this job is applied only on entities containing <kbd>Rotation</kbd> and <kbd>RotationSpeed</kbd> components.</p>
<p>Finally, you may note that we are using some strange types for rotation: <kbd>quaterion</kbd>, with a lower case <em>q</em>. This is because Unity developed some new types for vectors and quatrains in the ECS that have the advantage of being more optimized for jobs and components.</p>
<div class="packt_infobox">There are a lot of them but, as usual, they are a work in progress. To find up-to-date info on them, check the documentation of the <kbd>Unity.Mathematics</kbd> module here: <a href="https://docs.unity3d.com/Packages/com.unity.mathematics@1.0/manual/index.html">https://docs.unity3d.com/Packages/com.unity.mathematics@1.0/manual/index.html</a></div>
<p>Now that we have a job, we need to create a component system that takes advantage of it:</p>
<pre>    <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">class</span> <span class="syntax-all syntax-entity">RotationSystem</span> : <span class="syntax-all syntax-keyword">JobComponentSystem</span>
    {
        <span class="syntax-all syntax-keyword">protected</span> <span class="syntax-all syntax-keyword">override</span> JobHandle <span class="syntax-all syntax-entity">OnUpdate</span>(<span class="syntax-all syntax-keyword">JobHandle</span> <span class="syntax-all syntax-parameter">inputDeps</span>)
        {
            RotatorJob rotatorJob = <span class="syntax-all syntax-keyword">new</span> RotatorJob()
            {
                deltaTime = Time.deltaTime
            };

            <span class="syntax-all syntax-keyword">return</span> rotatorJob.Schedule(<span class="syntax-all syntax-constant">this</span>, inputDeps);
        }
    }</pre>
<p><kbd>JobComponentSystem</kbd> is a class designed to build a system that can run using C# jobs.</p>
<p>We start by defining a new class called <kbd>RotationSystem</kbd>, which extends the <kbd>JobComponentSystem</kbd> class. Inside this class, we override the <kbd>OnUpdate</kbd> (note: <kbd>OnUpdate</kbd>, not <kbd>Update</kbd>) method, inside which we just create a new <kbd>RotatorJob</kbd> job and schedule it.</p>
<p>Now, we just need to <span><span>attach the</span></span> <kbd>ECSJobManager</kbd> to an empty <kbd>GameObject</kbd> and run the application and see all the cubes spinning as normal. With these changes, we finally reach more than 100 FPS! Let's look at <span class="packt_screen">Profiler</span>:</p>
<p class="CDPAlignCenter CDPAlign"/>
<p class="CDPAlignCenter CDPAlign"><img src="assets/3e92b1f4-8470-461a-90a9-4d2c5d97188c.png" style="width:53.58em;height:29.58em;"/></p>
<p>The time is so fast that we can see the small spikes of v-sync. Every frame takes less than 10 ms; this is less than the time we spend only on scripts using the classical non-DOTS approach! That's an incredible speeding up, and the application contains less than half the memory.</p>
<p>But guess what. We can still do better.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">The burst compiler</h1>
                </header>
            
            <article>
                
<p>The last component of the DOTS is the burst compiler. The burst compiler is a compiler that can compile a subset of C# into optimized native code. The main goal of Burst is to compile jobs so that they can be as fast and lightweight as possible.</p>
<p>The cool thing is that using the burst compiler is extremely easy. First, you need to install the Burst package from <span class="packt_screen">Window</span> | <span class="packt_screen">Package Manager</span>. Then, the only thing you need to change is to add the <kbd>[BurstCompile]</kbd> decorator on top of the job definitions as follows:</p>
<pre>[BurstCompile]
<span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">struct</span> <span class="syntax-all syntax-entity">RotatorJob</span> : <span class="syntax-all syntax-keyword">IJobForEach</span>&lt;<span class="syntax-all syntax-keyword">Rotation</span>, <span class="syntax-all syntax-keyword">RotationSpeed</span>&gt;
        {

            [ReadOnly]
            <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">float</span> deltaTime;

            <span class="syntax-all syntax-keyword">public</span> <span class="syntax-all syntax-keyword">void</span> <span class="syntax-all syntax-entity">Execute</span>(<span class="syntax-all syntax-keyword">ref</span> <span class="syntax-all syntax-keyword">Rotation</span> <span class="syntax-all syntax-parameter">rotation</span>, [<span class="syntax-all syntax-keyword">ReadOnly]</span> <span class="syntax-all syntax-parameter">ref</span> RotationSpeed rotationSpeed)
            {
                rotation.Value = math.mul(math.normalize(rotation.Value), quaternion.AxisAngle(math.up(), rotationSpeed.Value * deltaTime));
            }
        }</pre>
<p>That's it! Now the job is compiled with Burst, and this will squeeze a bit more performance from our application. Our demo is straightforward, and the Burst compilation effect is limited—on my machine, I can reach 110 FPS, but for more complex jobs, the impact is more significant.</p>


            </article>

            
        </section>
    

        <section>

                            <header>
                    <h1 class="header-title">Summary</h1>
                </header>
            
            <article>
                
<p>The DOTS is the peak of Unity's effort to push Unity into the future of gaming. I firmly believe that in the future, DOTS will be a core component of any optimization effort, and this chapter will definitely grow into several ones while DOTS becomes more stable and is supported by the community.</p>
<p>Unfortunately, at this stage, C# jobs and ECS are still very unstable, their APIs are changing rapidly and, therefore, I do not advise using them in big, important, commercial games. However, I believe it is important to start experimenting with them so as to be ready for when their time comes.</p>
<p>This chapter merely scratches the surface of the DOTS. There are many more details, configurations, and optimizations that can be implemented both in jobs and ECS. For more information, the main Unity Hub for DOTS (<a href="https://unity.com/dots">https://unity.com/dots</a>) is your best friend.</p>
<p class="p1">This chapter effectively concludes all of the techniques we can bestow that explicitly aim to improve application performance. However, optimizing your workflow is also enormously beneficial. As mentioned previously, the one constant cost of performance optimization work is development time. However, if you can speed up our development working, saving some time during the more tedious parts of the job, then hopefully, you can save yourself enough time to actually implement as many optimization techniques we've talked about through this entire book as you can. There are a lot of neat little nuances to the Unity Engine that aren't well known or clearly documented, and that only become apparent through experience with the engine or by involving ourselves in its community. As such, the next chapter will be full of hints and tips for improving how to manage your project and scenes more effectively and how to make the most of the Unity Editor.</p>


            </article>

            
        </section>
    </body></html>