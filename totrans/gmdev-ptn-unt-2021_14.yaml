- en: Using the Decorator to Implement a Weapon System
  id: totrans-0
  prefs: []
  type: TYPE_NORMAL
  zh: 使用装饰器实现武器系统
- en: In this chapter, we are going to build a customizable weapon system. Throughout
    the game, the player will be able to upgrade its bike's primary weapon by purchasing
    attachments that will augment specific properties, such as range and strength.
    The primary weapon is mounted on the front of the bike and has two expansion slots
    for attachments that the player can use to build various combinations. To build
    this system, we are going to use the Decorator pattern. It should not be a surprise
    because its name implies its use, as we will see further in the chapter.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将构建一个可定制的武器系统。在整个游戏中，玩家将能够通过购买增强特定属性（如射程和强度）的附件来升级其自行车的初级武器。初级武器安装在自行车的正面，并有两个扩展插槽，玩家可以使用这些插槽构建各种组合。为了构建这个系统，我们将使用装饰器模式。这并不令人惊讶，因为它的名字暗示了它的用途，正如我们将在本章中进一步看到的。
- en: 'The following topics will be covered in this chapter:'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 本章将涵盖以下主题：
- en: The basic principles behind the Decorator pattern
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 装饰器模式背后的基本原理
- en: The implementation of a weapon system with attachments
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 带有附件的武器系统的实现
- en: Technical requirements
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: You will need to have a basic understanding of Unity and C#.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 你需要具备Unity和C#的基本理解。
- en: 'We will be using the following Unity engine and C# language concepts:'
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将使用以下Unity引擎和C#语言概念：
- en: Constructors
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数
- en: ScriptableObjects
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ScriptableObjects
- en: If you are unfamiliar with these concepts, please review [Chapter 3](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml),
    *A Short Primer to Programming in Unity*.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你对这些概念不熟悉，请参阅[第3章](c71c8dd0-2787-43e0-a140-d9cc4ab41ff9.xhtml)，《Unity编程简明指南》。
- en: The code files for this chapter can be found on GitHub at [https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter12](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter12).
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的代码文件可以在GitHub上找到：[https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter12](https://github.com/PacktPublishing/Game-Development-Patterns-with-Unity-2021-Second-Edition/tree/main/Assets/Chapters/Chapter12)。
- en: Check out the following video to see the code in action:[ https://bit.ly/3r9rvJD](https://bit.ly/3r9rvJD).
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 查看以下视频以查看代码的实际效果：[https://bit.ly/3r9rvJD](https://bit.ly/3r9rvJD)。
- en: We often use **ScriptableObjects** in the code examples in this book because
    we want to establish an authoring workflow for our designers to create new weapon
    attachments or configure existing ones without modifying a single line of code.
    It's good practice to make your systems, ingredients, and mechanics easy to configure
    for non-programmers.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在本书的代码示例中，我们经常使用**ScriptableObjects**，因为我们希望为我们的设计师建立一个创作工作流程，以便他们可以创建新的武器附件或配置现有的附件，而无需修改任何一行代码。对于非程序员来说，使系统、成分和机制易于配置是一种良好的实践。
- en: Understanding the Decorator pattern
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解装饰器模式
- en: In short, the Decorator is a pattern that permits the addition of new functionalities
    to an existing object without altering it. And this is made possible by creating
    a decorator class that wraps the original class. And with this mechanism, we easily
    attach but also detach new behaviors to an object.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，装饰器是一种模式，它允许在不改变现有对象的情况下向其添加新功能。这是通过创建一个包装原始类的装饰器类来实现的。通过这种机制，我们可以轻松地附加但也可以从对象中移除新的行为。
- en: 'Let''s review the following diagram to visualize the Decorator''s structure
    before diving deeply into the subject matter:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入探讨主题之前，让我们回顾以下图表以可视化装饰器的结构：
- en: '![](img/06a1b37f-1842-42c4-a927-a15c3e7f6eaf.png)'
  id: totrans-17
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/06a1b37f-1842-42c4-a927-a15c3e7f6eaf.png)'
- en: Figure 12.1 – UML diagram of the Decorator pattern
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 装饰器模式的UML图
- en: The `IWeapon` interface establishes an implementation contract that will maintain
    a consistent method signature between the decorated object and its decorators.
    `WeaponDecorator` wraps the target object, and the concrete decorator classes
    (`WithGrip` and `WithStabilizer`) decorate it by enhancing or overriding its behaviors.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: '`IWeapon`接口建立了一个实现合同，它将在装饰对象及其装饰器之间保持一致的方法签名。`WeaponDecorator`包装目标对象，并通过增强或覆盖其行为来装饰它。'
- en: The method signatures and the overall structure of the *decorated* object are
    not modified during the process, just its behaviors or property values. Thus,
    we can easily remove decorations from an object and return it to its initial form.
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 在过程中，**装饰**对象的方法签名和整体结构不会被修改，只是其行为或属性值。因此，我们可以轻松地从对象中移除装饰，并使其恢复到初始形式。
- en: Most textbook examples of this pattern are heavily dependent on the class constructor.
    However, native Unity API base classes, such as `MonoBehaviour` and `ScriptableObject`,
    don't use the concept of a constructor to initialize an instance of an object.
    Instead, in the case of MonoBehaviours, the engine takes care of initializing
    the classes that are attached to GameObjects. And any initialization code is expected
    to be implemented in the `Awake()` or `Start()` callbacks.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数关于这种模式的教科书示例都高度依赖于类构造函数。然而，原生的Unity API基类，如`MonoBehaviour`和`ScriptableObject`，并不使用构造函数的概念来初始化对象的实例。相反，对于MonoBehaviours，引擎负责初始化附加到GameObject上的类。任何初始化代码都应实现于`Awake()`或`Start()`回调中。
- en: Therefore, we are challenged to find a way to adapt the Decorator pattern so
    that it will use core Unity API features while not losing its primary benefits.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们面临着找到一种方法来适应装饰器模式，使其能够使用核心Unity API功能，同时不失其主要优势的挑战。
- en: Benefits and drawbacks of the Decorator pattern
  id: totrans-23
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 装饰器模式的好处和缺点
- en: 'The following are some of the benefits of the Decorator pattern:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些装饰器模式的好处：
- en: '**Alternative to subclassing**: Inheritance is a static process. Unlike the
    Decorator pattern, it doesn''t permit extending an existing object''s behavior
    at runtime. You can only replace an instance with another with the same parent
    class that has the desired behavior. Therefore, the Decorator pattern is a more
    dynamic alternative to subclassing and overcomes the limits of inheritance.'
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**子类化的替代方案**：继承是一个静态的过程。与装饰器模式不同，它不允许在运行时扩展现有对象的行为。你只能用具有相同父类且具有所需行为的另一个实例来替换一个实例。因此，装饰器模式是子类化和过度继承的更动态的替代方案，并克服了继承的限制。'
- en: '**Runtime dynamics**: The Decorator pattern permits us to add functionality
    to an object at runtime by attaching decorators to it. But this also means that
    the reverse is possible, and you can restore an object back to its original form
    by removing its decorators.'
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**运行时动态性**：装饰器模式允许我们通过向对象附加装饰器来在运行时向其添加功能。但这同时也意味着反向操作是可能的，你可以通过移除装饰器来将对象恢复到其原始形式。'
- en: 'The following are some of the potential drawbacks of the Decorator pattern:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是一些装饰器模式的潜在缺点：
- en: '**Relationship complexity**: Keeping track of the chain of initialization and
    the relationships between decorators can become very complicated if there are
    multiple layers of decorators around an object.'
  id: totrans-28
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关系复杂性**：如果对象周围有多个装饰器层，跟踪初始化链和装饰器之间的关系可能会变得非常复杂。'
- en: '**Code complexity**: Depending on how you implement the Decorator pattern,
    it can add complexity to your code base as you might need to maintain several
    little decorator classes. But when and how this becomes an actual drawback is
    very contextual and not a constant. In the upcoming code example that we will
    review, this is not an issue as each decorator is a `ScriptableObject` instance
    that we save as a configurable asset.'
  id: totrans-29
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**代码复杂性**：根据你如何实现装饰器模式，它可能会增加你的代码库的复杂性，因为你可能需要维护几个小的装饰器类。但是，何时以及如何成为实际的缺点是非常具体的，并不是恒定的。在我们即将审查的代码示例中，这不是一个问题，因为每个装饰器都是一个保存为可配置资源的`ScriptableObject`实例。'
- en: The Decorator pattern is a part of the structural design pattern family; some
    of its members include the Adapter, Bridge, Façade, and Flyweight patterns.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式是结构设计模式家族的一部分；其成员包括适配器模式、桥接模式、外观模式和享元模式。
- en: When to use the Decorator pattern
  id: totrans-31
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 何时使用装饰器模式
- en: 'In this chapter, we are implementing a weapon system with attachments. We have
    a couple of specifications to consider, such as the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们正在实现一个带有附件的武器系统。我们需要考虑一些规范，如下所示：
- en: We need to be able to attach multiple attachments to a weapon.
  id: totrans-33
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要能够将多个附件附加到武器上。
- en: We need to be able to add and remove them at runtime.
  id: totrans-34
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 我们需要在运行时能够添加和删除它们。
- en: The Decorator pattern offers us a way to fulfill these two core requirements.
    Therefore, it's a pattern to consider when implementing a system in which we need
    to support the ability to add and remove behaviors to an individual object in
    a dynamic manner.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 装饰器模式为我们提供了一种满足这两个核心需求的方法。因此，当实现一个需要以动态方式支持向单个对象添加和删除行为时，这是一个值得考虑的模式。
- en: For instance, if we are assigned to work on a **CCG** (**collectible card game**),
    we might have to implement a mechanism in which the player can augment a base
    card's powers with artifact cards stacked on top of each other. Another use case
    is imagining having to implement a wardrobe system in which players can decorate
    their armor with accessories to buff specific stats.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，如果我们被分配去工作在一个**CCG**（可收集卡牌游戏），我们可能需要实现一个机制，让玩家可以通过堆叠在基础卡牌上的神器卡来增强基础卡牌的能力。另一个用例是想象需要实现一个衣柜系统，玩家可以用配件装饰他们的盔甲以增强特定的属性。
- en: In both cases, using the Decorator pattern could be a good starting point to
    build these types of mechanics and systems. Now that we have a basic understanding
    of the Decorator pattern, we will review the design of our weapon attachment system
    before writing code.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，使用装饰器模式可能是构建这些类型机制和系统的良好起点。现在我们已经对装饰器模式有了基本的了解，我们将在编写代码之前回顾我们的武器附件系统设计。
- en: Designing a weapon system
  id: totrans-38
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设计武器系统
- en: 'By default, every bike model in our game comes equipped with a front-mounted
    gun that fires laser beams. The player can use this weapon to destroy obstacles
    that might be in the way, and very skilled players can shoot at flying drones
    while doing wheelies. The player can also purchase various attachments that boost
    the basic stats of the bike''s weapon, as illustrated in the following diagram:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，我们游戏中的每款自行车都配备了前置枪，可以发射激光束。玩家可以使用这种武器摧毁可能挡路的障碍物，而且非常熟练的玩家可以在做轮滑动作的同时射击飞行无人机。玩家还可以购买各种附件来增强自行车武器的基线属性，如下面的图所示：
- en: '![](img/41a64774-90d0-4763-a64b-a09aecd8f27a.png)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/41a64774-90d0-4763-a64b-a09aecd8f27a.png)'
- en: Figure 12.2 – Diagram of the weapon attachment system
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 武器附件系统图
- en: 'Let''s review a shortlist of potential attachments that the player could buy:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们回顾一下玩家可能购买的潜在附件的简短列表：
- en: '**Injector**: A plasma injector that amplifies the weapon''s damage capacity.'
  id: totrans-43
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**注入器**：一种等离子体注入器，可以增强武器的伤害能力。'
- en: '**Stabilizer**: An attachment that reduces vibrations caused when the bike
    hits its top speed. It stabilizes the weapon''s shooting mechanism and expands
    its range.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**稳定器**：一种减少当自行车达到最高速度时产生的振动的附件。它稳定了武器的射击机制并扩大了其射程。'
- en: '**Cooler**: A water-cooling system that attaches itself to the weapon''s firing
    mechanism. It enhances the rate of fire and reduces the cool-down duration.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**冷却器**：一种水冷系统，附着在武器的射击机构上。它提高了射速并减少了冷却时间。'
- en: These examples are high-level concepts of potential attachment variations. Each
    of these attachments modifies or, in other words, "decorates" specific properties
    of the weapon.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这些示例是潜在附件变体的高级概念。这些附件中的每一个都修改或换句话说，“装饰”了武器的特定属性。
- en: Another requirement to keep in mind while implementing our system is that our
    weapon will have a maximum of two expansion slots for attachments. The player
    must be able to add and remove them dynamically when adjusting the settings on
    their vehicle.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现我们的系统时，还需要记住的一个要求是，我们的武器将有两个最大扩展槽位用于附件。玩家必须能够在调整他们的车辆设置时动态地添加和移除它们。
- en: Now that we have a good overview of the requirements of the design of our system,
    it's time to translate this into code, which we will do in the next section.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经很好地概述了我们的系统设计的要求，是时候将其转化为代码了，我们将在下一节中这样做。
- en: Implementing a weapon system
  id: totrans-49
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现武器系统
- en: In this section, we are going to implement the core classes of our weapon system.
    However, please note that we are not going to write the weapon's core behaviors
    for reasons of brevity. We want to keep the focus on understanding how the Decorator
    pattern works. But if you wish to review a more advanced version of this code
    example, check out the `FPP` folder in this book's GitHub repo. The link can be
    found in the *Technical requirements* section.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将实现我们武器系统的核心类。但是请注意，为了简洁起见，我们不会编写武器的核心行为。我们希望保持对理解装饰器模式如何工作的关注。但如果您想查看这个代码示例的更高级版本，请查看本书GitHub仓库中的`FPP`文件夹。链接可以在*技术要求*部分找到。
- en: Implementing the weapon system
  id: totrans-51
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现武器系统
- en: 'Many steps need to be performed as we have a lot of code to review together:'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要执行许多步骤，因为我们有很多代码要一起审查：
- en: 'To start, we are going to implement the `BikeWeapon` class. Because it''s quite
    long, we will split it up into three segments:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们将实现 `BikeWeapon` 类。因为它相当长，我们将将其分成三个部分：
- en: '[PRE0]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: The first segment is the initialization code. Note that we are setting the weapon's
    configuration at the `Start()`.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 第一部分是初始化代码。请注意，我们在 `Start()` 方法中设置了武器的配置。
- en: 'For the second segment of the class, it is just `GUI` labels that will help
    us with debugging:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类的第二个部分，它只是 `GUI` 标签，将帮助我们进行调试：
- en: '[PRE1]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'However, it is in the last segment that things start to get interesting:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，正是在最后一个部分，事情开始变得有趣：
- en: '[PRE2]'
  id: totrans-59
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Reset()` method resets the weapon to its initial configurations by initializing
    a new `Weapon` with its default weapon configurations. This is a quick and simple
    way to remove the attachments that we set in the `Decorate()` method. It's not
    always the best approach, but it works in the context of this example.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: '`Reset()` 方法通过用默认武器配置初始化一个新的 `Weapon` 来将武器重置为其初始配置。这是一种快速简单的方法来移除我们在 `Decorate()`
    方法中设置的附件。这并不总是最佳方法，但在本例的上下文中它是有效的。'
- en: 'However, `Decorate()` is where the magic happens, and the Decorator pattern
    mechanism is triggered. You might notice that we can stack attachments over one
    another by chaining them in the constructor, as we see here:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Decorate()` 方法是魔法发生的地方，装饰者模式机制被触发。你可能注意到，我们可以通过在构造函数中链式调用它们来堆叠附件，就像我们在这里看到的那样：
- en: '[PRE3]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: That's a little trick that the Decorator and constructors permit us to do. How
    it works will be made more apparent when we start implementing the other classes.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个装饰者和构造函数允许我们做的的小技巧。当开始实现其他类时，它的工作原理将变得更加明显。
- en: 'The next class to implement is the `Weapon` class. Notice that it''s not a
    `MonoBehaviour`. Therefore, we will initialize it with its constructor:'
  id: totrans-64
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 下一个要实现的是 `Weapon` 类。请注意，它不是一个 `MonoBehaviour`。因此，我们将使用其构造函数来初始化它：
- en: '[PRE4]'
  id: totrans-65
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: Unlike `BikeWeapon`, the `Weapon` class doesn't implement any behaviors; it's
    just a representation of the configurable properties of a weapon. This is the
    object we will decorate with attachments. In its constructor, we are passing an
    instance of a `WeaponConfig` object. As we are going to see further on, this is
    a `ScriptableObject`.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 与 `BikeWeapon` 不同，`Weapon` 类不实现任何行为；它只是武器可配置属性的表示。这是我们将会用附件装饰的对象。在其构造函数中，我们传递一个
    `WeaponConfig` 对象的实例。正如我们稍后将看到的，这是一个 `ScriptableObject`。
- en: 'We need a common interface between the decorator class and the weapon, so we
    are going to implement one named `IWeapon`:'
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们需要在装饰器类和武器之间有一个公共接口，因此我们将实现一个名为 `IWeapon` 的接口：
- en: '[PRE5]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now that we have a standard interface that defines a set of properties that
    we can decorate, we can implement a `WeaponDecorator` class:'
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们有一个标准接口，它定义了我们能够装饰的一组属性，我们可以实现一个 `WeaponDecorator` 类：
- en: '[PRE6]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Notice how `WeaponDecorator` is wrapping itself around an instance of an object
    that shares a similar interface, in this case, the `IWeapon` interface. It never
    modifies directly the object that's its wrapping; it's only decorating its public
    properties with those of a `WeaponAttachment`.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 `WeaponDecorator` 是如何将自己包裹在一个具有相似接口的对象实例周围，在这个例子中，是 `IWeapon` 接口。它从不直接修改它所包裹的对象；它只是用
    `WeaponAttachment` 的属性装饰其公共属性。
- en: Keep in mind that in our code example, we are just modifying the values of the
    properties of a weapon. And this fits with our design because the attachments
    don't alter the weapon's core mechanism. Instead, they just enhance specific properties
    through an attachment slot.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 请记住，在我们的代码示例中，我们只是在修改武器的属性值。这与我们的设计相吻合，因为附件不会改变武器的核心机制。相反，它们只是通过附件槽增强特定的属性。
- en: One last detail to keep in mind is the fact that we are defining the weapon's
    behavior inside the `BikeWeapon` class and its behavior is determined by the properties
    set in an instance of a `Weapon` object. Therefore, by decorating the `Weapon`
    object, we are modifying how the bike weapon behaves.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一个需要注意的细节是，我们在 `BikeWeapon` 类中定义了武器的行为，其行为由 `Weapon` 对象实例中设置的属性决定。因此，通过装饰
    `Weapon` 对象，我们正在修改自行车武器的行为。
- en: 'The following step is where we are starting to deviate from a traditional implementation
    of the Decorator pattern. Instead of defining individual concrete decorator classes,
    we are going to implement a `ScriptableObject` named `WeaponConfig`. This approach
    will permit us to author separate attachments and configure their properties through
    the inspector. Then, we will use these attachment assets to decorate the weapon,
    as we can see here:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下步骤是我们开始偏离传统 Decorator 模式实现的地方。我们不是定义单独的具体装饰器类，而是将实现一个名为 `WeaponConfig` 的 `ScriptableObject`。这种方法将允许我们编写单独的附件并通过检查器配置它们的属性。然后，我们将使用这些附件资产来装饰武器，如下所示：
- en: '[PRE7]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: It's important to note that `WeaponAttachment` implements the `IWeapon` interface.
    This keeps it consistent with `WeaponDecorator` and `Weapon` classes as all three
    of them share the same interface.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 重要的是要注意，`WeaponAttachment` 实现了 `IWeapon` 接口。这使其与 `WeaponDecorator` 和 `Weapon`
    类保持一致，因为这三个类都共享相同的接口。
- en: 'And for our last step, we are going to implement the `ScriptableObject` class
    named `WeaponConfig`. We are using to it create various configurations for our
    `Weapon` object that we can then configure with attachments:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在最后一步，我们将实现名为 `WeaponConfig` 的 `ScriptableObject` 类。我们用它来创建各种配置，以便我们可以用附件来配置我们的
    `Weapon` 对象：
- en: '[PRE8]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: We now have all the key ingredients for our weapon attachment system, and it's
    time to test them inside the Unity engine.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们现在拥有了武器附件系统的所有关键成分，现在是时候在 Unity 引擎中测试它们了。
- en: Testing the weapon system
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 测试武器系统
- en: 'If you wish to test the code we just reviewed in your own instance of Unity,
    you need to follow these steps:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你希望在自己的 Unity 实例中测试我们刚刚审查的代码，你需要遵循以下步骤：
- en: Copy all the classes we just reviewed in your Unity project.
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们刚刚审查的所有类复制到你的 Unity 项目中。
- en: Create an empty Unity scene.
  id: totrans-83
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个空的 Unity 场景。
- en: Add a new GameObject to the scene.
  id: totrans-84
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个新的 GameObject 添加到场景中。
- en: 'Attach the following client script to the new GameObject:'
  id: totrans-85
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下客户端脚本附加到新的 GameObject：
- en: '[PRE9]'
  id: totrans-86
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: Add to the new GameObject the `BikeWeapon` script we implemented in the previous
    section.
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将我们在上一节中实现的 `BikeWeapon` 脚本添加到新的 GameObject 中。
- en: Under the **Assets** | **Create** | **Weapon** menu option, create a new **Config**
    and configure it as you wish.
  id: totrans-88
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Assets** | **Create** | **Weapon** 菜单选项下，创建一个新的 **Config** 并按你的意愿进行配置。
- en: Under the **Assets** | **Create** | **Weapon** menu option, create several **Attachment**
    variations with various configurations.
  id: totrans-89
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 **Assets** | **Create** | **Weapon** 菜单选项下，创建几个具有各种配置的 **Attachment** 变体。
- en: 'You can now add `WeaponConfig` and `WeaponAttachment` assets to the `BikeWeapon`
    component properties in `Inspector`, as seen in the following screenshot:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，你可以在 `Inspector` 中的 `BikeWeapon` 组件属性中添加 `WeaponConfig` 和 `WeaponAttachment`
    资产，如下面的截图所示：
- en: '![](img/eff3396f-8fe2-4109-9670-00320555bbe2.png)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![](img/eff3396f-8fe2-4109-9670-00320555bbe2.png)'
- en: Figure 12.3 – BikeWeapon component properties
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.3 – BikeWeapon 组件属性
- en: 'When you start your scene, you should see the following buttons in the top-left
    corner of the screen, as shown in the following screenshot:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 当你启动你的场景时，你应该在屏幕的左上角看到以下按钮，如下面的截图所示：
- en: '![](img/372aed4f-bb8d-4731-ad96-fd9b270cbec5.png)'
  id: totrans-94
  prefs: []
  type: TYPE_IMG
  zh: '![](img/372aed4f-bb8d-4731-ad96-fd9b270cbec5.png)'
- en: Figure 12.4 – Screenshot of the code example in action inside Unity
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.4 – Unity 中代码示例的实际截图
- en: You now test the weapon attachment system and adjust it as you wish by pressing
    the buttons and look at the weapon stats change as you modify the decorator's
    settings.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过按按钮来测试武器附件系统，并根据你的意愿进行调整，同时观察随着装饰器设置的修改，武器统计数据的变化。
- en: Reviewing the weapon system
  id: totrans-97
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 检查武器系统
- en: Our Decorator implementation is unorthodox because we are mixing native C# language
    features such as constructors while trying to utilize the best parts of the Unity
    API. By converting decorator classes into configurable `ScriptableObject` assets,
    we gain the ability to make our weapon attachments authorable and configurable
    by non-programmers. And under the hood, our attachment system is constructed on
    the foundation of a solid design pattern.
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的 Decorator 实现是非传统的，因为我们混合了原生 C# 语言特性，如构造函数，同时在尝试利用 Unity API 的最佳部分。通过将装饰器类转换为可配置的
    `ScriptableObject` 资产，我们获得了使我们的武器附件可由非程序员编写和配置的能力。而且，在底层，我们的附件系统建立在稳固的设计模式基础之上。
- en: Therefore, we endeavored to strike a balance between usability and maintainability.
    However, as we are going to see in the next section, there are always alternative
    approaches.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们努力在可用性和可维护性之间取得平衡。然而，正如我们将在下一节中看到的，总有其他方法。
- en: Design patterns are guidelines, not commandments. Therefore, it's OK to experiment
    with patterns and test out different ways of implementing them. The code example
    in this chapter is experimental because it's not a traditional implementation
    of the Decorator pattern. But we encourage you, as the reader, to continue experimenting
    with the patterns showcased in this book and find new ways of using them in Unity.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 设计模式是指导原则，而非命令。因此，尝试不同的模式实现方式是完全可以接受的。本章中的代码示例是实验性的，因为它并不是传统装饰器模式的实现。但我们鼓励读者继续在本书中展示的模式上进行实验，并找到在Unity中使用它们的新方法。
- en: Reviewing alternative solutions
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 审查替代方案
- en: In the context of the use case presented in this chapter, we could have implemented
    the weapon system without the Decorator pattern and with ScriptableObjects only.
    We could have iterated through a list of acquired weapon attachments and apply
    each of their properties to those of a `Weapon` class. We would lose the ability
    of chaining decorators, but our code will be more straightforward.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章所展示的使用案例的背景下，我们本可以使用装饰器模式以及可脚本化的对象来实现武器系统。我们可以遍历一个已获取的武器附件列表，并将它们的属性应用到`Weapon`类上。虽然我们会失去链式装饰的能力，但我们的代码将会更加直接。
- en: The core benefit of using the Decorator pattern in our case was that it gave
    us a structured and repeatable approach to implementing our system. Still, in
    consequence, we added additional complexity to our code base.
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的案例中，使用装饰器模式的核心好处是它为我们提供了一个结构化和可重复的系统实现方法。然而，作为结果，我们也给我们的代码库增加了额外的复杂性。
- en: Summary
  id: totrans-104
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we implemented a weapon attachment system that's authorable
    and configurable. Non-programmers will be able to create and adjust new attachments
    without writing a single line of code. Therefore, we can focus on building systems
    while designers work on balancing them. The Decorator pattern has proven itself
    to be a handy pattern for game development, and so it's a pattern to keep in our
    programmer's toolbox.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们实现了一个可编写和可配置的武器附件系统。非程序员将能够创建和调整新的附件，而无需编写一行代码。因此，我们可以专注于构建系统，而设计师则可以专注于平衡工作。装饰器模式已被证明是游戏开发中的一个实用模式，因此它应该成为程序员工具箱中的一个模式。
- en: In the next chapter, we will explore the Spatial Partition pattern—a subject
    matter that's quite important to understand when building games with large maps.
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将探讨空间分区模式——这是在构建大型地图游戏时理解的一个重要主题。
