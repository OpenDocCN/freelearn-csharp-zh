<html><head></head><body>
<div id="_idContainer024">
<h1 class="chapter-number" id="_idParaDest-72"><a id="_idTextAnchor071"/><span class="koboSpan" id="kobo.1.1">5</span></h1>
<h1 id="_idParaDest-73"><a id="_idTextAnchor072"/><span class="koboSpan" id="kobo.2.1">Working with the CQRS Pattern</span></h1>
<p><span class="koboSpan" id="kobo.3.1">We now know that microservices require a bit of foresight during the planning phase, and we need to ensure that we employ the best patterns and technology to support our decisions. </span><span class="koboSpan" id="kobo.3.2">In this chapter, we will be exploring another pattern that has gained much acclaim in helping us to write clean and maintainable code. </span><span class="koboSpan" id="kobo.3.3">This is the </span><strong class="bold"><span class="koboSpan" id="kobo.4.1">Command Query Responsibility Segregation or Separation</span></strong><span class="koboSpan" id="kobo.5.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.6.1">CQRS</span></strong><span class="koboSpan" id="kobo.7.1">) pattern, which is an extension of the </span><strong class="bold"><span class="koboSpan" id="kobo.8.1">Command-Query Separation</span></strong><span class="koboSpan" id="kobo.9.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.10.1">CQS</span></strong><span class="koboSpan" id="kobo.11.1">) pattern.</span></p>
<p><span class="koboSpan" id="kobo.12.1">This pattern allows us to cleanly separate our query operations from our command operations. </span><span class="koboSpan" id="kobo.12.2">In essence, a query asks for data, and the command should modify data in one way or another by the end of the operation.</span></p>
<p><span class="koboSpan" id="kobo.13.1">As programmers, we tend to employ </span><strong class="bold"><span class="koboSpan" id="kobo.14.1">Create, Read, Update, and Delete</span></strong><span class="koboSpan" id="kobo.15.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.16.1">CRUD</span></strong><span class="koboSpan" id="kobo.17.1">) in our applications. </span><span class="koboSpan" id="kobo.17.2">Considering that every application’s core functionality is to support CRUD operations, this is understandable. </span><span class="koboSpan" id="kobo.17.3">But the more intricate the application gets, the more we need to consider the business logic surrounding each of these operations, relative to the problem domain we are addressing.</span></p>
<p><span class="koboSpan" id="kobo.18.1">At that point, we begin to use words such as </span><em class="italic"><span class="koboSpan" id="kobo.19.1">behavior</span></em><span class="koboSpan" id="kobo.20.1"> and </span><em class="italic"><span class="koboSpan" id="kobo.21.1">scenarios</span></em><span class="koboSpan" id="kobo.22.1">. </span><span class="koboSpan" id="kobo.22.2">We begin to consider structuring our code in a manner that allows us to isolate behaviors and easily determine whether this behavior is simply a request for data or will augment data by the end of the operation.</span></p>
<p><span class="koboSpan" id="kobo.23.1">After reading this chapter, you will achieve the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.24.1">Understand the benefits of the CQRS pattern and why it is used for microservices development</span></li>
<li><span class="koboSpan" id="kobo.25.1">Know how to implement commands in the CQRS pattern</span></li>
<li><span class="koboSpan" id="kobo.26.1">Know how to implement queries in the CQRS pattern</span></li>
</ul>
<h1 id="_idParaDest-74"><a id="_idTextAnchor073"/><span class="koboSpan" id="kobo.27.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.28.1">Code references used in this chapter can be found in the project repository, which is hosted on GitHub at this URL: </span><a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch05"><span class="koboSpan" id="kobo.29.1">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch05</span></a><span class="koboSpan" id="kobo.30.1">.</span></p>
<h1 id="_idParaDest-75"><a id="_idTextAnchor074"/><span class="koboSpan" id="kobo.31.1">Why use CQRS for microservices development?</span></h1>
<p><strong class="bold"><span class="koboSpan" id="kobo.32.1">CQS</span></strong><span class="koboSpan" id="kobo.33.1"> was introduced </span><a id="_idIndexMarker206"/><span class="koboSpan" id="kobo.34.1">as a pattern that </span><a id="_idIndexMarker207"/><span class="koboSpan" id="kobo.35.1">would help developers separate code that does read operations from code that does write operations. </span><span class="koboSpan" id="kobo.35.2">The shortcoming with it was that it didn’t account for establishing specific models for each operation. </span><span class="koboSpan" id="kobo.35.3">CQRS built on this and introduced the concept of having specific models, tailored for the operation to be carried out.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.36.1">Figure 5.1</span></em><span class="koboSpan" id="kobo.37.1"> shows a typical CQRS architecture:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer021">
<span class="koboSpan" id="kobo.38.1"><img alt="Figure 5.1 – The application will interact with models for read operations and models for write operations, known as commands" src="image/Figure_5.1_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.39.1">Figure 5.1 – The application will interact with models for read operations and models for write operations, known as commands</span></p>
<p><span class="koboSpan" id="kobo.40.1">If you look a bit more closely, it can be argued that CQS only accounts for one data store, meaning we are doing read/write operations against the same database. </span><span class="koboSpan" id="kobo.40.2">CQRS would suggest that you have separate data stores, having potentially a standard relational database for your write operations and conducting read operations for a separate store, such as a document database or data warehouse. </span><span class="koboSpan" id="kobo.40.3">The implementation of multiple data stores is not always an option, nor is it a must.</span></p>
<p><span class="koboSpan" id="kobo.41.1">CQRS has gained much acclaim since its introduction in development and is touted as a very important staple in microservice design. </span><span class="koboSpan" id="kobo.41.2">The truth is, it can be used in standard applications, so it is not unique to microservices. </span><span class="koboSpan" id="kobo.41.3">It also adds a new level of complexity to the development effort as it introduces the need for more specific classes and code to be written, which can lead to project bloat.</span></p>
<p><span class="koboSpan" id="kobo.42.1">It is said, </span><em class="italic"><span class="koboSpan" id="kobo.43.1">“…when we have a hammer, everything looks like a nail…”</span></em><span class="koboSpan" id="kobo.44.1"> and this remains true in the context of when we hear of a new pattern and feel the need to use it everywhere. </span><span class="koboSpan" id="kobo.44.2">I suggest that you apply caution and careful consideration before using this pattern and ensure that its value in the application is justified.</span></p>
<p><span class="koboSpan" id="kobo.45.1">For bigger applications, CQRS is recommended to help us structure our code and more cleanly handle potentially complex business logic and moving parts. </span><span class="koboSpan" id="kobo.45.2">Though it is complex, it</span><a id="_idIndexMarker208"/><span class="koboSpan" id="kobo.46.1"> does </span><a id="_idIndexMarker209"/><span class="koboSpan" id="kobo.47.1">have benefits. </span><span class="koboSpan" id="kobo.47.2">Let us review the benefits of implementing the CQRS pattern in our applications.</span></p>
<h2 id="_idParaDest-76"><a id="_idTextAnchor075"/><span class="koboSpan" id="kobo.48.1">Benefits of the CQRS pattern</span></h2>
<p><span class="koboSpan" id="kobo.49.1">CQRS is about </span><a id="_idIndexMarker210"/><span class="koboSpan" id="kobo.50.1">splitting a single model into two variations, one for reads and one for writes. </span><span class="koboSpan" id="kobo.50.2">The end goal, however, is a bigger spoke in the wheel. </span><span class="koboSpan" id="kobo.50.3">The first benefit of this approach is scalability.</span></p>
<p><span class="koboSpan" id="kobo.51.1">It is important to assess the read/write workload of the system you are building. </span><span class="koboSpan" id="kobo.51.2">Read operations are arguably more intensive than write operations, given that one read may require copious amounts of data from several tables and each request might have its own requirements around what the data needs to look like. </span><span class="koboSpan" id="kobo.51.3">One school of thought encourages that we employ a data store that is dedicated to and optimized for reading operations. </span><span class="koboSpan" id="kobo.51.4">This allows us to scale read operations separately from write operations.</span></p>
<p><span class="koboSpan" id="kobo.52.1">An example of a dedicated read store could be a </span><em class="italic"><span class="koboSpan" id="kobo.53.1">data warehouse</span></em><span class="koboSpan" id="kobo.54.1">, where data is constantly being transformed by some form of data transformation pipeline, from the write data store, which is probably a normalized </span><em class="italic"><span class="koboSpan" id="kobo.55.1">relational database</span></em><span class="koboSpan" id="kobo.56.1">. </span><span class="koboSpan" id="kobo.56.2">Another commonly used technology is NoSQL databases</span><a id="_idIndexMarker211"/><span class="koboSpan" id="kobo.57.1"> such as </span><strong class="bold"><span class="koboSpan" id="kobo.58.1">MongoDB</span></strong><span class="koboSpan" id="kobo.59.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.60.1">Cosmos DB</span></strong><span class="koboSpan" id="kobo.61.1">. </span><span class="koboSpan" id="kobo.61.2">The data </span><a id="_idIndexMarker212"/><span class="koboSpan" id="kobo.62.1">constructs provided by the data warehouse or NoSQL databases represent a denormalized, read-only version of the data from the relational data store.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.63.1">Figure 5.2</span></em><span class="koboSpan" id="kobo.64.1"> shows a CQRS architecture with two databases:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer022">
<span class="koboSpan" id="kobo.65.1"><img alt="Figure 5.2 – The query model represents read operation-optimized representations of the data from the ﻿transactional database" src="image/Figure_5.2_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.66.1">Figure 5.2 – The query model represents read operation-optimized representations of the data from the transactional database</span></p>
<p><span class="koboSpan" id="kobo.67.1">The second benefit is performance. </span><span class="koboSpan" id="kobo.67.2">Though it seems to go hand in hand with scalability, there are different dynamics that we consider. </span><span class="koboSpan" id="kobo.67.3">Using separate data stores isn’t always a viable option, so there are other techniques that we can employ to optimize our operations that wouldn’t be possible with a unified data model. </span><span class="koboSpan" id="kobo.67.4">We can apply caching, for instance, to queries that do read operations. </span><span class="koboSpan" id="kobo.67.5">We can also employ database-specific features and fine-tuned raw SQL statements for our requests in contrast to </span><strong class="bold"><span class="koboSpan" id="kobo.68.1">object-relational mapping</span></strong><span class="koboSpan" id="kobo.69.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.70.1">ORM</span></strong><span class="koboSpan" id="kobo.71.1">) code </span><a id="_idIndexMarker213"/><span class="koboSpan" id="kobo.72.1">on the side of the command.</span></p>
<p><span class="koboSpan" id="kobo.73.1">Another benefit that we can reap from this pattern is simplicity. </span><span class="koboSpan" id="kobo.73.2">This sounds contradictory given that we mentioned complications in the earlier parts of this chapter, but it depends on the lens that you use to assess the rewards you will reap in the long run. </span><span class="koboSpan" id="kobo.73.3">Commands and queries have different needs, and it is not reasonable to use one data model to suit both sets of needs. </span><span class="koboSpan" id="kobo.73.4">CQRS forces us to consider creating specific data models for each query or command, which leads to more maintainable code. </span><span class="koboSpan" id="kobo.73.5">Each new data model is responsible for a specific operation, and modification therein will have little to no impact on other aspects of our program.</span></p>
<p><span class="koboSpan" id="kobo.74.1">We see here that</span><a id="_idIndexMarker214"/><span class="koboSpan" id="kobo.75.1"> there are a few benefits to using CQRS in our projects. </span><span class="koboSpan" id="kobo.75.2">But where there are pros, there are cons. </span><span class="koboSpan" id="kobo.75.3">Let us review some of the downsides to employing this design pattern.</span></p>
<h2 id="_idParaDest-77"><a id="_idTextAnchor076"/><span class="koboSpan" id="kobo.76.1">Disadvantages of the CQRS pattern</span></h2>
<p><span class="koboSpan" id="kobo.77.1">Every pattern</span><a id="_idIndexMarker215"/><span class="koboSpan" id="kobo.78.1"> that we consider must be investigated thoroughly for the value that it adds, and the potential drawbacks. </span><span class="koboSpan" id="kobo.78.2">We always want to make sure that the benefits outweigh the disadvantages and that we won’t live to regret these major design decisions. </span><span class="koboSpan" id="kobo.78.3">CQRS is not ideal for applications that will do simple CRUD operations. </span><span class="koboSpan" id="kobo.78.4">It is behavior- or scenario-driven, as we have stated, so be sure that you can justify the use cases before you take the plunge. </span><span class="koboSpan" id="kobo.78.5">This pattern will lead to a perceived duplication of code since it promotes the</span><a id="_idIndexMarker216"/><span class="koboSpan" id="kobo.79.1"> concept of </span><strong class="bold"><span class="koboSpan" id="kobo.80.1">separation of concerns</span></strong><span class="koboSpan" id="kobo.81.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.82.1">SoC</span></strong><span class="koboSpan" id="kobo.83.1">) and encourages that commands and queries have dedicated models.</span></p>
<p><span class="koboSpan" id="kobo.84.1">On a personal note, I have seen development leads start off with all the best intentions and implement CQRS in projects that, in truth, didn’t require it. </span><span class="koboSpan" id="kobo.84.2">The projects turned out to be overcomplicated, leaving all the newer developers completely confused as to what went where.</span></p>
<p><span class="koboSpan" id="kobo.85.1">As we have seen, there is a case for multiple data storage areas when we use CQRS. </span><span class="koboSpan" id="kobo.85.2">Arguably, that is the most complete implementation of it. </span><span class="koboSpan" id="kobo.85.3">Once we introduce multiple data stores, we introduce data consistency problems and need to implement </span><em class="italic"><span class="koboSpan" id="kobo.86.1">Event Sourcing</span></em><span class="koboSpan" id="kobo.87.1"> techniques and </span><a id="_idIndexMarker217"/><span class="koboSpan" id="kobo.88.1">include </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">service-level agreements</span></strong><span class="koboSpan" id="kobo.90.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.91.1">SLAs</span></strong><span class="koboSpan" id="kobo.92.1">) to let our users know of the potential gap between our read/write operations. </span><span class="koboSpan" id="kobo.92.2">We also must consider the additional costs in terms of infrastructure and general operation when we have multiple databases. </span><span class="koboSpan" id="kobo.92.3">With multiple databases comes multiple potential points of failure and the need for additional monitoring and fail-safe techniques to ensure that the system runs as smoothly as possible, even in the face of outages.</span></p>
<p><span class="koboSpan" id="kobo.93.1">CQRS can add value to a project when it is applied sensibly. </span><span class="koboSpan" id="kobo.93.2">When your project has complex business logic, or a distinct need for separating data stores and read/write operations, then CQRS will shine as an appropriate architectural choice.</span></p>
<p><span class="koboSpan" id="kobo.94.1">This pattern is</span><a id="_idIndexMarker218"/><span class="koboSpan" id="kobo.95.1"> not unique to any programming language, and .NET has excellent support for the pattern. </span><span class="koboSpan" id="kobo.95.2">Now let us review implementing CQRS using the Mediator pattern with the help of a few tools and libraries.</span></p>
<h2 id="_idParaDest-78"><a id="_idTextAnchor077"/><span class="koboSpan" id="kobo.96.1">Using the Mediator pattern with CQRS in .NET</span></h2>
<p><span class="koboSpan" id="kobo.97.1">Before we </span><a id="_idIndexMarker219"/><span class="koboSpan" id="kobo.98.1">get into how we implement</span><a id="_idIndexMarker220"/><span class="koboSpan" id="kobo.99.1"> CQRS, we should discuss a supporting pattern called the </span><em class="italic"><span class="koboSpan" id="kobo.100.1">Mediator</span></em><span class="koboSpan" id="kobo.101.1"> pattern. </span><span class="koboSpan" id="kobo.101.2">The Mediator pattern involves us defining an object that embodies how objects interact with each other. </span><span class="koboSpan" id="kobo.101.3">So, we can avoid two or more objects having direct dependencies on each other and, instead, use a mediator in between that will orchestrate the dependencies and route requests to appropriate </span><em class="italic"><span class="koboSpan" id="kobo.102.1">handlers</span></em><span class="koboSpan" id="kobo.103.1">. </span><span class="koboSpan" id="kobo.103.2">A handler will define all the details of the operation to be carried out based on the scenario or task to which the model is associated.</span></p>
<p><em class="italic"><span class="koboSpan" id="kobo.104.1">Figure 5.3</span></em><span class="koboSpan" id="kobo.105.1"> shows how the Mediator pattern works:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer023">
<span class="koboSpan" id="kobo.106.1"><img alt="Figure 5.3 – The query/command model is registered in the mediator engine, which then selects the appropriate handler for an operation" src="image/Figure_5.3_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.107.1">Figure 5.3 – The query/command model is registered in the mediator engine, which then selects the appropriate handler for an operation</span></p>
<p><span class="koboSpan" id="kobo.108.1">The Mediator </span><a id="_idIndexMarker221"/><span class="koboSpan" id="kobo.109.1">pattern </span><a id="_idIndexMarker222"/><span class="koboSpan" id="kobo.110.1">becomes useful relative to the implementation of the CQRS pattern since we need to promote loose coupling between the code being defined for each task. </span><span class="koboSpan" id="kobo.110.2">It allows us to maintain </span><em class="italic"><span class="koboSpan" id="kobo.111.1">loose coupling</span></em><span class="koboSpan" id="kobo.112.1"> and promotes more testability and scalability.</span></p>
<p><span class="koboSpan" id="kobo.113.1">In .NET Core, we have an excellent third-party package called </span><strong class="source-inline"><span class="koboSpan" id="kobo.114.1">MediatR</span></strong><span class="koboSpan" id="kobo.115.1"> that helps us implement this pattern with relative ease. </span><strong class="source-inline"><span class="koboSpan" id="kobo.116.1">MediatR</span></strong><span class="koboSpan" id="kobo.117.1"> assumes the role of an </span><em class="italic"><span class="koboSpan" id="kobo.118.1">in-process</span></em><span class="koboSpan" id="kobo.119.1"> mediator where it manages how classes interact with each other during the same process. </span><span class="koboSpan" id="kobo.119.2">One limitation here is that it might not be the best package if we wanted to separate commands and queries across different systems. </span><span class="koboSpan" id="kobo.119.3">Notwithstanding that drawback, it helps us to author CQRS-based systems with relative ease, efficiency, and reliability. </span><span class="koboSpan" id="kobo.119.4">We can develop strongly typed code that will ensure that we do not mismatch models and handlers, and we can even construct pipelines to govern the entire behavior of a request as it flows through the complete cycle.</span></p>
<p><span class="koboSpan" id="kobo.120.1">In a .NET Core application, we can set up </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">MediatR</span></strong><span class="koboSpan" id="kobo.122.1"> using the following steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.123.1">Install the </span><strong class="source-inline"><span class="koboSpan" id="kobo.124.1">MediatR.Extensions.Microsoft.DependencyInjection</span></strong><span class="koboSpan" id="kobo.125.1"> NuGet package</span></li>
<li><span class="koboSpan" id="kobo.126.1">Modify our </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">Program.cs</span></strong><span class="koboSpan" id="kobo.128.1"> file with the following line: </span><strong class="source-inline"><span class="koboSpan" id="kobo.129.1">builder.Services.AddMediatR(typeof(Program));</span></strong></li>
</ol>
<p><span class="koboSpan" id="kobo.130.1">Once we have done this, we can proceed to inject our </span><strong class="source-inline"><span class="koboSpan" id="kobo.131.1">IMediator</span></strong><span class="koboSpan" id="kobo.132.1"> service into our controllers or endpoints for further use. </span><span class="koboSpan" id="kobo.132.2">We will also need to implement two files that will directly relate to each other as the command/query model and the corresponding handler.</span></p>
<p><span class="koboSpan" id="kobo.133.1">Now that we</span><a id="_idIndexMarker223"/><span class="koboSpan" id="kobo.134.1"> have</span><a id="_idIndexMarker224"/><span class="koboSpan" id="kobo.135.1"> explored the foundations of setting up a CQRS implementation using the Mediator pattern, let us review the steps required to implement a command.</span></p>
<h1 id="_idParaDest-79"><a id="_idTextAnchor078"/><span class="koboSpan" id="kobo.136.1">Implementing a command</span></h1>
<p><span class="koboSpan" id="kobo.137.1">As we remember, a </span><a id="_idIndexMarker225"/><span class="koboSpan" id="kobo.138.1">command is expected to carry out actions that will augment the data in the data store, otherwise called a write operation. </span><span class="koboSpan" id="kobo.138.2">Given that we are using the Mediator pattern to govern how we carry out these operations, we will need a command model and a handler.</span></p>
<h2 id="_idParaDest-80"><a id="_idTextAnchor079"/><span class="koboSpan" id="kobo.139.1">Creating a command model</span></h2>
<p><span class="koboSpan" id="kobo.140.1">Our model is </span><a id="_idIndexMarker226"/><span class="koboSpan" id="kobo.141.1">relatively simple to implement. </span><span class="koboSpan" id="kobo.141.2">It tends to be a standard class or record, but with </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">MediatR</span></strong><span class="koboSpan" id="kobo.143.1"> present,we will implement a new type called </span><strong class="source-inline"><span class="koboSpan" id="kobo.144.1">IRequest</span></strong><span class="koboSpan" id="kobo.145.1">. </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">IRequest</span></strong><span class="koboSpan" id="kobo.147.1"> will associate this model class with an associated handler, which we will be looking into in a bit.</span></p>
<p><span class="koboSpan" id="kobo.148.1">In the example of making an appointment in our system, we can relatively easily implement a </span><strong class="source-inline"><span class="koboSpan" id="kobo.149.1">CreateAppointmentCommand.cs</span></strong><span class="koboSpan" id="kobo.150.1"> file like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.151.1">
public record CreateAppointmentCommand (int
  AppointmentTypeId, Guid DoctorId, Guid PatientId, Guid
    RoomId, DateTime Start, DateTime End, string Title):
      IRequest&lt;string&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.152.1">We use a </span><strong class="source-inline"><span class="koboSpan" id="kobo.153.1">record</span></strong><span class="koboSpan" id="kobo.154.1"> type in this example, but it could just as easily be a class definition if that is more comfortable for you. </span><span class="koboSpan" id="kobo.154.2">Notice that we inherit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.155.1">IRequest&lt;string&gt;</span></strong><span class="koboSpan" id="kobo.156.1">, which outlines to </span><strong class="source-inline"><span class="koboSpan" id="kobo.157.1">MediatR</span></strong><span class="koboSpan" id="kobo.158.1"> the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.159.1">This command should be associated with a handler with a corresponding return type.</span></li>
<li><span class="koboSpan" id="kobo.160.1">The handler that is associated with this command is expected to return a string value. </span><span class="koboSpan" id="kobo.160.2">This will be the appointment </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">Id</span></strong><span class="koboSpan" id="kobo.162.1"> value.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.163.1">Commands don’t always need to return a type. </span><span class="koboSpan" id="kobo.163.2">If you don’t expect a return type, you may simply inherit from </span><strong class="source-inline"><span class="koboSpan" id="kobo.164.1">IRequest</span></strong><span class="koboSpan" id="kobo.165.1">.</span></p>
<p><span class="koboSpan" id="kobo.166.1">Now that we </span><a id="_idIndexMarker227"/><span class="koboSpan" id="kobo.167.1">have an idea of how the command model needs to look, let us implement the corresponding handler.</span></p>
<h2 id="_idParaDest-81"><a id="_idTextAnchor080"/><span class="koboSpan" id="kobo.168.1">Creating a command handler</span></h2>
<p><span class="koboSpan" id="kobo.169.1">Our handler is where </span><a id="_idIndexMarker228"/><span class="koboSpan" id="kobo.170.1">the logic for carrying out the task usually sits. </span><span class="koboSpan" id="kobo.170.2">In some implementations and in the absence of a rich data model, you can carry out all the validations and additional tasks required to ensure that the task is handled properly. </span><span class="koboSpan" id="kobo.170.3">This way, we can better isolate the business logic that is expected when a particular command is sent for execution.</span></p>
<p><span class="koboSpan" id="kobo.171.1">Our handler for our command to create an appointment will be called </span><strong class="source-inline"><span class="koboSpan" id="kobo.172.1">CreateAppointmentHandler.cs</span></strong><span class="koboSpan" id="kobo.173.1"> and can be implemented like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
public class CreateAppointmentHandler :
  IRequestHandler&lt;CreateAppointmentCommand, string&gt;
{
    private readonly IAppointmentRepository _repo;
    public CreateAppointmentHandler(IAppointmentRepository
      repo /* Any Other Dependencies */)
{
        _repo = repo
        /* Any Other Dependencies */
      };
    public async Task&lt;string&gt; Handle
      (CreateAppointmentCommand request, CancellationToken
         cancellationToken)
    {
        // Handle Pre-checks and Validations Here
        var newAppointment = new Appointment
        (
            Guid.NewGuid(),
            request.AppointmentTypeId,
            request.DoctorId,
            request.PatientId,
            request.RoomId,
            request.Start,
            request.End,
            request.Title
        );
        await _repo.Add(newAppointment);
     //Perform post creation hand-off to services bus.
</span><span class="koboSpan" id="kobo.174.2">        return newAppointment.Id.ToString();
    }
}</span></pre>
<p><span class="koboSpan" id="kobo.175.1">There are several things to take note of here:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.176.1">The handler inherits from </span><strong class="source-inline"><span class="koboSpan" id="kobo.177.1">IRequestHandler&lt;&gt;</span></strong><span class="koboSpan" id="kobo.178.1">. </span><span class="koboSpan" id="kobo.178.2">In the type brackets, we outline the specific </span><em class="italic"><span class="koboSpan" id="kobo.179.1">command model type</span></em><span class="koboSpan" id="kobo.180.1"> that the handler is being implemented for and the </span><em class="italic"><span class="koboSpan" id="kobo.181.1">expected return type</span></em><span class="koboSpan" id="kobo.182.1">.</span></li>
<li><span class="koboSpan" id="kobo.183.1">A handler is implemented like any other class and can have dependencies injected in as needed.</span></li>
<li><span class="koboSpan" id="kobo.184.1">After completing our operations, we must return a value with a data type that matches the one outlined by </span><strong class="source-inline"><span class="koboSpan" id="kobo.185.1">IRequest&lt;&gt;</span></strong><span class="koboSpan" id="kobo.186.1"> from the command model.</span></li>
<li><strong class="source-inline"><span class="koboSpan" id="kobo.187.1">IRequestHandler</span></strong><span class="koboSpan" id="kobo.188.1"> implements a method called </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Handle</span></strong><span class="koboSpan" id="kobo.190.1"> that defaults to the outlined return type of </span><strong class="source-inline"><span class="koboSpan" id="kobo.191.1">IRequest&lt;&gt;</span></strong><span class="koboSpan" id="kobo.192.1"> attached to the command model. </span><span class="koboSpan" id="kobo.192.2">It will automatically generate a parameter called </span><strong class="source-inline"><span class="koboSpan" id="kobo.193.1">request</span></strong><span class="koboSpan" id="kobo.194.1">, which will be of the command model’s data type.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.195.1">If we did not require a return value, we would have to return </span><strong class="source-inline"><span class="koboSpan" id="kobo.196.1">Unit.Value</span></strong><span class="koboSpan" id="kobo.197.1">. </span><span class="koboSpan" id="kobo.197.2">This is the default </span><strong class="source-inline"><span class="koboSpan" id="kobo.198.1">void</span></strong><span class="koboSpan" id="kobo.199.1"> representation of </span><strong class="source-inline"><span class="koboSpan" id="kobo.200.1">MediatR</span></strong><span class="koboSpan" id="kobo.201.1">.</span></p>
<p><span class="koboSpan" id="kobo.202.1">Now that we have</span><a id="_idIndexMarker229"/><span class="koboSpan" id="kobo.203.1"> some boilerplate code for implementing a command model and its corresponding handler, let us look at making an actual call to the handler from a controller.</span></p>
<h2 id="_idParaDest-82"><a id="_idTextAnchor081"/><span class="koboSpan" id="kobo.204.1">Invoking a command</span></h2>
<p><span class="koboSpan" id="kobo.205.1">We have our </span><a id="_idIndexMarker230"/><span class="koboSpan" id="kobo.206.1">controller defined for appointment booking operations and it needs to have the dependency for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.207.1">IMediator</span></strong><span class="koboSpan" id="kobo.208.1"> service present to begin orchestrating our calls. </span><span class="koboSpan" id="kobo.208.2">We need to inject our dependency like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.209.1">
private readonly IMediator _mediator;
  public AppointmentsController(IMediator mediator) =&gt;
    _mediator = mediator;</span></pre>
<p><span class="koboSpan" id="kobo.210.1">Once we have this dependency present, we can begin making our calls. </span><span class="koboSpan" id="kobo.210.2">What makes this solution so clean is that we do not need to worry about the business logic and specific handlers for anything. </span><span class="koboSpan" id="kobo.210.3">We need to only create a command-model object with the appropriate data and then send it using our mediator, which will then call the appropriate handler. </span><span class="koboSpan" id="kobo.210.4">The code for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.211.1">POST</span></strong><span class="koboSpan" id="kobo.212.1"> method is shown here:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.213.1">
[HttpPost]
public async Task&lt;ActionResult&gt; Post([FromBody]
  CreateAppointmentCommand createAppointmentCommand)
{
   await _mediator.Send(createAppointmentCommand);
   return StatusCode(201);
}</span></pre>
<p><span class="koboSpan" id="kobo.214.1">There are several ways to implement this section. </span><span class="koboSpan" id="kobo.214.2">Some alternatives include the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.215.1">Using </span><em class="italic"><span class="koboSpan" id="kobo.216.1">models</span></em><span class="koboSpan" id="kobo.217.1"> or </span><strong class="bold"><span class="koboSpan" id="kobo.218.1">Data Transfer Objects</span></strong><span class="koboSpan" id="kobo.219.1"> (or </span><strong class="bold"><span class="koboSpan" id="kobo.220.1">DTOs</span></strong><span class="koboSpan" id="kobo.221.1"> for </span><a id="_idIndexMarker231"/><span class="koboSpan" id="kobo.222.1">short) to accept data from the API </span><a id="_idIndexMarker232"/><span class="koboSpan" id="kobo.223.1">endpoint. </span><span class="koboSpan" id="kobo.223.2">This means that we will then transfer the data points from the incoming model object to our command model before sending, as illustrated here:</span><pre class="console"><span class="koboSpan" id="kobo.224.1">
[HttpPost]</span></pre><pre class="console"><span class="koboSpan" id="kobo.225.1">
public async Task&lt;ActionResult&gt; Post([FromBody]</span></pre><pre class="console"><span class="koboSpan" id="kobo.226.1">
  AppointmentDto appointment)</span></pre><pre class="console"><span class="koboSpan" id="kobo.227.1">
{</span></pre><pre class="console"><span class="koboSpan" id="kobo.228.1">
    var createAppointmentCommand = new</span></pre><pre class="console"><span class="koboSpan" id="kobo.229.1">
      CreateAppointmentCommand { /* Assign all values</span></pre><pre class="console"><span class="koboSpan" id="kobo.230.1">
        here*/}</span></pre><pre class="console"><span class="koboSpan" id="kobo.231.1">
   await _mediator.Send(createAppointmentCommand);</span></pre><pre class="console"><span class="koboSpan" id="kobo.232.1">
   return StatusCode(201);</span></pre><pre class="console"><span class="koboSpan" id="kobo.233.1">
}</span></pre></li>
<li><span class="koboSpan" id="kobo.234.1">Instead of defining all the data properties in the command model, we use the DTO as a property of the command model so that we can pass it along with the mediator request, as follows:</span><pre class="console"><span class="koboSpan" id="kobo.235.1">
// New Command Model with DTO property</span></pre><pre class="console"><span class="koboSpan" id="kobo.236.1">
  public record CreateAppointmentCommand</span></pre><pre class="console"><span class="koboSpan" id="kobo.237.1">
    (AppointmentDto Appointment) : IRequest&lt;string&gt;;</span></pre><pre class="console"><span class="koboSpan" id="kobo.238.1">
// New Post method</span></pre><pre class="console"><span class="koboSpan" id="kobo.239.1">
[HttpPost]</span></pre><pre class="console"><span class="koboSpan" id="kobo.240.1">
public async Task&lt;ActionResult&gt; Post([FromBody]</span></pre><pre class="console"><span class="koboSpan" id="kobo.241.1">
  AppointmentDto appointment)</span></pre><pre class="console"><span class="koboSpan" id="kobo.242.1">
{</span></pre><pre class="console"><span class="koboSpan" id="kobo.243.1">
    var createAppointmentCommand = new</span></pre><pre class="console"><span class="koboSpan" id="kobo.244.1">
      CreateAppointmentCommand { Appointment =</span></pre><pre class="console"><span class="koboSpan" id="kobo.245.1">
        appointment; }</span></pre><pre class="console"><span class="koboSpan" id="kobo.246.1">
   await _mediator.Send(createAppointmentCommand);</span></pre><pre class="console"><span class="koboSpan" id="kobo.247.1">
   return StatusCode(201);</span></pre><pre class="console"><span class="koboSpan" id="kobo.248.1">
}</span></pre></li>
</ul>
<p><span class="koboSpan" id="kobo.249.1">You can observe that each method of authoring the code amounts to the same thing, and that is we need to compose the appropriate model type with the appropriate values before sending it off to our mediator. </span><span class="koboSpan" id="kobo.249.2">The mediator would have already figured out which model matches which handler and will proceed to carry out its operation.</span></p>
<p><span class="koboSpan" id="kobo.250.1">Commands and </span><a id="_idIndexMarker233"/><span class="koboSpan" id="kobo.251.1">queries generally follow the same implementation. </span><span class="koboSpan" id="kobo.251.2">In the next section, we will look at implementing a query model/handler pair using our mediator and CQRS patterns.</span></p>
<h1 id="_idParaDest-83"><a id="_idTextAnchor082"/><span class="koboSpan" id="kobo.252.1">Implementing a query</span></h1>
<p><span class="koboSpan" id="kobo.253.1">A query is expected to search for data and return a result. </span><span class="koboSpan" id="kobo.253.2">This search might be complicated, or it </span><a id="_idIndexMarker234"/><span class="koboSpan" id="kobo.254.1">might be simple enough. </span><span class="koboSpan" id="kobo.254.2">The fact, though, is that we implement this pattern as an easy way to segregate the query logic from the originator of the request (such as the controller) and from the command logic. </span><span class="koboSpan" id="kobo.254.3">This type of separation increases a team’s ability to maintain either side of the application without stepping on each other’s toes, so to speak. </span><span class="koboSpan" id="kobo.254.4">We will similarly use the Mediator pattern to govern how we carry out these operations, and we will need a query model and a handler.</span></p>
<h2 id="_idParaDest-84"><a id="_idTextAnchor083"/><span class="koboSpan" id="kobo.255.1">Creating a query model</span></h2>
<p><span class="koboSpan" id="kobo.256.1">Our model is simple </span><a id="_idIndexMarker235"/><span class="koboSpan" id="kobo.257.1">enough as we can leave it empty or include properties that will play a part in the process to be carried out in the handler. </span><span class="koboSpan" id="kobo.257.2">We inherit </span><strong class="source-inline"><span class="koboSpan" id="kobo.258.1">IRequest&lt;&gt;</span></strong><span class="koboSpan" id="kobo.259.1">, which defines a return type. </span><span class="koboSpan" id="kobo.259.2">I would go out on a limb and say that a return type is necessary, considering that this is a query.</span></p>
<p><span class="koboSpan" id="kobo.260.1">Let us look at two examples of queries, one that will retrieve all the appointments in the database and another that will retrieve only by ID. </span><span class="koboSpan" id="kobo.260.2">We can define </span><strong class="source-inline"><span class="koboSpan" id="kobo.261.1">GetAppointmentsQuery.cs</span></strong><span class="koboSpan" id="kobo.262.1"> and</span><strong class="source-inline"><span class="koboSpan" id="kobo.263.1"> GetAppointmentByIdQuery.cs</span></strong><span class="koboSpan" id="kobo.264.1"> like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.265.1">
public record GetAppointmentsQuery(): Irequest
  &lt;List&lt;Appointment&gt;&gt;;
public record GetAppointmentByIdQuery(string Id):
  IRequest&lt;AppointmentDetailsDto&gt;;</span></pre>
<p><span class="koboSpan" id="kobo.266.1">Just take note of the fact that either query model is specific to what it needs to represent. </span><span class="koboSpan" id="kobo.266.2">The </span><strong class="source-inline"><span class="koboSpan" id="kobo.267.1">GetAppointmentsQuery</span></strong><span class="koboSpan" id="kobo.268.1"> model doesn’t need any properties since it is just going to be used as an outline for the handler to make an association. </span><strong class="source-inline"><span class="koboSpan" id="kobo.269.1">GetAppointmentByIdQuery</span></strong><span class="koboSpan" id="kobo.270.1"> has an </span><strong class="source-inline"><span class="koboSpan" id="kobo.271.1">Id</span></strong><span class="koboSpan" id="kobo.272.1"> property for the obvious reason that the ID is going to be needed for the handler to correctly execute the task at hand. </span><span class="koboSpan" id="kobo.272.2">The difference in return types is also a crucial point to note as that sets the tone for what the handler will be able to return.</span></p>
<p><span class="koboSpan" id="kobo.273.1">We need to ensure that we craft our query models specifically for the type of data that we are expecting to retrieve from the matching handler. </span><span class="koboSpan" id="kobo.273.2">Now, let us look at implementing these handlers.</span></p>
<h2 id="_idParaDest-85"><a id="_idTextAnchor084"/><span class="koboSpan" id="kobo.274.1">Creating a query handler</span></h2>
<p><span class="koboSpan" id="kobo.275.1">Our query handlers will</span><a id="_idIndexMarker236"/><span class="koboSpan" id="kobo.276.1"> execute the expected queries and return the data as defined by </span><strong class="source-inline"><span class="koboSpan" id="kobo.277.1">IRequest&lt;&gt;</span></strong><span class="koboSpan" id="kobo.278.1">. </span><span class="koboSpan" id="kobo.278.2">As previously outlined, the ideal usage of this pattern will see us using a separate data store where the data being queried is already optimized for return. </span><span class="koboSpan" id="kobo.278.3">This would make our query operation efficient and reduce the need for data transformation and sanitization.</span></p>
<p><span class="koboSpan" id="kobo.279.1">In our example, we are not that fortunate to have a separate data store, so we will use the same repository to query the transactional data store. </span><span class="koboSpan" id="kobo.279.2">Our handler for our query to get all appointments will be called </span><strong class="source-inline"><span class="koboSpan" id="kobo.280.1">GetAppointmentsHandler.cs</span></strong><span class="koboSpan" id="kobo.281.1"> and can be implemented like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.282.1">
public class GetAppointmentsHandler : IrequestHandler
  &lt;GetAppointmentsQuery, List&lt;Appointment&gt;&gt;
    {
        private readonly IAppointmentRepository _repo;
        public GetAppointmentsHandler
          (IAppointmentRepository repo) =&gt; _repo = repo;
        public async Task&lt;List&lt;Appointment&gt;&gt;
           Handle(GetAppointmentsQuery request,
             CancellationToken cancellationToken)
        {
            return await _repo.GetAll();
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.283.1">This handler’s definition is simple as we simply retrieve a list of appointments. </span><span class="koboSpan" id="kobo.283.2">When we need to get an appointment by ID, it would imply that we need the details of the appointment. </span><span class="koboSpan" id="kobo.283.3">This will call for a more complex query that might involve joins or, better yet, require synchronous API calls to get the details of related records. </span><span class="koboSpan" id="kobo.283.4">This is where the database design’s strong </span><a id="_idIndexMarker237"/><span class="koboSpan" id="kobo.284.1">points or flaws will come into play. </span><span class="koboSpan" id="kobo.284.2">If we were guided by our </span><strong class="bold"><span class="koboSpan" id="kobo.285.1">Domain-Driven Design</span></strong><span class="koboSpan" id="kobo.286.1"> (</span><strong class="bold"><span class="koboSpan" id="kobo.287.1">DDD</span></strong><span class="koboSpan" id="kobo.288.1">) principles, then we would have been sure to include some additional information about records from other databases in this one. </span><span class="koboSpan" id="kobo.288.2">Without getting into too many details about that point, we need to ensure that we retrieve enough data to populate a model of type </span><strong class="source-inline"><span class="koboSpan" id="kobo.289.1">AppointmentDetailsDto</span></strong><span class="koboSpan" id="kobo.290.1"> for return, like so:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.291.1">
public class GetAppointmentByIdHandler :
  IRequestHandler&lt;GetAppointmentByIdQuery,
    AppointmentDetailsDto&gt;
    {
        private readonly IAppointmentRepository _repo;
        public GetAppointmentByIdHandler
          (IAppointmentRepository repo)
        {
            _repo = repo;
        }
        public async Task&lt;AppointmentDetailsDto&gt;
          Handle(GetAppointmentByIdQuery request,
            CancellationToken cancellationToken)
        {
            // Carry out all query operations and convert
            the result to the expected return type
            return new AppointmentDetailsDto{ /* Fill model
              with appropriate values */ };
        }
    }</span></pre>
<p><span class="koboSpan" id="kobo.292.1">After we have gathered </span><a id="_idIndexMarker238"/><span class="koboSpan" id="kobo.293.1">the data needed for this particular scenario, we construct our </span><strong class="source-inline"><span class="koboSpan" id="kobo.294.1">return</span></strong><span class="koboSpan" id="kobo.295.1"> object and send it back to the original sender.</span></p>
<p><span class="koboSpan" id="kobo.296.1">Now, let us look at what the controller actions look like as they seek to complete the queries.</span></p>
<h2 id="_idParaDest-86"><a id="_idTextAnchor085"/><span class="koboSpan" id="kobo.297.1">Invoking a query</span></h2>
<p><span class="koboSpan" id="kobo.298.1">Using the same</span><a id="_idIndexMarker239"/><span class="koboSpan" id="kobo.299.1"> controller, we can assume that the </span><strong class="source-inline"><span class="koboSpan" id="kobo.300.1">IMediator</span></strong><span class="koboSpan" id="kobo.301.1"> dependency has already been injected and execute the following code:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.302.1">
[HttpGet]
public async Task&lt;ActionResult&lt;Appointment&gt;&gt; Get()
{
    var appointments = await _mediator.Send(new
      GetAppointmentsQuery());
            return Ok(appointments);
}
[HttpGet("{id}")]
public async Task&lt;ActionResult&lt;AppointmentDetailsDto&gt;&gt;
    Get(string id)
{
  var appointment = await _mediator.Send(new
    GetAppointmentByIdQuery(id));
            return Ok(appointment);
}</span></pre>
<p><span class="koboSpan" id="kobo.303.1">Our actions look similar. </span><span class="koboSpan" id="kobo.303.2">Each one is defined with the parameters it needs from a request. </span><span class="koboSpan" id="kobo.303.3">They then call the </span><strong class="source-inline"><span class="koboSpan" id="kobo.304.1">mediator</span></strong><span class="koboSpan" id="kobo.305.1"> object and new objects of the expected query model type. </span><span class="koboSpan" id="kobo.305.2">The mediator will orchestrate the call and route the request to the appropriate handler.</span></p>
<h1 id="_idParaDest-87"><a id="_idTextAnchor086"/><span class="koboSpan" id="kobo.306.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.307.1">There are several benefits that can be reaped from this approach to development. </span><span class="koboSpan" id="kobo.307.2">We have already outlined that project bloat is a part of the territory, but the level of consistency and structure that can be enforced and guaranteed is perhaps worth the additional effort.</span></p>
<p><span class="koboSpan" id="kobo.308.1">In this chapter, we explored the CQRS pattern and how we can employ it in our microservice application. </span><span class="koboSpan" id="kobo.308.2">We took time to assess the problems that we need to address, to bring real context to why we added this new level of complexity. </span><span class="koboSpan" id="kobo.308.3">We then looked at how we restructure our code to facilitate our handlers and request/command objects. </span><span class="koboSpan" id="kobo.308.4">We also looked at some design decisions that we can make in terms of our data stores for reading and writing operations.</span></p>
<p><span class="koboSpan" id="kobo.309.1">In our next chapter, we will explore Event Sourcing patterns that will tie into our CQRS pattern and help us to keep our data relevant throughout our application.</span></p>
</div>
</body></html>