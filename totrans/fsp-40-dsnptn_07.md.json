["```cs\nlet rec ``naive factorial`` = function \n| n when n = 0I -> 1I \n| _ as n -> n * ``naive factorial`` (n - 1I) \n\n```", "```cs ``naive factorial`` 1000 ```", "```cs ``naive factorial`` 10000 ```", "```cs ``naive factorial`` ```", "```cs ``naive factorial`` 0 ```", "```cs\nlet ``wise factorial`` n = \n  let rec factorial_tail_call acc = function   | n when n = 0I -> acc \n  | _ as n -> factorial_tail_call (acc * n) (n - 1I) \n  factorial_tail_call 1I n \n\n```", "```cs ``wise factorial`` ```", "```cs ``wise factorial`` ```", "```cs ``wise factorial`` ```", "```cs ``wise factorial`` ```", "```cs\nlet rec fname_a arguments = \n  < fname_a definition> \nand fname _b arguments = \n  < fname_b definition> \n........................... \n\n```", "```cs\n// Beware, does not work as expected! \nlet rec Even x = if x = 0 then true else Odd (x - 1) \nand Odd x = if x = 1 then true else Even (x - 1) \n\n```", "```cs\nlet rec primes =  \n  Seq.cache <| seq { yield 2; yield! Seq.unfold nextPrime 3 } \nand nextPrime n = \n  let next = n + if n%6 = 1 then 4 else 2 in \n  if isPrime n then Some(n, next) else nextPrime next \nand isPrime n = \n  f n >= 2 then \n    primes \n    |> Seq.tryFind (fun x -> n % x = 0 || x * x > n) \n    |> fun x -> x.Value * x.Value > n \n  else false \n\n```", "```cs\nlet problem010 () = \n  primes \n  |> Seq.takeWhile ((>) 2000000) \n  |> (Seq.map int64 >> Seq.sum) \n\n```", "```cs\nSeq.init (n + 1) bigint.op_Implicit |> Seq.skip 1 \n\n```", "```cs\nlet ``folding factorial (seq)`` n = \n  let fs = Seq.init (n + 1) bigint.op_Implicit |> Seq.skip 1 \n  use er = fs.GetEnumerator() \n  let mutable acc = 1I \n  while er.MoveNext() do \n    acc <- acc * er.Current \n  acc \n\n```", "```cs\nfold: ('State -> 'T -> 'State) -> 'State -> 'T seq -> 'State \n\n```", "```cs ``folding factorial (seq)`` ```", "```cs\nlet ``folding factorial (lib)`` n = \n  Seq.init (n + 1) bigint.op_Implicit \n  |> Seq.skip 1 \n  |> Seq.fold (*) 1I \n\n```", "```cs\n// Excerpt from seq.fs of FSharp.Core.Collections: \n[<CompiledName(\"Fold\")>] \nlet fold<'T,'State> f (x:'State) (source : seq<'T>)  =  \n  checkNonNull \"source\" source \n  use e = source.GetEnumerator()  \n  let f = OptimizedClosures.FSharpFunc<_,_,_>.Adapt(f) \n  let mutable state = x  \n  while e.MoveNext() do \n    state <- f.Invoke(state, e.Current) \n  state \n\n```", "```cs\n// Memoization (F# 4.0 is required) \nlet memoize f = \n  let mutable cache = Map.empty \n  fun x -> \n    match cache.TryFind(x) with \n    | Some res -> printfn \"returned memoized\";res \n    | None -> let res = f x in \n    cache <- cache.Add(x,res) \n    printfn \"memoized, then returned\"; res \n\n```", "```cs\nmemoize : f:('a -> 'b) -> ('a -> 'b) when 'a : comparison \n\n```", "```cs\nlet memoize' f = \n  let cache = System.Collections.Generic.Dictionary() \n  fun x -> \n    match cache.TryGetValue(x) with \n    | true,res -> printfn \"returned memoized\";res \n    | _ -> let res = f x \n    cache.Add(x,res) \n    printfn \"memoized, then returned\" \n    res \n\n```", "```cs\nmemoize' : f:('a -> 'b) -> ('a -> 'b) when 'a : equality \n\n```", "```cs\nlet disaster = memoize' (fun () -> 5) \n...... \ndisaster() \n\n```", "```cs\nSystem.ArgumentNullException: Value cannot be null \n\n```", "```cs\nlet rec binomial n k =  \n  if k = 0 || k = n then 1 \n  else \n    binomial (n - 1) k + binomial (n - 1) (k - 1) \n\n```", "```cs\nlet rec memoizedBinomial = \n  let memoize f = \n    let cache = System.Collections.Generic.Dictionary() \n    fun x -> \n    match cache.TryGetValue(x) with \n    | true,res -> res \n    | _ -> let res = f x \n    cache.Add(x,res) \n    res \n  memoize \n  (fun (n,k) -> \n    if k = 0 || k = n then 1 \n    else \n      memoizedBinomial (n - 1, k) + \n      memoizedBinomial (n - 1, k - 1)) \n\n```", "```cs\nlet name = lazy ( expression ) \n\n```", "```cs\nlet twoByTwo  = lazy (let r = 2*2 in \n  printfn \"Everybody knows that 2*2=%d\" r; r)  \ntwoByTwo.Force() \ntwoByTwo.Force() \n\n```", "```cs\nlet rec ``factorial (cps)`` cont = function \n  | z when z = 0I -> cont 1I \n  | n -> ``factorial (cps)`` (fun x -> cont(n * x)) (n - 1I)  \n\n```", "```cs ``factorial (cps)`` ```", "```cs ``factorial (cps)`` ```", "```cs ``factorial (cps)`` ```", "```cs ``I'm active pattern`` ```", "```cs(|``Another active pattern``|)```", "```cs\nlet (|Echo|) x = x \nlet checkEcho p =  \n  match p with \n  | Echo 42 -> \"42!\" \n  | Echo x -> sprintf \"%O is not good\" x \n\n```", "```cs\nlet (|``I'm active pattern``|) x = x + 2 \n\n```", "```cslet (|``I'm active pattern``|) x = x + 2```", "```cslet x = match 40 with ``I'm active pattern`` x -> x```", "```cslet (``I'm active pattern`` x) = 40```", "```cs ``I'm active pattern`` ```", "```cs\nlet hexCharSet = ['0'..'9'] @ ['a'..'f'] |> set in \nlet (|IsValidGuidCode|) (guidstr: string) = \n  let (|HasRightSize|) _ = guidstr.Length = 32 \n  let (|IsHex|) _ = (guidstr.ToLower() |> set) = hexCharSet \n  match () with (HasRightSize rightsize & IsHex hex)-> rightsize && hex  \n\n```", "```cs\ntype Processable = \n| FedexFile \n| OnTracFile \n| BrainTreeFile \nwith \n  override this.ToString() = match this with \n    | FedexFile -> \"Fedex\" \n    | OnTracFile -> \"OnTrac\" \n    | BrainTreeFile -> \"BrainTree\" \n\n```", "```cs\nlet BraintreeHdr = \"Transaction ID,Subscription ID,...\" \nlet FedexHdr = \"\"Bill to Account Number\";\"Invoice Date\";...\" \nlet OntracHdr = \"AccountNum,InvoiceNum,Reference,ShipDate,TotalCharge,...\" \n\n```", "```cs\nlet (|IsProcessable|_|) (stream: Stream) = \n  use streamReader = new StreamReader(stream) \n  let hdr = streamReader.ReadLine() \n  [(Processable.BrainTreeFile,BraintreeHdr); \n  (Processable.FedexFile,FedexHdr); \n  (Processable.OnTracFile,OntracHdr)] \n  |> List.tryFind (fun x -> (snd x) = hdr) \n  |> function \n  | None -> (if hdr.StartsWith(\"\"1\",\") then \n    Some (Processable.OnTracFile) else None) \n  | _ as zx -> Some (fst zx.Value) \n\n```", "```cs\nopen System \n\nlet (|Recent|Due|) (dt: DateTimeOffset) = \n  if DateTimeOffset.Now.AddDays(-3.0) <= dt then Recent \n  else Due \n\nlet isDue = function \n| Recent -> printfn \"don't do anything\" \n| Due  -> printfn \"time to pay this one\" \n\n```"]