- en: '4'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '4'
- en: Documentation with Swagger
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Swagger的文档
- en: In this chapter, we’ll look at documenting your project with Swagger. Human-readable
    documentation is critical in an API. It allows your clients to understand each
    endpoint and the potential responses quickly.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨使用Swagger对你的项目进行文档记录。在API中，可读性强的文档至关重要。它允许你的客户快速理解每个端点和可能的响应。
- en: We’ll ensure that our Swagger documentation adheres to the OpenAPI (formerly
    Swagger) Specification by utilizing XML and incorporating attributes within the
    code. You can learn more about OpenAPI at [https://swagger.io/docs/specification/about/](https://swagger.io/docs/specification/about/)
    .
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将通过使用XML并在代码中包含属性来确保我们的Swagger文档遵循OpenAPI（以前称为Swagger）规范。你可以在[https://swagger.io/docs/specification/about/](https://swagger.io/docs/specification/about/)了解更多关于OpenAPI的信息。
- en: Swagger needs an OpenAPI implementation, and in the case of .NET, Swashbuckle
    serves as the designated option.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger需要一个OpenAPI实现，在.NET的情况下，Swashbuckle是指定的选项。
- en: 'In this chapter, we will cover the following topics:'
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主题：
- en: What Swagger is
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger是什么
- en: How Swagger is used
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: Swagger的使用方法
- en: How to set up Swagger
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何设置Swagger
- en: How to pass parameters to Swagger
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 如何向Swagger传递参数
- en: Technical requirements
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: For this chapter, all you will need is Visual Studio. All of the features we’ll
    be using come with Visual Studio, or can be obtained for free through NuGet.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 对于本章，你只需要Visual Studio。我们将使用的所有功能都包含在Visual Studio中，或者可以通过NuGet免费获得。
- en: 'The code files for this book are available in the book’s GitHub repository
    : [https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter04](https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter04)'
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 本书的相关代码文件可在GitHub仓库中找到：[https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter04](https://github.com/PacktPublishing/Programming-APIs-with-C-Sharp-and-.NET/tree/main/Chapter04)
- en: Setting up the Swagger documentation
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 设置Swagger文档
- en: To install Swagger, open your solution and from the menu, select **Tools** |
    **NuGet Package Manager** | **Manage NuGet Packages for Solution** . Install the
    latest version of **Swashbuckle.AspNetCore** .
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 要安装Swagger，打开你的解决方案，从菜单中选择**工具** | **NuGet包管理器** | **管理解决方案的NuGet包**。安装**Swashbuckle.AspNetCore**的最新版本。
- en: 'Right-click on your project file and click on **Properties** . On the left
    of your screen, choose **Application** . On the right, choose **Console Application**
    , as shown in *Figure 4* *.1* :'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 右键单击你的项目文件，然后点击**属性**。在屏幕的左侧，选择**应用程序**。在右侧，选择**控制台应用程序**，如*图4.1*所示：
- en: '![Figure 4.1 – Installation part 1](img/B21988_04_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![图4.1 – 安装部分1](img/B21988_04_01.jpg)'
- en: Figure 4.1 – Installation part 1
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.1 – 安装部分1
- en: 'Under **Build** , choose **Output** and scroll down to **Documentation file**
    . Check the **Generate a file containing API documentation** box, as shown in
    *Figure 4* *.2* :'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 在**生成**下，选择**输出**并滚动到**文档文件**。检查*图4.2*中显示的**生成包含API文档的文件**框：
- en: '![Figure 4.2 – Setting up Swagger output](img/B21988_04_02.jpg)'
  id: totrans-19
  prefs: []
  type: TYPE_IMG
  zh: '![图4.2 – 设置Swagger输出](img/B21988_04_02.jpg)'
- en: Figure 4.2 – Setting up Swagger output
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.2 – 设置Swagger输出
- en: Note
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In *Figure 4* *.2* , **Generate a file containing API documentation** is checked.
    The file that is generated can be imported into other applications, such as Postman,
    for an integrated documentation and testing experience.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在*图4.2*中，**生成包含API文档的文件**被选中。生成的文件可以导入到其他应用程序中，例如Postman，以获得集成文档和测试体验。
- en: 'Open **Program.cs** (typically the last file in Solution Explorer) and add
    the Swagger generator to the services collection:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 打开**Program.cs**（通常是解决方案资源管理器中的最后一个文件）并将Swagger生成器添加到服务集合中：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Save everything. That’s it. This is only done once. You have now set up Swagger
    documentation. In fact, you’ve already added the description, name, and contact
    information. The result is shown in *Figure 4* *.3* . This is what you will see
    when you start your program and Swagger opens a browser window to display its
    interface:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 保存所有内容。就是这样。这只需要做一次。你现在已经设置了Swagger文档。实际上，你已经添加了描述、名称和联系信息。结果如*图4.3*所示。这就是当你启动程序且Swagger打开浏览器窗口以显示其界面时你会看到的内容：
- en: '![Figure 4.3 – Top of Swagger documentation](img/B21988_04_03.jpg)'
  id: totrans-26
  prefs: []
  type: TYPE_IMG
  zh: '![图4.3 – Swagger文档的顶部](img/B21988_04_03.jpg)'
- en: Figure 4.3 – Top of Swagger documentation
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 图4.3 – Swagger文档的顶部
- en: Notice that on this page, the website and email are live links and the text
    **Create documentation for Cars** is what you put in the description in the preceding
    code.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在这个页面上，网站和电子邮件是活链接，而文本**为汽车创建文档**是你之前代码中描述的内容。
- en: Swagger for the controller
  id: totrans-29
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: Swagger 控制器
- en: 'Swagger documentation is implemented using XML comments. XML comments are preceded
    by three slash marks. Here’s an example:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 文档是通过 XML 注释实现的。XML 注释由三个斜杠标记开头。以下是一个示例：
- en: '[PRE1]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'XML comments are paired tags, such as the following:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: XML 注释是成对标签，如下所示：
- en: '[PRE2]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Let’s start with the controller of our Cars application. We’re going to put
    Swagger documentation above every method in the controller.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们从 Cars 应用程序的控制器开始。我们将在控制器中的每个方法上方放置 Swagger 文档。
- en: 'The first comment we’ll add is the summary:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将添加的第一个注释是摘要：
- en: '[PRE3]'
  id: totrans-36
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'This comment will appear next to the route for the **GET** button, as shown
    in *Figure 4* *.4* :'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 这条注释将出现在**GET**按钮的旁边，如图 *图 4.4* 所示：
- en: '![Figure 4.4 – Display the summary](img/B21988_04_04.jpg)'
  id: totrans-38
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.4 – 显示摘要](img/B21988_04_04.jpg)'
- en: Figure 4.4 – Display the summary
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.4 – 显示摘要
- en: Before we go any further, let’s look at what we get from Swagger without writing
    any additional code.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们继续前进之前，让我们看看在不编写任何额外代码的情况下，我们从 Swagger 中获得了什么。
- en: Swagger out of the box
  id: totrans-41
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Swagger开箱即用
- en: Note that Swagger will come up automatically just after you start your application.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 注意 Swagger 将在启动应用程序后自动出现。
- en: 'To see the auto-generated documentation, click on the arrow on the far right
    as circled in *Figure 4* *.4* . Swagger opens the details of the **Get** command,
    as shown in *Figure 4* *.5* :'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 要查看自动生成的文档，请点击*图 4.4* 中圆圈所示的右上角的箭头。Swagger 打开 **Get** 命令的详细信息，如图 *图 4.5* 所示：
- en: '![Figure 4.5 – Swagger out of the box](img/B21988_04_05.jpg)'
  id: totrans-44
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.5 – Swagger开箱即用](img/B21988_04_05.jpg)'
- en: Figure 4.5 – Swagger out of the box
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.5 – Swagger开箱即用
- en: 'This is a little hard to see, so let’s zoom in on a couple of important parts.
    In the upper-left corner is an area for all the parameters you’ll be sending in
    for the **GetAll** command. We are sending in **returnDeletedRecords** with a
    default value of **false** . *Figure 4* *.6* shows how Swagger depicts this:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 这有点难以看清，所以让我们放大几个重要部分。在左上角是一个区域，用于发送给 **GetAll** 命令的所有参数。我们发送了 **returnDeletedRecords**，默认值为
    **false**。*图 4.6* 显示了 Swagger 如何描述这一点：
- en: '![Figure 4.6 – Parameters](img/B21988_04_06.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.6 – 参数](img/B21988_04_06.jpg)'
- en: Figure 4.6 – Parameters
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.6 – 参数
- en: Notice the dropdown. It lets you try out both possible values ( **false** and
    **true** ).
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 注意下拉菜单。它允许你尝试两种可能的值（**false** 和 **true**）。
- en: 'Next, on the left side are the code and description for the potential responses
    from the server. *Figure 4* *.7* shows that the first potential response is **200:
    Success** :'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: '接下来，在左侧是服务器潜在响应的代码和描述。*图 4.7* 显示第一个潜在响应是 **200: 成功**：'
- en: '![Figure 4.7 – Success](img/B21988_04_07.jpg)'
  id: totrans-51
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.7 – 成功](img/B21988_04_07.jpg)'
- en: Figure 4.7 – Success
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.7 – 成功
- en: 'Beneath the first response code is the schema that tells you what properties
    there are and what their type is, as shown in *Figure 4* *.8* :'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 在第一个响应代码下方是架构，它告诉你有哪些属性以及它们的类型，如图 *图 4.8* 所示：
- en: '![Figure 4.8 – Schema](img/B21988_04_08.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.8 – 架构](img/B21988_04_08.jpg)'
- en: Figure 4.8 – Schema
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.8 – 架构
- en: We are all set to see the effects of our comments. Let’s take a look at what
    happens when we start the application and Swagger comes up.
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经准备好查看我们注释的效果。让我们看看启动应用程序并启动 Swagger 时会发生什么。
- en: Running your API in Swagger
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 Swagger 中运行您的 API
- en: 'Most importantly, in the upper-right corner is a **Try It Out** button. Clicking
    on this button puts Swagger into interactive mode, and allows you to try out your
    code. When that button is clicked, two other buttons appear: **Execute** and **Clear**
    . Pressing **Execute** causes the code to run and in our case returns the list
    of cars, along with some other metadata. Let’s zero in on that ( **Clear** removes
    the results so that you can try again).'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 最重要的是，在右上角有一个 **尝试一下** 按钮。点击此按钮将 Swagger 切换到交互模式，并允许你尝试你的代码。当点击此按钮时，将出现两个其他按钮：**执行**
    和 **清除**。按下 **执行** 将导致代码运行，在我们的情况下返回汽车列表和一些其他元数据。让我们专注于这一点（**清除**将删除结果，以便你可以再次尝试）。
- en: 'The first thing we see is marked as **Curl** , as shown in *Figure 4* *.9*
    :'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 我们看到的第一件事被标记为 **Curl**，如图 *图 4.9* 所示：
- en: '![Figure 4.9 – Every Swagger page displays the curl for the endpoint](img/B21988_04_09.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.9 – 每个Swagger页面都显示端点的curl](img/B21988_04_09.jpg)'
- en: Figure 4.9 – Every Swagger page displays the curl for the endpoint
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.9 – 每个Swagger页面都显示端点的curl
- en: According to Wikipedia, “ *Curl combines text markup (as in HTML), scripting
    (as in JavaScript), and heavy-duty computing (as in Java, C#, or C++) within one
    unified framework* ”. We will be ignoring Curl in this book.
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 根据维基百科，“ *Curl 结合了文本标记（如 HTML）、脚本（如 JavaScript）和强大的计算（如 Java、C# 或 C++）在一个统一的框架中*
    ”。在这本书中，我们将忽略 Curl。
- en: 'Below that, we see the request URL that we submitted to the server, as shown
    in *Figure 4* *.10* :'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面，我们看到我们提交给服务器的请求 URL，如图 *图 4.10* 所示：
- en: '![Figure 4.10 – Request URL as displayed in Swagger](img/B21988_04_10.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.10 – Swagger 中显示的请求 URL](img/B21988_04_10.jpg)'
- en: Figure 4.10 – Request URL as displayed in Swagger
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.10 – Swagger 中显示的请求 URL
- en: Notice that we are working with port **7025** (yours may differ) on localhost
    and that we pass our parameter ( **returnDeletedRecords=false** ) as we would
    with any HTML.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 注意我们正在使用本地主机上的端口 **7025**（你的可能不同）工作，并且我们像任何 HTML 一样传递我们的参数（**returnDeletedRecords=false**）。
- en: 'Next comes the most important server response: the response body, as shown
    in *Figure 4* *.11* :'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来是最重要的服务器响应：响应体，如图 *图 4.11* 所示：
- en: '![Figure 4.11 – Server response](img/B21988_04_11.jpg)'
  id: totrans-68
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.11 – 服务器响应](img/B21988_04_11.jpg)'
- en: Figure 4.11 – Server response
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.11 – 服务器响应
- en: 'Finally, the schema of the response object is displayed, as shown in *Figure
    4* *.12* :'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，响应对象的模式显示出来，如图 *图 4.12* 所示：
- en: '![Figure 4.12 – Response schema](img/B21988_04_12.jpg)'
  id: totrans-71
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.12 – 响应模式](img/B21988_04_12.jpg)'
- en: Figure 4.12 – Response schema
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.12 – 响应模式
- en: Swagger is terrific for documentation, but somewhat limited as a way to test
    your application. As we’ll see, Postman is a much more powerful application for
    testing.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: Swagger 对于文档来说很棒，但在测试你的应用程序方面有些局限。正如我们将看到的，Postman 是一个更强大的测试应用程序。
- en: param tag
  id: totrans-74
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: param 标签
- en: 'If your verb has parameters, you can document them in the Swagger attributes
    using the **param** keyword. For example, in our case, we want to document the
    **returnDeletedRecords** parameter. We can do so like this:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你的动词有参数，你可以使用 **param** 关键字在 Swagger 属性中记录它们。例如，在我们的案例中，我们想要记录 **returnDeletedRecords**
    参数。我们可以这样做：
- en: '[PRE4]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The result is that the parameter is documented in Swagger, as shown in *Figure
    4* *.13* :'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是参数在 Swagger 中得到记录，如图 *图 4.13* 所示：
- en: '![Figure 4.13 – Documenting the parameters](img/B21988_04_13.jpg)'
  id: totrans-78
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.13 – 记录参数](img/B21988_04_13.jpg)'
- en: Figure 4.13 – Documenting the parameters
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.13 – 记录参数
- en: Response codes
  id: totrans-80
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 响应代码
- en: 'You can (and should) document all the possible response codes and what they
    indicate:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以（并且应该）记录所有可能的响应代码及其指示：
- en: '[PRE5]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The result is that the return codes are documented in Swagger, as shown in
    *Figure 4* *.14* :'
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 结果是返回代码在 Swagger 中得到记录，如图 *图 4.14* 所示：
- en: '![Figure 4.14 – Documenting the return codes](img/B21988_04_14.jpg)'
  id: totrans-84
  prefs: []
  type: TYPE_IMG
  zh: '![图 4.14 – 记录返回代码](img/B21988_04_14.jpg)'
- en: Figure 4.14 – Documenting the return codes
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 图 4.14 – 记录返回代码
- en: While this all takes a bit of effort, it becomes routine and is a best practice.
    It also makes the lives of your clients far easier.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然这需要一些努力，但它变成了常规操作，是最佳实践。这也使你的客户的生活变得更加容易。
- en: Summary
  id: totrans-87
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned how to set up Swashbuckle to enable Swagger. Swagger
    provides extensive documentation of your API, allowing (human) clients to learn
    about each endpoint and what it is for. In addition, you can also document each
    parameter and the potential error codes.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了如何设置 Swashbuckle 以启用 Swagger。Swagger 提供了您 API 的详细文档，允许（人类）客户端了解每个端点及其用途。此外，您还可以记录每个参数和潜在的错误代码。
- en: In the next chapter, you’ll see how we can validate endpoint requests on the
    way in – preventing wasted resources and protecting you from various attacks against
    your system.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将看到我们如何可以在请求过程中验证端点请求——防止资源浪费并保护你免受针对你系统的各种攻击。
- en: You try it
  id: totrans-90
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 你试试看
- en: Install Swagger and create the documentation for the **Insert** endpoint in
    the **Car** controller. Run Swagger to ensure that all your documentation is displayed
    properly.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 安装 Swagger 并为 **Car** 控制器中的 **Insert** 端点创建文档。运行 Swagger 以确保所有文档都正确显示。
