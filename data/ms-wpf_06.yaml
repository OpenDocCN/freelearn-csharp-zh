- en: Adapting the Built-In Controls
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 适配内置控件
- en: The .NET Framework comes with a plethora of built-in controls that cover most
    real-world scenarios. And when we need something slightly different, we have seen
    that we can utilize the WPF styling and/or templating systems to adapt them to
    our requirements. However, there are also further ways of adjusting the built-in
    controls to suit our needs.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 框架附带了许多内置控件，涵盖了大多数现实世界场景。当我们需要稍微不同一点的东西时，我们已经看到我们可以利用 WPF 样式化和/或模板化系统来调整它们以满足我们的需求。然而，还有其他方法可以调整内置控件以适应我们的需求。
- en: Each .NET control has a number of methods, each named with the prefix `On`,
    for example, `OnInitialized`, or `OnApplyTemplate`. These are protected methods,
    that can be overridden in any custom class that extends a .NET control. They are
    called at certain points in the control's lifetime and enable us to change the
    default behavior of each control.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 .NET 控件都有一些方法，每个方法都以前缀 `On` 命名，例如 `OnInitialized` 或 `OnApplyTemplate`。这些是受保护的方法，可以在扩展
    .NET 控件的任何自定义类中重写。它们在控件生命周期的特定点被调用，使我们能够改变每个控件的默认行为。
- en: They enable us to do things as simple as starting a process as soon as a control
    has been initialized, or accessing a named control from a custom `ControlTemplate`,
    once it has been applied. But they can also be used to completely change the default
    behavior, or the look and feel of the control. In this chapter, we will investigate
    these methods and give examples of how they can be utilized to our advantage.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 它们使我们能够做到像在控件初始化后立即启动一个进程这样简单的事情，或者一旦应用了自定义的`ControlTemplate`，就可以访问一个命名的控件。但它们也可以用来完全改变控件的默认行为或外观。在本章中，我们将研究这些方法，并给出如何利用它们为我们带来好处的示例。
- en: We will then examine further ways of customizing the built-in controls, by adjusting
    their default `ControlTemplate` and leveraging new uses from them, while maintaining
    or extending their existing functionality. In this chapter, we consider the built-in
    controls merely as a starting point for our requirements, and learn how to build
    upon them, keeping what we need and changing what we don't.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将进一步探讨自定义内置控件的方法，通过调整它们的默认`ControlTemplate`并利用它们的新用途，同时保持或扩展它们现有的功能。在本章中，我们将内置控件仅视为我们需求的一个起点，并学习如何在此基础上构建，保留所需的部分并更改不需要的部分。
- en: Inspecting protected methods
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 检查受保护的方法
- en: Each .NET control has several methods that enable developers that extend that
    control to either interact with, or alter its functionality. Note that these are
    not events, but protected methods, that are called at specific points throughout
    the control's lifetime. As we have already seen in *[Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    Using the Right Controls for the Job*, each .NET control extends a number of base
    classes, with each providing certain additional functionality.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 每个 .NET 控件都有几个方法，这些方法允许开发者扩展该控件，以便与之交互或更改其功能。请注意，这些不是事件，而是受保护的方法，在控件生命周期的特定点被调用。正如我们已经在*[第
    5 章](d5906090-c679-45d6-81cd-016d4337eb75.xhtml)，使用适合工作的控件*中看到的那样，每个 .NET 控件都扩展了多个基类，每个基类都提供了一些额外的功能。
- en: In a similar way, each base class also provides a number of these protected
    methods, that enable us to interact with the control internally. In this chapter,
    we will also show how we can create our own methods that enable developers that
    extend our own control classes to adapt or extend their functionality.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 以类似的方式，每个基类也提供了一些这些受保护的方法，使我们能够与控件内部进行交互。在本章中，我们还将展示如何创建我们自己的方法，使扩展我们自己的控件类的开发者能够调整或扩展其功能。
- en: 'Let''s first take a look at the protected methods of the `Window` class:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们先看看 `Window` 类的受保护方法：
- en: '[PRE0]'
  id: totrans-9
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: You may notice that they are all marked with either the virtual or override
    keywords, indicating that they can be overridden in extending classes. Apart from
    the `ArrangeOverride` and `MeasureOverride` methods, that we discovered in *[Chapter
    5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml), Using the Right Controls for the
    Job,* you should see that their names all start with the prefix `On`. This signifies
    that they are called upon some action having taken place.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会注意到，它们都带有虚拟或重写关键字，这表明它们可以在扩展类中被重写。除了我们在*[第 5 章](d5906090-c679-45d6-81cd-016d4337eb75.xhtml)，使用适合工作的控件*中发现的`ArrangeOverride`和`MeasureOverride`方法之外，你应该看到它们的名称都以前缀`On`开头。这表示它们在某个动作发生后会被调用。
- en: For example, the `OnActivated` method is called when the `Window` becomes the
    active window on the computer, while the `OnDeactivated` method is called when
    the `Window` loses focus. These methods are usually used together to pause and
    resume animations, or other processes, while the `Window` is not in focus.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，当 `Window` 成为计算机上的活动窗口时，会调用 `OnActivated` 方法，而当 `Window` 失去焦点时，会调用 `OnDeactivated`
    方法。这些方法通常一起使用，以暂停和恢复动画或其他过程，当 `Window` 失去焦点时。
- en: As expected, the `OnClosed` method is called upon the `Window` being closed
    and gives us a chance to dispose of any resources, or to save user preferences
    before closing the application. Conversely, The `OnClosing` method is called before
    the `Window` is closed and gives us a chance to cancel the close operation.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 如预期的那样，当 `Window` 被关闭时，会调用 `OnClosed` 方法，这给了我们处理任何资源或关闭应用程序前保存用户首选项的机会。相反，`OnClosing`
    方法在 `Window` 关闭之前被调用，这给了我们取消关闭操作的机会。
- en: 'Therefore, the `OnClosing` method would be a good method from which to display
    a dialog, asking the user to confirm the close operation. Let''s take a quick
    look at how we might achieve this in a class that extends the `Window` class:'
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`OnClosing` 方法是一个很好的方法，可以用来显示对话框，要求用户确认关闭操作。让我们快速看一下在一个扩展 `Window` 类的类中我们如何实现这一点：
- en: '[PRE1]'
  id: totrans-14
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: In this simple example, we override the `OnClosing` method and in it, we first
    call the base class method, to ensure that any base class routines are run as
    expected. We then display a message box to the user, asking them to confirm their
    close operation.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个简单的例子中，我们重写了 `OnClosing` 方法，并在其中首先调用基类方法，以确保任何基类例程按预期运行。然后我们向用户显示一个消息框，要求他们确认他们的关闭操作。
- en: With the resulting value attained from the user via the message box buttons,
    we set the `Cancel` property of the `CancelEventArgs` object that is passed into
    the method. If the returned value is `Cancel`, the `Cancel` property is set to
    `true` and the close operation is canceled, otherwise, it is set to `false` and
    the application is closed.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消息框按钮从用户那里获得的结果值，我们设置传入方法的 `CancelEventArgs` 对象的 `Cancel` 属性。如果返回值是 `Cancel`，则将
    `Cancel` 属性设置为 `true` 并取消关闭操作，否则将其设置为 `false` 并关闭应用程序。
- en: Returning to the `Window` class now, we see the `OnLocationChanged` method,
    which is called whenever the `Window` is moved or resized in a manner that moves
    its top left corner. We could use this method to save the last position of the
    `Window`, so that it could be returned there the next time the user opened their
    application. However, this operation is more typically performed upon the user
    closing the application.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回到 `Window` 类，我们看到 `OnLocationChanged` 方法，该方法在 `Window` 被移动或调整大小，从而改变其左上角位置时被调用。我们可以使用这个方法来保存
    `Window` 的最后位置，以便用户下次打开应用程序时能够返回到那里。然而，这种操作通常是在用户关闭应用程序时执行的。
- en: The `OnSourceInitialized` method is called after the window source is created,
    but before it is shown and the `OnStateChanged` method is called when the `WindowState`
    property is changed. So you see, these methods provide us with opportunities to
    perform actions at specific points throughout each control's lifetime.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: '`OnSourceInitialized` 方法在窗口源创建后、显示前被调用，而当 `WindowState` 属性改变时，会调用 `OnStateChanged`
    方法。所以你看，这些方法为我们提供了在每个控件生命周期中特定点执行操作的机会。'
- en: Each base class adds its own collection of these protected methods for us to
    take advantage of, and ones of interest are overridden in the extending classes.
    Looking at the `Window` class declaration, we see that it extends the `ContentControl`
    class. Notice that its `OnContentChanged` method is marked with the `override`
    keyword.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 每个基类都为我们添加了自己的受保护方法集合，我们可以在扩展类中重写这些方法。查看 `Window` 类的声明，我们看到它扩展了 `ContentControl`
    类。注意，它的 `OnContentChanged` 方法被标记为 `override` 关键字。
- en: 'This is because this method, which is actually declared in the `ContentControl`
    class, has been overridden in the `Window` class so that it could add its own
    code after the base class functionality has been executed. Let''s have a look
    at the source code for this method from the `Window` class. The comments in the
    source code have been removed for brevity:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为这个方法实际上是在 `ContentControl` 类中声明的，但在 `Window` 类中被重写，以便在基类功能执行后添加自己的代码。让我们快速看一下
    `Window` 类中这个方法的源代码。为了简洁，源代码中的注释已被删除：
- en: '[PRE2]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The method starts by calling the base class version of the method, which is
    always a good practice unless we want to stop the existing functionality from
    being performed. Next, it calls the `SetIWindowService` method, which just sets
    the `Window` object to the `IWindowServiceProperty` Dependency Property, and then
    it checks if the `Window` has passed the loading stage or not.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 方法首先调用基类版本的方法，这通常是一个好习惯，除非我们不想停止现有功能的执行。接下来，它调用 `SetIWindowService` 方法，该方法只是将
    `Window` 对象设置为 `IWindowServiceProperty` 依赖属性，然后它检查 `Window` 是否已经通过了加载阶段。
- en: If it has, then it calls the `PostContentRendered` method, which basically invokes
    the `OnContentRendered` method using the `Dispatcher` object. Otherwise, if the
    `_postContentRenderedFromLoadedHandler` variable is `false`, it attaches an event
    handler to the `Loaded` event and sets the variable to `true`, to ensure that
    it is not attached more than once.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 如果已经通过，那么它将调用 `PostContentRendered` 方法，该方法基本上使用 `Dispatcher` 对象调用 `OnContentRendered`
    方法。否则，如果 `_postContentRenderedFromLoadedHandler` 变量是 `false`，它将事件处理程序附加到 `Loaded`
    事件并将变量设置为 `true`，以确保不会附加多次。
- en: 'Returning to our investigation now, we see that the `Window` class adds protected
    methods relating to the `Window` and the `ContentControl` class adds protected
    methods relating to the content of the control. Let''s see the protected methods
    of the `ContentControl` class now:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们的调查，我们看到 `Window` 类添加了与 `Window` 相关的受保护方法，而 `ContentControl` 类添加了与控件内容相关的受保护方法。现在让我们看看
    `ContentControl` 类的受保护方法：
- en: '[PRE3]'
  id: totrans-25
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Apart from the first two methods, which can be used to add a specified object
    or text string to the `ContentControl` element, the remaining four methods are
    all called in response to a change in the content, or the format of the content
    of the control.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 除了前两个方法，可以用来向 `ContentControl` 元素添加指定的对象或文本字符串外，其余四个方法都是在内容或控件内容格式发生变化时被调用。
- en: 'Moving on now, the `ContentControl` class extends the `Control` class, which
    introduces the concept of the `ControlTemplate`. As such, it provides a protected
    `OnTemplateChanged` method, which is called when the `ControlTemplate` value is
    changed:'
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 现在继续，`ContentControl` 类扩展了 `Control` 类，它引入了 `ControlTemplate` 的概念。因此，它提供了一个受保护的
    `OnTemplateChanged` 方法，当 `ControlTemplate` 值改变时被调用：
- en: '[PRE4]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'The `Control` class extends the `FrameworkElement` class, which provides framework-level
    methods and events. These include a mouse, keyboard, stylus, touch, and focus-related
    protected methods, along with several others:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: '`Control` 类扩展了 `FrameworkElement` 类，它提供了框架级别的 方法和事件。这些包括鼠标、键盘、笔、触摸和焦点相关的受保护方法，以及一些其他方法：'
- en: '[PRE5]'
  id: totrans-30
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: Perhaps by now you will have noticed that many of these method names relate
    closely to the names of events raised by each class. In fact, there is a .NET
    Framework programming guideline for having protected virtual methods that raise
    events, to allow derived classes to override the event invocation behavior and
    we'll see an example of this later in this chapter.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 可能到现在你已经注意到，许多这些方法名称与每个类引发的事件名称密切相关。事实上，有一个 .NET 框架编程指南，用于具有引发事件的受保护虚拟方法，以允许派生类覆盖事件调用行为，我们将在本章后面看到这个示例。
- en: When overriding these methods, we are therefore required to call the base class
    method in order to raise the corresponding event. When in doubt, it's usually
    best to call the base class version of the method to ensure that default functionality
    is not lost. However, it's good practice to view the base class method source
    code on the [www.referencesource.microsoft.com](http://www.referencesource.microsoft.com)
    website, to check if we need to call it or not.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，在重写这些方法时，我们需要调用基类方法来引发相应的事件。如果有疑问，通常最好调用基类方法版本，以确保不会丢失默认功能。然而，查看基类方法源代码是一个好习惯，可以在
    [www.referencesource.microsoft.com](http://www.referencesource.microsoft.com)
    网站上查看，以检查我们是否需要调用它。
- en: You may be wondering what the difference between handling the events and overriding
    the related protected methods is and there are a few answers to this, depending
    upon the method in question. The first thing to point out is that in order to
    override a protected method, we need to declare a subclass of the class that declares
    the method.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想知道处理事件和重写相关受保护方法之间的区别，这取决于所讨论的方法。首先要注意的是，为了重写受保护方法，我们需要声明一个声明该方法的类的子类。
- en: '*So, assuming that we already have a class that extends a base class, what
    are the differences?* For some methods, such as the `OnClosing` method that we
    explored, there is little difference. We could implement the same functionality
    in an event handler that is attached to the `Closing` event, although without
    the call to the base class method. In fact, this is the only real difference.'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '*所以，假设我们已经有了一个扩展基类的类，它们之间有什么区别呢？* 对于一些方法，例如我们探讨的 `OnClosing` 方法，差别很小。我们可以在附加到
    `Closing` 事件的处理器中实现相同的功能，尽管没有调用基类方法。实际上，这是唯一的真正区别。'
- en: When overriding the `OnClosing` method, we are in control of when or if the
    base class method is called. When handling the event, we have no control over
    this. So, if we need to perform some action before the base class routine is executed
    or if we want to stop it from executing, then we will need to override the `OnClosing`
    method.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当重写 `OnClosing` 方法时，我们可以控制基类方法何时或是否被调用。在处理事件时，我们无法控制这一点。因此，如果我们需要在基类例程执行之前执行某些操作，或者我们想要阻止其执行，那么我们就需要重写
    `OnClosing` 方法。
- en: So, the appearance of the `OnClosing` method is there, purely for convenience,
    for us to be able to alter the default behavior of the `Closing` event. Other
    methods, however, such as the `OnContextMenuClosing` method, introduce a way for
    us to perform class-wide handling for the related events.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，`OnClosing` 方法的出现纯粹是为了方便，让我们能够改变 `Closing` 事件的默认行为。然而，其他方法，例如 `OnContextMenuClosing`
    方法，为我们提供了一种进行类级处理相关事件的方式。
- en: Sometimes though, we have no alternative to overriding these protected methods.
    Typically, these types of methods do not start with the prefix `On` and do not
    relate to any event. Occasionally, to perform a particular operation, we may need
    to extend a class, just so that we can provide a new implementation for one of
    these methods.
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，我们别无选择，只能重写这些受保护的成员方法。通常，这些类型的方法不以 `On` 前缀开头，也不与任何事件相关。偶尔，为了执行特定的操作，我们可能需要扩展一个类，以便我们可以为这些方法之一提供新的实现。
- en: Let's look at an example using the `GetLayoutClip` method from the `FrameworkElement`
    class that we just saw.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看一个例子，使用我们刚才看到的 `FrameworkElement` 类的 `GetLayoutClip` 方法。
- en: Clipping the layout
  id: totrans-39
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 布局剪辑
- en: By default, the `TextBlock` class clips its textual content at its bounding
    rectangle, so that text does not leak out of it. Clipping is the process of cutting
    off a portion of the visible output of a control. *But what about if we want the
    text to extend its bounds?*
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 默认情况下，`TextBlock` 类会在其边界矩形内剪辑其文本内容，这样文本就不会从其中溢出。剪辑是剪切掉控件可见输出一部分的过程。*但是如果我们想让文本扩展其边界呢？*
- en: There is a property named `Clip`, that we typically use to adjust the visible
    portion of controls. However, this can only reduce what is already visible. It
    cannot increase the rendering space available to the control. Before we continue
    with our example, let's take a short detour to investigate this property.
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 有一个名为 `Clip` 的属性，我们通常用它来调整控件的可见部分。然而，这只能减少已经可见的部分。它不能增加控件可用的渲染空间。在我们继续我们的例子之前，让我们短暂地偏离一下，来调查这个属性。
- en: 'The `Clip` property, which is defined in the `UIElement` class, takes a `Geometry`
    object as its value. The object that we pass it can be created from any of the
    classes that extend the `Geometry` class, including the `CombinedGeometry` class.
    Therefore, the clipped object can be made into any shape. Let''s view a simple
    example:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 定义在 `UIElement` 类中的 `Clip` 属性接受一个 `Geometry` 对象作为其值。我们可以从扩展 `Geometry` 类的任何类中创建传递给它的对象，包括
    `CombinedGeometry` 类。因此，剪辑对象可以被制成任何形状。让我们查看一个简单的例子：
- en: '[PRE6]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Here, we use an `EllipseGeometry` object to make a `Rectangle` element appear
    as a small bullet shape. It works by displaying all of the image pixels from the
    `Rectangle` element that lies within the oval boundary of the `EllipseGeometry`
    object and hiding all those that lie outside the boundary. Let''s take a look
    at the visual output of this code:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们使用一个 `EllipseGeometry` 对象来使 `Rectangle` 元素呈现出一个小子弹形状。这是通过显示 `EllipseGeometry`
    对象椭圆边界内的 `Rectangle` 元素的所有图像像素，并隐藏所有位于边界之外的那些像素来实现的。让我们看看这段代码的视觉输出：
- en: '![](img/9b3b1ba2-8602-4dae-9312-033e7c73e078.png)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9b3b1ba2-8602-4dae-9312-033e7c73e078.png)'
- en: Returning to our previous example, the `TextBlock` class also clips its content
    in a similar way, but with a rectangle the size of the control, instead of an
    off-centered oval. Rather than using the `Clip` property, which provides the user
    with the same ability to clip the control as the other controls offer, it uses
    a protected method to ask for the `Geometry` object to use in the clipping process.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 回到我们之前的示例，`TextBlock`类也会以类似的方式剪辑其内容，但使用的是控件大小的矩形，而不是偏离中心的椭圆形。它不是使用提供用户与其它控件相同剪辑能力的`Clip`属性，而是使用一个受保护的方法来请求用于剪辑过程的`Geometry`对象。
- en: We could indeed return any geometric shape from this method, but it would not
    have the same visual effect as passing the shape to the `Clip` property would.
    For our example, we don't want to restrict the visible size of the control, but
    instead, remove the clipped area at the bounds of the control.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 我们确实可以从这个方法返回任何几何形状，但它不会产生与将形状传递给`Clip`属性相同的视觉效果。在我们的示例中，我们不想限制控件的可视大小，而是移除控件边界的剪辑区域。
- en: If we knew exactly what size we wanted to set the clipped range at, we could
    return a `Geometry` object of that size from the `GetLayoutClip` method. However,
    for our purposes, and to enable any of our custom `TextBlock` objects to leak
    endless text out of their bounds, we can simply return `null` from this method.
    Let's look at the difference between the two.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如果我们确切知道要设置剪辑范围的尺寸，我们可以从`GetLayoutClip`方法返回该尺寸的`Geometry`对象。然而，出于我们的目的，以及为了使我们的任何自定义`TextBlock`对象能够超出其边界输出无限文本，我们可以简单地从这个方法返回`null`。让我们看看两种方法之间的区别。
- en: 'First, we create our `BoundlessTextBlock` class by extending the `TextBlock`
    class. Probably, one of the easiest ways to do this in **Visual Studio** is to
    add a WPF User Control object into our Controls folder and then simply replace
    the word `UserControl` with the word `TextBlock` in both the XAML file and its
    associated code behind file. Failure to change both will result in a design-time
    error that complains that **Partial declarations of** ''**`BoundlessTextBlock`**''
    **must not specify different base classes**:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们通过扩展`TextBlock`类来创建我们的`BoundlessTextBlock`类。在**Visual Studio**中，这可能是最简单的方法之一：将一个WPF用户控件对象添加到我们的Controls文件夹中，然后在XAML文件及其关联的后台代码文件中，将单词`UserControl`简单地替换为`TextBlock`。如果未能同时更改这两个文件，将导致设计时错误，错误信息会抱怨**`BoundlessTextBlock`的局部声明**必须**不能指定不同的基类**：
- en: '[PRE7]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'As can be seen from this example, our XAML file can be left remarkably empty,
    and for our requirements, we only need to override the single `GetLayoutClip`
    method in the code behind file. In this first example, we will return an `EllipseGeometry`
    object with the same size as the text block that will be used in the user interface:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 如此示例所示，我们的XAML文件可以非常简洁，对于我们的需求，我们只需要在后台代码文件中重写单个`GetLayoutClip`方法。在这个第一个示例中，我们将返回一个与将要用于用户界面的文本块相同大小的`EllipseGeometry`对象：
- en: '[PRE8]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Let''s see how we can use our new class. First, we need to define a XAML Namespace
    that maps to the CLR namespace where we saved the class. Next, for demonstration
    purposes, we wrap our `BoundlessTextBlock` object in a `Border` object, so that
    we can see its natural bounds:'
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看如何使用我们的新类。首先，我们需要定义一个XAML命名空间，它映射到我们保存类的CLR命名空间。接下来，为了演示目的，我们将`BoundlessTextBlock`对象包裹在一个`Border`对象中，这样我们就可以看到它的自然边界：
- en: '[PRE9]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Let''s take a look at the visual output from this example:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个示例的视觉输出：
- en: '![](img/64858898-4506-4b38-9503-07f8038db0cb.png)'
  id: totrans-56
  prefs: []
  type: TYPE_IMG
  zh: '![](img/64858898-4506-4b38-9503-07f8038db0cb.png)'
- en: 'As you can see, the visual output from our `BoundlessTextBlock` object has
    been restricted to display only the pixels that lie within the `EllipseGeometry`
    object that was returned from the `GetLayoutClip` method. *But what will happen
    if we return an* `EllipseGeometry` *object that is larger than our custom text
    block?* Let''s find out, by returning this object instead:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们的`BoundlessTextBlock`对象的视觉输出已被限制，只显示从`GetLayoutClip`方法返回的`EllipseGeometry`对象内的像素。*但是，如果我们返回一个比我们的自定义文本块更大的`EllipseGeometry`对象会发生什么？*
    让我们通过返回这个对象来找出答案：
- en: '[PRE10]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, looking at the visual output of our `BoundlessTextBlock` object, we can
    see that the content of our custom text block now extends beyond its bounds, thanks
    to the `Border` object and the blue background:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`BoundlessTextBlock`对象的视觉输出，我们可以看到，由于`Border`对象和蓝色背景，我们自定义文本块的内容现在超出了其边界：
- en: '![](img/9368f750-445e-4664-990f-a16f067a8d3e.png)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![](img/9368f750-445e-4664-990f-a16f067a8d3e.png)'
- en: 'So, we can see that the clipping that is applied using the `Geometry` object
    that is returned from the `GetLayoutClip` method is not only unaffected by the
    control''s natural bounds, but in fact, can directly alter them. Returning to
    our original idea on this subject, if we want to totally remove the clipping at
    the control''s bounding edges, we can simply return `null` from this method instead:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以看到，使用从`GetLayoutClip`方法返回的`Geometry`对象应用的裁剪不仅不受控件自然边界的限制，而且实际上可以直接改变它们。回到我们关于这个主题的原始想法，如果我们想完全移除控件边界处的裁剪，我们可以简单地从该方法返回`null`：
- en: '[PRE11]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Let''s see the result of this change now:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看这个更改的结果：
- en: '![](img/bb9a6ae0-1df0-4509-9f03-e1ce24889ec7.png)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/bb9a6ae0-1df0-4509-9f03-e1ce24889ec7.png)'
- en: As you can see, the text now reaches right out of the boundary of the containing
    `TextBlock` object, and continues until the end of the text value. Note that it
    would extend as long as the text string requires, if given enough space by its
    parent control(s).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，文本现在延伸到了包含`TextBlock`对象的边界之外，并继续到文本值的末尾。请注意，如果其父控件（们）提供了足够的空间，它将延伸到文本字符串所需的长度。
- en: Let's look at another example of extending these classes to alter their functionality
    now.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看一下扩展这些类以修改其功能的另一个示例。
- en: Altering default behavior
  id: totrans-67
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 修改默认行为
- en: The developers of the `ItemsControl` class gave it a particular default behavior.
    They thought that any objects that extended the `UIElement` class would have their
    own UI container and so, should be displayed directly, rather than allowing them
    to be templated in the usual way.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemsControl`类的开发者为其赋予了特定的默认行为。他们认为任何扩展`UIElement`类的对象都将有自己的UI容器，因此应该直接显示，而不是允许它们以通常的方式模板化。'
- en: 'There is a method named `IsItemItsOwnContainer` in the `ItemsControl` class,
    which is called by the **WPF** Framework, to determine if an item in the `Items`
    collection is its own item container or not. Let''s first take a look at the source
    code of this method:'
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemsControl`类中有一个名为`IsItemItsOwnContainer`的方法，该框架调用它以确定`Items`集合中的项目是否是其自己的项目容器。让我们首先看看这个方法的源代码：'
- en: '[PRE12]'
  id: totrans-70
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'Note that internally, this method just calls the `IsItemItsOwnContainerOverride`
    method, returning its value unchanged. Let''s take a look at the source code of
    that method now:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，在内部，此方法只是调用`IsItemItsOwnContainerOverride`方法，并返回其值不变。现在让我们看看该方法的源代码：
- en: '[PRE13]'
  id: totrans-72
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Here, we see two things: The first is the default implementation that was just
    mentioned, where `true` is returned for all items that extend the `UIElement`
    class, and `false` for all other types. The second is that this method is marked
    as `virtual`, so we are able to extend this class and override the method to return
    a different value.'
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们看到两件事：第一是刚刚提到的默认实现，其中对于所有扩展`UIElement`类的项目返回`true`，对于所有其他类型返回`false`；第二是此方法被标记为`virtual`，因此我们可以扩展此类并重写该方法以返回不同的值。
- en: 'Let''s now look at the crucial part of the `ItemsControl` class source code
    (without the comments), where our overridden method would be used. This excerpt
    is from the `GetContainerForItem` method:'
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来看看`ItemsControl`类源代码的关键部分（不带注释），其中将使用我们的重写方法。此摘录来自`GetContainerForItem`方法：
- en: '[PRE14]'
  id: totrans-75
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: With the default implementation, we see that `UIElement` items are cast to the
    type of `DependencyObject`, and set as the container, while a new container is
    created for items of all other types. Before overriding this method, let's see
    what effect the default behavior has, using an example.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 在默认实现中，我们看到`UIElement`项目被转换为`DependencyObject`类型，并设置为容器，而为所有其他类型的项目创建了一个新的容器。在重写此方法之前，让我们用一个示例来看看默认行为的效果。
- en: 'The aim of this example is to render a little hollow circle for each item in
    a collection. Think of a slide show, where these circles would represent the slides,
    or a page numbering or linking system. We, therefore, need a collection control
    containing some items and a `DataTemplate`, with which to define the circles.
    Let''s see the collection control with the items on their own first:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 本例的目的是为集合中的每个项目渲染一个小空心圆。想象一下幻灯片放映，这些圆圈将代表幻灯片，或者页码编号或链接系统。因此，我们需要一个包含一些项目的集合控件和一个`DataTemplate`，以便定义这些圆圈。让我们首先看看包含项目的集合控件：
- en: '[PRE15]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: We start with the resources, where we have declared an `ItemsPanelTemplate`,
    that is set to an instance of a `StackPanel`, with its `Orientation` property
    set to `Horizontal`. This will make the panel's items appear horizontally. We
    then added a basic `Style`, in which we set our common properties for the `Rectangle`
    class.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 我们从资源开始，其中我们声明了一个 `ItemsPanelTemplate`，设置为 `StackPanel` 的一个实例，其 `Orientation`
    属性设置为 `Horizontal`。这将使面板的项目水平显示。然后我们添加了一个基本的 `Style`，在其中我们设置了 `Rectangle` 类的常用属性。
- en: 'In the markup, we have a `Grid` panel with two rows. In the first row, we have
    a `ListBox` named `ListBox`, with three colored `Rectangle` objects declared within
    its `Items` collection. Its `ItemsPanel` property is set to the `ItemsPanelTemplate`
    instance that we declared in the control''s `Resources` section. The second row
    is currently empty, but let''s see the visual output so far:'
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 在标记中，我们有一个 `Grid` 面板，有两行。在第一行，我们有一个名为 `ListBox` 的 `ListBox`，在其 `Items` 集合中声明了三个彩色的
    `Rectangle` 对象。其 `ItemsPanel` 属性设置为我们在控件 `Resources` 部分中声明的 `ItemsPanelTemplate`
    实例。第二行目前为空，但让我们看看到目前为止的视觉输出：
- en: '![](img/f4a3615c-e68a-4350-a624-4b2a3db432b7.png)'
  id: totrans-81
  prefs: []
  type: TYPE_IMG
  zh: '![](img/f4a3615c-e68a-4350-a624-4b2a3db432b7.png)'
- en: 'So far, so good. We can see our three rounded rectangles in the `ListBox` control.
    Now, let''s add a `DataTemplate` into the `Resources` section and an `ItemsControl`
    element into the second row of the `Grid` panel, declaring it directly underneath
    the `ListBox` XAML:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切顺利。我们可以在 `ListBox` 控件中看到我们的三个圆形矩形。现在，让我们在 `Resources` 部分添加一个 `DataTemplate`，并在
    `Grid` 面板的第二行添加一个 `ItemsControl` 元素，直接在 `ListBox` XAML 下方声明：
- en: '[PRE16]'
  id: totrans-83
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Note that this `ItemsControl` element has its `ItemsSource` property data bound
    to the `Items` property from the `ListBox`, using an `ElementName` binding. Like
    the `ListBox` control, it also arranges its items horizontally, using the `ItemsPanelTemplate`
    resource. It also applies the new `DataTemplate` element that we just added into
    the `Resources` section.
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个 `ItemsControl` 元素的 `ItemsSource` 属性数据绑定到了 `ListBox` 的 `Items` 属性，使用了一个
    `ElementName` 绑定。像 `ListBox` 控件一样，它也使用 `ItemsPanelTemplate` 资源水平排列其项目。它还应用了我们刚刚添加到
    `Resources` 部分的新的 `DataTemplate` 元素。
- en: 'In this `DataTemplate`, we define a hollow gray `Ellipse` element to be rendered
    for each item in the collection, specifying its dimensions, spacing and stroke
    settings. Let''s take a look at the visual output of our example now:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个 `DataTemplate` 中，我们定义了一个用于渲染集合中每个项目的空心灰色 `Ellipse` 元素，指定了其尺寸、间距和描边设置。现在让我们看看我们示例的视觉输出：
- en: '![](img/8094656d-d5f4-442e-81d2-d4f0811ec150.png)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![](img/8094656d-d5f4-442e-81d2-d4f0811ec150.png)'
- en: As you can see, we have some unexpected results. Instead of rendering the small
    gray ellipses that we defined in the `DataTemplate`, the items in the `ItemsControl`
    display the actual items from the `ListBox`. Even worse than that, as each UI
    element can only be displayed in one location at any given point in time, the
    original items no longer even appear in the `ListBox`.
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们得到了一些意外的结果。我们没有渲染在 `DataTemplate` 中定义的小灰色椭圆，而是 `ItemsControl` 中的项目显示了
    `ListBox` 的实际项目。更糟糕的是，由于每个 UI 元素在任何给定时间点只能显示在一个位置，原始项目甚至不再出现在 `ListBox` 中。
- en: 'You may see an `ArgumentException` being thrown regarding this issue:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能会看到关于这个问题的 `ArgumentException`：
- en: '[PRE17]'
  id: totrans-89
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: '*But why haven''t these objects been rendered as hollow circles in the second*
    `ListBox`*, according to our* `DataTemplate`*?* *Do you remember the* `IsItemItsOwnContainerOverride`
    *method that we investigated?* Well, that is the reason.'
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是，根据我们的* `DataTemplate`*，为什么这些对象没有被渲染成空心圆圈呢*？* 你还记得我们调查过的* `IsItemItsOwnContainerOverride`
    *方法吗？* 好吧，这就是原因。'
- en: The objects that are data-bound to the `ItemsControl`'s `ItemsSource` property
    extend the `UIElement` class, and so the `ItemsControl` class uses them as their
    own containers, rather than creating a new container and applying the item template
    to them.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 绑定到 `ItemsControl` 的 `ItemsSource` 属性的对象扩展了 `UIElement` 类，因此 `ItemsControl`
    类使用它们作为自己的容器，而不是为它们创建一个新的容器并应用项目模板。
- en: '*So, how do we change this default behavior?* That''s right, we need to extend
    the `ItemsControl` class and override the `IsItemItsOwnContainerOverride` method
    to always return `false`. In this way, a new container will always be created
    and the item template will always be applied. Let''s see how this would look in
    a new class:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，我们如何改变这种默认行为呢*？* 对，我们需要扩展 `ItemsControl` 类并重写 `IsItemItsOwnContainerOverride`
    方法，使其始终返回 `false`。这样，就会始终创建一个新的容器，并且始终应用项目模板。让我们看看在一个新类中这会是什么样子：'
- en: '[PRE18]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: Here we have the very simple `ForcedContainerItemsControl` class, with its single
    overridden method, that always returns `false`. We need to do nothing else in
    this class, as we are happy to use the default behavior of the `ItemsControl`
    class for everything else.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 这里我们有非常简单的 `ForcedContainerItemsControl` 类，它有一个重写的方法，总是返回 `false`。在这个类中我们不需要做其他任何事情，因为我们很高兴使用
    `ItemsControl` 类的默认行为来处理其他所有事情。
- en: 'All that remains is for us to use our new class in our example. We start by
    adding a XAML Namespace for our `Controls` CLR Namespace:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 剩下的就是在我们示例中使用我们的新类。我们首先为我们的 `Controls` CLR 命名空间添加一个 XAML 命名空间：
- en: 'Next, we replace the `ItemsControl` XAML with the following:'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将 `ItemsControl` XAML 替换为以下内容：
- en: '[PRE19]'
  id: totrans-97
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Let''s see the new visual output now:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在的新的视觉输出：
- en: '![](img/576ab18e-5550-4f71-aa5e-9cb53c8bcadc.png)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/576ab18e-5550-4f71-aa5e-9cb53c8bcadc.png)'
- en: 'Now, we see what we were originally expecting to see: a little hollow circle
    rendered for each item in the collection. The items in our custom `ItemsControl`
    have now all been generated a new container and had our template applied to them
    as expected.'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们看到我们最初期望看到的东西：为集合中的每个项渲染一个小空心圆。我们自定义的 `ItemsControl` 中的项现在都已经生成了新的容器，并且按照预期应用了我们的模板。
- en: '*But what if we need to make use of the selected item in this example?* The
    `ItemsControl` class has no concept of a selected item, so in this case, we would
    need to use a `ListBox` control in the second row of the `Grid` panel.'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: '*但是如果我们需要在这个示例中使用选中项怎么办？* `ItemsControl` 类没有选中项的概念，所以在这种情况下，我们需要在 `Grid` 面板的第二行中使用
    `ListBox` 控件。'
- en: However, note that the `ListBox` class has also overridden the `IsItemItsOwnContainerOverride`
    method, so that it does not suffer from this same problem.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，请注意，`ListBox` 类也重写了 `IsItemItsOwnContainerOverride` 方法，这样它就不会有相同的问题。
- en: 'In fact, it will only use an item as a container if it is actually the correct
    container for this class; a `ListBoxItem`. Let''s see its overridden method:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，它只会将项用作容器，如果它实际上是这个类的正确容器；一个 `ListBoxItem`。让我们看看它重写的方法：
- en: '[PRE20]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Therefore, if we need access to the `SelectedItem` property from the `ListBox`
    class, then we do not need to create our own extended class to override this method,
    and can instead use their standard implementation. To get the same visual output
    however, we would need some styles to hide the `ListBox`''s border and selected
    item highlights. Let''s see a basic example of this:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，如果我们需要从 `ListBox` 类中访问 `SelectedItem` 属性，那么我们不需要创建我们自己的扩展类来重写这个方法，而是可以使用它们的标准实现。然而，为了获得相同的视觉输出，我们需要一些样式来隐藏
    `ListBox` 的边框和选中项的高亮。让我们看看这个基本示例：
- en: '[PRE21]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'We would also need to update our `EllipseDataTemplate` template to include
    a trigger to highlight the small `Ellipse` object when its related item is selected
    in the top `ListBox` control:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还需要更新我们的 `EllipseDataTemplate` 模板，以便包含一个触发器，在顶部的 `ListBox` 控件中选择相关项时突出显示小的
    `Ellipse` 对象：
- en: '[PRE22]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'And finally, we''ll need to replace our `ForcedContainerItemsControl` element
    with a standard `ListBox` and apply our styles to it and its containers:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要将我们的 `ForcedContainerItemsControl` 元素替换为标准的 `ListBox`，并将其样式应用到它及其容器上：
- en: '[PRE23]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'When we run the application now, we see that the small hollow `Ellipse` objects
    become filled when their related item is selected in the top `ListBox`:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们现在运行应用程序时，我们看到当在顶部的 `ListBox` 中选择相关项时，小的空心 `Ellipse` 对象会变成实心：
- en: '![](img/4c9e7f03-1edb-4ed1-9a87-b3fd865b0c61.png)'
  id: totrans-112
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/4c9e7f03-1edb-4ed1-9a87-b3fd865b0c61.png)'
- en: So, we've seen how we can override these protected methods to change the default
    behavior of the built-in controls. Let's now take a look at how we can build these
    protected methods into our own custom classes, so that they can affect the natural
    flow of a piece of our control's functionality.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们已经看到了如何重写这些受保护的方法来改变内置控件的默认行为。现在让我们看看如何将这些受保护的方法构建到我们自己的自定义类中，以便它们可以影响我们控件功能的一部分的自然流程。
- en: Creating overridable methods
  id: totrans-114
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 创建可重写的方法
- en: The first thing that we need to do is to define either an abstract or a virtual
    method in our base class. Note that the class would need to be abstract in order
    to declare an abstract method. Which one we chose will depend on if we want to
    leave the implementation up to the developers that use our code, or if we have
    some implementation that we need to put in the method ourselves.
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是在我们的基类中定义一个抽象方法或虚方法。请注意，为了声明一个抽象方法，类必须是抽象的。我们选择哪一个将取决于我们是否希望将实现留给使用我们代码的开发者，或者如果我们需要在方法中自己实现一些实现。
- en: 'Let''s look at an example to clarify this. Here, we see a method from an abstract
    `BaseDragDropManager` class. It handles the `PreviewMouseMove` event on controls
    that are used as drag and drop sources, for example, on a `ListBox` from which
    an item is being dragged:'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过一个例子来澄清这一点。这里，我们看到一个来自抽象 `BaseDragDropManager` 类的方法。它处理用作拖放源的控件上的 `PreviewMouseMove`
    事件，例如，在一个 `ListBox` 上，一个项目正在被拖动：
- en: '[PRE24]'
  id: totrans-117
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In this example, the `DragSourcePreviewMouseMove` method first performs a check
    to verify that a drag operation has been initiated by the user. It then calls
    the `OnDragSourcePreviewMouseMove` method, which is marked as `virtual`, which
    makes overriding it in derived classes optional.
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，`DragSourcePreviewMouseMove` 方法首先执行一个检查，以验证是否由用户启动了拖动操作。然后，它调用标记为 `virtual`
    的 `OnDragSourcePreviewMouseMove` 方法，这使得在派生类中重写它是可选的。
- en: The next line of the `DragSourcePreviewMouseMove` method checks the `Handled`
    property of the `MouseEventArgs` input parameter and if it has been set to `true`
    in the derived class, it returns execution to the caller, instead of continuing
    with the drag and drop operation. If the event has not been handled, then the
    `OnDragStart` method is called.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: '`DragSourcePreviewMouseMove` 方法的下一行检查 `MouseEventArgs` 输入参数的 `Handled` 属性，如果它在派生类中被设置为
    `true`，则将执行权返回给调用者，而不是继续拖放操作。如果事件没有被处理，则调用 `OnDragStart` 方法。'
- en: This is the crucial bit that links the possible input from the derived classes.
    The only reason to override the `OnDragSourcePreviewMouseMove` method in an extending
    class is to set the `Handled` property of the `MouseEventArgs` input parameter
    to `true` and stop the drag and drop operation from starting, perhaps according
    to some information that the extending class has.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 这是将派生类可能的输入链接起来的关键部分。在扩展类中重写 `OnDragSourcePreviewMouseMove` 方法的唯一原因是将 `MouseEventArgs`
    输入参数的 `Handled` 属性设置为 `true` 并停止拖放操作开始，这可能根据扩展类拥有的某些信息。
- en: Conversely, the `OnDragStart` method is marked as `abstract`, requiring it to
    be overridden in all derived classes. This is the method that prepares the data
    for the drag and drop process, and is required to call the `StartDrag` method
    of the base class to start the operation, passing the prepared data.
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 相反，`OnDragStart` 方法被标记为 `abstract`，要求在所有派生类中重写它。这是准备拖放过程数据的方法，并且需要调用基类的 `StartDrag`
    方法以开始操作，传递准备好的数据。
- en: In this particular example, our virtual method is left empty in the base class
    and there is no need to call it from the overridden method. More typically, the
    base class would contain a default implementation, which could be overridden in
    derived classes, but may require a call to the base class, in order to retain
    its functionality.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个特定的例子中，我们的虚拟方法在基类中是空的，并且不需要从重写的方法中调用它。更典型的情况是，基类将包含一个默认实现，这可以在派生类中重写，但可能需要调用基类，以保留其功能。
- en: 'For example, a .NET Framework programming guideline exists for raising base
    class events from derived classes. Ordinarily, derived classes cannot raise base
    class events and any attempts to do so will be met with a compilation error:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，存在一个从派生类中引发基类事件的 .NET Framework 编程指南。通常，派生类不能引发基类事件，任何尝试这样做都会遇到编译错误：
- en: '[PRE25]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The solution to this problem from the guidelines is to wrap the invocation
    of these events in a protected method in the base class, so it can be called or
    overridden in derived classes. Let''s add a custom `EventArgs` class and an event
    into our `AddressControl` control that demonstrates this guideline:'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 指南中解决这个问题的方法是，在基类中包装这些事件的调用在一个受保护的方法中，以便可以在派生类中调用或重写。让我们向我们的 `AddressControl`
    控件添加一个自定义的 `EventArgs` 类和一个事件，以演示这个指南：
- en: '[PRE26]'
  id: totrans-126
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: First, we create a custom `EventArgs` class for our event. Then, we declare
    an event named `AddressChanged` and a protected virtual method that raises it,
    using the null conditional operator. This can be called directly from derived
    classes to raise the event, but also overridden, to add to or to stop the base
    class implementation from executing.
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们为我们的事件创建一个自定义的 `EventArgs` 类。然后，我们声明一个名为 `AddressChanged` 的事件和一个用于引发它的受保护的虚拟方法，使用空条件运算符。这可以直接从派生类中调用以引发事件，也可以重写，以添加到或阻止基类实现执行。
- en: Finally, we update our `Address` property to call the invocation method, passing
    in the required previous and current `Address` objects. Note that we now also
    mark this property as `virtual`, so that derived classes can override it as well,
    to fully control how, when and if the event should be raised.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们更新我们的`Address`属性，以调用调用方法，并传入所需的先前和当前`Address`对象。请注意，我们现在也将此属性标记为`virtual`，这样派生类也可以重写它，以完全控制事件何时以及是否应该被触发。
- en: This is a far more preferable solution to declaring a virtual event and overriding
    it in a derived class, as the compiler does not always handle this situation as
    expected, due to some complicated event overriding rules, and we cannot always
    be certain which version of the event a subscriber will actually by subscribing
    to.
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这比在派生类中声明一个虚拟事件并重写它要好得多，因为编译器并不总是按预期处理这种情况，这是由于一些复杂的事件重写规则，我们也不能总是确定订阅者实际上会订阅哪个版本的事件。
- en: Now that we have a better understanding of these protected methods, let's take
    a look at what other kinds of things we can do by overriding them in derived classes.
    We will use an extended example that raises a number of problems, that we can
    fix by overriding a number of these protected base class methods.
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们对这些受保护的方法有了更好的理解，让我们看看通过在派生类中重写它们我们可以做些什么。我们将使用一个扩展示例，该示例提出了许多问题，我们可以通过重写这些受保护基类方法中的几个来修复这些问题。
- en: Tailoring to attain our requirements
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 定制以满足我们的需求
- en: Let's imagine that we want to create an application that displays tabular data.
    This doesn't initially sound very complicated, but it is actually a very good
    example with which to demonstrate how to adapt the built-in .NET controls to fulfill
    our requirements. As we progress through this example, we will come across several
    potential problems and find out how to overcome each one in turn.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们想象一下，我们想要创建一个显示表格数据的程序。这听起来最初并不复杂，但实际上这是一个很好的示例，可以用来展示如何调整内置的.NET控件以满足我们的需求。随着我们通过这个示例的进展，我们将遇到几个潜在的问题，并逐一找出如何克服这些问题。
- en: For this extended example, we will create a `Spreadsheet` control. As always,
    when creating new controls, we look at the existing controls, to see if any of
    them can provide us with a good starting point. The first control that springs
    to mind is the `Grid` panel, as it has rows, columns and therefore also cells,
    but the creation of all of the `RowDefinition` and `ColumnDefinition` objects
    could be cumbersome or problematic.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个扩展示例，我们将创建一个`Spreadsheet`控件。和往常一样，在创建新的控件时，我们会查看现有的控件，看看是否有任何控件可以作为我们良好的起点。第一个跳入脑海的控件是`Grid`面板，因为它有行、列，因此也有单元格，但创建所有的`RowDefinition`和`ColumnDefinition`对象可能会很繁琐或有问题。
- en: There is also the `UniformGrid` panel, but as its name suggests, all of its
    cells are uniform, or the same size as each other, but this is not always the
    case in spreadsheets. We could potentially use an `ItemsControl` object and a
    custom `DataTemplate` to draw the borders and contents of each cell manually,
    *but could there be a better starting point?*
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 还有`UniformGrid`面板，但正如其名称所暗示的，它的所有单元格都是统一的，或者彼此大小相同，但在电子表格中这并不总是情况。我们可以使用一个`ItemsControl`对象和一个自定义的`DataTemplate`来手动绘制每个单元格的边框和内容，*但有没有更好的起点呢？*
- en: '*How about the* `DataGrid` *control?* It has rows, columns, and cells, and
    even draws the grid lines between the cells for us. It also has the concept of
    a selected cell, which could be useful if we wanted users to interact with our
    spreadsheet control. It has no numbers, letters, or selected cell markers in the
    grid axes, but we can extend the control to add these, so it seems like the best
    candidate for the job.'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，`DataGrid`控件怎么样呢？* 它有行、列和单元格，甚至为我们绘制单元格之间的网格线。它还有一个选中单元格的概念，如果我们想让用户与我们的电子表格控件交互，这可能很有用。它没有在网格轴上的数字、字母或选中单元格标记，但我们可以扩展控件来添加这些，所以它似乎是这项工作的最佳候选人。'
- en: The first thing that we need to do is to create a new class that extends the
    `DataGrid` class. As we saw earlier in this chapter, we can do this by adding
    a `UserControl` to our project and replacing the word `UserControl` with the word
    `DataGrid` in both the XAML file and its code behind file. Failure to change both
    will result in a design-time error that complains about mismatched classes.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是创建一个新的类，该类扩展了`DataGrid`类。正如我们在本章前面所看到的，我们可以通过向我们的项目中添加一个`UserControl`并将其XAML文件和其代码背后的文件中的`UserControl`一词替换为`DataGrid`来实现这一点。如果未能同时更改这两个地方，将导致设计时错误，错误信息会抱怨类不匹配。
- en: 'Let''s take a look at our new `Spreadsheet` class:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们的新 `Spreadsheet` 类：
- en: '[PRE27]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'The code behind is a simple affair, currently with no custom code in it. The
    XAML however, has a number of important properties set in it, so let''s see that
    now:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 背后的代码很简单，目前没有自定义代码。然而，XAML 中设置了许多重要的属性，所以现在让我们看看它：
- en: '[PRE28]'
  id: totrans-140
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: For this implementation, we set the `AutoGenerateColumns` property to `False`,
    because we will be programmatically creating the columns of our spreadsheet control.
    In order to approximate a spreadsheet control, we also need to restrict the selection
    possibilities of our custom `DataGrid`.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个实现，我们将 `AutoGenerateColumns` 属性设置为 `False`，因为我们将会以编程方式创建电子表格控件的列。为了近似电子表格控件，我们还需要限制我们自定义
    `DataGrid` 的选择可能性。
- en: As such, we set the `SelectionUnit` property to `Cell`, so that users select
    just the cell that they click on, rather than the whole row, which is the default
    selection behavior. In addition, to simplify this example, we also set the `SelectionMode`
    property to `Single`, the `IsReadOnly` property to `True` and the `RowHeight`
    property to `20`.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们将 `SelectionUnit` 属性设置为 `Cell`，这样用户就只会选择他们点击的单元格，而不是整行，这是默认的选择行为。此外，为了简化这个示例，我们还设置了
    `SelectionMode` 属性为 `Single`，`IsReadOnly` 属性为 `True`，以及 `RowHeight` 属性为 `20`。
- en: Our row and column headers will both be 26 pixels each, so we set the `RowHeaderWidth`
    and `ColumnHeaderHeight` properties to `26`. Note that we could set the row and
    column header dimensions in their relative styles instead, but we will need to
    reference these properties later, so it is important that we set them here. The
    next five properties, prefixed with `CanUser`, have also been set to `False`,
    to further shorten this example.
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 我们的行和列标题都将设置为 26 像素，因此我们将 `RowHeaderWidth` 和 `ColumnHeaderHeight` 属性设置为 `26`。请注意，我们也可以在它们的相对样式中设置行和列标题的尺寸，但我们需要稍后引用这些属性，所以在这里设置它们是很重要的。接下来的五个属性，以
    `CanUser` 为前缀，也已设置为 `False`，以进一步缩短这个示例。
- en: We then set both of the `HorizontalGridLinesBrush` and `VerticalGridLinesBrush`
    properties to the `GridlinesBrush` brush from the `Resources` section and the
    `BorderBrush` property to the `BorderBrush` brush. Note that we need to use a
    `DynamicResource` markup extension in these cases, because these brushes are defined
    after the `DataGrid` declaration, along with the rest of the resources, and the
    XAML parser would not be able to locate them with a standard `StaticResource`
    markup extension.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将 `HorizontalGridLinesBrush` 和 `VerticalGridLinesBrush` 属性都设置为来自 `Resources`
    部分的 `GridlinesBrush` 画笔，并将 `BorderBrush` 属性设置为 `BorderBrush` 画笔。请注意，在这些情况下，我们需要使用
    `DynamicResource` 标记扩展，因为这些画笔是在 `DataGrid` 声明之后定义的，包括其他所有资源，而 XAML 解析器无法使用标准的
    `StaticResource` 标记扩展来定位它们。
- en: 'Also, note that it is essential that we remove the empty `Grid` panel that
    Visual Studio adds into each new `UserControl`. The reason is that any elements
    declared inside the `DataGrid` control are determined to be its items and we cannot
    simultaneously use both its `Items` property and its `ItemsSource` property, which
    we intend on using. If we use them both, we''ll see this exception being thrown
    at runtime:'
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们必须删除 Visual Studio 添加到每个新 `UserControl` 中的空 `Grid` 面板。原因是任何在 `DataGrid`
    控件内部声明的元素都被确定为它的项目，我们不能同时使用它的 `Items` 属性和 `ItemsSource` 属性，而这是我们打算使用的。如果我们同时使用它们，我们将在运行时看到这个异常被抛出：
- en: '[PRE29]'
  id: totrans-146
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: Let's move on now, to investigate how we can display data in our spreadsheet.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续前进，研究我们如何在电子表格中显示数据。
- en: Populating with Data
  id: totrans-148
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 数据填充
- en: 'In order to get some data into our `Spreadsheet` control, we will need a class
    to represent each cell in the spreadsheet. Let''s take a look at a basic `Cell`
    class now:'
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 为了将一些数据放入我们的 `Spreadsheet` 控件中，我们需要一个类来表示电子表格中的每个单元格。现在让我们看看一个基本的 `Cell` 类：
- en: '[PRE30]'
  id: totrans-150
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: This is a very straight forward class, with just three properties, a constructor
    to populate those properties, and an overridden `ToString` method. As usual, we
    extend our `BaseDataModel` class to provide us with access to the `INotifyPropertyChanged`
    interface. Note that in a real spreadsheet-based application, we would have many
    more properties in this class, to enable us to style and format the content appropriately.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个非常直接的类，只有三个属性，一个用于填充这些属性的构造函数，以及一个重写的 `ToString` 方法。像往常一样，我们扩展了 `BaseDataModel`
    类，以便我们可以访问 `INotifyPropertyChanged` 接口。请注意，在一个真正的基于电子表格的应用程序中，我们会在这个类中有更多的属性，以便我们可以适当地样式化和格式化内容。
- en: 'Let''s now move on, to create our `SpreadsheetViewModel` and `SpreadsheetView`
    classes. In the `SpreadsheetViewModel` class, we populate a `DataTable` with some
    basic example data and we data bind that to our new `Spreadsheet` control in the
    `SpreadsheetView` class:'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们继续创建我们的`SpreadsheetViewModel`和`SpreadsheetView`类。在`SpreadsheetViewModel`类中，我们用一些基本示例数据填充一个`DataTable`，并将其数据绑定到`SpreadsheetView`类中的新`Spreadsheet`控件：
- en: '[PRE31]'
  id: totrans-153
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: In this very simple View Model, we declare a single property of type `DataRowCollection`,
    to contain our spreadsheet data. Using this type enables us to easily populate
    our spreadsheet from a `DataTable` object, which we may have loaded from a database,
    or generated from an XML file, for example.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个非常简单的视图模型中，我们声明了一个类型为`DataRowCollection`的单个属性，以包含我们的电子表格数据。使用此类型使我们能够轻松地从`DataTable`对象填充我们的电子表格，例如，从数据库加载或从XML文件生成。
- en: 'In the constructor, we programmatically initialize and populate a `DataTable`
    with example `Cell` objects and set its `Rows` property value to our `Rows` property.
    Let''s see how this `Rows` property is data-bound to our `Spreadsheet` control
    in the `SpreadsheetView` class now:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 在构造函数中，我们通过编程初始化并填充一个`DataTable`，使用示例`Cell`对象，并将其`Rows`属性值设置为我们的`Rows`属性。现在让我们看看这个`Rows`属性是如何在`SpreadsheetView`类中与我们的`Spreadsheet`控件数据绑定的：
- en: '[PRE32]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: Once again, this is a very simple class, with nothing other than a XAML Namespace
    declaration for our `Controls` project and one of our `Spreadsheet` controls,
    with its `ItemsSource` property data bound to the `Rows` property of our View
    Model. The code behind is even more bare, with no custom code in it at all. Also,
    remember to link our View and View Model together, using whichever method you
    prefer.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，这是一个非常简单的类，除了为我们的`Controls`项目声明一个XAML命名空间以及一个`Spreadsheet`控件，其`ItemsSource`属性绑定到视图模型的`Rows`属性外，没有其他内容。代码背后更是简单，其中没有任何自定义代码。此外，请记住使用您喜欢的任何方法将视图和视图模型链接在一起。
- en: 'Before we can see any data in our `Spreadsheet` control, however, we will need
    to declare a `DataTemplate` to define how each cell should be rendered and programmatically
    set up our columns, in relation to the data-bound items. Let''s declare the required
    XAML Namespace in the XAML file and add the `DataTemplate` into the `Resources`
    section of our `Spreadsheet` control first:'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在我们能够在`Spreadsheet`控件中看到任何数据之前，我们需要声明一个`DataTemplate`来定义每个单元格应该如何渲染，并程序化设置我们的列，与数据绑定项相关。现在让我们在XAML文件中声明所需的XAML命名空间，并将`DataTemplate`添加到我们的`Spreadsheet`控件的`Resources`部分中：
- en: '[PRE33]'
  id: totrans-159
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: Here, we have a horizontally centered `TextBlock` control, to output the contents
    of each cell. In a real-world application, we'd surround it with a `Border` element,
    to color the background of each cell and data bind to many more properties, to
    enable us to set different style and formatting settings for each cell. For this
    example, however, we'll keep it simple.
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，我们有一个水平居中的`TextBlock`控件，用于输出每个单元格的内容。在实际应用中，我们会用`Border`元素包围它，以着色每个单元格的背景，并将数据绑定到更多属性，以便我们为每个单元格设置不同的样式和格式设置。然而，在这个例子中，我们将保持简单。
- en: Returning to the subject of column generation now, remember that we do not know
    how many columns there will be in the incoming data, so we need to find a place
    to set them up programmatically. For this, we return to the protected base class
    methods.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 回到列生成的主题，记住我们不知道传入数据中会有多少列，因此我们需要找到一个地方来程序化设置它们。为此，我们回到受保护的基类方法。
- en: 'Looking through the protected methods of the `DataGrid` class, we see a good
    candidate: the `OnItemsSourceChanged` method. This method will be called each
    time the `ItemsSource` value changes, so it''s an ideal place to initialize our
    spreadsheet columns when the data source changes.'
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 在查看`DataGrid`类的受保护方法时，我们看到一个好的候选者：`OnItemsSourceChanged`方法。此方法将在`ItemsSource`值更改时被调用，因此它是初始化电子表格列的绝佳位置，当数据源更改时。
- en: But our items are `DataRow` objects, with each `Cell` object being in a different
    location in its `ItemArray` collection. We need a way to use the array syntax
    to data bind each `Cell`, but the built-in column types don't have this functionality.
    As such, we will need to create a custom one and the `DataGridTemplateColumn`
    class is the best place to start.
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 但是我们的项目是`DataRow`对象，每个`Cell`对象在其`ItemArray`集合中的位置都不同。我们需要一种方法来使用数组语法来数据绑定每个`Cell`，但是内置的列类型没有这个功能。因此，我们需要创建一个自定义的，而`DataGridTemplateColumn`类是最好的起点。
- en: 'We can override this class to add a property named `Binding` of type `Binding`
    and use it to set the binding on the UI element that is generated for each cell.
    Looking through the protected methods in the `DataGridTemplateColumn` class, we
    find the `GenerateElement` method, which generates these UI elements. Let''s see
    this new `DataGridBoundTemplateColumn` class now:'
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以重写这个类，添加一个名为 `Binding` 的 `Binding` 类型属性，并使用它来设置为每个单元格生成的 UI 元素上的绑定。通过查看
    `DataGridTemplateColumn` 类中的受保护方法，我们找到了 `GenerateElement` 方法，它生成这些 UI 元素。现在让我们看看这个新的
    `DataGridBoundTemplateColumn` 类：
- en: '[PRE34]'
  id: totrans-165
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: This is another simple class and, we start by extending the `DataGridTemplateColumn`
    class and declaring the aforementioned `Binding` property. We then override the
    `GenerateElement` method and in it, first call the base class implementation to
    generate the `FrameworkElement` object that relates to the current cell, passing
    the input parameters through unchanged.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类，我们首先扩展 `DataGridTemplateColumn` 类并声明上述 `Binding` 属性。然后我们重写 `GenerateElement`
    方法，在其中首先调用基类实现以生成与当前单元格相关的 `FrameworkElement` 对象，并通过不变的方式传递输入参数。
- en: If the `Binding` property is not `null`, we then call the `SetBinding` method
    on the element, specifying the `ContentPresenter.ContentProperty` Dependency Property
    as the binding target and passing the `Binding` object from the `Binding` property
    through to connect with it. We end by simply returning the generated element.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `Binding` 属性不是 `null`，我们就在元素上调用 `SetBinding` 方法，指定 `ContentPresenter.ContentProperty`
    依赖属性作为绑定目标，并通过 `Binding` 属性传递 `Binding` 对象以连接到它。最后，我们简单地返回生成的元素。
- en: 'Now, let''s return to the code behind of our `Spreadsheet` class, where we
    need to use our new `DataGridBoundTemplateColumn` class:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们回到 `Spreadsheet` 类的代码背后，在那里我们需要使用我们新的 `DataGridBoundTemplateColumn` 类：
- en: '[PRE35]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: As mentioned previously, we override the `OnItemsSourceChanged` method to initialize
    our spreadsheet columns each time the data source changes. In it, we use C# 6.0
    Pattern Matching to verify that the `newValue` input parameter is not `null` and
    is of type `DataRowCollection`, before also checking that the collection has one
    or more rows in it.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，我们重写 `OnItemsSourceChanged` 方法，以便在数据源更改时初始化我们的电子表格列。在其中，我们使用 C# 6.0 模式匹配来验证
    `newValue` 输入参数不是 `null` 并且是 `DataRowCollection` 类型，然后再检查集合中是否有一行或多行。
- en: If the `DataRowCollection` object is valid, then we cast the items in the `ItemArray`
    collection of its first row to an array of our custom type `Cell`. We only need
    to use the first row, because here, we are just setting up the columns, not the
    data. We then clear the columns of our spreadsheet control and find the `DataTemplate`
    named `CellTemplate` from the control's `Resources` section.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `DataRowCollection` 对象有效，那么我们将它的第一行的 `ItemArray` 集合中的项目转换为我们自定义类型 `Cell`
    的数组。我们只需要使用第一行，因为在这里，我们只是设置列，而不是数据。然后我们清除电子表格控制的列，并从控制的 `Resources` 部分找到名为 `CellTemplate`
    的 `DataTemplate`。
- en: Next, we iterate through the `Cell` objects in the array, adding a new `DataGridBoundTemplateColumn`
    element to the spreadsheet's `Columns` collection for each one. Each column element
    is initialized with a `Header`, taken from the `GetColumnName` method, the `CellTemplate`
    `DataTemplate`, the `Width` from the `Cell` object, and a `Binding` object.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们遍历数组中的 `Cell` 对象，为每个对象在电子表格的 `Columns` 集合中添加一个新的 `DataGridBoundTemplateColumn`
    元素。每个列元素使用 `Header` 初始化，该 `Header` 来自 `GetColumnName` 方法，`CellTemplate` `DataTemplate`，`Cell`
    对象的 `Width`，以及一个 `Binding` 对象。
- en: Note that the `Binding` path is set to `$"[{i}]"`, which would translate to
    `"[0]"` for the first item for example, and represents the standard indexing notation.
    This would result in the binding path being set to the first item in each row
    of the data-bound collection, or put another way, each cell in the first column
    of our data source.
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Binding` 路径设置为 `$"[{i}]"`，例如，对于第一个项目，它将转换为 `"[0]"`，这代表标准的索引表示法。这将导致绑定路径设置为数据绑定集合中每一行的第一个项目，或者换句话说，就是我们的数据源的第一列中的每个单元格。
- en: If the input value in the `GetColumnName` method is between 1 and 26, we add
    64 to it, before casting it to a `char` and then calling the `ToString` method
    on the result. The capital A character has the integer value of 65 in the ASCII
    table and so, this code has the effect of turning the index of the first 26 columns
    into the letters A to Z.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `GetColumnName` 方法中的输入值在 1 到 26 之间，我们将其加 64，然后将其转换为 `char` 并在结果上调用 `ToString`
    方法。大写字母 A 在 ASCII 表中的整数值为 65，因此，这段代码的效果是将前 26 列的索引转换为字母 A 到 Z。
- en: If the input value is more than `26` and is also an exact multiple of `26`,
    then we return the string concatenation of a recursive call to the `GetColumnName`
    method, passing in the factor of the input value when it is divided by `26`, with
    `1` subtracted from it, and the letter `Z`.
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入值大于`26`并且是`26`的精确倍数，那么我们返回对`GetColumnName`方法的递归调用的字符串连接，传递输入值除以`26`的因子，并从它中减去`1`，以及字母`Z`。
- en: 'If none of the `if` conditions are met, we return the result of two more recursive
    calls: the first passed value represents the factor of the input value when it
    is divided by 26 and the second represents the remainder of the input value when
    it is divided by 26.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有任何`if`条件满足，我们将返回两次递归调用的结果：第一个传递的值代表输入值除以26后的因子，第二个代表输入值除以26的余数。
- en: 'In plain English, the first line outputs letters A to Z, while the second handles
    column identities that contain more than a single letter and end in the letter
    Z, and the third line handles all of the rest. Let''s see what we have when running
    the application so far:'
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 用简单的英语来说，第一行输出字母A到Z，第二行处理包含多个字母并以字母Z结尾的列标识符，第三行处理所有其他情况。让我们看看到目前为止运行应用程序时我们有什么结果：
- en: '![](img/6fc648f4-48be-49de-966a-1cf54de2665e.png)'
  id: totrans-178
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/6fc648f4-48be-49de-966a-1cf54de2665e.png)'
- en: Progressing toward the Target
  id: totrans-179
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 向目标迈进
- en: '*So, what changes do we need to make to the turn this* `DataGrid` *control
    into something that looks more like a spreadsheet?* We need to style it accordingly
    and to populate the row headers with numbers that identify each row. We also need
    to highlight the relevant row and column headers when a cell is selected and can
    implement an animated selection rectangle to highlight the selected cell, instead
    of using the default highlighting shown in the image.'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
  zh: '*那么，我们需要对哪些方面进行修改，才能将这个* `DataGrid` *控件变成更类似于电子表格的外观？* 我们需要相应地对其进行样式化，并在行标题中填充标识每行的数字。我们还需要在单元格被选中时突出显示相关的行和列标题，并且可以实现一个动画选择矩形来突出显示选中的单元格，而不是使用图像中显示的默认突出显示。'
- en: 'First, let''s populate the row headers with numbers. There are several ways
    to achieve this, but I prefer to simply ask each row what its index is in a converter
    class and connect it to the row header via a data binding. Let''s see this converter
    now:'
  id: totrans-181
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们用数字填充行标题。有几种方法可以实现这一点，但我更喜欢简单地要求每个行在转换器类中询问其索引，并通过数据绑定将其连接到行标题。现在让我们看看这个转换器：
- en: '[PRE36]'
  id: totrans-182
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: This is another simple class and, as usual, we start by specifying the data
    types involved in the converter in the `ValueConversion` attribute. In this case,
    our input will be `DataRow` objects and our output will be their integer row numbers.
    In the `Convert` method, we use Pattern Matching from C# 6.0 as a shortcut to
    validate that our input value is not `null` and is of the appropriate type and
    if suitable, to cast it to that type.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个简单的类，并且，像往常一样，我们首先在`ValueConversion`属性中指定转换器中涉及的数据类型。在这种情况下，我们的输入将是`DataRow`对象，我们的输出将是它们的整数行号。在`Convert`方法中，我们使用C#
    6.0的匹配模式作为快捷方式来验证我们的输入值不是`null`并且是适当类型，如果合适的话，将其转换为该类型。
- en: If the input is valid, we call the `GetIndex` method on the pre-cast `dataGridRow`
    variable, remembering to add 1 to the zero-based method result, before returning
    it from the converter. For all other input values, we return the `DependencyProperty.UnsetValue`
    value. As we will not need to convert any values in the other direction, we leave
    the `ConvertBack` method unimplemented.
  id: totrans-184
  prefs: []
  type: TYPE_NORMAL
  zh: 如果输入有效，我们在预转换的`dataGridRow`变量上调用`GetIndex`方法，记得在返回转换器之前将零基方法结果加1。对于所有其他输入值，我们返回`DependencyProperty.UnsetValue`值。由于我们不需要在相反方向转换任何值，所以我们留空`ConvertBack`方法。
- en: 'Let''s see how we use this `converter` class now. First, we need to set up
    a XAML Namespace for our `Converters` CLR Namespace and create an instance of
    it in the control''s `Resources` section:'
  id: totrans-185
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在如何使用这个`converter`类。首先，我们需要为我们的`Converters` CLR命名空间设置一个XAML命名空间，并在控制器的`Resources`部分创建其实例：
- en: '[PRE37]'
  id: totrans-186
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'We are then able to use it in a data binding on the `Text` property of a `TextBlock`
    element in the `DataTemplate`, that is applied to the `RowHeaderTemplate` property
    in our custom `DataGrid`:'
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们能够在`DataTemplate`中`TextBlock`元素的`Text`属性的数据绑定中使用它，该`DataTemplate`应用于我们自定义的`DataGrid`的`RowHeaderTemplate`属性：
- en: '[PRE38]'
  id: totrans-188
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Note that the binding path is set to `.`, which as you may remember, sets it
    to the whole binding object. The `RelativeSource` binding sets the binding source
    to the first ancestor of the `TextBlock` of type `DataGridRow`, and so we pass
    the whole `DataGridRow` object through to the binding and therefore, also to the
    converter, as required.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，绑定路径被设置为“.”，正如你可能记得的，这会将它设置为整个绑定对象。`RelativeSource`绑定将绑定源设置为`DataGridRow`类型`TextBlock`的第一个祖先，因此我们将整个`DataGridRow`对象传递给绑定，以及所需的转换器。
- en: 'Also, note that we must declare this `RowHeaderTemplate` property below the
    `Resources` section in the XAML file. Failure to do this will result in the following
    runtime error:'
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，我们必须在XAML文件的`Resources`部分下方声明这个`RowHeaderTemplate`属性。未能这样做将导致以下运行时错误：
- en: '[PRE39]'
  id: totrans-191
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: Whereas sometimes we can fix these "reference not found" errors by using a `DynamicResource`
    markup extension instead of a `StaticResource` markup extension, it won't work
    in this case. This is because we can only use them on a `DependencyProperty` of
    a `DependencyObject` and the `Converter` property is not a `DependencyProperty`
    and the `Binding` class is not a `DependencyObject`.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然有时我们可以通过使用`DynamicResource`标记扩展而不是`StaticResource`标记扩展来修复这些“找不到引用”错误，但在这种情况下它不会起作用。这是因为我们只能在`DependencyObject`的`DependencyProperty`上使用它们，而`Converter`属性不是一个`DependencyProperty`，`Binding`类也不是一个`DependencyObject`。
- en: 'Let''s see what our spreadsheet looks like now:'
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在我们的电子表格看起来像什么：
- en: '![](img/57f6f121-0eaa-4d6d-9e52-bf5083725d6f.png)'
  id: totrans-194
  prefs: []
  type: TYPE_IMG
  zh: '![](img/57f6f121-0eaa-4d6d-9e52-bf5083725d6f.png)'
- en: 'As can be seen from the preceding image, we clearly need to add some styling
    to fix some issues and make it look more like a typical spreadsheet:'
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 如前图所示，我们显然需要添加一些样式来修复一些问题，并使其看起来更像一个典型的电子表格：
- en: '[PRE40]'
  id: totrans-196
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: The only thing to note here are the first four `SolidColorBrush` objects that
    we declared. They are used by the .NET Framework to set the default selection
    colors for a number of the built-in controls. We can use them to change the default
    blue background and white text shown in the previous image. There are many more
    of these default colors to be found in the `SystemColors` class, so it's worth
    familiarizing yourself with them.
  id: totrans-197
  prefs: []
  type: TYPE_NORMAL
  zh: 这里需要注意的只有我们声明的第一个四个`SolidColorBrush`对象。.NET Framework使用它们来设置许多内置控件默认的选择颜色。我们可以使用它们来更改之前图像中显示的默认蓝色背景和白色文本。在`SystemColors`类中可以找到更多这些默认颜色，因此熟悉它们是值得的。
- en: 'Let''s see what our spreadsheet looks like now:'
  id: totrans-198
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看现在我们的电子表格看起来像什么：
- en: '![](img/968e19ba-f48e-47ac-9c51-fbeecc315929.png)'
  id: totrans-199
  prefs: []
  type: TYPE_IMG
  zh: '![](img/968e19ba-f48e-47ac-9c51-fbeecc315929.png)'
- en: Now, our `Spreadsheet` control is starting to look more like a typical spreadsheet
    application, but we have no highlighting for our selected cell anymore. You may
    also notice that the row headers are not center-aligned horizontally, as our style
    suggests they should be.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的`Spreadsheet`控件开始看起来更像是一个典型的电子表格应用程序，但我们不再有选中单元格的高亮显示。你也许还会注意到，行标题没有像我们的样式建议的那样水平居中对齐。
- en: This happens because, unlike the default `ControlTemplate` for the `DataGridColumnHeader`
    class, the default `ControlTemplate` for the `DataGridRowHeader` class does not
    map the `HorizontalContentAlignment` property to the `HorizontalAlignment` property
    on any internal elements within the template.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为，与`DataGridColumnHeader`类的默认`ControlTemplate`不同，`DataGridRowHeader`类的默认`ControlTemplate`没有将`HorizontalContentAlignment`属性映射到模板内部任何元素的`HorizontalAlignment`属性。
- en: This might at first seem like an oversight on Microsoft's part, but it is actually
    because, in the default `ControlTemplate`, each `DataGridRowHeader` object has
    an additional control that displays the validation error to the right of the header
    content. With this extra control taking up the limited space, there is not enough
    space to horizontally center the row header.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能最初看起来像是微软的一个疏忽，但实际上是因为，在默认的`ControlTemplate`中，每个`DataGridRowHeader`对象都有一个额外的控件，用于在标题内容右侧显示验证错误。由于这个额外控件占据了有限的空间，因此没有足够的空间水平居中行标题。
- en: To fix this problem, we will need to alter the default `ControlTemplate`, to
    remove the control that displays the error template. Co-incidentally, we will
    also need to alter this template to be able to highlight the selected cell in
    the row header. Likewise, to highlight the selected cell in the column header,
    we will need to adjust the default `ControlTemplate` for the `DataGridColumnHeader`
    class.
  id: totrans-203
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要修改默认的`ControlTemplate`，以移除显示错误模板的控制项。巧合的是，我们还需要修改这个模板，以便能够突出显示行标题中的选定单元格。同样，为了突出显示列标题中的选定单元格，我们需要调整`DataGridColumnHeader`类的默认`ControlTemplate`。
- en: Highlighting the selection
  id: totrans-204
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 突出显示选择
- en: Let’s now move onto the task of highlighting the selected cell. Here, we will
    find out what is required to create a selection rectangle around the selected
    cell, that smoothly animates from selection to selection. But before that, let's
    investigate how we can also indicate which cell is selected in the axes of our
    spreadsheet control.
  id: totrans-205
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来处理突出显示选定单元格的任务。在这里，我们将找出创建围绕选定单元格的选择矩形所需的内容，这个矩形能够平滑地从选择状态过渡到另一个选择状态。但在那之前，让我们研究一下我们如何还能在电子表格控制器的轴上指示哪个单元格被选中。
- en: Indicating in the Axes
  id: totrans-206
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在轴上指示
- en: 'In order to highlight the currently selected cell in the row and column headers,
    we will need to update the two relating default `ControlTemplate` objects, as
    just described. But before we do that, we will need to declare two new `IValueConverter`
    classes as well. Let''s look at the row header converter class first:'
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 为了突出显示行和列标题中的当前选定单元格，我们需要更新前面描述的两个相关默认`ControlTemplate`对象。但在我们这样做之前，我们还需要声明两个新的`IValueConverter`类。让我们首先看看行标题转换器类：
- en: '[PRE41]'
  id: totrans-208
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: For this converter, we extend the `IMultiValueConverter` interface, and in the
    `Convert` method, we first validate our values input parameter. If it is `null`,
    contains more or less than two objects, or if either of the contained objects
    are not non-`null` `DataRow` objects, we return `false`. If the input parameter
    is valid, we use C# 6.0 Pattern Matching to cast the two contained objects to
    the `DataRow` type.
  id: totrans-209
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个转换器，我们扩展了`IMultiValueConverter`接口，并在`Convert`方法中，我们首先验证我们的值输入参数。如果它是`null`，包含的对象多于或少于两个，或者如果包含的对象中的任何一个不是非`null`的`DataRow`对象，我们返回`false`。如果输入参数有效，我们使用C#
    6.0模式匹配将两个包含的对象转换为`DataRow`类型。
- en: The first represents the `DataRow` object that contains the currently selected
    cell and the second comes from the `DataRow` object to compare. We return `true`
    if the selected `DataRow` object equals the currently compared `DataRow` object
    and `false` for all others. You can think of this as each row header asking the
    converter in turn, if it is in the same `DataRow` object as the currently selected
    cell. The `ConvertBack` method is unrequired for our example and so, is left unimplemented.
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 第一个表示包含当前选定单元格的`DataRow`对象，第二个来自用于比较的`DataRow`对象。如果选定的`DataRow`对象等于当前比较的`DataRow`对象，我们返回`true`，对于所有其他对象返回`false`。你可以把这想成每一行标题依次询问转换器，它是否与当前选定的单元格在同一个`DataRow`对象中。对于我们的示例，`ConvertBack`方法是不需要的，因此留空未实现。
- en: Let's now investigate the changes that we need to make to the default `ControlTemplate`
    for the `DataGridRowHeader` class. As described in *[Chapter 5](d5906090-c679-45d6-81cd-016d4337eb75.xhtml),
    Using the Right Controls for the Job*, in the *Modifying Existing Controls* section,
    we can create a copy of the default `ControlTemplate` from the Properties panel
    in Visual Studio. Note that if we do not already have a control of the correct
    type in our XAML file, we can simply declare one temporarily, select it, then
    continue with the process of template extraction as described, remembering to
    delete it afterwards.
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来研究我们需要对`DataGridRowHeader`类的默认`ControlTemplate`所做的更改。如*[第5章](d5906090-c679-45d6-81cd-016d4337eb75.xhtml)，使用正确的控件完成任务*中所述，在*修改现有控件*部分，我们可以从Visual
    Studio的属性面板中创建默认`ControlTemplate`的副本。请注意，如果我们XAML文件中还没有正确类型的控件，我们可以简单地临时声明一个控件，选择它，然后继续按照描述的模板提取过程，记得之后删除它。
- en: 'As this template is quite long, we won''t show it all here, instead highlighting
    just the areas that we need to change. The entire code will be available in the
    separate downloadable code bundle that comes with this book. Before we can use
    this template however, we need to add a reference to the `PresentationFramework.Aero`
    assembly to our project and a XAML Namespace for the `Microsoft.Windows.Themes`
    CLR Namespace:'
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 由于这个模板相当长，我们在这里不会展示全部内容，而是仅突出显示我们需要更改的区域。整个代码将在本书附带的可下载代码包中提供。然而，在我们可以使用此模板之前，我们需要将`PresentationFramework.Aero`程序集的引用添加到我们的项目中，并为`Microsoft.Windows.Themes`
    CLR 命名空间添加一个 XAML 命名空间：
- en: 'Next, we need to add an instance of our new converter class into our spreadsheet
    control''s `Resources` section:'
  id: totrans-213
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要在我们的电子表格控制的`Resources`部分添加我们新的转换器类的实例：
- en: '[PRE42]'
  id: totrans-214
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: 'Now, let''s see the template:'
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看模板：
- en: '[PRE43]'
  id: totrans-216
  prefs: []
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'In order to apply the template, we''ll need to add another `Setter` element
    into our `Style` for the `DataGridRowHeader` class, making sure that the template
    is declared before it in the XAML:'
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用模板，我们需要在我们的`DataGridRowHeader`类的`Style`中添加另一个`Setter`元素，确保在XAML中先声明模板：
- en: '[PRE44]'
  id: totrans-218
  prefs: []
  type: TYPE_PRE
  zh: '[PRE44]'
- en: After attaining a copy of the default `ControlTemplate` for the `DataGridRowHeader`
    class, we first named the `DataGridHeaderBorder` element `Border`, so that we
    could refer to it from the template's `Triggers` collection. We also set its `IsHitTestVisible`
    property to `False` to prevent selection from the row headers.
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: 在获得`DataGridRowHeader`类的默认`ControlTemplate`副本后，我们首先将`DataGridHeaderBorder`元素命名为`Border`，这样我们就可以从模板的`Triggers`集合中引用它。我们还将其`IsHitTestVisible`属性设置为`False`，以防止从行标题中选择。
- en: We then removed the control that displayed the validation error template and
    connected the `HorizontalAlignment` property of the internal `ContentPresenter`
    element with the `HorizontalContentAlignment` property of the parent `DataGridRowHeader`
    object via a `TemplateBinding` element, so that our style will actually center
    the header content, as previously expected.
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们删除了显示验证错误模板的控制，并通过`TemplateBinding`元素将内部`ContentPresenter`元素的`HorizontalAlignment`属性与父`DataGridRowHeader`对象的`HorizontalContentAlignment`属性连接起来，以便我们的样式实际上会居中标题内容，正如之前所期望的那样。
- en: Next, we added a new `Rectangle` element, named `ColorSelectionBar`, and a `DataTrigger`
    object. The `Rectangle` element has its `Fill` property set to `Transparent`,
    so that it cannot initially be seen, and its `IsHitTestVisible` property set to
    `False`, to prevent users from being able to interact with it.
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们添加了一个新的`Rectangle`元素，命名为`ColorSelectionBar`，以及一个`DataTrigger`对象。`Rectangle`元素将其`Fill`属性设置为`Transparent`，因此最初无法看到它，并将其`IsHitTestVisible`属性设置为`False`，以防止用户与之交互。
- en: We set its `VerticalAlignment` property to `Stretch`, so that it spans the full
    height of the row header, and its `HorizontalAlignment` property to `Right`, to
    ensure that it lies to the right of the header, out of the way of the row indicator.
    Finally, we set its top margin to `-1`, in order to extend it over the top border
    of the header, as it already extends over the bottom border by one pixel.
  id: totrans-222
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其`VerticalAlignment`属性设置为`Stretch`，以便它跨越整个行标题的高度，并将其`HorizontalAlignment`属性设置为`Right`，以确保它位于标题的右侧，避开行指示器。最后，我们将其上边距设置为`-1`，以便将其扩展到标题的顶部边界，因为它已经通过一个像素扩展到底部边界。
- en: We then added a `DataTrigger` object into the `Triggers` collection, using a
    `MultiBinding` object to define its conditions. We assigned our `DataGridRowHeaderSelectionMultiConverter`
    instance to the `Converter` property of the `MultiBinding` object.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们在`Triggers`集合中添加了一个`DataTrigger`对象，使用`MultiBinding`对象来定义其条件。我们将我们的`DataGridRowHeaderSelectionMultiConverter`实例分配给`MultiBinding`对象的`Converter`属性。
- en: 'Note that the `MultiBinding` object has two bindings: one is the `DataRow`
    object that relates to the `CurrentCell` property of the `DataGrid` control and
    the other is set directly to the `DataRow` object that the template is applied
    to.'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`MultiBinding`对象有两个绑定：一个是与`DataGrid`控制的`CurrentCell`属性相关的`DataRow`对象，另一个直接设置为应用于模板的`DataRow`对象。
- en: When the converter returns `true`, we paint the `ColorSelectionBar` element
    and the header foreground with our `SelectionBrush` brush and the `Border` element,
    which represents the background of the row header, with the `SelectedBackgroundBrush`
    brush. This results in the row header of the selected cell being highlighted each
    time a cell is selected.
  id: totrans-225
  prefs: []
  type: TYPE_NORMAL
  zh: 当转换器返回`true`时，我们使用我们的`SelectionBrush`画笔绘制`ColorSelectionBar`元素和标题前景，以及表示行标题背景的`Border`元素，使用`SelectedBackgroundBrush`画笔。这导致每次选择单元格时，所选单元格的行标题都会被突出显示。
- en: 'Let''s now do the same for the column headers, starting with a look at the
    required `DataGridColumnHeaderSelectionMultiConverter` class:'
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们现在为列标题做同样的事情，从查看所需的 `DataGridColumnHeaderSelectionMultiConverter` 类开始：
- en: '[PRE45]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE45]'
- en: We again extend the `IMultiValueConverter` interface, and in the `Convert` method,
    we start by checking the input values to ensure their validity for this converter.
    We validate that the `values` input parameter is not `null` and that it contains
    two non-`null` values, that are also not unset values. If any of these checks
    fail, we return `false`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 我们再次扩展了 `IMultiValueConverter` 接口，并在 `Convert` 方法中，我们首先检查输入值以确保它们对于此转换器的有效性。我们验证
    `values` 输入参数不是 `null`，并且它包含两个非 `null` 值，这些值也不是未设置值。如果这些检查中的任何一个失败，我们返回 `false`。
- en: If the `values` input parameter is valid, we call the `object.ToString` method
    on the two objects contained within it. The first value represents the text in
    the selected column header and the second represents the text in the column header
    to compare.
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 如果 `values` 输入参数有效，我们将在其中包含的两个对象上调用 `object.ToString` 方法。第一个值表示所选列标题中的文本，第二个表示要比较的列标题中的文本。
- en: Every column header will call this converter in turn and if the column header
    to compare equals the selected column header, that signifies that it is the column
    that contains the selected cell and we return `true`, otherwise we return `false`.
    As the `ConvertBack` method is unrequired for this example, it is left unimplemented.
  id: totrans-230
  prefs: []
  type: TYPE_NORMAL
  zh: 每个列标题将依次调用此转换器，如果要比较的列标题等于选定的列标题，则表示它是包含所选单元格的列，我们返回 `true`，否则返回 `false`。由于
    `ConvertBack` 方法对于此示例不是必需的，因此它被留空未实现。
- en: 'Before we alter the default `ControlTemplate` for the `DataGridColumnHeader`
    class, we will need to add a reference to our new `converter` class into our spreadsheet
    control''s `Resources` section:'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们修改 `DataGridColumnHeader` 类的默认 `ControlTemplate` 之前，我们需要将我们的新 `converter`
    类引用添加到我们的电子表格控件中的 `Resources` 部分中：
- en: '[PRE46]'
  id: totrans-232
  prefs: []
  type: TYPE_PRE
  zh: '[PRE46]'
- en: 'Now, let''s see the edited template:'
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看编辑后的模板：
- en: '[PRE47]'
  id: totrans-234
  prefs: []
  type: TYPE_PRE
  zh: '[PRE47]'
- en: Starting with the default `ControlTemplate` for the `DataGridColumnHeader` class,
    we again added a single UI element and a single `DataTrigger` object, with which
    to control its visibility, as we did with our custom `DataGridRowHeader` `ControlTemplate`.
    However, this template requires less alteration, as its header is already centered
    and we do not need to remove any elements.
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 从 `DataGridColumnHeader` 类的默认 `ControlTemplate` 开始，我们再次添加了一个 UI 元素和一个 `DataTrigger`
    对象，用于控制其可见性，就像我们为自定义的 `DataGridRowHeader` `ControlTemplate` 所做的那样。然而，此模板需要更少的修改，因为其标题已经居中，我们不需要删除任何元素。
- en: Once again, the `Rectangle` object named `ColorSelectionBar` is the new element.
    Note that we set its `Fill` property to `Transparent`, so that it cannot initially
    be seen. Remember that there is a column header on every column and we don't want
    them all to be highlighted at once.
  id: totrans-236
  prefs: []
  type: TYPE_NORMAL
  zh: 再次强调，名为 `ColorSelectionBar` 的 `Rectangle` 对象是新的元素。请注意，我们将其 `Fill` 属性设置为 `Transparent`，这样它最初是不可见的。记住，每一列都有一个列标题，我们不希望它们同时都被突出显示。
- en: We set the `Rectangle` element's `IsHitTestVisible` property to `False`, to
    prevent users from being able to interact with it. We set its `HorizontalAlignment`
    property to `Stretch`, so that it spans the full width of the column header, regardless
    of its size, and its `VerticalAlignment` property to `Bottom` to ensure that it
    lies at the bottom of the header, leaving space for the column identifier.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Rectangle` 元素的 `IsHitTestVisible` 属性设置为 `False`，以防止用户与其交互。我们将它的 `HorizontalAlignment`
    属性设置为 `Stretch`，以便它跨越列标题的全宽，无论其大小如何，并将它的 `VerticalAlignment` 属性设置为 `Bottom`，以确保它位于标题的底部，为列标识符留出空间。
- en: We set its left margin to `-1`, in order to extend it over the left border of
    the header, as it already extends over the right border by one pixel. In the `Triggers`
    section of the `ControlTemplate`, we added a `DataTrigger` object, with a `MultiBinding`
    object that has a reference to our `DataGridColumnHeaderSelectionMultiConverter`
    class set to its `Converter` property.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其左外边距设置为 `-1`，以便它扩展到标题的左侧边界，因为它已经通过一个像素扩展到右侧边界。在 `ControlTemplate` 的 `Triggers`
    部分中，我们添加了一个 `DataTrigger` 对象，它具有一个 `MultiBinding` 对象，该对象将我们的 `DataGridColumnHeaderSelectionMultiConverter`
    类引用设置为它的 `Converter` 属性。
- en: 'Note that we have two `Binding` elements connected to it: one is set to the
    `Header` property of the currently selected `Column` object and the other is set
    directly to the `Content` property of the `DataGridColumnHeader` class. Each column
    header will call the converter in turn and if you remember, the column that contains
    the selected cell will result in the converter returning `true`.'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们有两个 `Binding` 元素连接到它：一个设置为当前选中 `Column` 对象的 `Header` 属性，另一个直接设置为 `DataGridColumnHeader`
    类的 `Content` 属性。每个列标题将依次调用转换器，如果您还记得，包含选中单元格的列将导致转换器返回 `true`。
- en: When the `MultiBinding` object that is connected to this converter returns `true`,
    the `DataTrigger` `Setter` fills the header foreground and the `ColorSelectionBar`
    rectangle with the `SelectionBrush` resource and the background of the header
    with the `SelectedBackground` resource, highlighting the column header of the
    currently selected cell.
  id: totrans-240
  prefs: []
  type: TYPE_NORMAL
  zh: 当连接到此转换器的 `MultiBinding` 对象返回 `true` 时，`DataTrigger` 的 `Setter` 会用 `SelectionBrush`
    资源填充标题前景和 `ColorSelectionBar` 矩形，并用 `SelectedBackground` 资源填充标题的背景，从而突出显示当前选中单元格的列标题。
- en: 'In order to apply this `ControlTemplate` object, we''ll also need to add a
    `Setter` element into our `Style` for the `DataGridColumnHeader` class, making
    sure that the template declaration is before the `Style` declaration in the XAML:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 为了应用这个 `ControlTemplate` 对象，我们还需要在我们的 `Style` 中为 `DataGridColumnHeader` 类添加一个
    `Setter` 元素，确保模板声明在 `Style` 声明之前，在 XAML 中：
- en: '[PRE48]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE48]'
- en: 'As you can see, we have made minimal changes to the two default `ControlTemplate`
    objects, yet we have managed to adapt them to our purposes. In this way, we are
    able to manipulate the built-in .NET controls, to further extend their original
    usefulness. Let''s see the visual output from this latest addition to our code:'
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，我们对两个默认的 `ControlTemplate` 对象进行了最小程度的修改，但我们已经成功地使它们适应了我们的目的。通过这种方式，我们能够操纵内置的
    .NET 控件，进一步扩展它们原有的用途。让我们看看我们代码的最新添加部分的视觉输出：
- en: '![](img/ce0be1cf-7f18-4517-98ee-9ecfb2dde47b.png)'
  id: totrans-244
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ce0be1cf-7f18-4517-98ee-9ecfb2dde47b.png)'
- en: We now have a grid that is starting to look more like a typical spreadsheet
    application. Let's continue and add cell selection highlights for the users.
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们有一个网格，开始看起来更像是一个典型的电子表格应用程序。让我们继续并添加用户的选择突出显示。
- en: Emphasizing the Selection
  id: totrans-246
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 强调选择
- en: 'All that is left for us to do now is to implement the selection rectangle and
    the style for the Select All button in the top left corner of the control. We
    can accomplish both tasks by adjusting the default `ControlTemplate` for the `DataGrid`
    class. Let''s break this down into steps. First, we need to add a `ControlTemplate`
    for the Select All button into our `Resources` section:'
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们唯一要做的就是实现选择矩形和位于控件右上角的“全选”按钮的样式。我们可以通过调整 `DataGrid` 类的默认 `ControlTemplate`
    来完成这两个任务。让我们将其分解为步骤。首先，我们需要在我们的 `Resources` 部分添加一个 `ControlTemplate` 用于“全选”按钮：
- en: '[PRE49]'
  id: totrans-248
  prefs: []
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, we have another very simple template, where we replace the default definition
    of a `Button` control with a basic triangle. It contains a `Border` element, that
    draws its right and bottom borders with the `DiagonalBorderGradient` brush that
    we added to the spreadsheet control's resources. It also paints the background
    of the `Button` control with our `BackgroundBrush` resource.
  id: totrans-249
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，我们有一个非常简单的模板，其中我们用基本三角形替换了 `Button` 控件的默认定义。它包含一个 `Border` 元素，使用我们添加到电子表格控件资源中的
    `DiagonalBorderGradient` 画笔绘制其右侧和底部边框。它还用我们的 `BackgroundBrush` 资源绘制 `Button` 控件的背景。
- en: Within the `Border` element, we declare a `Polygon` shape, which we fill with
    a gray brush. Its shape is determined by the values declared in its `Points` property,
    so it begins at `0,12`, continues to `12,12` , and `12,0`, before returning to
    `0,12`. Plotting these values on a graph would show a triangle and that is the
    shape that this `Polygon` element will render.
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 在 `Border` 元素内部，我们声明了一个 `Polygon` 形状，并用灰色画笔填充它。其形状由其 `Points` 属性中声明的值决定，因此它从
    `0,12` 开始，继续到 `12,12`，然后到 `12,0`，最后返回到 `0,12`。将这些值绘制在图上会显示一个三角形，这就是 `Polygon`
    元素将要渲染的形状。
- en: We align it to the bottom right of the `Border` element and set its `Stretch`
    property to `Uniform` to ensure that its aspect ratio is maintained throughout
    any changes of its size. Finally, we set its `Margin` property to space it away
    from the `Border` element's edge.
  id: totrans-251
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将其对齐到 `Border` 元素的右下角，并将其 `Stretch` 属性设置为 `Uniform` 以确保在大小变化时保持其纵横比。最后，我们将其
    `Margin` 属性设置为与 `Border` 元素的边缘保持一定的空间。
- en: 'Next, we need to apply the `SelectAllButtonControlTemplate` template to the
    Select All button and add a transparent `Canvas` element into the `ControlTemplate`
    for the `ScrollViewer` object that appears inside the default `ControlTemplate`
    for the `DataGrid` class. Let''s extract this from the default template and declare
    it in our `Resources` section too:'
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要将 `SelectAllButtonControlTemplate` 模板应用到全选按钮上，并在 `DataGrid` 类的默认 `ControlTemplate`
    中添加一个透明的 `Canvas` 元素，该元素将出现在 `ScrollViewer` 对象内部。让我们从默认模板中提取这部分，并在我们的 `Resources`
    部分中声明它：
- en: '[PRE50]'
  id: totrans-253
  prefs: []
  type: TYPE_PRE
  zh: '[PRE50]'
- en: We first set a width and height of 26 pixels on the Select All button, in line
    with the dimensions of our row and column headers. We then apply our `ControlTemplate`
    from the `Resources` section to it. We also removed the `Visibility` binding from
    the default template, as we won't be needing that in our example. Note that this
    button has no action in our example and is purely decorative.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 我们首先将全选按钮的宽度和高度设置为 26 像素，与我们的行和列标题的尺寸相匹配。然后，我们将 `Resources` 部分中的 `ControlTemplate`
    应用到它上。我们还从默认模板中移除了 `Visibility` 绑定，因为在我们的示例中我们不需要它。请注意，在这个示例中，这个按钮没有任何动作，纯粹是装饰性的。
- en: Next, we added the transparent `Canvas` control, that will display the selection
    rectangle, within a `Border` element. Note that we must add it after the required
    `PART_ScrollContentPresenter` named part, to ensure that the selection rectangle
    will appear above the cells in the Z plane. Also, notice that we must wrap it
    in an invisible `Border` element, so that we can clip its bounds. Try removing
    the `ClipToBounds` property and resize the control to be smaller as an experiment
    to see what happens.
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们在 `Border` 元素内添加了透明的 `Canvas` 控件，该控件将显示选择矩形。请注意，我们必须在名为 `PART_ScrollContentPresenter`
    的必需部分之后添加它，以确保选择矩形将出现在单元格的 Z 轴上方。此外，请注意，我们必须将其包裹在一个不可见的 `Border` 元素中，这样我们就可以剪切它的边界。尝试移除
    `ClipToBounds` 属性并缩小控件的大小作为一个实验，看看会发生什么。
- en: We set the `Margin` property on the `Border` element to be `-2` in all directions,
    so that it can display the selection rectangle over and just outside the bounds
    of each cell. We, therefore, need to set the `Margin` property on the `Canvas`
    that draws the rectangle to `2` in all directions, to compensate for the border's
    negative margin.
  id: totrans-256
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将 `Border` 元素的 `Margin` 属性设置为所有方向上的 `-2`，以便它可以在每个单元格的边界内和边界外显示选择矩形。因此，我们需要将绘制矩形的
    `Canvas` 的 `Margin` 属性在所有方向上设置为 `2`，以补偿边界的负边距。
- en: We name the `Canvas` element, so that we can access it from the code behind,
    and set its `Background` property to `null`, which is slightly cheaper than setting
    it to `Transparent`. We then set the `IsHitTestVisible` property to `False`, to
    make it invisible to the users and their mouse cursors and center the origin of
    the render transform, which we will use to update the position of the `Canvas`
    element each time the containing `ScrollViewer` object is moved.
  id: totrans-257
  prefs: []
  type: TYPE_NORMAL
  zh: 我们给 `Canvas` 元素命名，以便我们可以从代码后面访问它，并将其 `Background` 属性设置为 `null`，这比设置为 `Transparent`
    稍微便宜一些。然后，我们将 `IsHitTestVisible` 属性设置为 `False`，使其对用户和他们的鼠标光标不可见，并将渲染变换的原点居中，我们将使用它来更新包含的
    `ScrollViewer` 对象每次移动时 `Canvas` 元素的位置。
- en: 'Let''s see our simplified `ControlTemplate` for the `DataGrid` class now:'
  id: totrans-258
  prefs: []
  type: TYPE_NORMAL
  zh: 现在让我们看看 `DataGrid` 类的简化 `ControlTemplate`：
- en: '[PRE51]'
  id: totrans-259
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: We made a few changes to the default `ControlTemplate` for the `DataGrid` control.
    The first was to set the `CanContentScroll` property to `False` on the `ScrollViewer`
    element named `DG_ScrollViewer`, to make it scroll in physical units (pixels)
    instead of logical units (rows). The only other change was to replace its inline
    `ControlTemplate` object with a reference to the custom template that we added
    into the `Resources` section.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对 `DataGrid` 控件的默认 `ControlTemplate` 进行了一些更改。首先，我们将名为 `DG_ScrollViewer` 的
    `ScrollViewer` 元素的 `CanContentScroll` 属性设置为 `False`，使其在物理单位（像素）而不是逻辑单位（行）中滚动。唯一的其他更改是将它的内联
    `ControlTemplate` 对象替换为我们在 `Resources` 部分中添加的自定义模板的引用。
- en: 'We must also remember to assign this custom `ControlTemplate` object to our
    spreadsheet control. This can be achieved in the class declaration:'
  id: totrans-261
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还必须记住将这个自定义的 `ControlTemplate` 对象分配给我们的电子表格控件。这可以在类声明中实现：
- en: '[PRE52]'
  id: totrans-262
  prefs: []
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'Now, let''s see our `Spreadsheet` control again, with all the latest changes:'
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们再次看看我们的 `电子表格` 控件，并查看所有最新的更改：
- en: '![](img/7c7201f5-8745-48c0-8415-b0f3ac0b159e.png)'
  id: totrans-264
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/7c7201f5-8745-48c0-8415-b0f3ac0b159e.png)'
- en: We can see that the job is nearly complete. We now have the XAML all set up
    to display the selection rectangle, but we still need to programmatically position
    and animate it. First, we'll need to attain a reference to the `Scrollviewer`
    from our custom `DataGrid` template.
  id: totrans-265
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以看到工作几乎完成了。我们现在已经设置了所有XAML以显示选择矩形，但我们仍然需要通过编程方式定位和动画化它。首先，我们需要从我们的自定义`DataGrid`模板中获取对`Scrollviewer`的引用。
- en: 'We can achieve this by overriding another method from the `DataGrid` base class.
    The `OnApplyTemplate` method is called whenever a `ControlTemplate` is applied,
    so it''s an ideal location to access the elements contained within it:'
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以通过重写`DataGrid`基类中的另一个方法来实现这一点。`OnApplyTemplate`方法在应用`ControlTemplate`时被调用，因此它是一个访问其中包含的元素的理想位置：
- en: '[PRE53]'
  id: totrans-267
  prefs: []
  type: TYPE_PRE
  zh: '[PRE53]'
- en: In this method, we call the `FindName` method on the `Spreadsheet` control's
    template, passing in the name of our `ScrollViewer` object and a reference to
    the spreadsheet, as the templated parent. We then cast the returned object to
    a `ScrollViewer`, using the `as` operator keyword, to avoid exceptions being thrown.
  id: totrans-268
  prefs: []
  type: TYPE_NORMAL
  zh: 在此方法中，我们在`Spreadsheet`控件模板上调用`FindName`方法，传入我们的`ScrollViewer`对象名称和作为模板父级的`Spreadsheet`引用。然后，我们使用`as`运算符关键字将返回的对象强制转换为`ScrollViewer`，以避免抛出异常。
- en: Note that as this spreadsheet example is quite long, we have omitted the usual
    `null` checks, with regards to accessing the internal controls from the `ControlTemplate`
    elements. In a real-world application, these checks should always be implemented,
    as we can never be sure that our required elements will be in the template, because
    it may have been changed.
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，由于此电子表格示例相当长，我们省略了通常的`null`检查，关于从`ControlTemplate`元素访问内部控件。在实际应用中，这些检查始终应该实现，因为我们永远不能确定我们的所需元素是否在模板中，因为模板可能已被更改。
- en: 'Next, we need a reference to the `Canvas` panel that we will draw our selection
    rectangle on:'
  id: totrans-270
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们需要一个引用到我们将绘制选择矩形的`Canvas`面板：
- en: '[PRE54]'
  id: totrans-271
  prefs: []
  type: TYPE_PRE
  zh: '[PRE54]'
- en: In the `SpreadsheetScrollViewer_ScrollChanged` event handler, we start by checking
    if the `selectionRectangleCanvas` private variable is `null`. If it is, we call
    the `GetCanvasReference` method, to attain a reference to it and to assign it
    to a private member variable.
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 在`SpreadsheetScrollViewer_ScrollChanged`事件处理程序中，我们首先检查`selectionRectangleCanvas`私有变量是否为`null`。如果是，我们调用`GetCanvasReference`方法，以获取对其的引用并将其分配给一个私有成员变量。
- en: In the `GetCanvasReference` method, we access the `ControlTemplate` object from
    the `Template` property of the `ScrollViewer` element that we previously stored
    a reference to. We call the `FindName` method on it, passing in the name of our
    `Canvas` object and a reference to the `ScrollViewer` element, as its templated
    parent.
  id: totrans-273
  prefs: []
  type: TYPE_NORMAL
  zh: 在`GetCanvasReference`方法中，我们从之前存储引用的`ScrollViewer`元素的`Template`属性中访问`ControlTemplate`对象。我们调用其上的`FindName`方法，传入我们的`Canvas`对象名称和作为其模板父级的`ScrollViewer`元素引用。
- en: We then assign the returned object, cast to the `Canvas` type, to the private
    `selectionRectangleCanvas` member variable and set a new `TranslateTransform`
    object to its `RenderTransform` property. We will use this to update the position
    of the `Canvas` element each time the containing `ScrollViewer` object's viewport
    is moved, and this will ensure that the selection rectangle will be scrolled,
    along with the spreadsheet.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们将返回的对象（转换为`Canvas`类型）分配给私有的`selectionRectangleCanvas`成员变量，并设置一个新的`TranslateTransform`对象到其`RenderTransform`属性。我们将使用它来更新包含`ScrollViewer`对象的视口每次移动时`Canvas`元素的位置，这将确保选择矩形会随着工作表一起滚动。
- en: Note that we attain a reference to the `Canvas` element from this event handler
    only in an attempt to shorten this example. A far better solution would be to
    extend the `ScrollViewer` class and declare a `TemplateChanged` event, that passed
    a reference of the new template in a custom `EventArgs` class.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们仅在此事件处理程序中获取`Canvas`元素的引用是为了简化示例。一个更好的解决方案是扩展`ScrollViewer`类并声明一个`TemplateChanged`事件，该事件通过自定义`EventArgs`类传递新模板的引用。
- en: We could raise it from an overridden `OnApplyTemplate` method, as we did to
    access our `ScrollViewer` reference, and subscribe to it from our `Spreadsheet`
    class. The problem with our current implementation is that the `ScrollChanged`
    event is raised many times and each time, we check if we already have the reference
    and so a lot of CPU cycles will be wasted when scrolling.
  id: totrans-276
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以从重写的`OnApplyTemplate`方法中引发它，就像我们访问我们的`ScrollViewer`引用一样，并从我们的`Spreadsheet`类中订阅它。我们当前实现的问题在于`ScrollChanged`事件被多次引发，每次引发时，我们都会检查是否已经有了引用，因此在滚动时会有大量的CPU周期浪费。
- en: 'Returning to the current implementation now, let''s assign our event handler
    for the `ScrollChanged` event to the `ScrollViewer` in our custom template for
    the `DataGrid` class:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到当前实现，让我们将我们的`ScrollChanged`事件处理程序分配给`ScrollViewer`，在我们的`DataGrid`类的自定义模板中：
- en: '[PRE55]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE55]'
- en: 'Let''s now investigate the code that is used to draw and animate the selection
    rectangle:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们调查用于绘制和动画化选择矩形的代码：
- en: '[PRE56]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: In the `UpdateSelectionRectangle` method, we first declare a duration of 150
    ms to use in our animations and check if the selection rectangle has been initialized
    or not. If it hasn't, we call the `InitializeSelectionRectangle` method, passing
    the `startPosition` and `endPosition` input parameters through. Let's examine
    this method before continuing.
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 在`UpdateSelectionRectangle`方法中，我们首先声明一个150毫秒的持续时间用于我们的动画，并检查选择矩形是否已经初始化。如果没有，我们调用`InitializeSelectionRectangle`方法，通过传入`startPosition`和`endPosition`输入参数。在继续之前，让我们检查这个方法。
- en: In the `InitializeSelectionRectangle` method, we initialize the `SelectionRectangle`
    element, with dimensions calculated from the two `Point` input parameters and
    default values for its stroke. We assign a new `TranslateTransform` object to
    its `RenderTransform` property, to enable its position to be manipulated in code.
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 在`InitializeSelectionRectangle`方法中，我们使用从两个`Point`输入参数计算出的尺寸初始化`SelectionRectangle`元素，并为其stroke设置默认值。我们将一个新的`TranslateTransform`对象分配给其`RenderTransform`属性，以便在代码中操作其位置。
- en: We then use the `SetTop` and `SetLeft` Attached Properties of the `Canvas` class
    to position the rectangle in the top left corner of the `Canvas` panel, that we
    added into our custom `ControlTemplate` for the `ScrollViewer` class.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们使用`Canvas`类的`SetTop`和`SetLeft`附加属性来定位矩形，将其放置在我们为`ScrollViewer`类添加的自定义`ControlTemplate`中的`Canvas`面板的左上角。
- en: We end by adding the `SelectionRectangle` element into the `Children` collection
    of the `selectionRectangleCanvas` panel and setting the `isSelectionRectangleInitialized`
    variable to `true`, to ensure that this initialization code is only called once.
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 我们通过将`SelectionRectangle`元素添加到`selectionRectangleCanvas`面板的`Children`集合中，并将`isSelectionRectangleInitialized`变量设置为`true`来结束操作，以确保初始化代码只被调用一次。
- en: Returning to the `UpdateSelectionRectangle` method now, if the selection rectangle
    has already been initialized, then we animate its size, from the size of the previous
    cell to the size of the newly selected cell, using the `startPosition` and `endPosition`
    input parameters.
  id: totrans-285
  prefs: []
  type: TYPE_NORMAL
  zh: 返回到`UpdateSelectionRectangle`方法，如果选择矩形已经初始化，那么我们使用`startPosition`和`endPosition`输入参数来动画化其大小，从之前单元格的大小过渡到新选中单元格的大小。
- en: We call the `BeginAnimation` method on the `SelectionRectangle` element for
    both its `WidthProperty` and `HeightProperty` dependency properties, so that the
    dimensions of the rectangle will smoothly animate from the size of the previously
    selected cell to the size of the new one.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 我们对`SelectionRectangle`元素的`WidthProperty`和`HeightProperty`依赖属性调用`BeginAnimation`方法，这样矩形的尺寸将平滑地从之前选中单元格的大小动画过渡到新单元格的大小。
- en: Next, we access the `TranslateTransform` instance from the `RenderTransform`
    property of the `SelectionRectangle` element and call the `BeginAnimation` method
    on it, for both the `Xproperty` and `Yproperty` Dependency Properties. This is
    what animates the position of the selection rectangle on the `Canvas` that we
    added into the `ScrollViewer` element's template.
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们从`SelectionRectangle`元素的`RenderTransform`属性中访问`TranslateTransform`实例，并对其调用`BeginAnimation`方法，针对`Xproperty`和`Yproperty`依赖属性。这正是我们在`ScrollViewer`元素模板中添加的`Canvas`上动画化选择矩形位置的方式。
- en: To calculate the horizontal position, we subtract the value of the `RowHeaderWidth`
    property, that we set earlier in the XAML class declaration, from the `X` property
    value of the `startPosition` input parameter and then add the value of the `HorizontalOffset`
    property of the `ScrollViewer` element.
  id: totrans-288
  prefs: []
  type: TYPE_NORMAL
  zh: 为了计算水平位置，我们从`startPosition`输入参数的`X`属性值中减去之前在XAML类声明中设置的`RowHeaderWidth`属性值，然后加上`ScrollViewer`元素的`HorizontalOffset`属性值。
- en: Likewise, the vertical position is calculated from the `Y` property value of
    the `startPosition` input parameter, with the value of the `ColumnHeaderHeight`
    property subtracted from it and the value of the `VerticalOffset` property of
    the `ScrollViewer` element added to it.
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，垂直位置是通过从`startPosition`输入参数的`Y`属性值中减去`ColumnHeaderHeight`属性值，并加上`ScrollViewer`元素的`VerticalOffset`属性值来计算的。
- en: All four animations share the same duration, that we declared at the start,
    so that they morph the dimensions and position of our selection rectangle in unison.
    They also all set a `HandoffBehavior` value of `Compose`, which basically provides
    smoother joins between consecutive animations. We'll discover more about this
    in *[Chapter 7](83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml), Mastering Practical
    Animations,* but for now, we'll keep it simple.
  id: totrans-290
  prefs: []
  type: TYPE_NORMAL
  zh: 四个动画共享相同的持续时间，我们在开始时声明了它，所以它们可以统一地改变选择矩形的尺寸和位置。它们还都设置了`HandoffBehavior`值为`Compose`，这基本上提供了连续动画之间的更平滑的连接。我们将在*[第7章](83362be0-c3e7-4f3c-89b9-74104ac23f5d.xhtml)，掌握实用动画*中了解更多关于这个，但现在我们将保持简单。
- en: So, our `UpdateSelectionRectangle` method is responsible for animating the selection
    rectangle between the previous and current cell selections, *but where is it called
    from?* That's right... we're going to call it from yet another overridden protected
    base class method.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们的`UpdateSelectionRectangle`方法负责在先前和当前单元格选择之间动画化选择矩形，*但是它从哪里被调用呢？*没错...我们将从另一个重写的受保护基类方法中调用它。
- en: 'Looking through the protected base class methods of the `DataGrid` class, we
    find the `OnSelectedCellsChanged` method, which is called each time a user selects
    a new cell in our spreadsheet control, so it''s the perfect candidate. Let''s
    take a look at its implementation now:'
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 通过查看`DataGrid`类的受保护基类方法，我们发现`OnSelectedCellsChanged`方法，它在用户在我们的工作表控件中选择新单元格时被调用，所以它是完美的候选者。现在让我们看看它的实现：
- en: '[PRE57]'
  id: totrans-293
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: Note that the base class version of this method is responsible for raising the
    `SelectedCellsChanged` event, so if we need that to happen, we should call it
    from this method. If we are ever in doubt if to call the base class version of
    a method that we're overriding, it's generally safer to do so, as we might lose
    some required functionality that it provides otherwise. As we do not require this
    event in this example however, we can safely omit the call to the base class method.
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，这个方法的基类版本负责引发`SelectedCellsChanged`事件，所以如果我们需要它发生，我们应该从这个方法中调用它。如果我们对是否调用我们正在重写的基类版本的方法有疑问，通常更安全的是这样做，因为我们可能会丢失它提供的某些必需功能。然而，在这个例子中，我们不需要这个事件，所以我们可以安全地省略对基类方法的调用。
- en: In our overridden `OnSelectedCellsChanged` method, we check that the `AddedCells`
    property of the `SelectedCellsChangedEventArgs` input parameter contains exactly
    one item. Note that in this example, it should only ever contain a single item,
    because we set the `SelectionMode` property to `Single` on our spreadsheet control,
    but it is always good practice to validate these things.
  id: totrans-295
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们重写的`OnSelectedCellsChanged`方法中，我们检查`SelectedCellsChangedEventArgs`输入参数的`AddedCells`属性是否恰好包含一个项目。请注意，在这个例子中，它应该只包含一个项目，因为我们已经将我们的工作表控件的`SelectionMode`属性设置为`Single`，但始终验证这些事情是一个好的做法。
- en: We then extract the single `DataGridCellInfo` object from the `AddedCells` property
    and return execution from the method if it is invalid. If it is valid, we call
    the `GetCellContent` method on its `Column` property, passing in its `Item` property,
    to access the cell content as a `FrameworkElement` object. This could benefit
    from a little more explanation.
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们从`AddedCells`属性中提取单个`DataGridCellInfo`对象，如果它无效，就从方法中返回执行。如果它是有效的，我们在它的`Column`属性上调用`GetCellContent`方法，传入它的`Item`属性，以作为`FrameworkElement`对象访问单元格内容。这可能会需要更多的解释。
- en: The `Column` property contains the `DataGridBoundTemplateColumn` element that
    relates to the selected cell and likewise, the `Item` property holds the `DataRow`
    object that contains the selected cell. The returned `FrameworkElement` object
    represents the content of the `DataGridCell` element, which in our case is a `ContentPresenter`
    object.
  id: totrans-297
  prefs: []
  type: TYPE_NORMAL
  zh: '`Column`属性包含与所选单元格相关的`DataGridBoundTemplateColumn`元素，同样，`Item`属性持有包含所选单元格的`DataRow`对象。返回的`FrameworkElement`对象代表`DataGridCell`元素的内容，在我们的例子中是一个`ContentPresenter`对象。'
- en: Any UI elements that we declare in the `DataTemplate` element that is applied
    to the `DataGridBoundTemplateColumn`. The `CellTemplate` property can be accessed
    through this `ContentPresenter` object, by walking the visual tree. In our case,
    that is a simple `TextBlock` element. Returning to our code now, if this cell
    content is `null`, we return execution from the method.
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 我们在应用于`DataGridBoundTemplateColumn`的`DataTemplate`元素中声明的任何UI元素。可以通过这个`ContentPresenter`对象，通过遍历视觉树来访问`CellTemplate`属性。在我们的例子中，这是一个简单的`TextBlock`元素。回到我们的代码，如果这个单元格内容是`null`，我们就从方法中返回执行。
- en: If the cell content is valid, we cast its `Parent` property value to its actual
    type of `DataGridCell`. If this `DataGridCell` object is `null`, we also return
    execution from the method. If it is valid, we call its `TransformToAncestor` method,
    followed by the `Transform` method, to find its onscreen position, relative to
    the spreadsheet control.
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 如果单元格内容有效，我们将其 `Parent` 属性值强制转换为其实际的 `DataGridCell` 类型。如果这个 `DataGridCell` 对象为
    `null`，我们也从方法中返回执行。如果它是有效的，我们调用其 `TransformToAncestor` 方法，然后是 `Transform` 方法，以找到相对于电子表格控件的位置。
- en: We then use the relative position to create the start point, or the top left
    corner, of the rectangle, by subtracting 3 pixels in each axis. This ensures that
    the rectangle will sit just outside the cell contents, overlapping it slightly.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 我们然后使用相对位置来创建矩形的起点，即左上角，通过在每个轴上减去 3 像素。这确保矩形将位于单元格内容之外，略微重叠。
- en: Similarly, we also use the relative position to create the endpoint, or the
    bottom right corner, of the rectangle, by adding the actual dimensions of the
    `DataGridCell` object to it. Finally, we call the `UpdateSelectionRectangle` method,
    to draw the selection rectangle, passing the calculated start and endpoints through.
  id: totrans-301
  prefs: []
  type: TYPE_NORMAL
  zh: 类似地，我们也使用相对位置来创建矩形的终点，即右下角，通过向其中添加 `DataGridCell` 对象的实际尺寸。最后，我们调用 `UpdateSelectionRectangle`
    方法来绘制选择矩形，并通过传递计算出的起始点和终点。
- en: Now, our selection rectangle is working and smoothly animates from one selected
    cell to the next. However, on a bigger spreadsheet, you might notice that it won't
    scroll in line with the spreadsheet itself. This is because there is not yet a
    connection between its position and the horizontal and vertical offsets of the
    `ScrollViewer` that it is defined inside.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们的选择矩形正在工作，并且可以平滑地从选中的单元格动画过渡到下一个。然而，在一个更大的电子表格中，你可能会注意到它不会与电子表格本身一起滚动。这是因为它的位置和定义在其内部的
    `ScrollViewer` 的水平和垂直偏移量之间还没有连接。
- en: 'To address this issue, we will need to update the positional information on
    the `TranslateTransform` object, from the `Canvas` element that the selection
    rectangle is drawn on, each time the spreadsheet control is scrolled. Let''s see
    how we do this, by adding further code into our `SpreadsheetScrollViewer_ScrollChanged`
    event handler now:'
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，我们需要在每次电子表格控件滚动时更新 `TranslateTransform` 对象的位置信息，该对象是在绘制选择矩形时使用的 `Canvas`
    元素。现在让我们看看我们如何通过向我们的 `SpreadsheetScrollViewer_ScrollChanged` 事件处理器中添加更多代码来实现这一点：
- en: '[PRE58]'
  id: totrans-304
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: Skipping over the existing code that attained the reference to our selection
    rectangle `Canvas` panel, we access the `TranslateTransform` element, that we
    declared in the `GetCanvasReference` method, from its `RenderTransform` property.
    We then create a new `TranslateTransform` object, with the values coming from
    the original one, plus the distance scrolled in either direction, and set it back
    to the `RenderTransform` property.
  id: totrans-305
  prefs: []
  type: TYPE_NORMAL
  zh: 跳过现有代码中引用我们选择矩形 `Canvas` 面板的代码，我们通过其 `RenderTransform` 属性访问我们在 `GetCanvasReference`
    方法中声明的 `TranslateTransform` 元素。然后我们创建一个新的 `TranslateTransform` 对象，其值来自原始对象，加上任意方向的滚动距离，并将其设置回
    `RenderTransform` 属性。
- en: 'Note that we have to do this because the `TranslateTransform` element is immutable
    and cannot be altered. Therefore, we need to replace it with a new element instead
    of just updating its property values. Any attempts to modify it will result in
    a runtime exception being thrown:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，我们必须这样做，因为 `TranslateTransform` 元素是不可变的，不能被更改。因此，我们需要用新元素替换它，而不是仅仅更新其属性值。任何修改它的尝试都将导致抛出运行时异常：
- en: '[PRE59]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: 'Let''s take a final look at the visual output of our spreadsheet control now:'
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们来最后看看我们的电子表格控件的可视输出：
- en: '![](img/82470a99-ef3b-49b0-b420-274a72fb2aff.png)'
  id: totrans-309
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/82470a99-ef3b-49b0-b420-274a72fb2aff.png)'
- en: Of course, we could continue to improve our spreadsheet control, perhaps by
    adding event handlers to detect changes to the size of the rows and columns when
    users resize them and update the selection rectangle accordingly. We could extend
    the `Cell` class, to add style and format properties, to style each cell and format
    the content.
  id: totrans-310
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们可以继续改进我们的电子表格控件，例如，通过添加事件处理器来检测用户调整行和列大小时行和列大小的变化，并相应地更新选择矩形。我们还可以扩展 `Cell`
    类，添加样式和格式属性，以样式化每个单元格并格式化内容。
- en: We could add a formula bar or an alternative information panel to display formulas
    or further information from the cells when clicked on. We could implement multi-cell
    selection, or enable users to edit cell contents. But either way, hopefully, this
    extended example has now provided you with enough understanding to be able to
    undertake these kinds of advanced projects successfully yourself.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 我们可以添加一个公式栏或一个备选信息面板，当点击时显示公式或从单元格中获取的更多信息。我们可以实现多单元格选择，或者允许用户编辑单元格内容。但无论如何，希望这个扩展示例已经为你提供了足够理解，以便能够成功独立完成这类高级项目。
- en: Summary
  id: totrans-312
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we further investigated the built-in controls, paying particular
    attention to the polymorphic ability to override base class methods in derived
    classes. We first examined examples from the .NET Framework source code, before
    moving on to create our own examples that highlight this ability.
  id: totrans-313
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们进一步研究了内置控件，特别关注在派生类中覆盖基类方法的多态能力。我们首先检查了.NET Framework源代码中的示例，然后继续创建我们自己的示例，以突出这种能力。
- en: We continued, introducing extended examples, to help to fully understand the
    benefits that can be gained from using this method. Through these examples, we
    highlighted a number of problems, and learned how to overcome them each in turn,
    by extending the built-in controls and overriding particular base class methods.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 我们继续介绍扩展示例，以帮助完全理解使用这种方法可以获得的好处。通过这些示例，我们突出了许多问题，并学会了如何逐一克服它们，通过扩展内置控件和覆盖特定的基类方法。
- en: In the next chapter, we will take a thorough look at the WPF animation system
    and discover how we can utilize it in everyday applications. We'll also find out
    a number of techniques to fine-tune animations to get that perfect effect and
    discover how we can build animation functionality right into our application framework.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，我们将彻底研究WPF动画系统，并了解我们如何在日常应用中利用它。我们还将发现许多微调动画以获得完美效果的技术，并了解我们如何将动画功能直接构建到我们的应用程序框架中。
