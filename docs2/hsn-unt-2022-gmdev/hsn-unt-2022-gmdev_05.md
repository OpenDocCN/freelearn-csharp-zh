# 5

# C# 和可视化脚本简介

Unity 拥有很多优秀的内置工具来解决游戏开发中最常见的问题，比如我们之前看到的问题。即使是同一类型的两个游戏也有它们自己的一些细微差别，使游戏变得独特，Unity 无法预见这一点，这就是为什么我们需要脚本。通过编码，我们可以以几种方式扩展 Unity 的功能，以实现我们需要的精确行为，所有这些都可以通过一个众所周知的语言——C# 来完成。但除了 C#，Unity 还有 **可视化脚本**，这是一种通过节点图工具生成代码的方法。这意味着你可以通过拖动 **节点**（代表可以链式连接的操作的盒子）来创建脚本，而不需要编写代码：

![图片](img/B18585_05_01.png)

图 5.1：可视化脚本图的示例

尽管本质上两种方法都可以达到相同的结果，但我们可以根据不同的用途使用它们。通常，由于通常很大且对性能非常敏感，游戏的核心逻辑是用 C# 编写的。但有时使用可视化脚本而不是代码可以让非程序员团队成员，如艺术家或游戏设计师，在游戏中有更多自由来编辑小的更改，尤其是在平衡或视觉效果方面。

另一个例子是游戏设计师通过可视化脚本原型设计想法，后来程序员将在想法获得批准后将这些想法转换为 C# 脚本。此外，C# 程序员可以为可视化脚本程序员创建节点。

这些工具的混合方式在团队之间差异很大，所以尽管在下一章我们将主要关注 C#，我们还将查看我们将要创建的脚本的可视化脚本等效版本。这样，你将有机会在方便的时候根据团队结构选择使用其中一个。

在本章中，我们将探讨以下脚本概念：

+   创建脚本

+   使用事件和指令

我们将创建自己的 Unity 组件，学习脚本的基本结构以及我们可以如何执行操作和公开属性以进行配置，无论是使用 C# 还是可视化脚本。我们在这里不会创建任何实际的游戏代码，只是提供一些示例脚本，以便在下一章开始这样做。让我们先讨论脚本创建的基本知识。

# 创建脚本

创建行为的第一步是创建脚本资产；这些文件将包含我们组件行为背后的逻辑。C# 和可视化脚本都有自己的资产类型来实现这一点，所以让我们来探讨如何在两个工具中实现这一点。

在这本书中需要一些编程知识。然而，在本节中，我们将讨论基本的脚本结构，以确保你在下一章编写游戏行为时有一个坚实的基础。即使你对 C# 熟悉，也尽量不要跳过这一节，因为我们将涵盖 Unity 特定的代码结构。

在本节中，我们将探讨以下脚本创建概念：

+   初始设置

+   创建 C#脚本

+   添加字段

+   创建 Visual Scripting 图

我们将创建我们的第一个脚本，这个脚本将用于创建我们的组件，讨论创建所需工具，并探讨如何将我们的类字段暴露给编辑器。让我们从脚本创建的基本知识开始。

## 初始设置

通过在**包管理器**中安装**Visual Scripting**包，我们可以添加对 Visual Scripting 的支持，就像我们在前几章中添加其他包一样，但由于 Unity 在创建项目时会自动为我们完成这项工作，所以我们不需要进行任何进一步的设置。这意味着本节的其余部分将负责设置与 C#一起工作的工具。

在创建我们的第一个 C#脚本之前，我们需要考虑 Unity 如何编译代码。在编码时，我们习惯于使用**集成开发环境**（**IDE**），这是一个用于创建我们的代码并编译或执行它的程序。在 Unity 中，我们只会使用 IDE 作为一个工具，通过着色和自动完成功能轻松地创建脚本，因为 Unity 没有自定义代码编辑器（如果您之前从未编码过，这些是初学者的宝贵工具）。脚本将在 Unity 项目中创建，如果进行任何更改，Unity 将检测并编译它们，因此您不需要在 IDE 中编译。不用担心，即使不在 IDE 中编译和运行代码，也可以使用 IDE 和 Unity 一起进行调试、添加断点以及检查变量和结构中的数据。

我们可以使用 Visual Studio、Visual Studio Code、Rider 或您想使用的任何 C# IDE，但安装 Unity 时，您可能会看到一个自动安装 Visual Studio 的选项，这允许您有一个默认的 IDE。这会安装 Visual Studio 的免费版本，所以在这里不用担心许可证问题。如果您电脑上没有 IDE，并且在安装 Unity 时没有勾选 Visual Studio 选项，您可以执行以下操作：

1.  打开**Unity Hub**。

1.  前往**安装**部分。

1.  点击您正在使用的 Unity 版本右上角的轮形按钮，然后点击**添加模块**：

![](img/B18585_05_02.png)

图 5.2：向 Unity 安装添加模块

1.  检查表示**Visual Studio**的选项；该选项的描述将根据您使用的 Unity 版本和平台而有所不同。

1.  点击右下角的**继续**按钮：

![](img/B18585_05_03.png)

图 5.3：安装 Visual Studio

1.  确认您接受条款和条件，然后点击**安装**：

![](img/B18585_05_04.png)

图 5.4：接受条款和条件

1.  等待操作结束。这可能需要几分钟。可能会有一些与平台和版本相关的 Visual Studio 步骤；如果是这样，只需按照它们进行即可。

如果你有一个首选的 IDE，你可以自己安装它并配置 Unity 使用它。如果你负担得起或者你是教师或学生（在这些情况下它是免费的），我推荐 Rider。这是一个功能强大的 IDE，拥有许多你将喜欢的 C# 和 Unity 功能；然而，它对于本书并不是必需的。为了设置 Unity 使用自定义 IDE，请按照以下步骤操作：

1.  打开项目。

1.  在编辑器顶部菜单中转到**编辑** | **首选项**（在 Mac 上为**Unity** | **首选项**）。

1.  从左侧面板选择**外部工具**菜单。

1.  从外部脚本编辑器中选择你首选的 IDE；Unity 将自动检测支持的 IDE：

![](img/B18585_05_05.png)

图 5.5：选择自定义 IDE

1.  如果你没有在列表中找到你的 IDE，你可以使用**浏览…**选项。请注意，通常需要使用此选项的 IDE 并没有得到很好的支持——但值得一试。

最后，一些 IDE，如 Visual Studio、Visual Studio Code 和 Rider，都有 Unity 集成工具，你需要在项目中安装这些工具，这是可选的但可能很有用。通常，Unity 会自动安装这些工具，但如果你想确保它们已安装，请按照以下步骤操作：

1.  打开**包管理器**（**窗口** | **包管理器**）。

1.  将**包**下拉菜单设置为**Unity 注册表**模式：

![](img/B18585_05_06.png)

图 5.6：启用 Unity 注册表模式

1.  在列表中搜索你的 IDE 或使用搜索栏进行过滤。在我的情况下，我使用了 Rider，我可以找到一个名为 **JetBrains Rider Editor** 的包：

![](img/B18585_05_07.png)

图 5.7：自定义 IDE 编辑器扩展安装——在这个例子中是 Rider 的

1.  通过查看包管理器右下角的按钮来检查你的 IDE 集成包是否已安装。如果你看到一个**安装**或**更新**按钮，点击它，但如果它显示为**已安装**，则一切设置就绪。

现在我们已经配置了一个 IDE，让我们创建我们的第一个脚本。

## 创建 C# 脚本

C# 是一种面向对象的语言，在 Unity 中也是如此。任何想要扩展 Unity 的时候，我们都需要创建自己的类——一个包含我们想要添加到 Unity 中的指令的脚本。如果我们想要创建自定义组件，我们需要创建一个继承自 `MonoBehaviour` 的类，这是每个自定义组件的基类。

我们可以直接在 Unity 项目中使用编辑器创建 C# 脚本文件，并将它们排列在其他 `assets` 文件夹旁边的文件夹中。创建脚本的最简单方法是按照以下步骤操作：

1.  选择你想要添加我们即将创建的组件的任何 GameObject。由于我们只是在测试，所以选择任何对象。

1.  在检查器底部点击**添加组件**按钮，并在点击**添加组件**后列表底部查找**新脚本**选项：

![](img/B18585_05_08.png)

图 5.8：新脚本选项

1.  在 **名称** 字段中输入所需的脚本名称，然后点击 **创建并添加**。在我的情况下，我将命名为 `MyFirstScript`，但为您游戏中的脚本尝试输入描述性的名称，无论长度如何：

![](img/B18585_05_09.png)

图 5.9：命名脚本

建议您使用帕斯卡大小写（Pascal case）来命名脚本。在帕斯卡大小写中，用于玩家射击功能的脚本会被命名为 `PlayerShoot`。每个单词的首字母都大写，且不能使用空格。

1.  你可以在 **项目视图** 中检查如何创建与你的脚本同名的新的资产。请记住，每个组件都有自己的资产，我建议你将每个组件放在一个 `Scripts` 文件夹中：

![](img/B18585_05_10.png)

图 5.10：脚本资产

1.  现在，你也会看到你的 GameObject 在检查器窗口中有一个新的组件，其名称与你的脚本相同。所以，你现在已经创建了你第一个 `component` 类：

![](img/B18585_05_11.png)

图 5.11：脚本添加到 GameObject 中

现在我们已经创建了一个 `component` 类，请记住，类本身不是组件。它是对组件应该是什么的描述——组件应该如何工作的蓝图。要实际使用组件，我们需要通过基于类创建组件来实例化它。每次我们使用编辑器将组件添加到对象时，Unity 都会为我们实例化它。通常，我们不会使用 newC# 关键字来实例化组件，而是通过使用编辑器或专用函数。

现在，你可以像添加任何其他组件一样，使用检查器窗口中的 **添加组件** 按钮将你的新空组件添加到其他对象中。然后你可以在 **脚本** 类别中查找该组件或通过名称搜索它：

![](img/B18585_05_12.png)

图 5.12：在脚本类别中添加自定义组件

在这里需要考虑的是，我们可以将相同的组件添加到多个 GameObject 中。我们不需要为每个使用该组件的 GameObject 创建一个类。我知道这是基本的程序员知识，但请记住，我们在这里试图回顾基础知识。

现在我们有了我们的组件，让我们通过以下步骤来探索它的外观并进行类结构回顾：

1.  在 **项目视图** 中定位脚本资产，并双击它。请记住，它应该在你之前创建的 `Scripts` 文件夹中。

1.  等待 IDE 打开；这可能需要一段时间。当你看到你的脚本代码及其关键字被正确着色时，你就知道 IDE 已经完成了初始化，这会根据所需的 IDE 而有所不同。在 Rider 中，它看起来就像 *图 5.13* 中所示的那样。在我的情况下，我知道 Rider 已经完成了初始化，因为 `MonoBehaviour` 类型与脚本名称的颜色相同：

![](img/B18585_05_13.png)

图 5.13：在 Rider IDE 中打开的新脚本

1.  前三条线——以 `using` 关键字开头的线——包括常见的命名空间。**命名空间**就像代码容器，在这种情况下，是其他人（如 Unity、C# 创建者等）创建的代码。我们将经常使用命名空间来简化我们的任务；它们已经包含了我们将要使用的已解决算法。我们将根据需要添加和删除 `using` 组件；在我的情况下，Rider 建议前两个 `using` 组件不是必需的，因为我没有使用它们内部的任何代码，所以它们被灰色显示。但到目前为止，请保留它们，因为你在本书的后续章节中会用到它们。记住，它们应该始终位于文件的开头：

![图片](img/B18585_05_14.png)

图 5.14：使用部分

1.  下一行，即以 `public class` 开头的行，是我们声明正在创建一个新的类，该类继承自 `MonoBehaviour`，这是每个自定义组件的基类。我们知道这一点，因为它以 `: MonoBehaviour` 结尾。你可以看到其余的代码位于该行下面的括号内，这意味着括号内的代码属于该组件：

![图片](img/B18585_05_15.png)

图 5.15：MyFirstScript 类定义继承自 MonoBehaviour

现在我们已经有了我们的 C# 脚本，让我们添加字段来配置它。

## 添加字段

在前面的章节中，当我们添加 `Rigidbody` 或不同类型的碰撞体作为组件时，仅仅添加组件是不够的。我们需要正确配置它们以实现我们需要的精确行为。例如，`Rigidbody` 有 `Mass` 属性来控制物体的重量，而碰撞体有 `Size` 属性来控制它们的形状。这样，我们可以为不同的场景重用相同的组件，防止类似组件的重复。使用 `Box` 碰撞体，我们可以通过改变大小属性来表示一个立方体或矩形盒子。我们的组件也不例外；如果我们有一个移动对象的组件，并且我们想让两个对象以不同的速度移动，我们可以使用具有不同配置的相同组件。

每个配置都是一个 **字段** 或 **变量**，我们可以在这里存储参数的值。我们可以以两种方式在编辑器中创建可编辑的类字段：

+   通过将字段标记为 `public`，但打破了封装原则

+   通过创建私有字段并使用属性公开它

现在，我们将介绍这两种方法，但如果你对 **面向对象编程**（**OOP**）概念不熟悉，例如封装，我建议你使用第一种方法。

假设我们正在创建一个移动脚本。我们将使用第一种方法——即通过添加 `public` 字段——添加一个表示速度的可编辑数字字段。我们将按照以下步骤进行：

1.  通过双击脚本打开它，就像我们之前做的那样。

1.  在类括号内，但不在它们内部的任何括号内，添加以下代码：

![图片](img/B18585_05_16.png)

图 5.16：在我们的组件中创建速度字段

`public` 关键字指定变量可以在类的作用域之外被看到和编辑。代码中的 `float` 部分表示变量使用的是十进制数字类型，而 `speed` 是我们为我们的字段选择的名称——这可以是任何你想要的内容。你可以使用其他值类型来表示其他类型的数据，例如 `bool` 用于复选框或 `Booleans` 和 `string` 用于文本。

1.  要应用更改，只需在 IDE 中保存文件（通常通过按 *Ctrl* + *S* 或 *Command* + *S*）并返回 Unity。当你这样做时，你会在编辑器的右下角注意到一个小型加载轮，这表明 Unity 正在编译代码。你必须在轮子停止转动之前不能测试更改：

![](img/B18585_05_17.png)

图 5.17：加载轮

记住，Unity 会编译代码；不要在 IDE 中编译。

1.  编译完成后，你可以在检查器窗口中看到你的组件，并且应该有一个 **Speed** 变量，允许你设置你想要的速度。当然，现在，这些变量没有任何作用。Unity 不会通过变量的名称来识别你的意图；我们需要以某种方式设置它以便使用，但我们将稍后进行操作：

![](img/B18585_05_18.png)

图 5.18：一个公共字段，用于编辑组件稍后将要使用的数据

如果你没有看到速度变量，请检查本章末尾的 *常见初学者 C# 脚本错误* 部分，它将提供有关如何调试编译错误的提示。

1.  尝试将相同的组件添加到其他对象中，并设置不同的速度。这将向你展示不同 GameObject 中的组件是如何独立的，允许你通过不同的设置更改它们的一些行为。

1.  定义属性的第二种方法类似，但不是创建一个 `public` 字段，而是创建一个 `private` 字段，鼓励封装，并通过 `SerializeField` 属性将其公开，如图中所示。

![](img/B18585_05_19.png)

图 5.19：在检查器窗口中公开私有属性

如果你不太熟悉面向对象编程中的封装概念，只需使用第一种方法，这对于初学者来说更加灵活。如果你创建一个 `private` 字段，它将不会被其他脚本访问，因为 `SerializeField` 属性只将变量暴露给编辑器。记住，Unity 不允许你使用构造函数，所以设置初始数据和注入依赖的唯一方法是通过序列化的 `private` 字段或 `public` 字段，并在编辑器中设置它们（或者使用依赖注入框架，但这超出了本书的范围）。为了简单起见，我们将在本书的大部分练习中使用第一种方法。

如果您想，尝试创建其他类型的变量并检查它们在检查器中的外观。尝试将`float`替换为`bool`或`string`，如之前建议的那样。请注意，并非所有可能的 C#类型都由 Unity 识别；通过这本书，我们将学习最常用的支持类型。现在我们知道了如何通过数据配置我们的组件，让我们使用这些数据来创建一些行为。

现在我们有了我们的 C#脚本，让我们看看如何在视觉脚本中做同样的事情。

## 创建视觉脚本

由于我们需要为 C#脚本创建**脚本资产**，因此需要创建视觉脚本编写的等效项，即**脚本图形**，并将其附加到我们的 GameObject 上，尽管这次采用不同的方法。在继续之前，请注意，我们的对象必须只有 C#或视觉脚本版本，但不能两者兼有，否则行为将被应用两次，每次一个版本。

实际上，只需为要尝试的版本执行步骤，或者如果您想进行实验，则在不同的对象中执行这两个步骤。

让我们创建一个执行以下操作的视觉脚本：

1.  创建一个新的 GameObject，我们将向其中添加视觉脚本。

1.  向其中添加**脚本机器**组件。此组件将执行我们即将创建的**视觉脚本图形**：

![](img/B18585_05_20.png)

图 5.20：添加脚本机器组件

1.  在**脚本机器**组件中，点击**新**按钮，选择一个文件夹和一个名称以保存**视觉脚本图形**资产。此资产将包含我们脚本的指令，**脚本机器**组件将执行这些指令：

![](img/B18585_05_21.png)

图 5.21：使用新按钮创建视觉脚本图形资产

1.  如果出现警告，请点击**立即更改**选项。这将防止在脚本上的更改在游戏运行时影响游戏，因为警告所说，它可能导致代码不稳定。始终停止游戏，更改代码，然后再次播放。

1.  点击**编辑图形**按钮以打开视觉脚本编辑器窗口。您可以将**脚本图形**标签拖动到编辑器的任何部分以合并该窗口：

![](img/B18585_05_22.png)

图 5.22：视觉脚本资产编辑器

1.  将鼠标放在**视觉脚本**编辑器网格的空白区域，同时按住中间鼠标按钮，移动鼠标以滚动通过图形。在 MacBooks 和 Apple Magic Mouses 上，您可以使用两个手指在触控板上进行滚动。

我们所做的是创建包含我们脚本代码的**视觉图形**资产，并通过**脚本机器**组件将其附加到 GameObject 上。与 C#脚本不同，我们无法直接附加**图形资产**；这就是为什么我们需要**脚本机器**为我们运行组件。

关于字段，我们在 C#脚本中创建的字段包含在脚本本身中，但对于**Visual Graph**来说，它们的工作方式略有不同。当我们添加了**Script Machine**组件时，还添加了另一个组件：**Variables**组件。这将保存所有**Visual Script Graph**的变量，一个 GameObject 可以包含。这意味着我们添加到对象的所有图表都将共享这些变量。如果你想创建特定于图表的变量，也可以，但它们不会在 Inspector 中暴露，这种方式也简化了从其他对象的脚本中访问变量的过程。也要记住，你可能需要向对象添加多个图表，因为每个图表将负责不同的行为，这样我们就可以根据需要混合和匹配它们。

为了将一个变量添加到我们的 GameObject 中，以便我们的图表可以使用它，让我们做以下操作：

1.  选择一个添加了**Visual Script**的 GameObject（带有**Script Machine**组件）并查看**Variables**组件。

1.  点击显示**（New Variable Name）**的输入字段，并输入变量的名称。在我的例子中，这是`speed`。如果你看不到这个选项，点击**Variables**组件名称左侧的三角形。

1.  点击**Variables**组件的**Plus (+)**按钮。

1.  在**Type**下拉菜单中，选择**Float**。

1.  可选地，你可以在**Value**字段中设置一个初始值：

![](img/B18585_05_23.png)

图 5.23：为 Visual Graph 创建变量

我们创建了一个`speed`变量，我们可以在 GameObject 中配置它来改变所有附加到我们的 GameObject 的**Visual Scripts Graphs**的工作方式，或者至少是使用那个`Variable`值的那些。考虑一下，你可能会有不同种类的速度，比如移动速度和旋转速度，所以在实际情况下，你可能希望变量名更加具体一些。

在 Visual Scripting 中使用的`Variables`组件也被称为**黑板**，这是一种常见的编程技术。这个黑板是我们对象几个值的容器，就像内存或数据库一样，我们的对象的其他几个组件将查询并使用这些值。C#脚本通常在其内部包含自己的变量。随着我们的脚本创建并准备配置，让我们看看如何让它们都做些事情。

# 使用事件和指令

现在我们有了脚本，我们准备用它做些事情。在本章中，我们不会实现任何有用的功能，但我们将确定基础概念，以便在下一章中添加我们将要创建的脚本的有趣行为。

在本节中，我们将介绍以下概念：

+   C#中的事件和指令

+   Visual Scripting 中的事件和指令

+   在指令中使用字段

+   常见初学者 C#脚本错误

我们将探索**Unity 事件系统**，这将允许我们通过执行指令来响应不同的情况。这些指令也将受到编辑器值的影响。最后，我们将讨论常见的脚本错误及其解决方法。让我们从介绍 Unity 事件在 C#中的概念开始。

## C#中的事件和指令

Unity 允许我们以因果关系的方式创建行为，这通常被称为**事件系统**。事件是 Unity 正在监控的情况——例如，当两个对象碰撞或被销毁时，Unity 会告诉我们这种情况，使我们能够根据我们的需求做出反应。例如，当玩家与子弹碰撞时，我们可以减少玩家的生命值。在这里，我们将探讨如何监听这些事件，并通过一些简单的操作来测试它们。

如果你习惯了事件系统，你会知道它们通常要求我们订阅某种监听器或代理，但在 Unity 中，有一个更简单的方法可用。对于 C#脚本，我们只需要编写一个与我们要使用的事件名称完全相同的函数——我的意思是**完全相同**。如果名称中的任何一个字母的格式不正确，它将不会执行，并且不会发出警告。这是最常见的初学者错误，所以请注意。对于视觉脚本，我们将添加一种特殊的节点，但稍后再讨论 C#版本。

在 Unity 中有很多事件或消息需要监听，所以让我们从最常见的一个开始——`Update`。这个事件将告诉你 Unity 何时想要更新你的对象，这取决于你行为的目的；有些不需要。`Update`逻辑通常是需要不断执行的事情——更准确地说，是在每一帧执行。记住，每个游戏都像是一部电影——一系列快速切换到屏幕上的图像，看起来我们有了连续的运动。在`Update`事件中执行的一个常见操作是稍微移动对象，通过这样做，每一帧都会使你的对象持续移动。

我们将在稍后了解我们可以使用`Update`和其他事件或消息做什么。现在，让我们专注于如何使我们的组件至少能够监听这个事件。实际上，基本脚本已经包含两个可以立即使用的函数，一个是`Update`，另一个是`Start`。如果你不熟悉 C#中的方法概念，我们指的是以下截图中的代码片段，它已经包含在我们的脚本中。试着在你的脚本中找到它：

![](img/B18585_05_24.png)

图 5.24：一个名为 Update 的函数，它将在每一帧执行

你会注意到（通常是）在`void Update()`行上方的绿色文本行（取决于 IDE）——这被称为**注释**。这些基本上被编译器忽略。它们只是你可以为自己留下的笔记，并且必须始终以`//`开头，以防止 Unity 尝试执行它们并失败。我们将使用这个来暂时禁用代码行。

现在，为了测试这个功能是否真的起作用，让我们添加一个始终要执行的指令。没有比`print`更好的测试函数了。这是一条简单的指令，告诉 Unity 将消息打印到控制台，开发者可以在那里看到各种消息，以检查一切是否正常工作。用户永远不会看到这些消息。它们类似于开发者有时在游戏中出现问题时要求你提供的经典日志文件。

为了使用函数测试 C#中的事件，请按照以下步骤操作：

1.  通过双击脚本文件来打开它。

1.  为了测试，在事件函数中添加`print("test");`。在下面的屏幕截图中，你可以看到一个如何在`Update`事件中执行此操作的示例。请记住，必须*精确地*写入指令，包括正确的大小写、空格和引号符号：

![](img/B18585_05_25.png)

图 5.25：在所有帧中打印消息

1.  保存文件，转到 Unity，并玩游戏。

记得在从 IDE 切换回 Unity 之前保存文件。这是 Unity 知道你的文件已更改的唯一方式。一些 IDE，如 Rider，会自动为你保存文件，但我不建议你在大型项目中使用自动保存（你不想意外地重新编译未完成的工作——在包含大量脚本的项目中，这会花费很长时间）。

1.  查找**控制台**标签并选择它。这通常位于**项目视图**标签旁边。如果你找不到它，请转到**窗口 | 通用 | 控制台**，或按*Ctrl* + *Shift* + *C*（在 macOS 上为*Command* + *Shift* + *C*）。

1.  你将在**控制台**标签页上看到每帧都打印出新的消息“`test`”。如果你看不到这个，记得在玩游戏之前保存脚本文件。

1.  你可能会看到一个单独的消息，但它的右侧数字在增加；这意味着相同的消息出现了多次。尝试点击**控制台**的**折叠**按钮来改变这种行为。

1.  让我们也测试一下`Start`函数。向其中添加`print("test Start");`，保存文件，并玩游戏。完整的脚本应如下所示：

![](img/B18585_05_26.png)

图 5.26：测试 Start 和 Update 函数的脚本

如果你现在检查控制台并滚动到最上方，你会看到一个单独的`"test Start"`消息和随后的许多`"test"`消息。正如你所猜到的，`Start`事件告诉你 GameObject 已被创建，并允许你在其生命周期的开始执行一次需要发生的代码。

对于 `void Update()` 语法，我们将告诉 Unity，此行以下括号内的任何内容都是一个将在所有帧中执行的功能。将 `print` 指令**放在** `Update` 括号内（类括号内的括号）内非常重要。此外，`print` 函数期望在其括号内接收一个要打印的值，称为参数或参数。在我们的例子中，我们想要打印简单的文本，在 C# 中它必须用引号括起来。最后，函数中如 **Update** 或 **Start** 的所有指令**必须**以分号结束。

在这里，我挑战您尝试添加另一个名为 `OnDestroy` 的事件，使用 `print` 来发现它何时执行。一个小建议是播放和停止游戏，查看控制台底部以测试此功能。

对于高级用户，如果您的 IDE 允许，您也可以使用断点。**断点**允许在执行特定代码行之前完全冻结 Unity，以查看我们的字段数据随时间的变化并检测错误。在这里，我将向您展示在 Rider 中使用断点的步骤，但 Visual Studio 版本应该类似：

1.  如果尚未安装，请安装属于您 IDE 的 Unity 包。检查 **包管理器** 中的 **JetBrains Rider 编辑器** 包。在 Visual Studio 的情况下，安装 **Visual Studio 编辑器** 包。

1.  在您想要添加断点的行的左侧垂直栏上单击：

![](img/B18585_05_27.png)

图 5.27：打印指令中的断点

1.  前往 **运行 | 连接到 Unity 进程**。如果您正在使用 Visual Studio，请前往 **调试 | 连接 Unity 调试器**：

![](img/B18585_05_28.png)

图 5.28：用 Unity 进程攻击我们的 IDE

1.  从列表中查找您想要测试的特定 Unity 实例。如果有的话，列表将显示其他打开的编辑器或正在执行的调试构建。

1.  如果这不起作用，请检查编辑器是否处于调试模式，查看编辑器右下角的错误图标。如果错误图标看起来是蓝色的带有复选框，那么它是正常的，但如果它看起来是灰色的并且被划掉，请单击它并单击 **切换到调试模式**：

![](img/B18585_05_29.png)

图 5.29：从发布模式切换到调试模式

停止调试过程不会关闭 Unity。它只会将 IDE 从编辑器中分离出来。

现在，让我们探索使用事件和指令的视觉脚本等效方法。

## 视觉脚本中的事件和指令

在视觉脚本中，事件和指令的概念保持不变，但当然这将通过图中的节点来完成。记住，一个节点代表图中的一个指令，我们可以将它们连接起来以链式连接每个指令的效果。为了在我们的图中添加事件和打印指令，请执行以下操作：

1.  打开 **视觉脚本图**（双击视觉脚本资产）。

1.  右键单击默认创建的 **On Start** 和 **On Update** 节点，然后单击 **Delete**。即使这些事件是我们需要的，我也想让你看到如何从头创建它们：

![](img/B18585_05_30.png)

图 5.30：删除节点

1.  在 **Graph** 的任何空白区域右键单击，并在 **Search** 框中输入 `start`。第一次可能需要一段时间。

1.  在左侧带有绿色复选框的列表中选择 **On Start** 元素。在这种情况下，我知道这是一个事件，因为我了解它，但通常你会因为它们没有输入引脚（在下一步中会有更多关于这个的说明）而将其识别为事件：

![](img/B18585_05_31.png)

图 5.31：搜索 On Start 事件节点

1.  将事件节点右侧的白色箭头（也称为输出流程引脚）拖动并释放鼠标按钮到任何空白区域。

1.  在 **Search** 框中搜索 `print` 节点，选择显示为 **Mono Behaviour:Print** 的节点。这意味着当 **On Start** 事件发生时，连接的节点将被执行，在这种情况下是 **print**。这就是我们开始将指令链接到事件的方式：

![](img/B18585_05_32.png)

图 5.32：创建一个连接到事件的打印节点

1.  将位于 **Print** 节点 **Message** 输入引脚左侧的空圆圈拖动到任何空白区域并释放。这个引脚有一个圆圈表示它是一个参数引脚，当执行引脚时将使用的数据。带有绿色箭头的流程引脚代表节点将被执行的顺序。

1.  选择 **String Literal** 选项，这将创建一个节点，允许我们指定要打印的消息：

![](img/B18585_05_33.png)

图 5.33：创建一个字符串字面量节点

1.  在空白的白色框中写入要打印的消息：

![](img/B18585_05_34.png)

图 5.34：指定要打印的消息

1.  玩游戏并查看控制台打印的消息。确保场景中只有视觉脚本版本，以避免将控制台中的消息与 C# 版本混淆。您还可以在视觉脚本中使用不同的消息文本，以确保哪些是真正执行的。

您可以通过将 **Print** 节点右侧的引脚（流程输出引脚）拖动到 **On Start** 上来将更多操作链接到 **On Start**，并链接新的节点，但我们将在稍后进行。现在，我们的脚本正在做些事情，让我们让指令使用我们创建的字段，以便脚本使用它们的配置。

## 在指令中使用字段

我们已经创建了字段来配置组件的行为，但到目前为止我们还没有使用它们。我们将在下一章创建有意义的组件，但我们会经常需要使用我们创建的字段来改变对象的行为。到目前为止，我们还没有真正使用我们创建的 `speed` 字段。然而，按照测试代码是否工作（也称为调试）的想法，我们可以学习如何使用函数中的字段数据来测试值是否为预期的，根据字段值改变控制台 `print` 的输出。

在我们当前的 C# 脚本中，我们的 `speed` 值在运行时不会改变。然而，作为一个例子，如果你正在创建一个带有护盾伤害吸收的生命系统，并且想要测试减少的伤害计算是否正常工作，你可能想要将计算值打印到控制台并检查它们是否正确。

这里的想法是将 `print` 函数内部的固定消息替换为字段。当您这样做时，`print` 将在控制台中显示字段的值。所以，如果您在 `speed` 中设置一个值为 `5` 并打印它，您将在控制台中看到很多显示 `5` 的消息，`print` 函数的输出由字段控制。为了测试这一点，您在 `Update` 函数中的 `print` 消息应该如下所示：

![](img/B18585_05_35.png)

图 5.35：使用字段作为 `print` 函数的参数

如您所见，我们只是将字段的名称放在引号之外。如果您使用引号，您将打印一个 `"``speed"` 消息。在其他场景中，您可以在某些移动函数中使用这个 `speed` 值来控制移动速度，或者您可能创建一个名为 `"fireRate"`（字段使用 **驼峰命名法** 而不是 Pascal 命名法，首字母小写）的字段来控制一枪和下一枪之间的冷却时间：

![](img/B18585_05_36.png)

图 5.36：打印当前速度

现在，为了使 Visual Script 图形打印出我们在 **Variables** 组件中创建的 **speed** 变量的值，让我们做以下操作。

1.  打开 Visual Scripting 图形资产（双击它）。

1.  在左侧的面板中，选择 **Object** 选项卡以显示对象拥有的所有变量——基本上是我们之前在 **Variables** 组件中定义的变量。

1.  使用变量框左侧的两条线将 `speed` 变量拖动到图形的任何空白区域。这将在图形中创建一个 **GetVariable** 节点来表示变量。请注意，目前拖动可能存在一个错误，所以您可能需要尝试几次，尝试从左侧部分拖动：

![](img/B18585_05_37.png)

图 5.37：将变量拖动到节点中以供使用

1.  将**获取变量**节点右侧的空圆圈拖动到**打印**节点**消息**输入引脚左侧的圆圈上。这将替换之前连接到**字符串文本**节点的连接。此节点没有**输入**或**输出**流节点（绿色箭头节点），因为它们是仅提供数据给其他节点的数据节点。在这种情况下，当**打印**需要执行时，它将执行**获取变量**以获取要读取的文本：

![图片](img/B18585_05_38.png)

图 5.38：将速度变量连接到打印节点

1.  右键单击**字符串文本**节点并删除它。

1.  播放游戏并观察。

所有这些，我们现在有了开始创建实际组件所需的工具。在继续之前，让我们回顾一下你可能会遇到的一些常见错误，如果你这是第一次在 C#中创建脚本。

## 常见的新手 C#脚本错误

可视化脚本脚本是以一种方式准备的，你犯的错误更少，不允许你写出像 C#脚本那样的错误语法。如果你是一个经验丰富的程序员，我敢打赌你对它们相当熟悉，但让我们回顾一下当你开始 C#脚本编写时会让你浪费很多时间的常见错误。其中大多数是由于没有**完全**复制显示的代码造成的。如果你在代码中有错误，Unity 将在控制台显示红色消息，并且不允许你运行游戏，即使你没有使用脚本。所以，永远不要留下未完成的事情。

让我们从经典的错误开始，一个缺少分号，这导致了许多程序员的梗和笑话。所有字段和函数（如`print`）内部的大多数指令（在调用时）需要在末尾有一个分号。如果你不添加分号，Unity 将在控制台显示错误，如*图 5.39*左边的截图所示。你还会注意到，这也有一个坏代码的例子，其中 IDE 显示一个红色图标，表明该位置有问题：

![图片](img/B18585_05_39.png)

图 5.39：IDE 和 Unity 控制台提示的打印行错误

你会注意到错误显示了确切的脚本（`MyFirstScript.cs`），确切的代码行（在这种情况下是`14`），通常还有一个描述性的消息——在这种情况下，`;` `expected`——作为指定指令在那里结束的方式，以便编译器可以处理下一个指令作为单独的一个。你可以简单地双击错误，Unity 将打开 IDE 并突出显示有问题的行。你甚至可以点击堆栈中的链接跳转到你想要的堆栈行。

我已经提到为什么使用指令中每个字母的**确切**大小写很重要。然而，根据我教授新手的经验，我需要强调这个特定的方面。

这种情况可能发生的第一个场景是在指令中。在下面的屏幕截图中，你可以看到一个写得不好的`print`函数的样子——即控制台将显示的错误以及 IDE 将建议存在错误。首先，在 Rider 的情况下，指令被标记为红色，表示指令不被识别（在 Visual Studio 中，将显示为红色横线）。然后，错误信息表明`Print`在当前上下文中不存在，这意味着 Unity（或实际上 C#）不识别任何名为`Print`的指令。在另一种类型的脚本中，大写的`Print`可能是有效的，但在常规组件中则不行，这就是为什么存在“**在当前上下文中**”的说明：

![](img/B18585_05_40.png)

图 5.40：编写错误指令时的错误提示

现在，如果你使用错误的大小写编写事件，情况会更糟。你可以为其他目的创建名为`Start`和`Update`的函数，无论你想要什么名字。将`update`或`start`写成小写是完全有效的，因为 C#会认为你打算将这些函数用作常规函数，而不是事件。因此，不会显示错误，你的代码将无法正常工作。尝试将`update`写成`Update`，看看会发生什么：

![](img/B18585_05_41.png)

图 5.41：Update 函数中的错误大小写将编译函数但不会执行

另一个错误是将指令放在函数括号之外，例如在类的括号内或括号外。这样做将不会给函数任何提示，说明何时需要执行。因此，在`Event`函数之外的`print`函数是没有意义的，它将显示如下*图 5.42*和*图 5.43*中的错误之一。

这次，错误信息并不非常详细。C#期望你创建一个函数或字段——可以直接放在类中的结构：

![](img/B18585_05_42.png)

图 5.42：放置错误的指令或函数调用

最后，另一个经典的错误是忘记关闭打开的括号。如果你不关闭一个括号，C#将不知道一个函数在哪里结束，另一个函数在哪里开始，或者类函数在哪里结束。这可能听起来有些多余，但 C#需要这一点才能定义得完美。在下面的屏幕截图中，你可以看到这会是什么样子：

![](img/B18585_05_43.png)

图 5.43：缺少闭合括号

这个错误有点难以捕捉，因为代码中的错误显示在实际错误之后。这是由于 C#允许你将函数放在函数内部（不常用）的事实，因此 C#会在稍后检测到错误，要求你添加一个闭合括号。然而，由于我们不希望在`Start`中放置`Update`，我们需要在`Start`的末尾之前修复错误。控制台中的错误信息将是描述性的，但同样，除非你 100%确定位置是正确的，否则不要按照消息建议的位置放置闭合括号。

你可能会遇到很多错误，除了这些之外，但它们都是一样的。IDE 会为你提供提示，控制台会显示消息；随着时间的推移，你会学会它们。只需保持耐心，因为每个程序员都会经历这个过程。还有其他类型的错误，例如运行时错误，代码可以编译但在执行时由于某些配置错误而失败，或者最糟糕的是：逻辑错误，你的代码可以编译并执行而没有错误，但并没有做你想要的事情。

# 摘要

在本章中，我们探讨了你在创建脚本时将使用的的基本概念。我们讨论了脚本资产的概念以及 C#脚本必须继承自`MonoBehaviour`才能被 Unity 接受以创建我们自己的脚本。我们还看到了如何混合事件和指令来为对象添加行为，以及如何在指令中使用字段来自定义它们的行为。所有这些操作都是使用 C#和视觉脚本完成的。

我们刚刚探索了脚本的基础知识以确保每个人都处于同一水平线上。然而，从现在开始，我们将假设你具备一些编程语言的基本编码经验，并且知道如何使用诸如`if`、`for`、`array`等结构。如果不具备，你仍然可以阅读这本书，并在需要时通过 C#入门书籍来补充你不理解的部分。

在下一章中，我们将开始看到如何使用我们所学的内容来创建移动和生成脚本。

# 加入我们的 Discord 频道！

与其他用户、Unity 游戏开发专家以及作者本人一起阅读这本书。

提出问题，为其他读者提供解决方案，通过 Ask Me Anything（问我任何问题）环节与作者聊天，等等。

扫描二维码或访问链接加入社区。

![二维码](img/Nicolas_QR_Code.png)

`packt.link/handsonunity22`
