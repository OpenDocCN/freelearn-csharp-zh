- en: '3'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '3'
- en: Extending Functionality with Unity Plugins
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Unity 插件扩展功能
- en: Welcome to [*Chapter 3*](B22017_03.xhtml#_idTextAnchor049), where we’ll delve
    into the world of Unity plugins. We’ll explore how to effectively integrate these
    plugins into your projects. This chapter aims to familiarize you with the different
    types of plugins available in the Unity ecosystem and guide you through the process
    of seamlessly incorporating them. By grasping the fundamentals of plugin integration,
    you’ll be able to make the most of existing solutions, enhance your game features,
    and save valuable development time. Let’s jump in and discover how Unity plugins
    can significantly boost your game development capabilities.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 欢迎来到 [*第 3 章*](B22017_03.xhtml#_idTextAnchor049)，我们将深入探讨 Unity 插件的世界。我们将探讨如何有效地将这些插件集成到您的项目中。本章旨在使您熟悉
    Unity 生态系统中可用的不同类型插件，并指导您无缝地整合它们。通过掌握插件集成的基础知识，您将能够充分利用现有解决方案，增强游戏功能，并节省宝贵的发展时间。让我们开始探索，看看
    Unity 插件如何显著提升您的游戏开发能力。
- en: 'In this chapter, we’re going to cover the following main topics:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将涵盖以下主要主题：
- en: Understanding Unity plugins
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 Unity 插件
- en: Integrating Unity plugins
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 集成 Unity 插件
- en: Best practices for using Unity plugins
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 Unity 插件的最佳实践
- en: Technical requirements
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: 'You will need the following to follow this chapter:'
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要以下内容来跟随本章：
- en: '**Unity version 2022.3.13**: Download and install Unity version 2022.3.13 or
    any other version. It is recommended to install the 2022 version.'
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity 版本 2022.3.13**：下载并安装 Unity 版本 2022.3.13 或任何其他版本。建议安装 2022 版本。'
- en: '**Primary IDE – Visual Studio 2022**: Ensure Visual Studio 2022 is installed
    for optimal learning.'
  id: totrans-10
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**主要 IDE – Visual Studio 2022**：确保已安装 Visual Studio 2022 以获得最佳学习体验。'
- en: '**GitHub repository for code samples**: Access code samples and project files
    on our GitHub repository: [https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2003](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2003).
    Clone or download the repository to have easy access to the code demonstrated
    in this chapter.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**GitHub 代码示例仓库**：访问我们的 GitHub 仓库中的代码示例和项目文件：[https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2003](https://github.com/PacktPublishing/Mastering-Unity-Game-Development-with-C-Sharp/tree/main/Assets/Chapter%2003)。克隆或下载仓库，以便轻松访问本章中展示的代码。'
- en: Understanding Unity plugins
  id: totrans-12
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 理解 Unity 插件
- en: In the world of game development, Unity plugins are like handy tools that developers
    can add to their toolkit. Think of them as special add-ons or extra features that
    make building games easier and more exciting.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 在游戏开发的世界里，Unity 插件就像是开发者可以添加到他们的工具箱中的便捷工具。把它们想象成特殊的附加组件或额外功能，使构建游戏变得更加容易和有趣。
- en: 'Let’s explore here how these optional upgrades can elevate your game development
    endeavors:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们在这里探讨这些可选升级如何提升您的游戏开发努力：
- en: '**Boost to game development**: Unity plugins are essential tools in the world
    of game development. These compact bundles of code serve as valuable additions
    to Unity, acting much like specialized ingredients seamlessly integrated into
    your game. Crafted by fellow developers, these plugins are generously shared within
    the Unity community, offering benefits to all.'
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**对游戏开发的提升**：Unity 插件是游戏开发世界中的必备工具。这些紧凑的代码包作为 Unity 的宝贵补充，就像无缝集成到您游戏中的专用成分。由同行开发者打造，这些插件在
    Unity 社区中慷慨共享，为所有人带来益处。'
- en: '**The significance of Unity plugins in game development**: The appeal of Unity
    plugins lies in their ability to enhance game development effortlessly. Picture
    this: you’re constructing a game, and you envision characters with incredibly
    smooth movements or breathtaking special effects such as dazzling explosions.
    Instead of grappling with complex code to achieve these elements, Unity plugins
    provide a solution. They save time and effort by leveraging the expertise of skilled
    developers, allowing you to relish the outcomes.'
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Unity 插件在游戏开发中的重要性**：Unity 插件的吸引力在于它们能够轻松地增强游戏开发。想象一下：您正在构建一个游戏，您想象着拥有极其流畅的动作或令人叹为观止的特殊效果，如耀眼的爆炸。而不是与复杂的代码搏斗以实现这些元素，Unity
    插件提供了一个解决方案。它们通过利用熟练开发者的专业知识来节省时间和精力，让您享受成果。'
- en: '**Extending functionality – elevating games to new heights**: Extending functionality
    with plugins is akin to granting your game superpowers. It goes beyond the basics,
    allowing you to incorporate various features without delving into the complexities
    of starting from square one. It’s like an upgrade for your game, making it more
    enjoyable and engaging.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**扩展功能 – 将游戏提升到新的高度**：通过插件扩展功能就像赋予你的游戏超级能力。它超越了基础功能，允许你无需深入研究从头开始的所有复杂性，就能整合各种功能。这就像是给你的游戏升级，使其更加有趣和吸引人。'
- en: 'Unity plugins play a vital role in the realm of game development, equipping
    developers with a toolbox to amplify the capabilities of Unity. It’s crucial to
    discern between two main categories of plugins: core plugins and extra plugins.
    Core plugins, inherent to Unity, provide foundational functionalities right out
    of the box. On the flip side, extra plugins act as optional upgrades, allowing
    you to tailor your toolkit to suit the specific needs of your project. To better
    understand these distinctions, let’s consider a comparison:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: Unity插件在游戏开发领域发挥着至关重要的作用，为开发者提供了一套工具箱，以增强Unity的功能。区分两个主要的插件类别至关重要：核心插件和额外插件。核心插件是Unity固有的，提供开箱即用的基础功能。另一方面，额外插件作为可选升级，允许你根据项目的具体需求定制工具箱。为了更好地理解这些区别，让我们考虑以下比较：
- en: '| **Plugin Type** | **Description** |'
  id: totrans-19
  prefs: []
  type: TYPE_TB
  zh: '| **插件类型** | **描述** |'
- en: '| Core plugins | Pre-packaged with Unity, offering foundational functionalities
    |'
  id: totrans-20
  prefs: []
  type: TYPE_TB
  zh: '| 核心插件 | 随Unity预包装，提供基础功能 |'
- en: '| Extra plugins | Optional upgrades that can be chosen based on specific project
    requirements |'
  id: totrans-21
  prefs: []
  type: TYPE_TB
  zh: '| 额外插件 | 根据特定项目需求可选的升级选项 |'
- en: In this chapter, we will prioritize additional plugins as they play a crucial
    role in enhancing the project, delving into how to seamlessly extend and integrate
    them into your projects. Our spotlight on the extra plugins falls on the **new
    Input System** and **Cinemachine** – as essential extra plugins, prominent choices
    for enhancing your game without delving into the core functionalities.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将优先考虑额外的插件，因为它们在增强项目方面发挥着至关重要的作用，深入探讨如何无缝扩展和集成它们到你的项目中。我们将重点关注**新的输入系统**和**Cinemachine**——作为重要的额外插件，它们是增强游戏而不深入研究核心功能的重要选择。
- en: In the next section, we will start talking about installing the plugins and
    how to extend them using C# scripts.
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将开始介绍如何安装插件以及如何使用C#脚本扩展它们。
- en: Integrating Unity plugins
  id: totrans-24
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 集成Unity插件
- en: Let’s delve into the seamless process of integrating external plugins into your
    Unity projects. Discover how this skill unlocks a world of possibilities, enhancing
    your game development experience with refined character movements, cinematic visual
    effects, and more. Dive in and elevate your projects.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们深入了解将外部插件无缝集成到Unity项目中的过程。发现这项技能如何解锁一个充满可能性的世界，通过精细的角色动作、电影般的视觉效果等，提升你的游戏开发体验。深入其中，提升你的项目。
- en: We will start with the new Input System and how to use it for handling input
    for our character.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将从新的输入系统及其如何用于处理角色的输入开始介绍。
- en: New Input System
  id: totrans-27
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 新输入系统
- en: 'Unity handles input through two systems: the older Input Manager, which is
    integrated into the editor, and the more recent Input System package. The aged
    Input Manager is an integral part of Unity’s core, readily available if you choose
    not to install the Input System package. Offering a fresher perspective, the Input
    System package enables you to employ any input device to govern your Unity content,
    taking the place of Unity’s traditional Input Manager. Installation of the new
    Input System package is a breeze – simply use the Package Manager. We will install
    it and use it in this section.'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: Unity通过两个系统处理输入：较旧的输入管理器，它是编辑器的一部分，以及较新的输入系统包。老旧的输入管理器是Unity核心的组成部分，如果你选择不安装输入系统包，它将直接可用。输入系统包提供了一个更新的视角，它允许你使用任何输入设备来控制你的Unity内容，取代了Unity的传统输入管理器。安装新的输入系统包非常简单——只需使用包管理器。我们将在本节中安装并使用它。
- en: 'In the following table, we’ll compare the old Input System with the new one,
    highlighting their key differences:'
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下表格中，我们将比较旧的输入系统与新的输入系统，突出它们的关键区别：
- en: '| **Feature** | **Old** **Input Manager** | **New** **Input System** |'
  id: totrans-30
  prefs: []
  type: TYPE_TB
  zh: '| **功能** | **旧** **输入管理器** | **新** **输入系统** |'
- en: '| Device support | Limited to keyboards, mice, and gamepads | Unified API for
    all devices |'
  id: totrans-31
  prefs: []
  type: TYPE_TB
  zh: '| 设备支持 | 限于键盘、鼠标和游戏手柄 | 针对所有设备的统一API |'
- en: '| Input actions | Basic button and axis mappings | Complex actions with triggers
    and combinations |'
  id: totrans-32
  prefs: []
  type: TYPE_TB
  zh: '| 输入动作 | 基本按钮和轴映射 | 带有触发器和组合的复杂动作 |'
- en: '| Architecture | Polling-based continuously checks input states at regular
    intervals, such as every frame, to detect changes and respond to user actions
    in real-time | Event-driven relies on triggering callbacks or events based on
    user actions, promoting modularity and efficient handling of input events without
    continuous polling |'
  id: totrans-33
  prefs: []
  type: TYPE_TB
  zh: '| 架构 | 基于轮询的连续检查在固定时间间隔（如每帧）检测输入状态的变化，以实时响应用户操作 | 事件驱动依赖于基于用户操作的触发回调或事件，促进模块化和高效处理输入事件，无需连续轮询
    |'
- en: '| Performance | Can be sluggish | Efficient and responsive |'
  id: totrans-34
  prefs: []
  type: TYPE_TB
  zh: '| 性能 | 可能会缓慢 | 高效且响应迅速 |'
- en: '| Extensibility | Closed system | Open-source and extensible |'
  id: totrans-35
  prefs: []
  type: TYPE_TB
  zh: '| 可扩展性 | 封闭系统 | 开源且可扩展 |'
- en: Excited for more exploration? Look forward to the following section, where we’ll
    delve into configuring the system, crafting personalized actions, and unlocking
    its full potential.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 对更多探索感到兴奋吗？期待下一节，我们将深入探讨配置系统、创建个性化动作和释放其全部潜力。
- en: Note
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Please be aware that the new Input System is compatible with Unity versions
    2019.4 and above, and it necessitates the .NET 4 runtime. Projects utilizing the
    old .NET 3.5 runtime are not supported.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，新输入系统与Unity 2019.4及以上版本兼容，并需要.NET 4运行时。使用旧.NET 3.5运行时的项目不受支持。
- en: 'In the following figure, you can choose **Input System** inside the **Package
    Manager** and install it:'
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，您可以在**包管理器**中选择**输入系统**并安装它：
- en: '![Figure 3.1 – Input System package inside Package Manager panel](img/B22017_03_01.jpg)'
  id: totrans-40
  prefs: []
  type: TYPE_IMG
  zh: '![图3.1 – 包管理器面板中的输入系统包](img/B22017_03_01.jpg)'
- en: Figure 3.1 – Input System package inside Package Manager panel
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.1 – 包管理器面板中的输入系统包
- en: 'After finishing the installation process, Unity will ask you if you want to
    enable the new backends. By choosing **Yes**, Unity will enable the new backends
    and disable the old backends, and the Unity Editor will restart. You can see a
    **Warning** message in the following figure:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 完成安装过程后，Unity将询问您是否想要启用新后端。通过选择**是**，Unity将启用新后端并禁用旧后端，Unity编辑器将重新启动。您可以在以下图中看到**警告**信息：
- en: '![Figure 3.2 – Warning message after installing the new Input System](img/B22017_03_02.jpg)'
  id: totrans-43
  prefs: []
  type: TYPE_IMG
  zh: '![图3.2 – 安装新输入系统后的警告信息](img/B22017_03_02.jpg)'
- en: Figure 3.2 – Warning message after installing the new Input System
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.2 – 安装新输入系统后的警告信息
- en: Please take note that you have the option to simultaneously enable both the
    old and new systems. To accomplish this, set **Active Input Handling** to **Both**.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，您可以选择同时启用旧系统和新系统。为此，将**Active Input Handling**设置为**Both**。
- en: Locate the relevant setting in the **Player** settings (navigate to **Edit**
    | **Project Settings** | **Player**), specifically under **Active Input Handling**.
    Feel free to adjust this setting at your convenience; however, please note that
    making changes will necessitate restarting the Editor.
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 在**Player**设置中找到相关设置（导航至**Edit** | **Project Settings** | **Player**），具体在**Active
    Input Handling**下。您可以根据需要调整此设置；然而，请注意，进行更改将需要重新启动编辑器。
- en: '![Figure 3.3 – Input settings inside the Project Settings](img/B22017_03_03.jpg)'
  id: totrans-47
  prefs: []
  type: TYPE_IMG
  zh: '![图3.3 – 项目设置中的输入设置](img/B22017_03_03.jpg)'
- en: Figure 3.3 – Input settings inside the Project Settings
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.3 – 项目设置中的输入设置
- en: Now that we’ve been introduced to the new Input System, let’s explore its implementation.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经介绍了新输入系统，让我们探索其实现。
- en: Implementing Unity’s new Input System
  id: totrans-50
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 实现Unity的新输入系统
- en: In this subsection, our focus shifts to the practical application of Unity’s
    new Input System. Get ready to dive into hands-on learning as we guide you through
    the step-by-step process of implementation. By the end of this section, you’ll
    have the skills and knowledge needed to seamlessly integrate the new Input System
    into your Unity projects, enhancing control and responsiveness. Let’s get hands-on
    and delve into the practical steps of implementing this powerful tool together.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 在本小节中，我们的重点转向Unity新输入系统的实际应用。准备好通过我们引导的逐步实施过程进行动手学习。在本节结束时，您将具备将新输入系统无缝集成到Unity项目中的技能和知识，增强控制和响应性。让我们动手操作，一起深入了解实施此强大工具的实际步骤。
- en: In Unity’s new Input System, `InputActions` are pivotal for defining and structuring
    input controls such as keyboard keys, mouse buttons, and controller inputs within
    an InputActionAsset. These actions are bound to specific input bindings and organized
    into logical groupings called `PlayerInput` component integrates InputActions
    into GameObjects, allowing for efficient input event handling through callbacks
    and events. InputActions support rebinding and overrides, empowering players to
    customize input bindings while maintaining a cohesive Input System architecture
    that enhances modularity and reusability compared to Unity’s legacy Input System.
    Let’s use the new Input System.
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 在 Unity 的新输入系统中，`InputActions` 对于定义和结构化输入控制（如键盘键、鼠标按钮和控制器输入）至关重要，这些控制绑定到特定的输入绑定，并组织成逻辑分组，称为
    `PlayerInput` 组件。这些动作通过回调和事件集成到 GameObject 中，允许通过回调和事件高效地处理输入事件。InputActions 支持重新绑定和覆盖，使玩家能够自定义输入绑定，同时保持一个增强模块化和可重用性的输入系统架构，与
    Unity 的传统输入系统相比。让我们使用新的输入系统。
- en: 'Create a new input action (**Create** | **Input Actions**) in the folder inside
    your project, as you can see in the next figure:'
  id: totrans-53
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在你的项目文件夹内创建一个新的输入动作（**创建** | **输入动作**），如图所示：
- en: '![Figure 3.4 – Choosing Input Actions from the Create panel](img/B22017_03_04.jpg)'
  id: totrans-54
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.4 – 从创建面板选择输入动作](img/B22017_03_04.jpg)'
- en: Figure 3.4 – Choosing Input Actions from the Create panel
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.4 – 从创建面板选择输入动作
- en: 'Then, you can open this input action, and a new panel will appear, as shown
    in the following figure:'
  id: totrans-56
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，你可以打开这个输入动作，并会出现一个新的面板，如图所示：
- en: '![Figure 3.5 – Input Action panel](img/B22017_03_05.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.5 – 输入动作面板](img/B22017_03_05.jpg)'
- en: Figure 3.5 – Input Action panel
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.5 – 输入动作面板
- en: 'Change the **Action Type** value to **Pass Through** and **Control Type** to
    **Vector 2**, as you can see in the following figure:'
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将**动作类型**值更改为**透传**和**控制类型**为**向量 2**，如图所示：
- en: '![Figure 3.6 – Action Properties](img/B22017_03_06.jpg)'
  id: totrans-60
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.6 – 动作属性](img/B22017_03_06.jpg)'
- en: Figure 3.6 – Action Properties
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.6 – 动作属性
- en: 'Then, choose to add bindings for movement, as you can see in the next figure:'
  id: totrans-62
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，选择添加移动的绑定，正如你在下一张图中可以看到的：
- en: '![Figure 3.7 – Choosing bindings for movement](img/B22017_03_07.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.7 – 选择移动绑定](img/B22017_03_07.jpg)'
- en: Figure 3.7 – Choosing bindings for movement
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.7 – 选择移动绑定
- en: 'Here, you can rename the name of the movement binding. Also, you can start
    to set the input keys for each process in the **Path** dropdown, as you can see
    in the following figure:'
  id: totrans-65
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在这里，你可以重命名移动绑定的名称。你还可以开始设置**路径**下拉菜单中每个过程的输入键，如图所示：
- en: '![Figure 3.8 – Movement binding](img/B22017_03_08.jpg)'
  id: totrans-66
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.8 – 移动绑定](img/B22017_03_08.jpg)'
- en: Figure 3.8 – Movement binding
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.8 – 移动绑定
- en: 'The magic of the new Input System shines as you can assign multiple bindings
    for the same action across different devices, as demonstrated in the following
    figure:'
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 新输入系统的魔法在于你可以为同一动作在不同设备上分配多个绑定，如图所示：
- en: '![Figure 3.9 – Arrows bindings](img/B22017_03_09.jpg)'
  id: totrans-69
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.9 – 箭头绑定](img/B22017_03_09.jpg)'
- en: Figure 3.9 – Arrows bindings
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.9 – 箭头绑定
- en: 'You can also add new actions for **Jump** and **Dash**, but for them, you need
    to change the **Action Type** value to **Button**. Your final settings should
    look something like this:'
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 你也可以为**跳跃**和**连击**添加新的动作，但为此，你需要将**动作类型**值更改为**按钮**。你的最终设置应该看起来像这样：
- en: '![Figure 3.10 – Adding Jump and Dash](img/B22017_03_10.jpg)'
  id: totrans-72
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.10 – 添加跳跃和连击](img/B22017_03_10.jpg)'
- en: Figure 3.10 – Adding Jump and Dash
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.10 – 添加跳跃和连击
- en: 'As the final step for this input action asset, you need to return to the input
    action in **Inspector** and choose **Generate C# Class** for it:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 作为此输入动作资产的最后一步，你需要回到**检查器**中的输入动作，并为其选择**生成 C# 类**：
- en: '![Figure 3.11 – Generating an input class](img/B22017_03_11.jpg)'
  id: totrans-75
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.11 – 生成输入类](img/B22017_03_11.jpg)'
- en: Figure 3.11 – Generating an input class
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.11 – 生成输入类
- en: 'Then, we will create a wrapper script to take callbacks from the inputs and
    invoke new actions to perform movement:'
  id: totrans-77
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将创建一个包装脚本，从输入中获取回调并调用新动作以执行移动：
- en: 'We are going to create a wrapper for using the new Input System, starting with
    implementing gameplay map actions in our `PlayerInput` script as follows:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们将创建一个包装器来使用新的输入系统，首先在我们的 `PlayerInput` 脚本中实现游戏玩法映射动作，如下所示：
- en: '[PRE0]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Also, we will register callbacks for this action and create events so that
    we can use them later in our **PlayerMovement** script, as you can see in the
    following code block:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此外，我们还将为这个动作注册回调并创建事件，以便我们可以在后续的 **PlayerMovement** 脚本中使用它们，如下面的代码块所示：
- en: '[PRE1]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Now, magic happens here. When we get the action callback and then invoke our
    events, we will subscribe to these events in the **PlayerMovement** script, as
    you can see in the following code block:'
  id: totrans-82
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，魔法就在这里发生。当我们获取动作回调并调用我们的事件时，我们将在 **PlayerMovement** 脚本中订阅这些事件，如下面的代码块所示：
- en: '[PRE2]'
  id: totrans-83
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Here are the functions for movement in the `PlayerMovement` script:'
  id: totrans-84
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这是 `PlayerMovement` 脚本中的移动功能：
- en: '[PRE3]'
  id: totrans-85
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Voilà! The new Input System is now employed for player movement.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 哇！新的输入系统现在被用于玩家移动。
- en: Discussing advanced techniques
  id: totrans-87
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 讨论高级技术
- en: 'In the upcoming section, we are going to talk about more advanced techniques
    for the new Input System. Let’s explore Unity’s Input System features by looking
    at Interactions and Processors, which help adjust input signals before they activate
    actions:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将讨论新输入系统的更多高级技术。让我们通过查看交互和处理器来探索 Unity 输入系统的功能，这些功能有助于在激活动作之前调整输入信号：
- en: '**Interactions**: Interactions modify or filter the raw input signal before
    reaching the action. Unity’s Input System provides a variety of built-in Interactions,
    such as **Tap**, **Slow Tap**, and **Press**, each serving specific use cases.
    For example, we can utilize **Multi Tap** for double jumps or activating special
    powers, while **Press** can help solve parts of puzzles in the game.'
  id: totrans-89
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**交互**：交互在原始输入信号到达动作之前对其进行修改或过滤。Unity 的输入系统提供了一系列内置的交互，如 **Tap**（轻触）、**Slow
    Tap**（慢触）和 **Press**（按下），每个都针对特定的用例。例如，我们可以使用 **Multi Tap** 来实现双跳或激活特殊能力，而 **Press**
    可以帮助解决游戏中的部分谜题。'
- en: 'In the following figure, you can find a list of Interactions to be applied:'
  id: totrans-90
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以找到一个应用交互的列表：
- en: '![Figure 3.12 – Interactions](img/B22017_03_12.jpg)'
  id: totrans-91
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.12 – 交互](img/B22017_03_12.jpg)'
- en: Figure 3.12 – Interactions
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.12 – 交互
- en: '**Processors**: Processors are applied to the input data after the Interaction
    but before the action triggers. They allow you to manipulate the input data, such
    as scaling, inverting, or smoothing analog values. Processors contribute to the
    fine-tuning of input behavior; you can apply them on controls, bindings, and actions.'
  id: totrans-93
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**处理器**：处理器在交互之后但在动作触发之前应用于输入数据。它们允许你操纵输入数据，例如缩放、反转或平滑模拟值。处理器有助于输入行为的微调；你可以在控制、绑定和动作上应用它们。'
- en: 'In the following figure, you will find a list of Processors to be applied:'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以找到一个应用处理器的列表：
- en: '![Figure 3.13 – Processors](img/B22017_03_13.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.13 – 处理器](img/B22017_03_13.jpg)'
- en: Figure 3.13 – Processors
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.13 – 处理器
- en: Having gained insights into Unity’s Input System, we now understand how Interactions
    and Processors refine input signals, enhancing control mechanisms within our game
    development endeavors. In the next section, let’s delve into Cinemachine, an essential
    tool in Unity that revolutionizes game development with cinematic flair.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在深入了解 Unity 的输入系统后，我们现在理解了交互和处理器如何细化输入信号，增强我们游戏开发中的控制机制。在下一节中，让我们深入探讨 Cinemachine，这是
    Unity 中的一个重要工具，它以电影化的风格彻底改变了游戏开发。
- en: Cinemachine
  id: totrans-98
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: Cinemachine
- en: Let’s talk about Cinemachine, a game-changer in Unity that takes your game development
    to cinematic levels. If you’re a Unity developer, Cinemachine is your go-to tool
    for effortlessly managing dynamic camera moves, crafting cinematic scenes, and
    enhancing the way players navigate virtual worlds.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们谈谈 Cinemachine，这是 Unity 中的一个游戏改变者，它将你的游戏开发提升到电影化的水平。如果你是 Unity 开发者，Cinemachine
    是你用于轻松管理动态摄像机移动、制作电影场景以及增强玩家在虚拟世界中导航方式的必备工具。
- en: At its core, Cinemachine introduces virtual cameras, which are like your personal
    camera crew for the digital stage. No need for complex camera scripts – Cinemachine
    simplifies the process, making it easy to guide player perspectives. Whether you
    want action-packed shots, serene landscapes, or immersive story moments, Cinemachine
    lets you play director without the headaches.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 在其核心，Cinemachine 引入了虚拟摄像机，它们就像你在数字舞台上的个人摄像团队。无需复杂的摄像机脚本——Cinemachine 简化了这一过程，使得引导玩家视角变得容易。无论你想要充满动作的镜头、宁静的风景，还是沉浸式的叙事时刻，Cinemachine
    都让你能够轻松地扮演导演，无需头痛。
- en: Benefits of Cinemachine
  id: totrans-101
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: Cinemachine 的好处
- en: 'Explore the array of features Cinemachine offers for seamless and captivating
    camera control and storytelling in Unity game development as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 按照以下方式探索 Cinemachine 在 Unity 游戏开发中提供的功能，以实现无缝和引人入胜的摄像机控制和叙事：
- en: '**Intuitive controls**: Cinemachine provides a user-friendly interface and
    intuitive controls, eliminating the need for complex camera scripting and making
    it accessible to developers of all skill levels'
  id: totrans-103
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**直观控制**：Cinemachine 提供了用户友好的界面和直观的控制，消除了复杂相机脚本的需求，使得所有技能水平的开发者都能使用。'
- en: '**Effortless perspective guidance**: With Cinemachine, you can effortlessly
    guide player perspectives, from dynamic action sequences to serene landscapes,
    without delving into intricate code'
  id: totrans-104
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**轻松的视角引导**：使用 Cinemachine，您可以轻松引导玩家视角，从动态动作序列到宁静的风景，而无需深入研究复杂的代码。'
- en: '**Realism with procedural noise**: Cinemachine introduces realism into scenes
    through procedural noise, offering subtle yet impactful effects such as camera
    shakes during key moments, enhancing the overall gaming experience'
  id: totrans-105
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**通过程序噪声实现逼真效果**：Cinemachine 通过程序噪声将逼真感引入场景，提供诸如在关键时刻相机抖动等微妙而影响深远的效果，从而增强整体游戏体验。'
- en: '**Composer for automatic framing**: The **Composer** component automates the
    camera’s position and **field-of-view** (**FOV**) adjustments, ensuring focus
    on essential elements, streamlining the framing process, and saving valuable development
    time'
  id: totrans-106
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**自动构图组件**：**Composer** 组件自动调整相机的位置和**视野**（**FOV**）设置，确保关注关键元素，简化构图过程，并节省宝贵的发展时间。'
- en: '**Seamless Timeline integration**: Cinemachine seamlessly integrates with Unity’s
    Timeline, enabling the easy creation of cinematic sequences for a more immersive
    and narrative-driven gaming experience'
  id: totrans-107
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**无缝时间轴集成**：Cinemachine 与 Unity 的 Timeline 无缝集成，使得创建电影化序列变得简单，从而提供更沉浸和以叙事驱动的游戏体验。'
- en: '**Enhanced storytelling capabilities**: Beyond a camera system, Cinemachine
    acts as a creative ally, enhancing storytelling capabilities and making games
    more captivating and memorable for players'
  id: totrans-108
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**增强的叙事能力**：除了相机系统之外，Cinemachine 还作为创意盟友，增强叙事能力，使游戏对玩家更具吸引力和难忘。'
- en: In summary, Cinemachine presents an array of features designed to streamline
    camera control and enhance storytelling in Unity game development, offering intuitive
    controls, effortless perspective guidance, realism with procedural noise, automated
    framing with the **Composer** component, seamless Timeline integration, and enhanced
    storytelling capabilities.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Cinemachine 提供了一系列功能，旨在简化相机控制和增强 Unity 游戏开发中的叙事，提供直观的控制、轻松的视角引导、程序噪声带来的逼真效果、Composer
    组件的自动化构图、无缝的时间轴集成和增强的叙事能力。
- en: Using Cinemachine in our game
  id: totrans-110
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 在我们的游戏中使用 Cinemachine
- en: Let’s kick off our journey with Cinemachine by exploring how to integrate it
    into our game seamlessly. In this subsection, we will learn how to install Cinemachine
    and set up your virtual camera for enhanced scene management and dynamic camera
    movements.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们以 Cinemachine 为起点，探索如何无缝将其集成到我们的游戏中。在本小节中，我们将学习如何安装 Cinemachine 并设置虚拟相机，以增强场景管理和动态相机运动。
- en: 'In the following figure, you can see the **Package Manager** panel, from which
    you can choose and install packages and wait till the editor finishes compiling
    scripts:'
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，您可以看到**包管理器**面板，您可以从其中选择和安装包，并等待编辑器完成脚本编译：
- en: '![Figure 3.14 – Installing Cinemachine from the Package Manager](img/B22017_03_14.jpg)'
  id: totrans-113
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.14 – 从包管理器安装 Cinemachine](img/B22017_03_14.jpg)'
- en: Figure 3.14 – Installing Cinemachine from the Package Manager
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.14 – 从包管理器安装 Cinemachine
- en: 'Unity provides a variety of cameras within the Cinemachine package. Let’s discuss
    some of these cameras and their respective uses:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: Unity 在 Cinemachine 包中提供了各种相机。让我们讨论一些这些相机及其相应的用途：
- en: '**Freelook** **Camera (CinemachineFreeLook)**:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**Freelook 相机（CinemachineFreeLook）**：'
- en: '*Usage*: The Freelook Camera provides versatile control for creating dynamic
    and cinematic camera movements in 3D environments. It is often used for character
    exploration, action sequences, and immersive gameplay experiences where fluid
    camera motion adds depth and engagement.'
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用法*：Freelook Camera 提供了在 3D 环境中创建动态和电影化相机运动的灵活控制。它常用于角色探索、动作序列和沉浸式游戏体验，其中流畅的相机运动增加了深度和参与感。'
- en: '*Key features*: Allows for multi-axis rotation, adjustable follow and look-at
    targets, customizable damping for smooth transitions, and the ability to define
    multiple rig configurations for different camera behaviors.'
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主要功能*：允许进行多轴旋转、可调整的跟随和注视目标、可定制的阻尼以实现平滑过渡，以及为不同相机行为定义多个机架配置的能力。'
- en: '**Virtual** **Camera (CinemachineVirtualCamera)**:'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**虚拟相机（CinemachineVirtualCamera）**：'
- en: '*Usage*: The Virtual Camera serves as a foundational camera tool in Cinemachine,
    offering precise control over framing, composition, and behavior. It is suitable
    for a wide range of scenarios, including character tracking, scene framing, cutscenes,
    and scripted camera sequences.'
  id: totrans-120
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用法*：虚拟相机是Cinemachine中的基础相机工具，提供对构图、构图和行为精确控制的选项。它适用于各种场景，包括角色跟踪、场景构图、电影场景和脚本化相机序列。'
- en: '*Key features*: Provides options for target tracking, damping settings for
    smooth transitions, customizable FOV, **depth of field** (**DOF**), and various
    blending modes for seamless camera transitions and effects.'
  id: totrans-121
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主要功能*：提供目标跟踪选项、平滑过渡的阻尼设置、可自定义的FOV、**景深**（**DOF**）以及各种混合模式，以实现无缝的相机过渡和效果。'
- en: '**2D** **Camera (CinemachineVirtualCamera)**:'
  id: totrans-122
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**2D** **相机 (CinemachineVirtualCamera)**:'
- en: '*Usage*: The 2D Camera variant of CinemachineVirtualCamera is specifically
    designed for 2D game development, offering similar functionality to the 3D Virtual
    Camera but tailored for 2D environments. It is ideal for platformers, side-scrolling
    games, and other 2D projects requiring dynamic camera control.'
  id: totrans-123
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*用法*：CinemachineVirtualCamera的2D相机变体专门为2D游戏开发设计，提供与3D虚拟相机类似的功能，但针对2D环境进行了优化。它非常适合平台游戏、横版滚动游戏以及其他需要动态相机控制的2D项目。它非常适合平台游戏、横版滚动游戏和其他需要动态相机控制的2D项目。'
- en: '*Key features*: Supports 2D-specific settings such as orthographic mode, pixel-perfect
    camera setup, pixel snapping, and follow and dead zones tailored for 2D gameplay
    mechanics. Allows for smooth tracking of 2D characters, parallax effects, and
    cinematic camera movements in 2D space.'
  id: totrans-124
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '*主要功能*：支持2D特定设置，如正交模式、像素级相机设置、像素吸附、以及针对2D游戏机制优化的跟随和死区。允许平滑跟踪2D角色、视差效果和2D空间中的电影式相机运动。'
- en: In the following demonstration, we’ll implement the Virtual Camera to highlight
    the specific changes that occur when transitioning from Unity’s default camera
    to Cinemachine cameras.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下演示中，我们将实现虚拟相机，以突出从Unity默认相机切换到Cinemachine相机时发生的具体变化。
- en: 'Choose **Virtual Camera** from the **Cinemachine** list. When you try to add
    components, the main camera will be managed by Cinemachine moving forward:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 从**Cinemachine**列表中选择**虚拟相机**。当你尝试添加组件时，主相机将由Cinemachine管理：
- en: '![Figure 3.15 – Virtual Camera option](img/B22017_03_15.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图3.15 – 虚拟相机选项](img/B22017_03_15.jpg)'
- en: Figure 3.15 – Virtual Camera option
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.15 – 虚拟相机选项
- en: 'After choosing **Virtual Camera**, the **CinemachineBrain** component will
    be added to the **MainCamera** GameObject, as seen in *Figure 3**.16*. The **CinemachineBrain**
    component orchestrates multiple virtual cameras, managing their activation, blending,
    and behavior for smooth transitions and dynamic camera control, crucial for creating
    immersive and visually engaging scenes in Unity projects using Cinemachine:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 选择**虚拟相机**后，**CinemachineBrain**组件将被添加到**MainCamera**游戏对象中，如图*图3*.16所示。**CinemachineBrain**组件协调多个虚拟相机，管理它们的激活、混合和行为，以实现平滑过渡和动态相机控制，这对于在Unity项目中使用Cinemachine创建沉浸式和视觉上引人入胜的场景至关重要：
- en: '![Figure 3.16 – CinemachineBrain component](img/B22017_03_16.jpg)'
  id: totrans-130
  prefs: []
  type: TYPE_IMG
  zh: '![图3.16 – CinemachineBrain组件](img/B22017_03_16.jpg)'
- en: Figure 3.16 – CinemachineBrain component
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.16 – CinemachineBrain组件
- en: 'Also, it will create a new game object for this virtual camera inside the scene
    that has the **CinemachineVirtualCamera** component, as seen in the following
    figure:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它还会在场景中为这个虚拟相机创建一个新的游戏对象，该对象包含**CinemachineVirtualCamera**组件，如图所示：
- en: '![Figure 3.17 – CinemachineVirtualCamera component](img/B22017_03_17.jpg)'
  id: totrans-133
  prefs: []
  type: TYPE_IMG
  zh: '![图3.17 – CinemachineVirtualCamera组件](img/B22017_03_17.jpg)'
- en: Figure 3.17 – CinemachineVirtualCamera component
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.17 – CinemachineVirtualCamera组件
- en: In summary, you successfully integrated Cinemachine into your game, allowing
    for streamlined camera management and dynamic virtual camera movements to enhance
    your game’s visual experience.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，你成功地将Cinemachine集成到你的游戏中，允许进行简化的相机管理和动态虚拟相机运动，以增强你的游戏视觉体验。
- en: Enhancing gameplay dynamics – adding shake effects with Cinemachine
  id: totrans-136
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 使用Cinemachine增强游戏动态性 – 添加震动效果
- en: Utilizing Cinemachine to elevate our game experience, we’ll now explore the
    integration of effects, specifically focusing on incorporating a shake effect
    using the **CinemachineImpulseListener** component. This essential component in
    Unity’s Cinemachine package acts as a crucial receiver of impulse signals from
    other Cinemachine modules, translating them into impactful visual and auditory
    effects within the game. Its primary function involves listening for impulse signals
    triggered by events such as collisions or explosions, enabling developers to apply
    customizable parameters such as intensity and duration for immersive feedback
    experiences. Seamlessly integrated with Cinemachine modules, the **CinemachineImpulseListener**
    component enhances gameplay and cinematic effects by delivering synchronized and
    dynamic responses to in-game events, thus significantly enhancing the overall
    immersive and engaging player experience.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 利用Cinemachine提升我们的游戏体验，我们现在将探索效果的集成，特别是关注使用**CinemachineImpulseListener**组件来整合震动效果。这个Unity
    Cinemachine包中的关键组件作为其他Cinemachine模块脉冲信号的至关重要接收器，将它们转换成游戏中的影响力和听觉效果。其主要功能涉及监听由碰撞或爆炸等事件触发的脉冲信号，使开发者能够应用可定制的参数，如强度和持续时间，以提供沉浸式反馈体验。与Cinemachine模块无缝集成，**CinemachineImpulseListener**组件通过向游戏事件提供同步和动态响应，增强了游戏玩法和电影效果，从而显著提升了整体沉浸感和参与感玩家体验。
- en: The shake effect stands out as a highly impactful element in game design, contributing
    significantly to the overall player experience. Whether applied to simulate fire,
    collisions, or other gameplay elements, this effect adds a layer of dynamism and
    engagement. Integrating a shake effect effectively enhances the player’s immersion
    during gameplay, creating a more compelling and enjoyable experience.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 震动效果在游戏设计中是一个极具影响力的元素，对整体玩家体验的贡献显著。无论应用于模拟火焰、碰撞或其他游戏元素，此效果都增加了一层动态性和参与感。有效地集成震动效果可以增强玩家在游戏中的沉浸感，创造一个更具吸引力和愉悦的体验。
- en: 'We will begin implementing this feature in the following steps:'
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将在以下步骤中开始实现此功能：
- en: 'We will start by clicking on **Add Extension**. It will show us a menu like
    this:'
  id: totrans-140
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们将首先点击**添加扩展**。它将显示如下菜单：
- en: '![Figure 3.18 – Extensions menu](img/B22017_03_18.jpg)'
  id: totrans-141
  prefs: []
  type: TYPE_IMG
  zh: '![图3.18 – 扩展菜单](img/B22017_03_18.jpg)'
- en: Figure 3.18 – Extensions menu
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.18 – 扩展菜单
- en: Then, we click on the **CinemachineImpulseListener** component to add to our
    camera.
  id: totrans-143
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们点击**CinemachineImpulseListener**组件将其添加到我们的相机中。
- en: 'We can tweak the values inside this component to achieve a better effect for
    our game, as you can see in the following figure:'
  id: totrans-144
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 我们可以调整此组件内的值以获得更好的游戏效果，如图所示：
- en: '![Figure 3.19 – CinemachineImpulseListener component](img/B22017_03_19.jpg)'
  id: totrans-145
  prefs: []
  type: TYPE_IMG
  zh: '![图3.19 – CinemachineImpulseListener组件](img/B22017_03_19.jpg)'
- en: Figure 3.19 – CinemachineImpulseListener component
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.19 – CinemachineImpulseListener组件
- en: 'You can learn more about values in Unity’s official documentation: [https://docs.unity3d.com/Packages/com.unity.cinemachine@2.3/manual/](https://docs.unity3d.com/Packages/com.unity.cinemachine@2.3/manual/).'
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在Unity官方文档中了解更多关于这些值的信息：[https://docs.unity3d.com/Packages/com.unity.cinemachine@2.3/manual/](https://docs.unity3d.com/Packages/com.unity.cinemachine@2.3/manual/)。
- en: Tip
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: For most Unity components, tooltips appear when you hover your mouse over the
    variable name.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 对于大多数Unity组件，当鼠标悬停在变量名上时，会显示工具提示。
- en: Then, we need to add **CinemachineImpulseSource** to a game object. In our case,
    we can easily add it to the player game object, as most Interactions will be from
    this player. The **CinemachineImpulseSource** component in Unity’s Cinemachine
    package is a versatile tool for generating impulse signals that simulate impactful
    events within a game. By defining parameters such as intensity and duration, we
    can create a range of effects such as camera shakes, controller vibrations, or
    screen flashes. Integrated seamlessly with other Cinemachine components, **CinemachineImpulseSource**
    enhances gameplay and cinematic experiences by allowing dynamic responses to events
    and fine-tuning effects for immersive and engaging player experiences. Its customization
    options and scripting capabilities enable us to tailor effects to match the game’s
    aesthetics and mechanics, adding depth and interactivity to the overall game world.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们需要将**CinemachineImpulseSource**添加到一个游戏对象中。在我们的例子中，我们可以轻松地将其添加到玩家游戏对象中，因为大多数交互都将来自这个玩家。Unity的Cinemachine包中的**CinemachineImpulseSource**组件是一个多功能的工具，用于生成脉冲信号，以模拟游戏中的影响性事件。通过定义强度和持续时间等参数，我们可以创建一系列效果，如相机震动、控制器震动或屏幕闪烁。与Cinemachine的其他组件无缝集成，**CinemachineImpulseSource**通过允许对事件进行动态响应和调整效果以实现沉浸式和吸引人的玩家体验来增强游戏玩法和电影体验。其定制选项和脚本功能使我们能够根据游戏的美学和机制定制效果，为整体游戏世界增添深度和交互性。
- en: 'We will need a reference to **CinemachineImpulseSource** in our scripts to
    start using it:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要在我们的脚本中引用**CinemachineImpulseSource**以开始使用它：
- en: '![Figure 3.20 – CinemachineImpulseSource component](img/B22017_03_20.jpg)'
  id: totrans-152
  prefs: []
  type: TYPE_IMG
  zh: '![图3.20 – CinemachineImpulseSource组件](img/B22017_03_20.jpg)'
- en: Figure 3.20 – CinemachineImpulseSource component
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.20 – CinemachineImpulseSource组件
- en: Now, we will use the **PlayerEffects** script, which will subscribe to the **PlayerShoot**
    fire event to generate an impulse.
  id: totrans-154
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将使用**PlayerEffects**脚本，该脚本将订阅**PlayerShoot**射击事件以生成脉冲。
- en: 'In the following code, we will generate an impulse when the player shoots fire:'
  id: totrans-155
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 在下面的代码中，我们将生成脉冲，当玩家射击火焰时：
- en: '[PRE4]'
  id: totrans-156
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: That’s it! Now, whenever the player shoots, the effect will be applied.
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 就这样！现在，每当玩家射击时，效果都会被应用。
- en: Dynamic cinematic experiences – seamless camera blending with Cinemachine
  id: totrans-158
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 动态电影体验 - 使用Cinemachine实现无缝相机融合
- en: Another application of **Cinemachine** lies in its ability to manage multiple
    cameras concurrently and seamlessly blend between them at runtime. This functionality
    proves valuable in scenarios where you want to create a dedicated camera for specific
    in-game events. For instance, you can design a special camera that triggers when
    the player encounters a boss, automatically activating when the player enters
    a boss room.
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: '**Cinemachine**的另一个应用在于其能够同时管理多个相机并在运行时无缝地在它们之间切换。这种功能在需要为特定游戏事件创建专用相机的场景中非常有价值。例如，你可以设计一个特殊的相机，当玩家遇到Boss时触发，玩家进入Boss房间时自动激活。'
- en: 'In the following figure, you can find the option to add custom blends in the
    Cinemachine component. Click **Create Asset** to generate a new scriptable object,
    which will be responsible for managing the transition between cameras, as well
    as orchestrating the tween action during the transition:'
  id: totrans-160
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的图中，你可以在Cinemachine组件中找到添加自定义融合的选项。点击**创建资产**以生成一个新的可脚本化对象，该对象将负责管理相机之间的过渡，以及协调过渡过程中的缓动动作：
- en: '![Figure 3.21 – Custom Blends section in Cinemachine component](img/B22017_03_21.jpg)'
  id: totrans-161
  prefs: []
  type: TYPE_IMG
  zh: '![图3.21 – Cinemachine组件中的自定义融合部分](img/B22017_03_21.jpg)'
- en: Figure 3.21 – Custom Blends section in Cinemachine component
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 图3.21 – Cinemachine组件中的自定义融合部分
- en: 'As seen in the following figure, using a scriptable object for **CinemachineBlenderSettings**,
    you can add transitions between cameras. The **CinemachineBlenderSettings** component
    in Unity’s Cinemachine package is instrumental in orchestrating smooth transitions
    between virtual cameras within a scene. By defining blend curves, weighting parameters,
    and blend techniques, we can control the rate, style, and visual dominance of
    camera blending, resulting in seamless and visually engaging camera movements
    during gameplay or cinematic sequences. With support for prioritization, triggering
    mechanisms, and extensive customization options, **CinemachineBlenderSettings**
    empowers us to create dynamic and immersive camera transitions tailored to the
    game’s aesthetics and narrative, enhancing overall player experience and immersion:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 如以下图所示，使用可脚本对象 **CinemachineBlenderSettings**，您可以在相机之间添加过渡。Unity Cinemachine
    包中的 **CinemachineBlenderSettings** 组件在场景中协调虚拟相机之间的平滑过渡中起着关键作用。通过定义混合曲线、权重参数和混合技术，我们可以控制相机混合的速度、风格和视觉主导性，从而在游戏玩法或电影序列中实现无缝且引人入胜的相机运动。支持优先级、触发机制和广泛的定制选项，**CinemachineBlenderSettings**
    使我们能够创建符合游戏美学和叙事的动态和沉浸式相机过渡，从而增强整体玩家体验和沉浸感：
- en: '![Figure 3.22 – CinemachineBlenderSettings scriptable object](img/B22017_03_22.jpg)'
  id: totrans-164
  prefs: []
  type: TYPE_IMG
  zh: '![图 3.22 – CinemachineBlenderSettings 可脚本对象](img/B22017_03_22.jpg)'
- en: Figure 3.22 – CinemachineBlenderSettings scriptable object
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 图 3.22 – CinemachineBlenderSettings 可脚本对象
- en: To utilize this functionality, you can enable or disable the game objects of
    the cameras or adjust the priority of the current camera by increasing it and
    decreasing the priority of the previous camera.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 要利用此功能，您可以通过增加当前相机的优先级并降低前一个相机的优先级来启用或禁用相机的游戏对象或调整当前相机的优先级。
- en: '[PRE5]'
  id: totrans-167
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: '[PRE6]'
  id: totrans-168
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: You can find all the code in our GitHub repo, the link to which is mentioned
    in the *Technical* *requirements* section.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在我们的 GitHub 仓库中找到所有代码，其链接在 *技术要求* 部分中提及。
- en: Note
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: I have chosen to use enums instead of strings for better performance efficiency.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择使用枚举而不是字符串以提高性能效率。
- en: 'The following code outlines the enum for various camera types:'
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码概述了各种相机类型的枚举：
- en: '[PRE7]'
  id: totrans-173
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: '[PRE8]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Tip
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 小贴士
- en: Given the abundance of Unity plugins, it’s essential to pick the right one for
    your project.
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 由于 Unity 插件众多，选择适合您项目的正确插件至关重要。
- en: In conclusion, Cinemachine offers Unity developers intuitive camera controls,
    effortless perspective guidance, realism with procedural noise, automatic framing,
    seamless Timeline integration, and enhanced storytelling capabilities. As we conclude
    this section, we have explored its features and benefits, preparing to leverage
    its power in our game development endeavors.
  id: totrans-177
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，Cinemachine 为 Unity 开发者提供了直观的相机控制、轻松的视角引导、通过程序噪声实现的逼真效果、自动构图、无缝时间轴集成以及增强的叙事能力。在本节结束时，我们探讨了其功能和优势，为在游戏开发中利用其力量做准备。
- en: Best practices for using Unity plugins
  id: totrans-178
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用 Unity 插件的最佳实践
- en: 'Before integrating plugins into your project, it’s essential to thoroughly
    explore their functionality, understand their documentation, assess compatibility
    and potential impact, evaluate specific features, stay updated with releases,
    check version compatibility, maintain project integrity, set up a testing environment,
    document integrations for future reference, and track and resolve issues encountered
    during integration:'
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: 在将插件集成到您的项目中之前，彻底探索其功能、理解其文档、评估兼容性和潜在影响、评估特定功能、跟踪发布、检查版本兼容性、维护项目完整性、设置测试环境、为将来参考记录集成文档以及跟踪和解决集成过程中遇到的问题至关重要：
- en: '**Exploring plugin functionality**: Before adding a plugin, thoroughly explore
    its features and functionalities'
  id: totrans-180
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**探索插件功能**：在添加插件之前，彻底探索其功能和功能'
- en: '**Understanding documentation**: Dive into the plugin’s documentation for a
    clear understanding of its capabilities'
  id: totrans-181
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**理解文档**：深入插件文档以清晰了解其功能'
- en: '**Compatibility and impact assessment**: Evaluate how the plugin aligns with
    your project, considering aspects such as performance and potential conflicts'
  id: totrans-182
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**兼容性和影响评估**：评估插件与您的项目是否兼容，考虑性能和潜在冲突等方面'
- en: '**Feature assessment**: Assess specific features to ensure they meet your project’s
    requirements'
  id: totrans-183
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**功能评估**：评估特定功能以确保它们符合您的项目需求'
- en: '**Keeping plugins updated**: Stay informed about updates, bug fixes, and new
    features for your integrated plugins'
  id: totrans-184
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**保持插件更新**：了解您集成插件的更新、错误修复和新功能'
- en: '**Version compatibility checks**: Verify that the plugin aligns with the current
    Unity version, exercising caution during Unity updates'
  id: totrans-185
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**版本兼容性检查**: 确认插件与当前Unity版本兼容，在Unity更新期间保持谨慎'
- en: '**Maintaining project integrity**: Back up your entire project before making
    significant changes to avoid data loss'
  id: totrans-186
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**维护项目完整性**: 在对项目进行重大更改之前，备份整个项目以避免数据丢失'
- en: '**Testing environment**: Create a dedicated testing environment to evaluate
    plugin updates or modifications'
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**测试环境**: 创建一个专门的测试环境以评估插件更新或修改'
- en: '**Documentation for future reference**: Create detailed integration documentation
    and include configurations, settings, and troubleshooting steps'
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**未来参考文档**: 创建详细的集成文档，包括配置、设置和故障排除步骤'
- en: '**Issue tracking and resolution**: Maintain a record of encountered issues
    and their resolutions for future reference'
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**问题跟踪和解决**: 记录遇到的问题及其解决方案，以供将来参考'
- en: In summary, exploring, understanding, assessing, updating, checking compatibility,
    maintaining integrity, testing, documenting, and tracking issues are crucial steps
    in effectively integrating and managing plugins within your Unity project.
  id: totrans-190
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，探索、理解、评估、更新、检查兼容性、维护完整性、测试、记录文档和跟踪问题是在Unity项目中有效集成和管理插件的关键步骤。
- en: Summary
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In wrapping up this chapter, we’ve covered the ins and outs of Unity plugins,
    understanding the basic and extended features they offer. You’ve also learned
    how to integrate the new Input System and Cinemachine using C#, gaining practical
    skills to enhance your game development projects. We’ve emphasized the importance
    of adopting best practices when working with plugins, setting the stage for more
    efficient integration into your projects. As you reflect on keeping your code
    organized and neat, these skills will be valuable as you continue your journey
    toward becoming a skilled Unity developer.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在结束本章之前，我们已经涵盖了Unity插件的方方面面，了解了它们提供的基本和扩展功能。您还学习了如何使用C#集成新的Input System和Cinemachine，获得了增强游戏开发项目的实用技能。我们强调了在处理插件时采用最佳实践的重要性，为更高效地集成到项目中奠定了基础。当您反思保持代码整洁有序时，这些技能将在您继续成为熟练的Unity开发者之路上变得非常有价值。
- en: Looking ahead to the next chapter, *Creating Fun Game Mechanics with C# in Unity*,
    get ready to expand your game development toolkit. Building on what you’ve learned
    about clean coding practices, you’ll explore how to bring excitement to your games
    through the expressive C# programming language. Imagine seamlessly incorporating
    your knowledge of plugins and organized code into the creation of engaging game
    mechanics. The upcoming chapter promises exciting challenges and discoveries that
    will further enhance your Unity development skills. Get ready to dive into the
    world of crafting immersive and enjoyable game mechanics in [*Chapter 4*](B22017_04.xhtml#_idTextAnchor058).
    Happy coding on this ongoing journey of skill-building!
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 展望下一章，“使用Unity中的C#创建有趣的游戏机制”，准备好扩展您的游戏开发工具集。在了解清洁编码实践的基础上，您将探索如何通过富有表现力的C#编程语言为您的游戏带来兴奋感。想象一下，将您对插件和组织化代码的知识无缝地融入引人入胜的游戏机制创作中。即将到来的章节承诺带来令人兴奋的挑战和发现，这将进一步增强您的Unity开发技能。准备好深入探索制作沉浸式和有趣游戏机制的世界，[第4章](B22017_04.xhtml#_idTextAnchor058)。在这个技能提升的持续旅程中，祝您编码愉快！
