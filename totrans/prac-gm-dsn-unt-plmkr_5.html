<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch05"/>Chapter 5. Scripting and Custom Actions</h1></div></div></div><p>In previous chapters, you learned how to make a game using Playmaker's in-built actions. Unfortunately, their capabilities are limited, and sooner or later you will find yourself in need of something that Playmaker does not know how to do out-of-the-box. In this case, you can try and find a ready-made solution on the Internet, but to make sure that there is an answer to every one of your questions, you will certainly have to learn how to write scripts. These are the topics that we will discuss in this chapter:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Programming in Unity JavaScript (sometimes also called UnityScript) and C#</li><li class="listitem" style="list-style-type: disc">Common Unity classes, variables, and functions</li><li class="listitem" style="list-style-type: disc">Writing a script and using it as component</li><li class="listitem" style="list-style-type: disc">Transforming a script into a Playmaker action</li></ul></div><div><div><div><div><h1 class="title"><a id="ch05lvl1sec26"/>Writing a Unity Script</h1></div></div></div><p>Explaining how <a id="id113" class="indexterm"/>programming works in general is beyond the scope of this book, so I am going to assume that you already know what variables, functions, classes, and operators are. If, however, you do not know these things, it should not take you too long to pick up the basics using either Code Academy<a id="id114" class="indexterm"/> (<a class="ulink" href="http://www.codecademy.com/tracks/javascript">http://www.codecademy.com/tracks/javascript</a>) or <a id="id115" class="indexterm"/>Unity's own starting level tutorials (<a class="ulink" href="http://unity3d.com/learn/tutorials/modules/beginner/scripting">http://unity3d.com/learn/tutorials/modules/beginner/scripting</a>).</p><p>We are going to start with <strong>JavaScript</strong> (<strong>JS</strong>)<a id="id116" class="indexterm"/> in this section, because it is much simpler to use and does not require any understanding of object-oriented programming beyond the component-based approach to development that we already discussed in <a class="link" href="ch03.html" title="Chapter 3. Components and State Machines">Chapter 3</a>, <em>Components and State Machines</em>. Besides, you will end up writing significantly less code.</p><p>Both JS and C# use the same Unity classes and functions, and the difference in syntax is not very significant at all. However, for more complex things it is generally a good idea to use C# (for one thing, it is currently impossible to write a Playmaker action in JavaScript). We will start with a JS script and then translate it into C#, explaining the differences. You can later choose whichever language works better for you.</p><p>We are going to create a<a id="id117" class="indexterm"/> script that replaces all the Playmaker actions in the <strong>Push Puck</strong> state of both mallets' FSMs. When you see that you have to make a chain of five or more actions, it is generally easier to combine them in a single custom action, especially if you are planning to use this compound action on multiple objects.</p><p>Let us start by creating a new script. First of all, create a new folder named <code class="literal">Scripts</code> using the <strong>Project</strong> panel. Then, right-click on the newly created folder and navigate to <strong>Create</strong> | <strong>Javascript</strong>. Name the file <code class="literal">PushPuck</code>. Double-click on the file. The standard Unity programming environment, MonoDevelop, should open. Select everything there is in that script and replace it with the following code:</p><div><pre class="programlisting">// Automatically added, compiler =directive 
// that makes JavaScript more explicit
#pragma strict

// Global variables available from Inspector
var pushMag : float = 20f;

var collisionTag : String = String.Empty;

// Function that will detect the collision with 
// controller and apply force in point of the collision
function OnControllerColliderHit (hit : ControllerColliderHit) 
{
  if (hit.gameObject.tag == collisionTag)
  {
    // Get the position of the object we collided with
    var hitObjectPos : Vector3 = hit.transform.position;

    // Get the position of the collision
    var hitPointPos : Vector3 = hit.point;

    // Calculate the direction of the force, 
    // multiply it by magnitude
    var pushForce : Vector3 = Vector3.Normalize(hitObjectPos - hitPointPos) * pushMag;

    // Finally, apply force in position
    hit.rigidbody.AddForceAtPosition(pushForce, hitPointPos);

    // Print a message in Console saying that 
    //the collision did happen and force was indeed applied
    Debug.Log("Detected hit with " + collisionTag + ", applying force of " + pushForce + " in " + hitPointPos + ".");
  }
}
@script RequireComponent(CharacterController)</pre></div><div><div><h3 class="title"><a id="tip18"/>Tip</h3><p>You can download the example code files for all Packt Publishing books you have purchased from your account at <a class="ulink" href="http://www.packtpub.com">http://www.packtpub.com</a>. If you purchased this book elsewhere, you can visit <a class="ulink" href="http://www.packtpub.com/support">http://www.packtpub.com/support</a> and register to have the files e-mailed directly to you.</p></div></div><p>Press <em>command</em> + <em>S</em> (<em>Ctrl</em> + <em>S</em> in Windows) in MonoDevelop to save the changes to the script.</p><p>Let us examine<a id="id118" class="indexterm"/> this code line-by-line. The first line is <code class="literal">#pragma strict</code>. This is a preprocessor directive. If you have some previous programming experience, you have probably seen something similar before. It does not participate in script logic; what it does is make JavaScript more explicit by imposing more strict error handling in the compiler. What it means for you is that you have to explicitly define the types of your variables, which is something you would not normally do in standard JavaScript.</p><div><div><h3 class="title"><a id="tip19"/>Tip</h3><p>Another common preprocessor directive for JS is <code class="literal">#pragma downcast</code>, which lets you get rid of warnings of implicit downcast if you do not care about them.</p></div></div><p>After that there are two lines of variable declaration: <code class="literal">pushMag</code> and <code class="literal">collisionTag</code> are declared as <code class="literal">float</code> and <code class="literal">String</code>. Once you attach this script to an object, these variables will be displayed in the Inspector, because they are both public and serialized. Since a script in Unity is treated as a component, variables appear as parameters in the Inspector once you attach the script to a game object.</p><p>If you want to declare a variable that does not appear in the Inspector, but want other scripts to still have access to it, you should put <code class="literal">[System.NonSerialized]</code> before it. If you want to both hide it and close all access to it, you just need to put <code class="literal">private</code> before the <code class="literal">var</code> keyword. Finally, if you want to expose a private variable in Inspector, you should put <code class="literal">[System.SerializableAttribute]</code> before its declaration.</p><p>Next goes the function declaration: <code class="literal">function</code> <code class="literal">OnControllerColliderHit</code> <code class="literal">(hit : ControllerColliderHit)</code>. <code class="literal">OnControllerColliderHit</code> is one of the standard Unity functions that are responsible for detecting collisions. Other such functions are <code class="literal">OnCollisionEnter</code>, <code class="literal">OnCollisionStay</code>, <code class="literal">OnCollisionExit</code>, <code class="literal">OnTriggerEnter</code>, <code class="literal">OnTriggerStay</code>, and <code class="literal">OnTriggerExit</code>.</p><p>The <code class="literal">OnControllerColliderHit</code> function<a id="id119" class="indexterm"/> gets called automatically if the object that the script is attached to has a Character Controller component and that Character Controller collides with a collider. The <code class="literal">hit</code> variable of type <code class="literal">ControllerColliderHit</code> gets assigned and can be used inside the function. By typing <code class="literal">hit</code> and a dot, one can access all kinds of information about the collision.</p><p>For instance, inside the function there is an <code class="literal">if</code> condition: <code class="literal">if (hit.gameObject.tag == collisionTag)</code>. We access the <code class="literal">gameObject</code> that our Character Controller has collided with, using the dot operator, and then we use it again to access that tag in <code class="literal">gameObject</code>. Then we compare that tag with the <code class="literal">collisionTag</code> string variable that is assigned in the Inspector. If the tag matches the string we specified, the code inside the curly brackets is executed.</p><p>In this <a id="id120" class="indexterm"/>script, we reproduced the exact sequence of actions in the <strong>Push Puck</strong> state of the mallets' FSMs. You can consult it for reference. First, we get the position of the puck and store it in a <code class="literal">Vector3</code> variable called <code class="literal">hitObjectPos</code>. Then we get the point of the hit and store it in another <code class="literal">Vector3</code> variable called <code class="literal">hitPointPos</code>. We then calculate the force of the push in one step instead of three that we used in Playmaker. Finally, the force is applied to the puck's rigidbody.</p><p>After that there is a line with <code class="literal">Debug.Log</code> that prints information about every hit in the Console. You can comment this line out by typing <code class="literal">//</code> in front of it. Keep it uncommented for now to make sure that the script works.</p><p>The very last line of the script is <code class="literal">@script RequireComponent (CharacterController)</code>. It is there to make sure that there is a Character Controller component attached to the game object that this script is attached to. If you attach this script to a game object that does not have a Character Controller, it will be attached automatically. If you try to remove the Character Controller without removing <code class="literal">PushPuck</code> first, Unity will display a warning dialog window and not allow you to do it.</p><p>Now it is time to see if our newly created script works. Go back to Unity and open the <strong>Console</strong> panel. If there are no red errors, this means that the script was compiled correctly and is ready to be used. If there is some kind of error in a script, double-clicking on it in the Console will open the script in MonoDevelop and direct you to the line where the error has occurred.</p><p>If everything is okay, select <strong>MalletLeft</strong>, open the <strong>playMaker</strong> panel and in the <strong>Move</strong> state disable the <strong>Collision</strong> <strong>Event</strong> action by unchecking the box next to its name. If you start the game now, colliding with the puck will not push it. Now it is time to use our brand-new <code class="literal">PushPuck</code> script. Drag and drop the <code class="literal">PushPuck</code> file from the <strong>Project</strong> panel to the <strong>Inspector</strong> panel while having <strong>MalletLeft</strong> selected. It will attach to it as a component. Set its parameters as shown in the following screenshot:</p><div><img src="img/8108OT_05_01.jpg" alt="Writing a Unity Script"/></div><p>Open the <strong>Console</strong> panel and launch the game. Note how messages appear in the Console every time you hit the puck with your mallet. If you stop the game and double-click on one of the <code class="literal">Debug.Logs</code>, MonoDevelop will open and point you to the <code class="literal">Debug.Log</code> line of the <code class="literal">PushPuck</code> script. Now<a id="id121" class="indexterm"/> that you know the script works, you can comment that line out in order to prevent it from spamming the console.</p><p>Also, now you can apply it to the AI opponent as well. Remember to deactivate the <strong>Collision Event</strong> action first.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec27"/>Overview of standard Unity classes</h1></div></div></div><p>While I am not going to copy the<a id="id122" class="indexterm"/> whole Unity Script Reference into this chapter of the book, I would like to list a few important classes and functions that you are going to use quite often.</p><p>The most obvious and frequently used standard functions are <code class="literal">Awake</code>, <code class="literal">Start</code>, <code class="literal">OnEnable</code>, <code class="literal">OnDisable</code>, <code class="literal">Update</code>, and <code class="literal">FixedUpdate</code>:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc"><code class="literal">Awake</code> is the first <a id="id123" class="indexterm"/>function that is called when a scene is loaded. The <code class="literal">Awake</code> function can happen only once per scene load. It is generally a good idea to put all initialization code into the <code class="literal">Awake</code> function.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Start</code> happens after <code class="literal">Awake</code> and also runs once. Sometimes it is a good idea to put some code into <code class="literal">Awake</code> and some other code into <code class="literal">Start</code><a id="id124" class="indexterm"/> in order to make sure that one is executed after the other. When you have an <code class="literal">Awake</code> function in one script and another <code class="literal">Awake</code> function in another script, you cannot be sure which one will be executed first. If the order matters, put one of the pieces of code into the <code class="literal">Start</code> function.<div><div><h3 class="title"><a id="tip20"/>Tip</h3><p>There's another way to ensure a correct script execution order. You can decide which script is executed before or after by navigating to <strong>Edit</strong> | <strong>Project Settings</strong> | <strong>Script Execution Order</strong> from the main menu and then pressing the plus button in the Inspector, selecting the script whose execution order you would like to define, and then dragging it up or down in the interface. You will notice that the number on the right changes as you drag the script: this number is the script's execution order. You give the script its default execution order by removing it from this list. You can do this by pressing the minus button on the right from its name in the list.</p></div></div></li><li class="listitem" style="list-style-type: disc">The <code class="literal">OnEnable</code> function<a id="id125" class="indexterm"/> is a lot like <code class="literal">Start</code>, except it is called every time the object to which the script is attached is activated, as well as every time the component itself is enabled.</li><li class="listitem" style="list-style-type: disc"><code class="literal">OnDisable</code> is the <a id="id126" class="indexterm"/>opposite of <code class="literal">OnEnable</code>. It is called when the object or the component gets disabled.</li><li class="listitem" style="list-style-type: disc"><code class="literal">Update</code> is called every <a id="id127" class="indexterm"/>frame. Most of the games' logic usually happens here.</li><li class="listitem" style="list-style-type: disc"><code class="literal">FixedUpdate</code> is called on<a id="id128" class="indexterm"/> physics update, which is generally significantly more frequent than <code class="literal">Update</code>. All the code that cannot be frame rate dependent (such as, for instance, movement) should be in the <code class="literal">FixedUpdate</code> function.</li></ul></div><p>Apart from the <a id="id129" class="indexterm"/>functions, there are whole classes with their methods and variables that you should absolutely know about when programming in Unity. It is hard to emphasize something in particular, and you really should just go through all the major classes listed in the Scripting Reference (<a class="ulink" href="http://docs.unity3d.com/Documentation/ScriptReference/">http://docs.unity3d.com/Documentation/ScriptReference/</a>). There are really a lot of classes, and there is hardly anyone who knows what all of them do, but we are going to go through a few that you should look at first thing: <code class="literal">Mathf</code>, <code class="literal">Vector3</code>, <code class="literal">Color</code>, <code class="literal">Input</code>, <code class="literal">GameObject</code>, <code class="literal">Transform</code>, <code class="literal">Renderer</code>, <code class="literal">Material</code>, <code class="literal">Collision</code>, <code class="literal">Collider</code>, and of course <code class="literal">Object</code>, <code class="literal">Behaviour</code>, <code class="literal">Component</code>, and <code class="literal">MonoBehaviour</code>.</p><p>The last four classes are especially important, since they include things that you are going to use every time you write a script in Unity, including functions like <code class="literal">Update</code>, <code class="literal">Destroy</code>, <code class="literal">GetComponent</code>, and <code class="literal">Start</code>, as well as variables such as <code class="literal">enabled</code>, <code class="literal">name</code>, <code class="literal">layer</code>, and <code class="literal">tag</code>. Try to read descriptions of these classes and their functions and variables very carefully, and look at the basic examples the documentation offers with them.</p></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec28"/>Creating a Playmaker action</h1></div></div></div><p>It is time to<a id="id130" class="indexterm"/> translate our <a id="id131" class="indexterm"/>script to C#. Create a new C# script the same way you created the JS one. Call it <code class="literal">PushPuckAction</code>. Open the script and find the line starting with the <code class="literal">public class</code> keywords. Make sure that the name of the class is the same as the name of the script, then press <em>command</em> + <em>S</em> (<em>Ctrl</em> + <em>S</em> in Windows) to save your changes if you made any.</p><p>As you can see, the default template for a C# script looks different from that of JS. This is because more things are shown to you. For instance, in JS it is implied that everything inside a script is, in fact, in a class with the same name, but you do not see the class declaration anywhere. Component classes in Unity have to inherit from MonoBehaviour, and it is shown in C#, while JS hides it from you. Then you have the two lines with the <code class="literal">using</code> keyword. All JS scripts use these namespaces, but JS hides it from you as well. The following script is the same one that we had before, but this time translated to C#. Replace the <a id="id132" class="indexterm"/>template<a id="id133" class="indexterm"/> with it.</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;
[RequireComponent (typeof (CharacterController))]

public class PushPuckAction : MonoBehaviour 
{
  // Global variables available from Inspector
  public float pushMag = 20f;

  public string collisionTag = string.Empty;

  // Function that will detect the collision with 
  // controller and apply force in point of the collision
  void OnControllerColliderHit (ControllerColliderHit hit) 
  {
    if (hit.gameObject.tag == collisionTag)
    {
      // Get the position of the object we collided with
      Vector3 hitObjectPos = hit.transform.position;

      // Get the position of the collision
      Vector3 hitPointPos = hit.point;

      // Calculate the direction of the force, 
      // multiply it by magnitude
      Vector3 pushForce = Vector3.Normalize(hitObjectPos - hitPointPos) * pushMag;

      // Finally, apply force in position
      hit.rigidbody.AddForceAtPosition(pushForce, hitPointPos);

      // Print a message in Console saying that 
      //the collision did happen and force was indeed applied
      Debug.Log("Detected hit with " + collisionTag + ", applying force of " + pushForce + " in " + hitPointPos + ".");
    }
  }
}</pre></div><p>Press <em>command</em> + <em>S</em> (<em>Ctrl</em> + <em>S</em> in Windows), and let us look at what has changed apart from the things already mentioned. The syntax of the component requirement is different in C#. On top of that, the <code class="literal">RequireComponent</code> attribute has to be placed before the class declaration.</p><p>The <code class="literal">#pragma strict</code> directive<a id="id134" class="indexterm"/> is gone. C# is explicit by nature and requires that you specify types of everything, so it is not needed.</p><div><div><h3 class="title"><a id="tip021"/>Tip</h3><p>In C#, the following are quite useful: <code class="literal">#region [Name]</code>/<code class="literal">#endregion</code>, which is a good way of <a id="id135" class="indexterm"/>dividing your code into regions that you can <a id="id136" class="indexterm"/>fold. For example, writing <code class="literal">#region Variables</code> will create a region called <code class="literal">Variables</code>. Then you will be able to press a minus in a rectangle on the left of the MonoDevelop window to fold the code region, the end of which you have to mark with <code class="literal">#endregion</code>.</p></div></div><p>The <code class="literal">function</code> keyword is not used. Instead, function declarations are preceded by return types. You can specify a return type in JS as well, but this is done with the <code class="literal">:</code> operator after the brackets, for example, <code class="literal">function Update() : void</code>.</p><p>Finally, all variable declarations are preceded with types of variables instead of the <code class="literal">var</code> keyword. There are more differences in syntax that we cannot see in this example because of the relative simplicity of our script, but these are the main ones.</p><p>Now, if you replace your JS script with the C# one on the Mallets, they will act exactly the same way as before. Try doing this, then remove the <strong>Push Puck Action</strong> component from the mallets. It is time to modify the script and transform <code class="literal">PushPuckAction.cs</code> into an actual Playmaker action. Replace the contents of <code class="literal">PushPuckAction.cs</code> with the following code:</p><div><pre class="programlisting">using UnityEngine;
using System.Collections;

namespace HutongGames.PlayMaker.Actions
{
  [ActionCategory(ActionCategory.Character)]
  [Tooltip("Detect collision with CharacterController, then push the other object into the opposite direction.")]
  public class PushPuckAction : FsmStateAction 
  {
    [Tooltip("Push magnitude")]
    public FsmFloat pushMag;

    [Tooltip("Object with this tag will be pushed")]
    public FsmString collisionTag;

    public override void Reset ()
    {
      pushMag = 20f;
      collisionTag = string.Empty;
    }

    public override void DoControllerColliderHit(ControllerColliderHit hit)
    {
      if (hit.gameObject.tag == collisionTag.Value)
      {
        FsmVector3 hitObjectPos = hit.transform.position;

        FsmVector3 hitPointPos = hit.point;

        FsmVector3 pushForce = (hitObjectPos.Value - hitPointPos.Value).normalized * pushMag.Value;

        hit.rigidbody.AddForceAtPosition(pushForce.Value, hitPointPos.Value);

        Debug.Log("Detected hit with " + collisionTag.Value + ", applying force of " + pushForce.Value + " in " + hitPointPos.Value + ".");
      }
    }
  }
}</pre></div><p>Press <em>command</em> + <em>S</em> (<em>Ctrl</em> + <em>S</em> in Windows) to save the script. As you can see, this time more things have changed, although you can still see the same structure. Let us go through the code line-by-line and examine it.</p><p>The <code class="literal">using</code> directives <a id="id137" class="indexterm"/>are the same, but the difference <a id="id138" class="indexterm"/>begins right after them. The line <code class="literal">namespace</code> <code class="literal">HutongGames.PlayMaker.Actions</code> is obligatory for all Playmaker actions. Without it Playmaker will not know that the script that you are writing is, in fact, an action.</p><p>The <code class="literal">[ActionCategory(ActionCategory.Character)]</code> line puts your new action into a category. In this case, we are putting it into the <code class="literal">Character</code> category, because the action is about things colliding with the Character Controller. It could also go into the <code class="literal">Physics</code> category. To move it there, the line would have to be <code class="literal">[ActionCategory(ActionCategory.Physics)]</code>.</p><p>After that there is <code class="literal">[Tooltip("...")]</code>, which is quite self-explanatory. It shows a short description when you select the action from the list in the <strong>Actions</strong> panel.</p><p>The <code class="literal">PushPuckAction</code> class now inherits from <code class="literal">FsmStateAction</code> instead of <code class="literal">MonoBehavior</code>. You still have access to all the standard Unity classes, but Playmaker-specific ones are added now.</p><p>Then there is another <code class="literal">Tooltip</code>, this time for a variable rather that a whole action. The text within this tooltip will appear when you hover your mouse pointer over the variable in the <strong>State</strong> tab of the <strong>playMaker</strong> panel or in the <strong>Actions</strong> panel.</p><p>Note that the<a id="id139" class="indexterm"/> type of the <code class="literal">pushMag</code> variable has<a id="id140" class="indexterm"/> changed from <code class="literal">float</code> to <code class="literal">FsmFloat</code>, and the same goes for the <code class="literal">string</code> variable <code class="literal">collisionTag</code>—it is <code class="literal">FsmString</code> now. These are Playmaker types of variables. The same operations can be performed on them as before, but to access their value you now have to use the dot operator with the word <code class="literal">Value</code>, so, for example, <code class="literal">pushMag.Value</code> will return a float, the value of the Playmaker variable.</p><div><div><h3 class="title"><a id="tip21"/>Tip</h3><p>If you do not want to be able to assign a value directly in the <strong>State</strong> tab of the <strong>playMaker</strong> panel and force choosing from existing variables, you can write <code class="literal">[UIHint(UIHint.Variable)]</code> in the line before the variable declaration, the same way we did for the tooltips.</p></div></div><p>A <code class="literal">Reset</code> function was added. This is what happens when a new action is added to a state or when you right-click on the header of the action and press <strong>Reset</strong>. In it, we reinitialize the variables.</p><p>Then there is the <code class="literal">DoControllerColliderHit</code> function. Its name has changed from the standard Unity <code class="literal">OnControllerColliderHit</code>. Inside the function everything has stayed more or less the same with the only difference that types of <code class="literal">Vector3</code> variables have changed to <code class="literal">FsmVector3</code>, so to access their values <code class="literal">.Value</code> is used. Also, instead of <code class="literal">Vector3.Normalize</code>, we used <code class="literal">.nomalized</code>, which does exactly the same thing.</p><div><div><h3 class="title"><a id="tip22"/>Tip</h3><p>While it is clear that in order to find examples and standard Unity classes' API one has to go to Unity Script Reference, it may be less clear about Playmaker-specific things. The easiest way to find examples is opening the script files of existing Playmaker actions that are located under the <code class="literal">PlayMaker/Actions</code> path, in your project. For example, if you are not quite sure how to detect mouse input and you want to do it via a Playmaker custom action, you can open <code class="literal">PlayMaker/Actions/MousePick.cs</code> and look at how the creators of Playmaker solved this problem.</p></div></div><p>Note that both <code class="literal">Reset</code> and <code class="literal">DoControllerColliderHit</code> have <code class="literal">override</code> preceding their types. This means that we are replacing a base function defined in the Playmaker with our own function. As a general rule, you will need to override all of the Playmaker standard functions using this keyword.</p><p>Now that we are done writing a custom Playmaker action, we can try using it. Remove the <strong>Push Puck</strong> and/or <strong>Push</strong> <strong>Puck</strong> <strong>Action</strong> components from <strong>MalletLeft</strong> and <strong>MalletRight</strong>. In their <strong>Move</strong> state, remove the <strong>Collision Event</strong> action. Then locate the newly created <strong>Push Puck Action</strong> in the <strong>Actions</strong> panel and add it to the state. Set the properties as shown in the following screenshot. Finally, delete the <strong>Push Puck</strong> state from the FSM as well as the <strong>Push</strong> <a id="id141" class="indexterm"/>event and transition. To delete a transition, you just need to right-click on <a id="id142" class="indexterm"/>the event in the FSM view and press <strong>Delete Transition</strong>.</p><div><img src="img/8108OT_05_02.jpg" alt="Creating a Playmaker action"/></div></div>
<div><div><div><div><h1 class="title"><a id="ch05lvl1sec29"/>Summary</h1></div></div></div><p>In this chapter, you were introduced to scripting in Unity, both JavaScript and C#, and learned how to create custom Playmaker actions. You should try repeating the process described in this chapter with another set of actions on your own. Set yourself a gameplay goal, for instance, you could take one of the exercises offered at the end of <a class="link" href="ch04.html" title="Chapter 4. Creating Your First Game">Chapter 4</a>, <em>Creating Your First Game</em>, write a JS or C# script that accomplishes the goal; and then translate it into a Playmaker action. You will feel much more comfortable with scripting by the time you are done, as it is all about practice, and no amount of reading and theory can replace a hands-on experience with a text editor and a search engine.</p><p>The next chapters continue talking about advanced subjects, such as networking and external APIs, and we are going to do some more scripting in <a class="link" href="ch07.html" title="Chapter 7. Working with External APIs">Chapter 7</a>, <em>Working with External APIs</em>.</p></div></body></html>