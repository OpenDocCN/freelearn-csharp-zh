- en: Advanced Concepts of Building an API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构建API的高级概念
- en: 'The previous chapter went through the implementation of the HTTP layer of the
    web service. Although the core functionalities of the service are already in place,
    there are still some refinements to cover. This chapter provides a walk-through
    of some additional implementations that will be a part of the catalog web service*,*
    such as soft deleting resources, the HATEOAS approach, adding a response-time
    middleware, and some of the best practices for asynchronous code in ASP.NET Core.
    More specifically, it will cover the following topics:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 上一章介绍了Web服务HTTP层的实现。尽管服务的核心功能已经到位，但仍有一些细节需要完善。本章将介绍一些额外的实现，这些实现将成为目录Web服务的一部分，例如软删除资源、HATEOAS方法、添加响应时间中间件以及ASP.NET
    Core中异步代码的一些最佳实践。更具体地说，它将涵盖以下主题：
- en: Implementing the soft delete technique
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现软删除技术
- en: Implementing HATEOAS
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 实现HATEOAS
- en: An overview of asynchronous code in ASP.NET Core
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: ASP.NET Core中异步代码概述
- en: Measuring the response time of APIs using middleware
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用中间件测量API的响应时间
- en: 'The code present in this chapter is available in the following GitHub repository:
    [https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3).'
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 本章中提供的代码可在以下GitHub仓库中找到：[https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3](https://github.com/PacktPublishing/Hands-On-RESTful-Web-Services-with-ASP.NET-Core-3)。
- en: Implementing the soft delete procedure
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现软删除过程
- en: As mentioned in the *Deleting resources* section of [Chapter 5](deede298-fc20-4523-afa6-02ed2c0592fd.xhtml),
    *Web Service Stack in ASP.NET Core*, the soft delete technique is a widespread
    deletion practice in real-world applications. Furthermore, it is quite uncommon
    to physically delete entities from our data source.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 如同在[第5章](deede298-fc20-4523-afa6-02ed2c0592fd.xhtml)中提到的*Web服务堆栈在ASP.NET Core中*的*删除资源*部分，软删除技术在现实世界的应用中是一种常见的删除实践。此外，从我们的数据源物理删除实体相当不常见。
- en: 'Deleted data may be relevant for historical purposes and for performing analysis
    and reports. The soft delete implementation involves all the projects we have
    seen in the previous three chapters. In order to proceed, let''s add a new `IsInactive`
    field to our `Item` entity inside the `Catalog.Domain` project:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 被删除的数据可能对历史目的以及执行分析和报告相关。软删除实现涉及我们在前三个章节中看到的所有项目。为了继续，让我们在`Catalog.Domain`项目中的`Item`实体中添加一个新的`IsInactive`字段：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Since we changed the schema of the `Item` entity, we need to perform another
    EF Core migration by executing the following commands inside the `Catalog.API`
    project:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们更改了`Item`实体的模式，我们需要在`Catalog.API`项目中执行以下命令以执行另一个EF Core迁移：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The result of the execution of the aforementioned command will generate a new
    migration file inside the `Migrations` folder and the application of the newly
    created migration in the database specified in the connection string of the `Startup`
    class.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 执行上述命令的结果将在`Migrations`文件夹中生成一个新的迁移文件，并将新创建的迁移应用于`Startup`类中指定的数据库。
- en: 'Furthermore, as we saw in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml),
    *Building the Data Access Layer*, if we want to connect to the local Docker SQL
    Server instance, we can specify the following connection string in the `appsettings.json`
    file:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，正如我们在[第8章](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml)中看到的，*构建数据访问层*，如果我们想连接到本地的Docker
    SQL Server实例，我们可以在`appsettings.json`文件中指定以下连接字符串：
- en: '[PRE2]'
  id: totrans-15
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'The preceding connection string provides the connection to the local instance
    of SQL Server. In order to run the instance, it is necessary to follow the command
    we saw in Chapter 8\. The following runs the docker instance using the name sql1:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提供的连接字符串提供了连接到本地SQL Server实例的连接。为了运行实例，必须遵循我们在第8章中看到的命令。以下使用名称sql1运行docker实例：
- en: '[PRE3]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Furthermore, we can log in into the container using the following command:'
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以使用以下命令登录到容器：
- en: '[PRE4]'
  id: totrans-19
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'and finally, we can execute the `sqlcmd` in order to log in into the SQL server
    instance:'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们可以执行`sqlcmd`以登录到SQL服务器实例：
- en: '[PRE5]'
  id: totrans-21
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The code above creates the `Store` database with a login user called `catalog_srv`.
    Later in the book, we will see how to automate this process using the tools provided
    by Docker. Now, the database schema is updated, and we are able to continue by
    including the `IsInactive` field in the repository and the service layer of the
    application.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 上面的代码创建了一个名为 `catalog_srv` 的登录用户的 `Store` 数据库。在本书的后面部分，我们将看到如何使用 Docker 提供的工具来自动化此过程。现在，数据库模式已更新，我们能够通过在应用程序的存储库和服务层中包含
    `IsInactive` 字段来继续进行。
- en: Updating the IItemRepository implementation
  id: totrans-23
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 更新 IItemRepository 实现
- en: 'Since we added the new `IsInactive` field in our database, we can proceed by
    adapting the `IItemRepository` interface to filter our data based on the `IsInactive`
    field. Therefore, we will proceed by implementing the following changes in order
    to maintain consistency in our data source:'
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 自从我们在数据库中添加了新的 `IsInactive` 字段后，我们可以通过调整 `IItemRepository` 接口来根据 `IsInactive`
    字段过滤我们的数据来继续进行。因此，我们将通过实施以下更改来保持数据源的一致性：
- en: The `IItemRepository.GetAsync()` method will filter all the fields by `IsInactive
    = false`. Consequently, the resulting response will only contain active entities.
    This kind of approach guarantees that we get a lightweight response when we try
    to get multiple entities from the database.
  id: totrans-25
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IItemRepository.GetAsync()` 方法将通过 `IsInactive = false` 过滤所有字段。因此，生成的响应将仅包含活动实体。这种方法的优点是，当我们尝试从数据库中获取多个实体时，我们可以得到一个轻量级的响应。'
- en: In the same way, `GetItemByArtistIdAsync` and `GetItemByGenreIdAsync` will filter
    the result by using the `IsInactive = false` flag. Also, in this case, we want
    to keep the response as light as possible.
  id: totrans-26
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 同样，`GetItemByArtistIdAsync` 和 `GetItemByGenreIdAsync` 将使用 `IsInactive = false`
    标志来过滤结果。此外，在这种情况下，我们希望尽可能保持响应尽可能轻量。
- en: The `IItemRepository.GetAsync(Guid id)` method will retrieve the details of
    the required entity regardless of the `IsInactive` flag. Moreover, this method
    is used by the validation checks of the application, therefore, we need to avoid
    duplicate IDs when we insert new objects, whether they are active or not.
  id: totrans-27
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`IItemRepository.GetAsync(Guid id)` 方法将根据 `IsInactive` 标志检索所需实体的详细信息。此外，此方法被应用程序的验证检查所使用，因此，当我们插入新对象时，无论它们是活动状态还是非活动状态，我们都需要避免重复的
    ID。'
- en: 'Let''s proceed by implementing these specifications mentioned in the `IItemRepository`
    interface:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们通过实现 `IItemRepository` 接口中提到的这些规范来继续：
- en: '[PRE6]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'This implementation changes the behavior of the `GetAsync`, `GetItemByArtistIdAsync`,
    and `GetItemByGenreIdAsync` methods by filtering for `IsInactive == false` using
    the `Where` LINQ clause. On the other hand, `GetAsync(Guid id)` remains the same
    because, as mentioned in the specifications, we want the get detail operation
    to always retrieve the information, including cases where the record is not active.
    Therefore, we can test the resulting implementation by executing the following
    command in the root of the project:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 此实现通过使用 `Where` LINQ 子句过滤 `IsInactive == false` 来更改 `GetAsync`、`GetItemByArtistIdAsync`
    和 `GetItemByGenreIdAsync` 方法的行为。另一方面，`GetAsync(Guid id)` 保持不变，因为，如规范中所述，我们希望获取详细信息操作始终检索信息，包括记录非活动的情况。因此，我们可以通过在项目根目录中执行以下命令来测试生成的实现：
- en: '[PRE7]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'All tests should pass because, by default, the `IsInactive` Boolean field is
    always `false`. To test the `Where(x=>!x.IsInactive)` change, we can add a new
    record in the `Catalog.API/tests/Catalog.Fixtures/Data/item.json` file by adding
    a new inactive item:'
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 所有测试都应该通过，因为默认情况下，`IsInactive` 布尔字段始终为 `false`。为了测试 `Where(x=>!x.IsInactive)`
    的更改，我们可以在 `Catalog.API/tests/Catalog.Fixtures/Data/item.json` 文件中添加一条新记录，添加一个非活动项：
- en: '[PRE8]'
  id: totrans-33
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Therefore, we can verify that the number of records retrieved by the get operation
    changes by creating a new test and counting the results. For example, if the `item.json`
    file contains three records and one is inactive, the get operation should retrieve
    three records. As an alternative, we can double-check by verifying that the `Item.Id`
    fields of the result do not include an inactive record:'
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们可以通过创建一个新的测试并计算结果来验证通过获取操作检索的记录数是否发生变化。例如，如果 `item.json` 文件包含三个记录，其中一个是非活动的，则获取操作应检索三个记录。作为替代方案，我们可以通过验证结果中的
    `Item.Id` 字段不包含非活动记录来双重检查：
- en: '[PRE9]'
  id: totrans-35
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: I chose to test the deletion behavior by adding a new `getitems_should_not_return_inactive_records`
    method in the `ItemRepositoryTests` class. The test verifies that when I call
    the `GetAsync` method of the repository, the result excludes the `Item` entity
    with the `Id` specified as a parameter of the test. A similar approach can be
    also taken for the `GetItemByArtistIdAsync` and the `GetItemByGenreIdAsync` methods.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 我选择通过在`ItemRepositoryTests`类中添加一个新的`getitems_should_not_return_inactive_records`方法来测试删除行为。该测试验证当我调用仓库的`GetAsync`方法时，结果排除了作为测试参数指定的`Id`的`Item`实体。对于`GetItemByArtistIdAsync`和`GetItemByGenreIdAsync`方法，也可以采取类似的方法。
- en: Implementing delete operations
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现删除操作
- en: 'Now that we have implemented the right filtering logic on the repository side,
    let''s proceed by implementing delete operations in the `Catalog.Domain`project
    by adding a new `DeleteItemAsync` method in the declaration of the `IItemService`
    interface:'
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经在仓库端实现了正确的过滤逻辑，接下来让我们在`Catalog.Domain`项目中通过在`IItemService`接口声明中添加一个新的`DeleteItemAsync`方法来实施删除操作：
- en: '[PRE10]'
  id: totrans-39
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The `DeleteItemAsync` method refers to a `DeleteItemRequest` type, which can
    be declared as follows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteItemAsync`方法引用一个`DeleteItemRequest`类型，它可以声明如下：'
- en: '[PRE11]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Once we update the `IItemService` interface declaration, we can proceed by
    adding the implementation to the `ItemService` concrete class:'
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦我们更新了`IItemService`接口声明，我们就可以继续向`ItemService`具体类添加实现：
- en: '[PRE12]'
  id: totrans-43
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `DeleteItemAsync` method receives an `Id` field that is part of the `DeleteItemRequest`
    class. Besides, it uses the `GetAsync` method to get the details of the entity,
    and it continues by calling the `Update` method by passing the entity with the
    `IsInactive` flag set to `true`. The next step is to implement a new action method
    in the `ItemController` that covers the following HTTP call:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '`DeleteItemAsync`方法接收一个`Id`字段，它是`DeleteItemRequest`类的一部分。此外，它使用`GetAsync`方法获取实体的详细信息，然后通过传递带有`IsInactive`标志设置为`true`的实体来调用`Update`方法。下一步是实现`ItemController`中的一个新操作方法，该方法涵盖了以下HTTP调用：'
- en: '[PRE13]'
  id: totrans-45
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: 'Moreover, we can proceed by changing the `ItemController` as follows:'
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们可以继续按照以下方式更改`ItemController`：
- en: '[PRE14]'
  id: totrans-47
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The `Delete` action method is decorated with the `HttpDelete` attribute verb,
    which means that it is mapped with the HTTP `Delete` requests. The implementation
    sets the `IsInactive` flag through the `DeleteItemAsync` method, and it returns
    a `NoContent` result, which represents an HTTP `204 No Content` status code.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: '`Delete`操作方法被`HttpDelete`属性动词装饰，这意味着它与HTTP `Delete`请求映射。实现通过`DeleteItemAsync`方法设置`IsInactive`标志，并返回一个`NoContent`结果，这代表HTTP
    `204 No Content`状态码。'
- en: 'We will proceed by testing the changes made to the `ItemController` class by
    implementing the following tests:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将继续通过实现以下测试来测试对`ItemController`类所做的更改：
- en: '[PRE15]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This test code covers the following two behaviors:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 此测试代码涵盖了以下两个行为：
- en: The `delete_should_returns_no_content_when_called_with_right_id` test method
    checks whether the action method correctly returns the HTTP `NoContent` response.
  id: totrans-52
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_should_returns_no_content_when_called_with_right_id`测试方法检查操作方法是否正确返回HTTP
    `NoContent`响应。'
- en: The `delete_should_returns_not_found_when_called_with_not_existing_id` method
    checks that the action method returns `HttpStatusCode.NotFound` by passing a non-existent
    GUID (`Guid.NewGuid`).
  id: totrans-53
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`delete_should_returns_not_found_when_called_with_not_existing_id`方法检查当传递一个不存在的GUID（`Guid.NewGuid`）时，操作方法是否返回`HttpStatusCode.NotFound`。'
- en: In both test cases, we are using the already implemented test infrastructure
    to verify the new behavior of the web service. In this section, we have seen how
    to extend our web service in order to support the soft delete operation.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两个测试用例中，我们使用已经实现的测试基础设施来验证Web服务的新行为。在本节中，我们看到了如何扩展我们的Web服务以支持软删除操作。
- en: The next section focuses on the implementation of the HATEOAS response approach.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 下一个部分将专注于实现HATEOAS响应方法。
- en: Implementing HATEOAS
  id: totrans-56
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 实现HATEOAS
- en: 'We already discussed the theory around the HATEOAS principle in [Chapter 1](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml),
    *REST 101 and Getting Started with ASP.NET Core.* This section explains how to
    implement the HATEOAS approach for the `ItemController` already present in the
    `Catalog.API` project. The following snippet of code shows an example of a generic
    HATEOAS response:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 我们已经在[第1章](b3e95a60-c4fb-491e-ad7e-a2213f70a63b.xhtml)中讨论了HATEOAS原则的理论，*REST
    101和ASP.NET Core入门指南*。本节解释了如何为`Catalog.API`项目中现有的`ItemController`实现HATEOAS方法。以下代码片段展示了通用HATEOAS响应的示例：
- en: '[PRE16]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: Although this kind of response adds a heavy payload to the effective JSON response,
    it assists the client by providing the URL for each operation and resource on
    our data. The HATEOAS principle will be implemented side-by-side with `ItemController`,
    and it will give all the necessary information to the client to interact with
    the data owned by the catalog service*.*
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管这种响应给有效的 JSON 响应增加了大量负载，但它通过提供我们数据中每个操作和资源的 URL 来帮助客户端。HATEOAS 原则将与 `ItemController`
    并行实施，并且它将向客户端提供所有必要的信息以与目录服务拥有的数据进行交互*.*
- en: Enriching our model with HATEOAS data
  id: totrans-60
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 用 HATEOAS 数据丰富我们的模型
- en: 'To get HATEOAS working, we will rely on a third-party NuGet package called
    `RiskFirst.Hateoas`*.* This package allows us to integrate the HATEOAS principle
    in our service efficiently. First of all, let''s proceed by adding the package
    to `Catalog.API` by executing the following command in both project folders:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 要使 HATEOAS 正常工作，我们将依赖一个名为 `RiskFirst.Hateoas` 的第三方 NuGet 包*.* 此包允许我们有效地在我们的服务中集成
    HATEOAS 原则。首先，让我们通过在两个项目文件夹中执行以下命令将包添加到 `Catalog.API`：
- en: '[PRE17]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Next, create a new entity called the `ItemHateoasResponse` class, which represents
    the HATEOAS response. This class refers to the already implemented `ItemResponse`
    class, and it implements the `ILinkContainer` interface exposed by the `RiskFirst.Hateoas`
    package:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，创建一个新的实体，称为 `ItemHateoasResponse` 类，它表示 HATEOAS 响应。此类引用已实现的 `ItemResponse`
    类，并实现了 `RiskFirst.Hateoas` 包公开的 `ILinkContainer` 接口：
- en: '[PRE18]'
  id: totrans-64
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: The `Links` field is a `Dictionary<string, Link>` type and it contains the URLs
    to the resources related to the response. For example, if we get the response
    of a specific item, the `Link` attribute will provide the URLs to add, update,
    and delete the item. The `AddLink` method is used to add new fields to the `Links`
    dictionary. Therefore, we will continue by using this type of response in a controller
    in order to provide a HATEOAS-compliant reaction to our client.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: '`Links` 字段是 `Dictionary<string, Link>` 类型，它包含与响应相关的资源的 URL。例如，如果我们获取特定项目的响应，`Link`
    属性将提供添加、更新和删除项目的 URL。`AddLink` 方法用于向 `Links` 字典中添加新字段。因此，我们将继续在控制器中使用这种类型的响应，以便向客户端提供符合
    HATEOAS 的反应。'
- en: Implementing HATEOAS in a controller
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在控制器中实现 HATEOAS
- en: The final step is to implement a controller that can handle the `ItemHateoasResponse`
    response model implemented previously. More specifically, we can proceed by creating
    a new `ItemHateoasController` class in our `Catalog.API` project. Note that we
    are building a new controller for demonstration purposes. An alternative would
    be to edit the already defined `ItemController` to return HATEOAS-compliant responses.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 最后一步是实现一个可以处理之前实现的 `ItemHateoasResponse` 响应模型的控制器。更具体地说，我们可以在我们的 `Catalog.API`
    项目中创建一个新的 `ItemHateoasController` 类。请注意，我们正在为了演示目的构建一个新的控制器。另一种选择是编辑已定义的 `ItemController`
    以返回符合 HATEOAS 的响应。
- en: 'The `ItemHateoasController` class will use the `ILinksService` interface provided
    by the `RiskFirst.Hateoas` namespace to enrich the `Links` attribute of the `ItemHateoasResponse`
    model and return it to our client. Let''s proceed by implementing the controller:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: '`ItemHateoasController` 类将使用 `RiskFirst.Hateoas` 命名空间提供的 `ILinksService` 接口来丰富
    `ItemHateoasResponse` 模型的 `Links` 属性并将其返回给我们的客户端。让我们通过实现控制器来继续：'
- en: '[PRE19]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'The `Get` and `GetById` action methods are quite similar to the one that is
    present in `ItemController`. The only difference is that they return a different
    response type, which is represented by the `ItemHateoasResponse` class. Furthermore,
    the action methods assign the `response` object to the `Data` field. Each action
    method also calls the `AddLinksAsync` method provided by the `ILinksService` interface
    to populate the link attribute. In the same way, we can extend the behavior of
    the other action methods present in the controller class:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: '`Get` 和 `GetById` 动作方法与 `ItemController` 中现有的方法非常相似。唯一的区别是它们返回不同的响应类型，该类型由
    `ItemHateoasResponse` 类表示。此外，动作方法将 `response` 对象分配给 `Data` 字段。每个动作方法还调用由 `ILinksService`
    接口提供的 `AddLinksAsync` 方法来填充链接属性。同样，我们还可以扩展控制器类中其他动作方法的行为：'
- en: '[PRE20]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'This is the declaration of the implementation of the create, update, and delete
    action methods. Also, in this case, we are using the `ItemHateoasResponse` model
    class to retrieve the response of the action method. We should notice that the
    action methods declare `Name` in the `[HttpVerb]` attribute decorator, such as
    `[HttpDelete("{id:guid}", Name = nameof(Delete))]`. Indeed, we will use the `Name`
    declared by the attribute in the `Startup` class to refer to each route and include
    it in the `Link` property:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这是创建、更新和删除操作方法的实现声明。在本例中，我们使用 `ItemHateoasResponse` 模型类来检索操作方法的响应。我们应该注意，操作方法在
    `[HttpVerb]` 属性装饰器中声明了 `Name`，例如 `[HttpDelete("{id:guid}", Name = nameof(Delete))]`。实际上，我们将使用在
    `Startup` 类中声明的 `Name` 来引用每个路由并将其包含在 `Link` 属性中：
- en: '[PRE21]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: The `AddLinks` extension method provided by the `RiskFirst.Hateoas` package
    allows us to define the policies related to a response model. This is the case
    for the `config.AddPolicy<ItemHateoasResponse>` method, which calls `RequireRoutedLink`
    for each action method name declared in `ItemsHateoasController`. Note that, similar
    to the previous cases, we can extract this snippet of code in an external extension
    method to keep the `Startup` class as clean as possible. Finally, this kind of
    approach allows us to define different groups of links for different response
    models. Moreover, it is possible to establish a policy related to a specific response
    model.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 由 `RiskFirst.Hateoas` 包提供的 `AddLinks` 扩展方法允许我们定义与响应模型相关的策略。这是 `config.AddPolicy<ItemHateoasResponse>`
    方法的例子，它为 `ItemsHateoasController` 中声明的每个操作方法名称调用 `RequireRoutedLink`。请注意，与前面的情况类似，我们可以将此代码片段提取到外部扩展方法中，以使
    `Startup` 类尽可能干净。最后，这种方法允许我们为不同的响应模型定义不同的链接组。此外，可以针对特定的响应模型建立策略。
- en: 'Consequently, we can now run and verify the result by executing the `dotnet
    run` command in the `Catalog.API` folder. Please note, to run the Docker SQL Server,
    specify the connection string in `appsetting.json` file. After that, we can run
    the following `curl` request to verify `ItemsHateoasController`. The resulting
    JSON response will look as follows:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们现在可以通过在 `Catalog.API` 文件夹中执行 `dotnet run` 命令来运行并验证结果。请注意，要运行 Docker SQL
    Server，请在 `appsetting.json` 文件中指定连接字符串。之后，我们可以运行以下 `curl` 请求来验证 `ItemsHateoasController`。生成的
    JSON 响应将如下所示：
- en: '[PRE22]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: As you can see, in addition to the list of items, `ItemHateoasController` also
    retrieves an envelope that provides additional information to the client, such
    as the other routes needed for the get, add, update, and delete operations. Furthermore,
    this approach gives all the URIs needed by the client, in order to navigate through
    the information exposed by the web service.
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，除了项目列表之外，`ItemHateoasController` 还检索了一个提供额外信息的信封，例如客户端需要的其他用于获取、添加、更新和删除操作的路由。此外，这种方法提供了客户端需要的所有
    URI，以便通过 Web 服务公开的信息进行导航。
- en: The asynchronous code in ASP.NET Core
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core 中的异步代码
- en: In this section, we will discuss the asynchronous code stack of ASP.NET Core.
    We have already dealt with the asynchronous pattern, and we have already seen
    that some of the implementations in the previous chapters used asynchronous code
    extensively.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将讨论 ASP.NET Core 的异步代码堆栈。我们已经处理了异步模式，并且已经看到前几章中的一些实现广泛使用了异步代码。
- en: Note that the following section is mainly focused on asynchronous code in ASP.NET
    Core based on .NET Core. Bear in mind that there are some differences between
    asynchronous programming in .NET Core and .NET Framework. Some of the deadlocking
    issues that we are used to seeing in .NET Framework are not present in .NET Core.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，以下部分主要关注基于 .NET Core 的 ASP.NET Core 中的异步代码。请记住，.NET Core 和 .NET Framework
    中的异步编程之间存在一些差异。我们习惯于在 .NET Framework 中看到的某些死锁问题在 .NET Core 中不存在。
- en: Before we start digging into the asynchronous code, let's take a look at the
    differences between synchronous and asynchronous systems in ASP.NET Core.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们深入探讨异步代码之前，让我们看看 ASP.NET Core 中同步和异步系统之间的区别。
- en: First of all, when a synchronous API receives a request, a thread from the thread
    pool will handle the request. The assigned thread is busy until the end of the
    request life cycle. In most cases, the API performs I/O operations on data or
    third-party APIs, which means that the thread will be blocked until the end of
    these operations. More specifically, a blocked thread cannot be used by other
    operations and requests. For asynchronous code, however, the behavior is entirely
    different.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，当一个同步 API 收到请求时，线程池中的一个线程将处理该请求。分配的线程将一直忙碌到请求的生命周期结束。在大多数情况下，API 对数据或第三方
    API 执行 I/O 操作，这意味着线程将一直阻塞，直到这些操作结束。更具体地说，一个阻塞的线程不能被其他操作和请求使用。然而，对于异步代码，行为完全不同。
- en: The request will be assigned to a thread, but the thread will not be locked,
    and it can be assigned and used by other operations. If the task is awaited and
    it doesn't involve CPU-bound work, then the thread can be released to return to
    the pool to carry out other work.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 请求将被分配到一个线程，但该线程不会被锁定，它可以被其他操作分配和使用。如果任务被等待且不涉及 CPU 密集型工作，则可以将线程释放回池中以执行其他工作。
- en: Task definitions
  id: totrans-84
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 任务定义
- en: The `Task` type represents asynchronous tasks. The `Task` class is a representation
    of a unit of work. We can find similar concepts in other languages. For example,
    in JavaScript, the concept of `Task` is represented by a `Promise`.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task` 类型代表异步任务。`Task` 类代表一个工作单元。我们可以在其他语言中找到类似的概念。例如，在 JavaScript 中，`Task`
    的概念由 `Promise` 表示。'
- en: 'It is common to associate a `Task` type with a thread in our CPU, which is
    not correct: wrapping a method execution in a `Task` doesn''t guarantee that the
    operation will be executed on another thread.'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 将 `Task` 类型与 CPU 中的线程相关联是常见的，但这并不正确：将方法执行包装在 `Task` 中并不能保证该操作将在另一个线程上执行。
- en: 'The `async` and `await` keywords are the easiest way to deal with asynchronous
    operations in C#: the `async` keyword converts the method into a state machine
    and it enables the `await` keyword in the implementation of the method. The `await`
    keyword indicates to the compiler the operations that need to be awaited in order
    to proceed with the execution of the asynchronous method. Therefore, it is common
    to find something similar in C# codebases:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`async` 和 `await` 关键字是处理 C# 中异步操作的最简单方法：`async` 关键字将方法转换为状态机，并在方法实现中启用 `await`
    关键字。`await` 关键字向编译器指示需要等待的操作，以便继续执行异步方法。因此，在 C# 代码库中经常可以找到类似的内容：'
- en: '[PRE23]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'The preceding snippet is very intuitive: it calls a `url` using the `GetAsync`
    method of the `_httpClient` instance, and it uses `ReadAsStringAsync` to get the
    resulting string and store it in the `responseContent` object. It is essential
    to understand that `async` and `await` are syntactic sugar keywords, and the same
    result can be achieved in a less readable way by using the `ContinueWith` method:'
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码片段非常直观：它通过 `_httpClient` 实例的 `GetAsync` 方法调用一个 `url`，并使用 `ReadAsStringAsync`
    获取结果字符串并将其存储在 `responseContent` 对象中。重要的是要理解 `async` 和 `await` 是语法糖关键字，同样可以通过使用
    `ContinueWith` 方法以不太易读的方式达到相同的结果：
- en: '[PRE24]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: This code snippet has the same effect as the previous one. The main difference
    is that this code is less intuitive. Furthermore, in complex operations that execute
    a lot of nested transactions, we would create a lot of nesting levels.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段与前面的代码具有相同的效果。主要区别在于这个代码不太直观。此外，在执行大量嵌套事务的复杂操作中，我们会创建很多嵌套层级。
- en: 'It is essential to embrace the `async`/`await` syntax as the primary way of
    working with asynchronous code. Other languages have taken a similar approach
    to keep the code more clean and readable. This is the case for ECMAScript, which
    introduced the `async`/`await` syntax in ES 2016: [https://github.com/tc39/ecma262/blob/master/README.md](https://github.com/tc39/ecma262/blob/master/README.md).'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 接受 `async`/`await` 语法作为处理异步代码的主要方式是至关重要的。其他语言也采取了类似的方法来使代码更加整洁和易于阅读。ECMAScript
    就是这种情况，它在 ES 2016 中引入了 `async`/`await` 语法：[https://github.com/tc39/ecma262/blob/master/README.md](https://github.com/tc39/ecma262/blob/master/README.md).
- en: The need for asynchronous code in ASP.NET Core
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 在 ASP.NET Core 中异步代码的需求
- en: 'The first thing to underline is that asynchronous code is not about speed.
    As mentioned before, asynchronous programming is just about not blocking incoming
    requests. Therefore, the real benefit is about better vertical scalability*,*
    instead of increasing the speed of our code. For example, let''s suppose that
    our web services perform some I/O operations such as queries on a database: in
    case we run our code stack in a synchronous way, the thread used by an incoming
    request will be blocked and not used by any other request until the read or write
    (I/O operation) process is completed. By taking an asynchronous approach we are
    able to release the thread as soon as the read/write operation is executed. Therefore,
    once the I/O operation is finished, the application will pick up another or the
    same thread in order to continue the execution of the stack.'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 首先需要强调的是，异步代码并非关乎速度。正如之前提到的，异步编程仅仅是关于不阻塞传入的请求。因此，真正的益处在于更好的垂直可伸缩性*，而不是提高我们代码的速度。例如，假设我们的网络服务执行一些I/O操作，比如对数据库的查询：如果我们以同步方式运行我们的代码堆栈，那么用于传入请求的线程将被阻塞，直到读取或写入（I/O操作）过程完成，期间不会被其他请求使用。通过采用异步方法，我们能够在读取/写入操作执行后立即释放线程。因此，一旦I/O操作完成，应用程序将选择另一个或相同的线程以继续执行堆栈。
- en: 'The asynchronous code also adds an overhead cost to our system, in fact, it
    is necessary to add additional logic to coordinate asynchronous operations. For
    example, let''s take a look at the following code:'
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 异步代码也为我们系统增加了开销，实际上，有必要添加额外的逻辑来协调异步操作。例如，让我们看一下以下代码：
- en: '[PRE25]'
  id: totrans-96
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: The aforementioned example defines an action method that calls an asynchronous
    method. With the help of some external tools, such as ILSpy, it is possible to
    decompile the C# code and analyze the IL code. The **IL code** is also known as
    the **intermediate code**, which is the code that is generated by the C# compiler
    and executed at runtime.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 上述示例定义了一个调用异步方法的操作方法。借助一些外部工具，例如ILSpy，可以反编译C#代码并分析IL代码。**IL代码**也被称为**中间代码**，这是由C#编译器生成并在运行时执行的代码。
- en: 'The resulting transformation in the IL code of the previously defined `Get`
    method looks as follows:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: 之前定义的`Get`方法的IL代码的结果转换如下：
- en: '[PRE26]'
  id: totrans-99
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: As you can see, the method has been transformed into a sealed class that implements
    the `IAsyncStateMachine` interface. The `MoveNext` method continuously checks
    whether the `__state` of the state machine is changed and updates the result of
    the operation. All these operations are performed for each asynchronous operation
    contained in our code.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，该方法已被转换为一个实现了`IAsyncStateMachine`接口的密封类。`MoveNext`方法持续检查状态机的`__state`是否发生变化，并更新操作的结果。所有这些操作都是针对我们代码中包含的每个异步操作执行的。
- en: What's new in ASP.NET Core?
  id: totrans-101
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: ASP.NET Core的新特性是什么？
- en: Since its introduction in the old ASP.NET framework, the `async`/`await` code
    was previously affected by some *deadlock issues*. The old version of ASP.NET
    uses a class called `SynchronizationContext`, which essentially provides a way
    to queue a `Task` to a context when a method calls other tasks that are nested
    asynchronous methods and forces them to be executed synchronously using the `.Result`
    or `.Wait()` keywords, therefore, this causes a deadlock of the request context.
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 自从在旧ASP.NET框架中引入以来，`async`/`await`代码之前受到了一些*死锁问题*的影响。旧版本的ASP.NET使用一个名为`SynchronizationContext`的类，它本质上提供了一种将`Task`排队到上下文中的方式，当方法调用其他嵌套的异步方法时，并强制它们使用`.Result`或`.Wait()`关键字以同步方式执行，因此，这会导致请求上下文的死锁。
- en: 'For example, let''s suppose that the following code is executed on the old
    version of ASP.NET:'
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设以下代码在旧版本的ASP.NET上执行：
- en: '[PRE27]'
  id: totrans-104
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This leads to a deadlock in the application because the `Get()` and `Operation1Async()`
    methods are using the same context. While the `Operation1Async()` method captures
    the context, which will be used to continue running the method, the `Get()` action
    method is blocking the context because it is waiting for a result.
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 这导致应用程序出现死锁，因为`Get()`和`Operation1Async()`方法使用了相同的上下文。当`Operation1Async()`方法捕获上下文，该上下文将被用于继续运行方法时，`Get()`操作方法会阻塞上下文，因为它正在等待结果。
- en: 'For this reason, developers started to fill their asynchronous code with `.ConfigureAwait(false)`
    instructions, which primarily provides a way to execute the `Task` in a different
    context by avoiding the deadlock issue seen before:'
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，开发者开始在他们异步代码中填充 `.ConfigureAwait(false)` 指令，这主要提供了一种通过避免之前看到的死锁问题来在不同的上下文中执行
    `Task` 的方法：
- en: '[PRE28]'
  id: totrans-107
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: This kind of approach works, but we should consider that by calling `Result`
    or `.Wait()`, we are losing all the benefits provided by the asynchronous programming
    pattern.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法可行，但我们应该考虑，通过调用 `Result` 或 `.Wait()`，我们正在失去异步编程模式提供的所有好处。
- en: 'The good news about ASP.NET Core is that it doesn''t use `SynchronizationContext`.
    The *context-less* idea provides lightweight management of the asynchronous code:
    while ASP.NET queues each asynchronous unit in the request context before assigning
    it to a thread, ASP.NET Core picks up a thread from the assigned thread pool and
    attaches it to the asynchronous task.'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 关于 ASP.NET Core 的好消息是它不使用 `SynchronizationContext`。*无上下文*的概念提供了异步代码的轻量级管理：当
    ASP.NET 在将异步单元分配给线程之前，在请求上下文中排队每个异步单元，而 ASP.NET Core 则从分配的线程池中选取一个线程并将其附加到异步任务。
- en: Moreover, the ASP.NET team has done an excellent job with ASP.NET Core and,
    as we saw in previous chapters, almost every component that is part of the ASP.NET
    Core pipeline has both a *synchronous* and an *asynchronous* version. This is
    the case, for example, for the action filter that we saw in [Chapter 6](13fd7d18-3ebe-4f60-89ff-4666d1c9671a.xhtml)*,*
    *Filter Pipeline*.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，ASP.NET 团队在 ASP.NET Core 方面做得非常出色，正如我们在前面的章节中看到的，ASP.NET Core 管道中的几乎每个组件都有同步和异步版本。例如，我们看到的动作过滤器就有同步和异步版本。[第
    6 章](13fd7d18-3ebe-4f60-89ff-4666d1c9671a.xhtml)*，*过滤器管道*。
- en: While the `.ConfigureAwait(false)` method is not needed anymore with the new
    version of .NET Core, we should keep in mind that it is still useful in some codebases.
    If you are building a .NET library that compiles in .NET Core but also in older
    version of the .NET Framework, you should still use the `.ConfigureAwait(false)`
    method in order to avoid deadlocks.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在新的 .NET Core 版本中不再需要 `.ConfigureAwait(false)` 方法，但我们应记住，在某些代码库中它仍然很有用。如果您正在构建一个在
    .NET Core 中编译但在旧版 .NET Framework 中也编译的 .NET 库，您仍然应该使用 `.ConfigureAwait(false)`
    方法，以避免死锁。
- en: Best practices in asynchronous programming
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 异步编程的最佳实践
- en: Let's take a look at some good and bad practices to do with the asynchronous
    programming model in ASP.NET Core. First of all, the central concept to keep in
    mind is to avoid mixing between synchronous and asynchronous code. As mentioned
    previously, ASP.NET Core exposes both the sync and `async` versions of the majority
    of classes and interfaces. Therefore, before blocking an asynchronous stack with
    synchronous code, you should explore and check all the alternatives provided by
    the framework.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们来看看在 ASP.NET Core 中关于异步编程模型的良好和不良实践。首先，需要牢记的核心概念是避免在同步和异步代码之间混合。如前所述，ASP.NET
    Core 提供了大多数类和接口的同步和 `async` 版本。因此，在用同步代码阻塞异步堆栈之前，你应该探索并检查框架提供的所有替代方案。
- en: 'The following recommendations come from a high-level perspective of asynchronous
    programming in .NET. This book is focused on other aspects of the framework. If
    you want to get more details about how to work with asynchronous programming,
    I suggest you navigate to the following link: [https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md).
    Moreover, if you want a more general overview of concurrency in .NET, I suggest
    you read the following book: *Concurrency in C# Cookbook* by Stephen Cleary ([https://stephencleary.com/book/](https://stephencleary.com/book/)).'
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 以下建议来自 .NET 异步编程的高级视角。本书专注于框架的其他方面。如果您想了解更多关于如何使用异步编程的细节，我建议您访问以下链接：[https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md](https://github.com/davidfowl/AspNetCoreDiagnosticScenarios/blob/master/AsyncGuidance.md)。此外，如果您想了解
    .NET 中并发的更一般概述，我建议您阅读以下书籍：*Concurrency in C# Cookbook* by Stephen Cleary ([https://stephencleary.com/book/](https://stephencleary.com/book/))。
- en: Don't use async void methods
  id: totrans-115
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 不要使用 async void 方法
- en: 'A common mistake about asynchronous programming in .NET Core and, more in general,
    in the whole .NET ecosystem, is to declare a method as `async void`. Indeed, when
    we declare a method as `async void`, we will not be able to catch exceptions thrown
    by the method. Furthermore, the `Task` type is used to capture the exceptions
    of the method and propagate them to the caller. In summary, we should always implement
    our `async` methods by returning the `Task` type when the method returns `void`,
    otherwise, we should return the `Task<T>` generic type when the method returns
    a type. Furthermore, the `Task` type is also useful when we want to notify the
    status of the operation to the caller: the `Task` type exposes the status of the
    operation through the following attributes: `Status`, `IsCanceled`, `IsCompleted,`
    and `IsFaulted`.'
  id: totrans-116
  prefs: []
  type: TYPE_NORMAL
  zh: 关于.NET Core和更广泛的.NET生态系统中异步编程的一个常见错误是声明一个方法为`async void`。实际上，当我们声明一个方法为`async
    void`时，我们将无法捕获该方法抛出的异常。此外，`Task`类型用于捕获方法的异常并将它们传播给调用者。总之，我们应该始终通过在方法返回`void`时返回`Task`类型来实现我们的`async`方法，否则，当方法返回一个类型时，我们应该返回`Task<T>`泛型类型。此外，`Task`类型在我们要通知调用者操作状态时也非常有用：`Task`类型通过以下属性公开操作状态：`Status`、`IsCanceled`、`IsCompleted`和`IsFaulted`。
- en: Use Task.FromResult over Task.Run
  id: totrans-117
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用Task.FromResult代替Task.Run
- en: 'If you have previously worked with .NET Core or .NET Framework, you have probably
    dealt with both `Task.FromResult` and `Task.Run`. Both can be used to return `Task<T>`.
    The main difference between them is in their input parameters. Take a look at
    the following `Task.Run` snippet:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你之前使用过.NET Core或.NET Framework，你可能已经处理过`Task.FromResult`和`Task.Run`。两者都可以用来返回`Task<T>`。它们之间的主要区别在于它们的输入参数。看看下面的`Task.Run`代码片段：
- en: '[PRE29]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'The `Task.Run` method will queue the execution as a work item in the thread
    pool. The work item will immediately complete with the pre-computed value. As
    a result, we have wasted a thread pool. Furthermore, we should also notice that
    the initial purpose of `Task.Run` method was intended for the client-side .NET
    applications: ASP.NET Core is not optimized for the `Task.Run` operations and
    it shouldn''t ever be used to offload the execution of a portion of code. On the
    opposite side, let''s examine another case:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`Task.Run`方法会将执行作为线程池中的工作项排队。工作项将立即完成，并带有预计算的值。因此，我们浪费了线程池。此外，我们还应该注意到，`Task.Run`方法的初始目的是针对客户端.NET应用程序的：ASP.NET
    Core没有针对`Task.Run`操作进行优化，它不应该用来卸载代码的一部分执行。相反，让我们看看另一个案例：'
- en: '[PRE30]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: In this case, the `Task.FromResult` method will wrap the pre-computed result
    without wasting a thread pool which means that we will not have the overhead provided
    by the execution of the `Task.Run` operation.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，`Task.FromResult`方法将预计算的值包装起来，而不会浪费线程池，这意味着我们不会承受`Task.Run`操作执行带来的开销。
- en: Enable cancellation
  id: totrans-123
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 启用取消
- en: Another important topic is to enable the cancellation of asynchronous operations.
    If we take a look at the service layer that we implemented in [Chapter 8](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml),
    and [Chapter 9](f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml), we can see that in
    some cases we have the possibility of passing `CancellationToken` as a parameter.
    The `CancellationToken` provides a light way to notify all asynchronous operations
    that the consumer wants to cancel the current transaction. Moreover, our code
    can examine the `CancellationToken.IsCancellationRequested` property to detect
    whether the consumer has requested the cancellation of the task. This kind of
    approach is especial suitable for long-running operations because the consumer
    of our asynchronous code can request the cancellation of the current performing
    task at any point in the process.
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 另一个重要的话题是启用异步操作的取消。如果我们查看我们在[第8章](84b281bd-11a2-4703-81ae-ca080e2a267a.xhtml)和[第9章](f8ac60e1-e948-4435-b804-e3e4ff305510.xhtml)中实现的服务层，我们可以看到在某些情况下，我们有传递`CancellationToken`作为参数的可能性。`CancellationToken`提供了一种轻量级的方式通知所有异步操作，消费者想要取消当前事务。此外，我们的代码可以检查`CancellationToken.IsCancellationRequested`属性以检测消费者是否请求取消任务。这种方法特别适合长时间运行的操作，因为我们的异步代码的消费者可以在过程中的任何时刻请求取消当前执行的任务。
- en: Asynchronous code in I/O bound operations
  id: totrans-125
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: I/O绑定操作中的异步代码
- en: 'When we implement code in an asynchronous way we should ask ourselves if the
    underlying process involves any kind of I/O operation. If this is the case, we
    should proceed by using an asynchronous approach for that stack. For example,
    the `Get` operation of the `ItemRepository` class involves a query to the database:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们以异步方式实现代码时，我们应该问自己底层过程是否涉及任何类型的I/O操作。如果是这种情况，我们应该使用该堆栈的异步方法进行操作。例如，`ItemRepository`类的`Get`操作涉及到对数据库的查询：
- en: '[PRE31]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'In this case, we are using the `FirstOrDefaultAsync` method to execute the
    operation in an asynchronous way. On the opposite side, if we take as an example
    another operation, such as the `Add` method of the `ItemRepository` we can see
    that the operation is not asynchronous even if the EF Core framework exposes the
    `AddAsync` methods:'
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，我们使用`FirstOrDefaultAsync`方法以异步方式执行操作。相反，如果我们以另一个操作为例，例如`ItemRepository`的`Add`方法，我们可以看到即使EF
    Core框架公开了`AddAsync`方法，该操作也不是异步的：
- en: '[PRE32]'
  id: totrans-129
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'This is because in the case of the adding operation we are not performing any
    kind of I/O operation: the entity is added to the `context` attribute and marked
    with an added status. The proper synchronization with the database happens when
    we call the `SaveChangesAsync` method which is asynchronous because it involves
    I/O operations with the database. In conclusion, we should always keep in mind
    to understand the full context and stack of the operation that we want to execute
    in an asynchronous manner. In general, every time we have to deal with the file
    system, a database, and any other network call we should implement our code using
    an asynchronous stack, otherwise we can keep the code synchronous in order to
    avoid additional thread overheads.'
  id: totrans-130
  prefs: []
  type: TYPE_NORMAL
  zh: 这是因为在添加操作的情况下，我们并没有执行任何类型的I/O操作：实体被添加到`context`属性中，并标记为已添加状态。当调用`SaveChangesAsync`方法时，与数据库的正确同步发生，这个方法是异步的，因为它涉及到与数据库的I/O操作。总之，我们应该始终牢记理解我们想要以异步方式执行的操作的完整上下文和堆栈。一般来说，每次我们必须处理文件系统、数据库和任何其他网络调用时，我们应该使用异步堆栈来实现我们的代码，否则我们可以保持代码的同步，以避免额外的线程开销。
- en: Measure response time using middleware
  id: totrans-131
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 使用中间件测量响应时间
- en: A common way to measure the response time of ASP.NET Core actions is by using
    a *middleware component*. As seen in [Chapter 3](77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml),
    *Working with the Middleware Pipeline*, these components act at the edge of the
    ASP.NET Core request life cycle, and they are useful for performing cross-cutting
    implementations. Measuring the response time of an action method falls into this
    implementation case. Furthermore, middleware is the first component hit by a request
    and the last one that can process an outgoing response. This means that we can
    analyze and include almost the whole life cycle of the request.
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 测量ASP.NET Core操作响应时间的一种常见方法是使用*中间件组件*。如[第3章](77d18c37-0c9d-4b2b-82f5-74fd874c0e0f.xhtml)中所述，*与中间件管道一起工作*，这些组件在ASP.NET
    Core请求生命周期的边缘操作，并且对于执行跨切面实现非常有用。测量动作方法的响应时间属于这种实现情况。此外，中间件是第一个被请求击中的组件，也是最后一个可以处理输出响应的组件。这意味着我们可以分析和包含请求的几乎整个生命周期。
- en: 'Let''s take a look at an implementation of `ResponseTimeMiddlewareAsync`:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`ResponseTimeMiddlewareAsync`的一个实现示例：
- en: '[PRE33]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'The previous class defines an `async` middleware to detect the response time
    of the requests. It follows these steps:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 之前的类定义了一个`async`中间件来检测请求的响应时间。它遵循以下步骤：
- en: It declares a `Stopwatch` instance in the `InvokeAsync` method.
  id: totrans-136
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它在`InvokeAsync`方法中声明了一个`Stopwatch`实例。
- en: It executes the `Start()` method of the `Stopwatch` instance.
  id: totrans-137
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它执行`Stopwatch`实例的`Start()`方法。
- en: It defines a new response delegate using the `OnStarting` method. The `OnStarting`
    method, which allows us to declare a delegate action to be invoked just before
    the response headers, will be sent to the client.
  id: totrans-138
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它使用`OnStarting`方法定义了一个新的响应委托。`OnStarting`方法允许我们在响应头之前调用一个委托动作，这个动作将被发送到客户端。
- en: It calls the `Stop()` method and sets the `ElapsedMilliseconds` property as
    a custom header using the `X-Response-Time-ms` header.
  id: totrans-139
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 它调用`Stop()`方法，并使用`X-Response-Time-ms`自定义头设置`ElapsedMilliseconds`属性。
- en: 'It is possible to include the `ResponseTimeMiddlewareAsync` class in the middleware
    pipeline by adding the following line in the `Startup` class:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 可以通过在`Startup`类中添加以下行将`ResponseTimeMiddlewareAsync`类包含在中间件管道中：
- en: '[PRE34]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Furthermore, it is also possible to test the middleware by following the same
    approach we took for testing the controllers by implementing the following:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，还可以通过实现以下方法，按照我们测试控制器所采取的相同方法来测试中间件：
- en: '[PRE35]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: The `ResponseTimeMiddlewareTests` class allows us to make an HTTP call by extending
    the `InMemoryApplicationFactory` class. We can check whether the `X-Response-Time-ms`
    header exists in the response object. It is important to note that the other measurement
    doesn't include the startup time of the web server or the application pool. Furthermore,
    it takes some additional time when the webserver is not initialized.
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: '`ResponseTimeMiddlewareTests` 类通过扩展 `InMemoryApplicationFactory` 类，使我们能够通过
    HTTP 调用。我们可以检查响应对象中是否存在 `X-Response-Time-ms` 头部。需要注意的是，其他测量不包括 Web 服务器或应用程序池的启动时间。此外，当
    Web 服务器未初始化时，它还会花费一些额外的时间。'
- en: Summary
  id: totrans-145
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we covered some different topics about building an API: from
    the soft deletion of our resources to how to measure the performance of responses.
    We also had an overview of the asynchronous programming stack of ASP.NET Core
    and some recommendations as to how to use it. The topics covered in this chapter
    will be helpful to you at an advanced development stage in order to improve the
    readability of the returned data and the performance of the web service. In the
    next chapter, we will see how to run our catalog solution using containerization
    technologies. The chapter provides an overview of Docker and on the related Docker
    compose tools.'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们介绍了构建 API 的不同主题：从我们资源的软删除到如何测量响应的性能。我们还概述了 ASP.NET Core 的异步编程堆栈以及如何使用它的建议。本章涵盖的主题将在高级开发阶段对您有所帮助，以便提高返回数据的可读性和
    Web 服务的性能。在下一章中，我们将看到如何使用容器化技术运行我们的目录解决方案。本章提供了 Docker 的概述以及相关的 Docker Compose
    工具。
