- en: '*Chapter 11*: Creating an ASP.NET Core 6 Web Application'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have built all the core components of the application, such
    as the data access layer and service layer, and all these components are primarily
    server-side components, also known as **backend components**.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we will build the presentation layer/**user interface** (**UI**)
    for our e-commerce application, which is also known as the **client-side component**.
    The UI is the face of the application; having a good presentation layer not only
    helps with keeping users engaged in the application but also encourages users
    to come back to the application. This is especially the case with enterprise applications,
    where a good presentation layer helps users to navigate through the application
    easily and helps them in performing various day-to-day activities that are dependent
    on the application with ease.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will focus on understanding ASP.NET Core MVC and developing a web application
    using ASP.NET Core MVC. Primarily, we will cover the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to frontend web development
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Integrating APIs with the service layer
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating the controller and actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Creating a UI using ASP.NET Core MVC
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Understanding Blazor
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'For this chapter, you need a basic knowledge of C#, .NET Core, HTML, and CSS.
    The code examples for the chapter can be found here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter11/RazorSample](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Chapter11/RazorSample).'
  prefs: []
  type: TYPE_NORMAL
- en: 'You can find more code examples here: [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/tree/main/Enterprise%20Application).'
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to frontend web development
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: The presentation layer is all about code that a browser can render and display
    to the user. Whenever a page gets loaded in a browser, it creates a hierarchy
    of various elements, such as textboxes and labels, that are present on the page.
    This hierarchy is known as the **Document Object Model** (**DOM**).
  prefs: []
  type: TYPE_NORMAL
- en: 'A good frontend is all about the ability to manipulate the DOM as needed, and
    there are many technologies/libraries that support manipulating the DOM and loading
    data dynamically using the de facto language of the web, JavaScript. Be it jQuery
    (which simplifies the use of JavaScript), full-blown client-side frameworks such
    as Angular, React, or Vue (which support complete client-side rendering), or ASP.NET
    Core frameworks such as ASP.NET Core MVC, Razor Pages, or Blazor, it all boils
    down to handling the three major building blocks of the web: HTML, CSS, and JavaScript.
    Let''s look into these three building blocks:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Hypertext Markup Language** (**HTML**): HTML, as the full form states, is
    a markup language that browsers can understand and display the contents. It primarily
    consists of a series of tags, which are known as **HTML elements**, and allows
    developers to define the structure of the page. For example, if you want to create
    a form that needs to allow the user to enter their first name and last name, it
    can be defined by using input HTML elements.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Cascading Style Sheets** (**CSS**): The presentation layer is all about presenting
    data in a way that makes a web application more appealing to users and ensures
    that the application is usable, irrespective of the device/resolution that a user
    tries to load the application in. This is where CSS plays a critical role in defining
    how the content is displayed on the browser. It controls various things, such
    as the styling of the pages, the theme of the application, and the color palette,
    and, more importantly, makes them responsive so that users have the same experience
    using the application, be it loaded on a mobile or a desktop.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The good thing about modern web development is we don't need to write everything
    from scratch and many libraries are available that can be picked and used as they
    are, in the application. We will be using one such library for an e-commerce application,
    which is explained in the *Creating a UI using ASP.NET Core MVC* section.
  prefs: []
  type: TYPE_NORMAL
- en: '**JavaScript**: JavaScript is a scripting language that helps in performing
    various advanced dynamic operations, for example, validating input text entered
    in a form or things such as enabling/disabling HTML elements conditionally or
    retrieving data from an API. JavaScript gives more power to web pages and adds
    many programming features that a developer can use to perform advanced operations
    on the client side. Just like HTML and CSS, all browsers can understand JavaScript,
    which forms an important part of the presentation layer. All these components
    can be linked to each other, as shown in the following diagram:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.1 – HTML, CSS, and JavaScript'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.1_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.1 – HTML, CSS, and JavaScript
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: HTML, CSS, and JavaScript all go hand in hand and play an important role in
    developing client-side/frontend applications and would require dedicated books
    to explain fully. Some related links can be found in the *Further reading* section.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we understand the importance of HTML, CSS, and JavaScript, we need
    to know how we can use them to build the presentation layer of a web application
    so that it can support multiple browsers and devices with different resolutions
    and is able to manage the state (HTTP being stateless).
  prefs: []
  type: TYPE_NORMAL
- en: One technique could be to create all the HTML pages and host them on a web server;
    however, while this works well with static sites and also involves building everything
    from the ground up, if we want the content to be more dynamic and want a rich
    UI, we need to use technologies that can generate the HTML pages dynamically and
    provide seamless support to interact with the backend. Let's look, in the next
    section, at various technologies that can be used to generate dynamic HTML.
  prefs: []
  type: TYPE_NORMAL
- en: Razor syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before we start understanding the various possible frameworks provided by ASP.NET
    Core, let's first understand what the Razor syntax is. It is a markup syntax to
    embed server-side components into HTML. We can use the Razor syntax to bind any
    dynamic data for display or send it back to the server from a view/page for further
    processing. The Razor syntax is primarily written in Razor files/Razor view pages,
    which are nothing more than files used by C# to generate dynamic HTML. They go
    with the `.cshtml` extension and support the Razor syntax. The Razor syntax is
    processed by an engine called the **view engine**, and the default view engine
    is known as the **Razor engine**.
  prefs: []
  type: TYPE_NORMAL
- en: 'To embed the Razor syntax, we typically use `@`, which tells the Razor engine
    to parse and generate HTML out of the engine. `@` can be followed by any C# built-in
    methods to generate HTML. For example, `<b>@DateTime.Now</b>` can be used to display
    the current date and time in a Razor view/page. Apart from this, just like C#,
    the Razor syntax also supports code blocks and controls structures and variables,
    among other things. Some sample Razor syntax going through the Razor engine is
    shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.2 – Razor syntax'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.2_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.2 – Razor syntax
  prefs: []
  type: TYPE_NORMAL
- en: 'The Razor syntax also supports defining HTML controls; for example, to define
    a textbox, we can use the following Razor syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: 'The preceding code is known as an `input` tag helper and the Razor syntax takes
    care of what is known as **directive** tag helpers to bind data to an HTML control
    and generate rich, dynamic HTML. Let''s discuss this briefly:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Directives**: Under the hood, each Razor view/page is parsed by the Razor
    engine, and a C# class is used to generate dynamic HTML and then send it back
    to the browser. Directives can be used to control the behavior of this class,
    which further controls the dynamic HTML that is generated.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: For example, the `@using` directive can be used to include any namespaces in
    the Razor view/page, or the `@code` directive can be used to include any C# members.
  prefs: []
  type: TYPE_NORMAL
- en: One of the most used directives is `@model`, which allows you to bind a model
    to a view, which helps in validating the type of view as well as helps with IntelliSense.
    This process of binding views to a specific class/model is known as **strongly
    typing** views. We will be strongly typing all our views in our e-commerce application,
    which we will see in the *Creating a UI using ASP.NET Core MVC* section.
  prefs: []
  type: TYPE_NORMAL
- en: '**Tag helpers**: If you used ASP.NET MVC before ASP.NET Core, you would have
    come across HTML helpers, which are classes that help to bind data and generate
    HTML controls.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'However, with ASP.NET Core, we have tag helpers, which help us to bind data
    to an HTML control. The benefit of tag helpers over HTML helpers is that tag helpers
    use the same syntax as HTML with additional attributes assigned to the standard
    HTML controls that can be generated from dynamic data. For example, to generate
    an HTML textbox control, typically, we write the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Using tag helpers, this would be rewritten as shown in the following code,
    where `@Name` is the property of the model that the view is strongly typed to:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'So, as you can see, it''s all about writing HTML but taking advantage of Razor
    markup to generate dynamic HTML. ASP.NET Core comes with many built-in tag helpers,
    and more details about them can be found here: [https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/tag-helpers/built-in/?view=aspnetcore-6.0).'
  prefs: []
  type: TYPE_NORMAL
- en: It is not required to know about/remember every tag helper, and we will use
    this reference documentation as and when we develop our application UI.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'Since Razor syntax is markup, it''s not necessary to know all the syntax. The
    following link can be used as a reference for Razor syntax: [https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/razor?view=aspnetcore-6.0).'
  prefs: []
  type: TYPE_NORMAL
- en: With this, let's look into the various options in ASP.NET Core as well as other
    common frameworks to develop the presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring Razor Pages
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Razor Pages is the default way to implement a web application using ASP.NET
    Core. Razor Pages relies on the concept of having a Razor file that can serve
    requests directly and an optional C# file associated with that Razor file for
    any additional processing. A typical Razor application can be created with the
    following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the project has Razor pages and their corresponding C# files.
    On opening any Razor view, we see a directive called `@page`, which helps in browsing
    the page. So, for example, `/index` will be routed to `index.cshtml`. It's important
    that all Razor pages have the `@page` directive at the top of the page and are
    placed in the `Pages` folder, as the ASP.NET Core runtime looks for all the Razor
    pages in this folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'A Razor page can be further associated with a C# class, also known as a `PageModel`
    class, by using another directive called `@model`. The following is the code for
    the `index.cshtml` page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'The `PageModel` class is nothing more than a C# class that can have specific
    methods for `GET` and `POST` calls so that data on the Razor page can be dynamically
    fetched, say, from an API. This class needs to be inherited by `Microsoft.AspNetCore.Mvc.RazorPages.PageModel`
    and is a standard C# class. `PageModel` for `index.cshtml`, which is part of `index.cshtml.cs`,
    is shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE33]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE34]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE35]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE36]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE37]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE38]'
  prefs: []
  type: TYPE_PRE
- en: Here, you can see that we are populating additional data that was used on the
    Razor page via the `OnGet` method, which is also known as a `PageModel` handler
    and can be used for the initialization of the Razor page. Like `OnGet`, we can
    add an `OnPost` handler that can be used to submit data back from the Razor page
    to `PageModel` and further the process.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `OnPost` method will automatically bind all the properties in the `PageModel`
    class if they meet the following two conditions:'
  prefs: []
  type: TYPE_NORMAL
- en: The property is annotated with the `BindProperty` attribute.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The Razor page has an HTML control with the same name as the property.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'So, for example, if we wanted to bind the value of the `select` control in
    the preceding code, we need to first add a property to the `PageModel` class,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE39]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE40]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, use the property name for the `select` control, as shown here, and Razor
    Pages will automatically bind the selected value to this property:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE41]'
  prefs: []
  type: TYPE_PRE
- en: We can use an asynchronous naming convention for the `OnGet` and `OnPost` methods
    so that they can be named as `OnGetAsync/OnPostAsync` if we are using asynchronous
    programming.
  prefs: []
  type: TYPE_NORMAL
- en: Razor Pages also supports calling methods based on the verb. The pattern for
    the method name should follow the `OnPost[handler]/OnPost[handler]Async` convention,
    where `[handler]` is the value set on the `asp-page-handler` attribute of any
    tag helper.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, the following code will call the `OnPostDelete/OnPostDeleteAsync`
    method from the corresponding `PageModel` class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE42]'
  prefs: []
  type: TYPE_PRE
- en: 'For the services configuration part, Razor Pages can be configured using the
    `AddRazorPages` method in the `Program` class by adding the service to the ASP.NET
    Core `MapRazorPages` middleware needs to be injected for the Razor pages endpoint
    in the `Program` class, as shown in the following code. This is done so that all
    the Razor pages can be requested using the name of the page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE43]'
  prefs: []
  type: TYPE_PRE
- en: This completes a simple Razor page application setup; we saw another sample
    in [*Chapter 9*](B18507_09_Epub.xhtml#_idTextAnchor860), *Working with Data in
    .NET 6*, that used Razor Pages to retrieve data from a database using **Entity
    Framework Core** (**EF Core**).
  prefs: []
  type: TYPE_NORMAL
- en: Razor Pages is the easiest form of developing web applications in ASP.NET Core;
    however, for a more structured form of developing web applications that can handle
    complex features, we can go with ASP.NET Core MVC. Let's explore developing web
    apps using ASP.NET Core MVC in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring the ASP.NET Core MVC website
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: As the name suggests, ASP.NET Core MVC is based on the MVC pattern discussed
    in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040), *Creating an ASP.NET
    Core 6 Web API*, and is a framework in ASP.NET Core to build web applications.
    We saw in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040), *Creating an
    ASP.NET Core 6 Web API*, that the ASP.NET Core Web API also uses the MVC pattern;
    however, ASP.NET Core MVC also supports views to display data. The underlying
    design pattern is the same, where we have a model to hold data, a controller to
    transfer the data, and views to render and display the data.
  prefs: []
  type: TYPE_NORMAL
- en: ASP.NET Core MVC supports all the features that were discussed in [*Chapter
    10*](B18507_10_Epub.xhtml#_idTextAnchor1040), *Creating an ASP.NET Core 6 Web
    API*, such as routing, DI, model binding, and model validation, and uses the same
    bootstrapping technique of using the `Program` class. Like the Web API, .NET 6
    application services and middlewares are configured in the `Program` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'One of the key differences with MVC is the additional loading of views for
    which, instead of `AddControllers`, we need to use `AddControllersWithViews` in
    the `Program` class. An example is shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.3 – MVC request life cycle'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.3_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.3 – MVC request life cycle
  prefs: []
  type: TYPE_NORMAL
- en: '`AddControllersWithViews` primarily takes care of loading the views and handling
    the data sent by the controller, but most importantly, it takes care of configuring
    the Razor engine service that is used to process the Razor syntax in views and
    generate dynamic HTML.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Controller actions in ASP.NET Core MVC need to be routed based on the action
    name passed in the URL, so on the routing part, instead of calling `MapController`,
    we configure `MapControllerRoute` and pass a pattern to it. So, the default routing
    configuration in the `UseEndpoints` middleware looks as in the following code
    snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE44]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE45]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE46]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE47]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE48]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE49]'
  prefs: []
  type: TYPE_PRE
- en: Here, in the pattern, we are telling the middleware that the first part of the
    URL should be a `controller` name, followed by the action name and an optional
    `id` parameter. If nothing is passed in the URL, the default route is the `Index`
    action method of `ProductsController`. So, primarily, this is the convention-based
    routing we discussed in [*Chapter 10*](B18507_10_Epub.xhtml#_idTextAnchor1040),
    *Creating an ASP.NET Core 6 Web API*.
  prefs: []
  type: TYPE_NORMAL
- en: Just like Razor Pages, views in ASP.NET Core MVC applications support the Razor
    syntax and allow strongly typed views; that is, a view can be bound to a model
    for type checking, and model properties can be associated with HTML controls with
    compile-time IntelliSense support.
  prefs: []
  type: TYPE_NORMAL
- en: Since ASP.NET Core MVC gives more structure to the application, we will be using
    ASP.NET Core MVC for our presentation layer development, and it is discussed in
    detail while implementing the presentation layer in subsequent sections.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'There is always a common question on which technology to choose for frontend
    development. The following link has some recommendations around this topic: [https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/choose-between-traditional-web-and-single-page-apps](https://docs.microsoft.com/en-us/dotnet/architecture/modern-web-apps-azure/choose-between-traditional-web-and-single-page-apps).
    All the pros and cons should be evaluated before choosing the frontend technology
    as there are no one-size-fits-all requirements.'
  prefs: []
  type: TYPE_NORMAL
- en: With this foundation, let's move on to the next section, where we will start
    integrating the backend APIs developed up until now with our presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: Integrating APIs with the service layer
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this section, we will be developing the `Packt.Ecommerce.Web` ASP.NET Core
    MVC application, which is created by adding the `ASP.NET Core web application(Model-View-Controller)`
    template. As we have already developed various APIs needed for the presentation
    layer, we will first build a wrapper class that will be used to communicate with
    these APIs.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is a single wrapper class that will be used to communicate with various
    APIs, so let''s create the contract for this class. For simplicity, we will limit
    the requirements to the most important workflow in our e-commerce application,
    and that will be as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: The landing page retrieves all products in the system and allows users to search/filter
    the products.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: View the details of the products, add them to the cart, and be able to add more
    products to the cart.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Complete the order and see the invoice.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To follow a more structured approach, we will segregate various classes and
    interfaces into separate folders. Let''s see how in the following steps:'
  prefs: []
  type: TYPE_NORMAL
- en: 'To start with, let''s add a `Contracts` folder to the `Packt.Ecommerce.Web`
    project and add an interface with the name `IECommerceService`. This interface
    will have the following methods:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE50]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Now, let's add a folder called `Services` and add a class called `EcommerceService`.
    This class will inherit `IECommerceService` and implement all the methods.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: As we need to call various APIs, we need to make use of the `Packt.Ecommerce.Common.Options.ApplicationSettings`
    using the `options` pattern.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The `Program` class will have the following services configured for our MVC
    application:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AddControllersWithViews`: This will inject the necessary services for ASP.NET
    Core MVC to use controllers and views.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`ApplicationSettings`: This will configure the `ApplicationSettings` class
    using the `IOptions` pattern with the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE51]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`AddHttpClient`: This will inject `System.Net.Http.IHttpClientFactory` and
    related classes that will allow us to create an `HttpClient` object. Additionally,
    we will configure the retry policy and circuit break policy, as discussed in [*Chapter
    10*](B18507_10_Epub.xhtml#_idTextAnchor1040), *Creating an ASP.NET Core 6 Web
    API*.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Mapping `EcommerceService` to `IECommerceService` using the .NET Core DI container.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Configure the app insights using the following code:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE52]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Moving on to the middleware, we will be injecting the following middleware
    using the `Program` class, apart from the default routing middleware:'
  prefs: []
  type: TYPE_NORMAL
- en: '`UseStatusCodePagesWithReExecute`: This middleware is used to redirect to a
    custom page other than for the `500` error code. We will add a method in `ProductController`
    in the next section that will be executed and loads the relevant view based on
    the error code. This middleware takes a string as an input parameter, which is
    nothing more than the route that should be executed in the case of an error, and
    to pass an error code, it allows a placeholder of `{0}`. So, the middleware configuration
    would look as follows:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE53]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '**Error handling**: As for the presentation layer, unlike with the API, we
    need to redirect users to a custom page that, in the case of runtime failures,
    has relevant information, such as a user-friendly failure message and a relevant
    logging ID that can be used to retrieve the actual failure at a later stage. However,
    in the case of a development environment, we can show the complete error along
    with the stack. So, we will configure two middlewares as shown in the following
    code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE54]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: Here, we can see that for the development environment, we are using the `UseDeveloperExceptionPage`
    middleware, which will load the full exception stack trace, whereas, for non-development
    environments, we are using the `UseExceptionHandler` middleware, which takes the
    path of the error action method that needs to be executed. Additionally, here,
    we don't need our custom error handling middleware, as the ASP.NET Core middleware
    takes care of logging detailed errors to the logging provider, which is Application
    Insights in our case.
  prefs: []
  type: TYPE_NORMAL
- en: '`UseStaticFiles`: To allow various static files, such as CSS, JavaScript, images,
    and any other static files, we don''t need to go through the entire request pipeline,
    and that is where this middleware comes into play, which allows serving static
    files and supports short-circuiting the rest of the pipeline for static files.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Coming back to the `EcommerceService` class, let''s first define the local
    variables and the constructor of this class, which will inject the `HTTPClient`
    factory and `ApplicationSettings` using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE55]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE56]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE57]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE58]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE59]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE60]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE61]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE62]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE63]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, to implement methods as per our `IECommerceService` interface, we will
    use the following steps for the Get APIs:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.4 – Get call to API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.4_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.4 – Get call to API
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on the steps in the preceding figure, the implementation of `GetProductsAsync`,
    which is primarily used to retrieve products for the landing page and apply any
    filters while doing a product search, will look as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE64]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE65]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE66]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE67]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE68]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE69]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE70]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE71]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE72]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE73]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE74]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE75]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE76]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE77]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE78]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE79]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE80]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE81]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE82]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE83]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE84]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE85]'
  prefs: []
  type: TYPE_PRE
- en: 'For the `POST`/`PUT` APIs, we will have similar steps with slight modifications,
    as shown in the following figure:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.5 – Post call to API'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.5_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.5 – Post call to API
  prefs: []
  type: TYPE_NORMAL
- en: 'Based on this, the strategy implementation of `CreateOrUpdateOrder`, which
    is primarily used to create the shopping cart, will look as shown in the following
    code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE86]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE87]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE88]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE89]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE90]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE91]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE92]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE93]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE94]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE95]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE96]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE97]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE98]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE99]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE100]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE101]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE102]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE103]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE104]'
  prefs: []
  type: TYPE_PRE
- en: Similarly, we will implement `GetProductByIdAsync`, `GetOrderByIdAsync`, `GetInvoiceByIdAsync`,
    and `SubmitOrder` using one of the preceding strategies and using the relevant
    API endpoints.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's create the controllers and action methods that will talk to `EcommerceService`
    and load the relevant views.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the controller and actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have already seen that routing takes care of mapping the request URI to an
    action method in a controller, so let's further understand how the action methods
    then load the respective views. As you will have noticed, all the views in the
    ASP.NET Core MVC project are part of the `Views` folder, and when the action method
    execution is completed, it simply looks for `Views/<ControllerName>/<Action>.cshtml`.
  prefs: []
  type: TYPE_NORMAL
- en: For example, an action method mapping to the `Products/Index` route will load
    the `Views/Products/Index.cshtml` view. This is handled by calling the `Microsoft.AspNetCore.Mvc.Controller.View`
    method at the end of every action method.
  prefs: []
  type: TYPE_NORMAL
- en: 'There are additional overloads and helper methods that can override this behavior
    and route to a different view as needed. Before we talk about these helper methods,
    just like the Web API, each action method in the MVC controller can also return
    `IActionResult`, which means we can make use of helper methods to redirect to
    a view. In ASP.NET Core MVC, every controller is inherited by a base class, `Microsoft.AspNetCore.Mvc.Controller`,
    which comes with a few helper methods, and loading a view via an action method
    is handled by the following helper methods in the `Microsoft.AspNetCore.Mvc.Controller`
    class:'
  prefs: []
  type: TYPE_NORMAL
- en: '`View`: This method has multiple overloads and primarily loads the view from
    the folder under `Views` based on the controller name. For example, calling this
    method in `ProductsController` can load any `.cshtml` file from the `Views/Products`
    folder. Additionally, it can take the name of the view, which can be loaded if
    required, and supports passing an object that can be retrieved in views by strongly
    typing the view.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`RedirectToAction`: Although the `View` method handles most scenarios, there
    would be scenarios where we need to call another action method within the same
    controller or another controller, which is where `RedirectToAction` helps. This
    method comes with various overloads and allows us to specify the name of the action
    method, controller method, and object that the action method can receive as route
    values.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In short, to load the views and pass data from controllers, we will be passing
    respective models to the `View` method and, as required, we will use `RedirectToAction`
    whenever there is a need to call another action method.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, the question is how to handle data retrieval (`GET` calls) versus data
    submission (`POST` calls), and in ASP.NET Core MVC, all the action methods support
    annotating with HTTP verbs using the `HttpGet` and `HttpPost` attributes. The
    following are a few rules that can be used to annotate methods:'
  prefs: []
  type: TYPE_NORMAL
- en: If we want to retrieve data, then the action method is annotated using `HttpGet`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If we want to submit data to an action method, it should be annotated using
    `HttpPost` with the relevant object as the input parameter to that action method.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Typically, methods that need to send data from a controller to a view should
    be annotated with `[HttpGet]`, and methods that need to receive data from a view
    for further submission to the database should be annotated using `[HttpPost]`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, let's move on to adding the required controllers and implementing them.
    When we add `Packt.Ecommerce.Web`, it creates a `Controllers` folder with `HomeController`
    created by default, which we need to delete. Then we need to add the three controllers
    by right-clicking on the `Controllers` folder, then selecting `ProductsController`,
    `CartController`, and `OrdersController`.
  prefs: []
  type: TYPE_NORMAL
- en: 'All these controllers will have the following two common properties, one for
    logging and one for calling methods of `EcommerceService`. They are further initialized
    using constructor injection as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE105]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE106]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s now discuss what is defined in each of these controllers:'
  prefs: []
  type: TYPE_NORMAL
- en: '`ProductsController`: This controller will contain the `public async Task<IActionResult>
    Index(string searchString, string category)` action method to load the default
    view for listing all the products, which further supports filtering. There will
    be another method, `public async Task<IActionResult> Details(string productId,
    string productName)`, that takes the ID and name of the product and loads the
    details of the specified product. As both these methods are used for retrieving,
    they will be annotated using `[HttpGet]`. Additionally, this controller will have
    the `Error` method, as discussed earlier. Since it can receive an error code as
    an input parameter from the `UseStatusCodePagesWithReExecute` middleware, we will
    have simple logic to load the views accordingly:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE107]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`CartController`: This controller contains the `public async Task<IActionResult>
    Index(ProductListViewModel product)` action method to add a product to the cart,
    where we will create an order with the order status set to `''Cart''`, as this
    needs to receive data and further pass it to the API, which will be annotated
    with `[HttpPost]`. For simplicity, this is left anonymous but can be restricted
    for the logged-in users. Once the order is created, this method will make use
    of the `RedirectToAction` helper method and redirects to the `public async Task<IActionResult>
    Index(string orderId)` action method within this controller, which further loads
    the cart with all the products and the checkout form. This method can also be
    used to directly navigate to the shopping cart.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`OrdersController`: This is the last controller in the flow, which contains
    the `public async Task<IActionResult> Create(OrderDetailsViewModel order)` action
    method to submit the order after filling in the payment details. This method updates
    the status of the order to `Submitted`, then creates an invoice for the order,
    and finally, redirects to another action method, `public async Task<IActionResult>
    Index(string invoiceId)`, which loads the final invoice of the order and completes
    the transaction.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following diagram represents the flow between various methods across controllers
    to complete the shopping workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.6 – Flow between controller action methods'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.6_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.6 – Flow between controller action methods
  prefs: []
  type: TYPE_NORMAL
- en: With this knowledge, let's design the views in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a UI using ASP.NET Core MVC
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Up until now, we have defined a service to communicate with backend APIs and
    further defined controllers that will pass the data to views using models. Now,
    let's build various views that will render the data and present it to users.
  prefs: []
  type: TYPE_NORMAL
- en: 'To begin with, let''s see the various components that are involved in rendering
    the views:'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Views` folder: All views are part of this folder, with each controller-specific
    view segregated by a subfolder, and finally, each action method is represented
    by a `.cshtml` file.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To add a view, we can right-click on the action method and click **Add View**,
    which will automatically create a folder (if it isn't already present) with the
    name of the controller and add the view. Additionally, while doing this, we can
    specify the model that the view would be bound to.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Layout` page: This is a common requirement in a web application where
    we have a common section across the application, such as a header with a menu
    or left navigation. To have a modular structure for our pages and to avoid any
    repetition, ASP.Net Core MVC comes with a layout page that is typically named
    `_Layout.cshtml` and is part of the `Views/Shared` folder. This page can be used
    as a parent page for all the views in our MVC project. A typical layout page looks
    like the one shown in the following code:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE108]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Here, you can see that it allows us to define the skeleton layout of the application,
    and then finally, there is a Razor method called `@RenderBody()`, which actually
    loads the child view. To specify a layout page in any view, we can use the following
    syntax, which adds `_Layout.cshtml` as a parent page to the view:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE109]'
  prefs: []
  type: TYPE_PRE
- en: 'However, there is no need to repeat this code in all the views, and that''s
    where `_ViewStart.cshtml` comes in handy. Let''s see how it helps in reusing some
    of the code across views:'
  prefs: []
  type: TYPE_NORMAL
- en: '`_ViewStart.cshtml`: This is a generic view that is located directly under
    the `Views` folder and is used by the Razor engine to execute any code that needs
    to be executed before the code in the view. So, typically, this is used to define
    the layout page and so, the preceding code can be added to this file so that it
    gets applied across the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`_ViewImports.cshtml`: This is another page that can be used to import any
    common directives or namespaces across the application. Just like `_ViewStart`,
    this is also located directly under the root folder; however, both `_ViewStart`
    and `_ViewImport` can be in one (or more than one) folder and they are executed
    hierarchically starting from the one in the root views folder to the lower-level
    one in any subfolders. To enable client-side telemetry using Application Insights,
    we inject `JavaScriptSnippet` as shown in the following code. We learned about
    injecting dependent services into views in [*Chapter 5*](B18507_05_Epub.xhtml#_idTextAnchor445),
    *Dependency Injection in .NET 6*. In the following code, `JavaScriptSnippet` is
    injected into the view:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE110]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: '`wwwroot`: This is the root folder of the application, and all the static resources,
    such as JavaScript, CSS, and any image files, are placed here. This can further
    hold any HTML plugins that we want to use in our application. As we have already
    configured the `UseStaticFiles` middleware in our application, content from the
    folder can be directly served without any processing. The default template of
    ASP.NET Core MVC comes with a segregation of folders based on their type; for
    example, all JavaScript files are placed inside a `js` folder, CSS files are placed
    in a `css` folder, and so on. We will stick to that folder structure for our application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The process of automatically generating views by right-clicking on the action
    method and using built-in templates is known as **scaffolding** and can be used
    if are you new to the Razor syntax. However, creating a view using scaffolding
    or manually placing it inside the respective folder and strongly typing it results
    in the same behavior.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: Setting up AdminLTE, the layout page, and views
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: An important thing for getting the same look and feel across an application
    is to choose the right styling framework. Doing that not only gives a consistent
    layout but also simplifies the responsive design, which helps in rendering the
    pages correctly in various resolutions. The ASP.NET Core MVC project template
    that we are using for `Packt.Ecommerce.Web` comes out of the box with Bootstrap
    as its styling framework. We will further extend this to a theme known as `AdminLTE`,
    which comes with some interesting layouts and dashboards that can be plugged into
    our presentation layer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s perform the following steps to integrate `AdminLTE` into our application:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Download the most recent version of `AdminLTE` from here: [https://github.com/ColorlibHQ/AdminLTE/releases](https://github.com/ColorlibHQ/AdminLTE/releases).'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Extract the ZIP file downloaded in the previous step and navigate to `AdminLTE-3.0.5\dist\css`.
    Copy `adminlte.min.css` and paste it inside the `wwwroot/css` folder of `Packt.Ecommerce.Web`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `AdminLTE-3.0.5\dist\js`. Copy `adminlte.min.js` and paste it inside
    the `wwwroot/js` folder of `Packt.Ecommerce.Web`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Navigate to `AdminLTE-3.0.5\dist\img`. Copy the required images and paste them
    inside the `wwwroot/img` folder of `Packt.Ecommerce.Web`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Copy the `AdminLTE-3.0.5\plugins` folder and paste it inside the `wwwroot` folder
    of `Packt.Ecommerce.Web`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: More information about `AdminLTE` can be found at [https://adminlte.io/docs/2.4/installation](https://adminlte.io/docs/2.4/installation).
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, navigate to the `Views/_Layout.cshtml` page and remove all the existing
    code and replace it with the code from `Packt.Ecommerce.Web\Views\Shared\_Layout.cshtml`.
    On a high level, the layout is divided into the following:'
  prefs: []
  type: TYPE_NORMAL
- en: A header with navigation to the home page on the left side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A search box in the header and a dropdown with search categories in the center
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The shopping cart in the header on the right side
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A breadcrumb trail to display the navigation
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A section to render the child view using `@RenderBody()`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'A couple of other key things that are needed to complete the integration of
    the `AdminLTE` template are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: 'Add the following styles defined in the `<head>` tag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE111]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following JavaScript files just before the end of the `<body>` tag:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[PRE112]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'With this, we have the `AdminLTE` theme integrated into our application. To
    render the JavaScript required to enable the client telemetry using Application
    Insights, add the following code inside the `head` tag of `_Layout.cshtml`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE113]'
  prefs: []
  type: TYPE_PRE
- en: The previous code injects the JavaScript required to send telemetry data from
    views along with the instrumentation key. Unlike the server side or the client
    side, the instrumentation key is exposed. Anyone can see the instrumentation key
    from the browser developer tools. But, this is how client-side telemetry is set
    up. At this point, the risk of this is that unwanted data can be pushed by a malicious
    user or attacker as the instrumentation key has write-only access. If you wish
    to make the client-side telemetry more secure, you can expose a secure REST API
    from your service and log the telemetry events from there. You will learn more
    about Application Insights features in [*Chapter 14*](B18507_14_Epub.xhtml#_idTextAnchor1674),
    *Health and Diagnostics*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, the application layout is ready. Let's now move on to defining various
    views in the application.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Products/Index view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This view will be used to list all the products available on our e-commerce
    application and is strongly typed with the `IEnumerable<Packt.Ecommerce.DTO.Models.ProductListViewModel>`
    model. It uses the `Index` action method of `ProductsController` to retrieve data.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this view, we will use a simple Razor `@foreach (var item in Model)` loop
    and for each product, we will display an image of the product, its name, and its
    price. A sample of this view looks as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.7 – Products view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.7_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.7 – Products view
  prefs: []
  type: TYPE_NORMAL
- en: Here, you can see that there is a search bar and a category dropdown coming
    from the layout page. Clicking on the product image will navigate to the `Products/Details`
    view. To support this navigation, we will make use of `AnchorTagHelper` and pass
    the product ID and name to the `Details` action method of `ProductsController`
    to further load the details of the product in the `Products/Details` view.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Products/Details view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'This view will load the details of the product based on the product ID and
    the name passed from the `Products/Index` view. We will be using a sample page
    from `AdminLTE` as shown here: [https://adminlte.io/themes/dev/AdminLTE/pages/examples/e_commerce.html](https://adminlte.io/themes/dev/AdminLTE/pages/examples/e_commerce.html).'
  prefs: []
  type: TYPE_NORMAL
- en: 'This page will be strongly typed with `Packt.Ecommerce.DTO.Models.ProductDetailsViewModel`
    and will display all the details of the product. A sample of this page is shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.8 – Product details view'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.8_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.8 – Product details view
  prefs: []
  type: TYPE_NORMAL
- en: As you can see, there is an `'Cart'`, this will call the `Index` action method
    of `CartController` to create the cart.
  prefs: []
  type: TYPE_NORMAL
- en: 'To pass data back to the action method, we will take the help of `FormTagHelper`,
    which allows us to wrap the page in an HTML form and specify the action and controller
    that the page can be submitted to using the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE114]'
  prefs: []
  type: TYPE_PRE
- en: With this code, once the `Submit` type, the page gets submitted to the `Index`
    action method of `CartController` to further save it to the database. However,
    we still need to pass the product details back to the `Index` action method and,
    for that, we will take the help of `InputTagHelper` and create hidden fields for
    all the values that need to be passed back to the action method.
  prefs: []
  type: TYPE_NORMAL
- en: 'The most important thing here is that the name of the hidden variable should
    match the name of the property in the model, so we will be adding the following
    code inside the form to pass the product values back to the controller:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE115]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE116]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE117]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE118]'
  prefs: []
  type: TYPE_PRE
- en: ASP.NET Core MVC's model binding system reads these values and creates the product
    object needed for the `Index` method of `CartController`, which further calls
    the backend system to create the order.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Cart/Index view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: This view will load the cart details and will have a checkout form to fill in
    all the details and complete the order. Here, we can navigate back to the home
    page to add more products or complete the order.
  prefs: []
  type: TYPE_NORMAL
- en: This view is strongly typed with `Packt.Ecommerce.DTO.Models.OrderDetailsViewModel`
    and loads data using the `Index` action method of `OrdersController`. Here, we
    are using the Bootstrap checkout form example from [https://getbootstrap.com/docs/4.5/examples/checkout/](https://getbootstrap.com/docs/4.5/examples/checkout/).
  prefs: []
  type: TYPE_NORMAL
- en: 'This form makes use of model validations and HTML attributes to perform validation
    on the required fields, and we are taking the help of ASP.NET Core MVC tag helpers
    and a few HTML helpers to render the form. A sample property with model validations
    would be as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE119]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE120]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE121]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE122]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE123]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE124]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE125]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE126]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE127]'
  prefs: []
  type: TYPE_PRE
- en: This model is used in [https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/data/Packt.Ecommerce.DTO.Models/OrderDetailsViewModel.cs](https://github.com/PacktPublishing/Enterprise-Application-Development-with-C-10-and-.NET-6-Second-Edition/blob/main/Enterprise%20Application/src/platform-apis/data/Packt.Ecommerce.DTO.Models/OrderDetailsViewModel.cs)
    and triggers necessary validations while placing an order.
  prefs: []
  type: TYPE_NORMAL
- en: 'As this form also needs to be submitted, the entire form is wrapped in `FormTagHelper`,
    as shown in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE128]'
  prefs: []
  type: TYPE_PRE
- en: 'To show these validations on the UI, add the following scripts to `_layout.cshtml`
    just after all the other scripts we added earlier:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE129]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE130]'
  prefs: []
  type: TYPE_PRE
- en: 'To display an error message, we can make use of a validation message tag helper,
    as shown in the following code snippet. On the server side, this can be further
    evaluated using `ModelState.IsValid`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE131]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE132]'
  prefs: []
  type: TYPE_PRE
- en: 'A sample of this page would be as shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.9 – Cart and checkout page'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.9_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.9 – Cart and checkout page
  prefs: []
  type: TYPE_NORMAL
- en: We will use `InputTagHelper` as hidden fields and textboxes to pass any additional
    information back to the action method. The good thing about textboxes is if the
    `id` attribute of the textbox matches the property name, that data is automatically
    passed back to the action method and ASP.NET Core MVC's model binding system will
    take care of mapping it to the required object, which, in this case, is of the
    `Packt.Ecommerce.DTO.Models.OrderDetailsViewModel` type, which finally submits
    the order, generates invoices, and redirects to the `Orders/Index` action method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In the preceding screenshot, although we have a checkout form that includes
    payment information in production applications, we would be integrating with a
    third-party payment gateway and, usually, this entire form sits on t[he payment
    gateway side of the application for various security reas](https://razorpay.com/docs/payment-gateway/server-integration/dot-net/)ons.
    [https://stripe.com/docs/api](https://stripe.com/docs/api) and [https://razorpay.com/docs/payment-gateway/server-integration/dot-net/](https://razorpay.com/docs/payment-gateway/server-integration/dot-net/)
    are a couple of such third-party providers that help in payment gateway integration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating the Orders/Index view
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Finally, we will have the view to see the invoice of the order, which is a
    simple read-only view that displays invoice information sent from the `Index`
    action method of `OrdersController`. A sample of this page is shown in the following
    screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.10 – Final invoice'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.10_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.10 – Final invoice
  prefs: []
  type: TYPE_NORMAL
- en: This completes the integration of various views and, as you have seen, we have
    limited the views to the most important flow in the e-commerce application. However,
    you can further add more features using the same principles.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding Blazor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Blazor is a new framework available from .NET Core 3.1 onward to develop the
    frontend layer of the application. It's one of the alternatives to MVC and Razor
    Pages and the application model is very much close to SPA; however, instead of
    JavaScript, we can write the logic in C# and Razor syntax.
  prefs: []
  type: TYPE_NORMAL
- en: 'All the code that is written in Blazor is placed in something called a `.Razor`
    and is used to represent the application; be it the entire web page or a small
    dialog popup, everything is created as a component in Blazor applications. A typical
    Razor component looks like the one in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE133]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE134]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE135]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE136]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE137]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE138]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE139]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE140]'
  prefs: []
  type: TYPE_PRE
- en: '[PRE141]'
  prefs: []
  type: TYPE_PRE
- en: In this code, we are creating a page that increments a counter on the click
    of a button, and the logic for the click event is handled in the C# code, which
    updates the value in HTML. This page can be accessed using the `/counter` relative
    URL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The major difference between Blazor and other MVC/Razor Pages is that unlike
    the request-response model, where every request is sent to the server and HTML
    is sent back to the browser, Blazor packages all the components (just like SPA)
    and loads them on the client-side. When the application is requested for the first
    time, any subsequent calls to the server are to retrieve/submit any API data or
    to update the DOM. Blazor supports the following two hosting models:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Blazor WebAssembly** (**WASM**): WASM is low-level instructions that can
    be run on modern browsers, which further helps to run code written in high-level
    languages such as C# on a browser without any additional plugins. The Blazor WASM
    hosting model makes use of the open web standards given by WASM and runs the C#
    code of any Blazor WASM application in a sandbox environment on a browser. At
    a high level, all the Blazor components are compiled into .NET assemblies and
    are downloaded to the browser, and WASM loads the .NET Core runtime and loads
    all the assemblies. It further uses JavaScript interop to refresh the DOM; the
    only calls to the server would be any backend APIs. The architecture is shown
    in the following figure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.11 – Blazor WASM hosting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.11_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.11 – Blazor WASM hosting
  prefs: []
  type: TYPE_NORMAL
- en: '`blazor.server.js` and uses SignalR to receive all the DOM updates, and this
    further means that every user interaction will have a server call (although very
    light). The architecture is shown in the following figure:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '![Figure 11.12 – Blazor Server hosting'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.12_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.12 – Blazor Server hosting
  prefs: []
  type: TYPE_NORMAL
- en: '.NET 6 comes with full tooling support for both hosting models, with their
    own project templates, and has its pros and cons, which are further explained
    here: [https://docs.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/blazor/hosting-models?view=aspnetcore-6.0).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s now create a frontend application as per the following steps using a
    Blazor Server application, which allows us to add/modify product details for our
    e-commerce application:'
  prefs: []
  type: TYPE_NORMAL
- en: Add a new Blazor Server application called `Packt.Ecommerce.Blazorweb` to the
    enterprise solution and add the `Products.razor`, `AddProduct.Razor`, and `EditProduct.razor`
    Razor components to the `Pages` folder.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This project contains the `Program` class, which is exactly like any other ASP.NET
    Core application with a few additional Blazor services. `_Host.cshtml` is the
    root of the application and an initial call to the application is received by
    this page and is responded to with HTML. This page further references the `blazor.server.js`
    script file for the SignalR connection. Another important component is the `App.Razor`
    component, which takes care of routing based on the URL. In Blazor, any component
    that needs to be mapped to a specific URL will have the `@page` directive at the
    beginning of the component, which specifies the relative URL of the application.
    `App.Razor` intercepts the URLs and routes them to the specified component. All
    Razor components are part of a `Pages` folder, and the `Data` folder comes with
    a sample model and a service that is used in the `FetchData.razor` component.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Let''s add the following code to `NavMenu.razor` to add the `Products` navigation
    to the left menu. At this stage, if you run the application, you should be able
    to see the left menu with the `Products` navigation; however, it will not navigate
    to any page:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE142]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'As we are going to retrieve data from the API, we need to inject `HTTPClient`
    into our `Program` class, just as how it''s done in ASP.NET Core applications.
    So, add the following code to the `Program` class:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE143]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Add the following setting of `ApplicationSettings:ProductsApiEndpoint` to `appsettings.json`:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE144]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Since we are going to bind the `products` data, let''s add `Packt.Ecommerce.DTO.Models`
    as a project reference to `Packt.Ecommerce.Blazorweb`. In the `Pages` folder,
    add the following code to the `Products.razor` page inside the `@code` block in
    which we are creating a `HttpClient` object using `IHttpClientFactory`, which
    will be injected in the next step, and retrieving the `products` data in the `OnInitializedAsync`
    method:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE145]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'Next, add the following code at the beginning of the `Products.Razor` page
    (outside the `@code` block). Here, we set the relative route for this component
    via the `@page` directive to `/products`. Next, we inject `IHttpClientFactory`
    and the other required namespaces, then add the HTML part that renders the list
    of products. As you can see, it''s a mixture of HTML and Razor syntax:'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE146]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: 'At this point, if you run the application, you should see the output shown
    in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.13 – Product list Blazor UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.13_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.13 – Product list Blazor UI
  prefs: []
  type: TYPE_NORMAL
- en: Next, let's create the `Add/Edit` pages in which we will make use of Blazor
    forms. Some of the important tooling/components that are available for forms are
    the following.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A Blazor form is created using an out-of-the-box template in Blazor known as
    `EditForm`, and it can be bound directly to any C# object using a model property.
    A typical `EditForm` looks as in the following code snippet. Here, we are defining
    to call the `OnSubmit` method when the form is submitted. Let''s add this to `AddProduct.razor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE147]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, `product` is the object of the model that we want to use, which in our
    case is `Packt.Ecommerce.DTO.Models.ProductDetailsViewModel`. To bind data to
    any control, we can use a mix of HTML and Razor syntax, as shown in the following
    code. Here, we are binding the `Name` property of the product object to a textbox
    and, similarly, the `Category` property to the dropdown. Once you enter any value
    in the textbox or select a value in the dropdown, it is automatically available
    in these properties to pass it back to any backend API or database. Let''s add
    all the required properties to the HTML element in a similar manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE148]'
  prefs: []
  type: TYPE_PRE
- en: 'Blazor forms support data validation using data annotations, so any model that
    we want to bind to the UI can have data annotations, and Blazor applies those
    validations out of the box to the controls that the property is bound to. To apply
    validations, we add the `DataAnnotationsValidator` component and can use the `ValidationSummary`
    component to show a summary of all the validation failures. You can find more
    details at [https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/blazor/forms-validation?view=aspnetcore-6.0).
    We can further use the `ValidationMessage` component at the control level, as
    shown in the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE149]'
  prefs: []
  type: TYPE_PRE
- en: In the `code` component, add an object of `ProductDetailsViewModel` and name
    it as the product, that is, as defined in the `Model` attribute of `EditForm`,
    and further implement the `OnSubmit` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The entire code for `AddProduct.Razor` and `EditProduct.Razor` can be found
    in the GitHub repository, and once we run the application, we can see the following
    page:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 11.14 – The Add Product Blazor UI'
  prefs: []
  type: TYPE_NORMAL
- en: '](img/Figure_11.14_B18507.jpg)'
  prefs: []
  type: TYPE_NORMAL
- en: Figure 11.14 – The Add Product Blazor UI
  prefs: []
  type: TYPE_NORMAL
- en: This is a basic sample for building the frontend using Blazor that performs
    list, create, and update operations. However, there are many concepts in Blazor
    that can be further explored at [https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/blazor/?view=aspnetcore-6.0).
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we understood various aspects of the presentation layer and
    UI design. Along with this, we also learned various skills in developing the presentation
    layer using ASP.NET Core MVC and Razor Pages, and then, finally, we implemented
    the presentation layer for our enterprise application using ASP.NET Core MVC and
    Blazor.
  prefs: []
  type: TYPE_NORMAL
- en: With these skills, you should be able to build the presentation layer using
    ASP.NET Core MVC, Razor Pages, and Blazor, and integrate it with the backend API.
  prefs: []
  type: TYPE_NORMAL
- en: In the next chapter, we will see how to integrate authentication in our system
    across various layers of the application.
  prefs: []
  type: TYPE_NORMAL
- en: Questions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Which one of the following is a recommended page to define the left-side navigation
    that needs to appear throughout the web application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `_ViewStart.cshtml`
  prefs: []
  type: TYPE_NORMAL
- en: b. `_ViewImports.cshtml`
  prefs: []
  type: TYPE_NORMAL
- en: c. `_Layout.cshtml`
  prefs: []
  type: TYPE_NORMAL
- en: d. `Error.cshtml`
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: c**'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following pages can be used to configure the `Layout` page for
    the entire application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `_ViewStart.cshtml`
  prefs: []
  type: TYPE_NORMAL
- en: b. `_ViewImports.cshtml`
  prefs: []
  type: TYPE_NORMAL
- en: c. `_Layout.cshtml`
  prefs: []
  type: TYPE_NORMAL
- en: d. `Error.cshtml`
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: a**'
  prefs: []
  type: TYPE_NORMAL
- en: Which of the following special characters is used to write Razor syntax in a
    `.cshtml` page?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: a. `@`
  prefs: []
  type: TYPE_NORMAL
- en: b. `#`
  prefs: []
  type: TYPE_NORMAL
- en: c. `<% %>`
  prefs: []
  type: TYPE_NORMAL
- en: d. None of the above
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: a**'
  prefs: []
  type: TYPE_NORMAL
- en: Which method will be called on a button click in the following tag helper code
    in a Razor page application?
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE150]'
  prefs:
  - PREF_IND
  type: TYPE_PRE
- en: a. `OnGet()`
  prefs: []
  type: TYPE_NORMAL
- en: b. `onDelete()`
  prefs: []
  type: TYPE_NORMAL
- en: c. `OnPostDelete()`
  prefs: []
  type: TYPE_NORMAL
- en: d. `OnDeleteAsync()`
  prefs: []
  type: TYPE_NORMAL
- en: '**Answer: c**'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/web-development/html5-and-css3-building-responsive-websites](https://www.packtpub.com/web-development/html5-and-css3-building-responsive-websites)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://www.packtpub.com/product/bootstrap-for-asp-net-mvc-second-edition/9781785889479](https://www.packtpub.com/product/bootstrap-for-asp-net-mvc-second-edition/9781785889479)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/WebAssembly](https://developer.mozilla.org/en-US/docs/WebAssembly)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/razor-pages/?view=aspnetcore-6.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-6.0](https://docs.microsoft.com/en-us/aspnet/core/mvc/views/partial?view=aspnetcore-6.0)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '[https://developer.mozilla.org/en-US/docs/Learn/Accessibility](https://developer.mozilla.org/en-US/docs/Learn/Accessibility)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
