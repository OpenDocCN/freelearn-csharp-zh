<html><head></head><body>
<div id="_idContainer027">
<h1 class="chapter-number" id="_idParaDest-88"><a id="_idTextAnchor087"/><span class="koboSpan" id="kobo.1.1">6</span></h1>
<h1 id="_idParaDest-89"><a id="_idTextAnchor088"/><span class="koboSpan" id="kobo.2.1">Applying Event Sourcing Patterns</span></h1>
<p><span class="koboSpan" id="kobo.3.1">In the previous chapter, we explored a prolific pattern in CQRS. </span><span class="koboSpan" id="kobo.3.2">This pattern encourages us to create a clear separation between code and data sources that govern read and write operations. </span><span class="koboSpan" id="kobo.3.3">With this kind of separation, we risk having our data out of sync in between operations, which introduces the need for additional techniques to ensure data consistency.</span></p>
<p><span class="koboSpan" id="kobo.4.1">Even without CQRS, we must contend with the typical microservices pattern where each service is expected to have its own data store. </span><span class="koboSpan" id="kobo.4.2">Recall that there will be situations where data needs to be shared between services. </span><span class="koboSpan" id="kobo.4.3">There needs to be some mechanism that will adequately transport data between services so that they will remain in sync.</span></p>
<p><strong class="bold"><span class="koboSpan" id="kobo.5.1">Event sourcing</span></strong><span class="koboSpan" id="kobo.6.1"> is touted as a solution to this issue, where a new data store is introduced that keeps track of all the command operations as they happen. </span><span class="koboSpan" id="kobo.6.2">The records in this data store are considered events and contain enough information for the system to track what happens with each command operation. </span><span class="koboSpan" id="kobo.6.3">These records are called events and they act as an intermediary store for event-driven or asynchronous services architecture. </span><span class="koboSpan" id="kobo.6.4">They can also act as an audit log as they will store all the necessary details for replaying changes being made against the domain.</span></p>
<p><span class="koboSpan" id="kobo.7.1">In this chapter, we will explore the event sourcing pattern and justify its use as a solution to our potentially out-of-sync databases.</span></p>
<p><span class="koboSpan" id="kobo.8.1">After reading this chapter, you will be able to do the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.9.1">Understand what events are and what event sourcing can do for you</span></li>
<li><span class="koboSpan" id="kobo.10.1">Apply event sourcing patterns in your application code</span></li>
<li><span class="koboSpan" id="kobo.11.1">Use the CQRS pattern to create events and read states in between events</span></li>
<li><span class="koboSpan" id="kobo.12.1">Create an event store using a relational or non-relational database</span></li>
</ul>
<h1 id="_idParaDest-90"><a id="_idTextAnchor089"/><span class="koboSpan" id="kobo.13.1">Technical requirements</span></h1>
<p><span class="koboSpan" id="kobo.14.1">Code references used in this chapter can be found in the project repository, which is hosted on GitHub at </span><a href="https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch06"><span class="koboSpan" id="kobo.15.1">https://github.com/PacktPublishing/Microservices-Design-Patterns-in-.NET/tree/master/Ch06</span></a><span class="koboSpan" id="kobo.16.1">.</span></p>
<h1 id="_idParaDest-91"><a id="_idTextAnchor090"/><span class="koboSpan" id="kobo.17.1">What are events?</span></h1>
<p><span class="koboSpan" id="kobo.18.1">An event, within the</span><a id="_idIndexMarker240"/><span class="koboSpan" id="kobo.19.1"> context of software development, refers to something that happens because of an action being completed. </span><span class="koboSpan" id="kobo.19.2">Events are then used to carry out actions in the background, such as the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.20.1">Storing data for analytics purposes</span></li>
<li><span class="koboSpan" id="kobo.21.1">Notification of completed actions</span></li>
<li><span class="koboSpan" id="kobo.22.1">Database auditing</span></li>
</ul>
<h2 id="_idParaDest-92"><a id="_idTextAnchor091"/><span class="koboSpan" id="kobo.23.1">Key attributes of events</span></h2>
<p><span class="koboSpan" id="kobo.24.1">Events can be used to build the</span><a id="_idIndexMarker241"/><span class="koboSpan" id="kobo.25.1"> foundation of any applicationâ€™s core functionality. </span><span class="koboSpan" id="kobo.25.2">While the concept can be suitable for many situations, it is important for us to understand some key attributes of events and properly scope the need for their introduction, as well as uphold certain standards in our implementations:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.26.1">Immutability</span></strong><span class="koboSpan" id="kobo.27.1">: This word refers to the unchangeable nature of an object. </span><span class="koboSpan" id="kobo.27.2">Within the context of an event, once </span><a id="_idIndexMarker242"/><span class="koboSpan" id="kobo.28.1">something has happened, it becomes a fact. </span><span class="koboSpan" id="kobo.28.2">That means we cannot change it or the outcome in the real world. </span><span class="koboSpan" id="kobo.28.3">We extend this same feature to our events and ensure that they cannot be changed after they are generated.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.29.1">Single occurrence</span></strong><span class="koboSpan" id="kobo.30.1">: Each event</span><a id="_idIndexMarker243"/><span class="koboSpan" id="kobo.31.1"> is unique. </span><span class="koboSpan" id="kobo.31.2">Once it has been generated, it cannot be repeated. </span><span class="koboSpan" id="kobo.31.3">Even if the same thing happens later, it should be recognized as a new event.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.32.1">Historical</span></strong><span class="koboSpan" id="kobo.33.1">: An event </span><a id="_idIndexMarker244"/><span class="koboSpan" id="kobo.34.1">should always represent a point in time. </span><span class="koboSpan" id="kobo.34.2">This way, we can trace what happened and when in the past. </span><span class="koboSpan" id="kobo.34.3">This discipline is also displayed in the way that we name our events, where we use the past tense to describe the event.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.35.1">Events at their best do </span><a id="_idIndexMarker245"/><span class="koboSpan" id="kobo.36.1">not contain any behavior or business logic. </span><span class="koboSpan" id="kobo.36.2">They generally only serve as a point-in-time data collection unit and help us to track what is happening at different points in our application.</span></p>
<p><span class="koboSpan" id="kobo.37.1">Now that we have a good idea of what events are and why they are used at a high level, let us focus on more practical uses of events and event sourcing patterns.</span></p>
<h1 id="_idParaDest-93"><a id="_idTextAnchor092"/><span class="koboSpan" id="kobo.38.1">What can event sourcing patterns do for me?</span></h1>
<p><span class="koboSpan" id="kobo.39.1">Applications built with </span><a id="_idIndexMarker246"/><span class="koboSpan" id="kobo.40.1">microservices architecture are structured to have a set of loosely coupled and independent services. </span><span class="koboSpan" id="kobo.40.2">Using the </span><strong class="bold"><span class="koboSpan" id="kobo.41.1">database-per-service pattern</span></strong><span class="koboSpan" id="kobo.42.1">, we further </span><a id="_idIndexMarker247"/><span class="koboSpan" id="kobo.43.1">segregate each service by giving it an individual data store. </span><span class="koboSpan" id="kobo.43.2">This now presents a unique challenge to keep the data in sync between services. </span><span class="koboSpan" id="kobo.43.3">It becomes more difficult given that we need to compromise on our ACID principles. </span><span class="koboSpan" id="kobo.43.4">We can recall that the acronym </span><strong class="bold"><span class="koboSpan" id="kobo.44.1">ACID</span></strong><span class="koboSpan" id="kobo.45.1"> stands for </span><strong class="bold"><span class="koboSpan" id="kobo.46.1">atomicity, consistency, isolation, and durability</span></strong><span class="koboSpan" id="kobo.47.1">. </span><span class="koboSpan" id="kobo.47.2">We are most concerned about the </span><a id="_idIndexMarker248"/><span class="koboSpan" id="kobo.48.1">principle of atomicity in this context. </span><span class="koboSpan" id="kobo.48.2">We cannot guarantee that all our write operations will be completed as a unit. </span><span class="koboSpan" id="kobo.48.3">The atomic principle dictates that all data operations should complete or fail as a unit. </span><span class="koboSpan" id="kobo.48.4">Given the allowance for different technologies to be used for the data stores, we cannot absolutely guarantee that.</span></p>
<p><span class="koboSpan" id="kobo.49.1">Considering all these factors, we</span><a id="_idIndexMarker249"/><span class="koboSpan" id="kobo.50.1"> turn to a new pattern called event sourcing, which allows us to persist messages that keep track of all the activities occurring against data in each service. </span><span class="koboSpan" id="kobo.50.2">This pattern is especially useful for asynchronous communication between services where we can keep track of all changes in the form of </span><strong class="bold"><span class="koboSpan" id="kobo.51.1">events</span></strong><span class="koboSpan" id="kobo.52.1">. </span><span class="koboSpan" id="kobo.52.2">These events can act as the following:</span></p>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.53.1">Persistent events</span></strong><span class="koboSpan" id="kobo.54.1">: Events contain</span><a id="_idIndexMarker250"/><span class="koboSpan" id="kobo.55.1"> enough detail to inform and recreate domain objects</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.56.1">Audit log</span></strong><span class="koboSpan" id="kobo.57.1">: Events are </span><a id="_idIndexMarker251"/><span class="koboSpan" id="kobo.58.1">generated with each change, so they can double as audits</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.59.1">Entity state identification</span></strong><span class="koboSpan" id="kobo.60.1">: We can </span><a id="_idIndexMarker252"/><span class="koboSpan" id="kobo.61.1">use events to view the point-in-time state of an entity on demand</span></li>
</ul>
<p><span class="koboSpan" id="kobo.62.1">The idea of tracking changes </span><a id="_idIndexMarker253"/><span class="koboSpan" id="kobo.63.1">against entities is called </span><strong class="bold"><span class="koboSpan" id="kobo.64.1">replaying</span></strong><span class="koboSpan" id="kobo.65.1">. </span><span class="koboSpan" id="kobo.65.2">We can replay events in two steps:</span></p>
<ol>
<li><span class="koboSpan" id="kobo.66.1">Grab all or partial events stored for a given aggregate.</span></li>
<li><span class="koboSpan" id="kobo.67.1">Iterate through all events and extract the relevant information to freshen up the instance of the aggregate.</span></li>
</ol>
<p><span class="koboSpan" id="kobo.68.1">Event sourcing is essentially all about querying records in some way using an </span><strong class="bold"><span class="koboSpan" id="kobo.69.1">aggregate ID</span></strong><span class="koboSpan" id="kobo.70.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.71.1">timestamp</span></strong><span class="koboSpan" id="kobo.72.1">. </span><span class="koboSpan" id="kobo.72.2">The aggregate ID</span><a id="_idIndexMarker254"/><span class="koboSpan" id="kobo.73.1"> represents the unique identifier column, or primary </span><a id="_idIndexMarker255"/><span class="koboSpan" id="kobo.74.1">key value, for the original record for which the event was raised. </span><span class="koboSpan" id="kobo.74.2">The timestamp represents the </span><a id="_idIndexMarker256"/><span class="koboSpan" id="kobo.75.1">point in time that the event was raised. </span><span class="koboSpan" id="kobo.75.2">The queries required for this look similar for relational and non-relational event stores. </span><span class="koboSpan" id="kobo.75.3">The event replay operation requires that we iterate through all the events, grab information, and then change the state of the target aggregate. </span><span class="koboSpan" id="kobo.75.4">In addition to the aggregate ID and timestamp, we will also have all the information needed to fill in the bits of data needed for the aggregate.</span></p>
<p><span class="koboSpan" id="kobo.76.1">Now, let us review some of the benefits of using events in our systems.</span></p>
<h2 id="_idParaDest-94"><a id="_idTextAnchor093"/><span class="koboSpan" id="kobo.77.1">Pros of event sourcing</span></h2>
<p><span class="koboSpan" id="kobo.78.1">We have been looking</span><a id="_idIndexMarker257"/><span class="koboSpan" id="kobo.79.1"> into the idea of tracking the history of operations that happen against our data, particularly our aggregates. </span><span class="koboSpan" id="kobo.79.2">We have encountered the concepts of events and replays. </span><span class="koboSpan" id="kobo.79.3">Now let us look at what event replays are, how they may benefit us, and what other benefits exist from using events.</span></p>
<p><span class="koboSpan" id="kobo.80.1">Event replays and the way that we conduct our updates depend on whether the aggregate is a domain class or not. </span><span class="koboSpan" id="kobo.80.2">If the aggregate relies on domain services for manipulation, we need to be clear that replays are not about repeating or redoing commands. </span><span class="koboSpan" id="kobo.80.3">A command, based on our understanding of CQRS, changes the state and data in the database. </span><span class="koboSpan" id="kobo.80.4">This also has the potential of being a long-running operation with event-data-generating side effects, which we may not want. </span><span class="koboSpan" id="kobo.80.5">A replay is about looking at data and performing logic to extract information. </span><span class="koboSpan" id="kobo.80.6">On the other hand, event replays copy the effects of events and apply them to fresh instances of the aggregate. </span><span class="koboSpan" id="kobo.80.7">Altogether, stored events may be processed differently relative to the application employing the technique.</span></p>
<p><span class="koboSpan" id="kobo.81.1">Events are bits of data that are stored at a lower level than the plain state. </span><span class="koboSpan" id="kobo.81.2">This means that we can reuse them to build any projection of the data that we need. </span><span class="koboSpan" id="kobo.81.3">Ad hoc projects of the data can be used for the read data store in a CQRS project structure, data analytics, business intelligence, and even artificial intelligence and simulations. </span><span class="koboSpan" id="kobo.81.4">Contextually, if we have a stream of events and can extract a specific subset, then we can replay them and perform ad hoc calculations and processes to generate custom and potentially new</span><a id="_idIndexMarker258"/><span class="koboSpan" id="kobo.82.1"> information. </span><span class="koboSpan" id="kobo.82.2">Events are constant and will always be the same now and later. </span><span class="koboSpan" id="kobo.82.3">This is an additional benefit in that we can always be sure that we will be able to count on the data for consistency.</span></p>
<p><span class="koboSpan" id="kobo.83.1">As in life, for every set of benefits, there is a lingering set of downsides. </span><span class="koboSpan" id="kobo.83.2">Let us explore some of the general concerns around event sourcing.</span></p>
<h2 id="_idParaDest-95"><a id="_idTextAnchor094"/><span class="koboSpan" id="kobo.84.1">Cons of event sourcing</span></h2>
<p><span class="koboSpan" id="kobo.85.1">In exploring event </span><a id="_idIndexMarker259"/><span class="koboSpan" id="kobo.86.1">sourcing, we must bear in mind that we need to introduce an additional data store and additional services that might impede the applicationâ€™s performance. </span><span class="koboSpan" id="kobo.86.2">Let us review some concerns.</span></p>
<p><span class="koboSpan" id="kobo.87.1">Performance is always important in an application. </span><span class="koboSpan" id="kobo.87.2">So, when introducing a new pattern or set of processes, it is prudent of us to ensure that the performance impact is minimal. </span><span class="koboSpan" id="kobo.87.3">What happens when we need to process too many events to rebuild data? </span><span class="koboSpan" id="kobo.87.4">This can quickly become an intensive operation based on the number of logged events, which is only going to grow since the event</span><a id="_idIndexMarker260"/><span class="koboSpan" id="kobo.88.1"> store will be an </span><strong class="bold"><span class="koboSpan" id="kobo.89.1">append-only</span></strong><span class="koboSpan" id="kobo.90.1"> data store.</span></p>
<p><span class="koboSpan" id="kobo.91.1">To address this, we take snapshots of the aggregate state and business entities that have recently been amended. </span><span class="koboSpan" id="kobo.91.2">We can then use these snapshots as a stored version of the record and use them as a recent version of the data, sparing the need to iterate through potentially many events. </span><span class="koboSpan" id="kobo.91.3">This operation is best complimented by having a </span><strong class="bold"><span class="koboSpan" id="kobo.92.1">read-only</span></strong><span class="koboSpan" id="kobo.93.1"> data store to </span><a id="_idIndexMarker261"/><span class="koboSpan" id="kobo.94.1">pair with our CQRS pattern. </span><span class="koboSpan" id="kobo.94.2">The snapshot will be used for read operations going forward.</span></p>
<p><span class="koboSpan" id="kobo.95.1">Now that we have looked at some of the more serious implications of this pattern and techniques that can be used to reduce the impact it might have on our application, let us review how event sourcing and domain events relate to each other so that we can strengthen our foundational knowledge.</span></p>
<h1 id="_idParaDest-96"><a id="_idTextAnchor095"/><span class="koboSpan" id="kobo.96.1">What are domain events?</span></h1>
<p><span class="koboSpan" id="kobo.97.1">Earlier in this book, we</span><a id="_idIndexMarker262"/><span class="koboSpan" id="kobo.98.1"> discussed the use of DDD as a design pattern that helps us to scope the different services that might be required as we develop our microservices application. </span><span class="koboSpan" id="kobo.98.2">Events can be employed in the implementation of this pattern to help us to model expected outcomes within our bounded contexts. </span><span class="koboSpan" id="kobo.98.3">Events are scoped based on the ubiquitous language that has been established within the bounded context and is informed by decisions within the domain.</span></p>
<p><span class="koboSpan" id="kobo.99.1">Within the domain, aggregates are responsible for creating domain events and our domain events are usually raised based on the outcome of some user action, or command. </span><span class="koboSpan" id="kobo.99.2">It is important to</span><a id="_idIndexMarker263"/><span class="koboSpan" id="kobo.100.1"> note that domain events are not raised based on actions such as the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.101.1">Button clicks, mouse moves, page scroll events, or simple application exceptions. </span><span class="koboSpan" id="kobo.101.2">Events should be based on the established ubiquitous language of the bounded context.</span></li>
<li><span class="koboSpan" id="kobo.102.1">Events from other systems or outside of the current context. </span><span class="koboSpan" id="kobo.102.2">It is important to properly establish the boundaries between each domain context.</span></li>
<li><span class="koboSpan" id="kobo.103.1">Simple user requests to the system. </span><span class="koboSpan" id="kobo.103.2">A user request at this point is a command. </span><span class="koboSpan" id="kobo.103.3">The event is raised based on the outcome of the command.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.104.1">Now let us get a better understanding of why domain events are integral to implementing event sourcing patterns.</span></p>
<h2 id="_idParaDest-97"><a id="_idTextAnchor096"/><span class="koboSpan" id="kobo.105.1">Domain events and event sourcing</span></h2>
<p><span class="koboSpan" id="kobo.106.1">Event sourcing is</span><a id="_idIndexMarker264"/><span class="koboSpan" id="kobo.107.1"> implemented to provide a single point of reference for the history of what has happened within a bounded context. </span><span class="koboSpan" id="kobo.107.2">Simply put, event sourcing uses domain events to store the states that an aggregate has gone through. </span><span class="koboSpan" id="kobo.107.3">We have already seen that event sourcing will have us store the record ID, a timestamp, and details that help us to understand what the data looked like at that moment. </span><span class="koboSpan" id="kobo.107.4">Properly implementing </span><strong class="bold"><span class="koboSpan" id="kobo.108.1">domain events</span></strong><span class="koboSpan" id="kobo.109.1"> within a bounded context will lay a foundation for a good implementation of event sourcing and so proper scoping and implementation are important.</span></p>
<p><span class="koboSpan" id="kobo.110.1">Implementing domain events in code can be done relatively</span><a id="_idIndexMarker265"/><span class="koboSpan" id="kobo.111.1"> simply using the </span><strong class="bold"><span class="koboSpan" id="kobo.112.1">MediatR</span></strong><span class="koboSpan" id="kobo.113.1"> library, which was so integral in our CQRS pattern implementation. </span><span class="koboSpan" id="kobo.113.2">In the next section, we will look at adjusting our application to implement domain events.</span></p>
<h2 id="_idParaDest-98"><a id="_idTextAnchor097"/><span class="koboSpan" id="kobo.114.1">Exploring domain events in our application</span></h2>
<p><span class="koboSpan" id="kobo.115.1">Now, let us </span><a id="_idIndexMarker266"/><span class="koboSpan" id="kobo.116.1">consider introducing domain events to our appointment booking system. </span><span class="koboSpan" id="kobo.116.2">As far as we can see, we have several activities that need to be completed when an appointment is booked in our system. </span><span class="koboSpan" id="kobo.116.3">We might also need to extend the capabilities of our system to support the idea that changes might be needed to the original appointment and should be tracked.</span></p>
<p><span class="koboSpan" id="kobo.117.1">Let us use the email dispatching activity. </span><span class="koboSpan" id="kobo.117.2">This needs to happen when an appointment is accepted into the system and saved. </span><span class="koboSpan" id="kobo.117.3">As it stands, our </span><strong class="source-inline"><span class="koboSpan" id="kobo.118.1">CreateAppointmentHandler</span></strong><span class="koboSpan" id="kobo.119.1"> will handle everything that is needed in the situation. </span><span class="koboSpan" id="kobo.119.2">We then run into the challenge of separating concerns since we probably donâ€™t want our handler to be responsible for too many actions. </span><span class="koboSpan" id="kobo.119.3">We would do well to separate our email dispatch operation into its own handler.</span></p>
<p><span class="koboSpan" id="kobo.120.1">Using MediatR, we can introduce a new type of handler called </span><strong class="source-inline"><span class="koboSpan" id="kobo.121.1">INotificationHandler&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.122.1">. </span><span class="koboSpan" id="kobo.122.2">This new base type allows us to define handlers relative to data types modeled from events that inherit from another MediatR base type, called </span><strong class="source-inline"><span class="koboSpan" id="kobo.123.1">INotification</span></strong><span class="koboSpan" id="kobo.124.1">. </span><span class="koboSpan" id="kobo.124.2">These event types should be named according to the action that it is created to facilitate and will be used as the generic parameter in our </span><strong class="source-inline"><span class="koboSpan" id="kobo.125.1">INotificationHandler&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.126.1">. </span><span class="koboSpan" id="kobo.126.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.127.1">INotificationHandler&lt;T&gt;</span></strong><span class="koboSpan" id="kobo.128.1"> base type will be inherited by a handler or handlers that will carry out any specific actions relative to the additional actions required.</span></p>
<p><span class="koboSpan" id="kobo.129.1">In code, we would want to start with some fundamental base types that will help us to define our concrete event types. </span><span class="koboSpan" id="kobo.129.2">The first would be </span><strong class="source-inline"><span class="koboSpan" id="kobo.130.1">IDomainEvent</span></strong><span class="koboSpan" id="kobo.131.1">, which will serve as a base type for all our domain events that will follow. </span><span class="koboSpan" id="kobo.131.2">Its definition looks something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.132.1">
public interface IDomainEvent : INotification
{}</span></pre>
<p><span class="koboSpan" id="kobo.133.1">Our interface inherits from MediatRâ€™s built-in </span><strong class="source-inline"><span class="koboSpan" id="kobo.134.1">INotification</span></strong><span class="koboSpan" id="kobo.135.1"> interface so that any derived data type will automatically also be a notification type. </span><span class="koboSpan" id="kobo.135.2">This </span><strong class="source-inline"><span class="koboSpan" id="kobo.136.1">IDomainEvent</span></strong><span class="koboSpan" id="kobo.137.1"> interface also helps us to enforce any mandatory data that must be present with any event object, such as the date and time of the action.</span></p>
<p><span class="koboSpan" id="kobo.138.1">Now that we have our base types, let us define our derived event class for when an appointment gets created. </span><span class="koboSpan" id="kobo.138.2">We want to</span><a id="_idIndexMarker267"/><span class="koboSpan" id="kobo.139.1"> ensure that we name our event type in a manner that accurately depicts the action that raised the event. </span><span class="koboSpan" id="kobo.139.2">So, we will call this event type </span><strong class="source-inline"><span class="koboSpan" id="kobo.140.1">AppointmentCreated</span></strong><span class="koboSpan" id="kobo.141.1">. </span><span class="koboSpan" id="kobo.141.2">We simply inherit from our </span><strong class="source-inline"><span class="koboSpan" id="kobo.142.1">IDomainEvent</span></strong><span class="koboSpan" id="kobo.143.1"> interface and then define additional fields that correspond with the data that is needed for the event to adequately carry out additional work:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.144.1">
public class AppointmentCreated : IDomainEvent
Â Â Â Â {
Â Â Â Â Â Â Â Â public Appointment { get; set; }
Â Â Â Â Â Â Â Â public DateTime ActionDate { get; private set; }
Â Â Â Â Â Â Â Â public AppointmentCreated(Appointment appointment,
Â Â Â Â Â Â Â Â Â Â DateTime dateCreated)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Appointment = appointment;
Â Â Â Â Â Â Â Â Â Â Â Â ActionDate = dateCreated;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â public AppointmentCreated(Appointment appointment)
Â Â Â Â Â Â Â Â Â Â : this(appointment, DateTime.Now)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â }
Â Â Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.145.1">In our </span><strong class="source-inline"><span class="koboSpan" id="kobo.146.1">AppointmentCreated</span></strong><span class="koboSpan" id="kobo.147.1"> derived event type, we have defined a property for our appointment and a constructor that makes sure that an object of </span><strong class="source-inline"><span class="koboSpan" id="kobo.148.1">Appointment</span></strong><span class="koboSpan" id="kobo.149.1"> is present at the time of creation. </span><span class="koboSpan" id="kobo.149.2">In this case, it is up to you to decide how much or little information you would require for the event to effectively be handled. </span><span class="koboSpan" id="kobo.149.3">For instance, some types of events might only need the appointmentâ€™s ID value. </span><span class="koboSpan" id="kobo.149.4">Be very sure to scope this properly however, and send as much information as is needed. </span><span class="koboSpan" id="kobo.149.5">You do not want to send only the ID and then need to query for additional details and risk potentially many event handlers trying to fetch details from just an ID value.</span></p>
<p><span class="koboSpan" id="kobo.150.1">Now let us look at defining handlers for our event type. </span><span class="koboSpan" id="kobo.150.2">Note that I said </span><em class="italic"><span class="koboSpan" id="kobo.151.1">handlers</span></em><span class="koboSpan" id="kobo.152.1"> as it is possible and viable to define multiple event handlers based on the event that has occurred. </span><span class="koboSpan" id="kobo.152.2">For instance, when an appointment gets created, we might have a handler that will update the event </span><a id="_idIndexMarker268"/><span class="koboSpan" id="kobo.153.1">store with the new record, or have one that dispatches</span><a id="_idIndexMarker269"/><span class="koboSpan" id="kobo.154.1"> an email alert, separate from one that updates</span><a id="_idTextAnchor098"/><span class="koboSpan" id="kobo.155.1"> a </span><a id="_idTextAnchor099"/><strong class="bold"><span class="koboSpan" id="kobo.156.1">SignalR</span></strong><span class="koboSpan" id="kobo.157.1"> hub, for example.</span></p>
<p><span class="koboSpan" id="kobo.158.1">To facilitate updating an event store, we would need to first have a handler defined that would look something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.159.1">
public class UpdateAppointmentEventStore :
Â Â INotificationHandler&lt;AppointmentCreated&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â private readonly AppointmentsEventStoreService
Â Â Â Â Â Â Â Â Â Â _appointmentsEventStore;
Â Â Â Â Â Â Â Â public UpdateAppointmentEventStore
Â Â Â Â Â Â Â Â Â Â (AppointmentsEventStoreService
Â Â Â Â Â Â Â Â Â Â Â Â appointmentsEventStore)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â this._appointmentsEventStore =
Â Â Â Â Â Â Â Â Â Â Â Â Â Â appointmentsEventStore;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â public async Task Handle(AppointmentCreated
Â Â Â Â Â Â Â Â Â notification, CancellationToken cancellationToken)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â await _appointmentsEventStore.CreateAsync
Â Â Â Â Â Â Â Â Â Â Â Â Â Â (notification.Appointment);
Â Â Â Â Â Â Â Â }
Â Â Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.160.1">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.161.1">AppointmentCreated</span></strong><span class="koboSpan" id="kobo.162.1"> event type is used as the target type for our </span><strong class="source-inline"><span class="koboSpan" id="kobo.163.1">INotificationHandler</span></strong><span class="koboSpan" id="kobo.164.1">. </span><span class="koboSpan" id="kobo.164.2">This is all it takes to add specific logic sequences to a raised event. </span><span class="koboSpan" id="kobo.164.3">This also helps us to separate concerns and better isolate bits of code associated with raised events. </span><span class="koboSpan" id="kobo.164.4">Our notification ob</span><a id="_idTextAnchor100"/><span class="koboSpan" id="kobo.165.1">ject contains the appointment record, and we can easily use </span><a id="_idIndexMarker270"/><span class="koboSpan" id="kobo.166.1">the data we need.</span></p>
<p><span class="koboSpan" id="kobo.167.1">This code will automatically get fired when the event occurs and handle the event-store-update operation accordingly.</span></p>
<p><span class="koboSpan" id="kobo.168.1">Let us look at our event handler that will dispatch our email alert:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.169.1">
public class NotifyAppointmentCreated :
Â Â INotificationHandler&lt;AppointmentCreated&gt;
Â Â Â Â {
Â Â Â Â Â Â Â Â private readonly IEmailSender _emailSender;
Â Â Â Â Â Â Â Â private readonly IPatientsRepository
Â Â Â Â Â Â Â Â Â Â _patientsRepository;
Â Â Â Â Â Â Â Â public NotifyAppointmentCreated(IEmailSender
Â Â Â Â Â Â Â Â Â Â emailSender, IPatientsRepository
Â Â Â Â Â Â Â Â Â Â Â Â patientsRepository)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â this._emailSender = emailSender;
Â Â Â Â Â Â Â Â Â Â Â Â this._patientsRepository = patientsRepository;
Â Â Â Â Â Â Â Â }
Â Â Â Â Â Â Â Â public async Task Handle(AppointmentCreated
Â Â Â Â Â Â Â Â Â notification, CancellationToken cancellationToken)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â // Get patient record via Patients API call
Â Â Â Â Â Â Â Â Â Â Â Â var patient = await _patientsRepository.Get
Â Â Â Â Â Â Â Â Â Â Â Â Â Â (notification.Appointment.
</span><span class="koboSpan" id="kobo.169.2">Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â PatientId.ToString());
Â Â Â Â Â Â Â Â Â Â Â Â string emailAddress = patient.EmailAddress;
Â Â Â Â Â Â Â Â Â Â Â Â // Send Email Here
Â Â Â Â Â Â Â Â Â Â Â Â var email = new Email
Â Â Â Â Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Body = $"Appointment Created for
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â {notification.Appointment.Start}",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â From = "noreply@appointments.com",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Subject = "Appointment Created",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â To = emailAddress
Â Â Â Â Â Â Â Â Â Â Â Â };
Â Â Â Â Â Â Â Â Â Â Â Â await _emailSender.SendEmail(email);
Â Â Â Â Â Â Â Â }
Â Â Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.170.1">Notice as well that </span><a id="_idIndexMarker271"/><span class="koboSpan" id="kobo.171.1">even though we did not have direct access to the patientâ€™s record, we had their ID. </span><span class="koboSpan" id="kobo.171.2">With that value, we could make a synchronous API call to retrieve additional details that can assist us in crafting and dispatching the notification email.</span></p>
<p><span class="koboSpan" id="kobo.172.1">In the same way, if we wanted to define an event handler for SignalR operations, we could simply define a</span><a id="_idIndexMarker272"/><span class="koboSpan" id="kobo.173.1"> second handler for the same event type:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.174.1">
public class NotifySignalRHubsAppointmentCreated :
Â Â INotificationHandler&lt;AppointmentCreated&gt;
{
Â Â public Task Handle(AppointmentCreated notification,
Â Â Â Â CancellationToken cancellationToken)
Â Â {
Â Â Â Â // SignalR awesomeness here
Â Â Â Â return Task.CompletedTask;
Â Â }
}</span></pre>
<p><span class="koboSpan" id="kobo.175.1">Now that we can raise an event, we can refactor our application a bit to reflect this. </span><span class="koboSpan" id="kobo.175.2">We can refactor our </span><strong class="source-inline"><span class="koboSpan" id="kobo.176.1">CreateAppointmentHandler</span></strong><span class="koboSpan" id="kobo.177.1"> and </span><strong class="source-inline"><span class="koboSpan" id="kobo.178.1">CreateAppointmentCommand</span></strong><span class="koboSpan" id="kobo.179.1"> classes to return an object of </span><strong class="source-inline"><span class="koboSpan" id="kobo.180.1">Appointment</span></strong><span class="koboSpan" id="kobo.181.1"> instead of the previously defined string value:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.182.1">
public record CreateAppointmentCommand(int
Â Â AppointmentTypeId, Guid DoctorId, Guid PatientId, Guid
Â Â Â Â RoomId, DateTime Start, DateTime End, string Title) :
Â Â Â Â Â Â IRequest&lt;Appointment&gt;;
public class CreateAppointmentHandler :
Â Â IRequestHandler&lt;CreateAppointmentCommand, Appointment&gt;
public async Task&lt;Appointment&gt; Handle
Â Â (CreateAppointmentCommand request, CancellationToken
Â Â Â Â cancellationToken){ â€¦ }</span></pre>
<p><span class="koboSpan" id="kobo.183.1">With this adjustment, we can now retrieve an object of the created appointment and publish an event from the original calling code, which was in the controller. </span><span class="koboSpan" id="kobo.183.2">Our </span><strong class="source-inline"><span class="koboSpan" id="kobo.184.1">POST</span></strong><span class="koboSpan" id="kobo.185.1"> method for our appointments </span><a id="_idIndexMarker273"/><span class="koboSpan" id="kobo.186.1">API now looks like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.187.1">
// POST api/&lt;AppointmentsController&gt;
Â Â Â Â Â Â Â Â [HttpPost]
Â Â Â Â Â Â Â Â public async Task&lt;ActionResult&gt; Post([FromBody]
Â Â Â Â Â Â Â Â Â CreateAppointmentCommand createAppointmentCommand)
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â // Send appointment information to create
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â handler
Â Â Â Â Â Â Â Â Â Â Â Â var appointment = await
Â Â Â Â Â Â Â Â Â Â Â Â Â Â _mediator.Send(createAppointmentCommand);
Â Â Â Â Â Â Â Â Â Â Â Â //Publish AppointmentCreated event to all
Â Â Â Â Â Â Â Â Â Â Â Â Â Â listeners
Â Â Â Â Â Â Â Â Â Â Â Â await _mediator.Publish(new AppointmentCreated
Â Â Â Â Â Â Â Â Â Â Â Â Â Â (appointment));
Â Â Â Â Â Â Â Â Â Â Â Â // return success code to caller
Â Â Â Â Â Â Â Â Â Â Â Â return StatusCode(201);
Â Â Â Â Â Â Â Â }</span></pre>
<p><span class="koboSpan" id="kobo.188.1">Now we use the </span><strong class="source-inline"><span class="koboSpan" id="kobo.189.1">Publish</span></strong><span class="koboSpan" id="kobo.190.1"> method from the MediatR library to raise an event, and all handlers that have been defined to watch for the specified event type will be called into action.</span></p>
<p><span class="koboSpan" id="kobo.191.1">These refactors to our code will introduce even more code and files, but they do assist in helping us maintain a distributed and loosely coupled code base. </span><span class="koboSpan" id="kobo.191.2">With this activity, we have reviewed how we can cleanly introduce domain events to our application, and now we need to appreciate how we can store our events.</span></p>
<h1 id="_idParaDest-99"><a id="_idTextAnchor101"/><span class="koboSpan" id="kobo.192.1">Creating an event store</span></h1>
<p><span class="koboSpan" id="kobo.193.1">Before we get to the scoping phase of</span><a id="_idIndexMarker274"/><span class="koboSpan" id="kobo.194.1"> creating an event store, it is important for us to fully understand what one is. </span><span class="koboSpan" id="kobo.194.2">A simple search on the topic might yield many results from various sources, with each citing varied definitions. </span><span class="koboSpan" id="kobo.194.3">For this book, we will conclude that an event store </span><em class="italic"><span class="koboSpan" id="kobo.195.1">is an ordered, easily queryable, and persistent source of long-term records that represents events that have happened against entities in a data store.</span></em></p>
<p><span class="koboSpan" id="kobo.196.1">In exploring the implementation of a data store, let us break out the key parts and how they connect to give the resulting event store. </span><span class="koboSpan" id="kobo.196.2">An event record will have an aggregate ID, a timestamp, an </span><strong class="source-inline"><span class="koboSpan" id="kobo.197.1">EventType</span></strong><span class="koboSpan" id="kobo.198.1"> flag, and data representing the state at that point in time. </span><span class="koboSpan" id="kobo.198.2">An application will persist event records in a data store. </span><span class="koboSpan" id="kobo.198.3">This data store has an API or some form of interface that allows for adding and retrieving events for an entity or aggregate. </span><span class="koboSpan" id="kobo.198.4">The event store might also behave like a message broker allowing for other services to subscribe to events as they are published by the source. </span><span class="koboSpan" id="kobo.198.5">It provides an API that enables services to subscribe to events. </span><span class="koboSpan" id="kobo.198.6">When a service saves an event in the event store, it is delivered to all interested subscribers. </span><em class="italic"><span class="koboSpan" id="kobo.199.1">Figure 6.1</span></em><span class="koboSpan" id="kobo.200.1"> shows a typical event store architecture.</span></p>
<div>
<div class="IMG---Figure" id="_idContainer025">
<span class="koboSpan" id="kobo.201.1"><img alt="Figure 6.1 â€“ An event store sits between the command handlers of an API and the query handler, which may require a different projection of the originally stored data" src="image/Figure_6.1_B19100.jpg"/></span>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US"><span class="koboSpan" id="kobo.202.1">Figure 6.1 â€“ An event store sits between the command handlers of an API and the query handler, which may require a different projection of the originally stored data</span></p>
<p><span class="koboSpan" id="kobo.203.1">Let us review event </span><a id="_idIndexMarker275"/><span class="koboSpan" id="kobo.204.1">storage strategies that we can employ.</span></p>
<h2 id="_idParaDest-100"><a id="_idTextAnchor102"/><span class="koboSpan" id="kobo.205.1">How to store events</span></h2>
<p><span class="koboSpan" id="kobo.206.1">We have already</span><a id="_idIndexMarker276"/><span class="koboSpan" id="kobo.207.1"> established that events should be immutable, and the data store should be append-only. </span><span class="koboSpan" id="kobo.207.2">Armed with these two requirements, we can deduce that our dos and donâ€™ts need to be at a minimum as we scope the data store.</span></p>
<p><span class="koboSpan" id="kobo.208.1">Each change that takes place in the domain needs to be recorded in the event store. </span><span class="koboSpan" id="kobo.208.2">Since events need to contain certain details relevant to the event being recorded, we need to maintain some amount of flexibility with the structure of the data. </span><span class="koboSpan" id="kobo.208.3">An event might contain data from multiple sources in the domain. </span><span class="koboSpan" id="kobo.208.4">That means that we need to leverage possible relationships between tables in order to grab all the details required to log the event.</span></p>
<p><span class="koboSpan" id="kobo.209.1">This makes the standard relational database model less feasible as a data store for events since we want to be as efficient as possible in retrieving our event records for auditing, replay, or analytics later. </span><span class="koboSpan" id="kobo.209.2">If we are using a relational data store, then we would do well to have denormalized tables modeled from the event data that we intend to store. </span><span class="koboSpan" id="kobo.209.3">An alternative and more efficient manner to handle event storage is the use of a non-relational or NoSQL database. </span><span class="koboSpan" id="kobo.209.4">This will allow us to store the relevant event data as documents in a far</span><a id="_idIndexMarker277"/><span class="koboSpan" id="kobo.210.1"> more dynamic manner.</span></p>
<p><span class="koboSpan" id="kobo.211.1">Let us explore some options regarding storing events in a relational database.</span></p>
<h2 id="_idParaDest-101"><a id="_idTextAnchor103"/><span class="koboSpan" id="kobo.212.1">Implementing event sourcing using a relational database</span></h2>
<p><span class="koboSpan" id="kobo.213.1">We have already reviewed some of the drawbacks of using a relational database as the event store. </span><span class="koboSpan" id="kobo.213.2">In truth, the way </span><a id="_idIndexMarker278"/><span class="koboSpan" id="kobo.214.1">you design this storage, alongside the technology that is used, can have a major bearing on how future-proofed your implementation will be.</span></p>
<p><span class="koboSpan" id="kobo.215.1">If we go the route of using</span><a id="_idIndexMarker279"/><span class="koboSpan" id="kobo.216.1"> denormalized table representations of the events, then we will end up going down a rabbit hole of modeling several tables based on several different events. </span><span class="koboSpan" id="kobo.216.2">This might not be sustainable in the long run, since we would need to introduce new tables with each newly scoped event and constantly change designs as the events evolve.</span></p>
<p><span class="koboSpan" id="kobo.217.1">An alternative would be that we create a singular log table that has columns that match the data points we just outlined. </span><span class="koboSpan" id="kobo.217.2">For example, this table and the matching data types would be as follows:</span></p>
<div>
<div class="IMG---Figure" id="_idContainer026">
<table class="No-Table-Style" id="table001-1">
<colgroup>
<col/>
<col/>
</colgroup>
<tbody>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><strong class="bold"><span class="koboSpan" id="kobo.218.1">Column Name</span></strong></p>
</td>
<td class="No-Table-Style T---Body">
<p><strong class="bold"><span class="koboSpan" id="kobo.219.1">Data Type</span></strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><strong class="bold"><span class="koboSpan" id="kobo.220.1">Id</span></strong></p>
</td>
<td class="No-Table-Style T---Body">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.221.1">Int</span></strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><strong class="bold"><span class="koboSpan" id="kobo.222.1">AggregateId</span></strong></p>
</td>
<td class="No-Table-Style T---Body">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.223.1">Guid</span></strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><strong class="bold"><span class="koboSpan" id="kobo.224.1">Timestamp</span></strong></p>
</td>
<td class="No-Table-Style T---Body">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.225.1">DateTime</span></strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><strong class="bold"><span class="koboSpan" id="kobo.226.1">EventType</span></strong></p>
</td>
<td class="No-Table-Style T---Body">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.227.1">Varchar</span></strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><strong class="bold"><span class="koboSpan" id="kobo.228.1">Data</span></strong></p>
</td>
<td class="No-Table-Style T---Body">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.229.1">Varchar</span></strong></p>
</td>
</tr>
<tr class="No-Table-Style">
<td class="No-Table-Style T---Body">
<p><strong class="bold"><span class="koboSpan" id="kobo.230.1">VersionNumber</span></strong></p>
</td>
<td class="No-Table-Style T---Body">
<p><strong class="source-inline"><span class="koboSpan" id="kobo.231.1">Int</span></strong></p>
</td>
</tr>
</tbody>
</table>
</div>
</div>
<ul>
<li><strong class="bold"><span class="koboSpan" id="kobo.232.1">Id</span></strong><span class="koboSpan" id="kobo.233.1">: Unique identifier for the event record.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.234.1">AggregateId</span></strong><span class="koboSpan" id="kobo.235.1">: Unique identifier for the aggregate record to which the event is related.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.236.1">Timestamp</span></strong><span class="koboSpan" id="kobo.237.1">: The date and time that this event was logged.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.238.1">EventType:</span></strong><span class="koboSpan" id="kobo.239.1"> This is a string representation of the name of the event that is being logged.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.240.1">Data:</span></strong><span class="koboSpan" id="kobo.241.1"> This is a serialized representation of the data associated with the event record. </span><span class="koboSpan" id="kobo.241.2">This serialization is best done in an easy-to-manipulate format such as </span><strong class="bold"><span class="koboSpan" id="kobo.242.1">JSON</span></strong><span class="koboSpan" id="kobo.243.1">.</span></li>
<li><strong class="bold"><span class="koboSpan" id="kobo.244.1">VersionNumber</span></strong><span class="koboSpan" id="kobo.245.1">: The version number helps us to know how to sort events. </span><span class="koboSpan" id="kobo.245.2">It represents the sequence in</span><a id="_idIndexMarker280"/><span class="koboSpan" id="kobo.246.1"> which each new event was logged in the stream and should be unique to each aggregate.We can </span><a id="_idIndexMarker281"/><span class="koboSpan" id="kobo.247.1">add constraints to our records by introducing a </span><strong class="bold"><span class="koboSpan" id="kobo.248.1">UNIQUE</span></strong><span class="koboSpan" id="kobo.249.1"> index on both the </span><strong class="bold"><span class="koboSpan" id="kobo.250.1">AggregateId</span></strong><span class="koboSpan" id="kobo.251.1"> and </span><strong class="bold"><span class="koboSpan" id="kobo.252.1">VersionNumber</span></strong><span class="koboSpan" id="kobo.253.1"> columns. </span><span class="koboSpan" id="kobo.253.2">This will help us with speedier queries and ensure that we do not repeat any combination of these values.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.254.1">The type of database </span><a id="_idIndexMarker282"/><span class="koboSpan" id="kobo.255.1">technology that is employed does play a part in how flexibly and efficiently we can store and retrieve data. </span><span class="koboSpan" id="kobo.255.2">The use of </span><strong class="bold"><span class="koboSpan" id="kobo.256.1">PostgreSQL</span></strong><span class="koboSpan" id="kobo.257.1"> and later versions of </span><strong class="bold"><span class="koboSpan" id="kobo.258.1">Microsoft SQL Server</span></strong><span class="koboSpan" id="kobo.259.1"> will see us reap the advantages of being able to manipulate the serialized representation of the data more efficiently.</span></p>
<p><span class="koboSpan" id="kobo.260.1">Now let us look at how we can model our NoSQL data stores.</span></p>
<h2 id="_idParaDest-102"><a id="_idTextAnchor104"/><span class="koboSpan" id="kobo.261.1">Implementing event sourcing using a non-relational database</span></h2>
<p><strong class="bold"><span class="koboSpan" id="kobo.262.1">NoSQL databases</span></strong><span class="koboSpan" id="kobo.263.1"> are also called </span><strong class="bold"><span class="koboSpan" id="kobo.264.1">document databases </span></strong><span class="koboSpan" id="kobo.265.1">and are characterized</span><a id="_idIndexMarker283"/><span class="koboSpan" id="kobo.266.1"> by their ability to effectively</span><a id="_idIndexMarker284"/><span class="koboSpan" id="kobo.267.1"> store </span><a id="_idIndexMarker285"/><span class="koboSpan" id="kobo.268.1">unstructured data. </span><span class="koboSpan" id="kobo.268.2">This means the following:</span></p>
<ul>
<li><span class="koboSpan" id="kobo.269.1">Records do not need </span><a id="_idIndexMarker286"/><span class="koboSpan" id="kobo.270.1">to meet any minimum structure. </span><span class="koboSpan" id="kobo.270.2">Columns are not mandated in the design phase, so it is easy enough to extend and contract the data based on the immediate need.</span></li>
<li><span class="koboSpan" id="kobo.271.1">Data types are not strictly implemented, so the data structure can evolve at any point in time without having detrimental effects on previously stored records.</span></li>
<li><span class="koboSpan" id="kobo.272.1">Data can be nested and can contain sequences. </span><span class="koboSpan" id="kobo.272.2">This is significant since we do not need to spread related data across multiple documents. </span><span class="koboSpan" id="kobo.272.3">One document can represent a denormalized representation of data from several sources.</span></li>
</ul>
<p><span class="koboSpan" id="kobo.273.1">Popular examples of</span><a id="_idIndexMarker287"/><span class="koboSpan" id="kobo.274.1"> document stores are </span><strong class="bold"><span class="koboSpan" id="kobo.275.1">MongoDB</span></strong><span class="koboSpan" id="kobo.276.1">, </span><strong class="bold"><span class="koboSpan" id="kobo.277.1">Microsoft Azure Cosmos DB</span></strong><span class="koboSpan" id="kobo.278.1">, and </span><strong class="bold"><span class="koboSpan" id="kobo.279.1">Amazon DynamoDB</span></strong><span class="koboSpan" id="kobo.280.1">, to name a few. </span><span class="koboSpan" id="kobo.280.2">Outside of the specific querying and integration requirements for each of these database options, the concepts of how documents are formed and </span><a id="_idIndexMarker288"/><span class="koboSpan" id="kobo.281.1">stored are the</span><a id="_idIndexMarker289"/><span class="koboSpan" id="kobo.282.1"> same.</span></p>
<p><span class="koboSpan" id="kobo.283.1">We can outline the properties of the document in a very similar manner to how a table would look. </span><span class="koboSpan" id="kobo.283.2">In a document data store, however, the data is stored in JSON format (unless specifically requested or implemented otherwise). </span><span class="koboSpan" id="kobo.283.3">An event entry would look something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.284.1">
{
Â Â Â Â "type":"AppointmentCreated",
Â Â Â Â "aggregateId":"aggregateId-guid-value",
Â Â Â Â "data": {
Â Â Â Â Â Â Â Â "doctorId": "doctorId-guid-value",
Â Â Â Â Â Â Â Â "customerId": "customerId-guid-value",
Â Â Â Â Â Â Â Â "dateTime": "recorded-date-time",
Â Â Â Â Â Â Â Â ...
</span><span class="koboSpan" id="kobo.284.2">Â Â Â Â },
Â Â Â Â "timestamp":"2022-01-01T21:00:46Z"
}</span></pre>
<p><span class="koboSpan" id="kobo.285.1">Another advantage to using a document data store is that we can more easily represent a record with its</span><a id="_idIndexMarker290"/><span class="koboSpan" id="kobo.286.1"> event history in a materialized </span><a id="_idIndexMarker291"/><span class="koboSpan" id="kobo.287.1">view. </span><span class="koboSpan" id="kobo.287.2">That could look something like this:</span></p>
<pre class="source-code"><span class="koboSpan" id="kobo.288.1">
{
Â Â Â Â "type":"AppointmentCreated",
Â Â Â Â "aggregateId":"aggregateId-guid-value",
Â Â Â Â "doctorId": "doctorId-guid-value",
Â Â Â Â "customerId": "customerId-guid-value",
Â Â Â Â "dateTime": "recorded-date-time",
Â Â Â Â ...
</span><span class="koboSpan" id="kobo.288.2">Â Â Â Â "history": [
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â "type":"AppointmentCreated",
Â Â Â Â Â Â Â Â Â Â Â Â "data": {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "doctorId": "doctorId-guid-value",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "customerId": "customerId-guid-value",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "dateTime": "recorded-date-time",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â ...
</span><span class="koboSpan" id="kobo.288.3">Â Â Â Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â Â Â Â Â "timestamp":"2022-01-01T21:00:46Z"
Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â {
Â Â Â Â Â Â Â Â Â Â Â Â "type":"AppointmentUpdated",
Â Â Â Â Â Â Â Â Â Â Â Â "data": {
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "doctorId": "different-doctorId-guid-value",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "customerId": "customerId-guid-value",
Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â "comment":"Update comment here"
Â Â Â Â Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â Â Â Â Â "timestamp":"2022-01-01T21:00:46Z",
Â Â Â Â Â Â Â Â Â Â Â Â ...
</span><span class="koboSpan" id="kobo.288.4">Â Â Â Â Â Â Â Â },
Â Â Â Â Â Â Â Â ...
</span><span class="koboSpan" id="kobo.288.5">Â Â Â Â ],
Â Â Â Â "createdDate":"2022-01-01T21:00:46Z",
Â Â Â Â ...
</span><span class="koboSpan" id="kobo.288.6">}</span></pre>
<p><span class="koboSpan" id="kobo.289.1">This type of data representation can be advantageous for retrieving a record with all its events, especially if we intend to display this data on a user interface. </span><span class="koboSpan" id="kobo.289.2">We have generated a view that acts as both</span><a id="_idIndexMarker292"/><span class="koboSpan" id="kobo.290.1"> a snapshot of the current state of the aggregate data and the stream of events that have</span><a id="_idIndexMarker293"/><span class="koboSpan" id="kobo.291.1"> affected it. </span><span class="koboSpan" id="kobo.291.2">This form of data aggregation helps us to reduce some complexity and keep the concept of event retrieval simple.</span></p>
<p><span class="koboSpan" id="kobo.292.1">Now that we see how we can implement a read-only and denormalized data store, let us review how we can use the CQRS pattern to retrieve the latest state of the data.</span></p>
<h2 id="_idParaDest-103"><a id="_idTextAnchor105"/><span class="koboSpan" id="kobo.293.1">Reading state with CQRS</span></h2>
<p><span class="koboSpan" id="kobo.294.1">We have reviewed the CQRS pattern, and</span><a id="_idIndexMarker294"/><span class="koboSpan" id="kobo.295.1"> we see where we can create handlers that will perform write operations. </span><span class="koboSpan" id="kobo.295.2">Earlier in this chapter, we enhanced our command handler functionality with the ability to trigger events, which are capable of performing triggering additional actions after a command has been completed.</span></p>
<p><span class="koboSpan" id="kobo.296.1">In the context of the event sourcing pattern, this additional action involves updating our read-only data stores with the appropriate data per view. </span><span class="koboSpan" id="kobo.296.2">When creating our query handlers, we can rely on these tables for the latest version of the data that is available. </span><span class="koboSpan" id="kobo.296.3">This ties in perfectly with the ideal implementation of the CQRS pattern where separate data stores are to be used for read and write operations.</span></p>
<p><span class="koboSpan" id="kobo.297.1">It also presents an excellent </span><a id="_idIndexMarker295"/><span class="koboSpan" id="kobo.298.1">opportunity for us to provide more specific representations of the data we wish to present from our read operations. </span><span class="koboSpan" id="kobo.298.2">This approach, however, introduces the risk that our data stores might become out of sync in between operations, which is a risk that we must accept and mitigate as best as possible.</span></p>
<p><span class="koboSpan" id="kobo.299.1">Now that we have explored events, event sourcing patterns, and event storage options, let us review these concepts.</span></p>
<h1 id="_idParaDest-104"><a id="_idTextAnchor106"/><span class="koboSpan" id="kobo.300.1">Summary</span></h1>
<p><span class="koboSpan" id="kobo.301.1">Event sourcing and event-driven design patterns bring a whole new dimension to what is required in our software implementation. </span><span class="koboSpan" id="kobo.301.2">These patterns involve additional code but do assist in helping us to implement additional business logic for completed commands while maintaining a reliable log of all the changes happening in our data store.</span></p>
<p><span class="koboSpan" id="kobo.302.1">In this chapter, we explored what events are, various factors of event sourcing patterns, how we can implement certain aspects in a real application, and the pros and cons of using relational or non-relational storage options.</span></p>
<p><span class="koboSpan" id="kobo.303.1">In our next chapter, we will explore the Database Per Service pattern and look at best practices when implementing the data access layer in each microservice.</span></p>
</div>


<div class="Content" id="_idContainer028">
<h1 id="_idParaDest-105"><a id="_idTextAnchor107"/><span class="koboSpan" id="kobo.1.1">Part 2: Database and Storage Design Patterns</span></h1>
<p><span class="koboSpan" id="kobo.2.1">Understanding and implementing data management patterns and techniques is vital when designing a microservices application. </span><span class="koboSpan" id="kobo.2.2">Each microservice might need its database, and we need to understand the intricacies surrounding managing each database and how we coordinate efforts across services. </span><span class="koboSpan" id="kobo.2.3">By the end of this part, you will come to appreciate the tough decisions that need to be made surrounding databases in a microservices application. </span></p>
<p><span class="koboSpan" id="kobo.3.1">This part has the following chapters:</span></p>
<ul>
<li><a href="B19100_07.xhtml#_idTextAnchor108"><em class="italic"><span class="koboSpan" id="kobo.4.1">Chapter 7</span></em></a><span class="koboSpan" id="kobo.5.1">, </span><em class="italic"><span class="koboSpan" id="kobo.6.1">Handling Data for Each Microservice with the Database per Service Pattern</span></em></li>
<li><a href="B19100_08.xhtml#_idTextAnchor127"><em class="italic"><span class="koboSpan" id="kobo.7.1">Chapter 8</span></em></a><span class="koboSpan" id="kobo.8.1">, </span><em class="italic"><span class="koboSpan" id="kobo.9.1">Implement Transactions across Microservices Using the Saga Pattern </span></em></li>
</ul>
</div>
<div>
<div id="_idContainer029">
</div>
</div>
</body></html>