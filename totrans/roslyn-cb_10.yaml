- en: Command-Line Tools Based on Roslyn API
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于Roslyn API的命令行工具
- en: 'In this chapter, we will cover the following recipes:'
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将介绍以下食谱：
- en: Writing an application based on the Compiler Syntax API to parse and transform
    source files
  id: totrans-2
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于编译器语法API编写应用程序以解析和转换源文件
- en: Writing an application based on the Compiler Semantic API to display diagnostics
    and overload resolution results
  id: totrans-3
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于编译器语义API编写应用程序以显示诊断和重载解析结果
- en: Writing an application based on the Compiler Analyzer API to execute diagnostic
    analyzers and display analyzer diagnostics
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于编译器分析API编写应用程序以执行诊断分析器和显示分析器诊断
- en: Writing an application based on the Workspaces API to format and simplify all
    source files in the solution
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于工作空间API编写应用程序以格式化和简化解决方案中的所有源文件
- en: Writing an application based on the Workspaces API to edit projects in a solution
    and display project properties
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 基于工作空间API编写应用程序以编辑解决方案中的项目并显示项目属性
- en: Introduction
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: This chapter enables developers to write command-line tools using the Roslyn
    compiler and workspaces API to analyze and/or edit C# code. The article at ([https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview](https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview))
    provides a very good introduction to the Roslyn APIs at each of these layers.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 本章使开发者能够使用Roslyn编译器和工作空间API编写命令行工具，用于分析和/或编辑C#代码。([https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview](https://github.com/dotnet/roslyn/wiki/Roslyn%20Overview))中的文章为这些层的Roslyn
    API提供了非常好的介绍。
- en: 'We will provide you a gist from the article:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将为您提供文章中的代码片段：
- en: '![](img/34e6b225-9b74-4f36-a4e0-a1fc49c5acd0.png)'
  id: totrans-10
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/34e6b225-9b74-4f36-a4e0-a1fc49c5acd0.png)'
- en: '**Compiler API**: The compiler layer contains the object models that correspond
    with information exposed at each phase of the compiler pipeline, both syntactic
    and semantic. The compiler layer also contains an immutable snapshot of a single
    invocation of a compiler, including assembly references, compiler options, and
    source code files. There are two distinct APIs that represent the C# language
    and the Visual Basic language. These two APIs are similar in shape but tailored
    for high fidelity to each individual language. This layer has no dependencies
    on Visual Studio components.'
  id: totrans-11
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**编译器API**：编译器层包含与编译器管道每个阶段公开的信息相对应的对象模型，包括语法和语义。编译器层还包含编译器单次调用的不可变快照，包括程序集引用、编译器选项和源代码文件。有两个不同的API代表C#语言和Visual
    Basic语言。这两个API在形状上相似，但针对每个语言进行了定制，以实现高保真度。这一层不依赖于Visual Studio组件。'
- en: '**Workspaces API**: The Workspaces layer contains the Workspaces API, which
    is the starting point for doing code analysis and refactoring over entire solutions.
    It assists you in organizing all the information about the projects in a solution
    into a single object model, offering you direct access to the compiler layer object
    models without needing to parse files, configure options, or manage project to
    project dependencies. This layer has no dependencies on Visual Studio components.'
  id: totrans-12
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**工作空间API**：工作空间层包含工作空间API，这是在整个解决方案上进行代码分析和重构的起点。它帮助您将解决方案中所有关于项目的信息组织到一个单一的对象模型中，提供直接访问编译层对象模型的能力，无需解析文件、配置选项或管理项目间的依赖关系。这一层不依赖于Visual
    Studio组件。'
- en: Writing an application based on the Compiler Syntax API to parse and transform
    source files
  id: totrans-13
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于编译器语法API编写应用程序以解析和转换源文件
- en: 'In this section, we will write a C# console application based on Roslyn Compiler
    APIs to parse a given source file into a syntax tree, and then perform the following
    syntax transformations:'
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个基于Roslyn编译器API的C#控制台应用程序，将给定的源文件解析为语法树，然后执行以下语法转换：
- en: Edit all the class declarations with no explicit accessibility modifier to add
    an internal modifier.
  id: totrans-15
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 编辑所有没有显式可访问性修饰符的类声明，添加内部修饰符。
- en: Add documentation comment syntax trivia to all public class declarations with
    no documentation comments.
  id: totrans-16
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 将所有没有文档注释的公共类声明添加文档注释语法技巧。
- en: Remove empty class declarations with no members.
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 删除没有成员的空类声明。
- en: Getting started
  id: totrans-18
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: 'You will need to have the Visual Studio 2017 Community Edition installed on
    your machine to execute this recipe. You can install a free Community Edition
    from: [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的机器上安装Visual Studio 2017社区版才能执行此菜谱。您可以从[https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)安装免费的社区版。
- en: How to do it...
  id: totrans-20
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open Visual Studio and create a new C# console application targeting .NET Framework
    4.6 or higher, say `ConsoleApp`*.*
  id: totrans-21
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio并创建一个新的针对.NET Framework 4.6或更高版本的C#控制台应用程序，例如`ConsoleApp`*.*。
- en: Install the `Microsoft.CodeAnalysis.CSharp` NuGet package (as of this writing,
    the latest stable version is *2.1.0*). For guidance on how to search and install
    the NuGet package to a project, refer to the recipe *Searching and installing
    analyzers through the NuGet package manager* in [Chapter 2](8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml),
    *Consuming Diagnostic Analyzers in .NET Projects*.
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装`Microsoft.CodeAnalysis.CSharp` NuGet包（截至本文写作，最新稳定版本是*2.1.0*）。有关如何在项目中搜索和安装NuGet包的指导，请参阅第2章中*通过NuGet包管理器搜索和安装分析器*的菜谱，*在.NET项目中使用诊断分析器*。
- en: Replace the source code in `Program.cs` with the source code from the attached
    code sample `\ConsoleApp\Program.cs`.
  id: totrans-23
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将`Program.cs`中的源代码替换为附带的代码示例`\ConsoleApp\Program.cs`中的源代码。
- en: Build the project.
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。
- en: Open a Visual Studio developer command prompt, change the directory to the project
    root directory, and execute `bin\Debug\ConsoleApp.exe` with no arguments.
  id: totrans-25
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开Visual Studio开发者命令提示符，将目录更改为项目根目录，然后不带参数执行`bin\Debug\ConsoleApp.exe`。
- en: 'Verify the output shows incorrect usage: `Usage: ConsoleApp.exe <%file_path%>`'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '验证输出显示不正确的用法：`Usage: ConsoleApp.exe <%file_path%>`'
- en: 'Create a text file, say `test.cs`, with the following code at the project root
    directory:'
  id: totrans-27
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录下创建一个文本文件，例如`test.cs`，包含以下代码：
- en: '[PRE0]'
  id: totrans-28
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Now, execute the application with `test.cs` as the argument: `bin\Debug\ConsoleApp.exe
    test.cs`.'
  id: totrans-29
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用`test.cs`作为参数执行应用程序：`bin\Debug\ConsoleApp.exe test.cs`。
- en: 'Verify the expected transformed source is displayed in the output:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证预期的转换后的源代码在输出中显示：
- en: '![](img/0d778001-bcef-4845-85fd-db54050e822e.png)'
  id: totrans-31
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0d778001-bcef-4845-85fd-db54050e822e.png)'
- en: How it works...
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we wrote a C# console application based on Roslyn Compiler
    API to parse and transform source text. As mentioned earlier, our application
    demonstrates three core syntax operations on the parsed tree: edit, add, and remove.
    Let''s walk through the code and understand how we implemented these operations:'
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们基于Roslyn编译器API编写了一个C#控制台应用程序来解析和转换源文本。如前所述，我们的应用程序演示了对解析树的三个核心语法操作：编辑、添加和删除。让我们逐行代码来了解我们如何实现这些操作：
- en: '[PRE1]'
  id: totrans-34
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'The `Main` method invokes individual methods to perform the following operations:'
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main`方法调用单个方法执行以下操作：'
- en: '`ParseArguments` to scan for the input file to parse and transform.'
  id: totrans-36
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParseArguments`用于扫描要解析和转换的输入文件。'
- en: Read the text from this source file and `Parse` it into a syntax tree.
  id: totrans-37
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 从此源文件中读取文本并将其`Parse`成语法树。
- en: 'Get the compilation unit root of the parsed tree and perform the following
    transformations on the root:'
  id: totrans-38
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 获取解析树的编译单元根并对其执行以下转换：
- en: '`EditClassDeclarations` : To add internal modifier to class with no accessibility
    modifier.'
  id: totrans-39
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`EditClassDeclarations`：向没有可访问性修饰符的类添加内部修饰符。'
- en: '`AddDocCommentsToClassDeclarations` : To add stub documentation comments to
    public class with no documentation comments.'
  id: totrans-40
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddDocCommentsToClassDeclarations`：向没有文档注释的公共类添加占位符文档注释。'
- en: '`RemoveEmptyClassDeclarations` : To remove class declarations with no members.'
  id: totrans-41
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveEmptyClassDeclarations`：删除没有成员的类声明。'
- en: Display the transformed text on the console.
  id: totrans-42
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在控制台上显示转换后的文本。
- en: The `ParseArguments` method expects a single argument, which must be a full
    path to an existing file on the disk. Otherwise, it displays an error and bails
    out returning null.
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseArguments`方法期望一个参数，该参数必须是磁盘上现有文件的完整路径。否则，它将显示错误并退出，返回null。'
- en: '[PRE2]'
  id: totrans-44
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: The `Parse` method reads the file contents from the input file and parses it
    using the parsing API `CSharpSyntaxTree.ParseText`.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: '`Parse`方法从输入文件读取文件内容，并使用解析API `CSharpSyntaxTree.ParseText`进行解析。'
- en: '[PRE3]'
  id: totrans-46
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: The `EditClassDeclarations` method walks the descendant nodes of the root to
    find all class declaration nodes whose modifier list has no accessibility modifier
    (public, private, internal, or protected).
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: '`EditClassDeclarations` 方法遍历根节点的后代节点以找到所有修饰符列表没有可访问修饰符（公共、私有、内部或受保护）的类声明节点。'
- en: '[PRE4]'
  id: totrans-48
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Then it invokes the `ReplaceNodes` API on the root syntax node to replace each
    such class declaration with an updated node returned by the `AddModifier` helper.
    This helper adds a new internal modifier at the start of the current modifier
    list of the class declaration. It also takes care of moving any existing leading
    trivia of the class declaration to the new modifier and adds a whitespace trivia
    after the new modifier:'
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它对根语法节点调用 `ReplaceNodes` API，用 `AddModifier` 辅助函数返回的更新节点替换每个此类声明。此辅助函数在类声明的当前修饰符列表开头添加一个新的内部修饰符。它还负责将类声明的任何现有前导杂注移动到新修饰符，并在新修饰符后添加一个空白杂注：
- en: '[PRE5]'
  id: totrans-50
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: The `AddDocCommentsToClassDeclarations` method walks the descendant nodes of
    the root to find all class declaration nodes whose modifier list has a public
    accessibility modifier and its first token has no leading documentation comment
    trivia.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddDocCommentsToClassDeclarations` 方法遍历根节点的后代节点以找到所有修饰符列表具有公共可访问修饰符且其第一个标记没有前导文档注释杂注的类声明节点。'
- en: '[PRE6]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: Then, it invokes the `ReplaceNode`*s* API on the root syntax node to replace
    each such class declaration with an updated node returned by the `AddDocumentationComment`
    helper. This helper creates an XML summary element with a `TODO` comment and creates
    a single line documentation comment with this stub summary element and adds this
    at end of the current leading trivia for the class declaration.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它对根语法节点调用 `ReplaceNode`*s* API，用 `AddDocumentationComment` 辅助函数返回的更新节点替换每个此类声明。此辅助函数创建一个带有
    `TODO` 注释的 XML 摘要元素，并创建一个单行文档注释，包含此存根摘要元素，并将其添加到类声明的当前前导杂注的末尾。
- en: '[PRE7]'
  id: totrans-54
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: The `RemoveEmptyClassDeclarations` method walks the descendant nodes of the
    root to find all class declaration nodes which have no members declarations (methods,
    fields, nested types, and so on) and then invokes the `ReplaceNodes` API on the
    root syntax node to remove all such declarations.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveEmptyClassDeclarations` 方法遍历根节点的后代节点以找到所有没有成员声明（方法、字段、嵌套类型等）的类声明节点，然后对根语法节点调用
    `ReplaceNodes` API 来删除所有此类声明。'
- en: '[PRE8]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Writing an application based on the Compiler Semantic API to display diagnostics
    and overload resolution results
  id: totrans-57
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于编译器语义 API 编写应用程序以显示诊断和重载解析结果
- en: 'In this section, we will write a C# console application based on Roslyn Compiler
    APIs to create a compilation from the given source file and then perform the following
    semantic analyses:'
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个基于 Roslyn 编译器 API 的 C# 控制台应用程序，从给定的源文件创建编译，然后执行以下语义分析：
- en: Compute and display the compilation diagnostics that would be produced by the
    C# compiler if the file were to be compiled.
  id: totrans-59
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算并显示如果文件被编译，C# 编译器将生成的编译诊断信息。
- en: 'Compute the symbol info for each invocation (method call) in the source file
    and display the following semantic information for each call:'
  id: totrans-60
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 计算源文件中每个调用（方法调用）的符号信息，并显示每个调用以下语义信息：
- en: 'Overload resolution result ([https://msdn.microsoft.com/en-us/library/aa691336(v=vs.71).aspx](https://msdn.microsoft.com/en-us/library/aa691336(v=vs.71).aspx)):
    Success or failure reason.'
  id: totrans-61
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 重载解析结果 ([https://msdn.microsoft.com/en-us/library/aa691336(v=vs.71).aspx](https://msdn.microsoft.com/en-us/library/aa691336(v=vs.71).aspx))：成功或失败的原因。
- en: If overload resolution succeeded, the method symbol bound to the invocation.
  id: totrans-62
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 如果重载解析成功，则将方法符号绑定到调用。
- en: Otherwise, if overload resolution failed and we have one or more candidate symbols,
    then display each candidate symbol.
  id: totrans-63
  prefs:
  - PREF_IND
  - PREF_OL
  type: TYPE_NORMAL
  zh: 否则，如果重载解析失败并且我们有多个候选符号，则显示每个候选符号。
- en: Getting started
  id: totrans-64
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: You will need to have the Visual Studio 2017 Community Edition installed on
    your machine to execute this recipe. You can install a free Community Edition
    from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的机器上安装 Visual Studio 2017 社区版才能执行此配方。您可以从 [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)
    安装免费的社区版。
- en: How to do it...
  id: totrans-66
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open Visual Studio and create a new C# console application targeting .NET Framework
    4.6 or higher, say `ConsoleApp`*.*
  id: totrans-67
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并创建一个新的 C# 控制台应用程序，目标为 .NET Framework 4.6 或更高版本，例如 `ConsoleApp`*.*。
- en: Install the `Microsoft.CodeAnalysis.CSharp` NuGet package (as of this writing,
    the latest stable version is *2.1.0*). For guidance on how to search and install
    NuGet package to a project, refer to the recipe *Searching and installing analyzers
    through the NuGet package manager* in [Chapter 2](8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml),
    *Consuming Diagnostic Analyzers in .NET Projects*.
  id: totrans-68
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `Microsoft.CodeAnalysis.CSharp` NuGet 包（截至本文写作，最新稳定版本为 *2.1.0*）。有关如何在项目中搜索和安装
    NuGet 包的指导，请参阅第 2 章 *通过 NuGet 包管理器搜索和安装分析器* 中的菜谱 *在 .NET 项目中消费诊断分析器*。
- en: Replace the source code in `Program.cs` with the source code from the attached
    code sample `\ConsoleApp\Program.cs`.
  id: totrans-69
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Program.cs` 中的源代码替换为附带的代码示例中的源代码 `\ConsoleApp\Program.cs`。
- en: Build the project.
  id: totrans-70
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。
- en: Open a Visual Studio developer command prompt, change the directory to the project
    root directory, and execute `bin\Debug\ConsoleApp.exe` with no arguments.
  id: totrans-71
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 开发者命令提示符，将目录更改为项目根目录，然后不带参数执行 `bin\Debug\ConsoleApp.exe`。
- en: 'Verify the output shows incorrect usage: `Usage: ConsoleApp.exe <%file_path%>`.'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '验证输出显示不正确的用法：`Usage: ConsoleApp.exe <%file_path%>`。'
- en: 'Create a text file, say `test.cs`, with the following code at the project root
    directory:'
  id: totrans-73
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在项目根目录中创建一个文本文件，例如 `test.cs`，包含以下代码：
- en: '[PRE9]'
  id: totrans-74
  prefs: []
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Now, execute the application with `test.cs` as the argument: `bin\Debug\ConsoleApp.exe
    test.cs`.'
  id: totrans-75
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用 `test.cs` 作为参数执行应用程序：`bin\Debug\ConsoleApp.exe test.cs`。
- en: 'Verify the expected diagnostics and invocation semantics with overload resolution
    results are displayed in the output:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证预期的诊断和重载解析结果显示在输出中：
- en: '![](img/b7728e2d-18de-47de-885a-3ea256bb3819.png)'
  id: totrans-77
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/b7728e2d-18de-47de-885a-3ea256bb3819.png)'
- en: How it works...
  id: totrans-78
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何工作...
- en: 'In this recipe, we wrote a C# console application based on the Roslyn Compiler
    API to create a compilation and analyze and display the diagnostics and overload
    resolution semantics for invocation expressions. These operations are very similar
    to what a C# compiler would do when compiling the source code. Let''s walk through
    the code and understand how we implemented these operations:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们基于 Roslyn 编译器 API 编写了一个 C# 控制台应用程序，用于创建编译、分析和显示调用表达式的诊断和重载解析语义。这些操作与
    C# 编译器在编译源代码时所做的操作非常相似。让我们逐行分析代码，了解我们是如何实现这些操作的：
- en: '[PRE10]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'The Main method invokes individual methods to perform the following operations:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: Main 方法调用单个方法执行以下操作：
- en: '`ParseArguments` to scan for the input file to parse and transform.'
  id: totrans-82
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParseArguments` 用于扫描要解析和转换的输入文件。'
- en: '`CreateCompilation` to create a C# compilation from a parsed syntax tree created
    with the text from this source file.'
  id: totrans-83
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `CreateCompilation` 从此源文件中的文本创建的解析语法树创建 C# 编译。
- en: '`DisplayDiagnostics` to compute the compiler diagnostics and then display them.'
  id: totrans-84
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DisplayDiagnostics` 计算编译器诊断，然后显示它们。
- en: '`DisplayInvocations` to analyze each invocation (method call) in a syntax tree
    and display the overload resolution result and bound symbols.'
  id: totrans-85
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用 `DisplayInvocations` 分析语法树中的每个调用（方法调用）并显示重载解析结果和绑定符号。
- en: Implementation of `ParseArguments` is identical to the one in the previous recipe,
    *Writing an application based on Compiler Syntax API to parse and transform source
    files.* Refer to the *How it works...*, section of that recipe for further explanation
    on this method.
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseArguments` 的实现与之前的菜谱 *基于编译器语法 API 编写解析和转换源文件的程序* 中的实现相同。有关此方法的进一步解释，请参阅该菜谱的
    *如何工作...* 部分。'
- en: 'The `CreateCompilation` method first reads the file contents from the input
    file and parses it using the parsing API `CSharpSyntaxTree.ParseText`. Then, it
    creates a metadata reference for the system assembly (corlib) using the location
    of the assembly containing the object type. It creates compilation options with
    output kind `DynamicallyLinkedLibrary` (`.dll`) and uses these inputs to create
    a C# compilation:'
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: '`CreateCompilation` 方法首先从输入文件中读取文件内容，并使用解析 API `CSharpSyntaxTree.ParseText`
    进行解析。然后，它使用包含对象类型的程序集的位置为系统程序集（corlib）创建元数据引用。它创建输出类型为 `DynamicallyLinkedLibrary`（`.dll`）的编译选项，并使用这些输入创建
    C# 编译：'
- en: '[PRE11]'
  id: totrans-88
  prefs: []
  type: TYPE_PRE
  zh: '[PRE11]'
- en: The `DisplayDiagnostics` method computes the compilation diagnostics using the
    `Compilation.GetDiagnostics` API and then displays the diagnostic count and string
    representation of each diagnostic.
  id: totrans-89
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisplayDiagnostics` 方法使用 `Compilation.GetDiagnostics` API 计算编译器诊断，然后显示每个诊断的数量和字符串表示形式。'
- en: '[PRE12]'
  id: totrans-90
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: 'The `DisplayInvocations` method first gets the semantic model for the syntax
    tree in the compilation. Then, it iterates over the descendant nodes of the root
    to get all `InvocationExpressionSyntax` nodes. For each such invocation, it queries
    the symbol info of the expression from the semantic model. The symbol info contains
    information about the semantics of the invocation. We display the overload resolution
    success/fail result based on whether or not the candidate reason is `CandidateReason.None`.
    Then, we display the bound symbol or candidate symbols for the success and failure
    cases, respectively:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisplayInvocations` 方法首先获取编译中的语法树的语义模型。然后，它遍历根的子节点以获取所有 `InvocationExpressionSyntax`
    节点。对于每个这样的调用，它从语义模型中查询表达式的符号信息。符号信息包含有关调用语义的信息。我们根据候选原因是否为 `CandidateReason.None`
    来显示重载解析成功/失败结果。然后，我们分别显示成功和失败情况下的绑定符号或候选符号：'
- en: '[PRE13]'
  id: totrans-92
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: Writing an application based on the Compiler Analyzer API to execute diagnostic
    analyzers and display analyzer diagnostics
  id: totrans-93
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 基于编译器分析器 API 编写应用程序以执行诊断分析器和显示分析器诊断
- en: In this section, we will write a C# console application based on Roslyn Compiler
    APIs that loads the given analyzer assembly, executes all diagnostic analyzers
    defined in this assembly on a given source file, and outputs all the reported
    analyzer diagnostics.
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将编写一个基于 Roslyn 编译器 API 的 C# 控制台应用程序，该程序加载给定的分析器程序集，在给定的源文件上执行该程序集中定义的所有诊断分析器，并输出所有报告的分析器诊断。
- en: Getting started
  id: totrans-95
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 入门
- en: You will need to have the Visual Studio 2017 Community Edition installed on
    your machine to execute this recipe. You can install a free Community Edition
    from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 您需要在您的机器上安装 Visual Studio 2017 社区版才能执行此配方。您可以从 [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15)
    安装免费的社区版。
- en: How to do it...
  id: totrans-97
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何操作...
- en: Open Visual Studio and create a new C# console application targeting .NET Framework
    4.6 or higher, say `ConsoleApp`.
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并创建一个新的针对 .NET Framework 4.6 或更高版本的 C# 控制台应用程序，例如 `ConsoleApp`。
- en: Install the `Microsoft.CodeAnalysis.CSharp` NuGet package (as of this writing,
    the latest stable version is *2.1.0*). For guidance on how to search and install
    the NuGet package to a project, refer to the recipe *Searching and installing
    analyzers through the NuGet package manager* in [Chapter 2](8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml),
    *Consuming Diagnostic Analyzers in .NET Projects*.
  id: totrans-99
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `Microsoft.CodeAnalysis.CSharp` NuGet 包（截至本文撰写时，最新稳定版本为 *2.1.0*）。有关如何在项目中搜索和安装
    NuGet 包的指导，请参阅第 2 章 *在 .NET 项目中消费诊断分析器* 中的配方 *通过 NuGet 包管理器搜索和安装分析器*。
- en: Replace the source code in `Program.cs` with the source code from the attached
    code sample `\ConsoleApp\Program.cs`.
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Program.cs` 中的源代码替换为附带的代码示例中的源代码 `\ConsoleApp\Program.cs`。
- en: Add a C# class library project targeting .NET Framework 4.6 or higher to the
    solution, say *Analyzer.*
  id: totrans-101
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将一个针对 .NET Framework 4.6 或更高版本的 C# 类库项目添加到解决方案中，例如 *Analyzer*。
- en: Install the `Microsoft.CodeAnalysis` NuGet package to this project (as of this
    writing, the latest stable version is *2.1.0*).
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Microsoft.CodeAnalysis` NuGet 包安装到该项目中（截至本文撰写时，最新稳定版本为 *2.1.0*）。
- en: Replace the source code in `Class1.cs` with the diagnostic analyzer source code
    from the attached code sample `\Analyzer\Class1.cs`. This file contains the code
    for the default symbol analyzer that reports a diagnostic for type names containing
    any lowercase characters.
  id: totrans-103
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Class1.cs` 中的源代码替换为附带的代码示例 `\Analyzer\Class1.cs` 中的诊断分析器源代码。此文件包含用于报告包含任何小写字母的类型名称的诊断的默认符号分析器的代码。
- en: Build the solution.
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建解决方案。
- en: Open a Visual Studio developer command prompt, change the directory to the project
    root directory of `ConsoleApp`, and execute `bin\Debug\ConsoleApp.exe` with no
    arguments.
  id: totrans-105
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 开发者命令提示符，将目录更改为 `ConsoleApp` 的项目根目录，并使用无参数执行 `bin\Debug\ConsoleApp.exe`。
- en: 'Verify the output shows incorrect usage: `Usage: ConsoleApp.exe <%analyzer_file_path%>
    <%source_file_path%>`.'
  id: totrans-106
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证输出显示不正确的用法：`用法：ConsoleApp.exe <%analyzer_file_path%> <%source_file_path%>`。
- en: 'Create a text file, say `test.cs`, at the project root directory of `ConsoleApp`
    with the following code:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `ConsoleApp` 的项目根目录中创建一个文本文件，例如 `test.cs`，并包含以下代码：
- en: '[PRE14]'
  id: totrans-108
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, execute the application with a relative path to analyzer assembly and
    `test.cs` as the arguments: `bin\Debug\ConsoleApp.exe ..\..\..\Analyzer\bin\Debug\Analyzer.dll
    test.cs`.'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'Verify that the expected analyzer diagnostics are displayed in the output:'
  id: totrans-110
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: '[PRE15]'
  id: totrans-111
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: How it works...
  id: totrans-112
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this recipe, we wrote a C# console application based on the Roslyn Compiler
    API to load and execute diagnostic analyzers from an analyzer assembly and report
    the diagnostics reported by the analyzers. These operations are very similar to
    what the C# compiler would do when you compile source files with `/analyzer:<%analyzer_file_path%>`
    command line switch. Let''s walk through the code and understand how we implemented
    these operations:'
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  id: totrans-114
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'The Main method invokes individual methods to perform the following operations:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
- en: '`ParseArguments` to scan for:'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Analyzer assembly file.
  id: totrans-117
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Input source file on which the analyzers will be executed.
  id: totrans-118
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCompilation` to create a C# compilation from parsed syntax tree created
    with the text from the input source file.'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`CreateCompilationWithAnalyzers` to create a compilation instance with diagnostic
    analyzers from the given analyzer assembly file attached to it.'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`DisplayAnalyzerDiagnostics` to execute the analyzers to compute the analyzer
    diagnostics and then display them.'
  id: totrans-121
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Implementation of `ParseArguments` and `CreateCompilation` is identical to the
    one in the previous recipe, *Writing an application based on Compiler Syntax API
    to parse and transform source files.* Refer to the *How it works...*, section
    of that recipe for further explanation on these methods.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
- en: 'The `CreateCompilationWithAnalyzers` method takes the compilation and the analyzer
    assembly as the parameters:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: First, it creates `AnalyzerFileReference` ([http://source.roslyn.io/#q=AnalyzerFileReference](http://source.roslyn.io/#q=AnalyzerFileReference))
    with the analyzer file path and an instance of the analyzer assembly loader (`IAnalyzerAssemblyLoader`
    - details later in the section ([http://source.roslyn.io/#q=IAnalyzerAssemblyLoader](http://source.roslyn.io/#q=IAnalyzerAssemblyLoader))).
    It invokes the `AnalyzerReference.GetAnalyzers` API ([http://source.roslyn.io/#q=AnalyzerReference.GetAnalyzers](http://source.roslyn.io/#q=AnalyzerReference.GetAnalyzers))
    on this analyzer file reference to load the analyzer assembly with the given analyzer
    assembly loader, and then create instances of the diagnostic analyzers defined
    in this assembly.
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
- en: 'It creates a default set of `CompilationWithAnalyzersOptions` ([http://source.roslyn.io/#q=CompilationWithAnalyzersOptions](http://source.roslyn.io/#q=CompilationWithAnalyzersOptions))
    for configuring the analyzer execution. The possible options include:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
- en: '`AnalyzerOptions`: Analyzer options contain the set of additional non-source
    text files that are passed to the analyzers. In this recipe, we use an empty set.
    You can read more about additional files at [https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md).'
  id: totrans-127
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AnalyzerOptions`：分析器选项包含传递给分析器的额外非源文本文件集。在这个配方中，我们使用一个空集。您可以在[https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md](https://github.com/dotnet/roslyn/blob/master/docs/analyzers/Using%20Additional%20Files.md)中了解更多关于额外文件的信息。'
- en: '`onAnalyzerException` delegate: Delegate to be invoked when an analyzer throws
    an exception. In this recipe, we just re-throw this exception.'
  id: totrans-128
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`onAnalyzerException`委托：当分析器抛出异常时将被调用的委托。在这个配方中，我们只是重新抛出这个异常。'
- en: '`concurrentAnalysis`: Flag to control whether the analyzers should be run concurrently
    or not. In this recipe, we default this to false.'
  id: totrans-129
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`concurrentAnalysis`：控制分析器是否应该并发运行的标志。在这个配方中，我们默认设置为false。'
- en: '`logAnalyzerExecutionTime`: Flag to control whether the relative execution
    times for each analyzer should be tracked. If set to true, then this data can
    be requested for each analyzer using the public API `CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync`
    ([http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync](http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync)).
    This returns an `AnalyzerTelemetryInfo`, which has a property named `ExecutionTime`
    (`http://source.roslyn.io/#q=AnalyzerTelemetryInfo.ExecutionTime`). In this recipe,
    we default this to false.'
  id: totrans-130
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`logAnalyzerExecutionTime`：控制是否应该跟踪每个分析器的相对执行时间。如果设置为true，则可以通过公共API `CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync`
    ([http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync](http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalyzerTelemetryInfoAsync))
    获取每个分析器的这些数据。这返回一个`AnalyzerTelemetryInfo`，它有一个名为`ExecutionTime`（`http://source.roslyn.io/#q=AnalyzerTelemetryInfo.ExecutionTime`）的属性。在这个配方中，我们默认设置为false。'
- en: Finally, the method creates and returns a `CompilationWithAnalyzers` ([http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/CompilationWithAnalyzers.cs,7efdf3edc21e904a](http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/CompilationWithAnalyzers.cs,7efdf3edc21e904a))
    instance with the given compilation, analyzer file reference, and options.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，该方法创建并返回一个具有给定编译、分析器文件引用和选项的`CompilationWithAnalyzers` ([http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/CompilationWithAnalyzers.cs,7efdf3edc21e904a](http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/CompilationWithAnalyzers.cs,7efdf3edc21e904a))
    实例。
- en: 'We briefly mentioned our custom `AnalyzerAssemblyLoader` passed into the `AnalyzerFileReference`
    constructor above. It is implemented in our code as follows:'
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 我们简要提到了上面传递给`AnalyzerFileReference`构造函数的我们的自定义`AnalyzerAssemblyLoader`。它在我们的代码中实现如下：
- en: '[PRE18]'
  id: totrans-133
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: This analyzer assembly loader handles loading the analyzer assembly using the
    .NET APIs for assembly loading on the executing platform. In this recipe, we use
    .NET Framework API `Assembly.LoadFrom` ([https://msdn.microsoft.com/en-us/library/system.reflection.assembly.loadfrom(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.reflection.assembly.loadfrom(v=vs.110).aspx))
    to load the assembly from the given path.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: 这个分析器程序集加载器处理使用执行平台上的.NET API进行程序集加载来加载分析器程序集。在这个配方中，我们使用.NET Framework API
    `Assembly.LoadFrom` ([https://msdn.microsoft.com/en-us/library/system.reflection.assembly.loadfrom(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.reflection.assembly.loadfrom(v=vs.110).aspx))
    从给定路径加载程序集。
- en: We ignore the callbacks to add analyzer dependency locations in our custom `AnalyzerAssemblyLoader`,
    as our test analyzer assembly has no dependencies. We can enhance this assembly
    loader to track these locations and handle assembly loading for dependencies.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的自定义`AnalyzerAssemblyLoader`中，我们忽略了添加分析器依赖位置的反调，因为我们的测试分析器程序集没有依赖项。我们可以增强这个程序集加载器以跟踪这些位置并处理依赖项的加载。
- en: '`DisplayAnalyzerDiagnostics` takes the `CompilationWithAnalyzers` instance
    created earlier and executes the analyzers on the underlying compilation using
    `GetAnalyzerDiagnosticsAsync` API. It then walks through all the analyzer diagnostics
    and outputs the message for each diagnostic, with the line and column information:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisplayAnalyzerDiagnostics`接受之前创建的`CompilationWithAnalyzers`实例，并使用`GetAnalyzerDiagnosticsAsync`
    API在底层编译上执行分析器。然后它遍历所有分析器诊断，并为每个诊断输出消息，包括行和列信息：'
- en: '[PRE19]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: You can invoke the `CompilationWithAnalyzers.GetAnalysisResultAsync` ([http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalysisResultAsync](http://source.roslyn.io/#q=CompilationWithAnalyzers.GetAnalysisResultAsync))
    public API to get a more fine-grained view of the analysis results. The returned
    `AnalysisResult` ([http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/AnalysisResult.cs,86a401660972cfb8](http://source.roslyn.io/#Microsoft.CodeAnalysis/DiagnosticAnalyzer/AnalysisResult.cs,86a401660972cfb8))
    allows you to get separate syntax, semantic, and compilations diagnostics reported
    by each diagnostic analyzer and also allows you to get the analyzer telemetry
    info for each analyzer.
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
- en: Writing an application based on the Workspaces API to format and simplify all
    source files in the solution
  id: totrans-139
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will write a C# console application based on Roslyn Workspaces
    APIs to load a C# solution into a workspace and then perform the following operations:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
- en: Format the solution to change tabs to white spaces with a custom indentation
    size. This is a syntactic code refactoring.
  id: totrans-141
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Simplify the solution to change local declarations to have an explicit type
    specification instead of var. This is a semantic code refactoring.
  id: totrans-142
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'You can read the XML documentation comments and implementation details for
    the Formatter and Simplifier for additional information on these operations at:
    [http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Formatting/Formatter.cs,f445ffe3c814c002](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Formatting/Formatter.cs,f445ffe3c814c002)
    and [http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Simplification/Simplifier.cs,1d256ae3815b1cac](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Simplification/Simplifier.cs,1d256ae3815b1cac),
    respectively.'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-144
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have the Visual Studio 2017 Community Edition installed on
    your machine to execute this recipe. You can install a free Community Edition
    from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-146
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Open Visual Studio and create a new C# console application targeting .NET Framework
    4.6 or higher, say `ConsoleApp`*.*
  id: totrans-147
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Install the `Microsoft.CodeAnalysis.CSharp.Workspaces` NuGet package (as of
    this writing, the latest stable version is *2.1.0*). For guidance on how to search
    and install NuGet package to a project, refer to the recipe *Searching and installing
    analyzers through the NuGet package manager* in [Chapter 2](8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml),
    *Consuming Diagnostic Analyzers in .NET Projects*.
  id: totrans-148
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Replace the source code in `Program.cs` with the source code from the attached
    code sample `\ConsoleApp\Program.cs`.
  id: totrans-149
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the project.
  id: totrans-150
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Open a Visual Studio developer command prompt, change the directory to the project
    root directory and execute `bin\Debug\ConsoleApp.exe` with no arguments.
  id: totrans-151
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 开发者命令提示符，切换到项目根目录，并使用无参数执行 `bin\Debug\ConsoleApp.exe`。
- en: 'Verify the output shows incorrect usage: `Usage: ConsoleApp.exe <%solution_file_path%>`.'
  id: totrans-152
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '验证输出显示使用错误：`Usage: ConsoleApp.exe <%solution_file_path%>`。'
- en: 'Create a new C# console application, say `TestSolution`, and add one implicitly
    typed and one explicitly typed local declaration to the `Main` method (note the
    indent size of 4):'
  id: totrans-153
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 控制台应用程序，例如 `TestSolution`，并在 `Main` 方法中添加一个隐式声明的局部变量和一个显式声明的局部变量（注意缩进大小为
    4）：
- en: '![](img/1b8bc391-7f99-4ca0-b91a-82bcc557c9c2.png)'
  id: totrans-154
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/1b8bc391-7f99-4ca0-b91a-82bcc557c9c2.png)'
- en: 'Now, execute the application with full path to `TestSolution.sln` as the argument:
    `bin\Debug\ConsoleApp.exe <%test_solution_path%>`.'
  id: totrans-155
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，使用完整路径 `TestSolution.sln` 作为参数执行应用程序：`bin\Debug\ConsoleApp.exe <%test_solution_path%>`。
- en: 'Verify the console output:'
  id: totrans-156
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证控制台输出：
- en: '[PRE20]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Verify the new contents of the source file in *TestSolution now* has an indent
    size of 2 and no explicitly typed local declarations:'
  id: totrans-158
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在验证 *TestSolution* 中的源文件新内容缩进大小为 2，并且没有显式声明的局部变量：
- en: '![](img/0e2b2aff-adf2-42a0-ab4d-e40859a988b9.png)'
  id: totrans-159
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/0e2b2aff-adf2-42a0-ab4d-e40859a988b9.png)'
- en: How it works...
  id: totrans-160
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we wrote a C# console application based on Roslyn Workspaces
    API to format and simplify all the source files in a solution. These operations
    are very similar to what a Visual Studio IDE would do when you apply formatting
    and simplification quick fixes after setting the corresponding tools options.
    Let''s walk through the code and understand how we implemented these operations:'
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们基于 Roslyn 工作区 API 编写了一个 C# 控制台应用程序，用于格式化和简化解决方案中的所有源文件。这些操作与在设置相应的工具选项后应用格式化和简化快速修复时
    Visual Studio IDE 会执行的操作非常相似。让我们通过代码来了解我们是如何实现这些操作的：
- en: '[PRE21]'
  id: totrans-162
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Main` method invokes individual methods to perform the following operations:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法调用单个方法执行以下操作：'
- en: '`ParseArguments`: To scan for the input file to parse and transform.'
  id: totrans-164
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParseArguments`：扫描要解析和转换的输入文件。'
- en: '`MSBuildWorkspace.Create`: To create a workspace and `Workspace.OpenSolutionAsync`
    to load the given solution in the workspace.'
  id: totrans-165
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSBuildWorkspace.Create`：创建工作区，`Workspace.OpenSolutionAsync`：将给定的解决方案加载到工作区中。'
- en: '`FormatSolution`: To format all the documents in the solution.'
  id: totrans-166
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormatSolution`：格式化解决方案中的所有文档。'
- en: '`SimplifySolution`: To simplify all the documents in the solution.'
  id: totrans-167
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`SimplifySolution`：简化解决方案中的所有文档。'
- en: '`ApplyChanges`: To apply the formatting and simplification changes to the workspace
    and persist these to the disk.'
  id: totrans-168
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ApplyChanges`：将格式化和简化更改应用到工作区，并将这些更改持久化到磁盘。'
- en: Implementation of `ParseArguments` is identical to the one in the recipe, *Writing
    an application based on Compiler Syntax API to parse and transform source files.*
    Refer to the *How it works...*, section of that recipe for further explanation
    on this method.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseArguments` 的实现与菜谱中的实现相同，*基于编译器语法 API 编写解析和转换源文件的程序.* 请参阅该菜谱的 *如何工作...*
    部分，以获取关于此方法的进一步说明。'
- en: '`MSBuildWorkspace` ([http://source.roslyn.io/#q=MSBuildWorkspace](http://source.roslyn.io/#q=MSBuildWorkspace))
    is a custom implementation of the core Roslyn Workspace, which uses the MSBuild
    ([https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild))
    project model for loading the solution/project files and allows reading and writing
    individual documents in the projects.'
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSBuildWorkspace` ([http://source.roslyn.io/#q=MSBuildWorkspace](http://source.roslyn.io/#q=MSBuildWorkspace))
    是 Roslyn 工作区核心的定制实现，它使用 MSBuild ([https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild](https://docs.microsoft.com/en-us/visualstudio/msbuild/msbuild))
    项目模型来加载解决方案/项目文件，并允许在项目中读取和写入单个文档。'
- en: 'The `FormatSolution` method formats all documents in the solution. First, it
    modifies the options to prefer whitespace over tabs, with an indentation size
    of 2 (default is 4):'
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: '`FormatSolution` 方法格式化解决方案中的所有文档。首先，它修改选项以优先使用空格而不是制表符，缩进大小为 2（默认为 4）：'
- en: '`FormattingOptions.UseTabs`: Value set to `false`.'
  id: totrans-172
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormattingOptions.UseTabs`：值设置为 `false`。'
- en: '`FormattingOptions.IndentationSize`: Value set to `2`.'
  id: totrans-173
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`FormattingOptions.IndentationSize`：值设置为 `2`。'
- en: '[PRE22]'
  id: totrans-174
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'It keeps track of the current solution snapshot in `newSolution`*,* which is
    initialized to `originalSolution`. It then iterates over all the documents in
    the solution and does the following:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 它跟踪当前解决方案快照在 `newSolution`*，*，该快照初始化为 `originalSolution`。然后它遍历解决方案中的所有文档，并执行以下操作：
- en: Format the document by invoking `Formatter.FormatAsync` public API ([http://source.roslyn.io/#q=Formatter.FormatAsync](http://source.roslyn.io/#q=Formatter.FormatAsync))
    with the current document and options.
  id: totrans-176
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Update `newSolution` to point to the solution of the formatted `newDocument`.
  id: totrans-177
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Note how we can't simply iterate over `originalSolution.Projects` or `project.Documents`
    because it will return objects from the unmodified `originalSolution`, not from
    the `newSolution`. We need to use the `ProjectId`/`DocumentIds` (that don't change)
    to look up the corresponding snapshots in the `newSolution`.
  id: totrans-178
  prefs: []
  type: TYPE_NORMAL
- en: Finally, it returns the `newSolution` after all documents have been formatted.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
- en: 'The `SimplifySolution` method simplifies all documents in the solution. First,
    it modifies the options to prefer implicitly type local declaration, that is,
    user `var` over explicit type specification, by setting `SimplificationOptions.PreferImplicitTypeInLocalDeclaration`
    to `true`:'
  id: totrans-180
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  id: totrans-181
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: '`SimplifySolution` has very identical implementation to the `FormatSolution`
    method for iterating the documents, simplifying them by invoking `Simplifier.ReduceAsync`
    public API ([http://source.roslyn.io/#q=Simplifier.ReduceAsync](http://source.roslyn.io/#q=Simplifier.ReduceAsync)),
    storing the latest snapshot in `newSolution` after processing each document, and
    finally returning the new solution snapshot at the end. It has one important difference
    though. `Simplifier.ReduceAsync` only processes nodes with a special syntax annotation:
    `Simplifier.Annotation` ([http://source.roslyn.io/#q=Simplifier.Annotation](http://source.roslyn.io/#q=Simplifier.Annotation)).
    Hence, before invoking this API, we add this syntax annotation to the root of
    the document.'
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ApplyChanges` method invokes the `Workspace.TryApplyChanges` public API
    ([http://source.roslyn.io/#q=Workspace.TryApplyChanges](http://source.roslyn.io/#q=Workspace.TryApplyChanges))
    with the new solution snapshot to apply the changes in the solution snapshot to
    the workspace. This also causes the `MSBuildWorkspace` to persist these changes
    onto the disk:'
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  id: totrans-184
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: Writing an application based on the Workspaces API to edit projects in a solution
    and display project properties
  id: totrans-185
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'In this section, we will write a C# console application based on Roslyn Workspaces
    APIs to load a C# solution into a workspace and then perform the following operations:'
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
- en: Display project properties such as project file path, output file path, project
    language, assembly name, reference count, document count, and so on.
  id: totrans-187
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Add a new project to the solution.
  id: totrans-188
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Remove an existing project from the solution.
  id: totrans-189
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Edit project to add a project reference.
  id: totrans-190
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Getting started
  id: totrans-191
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You will need to have the Visual Studio 2017 Community Edition installed on
    your machine to execute this recipe. You can install a free Community Edition
    from [https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15](https://www.visualstudio.com/thank-you-downloading-visual-studio/?sku=Community&rel=15).
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
- en: How to do it...
  id: totrans-193
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 如何做到这一点...
- en: Open Visual Studio and create a new C# console application targeting the .NET
    Framework 4.6 or higher, say `ConsoleApp`*.*
  id: totrans-194
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 并创建一个新的以 .NET Framework 4.6 或更高版本为目标平台的 C# 控制台应用程序，例如 `ConsoleApp`*.*
- en: Install the `Microsoft.CodeAnalysis.CSharp.Workspaces` NuGet package (as of
    this writing, the latest stable version is *2.1.0*). For guidance on how to search
    and install the NuGet package to a project, refer to the recipe *Searching and
    installing analyzers through the NuGet package manager* in [Chapter 2](8e0229af-657f-4306-96b5-40511d1fe7b2.xhtml),
    *Consuming Diagnostic Analyzers in .NET Projects*.
  id: totrans-195
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 安装 `Microsoft.CodeAnalysis.CSharp.Workspaces` NuGet 包（截至本文写作，最新稳定版本是 *2.1.0*）。有关如何在项目中搜索和安装
    NuGet 包的指导，请参阅第 2 章 *通过 NuGet 包管理器搜索和安装分析器* 中的菜谱 *在 .NET 项目中消费诊断分析器*。
- en: Replace the source code in `Program.cs` with the source code from the attached
    code sample `\ConsoleApp\Program.cs`.
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将 `Program.cs` 中的源代码替换为附带的代码示例 `\ConsoleApp\Program.cs` 中的源代码。
- en: Build the project.
  id: totrans-197
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 构建项目。
- en: Open a Visual Studio developer command prompt, change the directory to the project
    root directory, and execute `bin\Debug\ConsoleApp.exe` with no arguments.
  id: totrans-198
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 打开 Visual Studio 开发者命令提示符，将目录更改为项目根目录，并执行 `bin\Debug\ConsoleApp.exe`，不带任何参数。
- en: 'Verify the output shows incorrect usage: `Usage: ConsoleApp.exe <%solution_file_path%>`.'
  id: totrans-199
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: '验证输出显示使用不正确：`Usage: ConsoleApp.exe <%solution_file_path%>`.'
- en: 'Create a new C# class library solution, say `TestSolution`, and add one more
    class library project, say `ClassLibrary`*,* to the solution. Now, execute the
    application with full path to `TestSolution.sln` as the argument: `bin\Debug\ConsoleApp.exe
    <%test_solution_path%>`.'
  id: totrans-200
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个新的 C# 类库解决方案，例如 `TestSolution`，并将另一个类库项目，例如 `ClassLibrary`*，* 添加到解决方案中。现在，使用
    `TestSolution.sln` 的完整路径作为参数执行应用程序：`bin\Debug\ConsoleApp.exe <%test_solution_path%>`。
- en: 'Verify the console output shows the project properties for the initial solution
    with two projects, `TestSolution` and `ClassLibrary`:'
  id: totrans-201
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 验证控制台输出显示初始解决方案的两个项目 `TestSolution` 和 `ClassLibrary` 的项目属性：
- en: '![](img/eaea8ea5-56ce-4166-98b9-d7d6e5c28e46.png)'
  id: totrans-202
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/eaea8ea5-56ce-4166-98b9-d7d6e5c28e46.png)'
- en: 'Press any key to continue and note the following operations were performed:
    add project to solution, remove project from solution, and edit existing project
    (add project reference).'
  id: totrans-203
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按任意键继续并注意以下操作已执行：将项目添加到解决方案中，从解决方案中移除项目，以及编辑现有项目（添加项目引用）。
- en: '![](img/cbd48de2-5839-486a-8b70-5e7f7a908c6c.png)'
  id: totrans-204
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/cbd48de2-5839-486a-8b70-5e7f7a908c6c.png)'
- en: 'Press any key to continue and verify the solution now contains two projects
    `TestSolution` and `AddedClassLibrary`, and there is a project reference from
    `AddedClassLibrary` to `TestSolution`:'
  id: totrans-205
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 按任意键继续并验证解决方案现在包含两个项目 `TestSolution` 和 `AddedClassLibrary`，并且从 `AddedClassLibrary`
    到 `TestSolution` 存在一个项目引用：
- en: '![](img/ab01e219-8de4-4753-9aae-897a207e462d.png)'
  id: totrans-206
  prefs: []
  type: TYPE_IMG
  zh: '![图片](img/ab01e219-8de4-4753-9aae-897a207e462d.png)'
- en: How it works...
  id: totrans-207
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 它是如何工作的...
- en: 'In this recipe, we wrote a C# console application based on Roslyn Workspaces
    API to perform various operations on a projects in a solution: add, remove, edit,
    and display project properties. The rich Workspaces APIs provide you with a powerful
    object model for analyzing and editing projects and documents in a solution. Let''s
    walk through the code and understand how we implemented these operations:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个菜谱中，我们编写了一个基于 Roslyn Workspaces API 的 C# 控制台应用程序，以在解决方案中的项目上执行各种操作：添加、移除、编辑和显示项目属性。丰富的
    Workspaces API 为您提供了一个强大的对象模型，用于分析和编辑解决方案中的项目和文档。让我们通过代码了解我们如何实现这些操作：
- en: '[PRE25]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'The Main method invokes individual methods to perform the following operations:'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: '`Main` 方法调用单个方法以执行以下操作：'
- en: '`ParseArguments`: To scan for the input file to parse and transform'
  id: totrans-211
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`ParseArguments`：用于扫描要解析和转换的输入文件'
- en: '`MSBuildWorkspace.Create`: To create a workspace and `Workspace.OpenSolutionAsync`
    to load the given solution in the workspace'
  id: totrans-212
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`MSBuildWorkspace.Create`：用于创建工作区，`Workspace.OpenSolutionAsync` 用于在工作区中加载给定的解决方案'
- en: '`DisplayProjectProperties`: To display common properties for all projects in
    a solution.'
  id: totrans-213
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`DisplayProjectProperties`：用于显示解决方案中所有项目的常见属性。'
- en: '`AddProject`: To add a new project to the solution'
  id: totrans-214
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddProject`：用于将新项目添加到解决方案中'
- en: '`RemoveProject`: To remove an existing project from a solution'
  id: totrans-215
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`RemoveProject`：用于从解决方案中移除现有项目'
- en: '`AddProjectReference`: To add a project reference to an existing project in
    a solution'
  id: totrans-216
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`AddProjectReference`：用于向解决方案中的现有项目添加项目引用'
- en: Implementation of `ParseArguments` is identical to the one in the recipe, *Writing
    an application based on Compiler Syntax API to parse and transform source files.*
    Please refer to the *How it works...*, section of that recipe for further explanation
    on this method.
  id: totrans-217
  prefs: []
  type: TYPE_NORMAL
  zh: '`ParseArguments` 的实现与配方中的实现相同，即 *基于 Compiler Syntax API 编写解析和转换源文件的程序*。请参阅该配方中的
    *如何工作...* 部分，以获取关于此方法的进一步解释。'
- en: '`MSBuildWorkspace` ([http://source.roslyn.io/#q=MSBuildWorkspace](http://source.roslyn.io/#q=MSBuildWorkspace))
    is a custom implementation of the core Roslyn Workspace, which uses the MSBuild
    project model for loading the solution/project files, and allows reading and writing
    individual documents in the projects.'
  id: totrans-218
  prefs: []
  type: TYPE_NORMAL
  zh: '`MSBuildWorkspace` ([http://source.roslyn.io/#q=MSBuildWorkspace](http://source.roslyn.io/#q=MSBuildWorkspace))
    是 Roslyn 工作区核心的定制实现，它使用 MSBuild 项目模型来加载解决方案/项目文件，并允许在项目中读取和写入单个文档。'
- en: '`DisplayProjectProperties` displays common project properties such as project
    name, language, assembly name, references, documents, and so on:'
  id: totrans-219
  prefs: []
  type: TYPE_NORMAL
  zh: '`DisplayProjectProperties` 显示常见的项目属性，如项目名称、语言、程序集名称、引用、文档等：'
- en: '[PRE26]'
  id: totrans-220
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'The `AddProject` method creates a barebones `ProjectInfo` ([http://source.roslyn.io/#q=ProjectInfo](http://source.roslyn.io/#q=ProjectInfo))
    with the given `projectName`, a unique Project ID, version stamp, assembly name,
    and C# language name:'
  id: totrans-221
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddProject` 方法创建一个具有给定 `projectName`、唯一项目 ID、版本戳、程序集名称和 C# 语言名称的裸骨 `ProjectInfo`
    ([http://source.roslyn.io/#q=ProjectInfo](http://source.roslyn.io/#q=ProjectInfo))：'
- en: '[PRE27]'
  id: totrans-222
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: It then invokes the `Solution.AddProject` API ([http://source.roslyn.io/#q=Solution.AddProject](http://source.roslyn.io/#q=Solution.AddProject))
    to add a new project with the created project info to the solution.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，它调用 `Solution.AddProject` API ([http://source.roslyn.io/#q=Solution.AddProject](http://source.roslyn.io/#q=Solution.AddProject))
    将创建的项目信息添加到解决方案中。
- en: 'The `RemoveProject` method removes an existing project with the given `projectName`
    from the solution. It uses the `Solution.RemoveProject` API ([http://source.roslyn.io/#q=Solution.RemoveProject](http://source.roslyn.io/#q=Solution.RemoveProject))
    to remove the project:'
  id: totrans-224
  prefs: []
  type: TYPE_NORMAL
  zh: '`RemoveProject` 方法从解决方案中移除具有给定 `projectName` 的现有项目。它使用 `Solution.RemoveProject`
    API ([http://source.roslyn.io/#q=Solution.RemoveProject](http://source.roslyn.io/#q=Solution.RemoveProject))
    来移除项目：'
- en: '[PRE28]'
  id: totrans-225
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: The `AddProjectReference` method adds a project reference from the given `referenceFrom`
    project to the given `referenceTo` project. It searches for existing projects
    in the solution with the given names, creates a `ProjectReference` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Solution/ProjectReference.cs,944b5173649705e4](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Solution/ProjectReference.cs,944b5173649705e4))
    with project ID for the `referenceFrom` project, and uses the `Solution.AddProjectReference`
    ([http://source.roslyn.io/#q=Solution.AddProjectReference](http://source.roslyn.io/#q=Solution.AddProjectReference))
    to add the required reference.
  id: totrans-226
  prefs: []
  type: TYPE_NORMAL
  zh: '`AddProjectReference` 方法从给定的 `referenceFrom` 项目向给定的 `referenceTo` 项目添加项目引用。它搜索解决方案中具有给定名称的现有项目，为
    `referenceFrom` 项目创建一个具有项目 ID 的 `ProjectReference` ([http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Solution/ProjectReference.cs,944b5173649705e4](http://source.roslyn.io/#Microsoft.CodeAnalysis.Workspaces/Workspace/Solution/ProjectReference.cs,944b5173649705e4))，并使用
    `Solution.AddProjectReference` ([http://source.roslyn.io/#q=Solution.AddProjectReference](http://source.roslyn.io/#q=Solution.AddProjectReference))
    来添加所需的引用。'
- en: '[PRE29]'
  id: totrans-227
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
