- en: '7'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '7'
- en: Dependency Injection, Services, and Messaging
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 依赖注入、服务和消息传递
- en: 'As we continue building our *Recipes!* app using .NET MAUI, we want to make
    the most of the MVVM design pattern. MVVM is great for keeping our code organized
    and also promotes industry-standard practices that make our code base more maintainable
    and testable. In this chapter, we will focus on two critical concepts that are
    central to a solid MVVM architecture: **Dependency** **Injection** (**DI**) and
    **messaging**. DI promotes separation of concerns and allows our code to be much
    more testable. Messaging helps us keep different parts of our code from getting
    tangled up with each other. It allows different areas of our app to talk to each
    other in a loosely coupled way. Both concepts are extremely important to ensure
    that our MVVM architecture truly stands out.'
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 随着我们继续使用.NET MAUI构建我们的*Recipes!*应用程序，我们希望充分利用MVVM设计模式。MVVM非常适合保持我们的代码整洁，并促进行业标准实践，使我们的代码库更易于维护和测试。在本章中，我们将重点关注两个对坚实的MVVM架构至关重要的关键概念：**依赖注入**（**DI**）和**消息传递**。DI促进了关注点的分离，并使我们的代码更容易进行测试。消息传递帮助我们保持代码的不同部分不会相互纠缠。它允许应用程序的不同区域以松耦合的方式相互通信。这两个概念对于确保我们的MVVM架构真正突出至关重要。
- en: 'Let’s take a look at what this chapter covers:'
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看本章涵盖了哪些内容：
- en: Inversion of Control through Dependency Injection
  id: totrans-4
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 通过依赖注入实现控制反转
- en: Registering, resolving, and injecting services
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 注册、解析和注入服务
- en: Messaging
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 消息传递
- en: By the end of this chapter, you’ll have a good understanding of these concepts
    as we implement them in our *Recipes!* app. So, let’s go ahead and get into it.
  id: totrans-7
  prefs: []
  type: TYPE_NORMAL
  zh: 到本章结束时，您将对我们如何在*Recipes!*应用程序中实现这些概念有一个很好的理解。那么，让我们继续深入探讨。
- en: Technical requirements
  id: totrans-8
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 技术要求
- en: Throughout this chapter, we will be enhancing the functionality of the *Recipes!*
    app. All the resources, including additional classes and code required for the
    topics covered in this chapter, are available on GitHub at [https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter07](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter07).
    To follow along with this chapter’s content, you can start with the provided `Start`
    folder. It contains the initial code and necessary classes specific to this chapter.
    This code serves as the foundation, building upon what we have learned in the
    previous chapters. If you want to reference or compare the completed code, including
    all the code written throughout this chapter, you can find it in the `Finish`
    folder.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的整个过程中，我们将增强*Recipes!*应用程序的功能。包括本章涵盖的主题所需的所有资源，包括额外的类和代码，都可以在GitHub上找到：[https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter07](https://github.com/PacktPublishing/MVVM-pattern-.NET-MAUI/tree/main/Chapter07)。要跟随本章的内容，您可以从提供的`Start`文件夹开始。它包含本章的初始代码和必要的特定类。此代码作为基础，建立在之前章节学到的内容之上。如果您想参考或比较完成的代码，包括本章编写的所有代码，可以在`Finish`文件夹中找到。
- en: Inversion of Control through Dependency Injection
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 通过依赖注入实现控制反转
- en: '**Inversion of Control** (**IoC**) is a programming principle where the control
    over certain aspects of a program’s flow is handed over from the main code to
    a framework or a container. In simple terms, instead of a component being responsible
    for managing its dependencies and life cycle, these responsibilities are inverted
    or delegated to an external controller. This approach is particularly useful for
    creating modular and flexible systems.'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: '**控制反转**（**IoC**）是一种编程原则，其中程序流程的某些方面的控制权从主代码转移到框架或容器。简单来说，组件不再负责管理其依赖项和生命周期，这些责任被反转或委托给外部控制器。这种方法对于创建模块化和灵活的系统特别有用。'
- en: In a typical software design without IoC, a class that requires certain functionalities
    from other classes would create or manage these dependent objects within itself.
    With IoC, this creation and management is handled by an external component, hence
    inverting the control.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 在典型的无IoC的软件设计中，一个需要从其他类获取特定功能的类会在其内部创建或管理这些依赖对象。使用IoC时，这种创建和管理由外部组件处理，因此实现了控制反转。
- en: IoC can be achieved through various methods such as DI, Factory Pattern, Service
    Locator, and more. Among these, DI is the most commonly used method in the context
    of MVVM.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: IoC可以通过多种方法实现，例如DI、工厂模式、服务定位器等。在这些方法中，DI是MVVM上下文中最常用的方法。
- en: Dependency Injection
  id: totrans-14
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖注入
- en: DI, a specific form of IoC, involves injecting the dependencies of an object
    (such as services or components) into the object by an external entity rather
    than having the object create them. This is typically done through the constructor.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入（DI）是IoC的一种特定形式，它涉及通过外部实体将对象的依赖项（如服务或组件）注入到对象中，而不是由对象创建它们。这通常是通过构造函数完成的。
- en: 'Using DI brings a lot of advantages. Let’s take a look:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 使用DI带来了许多优势。让我们看看：
- en: '**Separation of concerns**: Each component or class focuses on its core responsibility.
    The creation and life cycle management of its dependencies are handled externally.'
  id: totrans-17
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**关注点分离**：每个组件或类都专注于其核心责任。其依赖项的创建和生命周期管理由外部处理。'
- en: '**Testability**: DI makes it much easier to test components by allowing mock
    dependencies to be injected. This is crucial because, in unit testing, you want
    to isolate the component being tested and not have to worry about the dependencies.
    For example, if a ViewModel depends on a service that fetches data, you can inject
    a mock data service that simulates data retrieval without actually hitting a database
    or API. This makes tests faster, repeatable, and more reliable.'
  id: totrans-18
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可测试性**：DI通过允许注入模拟依赖项，使得测试组件变得更加容易。这对于单元测试至关重要，因为在单元测试中，你希望隔离正在测试的组件，并且不必担心依赖项。例如，如果ViewModel依赖于一个获取数据的服务，你可以注入一个模拟数据服务来模拟数据检索，而不必实际击中数据库或API。这使得测试更快、可重复且更可靠。'
- en: '**Reusability and maintainability**: Components become more reusable and maintainable
    because they are not tightly coupled with their dependencies.'
  id: totrans-19
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**可重用性和可维护性**：组件因为不与其依赖项紧密耦合，所以变得更加可重用和可维护。'
- en: '**Flexibility**: It becomes easier to change or swap implementations of dependencies
    without altering the dependent class.'
  id: totrans-20
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**灵活性**：在不改变依赖类的情况下，更容易更改或交换依赖项的实现。'
- en: By allowing dependencies to be injected from the outside, DI supports the creation
    of more loosely coupled code. This not only results in a more maintainable and
    scalable system but is also highly advantageous for testing. Through the injection
    of mock or stub implementations during testing, you can focus on testing the functionality
    of individual components in isolation, without the complexity and unpredictability
    of the entire system.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 通过允许从外部注入依赖项，依赖注入（DI）支持创建更松散耦合的代码。这不仅导致系统更易于维护和扩展，而且对于测试也非常有利。通过在测试期间注入模拟或存根实现，你可以专注于单独测试单个组件的功能，而不必担心整个系统的复杂性和不可预测性。
- en: The ability to inject different implementations is one of the powerful aspects
    of DI and is central to creating robust and flexible architectures.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 注入不同实现的能力是DI的一个强大方面，并且对于创建健壮和灵活的架构至关重要。
- en: 'Remember, back in [*Chapter 1*](B20941_01.xhtml#_idTextAnchor015), *What Is
    the MVVM Design Pattern?,* where we had a `MainPageViewModel` and its constructor
    accepted an interface called `IQuoteService`? Let’s have a look:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 记得，在[*第一章*](B20941_01.xhtml#_idTextAnchor015)，“什么是MVVM设计模式？”中，我们有一个`MainPageViewModel`，其构造函数接受一个名为`IQuoteService`的接口？让我们看看：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: This is a textbook example of DI. `MainPageViewModel` should not be responsible
    for retrieving the “quote of the day.” Instead, this should be the responsibility
    of another class. `MainPageViewModel` is dependent on an instance of a class that
    implements `IQuoteService` for that functionality. However, instead of directly
    creating or managing an instance of this service, it receives the instance through
    its constructor. This is what’s known as `IQuoteService` dependency through its
    constructor, `MainPageViewModel` adheres to the principle of `MainPageViewModel`
    class’s responsibility is to provide data for the view, while the responsibility
    to fetch the actual data is delegated to `IQuoteService`.
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个依赖注入的典型示例。`MainPageViewModel`不应该负责检索“每日名言”。相反，这应该是另一个类的责任。`MainPageViewModel`依赖于一个实现`IQuoteService`接口的类的实例以实现该功能。然而，而不是直接创建或管理该服务的实例，它通过其构造函数接收该实例。这就是所谓的通过构造函数的`IQuoteService`依赖，`MainPageViewModel`遵循的原则是`MainPageViewModel`类的责任是提供视图数据，而获取实际数据的责任则委托给`IQuoteService`。
- en: Here, `MainPageViewModel` has no knowledge about where the class implementing
    the `IQuoteService` interface comes from, how it’s instantiated, or how its life
    cycle is managed. It simply receives an instance and uses it. This makes the ViewModel
    independent from the concrete implementation of the `IQuoteService` interface
    and it can be any class that implements this interface.
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`MainPageViewModel`对实现`IQuoteService`接口的类的来源、实例化方式或生命周期管理一无所知。它只是接收一个实例并使用它。这使得ViewModel独立于`IQuoteService`接口的具体实现，并且可以是实现此接口的任何类。
- en: This `IQuoteService` interface, we can just create a new class that implements
    it and fetch data from the API. We can then inject this new class into our ViewModel
    without having to change any code inside `MainPageViewModel` itself. The ViewModel
    is only concerned with the fact it has a class implementing the `IQuoteService`
    interface to work with, not the details of how it accomplishes its tasks.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 对于这个`IQuoteService`接口，我们只需创建一个新的类来实现它，并从API获取数据。然后我们可以将这个新类注入到我们的ViewModel中，而无需更改`MainPageViewModel`本身的任何代码。ViewModel只关心它有一个实现`IQuoteService`接口的类来与之交互，而不关心它完成任务的具体细节。
- en: Note
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While it’s common to see DI used with interfaces, it’s not a strict requirement.
    Interfaces are popular in DI because they promote loose coupling. However, abstract
    classes or even concrete classes can be injected as well. The choice depends on
    the specific needs of your application and your design goals.
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然在依赖注入（DI）中使用接口很常见，但这并不是一个严格的要求。接口在DI中很受欢迎，因为它们促进了松耦合。然而，抽象类甚至具体类也可以被注入。选择取决于您应用程序的具体需求和设计目标。
- en: The advantage of this decoupling becomes even more evident when it comes to
    testing. Let’s say we want to write unit tests for `MainPageViewModel`. To make
    these tests reliable, we need to ensure they’re not affected by the unpredictability
    of external dependencies. With DI, we can easily achieve this by creating a mock
    implementation of `IQuoteService` that returns controlled data, perfect for testing
    scenarios. This way, we can test all aspects of `MainPageViewModel` in isolation,
    without any unpredictable behavior from external dependencies.
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 当涉及到测试时，这种解耦的优势变得更加明显。假设我们想要为`MainPageViewModel`编写单元测试。为了使这些测试可靠，我们需要确保它们不受外部依赖不可预测性的影响。使用依赖注入（DI），我们可以通过创建一个返回受控数据的`IQuoteService`的模拟实现来轻松实现这一点，这对于测试场景来说非常完美。这样，我们就可以在隔离的情况下测试`MainPageViewModel`的所有方面，而不会受到外部依赖不可预测行为的影响。
- en: Let’s see DI in action and have a look at how we can register, resolve, and
    inject dependencies.
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看DI的实际应用，并看看我们如何注册、解析和注入依赖项。
- en: Registering, resolving, and injecting services
  id: totrans-32
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 注册、解析和注入服务
- en: .NET MAUI comes with built-in support for DI. It has been designed with DI in
    mind, which allows for easier configuration and management of services that your
    application relies on. By providing out-of-the-box support for DI, .NET MAUI enables
    developers to leverage the concept of DI and IoC to make their code more maintainable
    and more loosely coupled. As the MVVM pattern benefits tremendously from DI and
    IoC, it shows again that MVVM and .NET MAUI are a perfect match!
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI自带对DI的支持。它已经考虑到了DI，这使得配置和管理应用程序所依赖的服务变得更加容易。通过提供开箱即用的DI支持，.NET MAUI使开发者能够利用DI和IoC的概念来使他们的代码更易于维护和更松耦合。由于MVVM模式从DI和IoC中获得了巨大的好处，这再次表明MVVM和.NET
    MAUI是完美匹配的！
- en: The `Microsoft.Extensions.DependencyInjection` namespace is where .NET MAUI
    gets its default implementation for DI. However, it’s important to note that .NET
    MAUI is DI container agnostic, which means you’re not limited to the default.
    If you prefer a third-party DI container, you’re free to replace the default with
    your preferred choice. Let’s see how we can register services using .NET MAUI’s
    default DI implementation.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: '`Microsoft.Extensions.DependencyInjection`命名空间是.NET MAUI获取其默认DI实现的来源。然而，需要注意的是，.NET
    MAUI对DI容器是无关的，这意味着您不受默认容器的限制。如果您更喜欢第三方DI容器，您可以自由地将默认容器替换为您首选的选择。让我们看看如何使用.NET
    MAUI的默认DI实现来注册服务。'
- en: Registering services
  id: totrans-35
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 注册服务
- en: .NET MAUI hosts a DI container and makes it accessible throughout your application.
    When your application starts, you have the opportunity to configure the services
    that will be available for injection. This is done using the `Services` property
    of the `MauiAppBuilder` instance. If you have worked with ASP.NET before, then
    you already know how this works. Through the `Services` property, we can set up
    services for use throughout your application.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: .NET MAUI托管一个依赖注入容器，并使其在整个应用程序中可用。当应用程序启动时，你有机会配置将可用于注入的服务。这是通过`MauiAppBuilder`实例的`Services`属性完成的。如果你之前使用过ASP.NET，那么你已经知道这是如何工作的。通过`Services`属性，我们可以在整个应用程序中设置服务。
- en: 'The `Services` property on `MauiAppBuilder` is of type `IServiceCollection`,
    which is a framework-provided interface for a collection of service descriptors.
    It provides methods to register services in the container. In the following example,
    the `AddSingleton` method is used to register `QuoteService` as a Singleton service
    for the `IQuoteService` interface:'
  id: totrans-37
  prefs: []
  type: TYPE_NORMAL
  zh: '`MauiAppBuilder`上的`Services`属性是`IServiceCollection`类型，这是一个框架提供的用于服务描述符集合的接口。它提供了在容器中注册服务的方法。在下面的示例中，使用`AddSingleton`方法将`QuoteService`注册为`IQuoteService`接口的单例服务：'
- en: '[PRE1]'
  id: totrans-38
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: The preceding code shows how we can associate a concrete implementation (`QuoteService`)
    with an interface (`IQuoteService`). As a consequence, when the app’s `IServiceProvider`
    needs to resolve an instance of a class that implements the `IQuoteService`, it
    will create (or reuse) an instance of the `QuoteService` class. `IServiceProvider`
    represents a service container, which is a collection of service registrations.
    It’s essentially the object that is responsible for resolving and providing instances
    of services, which were registered through the associated `IServiceCollection`,
    when they are needed. Registering a concrete implementation for a particular interface
    allows us to decouple the implementation from the actual usage in our code. It’s
    good practice to code against interfaces and not against implementations and this
    is exactly what we can achieve here.
  id: totrans-39
  prefs: []
  type: TYPE_NORMAL
  zh: 前面的代码展示了我们如何将一个具体的实现（`QuoteService`）与一个接口（`IQuoteService`）关联起来。因此，当应用的`IServiceProvider`需要解析实现`IQuoteService`的类的实例时，它将创建（或重用）`QuoteService`类的实例。`IServiceProvider`代表一个服务容器，它是一组服务注册的集合。它本质上是一个负责在需要时解析和提供通过关联的`IServiceCollection`注册的服务实例的对象。为特定接口注册具体的实现使我们能够将实现与代码中的实际使用解耦。面向接口编程而不是面向实现编程是一种良好的编程实践，这正是我们在这里能够实现的目标。
- en: 'However, in the case of ViewModels or other classes that don’t necessarily
    have an associated interface, we can register them directly, as the following
    snippet shows:'
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于ViewModel或其他不一定有相关接口的类，我们可以直接注册它们，如下面的代码片段所示：
- en: '[PRE2]'
  id: totrans-41
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: When we do this, every time an instance of `MainPageViewModel` is requested
    from the DI container, it will provide an instance of the class and manage its
    life cycle.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们这样做时，每次从依赖注入容器请求`MainPageViewModel`的实例时，它将提供一个类的实例并管理其生命周期。
- en: 'Services can be registered in different ways, depending on their intended lifetimes:'
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 根据预期的生命周期，服务可以以不同的方式注册：
- en: '**Transient**: Transient services are created each time they’re requested from
    the container. This lifetime works best for lightweight, stateless services. In
    theory, Transient services take up more memory because a new instance is created
    every time the service is requested. However, because each instance can be garbage-collected
    as soon as it’s no longer in use, this memory can be reclaimed quickly.'
  id: totrans-44
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**瞬态（Transient）**：瞬态服务每次从容器请求时都会创建。这种生命周期最适合轻量级、无状态的服务。从理论上讲，瞬态服务因为每次请求服务时都会创建一个新的实例，所以会占用更多的内存。然而，因为每个实例一旦不再使用就可以被垃圾回收，所以这些内存可以快速回收。'
- en: '**Singleton**: Singleton services are created once, and the same instance is
    used throughout the application’s lifetime. This works best for stateful services
    that need to maintain consistency across the app, or for heavy services that would
    be expensive to create multiple times. Singleton services take up the least amount
    of memory because only one instance is ever created. However, because the same
    instance is used throughout the entire application, it stays in memory for as
    long as the application is running.'
  id: totrans-45
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**单例（Singleton）**: 单例服务只创建一次，并在整个应用程序的生命周期内使用相同的实例。这对于需要在整个应用程序中保持一致性的有状态服务，或者对于创建多次成本较高的重服务来说，效果最好。单例服务占用的内存最少，因为只创建了一个实例。然而，由于整个应用程序都使用相同的实例，它将保留在内存中，直到应用程序运行结束。'
- en: '**Scoped**: Scoped services are created once per scope. However, in a .NET
    MAUI application, this is similar to Singleton since there is generally only one
    scope.'
  id: totrans-46
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '**作用域（Scoped）**: 作用域服务在每个作用域内创建一次。然而，在.NET MAUI应用程序中，这类似于单例，因为通常只有一个作用域。'
- en: Choosing between these lifetimes depends entirely on the specific needs of the
    service. If your service is stateless and lightweight, a Transient lifetime might
    be appropriate. If your service needs to maintain state across the entire application,
    or if it’s expensive to create, a Singleton lifetime might be the best option.
    Choosing the right lifetime for your services is important. It can affect how
    your app behaves and performs, so think about it carefully. In my experience,
    I usually choose Transient as much as possible for my services. I do this because
    I aim to keep my services simple and without state. This way, they use memory
    more efficiently since they’re removed as soon as they’re not needed. Also, it
    helps to avoid problems that can come up when a shared state is changed in different
    places, especially in multi-threaded situations. But remember, there’s no one-size-fits-all
    solution here. Each service is unique and so is your app. Depending on what your
    service does and what your app needs, you might have to choose a different lifetime.
    That’s why it’s key to understand these concepts and make smart choices for your
    specific app.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 选择这些生命周期完全取决于服务的具体需求。如果你的服务是无状态的且轻量级，那么瞬态（Transient）生命周期可能很合适。如果你的服务需要在整个应用程序中维护状态，或者创建成本较高，那么单例（Singleton）生命周期可能是最佳选择。为你的服务选择正确的生命周期非常重要。它可能会影响你的应用程序的行为和性能，所以请仔细考虑。根据我的经验，我通常尽可能选择瞬态（Transient）作为我的服务。我这样做是因为我旨在保持我的服务简单且无状态。这样，它们更有效地使用内存，因为一旦不再需要，它们就会被移除。此外，这有助于避免在不同地方更改共享状态时可能出现的问题，尤其是在多线程情况下。但请记住，这里没有一刀切的方法。每个服务都是独特的，你的应用程序也是如此。根据你的服务做什么以及你的应用程序需要什么，你可能需要选择不同的生命周期。这就是为什么理解这些概念并为你的特定应用程序做出明智的选择至关重要。
- en: Let’s see how we can resolve and inject these registered services.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何解决和注入这些已注册的服务。
- en: Resolving and injecting services
  id: totrans-49
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 解决和注入服务
- en: DI containers, such as the one built into .NET MAUI, are capable of resolving
    not only direct dependencies but also nested dependencies.
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: DI容器，如.NET MAUI中内置的容器，能够解决不仅包括直接依赖项，还包括嵌套依赖项。
- en: In essence, when an instance of a class or service is being resolved by the
    container, all of its dependencies, and the dependencies of those dependencies,
    are automatically resolved and injected as well. This forms a complete object
    graph where every class has its dependencies satisfied.
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 从本质上讲，当容器解决类或服务的实例时，所有其依赖项以及这些依赖项的依赖项都会自动解决并注入。这形成了一个完整的对象图，其中每个类都有其依赖项得到满足。
- en: 'If a particular class has a dependency that needs to be injected, it is as
    simple as defining the dependency as a parameter of the class’s constructor. That’s
    exactly what we did with `MainPageViewModel`: it has a constructor that requires
    an instance of a class implementing the `IQuoteService` interface.'
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个特定的类有一个需要注入的依赖项，只需将其定义为类构造函数的参数即可。这正是我们对`MainPageViewModel`所做的那样：它有一个需要实现`IQuoteService`接口的类的实例的构造函数。
- en: Which constructor does the DI container use?
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: DI容器使用哪个构造函数？
- en: 'As the DI container can instantiate classes for us, you might wonder which
    constructor it uses when the class has multiple constructors. The answer is pretty
    simple: it uses the constructor with the most parameters that it can resolve.
    If there are two or more constructors with the same number of parameters the DI
    container can resolve, or when no constructor is found for which all dependencies
    could be resolved, an exception will be thrown.'
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 由于DI容器可以为我们实例化类，你可能会想知道当类有多个构造函数时，它使用哪个构造函数。答案是相当简单的：它使用可以解析的参数最多的构造函数。如果有两个或更多具有相同参数数量的构造函数可以被DI容器解析，或者当找不到所有依赖项都可以解析的构造函数时，将抛出异常。
- en: 'We are also able to resolve services on the fly, so long as we get a hold of
    the app’s `IServiceProvider` container. This interface exposes a `GetService<T>`
    method that we can call to get an instance of a class that was associated with
    the provided generic type parameter. The following code block shows how we can
    create a static `ServiceProvider` class that we could use to access the services
    container from anywhere in our app:'
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 我们还能够动态解析服务，只要我们能够获取到应用的`IServiceProvider`容器。此接口公开了一个`GetService<T>`方法，我们可以调用它来获取与提供的泛型类型参数关联的类的实例。以下代码块显示了如何创建一个静态的`ServiceProvider`类，我们可以用它从应用的任何地方访问服务容器：
- en: '[PRE3]'
  id: totrans-56
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'So, instead of instantiating a `MainPageViewModel` in the code behind the `MainPage_MVVM`
    class, and needing to manually provide an instance of a class that implements
    IQuoteService, we can do the following:'
  id: totrans-57
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，我们不需要在`MainPage_MVVM`类的代码背后实例化`MainPageViewModel`，也不需要手动提供实现IQuoteService接口的类的实例，我们可以这样做：
- en: '[PRE4]'
  id: totrans-58
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Because we have registered `MainPageViewModel` as a service and `QuoteService`,
    which we associated with the `IQuoteService` interface, the `GetService` method
    will return an instance of `MainPageViewModel`, which is instantiated by injecting
    an instance of the `QuoteService` class through its constructor. This `ServiceProvider`
    class can be very helpful to resolve instances of classes on the fly from the
    DI container. However, for this particular example, we could take this a step
    further and avoid the need to manually resolve an instance of `MainPageViewModel`.
    We can achieve this by adding an instance of `MainPageViewModel` as a dependency
    to the `MainPage_MVVM` class, as shown here:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 由于我们已经将`MainPageViewModel`注册为服务，并将`QuoteService`与之关联到`IQuoteService`接口，`GetService`方法将返回一个`MainPageViewModel`的实例，该实例通过其构造函数注入了`QuoteService`类的实例。这个`ServiceProvider`类可以在动态地从DI容器中解析类实例时非常有帮助。然而，对于这个特定的例子，我们可以更进一步，避免手动解析`MainPageViewModel`实例的需求。我们可以通过将`MainPageViewModel`的实例作为依赖项添加到`MainPage_MVVM`类中来实现这一点，如下所示：
- en: '[PRE5]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'The following code snippet shows how we can register the `MainPage_MVVM` class
    as well:'
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码片段显示了如何注册`MainPage_MVVM`类：
- en: '[PRE6]'
  id: totrans-62
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: In this sample app, we’re using .NET MAUI Shell for navigation. This allows
    an instance of a page to be dynamically resolved during the navigation process.
    So, when we navigate to the `MainPage_MVVM` page, the DI container springs into
    action. It resolves an instance of the `MainPage_MVVM` page and all of its dependencies.
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例应用中，我们使用.NET MAUI Shell进行导航。这允许在导航过程中动态解析页面的实例。因此，当我们导航到`MainPage_MVVM`页面时，DI容器会立即行动。它解析`MainPage_MVVM`页面的实例及其所有依赖项。
- en: What is .NET MAUI Shell?
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是.NET MAUI Shell？
- en: In [*Chapter 8*](B20941_08.xhtml#_idTextAnchor132), *Navigation in MVVM*, we
    will dive much deeper into the aspects of navigation and .NET MAUI Shell.
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 在[第8章](B20941_08.xhtml#_idTextAnchor132)“MVVM中的导航”中，我们将更深入地探讨导航和.NET MAUI Shell的各个方面。
- en: Now that we’ve got a taste of DI with the *Quote of the Day* app, let’s take
    things up a notch by applying what we’ve learned to our feature-rich *Recipes!*
    app. This will allow us to delve deeper into DI and see how it can be skillfully
    utilized in a more complex project. So, roll up your sleeves, and let’s get cooking
    with DI in the *Recipes!* app.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经通过“每日名言”应用体验了依赖注入（DI），让我们将所学应用到功能丰富的“食谱”应用中，进一步提升我们的技能。这将使我们能够更深入地了解DI，并看到它如何在更复杂的项目中巧妙地被利用。所以，卷起袖子，让我们在“食谱”应用中使用DI大显身手吧。
- en: Applying Dependency Injection
  id: totrans-67
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 应用依赖注入
- en: 'So far, in the ViewModels in our *Recipes!* app we have been working with hard-coded
    data. Now, it’s time to breathe more life into our application by introducing
    services that can fetch and manage data dynamically. The `Begin` directory in
    the GitHub repository for this chapter presents some updates and additional code
    that includes new service interfaces such as `IRecipeService`, `IFavoritesService`,
    and `IRatingsService`, along with their respective implementations. These services
    will play crucial roles in our application: the `IRecipeService` interface defines
    a contract for a service that will load and manage recipe data. Similarly, `IFavoritesService`
    outlines the rules for a service that will handle the user’s favorite recipes,
    and the `IRatingsService` interface does the same for a service managing recipe
    ratings. As we move forward, we’ll explore how to use these services within the
    MVVM architecture and how DI brings it all together in a clean, manageable manner.'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在我们的 *Recipes!* 应用中的 ViewModels 我们一直在使用硬编码的数据。现在，是时候通过引入可以动态获取和管理数据的服务来给我们的应用程序注入更多活力了。GitHub
    仓库中本章的 `Begin` 目录展示了某些更新和额外的代码，包括新的服务接口，如 `IRecipeService`、`IFavoritesService`
    和 `IRatingsService`，以及它们各自的实现。这些服务将在我们的应用程序中扮演关键角色：`IRecipeService` 接口定义了一个将加载和管理食谱数据的服务合同。同样，`IFavoritesService`
    概述了处理用户喜欢的食谱的服务规则，而 `IRatingsService` 接口对管理食谱评分的服务做了同样的事情。随着我们继续前进，我们将探讨如何在 MVVM
    架构中使用这些服务，以及 DI 如何以干净、可管理的方式将它们全部整合在一起。
- en: To introduce DI in our *Recipes!* app, we need to make sure that, unlike what
    we have been doing up until now, we don’t initialize ViewModels in the code-behind
    ourselves. Instead, these ViewModels need to be injected and assigned to the page’s
    `BindingContext`. Let’s have a look at this before we update the ViewModels.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 为了在我们的 *Recipes!* 应用中引入依赖注入（DI），我们需要确保，与我们现在所做的不一样，我们不再在代码背后初始化 ViewModels。相反，这些
    ViewModels 需要被注入并分配给页面的 `BindingContext`。在我们更新 ViewModels 之前，让我们先看看这个。
- en: Adding dependencies to pages
  id: totrans-70
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向页面添加依赖项
- en: 'To add the dependency of a particular ViewModel to a page, we simply need to
    add the type of ViewModel as a parameter to the constructor. Also, we need to
    make sure that both the page and the ViewModel are registered in the DI container:'
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 要将特定 ViewModel 的依赖项添加到页面中，我们只需将 ViewModel 的类型作为参数添加到构造函数中。此外，我们还需要确保页面和 ViewModel
    都已在 DI 容器中注册：
- en: 'Head over to the code-behind of `RecipesOverviewPage` and add a parameter of
    type `RecipeOverviewViewModel` to the page’s constructor, as shown in the following
    snippet:'
  id: totrans-72
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 前往 `RecipesOverviewPage` 的代码背后，并将 `RecipeOverviewViewModel` 类型的参数添加到页面的构造函数中，如下面的代码片段所示：
- en: '[PRE7]'
  id: totrans-73
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Next, we need to make sure the `RecipesOverviewPage` and `RecipeOverviewViewModel`
    classes are registered with the DI container. Only then can the DI container resolve
    `RecipesOverviewPage` and resolve its dependency, an instance of `RecipesOverviewViewModel`.
    Head over to `MauiProgram` and add the following lines of code:'
  id: totrans-74
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们需要确保 `RecipesOverviewPage` 和 `RecipeOverviewViewModel` 类已在 DI 容器中注册。只有这样，DI
    容器才能解析 `RecipesOverviewPage` 并解析其依赖项，即 `RecipesOverviewViewModel` 的一个实例。前往 `MauiProgram`
    并添加以下代码行：
- en: '[PRE8]'
  id: totrans-75
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'Similarly, we need to do the same for `RecipeDetailPage` and `RecipeRatingDetailPage`:
    add their respective ViewModels as dependencies by including them as parameters.
    This is what it looks like for `RecipesOverviewPage`:'
  id: totrans-76
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，我们还需要对 `RecipeDetailPage` 和 `RecipeRatingDetailPage` 做同样的处理：通过将它们作为参数包含进来，将它们各自的
    ViewModels 作为依赖项添加。以下是 `RecipesOverviewPage` 的样子：
- en: '[PRE9]'
  id: totrans-77
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'And likewise, for `RecipeRatingDetailPage`, we must do the following, where
    we want to inject `RecipeRatingsDetailViewModel`:'
  id: totrans-78
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 同样，对于 `RecipeRatingDetailPage`，我们必须做以下操作，其中我们想要注入 `RecipeRatingsDetailViewModel`：
- en: '[PRE10]'
  id: totrans-79
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Now, just like we did before, let’s register these additional pages and their
    ViewModels in the DI container within the `MauiProgram` class:'
  id: totrans-80
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，就像我们之前做的那样，让我们在 `MauiProgram` 类中注册这些额外的页面和它们的 ViewModels：
- en: '[PRE11]'
  id: totrans-81
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: With these modifications in place, we’ve successfully implemented the foundational
    elements of DI in our *Recipes!* app. By registering the pages and their corresponding
    ViewModels with the DI container, we’ve ensured that whenever these components
    are needed, they can be easily resolved and provided by the DI container. Moreover,
    by injecting the ViewModels into our pages through their constructors, we’ve shifted
    the responsibility of creating and managing ViewModel instances away from the
    pages themselves and toward the DI container. This sets up a more flexible and
    maintainable structure for our application, paving the way for us to further enhance
    it with additional services and functionality.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这些修改，我们已经在我们的*Recipes!*应用中成功实现了DI的基础元素。通过将页面及其对应的ViewModel注册到DI容器中，我们确保了每当需要这些组件时，它们可以很容易地由DI容器解决并提供。此外，通过通过构造函数将ViewModel注入到我们的页面中，我们将创建和管理ViewModel实例的责任从页面本身转移到DI容器。这为我们应用程序设置了一个更灵活、更易于维护的结构，为我们进一步通过额外的服务和功能增强它铺平了道路。
- en: Now, let’s take a closer look at the specific changes we need to make to our
    ViewModels to fully incorporate DI.
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们更仔细地看看我们需要对ViewModel进行的具体更改，以完全实现DI。
- en: Adding dependencies to ViewModels
  id: totrans-84
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 向ViewModel添加依赖项
- en: 'We no longer want our ViewModels to contain hard-coded data, nor do we want
    them to be responsible for retrieving data. So, let’s introduce some dependencies
    to our ViewModels:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不再希望我们的ViewModel包含硬编码的数据，也不希望它们负责检索数据。因此，让我们向我们的ViewModel中引入一些依赖项：
- en: At the very top of the `RecipesOverviewViewModel` class, we can start by removing
    the `items` field. We’re moving away from hard-coded data and will use services
    to fetch data instead.
  id: totrans-86
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`RecipesOverviewViewModel`类的顶部，我们可以先移除`items`字段。我们正在远离硬编码的数据，并将使用服务来获取数据。
- en: 'The following code snippet shows how we introduce two fields to this class:
    `recipeService`, which is of type `IRecipeService`, and `favoritesService`, which
    is of type `IFavoritesService`:'
  id: totrans-87
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码片段展示了我们如何向这个类中引入两个字段：`recipeService`，其类型为`IRecipeService`，以及`favoritesService`，其类型为`IFavoritesService`：
- en: '[PRE12]'
  id: totrans-88
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE12]'
- en: These services will take responsibility for loading the recipes on this page
    and displaying whether they are favorited by the user or not. Both of these services
    are dependencies that will be injected into the ViewModel.
  id: totrans-89
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这些服务将负责加载此页面上的食谱，并显示用户是否收藏了它们。这两个服务都是将被注入到ViewModel中的依赖项。
- en: 'This code block shows exactly how these dependencies can get injected through
    the constructor of the ViewModel:'
  id: totrans-90
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 此代码块展示了这些依赖项如何通过ViewModel的构造函数进行注入：
- en: '[PRE13]'
  id: totrans-91
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE13]'
- en: By defining these two parameters in the constructor for `RecipesOverviewViewModel`,
    the DI container will attempt to resolve instances for both when creating a `RecipesOverviewViewModel`.
    The resolved instances are then passed as parameters to the constructor, where
    we can assign them to the fields we created earlier.
  id: totrans-92
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过在`RecipesOverviewViewModel`的构造函数中定义这两个参数，DI容器将尝试在创建`RecipesOverviewViewModel`时解决这两个实例。然后，解决的实例作为参数传递给构造函数，在那里我们可以将它们分配给之前创建的字段。
- en: 'When we examine the `LoadRecipes` method, we can see how we utilize these services
    to load the data we need:'
  id: totrans-93
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 当我们检查`LoadRecipes`方法时，我们可以看到我们如何利用这些服务来加载数据：
- en: '[PRE14]'
  id: totrans-94
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE14]'
- en: The ViewModel doesn’t concern itself with where these recipes or favorites are
    coming from. It only trusts that the injected services – `recipeService` and `favoritesService`
    – adhere to the specified interfaces and deliver the required functionality. The
    exact implementation is abstracted away from the ViewModel, highlighting one of
    the main benefits of DI.
  id: totrans-95
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: ViewModel不关心这些食谱或收藏来自哪里。它只信任注入的服务——`recipeService`和`favoritesService`——遵循指定的接口并交付所需的功能。具体的实现被抽象化，从ViewModel中突出显示了DI的主要好处之一。
- en: 'Head over to `RecipeDetailViewModel`. In this class, we also want to remove
    all hard-coded data: `Title`, `Allergens`, `Calories`, and so on. And while we
    are at it, we should update the properties to “full” properties that trigger the
    `PropertyChanged` event. This is needed because the data on the ViewModel will
    be loaded asynchronously, so it won’t be there when the page is being rendered.
    As a result, the `PropertyChanged` event for each property needs to be triggered
    when the data is loaded to reflect the loaded values on the UI. The following
    snippet shows some of the updated properties:'
  id: totrans-96
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 转到 `RecipeDetailViewModel`。在这个类中，我们同样希望移除所有硬编码的数据：`Title`、`Allergens`、`Calories`
    等等。并且在我们做这件事的同时，我们应该更新属性为“完整”属性，这些属性会触发 `PropertyChanged` 事件。这是必要的，因为 ViewModel
    上的数据将异步加载，因此在页面渲染时可能不存在。因此，每个属性的 `PropertyChanged` 事件需要在数据加载时触发，以便在 UI 上反映加载的值。以下代码片段显示了部分更新的属性：
- en: '[PRE15]'
  id: totrans-97
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'Now is also the time to update the binding mode on the label, which shows the
    recipe’s title. Up until now, this was defined as a `OneTime` binding, but as
    we now load the data of the recipe after the ViewModel is set as the `BindingContext`
    of the `RecipeDetailPage`, we need to make sure the updated value is shown on
    the screen as well. Let’s update the binding mode to `OneWay` so that when the
    `PropertyChanged` event is triggered after the value of the `Title` property is
    set, the binding engine updates the value on the UI. The following snippet shows
    the updated label:'
  id: totrans-98
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在也是时候更新标签的绑定模式了，该标签显示菜谱的标题。到目前为止，这被定义为 `OneTime` 绑定，但因为我们现在在将 ViewModel 设置为
    `RecipeDetailPage` 的 `BindingContext` 之后加载菜谱的数据，我们需要确保更新的值也显示在屏幕上。让我们将绑定模式更新为
    `OneWay`，这样当 `Title` 属性的值设置后触发 `PropertyChanged` 事件时，绑定引擎会更新 UI 上的值。以下代码片段显示了更新的标签：
- en: '[PRE16]'
  id: totrans-99
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'Let’s update the constructor of `RecipeDetailViewModel` so that it accepts
    an instance of `IRecipeService`, `IFavoritesService`, and `IRatingsService`, as
    shown here:'
  id: totrans-100
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们更新 `RecipeDetailViewModel` 的构造函数，使其接受 `IRecipeService`、`IFavoritesService`
    和 `IRatingsService` 的实例，如下所示：
- en: '[PRE17]'
  id: totrans-101
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'These services (`recipeService`, `favoritesService`, and `ratingsService`)
    are `readonly` fields that we should define in the ViewModel, as demonstrated
    in the following snippet:'
  id: totrans-102
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这些服务（`recipeService`、`favoritesService` 和 `ratingsService`）是 ViewModel 中的 `readonly`
    字段，如以下代码片段所示：
- en: '[PRE18]'
  id: totrans-103
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'The following code block shows `LoadRecipe`, which accepts the ID of the recipe
    to load as a parameter. This method uses the injected services to load all relevant
    data for this ViewModel:'
  id: totrans-104
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块显示了 `LoadRecipe` 方法，该方法接受要加载的菜谱ID作为参数。此方法使用注入的服务来加载此 ViewModel 所需的所有相关数据：
- en: '[PRE19]'
  id: totrans-105
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: The three async tasks that retrieve `RecipeDetailDto`, `RatingsSummaryDto`,
    and the `bool` value indicating whether the recipe is a favorite or not are launched
    in parallel. Through the `Task.WhenAll` method, we wait for all three to complete.
    Beyond this point, the `Result` property of the tasks holds the retrieved data.
    This data is then mapped to the ViewModel through the `MapRecipeData` method.
  id: totrans-106
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 获取 `RecipeDetailDto`、`RatingsSummaryDto` 和表示菜谱是否为收藏夹的 `bool` 值的三个异步任务并行启动。通过
    `Task.WhenAll` 方法，我们等待所有三个任务完成。在此点之后，任务的 `Result` 属性包含检索到的数据。然后，通过 `MapRecipeData`
    方法将这些数据映射到 ViewModel。
- en: 'In the next chapter, [*Chapter 8*](B20941_08.xhtml#_idTextAnchor132), *Navigation
    in MVVM*, we’ll have a look at how we can pass the ID of the selected recipe from
    `RecipesOverviewViewModel` to `RecipeDetailViewModel` to load the recipe details
    of the chosen recipe. For now, let’s add the following snippet at the end of the
    ViewModel’s constructor to load the details of the recipe with an ID of `3`:'
  id: totrans-107
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在下一章，[*第8章*](B20941_08.xhtml#_idTextAnchor132)，*MVVM中的导航*，我们将探讨如何将选中菜谱的ID从 `RecipesOverviewViewModel`
    传递到 `RecipeDetailViewModel` 以加载选中菜谱的详细信息。现在，让我们在 ViewModel 的构造函数末尾添加以下代码片段以加载ID为
    `3` 的菜谱的详细信息：
- en: '[PRE20]'
  id: totrans-108
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Finally, we also need to update `RecipeRatingsDetailViewModel`. As before,
    we want to remove all hard-coded data and update the constructor so that it accepts
    an instance of a class that implements `IRecipeService` and one that implements
    the `IRatingsService` interface. The following snippet shows the updated constructor,
    where we also deleted the initialization of both the `Reviews` and `GroupedReviews`
    properties:'
  id: totrans-109
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，我们还需要更新 `RecipeRatingsDetailViewModel`。和之前一样，我们希望移除所有硬编码的数据，并更新构造函数，使其接受一个实现了
    `IRecipeService` 接口和实现了 `IRatingsService` 接口类的实例。以下代码片段显示了更新的构造函数，其中我们还删除了 `Reviews`
    和 `GroupedReviews` 属性的初始化：
- en: '[PRE21]'
  id: totrans-110
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'The `Reviews` property can be removed and we should make sure the `RecipeTitle`
    property calls the `PropertyChanged` event when it is being updated. Again, like
    we did previously, we must do this because the data is loaded asynchronously and
    we must notify the UI about the updated values. The following code block shows
    the updated `RecipeTitle` property, which uses the `SetProperty` method of the
    `ObservableObject` class to assign the value and trigger the `PropertyChanged`
    event. It also shows the fields that we added, to which we assign the injected
    dependencies in the constructor:'
  id: totrans-111
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 可以移除`Reviews`属性，并确保当`RecipeTitle`属性被更新时调用`PropertyChanged`事件。同样，我们必须这样做，因为数据是异步加载的，我们必须通知UI关于更新值的消息。下面的代码块显示了更新的`RecipeTitle`属性，它使用`ObservableObject`类的`SetProperty`方法来分配值并触发`PropertyChanged`事件。它还显示了我们在构造函数中分配注入依赖关系的字段：
- en: '[PRE22]'
  id: totrans-112
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Let’s also add the `LoadData` method, which accepts the ID of the recipe we
    want to load the rating for. It uses the injected services to dynamically load
    the data needed in this ViewModel. Let’s take a look:'
  id: totrans-113
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 让我们再添加一个`LoadData`方法，该方法接受我们想要加载评分的食谱ID。它使用注入的服务动态加载ViewModel中所需的数据。让我们看看：
- en: '[PRE23]'
  id: totrans-114
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'For now, let’s call the `LoadData` method from the constructor so that it loads
    some data when we initialize the ViewModel:'
  id: totrans-115
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们在构造函数中调用`LoadData`方法，以便在初始化ViewModel时加载一些数据：
- en: '[PRE24]'
  id: totrans-116
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: With all the updates done on the ViewModels, let’s finish up by registering
    the services that our updated ViewModels now have as dependencies.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 在对ViewModel的所有更新完成后，让我们通过注册我们的更新后的ViewModel现在作为依赖项的服务来完成。
- en: Registering services
  id: totrans-118
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 注册服务
- en: Now that our ViewModels have some dependencies, we have to make sure these dependencies
    get registered so that the DI container can resolve them.
  id: totrans-119
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们ViewModel有一些依赖项，我们必须确保这些依赖项被注册，以便DI容器可以解析它们。
- en: 'Registering the required dependencies is done again in the `MauiProgram` class.
    The following snippet shows how we register `FavoritesService`, which is very
    straightforward:'
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: 在`MauiProgram`类中再次执行注册所需依赖项的操作。以下代码片段显示了如何注册`FavoritesService`，这非常直接：
- en: '[PRE25]'
  id: totrans-121
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: We intentionally register `FavoritesService` as a Singleton because this particular
    implementation stores the user’s favorites in memory. If we were to register it
    as Transient, a new instance would be created each time it’s injected as a dependency,
    which would result in the favorites not persisting between page navigations. It’s
    worth noting, however, that keeping favorites in memory isn’t ideal, but for the
    sake of this example, it will serve our purpose. In a real-life scenario, we would
    want the favorites to be persisted in an (online) data store.
  id: totrans-122
  prefs: []
  type: TYPE_NORMAL
  zh: 我们故意将`FavoritesService`注册为Singleton，因为这种特定的实现将用户的收藏存储在内存中。如果我们将其注册为Transient，每次将其作为依赖项注入时都会创建一个新的实例，这将导致收藏在页面导航之间不会持久化。然而，值得注意的是，将收藏保留在内存中并不是理想的，但为了这个示例，它将满足我们的目的。在现实场景中，我们希望收藏能够持久化存储在（在线）数据存储中。
- en: 'Registering `RecipeService` involves a slightly more complex process. The reason
    for this is that the constructor of `RecipeService` requires a `Task` property
    that returns a stream to a JSON file that holds all the recipe information. This
    is shown in the constructor of `RecipeService`:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 注册`RecipeService`涉及一个稍微复杂的过程。原因在于`RecipeService`的构造函数需要一个`Task`属性，该属性返回一个指向包含所有食谱信息的JSON文件的流。这可以在`RecipeService`的构造函数中看到：
- en: '[PRE26]'
  id: totrans-124
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'We can’t register `RecipeService` in the same way we did with `FavoritesService`
    or other services we registered in earlier examples. This is because the DI container
    needs to know what parameter to pass to the constructor. In previous examples,
    it was straightforward: we just specified the concrete type that we wanted to
    associate with an interface or base class, or with the type itself. The container
    could then create an instance of the concrete class by invoking its default constructor
    or injecting other resolved dependencies.'
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 我们不能像之前在`FavoritesService`或其他服务中注册那样注册`RecipeService`。这是因为DI容器需要知道传递给构造函数的参数是什么。在之前的示例中，这很简单：我们只需指定我们想要与接口或基类或类型本身关联的具体类型。然后容器可以通过调用其默认构造函数或注入其他已解析的依赖关系来创建具体类的实例。
- en: 'However, in the case of `RecipeService`, the required parameter for creating
    an instance isn’t something we plan to register, meaning it cannot be resolved
    by the DI container. To tackle scenarios like this, the `AddTransient`, `AddSingleton`,
    and `AddScoped` methods provide an overload. This overload lets us pass in a function
    that returns an instance of the type we want to associate with the given base
    type. This function is invoked every time the associated type needs to be resolved.
    What’s more, the function’s parameter is `IServiceProvider` itself, allowing us
    to resolve any additional dependencies if necessary. The following code block
    shows how we can register `RecipeService`, using the overloaded function, while
    passing in a function that creates an instance of this class:'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，对于 `RecipeService` 来说，创建实例所需的参数并不是我们计划注册的，这意味着它不能由依赖注入容器解析。为了应对此类场景，`AddTransient`、`AddSingleton`
    和 `AddScoped` 方法提供了重载功能。这个重载功能允许我们传递一个函数，该函数返回我们想要与给定基类型关联的类型实例。每当关联类型需要被解析时，这个函数就会被调用。更重要的是，该函数的参数是
    `IServiceProvider` 本身，这允许我们在必要时解析任何额外的依赖项。以下代码块展示了我们如何使用重载函数注册 `RecipeService`，同时传递一个创建此类实例的函数：
- en: '[PRE27]'
  id: totrans-127
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: The passed-in function will be invoked every time an object of `IRecipeService`
    needs to be resolved by the DI container. However, as the `AddSingleton` method
    was used, the function would be invoked only once. This means that in this specific
    use case, registering the service as a Singleton could be a sensible decision
    as it would ensure that the JSON file only gets read once, keeping the recipes
    in memory, and thereby optimizing the application’s performance.
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 每当需要通过依赖注入容器解析 `IRecipeService` 对象时，传入的函数都会被调用。然而，由于使用了 `AddSingleton` 方法，该函数只会被调用一次。这意味着在这个特定用例中，将服务注册为
    Singleton 可能是一个明智的决定，因为它将确保 JSON 文件只被读取一次，从而保持食谱在内存中，并优化应用程序的性能。
- en: 'The same thing goes for the registration of `RatingsService`. Just like `RecipeService`,
    this class will also read from a local file to get the ratings. So, as before,
    we want to register this service using the overloaded `AddTransient` method, as
    shown here:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `RatingsService` 的注册也是如此。就像 `RecipeService` 一样，这个类也将从本地文件中读取评分。因此，就像之前一样，我们希望使用重载的
    `AddTransient` 方法来注册此服务，如下所示：
- en: '[PRE28]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: Once all these services have been registered, we can go ahead and run the *Recipes!*
    app. Our code now leverages DI, a practice that greatly enhances the modularity
    and testability of our application. By injecting dependencies, we decouple concrete
    classes with interfaces or base classes, allowing us to change or swap underlying
    implementations without affecting dependent classes. In the context of the MVVM
    pattern, DI allows us to provide ViewModels with the necessary services to handle
    their tasks, such as data fetching or business logic, without hard-coding these
    dependencies, promoting a clean separation of concerns. Moreover, we have even
    taken this concept a step further by using DI to inject ViewModels directly into
    our views, further emphasizing the flexibility and versatility this practice provides
    in our app development process.
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦所有这些服务都已注册，我们就可以继续运行 *Recipes!* 应用程序。我们的代码现在利用了依赖注入，这是一种极大地增强了我们应用程序模块化和可测试性的实践。通过注入依赖项，我们解耦了具体类与接口或基类，允许我们更改或替换底层实现，而不会影响依赖类。在
    MVVM 模式下，依赖注入允许我们为 ViewModels 提供处理其任务所需的服务，例如数据获取或业务逻辑，而不需要硬编码这些依赖项，从而促进关注点的清晰分离。此外，我们甚至通过将
    ViewModels 直接注入到视图中，进一步强调了这种实践在我们应用程序开发过程中的灵活性和多功能性。
- en: Note
  id: totrans-132
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While we’ve primarily discussed constructor-based DI in .NET MAUI, it’s worth
    mentioning that in broader contexts, dependencies can also be injected via properties
    or methods. However, such methods are not natively supported in .NET MAUI. The
    essence of DI is providing the class with its dependencies, irrespective of the
    method. Constructor injection is often preferred for clarity, but the technique
    that’s used might vary based on the platform and the design goals.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管我们主要讨论了在 .NET MAUI 中基于构造函数的依赖注入，但值得提及的是，在更广泛的环境中，依赖也可以通过属性或方法注入。然而，这些方法在 .NET
    MAUI 中并不是原生支持的。依赖注入的本质是为类提供其依赖项，无论使用何种方法。构造函数注入通常因为其清晰性而被优先考虑，但所使用的具体技术可能会根据平台和设计目标的不同而有所变化。
- en: DI plays a crucial role in keeping our application’s components decoupled. Next,
    we’ll delve into another mechanism that promotes decoupling in our application.
  id: totrans-134
  prefs: []
  type: TYPE_NORMAL
  zh: DI在保持我们应用程序组件解耦方面发挥着至关重要的作用。接下来，我们将深入了解另一种促进应用程序解耦的机制。
- en: Messaging
  id: totrans-135
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 消息传递
- en: Messaging is a software architectural pattern that facilitates communication
    between different parts of an application. In the context of .NET MAUI and MVVM
    architecture, messaging is typically used to send notifications between loosely
    coupled components, such as between ViewModels, or from a Model to a ViewModel.
    This decouples the components and promotes a more modular and maintainable code
    base.
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 消息传递是一种软件架构模式，它促进了应用程序不同部分之间的通信。在.NET MAUI和MVVM架构的背景下，消息传递通常用于在松散耦合的组件之间发送通知，例如在ViewModel之间，或者从模型到ViewModel。这解耦了组件，并促进了更模块化和可维护的代码库。
- en: The concept of messaging is especially useful when data needs to be passed or
    events need to be communicated between parts of your application that do not have
    a direct relationship. Instead of tightly coupling these parts by having them
    directly call each other, you can use a messaging system where one part sends
    a message that any interested part of your application can receive and react to.
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 当需要在不同部分之间传递数据或通信事件，而这些部分之间没有直接关系时，消息传递的概念特别有用。而不是通过直接调用对方来紧密耦合这些部分，你可以使用一个消息系统，其中一个部分发送的消息可以被应用程序中任何感兴趣的任何部分接收并做出反应。
- en: 'This pattern is a form of the **Observer** pattern, where an object, named
    the **Subject**, maintains a list of its dependents, called **Observers**, and
    notifies them automatically of any state changes, typically by calling one of
    their methods. Similarly, in MVVM, messaging is used to communicate between decoupled
    components of the application: any object in your application, including a ViewModel,
    a service, or a model class or service can send a message, and any other class
    that is subscribed to that particular type of message will be notified and can
    react accordingly.'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 这种模式是**观察者模式**的一种形式，其中名为**主题**的对象维护其依赖者（称为**观察者**）的列表，并自动通知它们任何状态变化，通常是通过调用它们的方法之一。同样，在MVVM中，消息传递用于在应用程序的解耦组件之间进行通信：应用程序中的任何对象，包括ViewModel、服务、模型类或服务都可以发送消息，任何订阅了该特定类型消息的任何其他类都将被通知并可以相应地做出反应。
- en: About MessagingCenter
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 关于MessagingCenter
- en: '`MessagingCenter`, originally introduced in Xamarin.Forms as a mechanism for
    loosely-coupled communication between components, is present but marked as obsolete
    in .NET MAUI. While it’s retained in .NET 8 for transition scenarios, its use
    is discouraged!'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: '`MessagingCenter`最初在Xamarin.Forms中作为组件之间松散耦合通信的机制被引入，但在.NET MAUI中被标记为已弃用。虽然它在.NET
    8中保留以用于过渡场景，但其使用是不被推荐的！'
- en: 'Typically, in the context of MVVM, as shown in the following figure, the messaging
    system itself maintains a list of observers and handles passing messages from
    senders to appropriate receivers:'
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在MVVM的背景下，如以下图所示，消息系统本身维护一个观察者列表，并处理从发送者到适当接收者的消息传递：
- en: '![Figure 7.1: Messaging overview](img/B20941_07_01.jpg)'
  id: totrans-142
  prefs: []
  type: TYPE_IMG
  zh: '![图7.1：消息概述](img/B20941_07_01.jpg)'
- en: 'Figure 7.1: Messaging overview'
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 图7.1：消息概述
- en: 'One notable challenge with the messaging pattern is its inherent opacity: it
    can be difficult to determine which parts of the application are subscribing to
    a particular message. This lack of transparency can lead to unforeseen side effects
    when altering the code and makes the code base more challenging to navigate and
    debug. When I do use messaging, I use it with caution. Keeping messages minimal
    and focused on a specific task can help mitigate this challenge. Another potential
    risk of using messaging is inadvertently causing memory leaks. This can occur
    when an object subscribes to a message but never unsubscribes. If this happens,
    the messaging system continues to hold a reference to the subscriber object, preventing
    it from being garbage collected even if there are no other references to it in
    the application. Over time, this can lead to increased memory usage and can eventually
    degrade the performance of the application.'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 消息模式的一个显著挑战是其固有的不透明性：很难确定应用程序的哪些部分订阅了特定的消息。这种缺乏透明度在修改代码时可能导致不可预见的结果，使得代码库更难以导航和调试。当我确实使用消息时，我会非常谨慎。保持消息最小化和专注于特定任务可以帮助减轻这一挑战。使用消息的另一个潜在风险是无意中造成内存泄漏。这可能会发生在对象订阅了消息但从未取消订阅的情况下。如果发生这种情况，消息系统会继续持有订阅者对象的引用，即使应用程序中没有其他引用，也会阻止它被垃圾回收。随着时间的推移，这可能会导致内存使用量增加，并最终降低应用程序的性能。
- en: This issue is particularly important in the context of MVVM, where ViewModels
    might subscribe to messages during their initialization and then get replaced
    by new ViewModels as the user navigates through the application. If these ViewModels
    don’t unsubscribe from the messages when they’re no longer in use, they will stay
    in memory indefinitely.
  id: totrans-145
  prefs: []
  type: TYPE_NORMAL
  zh: 在MVVM的上下文中，这个问题尤为重要，因为ViewModel可能会在初始化期间订阅消息，然后在用户在应用程序中导航时被新的ViewModel所取代。如果这些ViewModel在不再使用时没有取消订阅消息，它们将无限期地留在内存中。
- en: That’s where `WeakReferenceMessenger` comes in.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 正是这里，`WeakReferenceMessenger` 发挥了作用。
- en: WeakReferenceMessenger
  id: totrans-147
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: WeakReferenceMessenger
- en: The MVVM Toolkit, which we discussed earlier, provides us with a robust messenger
    implementation called `WeakReferenceMessenger`. Designed with MVVM applications
    in mind, this messenger ensures we can enjoy the benefits of messaging without
    worrying about potential memory leaks.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 我们之前讨论过的MVVM Toolkit为我们提供了一个强大的消息传递实现，名为`WeakReferenceMessenger`。考虑到MVVM应用程序的需求，这个消息传递者确保我们可以在不担心潜在内存泄漏的情况下享受消息传递的好处。
- en: Unlike a traditional messenger, which holds strong references to its subscribers,
    `WeakReferenceMessenger` holds weak references. This means it doesn’t prevent
    its subscribers from being garbage collected. So, even if you forget to unsubscribe,
    the garbage collector can still clean up your ViewModel when it’s no longer in
    use, preventing memory leaks.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 与传统的消息传递者不同，后者对其订阅者持有强引用，`WeakReferenceMessenger` 则持有弱引用。这意味着它不会阻止其订阅者被垃圾回收。因此，即使你忘记取消订阅，垃圾回收器仍然可以在不再使用时清理你的ViewModel，从而防止内存泄漏。
- en: Note
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: In this section, we’ll be using `WeakReferenceMessenger` from the MVVM Toolkit
    as our messaging system. However, it’s important to note that other messaging
    systems are available as well. While we’re focusing on `WeakReferenceMessenger`,
    the core concepts we’ll be discussing here – such as sending and receiving messages
    – apply to most messaging systems. Always remember to study and understand the
    specific messaging system you’re working with to make the most of its features
    and avoid potential pitfalls.
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将使用MVVM Toolkit中的`WeakReferenceMessenger`作为我们的消息系统。然而，重要的是要注意，还有其他消息系统可供选择。虽然我们专注于`WeakReferenceMessenger`，但我们在这里讨论的核心概念——例如发送和接收消息——适用于大多数消息系统。始终记得研究和理解你正在使用的特定消息系统，以充分利用其功能并避免潜在的风险。
- en: '`WeakReferenceMessenger` uses a type-based messaging system. This means that
    when you send a message, you specify a message type and only the recipients that
    have subscribed to that specific type will receive the message. The message type
    is typically defined as a class, and the message data is stored as properties
    of that class.'
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`WeakReferenceMessenger`使用基于类型的消息系统。这意味着当你发送消息时，你指定一个消息类型，只有订阅了该特定类型的接收者才会收到消息。消息类型通常定义为类，而消息数据则存储为该类的属性。'
- en: To send a message, you must use the `Send` method, passing in the message object
    and, optionally, a sender and target. The messenger will then deliver the message
    to all the registered recipients for the specified message type. To receive messages,
    a class needs to register with the messenger by calling the `Register` method,
    specifying the message type it wishes to receive, and providing a callback method
    that will be invoked when a message of that type is sent.
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 要发送消息，你必须使用 `Send` 方法，传入消息对象，可选地传入发送者和目标。然后，信使会将消息传递给所有已注册的指定消息类型的接收者。要接收消息，一个类需要通过调用
    `Register` 方法与信使注册，指定它希望接收的消息类型，并提供一个回调方法，当发送该类型消息时将被调用。
- en: Let’s take a look at how we can update our code and make it more loosely coupled
    by using `WeakReferenceMessenger`.
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看我们如何通过使用 `WeakReferenceMessenger` 更新我们的代码，并使其更加松耦合。
- en: Updating the number of servings
  id: totrans-155
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 更新份数数量
- en: 'Through messaging, ViewModels can communicate with each other in a loosely
    coupled manner. As an example, let’s take a look at `IngredientsListViewModel`.
    When updating the value of the `NumberOfServings` property, we loop through all
    elements in the `Ingredients` collection (which are `RecipeIngredientViewModel`
    objects) and call their `UpdateServings` method, passing in the updated value:'
  id: totrans-156
  prefs: []
  type: TYPE_NORMAL
  zh: 通过消息传递，ViewModels 可以以松耦合的方式相互通信。例如，让我们看看 `IngredientsListViewModel`。当更新 `NumberOfServings`
    属性的值时，我们会遍历 `Ingredients` 集合中的所有元素（它们是 `RecipeIngredientViewModel` 对象），并调用它们的
    `UpdateServings` 方法，传入更新的值：
- en: '[PRE29]'
  id: totrans-157
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'This approach is tightly coupled since the property knows about the implementation
    details of other objects, specifically `RecipeIngredientViewModel`. Also, it doesn’t
    adhere well to the **Single Responsibility Principle**: *the property doesn’t
    only concern itself; it is also responsible for updating the values of* *other
    properties.*'
  id: totrans-158
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法紧密耦合，因为属性了解其他对象的实现细节，特别是 `RecipeIngredientViewModel`。此外，它并不很好地遵循 **单一职责原则**：*属性不仅关注自身；它还负责更新其他属性的值。*
- en: So, let’s introduce messaging here!
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，让我们在这里引入消息传递！
- en: As `WeakReferenceMessenger` is a type-based messaging system, we must create
    a new type that we can send and subscribe to whenever the number of servings is
    being updated by the user. Right-click the `Messages`.
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 由于 `WeakReferenceMessenger` 是基于类型的消息系统，我们必须创建一个新类型，我们可以在用户更新份数时发送和订阅。在 `Messages`
    上右键单击。
- en: Right-click the `ServingsChangedMessage`.
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 在 `ServingsChangedMessage` 上右键单击。
- en: Although `WeakReferenceMessenger` can send messages of any type, there are some
    base message classes you might want to inherit from. In this case, we could inherit
    from the generic `CommunityToolkit.Mvvm.Messaging.Messages.ValueChanged` class
    because that is exactly what `ServingsChangedMessage` is for.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然 `WeakReferenceMessenger` 可以发送任何类型的消息，但你可能希望从某些基消息类继承。在这种情况下，我们可以从通用的 `CommunityToolkit.Mvvm.Messaging.Messages.ValueChanged`
    类继承，因为 `ServingsChangedMessage` 正是为了这个目的。
- en: 'The following code block shows the implementation of this class:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 下面的代码块显示了该类的实现：
- en: '[PRE30]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'We can now go ahead and update the `NumberOfServings` method on the `IngredientsListViewModel`
    class. Instead of looping over every item in the ingredients list and calling
    its `UpdateServings` method, we can now send `ServingsChangedMessage`, as shown
    here:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们可以更新 `IngredientsListViewModel` 类中的 `NumberOfServings` 方法。我们不再需要遍历配料列表中的每个项目并调用其
    `UpdateServings` 方法，现在我们可以发送 `ServingsChangedMessage`，如下所示：
- en: '[PRE31]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: Sending a message is as easy as calling the `Send` method on an instance of
    `WeakReferenceMessenger`, passing the message you want to send.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 向 `WeakReferenceMessenger` 的实例调用 `Send` 方法发送消息就像发送一个你想发送的消息一样简单。
- en: 'Finally, we need to update `RecipeIngredientViewModel`. This class will need
    to subscribe to `ServingsChangedMessage` so that it can react to it. Registering
    to a type of message is done by calling the generic `Register` method on `WeakReferenceMessenger`.
    As a type parameter, you need to pass in the type of message you want to listen
    to. Here is one way to register to the `ServingsChangedMessage`:'
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们需要更新 `RecipeIngredientViewModel`。这个类需要订阅 `ServingsChangedMessage` 以便能够对其做出反应。通过在
    `WeakReferenceMessenger` 上调用通用的 `Register` 方法来注册消息类型。作为类型参数，你需要传入你想要监听的消息类型。以下是如何注册
    `ServingsChangedMessage` 的一种方法：
- en: '[PRE32]'
  id: totrans-169
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: The first parameter of the `Register` method is the recipient of the message,
    which in our case will be the class itself. The second parameter is the handler
    that gets invoked when the message is received. The first parameter of the handler
    is the receiver and the second one is the message itself. The passed-in receiver
    allows the Lambda expression to not capture `this`, which improves performance.
    It might also be a good idea to update the access modifier of the `UpdateServings`
    method to `private` as no public access to this method is needed anymore.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: '`Register`方法的第一参数是消息的接收者，在我们的情况下将是这个类本身。第二个参数是当接收到消息时被调用的处理程序。处理程序的第一个参数是接收者，第二个参数是消息本身。传入的接收者允许Lambda表达式不捕获`this`，这可以提高性能。也许将`UpdateServings`方法的访问修饰符更新为`private`也是一个好主意，因为不再需要公开访问这个方法。'
- en: With this updated implementation, the `NumberOfServings` property in `IngredientsListViewModel`
    no longer needs to know about the `RecipeIngredientViewModel` objects. Instead,
    it simply sends a message when its value changes. The `RecipeIngredientViewModel`
    objects, which are subscribed to these messages, can update their state accordingly.
    This decouples the two classes and ensures that each is only responsible for managing
    its own state, adhering to the single responsibility principle and separation
    of concerns.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这个更新后的实现，`IngredientsListViewModel`中的`NumberOfServings`属性不再需要了解`RecipeIngredientViewModel`对象。相反，当其值发生变化时，它只需发送一条消息。订阅这些消息的`RecipeIngredientViewModel`对象可以相应地更新其状态。这种方式解耦了这两个类，并确保每个类只负责管理自己的状态，遵循单一职责原则和关注点分离。
- en: In the following example, we’ll have a look at the fact that messaging isn’t
    only valuable between ViewModels. A service might also send messages that ViewModels
    can respond to.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下示例中，我们将探讨消息传递不仅对ViewModel之间有价值。服务也可能发送ViewModel可以响应的消息。
- en: Keeping favorites in sync
  id: totrans-173
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 保持收藏同步
- en: In the *Recipes!* app, the `RecipesOverviewPage` displays all recipes, and users
    can mark favorites on the `RecipeDetailPage`. However, without reloading `RecipesOverviewPage`,
    newly favorited recipes aren’t highlighted. Given that the recipes database isn’t
    frequently updated, constant page reloads would be overkill and could be bad for
    the user experience.
  id: totrans-174
  prefs: []
  type: TYPE_NORMAL
  zh: 在*Recipes!*应用程序中，`RecipesOverviewPage`显示所有食谱，用户可以在`RecipeDetailPage`上标记收藏。然而，如果没有重新加载`RecipesOverviewPage`，新收藏的食谱不会被突出显示。鉴于食谱数据库不经常更新，频繁的页面重新加载将是过度行为，可能会影响用户体验。
- en: 'A more efficient strategy involves using messaging. When a recipe is favorited,
    a message is dispatched. The individual `RecipeListItemViewModel`s contained within
    `RecipesOverviewViewModel` subscribe to this message, and upon receiving it, they
    update their favorite status in real time. This approach prevents unnecessary
    data fetches, thereby enhancing the app’s performance and responsiveness. Let’s
    see what we need to do to make this work:'
  id: totrans-175
  prefs: []
  type: TYPE_NORMAL
  zh: 一种更有效的策略是使用消息传递。当一个食谱被收藏时，会发送一条消息。`RecipesOverviewViewModel`中包含的`RecipeListItemViewModel`个体订阅了这个消息，并在接收到消息后实时更新其收藏状态。这种方法防止了不必要的请求数据，从而提高了应用程序的性能和响应速度。让我们看看我们需要做什么来实现这一点：
- en: First, let’s add a new message type. Right-click the `FavoriteUpdateMessage`
    as the class name.
  id: totrans-176
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，让我们添加一个新的消息类型。右键单击`FavoriteUpdateMessage`作为类名。
- en: 'Add the following code to the `FavoriteUpdateMessage` class:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将以下代码添加到`FavoriteUpdateMessage`类中：
- en: '[PRE33]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE33]'
- en: This class holds two properties, `RecipeId` and `IsFavorite`, so that with this
    message, we can signal which recipe has been marked or removed as a favorite.
  id: totrans-179
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 这个类包含两个属性，`RecipeId`和`IsFavorite`，这样我们就可以通过这条消息来指示哪个食谱被标记或移除收藏。
- en: 'The following code block shows how we can send this `FavoriteUpdateMessage`
    from the `FavoritesService` whenever a recipe is added as a favorite:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 以下代码块展示了我们如何从`FavoritesService`发送`FavoriteUpdateMessage`，每当一个食谱被添加为收藏时：
- en: '[PRE34]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Similarly, when a recipe is removed as a favorite, a `FavoriteUpdateMessage`
    can be sent, as shown here:'
  id: totrans-182
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，当一个食谱被移除收藏时，也可以发送`FavoriteUpdateMessage`，如下所示：
- en: '[PRE35]'
  id: totrans-183
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'The final step involves subscribing to this message in `RecipeListItemViewModel`.
    This ensures that when a `FavoriteUpdateMessage` arrives, the `IsFavorite` property
    can be updated accordingly. Unlike the previous example, where we defined a message
    handler using the `Register` method, we’ll use a different approach this time
    by implementing the `IRecipient` interface. Here’s how we can do this:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一步是在`RecipeListItemViewModel`中订阅此消息。这确保了当`FavoriteUpdateMessage`到达时，`IsFavorite`属性可以相应地更新。与之前的示例不同，当时我们使用`Register`方法定义了一个消息处理器，这次我们将采用不同的方法，通过实现`IRecipient`接口。下面是如何做到这一点的示例：
- en: '[PRE36]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE36]'
- en: By implementing the `CommunityToolkit.Mvvm.Messaging.IRecipient<TMessage>` interface,
    where `TMessage` is `FavoriteUpdateMessage` in this case, we’re specifying the
    type of message we want to handle. Implementing this interface allows us to call
    the `Register` method of `WeakReferenceMessenger` and pass the class itself as
    the only parameter. The interface requires us to implement the `Receive` method,
    which is invoked when a message of the specified type is received.
  id: totrans-186
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 通过实现`CommunityToolkit.Mvvm.Messaging.IRecipient<TMessage>`接口，其中`TMessage`在这种情况下是`FavoriteUpdateMessage`，我们指定了我们想要处理的消息类型。实现此接口允许我们调用`WeakReferenceMessenger`的`Register`方法，并将类本身作为唯一参数传递。该接口要求我们实现`Receive`方法，当接收到指定类型的消息时，该方法会被调用。
- en: Through the updated code, a message is dispatched whenever a user adds or removes
    a recipe as a favorite. Instances of `RecipeListItemViewModel` are set to listen
    for this message and update their `IsFavorite` property accordingly. As a result,
    when the user navigates back from a detail page, where the favorite status was
    updated, the refreshed status is immediately visible on the overview page – all
    without reloading any data.
  id: totrans-187
  prefs: []
  type: TYPE_NORMAL
  zh: 通过更新的代码，每当用户将食谱添加或删除为收藏时，都会发送一条消息。`RecipeListItemViewModel`的实例被设置为监听此消息并相应地更新它们的`IsFavorite`属性。因此，当用户从更新收藏状态的详细页面返回时，刷新的状态会立即在概览页上可见——而无需重新加载数据。
- en: Note
  id: totrans-188
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: While `WeakReferenceMessenger` provides a robust solution for many messaging
    scenarios, it’s important to use it with caution when dealing with a large number
    of listeners. Always monitor the performance and behavior of your application,
    especially when dispatching messages to thousands of listeners, and consider optimizing
    or reevaluating your design if necessary.
  id: totrans-189
  prefs: []
  type: TYPE_NORMAL
  zh: 虽然`WeakReferenceMessenger`为许多消息传递场景提供了强大的解决方案，但在处理大量监听者时，使用它时需要谨慎。始终监控应用程序的性能和行为，尤其是在向数千个监听者发送消息时，如果需要，考虑优化或重新评估你的设计。
- en: Summary
  id: totrans-190
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: 'In this chapter, we delved into two pivotal topics in the architecture of modern
    applications: DI and messaging. First, we explored DI, a technique for achieving
    loose coupling between objects and their dependencies. In the context of the MVVM
    pattern, we utilized this technique to inject services and other dependencies
    into our ViewModels, enhancing their testability and maintainability.'
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们探讨了现代应用程序架构中的两个关键主题：依赖注入（DI）和消息传递。首先，我们探讨了依赖注入，这是一种在对象及其依赖项之间实现松耦合的技术。在MVVM模式中，我们利用这项技术将服务和其它依赖项注入到我们的ViewModel中，从而增强了它们的可测试性和可维护性。
- en: The latter part of this chapter focused on messaging, another integral component
    in MVVM applications for promoting decoupled communication between components.
    We examined `WeakReferenceMessenger` provided by the MVVM Toolkit, which facilitates
    loose coupling in the application.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 本章的后半部分专注于消息传递，这是MVVM应用程序中另一个重要的组件，用于在组件之间促进解耦通信。我们考察了MVVM Toolkit提供的`WeakReferenceMessenger`，它有助于在应用程序中实现松耦合。
- en: In essence, this chapter aimed to reinforce the importance of loose coupling
    in software design, showcasing how both DI and messaging contribute significantly
    to the creation of maintainable and testable applications.
  id: totrans-193
  prefs: []
  type: TYPE_NORMAL
  zh: 本质上，本章旨在强调软件设计中松耦合的重要性，展示了依赖注入和消息传递如何对创建可维护和可测试的应用程序做出重大贡献。
- en: In the upcoming chapter, we’ll delve deep into the intricacies of navigation
    in .NET MAUI and how we can integrate navigation into our MVVM architecture.
  id: totrans-194
  prefs: []
  type: TYPE_NORMAL
  zh: 在接下来的章节中，我们将深入探讨.NET MAUI中导航的复杂性以及如何将导航集成到我们的MVVM架构中。
- en: Further reading
  id: totrans-195
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 进一步阅读
- en: 'To learn more about the topics that were covered in this chapter, take a look
    at the following resources:'
  id: totrans-196
  prefs: []
  type: TYPE_NORMAL
  zh: 要了解更多关于本章所涉及的主题，请查看以下资源：
- en: 'Dependency injection: [https://learn.microsoft.com/dotnet/architecture/maui/dependency-injection](https://learn.microsoft.com/dotnet/architecture/maui/dependency-injection)'
  id: totrans-197
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '依赖注入: [https://learn.microsoft.com/dotnet/architecture/maui/dependency-injection](https://learn.microsoft.com/dotnet/architecture/maui/dependency-injection)'
- en: 'MVVM Toolkit messenger: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/messenger](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/messenger)'
  id: totrans-198
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 'MVVM Toolkit 消息传递器: [https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/messenger](https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/messenger)'
