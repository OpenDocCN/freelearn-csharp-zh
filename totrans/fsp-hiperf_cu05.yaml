- en: Chapter 5. Advanced Concurrency Support in F#
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We now have a basic understanding of F# concurrency features, including using
    and implementing the best practices of F# asynchronous workflow, and combining
    the asynchronous workflow with .NET APM, EAP, and TAP.
  prefs: []
  type: TYPE_NORMAL
- en: We have seen that `Control.Async` is the basic building block of all related
    asynchronous workflows, in terms of using it and also carefully deciding the best
    practices of using a returned object, especially when we have a nice construct
    of Disposable pattern in the asynchronous workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Know only that the asynchronous workflow features in F# are not unique, in that
    C#/VB already has them, and C#/VB's `async` construct is actually inspired by
    F#. We can further harness the F# advanced asynchronous workflow implementation
    of `MailboxProcessor`, as part of learning and leveraging the advanced concurrency
    support in F#.
  prefs: []
  type: TYPE_NORMAL
- en: Again, we will see that there are no silver bullets for all kinds of concurrency
    problems. We shall see this fact applies to `MailboxProcessor` usage and implementation
    as well.
  prefs: []
  type: TYPE_NORMAL
- en: This chapter describes the advanced concurrency features of F#, focusing on
    F# 4.0\. We are also introducing an overview of best practices to implement and
    optimize, such as combining asynchronous and parallelism, the F# message passing
    agent of `MailboxProcessor`, and further interoperability with .NET TPL.
  prefs: []
  type: TYPE_NORMAL
- en: 'The introduction to concurrency in F# is covered in the following topics:'
  prefs: []
  type: TYPE_NORMAL
- en: Using F# `MailboxProcessor`
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Interoperability with .NET Task Parallel Library (TPL)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Introduction to asynchronous workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Using F# MailboxProcessor
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: F# has extensive features of asynchronous operations such as the way it uniquely
    separates and differentiates from other .NET-managed languages, such as C#/VB,
    Managed C++, Nemerle, IronPython, and IronRuby. But at the same time, it runs
    on top of .NET CLR, providing high compatibility with other languages.
  prefs: []
  type: TYPE_NORMAL
- en: F#'s own unique asynchronous features are not just the asynchronous workflows;
    it has a class that acts as a message passing agent or actor, `MailboxProcessor`.
    The `MailboxProcessor` feature was introduced at the same time as asynchronous
    workflow was released, and the implementation of `MailboxProcessor` itself is
    actually an implementation of a set of asynchronous workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Background case of having message agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The advantage of having an asynchronous model is the fact that we don't have
    to wait for the operation or task to be completely finished before doing something
    else, especially the next operations. The advantage that we don't have to wait
    for the completion of a task is related to the illustrations of blocking operations
    that we mentioned in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to Concurrency in F#*.
  prefs: []
  type: TYPE_NORMAL
- en: Introducing fire and forget pattern
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The most common example of blocking operations is the I/O operation. This may
    include any network operation, including any data transfer-either incoming or
    outgoing. These data transfers take in many forms, ranging from a simple PING
    call (ICMP packets) to complex operations such as uploading files and sending
    emails. The operations, in most cases, are not guaranteed to have responses immediately
    and in many cases *don't need to have replies* as well. Some of the obvious cases
    need responses as soon as possible since most cases have operations that need
    real-time responses when the operations are in session.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can simply conclude that it is intuitive that asynchronous operations can
    be categorized further in terms of the necessity for responses:'
  prefs: []
  type: TYPE_NORMAL
- en: Operations that are invoked by an external party and that don't need to have
    a response/reply back. In many cases, we can simply ignore the status of the completion;
    this is often called the *fire and forget* pattern or model. Once it is fired,
    we can simply forget about waiting for the reply, for example, when sending emails
    or sending commands as messages to an external party or agents expected to execute
    actions based on the commands.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Operations that are invoked by an external party or an internal process on your
    machine that needs a reply after the operations are completed, for example, when
    uploading files or downloading web content, the calling execution needs to be
    notified if the operation is completed. Another example is waiting for an elapsed
    event on a timer in the .NET EAP model. This is often (generally) called **Promises
    model**, in the form of callbacks. We have already covered this in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2
    "Chapter 4. Introduction to Concurrency in F#"), *Introduction to Concurrency
    in F#*.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Both of these are still categorized as asynchronous because of the simplicity
    of not having to wait, and it's also highly predicted to have a non-blocking behavior.
  prefs: []
  type: TYPE_NORMAL
- en: 'Examples of fire and forget pattern (from simple to complex) are as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending emails through SMTP.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending network broadcast messages.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Sending commands to a network printer queue server. This is different from sending
    a command directly to a connected network printer that has to reply, at least
    giving status updates of the out-of-paper status to print job completion.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Not all commands sent to a printer are always fire and forget. There are many
    cases where sending commands to a printer, especially sending commands to a printer
    directly connected to our machine, are not fire and forget.
  prefs: []
  type: TYPE_NORMAL
- en: The operation of sending this command is usually asynchronous, with callbacks
    to notify the status of the finished/completed job.
  prefs: []
  type: TYPE_NORMAL
- en: On an OS such as Windows, sending a command to devices directly connected to
    our machine always requires replies or responses because it is expected that we
    have a response at least showing the status of the device in real time. It is
    normal to have this assumption as a requirement as the printer is directly connected
    to our machine and is also not shared. This is the reason why it is not part of
    fire and forget.
  prefs: []
  type: TYPE_NORMAL
- en: For example, on Windows, all printing operations are handled by the Windows
    Printing API on top of the printer's device driver. In the implementation of the
    Printing API, the commands sent to the printer have the requirement of the availability
    of any printing device installed. It does not care about how many printers are
    installed; it only cares about the status of any printing device available, by
    always querying the availability of a printing device using a Windows Message
    (the `WM_XXX` API) in an event of *message loop*.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'The term *message* in this message loop is different from the message in a
    message queue: the message is an encapsulation of a known system event to ease
    communication of system events. It always happens in loops and can be in the form
    of a looping queue (circular queue), instead of a queue in a message agent that
    does not operate in a loop (open ended queue).'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about the Windows message loop of Windows API, consult
    the MSDN Library at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms644927(v=vs.85).aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: 'It is common in Windows API to have this message loop of calling `GetMessage`,
    coded like this (this code is in C++):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: The preceding code will always loop by examining any incoming Windows `WM_XXX`
    messages. It will end the loop if there are implied errors, especially system
    errors. This common practice is also used in built-in Windows applets, such as
    the applets in the Control Panel (compiled as `.cpl`).
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: We can also implement the code of handling Win32 message loops in F#, but then,
    we have to hook into Win32 API calls by defining the entry point to Win32 API
    using P/Invoke. The P/Invoke declaration is required, but then, F# may lose HWND
    context if the message loop is handled within a non-UI thread. It is highly recommended
    to handle the Win32 message loop in a separate UI thread by explicitly executing
    it as invoking delegates. But interoperatibility with Win32 message API is beyond
    the scope of this book.
  prefs: []
  type: TYPE_NORMAL
- en: The queue used in this context can be a combination of an ordinary queue and
    the usage of round-robin, or it can be a simple queue, such as first come first
    served, and the incoming message is queued at the last line of the queue but the
    queue line itself always *moves forward*.
  prefs: []
  type: TYPE_NORMAL
- en: '**Round-robin** is one of the examples of queue handlings. But round-robin
    has its own overhead: it moves the pointer of the queue and also the data within
    the queue line. If this overhead pointer movement is executed in memory, the overhead
    cost might be deferred by high speed access to memory. This is why round-robin
    is also popular in the operating system world, from the use of the message loop
    to the scheduling of running processes, threads, and *coroutines*.'
  prefs: []
  type: TYPE_NORMAL
- en: The coroutine is quite common in many platforms, including .NET, Windows, and
    UNIX. In .NET, a sample coroutine is the yield iterator's implementation detail
    in C#/VB and F#. In Windows, a sample of a coroutine is the implementation of
    *fibers* in Windows (since Windows 2000). However, fiber in Windows and coroutine
    in .NET are different in semantics.
  prefs: []
  type: TYPE_NORMAL
- en: 'What is coroutine? There are many definitions of coroutines but not all of
    them are correct in the sense of the concurrency and runtime of any managed language/platform.
    The cleanest and simplest definition is available from the MSDN Library. Coroutine
    is defined as:'
  prefs: []
  type: TYPE_NORMAL
- en: '*Coroutine is a method that can stop in mid-execution and provide a value to
    the caller without returning program flow.*'
  prefs:
  - PREF_BQ
  type: TYPE_NORMAL
- en: 'This definition is taken from this MSDN Magazine on the MSDN Library:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineSeptember2003en-us.chm](http://download.microsoft.com/download/3/a/7/3a7fa450-1f33-41f7-9e6d-3aa95b5a6aea/MSDNMagazineSeptember2003en-us.chm)'
  prefs: []
  type: TYPE_NORMAL
- en: It is quite the same as yield, where yield can stop in the middle of the execution
    and will continue as needed. C#/VB/F# yield and Windows fibers are very good sample
    implementations of coroutine that can have multiple entries and exits, depending
    on the state we are handling.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about fiber in Windows API, visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/windows/desktop/ms682661(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/windows/desktop/ms682661(v=vs.85).aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'NOTE: We are not going to dive further into the implementation detail of coroutine
    in .NET, especially on yield. The implementation detail of the yield iterator
    may change in the future .NET versions after .NET 4.6\. However, it is important
    to at least have a basic understanding of coroutine.'
  prefs: []
  type: TYPE_NORMAL
- en: A simple evidence of this message loop in action, always querying printing devices,
    can be seen in how Windows displays the current status of a print job in the Print
    Management applet in Windows 8/8.1 and Windows 10.
  prefs: []
  type: TYPE_NORMAL
- en: 'The Print Management applet in the legacy Control Panel always displays the
    current status of any available installed and connected printers:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing fire and forget pattern](img/image00293.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The Printing API is also a good sample of Promises in action because a reply
    to notify that a print job is completed; it is a promise to at least give response
    that a print job is either completed or failed.
  prefs: []
  type: TYPE_NORMAL
- en: Other samples of Promises are the same as those of TPL, .NET EAP and APM. Basically,
    the semantics are mostly in the form of a notification when the action is completed.
  prefs: []
  type: TYPE_NORMAL
- en: There is a mixture of the f*ire and forget* model and the *Promises* model,
    although the promise in this mix may not be a true promise in the implementation
    details.
  prefs: []
  type: TYPE_NORMAL
- en: For example, we want to have an asynchronous way of processing any of the incoming
    transactions against savings accounts, and the transactions are expected to have
    commenced across many kinds of savings accounts. Even in the same bank, a person
    can have multiple accounts that may have traffic of incoming and outgoing transfers,
    either scheduled or manual.
  prefs: []
  type: TYPE_NORMAL
- en: It is optional to notify that the incoming transfer is successfully credited
    to the account. And this is also a promise, although it is not mandatory to be
    enforced to notify back a successful transaction. If it is mandatory, then a reply
    will be sent back later. But this reply can be made using an event triggered when
    the incoming transfer has been calculated as credited into the account. At the
    implementation detail, the notification on the receiving agent is not mandatory
    after all; the customization may be added as an event trigger.
  prefs: []
  type: TYPE_NORMAL
- en: In the case of online e-commerce, the response is mandatory, as the transactions
    of any purchase must have a reply immediately, as close to real time as possible.
    Then the promise is enforced, although it is not a pure promise after all, as
    the receiver is using an event trigger for any incoming successful transaction
    that it will send a notification back to inform a failed/successful transaction.
    The wait for any incoming transaction is continuous. It is similar to always listening
    to any incoming signal of an incoming operation. Therefore it is also often simply
    called a *listener*, to always listen for any incoming transactions.
  prefs: []
  type: TYPE_NORMAL
- en: 'This difference of having a promise is illustrated in the following simplified
    flow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing fire and forget pattern](img/image00294.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the previous illustration, the wait for an incoming transaction usually happens
    on an agent. In the case of a standalone message queue manager, it is also a sophisticated
    or standalone listener.
  prefs: []
  type: TYPE_NORMAL
- en: This is also a good sample of an agent to handle the transaction in the form
    of messages that contain the operation request to withdraw, transfer, or even
    receive a money transfer.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider this sample scenario of this agent:'
  prefs: []
  type: TYPE_NORMAL
- en: 'A data wrapper with the necessary information about the operations (any related
    bank account transactions) to be carried out that is then processed by a centralized
    process that is to be sent while waiting for any incoming data to be consumed.
    Usually, all of the data sent and received is stored and processed with first
    come first served or **first in first out** (**FIFO**) in a data structure: a
    queue.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The agent must be as scalable as possible. It means it must be able to serve
    a large number of requests per second. The initial website is usually assumed
    to be able to serve 500 to 1,000 requests per second, so the initial projected
    maximum requests to be served is 1,000 requests.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the preceding scenario, why does it have to be a queue?
  prefs: []
  type: TYPE_NORMAL
- en: The agent was initially planned to serve more than 1,000+ requests at a time.
    There is no guarantee that the web server can serve more than 1,000 requests *at
    a time and at the same time*. In order to do this precisely, we have to be sure
    that at least 1,000 requests are sent and received at the same time. This means
    we must have parallel I/O at the heart of the hardware side, which is very expensive
    and very difficult to implement and set up. Therefore, having parallel I/O to
    enforce this simulation is not quite scalable for the current needs, and it's
    also not quite feasible in terms of implementation speed (time to implement) and
    scalability.
  prefs: []
  type: TYPE_NORMAL
- en: If we are relying on the scalability of the available I/O throughput, this is
    not an option because pure hardware scalability has more initial expensive costs.
    If we rely on serving the requests optimally by increasing the number of CPU cores,
    this is also not an optimal solution. Web requests usually consume less on CPU
    and more on network (hence I/O) bandwidth. On the consumer of the requests, there
    can be a wait on the I/O side, and this can block the next request to be processed,
    although handling this can be optimized using the asynchronous workflow that we
    described in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to Concurrency in F#*.
  prefs: []
  type: TYPE_NORMAL
- en: The number of requests to be processed must be processed as first come first
    served. This fits into the FIFO model, and the best data structure to handle this
    is queue. The use of queues will always ensure that the first request is always
    to be processed first and then there are some actions processed afterwards.
  prefs: []
  type: TYPE_NORMAL
- en: The process of inserting new data is called *enqueue*, while removing the first
    item of the data is called *dequeue*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is an illustration of the incoming of requests and processing
    in a queue:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introducing fire and forget pattern](img/image00295.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The queue of requests is usually seen as a block of data to be sent and received,
    and this is often called as message, because of the conceptual similarity to sending
    and receiving emails.
  prefs: []
  type: TYPE_NORMAL
- en: The one software component that is responsible for managing incoming requests
    as queue and sending replies when needed is usually called a message queue manager.
    From F# perspective, it is called a message agent, or in MSDN terms, it is often
    simply called an agent. It is also called an *actor*, and this actor model is
    discussed in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of a message agent
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: This agent/ manager handles every message that is sent from senders (also called
    *producers*) and receives each message, which is then processed. The receivers
    can be from one to many receivers.
  prefs: []
  type: TYPE_NORMAL
- en: 'The overall main focuses in terms of the agent''s operations are on:'
  prefs: []
  type: TYPE_NORMAL
- en: Sending a message (including preparations before and after). Sending is simply
    a sending from message agent A to message agent B.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Receiving a message (including storing, processing). Message agent B receives
    messages from message agent A.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The following illustration depicts the sending of the message with the queue
    processing:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of a message agent](img/image00296.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The sending and receiving operations are handled in a different context, but
    both sending and receiving use queues.
  prefs: []
  type: TYPE_NORMAL
- en: 'When a message agent is sending a message, these are the activities performed:'
  prefs: []
  type: TYPE_NORMAL
- en: A queue is allocated. The main allocation to be considered is the available
    memory, then the physical storage.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The message to be sent is prepared with this convention first: the format of
    each message must have the same format, so the message will be processed in a
    predictable manner.'
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The message to be processed before sending usually comes in many forms. In the
    case of F# or any other lightweight agent, the message can be in the form of any
    object.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The object is then serialized as raw strings.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Serialization of the objects is then to be wrapped in a certain format. For
    example, the message can have headers and footers with additional information
    on how to process the message further.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The end result of the wrapped message is ready to be sent. At this time, any
    additional checks may be run, such as checking the availability of the network.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The agent sends the message. The transfer protocol used by the agent is the
    same protocol as the receiver.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The receiving side is illustrated as shown:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of a message agent](img/image00297.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'As illustrated, a queue on the agent that receives the messages is needed because:'
  prefs: []
  type: TYPE_NORMAL
- en: The incoming messages may come in close intervals; therefore, a minimum waiting
    time or minimal latency is expected. Also, incoming messages need to be stored
    before being processed, and the order of receiving is very important, as implied
    by FIFO.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The queue can be optimized further by processing it in memory as needed, and
    as much as possible, as long as it matches the available memory allocation with
    respect to the maximum available memory of the running agent. For example, a machine
    with 32 GB of RAM will of course process the queue more efficiently than a machine
    with 16 GB of RAM.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: By default, a queue is stored on heap but using a predefined size; therefore,
    there is minimal overhead in accessing a queue on heap. This is also the same
    for the queue when it comes to sending messages as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the activities that happen when receiving a message:'
  prefs: []
  type: TYPE_NORMAL
- en: A queue is allocated. This step is actually the same as step 1 in the sending
    message previously.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The incoming message is checked for deserialization problems according to the
    agreed format from message agent A. This validation is necessary because there
    is no guarantee that all incoming messages are valid. This is the first difference
    in handling messages between sending and receiving.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The receiving messages are not guaranteed to always arrive in the same sequence
    as they were sent. For example, it is not guaranteed that the first message sent
    will be received first. It is quite normal/common for the order of the message
    sent not to be the same as the message received. This is the second of the differences
    between sending and receiving messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: A valid incoming message is enqueued. The first incoming message will be processed
    first. This first incoming message might not be the first message sent.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: When it is ready to be dequeued (after a certain wait for the previous incoming
    message to be dequeued), the message content is waiting to be deserialized further.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The content of the message is deserialized from `String` to an object, and can
    be processed further as resulting data.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: It is up to the implementer to further process the queue to be ordered by certain
    conditions before being dequeued and this may vary. This can be the subject of
    evidence of being falsely treated as synchronous because the ordering of the queue
    will yield some process overhead and the consumer of the message will have to
    wait. The handling of received messages may vary in a sense that the queues may
    have raw FIFO without considering the order of the time the message was sent or
    will try to process the received messages in time order as long as it is guaranteed
    to proceed using certain configurations. However, using this sequence of enforcing
    the order of the message received by the time they were sent will defeat the nature
    of the message queue agent since the message received will be forced to wait for
    the earlier messages to arrive.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is not the same as the era of the legacy modem as the full connection
    on both sides is required to ensure continuous synchronous communication. If a
    message agent is supposed to have full real-time processing while always waiting
    for the result immediately, then a message agent will always be forced to wait
    indefinitely for incoming replies, and this will defeat the main purpose of a
    message agent itself: processing message asynchronously. Anything waitable, concerns
    (usually processes) is mostly blocking, and if the waiting is executed explicitly,
    then it will block the next operation or process to be executed.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The synchronous operations on a modem are not related to how the communication
    channels the transfer, either half duplex or full duplex. Many of us are mixing
    synchronous with half duplex/full duplex, and it is wrong. These concepts are
    not related at all.
  prefs: []
  type: TYPE_NORMAL
- en: The receiving of the message handling can also use a temporary storage to hold
    received messages if necessary. This is crucial if each message may contain certain
    operations or instructions to be processed heavily, for example, instructions
    to calculate the current positions of a pricing forecast.
  prefs: []
  type: TYPE_NORMAL
- en: The handling of the messages to be sent is processed in queues, the first message
    to be sent being processed first. This is the same as handling the received messages
    where the first message received is processed first. One of the important factors
    in handling the messages is **serialization**. There might be overhead on the
    serialization and deserialization of the object in the message.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of serialization
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Serialization and deserialization are often described as simply serialization.
    It is defined as how an object is flattened to a string of properties and values
    and the reverse: the construction of an object from a string of properties and
    values. The serialization part is actually an operation of flattening an object
    (or class in the type system), which is also called deconstruction of an object
    because the semantics of an object are translated into a string that describes
    the class, property, and values. The value of the properties must be serialized
    successfully too because we have to be able to deserialize back into the original
    object representation without changing the semantic value.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Serialization and deserialization are illustrated (simplified) in the following
    image:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of serialization](img/image00298.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The simplest example of a working serialization is available in how we create
    our own custom serialization to translate an object's properties and its value's
    implementation using a basic override of the `ToString` method, which is available
    in `System.Object`. This `System.Object` class is inherited by all classes in
    .NET because `System.Object` is the parent object of all types in .NET. We can
    override the `ToString()` method to represent the content of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we have a `Person` class, defined as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'The following are the explanations for the preceding code:'
  prefs: []
  type: TYPE_NORMAL
- en: The `Person` class overrides the `ToString()` method with the necessary `StringBuilder.Append`
    operations to construct a string representation of `Person`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The `StringBuilder` of `sb` is used as mutable because it is fine to have mutability
    in a locally scoped function/method because this symbol is not used outside the
    scope of the function and the side effect is still transparent. The property values
    are separated with `|`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The code uses the `val` keyword in the property member declaration because the
    property is using the auto setter and getter.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'A semantic description of the auto properties of setter-getter syntaxes for
    F# is beyond the scope of this book. For more information on the auto properties
    of F#, consult this MSDN Library page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/properties](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/members/properties)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The semantics of F# auto properties (auto setter and getter with backing fields
    automatically generated by compiler) are same as C#/VB auto properties. Only the
    internal naming of the backing properties has different implementation details,
    but this should not be our concern at all since we do not care about the backing
    field.
  prefs: []
  type: TYPE_NORMAL
- en: 'We then add the code to display the serialization representation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: 'Let''s run the code, and we will see that it will display the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of serialization](img/image00299.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The cost of serialization is usually cheaper than deserialization, as it tries
    to flatten the object (the attributes or properties of the object) into strings
    that define the property name and the values. The property value is then converted
    to `String` by implicitly or explicitly calling the `ToString()` method. This
    is actually a simplified sample that we can also write our own serializer to further
    optimize or to fully streamline the process.
  prefs: []
  type: TYPE_NORMAL
- en: Deserialization is more expensive because it tries to construct a type based
    on the string value, because we must maintain the semantics of the properties
    and the properties values from the serialized `String`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is a simplified sample of deserialization (add this code below
    the `Person` type declaration):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'To test this function, we now modify the `EntryPoint` code to test `Deserialize`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: We mark `Deserialize` as `static` because the main intention is to deserialize,
    not depend on the object that does the deserialization. We can test this deserialization
    by calling `Deserialize` with the existing serialized `ToString()` result with
    its parameter as demonstrated.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the display output of the result of `anyperson3.ToString()`
    combined with the previous `anyPerson1` and `anyPerson2`:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of serialization](img/image00300.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: The resulting display output now has proven that we have successfully constructed
    the object from the serialized `String` by checking the same value of `anyPerson1`
    with `anyperson3`. This sample is too simple for this demonstration, but it truly
    demonstrates that there are certain requirements that have to be met before having
    successful deserializations.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the mandatory requirements for successful deserializations:'
  prefs: []
  type: TYPE_NORMAL
- en: The serialized format must be agreed upon and must have the same structure format
    as the serializer. In terms of implementation, the type of serialization object
    must be the same type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The serialization and deserialization must have as simple type as possible;
    otherwise, complex serialization and deserialization will occur. For example,
    serializing the object that implements the COM object, whereas implicit marshalling
    will always occur and crossing the thread boundary across *STA* and *MTA* threads
    will always yield unpredictable results, often yielding errors not in the form
    of a thrown exception.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The serialization of an object has to be a concrete object (a class); otherwise,
    an overhead of type check casting will occur. For example, serializing an interface
    is not recommended as the deserialization will always try to create an instance
    of a concrete class, and a runtime error will occur.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: In common/daily practice, it is recommended to use an existing serializer with
    an already commonly-used format such as JSON, for example, `DataContractJsonSerializer`
    in the WCF class libraries, under the namespace of `System.Runtime.Serialization.Json`,
    and the commonly used third party serializer, NewtonSoft JSON serializer.
  prefs: []
  type: TYPE_NORMAL
- en: Introduction to F# MailboxProcessor
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Now, we have the basic knowledge of what a message agent is, and we have also
    highlighted how this agent operates as to how it sends and receive messages. It
    is time to find out more about the F# message agent, F# `MailboxProcessor`. For
    the rest of this book, we will simply use `MailboxProcessor` as a class and as
    an agent.
  prefs: []
  type: TYPE_NORMAL
- en: The `MailboxProcessor` is actor based. It may have multiple threads spawned
    or just a single thread. In a sense it is an actor because as an actor, it can
    have its own role. In their implementation detail, the actors can act on their
    own without depending on other actors (although they might have the same responsibilities
    or same behaviors). Actors can be implemented to have the same responsibilities,
    such as an actor/agent to process incoming requests or to process sending requests.
  prefs: []
  type: TYPE_NORMAL
- en: The writer of `MailboxProcessor` can also be seen as a producer while the reader
    can be seen as a consumer.
  prefs: []
  type: TYPE_NORMAL
- en: 'The lightweight aspects of `MailboxProcessor` are unique. It is not just lightweight
    in terms of being standalone and built-in to the core F#, but also:'
  prefs: []
  type: TYPE_NORMAL
- en: It is quite easy to start using it because it operates without dependency on
    how the underlying operating system does asynchronous operations.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It will not store the messages, so they are not persistent
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It can be further combined with F# asynchronous workflow
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It does not have an advanced infrastructure that has many configurable environment
    settings such as IBM Websphere MQ and MSMQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Other than those unique traits, the concept of F# `MailboxProcessor` queue agent
    is similar to famous message queue manager software such as IBM Websphere MQ (formerly
    IBM MQ Series) and Microsoft MQ (also called MSMQ). It is used to handle asynchronous
    message transfers.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about IBM Websphere MQ, visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[http://www-03.ibm.com/software/products/en/ibm-mq](http://www-03.ibm.com/software/products/en/ibm-mq)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about MSMQ, visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx](https://msdn.microsoft.com/en-us/library/ms711472(v=vs.85).aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: F# `MailboxProcessor` as agent is not completely standalone (not external) because
    `MailboxProcessor` is part of F# core libraries, so we can use and leverage it
    quickly instead of having an assessment and installation setup activities before
    using it.
  prefs: []
  type: TYPE_NORMAL
- en: 'The disadvantages are:'
  prefs: []
  type: TYPE_NORMAL
- en: If many messages are sent or received, we must implement our own storage to
    store them. This means we maintain our own storage of a queue of messages as,
    by default, `MailboxProcessor` messages are not persistent.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We must manage how we further optimize the queue operations as `MailboxProcessor`,
    by default, relies on operating at runtime with no offline storage feature to
    hold the queues.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: If the order of prioritization is critical, we cannot further customize how
    `MailboxProcessor` is going to use the thread affinity of the underlying machine
    on Windows because there is no way to do this. This is intentional, as the lightweight
    of `MailboxProcessor` always hides the implementation details of the synchronization
    of prioritization on the thread executions.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In the realm of F#, `MailboxProcessor` has the ability to write messages to
    send (*writer*) and to read incoming messages (*reader*).
  prefs: []
  type: TYPE_NORMAL
- en: 'The writer-reader model is often mentioned in the MSDN Library on the MSDN
    landing page of `Control.MailboxProcessor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.mailboxprocessor%5b%27msg%5d-class-%5bfsharp%5d](https://msdn.microsoft.com/visualfsharpdocs/conceptual/control.mailboxprocessor%5b%27msg%5d-class-%5bfsharp%5d)'
  prefs: []
  type: TYPE_NORMAL
- en: This reader-writer model shows that `MailboxProcessor` only focuses as an agent
    on writing a message and then sending it, and reading incoming messages. It may
    focus on one responsibility to only send, receive, or both.
  prefs: []
  type: TYPE_NORMAL
- en: If we set `MailboxProcessor` to have both send and receive, the sending and
    receiving processes cannot both be guaranteed to be at the same time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s look at a simplified sample of `MailboxProcessor` by constructing and
    simulating an email message. The sample code in the landing page of F# `Control.MailboxProcessor`
    is actually a script file instead of a common code file because we need to evaluate
    and test the result immediately, a good practice for REPL interactive of F# interactive:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: Start evaluating the previous code by pressing *Alt* + *Enter*.
  prefs: []
  type: TYPE_NORMAL
- en: 'The F# Interactive will evaluate the code sequentially, and this is the walkthrough
    of the semantics:'
  prefs: []
  type: TYPE_NORMAL
- en: Open the `System` namespace and `Microsoft.Fsharp.Control`. The `Microsoft.FSharp.Control`
    namespace is needed for `MailboxProcessor`. We are using `System` namespace because
    we are going to use `Console` to display the output later.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We create `EmailMessage` type to wrap the message we are going to use. The message
    is simple as it contains the sender (`From`), the destination, the optional CC,
    subject, and the content of the message. The properties are initialized in the
    default constructor.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: All of the properties use the explicit type declaration for more clarity.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The mailbox symbol is inferred as a `MailboxProcessor` instance with the parameterized
    type of `EmailMessage` as the message type.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The constructor of `MailboxProcessor` is a lambda that contains the loop of
    receiving messages.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: This lambda contains a recursive function of loop, and it uses `return!` to
    signify that the returning call of loop is within the asynchronous workflow boundary.
    In the implementation details, `return!` is further translated to calls to `AsyncBuilder.Return`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Received messages are handled by asynchronously getting results by calling the
    type inferred by the parameter of the lambda, `inbox`. `inbox` is actually typed
    as `MailboxProcessor<Message>`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The use of `return!` is crucial because the nature of the recursive function
    of a loop is contained inside an asynchronous workflow. If we use only `return`
    instead of `return!`, it will leak the call state outside the boundary of the
    `async` construct, which can then yield memory leaks in crossing the context.
    This `return!` is translated into calls to one of the F# asynchronous workflow
    builders, `AsyncBuilder.Return`, before it actually returns the call of `loop`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The internal implementation detail is available in the IL. Compile and start
    ILDASM, then if we open the compiled exe, we can examine the generated classes
    of loop. In one of the loops, we shall see it calls the `FSharp.Control.FSharpAsyncBuilder.Return`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: It has the `FSharpAsyncBuilder.Return` call before it actually returns to outside
    scope.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: All of the F# `AsyncBuilder` is compiled under the name of `FSharpAsyncBuilder`.
    This is also reflected in the generated IL.
  prefs: []
  type: TYPE_NORMAL
- en: 'Then, let''s see `MailboxProcessor` in action:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'This is the output of the previous code:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Introduction to F# MailboxProcessor](img/image00301.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s dive further into the code:'
  prefs: []
  type: TYPE_NORMAL
- en: The mailbox symbol is in fact an instance of `MailboxProcessor` with a default
    constructor of one parameter and the body of the message typed as `Message`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: After we have the `MailboxProcessor` instance, we can begin to initialize the
    mailbox as an agent by calling the `Start()` method.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We can then send messages by calling `Post()` with the message as the parameter;
    each call of the `Post()` method is guaranteed to be asynchronous.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: From the perspective of `MailboxProcessor`, the writer operation is represented
    by calling `Post()`, and this is also the sending operation; the reader is represented
    by calling `Receive()`, and this is also the receiving operation.
  prefs: []
  type: TYPE_NORMAL
- en: This is why the type name starts with *Mailbox* because it is quite similar
    to the mailbox as a starting container to send and receive letters that contain
    messages in everyday life.
  prefs: []
  type: TYPE_NORMAL
- en: Now let's dive into `MailboxProcessor` features.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of MailboxProcesor features
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: '`MailboxProcessor` has two constructors, the simplest constructor being the
    one that takes one parameter of delegate. The second one takes two parameters:
    a delegate and a `CancellationToken` object.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the syntaxes of the constructors:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: In the previous sample, we called the constructor with a delegate. This delegate
    is the main entry of the read loop when `MailboxProcessor` starts (as initialized
    by calling the `Start()` method).
  prefs: []
  type: TYPE_NORMAL
- en: Not all of the operations in `MailboxProcessor` are useful for all cases; that
    depends on the usage and the detail of the asynchronous operations we want to
    use. In fact, similar to the other message agents, `MailboxProcessor` does not
    guarantee that the sequence of the received messages will always be the same as
    the sequence of sent messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the interesting functions/methods of `MailboxProcessor`:'
  prefs: []
  type: TYPE_NORMAL
- en: '| **Function** | **Quick Remark** |'
  prefs: []
  type: TYPE_TB
- en: '| `Post` | Posts a message to the message queue of `MailboxProcessor` asynchronously.
    Should not be mixed with non-F# `async` such as C#/VB `async`. The posting of
    a message does not mandate `MailboxProcessor` to return any success/failure status
    of the posting action. |'
  prefs: []
  type: TYPE_TB
- en: '| `PostAndAsyncReply` | Posts a message to an agent and awaits a reply on the
    channel, asynchronously. Should not be confused with non-F# `async` such as C#/VB
    `async`. It requires us to always handle the reply of the message. |'
  prefs: []
  type: TYPE_TB
- en: '| `PostAndReply` | Posts a message to an agent and awaits a reply on the channel,
    synchronously. The sending of the message is still asynchronous. Should not be
    mixed with non F# `async` such as C#/VB `async`. It requires us to always handle
    the reply of the message. |'
  prefs: []
  type: TYPE_TB
- en: '| `PostAndTryAsyncReply` | Similar to `PostAndAsyncReply` but returns `None`
    if there is no reply within the timeout period. Should not be mixed with non-F#
    `async` such as C#/VB `async`. It requires us to always handle the reply of the
    message. |'
  prefs: []
  type: TYPE_TB
- en: '| `Receive` | Waits for a message. This will consume the first message in the
    arrival order. Should not be mixed with non-F# `async` such as C#/VB `async`.This
    `Receive` action has the same type of object as defined by the sending action.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Scan` | Scans for a message by looking through messages in arrival order
    until the scanner returns a `Some` value. Other messages remain in the queue.This
    scanning action will mostly block the message replies of `Receive` and `TryReceive`.
    |'
  prefs: []
  type: TYPE_TB
- en: '| `Start` | Starts the agent. The start of the agent may be included within
    a parallel loop, such as `Parallel.For` or `Parallel.ForEach`. |'
  prefs: []
  type: TYPE_TB
- en: '| `TryPostAndReply` | Similar to `PostAndReply` but returns `None` if there
    is no reply within the timeout period. Should not be mixed with non-F# `async`
    such as C#/VB `async`. |'
  prefs: []
  type: TYPE_TB
- en: '| `TryReceive` | Waits for a message. This will consume the first message in
    the arrival order. It also enforces synchronicity instead of receiving asynchronously.
    Returns `false` if the receiving message fails. Should not be mixed with non-F#
    `async` such as C#/VB `async`.The `Receive` action has the same type of object
    as defined by the sending action |'
  prefs: []
  type: TYPE_TB
- en: '| `TryScan` | Scans for a message by looking through the messages in the arrival
    order until scanner returns a `Some` value. Other messages remain in the queue.
    The queue is only stored in memory. |'
  prefs: []
  type: TYPE_TB
- en: In the previous table, all of the standard posts and replies, such as `Post`,
    `PostAndReply`, and `PostAndAsyncReply`, should not be used within the C#/VB `async`
    construct. The post and reply operations implemented in F# have their own thread
    synchronizer. This F# synchronizer often has unpredictable results when used within
    C#/VB `async` construct; mixing this different asynchronous model will make the
    F# synchronizer have race condition when switching back and forth between different
    execution contexts.
  prefs: []
  type: TYPE_NORMAL
- en: Further implementations of MailboxProcessor
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: 'Based on the previous table, `MailboxProcesor` can also send messages and wait
    for replies, not just send (post) messages. The following operations that do the
    sending and waiting for reply immediately after sending:'
  prefs: []
  type: TYPE_NORMAL
- en: '`PostAndAsyncReply`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostAndReply`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`PostAndTryAsyncReply`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TryPostAndReply`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: All these send and receive operations require a handle in F#. It is called `AsyncReplyChannel`,
    contained in the `Control.AsyncReplyChannel` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'These are the common steps for using `MailboxProcessor`:'
  prefs: []
  type: TYPE_NORMAL
- en: We must plan the format of the message to be transferred and received. The format
    of the message has to be as simple as possible.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The agent is created by instantiating it. At this stage, we have to decide whether
    the operation of sending and receiving messages can be canceled anytime by calling
    the `MailboxProcessor` constructor, which has the delegate and `CancellationToken`
    passed.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The delegate may contain both the sending and receiving message operations,
    or just receiving operations.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we require it to send and wait for replies, we must carefully construct the
    delegate to include `AsyncReplyChannel`. It is recommended to embed this handler
    inside the message itself because, then, we can enforce that the reply of the
    sent message is closely related.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: To see this sample of sending and waiting for reply in action, we also use the
    F# flexible type declaration to add more flexibility when handling messages.
  prefs: []
  type: TYPE_NORMAL
- en: 'At the declarations of the message, `AsyncReplyChannel` is embedded in the
    message itself:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: 'This is an excerpt of the code that creates the instance of `MailboxProcessor`
    and performs the receiving using handles:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: It is also nice to know that type inference not only flows nicely not just as
    an inferred type declaration and inferred return type but also accommodates the
    d*iscriminated unions* that infers the constructor of the type.
  prefs: []
  type: TYPE_NORMAL
- en: For example, let's see the declaration of the `ComplexMessage` type that has
    discriminated unions with our own previous `EmailMessage` embedded.
  prefs: []
  type: TYPE_NORMAL
- en: 'We can now combine this with pattern matching that checks for any Query as
    its *subtype*:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: It is also very nice to know that again this feature is unique to F#, as the
    current release of C#/VB does not have this discriminated union feature yet.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: There are rough plans to have discriminated union supported in C#/VB, but it
    is still debated. Also pattern matching is due in the upcoming version of C# 7,
    and VB 15 does not have the same automatic type inferences as F#. Consult Microsoft's
    Roslyn repo on GitHub to keep up with the latest developments in C#/VB language
    design.
  prefs: []
  type: TYPE_NORMAL
- en: 'A detailed description of the discriminated union is beyond the scope of this
    book because we cannot further optimize discriminated union. For more information
    on F#''s discriminated union, visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions](https://docs.microsoft.com/en-us/dotnet/articles/fsharp/language-reference/discriminated-unions)'
  prefs: []
  type: TYPE_NORMAL
- en: The pattern matching in the sample code can be further optimized. We will describe
    the optimizations of pattern matching as part of the F# language constructs (beside
    asynchronous workflow) later in [Chapter 7](fsp-hiperf_cu07.html#aid-1ENBI1 "Chapter 7. Language
    Features and Constructs Optimization"), *Language Features and Constructs Optimization*.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test the sending and receiving in action simultaneously, we can send (post)
    the message while at the same time waiting to receive the message:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Since we have embedded the channel inside the message, we can have a quick guarantee
    that for each message we receive, we can always try to relate the message we receive
    to the message we send because we are using the same `AsyncReplyChannel`.
  prefs: []
  type: TYPE_NORMAL
- en: Looking back at the definition of the delegate inside the constructor of `marketMaker`,
    it matches the query pattern of a `Message` type, which then returns the related
    asset based on the message posted by `PostAndReply`.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we have extended our understanding of `MailboxProcessor` using the sample
    of an order and sell transaction. It is still similar to a bank account model
    transaction, but we do not care how many parts or asset balances we have.
  prefs: []
  type: TYPE_NORMAL
- en: Managing side effects inside MailboxProcessor and asynchronous workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We may have been tempted to use a `MailboxProcessor` instantiation wrapped within
    an asynchronous workflow. *It is not recommended to have this overly complex wrapper
    as MailboxProcessor already has its own asynchronous context*.
  prefs: []
  type: TYPE_NORMAL
- en: This is also applied to interoperability with the UI thread as well as asynchronous
    context should not be mixed with the UI thread directly. Mixing the UI thread
    with asynchronous contexts will yield unpredictable results.
  prefs: []
  type: TYPE_NORMAL
- en: If we must use Windows forms, it is best to have asynchronous workflow and the
    UI coded in F#. Using WPF, we can use WPF Dispatcher to ensure we will not have
    cross-thread violation.
  prefs: []
  type: TYPE_NORMAL
- en: On managing side effects, using `MailboxProcessor` to do side effects activity
    must be handled carefully.
  prefs: []
  type: TYPE_NORMAL
- en: 'Consider these scenarios and the reasons:'
  prefs: []
  type: TYPE_NORMAL
- en: Upon receiving the messages inside the delegate parameter of a `MailboxProcessor`
    instantiation, we have calls to get web content asynchronously. These multiple
    asynchronous contexts are not recommended because there can be race conditions
    on which processes are to be finished and return the call back to the calling
    delegate. This added complexity will add overhead to the stack because there is
    no guarantee that `MailboxProcessor` will handle the asynchronous scheduling correctly.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: If we still want to do this, every call to get the web content must be handled
    using the Disposable pattern as far as possible in order to minimize the pointer
    leak of the call stack.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: The original intent of `MailboxProcessor` is to have a role as message agent.
    The delegate and the payload of the message should be constructed to be as simple
    as possible. If we want to use `AsyncReplyChannel`, it is recommended to embed
    it as part of the message.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Wrapping `MailboxProcessorPost` and `Reply` in a parallel loop such as `Parallel.ForEach()`
    does not really guarantee that `MailboxProcessor` will send the message fully
    parallel unless the instantiation of `MailboxProcessor` itself is encoded within
    a parallel loop. This will ensure that there will be no breach outside the context
    of the `MailboxProcessor` delegate when `MailboxProcessor` starts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: It is not recommended to have a nested recursive function of `async` calling
    another recursive `async` function. The level of unpredictability will increase
    by many orders of magnitude, especially as it will be considered as a long-lived
    object, but it will also put a burden on `Gen0` and `Gen1` of the CLR. Normally,
    long-lived objects should live on `Gen1`, but the asynchronous workflow might
    consider it as short-lived object; therefore, the burden will be put on both `Gen0`
    and `Gen1`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: We have seen from many sample cases that it's important to profile the application,
    especially when the code contains many asynchronous workflows, including the implied
    `MailboxProcessor`. The result of testing how many objects live in `Gen0` and
    `Gen1` will determine where and how the GC may experience unnecessary overheads
    of garbage collections and heap allocations.
  prefs: []
  type: TYPE_NORMAL
- en: There may happen to be unnecessary overheads because of an object being short-lived
    but profiled as long lived; the GC `Gen0` and `Gen1` profiling reports should
    be the basis for actually finding out where the `Gen0` and `Gen1` continues. However,
    premature GC will not definitely help increase the performance because if there
    is aggressive garbage collection at `Gen0`, then the cost of garbage collection
    will affect the initial run time of your code, especially when `GC.Collect` is
    called within a loop of `for` and `foreach`. Each time `GC.Collect` is called,
    any exception that might happen during the call of `GC.Collect` will also affect
    the state of the current stack frame and heap allocations.
  prefs: []
  type: TYPE_NORMAL
- en: Again, there is no single solution for uncommon implementations of your asynchronous
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Parallel programming with .NET TPL
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have a basic knowledge of asynchronous, parallel asynchronous, and interoperability
    of asynchronous workflows with .NET EAP and APM. We have finished discussing .NET
    Task based Asynchronous Programming (TAP) in the form of interoperability between
    F# asynchronous workflows and .NET TAP. We are now discussing more about interoperability
    with .NET TPL.
  prefs: []
  type: TYPE_NORMAL
- en: F# does not just have its own implementations of asynchronous supports and parallel
    asynchronous but is fully compatible with .NET BCL hence .NET TPL.
  prefs: []
  type: TYPE_NORMAL
- en: '.NET TPL is not just an infrastructure of a combination of implied asynchronous
    and parallelism. It focuses on these three features:'
  prefs: []
  type: TYPE_NORMAL
- en: Task-based parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Data parallelism
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: PLINQ, an implementation of LINQ in parallel, also called Parallel LINQ
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Let''s learn more .NET TPL by visiting the MSDN Library .NET TPL landing page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/dd460693(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd460693(v=vs.110).aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: 'According to MSDN, this is the overall high-level picture of .NET 4 TPL:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Parallel programming with .NET TPL](img/image00302.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: 'On the syntactic level, .NET TPL is conceptually divided into two:'
  prefs: []
  type: TYPE_NORMAL
- en: Declarative parallel queries (for example, PLINQ)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Imperative parallel (for example, `Parallel.ForEach`, with an additional parameter
    to maintain state consistency)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: This picture is valid for .NET 4.5 and it is still valid for .NET 4.6/4.6.1
    as it illustrates the high-level of .NET TPL that includes data flow parallelism,
    which starts in .NET 4.5.
  prefs: []
  type: TYPE_NORMAL
- en: 'It is also worth noting that since .NET 4.5, there are the following new features
    in parallelism support:'
  prefs: []
  type: TYPE_NORMAL
- en: Debugging parallelism is easier with parallel debugging support.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Dataflow libraries is essentially the same as F# `MailboxProcessor`.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Coordinating data structures makes the existing concurrent data structures more
    concurrent-aware. This is essentially the same as the concurrent data structures
    that improve performance in .NET 4.5 and later.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'For more information on what''s new in .NET 4.5, 4.6 and 4.6.1, visit:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/ms171868(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/ms171868(v=vs.110).aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on what''s new in .NET 4.5 specific to parallel programming,
    visit this Microsoft MSDN blog by .NET parallel team (formerly ParallelFX):'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://blogs.msdn.microsoft.com/pfxteam/2011/09/17/whats-new-for-parallelism-in-net-4-5/](https://blogs.msdn.microsoft.com/pfxteam/2011/09/17/whats-new-for-parallelism-in-net-4-5/)'
  prefs: []
  type: TYPE_NORMAL
- en: There is a comparable message-passing agent library in .NET TPL; it is called
    *Dataflow*. The Dataflow library is not included in the original runtime distribution
    of .NET runtime and SDK. It is available to be downloaded as a separate NuGet
    package.
  prefs: []
  type: TYPE_NORMAL
- en: Throughout this chapter, we are not going to discuss Dataflow libraries because
    we are focusing on F# `MailboxProcessor`.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Although .NET 4.0 is the starting release of .NET that has .NET TPL, some of
    the internal implementations of .NET TPL have bugs that have been fixed in .NET
    4.5 and later, especially the parallel debugging support. Beginning with [Chapter
    5](#aid-164MG2 "Chapter 5. Advanced Concurrency Support in F#"), *Advanced Concurrency
    Support in F#* all .NET TPL-related discussion should only be applied to .NET
    4.5 and later.
  prefs: []
  type: TYPE_NORMAL
- en: In the next section, we will discuss more about the TPL, from task-based parallelism
    to data parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of task-based parallelism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Let''s visit task-based parallelism. The term *task* is actually the same concept
    of task as in the **Task based Asynchrony Pattern** (**TAP**) with one additional
    trait: it can run independently, as a concurrent unit. The consequence of a parallelized
    task as a concurrent unit is that it can run in parallel or may run as a chain
    of tasks some time in the future.'
  prefs: []
  type: TYPE_NORMAL
- en: All the parallel task operations are available from the `System.Threading.Tasks.Parallel`
    class, under the `mscorlib.dll` assembly. This means that we can use it immediately
    without referencing any assembly other than `mscorlib.dll`.
  prefs: []
  type: TYPE_NORMAL
- en: This `Parallel` class has many `static` methods that provide support for task
    parallelism and data parallelism.
  prefs: []
  type: TYPE_NORMAL
- en: The task parallelism-related method in the `Parallel` class is the `Parallel.Invoke`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'This method has the following overloaded signatures; the first signature is
    as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'The second signature of `Parallel.Invoke` is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: The first signature defines `Invoke` to have one parameter-the parameter arrays
    of `Action` delegates. The `[<ParamArrayAttribute>]` is the same semantic as C#'s
    `param` keyword, but it has to be defined as an attribute parameter in F# to be
    used in a manner similar to `param` in C#.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second signature defines two parameters: `ParallelOptions`, a class to
    further configure the behavior of the parallelism we want to run, and the parameter
    arrays of `Action` delegates.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation on the `Parallel.Invoke` method is available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.invoke(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.tasks.parallel.invoke(v=vs.110).aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: Using `Parallel.Invoke` in F# is quite simple. For example, we can parallelize
    two different processes, the first process being factorial, and the second process
    getting all of the running processes on your local machine.
  prefs: []
  type: TYPE_NORMAL
- en: 'The full sample code is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The interesting fact about this code is how we interoperate with .NET `Action`
    delegate by simply instantiating a new `Action` delegate with the process we want
    to wrap as an `Action` delegate.
  prefs: []
  type: TYPE_NORMAL
- en: If we want to wrap a recursive function as an `Action` delegate, we need to
    wrap the function inside another function that always ignores the result, just
    as the `factwrap` function does. This is crucial, because `Action` delegate is
    a delegate that has no return value, or it returns a unit (`void` in C#).
  prefs: []
  type: TYPE_NORMAL
- en: 'We can then add the line to run `Parallel.Invoke` and our delegates of `factwrap`
    and `runningprocesses` in our existing `EntryPoint` of `main`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: The sample `Parallel.Invoke` contains two delegates to be parallelized. But
    we can add many delegates as well, more than one as implied by `ParamArrayAttribute`
    marking.
  prefs: []
  type: TYPE_NORMAL
- en: The parameter type of the array is the `Action[]` array. This means all of our
    functions must have a function body and return `void`, not just a result of a
    process. This is why the `fact` function must be wrapped into another function
    that runs `fact` and ignores the returning result, and the `runningProcesses`
    function body is explicitly contained within a lambda function that takes a unit
    as its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: If we do not declare `runningProcesses` as explicitly declared within lambda,
    this function will be inferred to have a generic type as its parameter because
    F# needs an explicit declaration of the parameter type. And we will catch other
    compile errors because the `Action` delegate also requires a signature of a function
    that takes no parameter and returns nothing.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following is the signature of the `Action` delegate:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: The `delegate` keyword in this sense is the .NET BCL delegate, not F# delegate.
    The delegate of F# represents an F# function, and this F# function will be compiled
    as an inheritance of F# `FastFunction`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s dive into the IL of the `factwrap` function and the inside declaration
    of `Action`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: We now can see that it extends ``Microsoft.Core.FSharpFunc<`T1,`T2>``, which
    takes two generic type parameters. `T1` is the parameter of the delegate and `T2`
    is the returning type. `T1` is typed as unit and `T2` is typed as unit as well.
  prefs: []
  type: TYPE_NORMAL
- en: Let's visit the second overload of `Parallel.Invoke` that has `ParallelOptions`
    as its parameter.
  prefs: []
  type: TYPE_NORMAL
- en: 'The documentation of the `Parallel.Options` class is available at:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/system.threading.tasks.paralleloptions(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.tasks.paralleloptions(v=vs.110).aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: The `ParallelOptions` class is basically a class to configure `Parallel.Invoke`
    further to meet custom concurrency requirements.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following are the properties of `ParallelOptions`:'
  prefs: []
  type: TYPE_NORMAL
- en: '`CancellationToken`, to pass `CancellationToken` to cancel the running of invoked
    actions.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`MaxDegreeOfParallelism`, to get or set the maximum number of concurrent tasks
    enabled by this `ParallelOptions` instance.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`TaskScheduler`, to get or set `TaskScheduler` associated with this `ParallelOptions`
    instance. Setting this property to null indicates that the current scheduler of
    the running thread from the current `threadpool` should be used.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We can also force the parallelism context to have a maximum degree of parallelism
    of `5` by passing this value to the property of `ParallelOptions.MaxDegreeOfParallelism`.
  prefs: []
  type: TYPE_NORMAL
- en: 'A quick sample of this (using our existing sample delegates) is as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: We have now set the maximum degree of parallelism to `5`, and this is not a
    pessimistic value because we are only passing two `Action` delegates. Setting
    this value to `-1` will instruct `Parallel.Invoke` to run as parallelized to use
    available cores and available threads in the thread pool as often as possible.
  prefs: []
  type: TYPE_NORMAL
- en: 'Be careful when setting a value for the `MaxDegreeOfParallelism` property.
    MSDN Library has additional cautions:'
  prefs: []
  type: TYPE_NORMAL
- en: 'On many cores:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you know that a particular algorithm you're using won't scale beyond a
    certain number of cores. You can set the property to avoid wasting cycles on additional
    cores.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: 'On the implementation detail of the allocation of `thread` and `threadpool`
    resources:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When you're running multiple algorithms concurrently and want to manually define
    how much of the system each algorithm can utilize. You can set a MaxDegreeOfParallelism
    value for each.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: When the thread pool's heuristics are unable to determine the right number of
    threads to use and could end up injecting too many threads. For example, in long-running
    loop body iterations, the thread pool might not be able to tell the difference
    between reasonable progress or livelock or deadlock, and might not be able to
    reclaim threads that were added to improve performance. In this case, you can
    set the property to ensure that you don't use more than a reasonable number of
    threads.
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
- en: The lock in the parallel invocation (in the last bullet) implies that any global
    and shared state, if used inside a `Parallel.Invoke` delegate, is prone to an
    unpredictable state; therefore, a lock should be used. But locking objects in
    the middle of parallelism might bring deadlock itself because many threads are
    racing to modify and there is no guarantee which one will have an exclusive lock
    and will not block others.
  prefs: []
  type: TYPE_NORMAL
- en: To see further what goes on when we invoke delegates to be parallelized, we
    could leverage the existing parallel debugging tool in Visual Studio, available
    since Visual Studio 2012.
  prefs: []
  type: TYPE_NORMAL
- en: Quick start-using the parallel debugging tool in Visual Studio
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: Now let's use the parallel debugging capability of Visual Studio and .NET 4.5+.
    Put breakpoint in the line of `Parallel.Invoke` and inside `factwrap` and `runningProcesses`.
  prefs: []
  type: TYPE_NORMAL
- en: Press *F5* to run with debugging.
  prefs: []
  type: TYPE_NORMAL
- en: 'When it stops at `Parallel.Invoke`, open the **Parallel Stacks** visualizer
    by choosing **Debug** | **Windows** | **Parallel Stacks**. We also open **Tasks**
    by choosing **Debug** | **Windows** | **Tasks**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Quick start-using the parallel debugging tool in Visual Studio](img/image00303.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As visualized in the screenshot, the **Tasks** window already displays the current
    task of the active task.
  prefs: []
  type: TYPE_NORMAL
- en: 'Press `F11` to step into the next function. At the first round, it will go
    through `factwrap` and a new thread is created:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Quick start-using the parallel debugging tool in Visual Studio](img/image00304.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: As `factwrap` is calling `fact`, the `fact` function body is also debugged for
    the number or parameter we passed into `factwrap`, in this case it is 5, as factorial
    of 5.
  prefs: []
  type: TYPE_NORMAL
- en: 'This is pictured nicely in **Parallel Stacks**:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Quick start-using the parallel debugging tool in Visual Studio](img/image00305.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: In the preceding screenshot, we can nicely see that it spawns a new thread to
    hold the `runningProcesses` delegate. In terms of the thread pool, all of these
    threads are in one thread pool, so it is efficiently executed within the same
    context of running the thread of the code that runs `Parallel.Invoke`.
  prefs: []
  type: TYPE_NORMAL
- en: 'As we go further into the `fact` function and leave the recursive, we can also
    see that **Parallel Stacks** displays the related call stack with the matched
    debug breakpoint:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Quick start-using the parallel debugging tool in Visual Studio](img/image00306.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: After it finishes executing the `Parallel.Invoke`, the current thread will go
    back to our entrypoint of `main`.
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information on using parallel debugging (including multithread debugging)
    in Visual Studio, consult the following MSDN Library page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/ms164746.aspx](https://msdn.microsoft.com/en-us/library/ms164746.aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: 'For more information about **Parallel Stacks**, consult the following MSDN
    Library page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/dd998398.aspx](https://msdn.microsoft.com/en-us/library/dd998398.aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: The current offline documentation of the MSDN Library in Visual Studio 2015
    (opened with MS Help) section of Visual Studio debugging is not updated. It is
    not in sync with the latest documentation of Visual Studio in the online MSDN
    Library. It is highly recommended to always have the offline MSDN Library installed
    and updated first, but we should check the online MSDN Library for the latest
    update.
  prefs: []
  type: TYPE_NORMAL
- en: Also, since we already know that F# documentation is open source, we should
    also always check the online documentation for the latest update. Starting from
    this chapter, more resources will be emphasized on online MSDN Library.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of data parallelism
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Data parallelism in .NET TPL is actually a library of functions/methods that
    have parallel operations on certain data operations, such as enumerating data.
    It is can also be seen as declarative because it is very closely related to the
    existing language features of how F# iterates a collection (using F# `for` loop).
  prefs: []
  type: TYPE_NORMAL
- en: It is also clearly stated in the MSDN Library that this data parallelism is
    only for a collection (such as IEnumerable) and array, not for encapsulating operations
    to be parallelized, such as task parallelism. The main focus of data parallelism
    is parallelizing `for`, either `for` with counter or `foreach`, to directly iterate
    through the elements of the collection.
  prefs: []
  type: TYPE_NORMAL
- en: In F#, `foreach` is represented by the for .. in construct, and it's conceptually
    and contextually the same as `foreach` in C#/VB, although it is semantically different.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following methods are the operations of data parallelism:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Parallel.For`, to have loops with counter (it may act as a starting value
    when incremented), and this `For` does not run sequentially as compared with the
    basic for'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Parallel.ForEach`, to have `foreach` in parallel when iterating elements'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The `Parallel.For` is related to the `for` loop of F# that has predefined from
    and stopping values to be counter for the loop.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, consider the following code snippet:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: The `function1` will run sequentially from `1` to `10`, and it will always run
    synchronously, which means that the first iteration has to be finished first before
    running the next iterations. The rest of the iterations still have to wait; therefore,
    it is intentional and it is also trivial that the execution behavior of the first
    iteration blocks the next remaining iterations.
  prefs: []
  type: TYPE_NORMAL
- en: The `parallelFunction1` is a parallel version of `function1`. In the function
    body, we add the display of the current iterations by passing the counter into
    the output display.
  prefs: []
  type: TYPE_NORMAL
- en: 'We shall put the code as F# script, run the script inside Visual Studio **F#
    Interactive**, and immediately see the result:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of data parallelism](img/image00307.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Here, we can see the proof that there is no guarantee that the loop will execute
    sequentially. This is intentional because in parallelism, we do not care about
    the order of the executions, as we explored in the section, *Introducing concurrency
    support in F# 4* in [Chapter 4](fsp-hiperf_cu04.html#aid-11C3M2 "Chapter 4. Introduction
    to Concurrency in F#"), *Introduction to Concurrency in F#*.
  prefs: []
  type: TYPE_NORMAL
- en: Now, we visit the parallel pair of the F# `for .. in` loop, and the `Parallel.ForEach`
    method.
  prefs: []
  type: TYPE_NORMAL
- en: 'We now start from the simple sample of iterating a collection in F# using the
    `for .. in` loop and put it into parallel:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'Again, run the code in **F# Interactive**, and we can compare the output:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Overview of data parallelism](img/image00308.jpeg)'
  prefs: []
  type: TYPE_IMG
- en: Now, we have interoperability of .NET TPL's data parallelism in F#. As long
    as we carefully keep the process as simple as possible (without shared state),
    we can have a successful implementation of parallelism with a highly predictable
    result.
  prefs: []
  type: TYPE_NORMAL
- en: This is also a good example of minimizing unpredictability by keeping the side
    effects as minimal as possible. We can still use shared state, but then, we have
    to implement locking as well, and this will decrease the performance. The background
    reason for this decreasing performance is the same as having locks in an asynchronous
    workflow.
  prefs: []
  type: TYPE_NORMAL
- en: Common potential pitfalls in parallel programming
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: There are common pitfalls for parallel programming in .NET, and we should pay
    attention to these.
  prefs: []
  type: TYPE_NORMAL
- en: 'We know that we should avoid the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Side effects in mutable states of an object. If a mutable state is used, a lock
    has to be implemented to ensure concurrency of the object state. This is also
    applied to shared states, because any shared state is also mutable as well.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A side effect in the possibility of having an exception. If we do not catch
    any possible exception (especially exceptions related to blocking operations such
    as I/O), any exceptions thrown in the middle of any parallel processes will cancel
    the whole pipeline of the parallel process.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: COM objects, because we have to be careful when handling an object that has
    a different apartment model, such as COM objects.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Side effects of mixing a UI thread with the current thread from a non-UI thread.
    In WPF, this can be mitigated by using WPF Dispatcher.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now, let's try to handle mutable states in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: Overview of handling mutable state
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
- en: If we want to really have a mutable state, we can enclose it in a pair of `Monitor.Enter`
    and `Monitor.Exit` loops.
  prefs: []
  type: TYPE_NORMAL
- en: 'For example, we can code this using a simplified sample of how the lock in
    C#/VB is actually implemented:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: This watching state is the reason why .NET names the object to watch the state
    as `Monitor`.
  prefs: []
  type: TYPE_NORMAL
- en: 'We will not describe the `Monitor` object further because Monitor is part of
    an object locking mechanism that is not recommended in many cases of F# concurrency
    implementation. We shall focus only on the functional aspects of F# concurrency
    rather than dealing with mutable state, which is common for non-functional programming
    style code. For more information on .NET Monitor, visit the following link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/system.threading.monitor(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/system.threading.monitor(v=vs.110).aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: There is also a class in .NET BCL to allow mixing mutable state for simple operations,
    such as increment and decrement inside a parallel loop. The class is `System.Threading.Interlocked`,
    and it is also used internally in F# to implement asynchronous workflows in `Control.Async`
    and builders in the `FSharpAsyncBuilder` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'The implementation of using `Interlocked` is not common, and we should be careful.
    This is why it has a limited kind of allowable operations. We can see a good sample
    implementation of leveraging `Interlocked` in the internal implementation of F#
    `Async.Parallel` code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: In this code, `Interlocked.Decrement` is used to maintain or keep track of the
    state of the counter of the number of parallelized asynchronous workflows. The
    code flows nicely because F# has its own parallel asynchronous operation without
    depending on the .NET TPL `Parallel` class.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the MSDN Library, there are additional aspects of common pitfalls of parallel
    programming available at the following page:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://msdn.microsoft.com/en-us/library/dd997392(v=vs.110).aspx](https://msdn.microsoft.com/en-us/library/dd997392(v=vs.110).aspx)'
  prefs: []
  type: TYPE_NORMAL
- en: 'Among those points, we should pay attention to the following examples in the
    MSDN Library article, in addition to the many samples of asynchrony and parallelism
    that we explored:'
  prefs: []
  type: TYPE_NORMAL
- en: Avoid over-parallelization. By using parallel loops, you incur the overhead
    costs of partitioning the source collection and synchronizing the worker threads.
    The benefits of parallelization are further limited by the number of processors
    and the cores on the computer. There is no speedup to be gained by running multiple
    compute-bound threads on just one processor. Therefore, you must be careful not
    to over-parallelize a loop. Also, too many parallelizations increase the overheads
    on the task scheduler and it may lead to a race condition on the thread affinities
    being obtained. Also, having overheads on a task scheduler will decrease the responsiveness
    of the running application.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid calls to non-thread-safe methods! This is extremely important, because
    writing to non-thread-safe instance methods from a parallel loop can lead to data
    corruption, which may or may not go undetected in your program. It can also lead
    to exceptions, for example, multiple parallel threads of calling `FileStream.WriteByte`.
    This point is closely related to avoiding mixing I/O operations. It is also necessary
    to be aware that almost all of the operations in `Stream`, `File`, and `System.Web`
    classes are not thread-safe at all.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Avoid changing thread affinity in the middle of any parallel operation. This
    might yield exceptions and not just unpredictable results/behaviors.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The most common scenario in which over-parallelization can occur is in nested
    loops. In most cases, it is best to parallelize only the outer loop unless one
    or more of the following conditions apply:'
  prefs: []
  type: TYPE_NORMAL
- en: The inner loop is known to be very long. You are performing an *expensive computation*
    on each order. The term expensive computation in this context means having complex
    calculations that will consume a lot of CPU cycles and also having a parallel
    computation inside a parallel computation or *complex nested parallelizations*.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The target system is known to have enough processors to handle the number of
    threads that will be produced by parallelizing the operation. Having too many
    degrees of parallelism, especially if the number of parallelism is higher than
    the number of CPU core, will enforce other processes to wait indefinitely, and
    this waiting will also result in a deadlock condition.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'We can also have a further reference to .NET parallelism from Microsoft by
    downloading the white paper titled *Patterns for Parallel Programming: Understanding
    and Applying Parallel Patterns with the .NET Framework 4* from the following official
    download link:'
  prefs: []
  type: TYPE_NORMAL
- en: '[https://www.microsoft.com/en-us/download/details.aspx?id=19222](https://www.microsoft.com/en-us/download/details.aspx?id=19222)'
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: We have explored the advanced concurrency support in F# and .NET TPL. We also
    have enough knowledge about how we should handle side effects and also on using
    asynchronous for various cases and scenarios.
  prefs: []
  type: TYPE_NORMAL
- en: The main conclusion when implementing the best practices of leveraging concurrency
    in F# is that there is no silver bullet for all concurrency needs, and this includes
    avoiding the assumption that parallelized code always runs faster than non-parallel
    code after examining cases that may bring down the performance of parallel implementation
    in .NET TPL. These warning cases can be applied not just in F# but also in VB/C#.
  prefs: []
  type: TYPE_NORMAL
- en: We have understood asynchrony and parallelism. We will use this knowledge to
    optimize the type providers and avoid the pitfalls of implementing them in [Chapter
    6](fsp-hiperf_cu06.html#aid-19UOO2 "Chapter 6. Optimizing Type Provider"), *Optimizing
    Type Provider* .
  prefs: []
  type: TYPE_NORMAL
