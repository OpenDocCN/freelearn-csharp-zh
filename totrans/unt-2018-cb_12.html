<html><head></head><body>
        

                            
                    <h1 class="header-title">Controlling and Choosing Positions</h1>
                
            
            
                
<p>In this chapter, we will cover the following topics:</p>
<ul>
<li>Player control of a 2D GameObject (and limiting the movement within a rectangle)</li>
<li>Player control of a 3D GameObject (and limiting the movement within a rectangle)</li>
<li>Choosing destinations – finding a random spawn point</li>
<li>Choosing destinations – finding the nearest spawn point</li>
<li>Choosing destinations – respawning to the most recently passed checkpoint</li>
<li>Moving objects by clicking on them</li>
<li>Firing projectiles in the direction of movement</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Introduction</h1>
                
            
            
                
<p>Many <strong>GameObjects</strong> in games move! Movement can be controlled by the player, by the (simulated) laws of physics in the environment, or by the <strong>Non-Player Character</strong> (<strong>NPC</strong>) logic; for example, objects that follow a path of a waypoint, or seek (move toward) or flee (away) from the current position of a character. Unity provides several controllers for first and third-person characters, and for vehicles such as cars and airplanes. <strong>GameObject</strong> movement can also be controlled through the state machines of the Unity <strong>Mecanim</strong> animation system.</p>
<p class="mce-root"/>
<p>However, there may be times when you wish to tweak the Player character controllers from Unity, or write your own. You might wish to write directional logic—simple or sophisticated <strong>Artificial Intelligence</strong> (<strong>AI</strong>) to control the game's NPC and enemy characters. Such AI might involve your computer program making objects orient and move toward or away from characters or other game objects.</p>
<p>This chapter (and the chapter that follows) presents a range of such directional recipes, from which many games can benefit in terms of a richer and more exciting user experience.</p>
<p>Unity provides sophisticated classes and components, including the <kbd>Vector3</kbd> class and rigid body physics for modeling realistic movements, forces, and collisions in games. We make use of these game engine features to implement some sophisticated NPC and enemy character movements in the recipes of this chapter.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">The big picture</h1>
                
            
            
                
<p>For 3D games (and to some extent, 2D games as well), a fundamental class of object is the <kbd>Vector3</kbd> class objects that store and manipulate (x, y, z) values representing locations in a 3D space. If we draw an imaginary arrow from the origin (0, 0, 0) to a point on the space, then the direction and length of this arrow (vector) can represent a velocity or force (that is, a certain amount of magnitude in a certain direction).</p>
<p>If we ignore all the character controller components, colliders, and the physics system in Unity, we can write code that teleports objects directly to a particular (x,  y,  z) location in our scene. Sometimes, this is just what we want to do; for example, we may wish to spawn an object at a location. However, in most cases, if we want objects to move in more physically realistic ways, then we either apply a force to the object's <strong>RigidBody</strong>, or change its velocity component. Or, if it has a <strong>Character Controller</strong> component, then we can send it a <kbd>Move()</kbd> message.</p>
<p>Some important concepts in the NPC object movement and creation (instantiation) include the following:</p>
<ul>
<li><strong>Spawn points</strong>: Specific locations in the scene where objects are to be created, or moved to</li>
<li><strong>Checkpoints</strong>: Locations (or colliders) that, once passed through, change what happens later in the game (for example, extra time, or if a Player's character gets killed, they respawn to the last crossed checkpoint, and so on)</li>
</ul>
<p class="mce-root"/>
<ul>
<li><strong>Waypoints</strong>: A sequence of locations to define a path for NPCs or, perhaps, the Player's character, to follow</li>
</ul>
<p>In this chapter, we will introduce a few recipes and demonstrate a selection of approaches to character control, spawn points, and checkpoints. In the next chapter, we'll look at waypoints for AI controlled characters.</p>
<p>You can learn more about the Unity 2D character controllers at <a href="http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers">http://unity3d.com/learn/tutorials/modules/beginner/2d/2d-controllers</a>.<br/>You can learn about the Unity 3D character component and control at <a href="http://docs.unity3d.com/Manual/class-CharacterController.html">http://docs.unity3d.com/Manual/class-CharacterController.html</a> and <a href="http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character">http://unity3d.com/learn/tutorials/projects/survival-shooter/player-character</a>.</p>
<p>Every game needs textures. Here are some of the sources of free textures that are suitable for many games:</p>
<ul>
<li>CG Textures are available at <a href="http://www.cgtextures.com/">http://www.cgtextures.com/</a></li>
<li>Naldz Graphics blog,  available at <a href="http://naldzgraphics.net/textures/">http://naldzgraphics.net/textures/</a></li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Player control of a 2D GameObject (and limiting the movement within a rectangle)</h1>
                
            
            
                
<p>While the rest of the recipes in this chapter are demonstrated in 3D projects, basic character movement in 2D and also limiting the movement to a bounding rectangle, are core skills for many 2D games, and so this first recipe illustrates how to achieve these features for a 2D game.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>Since in <a href="c6ad221f-b476-4471-8259-9ad448749a32.xhtml">Chapter 3</a>, <em>Inventory UIs</em>, we already created a basic 2D game, we'll adapt this game to restrict the movement to a bounding rectangle:</p>
<div><img src="img/76b6b50a-1659-4d5c-8de2-db2777b28ce4.png" style="width:23.58em;height:16.75em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe builds on a simple 2D game called the Simple2DGame_SpaceGirl mini game from the first recipe of <a href="c6ad221f-b476-4471-8259-9ad448749a32.xhtml">Chapter 3</a>, <em>Inventory UIs</em>. Start with a copy of this game, or use the provided completed recipe project as the basis for this recipe. You can download the completed project from <a href="https://github.com/dr-matt-smith/unity-cookbook-2018-ch03">https://github.com/dr-matt-smith/unity-cookbook-2018-ch03</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a 2D sprite controlled by the user with a movement that is limited to within a rectangle, follow these steps:</p>
<ol>
<li>Create a new, empty <strong>GameObject</strong> named <kbd>corner_max</kbd>, and position it somewhere above and to the right of the <strong>GameObject</strong> called <kbd>player_spaceGirl</kbd>. With this <strong>GameObject</strong> selected in the Hierarchy view, choose the large yellow oblong icon, highlighted in the Inspector panel:</li>
</ol>
<div><img src="img/accf458a-21c9-4fda-864c-145266b43739.png" style="width:34.50em;height:11.08em;"/></div>
<ol start="2">
<li>Duplicate the corner_max <strong>GameObject</strong> by naming the clone as <kbd>corner_min</kbd>, and position this clone somewhere below and to the left of the player-spaceGirl <strong>GameObject</strong>. The coordinates of these two <strong>GameObjects</strong> will determine the maximum and minimum bounds of movement, permitted for the player's character.</li>
<li>Modify the C# Script called <kbd>PlayerMove</kbd> to declare some new variables at the beginning of the class:</li>
</ol>
<pre>     public Transform corner_max;<br/>     public Transform corner_min;<br/>     private float x_min;<br/>     private float y_min;<br/>     private float x_max;<br/>     private float y_max; </pre>
<ol start="4">
<li>Modify the C# Script called <kbd>PlayerMove</kbd> so that the <kbd>Awake()</kbd> method now gets a reference to the <kbd>SpriteRenderer</kbd>, and uses this object to help set up the maximum and minimum X and Y movement limits:</li>
</ol>
<pre>    void Awake(){<br/>       rigidBody2D = GetComponent&lt;Rigidbody2D&gt;();<br/>       x_max = corner_max.position.x;<br/>       x_min = corner_min.position.x;<br/>       y_max = corner_max.position.y;<br/>       y_min = corner_min.position.y;<br/>     } </pre>
<ol start="5">
<li>Modify the C# Script called <kbd>PlayerMove</kbd> to declare a new method called <kbd>KeepWithinMinMaxRectangle()</kbd>:</li>
</ol>
<pre>  private void KeepWithinMinMaxRectangle(){<br/>     float x = transform.position.x;<br/>     float y = transform.position.y;<br/>     float z = transform.position.z;<br/>     float clampedX = Mathf.Clamp(x, x_min, x_max);<br/>     float clampedY = Mathf.Clamp(y, y_min, y_max);<br/>     transform.position = new Vector3(clampedX, clampedY, z);<br/>   } </pre>
<ol start="6">
<li>Modify the C# Script called <kbd>PlayerMove</kbd> so that, after having updated the velocity in the <kbd>FixedUpdate()</kbd> method, a call will be made to the <kbd>KeepWithinMinMaxRectangle()</kbd> method:</li>
</ol>
<pre>  void FixedUpdate(){<br/>     rigidBody2D.velocity = newVelocity;<br/><br/>     // restrict player movement<br/>     KeepWithinMinMaxRectangle();<br/>   } </pre>
<ol start="7">
<li>With the player-spaceGirl <strong>GameObject</strong> in the <strong>Hierarchy</strong> view, drag the corner_max and corner_min <strong>GameObjects</strong> over the public variables called corner_max and corner_min in the Inspector.</li>
</ol>
<p>Before running the scene in the <strong>Scene</strong> panel, try repositioning the corner_max and corner_min <strong>GameObjects</strong>. When you run the scene, the positions of these two <strong>GameObjects</strong> (max and min, and X and Y) will be used as the limits of movement for the Player's player-spaceGirl character.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You added the empty <strong>GameObjects</strong> called corner_max and corner_min to the scene. The X and Y coordinates of these <strong>GameObjects</strong> will be used to determine the bounds of movement that we will permit for the character called player-spaceGirl. Since these are the empty <strong>GameObjects</strong>, they will not be seen by the player when in play-mode. However, we can see and move them in the <strong>Scene</strong> panel, and having added the yellow oblong icons, we can see their positions and names very easily.</p>
<p>Upon using the <kbd>Awake()</kbd> method on the <kbd>PlayerMoveWithLimits</kbd> object, inside the player-spaceGirl <strong>GameObject</strong>, the maximum and minimum X and Y values of the <strong>GameObjects</strong> called corner_max and corner_min are recorded. Each time the physics system is called via the <kbd>FixedUpdate()</kbd> method, the velocity of the player-spaceGirl character is updated to the value set in the <kbd>Update()</kbd> method,which is based on the horizontal and vertical keyboard/joystick inputs. However, the final action of the <kbd>FixedUpdate()</kbd> method is to call the <kbd>KeepWithinMinMaxRectangle()</kbd> method, which uses the <kbd>Math.Clamp(...)</kbd> function to move the character back inside the X and Y limits. This happens so that the player's character is not permitted to move outside the area defined by the corner_max and corner_min <strong>GameObjects</strong>.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<p>We have kept to a good rule of thumb:</p>
<p>"Always listen for <strong>input</strong> in <kbd>Update()</kbd>.<br/>
Always apply <strong>physics</strong> in <kbd>FixedUpdate()</kbd>."</p>
<p>Learn more about why we should not check for inputs in <kbd>FixedUpdate()</kbd> in the Unity Answers thread (which is also the source for the preceding quote from user Tanoshimi) at <a href="https://answers.unity.com/questions/1279847/getaxis-being-missed-in-fixedupdate-work-around.html">https://answers.unity.com/questions/1279847/getaxis-being-missed-in-fixedupdate-work-around.html</a>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss out on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing a gizmo yellow rectangle to visually show bounding a rectangle</h1>
                
            
            
                
<p>As developers, it is useful to <em>see</em> elements like bounding rectangles when run-testing our game. Let's make the rectangular bounds of the movement visually explicit in yellow lines in the Scene panel by having a yellow "gizmo" rectangle drawn. Add the following method to the C# script class called <kbd>PlayerMove</kbd>:</p>
<pre>    void OnDrawGizmos(){<br/>       Vector3 top_right = Vector3.zero;<br/>       Vector3 bottom_right = Vector3.zero;<br/>       Vector3 bottom_left = Vector3.zero;<br/>       Vector3 top_left = Vector3.zero;<br/><br/>       if(corner_max &amp;&amp; corner_min){<br/>         top_right = corner_max.position;<br/>         bottom_left = corner_min.position;<br/><br/>         bottom_right = top_right;<br/>         bottom_right.y = bottom_left.y;<br/><br/>         top_left = top_right;<br/>         top_left.x = bottom_left.x;<br/>       }<br/><br/>       //Set the following gizmo colors to YELLOW<br/>       Gizmos.color = Color.yellow;<br/><br/>       //Draw 4 lines making a rectangle<br/>       Gizmos.DrawLine(top_right, bottom_right);<br/>       Gizmos.DrawLine(bottom_right, bottom_left);<br/>       Gizmos.DrawLine(bottom_left, top_left);<br/>       Gizmos.DrawLine(top_left, top_right);<br/>     } </pre>
<p>The <kbd>OnDrawGizmos()</kbd> method tests that the references to the corner_max and corner_min <strong>GameObjects</strong> are not null, and then sets the positions of the four <strong>Vector3</strong> objects, representing the four corners defined by the rectangle, with corner_max and corner_min at the opposite corners. It then sets the <strong>Gizmo</strong> color to yellow, and draws lines, connecting the four corners in the <strong>Scene</strong> panel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>Refer to the following recipe for more information about limiting Player controlled character movements.</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Player control of a 3D GameObject (and limiting the movement within a rectangle)</h1>
                
            
            
                
<p>Many of the 3D recipes in this chapter are built on this basic project, which constructs a scene with a textured terrain, a <strong>Main Camera</strong>, and a red cube that can be moved around by the user with the four directional arrow keys. The bounds of movement of the cube are constrained using the same technique as in the previous 2D recipe:</p>
<div><img src="img/fbef8f32-06f6-4e98-9af4-6cbb47191e8b.png" style="width:37.50em;height:18.75em;"/></div>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To create a basic 3D cube controlled game, follow these steps:</p>
<ol>
<li>Create a new, empty 3D project.</li>
<li>Once the project has been created, import the single <strong>Terrain Texture</strong> named SandAlbedo by choosing menu: Assets | Import Package | Environments. Deselect everything, and then locate and tick the asset by going to <kbd>Assets/Environment/TerrainAssets/SurfaceTextures/ SandAlbedo.psd</kbd>.</li>
</ol>
<p>You could have just added the Environment Asset Package when creating the project, but this would have imported hundreds of files, and we only needed this one. Starting a project in Unity and then selectively importing just what we need is the best approach to take if you want to keep the project's <kbd>Asset</kbd> folders to small sizes.</p>
<ol start="3">
<li>Create a new terrain by choosing menu: Create | 3D Object | Terrain. With this new terrain <strong>GameObject</strong> selected in Hierarchy, in its Inspector properties, set the size to 30 x 20, and its position to (-15, 0, -10):</li>
</ol>
<p>The transform position for the terrains relates to their corner and not their center.<br/>
<br/>
Since the <strong>Transform</strong> position of the terrains relates to the corner of the object, we center such objects at (0, 0, 0) by setting the X coordinate equal to ( <em>-1width/2</em>), and the Z-coordinate equal to (<em>-1length/2</em>). In other words, we slide the object by half its width and half its height to ensure that its center is just where we want it.<br/>
<br/>
In this case, the width is 30 and the length is 20, hence we get -15 for X (<em>-1 * 30/2</em>), and -10 for Z (<em>-1 * 20/2</em>).</p>
<div><img src="img/ece021ed-d3b8-40d2-8ac5-7edd13f44a9e.png" style="width:30.42em;height:18.83em;"/></div>
<ol start="4">
<li>Texture paint this terrain with your texture called SandAlbedo.</li>
<li>Make the following changes to the Main Camera:
<ul>
<li>Position: (0, 20, -15)</li>
<li>Rotation: (60, 0, 0)</li>
</ul>
</li>
<li>Change the Aspect Ratio of the <strong>Game Panel</strong> from Free Aspect to 4:3. You will now see the whole of the Terrain in the <strong>Game Panel</strong>.</li>
<li>Create a new empty <strong>GameObject</strong> named corner_max, and position it at (14, 0, 9). With this <strong>GameObject</strong> selected in the Hierarchy, choose the large, yellow oblong icon, highlighted in the Inspector panel.</li>
<li>Duplicate the corner_max <strong>GameObject</strong>, naming the clone as corner_min, and position this clone at (-14, 0, -9). The coordinates of these two <strong>GameObjects</strong> will determine the maximum and minimum bounds of the movement permitted for the player's character.</li>
<li>Create a new cube called <strong>GameObject </strong>by choosing menu: Create | 3D Object | Cube. Name this <kbd>Cube-player</kbd>, and set its position to (0, 0.5, 0), and size as (1, 1, 1).</li>
<li>Add a rigid body component to the Cube-player <strong>GameObject</strong> (Physics | RigidBody), and uncheck the <strong>RigidBody</strong> property Use Gravity.</li>
<li>Create a red <strong>Material</strong> named <kbd>m_red</kbd>, and apply this Material to Cube-player.</li>
</ol>
<ol start="12">
<li>Create a C# Script class called <kbd>PlayerControl</kbd>, and add an instance object as a component to <strong>GameObject </strong>Cube-player:</li>
</ol>
<pre>using UnityEngine;<br/><br/>public class PlayerControl : MonoBehaviour {<br/>   public Transform corner_max;<br/>         public Transform corner_min;<br/>         public float speed = 40;<br/>         private Rigidbody rigidBody;<br/>         private float x_min;<br/>         private float x_max;<br/>         private float z_min;<br/>         private float z_max;<br/>         private Vector3 newVelocity;<br/><br/>    void Awake() {<br/>       rigidBody = GetComponent&lt;Rigidbody&gt;();<br/>       x_max = corner_max.position.x;<br/>       x_min = corner_min.position.x;<br/>       z_max = corner_max.position.z;<br/>       z_min = corner_min.position.z;<br/>    }<br/><br/>private void Update() {<br/>    float xMove = Input.GetAxis("Horizontal") * speed * Time.deltaTime;<br/>    float zMove = Input.GetAxis("Vertical") * speed * Time.deltaTime;<br/>    float xSpeed = xMove * speed;<br/>    float zSpeed = zMove * speed;<br/>    newVelocity = new Vector3(xSpeed, 0, zSpeed);<br/>}<br/><br/>void FixedUpdate() {<br/>    rigidBody.velocity = newVelocity;<br/>    KeepWithinMinMaxRectangle();<br/>}<br/><br/> private void KeepWithinMinMaxRectangle() {<br/>   float x = transform.position.x;<br/>   float y = transform.position.y;<br/>   float z = transform.position.z;<br/>   float clampedX = Mathf.Clamp(x, x_min, x_max);<br/>   float clampedZ = Mathf.Clamp(z, z_min, z_max);<br/>   transform.position = new Vector3(clampedX, y, clampedZ);<br/> }<br/> }</pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="13">
<li>With the Cube-player <strong>GameObject</strong> selected in Hierarchy, drag the <strong>GameObjects</strong> called corner_max and corner_min over the public variables called corner_max and corner_min in the Inspector panel.</li>
</ol>
<p>When you run the scene, the positions of the corner_max and corner_min <strong>GameObjects</strong> will define the bounds of movement for the Player's Cube-player character.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The scene contains a positioned terrain so that its center is (0, 0, 0). The red cube is controlled by the user's arrow keys through the <kbd>PlayerControl</kbd> script.</p>
<p>Just as with the previous 2D recipe, a reference to the (3D) RigidBody component is stored when the <kbd>Awake()</kbd> method executes, and the maximum and minimum X and Z values are retrieved from the two corner <strong>GameObjects</strong>, and are stored in the <kbd>x_min</kbd>, <kbd>x_max</kbd>, <kbd>z_min</kbd>, and <kbd>z_max</kbd> variables. Note that for this basic 3D game, we won't allow any Y-movement, although such movement (and bounding limits by adding a third max-height corner <strong>GameObject</strong>) can be easily added by extending the code in this recipe.</p>
<p>The <kbd>KeyboardMovement()</kbd> method reads the horizontal and vertical input values (which the Unity default settings read from the four directional arrow keys). Based on these left-right and up-down values, the velocity of the cube is updated. The amount it will move depends on the speed variable.</p>
<p>The <kbd>KeepWithinMinMaxRectangle()</kbd> method uses the <kbd>Math.Clamp(...)</kbd> function to move the character back inside the X and Z limits so that the player's character is not permitted to move outside the area defined by the corner_max and corner_min <strong>GameObjects</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss out on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Drawing a gizmo yellow rectangle to visually show bounding a rectangle</h1>
                
            
            
                
<p>As developers, it is useful to <em>see</em> elements like bounding rectangles when test-running our game. Let's make the rectangular bounds of the movement visually explicit in yellow lines in the <strong>Scene</strong> panel by having a yellow "gizmo" rectangle drawn. Add the following method to the C# Script class called <kbd>PlayerMove</kbd>:</p>
<pre>void OnDrawGizmos (){<br/>         Vector3 top_right = Vector3.zero;<br/>         Vector3 bottom_right = Vector3.zero;<br/>         Vector3 bottom_left = Vector3.zero;<br/>         Vector3 top_left = Vector3.zero;<br/><br/>         if(corner_max &amp;&amp; corner_min){<br/>           top_right = corner_max.position;<br/>           bottom_left = corner_min.position;<br/><br/>           bottom_right = top_right;<br/>           bottom_right.z = bottom_left.z;<br/><br/>           top_left = bottom_left;<br/>           top_left.z = top_right.z;<br/>         }<br/><br/>         //Set the following gizmo colors to YELLOW<br/>         Gizmos.color = Color.yellow;<br/><br/>         //Draw 4 lines making a rectangle<br/>         Gizmos.DrawLine(top_right, bottom_right);<br/>         Gizmos.DrawLine(bottom_right, bottom_left);<br/>         Gizmos.DrawLine(bottom_left, top_left);<br/>         Gizmos.DrawLine(top_left, top_right);<br/>       } </pre>
<p>The <kbd>OnDrawGizmos()</kbd> method tests that the references to the corner_max and corner_min <strong>GameObjects</strong> are not null, and then sets the positions of the four Vector3 objects, representing the four corners defined by the rectangle, with the corner_max and corner_min <strong>GameObjects</strong> at the opposite corners. It then sets the <strong>Gizmo</strong> color to yellow, and draws lines, connecting the four corners in the <strong>Scene</strong> panel.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Choosing destinations – finding a random spawn point</h1>
                
            
            
                
<p>Many games make use of spawn points and waypoints. This recipe demonstrates choosing a random spawn point, and then the instantiation of an object at that chosen point.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe builds upon the previous recipe. So, make a copy of this project, open it, and then follow the steps in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To find a random spawn point, follow these steps:</p>
<ol>
<li>In the Scene panel, create a sphere (by navigating to Create | 3D Object | Sphere) sized as (1, 1, 1) at (2, 2, 2) position, and apply the m_red <strong>Material</strong>.</li>
<li>In the Project panel, create a new <strong>Prefab</strong> (by going to Create | Prefab) named <kbd>Prefab-ball</kbd>, and drag your sphere into it (and then delete the sphere from the Hierarchy panel).</li>
<li>In the Scene panel, create a new capsule (by navigating to Create | 3D Object | Capsule) named <kbd>Capsule-spawnPoint</kbd> at (3, 0.5, 3), and give it a tag of Respawn (this is one of the default tags that Unity provides):</li>
</ol>
<p>For testing, we'll leave these Respawn points visible. For the final game, we'll then uncheck the Mesh Rendered of each Respawn <strong>GameObject</strong> so that they are not visible to the Player.</p>
<div><img src="img/9e33a140-8ca0-4924-8995-611f9309024a.png" style="width:37.25em;height:8.08em;"/></div>
<ol start="4">
<li>Make several copies of your Capsule-spawnPoint by moving them to different locations on the terrain.</li>
<li>Create a C# Script class called SpawnBall, and add an instance object as a component to the Cube-player <strong>GameObject</strong>:</li>
</ol>
<pre>    using UnityEngine;<br/><br/>     public class BallSpawner : MonoBehaviour {<br/>         public GameObject prefabBall;<br/>         private SpawnPointManager spawnPointManager;<br/>         private float timeBetweenSpawns = 1;<br/><br/>         void Start () {<br/>             spawnPointManager = GetComponent&lt;SpawnPointManager&gt; ();<br/>             InvokeRepeating("CreateSphere", 0, timeBetweenSpawns);<br/>         }<br/><br/>         private void CreateSphere() {<br/>             GameObject spawnPoint = <br/>             spawnPointManager.RandomSpawnPoint();<br/><br/>             GameObject newBall = (GameObject)Instantiate(<br/>                 prefabBall, spawnPoint.transform.position, <br/>                 Quaternion.identity);<br/>             Destroy(newBall, timeBetweenSpawns/2);<br/>         }<br/>     } </pre>
<ol start="6">
<li>Create a C# Script class called <kbd>SpawnPointManager</kbd> and add an instance object as a component to the Cube-player <strong>GameObject</strong>:</li>
</ol>
<pre>    using UnityEngine;<br/><br/>     public class SpawnPointManager : MonoBehaviour {<br/>         private GameObject[] spawnPoints;<br/><br/>         void Start() {<br/>             spawnPoints = GameObject.FindGameObjectsWithTag("Respawn");<br/>         }<br/><br/>         public GameObject RandomSpawnPoint() {<br/>             int r = Random.Range(0, spawnPoints.Length);<br/>             return spawnPoints[r];<br/>         }<br/>     } </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<ol start="7">
<li>Ensure that Cube-player is selected in the Inspector for the SpawnBall scripted component. Then, drag Prefab-ball over the public variable projectile called Prefab Ball.</li>
<li>Now, run your game. Every second, a red ball should be spawned and disappear after half a second. The location each ball is spawned at should be random.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The <kbd>Capsule-spawnPoint</kbd> objects represent candidate locations, where we might wish to create an instance of our ball <strong>Prefab</strong>. When our <kbd>SpawnPointManager</kbd> object, inside the Cube-player <strong>GameObject</strong>, receives the <kbd>Start()</kbd> message, the respawned <strong>GameObject</strong> array is set to the array, which is returned from the call to <kbd>FindGameObjectsWithTag("Respawn")</kbd>. This creates an array of all the objects in the scene with the Respawn tag—that is, all our <kbd>Capsule-spawnPoint</kbd> objects.</p>
<p>When our <kbd>SpawnBall</kbd> object GameObject Cube-player receives the <kbd>Start()</kbd> message, it sets the <kbd>spawnPointManager</kbd> variable to be a reference to its sibling <kbd>SpawnPointManager</kbd> script component. Next, we use the <kbd>InvokeRepeating(...)</kbd> method to schedule the <kbd>CreateSphere()</kbd> method to be called every 1 second.</p>
<p>The <kbd>SpawnBall</kbd> method <kbd>CreateSphere()</kbd> assigns the <kbd>spawnPoint</kbd> variable to the <strong>GameObject</strong> returned by a call to the <kbd>RandomSpawnpoint(...)</kbd> method of our <kbd>spawnPointManager</kbd>. Then, it creates a new instance of <kbd>prefab_ball</kbd> (via the public variable) at the same position as the spawnPoint <strong>GameObject</strong>.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<p>The same techniques and code can be used for selecting spawn points or waypoints. Refer to the <em>NPC NavMeshAgent control to follow waypoints in sequence</em> recipe in the next chapter (<a href="https://cdp.packtpub.com/unity_2017_cookbook/wp-admin/post.php?post=604&amp;action=edit">Navigation Meshes and Agents</a>) for more information about waypoints.</p>
<p class="mce-root"/>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Choosing destinations – finding the nearest spawn point</h1>
                
            
            
                
<p>Rather than just choosing a random spawn point or waypoint, sometimes, we want to select the one closest to some object (such as the player's <strong>GameObject</strong>). In this recipe, we will modify the previous one to find the nearest spawn point to the player's cube, and use that location to spawn a new red ball prefab.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe builds upon the previous recipe. So, make a copy of this project, open it, and then follow the steps in the next section.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To find the nearest spawn point, follow these steps:</p>
<ol>
<li>Add the following method to the C# Script class called <kbd>SpawnPointManager</kbd>:</li>
</ol>
<pre>    public GameObject NearestSpawnpoint (Vector3 source){<br/>       GameObject nearestSpawnPoint = spawnPoints[0];<br/>       Vector3 spawnPointPos = spawnPoints[0].transform.position;<br/>       float shortestDistance = Vector3.Distance(source, spawnPointPos);<br/><br/>       for (int i = 1; i &lt; spawnPoints.Length; i++){<br/>         spawnPointPos = spawnPoints[i].transform.position;<br/>         float newDist = Vector3.Distance(source, spawnPointPos);<br/>         if (newDist &lt; shortestDistance){<br/>           shortestDistance = newDist;<br/>           nearestSpawnPoint = spawnPoints[i];<br/>         }<br/>       }<br/><br/>       return nearestSpawnPoint;<br/>     } </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>
<ol start="2">
<li>We now need to change the first line in the C# class called <kbd>SpawnBall</kbd> so that the <kbd>spawnPoint</kbd> variable is set by a call to our new method called <kbd>NearestSpawnpoint(...)</kbd>:</li>
</ol>
<pre>    private void CreateSphere(){<br/>       GameObject spawnPoint = <br/>       spawnPointManager.NearestSpawnpoint(transform.position);<br/><br/>       GameObject newBall = (GameObject)Instantiate (prefabBall, <br/>       spawnPoint.transform.position, Quaternion.identity);<br/>       Destroy(newBall, timeBetweenSpawns/2);<br/>     } </pre>
<ol start="3">
<li>Now, run your game. Every second, a red ball should be spawned, and disappear after half a second. Use the arrow keys to move the player's red cube around the terrain. Each time a new ball is spawned, it should be at the spawn point closest to the player.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>In the <kbd>NearestSpawnpoint(...)</kbd> method, we set nearestSpawnpoint to the first (array index <kbd>0</kbd>) <strong>GameObject</strong> in the array as our default. We then loop through the rest of the array (array index <kbd>1</kbd> up to <kbd>spawnPoints.Length</kbd>). For each <strong>GameObject</strong> in the array, we test to see if its distance is less than the shortest distance so far, and if it is, then we update the shortest distance, and also set <kbd>nearestSpawnpoint</kbd> to the current element. When the array has been searched, we return the <strong>GameObject</strong> that the <kbd>nearestSpawnpoint</kbd> variable refers to.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">There's more...</h1>
                
            
            
                
<p>There are some details that you don't want to miss out on.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Avoiding errors due to an empty array</h1>
                
            
            
                
<p>Let's make our code a little more robust so that it can cope with the issue of an empty <kbd>spawnPoints</kbd> array, that is, when there are no objects tagged as <kbd>Respawn</kbd> in the scene.</p>
<p class="mce-root"/>
<p>To cope with the no objects tagged as <kbd>Respawn</kbd>, we need to do the following:</p>
<ol>
<li>Improve our <kbd>Start()</kbd> method in the C# Script class called <kbd>SpawnPointManager</kbd> so that an <em>error</em> is logged if the array of the objects tagged as <kbd>Respawn</kbd> is empty:</li>
</ol>
<pre>    public GameObject NearestSpawnpoint (Vector3 source){<br/>     void Start() {<br/>       spawnPoints = GameObject.FindGameObjectsWithTag("Respawn");<br/><br/>       // logError if array empty<br/>       if(spawnPoints.Length &lt; 1)<br/>         Debug.LogError ("SpawnPointManagaer - cannot find any objects <br/>         tagged 'Respawn'!");<br/>     } </pre>
<ol start="2">
<li>Improve the <kbd>RandomSpawnPoint()</kbd> and <kbd>NearestSpawnpoint()</kbd> methods in the C# Script class called <kbd>SpawnPointManager</kbd> so that they still return a <strong>GameObject</strong>, even if the array is empty:</li>
</ol>
<pre>    public GameObject RandomSpawnPoint (){<br/>       // return current GameObject if array empty<br/>       if(spawnPoints.Length &lt; 1)<br/>         return null;<br/><br/>     // the rest as before ... </pre>
<ol start="3">
<li>Improve the <kbd>CreateSphere()</kbd> method in the C# class called <kbd>SpawnBall</kbd> so that we only attempt to instantiate a new <strong>GameObject</strong> if the <kbd>RandomSpawnPoint()</kbd> and <kbd>NearestSpawnpoint()</kbd> methods have returned a non-null object reference:</li>
</ol>
<pre>    private void CreateSphere(){<br/>       GameObject spawnPoint = spawnPointManager.RandomSpawnPoint ();<br/><br/>       if(spawnPoint){<br/>         GameObject newBall = (GameObject)Instantiate (prefabBall, <br/>         spawnPoint.transform.position, Quaternion.identity);<br/>         Destroy(newBall, destroyAfterDelay);<br/>       }<br/>     } </pre>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mceNonEditable"/>


            

            
        
    

        

                            
                    <h1 class="header-title">See also</h1>
                
            
            
                
<ul>
<li>The same techniques and code can be used for selecting spawn points or waypoints. Refer to the <em>NPC</em> <em>NavMeshAgent control to follow waypoints in sequence</em> recipe in the next chapter (<a href="https://cdp.packtpub.com/unity_2017_cookbook/wp-admin/post.php?post=604&amp;action=edit">Navigation Meshes and Agents</a>)</li>
</ul>


            

            
        
    

        

                            
                    <h1 class="header-title">Choosing destinations – respawning to the most recently passed checkpoint</h1>
                
            
            
                
<p>A checkpoint usually represents a certain distance through the game (or perhaps a track) in which an agent (user or NPC) has succeeded reaching. Reaching (or passing) checkpoints often results in bonus awards, such as extra time, points, ammo, and so on. Also, if a player has multiple lives, then often a player will only be respawned back as far as the most recently passed checkpoint, rather than right to the beginning of the level.</p>
<p>This recipe demonstrates a simple approach to the checkpoints, whereby once the player's character has passed a checkpoint, if they die, they are moved back to the most recently passed checkpoint:</p>
<div><img src="img/c7e329b9-214a-46bd-9088-ad03fec4a8fb.png" style="width:24.50em;height:4.75em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe builds upon the player-controlled 3D cube Unity project that you created at the beginning of this chapter. So, make a copy of this project, open it, and then follow the steps for this recipe.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To have the respawn position change upon losing a life depending on the checkpoints passed, follow these steps:</p>
<ol>
<li>Move the Cube-player <strong>GameObject</strong> to the (12, 0.5, 0) position.</li>
<li>Select Cube-player in the Inspector panel and add a <strong>Character Controller</strong> component by clicking on Add Component | Physics | Character Controller (this is to enable the <strong>OnTriggerEnter</strong> collision messages to be received).</li>
<li>Create a cube named Cube-checkpoint-1 at (5, 0, 0), scaled to (1, 1, 20).</li>
<li>With Cube-checkpoint-1 selected, check the Is Trigger property of its Box Collider component in the Inspector panel.</li>
<li>Create a CheckPoint tag, and assign this tag to Cube-checkpoint-1.</li>
<li>Duplicate Cube-checkpoint-1 and name the clone <kbd>Cube-checkpoint-2</kbd>, and position it at (-5, 0, 0).</li>
<li>Create a sphere named <kbd>Sphere-Death</kbd> at (7, 0.5, 0). Assign the m_red material to this sphere to make it red.</li>
<li>With Sphere-Death selected, check the Is Trigger property of its Sphere Collider component in the Inspector panel.</li>
<li>Create a <kbd>Death</kbd> tag, and assign this tag to Sphere-Death.</li>
<li>Duplicate Sphere-Death, and position this clone at (0, 0.5, 0).</li>
<li>Duplicate Sphere-Death a second time, and position this second clone at (-10, 0.5, 0).</li>
<li>Add an instance of the following C# Script class called <kbd>CheckPoints</kbd> to the Cube-player <strong>GameObject</strong>:</li>
</ol>
<pre>    using UnityEngine;<br/><br/>     public class CheckPoint : MonoBehaviour {<br/>         private Vector3 respawnPosition;<br/>         void Start () {<br/>             respawnPosition = transform.position;<br/>         }<br/><br/>         void OnTriggerEnter (Collider hit) {<br/>             if(hit.CompareTag("Checkpoint"))<br/>                 respawnPosition = transform.position;<br/><br/>             if(hit.CompareTag("Death"))</pre>
<p class="mce-root"/>
<pre>                 transform.position = respawnPosition;<br/>         }<br/>     } </pre>
<p>Run the scene. If the cube runs into a red sphere before crossing a checkpoint, it will be respawned back to its starting position. Once the red cube has passed a checkpoint, if a red sphere is hit, then the cube will be moved back to the location of the most recent checkpoint that it passed through.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The C# script class called <kbd>CheckPoint</kbd> has one variable called <kbd>respawnPosition</kbd>, which is a <strong>Vector3</strong> that refers to the position the player's cube is to be moved to (respawned) if it collides with a <kbd>Death</kbd> tagged object. The default setting for this is the position of the player's cube when the scene begins, so in the <kbd>Start()</kbd> method, we set it to the player's position.</p>
<p>Each time an object tagged called <kbd>Checkpoint</kbd> is collided with, the value of <kbd>respawnPosition</kbd> is updated to the current position of the player's red cube at this point in time (that is, where it is when it touches the stretched cube tagged object called CheckPoint). The next time the object tagged <kbd>Death</kbd> is hit, the cube will be respawned back to where it last touched the object tagged called CheckPoint.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Moving objects by clicking on them</h1>
                
            
            
                
<p>Sometimes, we want to allow the user to interact with objects through mouse pointer clicks. In this recipe, we will allow the user to move an object in a random direction by clicking on it.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe builds upon the player-controlled 3D cube Unity project that you created at the beginning of this chapter. So, make a copy of this project, open it, and then follow the steps for this recipe. The result of following this recipe should look as follows:</p>
<div><img src="img/4b8fb3a4-1972-4e56-8bfb-ff6d1c820c6e.png" style="width:31.50em;height:13.25em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To move objects by clicking on them, follow these steps:</p>
<ol>
<li>Delete the Cube-player <strong>GameObject</strong>.</li>
<li>Set the Main Camera position to (0, 3, -5), and its rotation to (25, 0, 0).</li>
<li>Create a C# Script class called <kbd>ClickMove</kbd>:</li>
</ol>
<pre>    using UnityEngine;<br/><br/>     [RequireComponent(typeof(Rigidbody))]<br/>     public class ClickMove : MonoBehaviour {<br/>         public float multiplier = 500f;<br/>         private Rigidbody rigidBody;<br/><br/>         private void Awake() {<br/>             rigidBody = GetComponent&lt;Rigidbody&gt;();<br/>         }<br/><br/>         void OnMouseDown() {<br/>             float x = RandomDirectionComponent();<br/>             float y = RandomDirectionComponent();<br/>             float z = RandomDirectionComponent();<br/>             Vector3 randomDirection = new Vector3(x,y,z);<br/>             rigidBody.AddForce(randomDirection);<br/>         }<br/><br/>         private float RandomDirectionComponent() {<br/>             return (Random.value - 0.5f) * multiplier;<br/>         }<br/>     } </pre>
<ol start="4">
<li>Create a Cube <strong>GameObject</strong> and add an instance object of the script class <kbd>ClickMove</kbd> as a component.</li>
</ol>
<p>You should see that a <strong>RigidBody</strong> component is automatically added to the new cube, since the script class has the directive <kbd>RequireComponent(typeof(Rigidbody))</kbd>. This only works if the directive is in the code before the script class is added to a <strong>GameObject</strong>.</p>
<ol start="5">
<li>Make four more duplicates of the cube, and arrange the six objects into a pyramid by setting their positions to be the following:</li>
</ol>
<pre>                       (0, 2.5, 0)<br/>    (-0.75, 1.5, 0),   (0.75, 1.5, 0)<br/> (-1, 0.5, 0),   (0, 0.5, 0),   (1.5, 0.5, 0)</pre>
<ol start="6">
<li>Run the scene. Each time you use the mouse pointer to click on a cube, the clicked cube will have a random directional force applied to it. So, with a few clicks, you can knock down the pyramid!</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>The public float variable multiplier allows you to change the maximum magnitude of the force by changing the value in the <kbd>ClickMove</kbd> scripted component of each cube.</p>
<p>The <kbd>ClickMove</kbd> script class has a private variable called <kbd>rigidBody</kbd> set as a reference to the RigidBody component in the <kbd>Awake()</kbd> method.</p>
<p>Each time the cube receives a <kbd>MouseDown()</kbd> message (such as when it has been clicked with the user's mouse pointer), this method creates a random directional <strong>Vector3</strong>, and applies this as a force to the object's <kbd>rigidBody</kbd> reference.</p>
<p>The <kbd>RandomDirectionComponent()</kbd> method returns a random value between <kbd>-multiplier</kbd> and <kbd>+multiplier</kbd>.</p>
<p class="mce-root"/>


            

            
        
    

        

                            
                    <h1 class="header-title">Firing projectiles in the direction of movement</h1>
                
            
            
                
<p>Another common use of force is to apply a force to a newly instantiated object, making it a projectile travelling in the direction the Player's <strong>GameObject</strong> is facing. That's what we'll create in this recipe. The result of following this recipe should look as follows:</p>
<div><img src="img/b1129371-8dba-467f-9351-7130a8e38c2b.png" style="width:10.00em;height:10.17em;"/></div>


            

            
        
    

        

                            
                    <h1 class="header-title">Getting ready</h1>
                
            
            
                
<p>This recipe builds upon the player-controlled 3D cube Unity project that you created at the beginning of this chapter. So, make a copy of this project, open it, and then follow the steps for this recipe.</p>


            

            
        
    

        

                            
                    <h1 class="header-title">How to do it...</h1>
                
            
            
                
<p>To fire projectiles in the direction of movement, follow these steps:</p>
<ol>
<li>Create a new Sphere <strong>GameObject</strong> (by navigating to Create | 3D Object | Sphere). Set its size as (0.5, 0.5, 0.5).</li>
<li>Add a RigidBody component to the Sphere (go to Physics | RigidBody).</li>
<li>In the Project panel, create a new blue <strong>Material</strong> named <kbd>m_blue</kbd> (go to Create | Material).</li>
<li>Apply the <kbd>m_blue</kbd> <strong>Material</strong> to your sphere.</li>
<li>In the Project panel, create a new <strong>Prefab</strong> named <kbd>prefab_projectile</kbd>.</li>
<li>Drag the sphere from the Hierarchy panel over your prefab_projectile (it should turn blue).</li>
<li>You can now delete the Sphere from the Hierarchy.</li>
</ol>
<ol start="8">
<li>Ensure that Cube-player is located at (0, 0.5, 0).</li>
<li>Create a new cube named <kbd>Cube-launcher</kbd>. Disable its Box Collider component, and set its transform as follows:
<ul>
<li>Position (0, 1, 0.3)</li>
<li>Rotation (330, 0, 0)</li>
<li>Scale (0.1, 0.1, 0.5)</li>
</ul>
</li>
<li>In the Hierarchy, make Cube-launcher a child of Cube-player by dragging Cube-launcher onto Cube-player. This means that both objects will move together when the user presses the arrow keys.</li>
<li>Create a C# Script class called <kbd>FireProjectile</kbd> and add an instance object as a component to Cube-launcher:</li>
</ol>
<pre>    using UnityEngine;<br/><br/>     public class FireProjectile : MonoBehaviour {<br/>         const float FIRE_DELAY = 0.25f;<br/>         const float PROJECTILE_LIFE = 1.5f;<br/><br/><br/>         public Rigidbody projectilePrefab;<br/>         public float projectileSpeed = 500f;<br/><br/>         private float nextFireTime = 0;<br/><br/>         void Update() {<br/>             if (Time.time &gt; nextFireTime)<br/>                 CheckFireKey();<br/>         }<br/><br/>         private void CheckFireKey() {<br/>             if(Input.GetButton("Fire1")) {<br/>                 CreateProjectile();<br/>                 nextFireTime = Time.time + FIRE_DELAY;<br/>             }<br/>         }<br/><br/>         private void CreateProjectile() {<br/>             Vector3 position = transform.position;<br/>             Quaternion rotation = transform.rotation;<br/><br/>             Rigidbody projectileRigidBody =<br/>                 Instantiate(projectilePrefab, position, rotation);<br/>             Vector3 projectileVelocity = transform.TransformDirection(<br/>                 Vector3.forward * projectileSpeed);<br/><br/>             projectileRigidBody.AddForce(projectileVelocity);<br/><br/>             GameObject projectileGO = projectileRigidBody.gameObject;<br/>             Destroy(projectileGO, PROJECTILE_LIFE);<br/>         }<br/>     } </pre>
<ol start="12">
<li>With Cube-launcher selected in the Inspector, from the Project panel, drag prefab_projectile into the public variable Projectile Prefab in the Fire Projectile (Script) component in the Inspector.</li>
<li>Run the scene. You can move around the terrain with the arrow keys, and each time you click the mouse button, you should see a blue sphere projectile launched in the direction that the player's cube is facing.</li>
</ol>


            

            
        
    

        

                            
                    <h1 class="header-title">How it works...</h1>
                
            
            
                
<p>You created a blue sphere as a <strong>Prefab</strong> (containing a RigidBody). You then created a scaled and rotated cube for the projectile launcher Cube-launcher, and childed this object to Cube-player.</p>
<p>The <kbd>FireProjectile</kbd> script class contains a constant <kbd>FIRE_DELAY</kbd>—this is the minimum time between the firing of new projectiles, set to <kbd>0.25</kbd> seconds. There is also a second constant called <kbd>PROJECTILE_LIFE</kbd>—this is how long each projectile will "live" until it is automatically destroyed, otherwise, the scene and memory would fill up quickly with lots of old projectiles!</p>
<p>There are also two public variables. One is for the reference to the sphere prefab, and the second is for the initial speed of newly instantiated prefabs.</p>
<p>There is also a private variable called <kbd>nextFireTime</kbd>—this is used to decide whether or not enough time has passed to allow a new projectile to be fired.</p>
<p>The <kbd>Update()</kbd> method tests the current time against the value of <kbd>nextFireTime</kbd>. If enough time has passed, then it will invoke the <kbd>CheckFireKey()</kbd> method.</p>
<p>The <kbd>CheckFireKey()</kbd> method tests to see if the Fire1 button has been clicked. This is usually mapped to the left mouse button, but can be mapped to other input events through the Project Settings (navingate to Edit | Project Settings | Input). If the <kbd>Fire1</kbd> event is detected, then the next fire time is reset to be <kbd>FIRE_DELAY</kbd> seconds in the future, and a new projectile is created by invoking the <kbd>CreateProjectile()</kbd> method.</p>
<p class="mce-root"/>
<p class="mce-root"/>
<p class="mce-root"/>
<p>The <kbd>CreateProjectile()</kbd> method gets the current position and rotation of the parent <strong>GameObject</strong>. Remember that the instance object of this class has been added to Cube-launcher, so our scripted object can use the position and rotation of this launcher as the initial settings for each new projectile. A new instance of <kbd>projectilePrefab</kbd> is created with these position and rotation settings.</p>
<p>Next, a Vector3 called <kbd>projectileVelocity</kbd> is created by multiplying the <kbd>projectileSpeed</kbd> variable with the standard forward vector (0, 0, 1). In Unity, for 3D objects, the Z-axis is generally the direction in which the object is facing.</p>
<p>The special method <kbd>TransformDirection(...)</kbd> is used to turn the local-space forward direction into a world-space direction so that we have a Vector representing a forward motion relative to the Cube-launcher object.</p>
<p>This world-space directional vector is then used to add a force to the projectile's RigidBody.</p>
<p>Finally, a reference is made to the parent <strong>GameObject</strong> of the projectile, and the <kbd>Destroy(...)</kbd> method is used so that the projectile will be destroyed after <kbd>1.5</kbd> seconds—the value of <kbd>PROJECTILE_LIFE</kbd>.</p>
<p>You can learn more about <kbd>Transform.TransformDirection()</kbd> at <a href="https://docs.unity3d.com/ScriptReference/Transform.TransformDirection.html">https://docs.unity3d.com/ScriptReference/Transform.TransformDirection.html</a>.</p>


            

            
        
    </body></html>