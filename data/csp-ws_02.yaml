- en: 2\. Building Quality Object-Oriented Code
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 2. 构建高质量面向对象代码
- en: Overview
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 概述
- en: In this chapter, you will learn how to simplify complex logic using Object-Oriented
    Programming (OOP). You will start by creating classes and objects, before exploring
    the four pillars of OOP. You will then learn about some of the best practices
    in coding, known as the SOLID principles, and see how you can use C# 10 features
    to write effective code guided by these principles. By the end of this chapter,
    you will be able to write clean code using object-oriented design with C#.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习如何使用面向对象编程（OOP）简化复杂逻辑。你将首先创建类和对象，然后探索OOP的四个支柱。接着，你将了解一些编码的最佳实践，即所谓的SOLID原则，并了解如何使用C#
    10特性来根据这些原则编写有效的代码。到本章结束时，你将能够使用C#面向对象设计编写干净的代码。
- en: Introduction
  id: totrans-3
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 简介
- en: How do people write software that is still maintainable even after many decades?
    What is the best way to model software around real-world concepts? The answer
    to both questions is Object Oriented Programming (OOP). OOP is a widely used paradigm
    in professional programming and is especially useful in enterprise settings.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 人们如何编写即使经过几十年仍然可维护的软件？在现实世界概念周围建模软件的最佳方式是什么？这两个问题的答案都是面向对象编程（OOP）。OOP是专业编程中广泛使用的一种范式，在企业环境中尤其有用。
- en: OOP can be thought of as a bridge that connects real-world concepts and source
    code. A cat, for example, has certain defining properties, such as age, fur color,
    eye color, and name. The weather can be described using factors such as temperature
    and humidity. Both of these are real-world concepts that humans have identified
    and defined over time. In OOP, classes are what help in defining the logic of
    a program. When assigning concrete values to the properties of these classes,
    the result is an object. For example, using OOP, you can define a class for representing
    a room in a house, and then assign values to its properties (color and area) to
    create an object of that class.
  id: totrans-5
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）可以被视为连接现实世界概念和源代码的桥梁。例如，一只猫具有某些定义属性，如年龄、毛色、眼色和名字。天气可以用温度和湿度等因素来描述。这两个都是人类在长时间内识别和定义的现实世界概念。在OOP中，类是帮助定义程序逻辑的东西。当将这些类的属性赋予具体值时，结果就是一个对象。例如，使用OOP，你可以定义一个表示房屋中房间的类，然后为其属性（颜色和面积）赋值以创建该类的对象。
- en: In *Chapter 1*, *Hello C#*, you learned how to use C# to write basic programs.
    In this chapter, you will see how you can design your code by implementing OOP
    concepts and using C# at its best.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: 在*第一章*，*Hello C#*中，你学习了如何使用C#编写基本程序。在本章中，你将看到如何通过实现OOP概念和使用C#的最佳方式来设计你的代码。
- en: Classes and Objects
  id: totrans-7
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 类和对象
- en: A class is like a blueprint that describes a concept. An object, on the other
    hand, is the result you get after the application of this blueprint. For example,
    `weather` can be a class, and `25 degrees and` `cloudless` could refer to an object
    of this class. Similarly, you can have a class named `Dog`, while a four-year-old
    `Spaniel` can represent an object of the `Dog` class.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 一个类就像一个描述概念的蓝图。另一方面，对象是在应用这个蓝图后得到的结果。例如，`weather`可以是一个类，而`25 degrees and` `cloudless`可以指这个类的对象。同样，你可以有一个名为`Dog`的类，而一只四岁的`Spaniel`可以代表`Dog`类的对象。
- en: 'Declaring a class in C# is simple. It starts with the `class` keyword, followed
    by the class name and a pair of curly braces. To define a class named `Dog`, you
    can write the following code:'
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中声明一个类很简单。它以`class`关键字开始，后面跟着类名和一对花括号。要定义一个名为`Dog`的类，你可以编写以下代码：
- en: '[PRE0]'
  id: totrans-10
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Right now, this class is just an empty skeleton. However, it can still be used
    to create objects by using the `new` keyword, as follows:'
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 目前，这个类只是一个空的骨架。然而，它仍然可以通过使用`new`关键字来创建对象，如下所示：
- en: '[PRE1]'
  id: totrans-12
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: This creates an object named `dog`. Currently, the object is an empty shell,
    as it lacks properties. You will see in an upcoming section how to define properties
    for classes, but first, you will explore constructors.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 这创建了一个名为`dog`的对象。目前，这个对象是一个空壳，因为它缺少属性。你将在接下来的部分中看到如何为类定义属性，但首先，你将探索构造函数。
- en: Constructors
  id: totrans-14
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 构造函数
- en: In C#, constructors are functions used to create new objects. You can also use
    them to set the initial values of an object. Like any function, a constructor
    has a name, takes arguments, and can be overloaded. A class must have at least
    one constructor, but if needed, it can have multiple constructors with different
    arguments. Even if you do not explicitly define a single constructor, a class
    will still have a default constructor–one that does not take any arguments or
    perform any actions but simply assigns memory to the newly created object and
    its fields.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，构造函数是用于创建新对象的函数。您还可以使用它们来设置对象的初始值。像任何函数一样，构造函数有一个名称，接受参数，并且可以重载。一个类必须至少有一个构造函数，但如果需要，它可以有多个具有不同参数的构造函数。即使您没有显式定义单个构造函数，类仍然有一个默认构造函数——它不接受任何参数或执行任何操作，只是为新建的对象及其字段分配内存。
- en: 'Consider the following snippet, where a constructor for the `Dog` class is
    being declared:'
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段，其中正在声明`Dog`类的构造函数：
- en: '[PRE2]'
  id: totrans-17
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: Note
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/H2lUF](https://packt.link/H2lUF).
    You can find the usage of the code at [https://packt.link/4WoSX](https://packt.link/4WoSX).
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://packt.link/H2lUF](https://packt.link/H2lUF)找到用于此示例的代码。您可以在[https://packt.link/4WoSX](https://packt.link/4WoSX)找到代码的用法。
- en: 'If a method has the same name as the class and does not provide a `return`
    type, it is a constructor. Here, the snippet of the code is within a class named
    `Dog`. So, the constructor is within the specified line of code. Note that by
    defining this constructor explicitly, you hide the default constructor. If there
    is one or more such custom constructors, you will no longer be able to use a default
    constructor. Once the new constructor is called, you should see this message printed
    in the console: `"A Dog object has been created"`.'
  id: totrans-20
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个方法与类的名称相同且不提供`return`类型，则它是一个构造函数。在这里，代码片段位于名为`Dog`的类中。因此，构造函数位于指定的代码行内。请注意，通过显式定义此构造函数，您隐藏了默认构造函数。如果有一个或多个这样的自定义构造函数，您将无法再使用默认构造函数。一旦调用新的构造函数，您应该看到控制台打印出此消息：“已创建一个Dog对象”。
- en: Fields and Class Members
  id: totrans-21
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 字段和类成员
- en: 'You already know what a variable is: it has a type, a name, and a value, as
    you saw in *Chapter 1*, *Hello C#*. Variables can also exist in the class scope,
    and such a variable is called a field. Declaring a field is as simple as declaring
    a local variable. The only difference is the addition of a keyword at the start,
    which is the access modifier. For example, you can declare a field within the
    `Dog` class with the public access modifier, as follows:'
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 您已经知道什么是变量：它有一个类型、一个名称和一个值，正如您在*第一章*，*Hello C#*中看到的。变量也可以存在于类作用域中，这样的变量被称为字段。声明一个字段就像声明一个局部变量一样简单。唯一的区别是在开始时添加一个关键字，即访问修饰符。例如，您可以使用公共访问修饰符在`Dog`类中声明一个字段，如下所示：
- en: '[PRE3]'
  id: totrans-23
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: This line of code states that the `Name` field, which is a string with the value
    `"unnamed"`, can be accessed publicly. Besides `public`, the other two main access
    modifiers in C# are `private` and `protected`, which you will look at them in
    detail later.
  id: totrans-24
  prefs: []
  type: TYPE_NORMAL
  zh: 这行代码表示，`Name`字段，其值是一个字符串`"unnamed"`，可以公开访问。除了`public`之外，C#中的其他两个主要访问修饰符是`private`和`protected`，你将在稍后详细了解它们。
- en: Note
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information regarding access modifiers at [https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers.)
  id: totrans-26
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在[https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers.](https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/access-modifiers.)找到有关访问修饰符的更多信息。
- en: Everything a class holds is called a class member. Class members can be accessed
    from outside of a class; however, such access needs to be granted explicitly using
    the `public` access modifier. By default, all members have a `private` access
    modifier.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 类所持有的所有内容都称为类成员。类成员可以从类外部访问；然而，这种访问需要使用`public`访问修饰符显式授权。默认情况下，所有成员都具有`private`访问修饰符。
- en: 'You can access class members by writing the object name followed by a dot (`.`)
    and the member name. For example, consider the following snippet in which two
    objects of the `Dog` class are being created:'
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过编写对象名称后跟一个点（`.`）和成员名称来访问类成员。例如，考虑以下代码片段，其中创建了两个`Dog`类的对象：
- en: '[PRE4]'
  id: totrans-29
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Here, you can declare two independent variables, `sparky` and `ricky`. However,
    you haven''t explicitly assigned these names to the objects; note that these are
    only the variable names. To assign the names to the objects, you can write the
    following code using dot notation:'
  id: totrans-30
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你可以声明两个独立的变量，`sparky`和`ricky`。然而，你没有明确地将这些名称分配给对象；注意，这些只是变量名。要使用点表示法将这些名称分配给对象，你可以编写以下代码：
- en: '[PRE5]'
  id: totrans-31
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: You can now have hands-on experience of creating classes and objects through
    an exercise.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过一个练习来亲身体验创建类和对象。
- en: 'Exercise 2.01: Creating Classes and Objects'
  id: totrans-33
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.01：创建类和对象
- en: Consider that there are two books, both by an author named `New Writer`. The
    first one, called `First Book`, was published by `Publisher 1`. There is no description
    available for this book. Similarly, the second one is named `Second Book` and
    was published by `Publisher 2`. It has a description that simply says, `"Interesting read"`.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑有两个书籍，都是由名为`New Writer`的作者所著。第一本书名为`First Book`，由`Publisher 1`出版。这本书没有可用的描述。同样，第二本书名为`Second
    Book`，由`Publisher 2`出版。它的描述简单地说：“有趣阅读”。
- en: In this exercise, you will model these books in code. The following steps will
    help you complete this exercise.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你将使用代码来模拟这些书籍。以下步骤将帮助你完成这个练习。
- en: 'Create a class called `Book`. Add fields for `Title`, `Author`, `Publisher`,
    `Description`, and the number of pages. You must print this information from outside
    the class, so make sure every field is `public`:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Book`的类。为`Title`、`Author`、`Publisher`、`Description`和页数添加字段。你必须从类外部打印这些信息，所以确保每个字段都是`public`：
- en: '[PRE6]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Create a class named `Solution`, with the `Main` method. As you saw in *Chapter
    1*, *Hello C#*, this class with the `Main` method is the starting point of your application:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为`Solution`的类，包含`Main`方法。正如你在*第一章*，*Hello C#*中看到的，这个包含`Main`方法的类是应用程序的起点：
- en: '[PRE7]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Inside the `Main` method, create an object for the first book and set the values
    for the fields, as follows:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部，为第一本书创建一个对象并设置字段的值，如下所示：
- en: '[PRE8]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: Here, a new object named `book1` is created. Values are assigned to different
    fields by writing dot (`.`) followed by the field name. The first book does not
    have a description, so you can omit the field `book1.Description`.
  id: totrans-42
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，创建了一个名为`book1`的新对象。通过写点（`.`）后跟字段名来为不同的字段赋值。第一本书没有描述，所以可以省略`book1.Description`字段。
- en: 'Repeat this step for the second book. For this book, you need to set a value
    for the `Description` field as well:'
  id: totrans-43
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为第二本书重复此步骤。对于这本书，你需要为`Description`字段设置一个值：
- en: '[PRE9]'
  id: totrans-44
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: In practice, you will rarely see fields with public access modifiers. Data mutates
    easily, and you might not want to leave your program open to external changes
    after initialization.
  id: totrans-45
  prefs: []
  type: TYPE_NORMAL
  zh: 在实践中，你很少会看到具有公共访问修饰符的字段。数据容易更改，你可能在初始化后不希望程序对外部更改开放。
- en: 'Inside the `Solution` class, create a method named `Print`, which takes a `Book`
    object as an argument and prints all fields and their values. Use string interpolation
    to concatenate book information and print it to the console using `Console.WriteLine()`,
    as follows:'
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Solution`类内部，创建一个名为`Print`的方法，该方法接受一个`Book`对象作为参数并打印所有字段及其值。使用字符串插值将书籍信息连接起来，并使用`Console.WriteLine()`将其打印到控制台，如下所示：
- en: '[PRE10]'
  id: totrans-47
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Inside the `Main` method, call the `Print` method for `book1` and `book2`:'
  id: totrans-48
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Main`方法内部，调用`book1`和`book2`的`Print`方法：
- en: '[PRE11]'
  id: totrans-49
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: 'Upon running this code, you will see the following output on the console:'
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码后，你将在控制台看到以下输出：
- en: '[PRE12]'
  id: totrans-51
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: Note
  id: totrans-52
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/MGT9b](https://packt.link/MGT9b).
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/MGT9b](https://packt.link/MGT9b)找到这个练习所使用的代码。
- en: In this exercise, you saw how to use fields and class members are used in simple
    programs. Now proceed to know about reference types.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个练习中，你看到了如何在简单程序中使用字段和类成员。现在继续了解引用类型。
- en: Reference Types
  id: totrans-55
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 引用类型
- en: 'Suppose you have an object and the object is not created, just declared, as
    follows:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你有一个对象，但这个对象不是创建的，只是声明的，如下所示：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: What would happen if you tried accessing its `Name` value? Calling `speedy.Name`
    would throw a `NullReferenceException` exception because `speedy` is yet to be
    initialized. Objects are reference types, and their default value is null until
    initialized. You have already worked with value types, such as `int`, `float`,
    and `decimal`. Now you need to grasp that there are two major differences between
    value and reference types.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试访问其`Name`值会发生什么？调用`speedy.Name`会抛出`NullReferenceException`异常，因为`speedy`尚未初始化。对象是引用类型，它们的默认值是null，直到初始化。你已经处理过值类型，例如`int`、`float`和`decimal`。现在你需要理解值类型和引用类型之间有两个主要区别。
- en: Firstly, value types allocate memory on the stack, whereas reference types allocate
    memory on the heap. The stack is a temporary place in memory. As the name implies,
    in a stack, blocks of memory are stacked on top of each other. When you call a
    function, all local function variables will end up on a single block of the stack.
    If you call a nested function, the local variables of that function will be allocated
    on another block of the stack.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，值类型在栈上分配内存，而引用类型在堆上分配内存。栈是内存中的一个临时位置。正如其名所示，在栈中，内存块是堆叠在一起的。当你调用一个函数时，所有局部函数变量最终都会位于栈的一个单独块中。如果你调用一个嵌套函数，该函数的局部变量将分配在另一个栈块中。
- en: In the following figure, you can see which parts of code will allocate memory
    in the stack during execution, and which will do so in the heap. Method calls
    (1, 8, 10) and local variables (2, 4) will be stored in the stack. Objects (3,
    5) and their members (6) will be stored on the heap. Stacks use the Push method
    to allocate data, and Pop to deallocate it. When memory is allocated, it comes
    on top of the stack. When it is deallocated, it is removed from the top as well.
    You deallocate memory from the stack as soon as you leave the scope of a method
    (8, 10, 11). Heap is much more random, and Garbage Collector (GC) automatically
    (unlike some other languages, where you need to do it yourself), deallocates memory.
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 在以下图中，你可以看到在执行过程中哪些代码部分会在栈上分配内存，哪些会在堆上分配。方法调用（1、8、10）和局部变量（2、4）将存储在栈上。对象（3、5）及其成员（6）将存储在堆上。栈使用Push方法分配数据，使用Pop释放数据。当分配内存时，它位于栈顶。当它被释放时，也从栈顶移除。你一旦离开方法的范围，就会从栈上释放内存（8、10、11）。堆更加随机，垃圾回收器（GC）自动释放内存（与一些其他语言不同，你需要自己这样做）。
- en: Note
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: GC is a massive topic in itself. If you want to find out more, please refer
    to the official Microsoft documentation at [https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals).
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: GC本身是一个巨大的主题。如果你想了解更多信息，请参阅官方Microsoft文档：[https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/fundamentals)。
- en: '![Figure 2.1: Stack and heap comparison ](img/B16835_02_01.jpg)'
  id: totrans-63
  prefs: []
  type: TYPE_IMG
  zh: '![图2.1：栈和堆比较](img/B16835_02_01.jpg)'
- en: 'Figure 2.1: Stack and heap comparison'
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 图2.1：栈和堆比较
- en: Note
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: If you make too many nested calls, you will run into a `StackoverflowException`
    exception because the stack ran out of memory. Freeing up memory on the stack
    is just a matter of exiting from a function.
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你进行了太多的嵌套调用，你会遇到`StackoverflowException`异常，因为栈内存已耗尽。在栈上释放内存只是退出函数的事情。
- en: The second difference is that, when value types are passed to a method, their
    value is copied, while for reference types, only the reference is copied. This
    means that the reference type object's state is modifiable inside a method, unlike
    a value type, because a reference is simply the address of an object.
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 第二个区别是，当值类型传递给方法时，它们的值被复制，而对于引用类型，只有引用被复制。这意味着在方法内部可以修改引用类型对象的状态，这与值类型不同，因为引用仅仅是对象的地址。
- en: 'Consider the following snippet. Here, a function named `SetTo5` sets the value
    of the number to `5`:'
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段。这里，一个名为`SetTo5`的函数将数字的值设置为`5`：
- en: '[PRE14]'
  id: totrans-69
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: 'Now, consider the following code:'
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，考虑以下代码：
- en: '[PRE15]'
  id: totrans-71
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: 'This should result in the following output:'
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下输出：
- en: '[PRE16]'
  id: totrans-73
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: If you run this code, you find that the printed value of `a` is still `2` and
    not `5`. This is because `a` is a value type that passed the value `2`, and therefore
    its value is copied. Inside a function, you never work with the original; a copy
    is always made.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你运行此代码，你会发现打印的`a`的值仍然是`2`而不是`5`。这是因为`a`是一个值类型，传递了值`2`，因此它的值被复制。在函数内部，你永远不与原始值打交道；总是创建一个副本。
- en: 'What about reference types? Suppose you add a field named `Owner` inside the
    `Dog` class:'
  id: totrans-75
  prefs: []
  type: TYPE_NORMAL
  zh: 那么引用类型呢？假设你在`Dog`类内部添加一个名为`Owner`的字段：
- en: '[PRE17]'
  id: totrans-76
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: 'Create a function, `ResetOwner`, that sets the value of the `Owner` field for
    an object to `None`:'
  id: totrans-77
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个函数`ResetOwner`，将对象的`Owner`字段的值设置为`None`：
- en: '[PRE18]'
  id: totrans-78
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: 'Now, suppose the following code is executed:'
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设以下代码被执行：
- en: '[PRE19]'
  id: totrans-80
  prefs: []
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'This should result in the following output:'
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 这应该产生以下输出：
- en: '[PRE20]'
  id: totrans-82
  prefs: []
  type: TYPE_PRE
  zh: '[PRE20]'
- en: Note
  id: totrans-83
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/gj164](https://packt.link/gj164).
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/gj164](https://packt.link/gj164)找到用于此示例的代码。
- en: If you try running this snippet of code yourself, you will first see the name
    `speedy` on one line and then `None` printed on another. This would change the
    dog's name, and the changes would remain outside the function. This is because
    Dog is a class, and a class is a reference type. When passed to a function, a
    copy of a reference is made. However, a copy of a reference points to the whole
    object, and therefore the changes that are made remain outside as well.
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你亲自尝试运行这段代码，你将首先在一行上看到名称`speedy`，然后在另一行上打印出`None`。这将改变狗的名称，并且这些更改将保留在函数外部。这是因为`Dog`是一个类，而类是一个引用类型。当传递给函数时，会创建一个引用的副本。然而，引用的副本指向整个对象，因此所做的更改也会保留在外部。
- en: 'It might be confusing to hear that you pass a copy of a reference. How can
    you be sure you are working with a copy? To learn this, consider the following function:'
  id: totrans-86
  prefs: []
  type: TYPE_NORMAL
  zh: 听到你传递一个引用的副本可能会让人困惑。你怎么能确定你正在处理一个副本呢？为了了解这一点，考虑以下函数：
- en: '[PRE21]'
  id: totrans-87
  prefs: []
  type: TYPE_PRE
  zh: '[PRE21]'
- en: Here, creating a new object creates a new reference. If you change the value
    of a reference type, you are working with a completely different object. It may
    be one that looks the same but is stored in a completely different place in memory.
    Creating an object for a passed parameter will not affect anything outside the
    object. Though this may sound potentially useful, you should generally avoid doing
    this as it can make code difficult to comprehend.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建一个新的对象创建了一个新的引用。如果你改变一个引用类型的值，你正在处理一个完全不同的对象。它可能看起来相同，但存储在内存中的完全不同的地方。为传递的参数创建一个对象将不会影响对象外部的东西。尽管这可能听起来很有用，但你通常应该避免这样做，因为它可以使代码难以理解。
- en: Properties
  id: totrans-89
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 属性
- en: The `Dog` class has one flaw. Logically, you wouldn't want the name of a dog
    to be changed once it is assigned. However, as of now, there is nothing that prevents
    changing it. Think about the object from the perspective of what you can do with
    it. You can set the name of a dog (`sparky.Name = "Sparky"`) or you can get it
    by calling `sparky.Name`. However, what you want is a read-only name that can
    be set just once.
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dog`类有一个缺陷。从逻辑上讲，你不会希望一旦分配了狗的名称就改变它。然而，到目前为止，没有任何东西可以阻止改变它。从你可以用它做什么的角度来考虑这个对象。你可以通过设置狗的名称（`sparky.Name
    = "Sparky"`）或通过调用`sparky.Name`来获取它。然而，你想要的只是一个只读的名称，可以设置一次。'
- en: Most languages take care of this through setter and getter methods. If you add
    the `public` modifier to a field, this means that it can be both retrieved (read)
    and modified (written). It isn't possible to allow just one of these actions.
    However, with setters and getters, you can restrict both read and write access.
    In OOP, restricting what can be done with an object is key to ensuring data integrity.
    In C#, instead of setter and getter methods, you can use properties.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数语言通过设置器和获取器方法来处理这个问题。如果你将`public`修饰符添加到一个字段上，这意味着它可以被检索（读取）和修改（写入）。不可能只允许这些操作中的任何一个。然而，通过设置器和获取器，你可以限制读取和写入访问。在面向对象编程（OOP）中，限制对对象可以执行的操作是确保数据完整性的关键。在C#中，你可以使用属性而不是设置器和获取器方法。
- en: 'In OOP languages (for example Java), to set or get the values of a name, you
    would write something like this:'
  id: totrans-92
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程语言（例如Java）中，要设置或获取名称的值，你会写如下内容：
- en: '[PRE22]'
  id: totrans-93
  prefs: []
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'In C#, it is as simple as the following:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，它就像以下这样：
- en: '[PRE23]'
  id: totrans-95
  prefs: []
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'This is a property, which is nothing but a method that reads like a field.
    There are two types of properties: getters and setters. You can perform both read
    and write operations with them. From the preceding code, if you remove `get`,
    it will become write-only, and if you remove `set`, it will become read-only.'
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个属性，它实际上是一种像字段一样读取的方法。属性有两种类型：获取器和设置器。你可以使用它们执行读取和写入操作。从前面的代码中，如果你移除`get`，它将变成只写，如果你移除`set`，它将变成只读。
- en: 'Internally, the property includes a setter and a getter method with a backing
    field. A backing field is simply a private field that stores a value, and getter
    and setter methods work with that value. You can write custom getters and setters
    as well, as follows:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 在内部，属性包括一个带有后置字段的设置器和获取器方法。后置字段只是一个存储值的私有字段，获取器和设置器方法与该值一起工作。你还可以像以下这样编写自定义的获取器和设置器：
- en: '[PRE24]'
  id: totrans-98
  prefs: []
  type: TYPE_PRE
  zh: '[PRE24]'
- en: In the preceding snippet, the `Owner` property shows what the default getter
    and setter methods would look like for the `Dog` class.
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的片段中，`Owner` 属性显示了 `Dog` 类默认的获取器和设置器方法的外观。
- en: 'Just like other members, individual parts of a property (either getter or setter)
    can have their own access modifier, like the following:'
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 就像其他成员一样，属性的各个部分（无论是获取器还是设置器）都可以有自己的访问修饰符，如下所示：
- en: '[PRE25]'
  id: totrans-101
  prefs: []
  type: TYPE_PRE
  zh: '[PRE25]'
- en: 'In this case, the getter is `public`, and the setter is `private`. All parts
    of the property (getter, setter, or both, as defined) take the access modifier
    from the property (`Name`, in this case) unless explicitly specified otherwise
    (as in the case of `private` set). If you do not need to set a name, you can get
    rid of the setter. If you need a default value, you can write the code for this
    as follows:'
  id: totrans-102
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，获取器是 `public`，而设置器是 `private`。属性的各个部分（获取器、设置器或两者，根据定义）都继承自属性（在这种情况下是
    `Name`）的访问修饰符，除非明确指定了其他情况（如 `private` 设置）。如果你不需要设置名称，你可以去掉设置器。如果你需要一个默认值，你可以按照以下方式编写代码：
- en: '[PRE26]'
  id: totrans-103
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: This piece of code means that the `Name` field is read-only. You can set the
    name only through a constructor. Note that this is not the same as a `private`
    set because the latter means you can still change the name within the `Dog` class
    itself. If no setter is provided (as is the case here), you can set the value
    in only one place, the constructor.
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码意味着 `Name` 字段是只读的。你只能通过构造函数设置名称。请注意，这与 `private` 设置不同，因为后者意味着你仍然可以在 `Dog`
    类内部更改名称。如果没有提供设置器（如这里的情况），你只能在构造函数中设置值。
- en: 'What happens internally when you create a read-only property? The following
    code is generated by the compiler:'
  id: totrans-105
  prefs: []
  type: TYPE_NORMAL
  zh: 当你创建一个只读属性时，内部会发生什么？以下代码是由编译器生成的：
- en: '[PRE27]'
  id: totrans-106
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: This shows that getter and setter properties are simply methods with a backing
    field. It is important to note that, if you have a property called `Name`, the
    `set_Name()` and `get_Name()` methods will be reserved because that's what the
    compiler generates internally.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 这表明获取器和设置器属性仅仅是带有后置字段的简单方法。需要注意的是，如果你有一个名为 `Name` 的属性，`set_Name()` 和 `get_Name()`
    方法将被保留，因为这是编译器内部生成的。
- en: You may have noticed a new keyword in the previous snippet, `readonly`. It signifies
    that the value of a field can only be initialized once—either during declaration
    or in a constructor.
  id: totrans-108
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能在前面的片段中注意到了一个新的关键字 `readonly`。它表示字段的值只能初始化一次——要么在声明时，要么在构造函数中。
- en: 'Returning a backing field with a property may seem redundant sometimes. For
    example, consider the next snippet:'
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，使用属性返回后置字段可能会显得多余。例如，考虑以下片段：
- en: '[PRE28]'
  id: totrans-110
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'This code snippet is a custom property. When a getter or a setter is more than
    just a basic return, you can write the property in this way to add custom logic
    to it. This property, without affecting the original name of a dog, will prepend
    `Dog''s name is` before returning the name. You can make this more concise using
    expression-bodied property syntax, as follows:'
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 这个代码片段是一个自定义属性。当一个获取器或设置器不仅仅是基本的返回时，你可以以这种方式编写属性，以向其中添加自定义逻辑。这个属性，不会影响狗的原有名称，会在返回名称之前添加
    `Dog's name is`。你可以使用表达式主体属性语法使其更简洁，如下所示：
- en: '[PRE29]'
  id: totrans-112
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: This code does the same thing as the previous code; the `=>` operator indicates
    that it is a read-only property, and you return a value that is specified on the
    right side of the `=>` operator.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码与之前的代码做的是同样的事情；`=>` 操作符表示这是一个只读属性，你返回 `=>` 操作符右侧指定的值。
- en: How do you set the initial value if there is no setter? The answer to that is
    a constructor. In OOP, a constructor serves one purpose—that is, setting the initial
    values of fields. Using a constructor is great for preventing the creation of
    objects in an invalid state.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 如果没有设置器，你如何设置初始值？答案是构造函数。在面向对象编程中，构造函数只有一个目的——那就是设置字段的初始值。使用构造函数可以很好地防止创建处于无效状态的对象。
- en: 'To add some validation to the `Dog` class, you can write the following code:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给 `Dog` 类添加一些验证，你可以编写以下代码：
- en: '[PRE30]'
  id: totrans-116
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: The code you have just written will prevent an empty name from being passed
    when creating a `Dog` instance.
  id: totrans-117
  prefs: []
  type: TYPE_NORMAL
  zh: 你刚才编写的代码将防止在创建 `Dog` 实例时传递空名称。
- en: 'It is worth mentioning that within a class, you have access to the object itself
    that will be created. It might sound confusing, but it should make sense with
    this example:'
  id: totrans-118
  prefs: []
  type: TYPE_NORMAL
  zh: 值得注意的是，在类内部，你可以访问将要创建的对象本身。这可能听起来有些令人困惑，但通过以下示例应该会变得清晰：
- en: '[PRE31]'
  id: totrans-119
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: The `this` keyword is most often used to clear the distinction between class
    members and arguments. `this` refers to the object that has just been created,
    hence, `this.name` refers to the name of that object and `name` refers to the
    passed parameter.
  id: totrans-120
  prefs: []
  type: TYPE_NORMAL
  zh: '`this`关键字最常用于消除类成员和参数之间的区别。`this`指的是刚刚创建的对象，因此`this.name`指的是该对象的名称，而`name`指的是传递的参数。'
- en: 'Creating an object of the `Dog` class, and setting the initial value of a name,
    can now be simplified as follows:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 创建`Dog`类的对象并设置名称的初始值现在可以简化为以下形式：
- en: '[PRE32]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: You still have a private setter, meaning the property that you have is not entirely
    read-only. You can still change the value of a name within the class itself. However,
    fixing that is quite easy; you can simply remove the setter and it will become
    truly read-only.
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: 你仍然有一个私有设置器，这意味着你拥有的属性并非完全只读。你仍然可以在类内部更改名称的值。但是，修复这个问题相当简单；你只需简单地移除设置器，它就会变成真正的只读。
- en: Note
  id: totrans-124
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [http://packt.link/hjHRV](http://packt.link/hjHRV).
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[http://packt.link/hjHRV](http://packt.link/hjHRV)找到这个示例使用的代码。
- en: Object Initialization
  id: totrans-126
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 对象初始化
- en: 'Often, a class has read and write properties. Usually, instead of setting the
    property values via a constructor, they are assigned after the creation of an
    object. However, in C# there is a better way—object initialization. This is where
    you create a new object and set the mutable (read and write) field values right
    away. If you had to create a new object of the `Dog` class and set the value of
    `Owner` for this object to `Tobias`, you could add the following code:'
  id: totrans-127
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，一个类有读和写属性。通常，而不是通过构造函数设置属性值，它们是在对象创建后分配的。然而，在C#中有一个更好的方法——对象初始化。这就是你创建一个新对象并立即设置可变（可读和可写）字段值的地方。如果你需要创建一个`Dog`类的新对象并将该对象的`Owner`值设置为`Tobias`，你可以添加以下代码：
- en: '[PRE33]'
  id: totrans-128
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This can be done using object initialization as follows:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以通过以下对象初始化来完成：
- en: '[PRE34]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Setting initial properties like this when they are not a part of a constructor
    is generally more concise. The same applies to arrays and other collection types.
    Suppose you had two objects of the `Dog` class, as follows:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 当这些初始属性不是构造函数的一部分时，通常会更简洁。同样的规则也适用于数组和其它集合类型。假设你有两个`Dog`类的对象，如下所示：
- en: '[PRE35]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'In such a case, one way of creating an array would be as follows:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，创建数组的一种方法如下：
- en: '[PRE36]'
  id: totrans-134
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'However, instead of this, you can just add the following code, which is more
    concise:'
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，而不是这样做，你只需添加以下代码，这会更简洁：
- en: '[PRE37]'
  id: totrans-136
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: 'In C# 10, you can simplify object initialization without providing the type,
    if it can be inferred from the declaration, as in the following code:'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 在C# 10中，如果你可以从声明中推断出类型，你可以简化对象初始化而不提供类型，如下面的代码所示：
- en: '[PRE38]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE38]'
- en: Comparing Functions and Methods
  id: totrans-139
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 比较函数和方法
- en: Up until now, you might have seen the terms—function and method—used quite often,
    almost interchangeably. Now proceed to gain further insight into functions and
    methods. A function is a block of code that you can call using its name and some
    input. A method is a function that exists within a class.
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你可能经常看到“函数”和“方法”这两个术语被频繁使用，几乎可以互换。现在继续深入了解函数和方法。函数是一段你可以通过其名称和一些输入调用的代码块。方法是存在于类中的函数。
- en: However, in C#, you cannot have functions outside of a class. Therefore, in
    C#, every function is a method. Many languages, especially non-OOP languages,
    have only some functions that can be called methods (for example, JavaScript).
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在C#中，你不能在类外有函数。因此，在C#中，每个函数都是一个方法。许多语言，尤其是非面向对象的语言，只有一些函数可以被称作方法（例如，JavaScript）。
- en: 'The behavior of a class is defined using methods. You have already defined
    some behavior for the `Dog` class, that is, getting its name. To finish implementing
    the behaviors for this class, you can implement some real-world parallels, such
    as sitting and barking. Both methods will be called from the outside:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 类的行为是通过方法定义的。你已经为`Dog`类定义了一些行为，即获取其名称。为了完成这个类的行为实现，你可以实现一些现实世界的类比，比如坐下和吠叫。这两个方法都将从外部调用：
- en: '[PRE39]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE39]'
- en: 'You can call both methods like this:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以这样调用这两个方法：
- en: '[PRE40]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE40]'
- en: In most cases, it is preferable to avoid exposing data publicly, so you should
    only ever expose functions publicly. Here, you might be wondering, What about
    properties? Properties are just getter and setter functions; they work with data
    but aren't data themselves. You should avoid **exposing** data publicly directly,
    for the same reason you lock your doors, or carry your phone in a case. If data
    were public, everyone could access it without any restrictions.
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，最好避免公开数据，因此你应该只公开函数。在这里，你可能想知道，属性怎么办？属性只是获取器和设置器函数；它们与数据一起工作，但本身不是数据。你应该避免直接公开数据，原因和你锁门或把手机放在手机套里一样。如果数据是公开的，任何人都可以无限制地访问它。
- en: Also, data should not change when the program requires it to be constant. A
    method is a mechanism that ensures that an object is not used in invalid ways,
    and if it is, it's well handled.
  id: totrans-147
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，当程序需要数据保持不变时，数据不应发生变化。方法是一种确保对象不被以无效方式使用的机制，如果它被这样使用，它会被妥善处理。
- en: What if you need to validate the fields consistently throughout the application?
    Again, properties, that is, getter and setter methods, can help with this. You
    can limit what you can do with data and add validation logic to it. Properties
    help you be in full control of how you can get and set data. Properties are handy,
    but it's important to use them with discretion. If you want to do something complex,
    something that needs extra computing, it is preferable to use a method.
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你需要在整个应用程序中持续验证字段，那么，属性，即获取器和设置器方法，可以帮到你。你可以限制对数据的操作，并添加验证逻辑。属性帮助你完全控制如何获取和设置数据。属性很方便，但使用它们时需要谨慎。如果你想做一些复杂的事情，需要额外的计算，那么使用方法会更合适。
- en: For example, imagine that you have a class for an inventory made up of items,
    each having some weight. Here, it might make sense to have a property to return
    the heaviest item. If you chose to do so through a property (call it `MaxWeight`),
    you might get unexpected results; getting the heaviest item would require iterating
    through a collection of all items and finding the maximum by weight. This process
    is not as fast as you would expect. In fact, in some cases, it might even throw
    an error. Properties should have simple logic, otherwise working with them might
    yield unexpected results. Therefore, when the need for compute-heavy properties
    arises, consider refactoring them to a method. In this case, you would refactor
    the `MaxWeight` property into the `GetMaxWeight` method.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个由物品组成的库存类，每个物品都有一些重量。在这里，可能有一个属性来返回最重的物品是有意义的。如果你选择通过属性（称为`MaxWeight`）来做这件事，你可能会得到意想不到的结果；获取最重的物品需要遍历所有物品的集合，并按重量找到最大值。这个过程并不像你预期的那么快。实际上，在某些情况下，它甚至可能会抛出错误。属性应该有简单的逻辑，否则与它们一起工作可能会产生意想不到的结果。因此，当需要计算密集型的属性时，考虑将它们重构为方法。在这种情况下，你会将`MaxWeight`属性重构为`GetMaxWeight`方法。
- en: Properties should be avoided for returning results of complex calculations,
    as calling a property could be expensive. Getting or setting the value of a field
    should be straightforward. If it becomes expensive, it should no longer be treated
    as property.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 应该避免使用属性来返回复杂计算的结果，因为调用属性可能会很昂贵。获取或设置字段的值应该是直接的。如果变得昂贵，它就不再被视为属性。
- en: An Effective Class
  id: totrans-151
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 有效的类
- en: The `Dog` class models a `dog` object; therefore, it can be called a model.
    Some developers prefer to have a strict separation between data and logic. Others
    try to put as much logic in a model as possible, so long as it is self-contained.
    There is no right or wrong way here. It all depends on the context you are working
    with.
  id: totrans-152
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dog`类模拟了一个`dog`对象；因此，它可以被称为模型。一些开发者更喜欢在数据和逻辑之间保持严格的分离。其他人则试图在模型中放入尽可能多的逻辑，只要它是自包含的。这里没有对错之分。这完全取决于你正在工作的上下文。'
- en: Note
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: This discussion is outside the scope of this chapter, but if you would like
    to know more, you can refer to the discussion on Domain-Driven Design (DDD) at
    [https://martinfowler.com/bliki/DomainDrivenDesign.xhtml](https://martinfowler.com/bliki/DomainDrivenDesign.xhtml).
  id: totrans-154
  prefs: []
  type: TYPE_NORMAL
  zh: 这个讨论超出了本章的范围，但如果你想了解更多，可以参考关于领域驱动设计（DDD）的讨论，请参阅[https://martinfowler.com/bliki/DomainDrivenDesign.xhtml](https://martinfowler.com/bliki/DomainDrivenDesign.xhtml)。
- en: 'It is hard to pinpoint what an effective class looks like. However, when deciding
    whether a method fits better in class A or class B, try asking yourself these
    questions:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 很难确定一个有效的类是什么样的。然而，在决定一个方法更适合类A还是类B时，试着问自己这些问题：
- en: Would someone, who is not a programmer, know that you are talking about the
    class? Is it a logical representation of a real-world concept?
  id: totrans-156
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 一个非程序员是否知道你在谈论类？它是否是现实世界概念的逻辑表示？
- en: How many reasons does the class have to change? Is it just one or are there
    more reasons?
  id: totrans-157
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类有多少理由需要改变？是只有一个还是更多？
- en: Is private data tightly related to public behavior?
  id: totrans-158
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 私有数据是否与公共行为紧密相关？
- en: How often does the class change?
  id: totrans-159
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类有多频繁地改变？
- en: How easy is it to break the code?
  id: totrans-160
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 破坏代码有多容易？
- en: Does the class do something by itself?
  id: totrans-161
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 这个类是否可以自行执行某些操作？
- en: High cohesion is a term used to describe a class that has all its members strongly
    related, not only semantically, but logically as well. In contrast, a low cohesion
    class has loosely related methods and fields that probably could have a better
    place. Such a class is inefficient because it changes for multiple reasons and
    you cannot expect to look for anything inside it, as it simply has no strong logical
    meaning.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 高聚合性是一个用来描述一个类，其所有成员不仅语义上，而且在逻辑上都有强烈关联的术语。相比之下，低聚合性的类具有松散相关的方法和字段，这些方法可能有一个更好的位置。这样的类效率低下，因为它可能因为多个原因而改变，并且你不能期望在其中找到任何东西，因为它根本没有任何强烈的逻辑意义。
- en: 'For example, a part of a `Computer` class could look like this:'
  id: totrans-163
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，`Computer` 类的一部分可能看起来像这样：
- en: '[PRE41]'
  id: totrans-164
  prefs: []
  type: TYPE_PRE
  zh: '[PRE41]'
- en: 'However, `Computer` and `keys` are not related at the same level. There could
    be another class that better suits the `Key` class, that is `Keyboard`:'
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，`Computer` 和 `keys` 并不在同一级别上相关。可能还有一个更适合 `Key` 类的类，那就是 `Keyboard`：
- en: '[PRE42]'
  id: totrans-166
  prefs: []
  type: TYPE_PRE
  zh: '[PRE42]'
- en: Note
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/FFcDa](https://packt.link/FFcDa).
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/FFcDa](https://packt.link/FFcDa) 找到这个示例所使用的代码。
- en: A keyboard is directly related to keys, just as it is directly related to a
    computer. Here, both `Keyboard` and the `Computer` class have high cohesion because
    the dependencies have a stable logical place. You can now learn more about it
    through an exercise.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 键盘与键直接相关，就像它与电脑直接相关一样。在这里，`Keyboard` 和 `Computer` 类都具有高度的聚合性，因为它们的依赖关系有一个稳定的逻辑位置。你现在可以通过一个练习来了解更多关于它的信息。
- en: 'Exercise 2.02: Comparing the Area Occupied by Different Shapes'
  id: totrans-170
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.02：比较不同形状所占的面积
- en: You have two sections of a backyard, one with circular tiles and the other with
    rectangular tiles. You would like to deconstruct one section of the backyard,
    but you are not sure which one it should be. Obviously, you want as little mess
    as possible and have decided to pick the section that occupies the least area.
  id: totrans-171
  prefs: []
  type: TYPE_NORMAL
  zh: 你有两个后院的部分，一个有圆形瓷砖，另一个有矩形瓷砖。你想要拆解后院的一个部分，但你不确定应该拆哪个。显然，你希望尽可能少地造成混乱，并决定选择占据面积最少的部分。
- en: Given two arrays, one for different sized rectangular tiles and the other for
    different-sized circular tiles, you need to find which section to deconstruct.
    This exercise aims to output the name of the section occupying less area, that
    is, `rectangular` or  `circular`.
  id: totrans-172
  prefs: []
  type: TYPE_NORMAL
  zh: 给定两个数组，一个用于不同尺寸的矩形瓷砖，另一个用于不同尺寸的圆形瓷砖，你需要找到要拆解的部分。这个练习的目标是输出占据面积较小的部分的名字，即 `rectangular`
    或 `circular`。
- en: 'Perform the following steps to do so:'
  id: totrans-173
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成：
- en: 'Create a `Rectangle` class as follows. It should have fields for `width`, `height`,
    and `area`:'
  id: totrans-174
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个 `Rectangle` 类，如下所示。它应该有 `width`、`height` 和 `area` 字段：
- en: '[PRE43]'
  id: totrans-175
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE43]'
- en: 'Here, `_width` and `_height` have been made immutable, using the `readonly`
    keyword. The type chosen is `double` because you will be performing `math` operations.
    The only property that is exposed publicly is `Area`. It will return a simple
    calculation: the product of width and height. The `Rectangle` is immutable, so
    all it needs is to be passed once through a constructor and it remains constant thereafter.'
  id: totrans-176
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`_width` 和 `_height` 已经被设置为不可变的，使用了 `readonly` 关键字。选择的数据类型是 `double`，因为你将执行
    `math` 操作。唯一公开暴露的属性是 `Area`。它将返回一个简单的计算：宽度和高度的乘积。`Rectangle` 是不可变的，所以它只需要通过构造函数传递一次，之后就会保持不变。
- en: 'Similarly, create a `Circle` class as follows:'
  id: totrans-177
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 类似地，创建一个 `Circle` 类，如下所示：
- en: '[PRE44]'
  id: totrans-178
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE44]'
- en: The `Circle` class is similar to `Rectangle` class, except that instead of width
    and height, it has `radius`, and the `Area` calculation uses a different formula.
    The constant `PI` has been used, which can be accessed from the `Math` namespace.
  id: totrans-179
  prefs: []
  type: TYPE_NORMAL
  zh: '`Circle` 类与 `Rectangle` 类相似，除了它没有宽度和高度，而是有 `radius`，并且 `Area` 计算使用不同的公式。这里使用了常数
    `PI`，它可以从 `Math` 命名空间中访问。'
- en: 'Create a `Solution` class with a skeleton method named `Solve`:'
  id: totrans-180
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Solution` 的类，并有一个名为 `Solve` 的骨架方法：
- en: '[PRE45]'
  id: totrans-181
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE45]'
- en: Here, the `Solution` class demonstrates how the code works. For now, there are
    three constants based on the requirements (which section is bigger? rectangular
    or circular, or are they equal?). Also, the flow will be to calculate the total
    area of rectangles, then of circles and finally return the bigger.
  id: totrans-182
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Solution`类展示了代码的工作方式。目前，有三个基于要求的常量（哪个部分更大？矩形还是圆形，或者它们是否相等？）。流程将是先计算矩形的总面积，然后是圆形的总面积，最后返回更大的面积。
- en: Before you can implement the solution, you must first create side methods for
    calculating the total area of the rectangular section, calculating the total area
    of the circular section, and comparing the two. You will do this over the next
    few steps.
  id: totrans-183
  prefs: []
  type: TYPE_NORMAL
  zh: 在实现解决方案之前，你必须首先创建用于计算矩形部分总面积、圆形部分总面积以及比较两者的辅助方法。你将在接下来的几个步骤中完成这项工作。
- en: 'Inside `Solution` class, add a method to calculate the total area of the rectangular
    section:'
  id: totrans-184
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`Solution`类内部，添加一个方法来计算矩形部分的总体面积：
- en: '[PRE46]'
  id: totrans-185
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE46]'
- en: This method goes through all the rectangles, gets the area of each, and adds
    it to the total sum.
  id: totrans-186
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法遍历所有矩形，获取每个矩形的面积，并将其添加到总和中。
- en: 'Similarly, add a method to calculate the total area of the circular section:'
  id: totrans-187
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 同样，添加一个方法来计算圆形部分的总体面积：
- en: '[PRE47]'
  id: totrans-188
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE47]'
- en: 'Next, add a method to get the bigger area, as follows:'
  id: totrans-189
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个方法来获取更大的面积，如下所示：
- en: '[PRE48]'
  id: totrans-190
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE48]'
- en: This snippet contains the most interesting part. In most languages, numbers
    with a decimal point are not accurate. In fact, in most cases, if a and b are
    floats or doubles, it is likely that they will never be equal. Therefore, when
    comparing such numbers, you must consider precision.
  id: totrans-191
  prefs: []
  type: TYPE_NORMAL
  zh: 这个片段包含了最有趣的部分。在大多数语言中，带有小数点的数字并不精确。事实上，在大多数情况下，如果a和b是浮点数或双精度浮点数，它们可能永远不会相等。因此，在比较这样的数字时，你必须考虑精度。
- en: In this code, you have defined the margin, to have an acceptable range of accuracy
    of your comparison for when the numbers are considered equal (for example, 0.001
    and 0.0011 will be equal in this case since the margin is 0.01). After this, you
    can do a regular comparison and return the value for whichever section has the
    biggest area.
  id: totrans-192
  prefs: []
  type: TYPE_NORMAL
  zh: 在此代码中，你定义了边距，以便在比较时，当数字被认为是相等的时候（例如，0.001和0.0011在这种情况下将是相等的，因为边距是0.01）。之后，你可以进行常规比较，并返回面积最大的部分。
- en: 'Now, create the `Main` method, as follows:'
  id: totrans-193
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，创建`Main`方法，如下所示：
- en: '[PRE49]'
  id: totrans-194
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE49]'
- en: Here, four sets of shapes are created for comparison. `compare1` has two empty
    sections, meaning they should be equal. `compare2` has a rectangle and no circles,
    so the rectangle is bigger. `compare3` has a circle and no rectangle, so the circles
    are bigger. Finally, `compare4` has both rectangles and circles, but the total
    area of the circles is bigger. You used string interpolation inside `Console.WriteLine`
    to print the results.
  id: totrans-195
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，创建了四组形状以进行比较。`compare1`有两个空的部分，这意味着它们应该是相等的。`compare2`有一个矩形但没有圆形，所以矩形更大。`compare3`有一个圆形但没有矩形，所以圆形更大。最后，`compare4`既有矩形也有圆形，但圆形的总面积更大。你使用了字符串插值在`Console.WriteLine`内部打印结果。
- en: 'Run the code. You should see the following being printed to the console:'
  id: totrans-196
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码。你应该会在控制台看到以下输出：
- en: '[PRE50]'
  id: totrans-197
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE50]'
- en: Note
  id: totrans-198
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/tfDCw](https://packt.link/tfDCw).
  id: totrans-199
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/tfDCw](https://packt.link/tfDCw)找到用于此练习的代码。
- en: What if you did not have objects? What would the section be made of in that
    case? For a circle, it might be viable to just pass radii, but for rectangles,
    you would need to pass another collinear array with widths and heights.
  id: totrans-200
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你没有对象会怎样？在这种情况下，部分由什么组成？对于一个圆，只传递半径可能是可行的，但对于矩形，你需要传递另一个包含宽度和高度的共线数组。
- en: Object-oriented code is great for grouping similar data and logic under one
    shell, that is, a class, and passing those class objects around. In this way,
    you can simplify complex logic through simple interaction with a class.
  id: totrans-201
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象的代码非常适合将相似的数据和逻辑组合在一个外壳下，即一个类，并传递这些类对象。通过这种方式，你可以通过简单的类交互来简化复杂的逻辑。
- en: You will now know about the four pillars of OOP.
  id: totrans-202
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将了解面向对象编程的四个支柱。
- en: The Four Pillars of OOP
  id: totrans-203
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 面向对象编程的四个支柱
- en: Efficient code should be easy to grasp and maintain, and OOP strives to achieve
    such simplicity. The entire concept of object-oriented design is based on four
    main tenets, also known as the four pillars of OOP.
  id: totrans-204
  prefs: []
  type: TYPE_NORMAL
  zh: 高效的代码应该易于理解和维护，面向对象编程努力实现这种简单性。面向对象设计的整个概念基于四个主要原则，也称为面向对象编程的四个支柱。
- en: Encapsulation
  id: totrans-205
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 封装
- en: 'The first pillar of OOP is encapsulation. It defines the relationship between
    data and behavior, placed in the same shell, that is, a class. It refers to the
    need to expose only what is necessary and hide everything else. When you think
    about encapsulation, think about the importance of security for your code: what
    if you leak a password, return confidential data, or make an API key public? Being
    reckless often leads to damage that can be hard to fix.'
  id: totrans-206
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的第一个支柱是封装。它定义了数据和行为的关联，放置在同一壳中，即类。它指的是只公开必要的内容，隐藏其他所有内容的需求。当你考虑封装时，要考虑代码安全性的重要性：如果你泄露了密码，返回了机密数据，或者公开了API密钥，会发生什么？粗心大意往往会导致难以修复的损害。
- en: Security is not just limited to protection from malicious intent, but also extends
    to preventing manual errors. Humans tend to make mistakes. In fact, the more options
    there are to choose from, the more mistakes they are likely to make. Encapsulation
    helps in that regard because you can simply limit the number of options available
    to the person who will use the code.
  id: totrans-207
  prefs: []
  type: TYPE_NORMAL
  zh: 安全性不仅限于防止恶意意图，还扩展到防止人为错误。人类容易犯错。事实上，可供选择的项目越多，他们犯错的概率就越高。封装在这方面有所帮助，因为你可以简单地限制将代码提供给使用代码的人的选项数量。
- en: 'You should prevent all access by default, and only grant explicit access when
    necessary. For example, consider a simplified `LoginService` class:'
  id: totrans-208
  prefs: []
  type: TYPE_NORMAL
  zh: 应该默认阻止所有访问，并在必要时才授予明确的访问权限。例如，考虑一个简化的 `LoginService` 类：
- en: '[PRE51]'
  id: totrans-209
  prefs: []
  type: TYPE_PRE
  zh: '[PRE51]'
- en: 'This class has two `private` fields: `_usernames` and `_passwords`. The key
    point to note here is that neither passwords nor usernames are accessible to the
    public, but you can still achieve the required functionality by exposing just
    enough logic publicly, through the `Login` method.'
  id: totrans-210
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类有两个 `private` 字段：`_usernames` 和 `_passwords`。这里需要注意的是，密码和用户名对公众不可访问，但你仍然可以通过在
    `Login` 方法中公开足够的逻辑来实现所需的功能。
- en: Note
  id: totrans-211
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find this code used for this example at [https://packt.link/6SO7a](https://packt.link/6SO7a).
  id: totrans-212
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/6SO7a](https://packt.link/6SO7a) 找到用于此示例的代码。
- en: Inheritance
  id: totrans-213
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 继承
- en: A police officer can arrest someone, a mailman delivers mail, and a teacher
    teaches one or more subjects. Each of them performs widely different duties, but
    what do they all have in common? In the context of the real world, they are all
    human. They all have a name, age, height, and weight. If you were to model each,
    you would need to make three classes. Each of those classes would look the same,
    other than one unique method for each. How could you express in code that they
    are all human?
  id: totrans-214
  prefs: []
  type: TYPE_NORMAL
  zh: 警察可以逮捕某人，邮递员投递邮件，教师教授一个或多个科目。他们每个人都执行着广泛不同的职责，但他们有什么共同点？在现实世界的背景下，他们都是人类。他们都有名字、年龄、身高和体重。如果你要为每个角色建模，你需要创建三个类。这些类除了每个类都有一个独特的方法之外，看起来都一样。你如何在代码中表达他们都是人类的事实？
- en: The key to solving this problem is inheritance. It allows you to take all the
    properties from a parent class and transfer them to its child class. Inheritance
    also defines an is-a relationship. A police officer, a mailman, and a teacher
    are all humans, and so you can use inheritance. You will now write this down in
    code.
  id: totrans-215
  prefs: []
  type: TYPE_NORMAL
  zh: 解决这个问题的关键是继承。它允许你从父类中获取所有属性并将其转移到子类中。继承还定义了一个“是”关系。警察、邮递员和教师都是人类，因此你可以使用继承。你现在将用代码写下这一点。
- en: 'Create a `Human` class that has fields for `name`, `age`, `weight`, and `height`:'
  id: totrans-216
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有 `name`、`age`、`weight` 和 `height` 字段的 `Human` 类：
- en: '[PRE52]'
  id: totrans-217
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE52]'
- en: 'A mailman is a human. Therefore, the `Mailman` class should have all that a
    `Human` class has, but on top of that, it should have the added functionality
    of being able to deliver mail. Write the code for this as follows:'
  id: totrans-218
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 邮递员是人类。因此，`Mailman` 类应该拥有 `Human` 类的所有功能，但在此基础上，它还应该具有能够投递邮件的附加功能。按照以下方式编写代码：
- en: '[PRE53]'
  id: totrans-219
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE53]'
- en: 'Now, look closely at the `Mailman` class. Writing `class Mailman : Human` means
    that `Mailman` inherits from `Human`. This means that `Mailman` takes all the
    properties and methods from `Human`. You can also see a new keyword, `base`. This
    keyword is used to tell which parent constructor is going to be used when creating
    `Mailman`; in this case, `Human`.'
  id: totrans-220
  prefs: []
  type: TYPE_NORMAL
  zh: '现在，仔细看看 `Mailman` 类。编写 `class Mailman : Human` 表示 `Mailman` 继承自 `Human`。这意味着
    `Mailman` 会继承 `Human` 中的所有属性和方法。你还可以看到一个新关键字，`base`。这个关键字用于告诉在创建 `Mailman` 时将使用哪个父构造函数；在这种情况下，是
    `Human`。'
- en: 'Next, create a class named `Mail` to represent the mail, containing a field
    for a message being delivered to an address:'
  id: totrans-221
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个名为 `Mail` 的类来表示邮件，该类包含一个用于将消息发送到地址的字段：
- en: '[PRE54]'
  id: totrans-222
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE54]'
- en: Creating a `Mailman` object is no different than creating an object of a class
    that does not use inheritance.
  id: totrans-223
  prefs: []
  type: TYPE_NORMAL
  zh: 创建一个 `Mailman` 对象与创建一个不使用继承的类的对象没有区别。
- en: 'Create `mailman` and `mail` variables and tell the `mailman` to deliver the
    mail as follows:'
  id: totrans-224
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建 `mailman` 和 `mail` 变量，并告诉 `mailman` 按以下方式投递邮件：
- en: '[PRE55]'
  id: totrans-225
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE55]'
- en: Note
  id: totrans-226
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/w1bbf](https://packt.link/w1bbf).
  id: totrans-227
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/w1bbf](https://packt.link/w1bbf) 找到用于此示例的代码。
- en: In the preceding snippet, you created `mailman` and `mail` variables. Then,
    you told the `mailman` to deliver the `mail`.
  id: totrans-228
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码片段中，你创建了 `mailman` 和 `mail` 变量。然后，你告诉 `mailman` 投递 `mail`。
- en: 'Generally, a base constructor must be provided when defining a child constructor.
    The only exception to this rule is when the parent has a parameter-less constructor.
    If a base constructor takes no arguments, then a child constructor using a base
    constructor would be redundant and therefore can be ignored. For example, consider
    the following snippet:'
  id: totrans-229
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，在定义子构造函数时必须提供一个基构造函数。这个规则的唯一例外是当父类有一个无参构造函数。如果基构造函数不带参数，那么使用基构造函数的子构造函数将是多余的，因此可以忽略。例如，考虑以下代码片段：
- en: '[PRE56]'
  id: totrans-230
  prefs: []
  type: TYPE_PRE
  zh: '[PRE56]'
- en: '`A` has no custom constructors, so implementing `B` would not require a custom
    constructor either.'
  id: totrans-231
  prefs: []
  type: TYPE_NORMAL
  zh: '`A` 没有自定义构造函数，因此实现 `B` 也不需要自定义构造函数。'
- en: In C#, only a single class can be inherited; however, you can have a multi-level
    deep inheritance. For example, you could have a child class for `Mailman` named
    `RegionalMailman`, which would be responsible for a single region. In this way,
    you could go deeper and have another child class for `RegionalMailman`, called
    `RegionalBillingMailman`, then `EuropeanRegionalBillingMailman`, and so on.
  id: totrans-232
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，只能继承一个类；然而，你可以有多层深度的继承。例如，你可以有一个名为 `RegionalMailman` 的 `Mailman` 子类，它将负责一个单一的区域。这样，你可以进一步深入，并为
    `RegionalMailman` 创建另一个子类，称为 `RegionalBillingMailman`，然后是 `EuropeanRegionalBillingMailman`，依此类推。
- en: When using inheritance, it is important to know that even if everything is inherited,
    not everything is visible. Just like before, `public` members only will be accessible
    from a parent class. However, in C#, there is a special modifier, named `protected`,
    that works like the `private` modifier. It allows child classes to access `protected`
    members (just like `public` members) but prevents them from being accessed from
    the outside of the class (just like `private`).
  id: totrans-233
  prefs: []
  type: TYPE_NORMAL
  zh: 在使用继承时，重要的是要知道即使所有内容都被继承，并不是所有内容都是可见的。就像之前一样，只有 `public` 成员才能从父类访问。然而，在 C# 中，有一个特殊的修饰符，称为
    `protected`，它就像 `private` 修饰符一样工作。它允许子类访问 `protected` 成员（就像 `public` 成员一样），但阻止它们从类外部访问（就像
    `private` 一样）。
- en: Decades ago, inheritance used to be the answer to many problems and the key
    to code reuse. However, over time, it became apparent that using inheritance comes
    at a price, which is coupling. When you apply inheritance, you couple a child
    class with a parent. Deep inheritance stacks class scope all the way from parent
    to child. The deeper the inheritance, the deeper the scope. Deep inheritance (two
    or more levels deep) should be avoided for the same reason you avoid global variables—it
    is hard to know what comes from where and hard to control the state changes. This,
    in turn, makes the code difficult to maintain.
  id: totrans-234
  prefs: []
  type: TYPE_NORMAL
  zh: 数十年前，继承曾是许多问题的答案和代码重用的关键。然而，随着时间的推移，人们逐渐意识到使用继承是有代价的，这个代价是耦合。当你应用继承时，你会将子类与父类耦合起来。深度继承会将类作用域从父类一直扩展到子类。继承越深，作用域就越深。为了避免与全局变量相同的原因，应该避免深度继承（两个或更多级别），因为它很难知道来源是什么，也很难控制状态变化。这反过来使得代码难以维护。
- en: 'Nobody wants to write duplicate code, but what is the alternative? The answer
    to that is composition. Just as a computer is composed of different parts, code
    should be composed of different parts as well. For example, imagine you are developing
    a 2D game and it has a `Tile` object. Some tiles contain a trap, and some tiles
    move. Using inheritance, you could write the code like this:'
  id: totrans-235
  prefs: []
  type: TYPE_NORMAL
  zh: 没有人想编写重复的代码，但替代方案是什么？答案是组合。就像计算机由不同的部分组成一样，代码也应该由不同的部分组成。例如，想象你正在开发一个 2D 游戏，并且它有一个
    `Tile` 对象。一些地砖包含陷阱，而一些地砖可以移动。使用继承，你可以这样编写代码：
- en: '[PRE57]'
  id: totrans-236
  prefs: []
  type: TYPE_PRE
  zh: '[PRE57]'
- en: This approach works fine until you face more complex requirements. What if there
    are tiles that could both be a trap and move? Should you inherit from a moving
    tile and rewrite the `TrapTile` functionality there? Could you inherit both? As
    you have seen, you cannot inherit more than one class at a time, therefore, if
    you were to implement this using inheritance, you would be forced to both complicate
    the situation, and rewrite some code. Instead, you could think about what different
    tiles contain. `TrapTile` has a trap. `MovingTile` has a motor.
  id: totrans-237
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法在面临更复杂的需求时仍然有效。如果有些瓦片既是陷阱又能移动，该怎么办？你应该从移动瓦片继承并重写那里的 `TrapTile` 功能吗？你能同时继承两个吗？正如你所见，你一次不能继承多个类，因此，如果你要使用继承来实现这一点，你将被迫使情况复杂化，并重写一些代码。相反，你可以考虑不同瓦片包含的内容。`TrapTile`
    有一个陷阱。`MovingTile` 有一个电机。
- en: Both represent tiles, but the extra functionality they each have should come
    from different components, and not child classes. If you wanted to make this a
    composition-based approach, you would need to refactor quite a bit.
  id: totrans-238
  prefs: []
  type: TYPE_NORMAL
  zh: 它们两者都代表瓦片，但它们各自额外的功能应该来自不同的组件，而不是子类。如果你想要将其作为一个基于组合的方法，你需要进行大量的重构。
- en: 'To solve this, keep the `Tile` class as-is:'
  id: totrans-239
  prefs: []
  type: TYPE_NORMAL
  zh: 为了解决这个问题，保持 `Tile` 类不变：
- en: '[PRE58]'
  id: totrans-240
  prefs: []
  type: TYPE_PRE
  zh: '[PRE58]'
- en: 'Now, add two components—Motor and Trap classes. Such components serve as logic
    providers. For now, they do nothing:'
  id: totrans-241
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，添加两个组件——电机和陷阱类。这样的组件作为逻辑提供者。目前，它们什么也不做：
- en: '[PRE59]'
  id: totrans-242
  prefs: []
  type: TYPE_PRE
  zh: '[PRE59]'
- en: Note
  id: totrans-243
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/espfn](https://packt.link/espfn).
  id: totrans-244
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/espfn](https://packt.link/espfn) 找到用于此示例的代码。
- en: 'Next, you define a `MovingTile` class that has a single component, `_motor`.
    In composition, components rarely change dynamically. You should not expose class
    internals, so apply `private readonly` modifiers. The component itself can have
    a child class or change, and so should not be created from the constructor. Instead,
    it should be passed as an argument (see the highlighted code):'
  id: totrans-245
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你定义一个名为 `MovingTile` 的类，它包含一个单一组件 `_motor`。在组合中，组件很少会动态变化。你不应该暴露类的内部结构，因此应用
    `private readonly` 修饰符。组件本身可以有一个子类或发生变化，因此不应该从构造函数中创建。相反，它应该作为参数传递（参见高亮代码）：
- en: '[PRE60]'
  id: totrans-246
  prefs: []
  type: TYPE_PRE
  zh: '[PRE60]'
- en: Note that the `Move` method now calls `_motor.Move()`. That is the essence of
    composition; the class that holds composition often does nothing by itself. It
    just delegates the calls of logic to its components. In fact, even though this
    is just an example class, a real class for a game would look quite similar to
    this.
  id: totrans-247
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，`Move` 方法现在调用 `_motor.Move()`。这就是组合的本质；持有组合的类通常本身并不做什么。它只是将逻辑调用的调用委托给其组件。实际上，尽管这只是一个示例类，但一个真正的游戏类看起来会非常相似。
- en: 'You will do the same for `TrapTile`, except that instead of `Motor`, it will
    contain a `Trap` component:'
  id: totrans-248
  prefs: []
  type: TYPE_NORMAL
  zh: 你将为 `TrapTile` 执行相同的操作，除了它将包含一个 `Trap` 组件而不是 `Motor`：
- en: '[PRE61]'
  id: totrans-249
  prefs: []
  type: TYPE_PRE
  zh: '[PRE61]'
- en: 'Finally, it''s time to create the `MovingTrapTile` class. It has two components
    that provide logic to the `Move` and `Damage` methods. Again, the two methods
    are passed as arguments to a constructor:'
  id: totrans-250
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，是时候创建 `MovingTrapTile` 类了。它有两个组件，为 `Move` 和 `Damage` 方法提供逻辑。同样，这两个方法作为参数传递给构造函数：
- en: '[PRE62]'
  id: totrans-251
  prefs: []
  type: TYPE_PRE
  zh: '[PRE62]'
- en: Note
  id: totrans-252
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/SX4qG](https://packt.link/SX4qG).
  id: totrans-253
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/SX4qG](https://packt.link/SX4qG) 找到用于此示例的代码。
- en: It might seem that this class repeats some code from the other class, but the
    duplication is negligible, and the benefits are well worth it. After all, the
    biggest chunk of logic comes from the components themselves, and a repeated field
    or a call is not significant.
  id: totrans-254
  prefs: []
  type: TYPE_NORMAL
  zh: 可能看起来这个类重复了其他类中的一些代码，但这种重复是可以忽略不计的，而且带来的好处是值得的。毕竟，最大的逻辑块来自组件本身，重复的字段或调用并不重要。
- en: 'You may have noticed that you inherited `Tile`, despite not extracting it as
    a component for other classes. This is because `Tile` is the essence of all the
    classes that inherit it. No matter what type a tile is, it is still a tile. Inheritance
    is the second pillar of OOP. It is powerful and useful. However, it can be hard
    to get inheritance right, because in order to be maintainable, it truly needs
    to be very clear and logical. When choosing whether you should use inheritance,
    consider these factors:'
  id: totrans-255
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能已经注意到，尽管没有将 `Tile` 提取为其他类的组件，但你继承了 `Tile`。这是因为 `Tile` 是所有继承它的类的本质。无论瓦片是什么类型，它仍然是一个瓦片。继承是面向对象编程的第二个支柱。它强大且有用。然而，要正确使用继承可能很困难，因为为了可维护性，它确实需要非常清晰和逻辑。在考虑是否应该使用继承时，考虑以下因素：
- en: Not deep (ideally single level).
  id: totrans-256
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不深入（理想情况下为单级）。
- en: Logical (is-a relation, as you saw in your tiles example).
  id: totrans-257
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 逻辑性（is-a关系，正如你在你的拼图示例中看到的那样）。
- en: Stable and extremely unlikely for the relationship between classes to change
    in the future; not going to be modified often.
  id: totrans-258
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 类之间的关系在未来几乎不会改变，且不太可能经常被修改。
- en: Purely additive (child class should not use parent class members, except for
    a constructor).
  id: totrans-259
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 纯加性（子类不应使用父类成员，除了构造函数）。
- en: If any one of these rules is broken, it is recommended to use composition instead
    of inheritance.
  id: totrans-260
  prefs: []
  type: TYPE_NORMAL
  zh: 如果违反了这些规则中的任何一个，建议使用组合而不是继承。
- en: Polymorphism
  id: totrans-261
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 多态性
- en: The third pillar of OOP is polymorphism. To grasp this pillar, it is useful
    to look at the meaning of the word. `Thomas`. `Thomas` is both a human and a mailman.
    `Mailman` is the specialized form and `Human` is the generalized form for Thomas.
    However, you can interact with `Thomas` through either of the two forms.
  id: totrans-262
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程的第三个支柱是多态性。为了掌握这个支柱，查看这个单词的含义是有用的。`Thomas`。`Thomas`既是人类也是邮递员。`Mailman`是`Thomas`的专门形式，而`Human`是`Thomas`的通用形式。然而，你可以通过这两种形式中的任何一种与`Thomas`进行交互。
- en: If you do not know the jobs for every human, you can use an `abstract` class.
  id: totrans-263
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你不知道每个人类的职责，你可以使用抽象类。
- en: 'An `abstract` class is a synonym for an incomplete class. This means that it
    cannot be initialized. It also means that some of its methods may not have an
    implementation if you mark them with the `abstract` keyword. You can implement
    this for the `Human` class as follows:'
  id: totrans-264
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象类是未完成类的同义词。这意味着它不能被初始化。这也意味着如果你用`abstract`关键字标记它们，其中一些方法可能没有实现。你可以为`Human`类实现如下：
- en: '[PRE63]'
  id: totrans-265
  prefs: []
  type: TYPE_PRE
  zh: '[PRE63]'
- en: You have created an abstract (incomplete) `Human` class here. The only difference
    from earlier is that you have applied the `abstract` keyword to the class and
    added a new `abstract` method, `public abstract void Work()`. You have also changed
    the constructor to protected so that it is accessible only from a child class.
    This is because it no longer makes sense to have it `public` if you cannot create
    an `abstract` class; you cannot call a `public` constructor. Logically, this means
    that the `Human` class, by itself, has no meaning, and it only gets meaning after
    you have implemented the `Work` method elsewhere (that is, in a child class).
  id: totrans-266
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这里创建了一个抽象（不完整）的`Human`类。与之前的不同之处在于，你将`abstract`关键字应用于类，并添加了一个新的`abstract`方法，`public
    abstract void Work()`。你还改变了构造函数为受保护的，这样它就只能从子类中访问。这是因为如果你不能创建抽象类，它就不再有`public`的意义；你不能调用`public`构造函数。从逻辑上讲，这意味着`Human`类本身没有意义，它只有在你在其他地方（即在子类中）实现了`Work`方法之后才有意义。
- en: 'Now, you will update the `Mailman` class. It does not change much; it just
    gets an additional method, that is, `Work()`. To provide an implementation for
    abstract methods, you must use the `override` keyword. In general, this keyword
    is used to change the implementation of an existing method inside a child class.
    You will explore this in detail later:'
  id: totrans-267
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你将更新`Mailman`类。它没有太大变化；它只是增加了一个额外的方法，即`Work()`。为了为抽象方法提供实现，你必须使用`override`关键字。通常，这个关键字用于在子类内部更改现有方法的实现。你将在稍后详细探讨这一点：
- en: '[PRE64]'
  id: totrans-268
  prefs: []
  type: TYPE_PRE
  zh: '[PRE64]'
- en: 'If you were to create a new object for this class and call the `Work` method,
    it would print `"A mailman is delivering mails."` to the console. To get a full
    picture of polymorphism, you will now create one more class, `Teacher`:'
  id: totrans-269
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你为这个类创建一个新的对象并调用`Work`方法，它会在控制台打印出`"A mailman is delivering mails."`。为了全面了解多态性，你现在将创建另一个类，`Teacher`：
- en: '[PRE65]'
  id: totrans-270
  prefs: []
  type: TYPE_PRE
  zh: '[PRE65]'
- en: This class is almost identical to `Mailman`; however, a different implementation
    for the `Work` method is provided. Thus, you have two classes that do the same
    thing in two different ways. The act of calling a method of the same name, but
    getting different behavior, is called polymorphism.
  id: totrans-271
  prefs: []
  type: TYPE_NORMAL
  zh: 这个类几乎与`Mailman`相同；然而，提供了`Work`方法的不同实现。因此，你有了两个以两种不同方式做同样事情的类。调用同名方法但得到不同行为的行为称为多态性。
- en: 'You already know about method overloading (not to be confused with overriding),
    which is when you have methods with the same names but different inputs. That
    is called static polymorphism and it happens during compile time. The following
    is an example of this:'
  id: totrans-272
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经了解了方法重载（不要与覆盖混淆），这是当你有相同名称但不同输入的方法时。这被称为静态多态性，它发生在编译时。以下是一个例子：
- en: '[PRE66]'
  id: totrans-273
  prefs: []
  type: TYPE_PRE
  zh: '[PRE66]'
- en: The `Person` class has two methods with the same name, Say. One takes no arguments
    and the other takes a string as an argument. Depending on the arguments passed,
    different implementations of the method will be called. If nothing is passed,
    `"Hello"` will be printed. Otherwise, the words you pass will be printed.
  id: totrans-274
  prefs: []
  type: TYPE_NORMAL
  zh: '`Person`类有两个同名的方法，`Say`。一个不接受任何参数，另一个接受一个字符串参数。根据传递的参数，将调用不同实现的方法。如果没有传递任何内容，将打印`"Hello"`。否则，将打印你传递的单词。'
- en: In the context of OOP, polymorphism is referred to as dynamic polymorphism,
    which happens during runtime. For the rest of this chapter, polymorphism should
    be interpreted as dynamic polymorphism.
  id: totrans-275
  prefs: []
  type: TYPE_NORMAL
  zh: 在面向对象编程的上下文中，多态被称为动态多态，它发生在运行时。在本章的其余部分，多态应理解为动态多态。
- en: What is the Benefit of Polymorphism?
  id: totrans-276
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 多态的好处是什么？
- en: 'A teacher is a human, and the way a teacher works is by teaching. This is not
    the same as a mailman, but a teacher also has a name, age, weight, and height,
    like a mailman. Polymorphism allows you to interact with both in the same way,
    regardless of their specialized forms. The best way to illustrate this is to store
    both in an array of `humans` values and make them work:'
  id: totrans-277
  prefs: []
  type: TYPE_NORMAL
  zh: 老师是人，老师的工作方式是通过教学。这和邮递员不同，但老师也有名字、年龄、体重和身高，就像邮递员一样。多态允许你以相同的方式与两者交互，无论它们的特殊形式如何。最好的说明方式是将两者存储在`humans`值的数组中，并让它们工作：
- en: '[PRE67]'
  id: totrans-278
  prefs: []
  type: TYPE_PRE
  zh: '[PRE67]'
- en: 'This code results in the following being printed in the console:'
  id: totrans-279
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码会导致以下内容在控制台打印出来：
- en: '[PRE68]'
  id: totrans-280
  prefs: []
  type: TYPE_PRE
  zh: '[PRE68]'
- en: Note
  id: totrans-281
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/ovqru](https://packt.link/ovqru).
  id: totrans-282
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/ovqru](https://packt.link/ovqru)找到用于此示例的代码。
- en: This code was polymorphism in action. You treated both `Mailman` and `Teacher`
    as `Human` and implemented the `Work` method for both. The result was different
    behaviors in each case. The important point to note here is that you did not have
    to care about the exact implementations of `Human` to implement `Work`.
  id: totrans-283
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码展示了多态的作用。你将`Mailman`和`Teacher`都视为`Human`，并为两者实现了`Work`方法。结果是每种情况都有不同的行为。这里要注意的重要点是，你不必关心`Human`的确切实现来实施`Work`。
- en: 'How would you implement this without polymorphism? You would need to write
    `if` statements based on the exact type of an object to find the behavior it should
    use:'
  id: totrans-284
  prefs: []
  type: TYPE_NORMAL
  zh: 没有多态，你将如何实现这一点？你需要根据对象的精确类型编写`if`语句来找到它应该使用的行为：
- en: '[PRE69]'
  id: totrans-285
  prefs: []
  type: TYPE_PRE
  zh: '[PRE69]'
- en: As you see, this is a lot more complicated and harder to grasp. Keep this example
    in mind when you get into a situation with many `if` statements. Polymorphism
    can remove the burden of all that branching code by simply moving the code for
    each branch into a child class and simplifying the interactions.
  id: totrans-286
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这要复杂得多，也更难理解。当你遇到许多`if`语句的情况时，请记住这个例子。多态可以通过将每个分支的代码移动到子类中并简化交互来消除所有这些分支代码的负担。
- en: 'What if you wanted to print some information about a person? Consider the following code:'
  id: totrans-287
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想打印有关某人的信息呢？考虑以下代码：
- en: '[PRE70]'
  id: totrans-288
  prefs: []
  type: TYPE_PRE
  zh: '[PRE70]'
- en: 'Running this code would result in the object type names being printed to the
    console:'
  id: totrans-289
  prefs: []
  type: TYPE_NORMAL
  zh: 运行此代码会导致对象类型名称被打印到控制台：
- en: '[PRE71]'
  id: totrans-290
  prefs: []
  type: TYPE_PRE
  zh: '[PRE71]'
- en: In C#, everything derives from the `System.Object` class, so every single type
    in C# has a method called `ToString()`. Each type has its own implementation of
    this method, which is another example of polymorphism, widely used in C#.
  id: totrans-291
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，所有内容都从`System.Object`类派生，所以C#中的每个类型都有一个名为`ToString()`的方法。每个类型都有自己的方法实现，这是多态的另一个例子，在C#中广泛使用。
- en: Note
  id: totrans-292
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: '`ToString()` is different from `Work()` in that it provides a default implementation.
    You can achieve that using the `virtual` keyword, which will be covered in detail
    later in the chapter. From the point of view of a child class, working with the
    `virtual` or `abstract` keyword is the same. If you want to change or provide
    behavior, you will override the method.'
  id: totrans-293
  prefs: []
  type: TYPE_NORMAL
  zh: '`ToString()`与`Work()`不同，因为它提供了一个默认实现。你可以使用`virtual`关键字来实现这一点，这将在本章后面详细讨论。从子类的角度来看，使用`virtual`或`abstract`关键字是相同的。如果你想改变或提供行为，你将重写该方法。'
- en: 'In the following snippet, a `Human` object is given a custom implementation
    of the `ToString()` method:'
  id: totrans-294
  prefs: []
  type: TYPE_NORMAL
  zh: 在下面的代码片段中，一个`Human`对象被赋予了一个自定义的`ToString()`方法实现：
- en: '[PRE72]'
  id: totrans-295
  prefs: []
  type: TYPE_PRE
  zh: '[PRE72]'
- en: 'Trying to print information about the humans in the same foreach loop would
    result in the following output:'
  id: totrans-296
  prefs: []
  type: TYPE_NORMAL
  zh: 尝试在同一个foreach循环中打印关于人类的信息会导致以下输出：
- en: '[PRE73]'
  id: totrans-297
  prefs: []
  type: TYPE_PRE
  zh: '[PRE73]'
- en: Note
  id: totrans-298
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/EGDkC](https://packt.link/EGDkC).
  id: totrans-299
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/EGDkC](https://packt.link/EGDkC)找到用于此示例的代码。
- en: Polymorphism is one of the best ways to use different underlying behaviors when
    dealing with missing type information.
  id: totrans-300
  prefs: []
  type: TYPE_NORMAL
  zh: 多态是在处理缺失类型信息时使用不同底层行为的最有效方法之一。
- en: Abstraction
  id: totrans-301
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 抽象
- en: The last pillar of OOP is abstraction. Some say that there are only three pillars
    of OOP because abstraction does not really introduce much that is new. Abstraction
    encourages you to hide implementation details and simplify interactions between
    objects. Whenever you need the functionality of only a generalized form, you should
    not depend on its implementation.
  id: totrans-302
  prefs: []
  type: TYPE_NORMAL
  zh: 面向对象编程（OOP）的最后一根支柱是抽象。有人说OOP只有三个支柱，因为抽象并没有真正引入很多新的东西。抽象鼓励你隐藏实现细节并简化对象之间的交互。每当你需要仅一个通用形式的功能时，你不应该依赖于它的实现。
- en: Abstraction could be illustrated with an example of how people interact with
    their computers. What occurs in the internal circuitry when you turn on the computer?
    Most people would have no clue, and that is fine. You do not need to know about
    the internal workings if you only need to use some functionality. All you have
    to know is what you can do, and not how it works. You know you can turn a computer
    on and off by pressing a button, and all the complex details are hidden away.
    Abstraction adds little new to the other three pillars because it reflects each
    of them. **Abstraction is similar to encapsulation**, as it hides unnecessary
    details to simplify interaction. It is also similar to polymorphism because it
    can interact with objects without knowing their exact types. Finally, inheritance
    is just one of the ways to create abstractions.
  id: totrans-303
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象可以通过一个例子来说明人们如何与他们的电脑互动。当你打开电脑时，内部电路会发生什么？大多数人可能没有头绪，这是正常的。如果你只需要使用某些功能，你不需要了解内部工作原理。你所需要知道的是你可以做什么，而不是它是如何工作的。你知道你可以通过按按钮来打开和关闭电脑，而所有复杂的细节都被隐藏起来。抽象对其他三个支柱的贡献很小，因为它反映了它们每一个。**抽象与封装相似**，因为它隐藏了不必要的细节以简化交互。它也类似于多态，因为它可以与不知道其确切类型的对象交互。最后，继承只是创建抽象的一种方式。
- en: 'You do not need to provide unnecessary details coming through implementation
    types when creating functions. The following example illustrates this problem.
    You need to make a progress bar. It should keep track of the current progress
    and should increment the progress up to a certain point. You could create a basic
    class with setters and getters, as follows:'
  id: totrans-304
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建函数时，你不需要提供通过实现类型传递的不必要细节。以下示例说明了这个问题。你需要创建一个进度条。它应该跟踪当前进度，并应将进度增加到一定点。你可以创建一个带有设置器和获取器的基本类，如下所示：
- en: '[PRE74]'
  id: totrans-305
  prefs: []
  type: TYPE_PRE
  zh: '[PRE74]'
- en: 'The following code demonstrates how to initialize a progress bar that starts
    at `0` progress and goes up to `100`. The rest of the code illustrates what happens
    when you want to set the new progress to 120\. Progress cannot be more than `Max`,
    hence, if it is more than `bar.Max`, it should just remain at `bar.Max`. Otherwise,
    you can update the new progress with the value you set. Finally, you need to check
    whether the progress is complete (at `Max` value). To do so, you will compare
    the delta with the allowed margin of error tolerance (`0.0001`). A progress bar
    is complete if it is close to tolerance. So, updating progress could look like
    the following:'
  id: totrans-306
  prefs: []
  type: TYPE_NORMAL
  zh: 以下代码演示了如何初始化一个进度条，该进度条从`0`进度开始，增加到`100`。其余的代码说明了当你想要将新的进度设置为`120`时会发生什么。进度不能超过`Max`，因此，如果它超过`bar.Max`，它应该保持在`bar.Max`。否则，你可以使用你设置的值更新新的进度。最后，你需要检查进度是否完成（达到`Max`值）。为此，你需要比较增量与允许的误差容忍度范围（`0.0001`）。如果进度条接近容忍度，则表示进度条已完成。因此，更新进度的代码可能如下所示：
- en: '[PRE75]'
  id: totrans-307
  prefs: []
  type: TYPE_PRE
  zh: '[PRE75]'
- en: This code does what is asked for, but it needs a lot of detail for a function.
    Imagine if you had to use this in other code; you would need to perform the same
    checks once again. In other words, it was easy to implement but complex to consume.
    You have so little within the class itself. A strong indicator of that is that
    you keep on calling the object, instead of doing something inside the class itself.
    Publicly, it's possible to break the object state by forgetting to check the `Max`
    value of progress and setting it to some high or negative value. The code that
    you wrote has low cohesion because to change `ProgressBar`, you would do it not
    within the class but somewhere outside of it. You need to create a better abstraction.
  id: totrans-308
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码完成了所需的功能，但需要一个函数的很多细节。想象一下，如果你在其他代码中使用这段代码，你需要再次执行相同的检查。换句话说，它容易实现但复杂难用。在类内部，你拥有的内容很少。一个强烈的迹象是，你总是调用对象，而不是在类内部做些事情。公开地，可能会通过忘记检查进度的`Max`值并将它设置为某个高值或负值来破坏对象状态。你写的代码耦合度低，因为要改变`ProgressBar`，你不会在类内部做，而是在类外部做。你需要创建一个更好的抽象。
- en: 'Consider the following snippet:'
  id: totrans-309
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑以下代码片段：
- en: '[PRE76]'
  id: totrans-310
  prefs: []
  type: TYPE_PRE
  zh: '[PRE76]'
- en: With this code, you have hidden the nitty-gritty details. When it comes to updating
    progress and defining what the tolerance is, that is up to the `ProgressBar` class
    to decide. In the refactored code, you have a property, `Current`, with a backing
    field, `_current`, to store the progress. The property setter checks whether progress
    is more than the maximum and, if it is, it will not allow the value of `_current`
    to be set to a higher value, `=`. It also cannot be negative, as in those cases,
    the value will be adjusted to `0`. Lastly, if it is not negative and not more
    than the maximum, then you can set `_current` to whatever value you pass.
  id: totrans-311
  prefs: []
  type: TYPE_NORMAL
  zh: 使用这段代码，你隐藏了细节。当涉及到更新进度和定义容差时，这由`ProgressBar`类来决定。在重构的代码中，你有一个属性`Current`，它有一个后端字段`_current`来存储进度。属性设置器检查进度是否超过最大值，如果是，则不允许将`_current`的值设置为更高的值，即`=`。它也不能是负数，因为在这种情况下，值将被调整为`0`。最后，如果它既不是负数也不超过最大值，那么你可以将`_current`设置为传递的任何值。
- en: 'Clearly, this code makes it much simpler to interact with the `ProgressBar`
    class:'
  id: totrans-312
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，这段代码使得与`ProgressBar`类的交互变得更加简单：
- en: '[PRE77]'
  id: totrans-313
  prefs: []
  type: TYPE_PRE
  zh: '[PRE77]'
- en: You cannot break anything; you do not have any extra choices and all you can
    do is defined through minimalistic methods. When you are asked to implement a
    feature, it is not recommended to do more than what is asked. Try to be minimalistic
    and simplistic because that is key to an effective code.
  id: totrans-314
  prefs: []
  type: TYPE_NORMAL
  zh: 你不能破坏任何东西；你没有任何额外的选择，你所能做的只是通过最小化方法定义。当你被要求实现一个功能时，不建议做超过所需的事情。尽量保持最小化和简单化，因为这对于有效的代码至关重要。
- en: Remember that well-abstracted code is full of empathy toward the reader. Just
    because today, it is easy to implement a class or a function, you should not forget
    about tomorrow. The requirements change, the implementation changes, but the structure
    should remain stable, otherwise, your code can break easily.
  id: totrans-315
  prefs: []
  type: TYPE_NORMAL
  zh: 记住，优秀的抽象代码充满了对读者的同理心。仅仅因为今天实现一个类或函数很容易，你也不应该忘记明天。需求会变化，实现也会变化，但结构应该保持稳定，否则你的代码很容易崩溃。
- en: Note
  id: totrans-316
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example can be found at [https://packt.link/U126i](https://packt.link/U126i).
    The code given in GitHub is split into two contrasting examples—`ProgressBarGood`
    and `ProgressBarBad`. Both codes are simple `ProgressBar` but were named distinctly
    to avoid ambiguity.
  id: totrans-317
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/U126i](https://packt.link/U126i)找到用于此示例的代码。GitHub中给出的代码分为两个对比鲜明的示例——`ProgressBarGood`和`ProgressBarBad`。这两个代码都是简单的`ProgressBar`，但被明确地命名以避免歧义。
- en: Interfaces
  id: totrans-318
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口
- en: Earlier, it was mentioned that inheritance is not the proper way of designing
    code. However, you want to have an efficient abstraction as well as support for
    polymorphism, and little to no coupling. What if you wanted to have robot or ant
    workers? They do not have a name. Information such as height and weight are irrelevant.
    And inheriting from the `Human` class would make little sense. Using an interface
    solves this conundrum.
  id: totrans-319
  prefs: []
  type: TYPE_NORMAL
  zh: 之前提到过，继承并不是设计代码的正确方式。然而，你希望拥有高效的抽象以及多态性的支持，并且尽量减少耦合。如果你想要拥有机器人或蚂蚁工人呢？它们没有名字。诸如身高和体重等信息都是无关紧要的。而且从`Human`类继承几乎没有什么意义。使用接口可以解决这个问题。
- en: In C#, by convention, interfaces are named starting with the letter `I`, followed
    by their actual name. An interface is a contract that states what a class can
    do. It does not have any implementation. It only defines behavior for every class
    that implements it. You will now refactor the human example using an interface.
  id: totrans-320
  prefs: []
  type: TYPE_NORMAL
  zh: 在 C# 中，按照惯例，接口的命名以字母 `I` 开头，后跟其实际名称。接口是一个合同，它声明了一个类可以做什么。它没有任何实现。它只为实现它的每个类定义行为。现在，你将使用接口重构人类示例。
- en: 'What can an object of the `Human` class do? It can work. Who or what can do
    work? A worker. Now, consider the following snippet:'
  id: totrans-321
  prefs: []
  type: TYPE_NORMAL
  zh: '`Human` 类的对象能做什么？它可以工作。谁或什么能做工作？一个工人。现在，考虑以下片段：'
- en: '[PRE78]'
  id: totrans-322
  prefs: []
  type: TYPE_PRE
  zh: '[PRE78]'
- en: Note
  id: totrans-323
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Interface `Work` method will have is the same as the interface access modifier,
    in this case, `public`.
  id: totrans-324
  prefs: []
  type: TYPE_NORMAL
  zh: 接口 `Work` 方法将与接口访问修饰符相同，在这种情况下，`public`。
- en: 'An ant is not a human, but it can work. With an interface, abstracting an ant
    as a worker is straightforward:'
  id: totrans-325
  prefs: []
  type: TYPE_NORMAL
  zh: 蚂蚁不是人类，但它可以工作。通过接口，将蚂蚁抽象为工人是直接的：
- en: '[PRE79]'
  id: totrans-326
  prefs: []
  type: TYPE_PRE
  zh: '[PRE79]'
- en: 'Similarly, a robot is not a human, but it can work as well:'
  id: totrans-327
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，机器人不是人类，但它也可以工作：
- en: '[PRE80]'
  id: totrans-328
  prefs: []
  type: TYPE_PRE
  zh: '[PRE80]'
- en: 'If you refer to the `Human` class, you can change its definition to `public
    abstract class Human : IWorker`. This can be read as: `Human` class implements
    the `IWorker` interface.'
  id: totrans-329
  prefs: []
  type: TYPE_NORMAL
  zh: '如果你引用 `Human` 类，你可以将其定义更改为 `public abstract class Human : IWorker`。这可以读作：`Human`
    类实现了 `IWorker` 接口。'
- en: 'In the next snippet, `Mailman` inherits the `Human` class, which implements
    the `IWorker` interface:'
  id: totrans-330
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一个片段中，`Mailman` 继承了 `Human` 类，该类实现了 `IWorker` 接口：
- en: '[PRE81]'
  id: totrans-331
  prefs: []
  type: TYPE_PRE
  zh: '[PRE81]'
- en: If a child class inherits a parent class, which implements some interfaces,
    the child class will also be able to implement the same interfaces by default.
    However, `Human` was an abstract class and you had to provide implementation to
    the `abstract void Work` method.
  id: totrans-332
  prefs: []
  type: TYPE_NORMAL
  zh: 如果子类继承了一个实现了某些接口的父类，则子类默认也能实现相同的接口。然而，`Human` 是一个抽象类，你必须提供 `abstract void Work`
    方法的实现。
- en: 'If anyone asked what a human, an ant, and a robot have in common, you could
    say that they can all work. You can simulate this situation as follows:'
  id: totrans-333
  prefs: []
  type: TYPE_NORMAL
  zh: 如果有人问人类、蚂蚁和机器人有什么共同点，你可以说它们都可以工作。你可以模拟这种情况如下：
- en: '[PRE82]'
  id: totrans-334
  prefs: []
  type: TYPE_PRE
  zh: '[PRE82]'
- en: 'This prints the following to the console:'
  id: totrans-335
  prefs: []
  type: TYPE_NORMAL
  zh: 这将在控制台打印以下内容：
- en: '[PRE83]'
  id: totrans-336
  prefs: []
  type: TYPE_PRE
  zh: '[PRE83]'
- en: Note
  id: totrans-337
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for the example at [https://packt.link/FE2ag](https://packt.link/FE2ag).
  id: totrans-338
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/FE2ag](https://packt.link/FE2ag) 找到用于示例的代码。
- en: 'C# does not support multiple inheritance. However, it is possible to implement
    multiple interfaces. Implementing multiple interfaces does not count as multiple
    inheritance. For example, to implement a `Drone` class, you could add an `IFlyer` interface:'
  id: totrans-339
  prefs: []
  type: TYPE_NORMAL
  zh: C# 不支持多重继承。然而，可以实现多个接口。实现多个接口不算作多重继承。例如，为了实现 `Drone` 类，你可以添加一个 `IFlyer` 接口：
- en: '[PRE84]'
  id: totrans-340
  prefs: []
  type: TYPE_PRE
  zh: '[PRE84]'
- en: '`Drone` is a flying object that can do some work; therefore it can be expressed
    as follows:'
  id: totrans-341
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drone` 是一个既能飞行又能做些工作的飞行物体；因此它可以表达如下：'
- en: '[PRE85]'
  id: totrans-342
  prefs: []
  type: TYPE_PRE
  zh: '[PRE85]'
- en: 'Listing multiple interfaces with separating commas means the class implements
    each of them. You can combine any number of interfaces, but try not to overdo
    this. Sometimes, a combination of two interfaces makes up a logical abstraction.
    If every drone can fly and does some work, then you can write that in code, as
    follows:'
  id: totrans-343
  prefs: []
  type: TYPE_NORMAL
  zh: 列出多个接口并用逗号分隔意味着该类实现了它们中的每一个。你可以组合任意数量的接口，但尽量不要过度。有时，两个接口的组合构成一个逻辑抽象。如果每个无人机都能飞行并做一些工作，你可以在代码中这样写：
- en: '[PRE86]'
  id: totrans-344
  prefs: []
  type: TYPE_PRE
  zh: '[PRE86]'
- en: 'And the `Drone` class becomes simplified to `public class Drone : IDrone`.'
  id: totrans-345
  prefs: []
  type: TYPE_NORMAL
  zh: '`Drone` 类简化为 `public class Drone : IDrone`。'
- en: 'It is also possible to mix interfaces with a base class (but no more than one
    base class). If you want to represent an ant that flies, you can write the following
    code:'
  id: totrans-346
  prefs: []
  type: TYPE_NORMAL
  zh: 还可以将接口与基类（但不超过一个基类）混合。如果你想表示一个会飞的蚂蚁，你可以编写以下代码：
- en: '[PRE87]'
  id: totrans-347
  prefs: []
  type: TYPE_PRE
  zh: '[PRE87]'
- en: An interface is undoubtedly the best abstraction because depending on it does
    not force you to depend on any implementation details. All that is required is
    the logical concepts that have been defined. Implementation is prone to change,
    but the logic behind relations between classes is not.
  id: totrans-348
  prefs: []
  type: TYPE_NORMAL
  zh: 显然，接口是最好的抽象方式，因为它不强迫你依赖任何实现细节。所需的一切只是已经定义的逻辑概念。实现可能会变化，但类之间关系背后的逻辑不会。
- en: 'If an interface defines what a class can do, is it also possible to define
    a contract for common data? Absolutely. An interface holds behavior, hence it
    can hold properties as well because they define setter and getter behavior. For
    example, you should be able to track the drone, and for this, it should be identifiable,
    that is, it needs to have an ID. This can be coded as follows:'
  id: totrans-349
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个接口定义了一个类可以做什么，那么是否也可以定义一个公共数据的契约？绝对可以。接口持有行为，因此它也可以持有属性，因为它们定义了设置器和获取器行为。例如，你应该能够跟踪无人机，为此，它应该是可识别的，也就是说，它需要一个
    ID。这可以编码如下：
- en: '[PRE88]'
  id: totrans-350
  prefs: []
  type: TYPE_PRE
  zh: '[PRE88]'
- en: 'In modern software development, there are several complex low-level details
    that programmers use on a daily basis. However, they often do so without knowing.
    If you want to create a maintainable code base with lots of logic and easy-to-grasp
    code, you should follow these principles of abstraction:'
  id: totrans-351
  prefs: []
  type: TYPE_NORMAL
  zh: 在现代软件开发中，程序员每天都会使用一些复杂的底层细节。然而，他们通常并不知道这一点。如果你想创建一个具有大量逻辑和易于理解的代码的可维护代码库，你应该遵循以下抽象原则：
- en: Keep it simple and small.
  id: totrans-352
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 保持简单和小巧。
- en: Do not depend on details.
  id: totrans-353
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 不要依赖于细节。
- en: Hide complexity.
  id: totrans-354
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 隐藏复杂性。
- en: Expose only what is necessary.
  id: totrans-355
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 只暴露必要的部分。
- en: With this exercise, you will grasp how OOP functions.
  id: totrans-356
  prefs: []
  type: TYPE_NORMAL
  zh: 通过这个练习，你将掌握面向对象编程的工作原理。
- en: 'Exercise 2.03: Covering Floor in the Backyard'
  id: totrans-357
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习 2.03：后院铺地板
- en: A builder is building a mosaic with which he needs to cover an area of x square
    meters. You have some leftover tiles that are either rectangular or circular.
    In this exercise, you need to find out whether, if you shatter the tiles to perfectly
    fill the area they take up, can the tiles fill the mosaic completely.
  id: totrans-358
  prefs: []
  type: TYPE_NORMAL
  zh: 一个建造者正在用马赛克覆盖 x 平方米的面积。你有一些剩余的瓷砖，它们要么是矩形的，要么是圆形的。在这个练习中，你需要找出，如果你将瓷砖打碎以完美填充它们占据的面积，这些瓷砖是否可以完全填满马赛克。
- en: 'You will write a program that prints `true`, if the mosaic can be covered with
    tiles, or `false`, if it cannot. Perform the following steps to do so:'
  id: totrans-359
  prefs: []
  type: TYPE_NORMAL
  zh: 你将编写一个程序，如果马赛克可以用瓷砖覆盖，则打印 `true`，如果不能，则打印 `false`。执行以下步骤：
- en: 'Create an interface named `IShape`, with an `Area` property:'
  id: totrans-360
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `IShape` 的接口，具有 `Area` 属性：
- en: '[PRE89]'
  id: totrans-361
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE89]'
- en: This is a get-only property. Note that a property is a method, so it is okay
    to have it in an interface.
  id: totrans-362
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个只读属性。请注意，属性是一个方法，所以它可以在接口中存在。
- en: 'Create a class called `Rectangle`, with width and height and a method for calculating
    area, called `Area`. Implement an `IShape` interface for this, as shown in the
    following code:'
  id: totrans-363
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Rectangle` 的类，具有宽度和高度，以及一个名为 `Area` 的计算面积的方法。为此实现一个 `IShape` 接口，如下所示代码：
- en: '[PRE90]'
  id: totrans-364
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE90]'
- en: '[PRE91]'
  id: totrans-365
  prefs: []
  type: TYPE_PRE
  zh: '[PRE91]'
- en: The only thing required is to calculate the area. Hence, only the `Area` property
    is `public`. Your interface needs to implement a getter `Area` property, achieved
    by multiplying `width` and `height`.
  id: totrans-366
  prefs: []
  type: TYPE_NORMAL
  zh: 唯一需要的是计算面积。因此，只有 `Area` 属性是 `public` 的。你的接口需要实现一个获取 `Area` 属性的 getter，通过乘以 `width`
    和 `height` 来实现。
- en: 'Create a `Circle` class with a `radius` and `Area` calculation, which also
    implements the `IShape` interface:'
  id: totrans-367
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有 `radius` 和 `Area` 计算功能的 `Circle` 类，它还实现了 `IShape` 接口：
- en: '[PRE92]'
  id: totrans-368
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE92]'
- en: 'Create a skeleton `Solution` class with a method named `IsEnough`, as follows:'
  id: totrans-369
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Solution` 的骨架类，其中包含一个名为 `IsEnough` 的方法，如下所示：
- en: '[PRE93]'
  id: totrans-370
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE93]'
- en: Both the class and the method are just placeholders for the implementation to
    come. The class is `static` because it will be used as a demo and it does not
    need to have a state. The `IsEnough` method takes the needed `mosaicArea`, an
    array of tiles objects, and returns whether the total area occupied by the tiles
    is enough to cover the mosaic.
  id: totrans-371
  prefs: []
  type: TYPE_NORMAL
  zh: 类和方法只是将来实现的占位符。这个类是 `static` 的，因为它将用作示例，并且不需要有状态。`IsEnough` 方法接受所需的 `mosaicArea`，一个瓷砖对象的数组，并返回瓷砖占据的总面积是否足够覆盖马赛克。
- en: 'Inside the `IsEnough` method, use a `for` loop to calculate the `totalArea`.
    Then, return whether the total area covers the mosaic area:'
  id: totrans-372
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `IsEnough` 方法内部，使用 `for` 循环来计算 `totalArea`。然后，返回总面积是否覆盖了马赛克面积：
- en: '[PRE94]'
  id: totrans-373
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE94]'
- en: 'Inside the `Solution` class, create a demo. Add several sets of different shapes,
    as follows:'
  id: totrans-374
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `Solution` 类内部创建一个示例。添加几组不同形状的集合，如下所示：
- en: '[PRE95]'
  id: totrans-375
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE95]'
- en: Here, you use four examples. When the area to cover is `0`, then no matter what
    shapes you pass, it will be enough. When the area to cover is `1`, a rectangle
    of area `1x1` will be just enough. When it's `100`, a circle of radius `5` is
    not enough. Finally, for the fourth example, the area occupied by three shapes
    is added up, that is, a rectangle of area `1x1`, a circle of radius `1`, and the
    second rectangle of area `1.4x1`. The total area is `5`, which is less than the
    combined area of these three shapes.
  id: totrans-376
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用了四个示例。当要覆盖的区域为`0`时，无论你传递什么形状，都足够了。当要覆盖的区域为`1`时，一个面积为`1x1`的矩形就足够了。当它是`100`时，半径为`5`的圆是不够的。最后，对于第四个示例，三个形状占据的总面积被加起来，即一个面积为`1x1`的矩形，一个半径为`1`的圆，以及第二个面积为`1.4x1`的矩形。总面积是`5`，这小于这三个形状的总面积。
- en: 'Run the demo. You should see the following output on your screen:'
  id: totrans-377
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行演示。你应该在屏幕上看到以下输出：
- en: '[PRE96]'
  id: totrans-378
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE96]'
- en: Note
  id: totrans-379
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/EODE6](https://packt.link/EODE6).
  id: totrans-380
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/EODE6](https://packt.link/EODE6)找到用于此练习的代码。
- en: This exercise is very similar to *Exercise 2.02*. However, even though the assignment
    is more complex, there is less code than in the previous assignment. By using
    the OOP pillars, you were able to create a simple solution for a complex problem.
    You were able to create functions that depend on abstraction, rather than making
    overloads for different types. Thus, OOP is a powerful tool, and this only scratches
    the surface.
  id: totrans-381
  prefs: []
  type: TYPE_NORMAL
  zh: 这个练习与*练习2.02*非常相似。然而，尽管任务更复杂，但代码比之前的任务要少。通过使用面向对象编程的支柱，你能够为复杂问题创建一个简单的解决方案。你能够创建依赖于抽象的函数，而不是为不同类型创建重载。因此，面向对象编程是一个强大的工具，而这只是触及了表面。
- en: Everyone can write code that works but writing code that lives for decades and
    is easy to grasp is hard. So, it is imperative to know about the set of best practices
    in OOP.
  id: totrans-382
  prefs: []
  type: TYPE_NORMAL
  zh: 每个人都能写出能工作的代码，但写出能持续数十年且易于理解的代码是困难的。因此，了解面向对象编程（OOP）的最佳实践集合是至关重要的。
- en: SOLID Principles in OOP
  id: totrans-383
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: OOP中的SOLID原则
- en: SOLID principles are a set of best practices for OOP. SOLID is an acronym for
    five principles, namely, single responsibility, open-closed, Liskov substitution,
    interface segregation, and dependency inversion. You will not explore each of
    these in detail.
  id: totrans-384
  prefs: []
  type: TYPE_NORMAL
  zh: SOLID原则是一组面向对象编程的最佳实践。SOLID是五个原则的缩写，分别是单一职责、开闭原则、里氏替换原则、接口隔离原则和依赖倒置原则。你将不会详细探讨这些原则中的每一个。
- en: Single Responsibility Principle
  id: totrans-385
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 单一职责原则
- en: Functions, classes, projects, and entire systems change over time. Every change
    is potentially a breaking one, so you should limit the risk of too many things
    changing at a time. In other words, a part of a code block should have only a
    single reason to change.
  id: totrans-386
  prefs: []
  type: TYPE_NORMAL
  zh: 函数、类、项目和整个系统都会随时间而变化。每一次变化都有可能引起破坏，因此你应该限制同时改变太多事物的风险。换句话说，代码块的一部分应该只有一个改变的理由。
- en: For a function, this means that it should do just one thing and have no side
    effects. In practice, this means that a function should either change, or get
    something, but never do both. This also means that functions responsible for high-level
    things should not be mixed with functions that perform low-level things. Low-level
    is all about implementing interactions with hardware, and working with primitives.
    High-level is focused on compositions of software building blocks or services.
    When talking about high- and low-level functions, it is usually referred to as
    a chain of dependencies. If function A calls function B, A is considered higher-level
    than B. A function should not implement multiple things; it should instead call
    other functions that implement doing one thing. The general guideline for this
    is that if you think you can split your code into different functions, then in
    most cases, you should do that.
  id: totrans-387
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个函数来说，这意味着它应该只做一件事，并且没有副作用。在实践中，这意味着一个函数要么改变，要么获取某些东西，但不能两者兼而有之。这也意味着负责高级事物的函数不应与执行低级事物的函数混合。低级主要涉及与硬件的交互和与原语一起工作。高级则专注于软件构建块或服务的组合。当谈论高级和低级函数时，通常指的是依赖链。如果函数A调用函数B，那么A被认为是比B更高级的。一个函数不应实现多个事物；相反，它应该调用其他实现单一事物的函数。这个一般性指南是，如果你认为可以将你的代码拆分成不同的函数，那么在大多数情况下，你应该这么做。
- en: 'For classes, it means that you should keep them small and isolated from one
    another. An example of an efficient class is the `File` class, which can read
    and write. If it implemented both reading and writing, it would change for two
    reasons (reading and writing):'
  id: totrans-388
  prefs: []
  type: TYPE_NORMAL
  zh: 对于类，这意味着你应该保持它们小巧且相互独立。一个高效的类示例是 `File` 类，它可以读取和写入。如果它实现了读取和写入，它会有两个原因（读取和写入）发生变化：
- en: '[PRE97]'
  id: totrans-389
  prefs: []
  type: TYPE_PRE
  zh: '[PRE97]'
- en: 'Therefore, to conform to this principle, you can split the reading code into
    a class called `Reader` and writing code into a class called `Writer`, as follows:'
  id: totrans-390
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，为了符合这个原则，你可以将读取代码拆分到一个名为 `Reader` 的类中，将写入代码拆分到一个名为 `Writer` 的类中，如下所示：
- en: '[PRE98]'
  id: totrans-391
  prefs: []
  type: TYPE_PRE
  zh: '[PRE98]'
- en: 'Now, instead of implementing reading and writing by itself, the `File` class
    will simply be composed of a reader and writer:'
  id: totrans-392
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，`File` 类将不再单独实现读取和写入功能，而是简单地由一个读取器和写入器组成：
- en: '[PRE99]'
  id: totrans-393
  prefs: []
  type: TYPE_PRE
  zh: '[PRE99]'
- en: Note
  id: totrans-394
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/PBppV](https://packt.link/PBppV).
  id: totrans-395
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/PBppV](https://packt.link/PBppV)找到用于此示例的代码。
- en: It might be confusing because what the class does essentially remains the same.
    However, now, it just consumes a component and is not responsible for implementing
    it. A high-level class (`File`) simply adds context to how lower-level classes
    (`Reader`, `Writer`) will be consumed.
  id: totrans-396
  prefs: []
  type: TYPE_NORMAL
  zh: 这可能有些令人困惑，因为类所执行的基本操作本质上保持不变。然而，现在，它只是消费一个组件，而不负责实现它。一个高级类（`File`）只是为如何使用低级类（`Reader`，`Writer`）添加上下文。
- en: For a module (library), it means that you should strive to not introduce dependencies,
    which would be more than what the consumer would want. For example, if you are
    using a library for logging, it should not come with some third-party logging
    provider-specific implementation.
  id: totrans-397
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个模块（库），这意味着你应该努力不引入消费者不需要的依赖。例如，如果你正在使用日志记录库，它不应该附带一些第三方日志提供者特定的实现。
- en: For a subsystem, it means that different systems should be as isolated as possible.
    If two (lower level) systems need to communicate, they could call one another
    directly. A consideration (not mandatory) would be to have a third system (higher-level)
    for coordination. Systems should also be separated through a boundary (such as
    a contract specifying communication parameters), which hides all the details.
    If a subsystem is a big library collection, it should have an interface to expose
    what it can do. If a subsystem is a web service, it should be a collection of
    endpoints. In any case, a contract of a subsystem should provide only the methods
    that the client may want.
  id: totrans-398
  prefs: []
  type: TYPE_NORMAL
  zh: 对于一个子系统，这意味着不同的系统应该尽可能独立。如果两个（低级）系统需要通信，它们可以直接调用对方。一个考虑因素（不是强制性的）是有一个第三系统（高级）进行协调。系统还应该通过边界（例如，指定通信参数的合同）进行分离，隐藏所有细节。如果一个子系统是一个大的库集合，它应该有一个接口来公开它所能做的事情。如果一个子系统是一个网络服务，它应该是一组端点。在任何情况下，子系统的合同应该只提供客户端可能需要的那些方法。
- en: 'Sometimes, the principle is overdone and classes are split so much that making
    a change requires changing multiple places. It does keep true to the principle,
    as a class will have a single reason to change, but in such a case, multiple classes
    will change for the same reason. For example, suppose you have two classes: `Merchandise`
    and `TaxCalculator`. The `Merchandise` class has fields for `Name`, `Price`, and
    `Vat`:'
  id: totrans-399
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，原则被过度执行，类被分割得太多，以至于需要更改多个地方。这确实符合原则，即一个类将有一个单一的理由进行更改，但在这种情况下，多个类将因为相同的原因而更改。例如，假设你有两个类：`Merchandise`
    和 `TaxCalculator`。`Merchandise` 类有 `Name`、`Price` 和 `Vat` 字段：
- en: '[PRE100]'
  id: totrans-400
  prefs: []
  type: TYPE_PRE
  zh: '[PRE100]'
- en: 'Next, you will create the `TaxCalculator` class. `vat` is measured as a percentage,
    so the actual price to pay will be `vat` added to the original price:'
  id: totrans-401
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建 `TaxCalculator` 类。`vat` 以百分比的形式衡量，因此实际支付的金额将是 `vat` 加上原始价格：
- en: '[PRE101]'
  id: totrans-402
  prefs: []
  type: TYPE_PRE
  zh: '[PRE101]'
- en: 'What would change if the functionality of calculating the price moved to the
    `Merchandise` class? You would still be able to perform the required operation.
    There are two key points here:'
  id: totrans-403
  prefs: []
  type: TYPE_NORMAL
  zh: 如果将计算价格的功能移动到 `Merchandise` 类，会发生什么变化？你仍然可以执行所需的操作。这里有两个关键点：
- en: The operation by itself is simple.
  id: totrans-404
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 单独的操作很简单。
- en: Also, everything that the tax calculator needs come from the `Merchandise` class.
  id: totrans-405
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 此外，税务计算器所需的一切都来自 `Merchandise` 类。
- en: 'If a class can implement the logic by itself, as long as it is self-contained
    (does not involve extra components), it usually should. Therefore, a proper version
    of the code would be as follows:'
  id: totrans-406
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个类可以自己实现逻辑，只要它是自包含的（不涉及额外组件），通常应该这样做。因此，一个合适的代码版本如下：
- en: '[PRE102]'
  id: totrans-407
  prefs: []
  type: TYPE_PRE
  zh: '[PRE102]'
- en: This code moves the `NetPrice` calculation to the `Merchandise` class and the
    `TaxCalculator` class has been removed.
  id: totrans-408
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将`NetPrice`计算移动到`Merchandise`类，并且已经删除了`TaxCalculator`类。
- en: Note
  id: totrans-409
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'Singe Responsibility Principle (SRP) can be summarized in a couple of words:
    **split it**. You can find the code used for this example at [https://packt.link/lWxNO](https://packt.link/lWxNO).'
  id: totrans-410
  prefs: []
  type: TYPE_NORMAL
  zh: 单一职责原则（SRP）可以用几个词来概括：**拆分它**。你可以在这个例子中找到使用的代码[https://packt.link/lWxNO](https://packt.link/lWxNO)。
- en: Open-Closed Principle
  id: totrans-411
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 开放封闭原则
- en: As mentioned previously, every change in code is potentially a breaking one.
    As a way around this, instead of changing existing code, it is often preferable
    to write new code. Every software entity should have an extension point, through
    which the changes should be introduced. However, after this change is done, a
    software entity should not be interfered with. The Open-Closed Principle (OCP)
    is hard to implement and takes a lot of practice, but the benefits (a minimum
    number of breaking changes) are well worth it.
  id: totrans-412
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，代码的每一次更改都可能是破坏性的。为了解决这个问题，通常更倾向于编写新的代码，而不是更改现有的代码。每个软件实体都应该有一个扩展点，通过这个扩展点引入更改。然而，在完成这个更改后，不应该干扰软件实体。开放封闭原则（OCP）难以实现且需要大量的实践，但其好处（最小化破坏性更改的数量）是非常值得的。
- en: If a multiple-step algorithm does not change, but its individual steps can change,
    you should split it into several functions. A change for an individual step will
    no longer affect the entire algorithm, but rather just that step. Such minimization
    of reasons for a single class or a function to change is what OCP is all about.
  id: totrans-413
  prefs: []
  type: TYPE_NORMAL
  zh: 如果一个多步骤算法本身没有变化，但其各个步骤可以变化，你应该将其拆分为几个函数。单个步骤的更改将不再影响整个算法，而只会影响那个步骤。这种最小化单个类或函数更改原因的做法正是OCP的核心。
- en: Note
  id: totrans-414
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on OCP at [https://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx](https://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx).
  id: totrans-415
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx](https://social.technet.microsoft.com/wiki/contents/articles/18062.open-closed-principle-ocp.aspx)找到有关OCP的更多信息。
- en: Another example where you may want to implement this principle is a function
    working with combinations of specific values in code. This is called hardcoding
    and is generally deemed an inefficient practice. To make it work with new values,
    you might be tempted to create a new function, but by simply removing a hardcoded
    part and exposing it through function parameters, you can make it extensible.
    However, when you have variables that are known to be fixed and not changing,
    it is fine to hardcode them, but they should be flagged as constant.
  id: totrans-416
  prefs: []
  type: TYPE_NORMAL
  zh: 你可能想要实施这个原则的另一个例子是，一个与代码中特定值组合工作的函数。这被称为硬编码，通常被认为是一种低效的做法。为了使其能够与新的值一起工作，你可能想创建一个新的函数，但通过简单地移除硬编码的部分并通过函数参数公开它，你可以使其可扩展。然而，当你有已知是固定且不会改变变量的情况，可以硬编码它们，但应该将它们标记为常量。
- en: 'Previously, you created a file class with two dependencies—`Reader` and `Writer`.
    Those dependencies are hardcoded, and leave you with no extension points. Fixing
    that will involve two things. First, add the virtual modifier for both the `Reader`
    and `Writer` class methods:'
  id: totrans-417
  prefs: []
  type: TYPE_NORMAL
  zh: 之前，你创建了一个具有两个依赖项（`Reader`和`Writer`）的文件类。这些依赖项是硬编码的，没有提供扩展点。解决这个问题将涉及两个方面。首先，为`Reader`和`Writer`类方法添加虚拟修饰符：
- en: '[PRE103]'
  id: totrans-418
  prefs: []
  type: TYPE_PRE
  zh: '[PRE103]'
- en: 'Then, change the constructor of the `File` class so that it accepts instances
    of `Reader` and `Writer`, instead of hardcoding the dependencies:'
  id: totrans-419
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，更改`File`类的构造函数，使其接受`Reader`和`Writer`的实例，而不是硬编码依赖项：
- en: '[PRE104]'
  id: totrans-420
  prefs: []
  type: TYPE_PRE
  zh: '[PRE104]'
- en: This code enables you to override the existing reader and writer behavior and
    replace it with whatever behavior you want, that is, the `File` class extension
    point.
  id: totrans-421
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码使你能够覆盖现有的读取器和写入器行为，并用你想要的任何行为替换它，即`File`类的扩展点。
- en: OCP can be summarized in a few words as **don't change it, extend it**.
  id: totrans-422
  prefs: []
  type: TYPE_NORMAL
  zh: OCP可以用几个词来概括为**不要改变它，扩展它**。
- en: Liskov Substitution
  id: totrans-423
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 李斯克代换
- en: 'The Liskov Substitution Principle (LSP) is one of the most straightforward
    principles out there. It simply means that a child class should support all the
    public behavior of a parent class. If you have two classes, `Car` and `CarWreck`,
    where one inherits the other, then you have violated the principle:'
  id: totrans-424
  prefs: []
  type: TYPE_NORMAL
  zh: 李斯克代换原则（LSP）是最直接的原则之一。它简单意味着子类应该支持父类的所有公共行为。如果你有两个类，`Car`和`CarWreck`，其中一个继承自另一个，那么你就违反了这个原则：
- en: '[PRE105]'
  id: totrans-425
  prefs: []
  type: TYPE_PRE
  zh: '[PRE105]'
- en: Note
  id: totrans-426
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/6nD76](https://packt.link/6nD76).
  id: totrans-427
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/6nD76](https://packt.link/6nD76) 找到用于此示例的代码。
- en: Both `Car` and `CarWreck` have a `Body` object. `Car` can move, but what about
    `CarWreck`? It can only stay in one place. The `Move` method is virtual because
    `CarWreck` intends to override it to mark it as not supported. If a child can
    no longer support what a parent can do, then it should no longer inherit that
    parent. In this case, a car wreck is not a car, it's simply a wreck.
  id: totrans-428
  prefs: []
  type: TYPE_NORMAL
  zh: '`Car` 和 `CarWreck` 都有一个 `Body` 对象。`Car` 可以移动，但 `CarWreck` 呢？它只能待在一个地方。`Move`
    方法是虚拟的，因为 `CarWreck` 想要覆盖它以标记为不支持。如果一个子类不再支持父类可以做的事情，那么它就不应该再继承那个父类。在这种情况下，车祸不是一辆车，它只是一个废墟。'
- en: 'How do you conform to this principle? All you have to do is to remove the inheritance
    relationship and replicate the necessary behavior and structure. In this case,
    `CarWreck` still has a `Body` object, but the `Move` method is unnecessary:'
  id: totrans-429
  prefs: []
  type: TYPE_NORMAL
  zh: 你如何遵循这个原则？你只需要移除继承关系并复制必要的功能和结构。在这种情况下，`CarWreck` 仍然有一个 `Body` 对象，但 `Move` 方法是不必要的：
- en: '[PRE106]'
  id: totrans-430
  prefs: []
  type: TYPE_PRE
  zh: '[PRE106]'
- en: Code changes happen quite often, and you can sometimes inadvertently use the
    wrong method to achieve your goals. Sometimes, you couple code in such a way that
    what you thought was flexible code turns out to be a complex mess. Do not use
    inheritance as a way of doing code reuse. Keep things small and compose them (again)
    instead of trying to override the existing behavior. Before things can be reusable,
    they should be usable. Design for simplicity and you will get flexibility for free.
  id: totrans-431
  prefs: []
  type: TYPE_NORMAL
  zh: 代码更改很常见，有时你可能会无意中使用错误的方法来实现你的目标。有时，你以某种方式耦合代码，结果你原本认为灵活的代码变成了一个复杂的混乱。不要用继承作为代码重用的方式。保持事物小巧，并重新组合它们（再次）而不是尝试覆盖现有行为。在事物可以重用之前，它们应该是可用的。设计简单，你将免费获得灵活性。
- en: 'LSP can be summarized in a few words: **don''t fake it**.'
  id: totrans-432
  prefs: []
  type: TYPE_NORMAL
  zh: LSP 可以用几个词来概括：**不要假装**。
- en: Note
  id: totrans-433
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find more information on LSP at [https://www.microsoftpressstore.com/articles/article.aspx?p=2255313](https://www.microsoftpressstore.com/articles/article.aspx?p=2255313).
  id: totrans-434
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://www.microsoftpressstore.com/articles/article.aspx?p=2255313](https://www.microsoftpressstore.com/articles/article.aspx?p=2255313)
    找到更多关于 LSP 的信息。
- en: Interface Segregation
  id: totrans-435
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 接口隔离
- en: The interface segregation principle is a special case of the OCP but is only
    applicable to contracts that will be exposed publicly. Remember, every change
    you make is potentially a breaking change, and this especially matters in making
    changes to a contract. Breaking changes are inefficient because they will often
    require effort to adapt to the change from multiple people.
  id: totrans-436
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离原则是 OCP 的一个特殊情况，但仅适用于将公开暴露的合同。记住，你做的每一个改变都可能是一个破坏性改变，这在修改合同时尤其重要。破坏性改变效率低下，因为它们通常需要多个人努力适应这些变化。
- en: 'For example, say you have an interface, `IMovableDamageable`:'
  id: totrans-437
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，假设你有一个接口，`IMovableDamageable`：
- en: '[PRE107]'
  id: totrans-438
  prefs: []
  type: TYPE_PRE
  zh: '[PRE107]'
- en: 'A single interface should represent a single concept. However, in this case,
    it does two things: move and manage `Hp` (hit points). By itself, an interface
    with two methods is not problematic. However, in scenarios of the implementation
    needing only a part of an interface, you are forced to create a workaround.'
  id: totrans-439
  prefs: []
  type: TYPE_NORMAL
  zh: 一个接口应该代表一个单一的概念。然而，在这种情况下，它做了两件事：移动和管理 `Hp`（生命值）。一个接口有两个方法本身并不是问题。然而，在实现只需要接口的一部分的场景中，你被迫创建一个解决方案。
- en: 'For example, score text is indestructible, but you would like it to be animated
    and to move it across a scene:'
  id: totrans-440
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，得分文本是不可摧毁的，但你希望它能够动画化，并在场景中移动：
- en: '[PRE108]'
  id: totrans-441
  prefs: []
  type: TYPE_PRE
  zh: '[PRE108]'
- en: Note
  id: totrans-442
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The point here isn't to print the location; just to give an example of where
    it is used. It's up to location's implementation whether it will be printed or
    not as such.
  id: totrans-443
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的重点不是打印位置；只是提供一个使用示例。是否打印取决于位置实现的意愿。
- en: 'Taking another example, you might have a house that does not move but can be destroyed:'
  id: totrans-444
  prefs: []
  type: TYPE_NORMAL
  zh: 再举一个例子，你可能有一个不移动但可以被摧毁的房子：
- en: '[PRE109]'
  id: totrans-445
  prefs: []
  type: TYPE_PRE
  zh: '[PRE109]'
- en: 'In both scenarios, you worked around the issue by throwing `NotSupportedException`.
    However, another programmer should not be given an option to call code that never
    works in the first place. In order to fix the problem of representing too many
    concepts, you should split the `IMoveableDamageable` interface into `IMoveable`
    and `IDamageable`:'
  id: totrans-446
  prefs: []
  type: TYPE_NORMAL
  zh: 在这两种情况下，你通过抛出 `NotSupportedException` 来绕过这个问题。然而，另一个程序员不应该有调用从开始就永远不会工作的代码的选择。为了解决表示太多概念的问题，你应该将
    `IMoveableDamageable` 接口拆分为 `IMoveable` 和 `IDamageable`：
- en: '[PRE110]'
  id: totrans-447
  prefs: []
  type: TYPE_PRE
  zh: '[PRE110]'
- en: 'And the implementations can now get rid of the unnecessary parts:'
  id: totrans-448
  prefs: []
  type: TYPE_NORMAL
  zh: 现在实现可以去掉不必要的部分：
- en: '[PRE111]'
  id: totrans-449
  prefs: []
  type: TYPE_PRE
  zh: '[PRE111]'
- en: The `Console.WriteLine`, in the preceding code, would display the namespace
    name with the class name.
  id: totrans-450
  prefs: []
  type: TYPE_NORMAL
  zh: 在前面的代码中，`Console.WriteLine` 会显示命名空间名称和类名。
- en: Note
  id: totrans-451
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Interface segregation can be summarized as **don't enforce it**. You can find
    the code used for this example at [https://packt.link/32mwP](https://packt.link/32mwP).
  id: totrans-452
  prefs: []
  type: TYPE_NORMAL
  zh: 接口隔离可以总结为**不要强制执行**。你可以在这个例子中找到用于此示例的代码：[https://packt.link/32mwP](https://packt.link/32mwP)。
- en: Dependency Inversion
  id: totrans-453
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 依赖反转
- en: Large software systems can consist of millions of classes. Each class is a small
    dependency, and if unmanaged, the complexity might stack into something impossible
    to maintain. If one low-level component breaks, it causes a ripple effect, breaking
    the whole chain of dependencies. The dependency inversion principle states that
    you should avoid hard dependence on underlying classes.
  id: totrans-454
  prefs: []
  type: TYPE_NORMAL
  zh: 大型软件系统可能包含数百万个类。每个类都是一个小的依赖项，如果未管理好，复杂性可能会累积成难以维护的状态。如果一个低级组件损坏，它会导致连锁反应，破坏整个依赖链。依赖反转原则指出，你应该避免对底层类有硬依赖。
- en: Dependency injection is the industry-standard way of implementing dependency
    inversion. Do not mix the two; one is a principle and the other refers to the
    implementation of this principle.
  id: totrans-455
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是实现依赖反转的行业标准方式。不要混淆这两个概念；一个是原则，另一个是这个原则的实现。
- en: Note that you can also implement dependency inversion without dependency injection.
    For example, when declaring a field, instead of writing something like `private
    readonly List<int> _numbers = new List<int>();`, it is preferable to write `private
    readonly IList<int> = _numbers`, which shifts dependency to abstraction (`IList`)
    and not implementation (`List`).
  id: totrans-456
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，你也可以在不使用依赖注入的情况下实现依赖反转。例如，在声明字段时，而不是写 `private readonly List<int> _numbers
    = new List<int>();`，最好是写 `private readonly IList<int> _numbers`，这样就将依赖转移到了抽象（`IList`）而不是实现（`List`）。
- en: 'What is dependency injection? It is the act of passing an implementation and
    setting it to an abstraction slot. There are three ways to implement this:'
  id: totrans-457
  prefs: []
  type: TYPE_NORMAL
  zh: 什么是依赖注入？它是传递一个实现并将其设置到抽象槽位的行为。有三种方法来实现这一点：
- en: Constructor injection is achieved by exposing an abstraction through the constructor
    argument and passing an implementation when creating an object and then assigning
    it to a field. Use it when you want to consistently use the same dependency in
    the same object (but not necessarily the same class).
  id: totrans-458
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 构造函数注入是通过在构造函数参数中暴露抽象并通过创建对象时传递实现来完成的，然后将它分配给一个字段。当你想在同一个对象中（但不一定是同一个类中）一致地使用相同的依赖项时使用它。
- en: Method injection is done by exposing an abstraction through a method argument,
    and then passing an implementation when calling that method. Use it when, for
    a single method, a dependency might vary, and you do not plan to store the dependency
    throughout that object's lifetime.
  id: totrans-459
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 方法注入是通过通过方法参数暴露抽象，然后在调用该方法时传递实现来实现的。当对于单个方法，依赖项可能会变化，并且你不想在整个对象的生命周期中存储依赖项时使用它。
- en: Property injection is implemented by exposing an abstraction through a public
    property, and then assigning (or not) that property to some exact implementation.
    Property injection is a rare way of injecting dependencies because it suggests
    that dependency might even be null or temporary and there are many ways in which
    it could break.
  id: totrans-460
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 属性注入是通过通过公共属性暴露抽象，然后分配（或不分配）该属性到某个具体实现来实现的。属性注入是注入依赖项的一种罕见方式，因为它暗示依赖项甚至可能是 null
    或临时的，并且有多种方式可能导致其失败。
- en: 'Given two types, `interface IBartender { }` and `class Bar : Bartender { }`,
    you can illustrate the three ways of dependency injection for a class called `Bar`.'
  id: totrans-461
  prefs: []
  type: TYPE_NORMAL
  zh: '给定两个类型，`interface IBartender { }` 和 `class Bar : Bartender { }`，你可以展示名为 `Bar`
    的类的三种依赖注入方式。'
- en: 'First, prepare the `Bar` class for constructor injection:'
  id: totrans-462
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，为构造函数注入准备 `Bar` 类：
- en: '[PRE112]'
  id: totrans-463
  prefs: []
  type: TYPE_PRE
  zh: '[PRE112]'
- en: 'The constructor injection is done as follows:'
  id: totrans-464
  prefs: []
  type: TYPE_NORMAL
  zh: 构造函数注入如下所示：
- en: '[PRE113]'
  id: totrans-465
  prefs: []
  type: TYPE_PRE
  zh: '[PRE113]'
- en: This kind of dependency injection is a dominating kind of inheritance, as it
    enforces stability through immutability. For example, some bars have just one
    bartender.
  id: totrans-466
  prefs: []
  type: TYPE_NORMAL
  zh: 这种依赖注入是一种占主导地位的继承方式，因为它通过不可变性来强制稳定性。例如，一些酒吧只有一位调酒师。
- en: 'Method injection would look like this:'
  id: totrans-467
  prefs: []
  type: TYPE_NORMAL
  zh: 方法注入看起来是这样的：
- en: '[PRE114]'
  id: totrans-468
  prefs: []
  type: TYPE_PRE
  zh: '[PRE114]'
- en: 'The injection itself is as follows:'
  id: totrans-469
  prefs: []
  type: TYPE_NORMAL
  zh: 注入本身如下：
- en: '[PRE115]'
  id: totrans-470
  prefs: []
  type: TYPE_PRE
  zh: '[PRE115]'
- en: Often, this kind of dependency injection is called interface injection because
    the method often goes under an interface. The interface itself is a great idea,
    but that does not change the idea behind this kind of dependency injection. Use
    method injection when you immediately consume a dependency that you set, or when
    you have a complex way of setting new dependencies dynamically. For example, it
    makes sense to use different bartenders for serving drinks.
  id: totrans-471
  prefs: []
  type: TYPE_NORMAL
  zh: 通常，这种依赖注入被称为接口注入，因为方法通常在接口下进行。接口本身是一个很好的想法，但这并没有改变这种依赖注入背后的理念。当你立即消耗你设置的依赖项，或者当你有复杂的方式动态设置新的依赖项时，使用方法注入。例如，使用不同的调酒师来服务饮品是有意义的。
- en: 'Finally, property injection can be done like this:'
  id: totrans-472
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，属性注入可以这样做：
- en: '[PRE116]'
  id: totrans-473
  prefs: []
  type: TYPE_PRE
  zh: '[PRE116]'
- en: 'Bartender is now injected like this:'
  id: totrans-474
  prefs: []
  type: TYPE_NORMAL
  zh: 调酒师现在是这样注入的：
- en: '[PRE117]'
  id: totrans-475
  prefs: []
  type: TYPE_PRE
  zh: '[PRE117]'
- en: For example, a bar might have bartenders changing shifts, but one bartender
    at a time.
  id: totrans-476
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，酒吧可能会有调酒师换班，但一次只有一个调酒师。
- en: Note
  id: totrans-477
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/JcmAT](https://packt.link/JcmAT).
  id: totrans-478
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/JcmAT](https://packt.link/JcmAT) 找到用于此示例的代码。
- en: 'Property injection in other languages might have a different name: setter injection.
    In practice, components do not change that often, so this kind of dependency injection
    is the rarest.'
  id: totrans-479
  prefs: []
  type: TYPE_NORMAL
  zh: 在其他语言中，属性注入可能有不同的名称：setter 注入。在实践中，组件并不经常改变，因此这种依赖注入是最罕见的。
- en: 'For the `File` class, this should mean that instead of exposing classes (implementation),
    you should expose abstractions (interfaces). This means that your `Reader` and
    `Writer` classes should implement some contract:'
  id: totrans-480
  prefs: []
  type: TYPE_NORMAL
  zh: 对于 `File` 类，这意味着你应该暴露抽象（接口）而不是类（实现），这意味着你的 `Reader` 和 `Writer` 类应该实现某些合同：
- en: '[PRE118]'
  id: totrans-481
  prefs: []
  type: TYPE_PRE
  zh: '[PRE118]'
- en: 'Your file class should expose reader and writer abstractions, instead of implementations,
    as follows:'
  id: totrans-482
  prefs: []
  type: TYPE_NORMAL
  zh: 你的文件类应该暴露读取器和写入器抽象，而不是实现，如下所示：
- en: '[PRE119]'
  id: totrans-483
  prefs: []
  type: TYPE_PRE
  zh: '[PRE119]'
- en: This allows for a choice of the kind of `IReader` and `IWriter` you would like
    to inject. A different reader may read a different file format, or a different
    writer may output in a different way. You have a choice.
  id: totrans-484
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你选择想要注入的 `IReader` 和 `IWriter` 类型。不同的读取器可能读取不同的文件格式，或者不同的写入器可能以不同的方式输出。你有选择权。
- en: Dependency injection is a powerful tool that is used often, especially in an
    enterprise setting. It allows you to simplify complex systems by putting an interface
    in between and having 1:1 dependencies of implementation-abstraction-implementation.
  id: totrans-485
  prefs: []
  type: TYPE_NORMAL
  zh: 依赖注入是一个常用的强大工具，特别是在企业环境中。它通过在实现和抽象之间插入一个接口，实现实现-抽象-实现的 1:1 依赖关系，从而简化了复杂系统。
- en: Writing effective code that does not break can be paradoxical. It is the same
    as buying a tool from a shop; you can't know for sure how long it will last, or
    how well it will work. Code, just like those tools, might work now but break in
    the near future, and you will only know that it does not work if and when it breaks.
  id: totrans-486
  prefs: []
  type: TYPE_NORMAL
  zh: 编写不会出错的代码可能是矛盾的。这就像从商店买工具一样；你无法确定它将持续多长时间，或者它将如何工作。代码，就像那些工具一样，现在可能工作，但不久后可能会出故障，你只有在它出故障时才会知道它不工作。
- en: Observing and waiting, seeing how the code evolves, is the only way to know
    for sure if you have written an effective code. In small, personal projects, you
    might not even notice any changes, unless you expose the project to the public
    or involve other people. To most people, SOLID principles often sound like old,
    outdated principles, like over-engineering. But they are actually a set of best
    practices that have withstood the test of time, formulated by top professionals
    seasoned in enterprise settings. It is impossible to write perfect, SOLID code
    right away. In fact, in some cases, it is not even necessary (if a project is
    small and meant to be short-lived, for example). As someone who wants to produce
    quality software and work as a professional, you should practice it as early on
    as possible.
  id: totrans-487
  prefs: []
  type: TYPE_NORMAL
  zh: 观察和等待，看代码如何演变，是确定你是否编写了有效代码的唯一方法。在小型的个人项目中，你可能甚至不会注意到任何变化，除非你将项目公之于众或涉及其他人。对大多数人来说，SOLID
    原则听起来像过时的原则，就像过度设计。但实际上，它们是一套经过时间考验的最佳实践，由在企业管理环境中经验丰富的顶级专业人士制定。一开始就编写完美的 SOLID
    代码是不可能的。事实上，在某些情况下，这甚至不是必要的（例如，如果项目很小且预期寿命短）。作为一个想要生产高质量软件并作为专业人士工作的人，你应该尽早开始练习它。
- en: How C# Helps with Object-Oriented Design
  id: totrans-488
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: C# 如何帮助面向对象设计
- en: So far, the principles you have learned are not language-specific. It is time
    to learn how to use C# for OOP. C# is a great language because it is full of some
    very useful features. It is not only one of the most productive languages to work
    with, but it also allows you to write beautiful, hard-to-break code. With a rich
    selection of keywords and languages features, you can model your classes completely
    the way you want, making the intentions crystal clear. This section will delve
    deep into C# features that help with object-oriented design.
  id: totrans-489
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，您所学的原则并非特定于任何一种语言。现在是时候学习如何使用 C# 进行面向对象编程了。C# 是一种非常好的语言，因为它包含了许多非常有用的特性。它不仅是最富有生产力的编程语言之一，而且它还允许您编写美观、难以破坏的代码。凭借丰富的关键字和语言特性，您可以完全按照自己的意愿来建模类，使意图清晰可见。本节将深入探讨有助于面向对象设计的
    C# 特性。
- en: Static
  id: totrans-490
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 静态
- en: Up till now in this book, you have interacted mostly with `static` code. This
    refers to code that does not need new classes and objects, and that can be called
    right away. In C#, the static modifier can be applied in five different scenarios—methods,
    fields, classes, constructors, and the `using` statement.
  id: totrans-491
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，在这本书中，您主要与 `static` 代码进行交互。这指的是不需要新类和对象的代码，并且可以立即调用。在 C# 中，静态修饰符可以应用于五种不同的场景——方法、字段、类、构造函数和
    `using` 语句。
- en: 'Static methods and fields are the simplest application of the `static` keyword:'
  id: totrans-492
  prefs: []
  type: TYPE_NORMAL
  zh: 静态方法和字段是 `static` 关键字的最简单应用：
- en: '[PRE120]'
  id: totrans-493
  prefs: []
  type: TYPE_PRE
  zh: '[PRE120]'
- en: Note
  id: totrans-494
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/748m3](https://packt.link/748m3).
  id: totrans-495
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以在 [https://packt.link/748m3](https://packt.link/748m3) 找到用于此示例的代码。
- en: 'Here, you created a class called `DogsGenerator`. A `static class` cannot be
    initialized manually (using the `new` keyword). Internally, it is initialized,
    but only once. Calling the `GenerateDog` method returns a new `Dog` object with
    a counter next to its name, such as `Dog1`, `Dog2`, and `Dog3`. Writing a counter
    like this allows you to increment it from everywhere as it is `public static`
    and has a setter. This can be done by directly accessing the member from a class:
    `DogsGenerator.Counter++` will increment the counter by `1`.'
  id: totrans-496
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，您创建了一个名为 `DogsGenerator` 的类。`static class` 不能手动初始化（使用 `new` 关键字）。内部初始化，但仅初始化一次。调用
    `GenerateDog` 方法将返回一个带有其名称旁边计数器的新的 `Dog` 对象，例如 `Dog1`、`Dog2` 和 `Dog3`。编写这样的计数器允许您从任何地方增加它，因为它
    `public static` 并具有设置器。这可以通过直接从类访问成员来完成：`DogsGenerator.Counter++` 将计数器增加 `1`。
- en: Once again, note that this does not require a call through an object because
    a `static class` instance is the same for the entire application. However, `DogsGenerator`
    is not the best example of a `static class`. That's because you have just created
    a global state. Many people would say that `static` is inefficient and should
    be avoided because it might create unpredictable results due to being modified
    and accessed uncontrollably.
  id: totrans-497
  prefs: []
  type: TYPE_NORMAL
  zh: 再次提醒，这不需要通过对象进行调用，因为 `static class` 实例在整个应用程序中是相同的。然而，`DogsGenerator` 并不是 `static
    class` 的最佳示例。这是因为您刚刚创建了一个全局状态。许多人会说 `static` 是低效的，应该避免使用，因为它可能会由于不可控的修改和访问而产生不可预测的结果。
- en: A public mutable state means that changes can happen from anywhere in the application.
    Other than being hard to grasp, such code is also prone to breaking in the context
    of applications with multiple threads (that is, it is not thread-safe).
  id: totrans-498
  prefs: []
  type: TYPE_NORMAL
  zh: 公开可变状态意味着更改可以在应用程序的任何地方发生。除了难以理解之外，此类代码在具有多个线程的应用程序上下文中也容易出错（即它不是线程安全的）。
- en: Note
  id: totrans-499
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: 'You will learn about threading in detail in *Chapter 5*, *Concurrency: Multithreading
    Parallel and Async Code*.'
  id: totrans-500
  prefs: []
  type: TYPE_NORMAL
  zh: 您将在第 5 章 *并发：多线程、并行和异步代码* 中详细了解线程。
- en: You can reduce the impact of a global state by making it publicly immutable.
    The benefit of doing so is that now you are in control. Instead of allowing a
    counter increment to happen from any place inside a program, you will change it
    within `DogsGenerator` only. For the `counter` property, achieving it is as simple
    as making the setter property `private`.
  id: totrans-501
  prefs: []
  type: TYPE_NORMAL
  zh: 您可以通过使全局状态公开不可变来减少其影响。这样做的好处是现在您处于控制之中。您将不再允许计数器从程序内部的任何地方增加，而是仅在 `DogsGenerator`
    中进行更改。对于 `counter` 属性，实现这一点就像将设置器属性 `private` 一样简单。
- en: There is one valuable use case for the `static` keyword though, which is with
    helper functions. Such functions take an input and return the output without modifying
    any state internally. Moreover, a class that contains such functions is `static`
    and has no state. Another good application of the `static` keyword is creating
    immutable constants. They are defined with a different keyword (`const`). The
    `PI` and `E`, static helper methods such as `Sqrt` and `Abs`, and so on.
  id: totrans-502
  prefs: []
  type: TYPE_NORMAL
  zh: 尽管如此，`static` 关键字有一个有价值的用途，那就是与辅助函数一起使用。这些函数接收输入并返回输出，而不在内部修改任何状态。此外，包含此类函数的类是
    `static` 的，并且没有状态。`static` 关键字的另一个良好应用是创建不可变常量。它们使用不同的关键字（`const`）定义。例如 `PI` 和
    `E`，静态辅助方法如 `Sqrt` 和 `Abs` 等。
- en: The `DogsGenerator` class has no members that would be applicable to an object.
    If all class members are `static`, then the class should be `static` as well.
    Therefore, you should change the class to `public static class DateGenerator`.
    Be aware, however, that depending on `static` is the same as depending on a concrete
    implementation. Although they are easy to use and straightforward, static dependencies
    are hard to escape and should only be used for simple code, or code that you are
    sure will not change and is critical in its implementation details. For that reason,
    the `Math` class is a `static class` as well; it has all the foundations for arithmetic
    calculations.
  id: totrans-503
  prefs: []
  type: TYPE_NORMAL
  zh: '`DogsGenerator` 类没有适用于对象的成员。如果所有类成员都是 `static`，则该类也应为 `static`。因此，你应该将类更改为
    `public static class DateGenerator`。然而，请注意，依赖 `static` 与依赖具体实现相同。虽然它们易于使用且直观，但静态依赖难以摆脱，并且仅应用于简单代码，或者你确信不会更改且实现细节至关重要的代码。因此，`Math`
    类也是一个 `static` 类；它拥有所有算术计算的基础。'
- en: 'The last application of `static` is `using static`. Applying the `static` keyword
    before a `using` statement causes all methods and fields to be directly accessible
    without the need to call a `class`. For example, consider the following code:'
  id: totrans-504
  prefs: []
  type: TYPE_NORMAL
  zh: '`static` 的最后一个应用是 `using static`。在 `using` 语句前使用 `static` 关键字会导致所有方法和字段直接可访问，无需调用
    `class`。例如，考虑以下代码：'
- en: '[PRE121]'
  id: totrans-505
  prefs: []
  type: TYPE_PRE
  zh: '[PRE121]'
- en: This is a static import feature in C#. By using `static Math`, all static members
    can be accessed directly.
  id: totrans-506
  prefs: []
  type: TYPE_NORMAL
  zh: 这是 C# 中的静态导入功能。通过使用 `static Math`，可以直接访问所有静态成员。
- en: Sealed
  id: totrans-507
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 密封
- en: Previously, you mentioned that inheritance should be handled with great care
    because the complexity can quickly grow out of hand. You can carefully consider
    complexity when you read and write code, but can you prevent complexity by design?
    C# has a keyword for stopping inheritance called `sealed`. If it logically makes
    no sense to inherit a class, then you should mark it with the `sealed` keyword.
    Security-related classes should also be sealed because it is critical to keep
    them simple and non-overridable. Also, if performance is critical, then methods
    in inherited classes are slower, compared to being directly in a sealed class.
    This is due to how method lookup works.
  id: totrans-508
  prefs: []
  type: TYPE_NORMAL
  zh: 此前，你提到应该非常小心地处理继承，因为复杂性可能会迅速失控。你在阅读和编写代码时可以仔细考虑复杂性，但你能否通过设计来防止复杂性？C# 有一个用于停止继承的关键字，称为
    `sealed`。如果从逻辑上讲继承一个类没有意义，那么你应该使用 `sealed` 关键字标记它。与安全相关的类也应密封，因为保持它们简单且不可覆盖至关重要。此外，如果性能至关重要，则与直接在密封类中相比，继承类中的方法会更慢。这是由于方法查找的工作方式。
- en: Partial
  id: totrans-509
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 部分
- en: In .NET, it is quite popular to make desktop applications using `WinForms`.
    The way `WinForms` works is that you can design how your application looks, with
    the help of a designer. Internally, it generates UI code and all you have to do
    is double-click a component, which will generate event handler code. That is where
    the partial class comes in. All the boring, autogenerated code will be in one
    class and the code that you write will be in another. The key point to note is
    that both classes will have the same name but be in different files.
  id: totrans-510
  prefs: []
  type: TYPE_NORMAL
  zh: 在 .NET 中，使用 `WinForms` 制作桌面应用程序相当流行。`WinForms` 的工作方式是，你可以借助设计器来设计应用程序的外观。内部，它会生成
    UI 代码，而你只需双击一个组件，它就会生成事件处理程序代码。这就是部分类的作用所在。所有无聊的自动生成代码将在一个类中，而你编写的代码将在另一个类中。需要注意的是，这两个类将具有相同的名称，但位于不同的文件中。
- en: You can have as many partial classes as you want. However, the recommended number
    of partial classes is no more than two. The compiler will treat them as one big
    class, but to the user, they will seem like two separate ones. Generating code
    generates new class files, which will overwrite the code you write. Use `partial`
    when you are dealing with autogenerated code. The biggest mistake that beginners
    make is using `partial` to manage big complex classes. If your class is complex,
    it's best to split it into smaller classes, not just different files.
  id: totrans-511
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以拥有任意数量的部分类。然而，建议的部分类数量不超过两个。编译器会将它们视为一个大类，但对于用户来说，它们看起来像是两个独立的类。生成代码会创建新的类文件，这将覆盖你编写的代码。当你处理自动生成的代码时，请使用`partial`。初学者犯的最大错误之一就是使用`partial`来管理大型复杂类。如果你的类很复杂，最好是将其拆分成更小的类，而不仅仅是不同的文件。
- en: There is one more use case for `partial`. Imagine you have a part of code in
    a class that is only needed in another assembly but is unnecessary in the assembly
    it is originally defined in. You can have the same class in different assemblies
    and mark it as `partial`. That way, a part of a class that is not needed will
    only be used where it is needed and be hidden where it should not be seen.
  id: totrans-512
  prefs: []
  type: TYPE_NORMAL
  zh: '`partial`还有一个用例。想象一下，你有一个类中的代码片段，它只在一个其他程序集（assembly）中需要，但在它最初定义的程序集中是不必要的。你可以在不同的程序集中拥有相同的类，并将其标记为`partial`。这样，类中不需要的部分将只在使用它的地方使用，而在不应该看到的地方隐藏。'
- en: Virtual
  id: totrans-513
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 虚拟
- en: 'Abstract methods can be overridden; however, they cannot be implemented. What
    if you wanted to have a method with a default behavior that could be overridden
    in the future? You can do this using the `virtual` keyword, as shown in the following example:'
  id: totrans-514
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法可以被重写；然而，它们不能被实现。如果你想要一个具有默认行为的方法，这个行为将来可以被重写，怎么办？你可以使用`virtual`关键字来实现，如下面的示例所示：
- en: '[PRE122]'
  id: totrans-515
  prefs: []
  type: TYPE_PRE
  zh: '[PRE122]'
- en: 'Here, the `Human` class has the `SayHi` method. This method is prefixed with
    the virtual keyword, which means that it can change behavior in a child class,
    for example:'
  id: totrans-516
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，`Human`类有`SayHi`方法。这个方法以`virtual`关键字为前缀，这意味着它可以在子类中更改行为，例如：
- en: '[PRE123]'
  id: totrans-517
  prefs: []
  type: TYPE_PRE
  zh: '[PRE123]'
- en: Note
  id: totrans-518
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/ZpHhI](https://packt.link/ZpHhI).
  id: totrans-519
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/ZpHhI](https://packt.link/ZpHhI)找到这个示例使用的代码。
- en: The `Frenchman` class inherits the `Human` class and overrides the `SayHi` method.
    Calling `SayHi` from a `Frenchman` object will print `Bonjour`.
  id: totrans-520
  prefs: []
  type: TYPE_NORMAL
  zh: '`Frenchman`类继承自`Human`类，并重写了`SayHi`方法。从`Frenchman`对象调用`SayHi`将打印`Bonjour`。'
- en: One of the things about C# is that its behavior is hard to override. Upon declaring
    a method, you need to be explicit by telling the compiler that the method can
    be overridden. Only `virtual` methods can be overridden. Interface methods are
    virtual (because they get behavior later), however, you cannot override interface
    methods from child classes. You can only implement an interface in a parent class.
  id: totrans-521
  prefs: []
  type: TYPE_NORMAL
  zh: C#的一个特点是它的行为很难被重写。在声明方法时，你需要明确地告诉编译器该方法可以被重写。只有`virtual`方法可以被重写。接口方法是虚拟的（因为它们稍后获得行为），然而，你不能从子类中重写接口方法。你只能在父类中实现接口。
- en: An abstract method is the last type of virtual method and is the most similar
    to `virtual` in that it can be overridden as many times as you need (in child
    and grandchild classes).
  id: totrans-522
  prefs: []
  type: TYPE_NORMAL
  zh: 抽象方法是最后一种虚拟方法，它与`virtual`最相似，因为它可以被重写任意多次（在子类和孙类中）。
- en: To avoid having fragile, changing, overridable behavior, the best kind of virtual
    methods are the ones that come from an interface. The `abstract` and `virtual`
    keywords enable changing class behavior in child classes and overriding it, which
    can become a big issue if uncontrolled. Overriding behavior often causes both
    inconsistent and unexpected results, so you should be careful before using the
    `virtual` keyword.
  id: totrans-523
  prefs: []
  type: TYPE_NORMAL
  zh: 为了避免有脆弱的、变化的、可重写的表现行为，最好的虚拟方法是来自接口的方法。`abstract`和`virtual`关键字允许在子类中更改类行为并重写它，如果不受控制，这可能会成为一个大问题。重写行为通常会导致不一致和意外的结果，所以在使用`virtual`关键字之前你应该小心。
- en: Internal
  id: totrans-524
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 内部
- en: '`public`, `private`, and `protected` are the three access modifiers that have
    been mentioned. Many beginners think that the default class modifier is `private`.
    However, `private` means that it cannot be called from outside a class, and in
    the context of a namespace, this does not make much sense. The default access
    modifier for a class is `internal`. This means that the class will only be visible
    inside the namespace it is defined in. The `internal` modifier is great for reusing
    classes across the same assembly, while at the same time hiding them from the
    outside.'
  id: totrans-525
  prefs: []
  type: TYPE_NORMAL
  zh: '`public`、`private`和`protected`是已经提到过的三种访问修饰符。许多初学者认为默认的类修饰符是`private`。然而，`private`意味着它不能从类外部调用，在命名空间的环境中，这并没有什么意义。类的默认访问修饰符是`internal`。这意味着该类将只在其定义的命名空间内部可见。`internal`修饰符非常适合在同一个程序集内重用类，同时又不让外部看到。'
- en: Conditional Operators
  id: totrans-526
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 条件运算符
- en: 'A null reference exception is probably the most common error in programming.
    For example, refer to the following code:'
  id: totrans-527
  prefs: []
  type: TYPE_NORMAL
  zh: 空引用异常可能是编程中最常见的错误。例如，参考以下代码：
- en: '[PRE124]'
  id: totrans-528
  prefs: []
  type: TYPE_PRE
  zh: '[PRE124]'
- en: This code will throw `NullReferenceException` because you are interacting with
    a variable that has a null value. What is the length of a null array? There is
    no proper answer to this question, so an exception will be thrown here.
  id: totrans-529
  prefs: []
  type: TYPE_NORMAL
  zh: 这段代码将抛出`NullReferenceException`，因为你正在与一个具有空值的变量交互。空数组的长度是多少？这个问题没有合适的答案，所以这里将抛出异常。
- en: The best way to protect against such an error is to avoid working with null
    values altogether. However, sometimes it is unavoidable. In those cases, there
    is another technique called defensive programming. Before using a value that might
    be `null`, make sure it is not `null`.
  id: totrans-530
  prefs: []
  type: TYPE_NORMAL
  zh: 防止此类错误发生的最佳方式是根本避免处理空值。然而，有时这是不可避免的。在这种情况下，还有一种称为防御性编程的技术。在使用可能为`null`的值之前，请确保它不是`null`。
- en: 'Now recall the example of the `Dog` class. If you create a new object, the
    value of `Owner` could be null. If you were to determine whether the owner''s
    name starts with the letter `A`, you would need to check first whether the value
    of `Owner` is `null`, as follows:'
  id: totrans-531
  prefs: []
  type: TYPE_NORMAL
  zh: 现在回想一下`Dog`类的例子。如果你创建一个新的对象，`Owner`的值可能是`null`。如果你要确定所有者的名字是否以字母`A`开头，你需要首先检查`Owner`的值是否为`null`，如下所示：
- en: '[PRE125]'
  id: totrans-532
  prefs: []
  type: TYPE_PRE
  zh: '[PRE125]'
- en: 'However, in C#, using null-conditional, this code becomes as simple as the
    following:'
  id: totrans-533
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，在C#中，使用空条件运算符，这段代码变得像下面这样简单：
- en: '[PRE126]'
  id: totrans-534
  prefs: []
  type: TYPE_PRE
  zh: '[PRE126]'
- en: Null-conditional (`?`) is an example of conditional operators in C#. It is an
    operator that implicitly runs an `if` statement (a specific `if` statement is
    based on the operator) and either returns something or continues work. The `Owner?.StartsWith('A')`
    part returns `true` if the condition is satisfied and `false` if it is either
    not satisfied or the object is `null`.
  id: totrans-535
  prefs: []
  type: TYPE_NORMAL
  zh: 空条件运算符（`?`）是C#中的条件运算符的一个例子。它是一个隐式运行`if`语句（基于特定运算符的特定`if`语句）并返回某些值或继续工作的运算符。`Owner?.StartsWith('A')`部分如果条件满足则返回`true`，如果不满足或对象为`null`则返回`false`。
- en: There are more conditional operators in C# that you will learn about.
  id: totrans-536
  prefs: []
  type: TYPE_NORMAL
  zh: C#中还有更多你将学习的条件运算符。
- en: Ternary Operators
  id: totrans-537
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 三元运算符
- en: 'There is hardly any language that does not have `if` statements. One of the
    most common kinds of `if` statement is `if-else`. For example, if the value of
    `Owner` is `null` for an instance of the `Dog` class, you can describe the instance
    simply as `{Name}`. Otherwise, you can better describe it as `{Name}, dog of {Owner}`,
    as shown in the following snippet:'
  id: totrans-538
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎没有哪种语言没有`if`语句。最常见的一种`if`语句是`if-else`。例如，如果一个`Dog`类的实例的`Owner`值为`null`，你可以简单地描述这个实例为`{Name}`。否则，你可以更好地描述它为`{Name},
    dog of {Owner}`，如下面的代码片段所示：
- en: '[PRE127]'
  id: totrans-539
  prefs: []
  type: TYPE_PRE
  zh: '[PRE127]'
- en: 'C#, like many other languages, simplifies this by using a ternary operator:'
  id: totrans-540
  prefs: []
  type: TYPE_NORMAL
  zh: C#像许多其他语言一样，通过使用三元运算符来简化这一点：
- en: '[PRE128]'
  id: totrans-541
  prefs: []
  type: TYPE_PRE
  zh: '[PRE128]'
- en: On the left side, you have a condition (true or false), followed by a question
    mark (`?`), which returns the value on the right if the condition is true, followed
    by a colon (`:`), which returns the value to the left if the condition is false.
    `$` is a string interpolation literal, which allows you to write `$"{dog1.Name},
    dog of {dog1.Owner}"` over `dog1.Name + "dog of" + dog1.Owner`. You should use
    it when concatenating text.
  id: totrans-542
  prefs: []
  type: TYPE_NORMAL
  zh: 在左侧，你有一个条件（真或假），后面跟着一个问号（`?`），如果条件为真，则返回右侧的值，后面跟着一个冒号（`:`），如果条件为假，则返回左侧的值。`$`是一个字符串插值字面量，它允许你写出`$"{dog1.Name},
    dog of {dog1.Owner}"`而不是`dog1.Name + "dog of" + dog1.Owner`。你应该在连接文本时使用它。
- en: 'Imagine there are two dogs now. You want the first dog to join the second one
    (that is, be owned by the owner of the second dog), but this can only happen if
    the second one has an owner to begin with. Normally, you would use the following
    code:'
  id: totrans-543
  prefs: []
  type: TYPE_NORMAL
  zh: 假设现在有两只狗。你希望第一只狗加入第二只（即，成为第二只狗的主人），但这只能发生在第二只狗已经有主人的情况下。通常，你会使用以下代码：
- en: '[PRE129]'
  id: totrans-544
  prefs: []
  type: TYPE_PRE
  zh: '[PRE129]'
- en: 'But in C#, you can use the following code:'
  id: totrans-545
  prefs: []
  type: TYPE_NORMAL
  zh: 但在C#中，你可以使用以下代码：
- en: '[PRE130]'
  id: totrans-546
  prefs: []
  type: TYPE_PRE
  zh: '[PRE130]'
- en: 'Here, you have applied the null-coalescing operator (`??`), which returns the
    value to the right if it is `null` and the value on the left if it is not `null`.
    However, you can simplify this further:'
  id: totrans-547
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你使用了空值合并运算符（`??`），如果右侧的值是`null`，则返回右侧的值；如果不是`null`，则返回左侧的值。然而，你可以进一步简化这个操作：
- en: '[PRE131]'
  id: totrans-548
  prefs: []
  type: TYPE_PRE
  zh: '[PRE131]'
- en: This means that if the value that you are trying to assign (on the left) is
    `null`, then the output will be the value on the right.
  id: totrans-549
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着如果你尝试分配的值（在左侧）是`null`，那么输出将是右侧的值。
- en: 'The last use case for the null-coalescing operator is input validation. Suppose
    there are two classes, `ComponentA` and `ComponentB`, and `ComponentB` must contain
    an initialized instance of `ComponentA`. You could write the following code:'
  id: totrans-550
  prefs: []
  type: TYPE_NORMAL
  zh: 空值合并运算符的最后一个用途是输入验证。假设有两个类，`ComponentA`和`ComponentB`，并且`ComponentB`必须包含一个初始化的`ComponentA`实例。你可以编写以下代码：
- en: '[PRE132]'
  id: totrans-551
  prefs: []
  type: TYPE_PRE
  zh: '[PRE132]'
- en: 'However, instead of the preceding code, you can simply write the following:'
  id: totrans-552
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，而不是前面的代码，你可以简单地写以下内容：
- en: '[PRE133]'
  id: totrans-553
  prefs: []
  type: TYPE_PRE
  zh: '[PRE133]'
- en: This can be read as If there is no `componentA`, then an exception must be thrown.
  id: totrans-554
  prefs: []
  type: TYPE_NORMAL
  zh: 这可以理解为如果没有`componentA`，则必须抛出异常。
- en: Note
  id: totrans-555
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/yHYbh](https://packt.link/yHYbh).
  id: totrans-556
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/yHYbh](https://packt.link/yHYbh)找到用于此示例的代码。
- en: In most cases, null operators should replace the standard `if null-else` statements.
    However, be careful with the way you use the ternary operator and limit it to
    simple `if-else` statements because the code can become unreadable very quickly.
  id: totrans-557
  prefs: []
  type: TYPE_NORMAL
  zh: 在大多数情况下，应该使用空值运算符来替换标准的`if null-else`语句。然而，在使用三元运算符时要小心，并将其限制在简单的`if-else`语句中，因为代码可能会变得难以阅读。
- en: Overloading Operators
  id: totrans-558
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 重载运算符
- en: It is fascinating how much can be abstracted away in C#. Comparing primitive
    numbers, multiplying, or dividing them is easy, but when it comes to objects,
    it is not that simple. What is one person plus another person? What is a bag of
    apples multiplied by another bag of apples? It is hard to say, but it can make
    total sense in the context of some domains.
  id: totrans-559
  prefs: []
  type: TYPE_NORMAL
  zh: 在C#中，可以抽象出很多内容是非常迷人的。比较原始数字、乘法或除法很容易，但涉及到对象时，这并不那么简单。一个人加上另一个人是什么？一袋苹果乘以另一袋苹果是什么？这很难说，但在某些领域背景下，这可以完全有道理。
- en: 'Consider a slightly better example. Suppose you are comparing bank accounts.
    Finding out who has more money in a bank account is a common use case. Normally,
    to compare two accounts, you would have to access their members, but C# allows
    you to overload comparison operators so that you can compare objects. For example,
    imagine you had a `BankAccount` class like so:'
  id: totrans-560
  prefs: []
  type: TYPE_NORMAL
  zh: 考虑一个稍微好一点的例子。假设你正在比较银行账户。找出谁在银行账户中有更多的钱是一个常见的用例。通常，为了比较两个账户，你必须访问它们的成员，但C#允许你重载比较运算符，以便你可以比较对象。例如，想象你有一个`BankAccount`类如下所示：
- en: '[PRE134]'
  id: totrans-561
  prefs: []
  type: TYPE_PRE
  zh: '[PRE134]'
- en: 'Here, the balance amount is `private`. You do not care about the exact value
    of `balance`; all you want is to compare one with another. You could implement
    a `CompareTo` method, but instead, you will implement a comparison operator. In
    the `BankAccount` class, you will add the following code:'
  id: totrans-562
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，余额是`private`的。你并不关心确切的余额值；你只想比较一个与另一个。你可以实现一个`CompareTo`方法，但相反，你将实现一个比较运算符。在`BankAccount`类中，你将添加以下代码：
- en: '[PRE135]'
  id: totrans-563
  prefs: []
  type: TYPE_PRE
  zh: '[PRE135]'
- en: The preceding code is called an operator overload. With a custom operator overload
    like this, you can return true when a balance is bigger and false otherwise. In
    C#, operators are `public static`, followed by a return type. After that, you
    have the `operator` keyword followed by the actual operator that is being overloaded.
    The input depends on the operator being overloaded. In this case, you passed two
    bank accounts.
  id: totrans-564
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码被称为运算符重载。使用这种自定义运算符重载，当余额更大时可以返回`true`，否则返回`false`。在C#中，运算符是`public static`，后面跟着返回类型。然后是`operator`关键字，后面跟着被重载的实际运算符。输入取决于被重载的运算符。在这种情况下，你传递了两个银行账户。
- en: 'If you tried to compile the code as it is, you would get an error that something
    is missing. It makes sense that the comparison operators have a twin method that
    does the opposite. Now, add the less operator overload as follows:'
  id: totrans-565
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试按原样编译代码，你会得到一个错误，表明缺少某些内容。比较运算符有一个相反的操作方法是有意义的。现在，添加小于运算符重载如下：
- en: '[PRE136]'
  id: totrans-566
  prefs: []
  type: TYPE_PRE
  zh: '[PRE136]'
- en: 'The code compiles now. Finally, it would make sense to have an equality comparison.
    Remember, you will need to add a pair, equal and not equal:'
  id: totrans-567
  prefs: []
  type: TYPE_NORMAL
  zh: 代码现在可以编译了。最后，进行等式比较是有意义的。记住，你需要添加一对，等于和不等于：
- en: '[PRE137]'
  id: totrans-568
  prefs: []
  type: TYPE_PRE
  zh: '[PRE137]'
- en: 'Next, you will create bank accounts to compare. Note that all numbers have
    an `m` appended, as this suffix makes those numbers `decimal`. By default, numbers
    with a fraction are `double`, so you need to add `m` at the end to make them `decimal`:'
  id: totrans-569
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，你将创建用于比较的银行账户。注意，所有数字后面都附加了`m`，因为这个后缀使这些数字成为`decimal`类型。默认情况下，有分数的数字是`double`类型，所以你需要添加`m`在末尾来使它们成为`decimal`：
- en: '[PRE138]'
  id: totrans-570
  prefs: []
  type: TYPE_PRE
  zh: '[PRE138]'
- en: 'Comparing two bank accounts becomes as simple as this now:'
  id: totrans-571
  prefs: []
  type: TYPE_NORMAL
  zh: 比较两个银行账户现在变得如此简单：
- en: '[PRE139]'
  id: totrans-572
  prefs: []
  type: TYPE_PRE
  zh: '[PRE139]'
- en: 'Running the code results in the following being printed to the console:'
  id: totrans-573
  prefs: []
  type: TYPE_NORMAL
  zh: 运行代码会在控制台打印出以下内容：
- en: '[PRE140]'
  id: totrans-574
  prefs: []
  type: TYPE_PRE
  zh: '[PRE140]'
- en: Note
  id: totrans-575
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/5DioJ](https://packt.link/5DioJ).
  id: totrans-576
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/5DioJ](https://packt.link/5DioJ)找到用于此示例的代码。
- en: Many (but not all) operators can be overloaded, but just because you can do
    so does not mean you should. Overloading operators can make sense in some cases,
    but in other cases, it might be counterintuitive. Again, remember to not abuse
    C# features and use them when it makes **logical** sense, and when it makes code
    easier to read, learn, and maintain.
  id: totrans-577
  prefs: []
  type: TYPE_NORMAL
  zh: 许多（但不是所有）运算符可以重载，但仅仅因为你可以这样做并不意味着你应该这样做。在某些情况下，重载运算符是有意义的，但在其他情况下，它可能是不直观的。再次提醒，不要滥用C#功能，只有在它们**逻辑上**有意义，并且使代码更容易阅读、学习和维护时才使用它们。
- en: Nullable Primitive Types
  id: totrans-578
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 可空原始类型
- en: Have you ever wondered what to do when a primitive value is unknown? For example,
    say a collection of products are announced. Their names, descriptions, and some
    other parameters are known, but the price is revealed only before the launch.
    What type should you use for storing the price values?
  id: totrans-579
  prefs: []
  type: TYPE_NORMAL
  zh: 你是否曾经想过当原始值未知时应该做什么？例如，假设宣布了一组产品。它们的名称、描述和一些其他参数是已知的，但价格只在发布前揭晓。你应该使用什么类型来存储价格值？
- en: 'Nullable primitive types are primitive types that might have some value or
    no value. In C#, to declare such a type, you have to add `?` after a primitive,
    as shown in the following code:'
  id: totrans-580
  prefs: []
  type: TYPE_NORMAL
  zh: 可空原始类型是一些可能具有某个值或没有值的原始类型。在C#中，要声明此类类型，你必须在原始类型后添加`?`，如下面的代码所示：
- en: '[PRE141]'
  id: totrans-581
  prefs: []
  type: TYPE_PRE
  zh: '[PRE141]'
- en: Here, you declared a field that may or may not have a value. Specifically, this
    means that a can be unknown. Do not confuse this with a default value because,
    by default, the value of `int` types is `0`.
  id: totrans-582
  prefs: []
  type: TYPE_NORMAL
  zh: 这里，你声明了一个可能具有值或没有值的字段。具体来说，这意味着a可能是未知的。不要将其与默认值混淆，因为默认情况下，`int`类型的值是`0`。
- en: 'You can assign a value to a nullable field quite simply, as follows:'
  id: totrans-583
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以非常简单地给一个可空字段赋值，如下所示：
- en: '[PRE142]'
  id: totrans-584
  prefs: []
  type: TYPE_PRE
  zh: '[PRE142]'
- en: 'And to retrieve its value afterward, you can write the code as follows:'
  id: totrans-585
  prefs: []
  type: TYPE_NORMAL
  zh: 要在之后检索其值，你可以编写如下代码：
- en: '[PRE143]'
  id: totrans-586
  prefs: []
  type: TYPE_PRE
  zh: '[PRE143]'
- en: Generics
  id: totrans-587
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 泛型
- en: 'Sometimes, you will come across situations where you do the exact same thing
    with different types, where the only difference is because of the type. For example,
    if you had to create a method that prints an `int` value, you could write the
    following code:'
  id: totrans-588
  prefs: []
  type: TYPE_NORMAL
  zh: 有时，你会遇到使用不同类型做完全相同的事情的情况，唯一的区别就是类型本身。例如，如果你需要创建一个打印`int`值的函数，你可以编写以下代码：
- en: '[PRE144]'
  id: totrans-589
  prefs: []
  type: TYPE_PRE
  zh: '[PRE144]'
- en: 'Similarly, if you need to print a string, you could add yet another overload:'
  id: totrans-590
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，如果你需要打印一个字符串，你可以添加另一个重载：
- en: '[PRE145]'
  id: totrans-591
  prefs: []
  type: TYPE_PRE
  zh: '[PRE145]'
- en: 'You did the same thing three times. Surely, there must be a way to reduce code
    duplication. Remember, in C#, all types derive from an `object` type, which has
    the `ToString()` method, so you can execute the following command:'
  id: totrans-592
  prefs: []
  type: TYPE_NORMAL
  zh: 你做了三遍同样的事情。当然，肯定有减少代码重复的方法。记住，在C#中，所有类型都从`object`类型派生，该类型具有`ToString()`方法，因此你可以执行以下命令：
- en: '[PRE146]'
  id: totrans-593
  prefs: []
  type: TYPE_PRE
  zh: '[PRE146]'
- en: Even though the last implementation contains the least code, it is actually
    the least efficient. An object is a reference type, whereas a primitive is a value
    type. When you take a primitive and assign it to an object, you also create a
    new reference to it. This is called boxing. It does not come for free, because
    you move objects from `stack to heap`. Programmers should be conscious of this
    fact and avoid it wherever possible.
  id: totrans-594
  prefs: []
  type: TYPE_NORMAL
  zh: 即使最后的实现包含的代码最少，但实际上它是最不高效的。对象是一种引用类型，而原始类型是一种值类型。当你将一个原始类型赋值给一个对象时，你也会为它创建一个新的引用。这被称为装箱。这并不是免费的，因为你将对象从`栈`移动到`堆`。程序员应该意识到这个事实，并在可能的情况下避免它。
- en: 'Earlier in the chapter, you encountered polymorphism—a way of doing different
    things using the same type. You can do the same things with different types as
    well and generics are what enable you to do that. In the case of the `Print` example,
    a generic method is what you need:'
  id: totrans-595
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章的早期，你遇到了多态——使用相同类型做不同事情的一种方式。你也可以使用不同类型做相同的事情，泛型就是让你能够做到这一点的东西。在`Print`示例的情况下，你需要的是一个泛型方法：
- en: '[PRE147]'
  id: totrans-596
  prefs: []
  type: TYPE_PRE
  zh: '[PRE147]'
- en: Using diamond brackets (`<>`), you can specify a type, `T`, with which this
    function works. `<T>` means that it can work with any type.
  id: totrans-597
  prefs: []
  type: TYPE_NORMAL
  zh: 使用菱形括号（`<>`），你可以指定一个类型`T`，这个函数将与之一起工作。`<T>`意味着它可以与任何类型一起工作。
- en: 'Now, suppose you want to print all elements of an array. Simply passing a collection
    to a `WriteLine` statement would result in printing a reference, instead of all
    the elements. Normally, you would create a method that prints all the elements
    passed. With the power of generics, you can have one method that prints an array
    of any type:'
  id: totrans-598
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，假设你想打印数组中的所有元素。简单地将一个集合传递给`WriteLine`语句会导致打印一个引用，而不是所有元素。通常，你会创建一个打印所有传递的元素的方法。利用泛型的力量，你可以有一个打印任何类型数组的单一方法：
- en: '[PRE148]'
  id: totrans-599
  prefs: []
  type: TYPE_PRE
  zh: '[PRE148]'
- en: Please note that the generic version is not as efficient as taking an `object`
    type, simply because you would still be using a `WriteLine` overload that takes
    an object as a parameter. When passing a generic, you cannot tell whether it needs
    to call an overload with an `int`, `float`, or `String`, or whether there is an
    exact overload in the first place. If there was no overload that takes an object
    for `WriteLine`, you would not be able to call the `Print` method. For that reason,
    the most performant code is actually the one with three overloads. It is not terribly
    important though because that is just one, very specific scenario where boxing
    happens anyway. There are so many other cases, however, where you can make it
    not only concise but performant as well.
  id: totrans-600
  prefs: []
  type: TYPE_NORMAL
  zh: 请注意，泛型版本并不像使用`object`类型那样高效，仅仅是因为你仍然会使用一个接受对象作为参数的`WriteLine`重载。当你传递一个泛型时，你无法确定它是否需要调用一个接受`int`、`float`或`String`的重载，或者是否一开始就有一个精确的重载。如果没有接受对象的重载`WriteLine`，你就无法调用`Print`方法。因此，最高效的代码实际上是具有三个重载的代码。尽管这并不非常重要，因为这只是一个装箱无论如何都会发生的非常具体的场景。然而，还有许多其他情况，你可以使代码不仅简洁，而且高效。
- en: 'Sometimes, the answer to choosing a generic or polymorphic function hides in
    tiny details. If you had to implement a method for comparing two elements and
    return `true` if the first one is bigger, you could do that in C# using an `IComparable` interface:'
  id: totrans-601
  prefs: []
  type: TYPE_NORMAL
  zh: 有时候，选择泛型或多态函数的答案隐藏在微小的细节中。如果你必须实现一个比较两个元素并返回`true`如果第一个更大的方法，你可以在C#中使用一个`IComparable`接口：
- en: '[PRE149]'
  id: totrans-602
  prefs: []
  type: TYPE_PRE
  zh: '[PRE149]'
- en: 'A generic version of this would look like this:'
  id: totrans-603
  prefs: []
  type: TYPE_NORMAL
  zh: 这个泛型版本看起来是这样的：
- en: '[PRE150]'
  id: totrans-604
  prefs: []
  type: TYPE_PRE
  zh: '[PRE150]'
- en: 'The new bit here is `where T : IComparable`. It is a generic constraint. By
    default, you can pass any type to a generic class or method. Constraints still
    allow different types to be passed, but they significantly reduce the possible
    options. A generic constraint allows only the types that conform to the constraint
    to be passed as a generic type. In this case, you will allow only the types that
    implement the `IComparable` interface. Constraints might seem like a limitation
    on types; however, they expose the behavior of the constrained types that you
    can use inside a generic method. Having constraints enables you to use the features
    of those types, so it is very useful. In this case, you do limit yourself to what
    types can be used, but at the same time, whatever you pass to the generic method
    will be comparable.'
  id: totrans-605
  prefs: []
  type: TYPE_NORMAL
  zh: '这里的新特性是 `where T : IComparable`。这是一个泛型约束。默认情况下，你可以将任何类型传递给泛型类或方法。约束仍然允许传递不同类型，但它们显著减少了可能的选项。泛型约束只允许符合约束的类型作为泛型类型传递。在这种情况下，你将只允许实现
    `IComparable` 接口类型的传递。约束可能看起来是对类型的限制；然而，它们暴露了受约束类型的内部行为，你可以在泛型方法中使用这些行为。有约束使你能够使用这些类型的特性，因此非常有用。在这种情况下，你确实限制了可以使用的类型，但与此同时，传递给泛型方法的任何内容都将是可以比较的。'
- en: 'What if instead of returning whether the first element is bigger, you needed
    to return the first element itself? You could write a non-generic method as follows:'
  id: totrans-606
  prefs: []
  type: TYPE_NORMAL
  zh: 如果不是返回第一个元素是否更大，而是需要返回第一个元素本身，你会怎么做？你可以编写一个非泛型方法，如下所示：
- en: '[PRE151]'
  id: totrans-607
  prefs: []
  type: TYPE_PRE
  zh: '[PRE151]'
- en: 'And the generic version would look as follows:'
  id: totrans-608
  prefs: []
  type: TYPE_NORMAL
  zh: 泛型版本将如下所示：
- en: '[PRE152]'
  id: totrans-609
  prefs: []
  type: TYPE_PRE
  zh: '[PRE152]'
- en: 'Also, it is worth comparing how you will get a meaningful output using each
    version. With a non-generic method, this is what the code would look like:'
  id: totrans-610
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，值得比较使用每个版本如何获取有意义的输出。使用非泛型方法，代码将如下所示：
- en: '[PRE153]'
  id: totrans-611
  prefs: []
  type: TYPE_PRE
  zh: '[PRE153]'
- en: 'With a generic version, the code would be like this:'
  id: totrans-612
  prefs: []
  type: TYPE_NORMAL
  zh: 使用泛型版本，代码将如下所示：
- en: '[PRE154]'
  id: totrans-613
  prefs: []
  type: TYPE_PRE
  zh: '[PRE154]'
- en: Note
  id: totrans-614
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/sIdOp](https://packt.link/sIdOp).
  id: totrans-615
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/sIdOp](https://packt.link/sIdOp) 找到用于此示例的代码。
- en: In this case, the winner is obvious. In the non-generic version, you have to
    do a cast. Casting in code is frowned upon because if you do get errors, you will
    get them during runtime and things might change and the cast will fail. Casting
    is also one extra action, whereas the generic version is far more fluent because
    it does not have a cast. Use generics when you want to work with types as-is and
    not through their abstractions. And returning an exact (non-polymorphic) type
    from a function is one of the best use cases for it.
  id: totrans-616
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，获胜者是显而易见的。在非泛型版本中，你必须进行类型转换。在代码中进行类型转换是不受欢迎的，因为如果你确实遇到错误，你将在运行时遇到它们，事情可能会改变，类型转换将失败。类型转换也是一个额外的动作，而泛型版本则更加流畅，因为它没有类型转换。当你想要直接使用类型而不是通过它们的抽象来工作时，请使用泛型。从函数中返回精确（非多态）类型是泛型的一个最佳用例之一。
- en: C# generics will be covered in detail in *Chapter 4*, *Data Structures and LINQ*.
  id: totrans-617
  prefs: []
  type: TYPE_NORMAL
  zh: C# 泛型将在第 4 章 *数据结构和 LINQ* 中详细介绍。
- en: Enum
  id: totrans-618
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 枚举
- en: 'The `enum` type represents a set of known values. Since it is a type, you can
    pass it instead of passing a primitive value to methods. `enum` holds all the
    possible values, hence it isn''t possible to have a value that it would not contain.
    The following snippet shows a simple example of this:'
  id: totrans-619
  prefs: []
  type: TYPE_NORMAL
  zh: '`enum` 类型代表一组已知值。由于它是一种类型，你可以将它传递给方法，而不是传递原始值。`enum` 包含所有可能的值，因此不可能有一个它不包含的值。以下代码片段展示了这个简单示例：'
- en: '[PRE155]'
  id: totrans-620
  prefs: []
  type: TYPE_PRE
  zh: '[PRE155]'
- en: Note
  id: totrans-621
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/gP9Li](https://packt.link/gP9Li).
  id: totrans-622
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/gP9Li](https://packt.link/gP9Li) 找到用于此示例的代码。
- en: You can now get a possible gender value as if it were in a `static class` by
    writing `Gender.Other`. Enums can easily be converted to an integer using casting—`(int)Gender.Male`
    will return `0`, `(int)Gender.Female` will return `1`, and so on. This is because
    `enum`, by default, starts numbering at `0`.
  id: totrans-623
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，你可以通过编写 `Gender.Other` 来获取一个可能的性别值，就像它在 `static class` 中一样。枚举可以很容易地通过类型转换转换为整数——`(int)Gender.Male`
    将返回 `0`，`(int)Gender.Female` 将返回 `1`，依此类推。这是因为 `enum` 默认从 `0` 开始编号。
- en: Enums do not have any behavior and they are known as constant containers. You
    should use them when you want to work with constants and prevent invalid values
    from being passed by design.
  id: totrans-624
  prefs: []
  type: TYPE_NORMAL
  zh: 枚举没有任何行为，它们被称为常量容器。当你想要使用常量并设计上防止传递无效值时，你应该使用它们。
- en: Extension Methods
  id: totrans-625
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 扩展方法
- en: Almost always, you will be working with a part of code that does not belong
    to you. Sometimes, this might cause inconvenience because you have no access to
    change it. Is it possible to somehow extend the existing types with the functionality
    you want? Is it possible to do so without inheriting or creating new component
    classes?
  id: totrans-626
  prefs: []
  type: TYPE_NORMAL
  zh: 几乎总是，你将处理不属于你的代码的一部分。有时，这可能会造成不便，因为你没有权限更改它。是否有可能以某种方式扩展现有类型以添加你想要的功能？是否可以在不继承或创建新的组件类的情况下做到这一点？
- en: You can achieve this easily through extension methods. They allow you to add
    methods on complete types and call them as if those methods were natively there.
  id: totrans-627
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以通过扩展方法轻松实现这一点。它们允许你在完整类型上添加方法，并像它们是本地存在的方法一样调用它们。
- en: 'What if you wanted to print a `string` to a console using a `Print` method,
    but call it from a `string` itself? `String` has no such method, but you can add
    it using an extension method:'
  id: totrans-628
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想使用 `Print` 方法将一个 `string` 打印到控制台，但要从 `string` 本身调用它？`String` 没有这样的方法，但你可以使用扩展方法（extension
    method）来添加它：
- en: '[PRE156]'
  id: totrans-629
  prefs: []
  type: TYPE_PRE
  zh: '[PRE156]'
- en: 'And this allows you to write the following code:'
  id: totrans-630
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许你编写以下代码：
- en: '[PRE157]'
  id: totrans-631
  prefs: []
  type: TYPE_PRE
  zh: '[PRE157]'
- en: 'This will print `Hey` to the console as follows:'
  id: totrans-632
  prefs: []
  type: TYPE_NORMAL
  zh: 这将按照以下方式将 `Hey` 打印到控制台：
- en: '[PRE158]'
  id: totrans-633
  prefs: []
  type: TYPE_PRE
  zh: '[PRE158]'
- en: Note
  id: totrans-634
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/JC5cj](https://packt.link/JC5cj).
  id: totrans-635
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/JC5cj](https://packt.link/JC5cj) 找到用于此示例的代码。
- en: Extension methods are `static` and must be placed within a `static class`. If
    you look at the semantics of the method, you will notice the use of the `this`
    keyword. The `this` keyword should be the first argument in an extension method.
    After that, the function continues as normal and you can use the argument with
    the `this` keyword as if it was just another argument.
  id: totrans-636
  prefs: []
  type: TYPE_NORMAL
  zh: 扩展方法是 `static` 的，并且必须放置在 `static class` 内部。如果你查看方法的语义，你会注意到 `this` 关键字的使用。在扩展方法中，`this`
    关键字应该是第一个参数。之后，函数会像平常一样继续执行，你可以使用带有 `this` 关键字的参数，就像它是另一个参数一样。
- en: Use extension methods to add (extend, but not the same extensions as what happens
    with inheritance) new behavior to existing types, even if the type would not support
    having methods otherwise. With extension methods, you can even add methods to
    `enum` types, which is not possible otherwise.
  id: totrans-637
  prefs: []
  type: TYPE_NORMAL
  zh: 使用扩展方法（extension methods）向现有类型添加（扩展，但不是与继承相同的方式）新行为，即使该类型在其他情况下不支持有方法。使用扩展方法，你甚至可以向
    `enum` 类型添加方法，这在其他情况下是不可能的。
- en: Struct
  id: totrans-638
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 结构体
- en: A class is a reference type, but not all objects are reference types (saved
    on the heap). Some objects can be created on the stack, and such objects are made
    using structs.
  id: totrans-639
  prefs: []
  type: TYPE_NORMAL
  zh: 类（class）是一个引用类型，但并非所有对象都是引用类型（保存在堆上）。一些对象可以在栈上创建，这样的对象是通过结构体（struct）创建的。
- en: 'A struct is defined like a class, but it is used for slightly different things.
    Now, create a `struct` named `Point`:'
  id: totrans-640
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体（struct）的定义类似于类（class），但它用于稍微不同的目的。现在，创建一个名为 `Point` 的 `struct`：
- en: '[PRE159]'
  id: totrans-641
  prefs: []
  type: TYPE_PRE
  zh: '[PRE159]'
- en: 'The only real difference here is the `struct` keyword, which indicates that
    this object will be saved on the stack. Also, you might have noticed that there
    is no use of properties. There are many people who would, instead of `Point`,
    type `x` and `y`. It is not a big deal, but instead of one variable, you would
    be working with two. This way of working with primitives is called primitive obsession.
    You should follow the principles of OOP and work with abstractions, well-encapsulated
    data, as well as behavior to keep things close so that they have high cohesion.
    When choosing where to place variables, ask yourself this question: can `x` change
    independently of `y`? Do you ever modify a point? Is a point a complete value
    on its own? The answer to all of this is **yes** and therefore putting it in a
    data structure makes sense. But why choose a struct over a class?'
  id: totrans-642
  prefs: []
  type: TYPE_NORMAL
  zh: 这里的唯一真正区别是 `struct` 关键字，它表示这个对象将被保存在栈上。你可能也注意到没有使用属性。很多人会直接使用 `x` 和 `y` 而不是
    `Point`。这不是什么大问题，但这样你将处理两个变量而不是一个。这种处理原始数据的方式被称为原始数据依赖（primitive obsession）。你应该遵循面向对象编程（OOP）的原则，与抽象、良好封装的数据以及行为一起工作，以保持事物紧密相连，从而具有高内聚性。在选择放置变量的位置时，问问自己这个问题：`x`
    是否可以独立于 `y` 改变？你是否曾经修改过一个点？一个点是否是一个完整的值？对这个问题的所有回答都是 **是**，因此将其放入数据结构中是有意义的。但为什么选择结构体而不是类？
- en: Structs are fast because they do not have any allocations on the heap. They
    are also fast because they are passed by value (therefore, access is direct, not
    through a reference). Passing them by value copies the values, so even if you
    could modify a struct, changes would not remain outside of a method. When something
    is just a simple, small composite value, you should use a struct. Finally, with
    structs, you get value equality.
  id: totrans-643
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体之所以快速，是因为它们在堆上没有进行任何分配。它们也很快，因为它们是通过值传递的（因此，访问是直接的，而不是通过引用）。通过值传递会复制值，所以即使你可以修改结构体，更改也不会保留在方法之外。当某物只是一个简单的小复合值时，你应该使用结构体。最后，使用结构体，你可以得到值相等性。
- en: Another effective example of a `struct` is `DateTime`. `DateTime` is just a
    unit of time, containing some information. It also does not change individually
    and supports methods such as `AddDays`, `TryParse`, and `Now`. Even though it
    has several different pieces of data, they can be treated as one unit, as they
    are date- and time-related.
  id: totrans-644
  prefs: []
  type: TYPE_NORMAL
  zh: '`struct`的另一个有效例子是`DateTime`。`DateTime`只是一个时间单位，包含一些信息。它也不会单独改变，支持`AddDays`、`TryParse`和`Now`等方法。尽管它包含几个不同的数据项，但它们可以被视为一个单元，因为它们与日期和时间相关。'
- en: 'Most `structs` should be immutable because they are passed by a copy of a value,
    so changing something inside a method will not keep those changes. You can add
    a `readonly` keyword to a `struct`, making all its fields `readonly`:'
  id: totrans-645
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数`struct`应该是不可变的，因为它们是通过值的副本传递的，所以在方法内部更改任何内容都不会保留这些更改。你可以在`struct`上添加`readonly`关键字，使其所有字段都变为`readonly`：
- en: '[PRE160]'
  id: totrans-646
  prefs: []
  type: TYPE_PRE
  zh: '[PRE160]'
- en: 'A `readonly` `struct` can have either a `readonly` field or getter properties.
    This is useful for the future maintainers of your code base as it prevents them
    from doing things that you did not design for (no mutability). Structs are just
    tiny grouped bits of data, but they can have behavior as well. It makes sense
    to have a method to calculate the distance between two points:'
  id: totrans-647
  prefs: []
  type: TYPE_NORMAL
  zh: 一个`readonly`的`struct`可以有一个`readonly`字段或getter属性。这对于你代码库的未来维护者来说很有用，因为它防止他们执行你没有设计过的操作（无可变性）。结构体只是微小的分组数据，但它们也可以有行为。有一个方法来计算两点之间的距离是有意义的：
- en: '[PRE161]'
  id: totrans-648
  prefs: []
  type: TYPE_PRE
  zh: '[PRE161]'
- en: The preceding code has a little bit of math in it—that is, distance between
    two points is the square root of points x's and y's squared differences added
    together.
  id: totrans-649
  prefs: []
  type: TYPE_NORMAL
  zh: 上述代码中包含一点数学——即两点之间的距离是x和y的平方差的平方根之和。
- en: 'It also makes sense to calculate the distance between this and other points.
    You do not need to change anything because you can just reuse the existing code,
    passing correct arguments:'
  id: totrans-650
  prefs: []
  type: TYPE_NORMAL
  zh: 计算这个点与其他点之间的距离也是有意义的。你不需要做任何改变，因为你可以直接重用现有的代码，传递正确的参数：
- en: '[PRE162]'
  id: totrans-651
  prefs: []
  type: TYPE_PRE
  zh: '[PRE162]'
- en: 'If you wanted to measure the distance between two points, you could create
    them like this:'
  id: totrans-652
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想测量两点之间的距离，你可以这样创建它们：
- en: '[PRE163]'
  id: totrans-653
  prefs: []
  type: TYPE_PRE
  zh: '[PRE163]'
- en: 'And use a member function to calculate distance:'
  id: totrans-654
  prefs: []
  type: TYPE_NORMAL
  zh: 并且使用成员函数来计算距离：
- en: '[PRE164]'
  id: totrans-655
  prefs: []
  type: TYPE_PRE
  zh: '[PRE164]'
- en: 'Or a static function:'
  id: totrans-656
  prefs: []
  type: TYPE_NORMAL
  zh: 或者使用静态函数：
- en: '[PRE165]'
  id: totrans-657
  prefs: []
  type: TYPE_PRE
  zh: '[PRE165]'
- en: 'The result for each version will be as follows:'
  id: totrans-658
  prefs: []
  type: TYPE_NORMAL
  zh: 每个版本的输出结果如下：
- en: '[PRE166]'
  id: totrans-659
  prefs: []
  type: TYPE_PRE
  zh: '[PRE166]'
- en: Note
  id: totrans-660
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/PtQzz](https://packt.link/PtQzz).
  id: totrans-661
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/PtQzz](https://packt.link/PtQzz)找到用于此示例的代码。
- en: When you think about a struct, think about it as just a group of primitives.
    The key point to remember is that all the data members (properties or fields)
    in a struct must be assigned during object initialization. It needs to be done
    for the same reason local variables cannot be used without having a value set
    initially. Structs do not support inheritance; however, they do support implementing
    an interface.
  id: totrans-662
  prefs: []
  type: TYPE_NORMAL
  zh: 当你考虑结构体时，把它想象成只是一个原始类型的组合。需要记住的关键点是，结构体中的所有数据成员（属性或字段）都必须在对象初始化时分配。这需要完成，原因与局部变量在没有初始值设置的情况下不能使用是一样的。结构体不支持继承；然而，它们支持实现接口。
- en: Structs are actually a great way to have simple business logic. Structs should
    be kept simple and should not contain other object references within them; they
    should be primitive-only. However, a class can hold as many struct objects as
    it needs. Using structs is a great way of escaping the obsessive use of primitives
    and using simple logic naturally, within a tiny group of data where it belongs—that
    is, a `struct`.
  id: totrans-663
  prefs: []
  type: TYPE_NORMAL
  zh: 结构体实际上是一种拥有简单业务逻辑的极好方式。结构体应该保持简单，并且不应该在其中包含其他对象引用；它们应该是仅包含原始类型的。然而，一个类可以拥有它需要的任意数量的结构体对象。使用结构体是避免过度使用原始类型并自然地在属于小数据组中应用简单逻辑的极好方法——也就是说，一个`struct`。
- en: Record
  id: totrans-664
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 记录
- en: A record is a reference type (unlike a `struct`, more like a class). However,
    out of the box, it has methods for comparison by value (both using the `equals`
    method and the operator). Also, a record has a different default implementation
    of `ToString()`, which no longer prints a type, but instead all the properties.
    This is exactly what is needed in many cases, so it helps a lot. Finally, there
    is a lot of syntactic sugar around records, which you are about to witness.
  id: totrans-665
  prefs: []
  type: TYPE_NORMAL
  zh: 记录是一种引用类型（与`struct`不同，更像是类）。然而，默认情况下，它具有按值比较的方法（既使用`equals`方法也使用运算符）。此外，记录有一个不同的`ToString()`默认实现，它不再打印类型，而是打印所有属性。这正是许多情况下所需要的，因此它非常有帮助。最后，记录周围有很多语法糖，你很快就会看到。
- en: 'You already know how to create custom types in C#. The only difference between
    different custom types is the keyword used. For record types, such a keyword is
    `record`. For example, you will now create a movie record. It has a `Title`, `Director`,
    `Producer`, `Description`, and a `ReleaseDate`:'
  id: totrans-666
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道如何在C#中创建自定义类型。不同自定义类型之间的唯一区别是使用的关键字。对于记录类型，这样的关键字是`record`。例如，你现在将创建一个电影记录。它有`Title`、`Director`、`Producer`、`Description`和`ReleaseDate`：
- en: '[PRE167]'
  id: totrans-667
  prefs: []
  type: TYPE_PRE
  zh: '[PRE167]'
- en: So far, you should find this very familiar, because the only difference is the
    keyword. Regardless of such a minor detail, you already reap major benefits.
  id: totrans-668
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，你应该觉得这非常熟悉，因为唯一的区别是关键字。无论这样一个细节如何，你都已经获得了巨大的好处。
- en: Note
  id: totrans-669
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The intention of having `MovieRecordV1` class in chapter, as against `MovieClass`
    in GitHub code, was to have a type, similar to a class and then refactor highlighting
    how record helps.
  id: totrans-670
  prefs: []
  type: TYPE_NORMAL
  zh: 在章节中保留`MovieRecordV1`类，而不是GitHub代码中的`MovieClass`，是为了有一个类似于类的类型，然后通过重构突出记录的帮助。
- en: 'Create two identical movies:'
  id: totrans-671
  prefs: []
  type: TYPE_NORMAL
  zh: 创建两个相同的电影：
- en: '[PRE168]'
  id: totrans-672
  prefs: []
  type: TYPE_PRE
  zh: '[PRE168]'
- en: 'So far, everything is the same. Try to print a movie to the console:'
  id: totrans-673
  prefs: []
  type: TYPE_NORMAL
  zh: 到目前为止，一切都没有变化。尝试将电影打印到控制台：
- en: '[PRE169]'
  id: totrans-674
  prefs: []
  type: TYPE_PRE
  zh: '[PRE169]'
- en: 'The output would be as follows:'
  id: totrans-675
  prefs: []
  type: TYPE_NORMAL
  zh: 输出结果如下：
- en: '[PRE170]'
  id: totrans-676
  prefs: []
  type: TYPE_PRE
  zh: '[PRE170]'
- en: Note
  id: totrans-677
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/xylkW](https://packt.link/xylkW).
  id: totrans-678
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/xylkW](https://packt.link/xylkW)找到这个示例使用的代码。
- en: If you tried doing the same to a class or a `struct` object, you would only
    get a type printed. However, for a record, a default behavior is to print all
    of its properties and their values.
  id: totrans-679
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你尝试对类或`struct`对象做同样的事情，你只会得到一个类型打印出来。然而，对于记录，默认行为是打印出所有属性及其值。
- en: 'That is not the only benefit of a record. Again, a record has value-equality
    semantics. Comparing two movie records will compare them by their property values:'
  id: totrans-680
  prefs: []
  type: TYPE_NORMAL
  zh: 这不是记录的唯一好处。同样，记录具有值相等语义。比较两个电影记录将通过它们的属性值进行比较：
- en: '[PRE171]'
  id: totrans-681
  prefs: []
  type: TYPE_PRE
  zh: '[PRE171]'
- en: This will print `true true`.
  id: totrans-682
  prefs: []
  type: TYPE_NORMAL
  zh: 这将打印`true true`。
- en: 'With the same amount of code, you have managed to get the most functionality
    by simply changing a data structure to a record. Out of the box, a record provides
    `Equals()`, `GetHashCode() overrides`, `== and != overrides`, and even a `ToString`
    override, which prints the record itself (all the members and their values). The
    benefits of records do not end there because, using them, you have a way to reduce
    a lot of boilerplate code. Take full advantage of records and rewrite your movie
    record:'
  id: totrans-683
  prefs: []
  type: TYPE_NORMAL
  zh: 仅通过将数据结构更改为记录，你就用相同数量的代码实现了最多的功能。默认情况下，记录提供了`Equals()`、`GetHashCode()`重写、`==
    和 !=`重写，甚至还有一个`ToString`重写，它会打印记录本身（所有成员及其值）。记录的好处不仅限于此，因为使用它们，你可以减少大量的样板代码。充分利用记录并重写你的电影记录：
- en: '[PRE172]'
  id: totrans-684
  prefs: []
  type: TYPE_PRE
  zh: '[PRE172]'
- en: 'This is a positional record, meaning all that you pass as parameters will end
    up in the right read-only data members as if it was a dedicated constructor. If
    you ran the demo again, you would notice that it no longer compiles. The major
    difference with this declaration is that, now, changing a description is no longer
    possible. Making a mutable property is not difficult, you just need to be explicit
    about it:'
  id: totrans-685
  prefs: []
  type: TYPE_NORMAL
  zh: 这是一个位置记录，意味着你传递的所有参数都将最终作为只读数据成员出现在正确的位置，就像是一个专门的构造函数。如果你再次运行演示，你会注意到它不再编译。这个声明的重大区别在于，现在，改变描述不再可能。创建可变属性并不困难，你只需要明确指出：
- en: '[PRE173]'
  id: totrans-686
  prefs: []
  type: TYPE_PRE
  zh: '[PRE173]'
- en: 'You started this paragraph with a discussion on immutability, but why is the
    primary focus on records? The benefits of records are actually immutability-focused.
    Using a `with` expression, you can create a copy of a record object with zero
    or more properties modified. So, suppose you add this to your demo:'
  id: totrans-687
  prefs: []
  type: TYPE_NORMAL
  zh: 你在这个段落开始时讨论了不可变性，但为什么主要关注的是记录？记录的好处实际上集中在不可变性上。使用`with`表达式，你可以创建一个具有零个或多个已修改属性的记录对象的副本。所以，假设你将以下内容添加到你的演示中：
- en: '[PRE174]'
  id: totrans-688
  prefs: []
  type: TYPE_PRE
  zh: '[PRE174]'
- en: 'The code would result in this:'
  id: totrans-689
  prefs: []
  type: TYPE_NORMAL
  zh: 代码将产生以下结果：
- en: '[PRE175]'
  id: totrans-690
  prefs: []
  type: TYPE_PRE
  zh: '[PRE175]'
- en: As you see, this code copies an object with just one property changed. Before
    records, you would need a lot of code to ensure all the members are copied, and
    only then would you set a value. Keep in mind that this creates a shallow copy.
    A shallow copy is an object with all the references copied. A deep copy is an
    object with all the reference-type objects recreated. Unfortunately, there is
    no way of overriding such behavior. Records cannot inherit classes, but they can
    inherit other records. They can also implement interfaces.
  id: totrans-691
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这段代码只拷贝了一个属性已更改的对象。在记录之前，你需要编写大量的代码来确保所有成员都被复制，然后才能设置值。请记住，这创建了一个浅拷贝。浅拷贝是一个包含所有引用的拷贝。深拷贝是一个包含所有引用类型对象重新创建的对象。不幸的是，没有方法可以覆盖这种行为。记录不能继承类，但可以继承其他记录。它们还可以实现接口。
- en: Other than being a reference type, records are more like structs in that they
    have value equality and syntactic sugar around immutability. They should not be
    used as a replacement for structs because structs are still preferable for small
    and simple objects, which have simple logic. Use records when you want immutable
    objects for data, which could hold other complex objects (if nested objects could
    have a state that changes, shallow copying might cause unexpected behavior).
  id: totrans-692
  prefs: []
  type: TYPE_NORMAL
  zh: 除了是引用类型外，记录更像结构体，因为它们具有值相等性和关于不可变性的语法糖。它们不应该用作结构体的替代品，因为对于小型和简单的对象，结构体仍然是首选，这些对象具有简单的逻辑。当你想要不可变的数据对象，这些对象可能包含其他复杂对象（如果嵌套对象的状态可能会改变，浅拷贝可能会导致意外的行为）时，请使用记录。
- en: Init-Only Setters
  id: totrans-693
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 仅`init`设置器
- en: 'With the introduction of records, the previous edition, C# 9, also introduced
    `init`-only setter properties. Writing `init` instead of `set` can enable object
    initialization for properties:'
  id: totrans-694
  prefs: []
  type: TYPE_NORMAL
  zh: 随着记录的引入，上一个版本C# 9也引入了仅`init`的设置器属性。使用`init`而不是`set`可以启用属性的初始化：
- en: '[PRE176]'
  id: totrans-695
  prefs: []
  type: TYPE_PRE
  zh: '[PRE176]'
- en: 'This enables you to create a house with unknown properties:'
  id: totrans-696
  prefs: []
  type: TYPE_NORMAL
  zh: 这使你能够创建一个具有未知属性的房子：
- en: '[PRE177]'
  id: totrans-697
  prefs: []
  type: TYPE_PRE
  zh: '[PRE177]'
- en: 'Or assign them:'
  id: totrans-698
  prefs: []
  type: TYPE_NORMAL
  zh: 或者分配它们：
- en: '[PRE178]'
  id: totrans-699
  prefs: []
  type: TYPE_PRE
  zh: '[PRE178]'
- en: Using `init`-only setters is especially useful when you want read-only data,
    which can be known or not, but not in a consistent matter.
  id: totrans-700
  prefs: []
  type: TYPE_NORMAL
  zh: 使用仅`init`的设置器特别有用，当你想要只读数据时，这些数据可以是已知的或未知的，但不一定是一致的。
- en: Note
  id: totrans-701
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/89J99](https://packt.link/89J99).
  id: totrans-702
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/89J99](https://packt.link/89J99)找到这个示例的代码。
- en: ValueTuple and Deconstruction
  id: totrans-703
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: '`ValueTuple`和解构'
- en: 'You already know that a function can only return one thing. In some cases,
    you can use the `out` keyword to return a second thing. For example, converting
    a string to a number is often done like this:'
  id: totrans-704
  prefs: []
  type: TYPE_NORMAL
  zh: 你已经知道一个函数只能返回一个值。在某些情况下，你可以使用`out`关键字来返回第二个值。例如，将字符串转换为数字通常是这样做的：
- en: '[PRE179]'
  id: totrans-705
  prefs: []
  type: TYPE_PRE
  zh: '[PRE179]'
- en: '`TryParse` returns both the parsed number and whether the text was a number.'
  id: totrans-706
  prefs: []
  type: TYPE_NORMAL
  zh: '`TryParse`返回解析的数字以及文本是否为数字。'
- en: 'However, C# has a better way of returning multiple values. You can achieve
    this using a data structure called `ValueTuple`. It is a generic `struct` that
    contains from one to six public mutable fields of any (specified) type. It is
    just a container for holding unrelated values. For example, if you had a `dog`,
    a `human`, and a `Bool`, you could store all three in a `ValueTuple` struct:'
  id: totrans-707
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，C#有一个更好的方法来返回多个值。你可以使用名为`ValueTuple`的数据结构来实现这一点。它是一个泛型`struct`，包含从一到六个公共可变字段，可以是任何（指定的）类型。它只是一个用于持有无关值的容器。例如，如果你有一个`dog`、一个`human`和一个`Bool`，你可以在一个`ValueTuple`结构体中存储所有三个：
- en: '[PRE180]'
  id: totrans-708
  prefs: []
  type: TYPE_PRE
  zh: '[PRE180]'
- en: 'You can then access each—that is, `dog` through `values1.Item1`, `human` through
    `values1.Item2`, and i`sDogKnown` through `values.Item3`. Another way of creating
    a `ValueTuple` struct is to use brackets. This does exactly the same thing as
    before, but using the brackets syntax:'
  id: totrans-709
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，你可以访问每个——也就是说，通过`values1.Item1`访问`dog`，通过`values1.Item2`访问`human`，以及通过`values.Item3`访问`i`sDogKnown`。创建`ValueTuple`结构体的另一种方法是使用括号。这和之前做的是完全一样，但使用了括号语法：
- en: '[PRE181]'
  id: totrans-710
  prefs: []
  type: TYPE_PRE
  zh: '[PRE181]'
- en: 'The following syntax proves extremely useful because, with it, you can declare
    a function that virtually returns multiple things:'
  id: totrans-711
  prefs: []
  type: TYPE_NORMAL
  zh: 以下语法非常有用，因为它允许你声明一个实际上返回多个值的功能：
- en: '[PRE182]'
  id: totrans-712
  prefs: []
  type: TYPE_PRE
  zh: '[PRE182]'
- en: Note
  id: totrans-713
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this example at [https://packt.link/OTFpm](https://packt.link/OTFpm).
  id: totrans-714
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以在[https://packt.link/OTFpm](https://packt.link/OTFpm)找到这个示例的代码。
- en: 'You can also do the opposite, using another C# feature called deconstruction.
    It takes object data members and allows you to split them apart, into separate
    variables. The problem with a tuple type is that it does not have a strong name.
    As mentioned before, every field will be called `ItemX`, where `X` is the order
    in which the item was returned. Working with all that, `GetDogHumanAndBool` would
    require the results to be assigned to three different variables:'
  id: totrans-715
  prefs: []
  type: TYPE_NORMAL
  zh: 你也可以做相反的操作，使用另一个名为解构的C#特性。它接受对象数据成员，并允许你将它们分开，到不同的变量中。元组类型的问题是没有强名称。如前所述，每个字段都将被命名为`ItemX`，其中`X`是返回项的顺序。处理所有这些，`GetDogHumanAndBool`将需要将结果分配给三个不同的变量：
- en: '[PRE183]'
  id: totrans-716
  prefs: []
  type: TYPE_PRE
  zh: '[PRE183]'
- en: 'You can simplify this and instead make use of deconstruction—assigning object
    properties to different variables right away:'
  id: totrans-717
  prefs: []
  type: TYPE_NORMAL
  zh: 你可以简化这一点，并利用解构——立即将对象属性分配给不同的变量：
- en: '[PRE184]'
  id: totrans-718
  prefs: []
  type: TYPE_PRE
  zh: '[PRE184]'
- en: Using deconstruction, you are able to make this a lot more readable and concise.
    Use `ValueTuple` when you have multiple unrelated variables and you want to return
    them all from a function. You do not have to always work around using the `out`
    keyword, nor do you have to add overhead by creating a new class. You can solve
    this problem by simply returning and then deconstructing a `ValueTuple` struct.
  id: totrans-719
  prefs: []
  type: TYPE_NORMAL
  zh: 通过解构，你可以使代码变得更加易读和简洁。当你有多个无关变量并希望从函数中返回它们时，请使用`ValueTuple`。你不必总是使用`out`关键字来绕过，也不必通过创建一个新类来增加开销。你可以通过简单地返回并解构一个`ValueTuple`结构体来解决这个问题。
- en: You can now have hands-on experience of using SOLID principles for writing codes
    incrementally through the following exercise.
  id: totrans-720
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在可以通过以下练习亲身体验使用SOLID原则逐步编写代码。
- en: 'Exercise 2.04: Creating a Composable Temperature Unit Converter'
  id: totrans-721
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 练习2.04：创建可组合的温度单位转换器
- en: 'Temperature can be measured in different units: Celsius, Kelvin, and Fahrenheit.
    In the future, more units might be added. However, units do not have to be added
    dynamically by the user; the application either supports it or not. You need to
    make an application that converts temperature from any unit to another unit.'
  id: totrans-722
  prefs: []
  type: TYPE_NORMAL
  zh: 温度可以用不同的单位来衡量：摄氏度、开尔文和华氏度。将来可能会添加更多单位。然而，用户不必动态地添加单位；应用程序要么支持它，要么不支持。你需要创建一个应用程序，将温度从任何单位转换为另一个单位。
- en: It is important to note that converting to and from that unit will be a completely
    different thing. Therefore, you will need two methods for every converter. As
    a standard unit, you will use Celsius. Therefore, every converter should have
    a conversion method from and to Celsius, which makes it the simplest unit of a
    program. When you need to convert non-Celsius to Celsius, you will need to involve
    two converters—one to adapt the input to the standard unit (C), and then another
    one to convert from C to whatever unit you want. The exercise will aid you in
    developing an application using the SOLID principles and C# features you have
    learned in this chapter, such as `record` and `enum`.
  id: totrans-723
  prefs: []
  type: TYPE_NORMAL
  zh: 需要注意的是，从该单位转换到其他单位以及从其他单位转换到该单位将完全是两回事。因此，你将为每个转换器需要两个方法。作为一个标准单位，你将使用摄氏度。因此，每个转换器都应该有一个从和到摄氏度的转换方法，这使得它成为程序中最简单的单位。当你需要将非摄氏度转换为摄氏度时，你需要涉及两个转换器——一个将输入适配到标准单位（C），然后另一个将C转换为所需的任何单位。这个练习将帮助你开发一个应用程序，使用你在本章中学到的SOLID原则和C#特性，例如`record`和`enum`。
- en: 'Perform the following steps to do so:'
  id: totrans-724
  prefs: []
  type: TYPE_NORMAL
  zh: 执行以下步骤来完成此操作：
- en: 'Create a `TemperatureUnit` that uses an `enum` type to define constants—that
    is, a set of known values. You do not need to add it dynamically:'
  id: totrans-725
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个使用`enum`类型定义常量（即一组已知值）的`TemperatureUnit`。你不需要动态添加它：
- en: '[PRE185]'
  id: totrans-726
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE185]'
- en: In this example, you will use three temperature units that are `C`, `K`, and
    `F`.
  id: totrans-727
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你将使用三个温度单位，即`C`、`K`和`F`。
- en: 'Temperature should be thought of as a simple object made of two properties:
    `Unit` and `Degrees`. You could either use a `record` or a `struct` because it
    is a very simple object with data. The best choice would be picking a `struct`
    here (due to the size of the object), but for the sake of practicing, you will
    use a `record`:'
  id: totrans-728
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 应该将温度视为由两个属性组成的简单对象：`Unit`和`Degrees`。你可以使用`record`或`struct`，因为这是一个非常简单的具有数据的对象。在这里的最佳选择是选择`struct`（由于对象的大小），但为了练习的目的，你将使用`record`：
- en: '[PRE186]'
  id: totrans-729
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE186]'
- en: 'Next, add a contract defining what you want from an individual specific temperature
    converter:'
  id: totrans-730
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，添加一个定义你希望从单个特定温度转换器中获得的合同：
- en: '[PRE187]'
  id: totrans-731
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE187]'
- en: You defined an interface with three methods—the `Unit` property to identify
    which temperature the converter is for, and `ToC` and `FromC` to convert from
    and to standard units.
  id: totrans-732
  prefs: []
  type: TYPE_NORMAL
  zh: 你定义了一个包含三个方法的外部接口——`Unit`属性用于标识转换器针对的是哪种温度，以及`ToC`和`FromC`用于从和到标准单位进行转换。
- en: 'Now that you have a converter, add the composable converter, which has an array
    of converters:'
  id: totrans-733
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在你已经有一个转换器了，添加一个组合转换器，它包含一个转换器数组：
- en: '[PRE188]'
  id: totrans-734
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE188]'
- en: 'It makes no sense to have duplicate temperature unit converters. So, add an
    error that will be thrown when a duplicate converter is detected. Also, not having
    any converters makes no sense. Therefore, there should be some code for validating
    against `null` or empty converters:'
  id: totrans-735
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 存在重复的温度单位转换器是没有意义的。因此，当检测到重复的转换器时，应该抛出一个错误。同样，没有任何转换器也是没有意义的。因此，应该有一些代码来验证`null`或空转换器：
- en: '[PRE189]'
  id: totrans-736
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE189]'
- en: When creating custom exceptions, you should provide as much information as possible
    about the context of an error. In this case, pass the `unit` for which the converter
    was not found.
  id: totrans-737
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建自定义异常时，你应该尽可能提供有关错误上下文的信息。在这种情况下，传递转换器未找到的`unit`。
- en: 'Add a method that requires non-empty converters:'
  id: totrans-738
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个需要非空转换器的`method`：
- en: '[PRE190]'
  id: totrans-739
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE190]'
- en: Passing an array of empty converters throws an `InvalidTemperatureConverterException`
    exception.
  id: totrans-740
  prefs: []
  type: TYPE_NORMAL
  zh: 传递一个空转换器数组将抛出`InvalidTemperatureConverterException`异常。
- en: 'Add a method that requires non-duplicate converters:'
  id: totrans-741
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个需要非重复转换器的`method`：
- en: '[PRE191]'
  id: totrans-742
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE191]'
- en: This method goes through every converter and checks that, at other indexes,
    the same converter is not repeated (by duplicating `TemperatureUnit`). If it finds
    a duplicate unit, it will throw an exception. If it does not, it will just terminate successfully.
  id: totrans-743
  prefs: []
  type: TYPE_NORMAL
  zh: 这种方法会遍历每一个转换器，并检查在其他索引处是否重复了相同的转换器（通过复制`TemperatureUnit`）。如果发现重复的单位，它将抛出异常。如果没有，它将成功终止。
- en: 'Now combine it all in a constructor:'
  id: totrans-744
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在将所有这些组合在一个构造函数中：
- en: '[PRE192]'
  id: totrans-745
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE192]'
- en: When creating the converter, validate against converters that are not empty
    and not duplicates and only then set them.
  id: totrans-746
  prefs: []
  type: TYPE_NORMAL
  zh: 在创建转换器时，验证它们不为空且不重复，然后才设置它们。
- en: 'Next, create a `private` helper method to help you find the requisite converter,
    `FindConverter`, inside the composable converter:'
  id: totrans-747
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，创建一个`private`辅助方法来帮助你在组合转换器中找到所需的转换器，即`FindConverter`：
- en: '[PRE193]'
  id: totrans-748
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE193]'
- en: This method returns the converter of the requisite unit and, if no converter
    is found, throws an exception.
  id: totrans-749
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回所需单位的转换器，如果找不到转换器，则抛出异常。
- en: 'To simplify how you search and convert from any unit to Celsius, add a `ToCelsius`
    method for that:'
  id: totrans-750
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 为了简化从任何单位到摄氏度的搜索和转换，添加一个`ToCelsius`方法：
- en: '[PRE194]'
  id: totrans-751
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE194]'
- en: Here, you find the requisite converter and convert the `Temperature` to Celsius.
  id: totrans-752
  prefs: []
  type: TYPE_NORMAL
  zh: 在这里，你找到所需的转换器并将`Temperature`转换为摄氏度。
- en: 'Do the same for converting from Celsius to any other unit:'
  id: totrans-753
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将同样的方法用于将摄氏度转换为任何其他单位：
- en: '[PRE195]'
  id: totrans-754
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE195]'
- en: 'Wrap it all up by implementing this algorithm, standardize the temperature
    (convert to Celsius), and then convert to any other temperature:'
  id: totrans-755
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 通过实现这个算法来总结整个过程，标准化温度（转换为摄氏度），然后转换为任何其他温度：
- en: '[PRE196]'
  id: totrans-756
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE196]'
- en: 'Add a few converters. Start with the Kelvin converter, `KelvinConverter`:'
  id: totrans-757
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一些转换器。从开尔文转换器`KelvinConverter`开始：
- en: '[PRE197]'
  id: totrans-758
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE197]'
- en: The implementation of this and all the other converters is straightforward.
    All you had to do was implement the formula to convert to the correct unit from
    or to Celsius. Kelvin has a useful constant, absolute zero, so instead of having
    a magic number, `–273.15`, you used a named constant. Also, it is worth remembering
    that a temperature is not a primitive. It is both a degree value and a unit. So,
    when converting, you need to pass both. `ToC` will always take `TemperatureUnit.C`
    as a unit and `FromC` will take whatever unit the converter is identified as,
    in this case, `TemperatureUnit.K`.
  id: totrans-759
  prefs: []
  type: TYPE_NORMAL
  zh: 所有其他转换器的实现都是直接的。你所要做的就是实现从或到摄氏度的正确单位的转换公式。开尔文有一个有用的常数，绝对零，所以你使用了一个命名的常数而不是一个魔法数字`-273.15`。此外，值得记住的是，温度不是一个原始数据类型。它既是一个度值，也是一个单位。因此，在转换时，你需要传递这两个值。`ToC`将始终以`TemperatureUnit.C`为单位，而`FromC`将接受转换器被识别为的任何单位，在这种情况下，`TemperatureUnit.K`。
- en: 'Now add a Fahrenheit converter, `FahrenheitConverter`:'
  id: totrans-760
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在添加一个华氏度转换器，`FahrenheitConverter`：
- en: '[PRE198]'
  id: totrans-761
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE198]'
- en: Fahrenheit is identical structure-wise; the only differences are the formulas
    and unit value.
  id: totrans-762
  prefs: []
  type: TYPE_NORMAL
  zh: 华氏度的结构相同；唯一的区别是公式和单位值。
- en: 'Add a `CelsiusConverter`, which will accept a value for the temperature and
    return the same value, as follows:'
  id: totrans-763
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个`CelsiusConverter`，它将接受一个温度值并返回相同的值，如下所示：
- en: '[PRE199]'
  id: totrans-764
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE199]'
- en: '`CelsiusConverter` is the simplest one. It does not do anything; it just returns
    the same temperature. The converters convert to standard temperature—Celsius to
    Celsius is always Celsius. Why do you need such a class at all? Without it, you
    would need to change the flow a bit, adding `if` statements to ignore the temperature
    if it was in Celsius. But with this implementation, you can incorporate it in
    the same flow and use it in the same way with the help of the same abstraction,
    `ITemperatureConverter`.'
  id: totrans-765
  prefs: []
  type: TYPE_NORMAL
  zh: '`CelsiusConverter` 是最简单的一个。它什么也不做；它只是返回相同的温度。转换器将转换为标准温度——摄氏度到摄氏度总是摄氏度。为什么你需要这样的类呢？如果没有它，你将需要稍微改变一下流程，添加
    `if` 语句来忽略如果是摄氏度的温度。但是，使用这种实现，你可以将其纳入相同的流程，并使用相同的抽象 `ITemperatureConverter` 以相同的方式使用。'
- en: 'Finally, create a demo:'
  id: totrans-766
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后，创建一个演示：
- en: '[PRE200]'
  id: totrans-767
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE200]'
- en: '[PRE201]'
  id: totrans-768
  prefs: []
  type: TYPE_PRE
  zh: '[PRE201]'
- en: In this example, you have created all the converters and passed them to the
    converters container called `composableConverter`. Then you have created a temperature
    in Celsius and used it to perform conversions from and to all the other temperatures.
  id: totrans-769
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，你已经创建了所有转换器并将它们传递给了名为 `composableConverter` 的转换器容器。然后你创建了一个摄氏度温度并使用它来执行到所有其他温度的转换。
- en: 'Run the code and you will get the following results:'
  id: totrans-770
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行代码，你将得到以下结果：
- en: '[PRE202]'
  id: totrans-771
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE202]'
- en: Note
  id: totrans-772
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 注意
- en: You can find the code used for this exercise at [https://packt.link/dDRU6](https://packt.link/dDRU6).
  id: totrans-773
  prefs:
  - PREF_IND
  type: TYPE_NORMAL
  zh: 你可以在 [https://packt.link/dDRU6](https://packt.link/dDRU6) 找到用于此练习的代码。
- en: A software developer, ideally, should design code in such a way that making
    a change now or in the future will take the same amount of time. Using SOLID principles,
    you can write code incrementally and minimize the risk of breaking changes, because
    you never change existing code; you just add new code. As systems grow, complexity
    increases, and it might be difficult to learn how things work. Through well-defined
    contracts, SOLID enables you to have easy-to-read, and maintainable code because
    each piece is straightforward by itself, and they are isolated from one another.
  id: totrans-774
  prefs: []
  type: TYPE_NORMAL
  zh: 软件开发者应该以这样的方式设计代码，即现在或将来进行更改所需的时间相同。通过使用 SOLID 原则，你可以增量地编写代码并最小化破坏性更改的风险，因为你永远不会更改现有代码；你只是添加新代码。随着系统的增长，复杂性增加，可能很难了解事物是如何工作的。通过定义良好的契约，SOLID
    使你能够拥有易于阅读和维护的代码，因为每个部分本身都很简单，并且它们彼此隔离。
- en: You will now test your knowledge of creating classes and overriding operators
    through an activity.
  id: totrans-775
  prefs: []
  type: TYPE_NORMAL
  zh: 你现在将通过一个活动来测试你创建类和重载操作符的知识。
- en: 'Activity 2.01: Merging Two Circles'
  id: totrans-776
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 活动二.01：合并两个圆
- en: 'In this activity, you will create classes and override operators to solve the
    following mathematics problem: A portion of pizza dough can be used to create
    two circular pizza bites each with a radius of three centimeters. What would be
    the radius of a single pizza bite made from the same amount of dough? You can
    assume that all the pizza bites are the same thickness. The following steps will
    help you complete this activity:'
  id: totrans-777
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个活动中，你将创建类并重载操作符来解决以下数学问题：一块披萨面团的一部分可以用来制作两个半径为三厘米的圆形披萨块。如果使用相同量的面团制作单个披萨块，其半径会是多少？你可以假设所有披萨块厚度相同。以下步骤将帮助你完成这个活动：
- en: Create a `Circle` struct with a radius. It should be a `struct` because it is
    a simple data object, which has a tiny bit of logic, calculating area.
  id: totrans-778
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个具有半径的 `Circle` 结构。它应该是一个 `struct`，因为它是一个简单的数据对象，它有一点点逻辑，计算面积。
- en: Add a property to get the area of a circle (try to use an expression-bodied
    member). Remember, the formula of a circle's area is `pi*r*r`. To use the `PI`
    constant, you will need to import the `Math` package.
  id: totrans-779
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 添加一个属性来获取圆的面积（尝试使用表达式成员）。记住，圆的面积公式是 `pi*r*r`。要使用 `PI` 常量，你需要导入 `Math` 包。
- en: Add two circles' areas together. The most natural way would be to use an overload
    for a plus (`+`) operator. Implement a `+` operator overload that takes two circles
    and returns a new one. The area of the new circle is the sum of the areas of the
    two old circles. However, do not create a new circle by passing the area. You
    need a Radius. You can calculate this by dividing the new area by `PI` and then
    taking the square root of the result.
  id: totrans-780
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 将两个圆的面积相加。最自然的方式是使用加号（`+`）的重载。实现一个 `+` 操作符重载，它接受两个圆并返回一个新的圆。新圆的面积是两个旧圆面积的总和。然而，不要通过传递面积来创建一个新的圆。你需要一个半径。你可以通过将新面积除以
    `PI` 然后取结果的平方根来计算这个半径。
- en: Now create a `Solution` class that takes two circles and returns a result—the
    radius of the new circle.
  id: totrans-781
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在创建一个 `Solution` 类，它接受两个圆并返回一个结果——新圆的半径。
- en: Within the `main` method, create two circles with a radius of `3` cm and define
    a new circle, which is equal to the areas of the two other circles added together.
    Print the results.
  id: totrans-782
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`main`方法中，创建两个半径为`3`厘米的圆，并定义一个新的圆，其面积等于另外两个圆面积之和。打印结果。
- en: 'Run the `main` method and the result should be as follows:'
  id: totrans-783
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 运行`main`方法，结果应该如下：
- en: '[PRE203]'
  id: totrans-784
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE203]'
- en: As you can see from this final output, the new circle will have a radius of
    `4.24` (rounded to the second decimal place).
  id: totrans-785
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个最终输出显示，新的圆将有一个半径为`4.24`（四舍五入到小数点后第二位）。
- en: Note
  id: totrans-786
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: The solution to this activity can be found at [https://packt.link/qclbF](https://packt.link/qclbF).
  id: totrans-787
  prefs: []
  type: TYPE_NORMAL
  zh: 该活动的解决方案可在[https://packt.link/qclbF](https://packt.link/qclbF)找到。
- en: This activity was designed to test your knowledge of creating classes and overriding
    operators. Operators are not normally employed to solve this sort of problem,
    but in this case, it worked well.
  id: totrans-788
  prefs: []
  type: TYPE_NORMAL
  zh: 这个活动旨在测试你创建类和重载运算符的知识。通常不会使用运算符来解决这类问题，但在这个情况下，它效果很好。
- en: Summary
  id: totrans-789
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, you learned about OOP and how it helps take complex problems
    and abstract them into simple concepts. C# has several useful features and, roughly
    every one or two years, a new language version is released. The features mentioned
    in this chapter are just some of the ways in which C# aids in productivity. You
    have seen how, by design, it allows for better, clearer code, less prone to error.
    C# is one of the best languages when it comes to productivity. With C#, you can
    make effective code, and quickly, because a lot of the boilerplate code is done
    for you.
  id: totrans-790
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你学习了面向对象编程（OOP）以及它是如何帮助将复杂问题抽象成简单概念的。C#有几个有用的特性，并且大约每一年或两年就会发布一个新的语言版本。本章中提到的特性只是C#帮助提高生产力的几种方式之一。你已经看到，通过设计，它允许编写更好、更清晰的代码，且更不容易出错。C#是生产力方面最好的语言之一。使用C#，你可以快速编写有效的代码，因为很多样板代码都是为你预先准备好的。
- en: Finally, you learned the SOLID principles and used them in an application. SOLID
    is not something you can just read and learn immediately; it takes practice, discussions
    with your peers, and a lot of trial and error before you get it right and start
    applying it consistently. However, the benefits are worth it. In modern software
    development, producing fast, optimal code is no longer a number one priority.
    Nowadays, the focus is a balance of productivity (how fast you develop) and performance
    (how fast your program is). C# is one of the most efficient languages out there,
    both in terms of performance and productivity.
  id: totrans-791
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，你学习了SOLID原则并在一个应用中使用了它们。SOLID不是你可以一读就学会的东西；它需要实践、与同伴的讨论以及大量的试错，才能正确地掌握并开始持续应用。然而，这些好处是值得的。在现代软件开发中，快速、高效地编写代码已不再是首要任务。如今，重点是平衡生产力（你开发的速度）和性能（你的程序运行的速度）。C#是性能和生产力方面最有效的语言之一。
- en: In the next chapter, you will learn what functional programming is and how to
    work with lambdas and functional constructs such as delegates.
  id: totrans-792
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，你将学习什么是函数式编程以及如何使用lambda和函数式结构，如委托。
