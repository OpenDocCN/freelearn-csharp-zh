- en: Chapter 9. Pipeline and Producer-consumer Design Patterns
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 第9章。管道和生产者-消费者设计模式
- en: In this chapter, we will explore two popular design patterns to solve concurrent
    problems—Pipeline and producer-consumer, which are used in developing parallel
    applications using the TPL. A **Pipeline** design is one where an application
    is designed with multiple tasks or stages of functionality with queues of work
    items between them. So, for each stage, the application will read from a queue
    of work to be performed, execute the work on that item, and then queue the results
    for the next stage. By designing the application this way, all of the stages can
    execute in parallel. Each stage just reads from its work queue, performs the work,
    and puts the results of the work into the queue for the next stage.
  id: totrans-1
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们将探讨两种流行的设计模式来解决并发问题——管道和生产者-消费者，这些模式用于使用 TPL 开发并行应用程序。**管道**设计是一种应用程序设计，其中包含多个任务或功能阶段，它们之间有工作项队列。因此，对于每个阶段，应用程序将从一个要执行的工作队列中读取，在该项上执行工作，然后将结果排队到下一阶段。通过这种方式设计应用程序，所有阶段都可以并行执行。每个阶段只需从其工作队列中读取，执行工作，并将工作结果放入下一阶段的工作队列中。
- en: Each stage is a task and can run independently of the other stages or tasks.
    They continue executing until their queue is empty and marked completed. They
    also block and wait for more work items if the queue is empty but not completed.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 每个阶段都是一个任务，可以独立于其他阶段或任务运行。它们将继续执行，直到它们的队列变为空并标记为完成。如果队列为空但未完成，它们也会阻塞并等待更多工作项。
- en: The **producer-consumer** design pattern is a similar concept but different.
    In this design, we have a set of functionality that produces data that is then
    consumed by another set of functionality. Each set of functionality is a TPL task.
    So, we have a producer task and a consumer task, with a buffer between them. Each
    of these tasks can run independently of each other. We can also have multiple
    producer tasks and multiple consumer tasks. The producers run independently and
    produce queue results to the buffer. The consumers run independently and dequeue
    from the buffer and perform work on the item. The producer can block if the buffer
    is full and wait for room to become available before producing more results. Also,
    the consumer can block if the buffer is empty, waiting on more results to be available
    to consume.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: '**生产者-消费者**设计模式是一个类似的概念，但有所不同。在这个设计中，我们有一组产生数据的功能，然后这些数据被另一组功能消费。每一组功能都是一个
    TPL 任务。因此，我们有一个生产者任务和一个消费者任务，它们之间有一个缓冲区。这些任务中的每一个都可以独立运行。我们也可以有多个生产者任务和多个消费者任务。生产者独立运行，并将队列结果输出到缓冲区。消费者独立运行，从缓冲区中出队并处理项目。如果缓冲区满了，生产者可以阻塞并等待空间变得可用后再产生更多结果。同样，如果缓冲区为空，消费者可以阻塞，等待更多可消费的结果。'
- en: 'In this chapter, you will learn the following:'
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，你将学习以下内容：
- en: Designing an application with a Pipeline design
  id: totrans-5
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用管道设计模式设计应用程序
- en: Designing an application with a producer-consumer design
  id: totrans-6
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 使用生产者-消费者设计设计应用程序
- en: Learning how to use `BlockingCollection`
  id: totrans-7
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 `BlockingCollection`
- en: Learning how to use `BufferedBlocks`
  id: totrans-8
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 学习如何使用 `BufferedBlocks`
- en: Understanding the classes of the `System.Threading.Tasks.Dataflow` library
  id: totrans-9
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: 理解 `System.Threading.Tasks.Dataflow` 库的类
- en: Pipeline design pattern
  id: totrans-10
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 管道设计模式
- en: The Pipeline design is very useful in parallel design when you can divide an
    application up into series of tasks to be performed in such a way that each task
    can run concurrently with other tasks. It is important that the output of each
    task is in the same order as the input. If the order does not matter, then a parallel
    loop can be performed. When the order matters and we don't want to wait until
    all items have completed task A before the items start executing task B, then
    a Pipeline implementation is perfect.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 管道设计在并行设计中非常有用，当你可以将应用程序分解为一系列要执行的任务时，这样每个任务都可以与其他任务并发运行。每个任务输出的顺序必须与输入相同。如果顺序不重要，则可以执行并行循环。当顺序很重要，我们不想在项目开始执行任务B之前等待所有项目完成任务A时，管道实现就非常完美。
- en: Some applications that lend themselves to pipelining are video streaming, compression,
    and encryption. In each of these examples, we need to perform a set of tasks on
    the data and preserve the data's order, but we do not want to wait for each item
    of data to perform a task before any of the data can perform the next task.
  id: totrans-12
  prefs: []
  type: TYPE_NORMAL
  zh: 一些适合管道化的应用程序包括视频流、压缩和加密。在每个例子中，我们需要对数据进行一系列任务，并保留数据的顺序，但我们不希望在数据执行下一个任务之前等待每个数据项执行任务。
- en: The key class that .NET has provided for implementing this design pattern is
    `BlockingCollection` of the `System.Collections.Concurrent` namespace. The `BlockingCollection`
    class was introduced with .NET 4.5\. It is a thread-safe collection specifically
    designed for producer-consumer and Pipeline design patterns. It supports concurrently
    adding and removing items by multiple threads to and from the collection. It also
    has methods to add and remove that block when the collection is full or empty.
    You can specify a maximum collection size to ensure a producing task that outpaces
    a consuming task does not make the queue too large. It supports cancellation tokens.
    Finally, it supports enumerations so that you can use the `foreach` loop when
    processing items of the collection.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: .NET 为实现此设计模式提供的键类是 `System.Collections.Concurrent` 命名空间中的 `BlockingCollection`。`BlockingCollection`
    类是在 .NET 4.5 中引入的。它是一个线程安全的集合，专门为生产者-消费者和管道设计模式设计。它支持多个线程同时向集合中添加和移除项目。它还具有在集合满或空时阻塞添加和移除的方法。您可以指定最大集合大小，以确保超出消费者任务的生产者任务不会使队列过大。它支持取消令牌。最后，它支持枚举，这样您就可以在处理集合的项目时使用
    `foreach` 循环。
- en: A producer of items to the collection can call the `CompleteAdding` method when
    the last item of data has been added to the collection. Until this method is called
    if a consumer is consuming items from the collection with a `foreach` loop and
    the collection is empty, it will block until an item is put into the collection
    instead of ending the loop.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 向集合添加项目的生产者可以在将数据文件的最后一个项目添加到集合时调用 `CompleteAdding` 方法。在此方法被调用之前，如果消费者使用 `foreach`
    循环从集合中消费项目，并且集合为空，它将阻塞，直到将项目放入集合而不是结束循环。
- en: 'Next, we will see a simple example of a Pipeline design implementation using
    an encryption program. This program will implement three stages in our pipeline.
    The first stage will read a text file character-by-character and place each character
    into a buffer (`BlockingCollection`). The next stage will read each character
    out of the buffer and encrypt it by adding 1 to its ASCII number. It will then
    place the new character into our second buffer and write it to an encryption file.
    Our final stage will read the character out of the second buffer, decrypt it to
    its original character, and write it out to a new file and to the screen. As you
    will see, stages 2 and 3 will start processing characters before stage 1 has finished
    reading all the characters from the input file. And all of this will be done while
    maintaining the order of the characters so that the final output file is identical
    to the input file:'
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们将看到一个使用加密程序实现的简单管道设计实现的例子。这个程序将在我们的管道中实现三个阶段。第一个阶段将逐字符读取文本文件，并将每个字符放入缓冲区（`BlockingCollection`）。下一个阶段将读取缓冲区中的每个字符，通过将其
    ASCII 编号加 1 来加密它。然后，它将新字符放入我们的第二个缓冲区，并将其写入加密文件。我们的最终阶段将读取第二个缓冲区中的字符，将其解密回原始字符，并将其写入新文件和屏幕。正如您将看到的，阶段
    2 和 3 将在阶段 1 完成从输入文件读取所有字符之前开始处理字符。所有这些都将保持字符的顺序，以确保最终输出文件与输入文件相同：
- en: '![Pipeline design pattern](img/8321EN_09_01.jpg)'
  id: totrans-16
  prefs: []
  type: TYPE_IMG
  zh: '![管道设计模式](img/8321EN_09_01.jpg)'
- en: Let's get started.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们开始吧。
- en: How to do it
  id: totrans-18
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: 'First, let''s open up Visual Studio and create a new **Windows Presentation
    Foundation** (**WPF**) application named `PipeLineApplication` and perform the
    following steps:'
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，让我们打开 Visual Studio 并创建一个名为 `PipeLineApplication` 的新 **Windows Presentation
    Foundation** (**WPF**) 应用程序，并执行以下步骤：
- en: Create a new class called `Stages.cs`. Next, make sure it has the following
    `using` statements.
  id: totrans-20
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 创建一个名为 `Stages.cs` 的新类。接下来，确保它具有以下 `using` 语句。
- en: '[PRE0]'
  id: totrans-21
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'In the `MainWindow.xaml.cs` file, make sure the following `using` statements
    are present:'
  id: totrans-22
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在 `MainWindow.xaml.cs` 文件中，确保存在以下 `using` 语句：
- en: '[PRE1]'
  id: totrans-23
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE1]'
- en: 'Next, we will add a method for each of the three stages in our pipeline. First,
    we will create a method called `FirstStage`. It will take two parameters: one
    will be a `BlockingCollection` object that will be the output buffer of this stage,
    and the second will be a string pointing to the input data file. This will be
    a text file containing a couple of paragraphs of text to be encrypted. We will
    place this text file in the `projects` folder on `C:`. The `FirstStage` method
    will have the following code:'
  id: totrans-24
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将为我们的管道中的每个阶段添加一个方法。首先，我们将创建一个名为 `FirstStage` 的方法。它将接受两个参数：一个将是 `BlockingCollection`
    对象，它将是此阶段的输出缓冲区，另一个将是指向输入数据文件的字符串。这将是一个包含要加密的几段文本的文本文件。我们将把这个文本文件放在 `C:` 上的 `projects`
    文件夹中。`FirstStage` 方法将具有以下代码：
- en: '[PRE2]'
  id: totrans-25
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE2]'
- en: 'Next, we will add a method for the second stage called `StageWorker`. This
    method will not return any values and will take three parameters. One will be
    a `BlockingCollection` value that will be its input buffer, the second one will
    be the output buffer of the stage, and the final one will be a file path to store
    the encrypted text in a data file. The code for this method will look like this:'
  id: totrans-26
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个用于第二阶段的方法，命名为`StageWorker`。这个方法不会返回任何值，并接受三个参数。其中一个将是一个`BlockingCollection`值，它将是它的输入缓冲区，第二个将是一个阶段的输出缓冲区，最后一个将是一个文件路径，用于在数据文件中存储加密后的文本。这个方法的代码看起来像这样：
- en: '[PRE3]'
  id: totrans-27
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE3]'
- en: 'Now, we will add a method for the third and final stage of the Pipeline design.
    This method will be named `FinalStage`. It will not return any values and will
    take two parameters. One will be a `BlockingCollection` object that is the input
    buffer and the other will be a string pointing to an output data file. It will
    have the following code in it:'
  id: totrans-28
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们将为管道设计的第三和最后一个阶段添加一个方法。这个方法将被命名为`FinalStage`。它不会返回任何值，并接受两个参数。一个将是一个`BlockingCollection`对象，它是输入缓冲区，另一个将是指向输出数据文件的字符串。它将包含以下代码：
- en: '[PRE4]'
  id: totrans-29
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE4]'
- en: 'Now that we have methods for the three stages of our pipeline, let''s add a
    few utility methods. The first of these methods will be one that reads in the
    input data file and places each character in the data file in a `List` object.
    This method will take a string parameter that has a filename and will return a
    `List` object of characters. It will have the following code:'
  id: totrans-30
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经有了管道三个阶段的处理方法，让我们添加一些实用方法。这些方法中的第一个方法将用于读取输入数据文件，并将数据文件中的每个字符放置在一个`List`对象中。这个方法将接受一个包含文件名的字符串参数，并返回一个字符的`List`对象。它将具有以下代码：
- en: '[PRE5]'
  id: totrans-31
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'Now we will need a method to encrypt the characters. This will be a simple
    encryption method. The encryption method is not really important to this exercise.
    This exercise is designed to demonstrate the Pipeline design, not implement the
    world''s toughest encryption. This encryption will simply take each character
    and add one to its ASCII numerical value. The method will take a character type
    as an input parameter and return a character. The code for it will be as follows:'
  id: totrans-32
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个方法来加密字符。这将是一个简单的加密方法。加密方法对这个练习来说并不重要。这个练习旨在演示管道设计，而不是实现世界上最复杂的加密。这个加密方法将简单地取每个字符并将其ASCII数值加一。这个方法将接受一个字符类型作为输入参数并返回一个字符。它的代码如下：
- en: '[PRE6]'
  id: totrans-33
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'Now we will add one final method to the `Stages` class to decrypt a character
    value. It will simply do the reverse of the `encrypt` method. It will take the
    ASCII numerical value and subtract 1\. The code for this method will look like
    this:'
  id: totrans-34
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们将在`Stages`类中添加一个最终的方法来解密字符值。它将简单地是`encrypt`方法的逆操作。它将接受ASCII数值并减去1。这个方法的代码将如下所示：
- en: '[PRE7]'
  id: totrans-35
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE7]'
- en: 'Now that we are done with the `Stages` class, let''s switch our focus back
    to the `MainWindow.xaml.cs` file. First, you will need to add three `using` statements.
    They are for the `StreamReader`, `StreamWriter`, `Threads`, and `BlockingCollection`
    classes:'
  id: totrans-36
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在我们已经完成了`Stages`类，让我们将注意力转回`MainWindow.xaml.cs`文件。首先，你需要添加三个`using`语句。它们是为`StreamReader`、`StreamWriter`、`Threads`和`BlockingCollection`类：
- en: '[PRE8]'
  id: totrans-37
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE8]'
- en: 'At the top of the `MainWindow` class, we need four variables available for
    the whole class. We need three strings that point to our three data files—the
    input data, encrypted data, and output data. Then we will need a `Stages` object.
    These declarations will look like this:'
  id: totrans-38
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 在`MainWindow`类的顶部，我们需要四个在整个类中可用的变量。我们需要三个指向我们的三个数据文件的字符串——输入数据、加密数据和输出数据。然后我们还需要一个`Stages`对象。这些声明看起来像这样：
- en: '[PRE9]'
  id: totrans-39
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE9]'
- en: 'Then, in the `MainWindow` constructor method, right after the `InitializeComponent`
    call, add a line to instantiate our `Stages` object:'
  id: totrans-40
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，在`MainWindow`构造方法中，在`InitializeComponent`调用之后，添加一行来实例化我们的`Stages`对象：
- en: '[PRE10]'
  id: totrans-41
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE10]'
- en: 'Next, add a button to the `MainWindow.xaml` file that will initiate the pipeline
    and encryption. Name this button control `butEncrypt`, and set its `Content` property
    to `Encrypt File`. Next, add a click event handler for this button in the `MainWindow.xaml.cs`
    file. Its event handler method will be `butEncrypt_Click` and will contain the
    main code for this application. It will instantiate two `BlockingCollection` objects
    for two queues. One queue between stages 1 and 2, and one queue between stages
    2 and 3\. This method will then create a task for each stage that executes the
    corresponding methods from the `Stages` classes. It will then start these three
    tasks and wait for them to complete. Finally, it will write the output of each
    stage to the input, encrypted, and results data files and text blocks for viewing.
    The code for it will look like the following code:'
  id: totrans-42
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，向`MainWindow.xaml`文件添加一个按钮，该按钮将启动管道和加密。将这个按钮控件命名为`butEncrypt`，并将其`Content`属性设置为`加密文件`。接下来，在`MainWindow.xaml.cs`文件中为这个按钮添加一个点击事件处理程序。其事件处理方法将是`butEncrypt_Click`，并将包含此应用程序的主要代码。它将为两个队列实例化两个`BlockingCollection`对象。一个在阶段1和2之间，一个在阶段2和3之间。此方法将为每个阶段创建一个任务，该任务执行`Stages`类中的相应方法。然后，它将启动这三个任务并等待它们完成。最后，它将每个阶段的输出写入输入、加密和结果数据文件以及用于查看的文本块。其代码如下：
- en: '[PRE11]'
  id: totrans-43
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE11]'
- en: One last thing. Let's add three textblocks to display the outputs. We will call
    these `tbStage1`, `tbStage2`, and `tbStage3`. We will also add three label controls
    with the text `Input File`, `Encrypted File`, and `Output File`. These will be
    placed by the corresponding textblocks. Now, the `MainWindow.xaml` file should
    look like the following screenshot:![How to do it](img/8321EN_09_02.jpg)
  id: totrans-44
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 最后一件事情。让我们添加三个文本块来显示输出。我们将把这些文本块命名为`tbStage1`、`tbStage2`和`tbStage3`。我们还将添加三个带有文本`输入文件`、`加密文件`和`输出文件`的标签控件。这些将被放置在相应的文本块旁边。现在，`MainWindow.xaml`文件应该看起来像以下截图：![如何操作](img/8321EN_09_02.jpg)
- en: Now we will need an input data file to encrypt. We will call this file `InputData.txt`
    and put it in the `C:\projects` folder on our computer. For our example, we have
    added the following text to it:![How to do it](img/8321EN_09_03.jpg)
  id: totrans-45
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要一个输入数据文件来加密。我们将把这个文件命名为`InputData.txt`，并将其放在我们电脑上的`C:\projects`文件夹中。在我们的例子中，我们向其中添加了以下文本：![如何操作](img/8321EN_09_03.jpg)
- en: We are all finished and ready to try it out. Compile and run the application
    and you should have a window that looks like the following screenshot:![How to
    do it](img/8321EN_09_04.jpg)
  id: totrans-46
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 我们已经完成，准备尝试它。编译并运行应用程序，你应该会有一个看起来像以下截图的窗口：![如何操作](img/8321EN_09_04.jpg)
- en: Now, click on the **Encrypt File** button and you should see the following output:![How
    to do it](img/8321EN_09_05.jpg)
  id: totrans-47
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，点击**加密文件**按钮，你应该看到以下输出：![如何操作](img/8321EN_09_05.jpg)
- en: As you can see, the input and output files look the same and the encrypted file
    looks different. Remember that **Input File** is the text we put in the input
    data text file; this is the input from the end of stage 1 after we have read the
    file in to a character list. **Encrypted File** is the output from stage 2 after
    we have encrypted each character. **Output File** is the output of stage 3 after
    we have decrypted the characters again. It should match **Input File**.
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: 如您所见，输入和输出文件看起来相同，而加密文件看起来不同。请记住，**输入文件**是我们放入输入数据文本文件中的文本；这是我们在将文件读入字符列表后从第一阶段末端的输入。**加密文件**是在加密每个字符后的第二阶段的输出。**输出文件**是在再次解密字符后的第三阶段的输出。它应该与**输入文件**匹配。
- en: Now, let's take a look at how this works.
  id: totrans-49
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看它是如何工作的。
- en: How it works
  id: totrans-50
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: 'Let''s look at the `butEncrypt` click event handler method in the `MainWindow.xaml.cs`
    file, as this is where a lot of the action takes place. Let''s examine the following
    lines of code:'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们看看`MainWindow.xaml.cs`文件中的`butEncrypt`点击事件处理方法，因为这里发生了许多操作。让我们检查以下代码行：
- en: '[PRE12]'
  id: totrans-52
  prefs: []
  type: TYPE_PRE
  zh: '[PRE12]'
- en: First, we create two queues that are implemented using `BlockingCollection`
    objects. Each of these is set with a size of `20` items. These two queues take
    a character datatype.
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们创建两个队列，这两个队列使用`BlockingCollection`对象实现。每个队列的大小设置为`20`个项目。这两个队列接受字符数据类型。
- en: Then we create a `TaskFactory` object and use it to start three tasks. Each
    task uses a lambda expression that executes one of the stages methods from the
    `Stages` class—`FirstStage`, `StageWorker`, and `FinalStage`.
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个`TaskFactory`对象，并使用它来启动三个任务。每个任务使用一个lambda表达式来执行`Stages`类中的一个阶段方法——`FirstStage`、`StageWorker`和`FinalStage`。
- en: So, now we have three separate tasks running besides the main UI thread. `Stage1`
    will read the input data file character by character and place each character
    in the queue `Buffer1`. Remember that this queue can only hold 20 items before
    it will block the `FirstStage` method waiting on room in the queue. This is how
    we know that `Stage2` starts running before `Stage1` completes. Otherwise, `Stage1`
    will only queue the first 20 characters and then block.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们除了主UI线程外还有三个单独的任务在运行。`Stage1`将逐个字符读取输入数据文件，并将每个字符放入队列`Buffer1`。记住，这个队列在阻塞`FirstStage`方法等待队列中的空间之前只能容纳20个项目。这就是我们知道`Stage2`在`Stage1`完成之前就开始运行的原因。否则，`Stage1`只会排队前20个字符然后阻塞。
- en: 'Once `Stage1` has read all of the characters from the input file and placed
    them into `Buffer1`, it then makes the following call:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦`Stage1`从输入文件中读取了所有字符并将它们放入`Buffer1`，它随后会进行以下调用：
- en: '[PRE13]'
  id: totrans-57
  prefs: []
  type: TYPE_PRE
  zh: '[PRE13]'
- en: This lets the `BlockingCollection` instance, `Buffer1`, to know that there are
    no more items to be put in the queue. So, when `Stage2` has emptied the queue
    after `Stage1` has called this method, it will not block but will instead continue
    until completion. Prior to the `CompleteAdding` method call, `Stage2` will block
    if `Buffer1` is empty, waiting until more items are placed in the queue. This
    is why a `BlockingCollection` instance was developed for Pipeline and producer-consumer
    applications. It provides the perfect mechanism for this functionality.
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 这让`BlockingCollection`实例`Buffer1`知道没有更多的项目要放入队列中。因此，当`Stage2`在`Stage1`调用此方法后清空队列时，它不会阻塞，而是继续直到完成。在调用`CompleteAdding`方法之前，如果`Buffer1`为空，`Stage2`将阻塞，等待更多项目放入队列。这就是为什么为Pipeline和生产者-消费者应用程序开发了`BlockingCollection`实例。它提供了实现此功能的完美机制。
- en: 'When we created the `TaskFactory`, we used the following parameter:'
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 当我们创建`TaskFactory`时，我们使用了以下参数：
- en: '[PRE14]'
  id: totrans-60
  prefs: []
  type: TYPE_PRE
  zh: '[PRE14]'
- en: This tells the threadpool that these tasks may run for a long time and could
    occasionally block waiting on their queues. In this way, the threadpool can decide
    how to best manage the threads allocated for these tasks.
  id: totrans-61
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉线程池，这些任务可能需要运行很长时间，并且有时可能会在等待队列时阻塞。这样，线程池可以决定如何最好地管理分配给这些任务的线程。
- en: 'Now, let''s look at the code in `Stage2`—the `StageWorker` method. We need
    a way to remove items in an enumerable way so that we can iterate over the queues
    items with a `foreach` loop because we do not know how many items to expect. Also,
    since `BlockingCollection` objects support multiple consumers, we need a way to
    remove items that no other consumer might remove. We use this method of the `BlockingCollection`
    class:'
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看`Stage2`中的代码——`StageWorker`方法。我们需要一种以可枚举的方式移除项目的方法，这样我们就可以使用`foreach`循环遍历队列中的项目，因为我们不知道期望多少个项目。此外，由于`BlockingCollection`对象支持多个消费者，我们需要一种方法来移除其他消费者可能不会移除的项目。我们使用`BlockingCollection`类的以下方法：
- en: '[PRE15]'
  id: totrans-63
  prefs: []
  type: TYPE_PRE
  zh: '[PRE15]'
- en: This allows multiple consumers to remove items from a `BlockingCollection` instance
    while maintaining the order of the items. To further improve performance of this
    application (assuming we have enough available processing cores), we could create
    a fourth task that also runs the `StageWorker` method. So, then we would have
    two stages and two tasks running. This might be helpful if there are enough processing
    cores and stage 1 runs faster than stage 2\. If this happens, it will continually
    fill the queue and block until space becomes available. But if we run multiple
    stage 2 tasks, then we will be able to keep up with stage 1.
  id: totrans-64
  prefs: []
  type: TYPE_NORMAL
  zh: 这允许多个消费者从`BlockingCollection`实例中移除项目，同时保持项目的顺序。为了进一步提高应用程序的性能（假设我们有足够的可用处理核心），我们可以创建一个第四个任务，该任务也运行`StageWorker`方法。这样，我们就会有两个阶段和两个任务在运行。如果处理核心足够并且阶段1比阶段2运行得快，这可能是有帮助的。如果发生这种情况，它将不断填充队列并阻塞，直到空间可用。但如果我们运行多个阶段2任务，那么我们将能够跟上阶段1。
- en: 'Then, finally we have this line of code:'
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，最后我们有这一行代码：
- en: '[PRE16]'
  id: totrans-66
  prefs: []
  type: TYPE_PRE
  zh: '[PRE16]'
- en: 'This tells our button handler to wait until all of the tasks are complete.
    Once we have called the `CompleteAdding` method on each `BlockingCollection` instance
    and the buffers are then emptied, all of our stages will complete and the `TaskFactory.WaitAll`
    command will be satisfied and this method on the UI thread can complete its processing,
    which in this application is to update the UI and data files:'
  id: totrans-67
  prefs: []
  type: TYPE_NORMAL
  zh: 这告诉我们的按钮处理程序等待直到所有任务都完成。一旦我们在每个`BlockingCollection`实例上调用`CompleteAdding`方法，并且缓冲区被清空，所有阶段都将完成，`TaskFactory.WaitAll`命令将得到满足，并且UI线程上的此方法可以完成其处理，在这个应用程序中是更新UI和数据文件：
- en: '[PRE17]'
  id: totrans-68
  prefs: []
  type: TYPE_PRE
  zh: '[PRE17]'
- en: Next, experiment with longer running, more complex stages and multiple consumer
    stages. Also, try stepping through the application with the Visual Studio debugger
    using the techniques we learned in [Chapter 8](ch08.html "Chapter 8. Debugging
    Multithreaded Applications with Visual Studio"), *Debugging Multithreaded Applications
    with Visual Studio*. Make sure you understand the interaction between the stages
    and the buffers.
  id: totrans-69
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，尝试使用运行时间更长、更复杂阶段以及多个消费者阶段进行实验。此外，尝试使用我们在第 8 章[调试多线程应用程序](ch08.html "第 8
    章。使用 Visual Studio 调试多线程应用程序")中学习的技术，通过 Visual Studio 调试器逐步执行应用程序，该章名为《使用 Visual
    Studio 调试多线程应用程序》。确保你理解阶段和缓冲区之间的交互。
- en: Explaining message blocks
  id: totrans-70
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 解释消息块
- en: Let's talk for a minute about message blocks and the TPL. There is a new library
    that Microsoft has developed as part of the TPL, but it does not ship directly
    with .NET 4.5\. This library is called the TPL `Dataflow` library. It is located
    in the `System.Threading.Tasks.Dataflow` namespace. It comes with various dataflow
    components that assist in asynchronous concurrent applications where messages
    need to be passed between multiple tasks or the data needs to be passed when it
    becomes available, as in the case of a web camera streaming video.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 让我们花一分钟时间来谈谈消息块和 TPL。微软作为 TPL 的一部分开发了一个新的库，但它并不直接随 .NET 4.5 一起提供。这个库被称为 TPL
    `Dataflow` 库。它位于 `System.Threading.Tasks.Dataflow` 命名空间中。它包含各种数据流组件，这些组件有助于异步并发应用程序，在这些应用程序中，需要在多个任务之间传递消息，或者当数据可用时传递数据，例如网络摄像头流式传输视频。
- en: The `Dataflow` library's message blocks are very helpful for design patterns
    such as Pipeline and producer-consumer where you have multiple producers producing
    data that can be consumed by multiple consumers. The two that we will take a look
    at are `BufferBlock` and `ActionBlock`.
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: '`Dataflow` 库的消息块对于设计模式，如 Pipeline 和生产者-消费者模式非常有帮助，在这种模式中，有多个生产者生产数据，这些数据可以被多个消费者消费。我们将要探讨的两个是
    `BufferBlock` 和 `ActionBlock`。'
- en: The TPL `Dataflow` library contains classes to assist in message passing and
    parallelizing I/O-heavy applications that have a lot of throughput. It provides
    explicit control over how data is buffered and passed. Consider an application
    that asynchronously loads large binary files from storage and manipulates that
    data. Traditional programming requires that you use callbacks and synchronization
    classes, such as locks, to coordinate tasks and have access to data that is shared.
    By using the TPL `Dataflow` objects, you can create objects that process image
    files as they are read in from a disk location. You can set how data is handled
    when it becomes available. Because the CLR runtime engine manages dependencies
    between data, you do not have to worry about synchronizing access to shared data.
    Also, since the CLR engine schedules the work depending on the asynchronous arrival
    of data, the TPL `Dataflow` objects can improve performance by managing the threads
    the tasks run on.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: TPL `Dataflow` 库包含用于辅助消息传递和并行化 I/O 重量级应用的类，这些应用具有很高的吞吐量。它提供了对数据缓冲和传递的显式控制。考虑一个异步从存储中加载大型二进制文件并处理这些数据的应用程序。传统的编程要求你使用回调和同步类，如锁，来协调任务并访问共享数据。通过使用
    TPL `Dataflow` 对象，你可以创建在从磁盘位置读取时处理图像文件的对象。你可以设置数据可用时如何处理数据。由于 CLR 运行时引擎管理数据之间的依赖关系，因此你不必担心同步访问共享数据。此外，由于
    CLR 引擎根据数据的异步到达来调度工作，因此 TPL `Dataflow` 对象可以通过管理任务运行的线程来提高性能。
- en: In this section, we will cover two of these classes, `BufferBlock` and `ActionBlock`.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在本节中，我们将介绍这两个类，`BufferBlock` 和 `ActionBlock`。
- en: Tip
  id: totrans-75
  prefs:
  - PREF_H3
  type: TYPE_NORMAL
  zh: 小贴士
- en: The TPL `Dataflow` library (`System.Threading.Tasks.Dataflow`) does not ship
    with .NET 4.5\. To install `System.Threading.Tasks.Dataflow`, open your project
    in Visual Studio, select **Manage NuGet Packages** from under the **Project**
    menu and then search online for `Microsoft.Tpl.Dataflow`.
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: TPL `Dataflow` 库（`System.Threading.Tasks.Dataflow`）不随 .NET 4.5 一起提供。要安装 `System.Threading.Tasks.Dataflow`，请在
    Visual Studio 中打开你的项目，从 **项目** 菜单下选择 **管理 NuGet 包**，然后在网络上搜索 `Microsoft.Tpl.Dataflow`。
- en: BufferBlock
  id: totrans-77
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BufferBlock
- en: The `BufferBlock` object in the `Dataflow` library provides a buffer to store
    data. The syntax is, `BufferBlock<T>`. The `T` indicates that the datatype is
    generic and can be of any type. All static variables of this object type are guaranteed
    to be thread-safe. `BufferBlock` is an asynchronous message structure that stores
    messages in a first-in-first-out queue. Messages can be "posted" to the queue
    by multiple producers and "received" from the queue by multiple consumers.
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFlow`库中的`BufferBlock`对象提供了一个存储数据的缓冲区。其语法是`BufferBlock<T>`。`T`表示数据类型是泛型，可以是任何类型。该对象类型的所有静态变量都保证是线程安全的。`BufferBlock`是一个异步消息结构，以先进先出的队列存储消息。消息可以由多个生产者“发布”到队列中，也可以由多个消费者“接收”。'
- en: The TPL `DatafLow` library provides interfaces for three types of objects—source
    blocks, target blocks, and propagator blocks. `BufferBlock` is a general-purpose
    message block that can act as both a source and a target message buffer, which
    makes it perfect for a producer-consumer application design. To act as both a
    source and a target, it implements two interfaces defined by the TPL `Dataflow`
    library—`ISourceBlock<TOutput>` and `ITargetBlock<TOutput>`. So, in the application
    that we will develop in the *Producer-consumer design pattern* section of this
    chapter, you will see that the producer method implements `BufferBlock` using
    the `ITargetBlock` interface and the consumer implements `BufferBlock` with the
    `ISourceBlock` interface.
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: TPL `DataFlow`库提供了三种类型对象的接口——源块、目标块和传播器块。`BufferBlock`是一个通用消息块，可以作为源和目标消息缓冲区，这使得它非常适合生产者-消费者应用程序设计。为了同时作为源和目标，它实现了TPL
    `DataFlow`库定义的两个接口——`ISourceBlock<TOutput>`和`ITargetBlock<TOutput>`。因此，在我们将在本章“生产者-消费者设计模式”部分开发的应用程序中，您将看到生产者方法使用`ITargetBlock`接口实现`BufferBlock`，而消费者使用`ISourceBlock`接口实现`BufferBlock`。
- en: This will be the same `BufferBlock` object that they will act on but by defining
    their local objects with a different interface there will be different methods
    available to use. The producer method will have `Post` and `Complete` methods,
    and the consumer method will use the `OutputAvailableAsync` and `Receive` methods.
  id: totrans-80
  prefs: []
  type: TYPE_NORMAL
  zh: 这将是他们将要操作的同一个`BufferBlock`对象，但通过定义具有不同接口的本地对象，将会有不同的方法可供使用。生产者方法将有`Post`和`Complete`方法，而消费者方法将使用`OutputAvailableAsync`和`Receive`方法。
- en: The `BufferBlock` object only has two properties, namely `Count`, which is a
    count of the number of data messages in the queue, and `Completion`, which gets
    a task that is an asynchronous operation and completion of the message block.
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferBlock`对象仅有两个属性，即`Count`，它表示队列中数据消息的数量，以及`Completion`，它获取一个异步操作和消息块完成的任务。'
- en: 'The following is a set of methods for this class:'
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 以下是这个类的几个方法：
- en: '![BufferBlock](img/8321EN_09_06.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![BufferBlock](img/8321EN_09_06.jpg)'
- en: Referenced from http://msdn.microsoft.com/en-us/library/hh160414(v=vs.110).aspx
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 参考自 http://msdn.microsoft.com/en-us/library/hh160414(v=vs.110).aspx
- en: 'Here is a list of the extension methods provided by the interfaces that it
    implements:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 这里是它所实现的接口提供的一组扩展方法列表：
- en: '![BufferBlock](img/8321EN_09_07.jpg)![BufferBlock](img/8321EN_09_08.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![BufferBlock](img/8321EN_09_07.jpg)![BufferBlock](img/8321EN_09_08.jpg)'
- en: Referenced from http://msdn.microsoft.com/en-us/library/hh160414(v=vs.110).aspx
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 参考自 http://msdn.microsoft.com/en-us/library/hh160414(v=vs.110).aspx
- en: 'Finally, here are the interface references for this class:'
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，以下是这个类的接口引用：
- en: '![BufferBlock](img/8321EN_09_09.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![BufferBlock](img/8321EN_09_09.jpg)'
- en: Referenced from http://msdn.microsoft.com/en-us/library/hh160414(v=vs.110).aspx
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 参考自 http://msdn.microsoft.com/en-us/library/hh160414(v=vs.110).aspx
- en: So, as you can see, these interfaces make using the `BufferBlock` object as
    a general-purpose queue between stages of a pipeline very easy. This technique
    is also useful between producers and consumers in a producer-consumer design pattern.
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，正如您所看到的，这些接口使得在管道的各个阶段之间使用`BufferBlock`对象作为通用队列变得非常容易。这种技术在生产者-消费者设计模式中，生产者和消费者之间也非常有用。
- en: ActionBlock
  id: totrans-92
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: ActionBlock
- en: 'Another very useful object in the `Dataflow` library is `ActionBlock`. Its
    syntax is `ActionBlock<TInput>`, where `TInput` is an `Action` object. `ActionBlock`
    is a target block that executes a delegate when a message of data is received.
    The following is a very simple example of using an `ActionBlock`:'
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: '`DataFlow`库中的另一个非常有用的对象是`ActionBlock`。其语法是`ActionBlock<TInput>`，其中`TInput`是一个`Action`对象。`ActionBlock`是一个目标块，在接收到数据消息时执行一个委托。以下是一个使用`ActionBlock`的非常简单的示例：'
- en: '[PRE18]'
  id: totrans-94
  prefs: []
  type: TYPE_PRE
  zh: '[PRE18]'
- en: In this sample piece of code, the `ActionBlock` object is created with an integer
    parameter and executes a simple lambda expression that does a `Console.WriteLine`
    when a message of data is posted to the buffer. So, when the `action.Post(10)`
    command is executed, the integer, `10`, is posted to the `ActionBlock` buffer
    and then the `ActionBlock` delegate, implemented as a lambda expression in this
    case, is executed.
  id: totrans-95
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个示例代码片段中，`ActionBlock`对象使用一个整数参数创建，并在将数据消息发布到缓冲区时执行一个简单的lambda表达式，该表达式执行`Console.WriteLine`。因此，当执行`action.Post(10)`命令时，整数`10`被发布到`ActionBlock`缓冲区，然后执行`ActionBlock`委托，在这种情况下实现为一个lambda表达式。
- en: In this example, since this is a target block, we would then need to call the
    `Complete` method to ensure the message block is completed.
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 在这个例子中，由于这是一个目标块，我们随后需要调用`Complete`方法以确保消息块完成。
- en: Another handy method of the `BufferBlock` is the `LinkTo` method. This method
    allows you to link `ISourceBlock` to `ITargetBlock`. So, you can have a `BufferBlock`
    that is implemented as an `ISourceBlock` and link it to an `ActionBlock` since
    it is an `ITargetBlock`. In this way, an `Action` delegate can be executed when
    a `BufferBlock` receives data. This does not dequeue the data from the message
    block. It just allows you to execute some task when data is received into the
    buffer.
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: '`BufferBlock`的另一个方便的方法是`LinkTo`方法。此方法允许您将`ISourceBlock`链接到`ITargetBlock`。因此，您可以有一个实现为`ISourceBlock`的`BufferBlock`，并将其链接到`ActionBlock`，因为它是`ITargetBlock`。这样，当`BufferBlock`接收到数据时，可以执行`Action`委托。这不会从消息块中出队数据。它只是允许您在数据被接收进入缓冲区时执行一些任务。'
- en: '`ActionBlock` only has two properties, namely `InputCount`, which is a count
    of the number of data messages in the queue, and `Completion`, which gets a task
    that is an asynchronous operation and completion of the message block. It has
    the following methods:'
  id: totrans-98
  prefs: []
  type: TYPE_NORMAL
  zh: '`ActionBlock`只有两个属性，即`InputCount`，它是队列中数据消息数量的计数，以及`Completion`，它获取一个异步操作和消息块完成的任务。它有以下方法：'
- en: '![ActionBlock](img/8321EN_09_10.jpg)'
  id: totrans-99
  prefs: []
  type: TYPE_IMG
  zh: '![ActionBlock](img/8321EN_09_10.jpg)'
- en: Referenced from http://msdn.microsoft.com/en-us/library/hh194684(v=vs.110).aspx
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 参考自 http://msdn.microsoft.com/en-us/library/hh194684(v=vs.110).aspx
- en: 'The following extension methods are implemented from its interfaces:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 从其接口实现了以下扩展方法：
- en: '![ActionBlock](img/8321EN_09_11.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![ActionBlock](img/8321EN_09_11.jpg)'
- en: Referenced from http://msdn.microsoft.com/en-us/library/hh194684(v=vs.110).aspx
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 参考自 http://msdn.microsoft.com/en-us/library/hh194684(v=vs.110).aspx
- en: 'Also, it implements the following interfaces:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，它实现了以下接口：
- en: '![ActionBlock](img/8321EN_09_12.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![ActionBlock](img/8321EN_09_12.jpg)'
- en: Referenced from http://msdn.microsoft.com/en-us/library/hh194684(v=vs.110).aspx
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 参考自 http://msdn.microsoft.com/en-us/library/hh194684(v=vs.110).aspx
- en: Now that we have examined a little of the `Dataflow` library that Microsoft
    has developed, let's use it in a producer-consumer application.
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 现在我们已经稍微了解了微软开发的`Dataflow`库，让我们在生产者-消费者应用程序中使用它。
- en: Producer-consumer design pattern
  id: totrans-108
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 生产者-消费者设计模式
- en: Now, that we have covered the TPL's `Dataflow` library and the set of objects
    it provides to assist in asynchronous message passing between concurrent tasks,
    let's take a look at the producer-consumer design pattern. In a typical producer-consumer
    design, we have one or more producers putting data into a queue or message data
    block. Then we have one or more consumers taking data from the queue and processing
    it. This allows for asynchronous processing of data. Using the `Dataflow` library
    objects, we can create a consumer task that monitors a `BufferBlock` and pulls
    items of the data from it when they arrive. If no items are available, the consumer
    method will block until items are available or the `BufferBlock` has been set
    to `Complete`. Because of this, we can start our consumer at any time, even before
    the producer starts to put items into the queue.
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们已经介绍了TPL的`Dataflow`库以及它提供的对象集合，以帮助在并发任务之间进行异步消息传递，让我们来看看生产者-消费者设计模式。在典型的生产者-消费者设计中，我们有一个或多个生产者将数据放入队列或消息数据块中。然后我们有一个或多个消费者从队列中取出数据并处理它。这允许异步处理数据。使用`Dataflow`库对象，我们可以创建一个消费者任务，该任务监控一个`BufferBlock`，并在数据到达时从中拉取数据项。如果没有可用的项目，消费者方法将阻塞，直到有项目可用或`BufferBlock`被设置为`Complete`。正因为如此，我们可以在任何时间启动我们的消费者，甚至在生产者开始将项目放入队列之前。
- en: Then we create one or more tasks that produce items and place them into the
    `BufferBlock`. Once the producers are finished processing all items of data to
    the `BufferBlock`, they can mark the block as `Complete`. Until then, the `BufferBlock`
    object is still available to add items into. This is perfect for long-running
    tasks and applications when we do not know when the data will arrive.
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们创建一个或多个任务来产生项目并将它们放入`BufferBlock`中。一旦生产者完成处理所有数据项到`BufferBlock`，它们可以标记块为`Complete`。在此之前，`BufferBlock`对象仍然可用于添加项目。这对于长时间运行的任务和应用程序来说非常完美，因为我们不知道数据何时到达。
- en: Because the producer task is implementing an input parameter of a `BufferBlock`
    as an `ITargetBlock` object and the consumer task is implementing an input parameter
    of a `BufferBlock` as an `ISourceBlock`, they can both use the same `BufferBlock`
    object but have different methods available to them. One has methods to produces
    items to the block and mark it complete. The other one has methods to receive
    items and wait for more items until the block is marked complete. In this way,
    the `Dataflow` library implements the perfect object to act as a queue between
    our producers and consumers.
  id: totrans-111
  prefs: []
  type: TYPE_NORMAL
  zh: 因为生产者任务正在实现一个`BufferBlock`的输入参数作为`ITargetBlock`对象，而消费者任务正在实现一个`BufferBlock`的输入参数作为`ISourceBlock`，它们都可以使用同一个`BufferBlock`对象，但它们有不同的方法可用。一个有方法向块中产生项目并标记它完成。另一个有方法接收项目并等待更多项目，直到块被标记为完成。这样，`Dataflow`库实现了作为我们生产者和消费者之间队列的完美对象。
- en: Now, let's take a look at the application we developed previously as a Pipeline
    design and modify it using the `Dataflow` library. We will also remove a stage
    so that it just has two stages, one producer and one consumer.
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看我们之前作为管道设计开发的应用程序，并使用`Dataflow`库对其进行修改。我们还将删除一个阶段，使其只有两个阶段，一个生产者和一个消费者。
- en: How to do it
  id: totrans-113
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 如何做到这一点
- en: The first thing we need to do is open Visual Studio and create a new console
    application called `ProducerConsumerConsoleApp`. We will use a console application
    this time just for ease. Our main purpose here is to demonstrate how to implement
    the producer-consumer design pattern using the TPL `Dataflow` library.
  id: totrans-114
  prefs: []
  type: TYPE_NORMAL
  zh: 我们需要做的第一件事是打开Visual Studio并创建一个名为`ProducerConsumerConsoleApp`的新控制台应用程序。我们这次使用控制台应用程序只是为了方便。我们在这里的主要目的是演示如何使用TPL
    `Dataflow`库实现生产者-消费者设计模式。
- en: 'Once you have opened Visual Studio and created the project, we need to perform
    the following steps:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦你打开了Visual Studio并创建了项目，我们需要执行以下步骤：
- en: First, we need to install and add a reference to the TPL `Dataflow` library.
    The TPL `Dataflow` library (`System.Threading.Tasks.Dataflow`) does not ship with
    .NET 4.5\. Select **Manage NuGet Packages** from under the **Project** menu and
    then search online for `Microsoft.Tpl.Dataflow`.
  id: totrans-116
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 首先，我们需要安装并添加对TPL `Dataflow`库的引用。TPL `Dataflow`库（`System.Threading.Tasks.Dataflow`）不随.NET
    4.5一起提供。从**项目**菜单下选择**管理NuGet包**，然后在网络上搜索`Microsoft.Tpl.Dataflow`。
- en: 'Now, we will need to add two `using` statements to our program. One for `StreamReader`
    and `StreamWriter` and one for the `BufferBlock` object:'
  id: totrans-117
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，我们需要在我们的程序中添加两个`using`语句。一个用于`StreamReader`和`StreamWriter`，另一个用于`BufferBlock`对象：
- en: '[PRE19]'
  id: totrans-118
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE19]'
- en: 'Now, let''s add two static strings that will point to our input data file and
    the encrypted data file that we output:'
  id: totrans-119
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 现在，让我们添加两个静态字符串，它们将指向我们的输入数据文件和输出的加密数据文件：
- en: '[PRE20]'
  id: totrans-120
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE20]'
- en: 'Next, let''s add a static method that will act as our producer. This method
    will have the following code:'
  id: totrans-121
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，让我们添加一个静态方法，它将充当我们的生产者。这个方法将具有以下代码：
- en: '[PRE21]'
  id: totrans-122
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE21]'
- en: 'Then we will add a static method to perform our consumer functionality. It
    will have the following code:'
  id: totrans-123
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们将添加一个静态方法来执行我们的消费者功能。它将具有以下代码：
- en: '[PRE22]'
  id: totrans-124
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE22]'
- en: 'Then, let''s create a simple static helper method to read our input data file
    and put it in a `List` collection character by character. This will give us a
    character list for our producer to use. The code in this method will look like
    this:'
  id: totrans-125
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，让我们创建一个简单的静态辅助方法来读取我们的输入数据文件，并将其逐字符放入一个`List`集合中。这将为我们提供生产者使用的字符列表。这个方法中的代码将看起来像这样：
- en: '[PRE23]'
  id: totrans-126
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE23]'
- en: 'Next, we will add a static method to encrypt our characters. This method will
    work like the one we used in our pipelining application. It will add one to the
    ASCII numerical value of the character:'
  id: totrans-127
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 接下来，我们将添加一个静态方法来加密我们的字符。这个方法将像我们在管道应用程序中使用的那样工作。它将字符的ASCII数值加一：
- en: '[PRE24]'
  id: totrans-128
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE24]'
- en: 'Then, we need to add the code for our `Main` method. This method will start
    our consumer and producer tasks. Then, when they have completed processing, it
    will display the results in the console. The code for this method looks like this:'
  id: totrans-129
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 然后，我们需要为我们的`Main`方法添加代码。此方法将启动消费者和生产者任务。然后，当它们完成处理时，它将在控制台显示结果。此方法的代码如下所示：
- en: '[PRE25]'
  id: totrans-130
  prefs:
  - PREF_IND
  type: TYPE_PRE
  zh: '[PRE25]'
- en: That is all the code that is needed. Now, let's build and run the application
    using the following input data file:![How to do it](img/8321EN_09_13.jpg)
  id: totrans-131
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 这就是所需的全部代码。现在，让我们使用以下输入数据文件构建和运行应用程序：![如何操作](img/8321EN_09_13.jpg)
- en: Once it runs and completes, your output should look like the following screenshot:![How
    to do it](img/8321EN_09_14.jpg)
  id: totrans-132
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
  zh: 一旦运行并完成，你的输出应该看起来像以下截图：![如何操作](img/8321EN_09_14.jpg)
- en: Now, try this with your own data files and inputs. Let's examine what happened
    and how this works.
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，尝试使用你自己的数据文件和输入进行操作。让我们检查发生了什么以及它是如何工作的。
- en: How it works
  id: totrans-134
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 它是如何工作的
- en: First we will go through the `Main` method. The first thing `Main` does is create
    a `BufferBlock` object called `buffer`. This will be used as the queue of items
    between our producer and consumer. This `BufferBlock` is defined to accept character
    datatypes.
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，我们将通过`Main`方法。`Main`首先做的事情是创建一个名为`buffer`的`BufferBlock`对象。这将用作生产者和消费者之间项目的队列。此`BufferBlock`被定义为接受字符数据类型。
- en: 'Next, we start our consumer task using this command:'
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们使用以下命令开始我们的消费者任务：
- en: '[PRE26]'
  id: totrans-137
  prefs: []
  type: TYPE_PRE
  zh: '[PRE26]'
- en: 'Also, note that when this buffer object goes into the consumer task, it is
    cast as `ISourceBlock`. Notice the method header of our consumer:'
  id: totrans-138
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，当此缓冲区对象进入消费者任务时，它被强制转换为`ISourceBlock`。注意我们消费者的方法头：
- en: '[PRE27]'
  id: totrans-139
  prefs: []
  type: TYPE_PRE
  zh: '[PRE27]'
- en: 'Next, our `Main` method starts our producer task using the following command:'
  id: totrans-140
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们的`Main`方法使用以下命令启动我们的生产者任务：
- en: '[PRE28]'
  id: totrans-141
  prefs: []
  type: TYPE_PRE
  zh: '[PRE28]'
- en: 'Then we wait until our consumer task finishes, using this command:'
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 然后，我们等待消费者任务完成，使用以下命令：
- en: '[PRE29]'
  id: totrans-143
  prefs: []
  type: TYPE_PRE
  zh: '[PRE29]'
- en: 'So, now our `Main` method just waits. Its work is done for now. It has started
    both the producer and consumer tasks. Now our consumer is waiting for items to
    appear in its `BufferBlock` so it can process them. The consumer will stay in
    the following loop until all items are removed from the message block and the
    block has been *completed*, which is done by someone calling its `Complete` method:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们的`Main`方法只是等待。它目前的工作已经完成。它已经启动了生产者和消费者任务。现在我们的消费者正在等待其`BufferBlock`中出现项目，以便它可以处理它们。消费者将保持在以下循环中，直到消息块中的所有项目都被移除并且块已被*完成*，这是通过有人调用其`Complete`方法来完成的：
- en: '[PRE30]'
  id: totrans-145
  prefs: []
  type: TYPE_PRE
  zh: '[PRE30]'
- en: 'So, now our consumer task will loop asynchronously, removing items from the
    message queue as they appear. It uses the following command in the while loop
    to do this:'
  id: totrans-146
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，现在我们的消费者任务将异步循环，在项目出现在消息队列时从队列中移除项目。它在while循环中使用以下命令来完成此操作：
- en: '[PRE31]'
  id: totrans-147
  prefs: []
  type: TYPE_PRE
  zh: '[PRE31]'
- en: 'Likewise, other consumer tasks can run at the same time and do the same thing.
    If the producer is adding items to the block quicker than the consumer can process
    them, then adding another consumer will improve performance. Once an item is available,
    then the consumer calls the following command to get the item from the buffer:'
  id: totrans-148
  prefs: []
  type: TYPE_NORMAL
  zh: 同样，其他消费者任务可以同时运行并执行相同的事情。如果生产者添加项目到块的速度比消费者处理它们快，那么添加另一个消费者将提高性能。一旦有项目可用，消费者将调用以下命令从缓冲区获取项目：
- en: '[PRE32]'
  id: totrans-149
  prefs: []
  type: TYPE_PRE
  zh: '[PRE32]'
- en: 'Since the buffer contains items of type character, we place the item received
    into a character value. Then the consumer processes it by encrypting the character
    and appending it to our display string:'
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 由于缓冲区包含字符类型的项目，我们将接收到的项目放入字符值中。然后消费者通过加密字符并将其附加到我们的显示字符串中来处理它：
- en: 'Now, let''s look at the consumer. The consumer first gets its data by calling
    the following command:'
  id: totrans-151
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，让我们看看消费者。消费者首先通过调用以下命令获取其数据：
- en: '[PRE33]'
  id: totrans-152
  prefs: []
  type: TYPE_PRE
  zh: '[PRE33]'
- en: 'This method returns a `List` collection of characters that has an item for
    each character in the input data file. Now the producer iterates through the collection
    and uses the following command to place each item into the buffer block:'
  id: totrans-153
  prefs: []
  type: TYPE_NORMAL
  zh: 此方法返回一个包含输入数据文件中每个字符的`List`集合。现在生产者遍历集合，并使用以下命令将每个项目放入缓冲区块：
- en: '[PRE34]'
  id: totrans-154
  prefs: []
  type: TYPE_PRE
  zh: '[PRE34]'
- en: 'Also, notice in the method header for our consumer that we cast our buffer
    as an `ITargetBlock` type:'
  id: totrans-155
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，请注意，在我们的消费者方法头中，我们将缓冲区强制转换为`ITargetBlock`类型：
- en: '[PRE35]'
  id: totrans-156
  prefs: []
  type: TYPE_PRE
  zh: '[PRE35]'
- en: 'Once the producer is done processing characters and adding them to the buffer,
    it officially closes the `BufferBlock` object using this command:'
  id: totrans-157
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦生产者完成处理字符并将它们添加到缓冲区，它将正式使用以下命令关闭`BufferBlock`对象：
- en: '[PRE36]'
  id: totrans-158
  prefs: []
  type: TYPE_PRE
  zh: '[PRE36]'
- en: 'That is it for the producer and consumer. Once the `Main` method is done waiting
    on the consumer to finish, it then uses the following code to write out the number
    of characters processed, the input data, and the encrypted data:'
  id: totrans-159
  prefs: []
  type: TYPE_NORMAL
  zh: 生产者和消费者的内容到此结束。一旦`Main`方法完成等待消费者完成，它随后使用以下代码来输出处理过的字符数、输入数据和加密数据：
- en: '[PRE37]'
  id: totrans-160
  prefs: []
  type: TYPE_PRE
  zh: '[PRE37]'
- en: Now that you are comfortable implementing a basic producer-consumer design using
    objects from the TPL `Dataflow` library, try experimenting with this basic idea
    but use multiple producers and multiple consumers all with the same `BufferBlock`
    object as the queue between them all.
  id: totrans-161
  prefs: []
  type: TYPE_NORMAL
  zh: 现在你已经熟悉使用TPL `Dataflow`库中的对象实现基本的生产者-消费者设计，尝试对这个基本想法进行实验，但使用多个生产者和多个消费者，它们之间都使用同一个`BufferBlock`对象作为队列。
- en: Also, try converting our original Pipeline application from the beginning of
    the chapter into a TPL `Dataflow` producer-consumer application with two sets
    of producers and consumers. The first will act as stage 1 and stage 2, and the
    second will act as stage 2 and stage 3\. So, in effect, stage 2 will be both a
    consumer and a producer.
  id: totrans-162
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，尝试将本章开头提到的原始管道应用程序转换为具有两套生产者和消费者的TPL `Dataflow`生产者-消费者应用程序。第一套将作为第1阶段和第2阶段，第二套将作为第2阶段和第3阶段。因此，实际上第2阶段将既是消费者又是生产者。
- en: Summary
  id: totrans-163
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 概述
- en: We have covered a lot in this chapter. We have learned the benefits and how
    to implement a Pipeline design pattern and a producer-consumer design pattern.
    As we saw, these are both very helpful design patterns when building parallel
    and concurrent applications that require multiple asynchronous processes of data
    between tasks.
  id: totrans-164
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们涵盖了大量的内容。我们学习了管道设计模式和生成者-消费者设计模式的好处以及如何实现它们。正如我们所见，这些都是在构建需要多个异步数据处理任务之间的并行和并发应用程序时非常有用的设计模式。
- en: In the Pipeline design, we are able to run multiple tasks or stages concurrently
    even though the stages rely on data being processed and output by other stages.
    This is very helpful for performance since all functionality doesn't have to wait
    on each stage to finish processing every item of data. In our example, we are
    able to start decrypting characters of data while a previous stage is still encrypting
    data and placing it into the queue.
  id: totrans-165
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道设计中，我们能够在多个任务或阶段之间并发运行，即使这些阶段依赖于其他阶段处理和输出数据。这对于性能非常有帮助，因为所有功能不需要等待每个阶段完成处理每个数据项。在我们的示例中，我们能够在前一个阶段仍在加密数据并将其放入队列的同时开始解密数据。
- en: In the Pipeline example, we examined the benefits of the `BlockingCollection`
    class in acting as a queue between stages in our pipeline.
  id: totrans-166
  prefs: []
  type: TYPE_NORMAL
  zh: 在管道示例中，我们探讨了`BlockingCollection`类在充当管道各阶段之间的队列时的优势。
- en: Next, we explored the new TPL `Dataflow` library and some of its messageblock
    classes. These classes implement several interfaces defined in the library—`ISourceBlock`,
    `ITargetBlock`, and `IPropogatorBlock`. By implementing these interfaces, it allows
    us to write generic producer and consumer task functionality that can be reused
    in a variety of applications.
  id: totrans-167
  prefs: []
  type: TYPE_NORMAL
  zh: 接下来，我们探讨了新的TPL `Dataflow`库及其一些消息块类。这些类实现了库中定义的几个接口——`ISourceBlock`、`ITargetBlock`和`IPropogatorBlock`。通过实现这些接口，它允许我们编写通用的生产者和消费者任务功能，这些功能可以在各种应用程序中重用。
- en: Both of these design patterns and the `Dataflow` library allow for easy implementations
    of common functionality in a concurrent manner. You will use these techniques
    in many applications, and this will become a go-to design pattern when you evaluate
    a system's requirements and determine how to implement concurrency to help improve
    performance. Like all programming, parallel programming is made easier when you
    have a toolbox of easy-to-use techniques that you are comfortable with.
  id: totrans-168
  prefs: []
  type: TYPE_NORMAL
  zh: 这两种设计模式和`Dataflow`库都允许以并发方式轻松实现常见功能。你将在许多应用中使用这些技术，当你在评估系统需求并确定如何实现并发以帮助提高性能时，这将成为一个首选的设计模式。就像所有编程一样，当你拥有一个易于使用且你感到舒适的工具箱时，并行编程会变得更加容易。
- en: Most applications that benefit from parallelism will be conducive to some variation
    of a producer-consumer or Pipeline pattern. Also, the `BlockingCollection` and
    `Dataflow` message block objects are useful mechanisms for coordinating data between
    parallel tasks, no matter what design pattern is used in the application. It will
    be very useful to become comfortable with these messaging and queuing classes.
  id: totrans-169
  prefs: []
  type: TYPE_NORMAL
  zh: 大多数从并行化中受益的应用程序将有利于某种形式的生成者-消费者或流水线模式。此外，`BlockingCollection`和`Dataflow`消息块对象是协调应用程序中数据之间的一种有用机制，无论使用何种设计模式。熟悉这些消息和队列类将非常有用。
- en: Now, we will move back to data parallelism in the next chapter, and this time,
    we will explore explicit data parallelism using PLINQ.
  id: totrans-170
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，我们将回到下一章的数据并行化，这次，我们将使用PLINQ来探索显式数据并行化。
