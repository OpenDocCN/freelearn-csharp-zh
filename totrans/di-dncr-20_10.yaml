- en: Dependency Injection in Other JavaScript Frameworks
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In [Chapter 9](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml), *Anti-Patterns and
    Misconceptions on Dependency Injection*, we covered the most important anti-patterns
    when using Dependency Injection, together with some typical misconceptions when
    it comes to how to use it. In this chapter, we're going to deal with Dependency
    Injection in other framework, specifically in TypeScript 2.3 and Angular 4+.
  prefs: []
  type: TYPE_NORMAL
- en: The reason for reviewing the very basics of TypeScript is that Angular 2+ uses
    this language, so we need some understanding of how class creation and module
    management is undertaken to really grasp the main concepts behind this architecture.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, we will cover:'
  prefs: []
  type: TYPE_NORMAL
- en: Class creation and module management in TypeScript 2.3+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native implementation and usage of DI techniques in AngularJS (version 1.x)
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Native implementation and customizable options to use DI in Angular 4+
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: You probably already know the role that TypeScript plays in the development
    of modern JavaScript frameworks, and even by itself as an improved replacement
    for JavaScript.
  prefs: []
  type: TYPE_NORMAL
- en: 'TypeScript has many times been defined as a strongly typed superset of JavaScript.
    It is a superset because it includes everything JavaScript has (and that extends
    to versions 3, 5, and 6, also called ES2015), plus a number of features to allow
    programmers to code in an object-oriented paradigm. At the time of writing, the
    latest version available is 2.3:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4c4122d3-ea45-48e1-b556-b0fd41235c5d.png)'
  prefs: []
  type: TYPE_IMG
- en: (Image courtesy: [http://blog.soat.fr/2016/08/feedback-typescript/](http://blog.soat.fr/2016/08/feedback-typescript/))
  prefs: []
  type: TYPE_NORMAL
- en: Consequently, we find many syntactical benefits while it still lets you write
    normal JavaScript if you want to (an important point is that any valid JavaScript
    is valid TypeScript).
  prefs: []
  type: TYPE_NORMAL
- en: In this way, TypeScript fosters a more declarative style of programming by using
    interfaces and static typing, it offers the concepts of modules and classes, and
    it's capable of integrating well with most existing JavaScript libraries and code.
    We can see it as a strongly static layer over JavaScript with a bunch of features
    to make the programmer's work (especially debugging) much more manageable.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to get a nice introduction to the TypeScript language, you can read
    *Introducing Object-Oriented Programming with TypeScript*, by Remo H. Jansen,
    (see [https://www.packtpub.com/books/content/introducing-object-oriented-programmng-typescript](https://www.packtpub.com/books/content/introducing-object-oriented-programmng-typescript))
    and, if you prefer to delve deeply into the language and its possibilities, take
    a look at the excellent *Mastering TypeScript* by Nathan Rozentals, available
    at [https://www.packtpub.com/web-development/mastering-typescript](https://www.packtpub.com/web-development/mastering-typescript).
  prefs: []
  type: TYPE_NORMAL
- en: 'The main goals of Anders Hejlsberg (the TypeScript Chief Architect) when creating
    the language were:'
  prefs: []
  type: TYPE_NORMAL
- en: Creating a totally object-oriented language that would convert into JavaScript
    at compilation time (it's called **transpilation** since it just produces another
    language and not a compiled module), allowing the final JavaScript generated to
    be executed in any browser (or Web platform).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Make the language statically typed, so the tools could offer modern development
    technologies in any editor: Intellisense, Code Completion, Intelligent Refactoring,
    and so on.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Engage the community in the project by making the language completely open source.
    You can see the current state of the project and collaborate on its website at [http://www.typescriptlang.org/](http://www.typescriptlang.org/).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Actually, TypeScript has been so successful that the Angular development team
    adopted it for the creation of Angular 2 and keeps on working with the language
    for coming versions (the most recent being Angular 4.1).
  prefs: []
  type: TYPE_NORMAL
- en: Architectural changes
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Understanding some architectural changes is fundamental to realize how you can
    implement DI in a language that, once transpiled, is not object-oriented, except
    if you are doing that transpilation into ES2015.
  prefs: []
  type: TYPE_NORMAL
- en: One of the biggest changes in ES2015 (or ES6, for short) is the presence of
    modules. A module is, basically, a piece of JavaScript code stored into a file.
    Once written, you can say that you have one file per module and one module per
    file.
  prefs: []
  type: TYPE_NORMAL
- en: Modules in TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'TypeScript defines two different types of modules--internal and external. Moreover,
    we could still differentiate internal ones into two more categories: those that
    have a name and those that don''t (you could call them implicit). The difference,
    in this case, is in the way you define them and use them.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Say you have a TypeScript file including the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: This code by itself is an implicit module. It becomes a part of the global namespace
    and you can find it inside the `window` object at runtime. You could also consider
    the global namespace as the implicit (default) module.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, we have better solutions than polluting the global namespace. The
    most obvious one is the `module` keyword which allows defining a private code
    section.
  prefs: []
  type: TYPE_NORMAL
- en: By definition, everything declared inside a module is private to that module.
    Therefore, the new reserved words `import` and `export` are used to allow access
    to a piece of code inside a named module.
  prefs: []
  type: TYPE_NORMAL
- en: 'If we wrap the previous class inside a module definition, any attempt to reference
    a module''s member outside the module is not recognized (see the following screenshot,
    inside the Visual Studio 2017 editor):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/0ff8b7b8-20d9-4ff5-9cae-58563dc37040.png)'
  prefs: []
  type: TYPE_IMG
- en: 'To make a module''s members available outside the module you should use the
    `export` keyword. Change the previous declaration into this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: 'Then, you can use the module''s name to access its public members:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Notice that the `ClassA.x` member is not accessible either due to its private
    declaration. In this manner, we have a convenient way to keep things tied to the
    namespace they should belong to.
  prefs: []
  type: TYPE_NORMAL
- en: External modules
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: However, the most useful approach when you're dealing with large applications
    is the use of external modules. Actually, as John Papa suggests ([https://johnpapa.net/typescriptpost4/](https://johnpapa.net/typescriptpost4/)),
    it may be useful to organize the functionality of an application in terms of the
    modules you'll need.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s say we have a module definition inside the `ES6Code.ts` file. To export
    the `foo()`function and `Timer` class, you declare them as follows:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: 'Now, in a distinct module or script section we can access that functionality
    using a slightly different reference:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: 'The same goes for the `Timer` class, except that we can also adopt another
    approach to reference the class:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: In this case, the module's name is used as a prefix to the class instantiation,
    in a similar way to what you find in C# code when dealing with namespaces.
  prefs: []
  type: TYPE_NORMAL
- en: 'To test this code, we just have to include references to the corresponding
    transpiled files (`.js` extension), inside an HTML page, or test it inside the
    Node console. For instance, if you use a blank HTML page, you could include the
    files in this manner:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'Note: The `<link>` tag is a fake favicon to prevent Chrome from presenting
    a File Not Found error in the console, next to the output.'
  prefs: []
  type: TYPE_NORMAL
- en: 'In both cases, the reference is correct, and the code is executed as expected,
    as we can see in the following screenshot (remember: `F12/Console` inside the
    developer''s tools of any modern browser. I''m using Chrome here):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4efb9134-695c-4612-b276-7070d1815d10.png)'
  prefs: []
  type: TYPE_IMG
- en: This is possible because, once the files are referenced inside a page, their
    members become accessible as long as they are marked as `export`.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, we can reference several files, and they'll be loaded and executed
    in sequence. Notice also that the console window indicates which code is responsible
    for the execution of which entry in the console.
  prefs: []
  type: TYPE_NORMAL
- en: 'In the initial example, `MyClasses` was stored inside the `app1.ts` file. So,
    now, we could also reference it, before the `</head>` tag, and check how a third
    source origin shows up in the console, which outputs the number 4, in the last
    position (check it in the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4ac5e5ae-8c88-4016-b656-f93411c52070.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Also, you''ll notice that Chrome is smart enough to reference the original
    `.ts` files and not the transpiled ones, allowing you to debug any of these files,
    setting breakpoints, and so on. In the following screenshot, I''m showing the
    debugging window inside Chrome after setting a breakpoint before printing the
    date and time values:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fcc46658-0505-44bf-821b-3009b34a7095.png)'
  prefs: []
  type: TYPE_IMG
- en: Besides these options, now it's possible to debug within Visual Studio 2017
    using Chrome as default browser.
  prefs: []
  type: TYPE_NORMAL
- en: This module separation is important because, as you'll see later, that implies
    file separation, which becomes crucial in the way TypeScript and, especially,
    Angular organize the distinct components of an application.
  prefs: []
  type: TYPE_NORMAL
- en: Dependency Injection in TypeScript
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: All that said, TypeScript itself doesn't have a DI container. However, you could
    use some of the third-party options available. Some of the most popular are `Infuse.js`
    (available at [https://github.com/soundstep/infuse.js](https://github.com/soundstep/infuse.js))
    and TypeScript IoC, which you can find on the NPMJS site ([https://www.npmjs.com/package/typescript-ioc](https://www.npmjs.com/package/typescript-ioc)),
    both of which work in a very similar way to what we've already seen in .NET Core.
  prefs: []
  type: TYPE_NORMAL
- en: That is, you have to make definitions that map an interface to a class or even
    a descriptor to a class and then register those options. Later on, you can make
    a reference to the type required and expect the DI container to provide you with
    the corresponding type.
  prefs: []
  type: TYPE_NORMAL
- en: Let's review the way TypeScript IoC works to define a simple injection scenario,
    the way it's shown on its official page.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, assuming you have TypeScript installed, you should also install TypeScript
    IoC, with a typical `npm` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Besides that, some modern options are also required inside the configuration
    file (the `tsconfig.json` file):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: 'Once that is configured, you use one of the `import` syntax variants to put
    it to work:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: As you can see, the `restProxy` property, which is of another type (`PersonRestProxy`),
    is marked with an `@Inject` decorator (a new feature in the latest versions of
    JavaScript and available in TypeScript), to indicate that it can be injected later
    on inside other code).
  prefs: []
  type: TYPE_NORMAL
- en: 'Somewhere else in the code, you''ll be able to use these definitions with a
    very simple syntax:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: 'The `restProxy` property will be provided by the container, resolving the dependencies.
    Parameter injection is also provided, using a class with a constructor, as we
    can see in the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: 'If, later on, you have another class that uses `PersonService` as a property,
    you mark that property with `@Inject`, like in this code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: You can rely on the chain of dependencies being managed by the container, which
    will go through all references previously marked as `@Inject`.
  prefs: []
  type: TYPE_NORMAL
- en: However, in practice, it's rare to see applications in TypeScript itself and
    the most common use of this language is to provide other frameworks, such as Angular
    or Ionic, with a consistent development language.
  prefs: []
  type: TYPE_NORMAL
- en: Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: As mentioned in [Chapter 2](9b8972f9-fedb-457b-a60a-8f62098bfa00.xhtml), *Dependency
    Injection and IoC Containers*, Angular is a development framework created by a
    team at Google (led by MiskoHevery), that has become very popular now (you can
    access the official information at [http://angularjs.org](http://angularjs.org)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Nowadays, Angular is available in two flavors that follow different release
    paths or branches:'
  prefs: []
  type: TYPE_NORMAL
- en: '**Version 1.x**:  Also called **AngularJS**. It''s recommended for small/medium
    applications and uses the MVC model to implement a suitable separation of concerns,
    from the beginning:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It's composed of a set of JavaScript libraries, each one supplying a part of
    the functionality required. However, all libraries depend on the basic AngularJS library.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: At the time of writing, the latest version is 1.6.4, and the team guarantees
    support and future updates. It can also be downloaded via CDN at [https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js](https://ajax.googleapis.com/ajax/libs/angularjs/1.6.4/angular.min.js).
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Version 2+**: It''s just named **Angular** and it follows a semantic versioning
    path, which means no breaking changes are allowed in minor revisions, only in
    new versions. There was a version number jump that avoided 3.0, so the latest
    version is Angular 4 (4.1, to be precise). It has a dedicated website apart from
    AngularJS at [https://angular.io/](https://angular.io/):'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Perhaps the biggest change is that Angular is not backward-compatible with AngularJS
    since it embraces a number of changes that appeared in ES6 and directly affects
    the way modules are managed.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Its main features are cross-compatibility, improved speed and performance, excellent
    tooling, and an increasing adoption by the community all over the world.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Angular is built in TypeScript thanks to a joint venture with Microsoft''s
    TypeScript team, which actively collaborates in the project. Recently, one of
    the lead members of the team announced: *TypeScript has become allowed for unrestricted
    client development as of March 2017\. TypeScript and Angular on TypeScript are
    used in Google Analytics, Firebase, and Google Cloud Platform and critical internal
    tools such as bug tracking, employee reviews, and product approval and launch
    tools*.'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Both versions have some points in common from an architectural point of view.
    They foster SOLID principles, and especially SRP and DIP, so they both rely on
    Dependency Injection containers. Furthermore, the adoption of the MVC model helps
    to structure the separation of concerns.
  prefs: []
  type: TYPE_NORMAL
- en: Let's see how these two popular architectures implement Dependency Injection
    (although in different ways).
  prefs: []
  type: TYPE_NORMAL
- en: AngularJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Creating a very basic Angular application is easy, once the basic principles
    of the MVC are clear. The MVC model proposes a foundational separation of application
    components into three parts (see the following figure):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/dabe33e4-815f-4207-adb1-a5d71c704cb4.png)'
  prefs: []
  type: TYPE_IMG
- en: '(Image courtesy: Wikipedia: [https://en.wikipedia.org/wiki/Model-view-controller](https://en.wikipedia.org/wiki/Model-view-controller))'
  prefs: []
  type: TYPE_NORMAL
- en: 'The user''s interaction generates a circuit in which the three pillars of MVC
    are present:'
  prefs: []
  type: TYPE_NORMAL
- en: The **MODEL** is created automatically in the loading process of the AngularJS
    library.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **VIEW** corresponds to the HTML side, which is marked with custom attributes
    (all starting with ***ng-***) to indicate the distinct functionality required.
    Views also use a syntax called **mustache** to indicate which parts are subject
    to data-binding.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: The **CONTROLLERS** are JavaScript fragments, coded to reflect any changes requested
    by the user, and manipulate the Model if required.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: When the user interacts with a UI element in the page, a controller takes care
    of the corresponding action, modifies the model if it is necessary, and Angular
    updates the view reflecting the changes. Finally, the view is received by the
    user and this cycle continues uninterruptedly.
  prefs: []
  type: TYPE_NORMAL
- en: Examples using Visual Studio 2017
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Once you have an HTML page that loads the AngularJS library, you should mark
    one DOM element with a special attribute (ng-app) to notify Angular of its working
    scope. This defines the area of action for AngularJS inside the page.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see all this in a very simple example. We can use Visual Studio 2017
    as well, for example creating a new website (notice that we don''t need a project
    since we don''t need any compiled code on the server: it all happens on the client
    side).'
  prefs: []
  type: TYPE_NORMAL
- en: So, I suggest choosing an ASP.NET Empty Website for this initial demo. That
    will create a folder to hold the solution and will include a `Web.config` file
    just in case you want to instruct the server about some behavior or require some
    compiled code as well.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, we add an HTML page and save the solution to be able to use the Manage
    NuGet packages option and search for the AngularJS.Core library. Make sure you''re
    selecting AngularJS.Core and not just angularjs if you don''t want to be overloaded
    with all available libraries for this framework (see the following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b2496a17-6026-47f4-9948-4c2e58998b24.png)'
  prefs: []
  type: TYPE_IMG
- en: Once installed, a new Scripts folder will show up in the Solution Explorer,
    including a few libraries. You just need to drag and drop the angular.js library
    inside the `<head>` tag, to let Visual Studio create a `<script>` tag pointing
    to the library and you're ready to go!
  prefs: []
  type: TYPE_NORMAL
- en: The next step is adding the `ng-app` attribute (for example, to the `<body>`
    tag) and giving it a valid name, such as `app`. Currently, we have a page, the
    angular library loaded, and a scope defined.
  prefs: []
  type: TYPE_NORMAL
- en: 'How can we see some AngularJS in action with this? We can create an HTML tag,
    such as `<h2>`, `<h3>`, `<div>`, `<article>,` and so on, and include a moustache
    link inside (they''re called AngularJS binding expressions) that should be resolved
    at runtime, for example, a `<h2>` tag that will show the current time. In all,
    up to this point, we should have a page like this:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: 'Observe the two identifiers (`app` and `time`) that are not defined yet. That
    will be our JavaScript section of this page. So, before the closing `</body>`
    tag, we will include an `<script>` tag with the following code:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'This needs some explanation: first, we create a `module` named `app`. That
    is an object managed by AngularJS to establish the DOM area of interest, and it
    is created by calling the `method` module on the `angular` object that the library
    created at loading time. We cache the return value in a variable of the same name
    just to make the following code a bit clearer.'
  prefs: []
  type: TYPE_NORMAL
- en: The next step is crucial. Here we create a controller called `TimeController` and
    assign a callback function to it. Well, that function is using Dependency Injection
    by default! If you notice the function's definition, there's a `$scope` variable
    defined. Where does it come from?
  prefs: []
  type: TYPE_NORMAL
- en: The explanation is that, in several angular's constructions, when you define
    a callback function and declare a recognizable service as a parameter (such as
    `$scope`), a singleton instance of that service is provided by the `$injector`
    object to you with no intervention on our own.
  prefs: []
  type: TYPE_NORMAL
- en: And it is precisely that `$injector` object that provides DI container services
    in AngularJS. Every object managed by a module has its own instance of that service
    and takes care of resolving all dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: 'The official AngularJS documentation defines its implementation in this way:'
  prefs: []
  type: TYPE_NORMAL
- en: The AngularJS injector subsystem is in charge of creating components, resolving
    their dependencies, and providing them to other components as requested.
  prefs: []
  type: TYPE_NORMAL
- en: Understanding the structure of AngularJS bootstrap
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'The following diagram shows the structure of the bootstrap process that takes
    place when loading an Angular app:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/fbb8428a-d617-418a-b24f-52f42df59c2f.png)'
  prefs: []
  type: TYPE_IMG
- en: 'The detailed explanation is this: HTML elements marked with attributes starting
    with `ng-` denote a part of the DOM called Dynamic DOM (where no `ng-` attributes
    are present, considered to be static DOM).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s briefly reproduce the steps used:'
  prefs: []
  type: TYPE_NORMAL
- en: When the DOM is loaded, AngularJS searches for a `ng-app`-marked element and
    defines a `$injector` linked to it.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'In turn, that injector defines a `$compile` service that teaches the HTML interpreter
    some new syntax. To be precise, the documentation explains this point by stating
    that:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*The compiler allows you to attach behavior to any HTML element or attribute
    and even create new HTML elements or attributes with custom behavior. AngularJS
    calls these behavior extensions directives.*'
  prefs: []
  type: TYPE_NORMAL
- en: With all that in memory, AngularJS also creates a special service called `$rootScope`,
    which serves as the root model for the module. Of course, you can use it as well
    in your own code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Now, every controller that you create has a child of that `$rootScope`, called
    simply `$scope`: that''s the section of the model that such a controller manages.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: As the last step, the `$compile` object traverses the module, searching for
    elements that have `ng-*` attributes, here called directives, or AngularJS expressions
    (`{{moustache}}` annotations), and substitutes those elements with the required
    data or code.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Consequently, the final aspect of our HTML code will be (I''m including only
    the contents of the `<body>` element):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: So, what I'm doing here is creating a model's variable (`time`) assigned to
    the controller named `TimeController`. Its value is equal to a string representing
    the current's system time.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, we need to indicate which AngularJS element is managed by which controller:
    in this case, it is the `<h2>` element containing the `time` variable defined
    in the model. At runtime, AngularJS substitutes the variable''s value for the
    `{{time}}` expression.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The output in the browser changes every time you refresh the page (see the
    following screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/85b8713d-4c16-4128-9c84-59c529808163.png)'
  prefs: []
  type: TYPE_IMG
- en: This is a very simple demo, but it illustrates the basics of AngularJS and how
    DI is pervasive throughout the framework since you'll find it all over.
  prefs: []
  type: TYPE_NORMAL
- en: Data access and Dependency Injection
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Actually, we can see a better implementation of a controller and how to use
    the `$injector` object if we access some real data using another AngularJS service,
    called `$http`.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following code reads all data from the `BookStore2.json` file that we used
    in [Chapter 9](58f9e2e8-6e57-473a-9ccf-89a9a90f1858.xhtml), *Anti-Patterns and
    Misconceptions on Dependency Injection*, demos and creates a list of its elements.
    I''ll show you the code first, and then we''ll move to the explanation:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Before commenting this out, let us note that I'm also using the BootStrap library,
    but that's only for presentation purposes; it has nothing to do with DI.
  prefs: []
  type: TYPE_NORMAL
- en: 'If you look at the previous code in any browser, it will present an output
    very similar to the one that''s shown in the following screenshot:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/8780a472-7196-42ea-973a-e4bcdc67b170.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Let''s review the most important changes in this code. On the JavaScript side:'
  prefs: []
  type: TYPE_NORMAL
- en: Module creation is not cached into a variable (this avoids unnecessary variables
    in the global space).
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The controller is created using a function expression assigned to a variable
    of the same name. It declares two variables to be injected later on:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$scope`: The reference to the model linked to the controller'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`$http`: A service that facilitates request/response actions with HTTP servers,
    either using the `XmlHttpRequest` object (AJAX) or JSONP inside AngularJS'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Inside the function, `$http` is used to get data by calling its `get` method
    and passing it the URL of the resource to recover. That call returns a promise,
    which is resolved asynchronously:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'When the promise is resolved, it returns the expected information, and the
    callback functions linked to it will receive an object with the following properties,
    according to the official site''s documentation:'
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`data{string|Object}`: The response body transformed with the transform functions'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`status{number}`: HTTP status code of the response'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`headers{function([headerName])}`: Header getter function'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`config{Object)`: The configuration object that was used to generate the request'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: '`statusText{string}`: HTTP status text of the response'
  prefs:
  - PREF_IND
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: If the status code is a number between 200 and 299, the process is successful,
    and a subsequent call to `.then()` receives the information inside its `[parameter].data`
    property
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: Otherwise (if you get a different status code) there's an error and you should
    catch it with an extra call to `.catch(),` just as we do in the preceding code
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The `$injector` object is able to resolve the names of the variables as singleton
    instances of the services they represent, but what happens when you package your
    application and the *minifiers* change the name of those variables? This is where
    the `$inject` array comes in:'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: It allows the *minifiers* to rename the function's parameters and still be able
    to inject the referred services. Notice that it is an array linked to the controller,
    and it can grow or shrink at will.
  prefs:
  - PREF_IND
  - PREF_UL
  type: TYPE_NORMAL
- en: 'The final step is to define the controller itself inside the module. That''s
    why we use the `angular.module("app")` syntax, which accesses the module and invokes
    the required methods inside (notice this time we don''t pass the second argument:
    that means to access, not creation).'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Of course, there is much more to AngularJS using DI and the framework itself,
    but I hope now have some idea of how Dependency Injection is implemented here.
    Let's summarize and complete the most important points about this pattern inside
    AngularJS.
  prefs: []
  type: TYPE_NORMAL
- en: Summing up Dependency Injection features inside AngularJS
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Dependency creation in AngularJS is the responsibility of the `injector` object.
    This object, by the way, uses the constructor injection paradigm. Actually, the
    injector behaves as a service locator that takes care of construction and look
    up for dependencies.
  prefs: []
  type: TYPE_NORMAL
- en: This is achieved using the declarative notation in HTML templates. When the
    HTML is processed (parsed), it passes the responsibility for component creation
    to the injector, thus avoiding the need to pass the injector throughout the application.
    All that work is done "behind the scenes".
  prefs: []
  type: TYPE_NORMAL
- en: As the documentation states, working in this manner *t**he application code
    simply declares the dependencies it needs, without having to deal with the injector.
    This setup does not break the Law of Demeter*.
  prefs: []
  type: TYPE_NORMAL
- en: Let's now focus on the latest versions of Angular (versions 2.0+), that are,
    in several ways, based on many of these principles but change its implementation
    quite a bit since they embrace ES6 and related technologies.
  prefs: []
  type: TYPE_NORMAL
- en: Angular 2+
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Since the release of AngularJS (version 1.x) in 2009, the web has changed immensely.
    We now have a multitude of build systems, modular loading capabilities, and Web
    components available to use. JavaScript development has also come on in leaps
    and bounds.
  prefs: []
  type: TYPE_NORMAL
- en: Those changes were not reflected in AngularJS, so it was not as performant as
    the team wanted, mainly due to the digest cycles (related to the DOM parsing that
    we mentioned previously), and directly related to change detection.
  prefs: []
  type: TYPE_NORMAL
- en: Change detection in Angular can be imagined as a tree working in one direction
    from the root to its leaves so that it's both faster and more predictable.
  prefs: []
  type: TYPE_NORMAL
- en: The name of any version higher than 1.x is just Angular, without the `JS` suffix
  prefs: []
  type: TYPE_NORMAL
- en: Angular has observable and immutable objects that greatly speed up how many
    properties are checked.
  prefs: []
  type: TYPE_NORMAL
- en: Besides, observable objects are triggered only if an input that they rely on
    emits an event. Immutable objects are only checked if one of their input properties
    has changed. In most cases though, these two types of object don't have to be
    checked, meaning that your whole application will be speeded up.
  prefs: []
  type: TYPE_NORMAL
- en: Microsoft's TypeScript is the preferred language in Angular 2+
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Another big change is the use of TypeScript as the preferred language (the Angular
    team also uses TypeScript language services and Visual Studio Code, to detect
    failures and inconsistencies in code, as Brad Green declared recently).
  prefs: []
  type: TYPE_NORMAL
- en: TypeScript has great support in editors such as Visual Studio Code and WebStorm
    and it behaves as a permanent assistant when you are importing modules and autocompleting
    intelligent suggestions.
  prefs: []
  type: TYPE_NORMAL
- en: Moreover, since it is a typed language, hints provided are far more in-depth
    than JavaScript's Intellisense. Additionally, any JavaScript is valid TypeScript,
    so you can use as much or as little of it as you're comfortable with. Many areas
    help Angular, such as interfaces, constructors, public variables, classes, typed
    arguments, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: But perhaps the biggest change in Angular is that its architecture is based
    on the concept of the component. And those components are defined using class
    annotations or decorators, a feature that allows adding metadata to a class.
  prefs: []
  type: TYPE_NORMAL
- en: Before delving into it, let's first remind ourselves of the required tooling
    to work with Angular.
  prefs: []
  type: TYPE_NORMAL
- en: Angular tools
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To work with the latest versions of Angular you can certainly choose from a
    variety of tools, but I'm going to use those that the official site recommends,
    plus those you need as a requirement.
  prefs: []
  type: TYPE_NORMAL
- en: 'First, you need a recent version of Node.js installed. At the time of writing,
    two versions are available on its website ([https://nodejs.org/es/](https://nodejs.org/es/)):
    6.10.3 and 7.10.0\. Either one will be fine, although I have installed 7.10.0\.
    This installation provides two basic tools to work with Angular: Node and **NPM**
    (**Node Package Manager**).'
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have completed the installation, make sure the versions are correct
    by typing the following in a console window:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: 'And by typing the following too:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: With that in place, there are a number of editors suitable for Angular, but
    you could try the free cross-platform Visual Studio Code, which has debugging
    capabilities and works fine in Windows, Linux, and OSX.
  prefs: []
  type: TYPE_NORMAL
- en: Working with Angular
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Let's install Angular CLI, a command line interface to work with Angular, which
    helps a lot in the initial steps with this framework. We will be able to create
    the early application very easily and understand how the architecture changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Angular CLI has a dedicated website ([https://cli.angular.io/](https://cli.angular.io/)),
    where you''ll find the installation process, downloads, and the related documentation.
    However, the easiest way to install it is via NPM. You just have to type the following
    in a Command Prompt:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: This installs the Angular-CLI tools globally, so it is available all over the
    filesystem.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once again, it''s a good practice to check the final state of the installation,
    which you can do by typing the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: 'The output should show the following information:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1b2a8589-50ea-4255-ad24-903883c1ac12.png)'
  prefs: []
  type: TYPE_IMG
- en: And we're all set! If you want to take a look at the list of commands that Angular
    CLI holds, just type `ng --help`. A long list will show up, so you can have an
    idea of how powerful this tool is in current versions.
  prefs: []
  type: TYPE_NORMAL
- en: 'To create the first application, open a Command Prompt (you can use the Developer
    Command Prompt link that Visual Studio installs), go to the directory where you
    want your demos to be located, create a new directory, and type the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: In my case, I typed `ng new ng4-demo` and then you wait until the bunch of libraries
    from NPM is downloaded and installed in the directory of your choice.
  prefs: []
  type: TYPE_NORMAL
- en: 'Inside the new directory, you can now see the list of files and directories
    created by the tool, and ready to launch. Notice that there are three new directories:
    `e2e`, `node_modules,` and `src`.'
  prefs: []
  type: TYPE_NORMAL
- en: The first one contains end-to-end tests for the application. That's done by
    default and you should modify those definitions further on to suit your needs.
  prefs: []
  type: TYPE_NORMAL
- en: 'The second and largest one holds the large list of JavaScript libraries required
    for almost any Angular application. Don''t get scared by its length: they''re
    downloaded and installed locally to provide programmers with the tools they might
    need, but at deploying time only those required will be included in the bundling
    and minifying process prior to deployment (it is called **tree-shaking**).'
  prefs: []
  type: TYPE_NORMAL
- en: Finally, in the `src` directory, you'll find all the files required for this
    initial demo. The rest are files used by Angular CLI and other tools (such as
    the editors) to manage the project (especially, `package.json`, `tsconfig.json`,
    and `angular-cli.json`).
  prefs: []
  type: TYPE_NORMAL
- en: 'You should end up with a list like the following:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/ef11a241-5f06-4ac6-8ae3-1f6dee9c8b01.png)'
  prefs: []
  type: TYPE_IMG
- en: To see it in action, just type `ng serve`. That will run the Webpack tool to
    get everything ready and launch a server on port 4200 (by default).
  prefs: []
  type: TYPE_NORMAL
- en: The final step will be to open any browser with the URL `http://localhost:4200`
    and see the very simple page saying `app works` (I omit the output; it is pretty
    obvious).
  prefs: []
  type: TYPE_NORMAL
- en: Editing the initial project
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Now that we know everything works, let's view the project inside Visual Studio
    Code (or the editor of your choice), and try to understand the architecture behind
    this.
  prefs: []
  type: TYPE_NORMAL
- en: So, I'll open the editor from the Command Prompt, just by typing `code .` on
    the main project's directory.
  prefs: []
  type: TYPE_NORMAL
- en: For more information about the VSCode, visit [https://code.visualstudio.com/](https://code.visualstudio.com/).
  prefs: []
  type: TYPE_NORMAL
- en: 'Perhaps, the most amazing thing about this initial demo (especially if you
    compare it to our previous demos in Angular 1.6) is the lack of references and
    directives inside the main HTML page of this app:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: 'The only non-static HTML is marked in bold: `<app-root>`. Angular resolves
    this customized element into the real page you saw in the browser through a complex
    process of component-related architectures, in which every component defines its
    behavior, its visual elements (if it has any), and the way it communicates with
    the rest of the application.'
  prefs: []
  type: TYPE_NORMAL
- en: If you look inside the `src` directory, you'll see several TypeScript files.
    The module responsible for instructing the browser what to do when `http://localhost:4200`
    is invoked appears inside the `angular-cli.json` file. This file contains a bunch
    of definitions about editor and server behaviors, and so on.
  prefs: []
  type: TYPE_NORMAL
- en: 'It holds an app''s entry containing that `main` property and also the entry
    point of the application, which is linked to an `index` field (see the following
    screenshot):'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/40ec42a2-507e-4a5c-a169-569022036138.png)'
  prefs: []
  type: TYPE_IMG
- en: 'With those definitions, the browser knows which page to launch, and the server
    which components should be resolved: whatever the `main` module indicates. And
    what it shows is a basic environment configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/afc0ddac-9403-43ff-b497-80fd1711ff66.png)'
  prefs: []
  type: TYPE_IMG
- en: So, this is how Angular manages the initialization of the app. Whatever is inside
    `AppModule` will be loaded and resolved.
  prefs: []
  type: TYPE_NORMAL
- en: The structure of the main module
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'However, as it turns out that every angular application must consist of at
    least one module, the `app.module.ts` becomes the one that sets up the application.
    It''s mandatory to understand how it works:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/4f8c1e04-cc51-44f4-be70-e0b82eed4403.png)'
  prefs: []
  type: TYPE_IMG
- en: First, we find `import` statements that load some previously exported components
    inside the Angular libraries, such as `platform-browser`, `core`, `forms`, and
    `http`. Some of these libraries are not needed in this basic demo, however.
  prefs: []
  type: TYPE_NORMAL
- en: The last `import` statement is the one that links this module with the rest
    of the functionality, loading `app.component`.
  prefs: []
  type: TYPE_NORMAL
- en: The way you define a module is by means of a class (here named `AppModule`),
    marked with a `@NgModule` decorator. There are no functionalities or definitions
    inside. Only the decorator provides the correct link with the rest of the app's
    elements.
  prefs: []
  type: TYPE_NORMAL
- en: Actually, the `bootstrap` property indicates which component will be in charge
    of launching the application.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let''s see how that component is made up:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/1282f3d2-3cd8-4bc5-be35-6163ed34f975.png)'
  prefs: []
  type: TYPE_IMG
- en: Now we have the `AppComponent` class marked with the `@Component` decorator.
    Inside, we find the HTML part that we see in the browser. It's the title field
    of the class.
  prefs: []
  type: TYPE_NORMAL
- en: 'But, inside the decorator, we have some clues:'
  prefs: []
  type: TYPE_NORMAL
- en: '`selector`: Indicates the customized piece of dynamic DOM that will be translated
    into a real fragment of HTML at runtime. Remember, the only foreign part of HTML
    inside `Index.html` is that reference to the `<app-root>` element.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`templateUrl` (optionally just template, if indicated next): The file containing
    the HTML fragments that will replace the selector. They admit `{{moustache}}`
    syntax, as it happens here.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`styleUrls`: An array of CSS files that will be loaded at runtime for presentation
    purposes. They will only affect the component that defines them, and not the whole
    page.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'Finally, the `app works` sentence that we saw in the browser''s initial page
    is just the `title` property of the `AppComponent` class. And, yes, it is linked
    via data-binding to the HTML inside the template, which is just a `<h1>` element:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: 'So, let''s make a couple of changes, to see how it goes. Instead of `app works`,
    I''ll change the `title` property to `First demo in Angular 4`, and the CSS file,
    which is empty, will also hold some formatting rules:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: 'Of course, we can also add any static content to the `**index.html**` itself
    (an image, for example, next to the selector):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The environment will take care of every change in the application and incrementally
    recompile those changes.
  prefs: []
  type: TYPE_NORMAL
- en: Notice that, at the end, the text we see is the class' `title` property, which
    is evaluated and managed by the component architecture of the Angular framework,
    and it is this component architecture that facilitates the implementation of Dependency
    Injection.
  prefs: []
  type: TYPE_NORMAL
- en: 'So, we should see those changes without any more intervention:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/d7fd9cc0-f66b-4eaa-aa72-46f81c7eb9fa.png)'
  prefs: []
  type: TYPE_IMG
- en: Some of the procedures implied in this model use types of dependencies that
    are solved at compile time and runtime. But how can we see the DI in action?
  prefs: []
  type: TYPE_NORMAL
- en: DI in Angular 4
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: Well, DI in Angular follows the construction injection pattern; thus, since
    we are dealing with classes (components) here, most of the injection is required
    in the constructor's parameter definitions.
  prefs: []
  type: TYPE_NORMAL
- en: A dedicated page on the official Angular documentation site supplies more information
    about Dependency Injection at [https://angular.io/docs/ts/latest/guide/dependency-injection.html](https://angular.io/docs/ts/latest/guide/dependency-injection.html).
  prefs: []
  type: TYPE_NORMAL
- en: As with AngularJS, Angular creates an injector object in the bootstrap process,
    so you don't have to do it by yourself (remember, the `platformBrowserDynamic().bootstrapModule(AppModule)`sentence
    inside `main.ts`).
  prefs: []
  type: TYPE_NORMAL
- en: The concept of a provider
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With that in mind, the programmer's responsibility is to register those classes
    that will be served via DI later on. You can do that, either in the `NgModule`,
    or inside any `Component`, but, in either case, the way to declare an injectable
    class is by adding its name to the `provider's` collection of a component or module.
  prefs: []
  type: TYPE_NORMAL
- en: The difference will be that, when declared inside a `@**NgModule**`, those services
    will be available alongside the entire application. In the remaining cases, it
    will be limited to the component's hierarchy.
  prefs: []
  type: TYPE_NORMAL
- en: Let's modify the previous example, so you can see this technique in action.
    Actually, it is quite simple.
  prefs: []
  type: TYPE_NORMAL
- en: The first step is to create a class that provides the injected information required
    (I'll call it `DIClass`). Let's imagine we want an extra text property and a picture.
    Since we only need the picture's URL, we'll define two string properties.
  prefs: []
  type: TYPE_NORMAL
- en: 'But to make the class injectable, we need to mark it as such. We do that by
    importing the "`Injectable`" definition from `@angular/core` and decorating the
    class with that annotation. The final aspect of this class'' code will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/b4d6086e-6d07-4c26-a03f-42a807a00f45.png)'
  prefs: []
  type: TYPE_IMG
- en: Now, we can get rid of the `<img>` element we inserted in `index.html` and pass
    the task of inserting the image to the component.
  prefs: []
  type: TYPE_NORMAL
- en: Besides that, and only for presentation purposes, I've modified the `app.component.css`
    code to mark the injected information inside a border, so those fragments become
    clearly visible.
  prefs: []
  type: TYPE_NORMAL
- en: With the class ready, we now define the scope of this service. Since we only
    need it for our `AppComponent`, we'll add a new definition of `providers` in the
    `@Component` decorator's class; this will make our `DIClass` content available
    inside the component.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we can modify our class to hold two extra properties (`subtitle` and
    `fotosource`), whose values are received by injection. In practice, this injected
    class will often be data access services or any other type of resource that might
    be needed in more than one application's component.
  prefs: []
  type: TYPE_NORMAL
- en: 'Since the way those values are received is by declaring the injected class
    (or values) in the constructor, the final version will be:'
  prefs: []
  type: TYPE_NORMAL
- en: '![](img/bb1b2adb-1090-4c00-8933-c3ae394459b7.png)'
  prefs: []
  type: TYPE_IMG
- en: 'Now, if you keep the server running and take a look at the new aspect of the
    page, next to the initial message, we should see those injected elements, formatted
    according to the CSS rules inside the `**app.component.css**` file:'
  prefs: []
  type: TYPE_NORMAL
- en: And that's it. We can inject as many items as needed as long as we have previously
    declared those values with the `**@Injectable**` decorator; however, if you need
    more customizable services or data, I recommend reading the documentation's reference
    I mentioned previously.
  prefs: []
  type: TYPE_NORMAL
- en: Wrapping it up
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: These techniques make your code more maintainable and scalable, and also less
    dependent on further changes. Since you only have to reference the required services,
    a change in the implementation of one doesn't necessarily mean a change in the
    high-level classes that use those services.
  prefs: []
  type: TYPE_NORMAL
- en: Of course, there is much more in DI in Angular 4 than the basic information
    included in this chapter. By now I hope you have a better understanding of how
    DI is present in these frameworks, and why it is becoming universally popular
    implementation design pattern.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, we have covered DI in other frameworks, with a special focus
    on Angular in its two current branches.
  prefs: []
  type: TYPE_NORMAL
- en: First, we've seen the very basics of TypeScript on which Angular 2+ is based
    and how its capabilities for class definitions and module loading allow the construction
    of JavaScript-based applications with a more object-oriented, modular approach.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we went through the implementation of DI inside AngularJS (the legacy
    branch of Angular), still in use in more than 70 percent of Angular projects worldwide.
  prefs: []
  type: TYPE_NORMAL
- en: Finally, we explored the basics of Angular 4 (the latest version available at
    thetime of writing this), and how the aforementioned object orientation and its
    component architecture (based on annotations) allow the implementation of Dependency
    Injection in a very easy way.
  prefs: []
  type: TYPE_NORMAL
- en: In [Chapter 11](a437ff1b-c4af-41ac-b502-8718dc132272.xhtml), *Best Practices
    and Other Related Techniques*, we'll cover some of the most common best practices
    in DI and other related techniques.
  prefs: []
  type: TYPE_NORMAL
