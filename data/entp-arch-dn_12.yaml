- en: '12'
  id: totrans-0
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: '12'
- en: Externalization of Business Rules
  id: totrans-1
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务规则的显式化
- en: After the two preceding chapters detailing the Master Data Management and Business
    Process Management parts of a utopic information system, this chapter will end
    with the third and last part of such an ideal system, which is the **Business
    Rules Management System** (**BRMS**). We have already discussed briefly business
    rules in the previous chapters because the data referential may contain some validation
    rules that are associated with a given business entity, and the business process
    may also embed some business rules to orient the workflow and decide which branch
    of the process should be executed, depending on the context. But in the perfectly
    ideal system that we envision, a centralized system should be responsible for
    all the business rules, and that is the subject of this chapter.
  id: totrans-2
  prefs: []
  type: TYPE_NORMAL
  zh: 在详细介绍了理想信息系统中的主数据管理和业务流程管理部分的前两个章节之后，本章将以这样一个理想系统的第三部分和最后一部分结束，即**业务规则管理系统**（**BRMS**）。我们已经在之前的章节中简要讨论了业务规则，因为数据参照可能包含与特定业务实体相关的一些验证规则，并且业务流程也可能嵌入一些业务规则以指导工作流程并决定根据上下文应该执行流程的哪个分支。但在我们构想的完美理想系统中，一个集中的系统应该负责所有业务规则，这就是本章的主题。
- en: We will start by explaining in more detail what a BRMS is and what implementing
    such a solution requires in terms of business rules management, deployment, and
    architecture of the stream of data in the system. Then, we will show the first
    example of business rules management using a standard called **DMN** (short for,
    **Decision Model and Notation**), inside a business process.
  id: totrans-3
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将首先详细解释什么是BRMS，以及实施此类解决方案在业务规则管理、部署和系统数据流架构方面所需的内容。然后，我们将展示使用称为**DMN**（即**决策模型和符号**）的标准在业务流程中使用的第一个业务规则管理的例子。
- en: Unlike the previous two, we will end this chapter (and the series of three chapters
    on the different parts of an ideal information system) without providing application
    examples of our sample information system. The reason behind this is that authorization
    management is one of the best examples of business rules management, but the subject
    is so complex that it needs a complete chapter to understand it.
  id: totrans-4
  prefs: []
  type: TYPE_NORMAL
  zh: 与前两个不同，我们将在这个章节（以及关于理想信息系统不同部分的三个章节系列）结束时，不提供我们样本信息系统的应用示例。这样做的原因是，授权管理是业务规则管理的最佳例子之一，但这个主题非常复杂，需要一整章来理解。
- en: Business Rules Management Systems
  id: totrans-5
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 业务规则管理系统
- en: A **Business Rules Management System** (we will abbreviate into **BRMS** from
    now on) is a piece of software that deals with computations and decisions that
    can be applied to data, in order to output results that have a higher business
    value. There are lots of concepts in that definition, and we are going to explain
    them one at a time.
  id: totrans-6
  prefs: []
  type: TYPE_NORMAL
  zh: '**业务规则管理系统**（以下简称**BRMS**）是一套软件，用于处理可以应用于数据的计算和决策，以便输出具有更高商业价值的成果。这个定义中包含了许多概念，我们将逐一进行解释。'
- en: How does a BRMS handle business rules?
  id: totrans-7
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BRMS如何处理业务规则？
- en: A business rule can, for example, calculate the total price of an order line,
    using the tax-excluding price of an article, the number of articles, and the applicable
    tax rate. Another example of its application would be to decide whether a piece
    of document created in an invoicing process should be given an electronic signature
    or not. In this case, the business rules output a Boolean value, stating whether
    the result is true or false. Business rules can call each other. In the previous
    example, we may have to decide how the document will be presented to someone for
    signature, who will sign if the initial signee is considered absent after several
    notifications, how many such notifications will be sent and on which channels,
    and so on – all these are business rules.
  id: totrans-8
  prefs: []
  type: TYPE_NORMAL
  zh: 例如，一条业务规则可以计算订单行的总价，使用商品的不含税价格、商品数量和适用的税率。另一个应用示例可能是决定在开票过程中创建的文件是否应该给予电子签名。在这种情况下，业务规则输出一个布尔值，表示结果为真或假。业务规则可以相互调用。在前一个例子中，我们可能需要决定如何向某人展示文件以供签名，如果初始签署人在多次通知后被视为缺席，谁将签署，将发送多少此类通知以及通过哪些渠道，等等——所有这些都是业务规则。
- en: As its name suggests, a BRMS manages business rules. But what this entails is
    not so obvious. In one way, you could consider that a BRMS is the MDM of business
    rules – it can store them, together with their old versions. It can allow some
    people to read them, some to write them, or reject others that have no authorization
    whatsoever on certain business rules. It can group and categorize business rules
    in order to specify their research. All this is done by an MDM on its referenced
    business entity, but a BRMS has one more responsibility that an MDM does not have,
    which is the execution of the business rule. Indeed, a business rule takes input
    to calculate an output, and it is the main responsibility of a BRMS to do so.
  id: totrans-9
  prefs: []
  type: TYPE_NORMAL
  zh: 如其名称所示，BRMS管理业务规则。但其所涉及的内容并不那么明显。一方面，你可以认为BRMS是业务规则的MDM（主数据管理），它可以存储它们，包括它们的旧版本。它可以允许一些人阅读它们，一些人编写它们，或者拒绝那些对某些业务规则没有任何授权的人。它可以对业务规则进行分组和分类，以便指定其研究。所有这些都是在MDM对其引用的业务实体上完成的，但BRMS还有一个MDM没有的责任，那就是执行业务规则。确实，业务规则通过输入来计算输出，而BRMS的主要责任就是这样做。
- en: However, responsibility does not mean the BRMS executes everything. Most of
    the time, it will delegate the enforcement of the rule, as it does not own the
    data that is addressed by a business rule or the service that executes a business
    action in a way defined by the output of the rule. That may sound counter-intuitive,
    but a BRMS can even delegate responsibility for the execution of the rule (which
    is to calculate the output of the rule from its input). This is the case, for
    example, where an MDM service validates its incoming data with a rule coming from
    the BRMS. Some local cache of the rules expressions is also possible since it
    does not introduce lots of coupling. Nonetheless, the responsibility of the validation
    rule remains in the BRMS, since if somebody changes the rule in the BRMS editor,
    then it will apply (maybe after a small delay, if the cache is not immediately
    invalidated for performance reasons) to all servers using this rule, among which
    is the MDM of our example.
  id: totrans-10
  prefs: []
  type: TYPE_NORMAL
  zh: 然而，责任并不意味着BRMS执行一切。大多数时候，它将委托规则的执行，因为它不拥有业务规则所针对的数据或以规则输出定义的方式执行业务动作的服务。这可能听起来有些反直觉，但BRMS甚至可以委托规则执行的职责（即从其输入计算规则的输出）。例如，当MDM服务使用来自BRMS的规则验证其传入数据时，这种情况就会发生。由于它不会引入太多的耦合，因此规则表达式的本地缓存也是可能的。尽管如此，验证规则的责任仍然在BRMS，因为如果有人在BRMS编辑器中更改了规则，那么它将（可能是在缓存因性能原因未立即失效后）应用于使用此规则的所有服务器，其中包括我们示例中的MDM。
- en: To summarize, the primary responsibilities of a BRMS are to store, expose, and
    execute business rules. It is responsible for the right execution of the rules
    and, thus, either executes them internally or trusts other applications to execute
    the rules that it provides them. This is often the case, as external applications
    are the ones that have access to the input data necessary to execute the rule.
    Also, they will be – most of the time – the ones that use the output of the rule
    to adjust their behavior accordingly.
  id: totrans-11
  prefs: []
  type: TYPE_NORMAL
  zh: 总结来说，BRMS（业务规则管理系统）的主要职责是存储、暴露和执行业务规则。它负责规则的正确执行，因此要么内部执行这些规则，要么信任其他应用程序执行它提供的规则。这种情况很常见，因为外部应用程序是那些能够访问执行规则所需输入数据的应用程序。而且，它们通常也是那些根据规则输出调整其行为的应用程序。
- en: Additional characteristics of a BRMS
  id: totrans-12
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BRMS的附加特性
- en: We often talk about the “secondary responsibilities” of a service for features
    that are not absolutely necessary but still remain important. In the case of BRMS,
    there are several such responsibilities.
  id: totrans-13
  prefs: []
  type: TYPE_NORMAL
  zh: 我们经常谈论服务的“次要职责”，这些职责对于绝对必要的功能来说不是必需的，但仍然很重要。在BRMS的情况下，有几个这样的职责。
- en: First and foremost, a BRMS should have high performance, both in execution time
    and in its capacity to withstand a high volume of requests. Indeed, rule execution
    is one of the few cases where a cache is difficult to apply. When retrieving an
    image from a URL, there is a great chance that it is not going to change from
    one call to another one a few seconds after; thus, it is really worth keeping
    a cache, as this will avoid a network roundtrip and server request handling and
    drastically improve performance. This is not the case for business rules, as their
    main function is to be calculated from varying input and provide an output that
    depends on them.
  id: totrans-14
  prefs: []
  type: TYPE_NORMAL
  zh: 首先，一个BRMS（业务规则管理系统）应该具有高性能，无论是在执行时间上还是在承受高请求量方面的能力。确实，规则执行是少数几个难以应用缓存的情况之一。当你从一个URL检索图像时，有很大可能性它不会在几秒钟后从一个调用变为另一个调用而改变；因此，保留缓存是非常有价值的，因为这将避免网络往返和服务器请求处理，并极大地提高性能。对于业务规则来说，情况并非如此，因为它们的主要功能是从变化的输入中进行计算，并提供依赖于它们的输出。
- en: Sure, the rule expression can be cached (and rules may not change that frequently),
    but when you do so, the caller has to be able to execute the rule from its textual
    expression itself, which may be overly complex and necessitate a rule-execution
    engine. If the rule is shared among many services, many instances of the engine
    will have to be kept in synchronization with the BRMS, so it is not efficient.
    So, we come back to the engine being in only one place, which is the BRMS server
    itself.
  id: totrans-15
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，规则表达式可以被缓存（并且规则可能不会频繁更改），但是当你这样做时，调用者必须能够从其文本表达式本身执行规则，这可能过于复杂，需要规则执行引擎。如果规则在许多服务之间共享，那么许多引擎实例将需要与BRMS保持同步，这并不高效。因此，我们回到引擎只在一个地方，即BRMS服务器本身。
- en: In this case, the engine’s moving parts may be cached, or at least kept in RAM,
    which will provide a quick execution. However, caching the results depending on
    the input is, most of the time, not efficient, as there are so many possible values.
    To use our preceding example, there is absolutely no need to cache the result
    of a calculation of an invoice line total price, as there is almost no chance
    that another call will come back quickly for the same article, with the same quantity
    and tax rate. If you add that some rules may be based on ever-changing data (such
    as stock market values), it can become absolutely impossible to arrange some way
    of caching. So, we basically fall back to the need for an engine that can output
    values as quickly as possible. This requirement should of course be supported
    in case of high volumes. As business data (as opposed to reporting data) tends
    to be volatile, business rules will be called very often.
  id: totrans-16
  prefs: []
  type: TYPE_NORMAL
  zh: 在这种情况下，发动机的移动部件可能被缓存，或者至少保持在RAM中，这将提供快速执行。然而，根据输入缓存结果，大多数情况下并不高效，因为可能存在如此多的可能值。以我们之前的例子来说，缓存发票行总价计算的结果完全没有必要，因为几乎不可能有另一个调用会很快返回相同的商品，相同的数量和税率。如果你考虑到一些规则可能基于不断变化的数据（例如股市价值），那么安排某种缓存方式可能变得完全不可能。因此，我们基本上退回到需要一个能够尽可能快地输出值的引擎的需求。当然，在高负载情况下，这一需求应该得到支持。因为与报告数据相比，业务数据往往更具波动性，所以业务规则会被频繁调用。
- en: The other “secondary” feature of a good BRMS is robustness. When they are used
    in the industry (which is not very often because they are complex applications),
    it is because they are a very important part of the business processes. For instance,
    a BRMS is used by insurance companies to calculate risk, or by mobile phone companies
    to calculate the price to be paid from data about the conversations (the duration,
    numbers called, time of the day, etc.) and the contract (a discount for certain
    numbers, prepaid amount per month, consumption in the month, etc.). Because of
    the cost of a BRMS, they are generally used for core business functions, where
    important decisions (in our examples, accepting a contract and sending the correct
    invoice to a customer) are made based on their output. The robustness of calculations
    is, thus, an important aspect because no one would work with a system that can
    miscalculate from time to time.
  id: totrans-17
  prefs: []
  type: TYPE_NORMAL
  zh: 一个好的BRMS的另一个“次要”特性是健壮性。当它们在行业中使用时（这并不常见，因为它们是复杂的应用程序），是因为它们是业务流程的重要组成部分。例如，BRMS被保险公司用来计算风险，或者被移动通信公司用来根据通话数据（通话时长、拨打的号码、一天中的时间等）和合同（对某些号码的折扣、每月预付费、月消费等）来计算应支付的费用。由于BRMS的成本，它们通常用于核心业务功能，其中重要的决策（在我们的例子中，接受合同和向客户发送正确的发票）是基于它们的输出做出的。因此，计算的健壮性是一个重要的方面，因为没有人愿意与偶尔会出错计算的系统合作。
- en: For the same reason, traceability is generally an important feature of a BRMS.
    It can, of course, delegate this to calling services because a BRMS mostly works
    for other services. But even if the responsibility is shared, there should be
    logs that record whether a rule has been applied to certain context data, providing
    output that clarifies why a certain rule was made. Even if logs are better suited
    to the calling application, it is a good idea that the version of the BRMS set
    of rules is kept somewhere and that the rule engine versions are immutable. This
    allows you, if necessary, to go back in time, re-execute business rules calculation
    on the then-used version of the BRMS engine, and understand why an output value
    was wrong.
  id: totrans-18
  prefs: []
  type: TYPE_NORMAL
  zh: 由于同样的原因，可追溯性通常是BRMS的一个重要特性。当然，它可以委托给调用服务，因为BRMS主要是为其他服务工作的。但即使责任是共享的，也应该有记录，记录是否将规则应用于某些上下文数据，提供澄清为什么制定某个规则的输出。即使日志更适合调用应用程序，将BRMS规则集的版本保存在某处，并且规则引擎版本不可变，也是一个好主意。这允许你在必要时回到过去，在BRMS引擎当时使用的版本上重新执行业务规则计算，并了解为什么输出值是错误的。
- en: Finally, as explained previously, a BRMS is often used in conjunction with other
    services and is useless by itself. Its low-level characteristics make its integration
    and good capacity for interoperation of paramount importance. An implementation
    should normally come with at least some APIs and, if possible, SDKs for as many
    languages as possible, making it easy to interact with all possible software applications.
  id: totrans-19
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，如前所述，BRMS通常与其他服务一起使用，单独使用是无用的。其低级特性使其集成和与其他服务的良好互操作性至关重要。实现通常应至少提供一些API，如果可能的话，为尽可能多的语言提供SDK，使其易于与所有可能的软件应用程序交互。
- en: Actual use of BRMS
  id: totrans-20
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BRMS的实际使用
- en: As was hinted previously, the actual use of BRMS in the field is very low. The
    cost of implementation is such that only a few very particular cases of business
    rule execution are actually worth deploying a dedicated server for. Also, as we
    saw, the externalization of a rule comes with a high toll on performance, as either
    the application that knows the data has to send it to the BRMS and wait for the
    output to follow its flow, or it has to dynamically execute a business rule expression
    sent by the BRMS, and maybe cached internally. In this case, the speed of execution
    is still lower than when the rule is compiled into an application. Sure, the coupling
    between the application and the rule is then maximal, there is no centralized
    sharing of the rule, and the many uses can diverge. However, the performance issue
    can be so significant that these reasons are not as important.
  id: totrans-21
  prefs: []
  type: TYPE_NORMAL
  zh: 如前所述，BRMS在实际应用中的使用非常低。实施成本如此之高，以至于只有少数非常特定的业务规则执行案例才真正值得部署专用服务器。此外，正如我们所见，规则的外部化会带来很高的性能损耗，因为要么知道数据的应用程序必须将其发送给BRMS并等待输出以继续其流程，要么它必须动态执行BRMS发送的业务规则表达式，也许内部缓存。在这种情况下，执行速度仍然低于将规则编译到应用程序中时的速度。当然，应用程序和规则之间的耦合度是最大的，没有规则的集中共享，许多用途可能会分化。然而，性能问题可能非常严重，这些原因并不那么重要。
- en: Also, let’s not underestimate habitual factors as well – since developers have
    spent most of their careers taking business rules from use cases and translating
    them into code put in an application, it is an effort to change this way of thinking,
    extract the business rule, and place it somewhere else. And with what results?
    A large performance drop and code that is more difficult to read and maintain.
    This means that the business rule should `CommonBusinessValues` class, in a `public
    static readonly` member, and everything will be fine and ready for an update.
  id: totrans-22
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们也不应低估习惯性因素——由于开发者的大部分职业生涯都是将业务规则从用例中提取出来，并将其转换为应用中嵌入的代码，因此改变这种思维方式，提取业务规则，并将其放置在其他地方是一项努力。而结果如何？性能大幅下降，代码的可读性和可维护性更差。这意味着业务规则应该放在
    `CommonBusinessValues` 类的 `public static readonly` 成员中，这样一切都会顺利，并准备好更新。
- en: 'This means that, indeed, in 99.99% of the cases, business rules will be concretely
    implemented, like in the following C# example, by means of code:'
  id: totrans-23
  prefs: []
  type: TYPE_NORMAL
  zh: 这意味着，确实，在 99.99% 的情况下，业务规则将通过代码具体实现，如下面的 C# 示例所示：
- en: '[PRE0]'
  id: totrans-24
  prefs: []
  type: TYPE_PRE
  zh: '[PRE0]'
- en: 'Also, lots of other business rules will be scattered all over the code:'
  id: totrans-25
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，许多其他业务规则将散布在代码的各个角落：
- en: '[PRE1]'
  id: totrans-26
  prefs: []
  type: TYPE_PRE
  zh: '[PRE1]'
- en: As a side note, it is better to use string values or even dedicated code structures
    instead of enumerations for this kind of value, as this eases evolution.
  id: totrans-27
  prefs: []
  type: TYPE_NORMAL
  zh: 作为旁注，对于这种类型的值，最好使用字符串值或甚至专门的代码结构，而不是枚举，因为这有助于进化。
- en: In fact, there are so many business rules everywhere in a code base that it
    is difficult to spot all of them. But this is not what is most important. The
    real challenge is for the architect/product owner/developer to know, when creating
    the application, which ones should be externalized, which ones should be centralized,
    and which should be simply left in the code, even in duplicates, because they
    will never change. Beware, though, that some things that are thought to never
    change sometimes evolve over time! For example, you could say that the rule about
    net price will always be stable; net price will always be the tax-free price multiplied
    by one plus the tax rate. Well, yes, until the government decides to apply multiple
    tax rates that apply differently to the sub-parts of a product. And if you have
    in your Product Information Management software some articles that are composed
    of a hardware part and an installation service, for example, you may end up with
    the first part taxed at 5.5% and the second part taxed at 20%. If the calculation
    has been written in a centralized function, this is not so bad. But if it has
    been duplicated in hundreds of places in the code (which can be the case with
    business rules that everyone assumes are constant and immutable), you will face
    some difficulty, not only because it will take ages for the change to be realized,
    but also because the one instance you forget will most likely be the one your
    most important customer uses.
  id: totrans-28
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，代码库中到处都是业务规则，很难全部找到。但这并不是最重要的。真正的挑战是架构师/产品所有者/开发者要知道，在创建应用程序时，哪些应该外部化，哪些应该集中化，哪些应该简单地留在代码中，即使有重复，因为它们永远不会改变。但请注意，有些被认为永远不会改变的事物有时会随着时间的推移而演变！例如，你可以这样说，关于净价的规则总是稳定的；净价总是免税价格乘以（1+税率）。嗯，是的，直到政府决定应用不同的税率，这些税率适用于产品的不同部分。例如，如果你的产品信息管理软件中有一些由硬件部分和安装服务组成的文章，你可能会遇到第一部分被征收
    5.5% 的税，而第二部分被征收 20% 的税。如果计算已经写入集中化的函数中，这并不是那么糟糕。但如果它在代码中的数百个地方被重复（这可能是每个人都认为恒定且不可变的企业规则），你将面临一些困难，不仅因为改变需要花费很长时间才能实现，而且因为你忘记的那个实例很可能是你的最重要客户使用的。
- en: In short, externalizing a business rule in a dedicated BRMS is 99.99% of the
    time overkill, and the cost is not justified. But you can go a very long way simply
    by putting the business rule in a function. And most of the time, the only difficulty
    there is simply realizing you are implementing one!
  id: totrans-29
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，将业务规则外部化到一个专门的 BRMS 中，99.99% 的时间都是过度设计，且成本无法得到合理证明。但仅仅通过将业务规则放入一个函数中，你就能走得很远。而且，大多数情况下，唯一的困难可能就是意识到你正在实现一个业务规则！
- en: Examples of a BRMS
  id: totrans-30
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: BRMS 的示例
- en: Let’s say that you are indeed in this very particular 0.01% case where you actually
    could gain business value from implementing a dedicated BRMS. You would, thus,
    need a piece of software to do this for you, since, as you can imagine from the
    required secondary features, this kind of server is quite a complex piece of code.
    At the time of writing, there were only two serious contenders for BRMS servers
    – Drools (open source) and **Operational Decision** **Manager** (**ODM**).
  id: totrans-31
  prefs: []
  type: TYPE_NORMAL
  zh: 假设你确实处于这种非常特别的0.01%的情况中，即你实际上可以从实施一个专门的BRMS中获得商业价值。因此，你需要一款软件来为你完成这项工作，因为正如你可以从所需的其他功能中想象到的，这种服务器是一段相当复杂的代码。在撰写本文时，只有两个严肃的BRMS服务器竞争者——Drools（开源）和**操作决策管理器**（**ODM**）。
- en: The most used open source BRMS is Drools ([https://www.drools.org/](https://www.drools.org/)).
    It contains a core engine to calculate rules (including some functions such as
    rule chaining), which is sometimes called an inference engine, as it infers results
    from a data context and a set of rules. It also contains an application to create
    and manipulate rules (with a web editor). Drools is written in Java and can be
    interoperated with other platforms, but not natively.
  id: totrans-32
  prefs: []
  type: TYPE_NORMAL
  zh: 最常用的开源BRMS是Drools（[https://www.drools.org/](https://www.drools.org/)）。它包含一个核心引擎来计算规则（包括一些如规则链的功能），有时被称为推理引擎，因为它可以从数据上下文和一组规则中推断出结果。它还包含一个用于创建和操作规则的应用程序（带有网页编辑器）。Drools是用Java编写的，可以与其他平台互操作，但不是原生支持。
- en: ODM, from IBM, is a proprietary decision management system that was created
    to extract the important business rules from legacy COBOL code, in an effort to
    modernize the information systems on the z/OS platform. Although it can manipulate
    rules, it is mostly organized around the concepts of decisions on events.
  id: totrans-33
  prefs: []
  type: TYPE_NORMAL
  zh: IBM的ODM是一个专有决策管理系统，旨在从遗留的COBOL代码中提取重要的业务规则，以努力使z/OS平台上的信息系统现代化。尽管它可以操作规则，但它主要围绕事件决策的概念组织。
- en: As you can see, the landscape is far from being as complicated as in other fields
    of IT – for example, Big Data, where a single book could not even describe all
    the software applications, platforms, and servers that are available, mostly all
    doing the same things while pretending to be radically different from their competitors.
    This has the merit of clarity – if you need to implement a BRMS in your information
    system and you want to reduce costs, Drools will be your first choice.
  id: totrans-34
  prefs: []
  type: TYPE_NORMAL
  zh: 如你所见，这个领域的复杂性远不如其他IT领域——例如大数据，一本书甚至无法描述所有可用的软件应用、平台和服务器，它们大多在做同样的事情，同时假装与竞争对手有根本的不同。这有其清晰性的优点——如果你需要在你的信息系统中实施BRMS并希望降低成本，Drools将是你的首选。
- en: Of course, there are some lesser-known alternatives. Lots of BPMN engines implement
    their own language for workflow decisions. Windows Workflow Foundation did so,
    but it is not supported anymore. PowerApps has some expression capability that
    can be used for business rule execution, but it can only be mutualized, so it
    is not a real BRMS system. Another solution, although it involves additional work,
    is to implement your own BRMS. If you do not need advanced features, you can build
    one quite quickly if you use an existing expression execution engine. Lots of
    scripting languages are available, and you can even use C# inside C# with expression
    trees, dynamic code generation, and other advanced, but still accessible, features.
  id: totrans-35
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，还有一些不太为人所知的替代方案。许多BPMN引擎实现了自己的工作流决策语言。Windows Workflow Foundation就是这样做的，但现在不再受支持。PowerApps有一些表达式能力，可以用于业务规则执行，但它只能共享，因此它不是一个真正的BRMS系统。另一个解决方案，尽管它涉及额外的工作，就是实现你自己的BRMS。如果你不需要高级功能，如果你使用现有的表达式执行引擎，你可以相当快速地构建一个。有很多脚本语言可用，你甚至可以在C#中使用C#，利用表达式树、动态代码生成和其他先进但仍然易于访问的功能。
- en: In short, you have a choice of software, even if it is not as plethoric as in
    some other fields of IT. However, as you are certainly used to now, business/IT
    alignment is about reducing coupling, so the choice of software implementation
    is normally not such an important subject (in the sense it could harm the application
    evolution) as long as there is a standard norm, widely accepted specification,
    or even just an organization-wide pivotal format that can serve as a level of
    indirection between functional dependency and technical implementation. And the
    great news is that there is a standard for business rules, which is **Decision
    Modeling Notation** (**DMN**) 1.0\. This will be our topic of discussion in the
    next section of this chapter.
  id: totrans-36
  prefs: []
  type: TYPE_NORMAL
  zh: 简而言之，你有软件的选择，即使它不像某些其他IT领域那样丰富。然而，正如你现在可能已经习惯的那样，业务/IT协同是关于减少耦合的，因此软件实现的选取通常不是一个如此重要的话题（从它可能损害应用演变的角度来看），只要存在一个标准规范、广泛接受的规范，或者甚至只是一个组织范围内的关键格式，它可以在功能依赖和技术实现之间提供一种间接层次。而且好消息是，存在一个关于业务规则的标准，即**决策建模符号**（**DMN**）1.0。这将是本章下一节讨论的主题。
- en: The DMN standard
  id: totrans-37
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: DMN标准
- en: DMN is a standard that defines decision trees and decision tables, which are
    the two main concepts concerning business rule implementation. In the upcoming
    sections, we will show how it works and how useful it can be.
  id: totrans-38
  prefs: []
  type: TYPE_NORMAL
  zh: DMN是一个定义决策树和决策表的标准，这是关于业务规则实现的两个主要概念。在接下来的章节中，我们将展示它是如何工作的以及它有多么有用。
- en: The origin and principle of DMN
  id: totrans-39
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DMN的起源和原理
- en: The DMN standard is in version 1.0 and was published by the **OMG** (short for,
    **Object Management Group**) in September 2015\. At the time of writing, the latest
    validated version is numbered 1.3 and was published in February 2021\. Version
    1.5 has existed since June 2023, but it is considered a beta version currently.
    Thus, we will discuss only version 1.3.
  id: totrans-40
  prefs: []
  type: TYPE_NORMAL
  zh: DMN标准目前是1.0版本，由**OMG**（即**对象管理组**）在2015年9月发布。在撰写本文时，最新的验证版本编号为1.3，并于2021年2月发布。1.5版本自2023年6月存在，但目前被视为一个测试版本。因此，我们将只讨论1.3版本。
- en: 'Note that OMG is also the consortium behind the BPMN 2.0 standard, which works
    in conjunction with the DMN standard. As expressed by OMG as soon as the first
    version was launched ([https://www.omg.org/spec/DMN/1.0/About-DMN](https://www.omg.org/spec/DMN/1.0/About-DMN)):
    “*DMN notation is designed to be useable alongside the standard BPMN business
    process notation.*” And there is a type of task that exists in BPMN that directly
    relates to business rules:'
  id: totrans-41
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，OMG也是BPMN 2.0标准的联盟，它与DMN标准协同工作。正如OMG在第一版发布时所述（[https://www.omg.org/spec/DMN/1.0/About-DMN](https://www.omg.org/spec/DMN/1.0/About-DMN)）：“*DMN符号设计为可以与标准BPMN业务流程符号一起使用。*”在BPMN中存在一种与业务规则直接相关的任务类型：
- en: '![Figure 12.1 – A business rule task](img/B21293_12_1.jpg)'
  id: totrans-42
  prefs: []
  type: TYPE_IMG
  zh: '![图12.1 – 业务规则任务](img/B21293_12_1.jpg)'
- en: Figure 12.1 – A business rule task
  id: totrans-43
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.1 – 业务规则任务
- en: 'The idea behind this type of task is that there are complex business rules
    that decide how a BPMN business process should behave (mostly, which path in the
    gateways should be taken) and that a way to handle such a decision should be made
    possible. Indeed, imagine a (not so) complicated process like the following:'
  id: totrans-44
  prefs: []
  type: TYPE_NORMAL
  zh: '这种任务背后的想法是存在复杂的业务规则，这些规则决定了BPMN业务流程应该如何行为（主要是，在网关中应该选择哪条路径）以及应该有一种处理此类决策的方法。确实，想象一下以下（并不那么）复杂的过程：  '
- en: '![Figure 12.2  – An example of a process with several rules](img/B21293_12_2.jpg)'
  id: totrans-45
  prefs: []
  type: TYPE_IMG
  zh: '![图12.2 – 具有多个规则的流程示例](img/B21293_12_2.jpg)'
- en: Figure 12.2 – An example of a process with several rules
  id: totrans-46
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.2 – 具有多个规则的流程示例
- en: For now, it is not too bad because there are only three types of contracts.
    But this is typically the kind of scenario that has many chances to scale (never
    underestimate the creativity of salespersons and marketing people). What if there
    are ten types of contract in the future, maybe with a third criterion to take
    into account? The process will become more and more complex and, soon, illegible,
    which would be a big problem, since business processes should always remain a
    helpful tool for teams and, specifically, not something that makes it more complicated
    for them to work.
  id: totrans-47
  prefs: []
  type: TYPE_NORMAL
  zh: 目前来说，情况还不错，因为只有三种类型的合同。但这通常是那种有很多机会扩展的场景（永远不要低估销售人员和市场营销人员的创造力）。如果未来有十种类型的合同，也许还需要考虑第三个标准呢？流程将变得越来越复杂，很快就会变得难以辨认，这将会是一个大问题，因为业务流程应该始终是团队的有用工具，而不是让他们的工作变得更复杂的东西。
- en: 'DMN proposes a solution, which is to externalize the decision rules in a dedicated
    place, in order to free up the design of the process itself. In the previous example,
    we would externalize the decision table like this:'
  id: totrans-48
  prefs: []
  type: TYPE_NORMAL
  zh: DMN提出了一种解决方案，即将决策规则外部化到一个专门的地方，以便释放流程本身的设计。在先前的例子中，我们会这样外部化决策表：
- en: '![Figure 12.3 – A decision table](img/B21293_12_3.jpg)'
  id: totrans-49
  prefs: []
  type: TYPE_IMG
  zh: '![图12.3 – 决策表](img/B21293_12_3.jpg)'
- en: Figure 12.3 – A decision table
  id: totrans-50
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.3 – 决策表
- en: 'This would allow us to draw the process in a much simpler way, as follows (note
    the icon in the second task, which corresponds to the `Business` `rule` type):'
  id: totrans-51
  prefs: []
  type: TYPE_NORMAL
  zh: 这将使我们能够以更简单的方式绘制流程，如下所示（注意第二个任务中的图标，它对应于`Business` `rule`类型）：
- en: '![Figure 12.4 – A simplified BPMN process](img/B21293_12_4.jpg)'
  id: totrans-52
  prefs: []
  type: TYPE_IMG
  zh: '![图12.4 – 简化的BPMN流程](img/B21293_12_4.jpg)'
- en: Figure 12.4 – A simplified BPMN process
  id: totrans-53
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.4 – 简化的BPMN流程
- en: Note
  id: totrans-54
  prefs: []
  type: TYPE_NORMAL
  zh: 注意
- en: Sadly, since there is no standardization of how data is collected in the different
    tasks of a BPMN process, there can be no standardized way either to call a DMN
    model. But it’s worth keeping informed about any updates to the norms at [https://www.omg.org/dmn/](https://www.omg.org/dmn/)
    since this is bound to change at some point in the future.
  id: totrans-55
  prefs: []
  type: TYPE_NORMAL
  zh: 很遗憾，由于BPMN流程中不同任务收集数据的方式没有标准化，因此调用DMN模型的方式也无法标准化。但是，值得了解[https://www.omg.org/dmn/](https://www.omg.org/dmn/)上的规范更新，因为这在未来的某个时候肯定会发生变化。
- en: 'The best part is that now that this logic has been decoupled from the business
    process itself, we could evolve to a much more complex definition of the type
    of contract, such as the following, without having to change anything on the process
    itself:'
  id: totrans-56
  prefs: []
  type: TYPE_NORMAL
  zh: 最好的部分是，现在这个逻辑已经从业务流程本身解耦，我们可以进化到一个更复杂的合同类型定义，如下所示，而无需对流程本身进行任何更改：
- en: '![Figure 12.5 – An extended decision table](img/B21293_12_5.jpg)'
  id: totrans-57
  prefs: []
  type: TYPE_IMG
  zh: '![图12.5 – 扩展的决策表](img/B21293_12_5.jpg)'
- en: Figure 12.5 – An extended decision table
  id: totrans-58
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.5 – 扩展的决策表
- en: This time, we also take into account the age of the author to issue some special
    contract that must be signed by the author’s parents. This is done by using a
    very simple expression here (`FEEL` expression language allows for much more sophisticated
    expressions (if you want to delve into more on this subject, [https://kiegroup.github.io/dmn-feel-handbook/#dmn-feel-handbook](https://kiegroup.github.io/dmn-feel-handbook/#dmn-feel-handbook)
    is a great starting point). You also may have spotted that the `AdditionalEdition`,
    since the result was common for any author as long as the book is a new edition
    of an existing one.
  id: totrans-59
  prefs: []
  type: TYPE_NORMAL
  zh: 这次，我们还考虑了作者的年龄，发布了一些必须由作者父母签署的特殊合同。这是通过这里的一个非常简单的表达式实现的（`FEEL`表达式语言允许使用更复杂的表达式，如果您想深入了解这个主题，[https://kiegroup.github.io/dmn-feel-handbook/#dmn-feel-handbook](https://kiegroup.github.io/dmn-feel-handbook/#dmn-feel-handbook)是一个很好的起点）。您也可能已经注意到，`AdditionalEdition`，因为只要这本书是现有版本的全新版，结果对任何作者都是通用的。
- en: 'Having these tables to externalize potentially complex rules is already a great
    advantage, but DMN also comes with a graphical way to represent the decision process
    itself:'
  id: totrans-60
  prefs: []
  type: TYPE_NORMAL
  zh: 拥有这些表来外部化可能复杂的规则已经是一个很大的优势，但DMN还提供了一种图形化的方式来表示决策过程本身：
- en: '![Figure 12.6 – An example decision graph](img/B21293_12_6.jpg)'
  id: totrans-61
  prefs: []
  type: TYPE_IMG
  zh: '![图12.6 – 决策图的示例](img/B21293_12_6.jpg)'
- en: Figure 12.6 – An example decision graph
  id: totrans-62
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.6 – 决策图的示例
- en: 'In our example, the diagram is very simple, since we use only two inputs (author
    and book information) in order to create a decision (the type of contract), possibly
    using a “knowledge source,” which would be our referential of contracts, although
    we did not relate to any such use in the simple example previously. However, these
    diagrams could be much more advanced and show hierarchical decisions if necessary.
    We could imagine that the type of contract decided on is then itself used to decide
    the content of a customized contract, depending on the regions of diffusion of
    the work, and that sales statistics are used to decide on a proposed amount for
    the contract:'
  id: totrans-63
  prefs: []
  type: TYPE_NORMAL
  zh: 在我们的例子中，图表非常简单，因为我们只使用了两个输入（作者和书籍信息）来创建一个决策（合同类型），可能使用“知识源”，即我们的合同参考，尽管我们在先前的简单示例中没有涉及此类使用。然而，这些图表可以更加复杂，并在必要时显示分层决策。我们可以想象，所决定的合同类型随后本身被用来决定定制合同的內容，这取决于作品的传播区域，并且销售统计数据被用来决定合同提议的金额：
- en: '![Figure 12.7 – An extended decision graph](img/B21293_12_7.jpg)'
  id: totrans-64
  prefs: []
  type: TYPE_IMG
  zh: '![图12.7 – 扩展的决策图](img/B21293_12_7.jpg)'
- en: Figure 12.7 – An extended decision graph
  id: totrans-65
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.7 – 扩展的决策图
- en: 'To give an idea of the XML structure of a DML file, here is the (shortened)
    content corresponding to this first example above, where you will easily recognize
    the first part with the decision rules (starting at `<decision>`) and the second
    part corresponding to the diagram (starting at `<dmndi:DMNDI>`):'
  id: totrans-66
  prefs: []
  type: TYPE_NORMAL
  zh: 为了给出 DML 文件 XML 结构的概念，以下是上述第一个示例的（缩短的）内容，其中你将很容易识别出以 `<decision>` 开始的决定规则的第一部分和以
    `<dmndi:DMNDI>` 开始的对应于图表的第二部分：
- en: '[PRE2]'
  id: totrans-67
  prefs: []
  type: TYPE_PRE
  zh: '[PRE2]'
- en: All the graphs shown previously were designed using the great tool provided
    by Camunda at [https://demo.bpmn.io/dmn](https://demo.bpmn.io/dmn). Now that you
    have an introductory knowledge of what DMN is about, let’s see how we can put
    the standard to work.
  id: totrans-68
  prefs: []
  type: TYPE_NORMAL
  zh: 所展示的所有图表都是使用 Camunda 提供的强大工具在 [https://demo.bpmn.io/dmn](https://demo.bpmn.io/dmn)
    上设计的。现在你已经对 DMN 的基本概念有了初步的了解，让我们看看如何将标准应用到实践中。
- en: Implementations
  id: totrans-69
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 实现
- en: The Business Rules Execution System landscape is quite small. The go-to implementation
    of DMN has been and remains the Java open source project called Drools. Drools
    is a BRMS that supports its own rules language but also DMN, and since DMN is
    the standard, all servers using Drools are based on it. You can use Drools directly
    in your Java applications, or even with some bridges to other platforms. In particular,
    there has been a Drools .NET implementation, and some projects such as [https://github.com/adamecr/Common.DMN.Engine](https://github.com/adamecr/Common.DMN.Engine)
    can help with that, but the maintenance of such projects is questionable, and
    I’d rather show you another way that – in my opinion – is more suitable to what
    we are trying to achieve, which is an aligned and adaptable information system.
  id: totrans-70
  prefs: []
  type: TYPE_NORMAL
  zh: 业务规则执行系统（Business Rules Execution System，简称 BRMS）的领域相当小。DMN 的首选实现一直是，并且仍然是名为
    Drools 的 Java 开源项目。Drools 是一个支持其自身规则语言的 BRMS，同时也支持 DMN，由于 DMN 是一个标准，因此所有使用 Drools
    的服务器都基于它。你可以在你的 Java 应用程序中直接使用 Drools，甚至通过一些桥梁连接到其他平台。特别是，已经有一个 Drools .NET 实现，一些项目如
    [https://github.com/adamecr/Common.DMN.Engine](https://github.com/adamecr/Common.DMN.Engine)
    可以帮助实现这一点，但这些项目的维护情况值得怀疑，我更愿意展示另一种——在我看来——更适合我们试图实现的目标的方法，即一个对齐且可适应的信息系统。
- en: To do so, we will get closer to a service-oriented architecture by using a BRMS
    server that exposes the business rule runtime through REST APIs. Sure, the performance
    will not be as strong as with an embedded library but remember that, first, “premature
    optimization is the root of all evil” and, second, that most calls of the business
    rules are not executed with high frequency (and when they need to be, we will
    show at the end of the chapter how we can adapt). Kogito has already been cited
    in the previous chapter, but we did not show a complete example of BPMN with it
    because, as was explained, this would be overkill for most cases, especially our
    sample `DemoEditor` information system. What is interesting is that Kogito also
    supports DMN, and that is why we are going to use it here – or, rather, use JBPM,
    which is the product that Kogito is based on.
  id: totrans-71
  prefs: []
  type: TYPE_NORMAL
  zh: 为了做到这一点，我们将通过使用一个暴露业务规则运行时通过 REST API 的 BRMS 服务器来更接近服务导向架构。当然，性能可能不会像使用嵌入式库那样强大，但请记住，首先，“过早优化是万恶之源”，其次，大多数业务规则的调用并不频繁（如果需要，我们将在本章末尾展示如何适应）。Kogito
    在上一章中已经被提及，但我们没有展示与它结合的完整 BPMN 示例，因为正如解释的那样，这对大多数情况来说都是过度设计，特别是我们的示例 `DemoEditor`
    信息系统。有趣的是，Kogito 也支持 DMN，这就是我们在这里使用它的原因——或者更准确地说，使用 JBPM，这是 Kogito 所基于的产品。
- en: In fact, Kogito is the cloud-native derivative of JBPM, a product maintained
    under the JBoss umbrella. Since we are not going to deploy in the cloud, instead
    keeping a Docker-based deployment of our applications to satisfy either SaaS or
    on-premise conditions, we will simply use JBPM in the following example. Still,
    keep in mind for your needs that Kogito may be a better alternative, particularly
    since it offers some functions that could be compared to a light MDM, exposing
    entities directly by REST APIs generated dynamically. If you want to go in this
    direction and see how a fully integrated cloud-oriented approach suits you, you
    can start with Docker images of Kogito, available at [https://github.com/kiegroup/kogito-images](https://github.com/kiegroup/kogito-images).
  id: totrans-72
  prefs: []
  type: TYPE_NORMAL
  zh: 事实上，Kogito是JBPM的云原生衍生产品，一个在JBoss旗下维护的产品。由于我们不会在云中部署，而是保持基于Docker的应用程序部署以满足SaaS或本地化条件，因此我们将在以下示例中简单地使用JBPM。然而，请记住，对于您的需求来说，Kogito可能是一个更好的选择，尤其是因为它提供了一些可以与轻量级MDM相比的功能，通过动态生成的REST
    API直接暴露实体。如果您想朝这个方向前进并查看一个完全集成的面向云的方法如何适合您，您可以从Kogito的Docker镜像开始，这些镜像可在[https://github.com/kiegroup/kogito-images](https://github.com/kiegroup/kogito-images)找到。
- en: The JBoss JBPM server that we are going to exploit is an all-in-one application,
    providing a frontend and a backend to design and operate BPMN workflows with DMN-based
    business rules. It works with Maven projects containing some Java code for the
    unit tests, and possibly for the exposition of the entities, but it can operate
    with simple standard files in DMN for our example.
  id: totrans-73
  prefs: []
  type: TYPE_NORMAL
  zh: 我们将要利用的JBoss JBPM服务器是一个一站式应用程序，提供前端和后端来设计和操作带有基于DMN业务规则的BPMN工作流。它与包含一些Java代码用于单元测试和可能用于实体展示的Maven项目一起工作，但也可以使用简单的标准DMN文件在我们的示例中运行。
- en: In the next section, we will explain how to operate a sample business rule engine
    in JBPM 7.74, using the Drools engine and a DMN definition of two business decisions
    with several parameters. For more information about how this works precisely,
    head over to [https://docs.jboss.org/drools/release/7.74.1.Final/drools-docs/html_single/](https://docs.jboss.org/drools/release/7.74.1.Final/drools-docs/html_single/).
    The reason why we use a sample provided by JBoss is that designing from scratch
    an example on the subject of `DemoEditor` would take up a whole chapter. In addition,
    it would be a completely artificial exercise, since a DMN rule engine, just like
    a BPMN engine in the previous chapter, would simply be overkill for our functional
    needs. It is essential that I respect the principal rule I have been repeating
    over and over since the beginning of this book, which is that the technical aspects
    should be completely defined by the functional needs. Although I – like most of
    us who are passionate about technology – would love to integrate a full-blown
    Kogito server in our sample information system, the truth is that it would not
    be suitable for our needs. The implementation of the business workflows and most
    business rules will simply be in dedicated .NET services. Only a particular case
    of business rules would be treated with a dedicated external service that strongly
    resembles a BRMS, namely the authorization rules. But I am anticipating the last
    section of this chapter, and for now, we are going to show how we can take advantage
    of a DMN-based BRMS in a business/IT-aligned context, using JBPM.
  id: totrans-74
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一节中，我们将解释如何在JBPM 7.74中操作一个示例业务规则引擎，使用Drools引擎和两个带有多个参数的业务决策的DMN定义。有关此工作精确方式的更多信息，请访问[https://docs.jboss.org/drools/release/7.74.1.Final/drools-docs/html_single/](https://docs.jboss.org/drools/release/7.74.1.Final/drools-docs/html_single/)。我们使用JBoss提供的示例的原因是，从头开始设计一个关于`DemoEditor`主题的示例将占用整整一章。此外，这将是一个完全人为的练习，因为DMN规则引擎，就像前一章中的BPMN引擎一样，对我们的功能需求来说将是过度设计。我必须尊重我从本书开始就反复强调的主要规则，即技术方面应由功能需求完全定义。尽管我——就像大多数对技术充满热情的人一样——希望在我们的示例信息系统中集成一个完整的Kogito服务器，但事实是它并不适合我们的需求。业务工作流和大多数业务规则的实施将简单地使用专门的.NET服务。只有特定类型的业务规则将使用一个专门的外部服务来处理，该服务强烈类似于BRMS，即授权规则。但我正在期待本章的最后一部分，现在，我们将展示如何在业务/IT对齐的背景下利用基于DMN的BRMS，使用JBPM。
- en: An example of DMN use
  id: totrans-75
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: DMN使用的示例
- en: 'Simple exercises such as the one that follows are really where Docker stands
    out because it will save us the hassle of installing Java and Maven, getting the
    right dependencies, updating versions, and so on. Provided you have Docker installed
    on your machine (and if this is not the case, you really should, as this tool
    is now part of your basic toolset, just like a web browser and a text editor),
    you can simply enter the following commands:'
  id: totrans-76
  prefs: []
  type: TYPE_NORMAL
  zh: 以下简单的练习正是 Docker 突出表现的地方，因为它将节省我们安装 Java 和 Maven、获取正确依赖项、更新版本等麻烦。只要你在机器上安装了
    Docker（如果还没有，你真的应该安装，因为这个工具现在已经成为你的基本工具集的一部分，就像网页浏览器和文本编辑器一样），你就可以简单地输入以下命令：
- en: '[PRE3]'
  id: totrans-77
  prefs: []
  type: TYPE_PRE
  zh: '[PRE3]'
- en: Note that the `latest` tag, at the time of writing, was the `7.74.1.Final` version.
    It is generally recommended to use the `latest` tag as much as possible, but if
    you ever encounter a functional problem replaying the example, give it a try using
    this precise version, even if it is not the latest anymore. The first Docker command
    will start a container based on the image containing everything that is needed
    to design, build, test, and deploy projects, including the BPMN and DMN assets.
    This is where we will manipulate the DMN model. If you want to get some more information
    about this image, the reference page is [https://quay.io/repository/kiegroup/business-central-workbench-showcase](https://quay.io/repository/kiegroup/business-central-workbench-showcase).
    The second Docker command runs a container onto which the project will be deployed
    and that will act as a separate business rule execution engine, or a simple runtime
    if you prefer to think of it that way. The reference page for this second image
    is [https://quay.io/repository/kiegroup/kie-server-showcase](https://quay.io/repository/kiegroup/kie-server-showcase).
  id: totrans-78
  prefs: []
  type: TYPE_NORMAL
  zh: 注意，截至写作时，`latest` 标签是 `7.74.1.Final` 版本。通常建议尽可能多地使用 `latest` 标签，但如果您在重新播放示例时遇到功能问题，请尝试使用这个精确版本，即使它不再是最新版本。第一个
    Docker 命令将启动一个基于包含设计、构建、测试和部署项目所需一切内容的镜像的容器，包括 BPMN 和 DMN 资产。这就是我们将操作 DMN 模型的地方。如果您想获取有关此镜像的更多信息，参考页面是
    [https://quay.io/repository/kiegroup/business-central-workbench-showcase](https://quay.io/repository/kiegroup/business-central-workbench-showcase)。第二个
    Docker 命令在一个容器上运行项目，该容器将作为单独的业务规则执行引擎，或者如果您更喜欢这样想，它将作为一个简单的运行时。此第二个镜像的参考页面是 [https://quay.io/repository/kiegroup/kie-server-showcase](https://quay.io/repository/kiegroup/kie-server-showcase)。
- en: Once everything has started (you should allow for some time – up to one minute
    – for the completion of the startup routine), you can access the console by navigating
    to `http://localhost:8080/business-central`, where you will be able to connect
    with the default credentials, `admin`/`admin` (the documentation cited previously
    provides other credentials for users with different authorization profiles, as
    well as how to set up production-ready authorization).
  id: totrans-79
  prefs: []
  type: TYPE_NORMAL
  zh: 一切启动完成后（您应该允许一些时间——最多一分钟——以完成启动程序），您可以通过导航到 `http://localhost:8080/business-central`
    访问控制台，在那里您可以使用默认凭据 `admin`/`admin`（之前引用的文档为具有不同授权配置文件的用户提供了其他凭据，以及如何设置生产就绪的授权）进行连接。
- en: '![Figure 12.8 – The JPBM login page](img/B21293_12_8.jpg)'
  id: totrans-80
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.8 – JPBM 登录页面](img/B21293_12_8.jpg)'
- en: Figure 12.8 – The JPBM login page
  id: totrans-81
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.8 – JPBM 登录页面
- en: Once connected, you will be presented with the welcome page interface, which
    you can return to at any time by clicking on **Business Central**, or the home
    icon in the top-left part of the screen.
  id: totrans-82
  prefs: []
  type: TYPE_NORMAL
  zh: 一旦连接，您将看到欢迎页面界面，您可以通过点击 **业务中心** 或屏幕左上角的首页图标随时返回。
- en: '![Figure 12.9 – The JPBM welcome page](img/B21293_12_9.jpg)'
  id: totrans-83
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.9 – JPBM 欢迎页面](img/B21293_12_9.jpg)'
- en: Figure 12.9 – The JPBM welcome page
  id: totrans-84
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.9 – JPBM 欢迎页面
- en: 'In the **Design** section, click on **Projects**. This will bring you to an
    interface in which you can manage your JBPM projects:'
  id: totrans-85
  prefs: []
  type: TYPE_NORMAL
  zh: 在 **设计** 部分点击 **项目**。这将带您到一个界面，您可以在此管理您的 JBPM 项目：
- en: '![Figure 12.10 – A list of JPBM spaces](img/B21293_12_10.jpg)'
  id: totrans-86
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.10 – JPBM 空间的列表](img/B21293_12_10.jpg)'
- en: Figure 12.10 – A list of JPBM spaces
  id: totrans-87
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.10 – JPBM 空间的列表
- en: Spaces are used to organize work and separate groups of projects from one another.
    In this simple tryout of the technology, simply select the existing **MySpace**
    space.
  id: totrans-88
  prefs: []
  type: TYPE_NORMAL
  zh: 空间用于组织工作和将一组项目与其他项目分开。在这个技术的简单试用中，只需选择现有的 **MySpace** 空间。
- en: '![Figure 12.11 – A JPBM space without any project](img/B21293_12_11.jpg)'
  id: totrans-89
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.11 – 没有任何项目的 JPBM 空间](img/B21293_12_11.jpg)'
- en: Figure 12.11 – A JPBM space without any project
  id: totrans-90
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.11 – 没有任何项目的 JPBM 空间
- en: 'The space just created is, of course, empty for now. We are going to use one
    of the embedded examples to illustrate how JBPMN works and what we are particularly
    interested in right now, namely the DMN rules engine. To do so, click on **Try
    Samples**, which will bring you to the following interface:'
  id: totrans-91
  prefs: []
  type: TYPE_NORMAL
  zh: 刚创建的空间现在当然是空的。我们将使用其中一个嵌入式示例来说明 JBPMN 的工作原理以及我们目前特别感兴趣的内容，即 DMN 规则引擎。为此，请点击**尝试示例**，这将带您进入以下界面：
- en: '![Figure 12.12 – Choosing sample projects](img/B21293_12_12.jpg)'
  id: totrans-92
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.12 – 选择示例项目](img/B21293_12_12.jpg)'
- en: Figure 12.12 – Choosing sample projects
  id: totrans-93
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.12 – 选择示例项目
- en: 'There, select the **Traffic_Violation** sample project and click on **OK**.
    You should receive a message stating that the project has been correctly imported,
    and you will land on a page that shows the assets contained by the sample project:'
  id: totrans-94
  prefs: []
  type: TYPE_NORMAL
  zh: 在那里，选择**Traffic_Violation**示例项目并点击**确定**。你应该会收到一条消息，说明项目已正确导入，并且你会进入一个显示示例项目包含的资产的页面：
- en: '![Figure 12.13 – Assets of the traffic violation JBPM sample](img/B21293_12_13.jpg)'
  id: totrans-95
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.13 – 交通违规 JBPM 示例的资产](img/B21293_12_13.jpg)'
- en: Figure 12.13 – Assets of the traffic violation JBPM sample
  id: totrans-96
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.13 – 交通违规 JBPM 示例的资产
- en: 'Of course, the asset that interests us most is the DMN model. Click on the
    **Traffic Violation** asset to analyze it, and you will be led to the following
    interface, which shows the main part of the DMN model, the decision graph:'
  id: totrans-97
  prefs: []
  type: TYPE_NORMAL
  zh: 当然，我们最感兴趣的资产是 DMN 模型。点击**Traffic_Violation**资产进行分析，你将被引导到以下界面，该界面显示了 DMN 模型的主体部分，即决策图：
- en: '![Figure 12.14 – A sample DMN decision graph](img/B21293_12_14.jpg)'
  id: totrans-98
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.14 – 一个示例 DMN 决策图](img/B21293_12_14.jpg)'
- en: Figure 12.14 – A sample DMN decision graph
  id: totrans-99
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.14 – 一个示例 DMN 决策图
- en: If you have a driver’s license, the understanding of this example should be
    self-explanatory – the violation of the speed limit provides data to calculate
    the associated fine. Then, depending on the fine and additional context on the
    driver, another decision is taken, regarding whether a suspension of the driver’s
    license should be invoked.
  id: totrans-100
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你拥有驾照，这个示例的理解应该是显而易见的——超速违规提供了计算相关罚款的数据。然后，根据罚款和驾驶员的额外背景信息，将采取另一个决定，关于是否应该吊销驾驶员的执照。
- en: 'If you now click on the menu on the left, on the **Decision Table** entry of
    the **Fine** section, you will be shown the following table that describes the
    conditions of application of the decision:'
  id: totrans-101
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你现在点击左侧菜单中的**Fine**部分的**Decision Table**条目，你会看到以下表格，该表格描述了决策应用的条件：
- en: '![Figure 12.15 – A sample DMN decision table](img/B21293_12_141.jpg)'
  id: totrans-102
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.15 – 一个示例 DMN 决策表](img/B21293_12_141.jpg)'
- en: Figure 12.15 – A sample DMN decision table
  id: totrans-103
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.15 – 一个示例 DMN 决策表
- en: 'Now, go back to the project by using the breadcrumbs menu at the top, and then
    click **Deploy** in the top menu that appears:'
  id: totrans-104
  prefs: []
  type: TYPE_NORMAL
  zh: 现在，通过顶部导航的面包屑菜单返回项目，然后点击顶部菜单中出现的**部署**：
- en: '![Figure 12.16 – The JBPM build and deploy menu](img/B21293_12_15.jpg)'
  id: totrans-105
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.16 – JBPM 构建和部署菜单](img/B21293_12_15.jpg)'
- en: Figure 12.16 – The JBPM build and deploy menu
  id: totrans-106
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.16 – JBPM 构建和部署菜单
- en: 'After a bit of time, you should see a message stating that the build is successful,
    and then a second one, like the one shown in the following figure, that explains
    that everything is now ready to exploit the decision engine:'
  id: totrans-107
  prefs: []
  type: TYPE_NORMAL
  zh: 经过一段时间后，你应该会看到一条消息，说明构建成功，然后是第二条消息，如图所示，解释说现在一切准备就绪，可以利用决策引擎：
- en: '![Figure 12.17 – The JBPM deployment success notification](img/B21293_12_16.jpg)'
  id: totrans-108
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.17 – JBPM 部署成功通知](img/B21293_12_16.jpg)'
- en: Figure 12.17 – The JBPM deployment success notification
  id: totrans-109
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.17 – JBPM 部署成功通知
- en: 'If you care to take a look at the deployment results, you can activate the
    **Menu**/**Execution Servers** command and watch how servers are configured and
    deployment units are organized on them. You can then start and stop execution
    servers from this console, or even remove deployments:'
  id: totrans-110
  prefs: []
  type: TYPE_NORMAL
  zh: 如果你想要查看部署结果，可以激活**菜单**/**执行服务器**命令，并观察服务器是如何配置的以及部署单元是如何在它们上面组织的。然后，你可以从这个控制台启动和停止执行服务器，甚至可以删除部署：
- en: '![Figure 12.18 – The JBPM servers management interface](img/B21293_12_18.0.jpg)'
  id: totrans-111
  prefs: []
  type: TYPE_IMG
  zh: '![图 12.18 – JBPM 服务器管理界面](img/B21293_12_18.0.jpg)'
- en: Figure 12.18 – The JBPM servers management interface
  id: totrans-112
  prefs: []
  type: TYPE_NORMAL
  zh: 图 12.18 – JBPM 服务器管理界面
- en: Since everything is now set up and deployed, we are able to exploit the business
    rules.
  id: totrans-113
  prefs: []
  type: TYPE_NORMAL
  zh: 由于一切现在都已设置和部署，我们能够利用业务规则。
- en: Calling the business rule runtime
  id: totrans-114
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
  zh: 调用业务规则运行时
- en: 'Checking how effective the engine is, is simply a matter of calling a REST
    API that has been exposed dynamically for us to consume. In order to do so, and
    since the engine is (logically) exposed through a `POST` verb, we need a tool
    a bit more advanced than a simple web browser, such as Postman. To access the
    API, you will have to use the port number that was associated with the second
    Docker container we ran – in our example, `8180`. The rest of the URL is composed
    like this:'
  id: totrans-115
  prefs: []
  type: TYPE_NORMAL
  zh: 检查引擎的有效性，只需调用一个为我们提供动态暴露的REST API即可。为了做到这一点，由于引擎（逻辑上）通过`POST`动词暴露，我们需要一个比简单网页浏览器更先进的工具，例如Postman。要访问API，您将必须使用与我们运行的第二个Docker容器关联的端口号
    – 在我们的例子中，`8180`。URL的其余部分如下所示：
- en: '`/kie-server` corresponds to the application server of the rules execution
    engine (or **BRE** for **Business** **Rules Execution**)'
  id: totrans-116
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/kie-server`对应于规则执行引擎的应用服务器（或**BRE**代表**业务规则执行**）'
- en: '`/services/rest` indicates that we will be accessing the REST APIs'
  id: totrans-117
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/services/rest`表示我们将访问REST API'
- en: '`/server/containers` is linked to the fact that BRE servers are exposed through
    containers, each deployment unit being separate from the others'
  id: totrans-118
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/server/containers`与BRE服务器通过容器暴露的事实相关联，每个部署单元与其他部署单元分开'
- en: '`/traffic-violation_1.0.0-SNAPSHOT` is the identity of the project that we
    have chosen to deploy in this unit'
  id: totrans-119
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/traffic-violation_1.0.0-SNAPSHOT`是我们选择在本单元中部署的项目标识'
- en: '`/dmn` corresponds to the resource we are interested in this project, namely
    the decision management system'
  id: totrans-120
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: '`/dmn`对应于我们在这个项目中感兴趣的资源，即决策管理系统'
- en: 'The content of the body should be adjusted to `raw`/`json` and contain the
    following data:'
  id: totrans-121
  prefs: []
  type: TYPE_NORMAL
  zh: 请求体的内容应调整为`raw`/`json`，并包含以下数据：
- en: '[PRE4]'
  id: totrans-122
  prefs: []
  type: TYPE_PRE
  zh: '[PRE4]'
- en: '`model-namespace` corresponds to the unique identifier of the project, and
    `dmn-context` indicates the values that should be fed to the rules engine for
    execution. The interface should look like the following:'
  id: totrans-123
  prefs: []
  type: TYPE_NORMAL
  zh: '`model-namespace`对应于项目的唯一标识符，而`dmn-context`表示应该提供给规则引擎以执行其值的值。界面应如下所示：'
- en: '![Figure 12.19 – A sample Postman call](img/B21293_12_19.0.jpg)'
  id: totrans-124
  prefs: []
  type: TYPE_IMG
  zh: '![图12.19 – 一个示例Postman调用](img/B21293_12_19.0.jpg)'
- en: Figure 12.19 – A sample Postman call
  id: totrans-125
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.19 – 一个示例Postman调用
- en: 'In order for this to work, you need to go to the `kieserver` as the username
    and `kieserver1!` as the password (these are the default values that, of course,
    would change if working in production):'
  id: totrans-126
  prefs: []
  type: TYPE_NORMAL
  zh: 为了使这可行，您需要以`kieserver`作为用户名和`kieserver1!`作为密码登录到`kieserver`（这些是默认值，当然，在生产环境中这些值会改变）：
- en: '![Figure 12.20 – Postman authentication settings](img/B21293_12_20.0.jpg)'
  id: totrans-127
  prefs: []
  type: TYPE_IMG
  zh: '![图12.20 – Postman认证设置](img/B21293_12_20.0.jpg)'
- en: Figure 12.20 – Postman authentication settings
  id: totrans-128
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.20 – Postman认证设置
- en: 'Finally, after sending the message to the server, the complete response is
    the following:'
  id: totrans-129
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，在向服务器发送消息后，完整的响应如下：
- en: '[PRE5]'
  id: totrans-130
  prefs: []
  type: TYPE_PRE
  zh: '[PRE5]'
- en: 'What interests us in particular is how `dmn-context` has been completed, with
    the results of the decision. In our case, the fine will be 3 points and 500 units
    of money, and the result of the driver’s license suspension decision will be negative.
    But change `Actual Speed` to `135` in the body of the request, send it again,
    and watch the impact on the results:'
  id: totrans-131
  prefs: []
  type: TYPE_NORMAL
  zh: 我们特别感兴趣的是`dmn-context`是如何完成的，以及决策的结果。在我们的案例中，罚款将是3分和500单位货币，而驾驶执照吊销决策的结果将是负面的。但将请求体中的`Actual
    Speed`更改为`135`，再次发送，并观察对结果的影响：
- en: '[PRE6]'
  id: totrans-132
  prefs: []
  type: TYPE_PRE
  zh: '[PRE6]'
- en: 'The engine is, thus, ready to be used in any information system that can handle
    REST APIs (which is any platform on earth, except for a few very exotic exceptions).
    Note there is also everything you need inside the JBPM platform to perform tests
    on the decisions that have been built. A test with Postman was preferred because
    it is closer to how the BRE would be exploited by another application, but if
    you click on the `Violation Scenarios` asset, you will be brought to this nice
    interface, where you can execute preliminary tests in order to make sure everything
    works fine before deployment:'
  id: totrans-133
  prefs: []
  type: TYPE_NORMAL
  zh: 因此，该引擎已准备好在任何可以处理REST API的信息系统中使用（这是地球上除少数非常罕见的例外情况之外的所有平台）。注意，在JBPM平台内部也有所有进行测试所需的一切，以测试已构建的决策。由于Postman更接近另一个应用程序如何利用BRE，因此更喜欢使用Postman进行测试，但如果你点击`违规场景`资产，你将被带到这个很棒的界面，在那里你可以执行初步测试，以确保在部署之前一切正常：
- en: '![Figure 12.21 – A JBPM-integrated automatic test interface](img/B21293_12_21.jpg)'
  id: totrans-134
  prefs: []
  type: TYPE_IMG
  zh: '![图12.21 – 一个集成了JBPM的自动测试界面](img/B21293_12_21.jpg)'
- en: Figure 12.21 – A JBPM-integrated automatic test interface
  id: totrans-135
  prefs: []
  type: TYPE_NORMAL
  zh: 图12.21 – 一个集成了JBPM的自动测试界面
- en: Also, if you want to understand better how to create your own project (which
    is outside of the scope of this book, where we focus only on how to use existing
    projects to correctly structure an information system), the best starting point
    is the code source of the example used previously, which can be found at [https://github.com/kiegroup/kie-wb-playground/tree/main/traffic-violation](https://github.com/kiegroup/kie-wb-playground/tree/main/traffic-violation).
    You can also follow the detailed instructions on how to build this project from
    the console, as explained at [https://docs.jboss.org/drools/release/7.51.0.Final/drools-docs/html_single/#dmn-gs-new-project-creating-proc_getting-started-decision-services](https://docs.jboss.org/drools/release/7.51.0.Final/drools-docs/html_single/#dmn-gs-new-project-creating-proc_getting-started-decision-services).
  id: totrans-136
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，如果你想更好地了解如何创建自己的项目（这超出了本书的范围，本书只关注如何使用现有项目来正确构建信息系统），最佳起点是之前使用的示例代码源，可以在
    [https://github.com/kiegroup/kie-wb-playground/tree/main/traffic-violation](https://github.com/kiegroup/kie-wb-playground/tree/main/traffic-violation)
    找到。你还可以按照在 [https://docs.jboss.org/drools/release/7.51.0.Final/drools-docs/html_single/#dmn-gs-new-project-creating-proc_getting-started-decision-services](https://docs.jboss.org/drools/release/7.51.0.Final/drools-docs/html_single/#dmn-gs-new-project-creating-proc_getting-started-decision-services)
    中解释的详细说明，从控制台构建此项目。
- en: 'Finally, we will complete this example with a very simple (thanks to Docker)
    clean-out procedure (be aware that this will erase all data associated with the
    exercise):'
  id: totrans-137
  prefs: []
  type: TYPE_NORMAL
  zh: 最后，我们将通过一个非常简单的（多亏了 Docker）清理程序来完成此示例（请注意，这将删除与练习相关的所有数据）：
- en: '[PRE7]'
  id: totrans-138
  prefs: []
  type: TYPE_PRE
  zh: '[PRE7]'
- en: Everything should be reverted to the state the test machine was in before creating
    this example, which leaves us with the conclusion of this chapter.
  id: totrans-139
  prefs: []
  type: TYPE_NORMAL
  zh: 所有的内容都应该恢复到创建此示例之前测试机器的状态，这使我们得出本章的结论。
- en: Summary
  id: totrans-140
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
  zh: 摘要
- en: In this chapter, we showed what a Business Rules Management System does, how
    useful it can be in an information system, and how we can implement one, starting
    with a functional example and demonstrating afterward another example relating
    to authorizations, which are one of the most used sets of business rules in software
    applications.
  id: totrans-141
  prefs: []
  type: TYPE_NORMAL
  zh: 在本章中，我们展示了业务规则管理系统的作用，它在信息系统中的有用性，以及我们如何实现它，从功能示例开始，然后展示与授权相关的另一个示例，授权是软件应用中最常用的业务规则集之一。
- en: Just like BPMN engines, BRMS engines are not used very often. In fact, business
    rules are – in the great majority of cases – implemented in code expressions or
    compiled into applications. This is absolutely normal because a BRMS represents
    an important investment, and implementing such complex applications really needs
    a strong business case, where business rules change very frequently, they are
    associated with high regulatory or marketing constraints (such as the necessity
    to trace all business rules and their changes), there is capacity to simulate
    the effects of new versions of sets of business rules, and so on. It is clear,
    then, that this approach is currently limited to very rare contexts. Things may,
    of course, change in the future, with the longed-for industrialization of information
    system designs, but currently, BPMNs and BRMSs are efforts that are almost always
    overkill.
  id: totrans-142
  prefs: []
  type: TYPE_NORMAL
  zh: 就像 BPMN 引擎一样，BRMS 引擎并不经常使用。实际上，在绝大多数情况下，业务规则都是通过代码表达式实现的，或者编译到应用程序中。这是绝对正常的，因为
    BRMS 代表着重要的投资，而实现如此复杂的应用程序确实需要强大的业务案例，其中业务规则变化非常频繁，它们与高监管或营销约束相关（例如，需要跟踪所有业务规则及其变化），有模拟业务规则集新版本影响的能力，等等。因此，很明显，这种方法目前仅限于非常罕见的情况。当然，随着信息系统设计工业化的期待，未来事情可能会发生变化，但目前，BPMNs
    和 BRMSs 几乎总是过度设计。
- en: And since two of the three parts of the ideal system are not worth using by
    most organizations, that means that this system remains utopic. Moreover, even
    a centralized MDM approach is complicated. The MDM practices per se are applicable
    to every business domain, so there is no problem with data referential – they
    are not very complicated to set up, as we will see in practice in [*Chapter 16*](B21293_16.xhtml#_idTextAnchor588)
    and the upcoming chapters and they bring lots of business value and advantages.
    However, the ideal system aims for a generic MDM, dynamically adjusting to every
    entity in the business context of an application. This additional sophistication
    is also out of context for now, although static code generation for data referential
    is becoming a viable option, as will be shown at the end of [*Chapter 19*](B21293_19.xhtml#_idTextAnchor634).
  id: totrans-143
  prefs: []
  type: TYPE_NORMAL
  zh: 由于理想系统的三个部分中有两个对大多数组织来说不值得使用，这意味着这个系统仍然是乌托邦式的。此外，即使是集中式的 MDM 方法也很复杂。MDM 实践本身适用于每个业务领域，所以数据参照没有问题——它们并不复杂，正如我们将在第
    [*16 章*](B21293_16.xhtml#_idTextAnchor588) 和接下来的章节中看到的那样，并且它们带来了大量的商业价值和优势。然而，理想系统旨在实现通用的
    MDM，能够动态地适应应用业务环境中的每个实体。这种额外的复杂性目前还不适用，尽管数据参照的静态代码生成正在成为一种可行的选择，这将在第 [*19 章*](B21293_19.xhtml#_idTextAnchor634)
    的结尾展示。
- en: 'In addition, we have shown that the three responsibilities of an ideal information
    system are, ultimately, quite interrelated with each other:'
  id: totrans-144
  prefs: []
  type: TYPE_NORMAL
  zh: 此外，我们已经表明，理想信息系统的三个责任最终是相当相互关联的：
- en: MDM uses business rules in its validation of data
  id: totrans-145
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: MDM 在其数据验证中使用业务规则
- en: A BRMS needs data from MDM to apply business rules and decide their output value
  id: totrans-146
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BRMS 需要从 MDM 获取数据来应用业务规则并决定它们的输出值
- en: A BPMN serves mainly as a collector of data to feed MDM, while also consuming
    data from MDM
  id: totrans-147
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BPMN 主要作为数据收集器，为 MDM 提供数据，同时也从 MDM 消费数据
- en: A BPMN also uses business rules to know where to go in the different gateways
    (and sometimes to calculate some additional data during a given task)
  id: totrans-148
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
  zh: BPMN 还使用业务规则来确定在不同网关中的走向（有时在执行给定任务期间计算一些额外的数据）
- en: All this proves that, technically, this assembly of three generic servers for
    MDM, BPM, and BRMS is not so feasible, and neither achieves a perfect decoupling.
    So, why did we bother in [*Chapter 5*](B21293_05.xhtml#_idTextAnchor164) and the
    last three chapters to discuss such an ideal system? Again, the answer lies in
    the business/IT alignment. The ideal system is not something that can be realized
    in practice in information systems today (and certainly for at least a few more
    decades), but it has the great advantage of forcing an architect to think in terms
    of three generic, always applicable, functional responsibilities. Even if you
    use a unique software application, knowing how to separate the data management,
    the business rules management, and the business process execution provides a great
    step toward decoupling your information system (which is not achieved at all with
    *n*-tier architecture, for example). As you will see in the upcoming chapters,
    constructing an information system with these principles in mind will help us
    achieve a very complex goal, which is to be able to modify important functional
    rules and behaviors very easily, in most cases without any significant impact
    on the implementation.
  id: totrans-149
  prefs: []
  type: TYPE_NORMAL
  zh: 所有这些都证明，从技术上讲，这个为 MDM、BPM 和 BRMS 设计的三个通用服务器组合并不可行，也没有实现完美的解耦。那么，为什么我们在 [*第 5
    章*](B21293_05.xhtml#_idTextAnchor164) 和最后三章中讨论这样一个理想系统呢？答案再次在于业务/IT 对齐。理想系统并不是今天的信息系统中可以实现的（当然至少在未来几十年内也不可能实现），但它有一个巨大的优势，那就是迫使架构师从三个通用、始终适用的功能责任的角度来思考。即使你使用一个独特的软件应用，了解如何分离数据管理、业务规则管理和业务流程执行，这也能为解耦你的信息系统迈出重要的一步（例如，*n*-层架构根本无法实现这一点）。正如你将在接下来的章节中看到的，本着这些原则构建信息系统将帮助我们实现一个非常复杂的目标，即能够非常容易地修改重要的功能规则和行为，在大多数情况下不会对实施产生任何重大影响。
- en: In the next chapter, as explained in the introduction, we will show a particular
    use case – yet very important application – of business rules management, which
    is using rules to determine and enforce authorization in a software application.
    Although we have shown a few examples in this chapter, the most complete description
    of how to use a BRMS will happen in the next chapter, by applying dedicated authorization
    management policies to our good old sample information system.
  id: totrans-150
  prefs: []
  type: TYPE_NORMAL
  zh: 在下一章中，正如引言中所述，我们将展示一个特定的用例——一个非常重要的业务规则管理应用——即使用规则在软件应用程序中确定和执行授权。尽管我们已经在本章中展示了几个例子，但如何使用BRMS的完整描述将在下一章中发生，我们将通过应用专门的授权管理策略到我们熟悉的示例信息系统中来实现。
