- en: '8'
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: CI/CD – Publishing with GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: One of the features of microservices is their ability to continuously build
    and deploy services. In the previous chapters, we automatically created the infrastructure
    that’s used by our service solution.
  prefs: []
  type: TYPE_NORMAL
- en: In this chapter, we’ll continue to automatically build and update services and
    use protection rules before deploying applications to staging and production environments.
    While doing this, you’ll learn how to use feature flags with Azure App Configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'In this chapter, you’ll learn how to do the following:'
  prefs: []
  type: TYPE_NORMAL
- en: Use GitHub Actions
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Build and test the application automatically after a pull request
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploy the application to test environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use deployment protection rules before deploying the application to production
    environments
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Publish NuGet packages
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Use feature flags with modern deployment patterns
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Technical requirements
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: In this chapter, similar to the previous chapter, you’ll need an Azure subscription,
    the Azure CLI, the Azure Developer CLI, and .NET Aspire. You’ll also need your
    own GitHub repository so that you can store secrets, create environments, and
    run GitHub actions. These features are available in public repositories. If you
    create a private repository, the GitHub Team feature is required for creating
    environments (see [https://github.com/pricing](https://github.com/pricing)).
  prefs: []
  type: TYPE_NORMAL
- en: 'The source code for this chapter can be found in this book’s GitHub repository:
    [https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure](https://github.com/PacktPublishing/Pragmatic-Microservices-with-CSharp-and-Azure).'
  prefs: []
  type: TYPE_NORMAL
- en: 'The `ch08` folder contains the following projects, along with the output for
    this chapter:'
  prefs: []
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs`: The `game-apis` project we used in the previous chapter
    has been enhanced using feature flags.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.Bot`: This is the implementation of `bot-service`, which plays
    games.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Codebreaker.GameAPIs.KiotaClient`: This is the client library we created in
    [*Chapter 4*](B21217_04.xhtml#_idTextAnchor092) to be used by clients.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`Workflows`: This folder is new. Here, you will find all the GitHub Actions
    workflows. However, these don’t become active until you copy them to the `.github/workflows`
    folder in your repository.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: To work through the code with this chapter, you can use the `service` and `bot`
    projects from the previous chapter, as well as the `Kiota` library from [*Chapter
    4*](B21217_04.xhtml#_idTextAnchor092).
  prefs: []
  type: TYPE_NORMAL
- en: For this chapter, you’ll need GitHub rights to run GitHub workflows, as well
    as to create and use GitHub environments with protection rules. The easiest way
    to do this is to create a public repository and copy just the code from this chapter
    into it. Create the `src` folder in this new repository and copy the source code
    to this folder.
  prefs: []
  type: TYPE_NORMAL
- en: Check out the README file in the `ch08` folder of this book’s GitHub repository
    for the latest updates.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the solution using the Azure Developer CLI
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'First, let’s prepare the solution using the Azure Developer CLI. When initializing
    the solution, set the current folder to the root folder of the repository (not
    the folder of the solution file, as we did previously):'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE0]'
  prefs: []
  type: TYPE_PRE
- en: Select `bot` and `game-apis` as projects to be exposed to the internet, and
    enter a new environment name – for example, `codebreaker-08-dev`. The generated
    `azure.yaml` file, which contains a link to the AppHost project file, needs to
    be committed to the source code repository. The generated `.azure` folder can
    contain secrets and has been – because of the generated `.gitignore` file – excluded
    from the source code repository.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The reason to use the root directory of the `azd pipeline` command used later;
    At the time of writing, this command requires the `.github/workflows` directory
    to be in the same folder. Some changes are planned for a later release, so please
    check the README file for this chapter for updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, let’s deploy the resources to Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE1]'
  prefs: []
  type: TYPE_PRE
- en: With `azd up`, the resources are deployed to your configured environment. Select
    the Azure subscription you wish to use and the Azure region where you want to
    deploy the resources.
  prefs: []
  type: TYPE_NORMAL
- en: The generated file, `azure.yaml`, references the AppHost project. The generated
    folder, `.azure` (which has been excluded from the source code repository because
    of possible secrets being stored), contains the current environment and a folder
    that has the same name as the environment. This folder contains the `config.json`
    file, which lists the publicly accessible service configuration, and the `.env`
    file, which contains variables referencing the created Azure resources.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, we are ready to use GitHub Actions. You can remove the Azure resources
    with `azd down` again since the complete infrastructure should have been deployed
    via GitHub Actions:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE2]'
  prefs: []
  type: TYPE_PRE
- en: Answer `y` to delete the resources, and then `y` again to permanently delete
    the resources that have soft delete enabled.
  prefs: []
  type: TYPE_NORMAL
- en: If you want to permanently delete resources, open the Azure portal ([https://portal.azure.com](https://portal.azure.com)),
    go to **Key Vault**, and click on **Manage deleted vaults**. Key vaults that are
    deleted need to be purged so that you can create a resource with the same name
    again. Purge the key vaults. Similarly, check for Azure App Configuration services
    that need to be purged.
  prefs: []
  type: TYPE_NORMAL
- en: Exploring GitHub Actions
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: '**GitHub Actions** is a feature of GitHub that you can use to automatically
    build, test, and deploy source code. GitHub Actions is a product that consists
    of *workflows*, *events*, *jobs*, *actions*, and *runners*:'
  prefs: []
  type: TYPE_NORMAL
- en: A `.github/workflows` folder of a repository. A workflow contains events and
    jobs.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **event** specifies what triggers a workflow. When should the workflow be
    started?
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **job** consists of steps that are executed on a **runner** machine.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: A **step** can run a script or an action.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: An **action** is a reusable GitHub extension that reduces the need to write
    scripts. Many of these reusable extensions can be used to build and deploy applications.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Now that we’ve set the foundation with these terms, let’s get into the details
    by creating a workflow using the Azure portal.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub Actions workflow
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'There are several options to automatically create GitHub Actions workflows
    to deploy services to Microsoft Azure. Using the Azure portal, upon opening **Container
    App**, you can select **Continuous deployment** under **Settings**, as shown in
    *Figure 8**.1*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.1 – Creating a GitHub Actions workflow from the Azure portal](img/B21217_08_01.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.1 – Creating a GitHub Actions workflow from the Azure portal
  prefs: []
  type: TYPE_NORMAL
- en: Using the Azure portal, you can select the GitHub repository, configure the
    Azure Container Registry you wish to use, and specify a **Service Principal**
    or a **User-assigned Identity** value to be used to publish the project.
  prefs: []
  type: TYPE_NORMAL
- en: 'Another option is to use Visual Studio. With Visual Studio, you can select
    a project (for example, `game-apis`) and select **Publish…** from the context
    menu. Upon adding a new publish profile, which you can do by selecting **Azure**
    | **Azure Container Apps (Linux)**, then selecting **Container App**, then Container
    Registry, the following dialogue appears:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.2 – Creating a GitHub Actions workflow via Visual Studio](img/B21217_08_02.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.2 – Creating a GitHub Actions workflow via Visual Studio
  prefs: []
  type: TYPE_NORMAL
- en: From this dialogue, you can directly publish to the Azure Container App or create
    a GitHub Actions workflow.
  prefs: []
  type: TYPE_NORMAL
- en: What’s common with these options is that you can publish service by service.
    Here, you used `azd up` to deploy the complete solution. Let’s have a look at
    what the Azure Developer CLI has to offer to create GitHub Actions workflows.
  prefs: []
  type: TYPE_NORMAL
- en: First, you need to create a `.github` folder in the root directory of the repository.
    Files that are used by specific GitHub functionality are stored in this folder.
    To this folder, add a `workflows` folder (`.github/workflows`). All the GitHub
    Actions workflows need to be stored within this folder.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, create the `codebreaker-deploy.yml` file. Now, copy the content of the
    `azure-deploy.yaml` file to this file. This file is from the *Azure-Samples* repository:
    [https://github.com/Azure-Samples/azd-starter-bicep/blob/main/.github/workflows/azure-dev.yml](https://github.com/Azure-Samples/azd-starter-bicep/blob/main/.github/workflows/azure-dev.yml).'
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve created this workflow file, we can take a closer look at it.
  prefs: []
  type: TYPE_NORMAL
- en: Workflow file with YAML syntax
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The syntax of workflow files makes use of **YAML Ain’t Markup Language** (**YAML**,
    a recursive acronym) syntax. YAML is a data-oriented human-readable serialization
    language that uses indentation to specify what belongs together.
  prefs: []
  type: TYPE_NORMAL
- en: 'See [https://yaml.org/](https://yaml.org/) for the YAML spec and links to libraries.
    You can check out the following cheat sheet for the syntax: [https://yaml.org/refcard.html](https://yaml.org/refcard.html).'
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look at the workflow file while making some small changes.
  prefs: []
  type: TYPE_NORMAL
- en: Triggers
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A workflow file starts with a name followed by a trigger:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/codebreaker-deploy.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE3]'
  prefs: []
  type: TYPE_PRE
- en: The name of a workflow is shown in the list of workflows. The `on` keyword specifies
    the events that trigger the workflow. GitHub offers many events that can be used
    with workflows. In this YAML file, the workflow is triggered with a `workflow_dispatch`
    event. This allows you to manually trigger the workflow. The second event, `push`,
    is triggered when changes are pushed to the repository. Because of the filtering
    that follows as part of `push`, the trigger is only done with a push to the `main`
    branch with changes specified by the files specified with `path`. If we don’t
    specify branches and path filters, the workflow will be triggered with every change
    in this repository.
  prefs: []
  type: TYPE_NORMAL
- en: Permissions for secretless Azure federated credentials
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'The `permissions` section is a new construct that’s used with secretless Azure
    federated credentials to deploy to Azure:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/codebreaker-deploy.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE4]'
  prefs: []
  type: TYPE_PRE
- en: Permissions are used to access the identity token and the content. With `contents
    read`, the workflow has read access to the content of the repository. `id-token
    write` grants write access to the identity token. This token is used to authenticate
    GitHub with Azure.
  prefs: []
  type: TYPE_NORMAL
- en: Jobs and runners
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'In the workflow file, after the trigger is defined, the `jobs` keyword can
    be used to list one or more jobs that should run:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/codebreaker-deploy.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE5]'
  prefs: []
  type: TYPE_PRE
- en: '`build-and-deploy` is the name of the job. A job needs a runner. GitHub offers
    hosted runners to run jobs on Linux, Windows, and Mac. You can find out what runners
    are available, as well as their versions, at: [https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners#supportedrunners-and-hardware-resources](https://docs.github.com/en/actions/using-github-hosted-runners/about-github-hosted-runners/about-github-hosted-runners#supportedrunners-and-hardware-resources).
    If other hardware or operating system versions are needed, a custom runner can
    be used.'
  prefs: []
  type: TYPE_NORMAL
- en: Using the `env` keyword, environment variables are defined that can be used
    with the steps in this runner. The values for these variables come from the GitHub
    project variables using the `vars` object. The `${{ }}` expressions are evaluated
    during the execution of the workflow, and the values that are retrieved are added
    to the workflow at runtime. We will specify these values later using `azd` `pipeline
    config`.
  prefs: []
  type: TYPE_NORMAL
- en: Steps and actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'A job consists of steps and actions:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/codebreaker-deploy.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE6]'
  prefs: []
  type: TYPE_PRE
- en: 'The first step consists of an action, `actions/checkout@v4`. This action checks
    out the source code to ensure it’s available alongside the runner. `@v4` defines
    the version number to be used for this GitHub action. Actions are available via
    GitHub Marketplace: [https://github.com/marketplace?category=&query=&type=actions](https://github.com/marketplace?category=&query=&type=actions).
    Every action has documentation that you can read to learn which parameters are
    available. `actions/checkout`, for example, allows you to include submodules at
    checkout and also allows you to check out source code from other repositories.'
  prefs: []
  type: TYPE_NORMAL
- en: The next action installs the Azure Developer CLI using `Azure/setup-azd`.
  prefs: []
  type: TYPE_NORMAL
- en: .NET is installed with the hosted runner, but we need to make sure we install
    the .NET Aspire workload. This can be done using a one-line script specified with
    the `run` field – that is, `dotnet workload` `install aspire`.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, the `azd auth` command is used:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/codebreaker-deploy.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE7]'
  prefs: []
  type: TYPE_PRE
- en: 'Here, we have the step where the permissions we defined earlier are needed:
    authentication with Federated Identity. `if` specifies that this step is conditional
    – only if `AZURE_CLIENT_ID` is not empty. We’ll have another option for authentication
    if `AZURE_CLIENT_ID` is empty with the following step. This step is not using
    a GitHub action; instead, the `run` field defines that it will invoke a multi-line
    script. Using multiple lines is specified by `|` at the end of the line. PowerShell
    (which is specified with the `shell` field) uses the backtick (`` ` ``) as a line
    continuation character.'
  prefs: []
  type: TYPE_NORMAL
- en: The command that’s running with PowerShell is `azd auth login`, passing a few
    parameters. `--client-id` uses the identifier of the service principal, which
    has the necessary Azure permissions. `--federated-credential-provider` uses GitHub
    for federated authentication. Federated authentication allows you to use GitHub
    identities to access resources on Azure. `--tenant-id` specifies the Azure directory
    identifier that is used with Azure authentication.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next step uses another conditional script if the `AZURE_CREDENTIALS` variable
    is set:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/codebreaker-deploy.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE8]'
  prefs: []
  type: TYPE_PRE
- en: The `AZURE_CREDENTIALS` environment variable is stored as a JSON script. This
    is converted into a PowerShell hash table variable named `info` and allows us
    to access each part of the JSON content, such as the client ID, the client secret,
    and the tenant ID. These parts are then passed to the `azd auth login` command.
    `AZURE_CREDENTIALS` itself is retrieved using `secrets.AZURE_CREDENTIALS`. Secrets
    are stored encrypted alongside the GitHub project and are not part of the source
    code of the repository. We’ll configure these secrets in the next section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Finally, two one-line commands are invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/codebreaker-deploy.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE9]'
  prefs: []
  type: TYPE_PRE
- en: The first command, `azd provision`, creates the Azure infrastructure, as specified
    by the ap`p-model` definition of the AppHost project. If the infrastructure already
    exists, it is checked if a change is needed, and only updates are applied. `azd
    deploy` then deploys the services to Azure, thus building the Docker images, publishing
    them to Azure Container Registry, and creating various Azure Container Apps with
    the created images. The `--no-prompt` option doesn’t wait for the user to interact
    with this command and just uses defaults.
  prefs: []
  type: TYPE_NORMAL
- en: The `azd up` command we used previously used `azd provision` and `azd deploy`.
  prefs: []
  type: TYPE_NORMAL
- en: Create the `.github/workflows` folder in your repository and copy the `codebreaker-deploy.yml`
    workflow file to this folder.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub variables and secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Secrets shouldn’t be part of the source code, and the workflow file is stored
    with the source code. GitHub has a vault where you can store secrets outside of
    the source code repository. Using `azd`, secrets and variables can automatically
    be configured with GitHub.
  prefs: []
  type: TYPE_NORMAL
- en: The `azd pipeline` command supports this. Start by having the current directory
    set to the root folder of the repository. `azd pipeline` needs the .`github/workflows`
    folder to be in the same directory where you run `azd pipeline`; you must also
    have the .NET Aspire application initialized in this directory. This requirement
    might change – check the README file in this chapter’s GitHub repository for more
    information.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the following command to configure the pipeline:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE10]'
  prefs: []
  type: TYPE_PRE
- en: '`azd pipeline config` uses the Azure subscription you configured earlier to
    create GitHub variables and secrets, as well as create an Azure app registration,
    which allows GitHub to deploy to Azure. By default, the principal name created
    starts with `az-dev-` and contains the date and time it was created. Here, we
    specify the principal name as `github-codebreaker-dev`. Repository variables for
    `AZURE_ENV_NAME`, `AZURE_LOCATION`, `AZURE_SUBSCRIPTION_ID`, `AZURE_TENANT_ID`,
    and `AZURE_CLIENT_ID` are created.'
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the GitHub repository in your browser. In the portal, click **Settings**.
    With the **Security** category open in the left pane, you’ll see **Secrets and
    variables**. In this sub-category, when you open **Actions**, you’ll see the **Actions
    secrets and variables** page, which contains **Repository secrets**. This is shown
    in *Figure 8**.3*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.3 – Repository secrets](img/B21217_08_03.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.3 – Repository secrets
  prefs: []
  type: TYPE_NORMAL
- en: The `AZD_INITIAL_ENVIRONMENT_CONFIG` secret contains the content of the `.azure/[environment]/config.json`
    file. This file contains a list of publicly accessible services and is read by
    `azd deploy` to configure the Ingress controller. The needed environment name,
    location, subscription ID, and other details are stored within repository variables.
  prefs: []
  type: TYPE_NORMAL
- en: Because `azd pipeline config` creates Federated Identity credentials for GitHub,
    secrets to access Azure are not required with the default (federated) configuration.
    Instead of using a value of `federated`, you can pass `client-credentials`, which
    configures credentials to be stored within a repository secret.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: In [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137), you understood how to separate
    secrets and variables with Azure Container Apps, and then with Azure App Configuration
    and Key Vault in [*Chapter 7*](B21217_07.xhtml#_idTextAnchor162). The reason for
    this separation is similar here using GitHub Actions.
  prefs: []
  type: TYPE_NORMAL
- en: GitHub allows you to specify different levels where you can store secrets and
    variables. The organization level can be used when secrets should be shared across
    different repositories within the organization. Repository secrets are stored
    within the scope of the repository and are not available from other repositories.
    Environment secrets are scoped within deployment environments. These will be covered
    later in the *Using deployment* *environments* section.
  prefs: []
  type: TYPE_NORMAL
- en: 'Run the GitHub Actions workflow now – either by pushing a source code update
    to the GitHub repository or by running the workflow explicitly from the GitHub
    portal. You’ll see that the workflow is in progress before it completes:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.4 – Workflow in progress](img/B21217_08_04.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.4 – Workflow in progress
  prefs: []
  type: TYPE_NORMAL
- en: 'At this stage, you might need to wait until an agent is available. When it’s
    in progress, you can click on it to see progress information about what’s going
    on. *Figure 8**.5* shows the steps that appear when the workflow is completed
    successfully:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.5 – Workflow steps](img/B21217_08_05.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.5 – Workflow steps
  prefs: []
  type: TYPE_NORMAL
- en: Upon checking the logs, you’ll see all the steps that have been completed. In
    the preceding figure, you can see that federated credentials have been used, and
    not the client credentials. You can click on each of these steps to find more
    details.
  prefs: []
  type: TYPE_NORMAL
- en: When creating a GitHub Actions workflow with `azd`, just a few statements are
    required to deploy the complete solution. With every source code change that is
    not pushed to the main branch, the deployment is updated.
  prefs: []
  type: TYPE_NORMAL
- en: Getting more with GitHub Actions
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: It’s great to have an easy way to create a GitHub action using integration from
    Visual Studio, the Azure portal, or via the `azd pipeline` command. `azd pipeline`
    is great for deploying a complete solution, but because of its early development
    stages, some features are missing. With our solution, some more features are required;
    we’ll customize these manually.
  prefs: []
  type: TYPE_NORMAL
- en: 'Let’s have a look at some of the goals we have:'
  prefs: []
  type: TYPE_NORMAL
- en: All the services should be built, tested, and deployed
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: NuGet packages should be published to GitHub Packages and made available there
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: We don’t want to repeat code, so we’ll create reusable workflows
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Deploying should be done to multiple environments, such as development, staging,
    and production
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: Let’s get into the details.
  prefs: []
  type: TYPE_NORMAL
- en: Enhancing GitHub Actions workflows
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: To build our services, we must create reusable workflows. First, let’s configure
    the variables and secrets that are needed by these workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring variables and secrets
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'We’ve configured variables and secrets using `az pipeline config` previously.
    if you need more customization, you might need to set these values yourself. You’ve
    already seen how to access the repository secrets and variables with the GitHub
    portal. Now, let’s add these to secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AZURE_TENANT_ID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AZURE_SUBSCRIPTION_ID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AZURE_CLIENT_ID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'To get the tenant ID, use the Azure CLI:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE11]'
  prefs: []
  type: TYPE_PRE
- en: '`az account show` returns JSON information about the logged-in Azure account.
    With the JSONPath `--query tenantId` query, the Microsoft Entra tenant ID is returned.
    `-o tsv` returns the result in tab-separated values. Set the returned value with
    the `AZURE_TENANT_ID` repository secret.'
  prefs: []
  type: TYPE_NORMAL
- en: 'The subscription ID can also be listed with `az` `account show`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE12]'
  prefs: []
  type: TYPE_PRE
- en: Here, `id` contains the subscription ID. Set this value with the `AZURE_SUBSCRIPTION_ID`
    repository secret.
  prefs: []
  type: TYPE_NORMAL
- en: 'Earlier in this chapter, we used the `azd pipeline` command to create an account
    for federated authentication. Let’s check out this account within the Microsoft
    Entra portal: [https://entra.microsoft.com](https://entra.microsoft.com). After
    logging in, from the left bar, within the `github-codebreaker-dev`. If you didn’t
    supply a name, `azd` creates an account starting with `az-dev`. Open this account
    and, within the **Manage** category, click **Certificates & secrets**. Open **Federated
    credentials**. You will see credentials named based on the GitHub organization
    and the repository, with entity types of **Pull request** and **Branch**. A predefined
    federated credential scenario for GitHub actions deploying Azure resources will
    be available.'
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: 'To create a new app registration with federated credentials using the Azure
    portal, the Azure CLI, or Azure PowerShell, check out the following documentation:
    [https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Clinux#add-federated-credentials](https://learn.microsoft.com/en-us/azure/developer/github/connect-from-azure?tabs=azure-portal%2Clinux#add-federated-credentials).'
  prefs: []
  type: TYPE_NORMAL
- en: Copy the value for `AZURE_CLIENT_ID` repository secret.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve specified the necessary secrets and variables, let’s get back
    to creating workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Running unit tests
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'When triggering the workflow by updating the source code of a service, the
    first step should be to run unit tests. Let’s create a reusable workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/shared-test.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE13]'
  prefs: []
  type: TYPE_PRE
- en: A reusable workflow is triggered by calling this workflow. The trigger specified
    by `on` uses the `workflow_call` keyword. At this point, the input values that
    are needed are also defined. With this workflow, `project-name` and `solution-path`
    are required input values. The `dotnet-version` input value has a default value
    assigned and is not required.
  prefs: []
  type: TYPE_NORMAL
- en: 'After the trigger and the input values, a job with a runner is defined, followed
    by the steps to be invoked:'
  prefs: []
  type: TYPE_NORMAL
- en: work flows/shared-test.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE14]'
  prefs: []
  type: TYPE_PRE
- en: 'After checking out the source code with the `actions/checkout` action, the
    .NET SDK is installed using `actions/setup-dotnet`. Here, the .NET version is
    retrieved from the input values. As the .NET SDK is now installed with this runner,
    the .NET CLI can be used. In the next step, instead of invoking an action, the
    `run` keyword is used to execute the `dotnet restore` command. `dotnet restore`
    retrieves the NuGet packages of the referenced solution. If this fails, there’s
    no need to continue with the next step. The next step runs the unit tests using
    `dotnet test`. The `--logger` option specifies to write log output with the TRX
    logger format – a Visual Studio `actions/upload-artifact` action. Artifacts can
    be used to share data between runners and also downloaded with workflow runs.
    By default, a step only runs if the previous step succeeds. In this case, we want
    to download the test result from the artifacts if the test fails – that’s why
    `if: always()` was added on uploading the artifact.'
  prefs: []
  type: TYPE_NORMAL
- en: 'This shared workflow is started from the `codebreaker-test.yml` workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/codebreaker-test.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE15]'
  prefs: []
  type: TYPE_PRE
- en: The job that’s been defined uses the name `build-and-test`, references the shared
    workflow file with the `uses` keyword, and sets the input values using the `with`
    keyword.
  prefs: []
  type: TYPE_NORMAL
- en: 'This workflow is triggered when a change is made in the specified files and
    folders in the main branch, explicitly. *Figure 8**.6* shows the result of running
    the workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.6 – Running the workflow](img/B21217_08_06.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.6 – Running the workflow
  prefs: []
  type: TYPE_NORMAL
- en: With this result, you can see the downloadable artifacts for viewing the test
    results.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve run the unit tests, let’s combine this with the previously created
    build and deploy job.
  prefs: []
  type: TYPE_NORMAL
- en: Running multiple jobs
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To run multiple jobs from one workflow, we’ll need to create a shared workflow
    from the deployment project:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/shared-deploy.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE16]'
  prefs: []
  type: TYPE_PRE
- en: Because this is a shared workflow that’s triggered from other workflows, `on`
    specifies `workflow_call`. This workflow is very similar to the previously created
    deployment workflow, so the code for this hasn’t been repeated here. Check out
    the source code repository for the complete workflow. What’s important here is
    that not only inputs are passed from the calling workflow, but also secret information.
    These secrets are referenced using the `$ {{ secrets.<secret> }}` expression.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `codebreaker-testanddeploy.yml` workflow invokes both shared workflows:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/codebreaker-testanddeploy.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE17]'
  prefs: []
  type: TYPE_PRE
- en: Using the `needs` keyword, the `build-and-deploy` job is defined to require
    the `build-and-test` job to run beforehand. If the `build-and-test` job does not
    succeed, `build-and-deploy` will not run. Secrets need to be forwarded to the
    shared workflow. With secrets, you can specify every secret to pass with the calling
    workflow, or to share all the secrets available from the calling workflow with
    the called workflow. Inheriting these secrets is required when using environments
    (as shown in a later section).
  prefs: []
  type: TYPE_NORMAL
- en: 'When you run the workflow at this stage, you’ll see a graphical view of how
    the two jobs are connected, as shown in *Figure 8**.7*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.7 – Running multiple jobs](img/B21217_08_07.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.7 – Running multiple jobs
  prefs: []
  type: TYPE_NORMAL
- en: Both jobs were completed successfully.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll dive into environments that can be used from multiple jobs to, for
    example, deploy the solution to staging and production environments.
  prefs: []
  type: TYPE_NORMAL
- en: Using deployment environments
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: When running the solution locally on the developer system, projects can be built
    and debugged locally. Just a few services, such as App Insights and Key Vault,
    need to be run in the Azure cloud environment. This is done automatically by .NET
    Aspire, which provisions `app-model` in the AppHost project. You just need to
    make sure you configure `Azure:SubscriptionId` with the user secrets. To run and
    test the application while it’s running within Azure, and to try out different
    Azure offerings, every developer of the team can use `azd init` and `azd up` to
    have all the services running in the personal Azure subscription that’s part of
    the Visual Studio Professional and Enterprise offerings.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also useful to use a shared environment where the services of the solution
    running in Microsoft Azure are used together by the developer team. One example
    is for client application developers to use a new daily build to test the client
    applications accessing the services in the cloud. This is the *development environment*.
  prefs: []
  type: TYPE_NORMAL
- en: To run load tests, it’s useful to have *test environments*. Such environments
    can be created on demand before running the load test. They can be deleted again
    after the load tests are finished and the results have been documented. See [*Chapter
    10*](B21217_10.xhtml#_idTextAnchor239) for more details on running tests.
  prefs: []
  type: TYPE_NORMAL
- en: Before moving into production, *staging environments*, which mirror the *production
    environments*, are used to make final tests if the application is behaving as
    expected.
  prefs: []
  type: TYPE_NORMAL
- en: We can deploy the solution to all these environments by using GitHub Actions.
    However, some of these environments are more restrictive, which means that deployments
    can only be done when it’s been verified that the solution runs successfully with
    the defined constraints.
  prefs: []
  type: TYPE_NORMAL
- en: Let’s take a closer look.
  prefs: []
  type: TYPE_NORMAL
- en: Create environments with the Azure Developer CLI
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To create environments with the Azure Developer CLI, you can use the `azd env`
    `new` command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE18]'
  prefs: []
  type: TYPE_PRE
- en: 'This not only creates a new environment named `codebreaker-08-prod` but also
    sets the current environment to this new one. To show all environments that have
    been configured, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE19]'
  prefs: []
  type: TYPE_PRE
- en: 'This shows all the environments that have been configured, as well as the currently
    selected environment. To change the current one, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE20]'
  prefs: []
  type: TYPE_PRE
- en: Creating an environment with `azd` creates the `.azure` subdirectory. Upon opening
    this folder, you will see the `config.json` file. This shows the currently selected
    environment.
  prefs: []
  type: TYPE_NORMAL
- en: With every environment that’s created, a subdirectory containing the name of
    the environment is created that contains values for the resource group, the Azure
    region, and the Azure subscription ID. When you’re creating a new environment,
    you can change the subscription with the `--subscription` option. To change the
    location of the resources, use `--location`.
  prefs: []
  type: TYPE_NORMAL
- en: 'To see the configuration values for an environment, run the following command:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE21]'
  prefs: []
  type: TYPE_PRE
- en: 'To change the Azure region afterward, you can use `azd` `env set`:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE22]'
  prefs: []
  type: TYPE_PRE
- en: While the Azure Developer CLI supports using multiple environments, using this
    in combination with GitHub environments is (not yet) directly available but can
    be easily customized. At the time of writing, the `azd pipeline config` command
    only supports one environment per repository. However, this is expected to change,
    and integration with GitHub environments is already being discussed. Check the
    README file in this chapter’s repository for updates.
  prefs: []
  type: TYPE_NORMAL
- en: 'You can still use `azd pipeline` to create federated accounts for every environment:'
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE23]'
  prefs: []
  type: TYPE_PRE
- en: This creates the account that we’ll use with the `codebreaker-08-prod` environment.
  prefs: []
  type: TYPE_NORMAL
- en: At this point, we need to learn how to use GitHub environments. So, we’ll start
    by creating GitHub environments.
  prefs: []
  type: TYPE_NORMAL
- en: Creating GitHub environments
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before using GitHub environments, you need to be aware that this GitHub feature
    is only available for free with public repositories. With private repositories,
    a Team license is required (see [https://github.com/pricing](https://github.com/pricing)).
  prefs: []
  type: TYPE_NORMAL
- en: 'Open your GitHub repository in your browser and click **Settings**. In the
    left pane, under the **Code and automation** category, click **Environments**.
    *Figure 8**.8* shows the environments for development, testing, staging, and production:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.8 – GitHub environments](img/B21217_08_08.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.8 – GitHub environments
  prefs: []
  type: TYPE_NORMAL
- en: You can create these environments using your browser by accessing your repository.
    As the environments are being created, protection rules can be applied.
  prefs: []
  type: TYPE_NORMAL
- en: Defining deployment protection rules
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Before publishing to another environment, you can enforce **deployment protection
    rules**. Publishing to the production environment might only be allowed from **protected
    branches**, specific branches that fulfill a naming convention, and only with
    commits from specific tag names. Up to six reviewers can be specified to approve
    the deployment. There’s also the option to implement custom protection rules,
    which, for example, might check the results of different test runs (tests will
    be covered in [*Chapter 10*](B21217_10.xhtml#_idTextAnchor239)) or check for issues
    within the GitHub repository. Third-party protection rules are also available.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: With the first few versions of the application, where you’ll start with deployments
    across different environments, it’s good practice to add reviewers that do some
    manual checks. Before the solution is deployed to the **production** environment,
    it needs to be deployed to the **staging** environment. In the staging environment,
    manual checks are used. On the road to improving the CI/CD process, you might
    add more and more automatic checks. Automated tests, code analysis, checking for
    issues, and more can be done before moving on to the next stage. You just need
    to be able to trust how you set up the environment and have your tests running.
  prefs: []
  type: TYPE_NORMAL
- en: 'Within the production environment, add yourself as a required reviewer with
    deployment protection, as shown in *Figure 8**.9*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.9 – Required reviewers with GitHub environments](img/B21217_08_09.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.9 – Required reviewers with GitHub environments
  prefs: []
  type: TYPE_NORMAL
- en: Other than requiring reviewers, you can use rules defined by existing apps from
    GitHub partner applications to require some source code or issue checks, and also
    implement custom protection rules
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: When using deployment protection rules for branches and tags, you should specify
    that not everyone is allowed to create branches and tags that are used with the
    rules. See *Configuring tag protection rules* at [https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/configuring-tag-protection-rules](https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/managing-repository-settings/configuring-tag-protection-rules)
    for more details.
  prefs: []
  type: TYPE_NORMAL
- en: Next, we’ll configure secrets and variables with environments.
  prefs: []
  type: TYPE_NORMAL
- en: Setting environment secrets and variables
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: With environments, you can also specify variables and secrets that are only
    available within these environments. We need the tenant ID, the subscription ID
    , and the account ID of the federated account we created earlier. This information
    was configured in the *Enhancing GitHub Actions* *workflows* section.
  prefs: []
  type: TYPE_NORMAL
- en: As a reminder, to get the tenant ID, use `az account show –query tenantId -o
    tsv`). To get the subscription ID, use `az account show --query id -o tsv`. With
    the account, to use an environment, an additional credential is required.
  prefs: []
  type: TYPE_NORMAL
- en: 'Open the Entra portal ([https://entra.microsoft.com](https://entra.microsoft.com))
    and select `az-dev<date>`. Select `repo:<github org/repo>:pull_request` and `repo:<github
    org/repo:refs/heads/main` subject identifiers were added. Add a new credential
    and select **GitHub Actions deploying Azure resources**, as shown in *Figure 8**.10*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.10 – Environment credentials](img/B21217_08_10.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.10 – Environment credentials
  prefs: []
  type: TYPE_NORMAL
- en: Within this dialogue, add your GitHub **Organization** and **Repository**, select
    **Environment** for **Entity type**, enter the **GitHub environment name** value
    that matches your GitHub environment, and provide **Credential details**.
  prefs: []
  type: TYPE_NORMAL
- en: To configure the secret, copy the **Application (client) ID** value of this
    app registration.
  prefs: []
  type: TYPE_NORMAL
- en: 'Once you have these values, open the environment in the GitHub portal and add
    **Environment secrets** and **Environment variables**, as shown in *Figure 8**.11*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.11 – Configuring Environment secrets and Environment variables](img/B21217_08_11.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.11 – Configuring Environment secrets and Environment variables
  prefs: []
  type: TYPE_NORMAL
- en: 'The following variables are required:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AZURE_ENV_NAME`: The resource group name that should be used without the `rg-`
    prefix – for example, `codebreaker-08-prod`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AZURE_LOCATION`: Your preferred Azure region'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: 'You will need the following secrets:'
  prefs: []
  type: TYPE_NORMAL
- en: '`AZURE_SUBSCRIPTION_ID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AZURE_TENANT_ID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '`AZURE_CLIENT_ID`'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With this configuration in place, let’s update the workflows.
  prefs: []
  type: TYPE_NORMAL
- en: Using environments with workflows
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use an environment from a workflow, all you need to do is reference the
    environment name. Copy the shared workflow, `shared-deploy.yml`, to `shared-deploy-withenvironment.yml`
    and enhance it with an environment configuration:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/shared-deploy-withenvironment.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE24]'
  prefs: []
  type: TYPE_PRE
- en: When configuring the job, the `environment` keyword is used to reference an
    environment name. With this implementation, a required input parameter is used
    to pass the name of the environment. No changes need to be made regarding the
    secrets and variables. When running in the environment, these values are retrieved
    from the environment configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `codebreaker-production.yml` workflow, which uses the various workflows
    to create and push the Docker image and publish the Container App, is different
    from the development environment, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: workflows/codebreaker- produnction.yml
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE25]'
  prefs: []
  type: TYPE_PRE
- en: The environment parameter is now set to `codebreaker-08-prod`. This time, the
    secrets are not explicitly declared, but all secrets this workflow has access
    to are given to the called workflow. Because of the environment specified by the
    called workflow, secrets and variables are referenced from the GitHub environment.
  prefs: []
  type: TYPE_NORMAL
- en: 'Now, you can try triggering the workflow. The first stage runs, but the second
    stage must be reviewed, as shown in *Figure 8**.12*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.12 – Workflow review requested](img/B21217_08_12.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.12 – Workflow review requested
  prefs: []
  type: TYPE_NORMAL
- en: 'Review the results of the workflow and approve it, as shown in *Figure 8**.13*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.13 – Approve and deploy](img/B21217_08_13.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.13 – Approve and deploy
  prefs: []
  type: TYPE_NORMAL
- en: At this point, you need to wait a few minutes until all the resources are deployed
    to the production environment. Verify that the deployment succeeded. After a successful
    deployment, you can use a client, update the link to the new environment, and
    play a game.
  prefs: []
  type: TYPE_NORMAL
- en: For the client programmers, we’ll create a NuGet package.
  prefs: []
  type: TYPE_NORMAL
- en: Publishing NuGet packages
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: With our solution, we also have libraries that are used by client applications.
    Having NuGet packages helps with using these libraries. By creating a GitHub action,
    we can automatically build and publish the NuGet package. If you want to make
    a package publicly available, you can publish it to the NuGet server (you’ve already
    used packages that are available for this book). To make packages private with
    authentication, GitHub offers **GitHub Packages**.
  prefs: []
  type: TYPE_NORMAL
- en: Preparing the library project
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Adding some metadata, such as a README Markdown file to the project describing
    the package, and a custom icon to replace the default icon, enhances usability.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `Codebreaker.GameAPIs.KiotaClient` project contains a `readme.md` file
    and a JPG file for an icon. These additions need to be uploaded within the project
    file:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.KioataClient/Codebreaker.GameAPIs.KiotaClient.csproj
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE26]'
  prefs: []
  type: TYPE_PRE
- en: The README file and the icon don’t need to be built into the library, which
    is why `None` is used within `ItemGroup` to exclude them from the build result
    of the library. Adding these items to the NuGet package is specified by the `Pack`
    attribute. `PackagePath` specifies the folder within the package where these items
    can be found.
  prefs: []
  type: TYPE_NORMAL
- en: 'The following `PropertyGroup` definitions specify the use of the README file
    and the package icon and add some metadata:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs.KioataClient/Codebreaker.GameAPIs.KiotaClient.csproj
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE27]'
  prefs: []
  type: TYPE_PRE
- en: Adding metadata to the package is specified with the `PackageId`, `PackageTags`,
    and `Description` elements.
  prefs: []
  type: TYPE_NORMAL
- en: It’s also a good idea to define the version of the package. With the source
    code repository, the `VersionPrefix` element, which is defined within the `Directory.Build.props`
    file, specifies the first part of the version for all the projects found in subdirectories.
    Using a GitHub action, a `VersionSuffix` element is added dynamically that increments
    with every build. This versioning scheme is used with `alpha`, `beta`, and `prerelease`
    versions.
  prefs: []
  type: TYPE_NORMAL
- en: As soon as the library is released, the `Version` element is added to specify
    the complete version of the package. Adding the `Version` element to the project
    overrides `VersionPrefix` and `VersionSuffix`, and just this version is used.
    After the release, when the next beta versions are available, the `Version` element
    is removed again, and the `VersionPrefix` element is incremented to the next iteration.
  prefs: []
  type: TYPE_NORMAL
- en: Creating access tokens
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: To publish a package to GitHub Packages, a **personal access token (classic)**
    is required. At the time of writing, the new fine-grained personal access tokens
    cannot be used with GitHub Packages.
  prefs: []
  type: TYPE_NORMAL
- en: You can create a personal access token by clicking on the user icon in the top-right
    corner, selecting **Settings**, and then clicking on **Developer Settings** in
    the left pane. Select **Personal access tokens** and click **Tokens (classic)**.
    To create a new token, select **Generate new token (classic)**. Select an expiration
    date. The scope that is required to publish packages is **write:packages**. Selecting
    this scope also adds other scopes, such as reading packages and access to the
    repository. Click **Generate token**. You need to copy this generated token –
    it will not be visible again after you close the screen. Just make sure you store
    it in a safe place. You can create a new token in case you don’t have one anymore,
    or when the token has expired.
  prefs: []
  type: TYPE_NORMAL
- en: For the GitHub action you wish to use, store this token alongside the secrets
    of the `PAT_PUBLISHPACKAGE` repository.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve stored this secret, let’s use it with a GitHub action.
  prefs: []
  type: TYPE_NORMAL
- en: Creating a GitHub action to publish a GitHub package
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: The GitHub actions that are used to create a NuGet package have similarities
    with the GitHub actions we created previously. Check out the source code repository
    for details.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `shared-create-nuget.yml` shared workflow builds the NuGet package and
    uploads it with GitHub artifacts. The following steps are completed in this workflow:'
  prefs: []
  type: TYPE_NORMAL
- en: Check out the source code.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up .NET.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Calculate the build number (using a configured offset to the GitHub build number).
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Build the library using `dotnet build`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Test the library using `dotnet test`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Create a NuGet package using `dotnet pack`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Upload the package with GitHub artifacts.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: 'The next shared workflow (`shared-githubpackages.yml`) uploads the package
    to GitHub Packages by following these steps:'
  prefs: []
  type: TYPE_NORMAL
- en: Download the GitHub artifact.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set up .NET.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Set the NuGet source with `dotnet nuget` `add source`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Push the package to GitHub Packages with `dotnet` `nuget push`.
  prefs:
  - PREF_OL
  type: TYPE_NORMAL
- en: Pushing the package makes use of the configured access token.
  prefs: []
  type: TYPE_NORMAL
- en: 'The `kiota-lib.yml` workflow connects the two shared workflows and passes parameters.
    Upon running this workflow successfully, you can verify the packages with the
    organization of your GitHub repository, as shown in *Figure 8**.14*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.14 – GitHub Packages](img/B21217_08_14.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.14 – GitHub Packages
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub environments, you can enhance the creation of NuGet packages and
    define environments, such as those to publish to the publicly available NuGet
    server only after successfully using a private feed with GitHub Packages.
  prefs: []
  type: TYPE_NORMAL
- en: With modern deployments, there’s more than just using development, staging,
    and production environments. We’ll discuss this next.
  prefs: []
  type: TYPE_NORMAL
- en: Using modern deployment patterns
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'Using development, staging, and production environments is one of the “traditional”
    deployment patterns. Nowadays, other deployment patterns are used as well:'
  prefs: []
  type: TYPE_NORMAL
- en: When using **canary releases**, different versions of an application are available
    for the user to choose from. This is evident from the Edge browser, which offers
    a Beta channel that’s updated monthly, a Dev channel that’s updated weekly, and
    a Canary channel that’s updated daily. The user can decide what version to test.
    See [https://www.microsoft.com/en-us/edge/download/insider](https://www.microsoft.com/en-us/edge/download/insider)
    for more details.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: With **A/B testing**, users randomly receive one of two different user interfaces.
    When using this pattern, you can monitor which UI allows the user to be more productive.
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Blue-green deployments** allow you to quickly roll back an installation by
    installing to a staging server, swapping staging with production. If something
    fails, an easy rollback can be done.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Dark launching** is a pattern that you can use to publish a new version of
    the application while ensuring that the new features are hidden until they are
    activated by turning on a switch. One example of this is when a feature should
    be available at a specific time. This switch can be turned on by a time event
    – there’s no need to redeploy the application.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '**Feature toggles** allow you to turn each feature on/off. One option is to
    enable some of the features for a specific group of users, such as early adopters.
    Users themselves can also decide which of the new features they want to test.
    Such toggles are available with Microsoft Azure and Visual Studio.'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: In [*Chapter 7*](B21217_07.xhtml#_idTextAnchor162), you saw Azure App Configuration
    in action. This Azure service not only supports a central application configuration
    but also offers feature flags. This functionality of Azure App Configuration can
    be used with several of the modern deployment patterns by using different feature
    flag filters.
  prefs: []
  type: TYPE_NORMAL
- en: Configuring feature flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: Let’s open the Azure App Configuration service that was created with Bicep scripts.
    In the left pane, within the **Operations** category, open **Feature manager**.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: You might not have access to this resource to add configuration data since the
    resource was created from Bicep scripts. Using **Access control (IAM)**, add your
    user to the **App Configuration Data Owner** or **Contributor** role. You might
    need to wait about 15 minutes before the role changes.
  prefs: []
  type: TYPE_NORMAL
- en: 'Create a new feature flag, as shown in *Figure 8**.15*:'
  prefs: []
  type: TYPE_NORMAL
- en: '![Figure 8.15 – Creating feature flags](img/B21217_08_15.jpg)'
  prefs: []
  type: TYPE_IMG
- en: Figure 8.15 – Creating feature flags
  prefs: []
  type: TYPE_NORMAL
- en: Set the feature flag’s name to `Feature8x5Game`, add a description, and check
    the `FeatureGame6x4Mini`, `FeatureGame6x4`, and `FeatureGame5x5x4`. Don’t add
    filters for the first two; just enable one of these. For the last one, add a time
    filter so that it can be enabled in the future, but don’t set an expiration date.
  prefs: []
  type: TYPE_NORMAL
- en: The **targeting filter** allows you to open a feature for a specific user group
    (early adopters). It can also act as a percentage filter, so you can turn this
    feature on for a random percentage of users. The other built-in filter is the
    **time window filter**. Using this filter, you can specify start and end times
    when this feature should be enabled. You can also create a custom implementation
    for a filter.
  prefs: []
  type: TYPE_NORMAL
- en: Now that we’ve configured this feature flag, let’s use this from the `game-apis`
    service.
  prefs: []
  type: TYPE_NORMAL
- en: DI and middleware configuration for feature flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'To use Feature Management, add the `Microsoft.FeatureManagement.AspNetCore`
    NuGet package to the `Codebreaker.GameAPIs` project. The DI container needs to
    be configured for feature flags, as shown here:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE28]'
  prefs: []
  type: TYPE_PRE
- en: The `AddFeatureManagement` extension method registers types that are needed
    for feature flags. Every filter that is used is added using the `AddFeatureFilter`
    extension method.
  prefs: []
  type: TYPE_NORMAL
- en: Note
  prefs: []
  type: TYPE_NORMAL
- en: The Feature Management API can also be used without Azure App Configuration.
    Upon viewing the source code in this book’s GitHub repository, you’ll see that
    the Feature Management API can be configured without using Azure as well. In this
    case, an overload of the `AddFeatureManagement` API is invoked to pass an `IConfiguration`
    object. With this, feature flags can be configured with the .NET configuration
    options. Revisit [*Chapter 7*](B21217_07.xhtml#_idTextAnchor162) for more information
    on configuration.
  prefs: []
  type: TYPE_NORMAL
- en: 'To connect Feature Management with Azure App Configuration, you must update
    the `AddAzureAppConfiguration` method:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE29]'
  prefs: []
  type: TYPE_PRE
- en: '`UseFeatureFlags` is a method of the `AzureAppConfigurationOptions` class for
    connecting feature flags.'
  prefs: []
  type: TYPE_NORMAL
- en: 'When using feature flags, the Azure App Configuration middleware also needs
    to be configured:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Program.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE30]'
  prefs: []
  type: TYPE_PRE
- en: With the setup in place, we can check if feature flags have been set.
  prefs: []
  type: TYPE_NORMAL
- en: Using feature flags
  prefs:
  - PREF_H2
  type: TYPE_NORMAL
- en: 'Now, we can use the feature manager to check if features are available. We’ll
    start by creating an extension method for the `IFeatureManager` interface:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Extensions/FeatureManagerExtensions.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE31]'
  prefs: []
  type: TYPE_PRE
- en: This method uses the `GetFeatureNamesAsync` and `IsEnabledAsync` methods defined
    by the `IFeatureManager` interface. On the first invocation of this method, the
    list of features registered with the feature manager is retrieved and added to
    the `_featureNames` collection. Not every game type is registered as a feature.
    For the game types that are not registered as features, the method returns `true`
    to inform us that this type is available. With all the game types registered as
    a feature, the `IsEnabledAsync` method is used to check if the feature is enabled.
  prefs: []
  type: TYPE_NORMAL
- en: 'Next, let’s inject `IFeatureManager` with the minimal API:'
  prefs: []
  type: TYPE_NORMAL
- en: Codebreaker.GameAPIs/Endpoints/GameEndpoints.cs
  prefs: []
  type: TYPE_NORMAL
- en: '[PRE32]'
  prefs: []
  type: TYPE_PRE
- en: On starting a game using the API, the `IFeatureManagement` interface is injected
    to check the requested game type for the feature to be enabled using the previously
    created extension method, `IsGameTypeAvailable`. Depending on the result, an error
    is returned, or a new game is created.
  prefs: []
  type: TYPE_NORMAL
- en: With this implementation, you can run the application and test these feature
    flags. The `game-apis` project contains an HTTP file that you can use to create
    all the different game types and see the results that were returned when using
    feature flags. You can test this locally on your developer system. Upon pushing
    an update to your GitHub repository, a workflow is ready to be triggered. Then,
    you just need to configure the link of your API service within the HTTP file to
    test the service that’s running with Azure Container Apps.
  prefs: []
  type: TYPE_NORMAL
- en: Summary
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: After creating Azure services with Bicep scripts in [*Chapter 6*](B21217_06.xhtml#_idTextAnchor137),
    in this chapter, you learned how to use **continuous integration** (**CI**) and
    **continuous delivery** (**CD**) with GitHub Actions. Here, you changed the source
    code, created and merged a pull request, tested code, and deployed Azure Container
    Apps. Using GitHub Actions, you learned how to build NuGet packages and push them
    to GitHub Packages.
  prefs: []
  type: TYPE_NORMAL
- en: Using GitHub environments, you created multiple deployment environments where
    additional checks are required before deployment is extended to another stage.
  prefs: []
  type: TYPE_NORMAL
- en: After, you learned how to configure Azure App Configuration, as well as how
    to use feature flags, which are needed for modern deployment patterns such as
    A/B testing, blue-green deployments, and dark launching.
  prefs: []
  type: TYPE_NORMAL
- en: 'The next chapter covers another important topic: authentication and authorization.
    In [*Chapter 7*](B21217_07.xhtml#_idTextAnchor162), you learned how to run Azure
    services with managed identities. In [*Chapter 9*](B21217_09.xhtml#_idTextAnchor216),
    we’ll restrict the applications that are allowed to invoke APIs, authenticate
    users to restrict functionality for anonymous users, and add APIs that are only
    allowed to be used by specific user groups.'
  prefs: []
  type: TYPE_NORMAL
- en: Further reading
  prefs:
  - PREF_H1
  type: TYPE_NORMAL
- en: 'To learn more about the topics that were discussed in this chapter, please
    refer to the following links:'
  prefs: []
  type: TYPE_NORMAL
- en: '*GitHub Actions* *documentation*: [https://docs.github.com/en/actions](https://docs.github.com/en/actions)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*azd: configure a* *pipeline*: [https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/configure-devops-pipeline](https://learn.microsoft.com/en-us/azure/developer/azure-developer-cli/configure-devops-pipeline)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Using environments for* *deployments*: [https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment](https://docs.github.com/en/actions/deployment/targeting-different-environments/using-environments-for-deployment)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Creating custom protection* *rules*: [https://docs.github.com/en/actions/deployment/protecting-deployments/creating-custom-deployment-protection-rules](https://docs.github.com/en/actions/deployment/protecting-deployments/creating-custom-deployment-protection-rules)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
- en: '*Microsoft Feature Management* *documentation*: [https://learn.microsoft.com/en-us/dotnet/api/microsoft.featuremanagement?view=azure-dotnet](https://learn.microsoft.com/en-us/dotnet/api/microsoft.featuremanagement?view=azure-dotnet)'
  prefs:
  - PREF_UL
  type: TYPE_NORMAL
