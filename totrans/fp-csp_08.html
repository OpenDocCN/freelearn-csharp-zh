<html><head></head><body>
		<div><h1 id="_idParaDest-263" class="chapter-number"><a id="_idTextAnchor360"/>8</h1>
			<h1 id="_idParaDest-264"><a id="_idTextAnchor361"/>Recursion and Tail Calls</h1>
			<p>In this chapter,  we will look at the concept of recursion, which is particularly powerful for tackling problems with inherent hierarchical or repetitive structures, such as directory traversal, parsing nested data formats, or implementing algorithms on tree-like data structures.</p>
			<p>As we delve into recursion, we’ll explore its two main components: the base case and the recursive case. The base case acts as a stop signal for recursion, preventing infinite loops, while the recursive case is where the function makes progress toward the base case. In addition to these cases, we will discuss the following topics:</p>
			<ul>
				<li>Types of recursion: simple and tail recursions</li>
				<li>Challenges of recursion: stack overflow risk and performance considerations</li>
				<li>C# features for recursion: local functions and pattern matching</li>
				<li>Advanced recursive patterns: mutual recursion and memoization</li>
				<li>Comparison with iterative solutions: readability and performance</li>
				<li>Recursion in asynchronous programming: async recursion</li>
			</ul>
			<p>As always, we start with a self-evaluation to measure your current understanding of recursion. The following tasks are designed to test your grasp of the concepts we’ll be covering. If you find these tasks challenging, this chapter will be a very valuable resource for you. On the other hand, if you solve these tasks with ease, you may still discover new insights and applications of recursion or just move on to the next chapters.</p>
			<h1 id="_idParaDest-265"><a id="_idTextAnchor362"/>Task 1 – Recursive enemy count</h1>
			<p>Steve’s game <a id="_idIndexMarker438"/>has a hierarchical structure of enemy waves, where each wave can contain both individual enemies and sub-waves. Implement a recursive function, <code>CountAllEnemies</code>, that navigates through a <code>Wave</code> object (which can contain both <code>Enemy</code> objects and <code>Wave</code> objects) and returns the total count of enemies found within that wave, including all its sub-waves (flying, armored, quick, etc.):</p>
			<pre class="source-code">
public interface IWaveContent {}
public class Enemy : IWaveContent
{
    public string Name { get; set; }
}
public class Wave : IWaveContent
{
    public List&lt;IWaveContent&gt; Contents { get; set; } = new();
}
// Implement this method
int CountAllEnemies(Wave wave)
{
    // Your recursive logic here
}</pre>			<p>Test your <a id="_idIndexMarker439"/>method with a <code>Wave</code> containing a mix of <code>Enemy</code> objects and <code>Wave</code> objects to ensure that it accurately counts all enemies, including those in nested sub-waves.</p>
			<h1 id="_idParaDest-266"><a id="_idTextAnchor363"/>Task 2 – Wave generation</h1>
			<p>Using the same wave structure from Task 1, Steve wants to generate increasingly complex <a id="_idIndexMarker440"/>waves as the game progresses. Implement a recursive function, <code>GenerateWave</code>, that creates a <code>Wave</code> object with a nested structure of enemies and sub-waves based on the current level number.</p>
			<pre class="source-code">
public interface IWaveContent {}
public class Enemy : IWaveContent
{
     public string Name { get; set; }
     public EnemyType Type { get; set; }
}
public class Wave : IWaveContent
{
     public List&lt;IWaveContent&gt; Contents { get; set; } = new();
}
public enum EnemyType
{
     Normal,
     Flying,
     Armored,
     Boss
}
// Implement this method
Wave GenerateWave(int levelNumber)
{
     // Your recursive logic here
}</pre>			<p>This function <a id="_idIndexMarker441"/>should create more complex wave structures as the level number increases. Consider the following guidelines:</p>
			<ul>
				<li>For every 5 levels, add a sub-wave.</li>
				<li>The number of enemies in each wave or sub-wave should increase with the level number.</li>
				<li>Introduce more varied enemy types as the levels progress.</li>
			</ul>
			<p>Every 10th level should include a boss enemy.</p>
			<p>Test your method with different level numbers to ensure it generates appropriate wave structures.</p>
			<p>Example usage:</p>
			<pre class="source-code">
int currentLevel = 15;
Wave generatedWave = GenerateWave(currentLevel);
// Use the CountAllEnemies function from Task 1 to verify the total number of enemies
int totalEnemies = CountAllEnemies(generatedWave);
Console.WriteLine($"Level {currentLevel} wave contains {totalEnemies} total enemies");
// You can also implement a function to print the wave structure for verification
PrintWaveStructure(generatedWave);</pre>			<h1 id="_idParaDest-267"><a id="_idTextAnchor364"/>Task 3 – Asynchronously updating enemy stats</h1>
			<p>Updating the stats of enemies (such as health, speed, or damage) might need to be done <a id="_idIndexMarker442"/>asynchronously, especially if it involves fetching or syncing information from a game server. Implement an <code>UpdateAllEnemyStatsAsync</code> method that recursively goes through a hierarchy of waves (containing both enemies and sub-waves) and updates stats for each enemy asynchronously.</p>
			<p>For the sake of this exercise, simulate the asynchronous update operation with the <code>UpdateStatsAsync(Enemy enemy)</code> method, which returns <code>Task</code>. Your recursive function should await the completion of stat updates for each enemy before moving to the next:</p>
			<pre class="source-code">
class Enemy
{
    public string Name { get; set; }
    // Assume other stat properties like Health, Speed, Damage
}
class Wave
{
    public List&lt;object&gt; Contents { get; set; } = new();
}
// Simulated asynchronous update method
async Task UpdateStatsAsync(Enemy enemy)
{
    // Simulate an asynchronous operation with a delay
    await Task.Delay(100); // Simulated delay
    Console.WriteLine($"Updated stats for enemy: {enemy.Name}");
}
// Implement this recursive async method
async Task UpdateAllEnemyStatsAsync(Wave wave)
{
    // Your recursive logic here
}</pre>			<p>As you <a id="_idIndexMarker443"/>tackle these tasks, pay attention to how you break down each problem into smaller pieces and how you identify the base case and recursive case for each scenario. This initial self-evaluation will not only prepare you for the concepts ahead but also provide a practical context for their application. Now, let’s dive in and explore recursion in detail.</p>
			<h1 id="_idParaDest-268"><a id="_idTextAnchor365"/>Introducing recursion</h1>
			<p>As Steve <a id="_idIndexMarker444"/>continued developing his tower defense game, he found himself struggling with complex nested structures for enemy waves. He called Julia, hoping she might have some insights.</p>
			<p>Julia: <em class="italic">It sounds like you’re dealing with hierarchical data structures. Have you considered </em><em class="italic">using recursion?</em></p>
			<p>Steve: <em class="italic">Recursion? Isn’t that when a function calls itself? It always seemed a bit confusing </em><em class="italic">to me.</em></p>
			<p>Julia: <em class="italic">That’s right, but it’s a powerful tool for handling nested structures. Let’s explore how it could help with </em><em class="italic">your game.</em></p>
			<p>Recursion is a programming technique where a function calls itself to solve a problem. It’s like breaking down a task into smaller tasks of the same type. This approach is very useful for tasks that have a repetitive structure, such as navigating through folders and files, working with data structures such as trees, or doing calculations that follow a pattern.</p>
			<p>In recursion, there are <a id="_idIndexMarker445"/>two main parts: the base case and the recursive case. The <a id="_idIndexMarker446"/>base case stops the recursion from going on forever. It’s <a id="_idIndexMarker447"/>where the function doesn’t call itself again. The recursive <a id="_idIndexMarker448"/>case is where the function does call itself but with a simpler version of the original problem.</p>
			<p>Let’s apply recursion to a practical example. Imagine we need to count the total number of views for a series of videos organized in a nested playlist, where a playlist can contain both videos and other playlists.</p>
			<p>Here’s how we might write a recursive function to solve this:</p>
			<pre class="source-code">
class Video : IContent
{
   public int Views {get; set;}
   // Other properties like title, duration, etc.
}
class Playlist : IContent
{
   public List&lt;IContent&gt; Contents; // Can contain both Videos and Playlists
}
int CountViews(IContent item)
{
   if (item is Video video)
   {
      // Base case: If the item is a video, return its view count.
      return video.Views;
   }
   if (item is Playlist playlist)
   {
      // Recursive case: If the item is a playlist, sum up the views of all contents.
      int totalViews = 0;
      foreach (var content in playlist.Contents)
      {
         totalViews += CountViews(content); // Recursively count views
      }
      return totalViews;
   }
   // In case the item is neither a Video nor a Playlist
   throw new ArgumentException($"Unsupported content type {item.GetType().Name}");
}</pre>			<p>In this code, <code>CountViews</code> is a recursive <a id="_idIndexMarker449"/>function that can handle both videos and playlists. If it encounters a video, it returns the number of views (the base case). If it encounters a playlist, it goes through each item in the playlist and calls itself to count the views, adding up all the views for a total (the recursive case).</p>
			<p>Recursion is powerful for problems like this because it simplifies the code and makes it more readable, especially when dealing with nested or hierarchical data. However, it’s important to always have a clear base case to prevent the function from calling itself indefinitely.</p>
			<h1 id="_idParaDest-269"><a id="_idTextAnchor366"/>Recursive thinking</h1>
			<p>When managing a complex hierarchy of videos, such as sorting them into categories and subcategories, thinking <a id="_idIndexMarker450"/>recursively can simplify the process. Recursive thinking means breaking down a big problem into smaller versions of the same problem until it becomes easy to solve.</p>
			<p>Let’s take organizing a tree of video categories and subcategories as our example. The goal is to go through each category, visit all its subcategories, and organize the videos in each. This task sounds complex, but recursion makes it easier by handling one category (and its subcategories) at a time.</p>
			<p>Here’s how you might write a recursive function to do this:</p>
			<pre class="source-code">
class Category
{
    public List&lt;Category&gt; Subcategories;
    public List&lt;Video&gt; Videos;
    // Other properties like name, etc.
}
void OrganizeVideos(Category category)
{
    // First, go through each subcategory
    foreach (var subcategory in category.Subcategories)
    {
        OrganizeVideos(subcategory); // Recursive call to organize subcategories
    }
    // Now, organize the current category's videos
    // You can add sorting, filtering, or other logic here
    Console.WriteLine($"Organizing videos in category: {category.Name}");
}</pre>			<p>In this code, <code>OrganizeVideos</code> is a recursive function. It looks at a category, and for each subcategory, it calls itself, diving deeper into the hierarchy. This is the recursive case. After it has visited all subcategories, it then organizes the videos in the current category. That’s where <a id="_idIndexMarker451"/>you’d put your sorting or organizing logic, but for now, we’re keeping it simple with a <code>print</code> statement.</p>
			<p>The beauty of recursive thinking is how it simplifies managing a complex hierarchy. You deal with organizing videos at just one level at a time, and recursion takes care of diving into the depths of the hierarchy for you. Just like in the previous example, having a clear base case (in this case, reaching a category with no subcategories) ensures that the recursion doesn’t go on indefinitely.</p>
			<p>Now, let’s look at an example demonstrating the power of recursive thinking in parsing nested JSON data. Consider a scenario where we need to process a JSON string representing a book publishing system’s catalog and convert it into a corresponding object hierarchy. This example will showcase how recursion can simplify the task of navigating and constructing complex data structures.</p>
			<p>Assume we have the following JSON string representing a book catalog with nested genres and sub-genres:</p>
			<pre class="source-code">
{
  "catalog": {
    "name": "Book Catalog",
    "genres": [
      {
        "name": "Fiction",
        "subgenres": [
          {
            "name": "Mystery",
            "books": [
              {
                "title": "The Hound of the Baskervilles",
                "author": "Arthur Conan Doyle",
                «isbn": "9780141032435"
              },
              {
                "title": "Gone Girl",
                "author": "Gillian Flynn",
                «isbn": "9780307588371"
              }
            ]
          },
          {
            "name": "Science Fiction",
            "books": [
              {
                "title": "Dune",
                "author": "Frank Herbert",
                «isbn": "9780441013593"
              }
            ],
            "subgenres": [
              {
                "name": "Dystopian",
                "books": [
                  {
                    "title": "1984",
                    "author": "George Orwell",
                    «isbn": "9780451524935"
                  }
                ]
              }
            ]
          }
        ]
      },
      {
        "name": "Non-Fiction",
        "books": [
          {
            "title": "Sapiens: A Brief History of Humankind",
            "author": "Yuval Noah Harari",
            «isbn": "9780062316097"
          }
        ]
      }
    ]
  }
}</pre>			<p>To parse this <a id="_idIndexMarker452"/>JSON string and create a corresponding object hierarchy, we define the following classes:</p>
			<pre class="source-code">
class Catalog
{
    public string Name { get; set; }
    public List&lt;Genre&gt; Genres { get; set; }
}
class Genre
{
    public string Name { get; set; }
    public List&lt;Book&gt; Books { get; set; }
    public List&lt;Genre&gt; Subgenres { get; set; }
}
class Book
{
    public string Title { get; set; }
    public string Author { get; set; }
    public string ISBN { get; set; }
}</pre>			<p>Now, let’s implement <a id="_idIndexMarker453"/>the recursive functions to parse the JSON string and construct the object hierarchy:</p>
			<pre class="source-code">
Catalog ParseCatalog(JsonElement json)
{
    Catalog catalog = new Catalog();
    catalog.Name = json.GetProperty("catalog").GetProperty("name").GetString();
    catalog.Genres = new List&lt;Genre&gt;();
    foreach (JsonElement genreJson in json.GetProperty("catalog").GetProperty("genres").EnumerateArray())
    {
        Genre genre = ParseGenre(genreJson);
        catalog.Genres.Add(genre);
    }
    return catalog;
}
Genre ParseGenre(JsonElement json)
{
    Genre genre = new Genre();
    genre.Name = json.GetProperty("name").GetString();
    genre.Books = new List&lt;Book&gt;();
    genre.Subgenres = new List&lt;Genre&gt;();
    if (json.TryGetProperty("books", out JsonElement booksJson))
    {
        foreach (JsonElement bookJson in booksJson.EnumerateArray())
        {
            Book book = ParseBook(bookJson);
            genre.Books.Add(book);
        }
    }
    if (json.TryGetProperty("subgenres", out JsonElement subgenresJson))
    {
        foreach (JsonElement subgenreJson in subgenresJson.EnumerateArray())
        {
            Genre subgenre = ParseGenre(subgenreJson);
            genre.Subgenres.Add(subgenre);
        }
    }
    return genre;
}
Book ParseBook(JsonElement json)
{
    Book book = new Book();
    book.Title = json.GetProperty("title").GetString();
    book.Author = json.GetProperty("author").GetString();
    book.ISBN = json.GetProperty("isbn").GetString();
    return book;
}</pre>			<p>The <code>ParseCatalog</code> function <a id="_idIndexMarker454"/>serves as the entry point, recursively calling <code>ParseGenre</code> for each genre in the catalog. <code>ParseGenre</code>, in turn, recursively calls itself for each subgenre and invokes <code>ParseBook</code> for each book within the genre or subgenre.</p>
			<p>With recursion, we can <a id="_idIndexMarker455"/>effectively navigate the nested structure of the JSON string, handling the parsing of sub-elements (genres, subgenres, and books) within the context of their parent elements (catalog and genres). This approach results in cleaner and more maintainable code compared to an iterative solution, which would require explicit management of multiple levels of nesting and conditional checks for the presence of subgenres and books.</p>
			<h1 id="_idParaDest-270"><a id="_idTextAnchor367"/>Types of recursion</h1>
			<p>Recursion can <a id="_idIndexMarker456"/>be classified into two main types based on how the recursive call is made and its position within the function: simple recursion and tail recursion.</p>
			<h2 id="_idParaDest-271"><a id="_idTextAnchor368"/>Simple recursion</h2>
			<p>Simple recursion occurs when a function calls itself directly. This type is the most common <a id="_idIndexMarker457"/>and easiest to understand. Let’s use it to count the <a id="_idIndexMarker458"/>total number of videos in a hierarchy of video categories and subcategories:</p>
			<pre class="source-code">
class Category
{
    public List&lt;Category&gt; Subcategories;
    public List&lt;Video&gt; Videos;
    // Constructor and other members
}
int CountTotalVideos(Category category)
{
    // Start with the current category's videos
    int count = category.Videos.Count;
    foreach (var subcategory in category.Subcategories)
    {
       // Add counts from subcategories
        count += CountTotalVideos(subcategory);
    }
    return count; // Return the total count
}</pre>			<p>In this code, <code>CountTotalVideos</code> counts all videos in the given category, including those in its subcategories. It starts by counting videos in the current category. Then, it goes through each subcategory, calls itself for each one, and adds their video counts to the total.</p>
			<h2 id="_idParaDest-272"><a id="_idTextAnchor369"/>Tail recursion</h2>
			<p>Tail recursion <a id="_idIndexMarker459"/>is a special case of recursion where the recursive <a id="_idIndexMarker460"/>call is the last operation in the function. It’s important because many compilers optimize it to avoid increasing the call stack, which makes the function more efficient and prevents stack overflow errors.</p>
			<p>Let’s look at an example where we flatten the video category tree into a single list of videos. This task can benefit from tail recursion optimization.</p>
			<p>First, we need a slight modification in our approach to allow tail recursion. Instead of returning the result directly, we pass along an accumulator—a container that collects the result as we go:</p>
			<pre class="source-code">
void FlattenCategories(Category category, List&lt;Video&gt; accumulator)
{
    accumulator.AddRange(category.Videos); // Add current category's videos to the accumulator
    foreach (var subcategory in category.Subcategories)
    {
        FlattenCategories(subcategory, accumulator); // Recursive call with the same accumulator
    }
}</pre>			<p>To use this function, you’d start with an empty list and pass it in:</p>
			<pre class="source-code">
List&lt;Video&gt; allVideos = new();
FlattenCategories(rootCategory, allVideos);
// Now, allVideos contains all videos from all categories and subcategories</pre>			<p>This function is tail-recursive because the last action it takes is the recursive call (or adding to the accumulator, which doesn’t change the nature of the recursion). However, it’s worth noting that not all programming languages or compilers automatically optimize tail recursion. In .NET, for example, tail call optimization is at the discretion of the CLR, and it <a id="_idIndexMarker461"/>might not always apply it. Still, writing tail-recursive <a id="_idIndexMarker462"/>functions can be a good practice for efficiency and clarity, especially in languages and environments that support optimization.</p>
			<h1 id="_idParaDest-273"><a id="_idTextAnchor370"/>Challenges of recursion</h1>
			<p>When using recursion in programming, two main challenges often arise: the risk of stack overflow and <a id="_idIndexMarker463"/>the considerations for performance. Let’s dive into these challenges with our characters.</p>
			<p>As Steve began implementing recursive functions in his game, he ran into some issues.</p>
			<p>Steve: <em class="italic">Julia, I’m getting stack overflow errors when I have too many nested waves. What’s </em><em class="italic">going on?</em></p>
			<p>Julia: <em class="italic">Ah, you’ve discovered one of the challenges of recursion. Let’s talk about stack overflow risk and how to </em><em class="italic">mitigate it.</em></p>
			<h2 id="_idParaDest-274"><a id="_idTextAnchor371"/>Stack overflow risk</h2>
			<p>A stack <a id="_idIndexMarker464"/>overflow occurs when there’s too much <a id="_idIndexMarker465"/>information to store in the call stack—the part of memory that tracks where each function is in its execution. This can happen if a recursive function calls itself too many times without reaching a base case.</p>
			<p>For example, when counting the total number of videos in all categories and subcategories, if the hierarchy is very deep or there’s a circular reference (a category somehow includes itself), the <code>CountVideos</code> function could keep calling itself indefinitely:</p>
			<pre class="source-code">
int CountVideos(Category category)
{
    // Start with the count of videos in the current category
    int count = category.Videos.Count;
    foreach (var subcategory in category.Subcategories)
    {
        count += CountVideos(subcategory); // Recursive call
    }
    return count;
}</pre>			<p>If the <a id="_idIndexMarker466"/>category structure is very deep, this could <a id="_idIndexMarker467"/>lead to thousands of nested calls, each one adding a frame to the call stack, potentially causing a stack overflow error.</p>
			<h2 id="_idParaDest-275"><a id="_idTextAnchor372"/>Default stack size and limitations</h2>
			<p>When using recursion, it’s crucial to be aware of the limitations imposed by the default stack size. The <a id="_idIndexMarker468"/>stack is a region of memory used to <a id="_idIndexMarker469"/>store method calls, local variables, and other information. Each recursive call adds a new frame to the stack, consuming a portion of the available stack space. If the recursion depth becomes too large, it can exhaust the stack, leading to a stack overflow exception.</p>
			<p>In .NET, the default stack size varies depending on the architecture:</p>
			<ul>
				<li>32-bit: 1 MB</li>
				<li>64-bit: 4 MB</li>
			</ul>
			<p>It’s important to note that these default sizes are subject to change and may vary based on the specific runtime environment and configuration.</p>
			<p>To understand the impact of stack size on recursion, let’s use the example of the preceding <code>CountVideos</code> function. If the category hierarchy is very deep, the recursive calls to <code>CountVideos</code> can quickly consume the available stack space. For example, with a stack size of 1 MB and assuming an average stack frame size of 32 bytes (for simplicity), the maximum recursion depth would be approximately 32,000 (1 MB / 32 bytes). Exceeding this depth would result in a stack overflow exception.</p>
			<p>To mitigate the risk of stack overflow, you can employ several techniques:</p>
			<ul>
				<li><strong class="bold">Tail call optimization</strong> (<strong class="bold">TCO</strong>): If your recursive function is tail-recursive, the compiler <a id="_idIndexMarker470"/>may optimize it to avoid adding new frames to the stack. However, TCO is not guaranteed in .NET and depends on the runtime’s discretion.</li>
				<li><strong class="bold">Iterative alternatives</strong>: Convert the recursive algorithm to an iterative one using <a id="_idIndexMarker471"/>loops and data structures such as stacks or queues. Iterative solutions generally have a smaller stack footprint compared to recursive ones.</li>
				<li><code>System.Threading.Thread.MaxStackSize</code> property or by configuring the runtime environment.</li>
				<li><strong class="bold">Limit recursion depth</strong>: Implement a maximum depth limit in your recursive function <a id="_idIndexMarker473"/>to prevent excessive recursion. This can be done by passing a depth counter as a parameter and checking against a predefined limit.</li>
			</ul>
			<p>Here’s an example of limiting the recursion depth in the <code>CountVideos</code> function:</p>
			<pre class="source-code">
int CountVideos(Category category, int depth, int maxDepth)
{
    if (depth &gt; maxDepth)
    {
        // Recursion depth limit exceeded
        throw new StackOverflowException("Maximum recursion depth exceeded");
    }
    int count = category.Videos.Count;
    foreach (var subcategory in category.Subcategories)
    {
        count += CountVideos(subcategory, depth + 1, maxDepth);
    }
    return count;
}</pre>			<p>In this <a id="_idIndexMarker474"/>modified version, the <code>CountVideos</code> function <a id="_idIndexMarker475"/>takes additional parameters: <code>depth</code> to track the current recursion depth, and <code>maxDepth</code> to specify the maximum allowed depth. If <code>depth</code> exceeds <code>maxDepth</code>, a <code>StackOverflowException</code> is thrown to prevent further recursion.</p>
			<h2 id="_idParaDest-276"><a id="_idTextAnchor373"/>Performance considerations</h2>
			<p>Recursion can sometimes be less efficient than iterative solutions, especially in languages <a id="_idIndexMarker476"/>and environments that don’t optimize recursive calls. The main reasons are the overhead of multiple function calls and, in non-tail-recursive cases, the additional memory required to maintain the call stack.</p>
			<p>Again, in the best case scenario, a smart compiler could optimize this to avoid a stack overflow and make it run as efficiently as a loop. However, not all environments support this optimization, and without it, tail recursion offers no performance benefit over simple recursion.</p>
			<p>To mitigate the risk of stack overflow with deep recursion, you can sometimes refactor recursive functions to use an iterative approach or ensure your recursion has a guaranteed termination condition. For performance, it’s often about weighing the readability and elegance of recursion against the efficiency of iteration. In some cases, using iterative algorithms can be a more practical choice, especially for very large datasets or when working in environments that don’t optimize tail recursion.</p>
			<h1 id="_idParaDest-277"><a id="_idTextAnchor374"/>Leveraging C# features for recursion</h1>
			<p>C# offers <a id="_idIndexMarker477"/>several features that can make writing recursive functions easier and your code cleaner. Two of these features are local functions and pattern matching.</p>
			<h2 id="_idParaDest-278"><a id="_idTextAnchor375"/>Local functions</h2>
			<p>Local functions <a id="_idIndexMarker478"/>allow you to define functions <a id="_idIndexMarker479"/>inside the body of another function. This can be particularly useful for recursion when you want to encapsulate all the logic within a single method, keeping the recursive part separate for clarity and maintainability.</p>
			<p>Here’s an example showing how to use a local function for recursively processing video categories and counting videos:</p>
			<pre class="source-code">
void ProcessAndCountVideosInCategory(Category category)
{
    int videoCount = 0;
    // Local function for recursion
    void CountVideos(Category cat)
    {
        foreach (var subcategory in cat.Subcategories)
      {
            CountVideos(subcategory); // Recursive call
        }
        videoCount += cat.Videos.Count;
    }
    CountVideos(category); // Start the recursion with the top-level category
    Console.WriteLine($"Total videos: {videoCount}");
}</pre>			<p>In this <a id="_idIndexMarker480"/>example, <code>CountVideos</code> is a local function defined within <code>ProcessAndCount</code><strong class="source-inline">
VideosInCategory</strong>. It’s used to traverse the hierarchy of video <a id="_idIndexMarker481"/>categories, counting videos in all subcategories. The total count is kept in the <code>videoCount</code> variable, which is accessible to the local function thanks to C#’s closure capabilities.</p>
			<h2 id="_idParaDest-279"><a id="_idTextAnchor376"/>Pattern matching</h2>
			<p>Pattern <a id="_idIndexMarker482"/>matching makes it easier to work <a id="_idIndexMarker483"/>with complex data by letting you check types and conditions more simply. It’s particularly useful in recursive functions where you need to handle different types or scenarios.</p>
			<p>Let’s see how pattern matching can streamline our function for processing video categories:</p>
			<pre class="source-code">
void ProcessVideoCategory(Category category)
{
    switch (category)
    {
        case Category c when c.HasSubcategories:
            foreach (var subcategory in c.Subcategories)
            {
                ProcessVideoCategory(subcategory); // Recursive call
            }
            break;
        // Additional cases for other types or specific conditions
    }
}</pre>			<p>In this <a id="_idIndexMarker484"/>example, pattern matching is used to check whether the <code>category</code> has subcategories. If it does, the function recursively <a id="_idIndexMarker485"/>processes each subcategory. This approach makes the code more readable and eliminates the need for multiple <code>if</code> statements or type checks.</p>
			<p>Both local functions and pattern matching are powerful tools, especially when dealing with recursion. They not only make your recursive logic more understandable but also keep your code organized and concise.</p>
			<h1 id="_idParaDest-280"><a id="_idTextAnchor377"/>Advanced recursive patterns</h1>
			<p>In more <a id="_idIndexMarker486"/>complex scenarios, recursion can be taken a step further with techniques such as mutual recursion and memoization. These advanced patterns can optimize performance and manage tasks that require alternating between different operations.</p>
			<h2 id="_idParaDest-281"><a id="_idTextAnchor378"/>Mutual recursion</h2>
			<p>Mutual <a id="_idIndexMarker487"/>recursion occurs when two or <a id="_idIndexMarker488"/>more functions call each other in a cycle. This pattern can be particularly useful when you have a problem that requires switching between different types of tasks. Imagine a scenario where one function organizes video metadata and another validates it. Each function calls the other as part of its process.</p>
			<p>In a book creation process, books often undergo a meticulous cycle of editing and review before being deemed ready for publication. This process, inherently iterative and dependent on passing various checks at each stage, lends itself well to a mutual recursion model. Here, we explore a scenario where a book’s manuscript is edited for both content and format, each process potentially unveiling the need for further alterations in the other.</p>
			<p>Consider a system where after a manuscript is initially edited for content (such as narrative structure, character development, etc.); it must then be formatted to meet publishing standards (including font consistency, margin settings, and header/footer content). However, the <a id="_idIndexMarker489"/>formatting process <a id="_idIndexMarker490"/>might introduce or reveal content issues that need re-editing, illustrating a dynamic interdependence between these stages.</p>
			<p>Here’s a conceptual implementation:</p>
			<pre class="source-code">
class Manuscript
{
    public string Title { get; set; }
    public bool ContentEdited { get; set; }
    public bool FormatEdited { get; set; }
    public List&lt;string&gt; ContentIssues { get; set; }
    public List&lt;string&gt; FormatIssues { get; set; }
    public Manuscript(string title)
    {
        Title = title;
        ContentEdited = false;
        FormatEdited = false;
        ContentIssues = new();
        FormatIssues = new();
    }
}
class PublishingWorkflow
{
    public void EditContent(Manuscript manuscript)
    {
        Console.WriteLine($"Editing content for: {manuscript.Title}");
        // Simulate content editing and issue detection
        manuscript.ContentEdited = true;
        manuscript.ContentIssues.Clear(); // Assume content issues are resolved
        // Check for formatting issues
        manuscript.FormatIssues.Add("Inconsistent chapter titles");
        // Check if formatting needs review due to content edits
        if (manuscript.FormatIssues.Any())
        {
            EditFormat(manuscript);
        }
    }
    public void EditFormat(Manuscript manuscript)
    {
        Console.WriteLine($"Editing format for: {manuscript.Title}");
        // Simulate format editing
        manuscript.FormatEdited = true;
        manuscript.FormatIssues.Clear(); // Assume format issues are resolved
        // Formatting might reveal content issues or areas for improvement
        manuscript.ContentIssues.Add("Chapter 3 exceeds length limit");
        // Loop back to content editing if new issues are identified
        if (manuscript.ContentIssues.Any())
        {
            EditContent(manuscript);
        }
    }
}</pre>			<p>In this example, the <code>PublishingWorkflow</code> class contains two mutually recursive functions: <code>EditContent</code> and <code>EditFormat</code>. <code>EditContent</code> handles narrative and textual corrections, while <code>EditFormat</code> ensures that the manuscript adheres to the publisher’s formatting standards. The discovery of issues in one stage can lead back to the other, mirroring the real-world intricacies of preparing a manuscript for publication.</p>
			<p>This mutual <a id="_idIndexMarker491"/>recursion effectively captures the cyclic nature of book editing <a id="_idIndexMarker492"/>and formatting, ensuring that neither content quality nor presentation standards are compromised. It highlights the iterative process of refinement that manuscripts undergo, embodying the collaborative effort between content editors and formatting specialists to achieve a publication-ready book. Through this model, the publishing workflow is optimized for thoroughness and quality, ensuring that readers receive well-crafted and professionally presented books.</p>
			<h2 id="_idParaDest-282"><a id="_idTextAnchor379"/>Memoization</h2>
			<p>Memoization is a technique to speed up recursive functions by caching the results of expensive <a id="_idIndexMarker493"/>function calls and reusing those results <a id="_idIndexMarker494"/>when the same inputs occur again. This can significantly reduce the computation time for functions that are called repeatedly with the same arguments, such as calculating viewership statistics for categories.</p>
			<p>Let’s explore how memoization can be applied to optimize a recursive function for calculating Fibonacci numbers—a common scenario that illustrates the power of memoization in recursive algorithms:</p>
			<pre class="source-code">
public class FibonacciCalculator
{
    private Dictionary&lt;int, long&gt; memo = new();
    public long Calculate(int n)
    {
        // Base cases
        if (n == 0) return 0;
        if (n == 1) return 1;
        // Check if the result is already in the cache
        if (memo.ContainsKey(n))
        {
            return memo[n];
        }
        // Recursively calculate the nth Fibonacci number
        long result = Calculate(n - 1) + Calculate(n - 2);
        // Cache the result before returning
        memo[n] = result;
        return result;
    }
}</pre>			<p>In this implementation, the <code>FibonacciCalculator</code> class uses a dictionary to cache the results <a id="_idIndexMarker495"/>of Fibonacci calculations. When the <code>Calculate</code> method is called, before doing the calculations, it checks whether the <a id="_idIndexMarker496"/>result for the given <code>n</code> is already cached. If so, it returns the cached result immediately, avoiding further recursive calls. If not, it proceeds with the recursive calculation and then caches the result before returning it.</p>
			<p>This memoized approach to calculating Fibonacci numbers is vastly more efficient than a simple recursive solution without memoization. Without caching, the time complexity of calculating the <em class="italic">n</em>th Fibonacci number recursively is exponential (specifically, <code>O(2^n)</code>) due to the repeated computation of the same values. In other words, each call to <code>Calculate(n)</code> results in two additional calls: <code>Calculate(n-1)</code> and <code>Calculate(n-2</code>), each of which branches out similarly. The only exceptions are the base cases where <code>n = 0</code> or <code>n = 1</code>. With memoization, the complexity is reduced to linear (<code>O(n)</code>), as each unique Fibonacci number up to <code>n</code> is calculated exactly once.</p>
			<p>To illustrate the impact of memoization on the efficiency of recursive function calls, let’s analyze the specific case of calculating Fibonacci numbers for <code>n = 13</code>, <code>n = 29</code>, and <code>n = 79</code>, comparing the number of function calls required with and without memoization.</p>
			<p>For <code>n = 13</code>, the total number of function calls would be <code>F(13)</code> + <code>F(12)</code> + <code>F(11)</code> + <code>...</code> + <code>F(1)</code> + <code>F(0)</code>, which adheres to the Fibonacci sequence itself, leading us to 753 function calls. However, if we use memoization, the number of function calls will be only 25.</p>
			<p>For <code>n = 29</code>, we must call our function 1,664,079 times. On the other hand, the memoized approach will require only 57 calls.</p>
			<p>Lastly, for <code>n = 79</code>, the number of function calls grows astronomically, making it impractical to calculate the exact number here. It’s in the order of trillions. For the memoization solution, 157 calls will be enough.</p>
			<p>This analysis <a id="_idIndexMarker497"/>demonstrates the power of memoization to enhance performance and its critical role in making recursive solutions <a id="_idIndexMarker498"/>viable for complex problems. By leveraging memoization, developers can use recursion without incurring extra computational costs.</p>
			<p>To sum up, mutual recursion and memoization are powerful techniques that can make your recursive solutions more efficient and capable. Mutual recursion allows for an elegant alternation between related tasks, while memoization optimizes performance by avoiding redundant calculations.</p>
			<h1 id="_idParaDest-283"><a id="_idTextAnchor380"/>Comparison with iterative solutions</h1>
			<p>When <a id="_idIndexMarker499"/>managing video playlists or similar hierarchical data structures, both recursive and iterative approaches have their place. The choice between them often depends on readability and performance considerations. Let’s explore how these two approaches compare in th<a id="_idTextAnchor381"/>e context of a video management system.</p>
			<h2 id="_idParaDest-284"><a id="_idTextAnchor382"/>Readability</h2>
			<p>Recursion <a id="_idIndexMarker500"/>naturally fits scenarios where the problem <a id="_idIndexMarker501"/>can be divided into smaller, similar problems. For instance, traversing a tree of video playlists and sub-playlists is intuitively understood with recursion:</p>
			<pre class="source-code">
void TraversePlaylist(Playlist playlist)
{
    foreach (var item in playlist.Items)
    {
        switch (item)
        {
            case Video video:
                Console.WriteLine($"Video: {video.Title}");
                break;
            case Playlist subPlaylist:
                TraversePlaylist(subPlaylist); // Recursive call
                break;
        }
    }
}</pre>			<p>This recursive <a id="_idIndexMarker502"/>function is clear and mirrors the hierarchical <a id="_idIndexMarker503"/>nature of playlists. It’s easy to read and understand, especially for those familiar with recursion.</p>
			<p>Iterative solutions, using loops and data structures such as stacks or queues, can manage the same tasks but often require more setup. An iterative version of the playlist traversal might not be as intuitive:</p>
			<pre class="source-code">
void TraversePlaylistIteratively(Playlist playlist)
{
    Stack&lt;Playlist&gt; stack = new();
    stack.Push(playlist);
    while (stack.Count &gt; 0)
    {
        Playlist current = stack.Pop();
        foreach (var item in current.Items)
        {
            switch (item)
            {
                case Video video:
                    Console.WriteLine($"Video: {video.Title}");
                    break;
                case Playlist subPlaylist:
                    stack.Push(subPlaylist); // Mimicking recursion
                    break;
            }
        }
    }
}</pre>			<p>While <a id="_idIndexMarker504"/>effective, the iterative solution is more verbose and <a id="_idIndexMarker505"/>its logic is less direct compared to the recursive approach. Using a stack to mimic the call stack of recursion also adds complexity.</p>
			<h2 id="_idParaDest-285"><a id="_idTextAnchor383"/>Performance</h2>
			<p>The performance <a id="_idIndexMarker506"/>characteristics of recursive and iterative <a id="_idIndexMarker507"/>approaches can vary depending on the specific problem and implementation. Let’s examine the benchmark results for the video playlist that contains 10 levels of sub-playlists with 10 of them on each level:</p>
			<div><div><img src="img/B21069_08_001.jpg" alt="" role="presentation"/>
				</div>
			</div>
			<p>These results provide interesting insights:</p>
			<ul>
				<li>The recursive method is approximately 14% faster, with a mean execution time of 299.2 ms compared to 348.9 ms for the iterative method.</li>
				<li>The recursive approach shows slightly less variation in performance, with smaller error and standard deviation values.</li>
				<li>Contrary to common assumptions, the recursive method allocates less memory (876 bytes) compared to the iterative method (2840 bytes), which is more than three times as much.</li>
			</ul>
			<p>These findings <a id="_idIndexMarker508"/>challenge the conventional wisdom <a id="_idIndexMarker509"/>that iterative solutions are always more efficient:</p>
			<ul>
				<li><strong class="bold">Speed</strong>: The recursive approach outperforms the iterative one, possibly due to the compiler’s optimizations or the specific nature of the traversal task.</li>
				<li><strong class="bold">Memory usage</strong>: Surprisingly, the recursive method uses significantly less memory. This could be due to efficient tail-call optimization or other compiler optimizations for recursive calls.</li>
				<li><strong class="bold">Consistency</strong>: The recursive method shows slightly more consistent performance across runs, as indicated by the lower standard deviation.</li>
			</ul>
			<p>It’s important to note that these results are specific to this particular implementation and dataset. Factors that could influence the outcomes include:</p>
			<ul>
				<li>The depth and breadth of the playlist structure</li>
				<li>The specific operations performed during traversal</li>
				<li>The compiler’s optimization capabilities</li>
			</ul>
			<p>The runtime environment</p>
			<p>In conclusion, while traditional wisdom often favors iterative approaches for performance reasons, our benchmark demonstrates that recursive methods can be more efficient for certain hierarchical structures. This underscores the importance of empirical testing rather than relying solely on general principles. When choosing between recursion and iteration, consider not only code readability and problem structure but also conduct performance tests tailored to your specific use case.</p>
			<h1 id="_idParaDest-286"><a id="_idTextAnchor384"/>Recursion in asynchronous programming</h1>
			<p>Asynchronous <a id="_idIndexMarker510"/>programming has become a cornerstone for developing responsive applications, especially when dealing with I/O-bound operations, such as network requests. When you combine recursion with asynchronous programming, you can handle complex tasks such as fetching and processing data from external APIs or managing video content across a network efficiently.</p>
			<p>Async recursion allows you to perform recursive operations without blocking the main thread, ensuring that your application remains responsive. For example, when fetching video data from an external API where videos are organized into categories that may contain subcategories, you can process each category and its subcategories recursively without freezing the UI.</p>
			<p>Here’s how you might write an asynchronous recursive function to process videos:</p>
			<pre class="source-code">
async Task ProcessVideosAsync(Category category)
{
    foreach (var subcategory in category.Subcategories)
    {
        await ProcessVideosAsync(subcategory); // Recursive call
    }
    // Asynchronous processing of current category videos
    foreach (var video in category.Videos)
    {
        await ProcessVideoAsync(video);
    }
}</pre>			<p>In this example, <code>ProcessVideosAsync</code> processes each subcategory by making recursive calls to itself, ensuring that all levels of the category hierarchy are covered. It then asynchronously processes each video in the current category. The use of <code>await</code> ensures that each operation is complete before moving to the next, maintaining the order of operations without blocking.</p>
			<h2 id="_idParaDest-287"><a id="_idTextAnchor385"/>Explaining asynchronous recursion under the hood</h2>
			<p>To understand <a id="_idIndexMarker511"/>how asynchronous recursion works under the hood, let’s dive into the asynchronous programming model in .NET and explore the use of state machines and the interaction with <code>ThreadPool</code>.</p>
			<p>In .NET, asynchronous methods are implemented using state machines. When an asynchronous method is called, the compiler generates a state machine that keeps track of the method’s execution state. Each <code>await</code> expression in the method marks a point where the method can be suspended, allowing other work to be performed while the awaited operation completes.</p>
			<p>When an asynchronous recursive call is made, the state machine is created for each recursive invocation. The state machines are managed by the .NET runtime, which coordinates their execution and resumption.</p>
			<p>Here’s a simplified representation of how the <code>ProcessVideosAsync</code> method’s state machine might look:</p>
			<pre class="source-code">
class ProcessVideosAsyncStateMachine
{
   // State machine fields
   Category category;
   IEnumerator&lt;Category&gt; subcategoryEnumerator;
   IEnumerator&lt;Video&gt; videoEnumerator;
   TaskAwaiter&lt;Task&gt; recursiveCallAwaiter;
   TaskAwaiter&lt;Task&gt; processVideoAwaiter;
   int state;
   // MoveNext method
   void MoveNext()
   {
      switch (state)
      {
         case 0:
            subcategoryEnumerator = category.Subcategories.GetEnumerator();
            state = 1;
            goto case 1;
         case 1:
            if (subcategoryEnumerator.MoveNext())
            {
               var subcategory = subcategoryEnumerator.Current;
               recursiveCallAwaiter = ProcessVideosAsync(subcategory).GetAwaiter();
               if (!recursiveCallAwaiter.IsCompleted)
               {
                  state = 2;
                  recursiveCallAwaiter.OnCompleted(MoveNext);
                  return;
               }
            }
            else
            {
               state = 3;
               goto case 3;
            }
         case 2:
            recursiveCallAwaiter.GetResult();
            goto case 1;
         case 3:
            videoEnumerator = category.Videos.GetEnumerator();
            state = 4;
            goto case 4;
         case 4:
            if (videoEnumerator.MoveNext())
            {
               var video = videoEnumerator.Current;
               processVideoAwaiter = ProcessVideoAsync(video).GetAwaiter();
               if (!processVideoAwaiter.IsCompleted)
               {
                  state = 5;
                  processVideoAwaiter.OnCompleted(MoveNext);
                  return;
               }
            }
            else
            {
               state = 6;
               goto case 6;
            }
         case 5:
            processVideoAwaiter.GetResult();
            goto case 4;
         case 6:
            // Asynchronous operation completed
            break;
      }
   }
}</pre>			<p>In this state <a id="_idIndexMarker512"/>machine representation, the <code>MoveNext</code> method encapsulates the logic of the asynchronous recursive function. It uses a <code>switch</code> statement to handle different states of the asynchronous operation. The <code>await</code> expressions are translated into asynchronous continuations using <code>TaskAwaiter</code> and <code>OnCompleted</code> callbacks.</p>
			<p>When an asynchronous recursive call is awaited, the state machine is suspended, and the control is returned to the caller. The .NET runtime then schedules the continuation of the state machine on a <code>ThreadPool</code> thread when the awaited operation completes.</p>
			<p>It’s important to note that asynchronous recursive calls interact with <code>ThreadPool</code> differently compared to synchronous recursive calls. Instead of consuming stack space, asynchronous <a id="_idIndexMarker513"/>recursive calls are managed by the <code>ThreadPool</code>, which has a limited number of <a id="_idIndexMarker514"/>threads. If the number of asynchronous recursive calls exceeds the available <code>ThreadPool</code> threads, the <code>ThreadPool</code> may create additional threads or queue the work items until threads become available.</p>
			<p>To avoid overloading the <code>ThreadPool</code> and ensure efficient resource utilization, consider the <a id="_idIndexMarker515"/>following best practices when using asynchronous recursion:</p>
			<ul>
				<li><strong class="bold">Limit recursion depth</strong>: Similar to synchronous recursion, it’s crucial to have a base case that terminates the recursion to prevent excessive recursive calls. Implement a maximum depth limit or use other conditions to control the recursion depth.</li>
				<li><code>SemaphoreSlim</code> or TPL Dataflow to avoid overwhelming the system.</li>
				<li><code>CancellationToken</code>. This allows you to gracefully cancel the recursive operation if needed, preventing unnecessary work and resource consumption.</li>
				<li><code>try</code>-<code>catch</code> blocks to handle exceptions and consider using libraries such as Polly for retry and circuit-breaker policies.</li>
			</ul>
			<p>By understanding how asynchronous recursion works under the hood and following best practices, you can effectively leverage the power of asynchronous programming in combination with recursion to build responsive and efficient applications.</p>
			<p>Asynchronous recursion is a powerful technique that allows you to perform recursive operations without blocking the main thread, enabling your application to remain responsive even when dealing with complex hierarchical data structures or remote API calls. By combining the benefits of asynchronous programming with the elegance of recursion, you can write more efficient and maintainable code for a wide range of scenarios.</p>
			<h1 id="_idParaDest-288"><a id="_idTextAnchor386"/>Synchronous versus asynchronous recursion</h1>
			<p>When it <a id="_idIndexMarker516"/>comes to implementing recursive algorithms, we have the choice between using synchronous or asynchronous <a id="_idIndexMarker517"/>approaches. Each approach has its own characteristics, benefits, and trade-offs. Let’s compare synchronous and asynchronous recursive code using an example of traversing a filesystem hierarchy.</p>
			<p>Here is a synchronous recursive example:</p>
			<pre class="source-code">
void TraverseDirectory(string path)
{
    foreach (var file in Directory.GetFiles(path))
    {
        // Perform some operation on the file
        ProcessFile(file);
    }
    foreach (var subDirectory in Directory.GetDirectories(path))
    {
        // Recursively traverse subdirectories
        TraverseDirectory(subDirectory);
    }
}</pre>			<p>In this <a id="_idIndexMarker518"/>example, the <code>TraverseDirectory</code> function takes a directory path as input and recursively traverses its subdirectories. For each file encountered, it calls the <code>ProcessFile</code> function to perform some operation on the file. The function blocks until all files and subdirectories have been processed.</p>
			<p>Now, let’s <a id="_idIndexMarker519"/>consider an asynchronous <a id="_idIndexMarker520"/>version of the same example:</p>
			<pre class="source-code">
async Task TraverseDirectoryAsync(string path)
{
    var files = await Task.Run(() =&gt; Directory.GetFiles(path));
    foreach (var file in files)
    {
           // Perform some asynchronous operation on the file
           await ProcessFileAsync(file);
    }
    var subDirectories = await Task.Run(() =&gt; Directory.GetDirectories(path));
    foreach (var subDirectory in subDirectories)
    {
           // Recursively traverse subdirectories asynchronously
           await TraverseDirectoryAsync(subDirectory);
    }
}</pre>			<p>In the asynchronous version, the <code>TraverseDirectoryAsync</code> function uses the <code>async</code> and <code>await</code> keywords to enable asynchronous execution. It uses <code>Task.Run</code> to execute the filesystem operations (<code>Directory.GetFiles</code> and <code>Directory.GetDirectories</code>) on a separate thread, allowing the calling thread to continue execution without blocking.</p>
			<p>The <code>ProcessFileAsync</code> function is <a id="_idIndexMarker521"/>assumed to perform some asynchronous operation on each file, such as reading its contents or making an API call. The <code>await</code> keyword <a id="_idIndexMarker522"/>is used to wait for <a id="_idIndexMarker523"/>the completion of each asynchronous operation without blocking the calling thread.</p>
			<p>Let’s <a id="_idIndexMarker524"/>now look <a id="_idIndexMarker525"/>at a comparison and the benefits of each:</p>
			<ul>
				<li><strong class="bold">Responsiveness</strong>: The main advantage of asynchronous recursion is that it allows the calling thread to remain responsive while the recursive operations are being performed. In the synchronous example, the thread is blocked until all files and subdirectories have been processed, which can lead to a frozen UI or unresponsive application. Asynchronous recursion, on the other hand, allows the thread to continue executing other tasks while waiting for the asynchronous operations to complete.</li>
				<li><strong class="bold">Performance</strong>: Asynchronous recursion can improve performance by allowing multiple operations to be executed concurrently. In the asynchronous example, the filesystem operations and file processing can happen in parallel, potentially reducing the overall execution time. However, the actual performance gains depend on the nature of the operations being performed and the available system resources.</li>
				<li><strong class="bold">Resource utilization</strong>: Asynchronous recursion can help optimize resource utilization by allowing the system to process other tasks while waiting for I/O-bound operations to complete. In the synchronous example, the thread is blocked and cannot be used for other purposes until the recursive operation finishes. Asynchronous recursion enables better utilization of system resources by allowing the thread to be freed up for other tasks.</li>
				<li><code>async</code>, <code>await</code>, and <code>Task</code> adds an <a id="_idIndexMarker526"/>extra layer of abstraction and requires <a id="_idIndexMarker527"/>an understanding of asynchronous programming concepts. Error handling and exception propagation also become more involved in asynchronous code.</li>
			</ul>
			<h2 id="_idParaDest-289"><a id="_idTextAnchor387"/>Scenarios for asynchronous recursion</h2>
			<p>Asynchronous <a id="_idIndexMarker528"/>recursion is particularly beneficial in scenarios where the recursive operations involve I/O-bound tasks or long-running CPU-bound operations. Some examples are as follows:</p>
			<ul>
				<li><strong class="bold">Filesystem operations</strong>: Traversing a large filesystem hierarchy and performing I/O operations on files, such as reading or writing data, can benefit from asynchronous recursion. It allows the application to remain responsive while the file operations are being performed asynchronously.</li>
				<li><strong class="bold">Network operations</strong>: Recursive algorithms that involve making network requests or API calls can leverage asynchronous recursion to prevent blocking the calling thread. Asynchronous recursion enables concurrent execution of network operations, improving overall performance.</li>
				<li><strong class="bold">Database operations</strong>: Recursive queries or operations that involve interacting with a database can be implemented using asynchronous recursion. It allows the application to continue executing other tasks while waiting for the database operations to complete.</li>
				<li><strong class="bold">Complex calculations</strong>: Recursive algorithms that perform complex calculations or computations can benefit from asynchronous recursion, especially if the calculations can be parallelized. Asynchronous recursion can help distribute the workload across multiple threads or tasks, potentially improving the overall execution time.</li>
			</ul>
			<p>It’s important to note that not all recursive algorithms are suitable for asynchronous execution. Asynchronous recursion is most effective when the recursive operations involve I/O-bound tasks or can be parallelized efficiently. In cases where the recursive operations are primarily CPU-bound and cannot be parallelized, synchronous recursion may be more appropriate.</p>
			<p>Understanding <a id="_idIndexMarker529"/>the differences between synchronous and asynchronous recursion can help you write more performance code.</p>
			<h1 id="_idParaDest-290"><a id="_idTextAnchor388"/>Exercises</h1>
			<p>To help Steve apply recursion concepts to his tower defense game, Julia prepared three coding challenges. Let’s see if you can help Steve solve them!</p>
			<h2 id="_idParaDest-291"><a id="_idTextAnchor389"/>Exercise 1</h2>
			<p>Steve’s game has a hierarchical structure of enemy waves, where each wave can contain both individual enemies and sub-waves. Implement a recursive function, <code>CountAllEnemies</code>, that navigates through a <code>Wave</code> object (which can contain both <code>Enemy</code> objects and <code>Wave</code> objects) and returns the total count of enemies found within that wave, including all its sub-waves:</p>
			<pre class="source-code">
public interface IWaveContent {}
public class Enemy : IWaveContent
{
     public string Name { get; set; }
}
public class Wave : IWaveContent
{
     public List&lt;IWaveContent&gt; Contents { get; set; } = new();
}
// Implement this method
int CountAllEnemies(Wave wave)
{
     // Your recursive logic here
}</pre>			<p>Test your method with a <code>Wave</code> containing a mix of <code>Enemy</code> objects and <code>Wave</code> objects to ensure that it accurately counts all enemies, including those in nested sub-waves.</p>
			<h2 id="_idParaDest-292"><a id="_idTextAnchor390"/>Exercise 2</h2>
			<p>Using the same wave structure from Task 1, Steve wants to generate increasingly complex waves as the game progresses. Implement a recursive function, <code>GenerateWave</code>, that creates a <code>Wave</code> object with a nested structure of enemies and sub-waves based on the current level number.</p>
			<pre class="source-code">
public interface IWaveContent {}
public class Enemy : IWaveContent
{
     public string Name { get; set; }
     public EnemyType Type { get; set; }
}
public class Wave : IWaveContent
{
     public List&lt;IWaveContent&gt; Contents { get; set; } = new();
}
public enum EnemyType
{
     Normal,
     Flying,
     Armored,
     Boss
}
// Implement this method
Wave GenerateWave(int levelNumber)
{
     // Your recursive logic here
}</pre>			<p>This function should create more complex wave structures as the level number increases. Consider the following guidelines:</p>
			<ul>
				<li>For every 5 levels, add a sub-wave.</li>
				<li>The number of enemies in each wave or sub-wave should increase with the level number.</li>
				<li>Introduce more varied enemy types as the levels progress.</li>
				<li>Every 10th level should include a boss enemy.</li>
			</ul>
			<p>Test your method with different level numbers to ensure it generates appropriate wave structures.</p>
			<p>Example usage:</p>
			<pre class="source-code">
int currentLevel = 15;
Wave generatedWave = GenerateWave(currentLevel);
// Use the CountAllEnemies function from Task 1 to verify the total number of enemies
int totalEnemies = CountAllEnemies(generatedWave);
Console.WriteLine($"Level {currentLevel} wave contains {totalEnemies} total enemies");
// You can also implement a function to print the wave structure for verification
PrintWaveStructure(generatedWave);</pre>			<h2 id="_idParaDest-293"><a id="_idTextAnchor391"/>Exercise 3</h2>
			<p>Updating the stats of enemies (such as health, speed, or damage) might need to be done asynchronously, especially if it involves fetching or syncing information from a game server. Implement an <code>UpdateAllEnemyStatsAsync</code> method that recursively goes through a hierarchy of waves (containing both enemies and sub-waves) and updates stats for each enemy asynchronously.</p>
			<p>For the sake of this exercise, simulate the asynchronous update operation with the <code>UpdateStatsAsync(Enemy enemy)</code> method, which returns <code>Task</code>. Your recursive function should await the completion of stat updates for each enemy before moving to the next:</p>
			<pre class="source-code">
class Enemy
{
     public string Name { get; set; }
     // Assume other stat properties like Health, Speed, Damage
}
class Wave
{
     public List&lt;object&gt; Contents { get; set; } = new();
}
// Simulated asynchronous update method
async Task UpdateStatsAsync(Enemy enemy)
{
     // Simulate an asynchronous operation with a delay
     await Task.Delay(100); // Simulated delay
     Console.WriteLine($"Updated stats for enemy: {enemy.Name}");
}
// Implement this recursive async method
async Task UpdateAllEnemyStatsAsync(Wave wave)
{
     // Your recursive logic here
}</pre>			<p>By tackling these tasks, you’ll enhance your ability to think recursively, manage complex data structures, and leverage asynchronous programming techniques effectively.</p>
			<h1 id="_idParaDest-294"><a id="_idTextAnchor392"/>Solutions</h1>
			<p>Now, let’s delve into the solutions for these exercises. As always, these solutions represent one of the ways in which the problem can be solved. They are provided just to help you verify your work and to offer insights into different ways of approaching recursive problems.</p>
			<h2 id="_idParaDest-295"><a id="_idTextAnchor393"/>Exercise 1</h2>
			<pre class="source-code">
int CountAllEnemies(Wave wave)
{
     int count = 0;
     foreach (var content in wave.Contents)
     {
                  switch (content)
                  {
                      case Enemy:
                          count++;
                          break;
                      case Wave subWave:
                          count += CountAllEnemies(subWave);
                          break;
                  }
     }
     return count;
}</pre>			<p>This solution demonstrates a basic application of recursion to navigate through nested wave structures. It incrementally counts enemies and dives deeper into sub-waves when encountered.</p>
			<h2 id="_idParaDest-296"><a id="_idTextAnchor394"/>Exercise 2</h2>
			<pre class="source-code">
public Wave GenerateWave(int levelNumber)
{
     Wave wave = new Wave();
     wave.Contents = new List&lt;IWaveContent&gt;();
     // Base number of enemies increases with level
     int baseEnemyCount = 5 + levelNumber;
     // Add normal enemies
     for (int i = 0; i &lt; baseEnemyCount; i++)
     {
                  wave.Contents.Add(new Enemy { Name = "Normal Enemy", Type = EnemyType.Normal });
     }
     // Add flying enemies every 3 levels
     if (levelNumber % 3 == 0)
     {
                  int flyingEnemyCount = levelNumber / 3;
                  for (int i = 0; i &lt; flyingEnemyCount; i++)
                  {
                      wave.Contents.Add(new Enemy { Name = "Flying Enemy", Type = EnemyType.Flying });
                  }
     }
     // Add armored enemies every 4 levels
     if (levelNumber % 4 == 0)
     {
                  int armoredEnemyCount = levelNumber / 4;
                  for (int i = 0; i &lt; armoredEnemyCount; i++)
                  {
                      wave.Contents.Add(new Enemy { Name = "Armored Enemy", Type = EnemyType.Armored });
                  }
     }
     // Add a boss every 10 levels
     if (levelNumber % 10 == 0)
     {
                  wave.Contents.Add(new Enemy { Name = "Boss Enemy", Type = EnemyType.Boss });
     }
     // Add a sub-wave every 5 levels
     if (levelNumber &gt; 5 &amp;&amp; levelNumber % 5 == 0)
     {
                  Wave subWave = GenerateWave(levelNumber - 2);
                  wave.Contents.Add(subWave);
     }
     return wave;
}</pre>			<p>To use and test this function, Steve could implement a helper method to print the wave structure:</p>
			<pre class="source-code">
public void PrintWaveStructure(Wave wave, string indent = "")
{
     foreach (var content in wave.Contents)
     {
                  if (content is Enemy enemy)
                  {
                      Console.WriteLine($"{indent}{enemy.Type} Enemy");
                  }
                  else if (content is Wave subWave)
                  {
                      Console.WriteLine($"{indent}Sub-wave:");
                      PrintWaveStructure(subWave, indent + "  ");
                  }
     }
}
// Usage
int currentLevel = 15;
Wave generatedWave = GenerateWave(currentLevel);
Console.WriteLine($"Wave structure for level {currentLevel}:");
PrintWaveStructure(generatedWave);
int totalEnemies = CountAllEnemies(generatedWave);
Console.WriteLine($"Total enemies in the wave: {totalEnemies}");</pre>			<p>This solution demonstrates how recursion can be used to generate complex game structures. As the level number increases, the waves become more challenging with more enemies, different types of enemies, and nested sub-waves. The recursive nature of the function allows for easy scalability and the creation of intricate wave patterns as the game progresses.</p>
			<h2 id="_idParaDest-297"><a id="_idTextAnchor395"/>Exercise 3</h2>
			<pre class="source-code">
async Task UpdateAllEnemyStatsAsync(Wave wave)
{
     foreach (var content in wave.Contents)
     {
              switch (content)
              {
                  case Enemy enemy:
                      await UpdateStatsAsync(enemy);
                      break;
                  case Wave subWave:
                      await UpdateAllEnemyStatsAsync(subWave);
                      break;
              }
     }
}</pre>			<p>This <code>async</code> recursive solution iterates through each content item of a wave, updating stats for enemies directly and diving deeper into sub-waves with recursive calls. The use of <code>await</code> ensures that updates are processed sequentially within each wave and sub-wave, maintaining order and ensuring completeness before proceeding.</p>
			<p>By completing these exercises, you’ve practiced applying recursion to solve different problems. Whether counting items in nested structures, determining the depth of hierarchies, or performing batch operations asynchronously, recursion is a powerful tool in your software development toolkit.</p>
			<h1 id="_idParaDest-298"><a id="_idTextAnchor396"/>Summary</h1>
			<p>Throughout this chapter on recursion, we’ve explored how it allows us to solve complex problems cleanly and elegantly. By breaking down tasks into smaller, manageable parts, recursion provides a direct approach to tackling problems that are naturally hierarchical or repetitive, such as organizing books into genres and sub-genres or processing book metadata.</p>
			<p>We started by understanding the essence of recursion, distinguishing between the base case and the recursive case, and highlighting the importance of always having a clear base case to prevent infinite loops. Then, through practical examples, we demonstrated how recursion simplifies code and enhances readability, especially when dealing with nested or hierarchical data structures.</p>
			<p>Leveraging C# features such as local functions and pattern matching, we explored how the language’s capabilities can enhance our recursive functions, making them more readable and maintainable. Advanced recursive patterns such as mutual recursion and memoization were also introduced, showing how recursion can be extended to handle more complex scenarios efficiently.</p>
			<p>In conclusion, this chapter aimed to equip you with a deeper understanding of recursion, its principles, and its practical applications in real-world scenarios such as those encountered in a book publishing system. As you move forward, you will learn about currying and partial application and their application in real-world scenarios.</p>
		</div>
	</body></html>