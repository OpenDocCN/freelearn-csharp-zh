<html><head></head><body>
<div><div><h1 class="chapter-number" id="_idParaDest-137"><a id="_idTextAnchor136"/>7</h1>
<h1 id="_idParaDest-138"><a id="_idTextAnchor137"/>Nothing Left but the Typing – Implementing the Wheelchair Project</h1>
<p>In the previous chapter, we learned about the advantages of creating a set of diagrams as a design plan for our next coding project. The whole point is to get the design in a format that can be discussed, argued, pondered, socialized, and changed. After the design is completed, the last step is to implement the diagrams as code. Our trio of software engineers has done just that with an ambitious new project designed to make a difference in the lives of potentially thousands of people who could benefit from access to a high-quality, low-cost wheelchair. </p>
<p>I’ve often compared UML with sheet music. A good UML design can be handed off to a developer the same way a musical composer can hand off a score to a competent orchestra. In music, the orchestra will often make changes and improvisational improvements to the sheet music. Sometimes they do this to make the music fit the skill of the performers. Other times, they might need to change or adapt the music to fit the performance itself. Classical composer Johann Sebastian Bach was prolific. Among his most popular works are <em class="italic">The Brandenburg Concertos</em>. Bach assembled the collection in 1721. In 1968, a different composer, Wendy Carlos, arranged <em class="italic">The Brandenburg Concertos</em> to be played entirely on analog synthesizers in her work <em class="italic">Switched on Bach</em>. The music didn’t change as much as the implementation details. It isn’t a stretch to think of programming as being a lot like playing music. It requires creativity and improvisation. A talented architect who has created a good diagram can be reasonably sure a competent development team will be able to implement the diagram and, if required, make some improvisations.</p>
<p>In this chapter, we are going to hand off Tom’s UML design diagrams for implementation. There is a big difference between designing the classes and implementing them. First, the diagrams leave some areas vague on purpose. This is done to allow the developer to make decisions about details that don’t really matter to the diagram. As an example, there are many diagrams in this book that leave out class details. Look at a diagram from the previous chapter in <em class="italic">Figure 7.1</em>:</p>
<div><div><img alt="Figure 7.1: The composite diagram from the last chapter leaves a lot of details up to the developer.  " height="928" src="img/B18605_Figure_7.1.jpg" width="1379"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.1: The composite diagram from the last chapter leaves a lot of details up to the developer. </p>
<p>This isn’t done because the architect is lazy. It is done because those details don’t really matter to the structure of the design. Imagine building a house from a blueprint. The blueprint will probably specify where the walls go. It might even specify the materials to be used, the same way we sometimes dictate a particular type for an instance variable or return type. However, the smaller details, such as what kind of paint to use on the walls or the brand of shingles used on the roof, are all implementation details. The builder can make those decisions independently of the blueprint.</p>
<p>While focusing on the design from <a href="B18605_06.xhtml#_idTextAnchor110"><em class="italic">Chapter 6</em></a>, <em class="italic">Step Away from the IDE! Designing with Patterns Before You Code</em>, we’ll cover the following:</p>
<ul>
<li>Creating a new command -line project. So far, I have stayed away from IDE mechanics. I won’t be going into depth here either. It just feels right to start the chapter this way. If you’re new to C# development, and you haven’t noticed <a href="B18605_Appendix_1.xhtml#_idTextAnchor178"><em class="italic">Appendix 1</em></a> at the end of the book, you should check that out because I show you some of these mechanics that might not be second nature to you</li>
<li>We’ll start by adding our base classes just like Tom did, but we don’t really need a two-pass system since we did all the organization work in the design phase.</li>
<li>We’ll implement the Builder pattern.</li>
<li>We’ll convert the Builder pattern implementation to a Singleton.</li>
<li>We’ll implement the Composite pattern.</li>
<li>We’ll implement the Bridge pattern.</li>
<li>We’ll implement the Command pattern.</li>
</ul>
<p>Throughout the book, I assume you know how to create new C# projects in your favorite <strong class="bold">integrated development environment</strong> (<strong class="bold">IDE)</strong>. I do not usually spend any time on the mechanics of setting up and running projects. This chapter is a mild exception since the whole chapter really is an example of one big project. If you need more details, or you want to use an IDE other than Rider, and you’re not sure how to set up the projects, please see <a href="B18605_Appendix_1.xhtml#_idTextAnchor178"><em class="italic">Appendix 1</em></a> of this book. Should you decide to try any of this out, you’ll need the following:</p>
<ul>
<li>A computer running the Windows operating system. I’m using Windows 10. Since the projects are simple command-line projects, I’m pretty sure everything here would also work on a Mac or Linux, but I haven’t tested the projects on those operating systems.</li>
<li>A supported IDE such as Visual Studio, JetBrains Rider, or Visual Studio Code with C# extensions. I’m using Rider 2021.3.3.</li>
<li>Any version of the .NET SDK. Again, the projects are simple enough that our code shouldn’t be reliant on any particular version. I happen to be using the .NET Core 6 SDK.</li>
</ul>
<p>You can find the completed project files for this chapter on GitHub at <a href="https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-7">https://github.com/Kpackt/Real-World-Implementation-of-C-Design-Patterns/tree/main/chapter-7</a>.</p>
<h1 id="_idParaDest-139"><a id="_idTextAnchor138"/>The crack of noon</h1>
<p>Having spent the previous day and well into the night diagramming their project, Tom, Kitty, and Phoebe arrived at Bumble Bikes. At high noon the next day, the energy in the room was palpable. </p>
<p>Kitty walked in with a box under her arm. She had ordered a new keyboard, the kind with the loud blue clicky switches. She loved these keyboards because they reminded her of her father’s IBM Model M keyboard. She used to play with it when she was little. Kitty wanted to remember the inspiration for this project. </p>
<p>A short time ago, she and her sister, Phoebe, had started a successful bicycle manufacturing company. Their outlook was optimistic until their father was diagnosed with a rare degenerative muscular disease called dermatomyositis and he was newly confined to a wheelchair. Kitty and Phoebe’s mother had fought a long legal battle with their medical insurance provider, who refused to pay for the expensive wheelchair their father needed to cope with his disease. Phoebe took matters into her own hands and decided, nearly singlehandedly, that she could make a wheelchair for their father and everyone else who needed one. Naturally, Kitty followed her younger sister’s lead because she knew Phoebe was right. “<em class="italic">Today is the day,</em>” Kitty thought, <em class="italic">“we change the world.”</em> The new keyboard would keep her focus on her father and all the people she could help just by doing a little typing.</p>
<p>Tom showed up to the lab wearing his finest nerdy T-shirt; it bore a famous XKCD cartoon featuring two developers sword fighting with the lettering on the shirt stating that Tom was not slacking off; he was merely waiting for his code to compile. Phoebe arrived with a stack of pizzas and a palette of fizzy water. The advantage to starting work at noon is that it’s easy to get the supplies needed. As we all know, a programmer is merely a biological machine that converts pizza and caffeine into code. </p>
<p>The trio got set up and Phoebe turned off the harsh overhead fluorescent lights. After a quick scrum session, they decided on a part of the application where they would get started. With any luck, they could have this done in a few days and this code might be the most important code the sisters, with Tom’s help, might ever write.</p>
<h1 id="_idParaDest-140"><a id="_idTextAnchor139"/>Setting up the project</h1>
<p>Kitty, Phoebe, and Tom hunker<a id="_idIndexMarker482"/> down in front of Kitty’s new keyboard. The three are intent on using pair programming. Pair programming occurs when two or more developers work together and one keyboard is shared. One person types as the others watch. The developers trade positions every so often. The developers who are not typing are responsible for watching and helping with research. Pair programming negates the need for code reviews and is shown to dramatically increase developer productivity. If you’re not familiar with the practice of pair programming, check out the book <em class="italic">Practical Remote Pair Programming</em> listed in the <em class="italic">Further reading</em> section of this chapter. Tom is intimately familiar with the design, but Kitty and Phoebe can type faster. Tom’s ability to type with his toes is truly amazing, but he accepted a long time ago that typing speed is not a value he brings to a team. Kitty and Phoebe have far less coding experience, but having spent the last few years writing research papers at separate universities, their typing has become quite fast. Kitty decides to take the keyboard first while Phoebe fuels up on pizza and fizzy water. Kitty opens her favorite IDE and creates a new <strong class="bold">Console Application</strong> project as shown in <em class="italic">Figure 7.2</em>.</p>
<div><div><img alt="Figure 7.2: Creating a new command-line project. " height="877" src="img/B18605_Figure_7.2.jpg" width="1377"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.2: Creating a new command-line project.</p>
<p>If you’re following<a id="_idIndexMarker483"/> along with a different IDE, and you’re not sure how to create a command-line project, check out <a href="B18605_Appendix_1.xhtml#_idTextAnchor178"><em class="italic">Appendix 1</em></a> of this book. In it, I cover project creation mechanics for Visual Studio, Rider, and Visual Studio Code. I used Rider for this book because it has exceptional tools for cleaning and formatting code that come in handy when you’re writing a book.</p>
<p>Once Kitty had created the project, she put Visio on one of the other monitors so she could see the UML diagrams for the project. The first diagram she opened was actually the very last diagram they had worked on. You can see it in <em class="italic">Figure 7.3</em>. Tom had added a change to a central interface called <code>IManufacturable</code>. This is a very good place to start since everything else flows from this one interface.</p>
<div><div><img alt="Figure 7.3: The IManufacturable interface and a class structure that implements make the perfect place to start. " height="953" src="img/B18605_Figure_7.3.jpg" width="1391"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.3: The IManufacturable interface and a class structure that implements make the perfect place to start.</p>
<p>Kitty adds a new file called <code>IManufacturable</code> and types the code<a id="_idIndexMarker484"/> indicated by the diagram:</p>
<pre class="source-code">public interface IManufacturable
{
    public string ModelName { get; set; }
    public int Year { get; }
    public string SerialNumber { get; }
    public string BuildStatus { get; set; }
}</pre>
<p>We’ve seen these properties before in the <code>bicycle</code> project. The <code>Year</code> and <code>SerialNumber</code> properties<a id="_idIndexMarker485"/> are going to be set automatically by the constructor in the implementing class, so only a <code>get</code> method is needed.</p>
<p>Next, Kitty adds the abstract <code>Wheelchair</code> class:</p>
<pre class="source-code">public abstract class Wheelchair : IManufacturable
{</pre>
<p>The class is marked as <code>abstract</code> as per the diagram. Don’t forget that in UML, abstract classes display the class title <em class="italic">in italics</em>. This can be difficult to see with some of the fonts in UML modeling tools. The <code>Wheelchair</code> class implements the <code>IManufacturable</code> interface Kitty made a moment ago. Most IDEs can generate the missing members specified by the interface. Kitty generated the following code. She made <code>BuildStatus</code> nullable by adding the question mark next to the type definition:</p>
<pre class="source-code">    public string ModelName { get; set; }
    public int Year { get; }
    public string SerialNumber { get; }
    public string? BuildStatus { get; set; }</pre>
<p>The constructor is almost identical to those used in the <code>bicycle</code> project. Since the class is abstract, it makes sense to expose the constructor as <code>protected</code>. Within the constructor, Kitty initializes everything she can:</p>
<pre class="source-code">    protected Wheelchair()
    {
        ModelName = string.Empty; 
        SerialNumber = Guid.NewGuid().ToString();
        Year = DateTime.Now.Year; 
    }
}</pre>
<p>The <code>SerialNumber</code> attribute is a GUID. This is a system-generated string that is guaranteed to be unique. This makes it perfect for a serial number. The <code>Year</code> attribute is initialized to the current year.</p>
<p><em class="italic">“Let’s wait on the frame</em><em class="italic"><a id="_idIndexMarker486"/></em><em class="italic"> and seat properties for now. They’re not primitives and we haven’t created classes for them yet,”</em> Tom said.</p>
<p>Tom’s design split wheelchairs into two types: unpowered chairs and powered chairs. Kitty adds the <code>UnpoweredChair</code> class next:</p>
<pre class="source-code">public abstract class UnpoweredChair : Wheelchair
{
  
}</pre>
<p>She doesn’t make it very far. Like most class diagrams, the types needed for the <code>RightWheel</code>, <code>LeftWheel</code>, and <code>Casters</code> properties aren’t specified. “<em class="italic">We need the composite diagram for the types,</em>” Tom reminded her. That particular diagram can be seen in <em class="italic">Figure 7.4</em>:</p>
<div><div><img alt="Figure 7.4: The Composite structure. " height="928" src="img/B18605_Figure_7.4.jpg" width="1379"/>
</div>
</div>
<p class="figure-caption">Figure 7.4: The Composite structure.</p>
<p>Tom’s design for the Composite pattern<a id="_idIndexMarker487"/> makes each part of the wheelchair out of an abstract class called <code>WheelchairComponent</code>. The wheels and casters in our current model need this abstract class defined before we can get the types correct. Kitty adds a new class called <code>WheelchairComponent</code>:</p>
<pre class="source-code">public abstract class WheelchairComponent
{</pre>
<p>In order to use the Composite pattern, we need a few properties. The point of the Composite pattern is to use a tree-like structure to process lists. Kitty and Phoebe want to be able to iterate recursively over their wheelchair model instance to report on the weight and cost for each component. These numbers can be summed at any level to determine the weight and cost of a single part or a subset of the chair. For example, it might be useful to know the weight and cost of the assembled frame. When we are working with bicycles, weight and cost are typical trade-offs. Cheaper components are heavier. Competitive cyclists are willing to pay more to shave grams off their total weight. Doing this can reduce the time of a long ride by a few seconds, which might be enough to win a race.</p>
<p>Lightweight components<a id="_idIndexMarker488"/> for a wheelchair have the same concerns as bicycles; however, the motivation is driven by a different purpose. Kitty and Phoebe’s dad has a degenerative muscle disease. He specifically needs something lightweight if he’s going to be using an unpowered chair. Some wheelchair users have very strong upper bodies; others are not as strong. Lightweight materials are still balanced against cost, and the Composite pattern will help the engineering team analyze and improve the cost-to-weight ratio for the wheelchairs.</p>
<p>Since this class is abstract, its members are going to be <code>protected</code>, unless there’s a good reason for them to not be <code>protected</code>. Kitty adds properties for <code>Weight</code> and <code>Price</code> as floats:</p>
<pre class="source-code">    protected float Weight { get; set; }
    protected float Price { get; set; }</pre>
<p>Next, Kitty adds the crucial part of the class. The Composite pattern needs a <code>Subcomponents</code> collection. Remember, components in the composite are either leaves or containers. Containers are nodes in the tree that have other nodes within them. During the design phase, Kitty and Tom drew a diagram of the composite’s tree structure on a whiteboard. You can see that again in <em class="italic">Figure 7.5</em>, with Tom’s design written on the left side and Kitty’s on the right.</p>
<div><div><img alt="Figure 7.5: Tree-like structure for powered and unpowered chairs. " height="942" src="img/figure-7-5.jpg" width="1608"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.5: Tree-like structure for powered and unpowered chairs.</p>
<p>If you look at the axle<a id="_idIndexMarker489"/> on the unpowered chair, you will see that it has components within it. The axle is a container. The right caster, on the other hand, doesn’t contain any other components, so it is a leaf.</p>
<p>Regardless of whether they are a container or a leaf, all classes in the structure use the same base class, which contains a collection to hold other components. In effect, everything has the potential to be a container, even if it is merely a leaf. Kitty adds the collection:</p>
<pre class="source-code">    protected List&lt;WheelchairComponent&gt; Subcomponents { get; set; }</pre>
<p>Note: the collection type is the very class she’s writing. This allows the composite to be iterable. We will rely on Liskov substitution heavily by requiring this base class for our types, but will supply concrete<a id="_idIndexMarker490"/> classes when we actually implement the Builder pattern later.</p>
<p>Next, Kitty adds a constructor and initializes all the properties:</p>
<pre class="source-code">    protected WheelchairComponent()
    {
        Subcomponents = new List&lt;WheelchairComponent&gt;();
        Weight = 0.0f;
        Price = 0.0f;
    }</pre>
<p>The diagram in <em class="italic">Figure 7.4</em> indicates a couple of methods. Kitty isn’t far enough along yet to worry about the specifics of these methods. For now, she just adds a line that throws <code>NotImplementedException</code> should anything try to access these methods. This is a very common placeholder:</p>
<pre class="source-code">    protected void DisplayWeight()
    {
        throw new NotImplementedException();
    }
    protected void DisplayCost()
    {
        throw new NotImplementedException();
    }
    
}</pre>
<p>With this done, Kitty can return to defining the <code>UnpoweredChair</code> class. She switches to the <code>UnpoweredChair.cs</code> file in her IDE. This time, she gets a little further. She adds the three properties required by the class diagram (<em class="italic">Figure 7.3</em>):</p>
<pre class="source-code">public abstract class UnpoweredChair : Wheelchair
{
    protected WheelchairComponent RightWheel { get; set; }
    protected WheelchairComponent LeftWheel { get; set; }
    protected WheelchairComponent Casters { get; set; }
}</pre>
<p>Kitty’s IDE indicates a problem<a id="_idIndexMarker491"/> with a yellow wavy line beneath each property. She hasn’t initialized any of them. This isn’t a huge problem because she knows she’s going to be using the Builder pattern later to fill in these details based on which chair model is being built. </p>
<p>It was right about then that Kitty was startled by a loud voice behind her. “<em class="italic">PEEE-EW! That’s some smelly code you got there!</em>” Phoebe exclaimed. Apparently, having downed a few slices of pizza and a few cans of caffeinated fizzy water, she was ready to be tagged in.</p>
<p>“<em class="italic">What?</em>” Kitty asked sheepishly. Tom chimed in, “<em class="italic">I think she’s upset because you used the WheelchairComponent base class for your types.</em>”</p>
<p>“<em class="italic">I thought that’s what we were doing</em>,” Kitty replied.</p>
<p>“<em class="italic">Look again, Sis. The composite diagram</em><em class="italic"><a id="_idIndexMarker492"/></em><em class="italic"> has classes under the WheelchairComponent class</em> <em class="italic">that are more specific</em>,” Phoebe said. Kitty got up and Phoebe took her place.</p>
<h2 id="_idParaDest-141"><a id="_idTextAnchor140"/>Wheelchair components</h2>
<p>Phoebe sat down<a id="_idIndexMarker493"/> and made a show of stretching her neck and cracking her knuckles. If this were a fight scene in an action movie, this would be her opponent’s cue to be intimidated. Instead, the cursor blinked unafraid in the IDE. “<em class="italic">This is a good spot for me to fill in because I know a little bit more about the actual components,</em>” said Phoebe. She was right. Phoebe had spent many hours sourcing parts and figuring out how to make what she couldn’t buy while building bikes. In <em class="italic">Figure 7.4</em>, we can see there is a set of abstract components that all inherit from <code>WheelchairComponent</code>. The <code>WheelchairComponent</code> base class gives us the <code>Weight</code> and <code>Price</code> fields used in the composite pattern to help us iteratively compute the weight and price of a set of components. The diagram lists nine such components:</p>
<ul>
<li><code>WheelchairSeat</code></li>
<li><code>Axle</code></li>
<li><code>CasterAssembly</code></li>
<li><code>MechanicalWheel</code></li>
<li><code>ElectricMotor</code></li>
<li><code>WheelchairFrame</code></li>
<li><code>Battery</code></li>
<li><code>TrackDriveSystem</code></li>
<li><code>SteeringMechanism</code></li>
</ul>
<p>Phoebe will need to make a class for each item on the list. “<em class="italic">That’s a lot of components</em>,” Phoebe said. “<em class="italic">Can we focus on a minimum viable product here?”</em></p>
<p>A <strong class="bold">minimum viable product (MVP)</strong> is a term from agile development. <strong class="bold">Agile development</strong> is a project management paradigm<a id="_idIndexMarker494"/> Kitty had learned in one of her product<a id="_idIndexMarker495"/> development courses. Agile methodologies are popular in software companies because they allow you to get a product to market quickly by focusing on the smallest product the company can sell. It then uses <strong class="bold">iterative development</strong> to build that product in a series<a id="_idIndexMarker496"/> of small bursts of effort. In this case, we have two wheelchair designs. The <em class="italic">Texas Tank</em> is seriously<a id="_idIndexMarker497"/> cool, but it will also be seriously expensive to make. The trio realizes they can make a huge impact by building the simple unpowered chair: the <em class="italic">Plano Wheelchair</em>. The faster this chair goes to market, the more people they can help. The team decides to focus on just making that chair. This cuts down her list to just these components:</p>
<ul>
<li><code>WheelchairSeat</code></li>
<li><code>Axle</code></li>
<li><code>CasterAssembly</code></li>
<li><code>MechanicalWheel</code></li>
<li><code>WheelchairFrame</code></li>
</ul>
<p>“<em class="italic">Why don’t you make a folder for those?</em> <em class="italic">It will make them easier to find later and our code will be a little less cluttered</em>,” Tom suggested. A focused expression settled over Phoebe’s countenance. She added a folder to her project called <code>WheelchairComponents</code>.</p>
<p>Next, Phoebe added a class within the folder called <code>WheelchairSeat</code>. She also added the remaining classes from the list, each one being empty for now. At this point, her project resembles <em class="italic">Figure 7.6</em>:</p>
<div><div><img alt="Figure 7.6:  The folder structure for the abstract wheelchair components. " height="583" src="img/B18605_Figure_7.6.jpg" width="645"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.6:  The folder structure for the abstract wheelchair components.</p>
<p>“<em class="italic">It probably makes sense to move the WheelchairComponent.cs file into that folder as well</em>,” Tom advised. Phoebe<a id="_idIndexMarker498"/> dragged the file from the project’s root folder into the subfolder with the other nine class files she had just created.</p>
<p>“<em class="italic">Hey, open  that file real quick. Let’s make sure the IDE changed the namespace for you,”</em> said Tom. <em class="italic">“Some IDEs do this and some don’t,</em>” he continued. Phoebe double-clicked the file in Rider. The IDE, in fact, did not change the code. Namespaces in C# are like packages in Java. Their job is to help you keep your code organized and to prevent name collisions in complicated projects. Tom doubted this project would be complicated enough to have such a name collision. A name collision occurs when you want to name two classes with the same name. This is illegal in C# if the classes are in the same namespace. The project’s namespace is usually created automatically when the project is created in your IDE. </p>
<p>Changing the namespace in the <code>WheelchairComponent.cs</code> file isn’t crucial to the operation of the program. Since Tom and Phoebe have chosen to organize their code into folders, it is conventional to have the namespace match the folder structure. Phoebe modifies the <code>WheelchairComponent</code> class code to reflect the new folder location. This is done at the top of the file. The code before the operation reads as follows:</p>
<pre class="source-code">namespace <strong class="bold">WheelchairProject</strong>;
public abstract class WheelchairComponent
{</pre>
<p>Phoebe<a id="_idIndexMarker499"/> corrects it to the following:</p>
<pre class="source-code">namespace <strong class="bold">WheelchairProject.WheelchairComponents</strong>;
public abstract class WheelchairComponent
{</pre>
<p>After she did this, her IDE immediately colored her <code>UnpoweredChair</code> class with red underlines alerting her to a syntax problem. It used <code>WheelchairComponent</code>, and we just changed the namespace. Fixing this is error is easy. We just need to add a <code>using</code> statement to the top of the file. However, doing so right now is pointless. Phoebe intends for this class to use the class files she just created instead of the abstract <code>WheelchairComponent</code> class, which is too generic to represent an actual component.</p>
<p>Phoebe switches her focus back to the <code>MechanicalWheel</code> component she created a moment ago. Right now, the class merely contains the boilerplate added by the IDE:</p>
<pre class="source-code">namespace WheelchairProject.WheelchairComponents;
public class MechanicalWheel
{
  
}</pre>
<p>Phoebe goes to work on it:</p>
<pre class="source-code">namespace WheelchairProject.WheelchairComponents;
public abstract class MechanicalWheel : WheelchairComponent
{
    protected float Radius { get; set; }
    protected int SpokeCount { get; set; }
    protected bool IsPneumatic { get; set; }
}</pre>
<p>Phoebe adds three properties<a id="_idIndexMarker500"/> to describe an abstract wheel. “<em class="italic">Why are we making this class abstract?</em>” Kitty asked. Kitty was sitting off to the side, but the group had set up a monitor so that whoever was sitting out from typing could see all the action. Phoebe answered, “We’ll later <em class="italic">define more concrete wheels, but having this abstract is a smart defense against future change. We don’t want to tightly couple our UnpoweredChair class to a particular wheel. Instead, just about any type of mechanical wheel you can imagine can be implemented as a subclass to this one. Unless we come up with a radically new type of wheel, all wheels will have a radius. Most wheelchair wheels have spokes, but even if you had one that didn’t, you could set the spoke count to zero. Finally, most wheelchairs have some sort of tire. Some are solid and some use air. The ones that use air are called pneumatic tires and are similar to typical bicycle tires.”</em></p>
<p><em class="italic">“I get it!”</em> Kitty exclaimed. “<em class="italic">You’re going to use this class and the others like it from our list to define the structure of the UnpoweredChair class. Then you’re going to define concrete classes for the actual wheels we’ll be using. When the builder class constructs the wheelchair object, it can specify the concrete classes. The Liskov substitution allows us to substitute a parent class for a subclass, thus our design remains flexible</em>.”</p>
<p>“<em class="italic">You’ve got it!”</em> Tom said. “<em class="italic">Now we need to do the same thing with the rest of the components</em>.”</p>
<p>I need to break the fourth wall<a id="_idIndexMarker501"/> here for a minute: I am what you might call a detail junkie. I’m the kind of guy that likes to point out mistakes in TV shows and movies. I think it’s a safe assumption, given you are reading this book, that you have likely seen the TV show <em class="italic">Star Trek, The Next Generation</em>. If that was before your time, you now have a binge-watching assignment after you complete this book. Here are a few things I noticed in that show. In Season 1, Episode 13, the android Data drinks spiked champagne, falling backward, and in the very next scene, he is face down. In Season 1, Episode 25, Riker orders Geordi to increase the speed of the starship Enterprise to Warp 6. Geordi replies, <em class="italic">“Aye</em> <em class="italic">sir, full impulse.”</em> In Star Trek, “warp” refers to a logarithmic scale relative to the speed of light, while “impulse” refers to sublight speed. As I said, things like that bother me. I realize, having said that, I will probably be inundated with emails regarding my own inconsistencies within this book. Here’s my rule about that: you’re only allowed to do this if you tell all your friends to buy the book so you can have a nice chuckle over my errors. If all your friends buy the book, we’ll sell enough to do a second printing, and I can fix all the continuity mistakes. Of course, I’ll probably introduce some new ones during the revision process, so the cycle will continue. I’m okay with that if you are.</p>
<p>Here, I’m trying to spare you the tedium of making this so realistic that there are hundreds of classes. Don’t forget that our focus is patterns. This isn’t an attempt to build a real wheelchair model that would pass muster with a mechanical engineer. I’ll be doing more of this as the chapter progresses. Direct your focus to the structure of the objects, not their contents. The parts important to the patterns are always going to be there; the rest just makes for a good story. Now that we’ve gotten that out of the way, let’s fast-forward a bit. All of the classes in the <code>WheelchairComponents</code> folder are going to be abstract classes that subclass <code>WheelchairComponent</code>. The other properties don’t affect the Composite pattern or any other part of our program.</p>
<p>We now return you to your story already in progress.</p>
<p>Phoebe continues filling out the remaining classes<a id="_idIndexMarker502"/> in the components list. We’ll go in alphabetical order focusing only on the components needed in an unpowered chair. The first class is the Axle class. Remember that in the Component pattern, each element is either a container or a leaf. Containers contain other containers and leaves. A leaf cannot contain anything. According to <em class="italic">Figure 7.5</em>, the <code>Axle</code> is a container which holds the left and right wheels.</p>
<pre class="source-code">using WheelchairProject.WheelchairComponents.Wheels;
namespace WheelchairProject.WheelchairComponents.Axles;
public abstract class Axle : WheelchairComponent 
{</pre>
<p>I’ll add the two wheels as private fields.</p>
<pre class="source-code">  private MechanicalWheel _leftWheel;
  private MechanicalWheel _rightWheel;</pre>
<p>These next two properties define the axle, which is just a cylinder.</p>
<pre class="source-code">  protected float Radius { get; set; }
  protected float Length { get; set; }</pre>
<p>Next, Phoebe adds accessor methods for the <code>_leftWheel</code> and <code>_rightWheel</code> fields. First<a id="_idIndexMarker503"/> comes the left wheel. Note the<code> FixComposite()</code> method. This implements Tom’s original idea of having the Composite pattern baked directly into the object structure, in contrast with Kitty and Phoebe’s implementation in the bicycle project which used a separate object graph. We’ll create the<code> FixComposite()</code> method in just a moment.</p>
<pre class="source-code">  public MechanicalWheel LeftWheel
  {
    get =&gt; _leftWheel;
    set
    {
      _leftWheel = value;
      FixComposite();
    }
  }</pre>
<p>Then comes the right wheel.</p>
<pre class="source-code">  public MechanicalWheel RightWheel
  {
    get =&gt; _rightWheel;
    set
    {
      _rightWheel = value;
      FixComposite();
    }
  }</pre>
<p>Next, with Tom’s guidance, Phoebe<a id="_idIndexMarker504"/> creates a method<a id="_idIndexMarker505"/> called <code>FixComposite()</code>. <em class="italic">“You need to put this on the abstract components.”</em>, Tom said. Phoebe added the following code:</p>
<pre class="source-code">  private void FixComposite()
  {
    Subcomponents.Clear();
    Subcomponents.Add(_leftWheel);
    Subcomponents.Add(_rightWheel);
  }
}</pre>
<p><em class="italic">“I see what you’re doing!”</em>, Kitty said from her chair behind Phoebe. <em class="italic">“Each component manages the subcomponents inside it. Instead of making a separate object graph, you’re having the accessor methods rebuild the composite every time the left and right wheels change.”</em></p>
<p><em class="italic">“Why aren’t we putting it in the </em><code>WheelchairComponent</code><em class="italic"> base class?”,</em> asked Phoebe. <em class="italic">“There are two reasons.”</em>, Tom said. <em class="italic">“First, this method is specific to the Axle. It contains these two specific components”</em> Phoebe interrupted, <em class="italic">“But we could make it abstract, and override it in the subclasses.”</em> </p>
<p><em class="italic">“Let me finish, Phoebe”,</em> said Tom. He continued, <em class="italic">“The second reason is the interface segregation principle from SOLID. Only containers need this method. The leaves don’t have any sub-components, and so have no need to fix the list of subcomponents on the WheelchairComponent base class. The interface segregation principle holds that no class should be forced to implement an interface it doesn’t use, nor should it depend on a method it doesn’t need. If we make this an abstract method in the base class, the leaf classes will have to implement it. Any implementation we add with be contrived, and it will introduce a code smell to those classes.”</em></p>
<p><em class="italic">“Who is writing smelly code, now Phoebe?”</em>, Kitty chided as she enjoyed sweet revenge on her sister.</p>
<p>Phoebe shrugged off her sisters<a id="_idIndexMarker506"/> jab and continued working. Based on <em class="italic">Figure 7.5</em>, she knows these classes need a <code>FixComponent()</code> method because<a id="_idIndexMarker507"/> they are containers:</p>
<ul>
<li><code>Axle</code> (already written)</li>
<li><code>CasterAssembly</code></li>
<li><code>Wheelchair</code></li>
<li><code>WheelchairFrame</code></li>
</ul>
<p><code>Wheelchair</code> is the base class for all wheelchairs. It needs to inherit from <code>WheelchairComponent</code> because we need a top-level container. Phoebe makes extensive modifications to the Wheelchair class. When she’s finished, it looks like this:</p>
<pre class="source-code">using WheelchairProject.WheelchairComponents.Frames;
using WheelchairProject.WheelchairComponents.Seats;</pre>
<p>Phoebe has added the frame and the seat namespaces so we can specify the two components<a id="_idIndexMarker508"/> that go into the wheelchair. She continues by adding the <code>WheelchairComponents</code> reference right below the namespace.</p>
<pre class="source-code">namespace WheelchairProject;
using WheelchairComponents;</pre>
<p>Next, she adds the <code>WheelchairComponent</code> as the base class:</p>
<pre class="source-code">public abstract class Wheelchair : <strong class="bold">WheelchairComponent</strong>, IManufacturable
{</pre>
<p>Next, she adds the private fields for the seat and frame:</p>
<pre class="source-code"><strong class="bold">    private WheelchairSeat _seat;</strong>
<strong class="bold">    private WheelchairFrame _frame;</strong>
  public string ModelName { get; set; }
  public int Year { get; }
  public string SerialNumber { get; }</pre>
<p>Then she adds the accessor methods just like before with the <code>Axle</code> class:</p>
<pre class="source-code">  public WheelchairSeat Seat
  {
    get =&gt; _seat;
    set
    {
      _seat = value;
      FixComposite();
    }
  }
  public WheelchairFrame Frame
  {
    get =&gt; _frame;
    set
    {
      _frame = value;
      FixComposite();
    }
  }</pre>
<p>Next, Phoebe adds the magical <code>FixComposite()</code> method which clears out<a id="_idIndexMarker509"/> the subcomponent list and adds the _seat and _frame fields. This is called from the accessor methods, so anytime these get changed, the composite is updated. Truthfully, since we’ll be using the Builder pattern to create these objects, there likely won’t be much call for changing the object once it gets created, but its nice to know you can.</p>
<pre class="source-code">  private void FixComposite()
  {
    Subcomponents.Clear();
    Subcomponents.Add(_frame);
    Subcomponents.Add(_seat);
  }
  </pre>
<p>The rest of the class<a id="_idIndexMarker510"/> remains unchanged. Rather than cover every class Phoebe created, I encourage you to review her finished code in the <code>chapter-7</code> project in the book’s sample code. You’ll find most of this in the <code>WheelchairComponents</code> folder.</p>
<h2 id="_idParaDest-142"><a id="_idTextAnchor141"/>Finishing the wheelchair base classes</h2>
<p><em class="italic">“Nice work, Phoebe. All that’s left</em><em class="italic"><a id="_idIndexMarker511"/></em><em class="italic"> is to clean up Kitty’s mess</em>,” Tom chided. Kitty stuck out her tongue. Phoebe giggled and opened the <code>UnpoweredChair</code> class. She now had all the types she needed to model the abstract classes. She updated the class code like so:</p>
<pre class="source-code">using WheelchairComponents;</pre>
<p>Here, the <code>using</code> statement is needed because we moved the <code>component</code> classes into the <code>WheelchairComponents</code> namespace. The next few lines remain unchanged:</p>
<pre class="source-code">public abstract class UnpoweredChair : Wheelchair
{</pre>
<p>Phoebe’s next change<a id="_idIndexMarker512"/> is to set the correct types for the <code>RightWheel</code>, <code>LeftWheel</code>, and <code>CasterAssembly</code> properties:</p>
<pre class="source-code">    <strong class="bold">protected MechanicalWheel RightWheel { get; set; }</strong>
<strong class="bold">    </strong><strong class="bold">protected MechanicalWheel LeftWheel { get; set; }</strong>
<strong class="bold">    protected CasterAssembly Casters { get; set; }</strong></pre>
<h1 id="_idParaDest-143"><a id="_idTextAnchor142"/>Finishing up the composite</h1>
<p><em class="italic">“We should take</em><em class="italic"><a id="_idIndexMarker513"/></em><em class="italic"> a break soon,”</em> Phoebe said. “<em class="italic">We’ve got a lot</em><em class="italic"><a id="_idIndexMarker514"/></em><em class="italic"> done. We’ve got most, if not all, of our</em> <em class="italic">abstract base classes written. Those classes are the most important parts of our patterns. We’ve also almost finished the composite pattern. We just need to add the methods that recursively compute the weight and cost of each component.”</em></p>
<p>“<em class="italic">To do that,”</em> Tom said, “w<em class="italic">e just need to make two small adjustments. Open the WheelchairComponent class.”</em></p>
<p>Phoebe complied. She remembered that Kitty had left the <code>DisplayCost</code> and <code>DisplayWeight</code> methods for later. They presently read as follows:</p>
<pre class="source-code">protected void DisplayWeight()
    {
        throw new NotImplementedException();
    }
    protected void DisplayCost()
    {
        throw new NotImplementedException();
    }</pre>
<p>Phoebe adds<a id="_idIndexMarker515"/> the implementation:</p>
<pre class="source-code">protected void DisplayWeight()
{</pre>
<p>As with the <code>BicycleComponent</code> implementation, first, we<a id="_idIndexMarker516"/> check to see whether there are any subcomponents. If not, we simply return:</p>
<pre class="source-code">    if (!Subcomponents.Any()) return;</pre>
<p>If there are, we print the name and weight:</p>
<pre class="source-code">    foreach (var component in Subcomponents)
    {
        Console.WriteLine(component.GetType().Name + " weighs "        + component.Weight);</pre>
<p>Then, we call the <code>DisplayWeight</code> method recursively:</p>
<pre class="source-code">        component.DisplayWeight();
    }
}</pre>
<p>We do the same thing with <code>Price</code>:</p>
<pre class="source-code">protected void DisplayCost()
{
    if (!Subcomponents.Any()) return;
    foreach (var component in Subcomponents)
    {
        Console.WriteLine(component.GetType().Name + " costs $"         + component.Price + " USD");
        component.DisplayCost();
    }
}</pre>
<p>Phoebe slumped in her chair. “<em class="italic">Phew! That</em><em class="italic"><a id="_idIndexMarker517"/></em><em class="italic"> was a lot of work,</em>” said Phoebe. “<em class="italic">I know. We have</em><em class="italic"><a id="_idIndexMarker518"/></em><em class="italic"> the structure for the Composite pattern, but we still need a builder to populate it</em>,” said Tom. “<em class="italic">Yeah,</em>” said Kitty. “<em class="italic">This structure is complicated. We can’t just make a Wheelchair object and add the chair, the frame, and some wheels like we can with simple composition. We need a way to assemble the hierarchy we drew on the board earlier (Figure 7.5).</em> The three took a break and rested up. They knew the next pattern they needed to make was the Builder pattern.</p>
<h1 id="_idParaDest-144"><a id="_idTextAnchor143"/>Implementing the Builder pattern</h1>
<p>Kitty had called<a id="_idIndexMarker519"/> Karina, their mother, and asked her to stop by, in order to give her a break from the non-stop hospital vigil. Phoebe shared some pizza and the four played a little Mario Kart on the Nintendo Switch to get their minds off their problems. After a few races, Tom, Kitty, and Phoebe were ready to get back to work.  Karina returned to the hospital</p>
<p>“<em class="italic">This is going to be the hard part</em>,” Tom said. “<em class="italic">The Builder pattern implementation is going to be doing a lot of work. It needs to assemble the wheelchair object, assemble the composite, and ultimately handle the wheelchair’s paint job with the Bridge pattern.”</em></p>
<p>“We should review <a id="_idIndexMarker520"/>our diagram,” said Kitty. It was her turn to type. She brought up the diagram they had drawn of the builder pattern. You can review it in <em class="italic">Figure 7.7</em>:</p>
<div><div><img alt="Figure 7.7: The Builder pattern design with everything on it, including the Composite and Bridge pattern elements. " height="747" src="img/figure-7-7.jpg" width="1650"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.7: The Builder pattern design with everything on it, including the Composite and Bridge pattern elements.</p>
<p><em class="italic">“I think I’ll make a folder to hold all the builder classes and interfaces. It seems like there are going to be a few of them,”</em> Kitty said. “<em class="italic">Good idea,”</em> said Tom. Kitty created a folder called <code>Builders</code>. Next, Kitty added the <code>IWheelchairBuilder</code> interface to the <code>Builders</code> folder:</p>
<pre class="source-code">namespace WheelchairProject.Builders;</pre>
<p>Kitty implemented the code specified in the UML design:</p>
<pre class="source-code">public interface IWheelchairBuilder
{
    public void Reset();
    public void BuildFrame();
    public void BuildWheels();
    public void BuildSeat();
    public Wheelchair GetProduct();
}</pre>
<p>Aside from the interface, the Builder pattern<a id="_idIndexMarker521"/> needs a <code>director</code> class. That is, it needs an abstract builder that implements the interface, and one or more concrete <code>builder</code> subclasses to build the concrete products. You can see each of these in <em class="italic">Figure 7.4</em>.</p>
<p>Kitty adds the director class next. She decides to call it <code>WheelchairBuilderDirector</code>:</p>
<pre class="source-code">namespace WheelchairProject.Builders;
public class WheelchairBuilderDirector
{</pre>
<p>The director holds a private instance of any class implementing <code>IWheelchairBuilder</code>:</p>
<pre class="source-code">    private IWheelchairBuilder _builder;</pre>
<p>Kitty adds a constructor that specifies the builder she wants to use on instantiation:</p>
<pre class="source-code">    public WheelchairBuilderDirector(IWheelchairBuilder     builder)
    {
        _builder = builder;
    }</pre>
<p>The <code>Build</code> method specified in the diagram is designed to call the various methods on the <code>builder</code> class specified in <code>IWheelchairBuilder</code>. Remember, the director’s job is to call these in order. The complex logic behind building the object is controlled here in the director class:</p>
<pre class="source-code">    public Wheelchair Build()
    {
       _builder.BuildSeat();
       _builder.BuildFrame();
       _builder.BuildAxleAssembly();
       _builder.BuildCasterAssembly();</pre>
<p>Finally, the director returns<a id="_idIndexMarker522"/> the built object using the <code>GetProduct</code> method:</p>
<pre class="source-code">        return _builder.GetProduct();
    }
}</pre>
<p><em class="italic">“So far, so good!”</em> said Tom. “<em class="italic">Let’s make a concrete builder for the Plano Wheelchair</em>.”</p>
<p>Kitty added a class called <code>PlanoWheelchairBuilder</code>. It looked like this:</p>
<pre class="source-code">namespace WheelchairProject.Builders;
public class PlanoWheelchairBuilder : IWheelchairBuilder
{</pre>
<p>The pattern requires us to have a <code>private</code> field to hold the <code>Wheelchair</code> object as it is built:</p>
<pre class="source-code">    private PlanoWheelchair _wheelchair;</pre>
<p>The pattern also requires a <code>Reset</code> method, which essentially<a id="_idIndexMarker523"/> re-initializes the <code>_wheelchair</code> field. In order to keep the class <code>Reset</code> method, then call it from the constructor, which you also need. Kitty prefers to make sure the constructor is always the first method in the class, so it comes first:</p>
<pre class="source-code">    Public PlanoWheelchairBuilder()
    {
        Reset();
    }</pre>
<p> Then, she adds the <code>Reset</code> method: </p>
<pre class="source-code">    public void Reset()
    {
        _wheelchair = new PlanoWheelchair();
        
    }</pre>
<p>Since this class implements the <code>IWheelchairBuilder</code> interface, we need the remainder of the required<a id="_idIndexMarker524"/> methods. Most IDEs will generate this for you. Kitty is using Rider, so she clicks her cursor into the class name line near the top of the class. It has some angry-looking red squiggly lines beneath it because she hasn’t implemented the methods required by the interface. She presses <em class="italic">Ctrl</em> + <em class="italic">.</em> (control-period) and she sees the option to generate the missing members with placeholder code. You can see what this looks like in <em class="italic">Figure 7.8</em>:</p>
<div><div><img alt="Figure 7.8: Rider, like most IDEs, will autogenerate placeholder code for any missing members required by the interface. " height="869" src="img/B18605_Figure_7.8.jpg" width="1416"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7.8: Rider, like most IDEs, will autogenerate placeholder code for any missing members required by the interface.</p>
<p>The code generated<a id="_idIndexMarker525"/> looks like this:</p>
<pre class="source-code">    public void BuildFrame()
    {
       throw new NotImplementedException();
    }
    public void BuildWheels()
    {
        throw new NotImplementedException();
    }
public void BuildAxleAssembly()
    {
        throw new NotImplementedException();
    }
    public void BuildCasterAssembly()
    {
        throw new NotImplementedException();
    }
    public void BuildSeat()
    {
        
        throw new NotImplementedException();
    }
    public void BuildComposite()
    {
        throw new NotImplementedException();
    }
    public void BuildFramePainter()
    {
        throw new NotImplementedException();
    }
    public Wheelchair GetProduct()
    {
        return _wheelchair;
    }
}</pre>
<p>This code is long<a id="_idIndexMarker526"/> and uneventful, but it saves a lot of typing! Kitty just needs to fill in the implementation for each method. She can’t really do that yet. She needs concrete implementations of the various abstract wheelchair component classes, and those have yet to be created.</p>
<h2 id="_idParaDest-145"><a id="_idTextAnchor144"/>Another refactor</h2>
<p><em class="italic">“That’s a whole lot </em><em class="italic"><a id="_idIndexMarker527"/></em><em class="italic">of placeholder code,”</em> Tom said. <em class="italic">“Maybe it’s time to add some concrete classes for the wheelchair components so we build a real wheelchair?”</em></p>
<p><em class="italic">“OK,”</em> Kitty agreed. She started to think about structuring the concrete classes. There is going to be at least one concrete component for each of the abstract component classes. Assuming the wheelchair project is wildly successful, the list of concrete implementations is likely to grow, making the <code>WheelchairComponents</code> folder very crowded.</p>
<p><em class="italic">“Tom, why don’t we split up the WheelchairComponents folder a little more? As we add concrete classes, I think it will be easier to find everything if we do it that way</em>,” Kitty said. <em class="italic">“Good idea,</em>” Tom replied.</p>
<p>Kitty added a series of folders beneath the <code>WheelchairComponents</code> folder:</p>
<ul>
<li><code>Axles</code></li>
<li><code>Casters</code></li>
<li><code>Frames</code></li>
<li><code>Seats</code></li>
<li><code>Wheels</code></li>
</ul>
<p>Next, she moved the abstract classes for each component into their respective folder. In each case, she corrected the namespace for the class she moved.</p>
<p>The <code>Axle</code> class goes in the <code>Axles</code> folder. The namespace code should be adjusted to this:</p>
<pre class="source-code">namespace WheelchairProject.WheelchairComponents.Axles;</pre>
<p>The <code>Caster Assembly</code> class goes in the <code>Casters</code> folder. The namespace code should be adjusted to this:</p>
<pre class="source-code">namespace WheelchairProject.WheelchairComponents.Casters;</pre>
<p>The <code>WheelchairFrame</code> class goes in the <code>Frames</code> folder. The namespace code should be adjusted to this:</p>
<pre class="source-code">namespace WheelchairProject.WheelchairComponents.Frames;</pre>
<p>The <code>WheelchairSeat</code> class goes in the <code>Seats</code> folder. The namespace code should be adjusted to this:</p>
<pre class="source-code">namespace WheelchairProject.WheelchairComponents.Seats;</pre>
<p>Finally, the <code>MechanicalWheel</code> class is moved to the <code>Wheels</code> folder and its namespace is adjusted like so:</p>
<pre class="source-code">namespace WheelchairProject.WheelchairComponents.Wheels;</pre>
<p>When this<a id="_idIndexMarker528"/> refactor is over, the code’s folder structure looks like <em class="italic">Figure 7.6</em>.</p>
<h2 id="_idParaDest-146"><a id="_idTextAnchor145"/>Adding concrete component classes</h2>
<p>Kitty’s next job<a id="_idIndexMarker529"/> is going to be adding component<a id="_idIndexMarker530"/> classes for each component type. We’ve established a base class and structure for each component. Next, we simply need to add the concrete classes that extend the base classes.</p>
<h3>Axles</h3>
<p>She starts in the <code>Axles</code> folder by adding<a id="_idIndexMarker531"/> a class called <code>StandardAxle</code>. The parts for the <em class="italic">Plano Wheelchair</em> are mechanically<a id="_idIndexMarker532"/> simple and common. Phoebe has provided a <strong class="bold">bill of materials</strong> (<strong class="bold">BOM</strong>) listing the components, along with the data required by the Composite pattern implementation. In the world of manufacturing, this is a list of parts normally exported to an Excel spreadsheet. Kitty and Tom can simply reference the spreadsheet to get the values needed in the concrete classes.</p>
<p>The <code>StandardAxle</code> class looks like this:</p>
<pre class="source-code">using WheelchairProject.WheelchairComponents.Wheels;
namespace WheelchairProject.WheelchairComponents.Axles;
public class StandardAxle : Axle
{
    public StandardAxle(MechanicalWheel leftWheel, 
    MechanicalWheel rightWheel)
    {
        Price = 4.33f;
        Weight = 0.335f;
        Radius = 0.24f;
        Length = 28.5f;
        LeftWheel = leftWheel;
        RightWheel = rightWheel;
    }
}</pre>
<h3>Casters</h3>
<p>Next, Kitty adds a concrete class<a id="_idIndexMarker533"/> for the caster assembly to be used on the <em class="italic">Plano Wheelchair</em>. Unsurprisingly, she calls it <code>PlanoCasterAssembly</code>. Its contents are as follows:</p>
<pre class="source-code">using WheelchairProject.WheelchairComponents.Wheels;
namespace WheelchairProject.WheelchairComponents.Casters;
public class PlanoCasterAssembly : CasterAssembly
{
    public PlanoCasterAssembly(MechanicalWheel wheel)
    {
        LoadCapacity = 300.0f;
        MountingType = "STEM";
        Weight = 0.443f;
        Price = 4.32f;
        Wheel = wheel;
    }   
}</pre>
<h3>Frames</h3>
<p>It’s time to add a concrete class<a id="_idIndexMarker534"/> for the <em class="italic">Plano Wheelchair’s</em> frame. It’s called <code>PlanoWheelchairFrame</code>:</p>
<pre class="source-code">namespace WheelchairProject.WheelchairComponents.Frames;
public class PlanoWheelchairFrame : WheelchairFrame
{
    public PlanoWheelchairFrame()
    {
        Price = 75.92f;
        Weight = 16.34f;
    }
}</pre>
<h3>Seats</h3>
<p>A wheelchair wouldn’t be very useful without a place<a id="_idIndexMarker535"/> to sit. Kitty adds a class she calls <code>PlanoSeat</code>:</p>
<pre class="source-code">namespace WheelchairProject.WheelchairComponents.Seats;
public class PlanoSeat : WheelchairSeat
{
    public PlanoSeat()
    {
        Price = 27.48f;
        Weight = 3.22f;
        Width = 22;
        BackHeight = 30;
        SeatThickness = 2.4f;
    }
}</pre>
<h3>Wheels</h3>
<p>Equally important to the construction<a id="_idIndexMarker536"/> of a wheelchair, beyond the seat, are the wheels. There are two of these. The large wheels on the side of the wheelchair are specified by a class called <code>StandardWheel</code>:</p>
<pre class="source-code">namespace WheelchairProject.WheelchairComponents.Wheels;
public class StandardWheel : MechanicalWheel
{
    public StandardWheel()
    {
        Price = 11.34f;
        Weight = 1.3f;
        Radius = 16f;
        IsPneumatic = true;
        SpokeCount = 48;
    }
}</pre>
<p>The second type of wheel<a id="_idIndexMarker537"/> we need is the smaller set that attaches to the swiveling casters on the front of the chair. Kitty called these <code>CasterWheel</code>:</p>
<pre class="source-code">namespace WheelchairProject.WheelchairComponents.Wheels;
public class CasterWheel : MechanicalWheel
{
    public CasterWheel()
    {
        Price = 5.21f;
        Weight = 0.753f;
        Radius = 6f;
        IsPneumatic = true;
        SpokeCount = 24;
    }
}</pre>
<p>Now, Kitty’s folder structure resembles <em class="italic">Figure 7.9</em>:</p>
<div><div><img alt="Figure 7 .9: The WheelchairComponents folder after Kitty added all the concrete classes. " height="774" src="img/B18605_Figure_7.9.jpg" width="613"/>
</div>
</div>
<p class="IMG---Caption" lang="en-US" xml:lang="en-US">Figure 7 .9: The WheelchairComponents folder after Kitty added all the concrete classes.</p>
<p>Now that all the concrete classes<a id="_idIndexMarker538"/> for the <em class="italic">Plano Wheelchair</em> are in place, we can set up the Builder pattern code to build a full <code>Wheelchair</code> object.</p>
<h2 id="_idParaDest-147"><a id="_idTextAnchor146"/>Wrapping up the Builder pattern</h2>
<p>At this point, Kitty needs to finish the <code>PlanoWheelchairBuilder</code> class. If you recall, this was the class<a id="_idIndexMarker539"/> where she generated all that placeholder code earlier. She needs to replace the placeholder code with code using her new concrete classes.</p>
<p>Kitty starts with the frame because the frame is the foundation for all the other parts of the wheelchair. She changes the code in the <code>BuildFrame</code> method generated by the IDE:</p>
<pre class="source-code">public void BuildFrame()
{
    wheelchair.Frame = new PlanoWheelchairFrame();
}</pre>
<p>There’s not much to the <code>BuildFrame</code> method. All it does is instantiate <code>PlanoWheelchairFrame</code> and set the <code>_wheelchair</code> frame property.</p>
<p>Next, Kitty replaced<a id="_idIndexMarker540"/> the <code>BuildAxleAssembly</code> method. An <code>Axle</code> object, such as the <code>StandardAxle</code> class, per the Composite pattern, is a container. The team specified this in <em class="italic">Figure 7.5</em>. The <code>Axle</code> contains the left and right wheels, which are the <code>StandardWheel</code> type. As such, the code looks like this:</p>
<pre class="source-code">public void BuildAxleAssembly()
{
    var leftWheel = new StandardWheel();
    var rightWheel = new StandardWheel();
    var axle = new StandardAxle(leftWheel, rightWheel);
    _wheelchair.Frame.Axle = axle;
}</pre>
<p>Here, we’ve instantiated two <code>StandardWheel</code> objects and set them into <code>Axle</code> using the <code>StandardAxle</code> constructor. Lastly, we set the <code>_wheelchair</code>’s <code>Axle</code>, which is a property of the <code>Frame</code> property. This mirrors real life because an axle would be attached to the wheelchair’s frame, and the wheels, in turn, would be affixed to the axle.</p>
<p>In her mind’s eye, all Kitty sees is a wheelchair with two wheels awkwardly rocking back and forth. With the main wheels attached, Kitty decides to do the casters next. She alters the <code>BuildCasterAssembly</code> method like this:</p>
<pre class="source-code">public void BuildCasterAssembly()
{
    var planoCasterWheel = new CasterWheel();
    var casterAssembly = new     PlanoCasterAssembly(planoCasterWheel);
    _wheelchair.Frame.LeftCaster = casterAssembly;
    _wheelchair.Frame.RightCaster = casterAssembly;
}</pre>
<p><code>PlanoCasterAssembly</code> consists of <code>CasterWheel</code>, which is passed into the <code>PlanoCasterAssembly</code> constructor. The assembly<a id="_idIndexMarker541"/> is then mounted to the frame on the left and right sides. As I review Kitty’s code, I can’t tell whether she’s cutting a corner here or not. She used the same instance of <code>PlanoCasterAssembly</code> on both sides. I’m sure it’s probably right. If it isn’t, I’m sure Phoebe would have let her know.</p>
<p>We have four wheels and a frame. We’re missing a seat. Kitty updates the <code>BuildSeat</code> method:</p>
<pre class="source-code">public void BuildSeat()
{
    _wheelchair.Seat = new PlanoSeat();    
}</pre>
<p>Like the frame, this one is straightforward. Just instantiate the <code>PlanoSeat</code> object and attach it to the frame. Kitty needs one more easy change. <code>GetProduct</code> should not return an instantiation of <code>PlanoWheelchair</code>. Instead, it should return the one we’ve built:</p>
<pre class="source-code">public Wheelchair GetProduct()
{
    return _wheelchair;
}</pre>
<p>“<em class="italic">Wow, that’s really neat!”</em> Phoebe said. Phoebe had been wandering in and out of the lab, but all of a sudden, showed a renewed interest. <em class="italic">“I see what you mean by hiding the Composite pattern complexity inside the builder. Anyone working with the object can use normal composition, but we also get the benefit of the recursive price and weight functions,”</em> Phoebe said.</p>
<p>“<em class="italic">Are we still going to make it a singleton?”</em> Tom asked.</p>
<p><em class="italic">“I think we should</em><em class="italic"><a id="_idIndexMarker542"/></em><em class="italic"> try,”</em> Kitty said. “<em class="italic">It would be interesting to write some tests to see whether we gain any benefit from making this a singleton. But for now, let’s go ahead and turn the builder into a singleton</em>.”</p>
<h1 id="_idParaDest-148"><a id="_idTextAnchor147"/>Adding the Singleton pattern</h1>
<p>“<em class="italic">Tag! I’m in!”</em> Phoebe<a id="_idIndexMarker543"/> exclaimed, as she nudged Kitty out of the typing chair and sat down at the keyboard. Phoebe made a show of cracking her knuckles and popping her neck. They were in the home stretch and Phoebe knew it.</p>
<p>“<em class="italic">The Singleton is pretty easy</em>,” Tom said. <em class="italic">“I remember</em> it,” said Phoebe. She continued, <em class="italic">“It seems like all I need to do is change the director class in the Builder pattern.</em>” Phoebe located the director class in the <code>Builders</code> folder and opened it in her IDE:</p>
<pre class="source-code">public class WheelchairBuilderDirector
{
    private IWheelchairBuilder _builder;</pre>
<p>Phoebe adds this line to create a field to hold the current instance. She makes it nullable because if the field is <code>null</code>, we need to create a new instance of this class and place it in the <code>_instance</code> field. The field is marked <code>static</code> to ensure it is unique in memory:</p>
<pre class="source-code">    private static WheelchairBuilderDirector? _instance;</pre>
<p>Next, Phoebe changes the constructor’s accessor to <code>private</code>. It should not be possible to instantiate the director directly. To use the class, you have to use the hallmark <code>GetInstance</code> method, which she’ll write next:</p>
<pre class="source-code">    private WheelchairBuilderDirector(IWheelchairBuilder     builder)
    {
        _builder = builder;
    }</pre>
<p>The last step to converting the builder’s director<a id="_idIndexMarker544"/> class is to add a public static method called <code>GetInstance</code>. We still need the <code>IWheelchairBuilder</code> parameter to be passed in just as we did on the original constructor. This method checks to see whether the <code>_instance</code> field is null. If it is, then this method will invoke the private constructor and set the <code>_instance</code> field to the result. If the <code>_instance</code> field is not null, the <code>GetInstance</code> method will simply return the instance it already has:</p>
<pre class="source-code">    public static WheelchairBuilderDirector? GetInstance(IWheelchairBuilder builder)
    {
        if (_instance == null)
        {
            _instance = new WheelchairBuilderDirector(builder);
        }
        return _instance;
    }</pre>
<p>The rest of the class remains unchanged.</p>
<p>“<em class="italic">That wasn’t so tough,”</em> Phoebe said. “<em class="italic">I can imagine this object being expensive in terms of memory once the factories are producing wheelchairs as well as bicycles,”</em> Tom said. “<em class="italic">I’m on the fence</em>,” Phoebe replied. “<em class="italic">I’m not totally sure we need this, but I don’t think it will hurt anything. There’s just one thing left, and it’s my favorite!</em>” said Kitty, watching from behind Phoebe’s chair. “<em class="italic">You’re proud</em><em class="italic"><a id="_idIndexMarker545"/></em><em class="italic"> of your paint system, aren’t you Sis?”</em> asked Phoebe. Kitty just grinned and sat down behind her sister.</p>
<h1 id="_idParaDest-149"><a id="_idTextAnchor148"/>Painting the chairs with the Bridge pattern</h1>
<p>The last pattern we need to complete<a id="_idIndexMarker546"/> our wheelchair project is the Bridge<a id="_idIndexMarker547"/> pattern. Remember, the Bridge pattern is used when you have two related systems of complex classes. The bridge allows you to join the classes using composition. It gives you the benefit of being able to vary the complexity and maintain these complicated classes independently. Kitty and Phoebe used this system to add the ability to create custom paint jobs for their bicycles. They did this late in the game though, and the changes they had to make to accommodate those changes were problematic. They had to violate the open-closed principle.</p>
<p>This time, with experience behind them, they can integrate the Bridge pattern for painting wheelchairs early in the implementation. The ability to specify colors for wheelchairs will be a big differentiator for Bumble Bikes since most manufacturers only sell black and gray chairs. This is fine for the loaner chair at your local hospital, but for people who use wheelchairs every day to get around in life, it’s nice to have a little fashion in the mix.</p>
<p>Kitty created the paint system for the bicycles to work in a similar fashion as an inkjet printer works. She devised a system that could mix any color using cyan, magenta, yellow, and<a id="_idIndexMarker548"/> black paint. This is called the <strong class="bold">CMYK</strong> color model, and it’s a standard in the printing industry.</p>
<p>Tom, who works with disabled children at a local pediatric hospital, had taken an informal survey on what the most popular colors might be for a wheelchair. Then he asked the kids to pick just one color for the initial product release. After some animated discussion, the kids decided on a shade of green. There was a woman who worked with the kids, named Judy. Everyone loved her, and she had sparkling green eyes. They decided to honor her by naming the color <em class="italic">Green Eyed Judy</em>.</p>
<p>Phoebe got to work on implementing the Bridge pattern. In real life, it might be possible to reuse the bridge interfaces and classes from the bicycle package. The only downside is that you’d create a dependency between two products that don’t necessarily have anything to do with each other besides being two products made by the same company. For the purposes of this book, we’re just going to make a new set of classes in order to keep the wheelchair project self-contained.</p>
<p>Phoebe starts by creating a new directory called <code>Painters</code>. Next, she adds an interface called <code>IFramePainter</code>. This is the key to the Bridge pattern. This interface defines a complex system of classes that specify a color painting system. This is one side of the bridge.</p>
<p>On the other side<a id="_idIndexMarker549"/> of the bridge is the wheelchair class. We can<a id="_idIndexMarker550"/> freely expand and modify either side of the bridge without affecting the other side.</p>
<p>The <code>IFramePainter</code> interface looks like this:</p>
<pre class="source-code">namespace WheelchairProject.Painters;
public interface IFramePainter
{</pre>
<p>The interface requires five properties. <code>PaintColorName</code> allows you to give a name to the color combination. The remaining four are the values for <code>Cyan</code>, <code>Magenta</code>, <code>Yellow</code>, and <code>Black</code>:</p>
<pre class="source-code">    public string PaintColorName { get; set; }
    public int Cyan { get; set; }
    public int Magenta { get; set; }
    public int Yellow { get; set; }
    public int Black { get; set; }</pre>
<p>Next, Phoebe adds the requirements for two methods. This is for the benefit of the robotic machinery that will assemble and paint the wheelchair. The system needs to first mix the paint color, then apply it:</p>
<pre class="source-code">    public void MixPaint();
    public void PaintFrame();
}</pre>
<p>The next thing we need is a concrete class to implement the interface. Phoebe remains focused on the <em class="italic">Plano Wheelchair</em>, and so makes a class called <code>PlanoWheelchairPainter</code>:</p>
<pre class="source-code">namespace WheelchairProject.Painters;
public class PlanoWheelchairPainter : IFramePainter
{</pre>
<p>Phoebe leaves<a id="_idIndexMarker551"/> the five properties mentioned earlier<a id="_idIndexMarker552"/> as auto-properties:</p>
<pre class="source-code">    public string PaintColorName { get; set; }
    public int Cyan { get; set; }
    public int Magenta { get; set; }
    public int Yellow { get; set; }
    public int Black { get; set; }</pre>
<p>The <code>MixPaint</code> method is complicated and highly proprietary. Kitty and Phoebe’s lawyer won’t let me show you the real code. So, we’ll have to settle for some placeholder code:</p>
<pre class="source-code">    public void MixPaint()
    {
        Console.WriteLine("Mixing in Cyan: "         + Cyan.ToString() );
        Console.WriteLine("Mixing in Magenta: " + Magenta.                         ToString() );
        Console.WriteLine("Mixing in Yellow: " + Yellow.        ToString() );
        Console.WriteLine("Mixing in Black: " + Black.        ToString() );
        Console.WriteLine("Mixing complete!  The color is: " +         PaintColorName);
    }</pre>
<p>Likewise, the <code>PaintFrame</code> method refers to some proprietary robotics APIs, so once again, we’ll keep it simple by way of an example:</p>
<pre class="source-code">    public void PaintFrame()
    {
        Console.WriteLine("Applying " + PaintColorName);
    }
}</pre>
<p>The next change<a id="_idIndexMarker553"/> we need to make is to add the interface through<a id="_idIndexMarker554"/> composition to the <code>Wheelchair</code> class. Phoebe opens the <code>Wheelchair</code> class and adds a property:</p>
<pre class="source-code">public abstract class Wheelchair : WheelchairComponent, IManufacturable
{
    public IFramePainter FramePainter { get; set; }</pre>
<p>There’s just one thing left to do. We need to add the bridge implementation to the builder so that when the builder builds a wheelchair, it gets painted in the same process. The builder really ties everything together!</p>
<p>The first change will be to the <code>IWheelchairBuilder</code> interface. Phoebe just adds one new method definition:</p>
<pre class="source-code">public interface IWheelchairBuilder
{
    public void Reset();
    public void BuildFrame();
    public void BuildAxleAssembly();
    public void BuildCasterAssembly();
    public void BuildSeat();</pre>
<p>She adds the definition here:</p>
<pre class="source-code">    public void BuildFramePainter();</pre>
<p>The rest of the code hasn’t changed:</p>
<pre class="source-code">    public Wheelchair GetProduct();
}</pre>
<p>The interface updates, and suddenly Phoebe<a id="_idIndexMarker555"/> sees some red squiggly lines indicating<a id="_idIndexMarker556"/> a problem. Since she changed the interface, the <code>PlanoWheelchairBuilder</code> class is wrong because it doesn’t have the new method. Phoebe opens up the <code>PlanoWheelchairBuilder</code> class and adds the missing method:</p>
<pre class="source-code">    public void BuildFramePainter()
    {</pre>
<p>Phoebe instantiates a concrete <code>PlanoWheelchairPainter</code> class and sets it up with the new wheelchair paint color:</p>
<pre class="source-code">        var painter = new PlanoWheelchairPainter
        {
            PaintColorName = "Green-Eyed Judy",
            Cyan = 79,
            Magenta = 22,
            Yellow = 100,
            Black = 8
        };</pre>
<p>Next, she sets the property on the <code>_wheelchair</code> instance inside the builder. After that, she calls the methods to mix the paint color and paint the frame:</p>
<pre class="source-code">        _wheelchair.FramePainter = painter;
        _wheelchair.FramePainter.MixPaint();
        _wheelchair.FramePainter.PaintFrame();
    }</pre>
<p>SLAP!</p>
<p>A loud sound echoed through the lab as Kitty and Phoebe high-fived each other. Tom let out a good old-fashioned Texan “<em class="italic">Yee haw!”</em></p>
<p>Over the next week, the team<a id="_idIndexMarker557"/> would test, debug, and refactor<a id="_idIndexMarker558"/> the code. If everything went to plan, Bumble Bikes could be shipping their high-quality, low-cost wheelchairs to rehabilitation centers and pediatric hospitals all over the world.</p>
<h1 id="_idParaDest-150"><a id="_idTextAnchor149"/>Summary</h1>
<p>Kitty, Phoebe, and Tom were delighted at their progress. There is no doubt they would continue to refine their software over the coming weeks to make the system product-ready. They managed to get a lot done in a short time because they planned their software by designing first and implementing second.</p>
<p>You might have noticed a huge gap between the project proposed and what was delivered. We only worked on the <em class="italic">Plano Wheelchair</em> because the team decided this chair represented the minimum viable product. Neither the <em class="italic">Maverick</em> nor the flagship product, the <em class="italic">Texas Tank</em>, were built in this chapter. I left this as a challenge for you. Practice what you’ve learned and try implementing the <em class="italic">Maverick</em> and powered chair diagrams on your own. </p>
<p>We also saw a lot of interplay between patterns. The Builder was leveraged in conjunction with the Bridge, Singleton, and Composite patterns. This resulted in all the complexity being handled in one place. When these patterns were introduced, they were presented one at a time. Now we see them fitting together like interlocking pieces of a puzzle.</p>
<h1 id="_idParaDest-151"><a id="_idTextAnchor150"/>Questions</h1>
<ol>
<li>What was the point of making the Builder pattern’s director class a Singleton? Do you agree with the design decision? Why, or why not?</li>
<li>What is the advantage of embedding the composite structure into the normal object graph of the wheelchair versus making a separate object graph as we did in <a href="B18605_04.xhtml#_idTextAnchor078"><em class="italic">Chapter 4</em></a><em class="italic"> </em> with the bicycle project?</li>
<li>What is the process in your favorite IDE for generating missing members for an interface?</li>
</ol>
<h1 id="_idParaDest-152"><a id="_idTextAnchor151"/>Further reading</h1>
<p><em class="italic">Practical Remote Pair Programming</em> by Adrian Bolboacă: <a href="https://www.packtpub.com/product/practical-remote-pair-programming/9781800561366">https://www.packtpub.com/product/practical-remote-pair-programming/9781800561366</a></p>
<p>Be sure to check out this book’s companion website at <a href="https://csharppatterns.dev">https://csharppatterns.dev</a>.</p>
</div>
</div>
</body></html>