<html><head></head><body><div><div><div><div><h1 class="title"><a id="ch10"/>Chapter 10. Parallel LINQ – PLINQ</h1></div></div></div><p>In this chapter, we will learn about declarative data <a id="id570" class="indexterm"/>parallelism using <strong>Parallel Language Integrated Query</strong> (<strong>PLINQ</strong>). In <a class="link" href="ch07.html" title="Chapter 7. Data Parallelism">Chapter 7</a>, <em>Data Parallelism</em>, we discussed data parallelism using the <code class="literal">Parallel</code> library and the <code class="literal">Parallel.For</code> and <code class="literal">Parallel.ForEach</code> loops. PLINQ is a parallel version of LINQ to Objects. <strong>LINQ to Objects</strong><a id="id571" class="indexterm"/> allows for LINQ queries on in-memory data collections such as <code class="literal">List</code> and <code class="literal">DataTable</code> that implement the <code class="literal">IEnumerable</code> or <code class="literal">IEnumerable&lt;T&gt;</code> interface. Unlike a sequential LINQ, PLINQ tries to use all of the processors in the computer it is running on by dividing the data collections into segments and creating a task to process each segment of the data collection. PLINQ and the <strong>Common Language Runtime</strong> (<strong>CLR</strong>)<a id="id572" class="indexterm"/> are smart enough to evaluate the query and determine if it will benefit from a multithreaded execution. If not, then it will run sequentially like a normal LINQ. It is the best of both worlds. .NET figures out whether it can gain performance improvements by operating concurrently or not and makes the decision for you.</p><p>The parallel extension methods were added to the <code class="literal">System.Linq</code> namespace in .NET 4.5. It includes extension methods for all standard LINQ operators as well as some extra ones for parallel operators. Almost all of the PLINQ methods are implemented in the <code class="literal">System.Linq.ParallelEnumerable</code> namespace.</p><p>The topics that will be covered in this chapter are as follows:</p><div><ul class="itemizedlist"><li class="listitem" style="list-style-type: disc">Executing a PLINQ</li><li class="listitem" style="list-style-type: disc">Ordering in PLINQ</li><li class="listitem" style="list-style-type: disc">Merging in PLINQ</li><li class="listitem" style="list-style-type: disc">Canceling a PLINQ</li><li class="listitem" style="list-style-type: disc">Understanding performance improvements in PLINQ</li></ul></div><div><div><div><div><h1 class="title"><a id="ch10lvl1sec71"/>Executing a PLINQ</h1></div></div></div><p>Now, let's take a look at a<a id="id573" class="indexterm"/> basic PLINQ and syntax. We will use three different methods to perform the PLINQ and then examine the results. The first will use the <code class="literal">ForAll</code> method of the <code class="literal">ParallelQuery</code> class. The next one will use the <code class="literal">AsParallel</code> method of the LINQ library on the <code class="literal">Enumerable</code> collection. The final way will use the standard LINQ method syntax.</p><p>We will then display the results of the three queries in three listboxes and also display the time it took to execute each query.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec87"/>How to do it</h2></div></div></div><p>Let's start by opening up Visual Studio and creating a new WPF application project named <code class="literal">WpfPLINQQuery</code>. Once this project is open, let's perform the following steps:</p><div><ol class="orderedlist arabic"><li class="listitem">In the <code class="literal">MainWindow.xaml</code> file in design mode add three button controls and name them <code class="literal">btnMethod1</code>, <code class="literal">btnMethod2</code>, and <code class="literal">btnMethod3</code>. Set the <code class="literal">Content</code> property of each to <code class="literal">Execute Method 1</code>, <code class="literal">Execute Method 2</code>, and <code class="literal">Execute Method 3,</code> respectively. Next, create a click event handler for each in the <code class="literal">MainWindow.xaml.cs</code> file and name these three methods <code class="literal">btnMethod1_Click</code>, <code class="literal">btnMethod2_Click</code>, and <code class="literal">btnMethod3_Click,</code> respectively.</li><li class="listitem">In the <code class="literal">btnMethod1_Click</code> event handler method, place the following code:<div><pre class="programlisting">private void btnMethod1_Click(object sender, RoutedEventArgs e)
        {
            IEnumerable&lt;int&gt; collection1 = Enumerable.Range(10, 500000);

            //Start the timer.
            Stopwatch sw1 = new Stopwatch();
            sw1.Start();

     //Method 1 - This uses a ForAll method and an empty 
     //delegate method.
            ParallelQuery&lt;int&gt; PQ1 = from num in collection1.AsParallel()
                      where num % 5 == 0
                      select num;

            PQ1.ForAll((i) =&gt; DoWork(i));

    // Use a standard foreach loop and merge the results.
            foreach (int i in PQ1)
            {
                lb1.Items.Add(i);
            }

            //Stop the timer.
            sw1.Stop();

            tbTime1.Text = sw1.ElapsedMilliseconds.ToString();

        }</pre></div></li><li class="listitem">In the <code class="literal">btnMethod2_Click</code> event handler <a id="id574" class="indexterm"/>method, place the following code:<div><pre class="programlisting">private void btnMethod2_Click(object sender, RoutedEventArgs e)
        {
            IEnumerable&lt;int&gt; collection2 = Enumerable.Range(10, 500000);

            //Start the timer.
            Stopwatch sw2 = new Stopwatch();
            sw2.Start();

            // Method 2 - Use a standard ToArray method to return //the results.
            int[] PQ2 = (from num in collection2.AsParallel()
                       where num % 10 == 0
                       select num).ToArray();

            // Use a standard foreach loop and merge the results.
            foreach (int i in PQ2)
            {
                lb2.Items.Add(i);
            }

            //Stop the timer.
            sw2.Stop();

            tbTime2.Text = sw2.ElapsedMilliseconds.ToString();
     }</pre></div></li><li class="listitem">In the <code class="literal">btnMethod3_Click</code> event handler method, place the following code. Also, let's add three listboxes and name them <code class="literal">lb1</code>, <code class="literal">lb2</code>, and <code class="literal">lb3</code>.<div><pre class="programlisting">private void btnMethod3_Click(object sender, RoutedEventArgs e)
        {
            IEnumerable&lt;int&gt; collection3 = Enumerable.Range(10, 10000);

            //Start the timer.
            Stopwatch sw3 = new Stopwatch();
            sw3.Start();

            // Method 3 - Use the LINQ standard method format.
            ParallelQuery&lt;int&gt; PQ3 = collection3.AsParallel().Where(n =&gt; n % 10 == 0).Select(n =&gt; n);

            // Use a standard foreach loop and merge the results.
            foreach (int i in PQ3)
            {
                lb3.Items.Add(i);
            }


            //Stop the timer.
            sw3.Stop();

            tbTime3.Text = sw3.ElapsedMilliseconds.ToString();

        }</pre></div></li><li class="listitem">Then add three<a id="id575" class="indexterm"/> textboxes and name them <code class="literal">tbTime1</code>, <code class="literal">tbTime2</code>, and <code class="literal">tbTime3</code>. Also, clear their <code class="literal">Text</code> properties.</li><li class="listitem">In the <code class="literal">MainWindow.xaml.cs</code> file, we will need to add a <code class="literal">using</code> statement so that the <code class="literal">Stopwatch</code> class is available to us. So, add the following statement at the top of the file with the rest of the <code class="literal">using</code> statements:<div><pre class="programlisting">using System.Diagnostics;</pre></div></li><li class="listitem">Then we need to add an empty method to serve as our delegate for the lambda expression. We will call it <code class="literal">DoWork</code>. Add it to the bottom of the <code class="literal">MainWindow</code> class with the following code:<div><pre class="programlisting">static void DoWork(int i)
        {
        }</pre></div></li><li class="listitem">That is all the code we need to add to our <code class="literal">MainWindow.xaml.cs</code> file. Our <code class="literal">MainWindow.xaml</code> file <a id="id576" class="indexterm"/>should now contain the following code:<div><pre class="programlisting">&lt;Window x:Class="WpfPLINQQuery.MainWindow"
        
        
        Title="MainWindow" Height="759.12" Width="725.431"&gt;

    &lt;Grid&gt;
        &lt;ListBox x:Name="lb1" HorizontalAlignment="Left" Height="557" Margin="38,78,0,0" VerticalAlignment="Top" Width="150"/&gt;
        &lt;ListBox x:Name="lb2" HorizontalAlignment="Left" Height="557" Margin="285,78,0,0" VerticalAlignment="Top" Width="150"/&gt;
        &lt;ListBox x:Name="lb3" HorizontalAlignment="Left" Height="557" Margin="526,78,0,0" VerticalAlignment="Top" Width="150"/&gt;
        &lt;Button x:Name="btnMethod1" Content="Execute Method 1" HorizontalAlignment="Left" Height="43" Margin="38,26,0,0" VerticalAlignment="Top" Width="150" Click="btnMethod1_Click"/&gt;
        &lt;Button x:Name="btnMethod2" Content="Execute Method 2" HorizontalAlignment="Left" Height="43" Margin="285,26,0,0" VerticalAlignment="Top" Width="150" Click="btnMethod2_Click"/&gt;
        &lt;Button x:Name="btnMethod3" Content="Execute Method 3" HorizontalAlignment="Left" Height="43" Margin="526,26,0,0" VerticalAlignment="Top" Width="150" Click="btnMethod3_Click"/&gt;
        &lt;TextBox x:Name="tbTime1" HorizontalAlignment="Left" Height="28" Margin="38,684,0,0" TextWrapping="Wrap" VerticalAlignment="Top" Width="150"/&gt;
        &lt;TextBox x:Name="tbTime2" HorizontalAlignment="Left" Height="28" Margin="285,684,0,0" TextWrapping="Wrap" VerticalAlignment="Top" Width="150"/&gt;
        &lt;TextBox x:Name="tbTime3" HorizontalAlignment="Left" Height="28" Margin="526,684,0,0" TextWrapping="Wrap" VerticalAlignment="Top" Width="150"/&gt;

    &lt;/Grid&gt;

&lt;/Window&gt;</pre></div></li></ol></div><p>Now our project is completed. Let's build and run the project. The program should look like this when it runs:</p><div><img src="img/8321EN_10_01.jpg" alt="How to do it"/></div><p>Now, let's click on the<a id="id577" class="indexterm"/> <strong>Execute Method 1</strong> button. We should see results like the following:</p><div><img src="img/8321EN_10_02.jpg" alt="How to do it"/></div><p>Now, let's click on the<a id="id578" class="indexterm"/> next two buttons, <strong>Execute Method 2</strong> and <strong>Execute Method 3</strong> and see what the program looks like:</p><div><img src="img/8321EN_10_03.jpg" alt="How to do it"/></div><p>As you can see, we <a id="id579" class="indexterm"/>executed the PLINQ parallel query using three different methods and the results are different each time. The first thing you'll notice if you scroll through the results is that the numbers in the listbox are not ordered. The next thing you will notice is that the runtime of each is not exactly the same. Granted, the first one will take longer to display because we divide by 5 instead of 10, so there are more results. But the query itself should take roughly the same time. You can play with this by moving the command to stop the <code class="literal">Stopwatch</code> object.</p><p>Now let's examine how this works.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec88"/>How it works</h2></div></div></div><p>In this project, we<a id="id580" class="indexterm"/> performed a PLINQ parallel query using three different methods. In the first one, we defined a <code class="literal">ParallelQuery</code> object using this line of code, but didn't execute it yet:</p><div><pre class="programlisting">ParallelQuery&lt;int&gt; PQ1 = from num in collection1.AsParallel()
                      where num % 5 == 0
                      select num;</pre></div><p>We add the <code class="literal">AsParallel</code> method to the <code class="literal">IEnumerable</code> collection with the following command:</p><div><pre class="programlisting">collection1.AsParallel();</pre></div><p>This tells .NET to try and execute this query concurrently if it determines that it will improve performance. We can force .NET to operate this query concurrently using the parallel extension method <code class="literal">WithExecutionMode(ParallelExecutionMode.ForceParallelism)</code>.</p><p>Then we actually ran the query using the <code class="literal">ForAll</code> method of the <code class="literal">ParallelQuery</code> class. We did this using the following command:</p><div><pre class="programlisting">PQ1.ForAll((i) =&gt; DoWork(i));</pre></div><p>To use this command, we need to pass it a lambda expression. We are just using a lambda expression that passes a delegate to a method that does nothing. We do not need to do work in the delegate method because we are doing all of the work in the parallel query.</p><p>In the second method, we create a parallel query that executes when the command is processed and returns an array. This command is as follows:</p><div><pre class="programlisting">int[] PQ2 = (from num in collection2.AsParallel()
                       where num % 10 == 0
                       select num).ToArray();</pre></div><div><div><h3 class="title"><a id="note29"/>Note</h3><p>Notice that here we have added the <code class="literal">ToArray()</code> method to the results of the query. By implementing the parallel query this way we ensure that the query is executing during this command. In the first method, we create the query but do not execute it until the <code class="literal">ForAll</code> command is executed.</p></div></div><p>In the final method, we use the LINQ method syntax. Here is the statement that performs the query using this syntax:</p><div><pre class="programlisting">ParallelQuery&lt;int&gt; PQ3 = collection3.AsParallel().Where(n =&gt; n % 10 == 0).Select(n =&gt; n);</pre></div><p>Here we return a <code class="literal">ParallelQuery</code> object instead of an array.</p><p>Also, notice that in all<a id="id581" class="indexterm"/> three methods the results are not returned in order. We will see later in the chapter how to ensure the order of the results if that is necessary. For now, we are just trying to run a parallel query. We will let .NET determine how to run the query (concurrently or sequentially), and in whatever order.</p></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec72"/>Ordering in PLINQ</h1></div></div></div><p>Now, what if the order of our <a id="id582" class="indexterm"/>results matters? In a lot of cases, we will want the results to come<a id="id583" class="indexterm"/> back in a certain order. Let's examine how we can accomplish this.</p><p>There are several methods contained in the parallel extension methods of the <code class="literal">IEnumerable</code> interface. The two we use the most are <code class="literal">AsOrdered()</code> and <code class="literal">AsOrderedBy()</code>. These two methods guarantee order preservation in the results of the parallel query. This does add some cost and overhead.</p><p>Let's take our project from the last section and update it to return the ordered results.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec89"/>How to do it</h2></div></div></div><p>Let's open up our <code class="literal">PLINQQuery</code> project and make the following changes:</p><div><ol class="orderedlist arabic"><li class="listitem">Change the parallel query statement in the <code class="literal">btnMethod1_Click</code> method to look like the following by adding the <code class="literal">AsOrdered</code> method to the query:<div><pre class="programlisting">ParallelQuery&lt;int&gt; PQ1 = from num in collection1.AsParallel().AsOrdered()
                      where num % 5 == 0
                   select num;</pre></div></li><li class="listitem">Now, make a similar change to the statement in the <code class="literal">btnMethod2_Click</code> method. Make its parallel query statement look like the following:<div><pre class="programlisting">int[] PQ2 = (from num in collection2.AsParallel().AsOrdered()
                       where num % 10 == 0
                   select num).ToArray();</pre></div></li><li class="listitem">Finally, let's make a similar change to the <code class="literal">btn3Method_Click</code> method and its query statement:<div><pre class="programlisting">ParallelQuery&lt;int&gt; PQ3 = collection3.AsParallel().AsOrdered().Where(n =&gt;           n % 10 == 0).Select(n =&gt; n);</pre></div></li></ol></div><p>That is all of the changes; seems simple enough. Now, let's build and run our application. You should get a program that looks<a id="id584" class="indexterm"/> like the following <a id="id585" class="indexterm"/>screenshot:</p><div><img src="img/8321EN_10_04.jpg" alt="How to do it"/></div><p>Now, let's click on each of the three buttons to run all the three queries. Your program should now look like the following screenshot:</p><div><img src="img/8321EN_10_05.jpg" alt="How to do it"/></div><p>As you can see, the results are <a id="id586" class="indexterm"/>now ordered. This is a simple example; however, in a more <a id="id587" class="indexterm"/>complex example, you will also see that the runtimes are longer. As you would expect, ordering the results will slow down the query processing.</p><p>Also, did you notice that if you execute the queries in the application in a different order you will see that typically the first one takes longer than the last one? There are two explanations for why the last one to run is usually faster. .NET has run the query, so it has also taken time to determine the best execution method. Also, if it chooses to run the query concurrently, it has already taken the overhead of creating the tasks in the threadpool.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec90"/>How it works</h2></div></div></div><p>The change from the first project to <a id="id588" class="indexterm"/>this one is a simple one. We just added the <code class="literal">AsOrdered()</code> method to the <a id="id589" class="indexterm"/>parallel extension method, <code class="literal">AsParallel()</code>, that we execute against the <code class="literal">IEnumerable</code> collection.</p><p>This forces .NET to order the results. We can also order the results with the <code class="literal">OrderBy</code> query syntax. It should be noted that <code class="literal">OrderBy</code> is done sequentially, not in parallel. The following screenshot explains items in the query itself that will order the results:</p><div><img src="img/8321EN_10_06.jpg" alt="How it works"/><div><p>Referenced from http://msdn.microsoft.com/en-us/library/dd460677(v=vs.110).aspx</p></div></div></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec73"/>Merging in PLINQ</h1></div></div></div><p>We have learned how to<a id="id590" class="indexterm"/> perform a parallel query and how to order the results. Now, let's examine<a id="id591" class="indexterm"/> merging with our parallel queries.</p><p>When a parallel query is performed, the .NET CLR partitions the source collection so that several tasks can work sections of the collection concurrently. Once this is completed, the results need to be merged into a result collection for processing. Depending on the query operators used, the results can be merged in different ways. Query operators that dictate a new order on the result collection will buffer all items from the separate threads before merging them together again. Other query operators are partially buffered, while the query operator, <code class="literal">ForAll&lt;TSource&gt;</code>, is not buffered. It produces all items from all tasks as soon as they are processed.</p><p>The <code class="literal">WithMergeOptions&lt;TSource&gt;</code> method can tell PLINQ how to perform the merging process of a concurrent query.</p><p>If a query cannot perform the <a id="id592" class="indexterm"/>merge option specified, .NET will ignore it. So, you can see <a id="id593" class="indexterm"/>that .NET treats merge options as suggestions and will not throw an error if the merge option is not compatible; it will just ignore it. Likewise, if you do not specify a merge option, .NET will select one for you. So, you can use a merge option if you have determined that a specific merge is best for your performance or just let .NET decide for you. This is one of the beautiful things of the TPL. It handles a lot of the thinking for you when it comes to common concurrent issues.</p><p>The different options with which the parallel merge can be set up are listed in the following screenshot:</p><div><img src="img/8321EN_10_07.jpg" alt="Merging in PLINQ"/><div><p>Referenced from http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx</p></div></div><p>The following are the parallel query operators that support merging:</p><div><img src="img/8321EN_10_08.jpg" alt="Merging in PLINQ"/><div><p>Referenced from http://msdn.microsoft.com/en-us/library/dd997424(v=vs.110).aspx</p></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec91"/>How to do it</h2></div></div></div><p>Now, let's go back to our <a id="id594" class="indexterm"/>project and try changing our program to <a id="id595" class="indexterm"/>use the <code class="literal">NotBuffered</code>, <code class="literal">AutoBuffered</code>, and <code class="literal">FullyBuffered</code> merging options.</p><p>To do this, let's open our <code class="literal">PLINQQuery</code> project and change the parallel query statement in the <code class="literal">btnMethod1_Click</code> method to look like the following:</p><div><pre class="programlisting">ParallelQuery&lt;int&gt; PQ1 = from num in collection1.AsParallel().AsOrdered().WithMergeOptions(ParallelMergeOptions.NotBuffered)
                where num % 5 == 0
                select num;</pre></div><p>Now, let's build and run the program and click on the <strong>Execute Method 1</strong> button. You should see the following results:</p><div><img src="img/8321EN_10_09.jpg" alt="How to do it"/></div><p>Now, let's try to use <a id="id596" class="indexterm"/>the <code class="literal">AutoBuffered</code> method. To do this, in the <code class="literal">btnMethod1_Click</code> method, change <a id="id597" class="indexterm"/>the parallel query statement to the following:</p><div><pre class="programlisting">ParallelQuery&lt;int&gt; PQ1 = from num in collection1.AsParallel().AsOrdered().WithMergeOptions(ParallelMergeOptions.AutoBuffered)
                      where num % 5 == 0
                      select num;</pre></div><p>Now, build and run the program again. Click on the <strong>Execute Method 1</strong> button and you should get the following results:</p><div><img src="img/8321EN_10_10.jpg" alt="How to do it"/></div><p>Now, let's make one final <a id="id598" class="indexterm"/>change to the parallel query in this method to use the <code class="literal">AutoBuffered</code> option. Change <a id="id599" class="indexterm"/>the <code class="literal">btnMethod1_click</code> method to have the following parallel query statement:</p><div><pre class="programlisting">ParallelQuery&lt;int&gt; PQ1 = from num in collection1.AsParallel().AsOrdered().WithMergeOptions(ParallelMergeOptions.FullyBuffered)
                      where num % 5 == 0
                      select num;</pre></div><p>Now, let's build and run this application<a id="id600" class="indexterm"/> one final time and click on the <strong>Execute Method 1</strong> button. The<a id="id601" class="indexterm"/> results should look like the following screenshot:</p><div><img src="img/8321EN_10_11.jpg" alt="How to do it"/></div></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec92"/>How it works</h2></div></div></div><p>As you can see, to dictate <a id="id602" class="indexterm"/>to .NET on how to merge the results of a buffered query is as <a id="id603" class="indexterm"/>easy as calling the <code class="literal">WithMergeOptions()</code> parallel extension method; just like ordering the results is as easy as calling the <code class="literal">AsOrdered()</code> parallel extension method.</p><p>But you will also notice that the best results come from using the <code class="literal">AutoBuffered</code> or no-merge option. Even though PLINQ gives you these options to dictate how the parallel query is merged, if we let .NET determine how to do it, the results are often far better.</p><p>For complex examples, it might be beneficial to tell .NET how to merge the results, but often it is best to let the CLR determine this itself. This is one of the benefits of using PLINQ and the TPL—a lot of the complex work and thinking are handled for you. You can concentrate your coding time on the functionality and not the performance.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec74"/>Canceling a PLINQ</h1></div></div></div><p>Canceling a parallel query is<a id="id604" class="indexterm"/> very similar to canceling a task using TPL. First, we create a cancellation token and then we issue a cancel request to the cancellation token. This will create an operation cancellation exception. Then when we execute our parallel query, add the parallel extension method <code class="literal">WithCancellation()</code>, and pass it the cancellation token. Then, finally, we catch the operation cancellation request and process it.</p><p>The .NET framework does not pass a single <code class="literal">OperationCanceledException</code> into a <code class="literal">System.AggregateException</code>; the <code class="literal">OperationCanceledException</code> must be processed in a separate <code class="literal">catch</code> block.</p><div><div><div><div><h2 class="title"><a id="ch10lvl2sec93"/>How to do it</h2></div></div></div><p>Now, let's open our <code class="literal">PLINQQuery</code> project again and this time we will add a Cancel button and work with the <code class="literal">btnMethod2_Click</code> event handler method:</p><div><ol class="orderedlist arabic"><li class="listitem">First, add a new button control to our <code class="literal">MainWindow.xaml.cs</code> file and set its <code class="literal">Content</code> property to <code class="literal">Cancel</code> and name the control <code class="literal">btnCancel</code>.</li><li class="listitem">Next, we need to add a <code class="literal">using</code> statement for the <code class="literal">Threading</code> namespace so we can create a cancellation token object. Add the following <code class="literal">using</code> statement:<div><pre class="programlisting">      using System.Threading;</pre></div></li><li class="listitem">Next, let's create a cancellation token at the top of our <code class="literal">MainWindow</code> class with the following statement:<div><pre class="programlisting">            CancellationTokenSource cs = new CancellationTokenSource();</pre></div></li><li class="listitem">Now, let's add a <code class="literal">btnCancel_Click</code> click event handler method for our <strong>Cancel</strong> button. It should have the following code:<div><pre class="programlisting">         private void btnCancel_Click(object sender, RoutedEventArgs e)
              {
                     cs.Cancel();
           }</pre></div></li><li class="listitem">Also, let's change <a id="id605" class="indexterm"/>our <code class="literal">IEnumerable</code> collection to have 500,000 items, so it will run longer and give us a chance to cancel the operation:<div><pre class="programlisting">            IEnumerable&lt;int&gt; collection1 = Enumerable.Range(10, 500000);</pre></div></li><li class="listitem">Finally, let's change the <code class="literal">btnMethod2_Click</code> event handler to have the following code for the parallel query:<div><pre class="programlisting">            try
                  {
                      // Method 2 - Use a standard TOArray method to //return the results.
PQ2 = (from num in collection2.AsParallel().AsOrdered().WithCancellation(cs.Token)
                             where num % 10 == 0
                             select num).ToArray();
                  }
                  catch (OperationCanceledException ex)
                  {
                      lb2.Items.Clear();
                      lb2.Items.Add(ex.Message);
                      return;
               }</pre></div></li></ol></div><p>Now, let's build and run our program. Click on the <strong>Execute Method 2</strong> button and immediately click on the <strong>Cancel</strong> button. You should see the following output in your application:</p><div><img src="img/8321EN_10_12.jpg" alt="How to do it"/></div><p>You can see that we have <a id="id606" class="indexterm"/>canceled the parallel query before its completion. Now, let's now take a look at how it was performed.</p></div><div><div><div><div><h2 class="title"><a id="ch10lvl2sec94"/>How it works</h2></div></div></div><p>We performed this very simply. First, we created a cancellation token to use with this command:</p><div><pre class="programlisting">   CancellationTokenSource cs = new CancellationTokenSource();</pre></div><p>Next, we created a <strong>Cancel</strong> button. and when it is pressed, we execute the <code class="literal">Cancel()</code> method of the cancellation token object. This is done here:</p><div><pre class="programlisting">    private void btnCancel_Click(object sender, RoutedEventArgs e)
        {
            cs.Cancel();
        }</pre></div><p>Finally, in our parallel <a id="id607" class="indexterm"/>query, we add the <code class="literal">WithCancellation()</code> method and pass it the cancellation token. Then we add a <code class="literal">catch</code> block and catch any <code class="literal">OperationCanceledException</code> exceptions:</p><div><pre class="programlisting">        try
            {
                // Method 2 - Use a standard TOArray method to return the //results.
                PQ2 = (from num in collection2.AsParallel().AsOrdered().WithCancellation(cs.Token)
                             where num % 10 == 0
                             select num).ToArray();
            }
            catch (OperationCanceledException ex)
            {
                lb2.Items.Clear();
                lb2.Items.Add(ex.Message);
                return;
            }</pre></div><p>That is all there is to it.</p></div></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec75"/>Understanding performance improvements in PLINQ</h1></div></div></div><p>We have seen how we can <a id="id608" class="indexterm"/>implement PLINQ queries and specify <a id="id609" class="indexterm"/>ordering, merging, and parallel execution options. We have also seen how to execute a PLINQ with the <code class="literal">ForAll()</code> method and as a <code class="literal">foreach</code> loop. All of these factor into the performance of the query. It is also important to examine how .NET decides to partition a source data collection when it decides to execute a PLINQ in parallel. Remember, a PLINQ executed in parallel is just a LINQ where a data collection is partitioned into groups and a task is created to process the <code class="literal">Where</code> action of the query on each partition of data. The following diagrams depict the differences between LINQ processing and PLINQ processing.</p><p>The following <a id="id610" class="indexterm"/>diagram shows the <a id="id611" class="indexterm"/>process of the LINQ:</p><div><img src="img/8321EN_10_13.jpg" alt="Understanding performance improvements in PLINQ"/></div><p>The following diagram shows the process of PLINQ. Notice how the data is partitioned and the <code class="literal">Where</code> clause is executed concurrently on each partition:</p><div><img src="img/8321EN_10_14.jpg" alt="Understanding performance improvements in PLINQ"/></div><p>Also, when we perform a <a id="id612" class="indexterm"/>query using a <code class="literal">ForAll</code> versus a <code class="literal">foreach</code> loop, the<a id="id613" class="indexterm"/> processing is different. We can determine which of these are the best methods, usually by finding out whether or not the order of the results matter. If the order of the results is important, then <code class="literal">foreach</code> is the better processing method because the results are merged after the loop processes. Using the <code class="literal">ForAll</code> loop, the whole query is processed on each data partition individually so that there is no merging of the results in the correct order. You can place the <code class="literal">AsOrdered</code> method on the <code class="literal">IEnumerable</code> collection for the query, but it then basically buffers all results to merge them so you lose the performance gains the <code class="literal">ForAll</code> loop gives you. The following diagrams depict the differences in the way each of these is processed.</p><p>First, we'll have a look at the <code class="literal">ForAll</code> processing:</p><div><img src="img/8321EN_10_15.jpg" alt="Understanding performance improvements in PLINQ"/></div><p>Second, let's look at <a id="id614" class="indexterm"/>the process of the <code class="literal">foreach</code> processing. Notice in the following diagram that<a id="id615" class="indexterm"/> the merge happens before the <code class="literal">foreach</code> loop processing, so the <code class="literal">foreach</code> processing is done sequentially:</p><div><img src="img/8321EN_10_16.jpg" alt="Understanding performance improvements in PLINQ"/></div><p>Now, let's take a look at<a id="id616" class="indexterm"/> the algorithms PLINQ (or more aptly the .NET CLR) uses<a id="id617" class="indexterm"/> to partition a data collection into groups for parallel processing. .NET uses four different algorithms to partition data based on the collection and the query. The following screenshot details the first two algorithms:</p><div><img src="img/8321EN_10_17.jpg" alt="Understanding performance improvements in PLINQ"/><div><p>Referenced from http://blogs.msdn.com/b/pfxteam/archive/2009/05/28/9648672.aspx</p></div></div><p>The details of the other two <a id="id618" class="indexterm"/>algorithms<a id="id619" class="indexterm"/> are as follows:</p><div><img src="img/8321EN_10_18.jpg" alt="Understanding performance improvements in PLINQ"/><div><p>Referenced from http://blogs.msdn.com/b/pfxteam/archive/2009/05/28/9648672.aspx</p></div></div><p>As you can see from the <a id="id620" class="indexterm"/>previous screenshot, PLINQ partitions the<a id="id621" class="indexterm"/> source data collection based on the type of data and the type of query. This is all part of the logic that .NET performs so we do not have to. Just like determining if a query should be run concurrently or sequentially, it also determines if concurrent is the best way to partition the data.</p><p>As we also saw, based on whether or not you need the results ordered either a <code class="literal">ForAll</code> or a <code class="literal">foreach</code> statement can yield better performance.</p></div>
<div><div><div><div><h1 class="title"><a id="ch10lvl1sec76"/>Summary</h1></div></div></div><p>In this chapter, you learned how to change an ordinary LINQ to Objects query into a concurrent PLINQ. You also learned how to order results, merge results, and cancel queries. PLINQ makes it very easy to concurrently process queries on any memory data collection that supports <code class="literal">IEnumerable</code>.</p><p>It is also important to remember that PLINQ only supports LINQ to Objects and not the other forms of LINQ such as LINQ to SQL or LINQ to XML.</p><p>PLINQ is as easy to implement as adding a parallel extension method to a source data collection in a LINQ query—it is really that simple. Then .NET can determine if the query will have better performance running concurrently by partitioning the data collection into pieces, and if so, how to partition it. You as the programmer do not have to worry about any of this through your source code. PLINQ is really a no-brainer when performing a LINQ query because if .NET cannot improve performance making the query concurrent, it will just run the query sequentially.</p><p>In the next chapter, we will examine the new <code class="literal">async</code> and <code class="literal">await</code> keywords and how to easily implement asynchronous methods.</p></div></body></html>